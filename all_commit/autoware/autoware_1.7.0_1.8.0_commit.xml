<?xml version="1.0" encoding="utf-8"?>
<Root>
	<commit hash="9e685a7f5bc8990f6b91ed90535baa95d6f07f28" author="Masahiro Kitazawa">
		<msg>WIP: fix indent</msg>
		<modified_files>
			<file old_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" new_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" added_lines="29" deleted_lines="29">
				<diff>@@ -122,13 +122,13 @@ static std::vector&lt;std::string&gt; split(const string&amp; input, char delimiter) {
 static void dbg_out_pictogram(jsk_rviz_plugins::Pictogram pictogram) {
 #ifdef POS_DB_VERBOSE
   std::cout
-	&lt;&lt; pictogram.pose.position.x &lt;&lt; ","
-	&lt;&lt; pictogram.pose.position.y &lt;&lt; ","
-	&lt;&lt; pictogram.pose.position.z &lt;&lt; " : "
-	&lt;&lt; pictogram.pose.orientation.x &lt;&lt; ","
-	&lt;&lt; pictogram.pose.orientation.y &lt;&lt; ","
-	&lt;&lt; pictogram.pose.orientation.z &lt;&lt; ","
-	&lt;&lt; pictogram.pose.orientation.w &lt;&lt; std::endl;
+  &lt;&lt; pictogram.pose.position.x &lt;&lt; ","
+  &lt;&lt; pictogram.pose.position.y &lt;&lt; ","
+  &lt;&lt; pictogram.pose.position.z &lt;&lt; " : "
+  &lt;&lt; pictogram.pose.orientation.x &lt;&lt; ","
+  &lt;&lt; pictogram.pose.orientation.y &lt;&lt; ","
+  &lt;&lt; pictogram.pose.orientation.z &lt;&lt; ","
+  &lt;&lt; pictogram.pose.orientation.w &lt;&lt; std::endl;
 #endif /* POS_DB_VERBOSE */
 }
 
@@ -139,7 +139,7 @@ static void update_pictograms(int id, jsk_rviz_plugins::Pictogram pictogram) {
 }
 
 static void publish_car(int id, int is_current, ros::Time now,
-		       geometry_msgs::Pose&amp; pose, int diffmsec) {
+  geometry_msgs::Pose&amp; pose, int diffmsec) {
   jsk_rviz_plugins::Pictogram pictogram;
   pictogram.header.frame_id = "/map";
   pictogram.header.stamp = now;
@@ -253,7 +253,7 @@ static void publish_car_summary(ros::Time now) {
 #endif /* ! CURRENT_CAR_DIRECTLY */
 
 static void publish_pedestrian(int id, int is_pedestrian, ros::Time now,
-			      geometry_msgs::Pose&amp; pose, int diffmsec) {
+  geometry_msgs::Pose&amp; pose, int diffmsec) {
   jsk_rviz_plugins::Pictogram pictogram;
   pictogram.header.frame_id = "/map";
   pictogram.header.stamp = now;
@@ -297,8 +297,8 @@ static void publish_pedestrian(int id, int is_pedestrian, ros::Time now,
 }
 
 static int result_to_pictogram(const string&amp; idstr, ros::Time now,
-			    geometry_msgs::Pose&amp; pose, int type,
-			    int diffmsec, int is_swap) {
+  geometry_msgs::Pose&amp; pose, int type,
+  int diffmsec, int is_swap) {
   int nid;
 
   switch (type) {
@@ -320,17 +320,17 @@ static int result_to_pictogram(const string&amp; idstr, ros::Time now,
     if (idstr.find("current_pose", 0) != string::npos) {
       /* current_pose:DEF012345678 */
       if (idstr.length() &gt;= 25) {
-	/* use lower 6 bytes */
-	nid = ANON_MARKER_ID_MAX |
-	  (std::strtol((idstr.substr(19, 6)).c_str(), NULL, 16)) &lt;&lt; 1;
+        /* use lower 6 bytes */
+        nid = ANON_MARKER_ID_MAX |
+        (std::strtol((idstr.substr(19, 6)).c_str(), NULL, 16)) &lt;&lt; 1;
         publish_car(nid, 1, now, pose, diffmsec);
       }
     } else if (idstr.find("ndt_pose", 0) != string::npos) {
       /* ndt_pose:9ABCDEF01234 */
       if (idstr.length() &gt;= 21) {
-	/* use lower 6 bytes */
-	nid = ANON_MARKER_ID_MAX |
-	  (std::strtol((idstr.substr(15, 6)).c_str(), NULL, 16)) &lt;&lt; 1;
+        /* use lower 6 bytes */
+        nid = ANON_MARKER_ID_MAX |
+        (std::strtol((idstr.substr(15, 6)).c_str(), NULL, 16)) &lt;&lt; 1;
         publish_car(nid, 1, now, pose, diffmsec);
       }
     } else if (idstr.find("car_pose", 0) != string::npos) {
@@ -350,7 +350,7 @@ static int get_timeval(const char *tstr, time_t *sp, int *np) {
   const char *p;
 
   if (sscanf(tstr, "%d-%d-%d %d:%d:%d", &amp;tm.tm_year, &amp;tm.tm_mon,
-	&amp;tm.tm_mday, &amp;tm.tm_hour, &amp;tm.tm_min, &amp;tm.tm_sec) != 6) {
+  &amp;tm.tm_mday, &amp;tm.tm_hour, &amp;tm.tm_min, &amp;tm.tm_sec) != 6) {
     std::cerr &lt;&lt; "Cannot convert time \"" &lt;&lt; tstr &lt;&lt; "\"" &lt;&lt; std::endl;
     return -1;
   }
@@ -398,11 +398,11 @@ static void pictogram_publisher(const std_msgs::String&amp; msg, int is_swap) {
   for (const std::vector&lt;string&gt;&amp; cols : db_data) {
     type = std::stoi(cols[11]);
     if(ignore_my_pose &amp;&amp;
-       (type == TYPE_OWN ||
-	cols[0].find("current_pose", 0) != string::npos ||
-	cols[0].find("ndt_pose", 0) != string::npos) &amp;&amp;
-       cols[0].find(mac_addr, 0) != string::npos) {
-      continue;	// don't publish Marker of my pose
+      (type == TYPE_OWN ||
+        cols[0].find("current_pose", 0) != string::npos ||
+        cols[0].find("ndt_pose", 0) != string::npos) &amp;&amp;
+        cols[0].find(mac_addr, 0) != string::npos) {
+          continue;	// don't publish Marker of my pose
     }
 
     if (is_swap) {
@@ -420,9 +420,9 @@ static void pictogram_publisher(const std_msgs::String&amp; msg, int is_swap) {
     pose.orientation.z = std::stod(cols[6]);
     pose.orientation.w = std::stod(cols[7]);
     // VoltDB returns not NULL but -1.7976931348623157E308
-    if (pose.position.x &lt; -1.79E308 ||
-	pose.position.y &lt; -1.79E308 ||
-	pose.position.z &lt; -1.79E308) {
+    if (pose.position.x &lt; -1.79E308||
+      pose.position.y &lt; -1.79E308 ||
+      pose.position.z &lt; -1.79E308) {
       geo_pos_conv geo;
       double lon = std::stod(cols[8]);
       double lat = std::stod(cols[9]);
@@ -459,8 +459,8 @@ static int create_timestr(time_t sec, int nsec, char *str, size_t size) {
 
   nowtm = std::gmtime(&amp;sec);
   return std::snprintf(str, size, "%04d-%02d-%02d %02d:%02d:%02d.%03d",
-	nowtm-&gt;tm_year + 1900, nowtm-&gt;tm_mon + 1, nowtm-&gt;tm_mday,
-	nowtm-&gt;tm_hour, nowtm-&gt;tm_min, nowtm-&gt;tm_sec, nsec/1000/1000);
+  nowtm-&gt;tm_year + 1900, nowtm-&gt;tm_mon + 1, nowtm-&gt;tm_mday,
+  nowtm-&gt;tm_hour, nowtm-&gt;tm_min, nowtm-&gt;tm_sec, nsec/1000/1000);
 }
 
 //wrap SendData class
@@ -480,7 +480,7 @@ static void send_sql(time_t diff_sec) {
   data = make_header(1, 1);
   // select pos data between previous latest timestamp and now
   data += "SELECT id,x,y,z,or_x,or_y,or_z,or_w,lon,lat,tm,type FROM POS "
-	"WHERE tm &gt; '";
+  "WHERE tm &gt; '";
   data += prevstr;
   data += "' AND tm &lt; '";
   data += timestr;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c31ce8848af2549d94b74d049e1b7e4a158298a4" author="Masahiro Kitazawa">
		<msg>WIP</msg>
		<modified_files>
			<file old_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" new_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" added_lines="20" deleted_lines="9">
				<diff>@@ -86,7 +86,8 @@ static double pedestrian_dz;
 
 static ros::Publisher pub;
 
-static jsk_rviz_plugins::Pictogram[] *pictogramsp;
+static std::vector&lt;jsk_rviz_plugins::Pictogram&gt; pictogramsp;
+static std::vector&lt;int&gt; car_ids;
 
 static SendData sd;
 
@@ -134,8 +135,14 @@ static void dbg_out_pictogram(jsk_rviz_plugins::Pictogram pictogram) {
 
 
 static void update_pictograms(int id, jsk_rviz_plugins::Pictogram pictogram) {
-
-  pub.publish(*pictogramsp);
+  vector&lt;int&gt;::iterator itr = find(car_ids.begin(), car_ids.end(), id);
+  if (itr == car_ids.end()) {
+    car_ids.push_back(id);
+    pictogramsp.push_back(pictogram);
+  } else {
+    pictogramsp[itr - car_ids.begin()] = pictogram;
+  }
+  pub.publish(pictogramsp.data());
 }
 
 static void publish_car(int id, int is_current, ros::Time now,
@@ -301,18 +308,22 @@ static int result_to_pictogram(const string&amp; idstr, ros::Time now,
   int diffmsec, int is_swap) {
   int nid;
 
+  /* use lower 6 bytes */
+  nid = ANON_MARKER_ID_MAX |
+  (std::strtol(idstr.substr(idstr.end() -= 6, 6).c_str(), NULL, 16)) &lt;&lt; 1;
+
   switch (type) {
   case TYPE_OWN:
     /* use lower 6 bytes */
     nid = ANON_MARKER_ID_MAX |
-      (std::strtol(idstr.substr(6, 6).c_str(), NULL, 16)) &lt;&lt; 1;
+    (std::strtol(idstr.substr(6, 6).c_str(), NULL, 16)) &lt;&lt; 1;
     publish_car(nid, 1, now, pose, diffmsec);
     break;
   case TYPE_CAR:
-    publish_car(0, 0, now, pose, diffmsec);
+    publish_car(nid, 0, now, pose, diffmsec);
     break;
   case TYPE_PEDESTRIAN:
-    publish_pedestrian(0, 1, now, pose, diffmsec);
+    publish_pedestrian(nid, 1, now, pose, diffmsec);
     break;
 
   /* backward compatibility */
@@ -334,11 +345,11 @@ static int result_to_pictogram(const string&amp; idstr, ros::Time now,
         publish_car(nid, 1, now, pose, diffmsec);
       }
     } else if (idstr.find("car_pose", 0) != string::npos) {
-      publish_car(0, 0, now, pose, diffmsec);
+      publish_car(nid, 0, now, pose, diffmsec);
     } else if (idstr.find("pedestrian_pose", 0) != string::npos) {
-      publish_pedestrian(0, 1, now, pose, diffmsec);
+      publish_pedestrian(nid, 1, now, pose, diffmsec);
     } else {
-      publish_pedestrian(0, 0, now, pose, diffmsec); // PosUp
+      publish_pedestrian(nid, 0, now, pose, diffmsec); // PosUp
     }
   }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4b4dc8a9159be5ead6df98c9e8a66a3d28be45cb" author="Masahiro Kitazawa">
		<msg>WIP</msg>
		<modified_files>
			<file old_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" new_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" added_lines="8" deleted_lines="7">
				<diff>@@ -86,7 +86,7 @@ static double pedestrian_dz;
 
 static ros::Publisher pub;
 
-static std::vector&lt;jsk_rviz_plugins::Pictogram&gt; pictogramsp;
+static std::vector&lt;jsk_rviz_plugins::Pictogram&gt; pictograms;
 static std::vector&lt;int&gt; car_ids;
 
 static SendData sd;
@@ -138,11 +138,11 @@ static void update_pictograms(int id, jsk_rviz_plugins::Pictogram pictogram) {
   vector&lt;int&gt;::iterator itr = find(car_ids.begin(), car_ids.end(), id);
   if (itr == car_ids.end()) {
     car_ids.push_back(id);
-    pictogramsp.push_back(pictogram);
+    pictograms.push_back(pictogram);
   } else {
-    pictogramsp[itr - car_ids.begin()] = pictogram;
+    pictograms[itr - car_ids.begin()] = pictogram;
   }
-  pub.publish(pictogramsp.data());
+  pub.publish(pictograms.data());
 }
 
 static void publish_car(int id, int is_current, ros::Time now,
@@ -309,8 +309,9 @@ static int result_to_pictogram(const string&amp; idstr, ros::Time now,
   int nid;
 
   /* use lower 6 bytes */
+  int itr = idstr.length() - 6;
   nid = ANON_MARKER_ID_MAX |
-  (std::strtol(idstr.substr(idstr.end() -= 6, 6).c_str(), NULL, 16)) &lt;&lt; 1;
+  (std::strtol(idstr.substr(itr, 6).c_str(), NULL, 16)) &lt;&lt; 1;
 
   switch (type) {
   case TYPE_OWN:
@@ -379,7 +380,7 @@ static int get_timeval(const char *tstr, time_t *sp, int *np) {
 
 static void pictogram_publisher(const std_msgs::String&amp; msg, int is_swap) {
   std::vector&lt;std::string&gt; raw_db_data = split(msg.data, '\n');
-  std::vector&lt;std::vector&gt; db_data;
+  std::vector&lt;std::vector&lt;std::string&gt;&gt; db_data;
   std::vector&lt;std::string&gt; cols;
   ros::Time now = ros::Time::now();
   geometry_msgs::Pose pose;
@@ -404,7 +405,7 @@ static void pictogram_publisher(const std_msgs::String&amp; msg, int is_swap) {
     [](const std::vector&lt;string&gt;&amp; cols_x, const std::vector&lt;string&gt;&amp; cols_y){
       return stod(cols_x[10]) &lt; stod(cols_y[10]);
     }
-  )
+  );
 
   for (const std::vector&lt;string&gt;&amp; cols : db_data) {
     type = std::stoi(cols[11]);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="22ad211085e1dbeb49654f5530617671a5eb4f19" author="Masahiro Kitazawa">
		<msg>wait for review</msg>
		<modified_files>
			<file old_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" new_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" added_lines="16" deleted_lines="11">
				<diff>@@ -37,6 +37,7 @@ publish data as ractangular plane
 #include "ros/ros.h"
 #include "std_msgs/String.h"
 #include &lt;jsk_rviz_plugins/Pictogram.h&gt;
+#include &lt;jsk_rviz_plugins/PictogramArray.h&gt;
 #include &lt;cstdio&gt;
 #include &lt;cstdlib&gt;
 #include &lt;vector&gt;
@@ -86,7 +87,7 @@ static double pedestrian_dz;
 
 static ros::Publisher pub;
 
-static std::vector&lt;jsk_rviz_plugins::Pictogram&gt; pictograms;
+static jsk_rviz_plugins::PictogramArray pictograms_array;
 static std::vector&lt;int&gt; car_ids;
 
 static SendData sd;
@@ -134,15 +135,19 @@ static void dbg_out_pictogram(jsk_rviz_plugins::Pictogram pictogram) {
 }
 
 
-static void update_pictograms(int id, jsk_rviz_plugins::Pictogram pictogram) {
+static void update_pictograms(int id, ros::Time now, jsk_rviz_plugins::Pictogram pictogram) {
   vector&lt;int&gt;::iterator itr = find(car_ids.begin(), car_ids.end(), id);
+
+  pictograms_array.header.frame_id = "/map";
+  pictograms_array.header.stamp = now;
+
   if (itr == car_ids.end()) {
     car_ids.push_back(id);
-    pictograms.push_back(pictogram);
+    pictograms_array.pictograms.push_back(pictogram);
   } else {
-    pictograms[itr - car_ids.begin()] = pictogram;
+    pictograms_array.pictograms[itr - car_ids.begin()] = pictogram;
   }
-  pub.publish(pictograms.data());
+  pub.publish(pictograms_array);
 }
 
 static void publish_car(int id, int is_current, ros::Time now,
@@ -181,7 +186,7 @@ static void publish_car(int id, int is_current, ros::Time now,
     pictogram.pose.orientation.z = q3.z();
     pictogram.pose.orientation.w = q3.w();
 
-    update_pictograms(id, pictogram);
+    update_pictograms(id, now, pictogram);
     dbg_out_pictogram(pictogram);
 #else /* CURRENT_CAR_DIRECTLY */
     ros::Time newnow = now - ros::Duration(diffmsec/1000.0);
@@ -202,7 +207,7 @@ static void publish_car(int id, int is_current, ros::Time now,
     pictogram.color.b = 0.0;
     pictogram.color.a = alpha_percent(diffmsec);
     pictogram.pose.position.z += 0.5; // == #1/2
-    update_pictograms(id, pictogram);
+    update_pictograms(id, now, pictogram);
     dbg_out_pictogram(pictogram);
   }
 }
@@ -250,7 +255,7 @@ static void publish_car_summary(ros::Time now) {
     pictogram.pose.orientation.z = q3.z();
     pictogram.pose.orientation.w = q3.w();
 
-    update_pictograms(id, pictogram);
+    update_pictograms(id, now, pictogram);
     dbg_out_pictogram(pictogram);
     prev_map[id] = cur;
   }
@@ -288,7 +293,7 @@ static void publish_pedestrian(int id, int is_pedestrian, ros::Time now,
   // marker.scale.y = 0.6;
   // marker.scale.z = 1.2; // #1
   pictogram.pose.position.z += 0.6; // == #1/2
-  update_pictograms(id, pictogram);
+  update_pictograms(id, now, pictogram);
   dbg_out_pictogram(pictogram);
 
   //marker.type = visualization_msgs::Marker::SPHERE;
@@ -299,7 +304,7 @@ static void publish_pedestrian(int id, int is_pedestrian, ros::Time now,
   // marker.scale.x = 0.6; // #2
   // marker.scale.y = 0.6;
   // marker.scale.z = 0.6;
-  update_pictograms(id, pictogram);
+  update_pictograms(id, now, pictogram);
   dbg_out_pictogram(pictogram);
 }
 
@@ -550,7 +555,7 @@ int main(int argc, char **argv) {
 
   string home_dir = getenv("HOME");
 
-  pub = nh.advertise&lt;jsk_rviz_plugins::Pictogram[]&gt;(PICTOGRAMNAME, 1);
+  pub = nh.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;(PICTOGRAMNAME, 1);
   nh.param&lt;double&gt;(MYNAME "/time", args[0], STARTTIME);
   cout &lt;&lt; "time=" &lt;&lt; args[0] &lt;&lt; endl;
   nh.param&lt;double&gt;(MYNAME "/delay", args[1], DELAYSEC);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8b784f30fc53c09a734efeaca1dea263153c2fcd" author="Masahiro Kitazawa">
		<msg>wait for review</msg>
		<modified_files>
			<file old_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" new_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" added_lines="5" deleted_lines="10">
				<diff>@@ -308,11 +308,6 @@ static int result_to_pictogram(const string&amp; idstr, ros::Time now,
   int diffmsec, int is_swap) {
   int nid;
 
-  /* use lower 6 bytes */
-  int itr = idstr.length() - 6;
-  nid = ANON_MARKER_ID_MAX |
-  (std::strtol(idstr.substr(itr, 6).c_str(), NULL, 16)) &lt;&lt; 1;
-
   switch (type) {
   case TYPE_OWN:
     /* use lower 6 bytes */
@@ -321,10 +316,10 @@ static int result_to_pictogram(const string&amp; idstr, ros::Time now,
     publish_car(nid, 1, now, pose, diffmsec);
     break;
   case TYPE_CAR:
-    publish_car(nid, 0, now, pose, diffmsec);
+    publish_car(0, 0, now, pose, diffmsec);
     break;
   case TYPE_PEDESTRIAN:
-    publish_pedestrian(nid, 1, now, pose, diffmsec);
+    publish_pedestrian(0, 1, now, pose, diffmsec);
     break;
 
   /* backward compatibility */
@@ -346,11 +341,11 @@ static int result_to_pictogram(const string&amp; idstr, ros::Time now,
         publish_car(nid, 1, now, pose, diffmsec);
       }
     } else if (idstr.find("car_pose", 0) != string::npos) {
-      publish_car(nid, 0, now, pose, diffmsec);
+      publish_car(0, 0, now, pose, diffmsec);
     } else if (idstr.find("pedestrian_pose", 0) != string::npos) {
-      publish_pedestrian(nid, 1, now, pose, diffmsec);
+      publish_pedestrian(0, 1, now, pose, diffmsec);
     } else {
-      publish_pedestrian(nid, 0, now, pose, diffmsec); // PosUp
+      publish_pedestrian(0, 0, now, pose, diffmsec); // PosUp
     }
   }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="acfccd67c05703c6300ed9f9478e36b433bdafac" author="Masahiro Kitazawa">
		<msg>wait for review</msg>
		<modified_files>
			<file old_path="ros\src\data\packages\obj_db\nodes\obj_downloader\obj_downloader.cpp" new_path="ros\src\data\packages\obj_db\nodes\obj_downloader\obj_downloader.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -133,7 +133,7 @@ static void marker_publisher(const std_msgs::String&amp; msg)
   visualization_msgs::Marker sphere_list;
   sphere_list.header.frame_id = "/mobility";
   sphere_list.header.stamp = ros::Time::now();
-  sphere_list.ns = "mo_pictogram";
+  sphere_list.ns = "mo_pictograms";
   sphere_list.id = 0;
   sphere_list.type = visualization_msgs::Marker::SPHERE_LIST;
   sphere_list.action = visualization_msgs::Marker::ADD;
@@ -278,7 +278,7 @@ int main(int argc, char **argv)
 
   cout &lt;&lt; "obj_downloader" &lt;&lt; endl;
 
-  pub = nh.advertise&lt;visualization_msgs::Marker&gt;("mo_pictogram",1);
+  pub = nh.advertise&lt;visualization_msgs::Marker&gt;("mo_pictograms",1);
 
   if(argc == 1){
     std::cout &lt;&lt; "normal execution" &lt;&lt; std::endl;
</diff>
			</file>
			<file old_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" new_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -57,7 +57,7 @@ publish data as ractangular plane
 #include &lt;tf/transform_datatypes.h&gt;
 
 #define MYNAME		"pos_downloader"
-#define PICTOGRAMNAME "mo_pictogram"
+#define PICTOGRAMNAME "mo_pictograms"
 #define STARTTIME	(0)		// sec since 1970-01-01 (0==now)
 #define DELAYSEC	(0)		// delay sec for pos_uploader
 #define POSUP_DZ	(40)		// z offset of PosUp
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2e68ed38206046aba67aa866a3e63e870dd2e853" author="anhnv3991">
		<msg>Fix ndt_matching/ndt_mapping on drivePX2 and JetsonTX2</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\ndt_gpu\src\NormalDistributionsTransform.cu" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\src\NormalDistributionsTransform.cu" added_lines="7" deleted_lines="4">
				<diff>@@ -207,10 +207,13 @@ void GNormalDistributionsTransform::computeTransformation(const Eigen::Matrix&lt;fl
 
 		delta_p *= delta_p_norm;
 
-		transformation_ = (Eigen::Translation&lt;float, 3&gt;(static_cast&lt;float&gt;(delta_p(0)), static_cast&lt;float&gt;(delta_p(1)), static_cast&lt;float&gt;(delta_p(2))) *
-							Eigen::AngleAxis&lt;float&gt;(static_cast&lt;float&gt;(delta_p(3)), Eigen::Vector3f::UnitX()) *
-							Eigen::AngleAxis&lt;float&gt;(static_cast&lt;float&gt;(delta_p(4)), Eigen::Vector3f::UnitY()) *
-							Eigen::AngleAxis&lt;float&gt;(static_cast&lt;float&gt;(delta_p(5)), Eigen::Vector3f::UnitZ())).matrix();
+		Eigen::Translation&lt;float, 3&gt; translation(static_cast&lt;float&gt;(delta_p(0)), static_cast&lt;float&gt;(delta_p(1)), static_cast&lt;float&gt;(delta_p(2)));
+		Eigen::AngleAxis&lt;float&gt; tmp1(static_cast&lt;float&gt;(delta_p(3)), Eigen::Vector3f::UnitX());
+		Eigen::AngleAxis&lt;float&gt; tmp2(static_cast&lt;float&gt;(delta_p(4)), Eigen::Vector3f::UnitY());
+		Eigen::AngleAxis&lt;float&gt; tmp3(static_cast&lt;float&gt;(delta_p(5)), Eigen::Vector3f::UnitZ());
+		Eigen::AngleAxis&lt;float&gt; tmp4(tmp1 * tmp2 * tmp3);
+
+		transformation_ = (translation * tmp4).matrix();
 
 		p = p + delta_p;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8fa647925f75b45d977a7b84546319a89944b9cd" author="anhnv3991">
		<msg>Fix ndt not working correctly on drivePx2 and JetsonTX2</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\ndt_gpu\src\NormalDistributionsTransform.cu" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\src\NormalDistributionsTransform.cu" added_lines="13" deleted_lines="8">
				<diff>@@ -1238,10 +1238,13 @@ double GNormalDistributionsTransform::computeStepLengthMT(const Eigen::Matrix&lt;do
 
 	x_t = x + step_dir * a_t;
 
-	final_transformation_ = (Eigen::Translation&lt;float, 3&gt;(static_cast&lt;float&gt;(x_t(0)), static_cast&lt;float&gt;(x_t(1)), static_cast&lt;float&gt;(x_t(2))) *
-								Eigen::AngleAxis&lt;float&gt;(static_cast&lt;float&gt;(x_t(3)), Eigen::Vector3f::UnitX()) *
-								Eigen::AngleAxis&lt;float&gt;(static_cast&lt;float&gt;(x_t(4)), Eigen::Vector3f::UnitY()) *
-								Eigen::AngleAxis&lt;float&gt;(static_cast&lt;float&gt;(x_t(5)), Eigen::Vector3f::UnitZ())).matrix();
+	Eigen::Translation&lt;float, 3&gt; translation(static_cast&lt;float&gt;(x_t(0)), static_cast&lt;float&gt;(x_t(1)), static_cast&lt;float&gt;(x_t(2)));
+	Eigen::AngleAxis&lt;float&gt; tmp1(static_cast&lt;float&gt;(x_t(3)), Eigen::Vector3f::UnitX());
+	Eigen::AngleAxis&lt;float&gt; tmp2(static_cast&lt;float&gt;(x_t(4)), Eigen::Vector3f::UnitY());
+	Eigen::AngleAxis&lt;float&gt; tmp3(static_cast&lt;float&gt;(x_t(5)), Eigen::Vector3f::UnitZ());
+	Eigen::AngleAxis&lt;float&gt; tmp4(tmp1 * tmp2 * tmp3);
+
+	final_transformation_ = (translation * tmp4).matrix();
 
 	transformPointCloud(x_, y_, z_, trans_x, trans_y, trans_z, points_num, final_transformation_);
 
@@ -1264,11 +1267,13 @@ double GNormalDistributionsTransform::computeStepLengthMT(const Eigen::Matrix&lt;do
 
 		x_t = x + step_dir * a_t;
 
+		translation = Eigen::Translation&lt;float, 3&gt;(static_cast&lt;float&gt;(x_t(0)), static_cast&lt;float&gt;(x_t(1)), static_cast&lt;float&gt;(x_t(2)));
+		tmp1 = Eigen::AngleAxis&lt;float&gt;(static_cast&lt;float&gt;(x_t(3)), Eigen::Vector3f::UnitX());
+		tmp2 = Eigen::AngleAxis&lt;float&gt;(static_cast&lt;float&gt;(x_t(4)), Eigen::Vector3f::UnitY());
+		tmp3 = Eigen::AngleAxis&lt;float&gt;(static_cast&lt;float&gt;(x_t(5)), Eigen::Vector3f::UnitZ());
+		tmp4 = tmp1 * tmp2 * tmp3;
 
-		final_transformation_ = (Eigen::Translation&lt;float, 3&gt;(static_cast&lt;float&gt;(x_t(0)), static_cast&lt;float&gt;(x_t(1)), static_cast&lt;float&gt;(x_t(2))) *
-								 Eigen::AngleAxis&lt;float&gt;(static_cast&lt;float&gt;(x_t(3)), Eigen::Vector3f::UnitX()) *
-								 Eigen::AngleAxis&lt;float&gt;(static_cast&lt;float&gt;(x_t(4)), Eigen::Vector3f::UnitY()) *
-								 Eigen::AngleAxis&lt;float&gt;(static_cast&lt;float&gt;(x_t(5)), Eigen::Vector3f::UnitZ())).matrix();
+		final_transformation_ = (translation * tmp4).matrix();
 
 		transformPointCloud(x_, y_, z_, trans_x, trans_y, trans_z, points_num, final_transformation_);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6bed944eaf5c961ec6a32b906902091c19287306" author="Yusuke FUJII">
		<msg>Add to publish position deviation from waypoint
- apply clang-format
- add publisher of position deviation</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -242,7 +242,7 @@ bool PurePursuit::canGetCurvature(double *output_kappa)
   }
   // check whether curvature is valid or not
   bool is_valid_curve = false;
-  for (const auto&amp; el : current_waypoints_)
+  for (const auto &amp;el : current_waypoints_)
   {
     if (getPlaneDistance(el.pose.pose.position, current_pose_.position) &gt; minimum_lookahead_distance_)
     {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" added_lines="1" deleted_lines="0">
				<diff>@@ -33,6 +33,7 @@
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
+
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="29" deleted_lines="6">
				<diff>@@ -83,6 +83,7 @@ void PurePursuitNode::initForROS()
   pub14_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("line_point_mark", 0);  // debug tool
   pub15_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("trajectory_circle_mark", 0);
   pub16_ = nh_.advertise&lt;std_msgs::Float32&gt;("angular_gravity", 0);
+  pub17_ = nh_.advertise&lt;std_msgs::Float32&gt;("deviation_of_current_position", 0);
   // pub7_ = nh.advertise&lt;std_msgs::Bool&gt;("wf_stat", 0);
 }
 
@@ -118,6 +119,8 @@ void PurePursuitNode::run()
     angular_gravity_msg.data = computeAngularGravity(computeCommandVelocity(), kappa);
     pub16_.publish(angular_gravity_msg);
 
+    publishDeviationCurrentPosition(pp_.getCurrentPose().position, pp_.getCurrentWaypoints());
+
     is_pose_set_ = false;
     is_velocity_set_ = false;
     is_waypoint_set_ = false;
@@ -157,9 +160,8 @@ double PurePursuitNode::computeLookaheadDistance() const
   double maximum_lookahead_distance = current_linear_velocity_ * 10;
   double ld = current_linear_velocity_ * lookahead_distance_ratio_;
 
-  return ld &lt; minimum_lookahead_distance_ ? minimum_lookahead_distance_
-        : ld &gt; maximum_lookahead_distance ? maximum_lookahead_distance
-        : ld;
+  return ld &lt; minimum_lookahead_distance_ ? minimum_lookahead_distance_ :
+                                            ld &gt; maximum_lookahead_distance ? maximum_lookahead_distance : ld;
 }
 
 double PurePursuitNode::computeCommandVelocity() const
@@ -176,17 +178,18 @@ double PurePursuitNode::computeCommandAccel() const
   const geometry_msgs::Pose target_pose = pp_.getCurrentWaypoints().at(1).pose.pose;
 
   // v^2 - v0^2 = 2ax
-  const double x =  std::hypot(current_pose.position.x-target_pose.position.x, current_pose.position.y-target_pose.position.y);
+  const double x =
+      std::hypot(current_pose.position.x - target_pose.position.x, current_pose.position.y - target_pose.position.y);
   const double v0 = current_linear_velocity_;
   const double v = computeCommandVelocity();
-  const double a = (v*v - v0*v0) / (2*x);
+  const double a = (v * v - v0 * v0) / (2 * x);
   return a;
 }
 
 double PurePursuitNode::computeAngularGravity(double velocity, double kappa) const
 {
   const double gravity = 9.80665;
-  return (velocity*velocity) / (1.0/kappa*gravity);
+  return (velocity * velocity) / (1.0 / kappa * gravity);
 }
 
 void PurePursuitNode::callbackFromConfig(const autoware_msgs::ConfigWaypointFollowerConstPtr &amp;config)
@@ -199,6 +202,26 @@ void PurePursuitNode::callbackFromConfig(const autoware_msgs::ConfigWaypointFoll
   is_config_set_ = true;
 }
 
+void PurePursuitNode::publishDeviationCurrentPosition(const geometry_msgs::Point &amp;point,
+                                                      const std::vector&lt;autoware_msgs::waypoint&gt; &amp;waypoints) const
+{
+  // Calculate the deviation of current position from the waypoint approximate line
+
+  if (waypoints.size() &lt; 3)
+  {
+    return;
+  }
+
+  double a, b, c;
+  double linear_flag_in =
+      getLinearEquation(waypoints.at(2).pose.pose.position, waypoints.at(1).pose.pose.position, &amp;a, &amp;b, &amp;c);
+
+  std_msgs::Float32 msg;
+  msg.data = getDistanceBetweenLineAndPoint(point, a, b, c);
+
+  pub17_.publish(msg);
+}
+
 void PurePursuitNode::callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 {
   pp_.setCurrentPose(msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" added_lines="7" deleted_lines="5">
				<diff>@@ -32,18 +32,18 @@
 #define PURE_PURSUIT_CORE_H
 
 // ROS includes
+#include &lt;geometry_msgs/PoseStamped.h&gt;
+#include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Float32.h&gt;
-#include &lt;geometry_msgs/TwistStamped.h&gt;
-#include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 
 // User defined includes
 #include "autoware_msgs/ConfigWaypointFollower.h"
-#include "autoware_msgs/lane.h"
 #include "autoware_msgs/ControlCommandStamped.h"
-#include "pure_pursuit_viz.h"
+#include "autoware_msgs/lane.h"
 #include "pure_pursuit.h"
+#include "pure_pursuit_viz.h"
 
 namespace waypoint_follower
 {
@@ -78,7 +78,7 @@ private:
   PurePursuit pp_;
 
   // publisher
-  ros::Publisher pub1_, pub2_, pub11_, pub12_, pub13_, pub14_, pub15_, pub16_;
+  ros::Publisher pub1_, pub2_, pub11_, pub12_, pub13_, pub14_, pub15_, pub16_, pub17_;
 
   // subscriber
   ros::Subscriber sub1_, sub2_, sub3_, sub4_;
@@ -110,6 +110,8 @@ private:
   // functions
   void publishTwistStamped(const bool &amp;can_get_curvature, const double &amp;kappa) const;
   void publishControlCommandStamped(const bool &amp;can_get_curvature, const double &amp;kappa) const;
+  void publishDeviationCurrentPosition(const geometry_msgs::Point &amp;point,
+                                       const std::vector&lt;autoware_msgs::waypoint&gt; &amp;waypoints) const;
 
   double computeLookaheadDistance() const;
   double computeCommandVelocity() const;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_node.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -41,4 +41,4 @@ int main(int argc, char **argv)
   ppn.run();
 
   return 0;
-}
\ No newline at end of file
+}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_viz.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_viz.h" added_lines="2" deleted_lines="1">
				<diff>@@ -33,8 +33,9 @@
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
-#include &lt;geometry_msgs/TwistStamped.h&gt;
+
 #include &lt;geometry_msgs/PoseStamped.h&gt;
+#include &lt;geometry_msgs/TwistStamped.h&gt;
 
 #include &lt;visualization_msgs/Marker.h&gt;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="81556d77fc25d30e6d23ac42fbe6990f50db3cdd" author="hatem-darweesh">
		<msg>Update OpenPlanner libraries (op_planner, op_utitity, op_ros_helpers)
Update ring ground filter with latest implementation
Update lidar_kf_contour_track with latest implementation
Add op_utilities nodes (op_bag_player, op_data_logger, op_pose2tf)
Modify autoware_msgs for OpenPlanner use (CloudCluster, DetectedObject, lane, waypoint)
Update UI computing.yaml for the new nodes and modifies parameters
Update UI sensing.yaml for updated ring_ground_filter params</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\op_planner_sim.rviz" new_path="ros\src\.config\rviz\op_planner_sim.rviz" added_lines="130" deleted_lines="73">
				<diff>@@ -4,16 +4,16 @@ Panels:
     Name: Displays
     Property Tree Widget:
       Expanded:
-        - /Global Options1
         - /Camera1/Visibility1
         - /Points Raw1/Status1
         - /Local Waypoints1/Status1
         - /Vector Map CenterLines1/Namespaces1
         - /Global Path1/Namespaces1
         - /Local Rollouts1/Namespaces1
+        - /Tracked Contours1/Namespaces1
         - /GlobalPathAnimation1/Status1
       Splitter Ratio: 0.695804
-    Tree Height: 1183
+    Tree Height: 841
   - Class: rviz/Selection
     Name: Selection
   - Class: rviz/Tool Properties
@@ -22,7 +22,7 @@ Panels:
       - /2D Nav Goal1
       - /Publish Point1
     Name: Tool Properties
-    Splitter Ratio: 0.588679
+    Splitter Ratio: 0.588679016
   - Class: rviz/Views
     Expanded:
       - /Current View1
@@ -42,7 +42,7 @@ Visualization Manager:
       Color: 160; 160; 164
       Enabled: false
       Line Style:
-        Line Width: 0.03
+        Line Width: 0.0299999993
         Value: Lines
       Name: Grid
       Normal Cell Count: 0
@@ -59,10 +59,30 @@ Visualization Manager:
       Frame Timeout: 15
       Frames:
         All Enabled: true
+        FrontLidarC:
+          Value: true
+        LeftLidarC:
+          Value: true
+        RearLidarC:
+          Value: true
+        RightLidarC:
+          Value: true
         base_link:
           Value: true
+        camera2:
+          Value: true
+        camera3:
+          Value: true
+        camera4:
+          Value: true
+        camera5:
+          Value: true
+        camera6:
+          Value: true
         map:
           Value: true
+        mti/data:
+          Value: true
         velodyne:
           Value: true
         world:
@@ -77,10 +97,29 @@ Visualization Manager:
           map:
             base_link:
               velodyne:
-                {}
+                FrontLidarC:
+                  {}
+                LeftLidarC:
+                  {}
+                RearLidarC:
+                  {}
+                RightLidarC:
+                  {}
+                camera2:
+                  {}
+                camera3:
+                  {}
+                camera4:
+                  {}
+                camera5:
+                  {}
+                camera6:
+                  {}
+                mti/data:
+                  {}
       Update Interval: 0
       Value: true
-    - Alpha: 0.05
+    - Alpha: 0.0500000007
       Autocompute Intensity Bounds: true
       Autocompute Value Bounds:
         Max Value: 10
@@ -103,53 +142,26 @@ Visualization Manager:
       Queue Size: 10
       Selectable: true
       Size (Pixels): 2
-      Size (m): 0.01
+      Size (m): 0.00999999978
       Style: Points
       Topic: /points_map
       Unreliable: false
       Use Fixed Frame: true
       Use rainbow: true
       Value: true
-    - Class: rviz/MarkerArray
-      Enabled: true
-      Marker Topic: /vector_map
-      Name: Vector Map
-      Namespaces:
-        cross_road: true
-        cross_walk: true
-        curb: true
-        curve_mirror: true
-        fence: true
-        guard_rail: true
-        gutter: true
-        rail_crossing: true
-        road_edge: true
-        road_mark: true
-        road_pole: true
-        road_sign: true
-        side_walk: true
-        signal: true
-        stop_line: true
-        street_light: true
-        utility_pole: true
-        wall: true
-        white_line: true
-        zebra_zone: true
-      Queue Size: 100
-      Value: true
     - Class: rviz/Camera
       Enabled: false
       Image Rendering: overlay
       Image Topic: /image_raw
       Name: Camera
-      Overlay Alpha: 0.4
+      Overlay Alpha: 0.400000006
       Queue Size: 10
       Transport Hint: raw
       Unreliable: false
       Value: false
       Visibility:
+        "": true
         Behavior State: true
-        Bounding Boxes: true
         Control Pose: true
         Current Pose: true
         Detection Range: true
@@ -157,7 +169,7 @@ Visualization Manager:
         Global Waypoints: true
         GlobalPathAnimation: true
         Grid: true
-        Image: true
+        ImageRaw: true
         Laserscan Costmap: true
         Local Rollouts: true
         Local Waypoints: true
@@ -190,12 +202,11 @@ Visualization Manager:
         TF: false
         Tracked Contours: true
         Value: true
-        Vector Map: true
         Vector Map CenterLines: true
+        VectorMap: true
         Vehicle Model: true
         Vscan Points: true
         Waypoint Guide: true
-        km/h: true
       Zoom Factor: 1
     - Alpha: 0.5
       Autocompute Intensity Bounds: true
@@ -209,24 +220,32 @@ Visualization Manager:
       Color: 255; 255; 255
       Color Transformer: Intensity
       Decay Time: 0
-      Enabled: true
+      Enabled: false
       Invert Rainbow: false
       Max Color: 255; 255; 255
-      Max Intensity: 237
+      Max Intensity: 255
       Min Color: 0; 0; 0
-      Min Intensity: 0
+      Min Intensity: 5.17198515
       Name: Points Raw
       Position Transformer: XYZ
       Queue Size: 10
       Selectable: true
       Size (Pixels): 1
-      Size (m): 0.01
+      Size (m): 0.00999999978
       Style: Points
       Topic: /points_raw
       Unreliable: false
       Use Fixed Frame: true
       Use rainbow: true
-      Value: true
+      Value: false
+    - Class: rviz/MarkerArray
+      Enabled: false
+      Marker Topic: /vector_map
+      Name: VectorMap
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: false
     - Alpha: 0.5
       Autocompute Intensity Bounds: true
       Autocompute Value Bounds:
@@ -250,7 +269,7 @@ Visualization Manager:
       Queue Size: 10
       Selectable: true
       Size (Pixels): 3
-      Size (m): 0.01
+      Size (m): 0.00999999978
       Style: Points
       Topic: /vscan_points
       Unreliable: false
@@ -259,7 +278,7 @@ Visualization Manager:
       Value: true
     - Alpha: 1
       Axes Length: 1
-      Axes Radius: 0.1
+      Axes Radius: 0.100000001
       Class: rviz/Pose
       Color: 255; 25; 0
       Enabled: true
@@ -274,7 +293,7 @@ Visualization Manager:
       Value: true
     - Alpha: 1
       Axes Length: 1
-      Axes Radius: 0.1
+      Axes Radius: 0.100000001
       Class: rviz/Pose
       Color: 255; 170; 255
       Enabled: false
@@ -362,8 +381,8 @@ Visualization Manager:
       Position Transformer: XYZ
       Queue Size: 10
       Selectable: true
-      Size (Pixels): 5
-      Size (m): 0.01
+      Size (Pixels): 1
+      Size (m): 0.00999999978
       Style: Points
       Topic: /points_cluster
       Unreliable: false
@@ -402,7 +421,7 @@ Visualization Manager:
         {}
       Queue Size: 100
       Value: true
-    - Alpha: 0.7
+    - Alpha: 0.699999988
       Class: rviz/Map
       Color Scheme: map
       Draw Behind: false
@@ -410,6 +429,7 @@ Visualization Manager:
       Name: Laserscan Costmap
       Topic: /ring_ogm
       Unreliable: false
+      Use Timestamp: false
       Value: false
     - Class: rviz/MarkerArray
       Enabled: false
@@ -424,9 +444,7 @@ Visualization Manager:
       Marker Topic: /global_waypoints_rviz
       Name: Global Path
       Namespaces:
-        global_lane_array_marker: true
-        global_lane_waypoint_orientation_marker: true
-        global_velocity_lane_1: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -434,7 +452,7 @@ Visualization Manager:
       Marker Topic: /local_trajectories
       Name: Local Rollouts
       Namespaces:
-        global_lane_array_marker: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -442,7 +460,13 @@ Visualization Manager:
       Marker Topic: /detected_polygons
       Name: Tracked Contours
       Namespaces:
-        {}
+        CenterMarker: true
+        Detection_Circles: false
+        Directions: true
+        InfoText: true
+        detected_polygons: true
+        matching_connections: true
+        tracked_trajectories: true
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -450,7 +474,7 @@ Visualization Manager:
       Marker Topic: /curr_simu_pose
       Name: SimulatedCar Pose
       Namespaces:
-        curr_simu_pose: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -458,7 +482,7 @@ Visualization Manager:
       Marker Topic: /follow_pose
       Name: Simulated Following Point
       Namespaces:
-        follow_pose: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -466,7 +490,7 @@ Visualization Manager:
       Marker Topic: /behavior_state
       Name: Behavior State
       Namespaces:
-        detected_polygons_velocity: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -482,20 +506,20 @@ Visualization Manager:
       Marker Topic: /safety_border
       Name: Safety Box
       Namespaces:
-        global_lane_array_marker: true
+        {}
       Queue Size: 100
       Value: true
     - Class: jsk_rviz_plugin/BoundingBoxArray
-      Enabled: true
+      Enabled: false
       Name: Simulated Obstacle
-      Topic: /dp_planner_tracked_boxes
+      Topic: /bounding_boxes
       Unreliable: false
-      Value: true
-      alpha: 0.8
+      Value: false
+      alpha: 0.800000012
       color: 25; 255; 0
       coloring: Value
-      line width: 0.01
-      only edge: false
+      line width: 0.100000001
+      only edge: true
       show coords: false
     - Class: rviz/Marker
       Enabled: true
@@ -617,9 +641,38 @@ Visualization Manager:
         {}
       Queue Size: 100
       Value: true
+    - Class: rviz/Image
+      Enabled: true
+      Image Topic: /image_raw
+      Max Value: 1
+      Median window: 5
+      Min Value: 0
+      Name: ImageRaw
+      Normalize Range: true
+      Queue Size: 2
+      Transport Hint: raw
+      Unreliable: false
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /detected_objects/target_id
+      Name: Marker
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /detected_objects/velocity_arrow
+      Name: Marker
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
   Enabled: true
   Global Options:
     Background Color: 48; 48; 48
+    Default Light: true
     Fixed Frame: world
     Frame Rate: 30
   Name: root
@@ -640,20 +693,21 @@ Visualization Manager:
   Value: true
   Views:
     Current:
-      Angle: 0.00500008
+      Angle: 0
       Class: rviz/TopDownOrtho
       Enable Stereo Rendering:
-        Stereo Eye Separation: 0.06
+        Stereo Eye Separation: 0.0599999987
         Stereo Focal Distance: 1
         Swap Stereo Eyes: false
         Value: false
+      Invert Z Axis: false
       Name: Current View
-      Near Clip Distance: 0.01
-      Scale: 22.8087
+      Near Clip Distance: 0.00999999978
+      Scale: 10
       Target Frame: world
       Value: TopDownOrtho (rviz)
-      X: 3.80643
-      Y: -18.6686
+      X: 0
+      Y: 0
     Saved: ~
 Window Geometry:
   Camera:
@@ -663,9 +717,9 @@ Window Geometry:
   Height: 1416
   Hide Left Dock: false
   Hide Right Dock: false
-  Image:
+  ImageRaw:
     collapsed: false
-  QMainWindow State: 000000ff00000000fd0000000400000000000001fc000004e0fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc00000028000004e0000000dd00fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000005c00fffffffb0000000c00430061006d0065007200610000000000ffffffff0000006500fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb00000000000000000000000100000163000004e0fc0200000003fb0000000a005600690065007700730100000028000004e0000000b000fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e1000001970000000300000a000000005cfc0100000002fb0000000800540069006d0065010000000000000a00000002f600fffffffb0000000800540069006d0065010000000000000450000000000000000000000695000004e000000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  QMainWindow State: 000000ff00000000fd0000000400000000000001fc000004e0fc0200000010fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006100fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc000000280000038a000000d700fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000c00430061006d0065007200610000000000ffffffff0000006700fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb0000000000000000fb0000000a0049006d0061006700650100000431000000d70000000000000000fb0000000a0049006d00610067006501000003d7000001310000000000000000fb000000100049006d00610067006500520061007701000003b8000001500000001600ffffff0000000100000163000004e0fc0200000003fb0000000a005600690065007700730100000028000004e0000000ad00fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e1000001970000000300000a000000005cfc0100000002fb0000000800540069006d0065010000000000000a000000030000fffffffb0000000800540069006d0065010000000000000450000000000000000000000695000004e000000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
@@ -674,3 +728,6 @@ Window Geometry:
     collapsed: false
   Views:
     collapsed: false
+  Width: 2560
+  X: 1080
+  Y: 24
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\lidar_kf_contour_track_core.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\lidar_kf_contour_track_core.h" added_lines="42" deleted_lines="12">
				<diff>@@ -34,7 +34,10 @@
 // ROS includes
 #include &lt;ros/ros.h&gt;
 #include "op_planner/RoadNetwork.h"
-#include "op_simu/SimpleTracker.h"
+#include "op_planner/PlannerCommonDef.h"
+#include "op_planner/MatrixOperations.h"
+#include "SimpleTracker.h"
+#include "PolygonGenerator.h"
 
 #include &lt;autoware_msgs/CloudClusterArray.h&gt;
 #include &lt;autoware_msgs/DetectedObjectArray.h&gt;
@@ -55,7 +58,10 @@ public:
 	double 	MaxObjSize;
 	double  nQuarters;
 	double 	PolygonRes;
-	SimulationNS::TRACKING_TYPE	trackingType; // 0 association only , 1 simple tracking, 2 contour based tracking
+	TRACKING_TYPE	trackingType; // 0 association only , 1 simple tracking, 2 contour based tracking
+	bool    bEnableSimulation;
+	bool 	bEnableStepByStep;
+	bool 	bEnableLogging;
 
 	PerceptionParams()
 	{
@@ -66,7 +72,10 @@ public:
 		MaxObjSize =0;
 		nQuarters = 0;
 		PolygonRes = 0;
-		trackingType = SimulationNS::SIMPLE_TRACKER;
+		trackingType = SIMPLE_TRACKER;
+		bEnableStepByStep = false;
+		bEnableSimulation = false;
+		bEnableLogging = false;
 	}
 };
 
@@ -75,15 +84,11 @@ class ContourTracker
 protected:
 	std::vector&lt;PlannerHNS::DetectedObject&gt; m_OriginalClusters;
 	autoware_msgs::DetectedObjectArray m_OutPutResults;
-
 	bool bNewClusters;
-
 	PlannerHNS::WayPoint m_CurrentPos;
 	bool bNewCurrentPos;
-
 	PerceptionParams m_Params;
-
-	SimulationNS::SimpleTracker m_ObstacleTracking;
+	SimpleTracker m_ObstacleTracking;
 
 	//Visualization Section
 	int m_nDummyObjPerRep;
@@ -91,10 +96,30 @@ protected:
 	std::vector&lt;visualization_msgs::MarkerArray&gt; m_DetectedPolygonsDummy;
 	std::vector&lt;visualization_msgs::MarkerArray&gt; m_DetectedPolygonsActual;
 	visualization_msgs::MarkerArray m_DetectedPolygonsAllMarkers;
-
 	visualization_msgs::MarkerArray m_DetectionCircles;
 
-protected: //ROS messages (topics)
+	std::vector&lt;visualization_msgs::MarkerArray&gt; m_MatchingInfoDummy;
+	std::vector&lt;visualization_msgs::MarkerArray&gt; m_MatchingInfoActual;
+
+	std::vector&lt;std::string&gt;    m_LogData;
+	PlannerHNS::MAP_SOURCE_TYPE m_MapType;
+	std::string m_MapPath;
+	PlannerHNS::RoadNetwork m_Map;
+	bool bMap;
+	bool bVectorMapCheck;
+	double m_MapFilterDistance;
+
+	std::vector&lt;PlannerHNS::Lane*&gt; m_ClosestLanesList;
+
+	int m_nOriginalPoints;
+	int m_nContourPoints;
+	double m_FilteringTime;
+	double m_PolyEstimationTime;
+	double m_tracking_time;
+	double m_dt;
+	struct timespec  m_loop_timer;
+
+	//ROS subscribers
 	ros::NodeHandle nh;
 
 	//define publishers
@@ -108,12 +133,17 @@ protected: //ROS messages (topics)
 	ros::Subscriber sub_current_pose ;
 
 
-protected: // Callback function for subscriber.
+	// Callback function for subscriber.
 	void callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr &amp;msg);
 	void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg);
 
-protected: //Helper Functions
+	//Helper Functions
 	void VisualizeLocalTracking();
+	void ImportCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr&amp; msg, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; originalClusters);
+	bool IsCar(const PlannerHNS::DetectedObject&amp; obj, const PlannerHNS::WayPoint&amp; currState, PlannerHNS::RoadNetwork&amp; map);
+	void ReadNodeParams();
+	void ReadCommonParams();
+	void LogAndSend();
 
 public:
   ContourTracker();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -36,7 +36,7 @@
 #include &lt;ros/ros.h&gt;
 
 int main(int argc, char **argv) {
-  ros::init(argc, argv, "kf_contour_track");
+  ros::init(argc, argv, "lidar_kf_contour_track");
   ContourTrackerNS::ContourTracker tracker;
   tracker.MainLoop();
   return 0;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track_core.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track_core.cpp" added_lines="393" deleted_lines="216">
				<diff>@@ -32,235 +32,412 @@
 */
 #include "lidar_kf_contour_track_core.h"
 #include "op_ros_helpers/op_RosHelpers.h"
+#include "op_planner/MappingHelpers.h"
+
+namespace ContourTrackerNS
+{
+
+ContourTracker::ContourTracker()
+{
+	m_MapFilterDistance = 0;
+	m_dt = 0;
+	m_tracking_time = 0;
+	m_nOriginalPoints = 0;
+	m_FilteringTime = 0 ;
+	m_FilteringTime = 0;
+	m_FilteringTime = 0;
+	m_nContourPoints = 0;
+	m_PolyEstimationTime = 0;
+	m_MapType = PlannerHNS::MAP_KML_FILE;
+	bMap = false;
+	bVectorMapCheck = true;
+	bNewCurrentPos = false;
+	ReadNodeParams();
+	ReadCommonParams();
+
+	m_ObstacleTracking.m_dt = 0.1;
+	m_ObstacleTracking.m_bUseCenterOnly = true;
+	m_ObstacleTracking.m_Horizon = m_Params.DetectionRadius;
+	m_ObstacleTracking.m_bEnableStepByStep = m_Params.bEnableStepByStep;
+	m_ObstacleTracking.InitSimpleTracker();
+
+	sub_cloud_clusters 		= nh.subscribe("/cloud_clusters", 1, &amp;ContourTracker::callbackGetCloudClusters, this);
+	sub_current_pose 		= nh.subscribe("/current_pose",   1, &amp;ContourTracker::callbackGetCurrentPose, 	this);
+
+	pub_AllTrackedObjects 	= nh.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("tracked_objects", 1);
+	pub_DetectedPolygonsRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detected_polygons", 1);
+	pub_TrackedObstaclesRviz = nh.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("op_planner_tracked_boxes", 1);
+
+
+	m_nDummyObjPerRep = 150;
+	m_nDetectedObjRepresentations = 5;
+	m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
+	m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
+	m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
+	m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
+	m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
+	m_DetectedPolygonsActual = m_DetectedPolygonsDummy;
+	PlannerHNS::RosHelpers::InitMarkers(m_nDummyObjPerRep, m_DetectedPolygonsDummy.at(0), m_DetectedPolygonsDummy.at(1), m_DetectedPolygonsDummy.at(2), m_DetectedPolygonsDummy.at(3), m_DetectedPolygonsDummy.at(4));
+
+	m_MatchingInfoDummy.push_back(visualization_msgs::MarkerArray());
+	m_MatchingInfoActual = m_MatchingInfoDummy;
+	PlannerHNS::RosHelpers::InitMatchingMarkers(m_nDummyObjPerRep, m_MatchingInfoDummy.at(0));
+}
+
+ContourTracker::~ContourTracker()
+{
+	if(m_Params.bEnableLogging == true)
+	{
+		UtilityHNS::DataRW::WriteLogData(UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName+UtilityHNS::DataRW::TrackingFolderName, "contour_tracker",
+					"time,dt,num_Tracked_Objects,num_new_objects,num_matched_objects,num_Cluster_Points,num_Contour_Points,t_filtering,t_poly_calc,t_Tracking,t_total",m_LogData);
+	}
+}
+
+void ContourTracker::ReadNodeParams()
+{
+	ros::NodeHandle _nh;
+	_nh.getParam("/lidar_kf_contour_track/vehicle_width" 			, m_Params.VehicleWidth);
+	_nh.getParam("/lidar_kf_contour_track/vehicle_length" 			, m_Params.VehicleLength);
+	_nh.getParam("/lidar_kf_contour_track/min_object_size" 			, m_Params.MinObjSize);
+	_nh.getParam("/lidar_kf_contour_track/max_object_size" 			, m_Params.MaxObjSize);
+	_nh.getParam("/lidar_kf_contour_track/polygon_quarters" 		, m_Params.nQuarters);
+	_nh.getParam("/lidar_kf_contour_track/polygon_resolution" 		, m_Params.PolygonRes);
+	_nh.getParam("/lidar_kf_contour_track/enableSimulationMode" 	, m_Params.bEnableSimulation);
+	_nh.getParam("/lidar_kf_contour_track/enableStepByStepMode" 	, m_Params.bEnableStepByStep);
+
+
+	_nh.getParam("/lidar_kf_contour_track/max_association_distance" , m_ObstacleTracking.m_MAX_ASSOCIATION_DISTANCE);
+	_nh.getParam("/lidar_kf_contour_track/max_association_size_diff" , m_ObstacleTracking.m_MAX_ASSOCIATION_SIZE_DIFF);
+	_nh.getParam("/lidar_kf_contour_track/enableLogging" , m_Params.bEnableLogging);
+	int tracking_type = 0;
+	_nh.getParam("/lidar_kf_contour_track/tracking_type" 			, tracking_type);
+	if(tracking_type==0)
+		m_Params.trackingType = ASSOCIATE_ONLY;
+	else if (tracking_type == 1)
+		m_Params.trackingType = SIMPLE_TRACKER;
+	else if(tracking_type == 2)
+		m_Params.trackingType = CONTOUR_TRACKER;
+
+	_nh.getParam("/lidar_kf_contour_track/max_remeber_time" 			, m_ObstacleTracking.m_MaxKeepTime);
+	_nh.getParam("/lidar_kf_contour_track/trust_counter" 				, m_ObstacleTracking.m_nMinTrustAppearances);
+	_nh.getParam("/lidar_kf_contour_track/vector_map_filter_distance" 	, m_MapFilterDistance);
+}
 
-namespace ContourTrackerNS {
-
-ContourTracker::ContourTracker() {
-  bNewClusters = false;
-  bNewCurrentPos = false;
-  ros::NodeHandle _nh;
-  _nh.getParam("/kf_contour_tracker/vehicle_width", m_Params.VehicleWidth);
-  _nh.getParam("/kf_contour_tracker/vehicle_length", m_Params.VehicleLength);
-  _nh.getParam("/kf_contour_tracker/horizon", m_Params.DetectionRadius);
-  _nh.getParam("/kf_contour_tracker/min_object_size", m_Params.MinObjSize);
-  _nh.getParam("/kf_contour_tracker/max_object_size", m_Params.MaxObjSize);
-  _nh.getParam("/kf_contour_tracker/polygon_quarters", m_Params.nQuarters);
-  _nh.getParam("/kf_contour_tracker/polygon_resolution", m_Params.PolygonRes);
-  _nh.getParam("/kf_contour_tracker/max_association_distance",
-               m_ObstacleTracking.m_MAX_ASSOCIATION_DISTANCE);
-  _nh.getParam("/kf_contour_tracker/max_association_size_diff",
-               m_ObstacleTracking.m_MAX_ASSOCIATION_SIZE_DIFF);
-
-  int tracking_type = 0;
-  _nh.getParam("/kf_contour_tracker/tracking_type", tracking_type);
-  if (tracking_type == 0)
-    m_Params.trackingType = SimulationNS::ASSOCIATE_ONLY;
-  else if (tracking_type == 1)
-    m_Params.trackingType = SimulationNS::SIMPLE_TRACKER;
-  else if (tracking_type == 2)
-    m_Params.trackingType = SimulationNS::CONTOUR_TRACKER;
-
-  _nh.getParam("/kf_contour_tracker/max_remeber_time",
-               m_ObstacleTracking.m_MaxKeepTime);
-  _nh.getParam("/kf_contour_tracker/trust_counter",
-               m_ObstacleTracking.m_nMinTrustAppearances);
-  _nh.getParam("/kf_contour_tracker/contours_circle_resolutions",
-               m_ObstacleTracking.m_CirclesResolution);
-
-  m_ObstacleTracking.m_dt = 0.12;
-  m_ObstacleTracking.m_bUseCenterOnly = true;
-  m_ObstacleTracking.m_Horizon = m_Params.DetectionRadius;
-  m_ObstacleTracking.InitSimpleTracker();
-
-  sub_cloud_clusters = nh.subscribe(
-      "/cloud_clusters", 1, &amp;ContourTracker::callbackGetCloudClusters, this);
-  sub_current_pose = nh.subscribe(
-      "/current_pose", 1, &amp;ContourTracker::callbackGetCurrentPose, this);
-
-  pub_AllTrackedObjects =
-      nh.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detected_objects", 1);
-  pub_DetectedPolygonsRviz =
-      nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detected_polygons", 1);
-  pub_TrackedObstaclesRviz =
-      nh.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(
-          "op_planner_tracked_boxes", 1);
-
-  m_nDummyObjPerRep = 100;
-  m_nDetectedObjRepresentations = 5;
-  m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
-  m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
-  m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
-  m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
-  m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
-  m_DetectedPolygonsActual = m_DetectedPolygonsDummy;
-  PlannerHNS::RosHelpers::InitMarkers(
-      m_nDummyObjPerRep, m_DetectedPolygonsDummy.at(0),
-      m_DetectedPolygonsDummy.at(1), m_DetectedPolygonsDummy.at(2),
-      m_DetectedPolygonsDummy.at(3), m_DetectedPolygonsDummy.at(4));
+void ContourTracker::ReadCommonParams()
+{
+	ros::NodeHandle _nh("~");
+	if(!_nh.getParam("/op_common_params/horizonDistance" , m_Params.DetectionRadius))
+		m_Params.DetectionRadius = 150;
+
+	m_ObstacleTracking.m_CirclesResolution = m_Params.DetectionRadius*0.05;
+
+	int iSource = 0;
+	if(_nh.getParam("/op_common_params/mapSource" , iSource))
+	{
+		if(iSource == 0)
+			m_MapType = PlannerHNS::MAP_AUTOWARE;
+		else if (iSource == 1)
+			m_MapType = PlannerHNS::MAP_FOLDER;
+		else if(iSource == 2)
+			m_MapType = PlannerHNS::MAP_KML_FILE;
+
+		_nh.getParam("/op_common_params/mapFileName" , m_MapPath);
+		bVectorMapCheck = true;
+	}
+	else
+	{
+		bVectorMapCheck = false;
+	}
 }
 
-ContourTracker::~ContourTracker() {}
+void ContourTracker::callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr &amp;msg)
+{
+	if(bNewCurrentPos || m_Params.bEnableSimulation)
+	{
+		ImportCloudClusters(msg, m_OriginalClusters);
+
+		struct timespec  tracking_timer;
+		UtilityHNS::UtilityH::GetTickCount(tracking_timer);
+
+		//std::cout &lt;&lt; "Filter the detected Obstacles: " &lt;&lt; msg-&gt;clusters.size() &lt;&lt; std::endl;
+		m_ObstacleTracking.DoOneStep(m_CurrentPos, m_OriginalClusters, m_Params.trackingType);
+
+		m_tracking_time = UtilityHNS::UtilityH::GetTimeDiffNow(tracking_timer);
+		m_dt  = UtilityHNS::UtilityH::GetTimeDiffNow(m_loop_timer);
+		UtilityHNS::UtilityH::GetTickCount(m_loop_timer);
+
+		LogAndSend();
+		VisualizeLocalTracking();
+	}
+}
+
+void ContourTracker::ImportCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr&amp; msg, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; originalClusters)
+{
+	originalClusters.clear();
+	m_nOriginalPoints = 0;
+	m_nContourPoints = 0;
+	m_FilteringTime = 0;
+	m_PolyEstimationTime = 0;
+	struct timespec filter_time, poly_est_time;
+
+	PlannerHNS::DetectedObject obj;
+	PlannerHNS::GPSPoint avg_center;
+	PolygonGenerator polyGen(m_Params.nQuarters);
+	pcl::PointCloud&lt;pcl::PointXYZ&gt; point_cloud;
+
+	if(bMap)
+		m_ClosestLanesList = PlannerHNS::MappingHelpers::GetClosestLanesFast(m_CurrentPos, m_Map, m_Params.DetectionRadius);
+
+	//Filter the detected Obstacles:
+	//std::cout &lt;&lt; "Filter the detected Obstacles: " &lt;&lt; std::endl;
+	for(unsigned int i=0; i &lt; msg-&gt;clusters.size(); i++)
+	{
+		obj.center.pos.x = msg-&gt;clusters.at(i).centroid_point.point.x;
+		obj.center.pos.y = msg-&gt;clusters.at(i).centroid_point.point.y;
+		obj.center.pos.z = msg-&gt;clusters.at(i).centroid_point.point.z;
+		obj.center.pos.a = msg-&gt;clusters.at(i).estimated_angle;
+
+		obj.distance_to_center = hypot(obj.center.pos.y-m_CurrentPos.pos.y, obj.center.pos.x-m_CurrentPos.pos.x);
+
+		obj.actual_yaw = msg-&gt;clusters.at(i).estimated_angle;
+
+		obj.w = msg-&gt;clusters.at(i).dimensions.x;
+		obj.l = msg-&gt;clusters.at(i).dimensions.y;
+		obj.h = msg-&gt;clusters.at(i).dimensions.z;
+
+		UtilityHNS::UtilityH::GetTickCount(filter_time);
+		if(!IsCar(obj, m_CurrentPos, m_Map)) continue;
+		m_FilteringTime += UtilityHNS::UtilityH::GetTimeDiffNow(filter_time);
+
+		obj.id = msg-&gt;clusters.at(i).id;
+		obj.originalID = msg-&gt;clusters.at(i).id;
+		obj.label = msg-&gt;clusters.at(i).label;
+
+		if(msg-&gt;clusters.at(i).indicator_state == 0)
+			obj.indicator_state = PlannerHNS::INDICATOR_LEFT;
+		else if(msg-&gt;clusters.at(i).indicator_state == 1)
+			obj.indicator_state = PlannerHNS::INDICATOR_RIGHT;
+		else if(msg-&gt;clusters.at(i).indicator_state == 2)
+			obj.indicator_state = PlannerHNS::INDICATOR_BOTH;
+		else if(msg-&gt;clusters.at(i).indicator_state == 3)
+			obj.indicator_state = PlannerHNS::INDICATOR_NONE;
+
+
+		UtilityHNS::UtilityH::GetTickCount(poly_est_time);
+		point_cloud.clear();
+		pcl::fromROSMsg(msg-&gt;clusters.at(i).cloud, point_cloud);
+
+		obj.contour = polyGen.EstimateClusterPolygon(point_cloud ,obj.center.pos,avg_center, m_Params.PolygonRes);
+
+		m_PolyEstimationTime += UtilityHNS::UtilityH::GetTimeDiffNow(poly_est_time);
+		m_nOriginalPoints += point_cloud.points.size();
+		m_nContourPoints += obj.contour.size();
+		originalClusters.push_back(obj);
+
+	}
+}
+
+bool ContourTracker::IsCar(const PlannerHNS::DetectedObject&amp; obj, const PlannerHNS::WayPoint&amp; currState, PlannerHNS::RoadNetwork&amp; map)
+{
+
+	if(bMap)
+	{
+		bool bOnLane = false;
+	//	std::cout &lt;&lt; "Debug Obj: " &lt;&lt; obj.id &lt;&lt; ", Closest Lane: " &lt;&lt; m_ClosestLanesList.size() &lt;&lt; std::endl;
+
+		for(unsigned int i =0 ; i &lt; m_ClosestLanesList.size(); i++)
+		{
 
-void ContourTracker::callbackGetCloudClusters(
-    const autoware_msgs::CloudClusterArrayConstPtr &amp;msg) {
-  if (bNewCurrentPos) {
-    m_OriginalClusters.clear();
-    int nOriginalPoints = 0;
-    int nContourPoints = 0;
+			PlannerHNS::RelativeInfo info;
+			PlannerHNS::PlanningHelpers::GetRelativeInfoLimited(m_ClosestLanesList.at(i)-&gt;points, obj.center, info);
+			PlannerHNS::WayPoint wp = m_ClosestLanesList.at(i)-&gt;points.at(info.iFront);
 
-    PlannerHNS::RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(
-        m_CurrentPos, m_Params.VehicleWidth, m_Params.VehicleLength, *msg,
-        m_OriginalClusters, m_Params.MaxObjSize, m_Params.MinObjSize,
-        m_Params.DetectionRadius, m_Params.nQuarters, m_Params.PolygonRes,
-        nOriginalPoints, nContourPoints);
+			double direct_d = hypot(wp.pos.y - obj.center.pos.y, wp.pos.x - obj.center.pos.x);
 
-    bNewClusters = true;
-  }
+		//	std::cout &lt;&lt; "- Distance To Car: " &lt;&lt; obj.distance_to_center &lt;&lt; ", PerpD: " &lt;&lt; info.perp_distance &lt;&lt; ", DirectD: " &lt;&lt; direct_d &lt;&lt; ", bAfter: " &lt;&lt; info.bAfter &lt;&lt; ", bBefore: " &lt;&lt; info.bBefore &lt;&lt; std::endl;
+
+			if((info.bAfter || info.bBefore) &amp;&amp; direct_d &gt; m_MapFilterDistance*2.0)
+				continue;
+
+			if(fabs(info.perp_distance) &lt;= m_MapFilterDistance)
+			{
+				bOnLane = true;
+				break;
+			}
+		}
+
+		if(bOnLane == false)
+			return false;
+	}
+
+	double object_size = hypot(obj.w, obj.l);
+
+	//std::cout &lt;&lt; "Filter the detected Obstacles: (" &lt;&lt;  obj.distance_to_center  &lt;&lt; ",&gt;" &lt;&lt;  m_Params.DetectionRadius &lt;&lt; " | "&lt;&lt; object_size &lt;&lt; ",&lt; " &lt;&lt;  m_Params.MinObjSize  &lt;&lt; "| " &lt;&lt;  object_size &lt;&lt; ", &gt;" &lt;&lt;  m_Params.MaxObjSize &lt;&lt; ")"&lt;&lt; std::endl;
+
+	if(obj.distance_to_center &gt; m_Params.DetectionRadius || object_size &lt; m_Params.MinObjSize || object_size &gt; m_Params.MaxObjSize)
+		return false;
+
+	if(m_Params.bEnableSimulation)
+	{
+		PlannerHNS::Mat3 rotationMat(-currState.pos.a);
+		PlannerHNS::Mat3 translationMat(-currState.pos.x, -currState.pos.y);
+
+		PlannerHNS::GPSPoint relative_point = translationMat*obj.center.pos;
+		relative_point = rotationMat*relative_point;
+
+		double distance_x = fabs(relative_point.x - m_Params.VehicleLength/3.0);
+		double distance_y = fabs(relative_point.y);
+
+		if(distance_x  &lt;= m_Params.VehicleLength*0.5 &amp;&amp; distance_y &lt;=  m_Params.VehicleWidth*0.5) // don't detect yourself
+			return false;
+	}
+
+	return true;
 }
 
-void ContourTracker::callbackGetCurrentPose(
-    const geometry_msgs::PoseStampedConstPtr &amp;msg) {
-  m_CurrentPos = PlannerHNS::WayPoint(
-      msg-&gt;pose.position.x, msg-&gt;pose.position.y, msg-&gt;pose.position.z,
+void ContourTracker::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg)
+{
+  m_CurrentPos = PlannerHNS::WayPoint(msg-&gt;pose.position.x, msg-&gt;pose.position.y, msg-&gt;pose.position.z,
       tf::getYaw(msg-&gt;pose.orientation));
+
   bNewCurrentPos = true;
 }
 
-void ContourTracker::VisualizeLocalTracking() {
-  PlannerHNS::RosHelpers::ConvertTrackedObjectsMarkers(
-      m_CurrentPos, m_ObstacleTracking.m_DetectedObjects,
-      m_DetectedPolygonsDummy.at(0), m_DetectedPolygonsDummy.at(1),
-      m_DetectedPolygonsDummy.at(2), m_DetectedPolygonsDummy.at(3),
-      m_DetectedPolygonsDummy.at(4), m_DetectedPolygonsActual.at(0),
-      m_DetectedPolygonsActual.at(1), m_DetectedPolygonsActual.at(2),
-      m_DetectedPolygonsActual.at(3), m_DetectedPolygonsActual.at(4));
-
-  m_DetectedPolygonsAllMarkers.markers.clear();
-  m_DetectedPolygonsAllMarkers.markers.insert(
-      m_DetectedPolygonsAllMarkers.markers.end(),
-      m_DetectedPolygonsActual.at(0).markers.begin(),
-      m_DetectedPolygonsActual.at(0).markers.end());
-  m_DetectedPolygonsAllMarkers.markers.insert(
-      m_DetectedPolygonsAllMarkers.markers.end(),
-      m_DetectedPolygonsActual.at(1).markers.begin(),
-      m_DetectedPolygonsActual.at(1).markers.end());
-  m_DetectedPolygonsAllMarkers.markers.insert(
-      m_DetectedPolygonsAllMarkers.markers.end(),
-      m_DetectedPolygonsActual.at(2).markers.begin(),
-      m_DetectedPolygonsActual.at(2).markers.end());
-  m_DetectedPolygonsAllMarkers.markers.insert(
-      m_DetectedPolygonsAllMarkers.markers.end(),
-      m_DetectedPolygonsActual.at(3).markers.begin(),
-      m_DetectedPolygonsActual.at(3).markers.end());
-  m_DetectedPolygonsAllMarkers.markers.insert(
-      m_DetectedPolygonsAllMarkers.markers.end(),
-      m_DetectedPolygonsActual.at(4).markers.begin(),
-      m_DetectedPolygonsActual.at(4).markers.end());
-
-  visualization_msgs::MarkerArray all_circles;
-  for (unsigned int i = 0; i &lt; m_ObstacleTracking.m_InterestRegions.size();
-       i++) {
-    visualization_msgs::Marker circle_mkrs;
-    PlannerHNS::RosHelpers::CreateCircleMarker(
-        m_CurrentPos, m_ObstacleTracking.m_InterestRegions.at(i)-&gt;radius, i,
-        circle_mkrs);
-    all_circles.markers.push_back(circle_mkrs);
-  }
-
-  m_DetectedPolygonsAllMarkers.markers.insert(
-      m_DetectedPolygonsAllMarkers.markers.end(), all_circles.markers.begin(),
-      all_circles.markers.end());
-
-  pub_DetectedPolygonsRviz.publish(m_DetectedPolygonsAllMarkers);
-
-  jsk_recognition_msgs::BoundingBoxArray boxes_array;
-  boxes_array.header.frame_id = "map";
-  boxes_array.header.stamp = ros::Time();
-
-  for (unsigned int i = 0; i &lt; m_ObstacleTracking.m_DetectedObjects.size();
-       i++) {
-    jsk_recognition_msgs::BoundingBox box;
-    box.header.frame_id = "map";
-    box.header.stamp = ros::Time();
-    box.pose.position.x =
-        m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.x;
-    box.pose.position.y =
-        m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.y;
-    box.pose.position.z =
-        m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.z;
-
-    box.value = 0.9;
-
-    box.pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(
-        0, 0, UtilityHNS::UtilityH::SplitPositiveAngle(
-                  m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.a));
-    box.dimensions.x = m_ObstacleTracking.m_DetectedObjects.at(i).w;
-    box.dimensions.y = m_ObstacleTracking.m_DetectedObjects.at(i).l;
-    box.dimensions.z = m_ObstacleTracking.m_DetectedObjects.at(i).h;
-    boxes_array.boxes.push_back(box);
-  }
-
-  pub_TrackedObstaclesRviz.publish(boxes_array);
+void ContourTracker::VisualizeLocalTracking()
+{
+	PlannerHNS::RosHelpers::ConvertTrackedObjectsMarkers(m_CurrentPos, m_ObstacleTracking.m_DetectedObjects,
+				m_DetectedPolygonsDummy.at(0),
+				m_DetectedPolygonsDummy.at(1),
+				m_DetectedPolygonsDummy.at(2),
+				m_DetectedPolygonsDummy.at(3),
+				m_DetectedPolygonsDummy.at(4),
+				m_DetectedPolygonsActual.at(0),
+				m_DetectedPolygonsActual.at(1),
+				m_DetectedPolygonsActual.at(2),
+				m_DetectedPolygonsActual.at(3),
+				m_DetectedPolygonsActual.at(4));
+
+	PlannerHNS::RosHelpers::ConvertMatchingMarkers(m_ObstacleTracking.m_MatchList, m_MatchingInfoDummy.at(0), m_MatchingInfoActual.at(0), 0);
+
+	m_DetectedPolygonsAllMarkers.markers.clear();
+	m_DetectedPolygonsAllMarkers.markers.insert(m_DetectedPolygonsAllMarkers.markers.end(), m_DetectedPolygonsActual.at(0).markers.begin(), m_DetectedPolygonsActual.at(0).markers.end());
+	m_DetectedPolygonsAllMarkers.markers.insert(m_DetectedPolygonsAllMarkers.markers.end(), m_DetectedPolygonsActual.at(1).markers.begin(), m_DetectedPolygonsActual.at(1).markers.end());
+	m_DetectedPolygonsAllMarkers.markers.insert(m_DetectedPolygonsAllMarkers.markers.end(), m_DetectedPolygonsActual.at(2).markers.begin(), m_DetectedPolygonsActual.at(2).markers.end());
+	m_DetectedPolygonsAllMarkers.markers.insert(m_DetectedPolygonsAllMarkers.markers.end(), m_DetectedPolygonsActual.at(3).markers.begin(), m_DetectedPolygonsActual.at(3).markers.end());
+	m_DetectedPolygonsAllMarkers.markers.insert(m_DetectedPolygonsAllMarkers.markers.end(), m_DetectedPolygonsActual.at(4).markers.begin(), m_DetectedPolygonsActual.at(4).markers.end());
+
+
+	visualization_msgs::MarkerArray all_circles;
+	for(unsigned int i = 0; i &lt; m_ObstacleTracking.m_InterestRegions.size(); i++)
+	{
+		visualization_msgs::Marker circle_mkrs;
+		PlannerHNS::RosHelpers::CreateCircleMarker(m_CurrentPos, m_ObstacleTracking.m_InterestRegions.at(i)-&gt;radius, i ,circle_mkrs );
+		all_circles.markers.push_back(circle_mkrs);
+	}
+
+	m_DetectedPolygonsAllMarkers.markers.insert(m_DetectedPolygonsAllMarkers.markers.end(), all_circles.markers.begin(), all_circles.markers.end());
+
+	m_DetectedPolygonsAllMarkers.markers.insert(m_DetectedPolygonsAllMarkers.markers.end(), m_MatchingInfoActual.at(0).markers.begin(), m_MatchingInfoActual.at(0).markers.end());
+
+	pub_DetectedPolygonsRviz.publish(m_DetectedPolygonsAllMarkers);
+
+	jsk_recognition_msgs::BoundingBoxArray boxes_array;
+	boxes_array.header.frame_id = "map";
+	boxes_array.header.stamp  = ros::Time();
+
+	for(unsigned int i = 0 ; i &lt; m_ObstacleTracking.m_DetectedObjects.size(); i++)
+	{
+		jsk_recognition_msgs::BoundingBox box;
+		box.header.frame_id = "map";
+		box.header.stamp = ros::Time().now();
+		box.pose.position.x = m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.x;
+		box.pose.position.y = m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.y;
+		box.pose.position.z = m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.z;
+
+		box.value = 0.9;
+
+		box.pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(0, 0, m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.a);
+		box.dimensions.x = m_ObstacleTracking.m_DetectedObjects.at(i).l;
+		box.dimensions.y = m_ObstacleTracking.m_DetectedObjects.at(i).w;
+		box.dimensions.z = m_ObstacleTracking.m_DetectedObjects.at(i).h;
+		boxes_array.boxes.push_back(box);
+	}
+
+	pub_TrackedObstaclesRviz.publish(boxes_array);
 }
 
-void ContourTracker::MainLoop() {
-  ros::Rate loop_rate(25);
-
-  PlannerHNS::WayPoint prevState, state_change;
-
-  while (ros::ok()) {
-    ros::spinOnce();
-
-    if (bNewClusters) {
-      m_ObstacleTracking.DoOneStep(m_CurrentPos, m_OriginalClusters,
-                                   m_Params.trackingType);
-
-      m_OutPutResults.objects.clear();
-      autoware_msgs::DetectedObject obj;
-      for (unsigned int i = 0; i &lt; m_ObstacleTracking.m_DetectedObjects.size();
-           i++) {
-        obj.id = m_ObstacleTracking.m_DetectedObjects.at(i).id;
-        obj.label = m_ObstacleTracking.m_DetectedObjects.at(i).label;
-        obj.dimensions.x = m_ObstacleTracking.m_DetectedObjects.at(i).l;
-        obj.dimensions.y = m_ObstacleTracking.m_DetectedObjects.at(i).w;
-        obj.dimensions.z = m_ObstacleTracking.m_DetectedObjects.at(i).h;
-
-        obj.pose.position.x =
-            m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.x;
-        obj.pose.position.y =
-            m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.y;
-        obj.pose.position.z =
-            m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.z;
-
-        obj.pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(
-            0, 0, UtilityHNS::UtilityH::SplitPositiveAngle(
-                      m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.a));
-
-        geometry_msgs::Point32 p;
-        obj.convex_hull.polygon.points.clear();
-
-        for (unsigned int j = 0;
-             j &lt; m_ObstacleTracking.m_DetectedObjects.at(i).contour.size();
-             j++) {
-          p.x = m_ObstacleTracking.m_DetectedObjects.at(i).contour.at(j).x;
-          p.y = m_ObstacleTracking.m_DetectedObjects.at(i).contour.at(j).y;
-          p.z = m_ObstacleTracking.m_DetectedObjects.at(i).contour.at(j).z;
-          obj.convex_hull.polygon.points.push_back(p);
-        }
-
-        m_OutPutResults.objects.push_back(obj);
-      }
-
-      m_OutPutResults.header.frame_id = "map";
-      m_OutPutResults.header.stamp = ros::Time();
-
-      pub_AllTrackedObjects.publish(m_OutPutResults);
-
-      VisualizeLocalTracking();
-
-      bNewClusters = false;
-    }
-    loop_rate.sleep();
-  }
+void ContourTracker::LogAndSend()
+{
+	timespec log_t;
+	UtilityHNS::UtilityH::GetTickCount(log_t);
+	std::ostringstream dataLine;
+	std::ostringstream dataLineToOut;
+	dataLine &lt;&lt; UtilityHNS::UtilityH::GetLongTime(log_t) &lt;&lt;"," &lt;&lt; m_dt &lt;&lt; "," &lt;&lt;
+			m_ObstacleTracking.m_DetectedObjects.size() &lt;&lt; "," &lt;&lt;
+			m_OriginalClusters.size() &lt;&lt; "," &lt;&lt;
+			m_ObstacleTracking.m_DetectedObjects.size() - m_OriginalClusters.size() &lt;&lt; "," &lt;&lt;
+			m_nOriginalPoints &lt;&lt; "," &lt;&lt;
+			m_nContourPoints&lt;&lt; "," &lt;&lt;
+			m_FilteringTime&lt;&lt; "," &lt;&lt;
+			m_PolyEstimationTime&lt;&lt; "," &lt;&lt;
+			m_tracking_time&lt;&lt; "," &lt;&lt;
+			m_tracking_time+m_FilteringTime+m_PolyEstimationTime&lt;&lt; ",";
+	m_LogData.push_back(dataLine.str());
+
+	//For Debugging
+//	cout &lt;&lt; "dt: " &lt;&lt; m_dt &lt;&lt; endl;
+//	cout &lt;&lt; "num_Tracked_Objects: " &lt;&lt; m_ObstacleTracking.m_DetectedObjects.size() &lt;&lt; endl;
+//	cout &lt;&lt; "num_new_objects: " &lt;&lt; m_OriginalClusters.size() &lt;&lt; endl;
+//	cout &lt;&lt; "num_matched_objects: " &lt;&lt; m_ObstacleTracking.m_DetectedObjects.size() - m_OriginalClusters.size() &lt;&lt; endl;
+//	cout &lt;&lt; "num_Cluster_Points: " &lt;&lt; m_nOriginalPoints &lt;&lt; endl;
+//	cout &lt;&lt; "num_Contour_Points: " &lt;&lt; m_nContourPoints &lt;&lt; endl;
+//	cout &lt;&lt; "t_filtering : " &lt;&lt; m_FilteringTime &lt;&lt; endl;
+//	cout &lt;&lt; "t_poly_calc : " &lt;&lt; m_PolyEstimationTime &lt;&lt; endl;
+//	cout &lt;&lt; "t_Tracking : " &lt;&lt; m_tracking_time &lt;&lt; endl;
+//	cout &lt;&lt; "t_total : " &lt;&lt; m_tracking_time+m_FilteringTime+m_PolyEstimationTime &lt;&lt; endl;
+//	cout &lt;&lt; endl;
+
+	m_OutPutResults.objects.clear();
+	autoware_msgs::DetectedObject obj;
+	for(unsigned int i = 0 ; i &lt;m_ObstacleTracking.m_DetectedObjects.size(); i++)
+	{
+		PlannerHNS::RosHelpers::ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(m_ObstacleTracking.m_DetectedObjects.at(i), m_Params.bEnableSimulation, obj);
+		m_OutPutResults.objects.push_back(obj);
+	}
+
+	m_OutPutResults.header.frame_id = "map";
+	m_OutPutResults.header.stamp  = ros::Time();
+
+	pub_AllTrackedObjects.publish(m_OutPutResults);
+}
+
+void ContourTracker::MainLoop()
+{
+	ros::Rate loop_rate(50);
+
+	while (ros::ok())
+	{
+		ReadCommonParams();
+
+		if(bVectorMapCheck &amp;&amp; m_MapType == PlannerHNS::MAP_KML_FILE &amp;&amp; !bMap)
+		{
+			PlannerHNS::MappingHelpers::LoadKML(m_MapPath, m_Map);
+			if(m_Map.roadSegments.size() &gt; 0)
+			{
+				bMap = true;
+				std::cout &lt;&lt; " ******* Map Is Loaded successfully from the tracker !! " &lt;&lt; std::endl;
+			}
+		}
+		else if (bVectorMapCheck &amp;&amp; m_MapType == PlannerHNS::MAP_FOLDER &amp;&amp; !bMap)
+		{
+			PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_MapPath, m_Map, true);
+			if(m_Map.roadSegments.size() &gt; 0)
+				bMap = true;
+		}
+
+		ros::spinOnce();
+		loop_rate.sleep();
+	}
+
 }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\MappingHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\MappingHelpers.h" added_lines="1" deleted_lines="1">
				<diff>@@ -53,7 +53,7 @@ public:
 	static TiXmlElement* GetHeadElement(TiXmlElement* pMainElem);
 	static TiXmlElement* GetDataFolder(const std::string&amp; folderName, TiXmlElement* pMainElem);
 
-
+	static std::vector&lt;Lane*&gt; GetClosestLanesFast(const WayPoint&amp; center, RoadNetwork&amp; map, const double&amp; distance);
 	static Lane* GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0, const bool bDirectionBased = true);
 	static std::vector&lt;Lane*&gt; GetClosestLanesListFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 2.0, const bool bDirectionBased = true);
 	static Lane* GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlanningHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlanningHelpers.h" added_lines="2" deleted_lines="0">
				<diff>@@ -48,6 +48,8 @@ public:
 
 	static bool GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectories, const WayPoint&amp; p, const double&amp; searchDistance, RelativeInfo&amp; info);
 
+	static bool GetRelativeInfoLimited(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex = 0);
+
 	/**
 	 * @brief Find point on the trajectory after initial relative point with specific distance
 	 * @param trajectory list of waypoints
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\RoadNetwork.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\RoadNetwork.h" added_lines="30" deleted_lines="0">
				<diff>@@ -385,6 +385,9 @@ public:
 	std::vector&lt;WayPoint*&gt; pBacks;
 	std::vector&lt;std::pair&lt;ACTION_TYPE, double&gt; &gt; actionCost;
 
+	int			originalMapID;
+	int			gid;
+
 	WayPoint()
 	{
 		id = 0;
@@ -405,6 +408,9 @@ public:
 		state = INITIAL_STATE;
 		beh_state = BEH_STOPPING_STATE;
 		iOriginalIndex = 0;
+
+		gid = 0;
+		originalMapID = -1;
 	}
 
 	WayPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
@@ -432,6 +438,9 @@ public:
 		iOriginalIndex = 0;
 		state = INITIAL_STATE;
 		beh_state = BEH_STOPPING_STATE;
+
+		gid = 0;
+		originalMapID = -1;
 	}
 };
 
@@ -446,6 +455,9 @@ public:
 	int iGlobalPath;
 	WayPoint perp_point;
 	double angle_diff; // degrees
+	bool bBefore;
+	bool bAfter;
+	double after_angle;
 
 	RelativeInfo()
 	{
@@ -456,6 +468,9 @@ public:
 		iBack = 0;
 		iGlobalPath = 0;
 		angle_diff = 0;
+		after_angle = 0;
+		bBefore = false;
+		bAfter = false;
 	}
 };
 
@@ -740,6 +755,14 @@ public:
 	bool bDirection;
 	bool bVelocity;
 	int acceleration;
+
+	int acceleration_desc;
+	double acceleration_raw;
+	LIGHT_INDICATOR indicator_state;
+
+	int originalID;
+	BEH_STATE_TYPE behavior_state;
+
 	DetectedObject()
 	{
 		bDirection = false;
@@ -754,6 +777,13 @@ public:
 		predicted_behavior = INITIAL_STATE;
 		actual_speed = 0;
 		actual_yaw = 0;
+
+		acceleration_desc = 0;
+		acceleration_raw = 0.0;
+		indicator_state = INDICATOR_NONE;
+
+		originalID = -1;
+		behavior_state = BEH_STOPPING_STATE;
 	}
 
 };
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" added_lines="21" deleted_lines="0">
				<diff>@@ -849,6 +849,27 @@ WayPoint* MappingHelpers::GetClosestBackWaypointFromMap(const WayPoint&amp; pos, Roa
 		return &amp;pLane-&gt;points.at(closest_index);
 }
 
+std::vector&lt;Lane*&gt; MappingHelpers::GetClosestLanesFast(const WayPoint&amp; center, RoadNetwork&amp; map, const double&amp; distance)
+{
+	vector&lt;Lane*&gt; lanesList;
+	for(unsigned int j=0; j&lt; map.roadSegments.size(); j ++)
+	{
+		for(unsigned int k=0; k&lt; map.roadSegments.at(j).Lanes.size(); k ++)
+		{
+			Lane* pL = &amp;map.roadSegments.at(j).Lanes.at(k);
+			int index = PlanningHelpers::GetClosestNextPointIndexFast(pL-&gt;points, center);
+
+			if(index &lt; 0 || index &gt;= pL-&gt;points.size()) continue;
+
+			double d = hypot(pL-&gt;points.at(index).pos.y - center.pos.y, pL-&gt;points.at(index).pos.x - center.pos.x);
+			if(d &lt;= distance)
+				lanesList.push_back(pL);
+		}
+	}
+
+	return lanesList;
+}
+
 Lane* MappingHelpers::GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance, const bool bDirectionBased)
 {
 	vector&lt;pair&lt;double, Lane*&gt; &gt; laneLinksList;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" added_lines="170" deleted_lines="0">
				<diff>@@ -163,6 +163,176 @@ bool PlanningHelpers::GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, c
 	return true;
 }
 
+bool PlanningHelpers::GetRelativeInfoLimited(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex )
+{
+	if(trajectory.size() &lt; 2) return false;
+
+	WayPoint p0, p1;
+
+	if(trajectory.size()==2)
+	{
+		vector&lt;WayPoint&gt; _trajectory;
+		p0 = trajectory.at(0);
+		p1 = p0;
+		p1 = WayPoint((trajectory.at(0).pos.x+trajectory.at(1).pos.x)/2.0,
+					  (trajectory.at(0).pos.y+trajectory.at(1).pos.y)/2.0,
+					  (trajectory.at(0).pos.z+trajectory.at(1).pos.z)/2.0, trajectory.at(0).pos.a);
+		_trajectory.push_back(p0);
+		_trajectory.push_back(p1);
+		_trajectory.push_back(trajectory.at(0));
+
+		info.iFront = GetClosestNextPointIndexFast(_trajectory, p, prevIndex);
+		if(info.iFront &gt; 0)
+			info.iBack = info.iFront -1;
+		else
+			info.iBack = 0;
+
+		if(info.iFront == 0)
+		{
+			p0 = _trajectory.at(info.iFront);
+			p1 = _trajectory.at(info.iFront+1);
+		}
+		else if(info.iFront &gt; 0 &amp;&amp; info.iFront &lt; _trajectory.size()-1)
+		{
+			p0 = _trajectory.at(info.iFront-1);
+			p1 = _trajectory.at(info.iFront);
+		}
+		else
+		{
+			p0 = _trajectory.at(info.iFront-1);
+			p1 = WayPoint((p0.pos.x+_trajectory.at(info.iFront).pos.x)/2.0, (p0.pos.y+_trajectory.at(info.iFront).pos.y)/2.0, (p0.pos.z+_trajectory.at(info.iFront).pos.z)/2.0, p0.pos.a);
+		}
+
+		WayPoint prevWP = p0;
+		Mat3 rotationMat(-p1.pos.a);
+		Mat3 translationMat(-p.pos.x, -p.pos.y);
+		Mat3 invRotationMat(p1.pos.a);
+		Mat3 invTranslationMat(p.pos.x, p.pos.y);
+
+		p0.pos = translationMat*p0.pos;
+		p0.pos = rotationMat*p0.pos;
+
+		p1.pos = translationMat*p1.pos;
+		p1.pos = rotationMat*p1.pos;
+
+		double m = (p1.pos.y-p0.pos.y)/(p1.pos.x-p0.pos.x);
+		info.perp_distance = p1.pos.y - m*p1.pos.x; // solve for x = 0
+
+		if(isnan(info.perp_distance) || isinf(info.perp_distance)) info.perp_distance = 0;
+
+		info.to_front_distance = fabs(p1.pos.x); // distance on the x axes
+
+		info.perp_point = p1;
+		info.perp_point.pos.x = 0; // on the same y axis of the car
+		info.perp_point.pos.y = info.perp_distance; //perp distance between the car and the _trajectory
+
+		info.perp_point.pos = invRotationMat  * info.perp_point.pos;
+		info.perp_point.pos = invTranslationMat  * info.perp_point.pos;
+
+		info.from_back_distance = hypot(info.perp_point.pos.y - prevWP.pos.y, info.perp_point.pos.x - prevWP.pos.x);
+
+		info.angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(p1.pos.a, p.pos.a)*RAD2DEG;
+
+		info.bAfter = false;
+		info.bBefore = false;
+
+		if(info.iFront == 0)
+		{
+			info.bBefore = true;
+		}
+		else if(info.iFront == _trajectory.size()-1)
+		{
+			int s = _trajectory.size();
+			double angle_befor_last = UtilityH::FixNegativeAngle(atan2(_trajectory.at(s-2).pos.y - _trajectory.at(s-1).pos.y, _trajectory.at(s-2).pos.x - _trajectory.at(s-1).pos.x));
+			double angle_from_perp = UtilityH::FixNegativeAngle(atan2(info.perp_point.pos.y - _trajectory.at(s-1).pos.y, info.perp_point.pos.x - _trajectory.at(s-1).pos.x));
+			double diff_last_perp = UtilityH::AngleBetweenTwoAnglesPositive(angle_befor_last, angle_from_perp);
+			info.after_angle = diff_last_perp;
+			if(diff_last_perp &gt; M_PI_2)
+			{
+				info.bAfter = true;
+			}
+
+		}
+	}
+	else
+	{
+		info.iFront = GetClosestNextPointIndexFast(trajectory, p, prevIndex);
+		if(info.iFront &gt; 0)
+			info.iBack = info.iFront -1;
+		else
+			info.iBack = 0;
+
+		if(info.iFront == 0)
+		{
+			p0 = trajectory.at(info.iFront);
+			p1 = trajectory.at(info.iFront+1);
+		}
+		else if(info.iFront &gt; 0 &amp;&amp; info.iFront &lt; trajectory.size()-1)
+		{
+			p0 = trajectory.at(info.iFront-1);
+			p1 = trajectory.at(info.iFront);
+		}
+		else
+		{
+			p0 = trajectory.at(info.iFront-1);
+			p1 = WayPoint((p0.pos.x+trajectory.at(info.iFront).pos.x)/2.0, (p0.pos.y+trajectory.at(info.iFront).pos.y)/2.0, (p0.pos.z+trajectory.at(info.iFront).pos.z)/2.0, p0.pos.a);
+		}
+
+		WayPoint prevWP = p0;
+		Mat3 rotationMat(-p1.pos.a);
+		Mat3 translationMat(-p.pos.x, -p.pos.y);
+		Mat3 invRotationMat(p1.pos.a);
+		Mat3 invTranslationMat(p.pos.x, p.pos.y);
+
+		p0.pos = translationMat*p0.pos;
+		p0.pos = rotationMat*p0.pos;
+
+		p1.pos = translationMat*p1.pos;
+		p1.pos = rotationMat*p1.pos;
+
+		double m = (p1.pos.y-p0.pos.y)/(p1.pos.x-p0.pos.x);
+		info.perp_distance = p1.pos.y - m*p1.pos.x; // solve for x = 0
+
+		if(isnan(info.perp_distance) || isinf(info.perp_distance)) info.perp_distance = 0;
+
+		info.to_front_distance = fabs(p1.pos.x); // distance on the x axes
+
+		info.perp_point = p1;
+		info.perp_point.pos.x = 0; // on the same y axis of the car
+		info.perp_point.pos.y = info.perp_distance; //perp distance between the car and the trajectory
+
+		info.perp_point.pos = invRotationMat  * info.perp_point.pos;
+		info.perp_point.pos = invTranslationMat  * info.perp_point.pos;
+
+		info.from_back_distance = hypot(info.perp_point.pos.y - prevWP.pos.y, info.perp_point.pos.x - prevWP.pos.x);
+
+		info.angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(p1.pos.a, p.pos.a)*RAD2DEG;
+
+		info.bAfter = false;
+		info.bBefore = false;
+
+		if(info.iFront == 0)
+		{
+			info.bBefore = true;
+		}
+		else if(info.iFront == trajectory.size()-1)
+		{
+			int s = trajectory.size();
+			double angle_befor_last = UtilityH::FixNegativeAngle(atan2(trajectory.at(s-2).pos.y - trajectory.at(s-1).pos.y, trajectory.at(s-2).pos.x - trajectory.at(s-1).pos.x));
+			double angle_from_perp = UtilityH::FixNegativeAngle(atan2(info.perp_point.pos.y - trajectory.at(s-1).pos.y, info.perp_point.pos.x - trajectory.at(s-1).pos.x));
+			double diff_last_perp = UtilityH::AngleBetweenTwoAnglesPositive(angle_befor_last, angle_from_perp);
+			info.after_angle = diff_last_perp;
+			if(diff_last_perp &gt; M_PI_2)
+			{
+				info.bAfter = true;
+			}
+
+		}
+	}
+
+	return true;
+}
+
 bool PlanningHelpers::GetThreePointsInfo(const WayPoint&amp; p0, const WayPoint&amp; p1, const WayPoint&amp; p2, WayPoint&amp; perp_p, double&amp; long_d, double lat_d)
 {
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_ros_helpers\op_RosHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_ros_helpers\op_RosHelpers.h" added_lines="17" deleted_lines="1">
				<diff>@@ -36,6 +36,7 @@
 #include &lt;pcl/point_types.h&gt;
 
 #include "autoware_msgs/CloudClusterArray.h"
+#include "autoware_msgs/DetectedObjectArray.h"
 
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "autoware_msgs/LaneArray.h"
@@ -203,11 +204,15 @@ public:
 			visualization_msgs::MarkerArray&amp; polygons,
 			visualization_msgs::MarkerArray&amp; trajectories);
 
+	static void InitMatchingMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; connections);
+
+	static void ConvertMatchingMarkers(const std::vector&lt;std::pair&lt;PlannerHNS::WayPoint, PlannerHNS::WayPoint&gt; &gt;&amp; match_list,
+			visualization_msgs::MarkerArray&amp; tracked_traj_d, visualization_msgs::MarkerArray&amp; tracked_traj, int start_id=0);
 
 	/**
 	 * Used
 	 */
-	static void ConvertTrackedObjectsMarkers(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
+	static int ConvertTrackedObjectsMarkers(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
 			visualization_msgs::MarkerArray&amp; centers_d,
 			visualization_msgs::MarkerArray&amp; dirs_d,
 			visualization_msgs::MarkerArray&amp; text_info_d,
@@ -249,6 +254,17 @@ public:
 	static void ConvertFromPlannerObstaclesToAutoware(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
 			visualization_msgs::MarkerArray&amp; detectedPolygons);
 
+	static void ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, autoware_msgs::lane&amp; trajectory , const unsigned int&amp; iStart = 0);
+	static void ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path, autoware_msgs::lane&amp; trajectory);
+	static void ConvertFromAutowareLaneToLocalLane(const autoware_msgs::lane&amp; trajectory, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path);
+	static void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const autoware_msgs::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray);
+	static void createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array , visualization_msgs::MarkerArray&amp; markerArray);
+	static void createGlobalLaneArrayOrientationMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array , visualization_msgs::MarkerArray&amp; markerArray);
+	static void GetTrafficLightForVisualization(std::vector&lt;PlannerHNS::TrafficLight&gt;&amp; lights, visualization_msgs::MarkerArray&amp; markerArray);
+
+	static void ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(const autoware_msgs::DetectedObject&amp; det_obj, PlannerHNS::DetectedObject&amp; obj);
+	static void ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(const PlannerHNS::DetectedObject&amp; det_obj, const bool&amp; bSimulationMode, autoware_msgs::DetectedObject&amp; obj);
+
 	static PlannerHNS::SHIFT_POS ConvertShiftFromAutowareToPlannerH(const PlannerHNS::AUTOWARE_SHIFT_POS&amp; shift);
 	static PlannerHNS::AUTOWARE_SHIFT_POS ConvertShiftFromPlannerHToAutoware(const PlannerHNS::SHIFT_POS&amp; shift);
 	static PlannerHNS::AutowareBehaviorState ConvertBehaviorStateFromPlannerHToAutoware(const PlannerHNS::BehaviorState&amp; beh);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\op_RosHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\op_RosHelpers.cpp" added_lines="438" deleted_lines="10">
				<diff>@@ -118,7 +118,44 @@ void RosHelpers::InitMarkers(const int&amp; nMarkers,
 	}
 }
 
-void RosHelpers::ConvertTrackedObjectsMarkers(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
+void RosHelpers::InitMatchingMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; connections)
+{
+	connections.markers.clear();
+	for(int i=0; i&lt;nMarkers; i++)
+	{
+		visualization_msgs::Marker mkr = CreateGenMarker(0,0,0,0,1,1,1,1,i,"matching_connections", visualization_msgs::Marker::LINE_STRIP);
+		connections.markers.push_back(mkr);
+	}
+}
+
+void RosHelpers::ConvertMatchingMarkers(const std::vector&lt;std::pair&lt;PlannerHNS::WayPoint, PlannerHNS::WayPoint&gt; &gt;&amp; match_list,
+		visualization_msgs::MarkerArray&amp; tracked_traj_d, visualization_msgs::MarkerArray&amp; tracked_traj, int start_id)
+{
+
+	tracked_traj = tracked_traj_d;
+
+	for(unsigned int i = 0; i &lt; match_list.size(); i++)
+	{
+		visualization_msgs::Marker match_mkr = CreateGenMarker(0,0,0,0,1,0,0,0.2, start_id+i,"matching_connections", visualization_msgs::Marker::LINE_STRIP);
+		geometry_msgs::Point point;
+		point.x = match_list.at(i).first.pos.x;
+		point.y = match_list.at(i).first.pos.y;
+		point.z = match_list.at(i).first.pos.z;
+		match_mkr.points.push_back(point);
+
+		point.x = match_list.at(i).second.pos.x;
+		point.y = match_list.at(i).second.pos.y;
+		point.z = match_list.at(i).second.pos.z;
+		match_mkr.points.push_back(point);
+
+		if(i &lt; tracked_traj.markers.size())
+			tracked_traj.markers.at(i) = match_mkr;
+		else
+			tracked_traj.markers.push_back(match_mkr);
+	}
+}
+
+int RosHelpers::ConvertTrackedObjectsMarkers(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
 		visualization_msgs::MarkerArray&amp; centers_d,
 		visualization_msgs::MarkerArray&amp; dirs_d,
 		visualization_msgs::MarkerArray&amp; text_info_d,
@@ -131,6 +168,7 @@ void RosHelpers::ConvertTrackedObjectsMarkers(const PlannerHNS::WayPoint&amp; currSt
 		visualization_msgs::MarkerArray&amp; tracked_traj)
 {
 
+	int i_next_id = 0;
 	centers = centers_d;
 	dirs = dirs_d;
 	text_info = text_info_d;
@@ -145,41 +183,54 @@ void RosHelpers::ConvertTrackedObjectsMarkers(const PlannerHNS::WayPoint&amp; currSt
 		visualization_msgs::Marker center_mkr = CreateGenMarker(trackedObstacles.at(i).center.pos.x,trackedObstacles.at(i).center.pos.y,trackedObstacles.at(i).center.pos.z,
 				trackedObstacles.at(i).center.pos.a,1,0,0,0.5,i,"CenterMarker", visualization_msgs::Marker::SPHERE);
 		if(i &lt; centers.markers.size())
+		{
+			center_mkr.id = centers.markers.at(i).id;
 			centers.markers.at(i) = center_mkr;
+		}
 		else
 			centers.markers.push_back(center_mkr);
 
+		//Directions
 		if(trackedObstacles.at(i).bDirection)
 		{
 			visualization_msgs::Marker dir_mkr = CreateGenMarker(trackedObstacles.at(i).center.pos.x,trackedObstacles.at(i).center.pos.y,trackedObstacles.at(i).center.pos.z+0.5,
-					trackedObstacles.at(i).center.pos.a,0,1,0,0.1,centers.markers.size()+i,"Directions", visualization_msgs::Marker::ARROW);
+					trackedObstacles.at(i).center.pos.a,0,1,0,0.3,centers.markers.size()+i,"Directions", visualization_msgs::Marker::ARROW);
 			dir_mkr.scale.x = 0.4;
 			if(i &lt; dirs.markers.size())
+			{
+				dir_mkr.id = dirs.markers.at(i).id;
 				dirs.markers.at(i) = dir_mkr;
+			}
 			else
 				dirs.markers.push_back(dir_mkr);
 		}
 
 
+		//Text
 		visualization_msgs::Marker text_mkr;
-		if(speed &gt; 3.0)
-			text_mkr = CreateGenMarker(trackedObstacles.at(i).center.pos.x+0.5,trackedObstacles.at(i).center.pos.y+0.5,trackedObstacles.at(i).center.pos.z+1,
-					trackedObstacles.at(i).center.pos.a,1,0,0,0.75,centers.markers.size()*2+i,"InfoText", visualization_msgs::Marker::TEXT_VIEW_FACING);
-		else
-			text_mkr = CreateGenMarker(trackedObstacles.at(i).center.pos.x+0.5,trackedObstacles.at(i).center.pos.y+0.5,trackedObstacles.at(i).center.pos.z+1,
-								trackedObstacles.at(i).center.pos.a,1,1,1,0.75,centers.markers.size()*2+i,"InfoText", visualization_msgs::Marker::TEXT_VIEW_FACING);
+//		if(speed &gt; 3.0)
+//			text_mkr = CreateGenMarker(trackedObstacles.at(i).center.pos.x+0.5,trackedObstacles.at(i).center.pos.y+0.5,trackedObstacles.at(i).center.pos.z+1,
+//					trackedObstacles.at(i).center.pos.a,1,0,0,0.75,centers.markers.size()*2+i,"InfoText", visualization_msgs::Marker::TEXT_VIEW_FACING);
+//		else
+		text_mkr = CreateGenMarker(trackedObstacles.at(i).center.pos.x+0.5,trackedObstacles.at(i).center.pos.y+0.5,trackedObstacles.at(i).center.pos.z+1,
+							trackedObstacles.at(i).center.pos.a,1,1,1,1.2,centers.markers.size()*2+i,"InfoText", visualization_msgs::Marker::TEXT_VIEW_FACING);
 
 		std::ostringstream str_out;
-		str_out &lt;&lt; trackedObstacles.at(i).id &lt;&lt; " ( " &lt;&lt; speed &lt;&lt; " )";
+		//str_out &lt;&lt; trackedObstacles.at(i).id &lt;&lt; " ( " &lt;&lt; speed &lt;&lt; " )" &lt;&lt; " (" &lt;&lt; trackedObstacles.at(i).distance_to_center &lt;&lt; ")";
+		str_out &lt;&lt; trackedObstacles.at(i).id &lt;&lt; " (" &lt;&lt; speed &lt;&lt; ")";
 		text_mkr.text = str_out.str();
 
 		if(i &lt; text_info.markers.size())
+		{
+			text_mkr.id = text_info.markers.at(i).id;
 			text_info.markers.at(i) = text_mkr;
+		}
 		else
 			text_info.markers.push_back(text_mkr);
 
 
-		visualization_msgs::Marker poly_mkr = CreateGenMarker(0,0,0,0, 0,0,1,0.1,centers.markers.size()*3+i,"detected_polygons", visualization_msgs::Marker::LINE_STRIP);
+		//Polygons
+		visualization_msgs::Marker poly_mkr = CreateGenMarker(0,0,0,0, 1,0.25,0.25,0.1,centers.markers.size()*3+i,"detected_polygons", visualization_msgs::Marker::LINE_STRIP);
 
 		for(unsigned int p = 0; p &lt; trackedObstacles.at(i).contour.size(); p++)
 		{
@@ -200,11 +251,15 @@ void RosHelpers::ConvertTrackedObjectsMarkers(const PlannerHNS::WayPoint&amp; currSt
 		}
 
 		if(i &lt; polygons.markers.size())
+		{
+			poly_mkr.id =  polygons.markers.at(i).id;
 			polygons.markers.at(i) = poly_mkr;
+		}
 		else
 			polygons.markers.push_back(poly_mkr);
 
 
+		//Trajectories
 		visualization_msgs::Marker traj_mkr = CreateGenMarker(0,0,0,0,1,1,0,0.1,centers.markers.size()*4+i,"tracked_trajectories", visualization_msgs::Marker::LINE_STRIP);
 
 		for(unsigned int p = 0; p &lt; trackedObstacles.at(i).centers_list.size(); p++)
@@ -218,11 +273,18 @@ void RosHelpers::ConvertTrackedObjectsMarkers(const PlannerHNS::WayPoint&amp; currSt
 
 
 		if(i &lt; tracked_traj.markers.size())
+		{
+			traj_mkr.id = tracked_traj.markers.at(i).id ;
 			tracked_traj.markers.at(i) = traj_mkr;
+		}
 		else
 			tracked_traj.markers.push_back(traj_mkr);
 
+		i_next_id = traj_mkr.id;
+
 	}
+
+	return i_next_id +1;
 }
 
 void RosHelpers::CreateCircleMarker(const PlannerHNS::WayPoint&amp; _center, const double&amp; radius, const int&amp; start_id, visualization_msgs::Marker&amp; circle_points)
@@ -986,6 +1048,372 @@ PlannerHNS::AutowareBehaviorState RosHelpers::ConvertBehaviorStateFromPlannerHTo
 
 }
 
+void RosHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, autoware_msgs::lane&amp; trajectory , const unsigned int&amp; iStart)
+{
+	trajectory.waypoints.clear();
+
+	for(unsigned int i = iStart; i &lt; path.size(); i++)
+	{
+		autoware_msgs::waypoint wp;
+		wp.pose.pose.position.x = path.at(i).pos.x;
+		wp.pose.pose.position.y = path.at(i).pos.y;
+		wp.pose.pose.position.z = path.at(i).pos.z;
+		wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(UtilityHNS::UtilityH::SplitPositiveAngle(path.at(i).pos.a));
+
+		wp.twist.twist.linear.x = path.at(i).v;
+		wp.lane_id = path.at(i).laneId;
+		wp.stop_line_id = path.at(i).stopLineID;
+		wp.left_lane_id = path.at(i).LeftLaneId;
+		wp.right_lane_id = path.at(i).RightLaneId;
+		wp.time_cost = path.at(i).timeCost;
+
+		wp.gid = path.at(i).gid;
+
+		//wp.cost = path.at(i).cost;
+		wp.cost = 0;
+
+		if(path.at(i).actionCost.size()&gt;0)
+		{
+			wp.direction = path.at(i).actionCost.at(0).first;
+			wp.cost += path.at(i).actionCost.at(0).second;
+		}
+
+		trajectory.waypoints.push_back(wp);
+	}
+}
+
+void RosHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path, autoware_msgs::lane&amp; trajectory)
+{
+	trajectory.waypoints.clear();
+
+	for(unsigned int i=0; i &lt; path.size(); i++)
+	{
+		autoware_msgs::waypoint wp;
+		wp.pose.pose.position.x = path.at(i).x;
+		wp.pose.pose.position.y = path.at(i).y;
+		wp.pose.pose.position.z = path.at(i).z;
+		wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(UtilityHNS::UtilityH::SplitPositiveAngle(path.at(i).a));
+
+		trajectory.waypoints.push_back(wp);
+	}
+}
+
+void RosHelpers::ConvertFromAutowareLaneToLocalLane(const autoware_msgs::lane&amp; trajectory, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
+{
+	path.clear();
+
+	for(unsigned int i=0; i &lt; trajectory.waypoints.size(); i++)
+	{
+		PlannerHNS::WayPoint wp;
+		wp.pos.x = trajectory.waypoints.at(i).pose.pose.position.x;
+		wp.pos.y = trajectory.waypoints.at(i).pose.pose.position.y;
+		wp.pos.z = trajectory.waypoints.at(i).pose.pose.position.z;
+		wp.pos.a = tf::getYaw(trajectory.waypoints.at(i).pose.pose.orientation);
+
+		wp.v = trajectory.waypoints.at(i).twist.twist.linear.x;
+
+		wp.gid = trajectory.waypoints.at(i).gid;
+		wp.laneId = trajectory.waypoints.at(i).lane_id;
+		wp.stopLineID = trajectory.waypoints.at(i).stop_line_id;
+		wp.LeftLaneId = trajectory.waypoints.at(i).left_lane_id;
+		wp.RightLaneId = trajectory.waypoints.at(i).right_lane_id;
+		wp.timeCost = trajectory.waypoints.at(i).time_cost;
+
+		if(trajectory.waypoints.at(i).direction == 0)
+			wp.bDir = PlannerHNS::FORWARD_DIR;
+		else if(trajectory.waypoints.at(i).direction == 1)
+			wp.bDir = PlannerHNS::FORWARD_LEFT_DIR;
+		else if(trajectory.waypoints.at(i).direction == 2)
+			wp.bDir = PlannerHNS::FORWARD_RIGHT_DIR;
+		else if(trajectory.waypoints.at(i).direction == 3)
+			wp.bDir = PlannerHNS::BACKWARD_DIR;
+		else if(trajectory.waypoints.at(i).direction == 4)
+			wp.bDir = PlannerHNS::BACKWARD_LEFT_DIR;
+		else if(trajectory.waypoints.at(i).direction == 5)
+			wp.bDir = PlannerHNS::BACKWARD_RIGHT_DIR;
+		else if(trajectory.waypoints.at(i).direction == 6)
+			wp.bDir = PlannerHNS::STANDSTILL_DIR;
+
+		wp.cost = trajectory.waypoints.at(i).cost;
+
+		path.push_back(wp);
+	}
+}
+
+void RosHelpers::createGlobalLaneArrayMarker(std_msgs::ColorRGBA color,
+		const autoware_msgs::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray)
+{
+  visualization_msgs::Marker lane_waypoint_marker;
+  lane_waypoint_marker.header.frame_id = "map";
+  lane_waypoint_marker.header.stamp = ros::Time();
+  lane_waypoint_marker.ns = "global_lane_array_marker";
+  lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
+  lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
+  lane_waypoint_marker.scale.x = 0.75;
+  lane_waypoint_marker.scale.y = 0.75;
+  lane_waypoint_marker.color = color;
+  lane_waypoint_marker.frame_locked = false;
+
+  int count = 0;
+  for (unsigned int i=0; i&lt;  lane_waypoints_array.lanes.size(); i++)
+  {
+    lane_waypoint_marker.points.clear();
+    lane_waypoint_marker.id = count;
+
+    for (unsigned int j=0; j &lt; lane_waypoints_array.lanes.at(i).waypoints.size(); j++)
+    {
+      geometry_msgs::Point point;
+      point = lane_waypoints_array.lanes.at(i).waypoints.at(j).pose.pose.position;
+      lane_waypoint_marker.points.push_back(point);
+    }
+    markerArray.markers.push_back(lane_waypoint_marker);
+    count++;
+  }
+
+}
+
+void RosHelpers::createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
+		, visualization_msgs::MarkerArray&amp; markerArray)
+{
+  visualization_msgs::MarkerArray tmp_marker_array;
+  // display by markers the velocity of each waypoint.
+  visualization_msgs::Marker velocity_marker;
+  velocity_marker.header.frame_id = "map";
+  velocity_marker.header.stamp = ros::Time();
+  velocity_marker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
+  velocity_marker.action = visualization_msgs::Marker::ADD;
+  //velocity_marker.scale.z = 0.4;
+  velocity_marker.color.a = 0.9;
+  velocity_marker.color.r = 1;
+  velocity_marker.color.g = 1;
+  velocity_marker.color.b = 1;
+  velocity_marker.frame_locked = false;
+
+  int count = 1;
+  for (unsigned int i=0; i&lt;  lane_waypoints_array.lanes.size(); i++)
+  {
+
+	  std::ostringstream str_count;
+	  str_count &lt;&lt; count;
+    velocity_marker.ns = "global_velocity_lane_" + str_count.str();
+    for (unsigned int j=0; j &lt; lane_waypoints_array.lanes.at(i).waypoints.size(); j++)
+    {
+      //std::cout &lt;&lt; _waypoints[i].GetX() &lt;&lt; " " &lt;&lt; _waypoints[i].GetY() &lt;&lt; " " &lt;&lt; _waypoints[i].GetZ() &lt;&lt; " " &lt;&lt; _waypoints[i].GetVelocity_kmh() &lt;&lt; std::endl;
+      velocity_marker.id = j;
+      geometry_msgs::Point relative_p;
+      relative_p.y = 0.5;
+      velocity_marker.pose.position = calcAbsoluteCoordinate(relative_p, lane_waypoints_array.lanes.at(i).waypoints.at(j).pose.pose);
+      velocity_marker.pose.position.z += 0.2;
+
+      // double to string
+      std::ostringstream str_out;
+      str_out &lt;&lt; lane_waypoints_array.lanes.at(i).waypoints.at(j).twist.twist.linear.x;
+      //std::string vel = str_out.str();
+      velocity_marker.text = str_out.str();//vel.erase(vel.find_first_of(".") + 2);
+
+      tmp_marker_array.markers.push_back(velocity_marker);
+    }
+    count++;
+  }
+
+  markerArray.markers.insert(markerArray.markers.end(), tmp_marker_array.markers.begin(),
+                                       tmp_marker_array.markers.end());
+}
+
+void RosHelpers::createGlobalLaneArrayOrientationMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
+		, visualization_msgs::MarkerArray&amp; markerArray)
+{
+  visualization_msgs::MarkerArray tmp_marker_array;
+  visualization_msgs::Marker lane_waypoint_marker;
+  lane_waypoint_marker.header.frame_id = "map";
+  lane_waypoint_marker.header.stamp = ros::Time();
+  lane_waypoint_marker.type = visualization_msgs::Marker::ARROW;
+  lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
+  lane_waypoint_marker.scale.x = 0.6;
+  lane_waypoint_marker.scale.y = 0.2;
+  lane_waypoint_marker.scale.z = 0.1;
+  lane_waypoint_marker.color.r = 1.0;
+  lane_waypoint_marker.color.a = 1.0;
+  //lane_waypoint_marker.frame_locked = false;
+
+  lane_waypoint_marker.ns = "global_lane_waypoint_orientation_marker";
+
+  int count = 1;
+  for (unsigned int i=0; i&lt;  lane_waypoints_array.lanes.size(); i++)
+  {
+//	  std::ostringstream str_ns;
+//	  str_ns &lt;&lt; "global_lane_waypoint_orientation_marker_";
+//	  str_ns &lt;&lt; i;
+//	 lane_waypoint_marker.ns = str_ns.str();
+
+    for (unsigned int j=0; j &lt; lane_waypoints_array.lanes.at(i).waypoints.size(); j++)
+    {
+    	lane_waypoint_marker.id = count;
+    	lane_waypoint_marker.pose = lane_waypoints_array.lanes.at(i).waypoints.at(j).pose.pose;
+
+    	if(lane_waypoints_array.lanes.at(i).waypoints.at(j).dtlane.dir == 1)
+    	{
+    		lane_waypoint_marker.color.r = 0.0;
+    		lane_waypoint_marker.color.g = 1.0;
+    		lane_waypoint_marker.color.b = 0.0;
+    		tmp_marker_array.markers.push_back(lane_waypoint_marker);
+    	}
+    	else if(lane_waypoints_array.lanes.at(i).waypoints.at(j).dtlane.dir == 2)
+    	{
+    		lane_waypoint_marker.color.r = 0.0;
+			lane_waypoint_marker.color.g = 0.0;
+			lane_waypoint_marker.color.b = 1.0;
+			tmp_marker_array.markers.push_back(lane_waypoint_marker);
+    	}
+    	else
+    	{
+
+    		if(lane_waypoints_array.lanes.at(i).waypoints.at(j).cost &gt;= 100)
+    		{
+    			lane_waypoint_marker.color.r = 1.0;
+				lane_waypoint_marker.color.g = 0.0;
+				lane_waypoint_marker.color.b = 0.0;
+				tmp_marker_array.markers.push_back(lane_waypoint_marker);
+    		}
+    		else
+    		{
+				lane_waypoint_marker.color.r = 0.0;
+				lane_waypoint_marker.color.g = 0.8;
+				lane_waypoint_marker.color.b = 0.0;
+				tmp_marker_array.markers.push_back(lane_waypoint_marker);
+    		}
+    	}
+
+
+      count++;
+    }
+  }
+
+  markerArray.markers.insert(markerArray.markers.end(), tmp_marker_array.markers.begin(),
+										   tmp_marker_array.markers.end());
+}
+
+void RosHelpers::GetTrafficLightForVisualization(std::vector&lt;PlannerHNS::TrafficLight&gt;&amp; lights, visualization_msgs::MarkerArray&amp; markerArray)
+{
+	markerArray.markers.clear();
+	for(unsigned int i=0; i&lt;lights.size(); i++)
+	{
+		if(lights.at(i).lightState == RED_LIGHT)
+		{
+			visualization_msgs::Marker mkr = CreateGenMarker(lights.at(i).pos.x,lights.at(i).pos.y,lights.at(i).pos.z,0,1,0,0,3,i,"traffic_light_visualize", visualization_msgs::Marker::SPHERE);
+			markerArray.markers.push_back(mkr);
+		}
+		else if(lights.at(i).lightState == GREEN_LIGHT)
+		{
+			visualization_msgs::Marker mkr = CreateGenMarker(lights.at(i).pos.x,lights.at(i).pos.y,lights.at(i).pos.z,0,0,1,0,3,i,"traffic_light_visualize", visualization_msgs::Marker::SPHERE);
+			markerArray.markers.push_back(mkr);
+		}
+	}
+}
+
+void RosHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(const autoware_msgs::DetectedObject&amp; det_obj, PlannerHNS::DetectedObject&amp; obj)
+{
+	obj.id = det_obj.id;
+	obj.label = det_obj.label;
+	obj.l = det_obj.dimensions.x;
+	obj.w = det_obj.dimensions.y;
+	obj.h = det_obj.dimensions.z;
+
+	obj.center.pos.x = det_obj.pose.position.x;
+	obj.center.pos.y = det_obj.pose.position.y;
+	obj.center.pos.z = det_obj.pose.position.z;
+	obj.center.pos.a = tf::getYaw(det_obj.pose.orientation);
+
+	obj.center.v = det_obj.velocity.linear.x;
+	obj.acceleration_raw = det_obj.velocity.linear.y;
+	obj.acceleration_desc = det_obj.velocity.linear.z;
+	obj.bVelocity = det_obj.velocity_reliable;
+	obj.bDirection = det_obj.pose_reliable;
+
+	if(det_obj.indicator_state == 0)
+		obj.indicator_state = PlannerHNS::INDICATOR_LEFT;
+	else if(det_obj.indicator_state == 1)
+		obj.indicator_state = PlannerHNS::INDICATOR_RIGHT;
+	else if(det_obj.indicator_state == 2)
+		obj.indicator_state = PlannerHNS::INDICATOR_BOTH;
+	else if(det_obj.indicator_state == 3)
+		obj.indicator_state = PlannerHNS::INDICATOR_NONE;
+
+	PlannerHNS::GPSPoint p;
+	obj.contour.clear();
+
+	for(unsigned int j=0; j &lt; det_obj.convex_hull.polygon.points.size(); j++)
+	{
+
+		p.x = det_obj.convex_hull.polygon.points.at(j).x;
+		p.y = det_obj.convex_hull.polygon.points.at(j).y;
+		p.z = det_obj.convex_hull.polygon.points.at(j).z;
+		obj.contour.push_back(p);
+	}
+
+	obj.predTrajectories.clear();
+
+	for(unsigned int j = 0 ; j &lt; det_obj.candidate_trajectories.lanes.size(); j++)
+	{
+		std::vector&lt;PlannerHNS::WayPoint&gt; _traj;
+		PlannerHNS::RosHelpers::ConvertFromAutowareLaneToLocalLane(det_obj.candidate_trajectories.lanes.at(j), _traj);
+		for(unsigned int k=0; k &lt; _traj.size(); k++)
+			_traj.at(k).collisionCost = det_obj.candidate_trajectories.lanes.at(j).cost;
+
+		obj.predTrajectories.push_back(_traj);
+	}
+}
+
+void RosHelpers::ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(const PlannerHNS::DetectedObject&amp; det_obj, const bool&amp; bSimulationMode, autoware_msgs::DetectedObject&amp; obj)
+{
+	if(bSimulationMode)
+		obj.id = det_obj.originalID;
+	else
+		obj.id = det_obj.id;
+
+	obj.label = det_obj.label;
+	obj.indicator_state = det_obj.indicator_state;
+	obj.dimensions.x = det_obj.l;
+	obj.dimensions.y = det_obj.w;
+	obj.dimensions.z = det_obj.h;
+
+	obj.pose.position.x = det_obj.center.pos.x;
+	obj.pose.position.y = det_obj.center.pos.y;
+	obj.pose.position.z = det_obj.center.pos.z;
+	obj.pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(0, 0, UtilityHNS::UtilityH::SplitPositiveAngle(det_obj.center.pos.a));
+
+	obj.velocity.linear.x = det_obj.center.v;
+	obj.velocity.linear.y = det_obj.acceleration_raw;
+	obj.velocity.linear.z = det_obj.acceleration_desc;
+	obj.velocity_reliable = det_obj.bVelocity;
+	obj.pose_reliable = det_obj.bDirection;
+
+	geometry_msgs::Point32 p;
+	obj.convex_hull.polygon.points.clear();
+
+	for(unsigned int j=0; j &lt; det_obj.contour.size(); j++)
+	{
+		p.x = det_obj.contour.at(j).x;
+		p.y = det_obj.contour.at(j).y;
+		p.z = det_obj.contour.at(j).z;
+		obj.convex_hull.polygon.points.push_back(p);
+	}
+
+
+	obj.candidate_trajectories.lanes.clear();
+	for(unsigned int j = 0 ; j &lt; det_obj.predTrajectories.size(); j++)
+	{
+		autoware_msgs::lane pred_traj;
+		PlannerHNS::RosHelpers::ConvertFromLocalLaneToAutowareLane(det_obj.predTrajectories.at(j), pred_traj);
+		if(det_obj.predTrajectories.at(j).size() &gt; 0)
+		{
+			pred_traj.cost = det_obj.predTrajectories.at(j).at(0).collisionCost;
+		}
+		pred_traj.lane_index = 0;
+		obj.candidate_trajectories.lanes.push_back(pred_traj);
+	}
+}
+
 void RosHelpers::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::RoadNetwork&amp; out_map)
 {
 	std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt; lanes;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\DataRW.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\DataRW.h" added_lines="3" deleted_lines="0">
				<diff>@@ -29,11 +29,14 @@ public:
 	static std::string StatesLogFolderName;
 	static std::string SimulationFolderName;
 	static std::string KmlMapsFolderName;
+	static std::string PredictionFolderName;
+	static std::string TrackingFolderName;
 
 
 	static void WriteKMLFile(const std::string&amp; fileName, const std::vector&lt;std::string&gt;&amp; gps_list);
 	static void WriteKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;std::string&gt; &gt;&amp; gps_list);
 	static void WriteLogData(const std::string&amp; logFolder, const std::string&amp; logTitle, const std::string&amp; header, const std::vector&lt;std::string&gt;&amp; logData);
+	static void CreateLoggingFolder();
 };
 
 class SimpleReaderBase
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" added_lines="48" deleted_lines="0">
				<diff>@@ -8,8 +8,10 @@
 #include "op_utility/DataRW.h"
 #include &lt;stdlib.h&gt;
 #include &lt;tinyxml.h&gt;
+#include &lt;sys/stat.h&gt;
 #include "op_utility/UtilityH.h"
 
+
 using namespace std;
 
 namespace UtilityHNS
@@ -22,6 +24,8 @@ std::string DataRW::PathLogFolderName 		= "TrajectoriesLogs/";
 std::string DataRW::StatesLogFolderName 	= "BehaviorsLogs/";
 std::string DataRW::SimulationFolderName 	= "SimulationData/";
 std::string DataRW::KmlMapsFolderName 		= "KmlMaps/";
+std::string DataRW::PredictionFolderName 	= "PredictionResults/";
+std::string DataRW::TrackingFolderName 		= "TrackingLogs/";
 
 
 DataRW::DataRW()
@@ -32,6 +36,50 @@ DataRW::~DataRW()
 {
 }
 
+void DataRW::CreateLoggingFolder()
+{
+	std::string main_folder = UtilityH::GetHomeDirectory() + DataRW::LoggingMainfolderName;
+	int dir_err = mkdir(main_folder.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+	if (-1 == dir_err)
+	    cout &lt;&lt; "Can't Create OpenPlanner Log Path!n" &lt;&lt; endl;
+
+	main_folder = UtilityH::GetHomeDirectory() + DataRW::LoggingMainfolderName + DataRW::ControlLogFolderName;
+	dir_err = mkdir(main_folder.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+
+	main_folder = UtilityH::GetHomeDirectory() + DataRW::LoggingMainfolderName + DataRW::GlobalPathLogFolderName;
+	dir_err = mkdir(main_folder.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+
+	main_folder = UtilityH::GetHomeDirectory() + DataRW::LoggingMainfolderName + DataRW::PathLogFolderName;
+	dir_err = mkdir(main_folder.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+
+	main_folder = UtilityH::GetHomeDirectory() + DataRW::LoggingMainfolderName + DataRW::StatesLogFolderName;
+	dir_err = mkdir(main_folder.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+
+	main_folder = UtilityH::GetHomeDirectory() + DataRW::LoggingMainfolderName + DataRW::SimulationFolderName;
+	dir_err = mkdir(main_folder.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+
+	main_folder = UtilityH::GetHomeDirectory() + DataRW::LoggingMainfolderName + DataRW::PredictionFolderName;
+	dir_err = mkdir(main_folder.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+
+	main_folder = UtilityH::GetHomeDirectory() + DataRW::LoggingMainfolderName + DataRW::TrackingFolderName;
+	dir_err = mkdir(main_folder.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+
+	main_folder = UtilityH::GetHomeDirectory() + DataRW::LoggingMainfolderName + "SimulatedCar1";
+	dir_err = mkdir(main_folder.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+
+	main_folder = UtilityH::GetHomeDirectory() + DataRW::LoggingMainfolderName + "SimulatedCar2";
+	dir_err = mkdir(main_folder.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+
+	main_folder = UtilityH::GetHomeDirectory() + DataRW::LoggingMainfolderName + "SimulatedCar3";
+	dir_err = mkdir(main_folder.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+
+	main_folder = UtilityH::GetHomeDirectory() + DataRW::LoggingMainfolderName + "SimulatedCar4";
+	dir_err = mkdir(main_folder.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+
+	main_folder = UtilityH::GetHomeDirectory() + DataRW::LoggingMainfolderName + "SimulatedCar5";
+	dir_err = mkdir(main_folder.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+}
+
 void DataRW::WriteLogData(const std::string&amp; logFolder, const std::string&amp; logTitle, const std::string&amp; header, const std::vector&lt;std::string&gt;&amp; logData)
 {
 	if(logData.size() &lt; 2)
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ring_ground_filter\ring_ground_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ring_ground_filter\ring_ground_filter.cpp" added_lines="131" deleted_lines="208">
				<diff>@@ -1,9 +1,9 @@
 /*
- * ground_filter.cpp
+ * ring_ground_filter.cpp
  *
- * Created on	: May 19, 2017
+ * Created on	: June 5, 2018
  * Author	: Patiphon Narksri
- * @brief Below algorithm is documented here https://github.com/CPFL/Autoware-Manuals/tree/master/en/pdfs/ground_filter.pdf.
+ *
  */
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
@@ -12,7 +12,6 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;velodyne_pointcloud/point_types.h&gt;
 #include &lt;opencv/cv.h&gt;
-#include "autoware_msgs/ConfigRingGroundFilter.h"
 
 enum Label
 {
@@ -21,35 +20,32 @@ enum Label
 	UNKNOWN //Initial state, not classified
 };
 
-class RingGroundFilter
+class GroundFilter
 {
 public:
 
-	RingGroundFilter();
+	GroundFilter();
 
 private:
 
 	ros::NodeHandle node_handle_;
-	ros::Subscriber config_node_sub_;
 	ros::Subscriber points_node_sub_;
 	ros::Publisher groundless_points_pub_;
 	ros::Publisher ground_points_pub_;
 
 	std::string point_topic_;
+	std::string no_ground_topic, ground_topic;
 	int 		sensor_model_;
 	double 		sensor_height_;
 	double 		max_slope_;
-	int 		min_point_;
-	double 		clipping_thres_;
-	double 		gap_thres_;
-	double		point_distance_;
+	double vertical_thres_;
 	bool		floor_removal_;
 
 	int 		vertical_res_;
 	int 		horizontal_res_;
-	double 		limiting_ratio_;
 	cv::Mat 	index_map_;
 	Label 		class_label_[64];
+	double	radius_table_[64];
 
 	boost::chrono::high_resolution_clock::time_point t1_;
 	boost::chrono::high_resolution_clock::time_point t2_;
@@ -57,14 +53,9 @@ private:
 
 	const int 	DEFAULT_HOR_RES = 2000;
 
-	void SetHorizontalRes(const int sensor_model, int &amp;horizontal_res);
 	void InitLabelArray(int in_model);
+	void InitRadiusTable(int in_model);
 	void InitDepthMap(int in_width);
-	void PublishPointCloud(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
-				int in_indices[], int &amp;in_out_index_size,
-				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;in_cloud);
-
-	void ConfigCallback(const autoware_msgs::ConfigRingGroundFilterConstPtr &amp;config);
 	void VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg);
 	void FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
 				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_groundless_points,
@@ -72,7 +63,7 @@ private:
 
 };
 
-RingGroundFilter::RingGroundFilter() : node_handle_("~")
+GroundFilter::GroundFilter() : node_handle_("~")
 {
 	ROS_INFO("Inititalizing Ground Filter...");
 	node_handle_.param&lt;std::string&gt;("point_topic", point_topic_, "/points_raw");
@@ -81,99 +72,132 @@ RingGroundFilter::RingGroundFilter() : node_handle_("~")
  	ROS_INFO("Floor Removal: %d", floor_removal_);
 	node_handle_.param("sensor_model", sensor_model_, 64);
 	ROS_INFO("Sensor Model: %d", sensor_model_);
-	node_handle_.param("sensor_height", sensor_height_, 1.72);
+	node_handle_.param("sensor_height", sensor_height_, 1.80);
 	ROS_INFO("Sensor Height: %f", sensor_height_);
-	node_handle_.param("max_slope", max_slope_, 20.0);
+	node_handle_.param("max_slope", max_slope_, 10.0);
 	ROS_INFO("Max Slope: %f", max_slope_);
-	node_handle_.param("point_distance", point_distance_, 0.05);
-	ROS_INFO("Point Distance: %f", point_distance_);
-	node_handle_.param("min_point", min_point_, 3);
-	ROS_INFO("Min Points: %d", min_point_);
-	node_handle_.param("clipping_thres", clipping_thres_, 0.5);
-	ROS_INFO("Lower Clipping Threshold: %f", clipping_thres_);
-	node_handle_.param("gap_thres", gap_thres_, 0.5);
-	ROS_INFO("Point Gap Threshold: %f", gap_thres_);
+	node_handle_.param("vertical_thres", vertical_thres_, 0.08);
+	ROS_INFO("Vertical Threshold: %f", vertical_thres_);
 
-	std::string no_ground_topic, ground_topic;
 	node_handle_.param&lt;std::string&gt;("no_ground_point_topic", no_ground_topic, "/points_no_ground");
 	ROS_INFO("No Ground Output Point Cloud: %s", no_ground_topic.c_str());
 	node_handle_.param&lt;std::string&gt;("ground_point_topic", ground_topic, "/points_ground");
 	ROS_INFO("Only Ground Output Point Cloud: %s", ground_topic.c_str());
 
+
 	int default_horizontal_res;
-	SetHorizontalRes(sensor_model_, default_horizontal_res);
+	switch(sensor_model_)
+	{
+		case 64:
+			default_horizontal_res = 2083;
+			break;
+		case 32:
+			default_horizontal_res = 2250;
+			break;
+		case 16:
+			default_horizontal_res = 1800;
+			break;
+		default:
+			default_horizontal_res = DEFAULT_HOR_RES;
+			break;
+	}
 	node_handle_.param("horizontal_res", horizontal_res_, default_horizontal_res);
 
-	config_node_sub_ = node_handle_.subscribe("/config/ring_ground_filter", 10, &amp;RingGroundFilter::ConfigCallback, this);
-	points_node_sub_ = node_handle_.subscribe(point_topic_, 2, &amp;RingGroundFilter::VelodyneCallback, this);
-	groundless_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(no_ground_topic, 2);
-	ground_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(ground_topic, 2);
+	points_node_sub_ = node_handle_.subscribe(point_topic_, 10000, &amp;GroundFilter::VelodyneCallback, this);
+	groundless_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(no_ground_topic, 10000);
+	ground_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(ground_topic, 10000);
 
 	vertical_res_ = sensor_model_;
 	InitLabelArray(sensor_model_);
-	limiting_ratio_ = tan(max_slope_*M_PI/180);
+	InitRadiusTable(sensor_model_);
+}
 
+void GroundFilter::InitLabelArray(int in_model)
+{
+	for(int a = 0; a &lt; vertical_res_; a++)
+	{
+		class_label_[a] = UNKNOWN;
+	}
 }
 
-void RingGroundFilter::SetHorizontalRes(const int sensor_model, int &amp;horizontal_res)
+void GroundFilter::InitRadiusTable(int in_model)
 {
-	switch(sensor_model)
+	double a;
+	double b;
+	double theta;
+	switch (in_model)
 	{
 		case 64:
-			horizontal_res = 2083;
+			a = 1.0/3*M_PI/180;
+			b = max_slope_*M_PI/180;
+			for (int i = 0; i &lt; 64; i++)
+			{
+				if (i &lt;= 31)
+				{
+					if (i == 31) a = -a;
+					theta = (1.0/3*i - 2.0)*M_PI/180;
+					radius_table_[i] = fabs(sensor_height_*(1.0/(tan(theta)+tan(b)) - 1.0/(tan(a+theta)+tan(b))));
+				}
+				else
+				{
+					a = 0.5*M_PI/180;
+					theta = (8.83 + (0.5)*(i - 32.0))*M_PI/180;
+					radius_table_[i] = fabs(sensor_height_*(1.0/(tan(theta)+tan(b)) - 1.0/(tan(a+theta)+tan(b))));
+				}
+			}
 			break;
 		case 32:
-			horizontal_res = 2250;
+			a = 4.0/3*M_PI/180;
+			b = max_slope_*M_PI/180;
+			for (int i = 0; i &lt; 32; i++)
+			{
+				theta = (-31.0/3 + (4.0/3)*i)*180/M_PI;
+				radius_table_[i] = fabs(sensor_height_*(1.0/(tan(theta)+tan(b)) - 1.0/(tan(a+theta)+tan(b))));
+			}
 			break;
 		case 16:
-			horizontal_res = 1800;
+			a = 2.0*M_PI/180;
+			b = max_slope_*M_PI/180;
+			for (int i = 0; i &lt; 16; i++)
+			{
+				theta = (-30.0/2 + (2.0)*i)*180/M_PI;
+				radius_table_[i] = fabs(sensor_height_*(1.0/(tan(theta)+tan(b)) - 1.0/(tan(a+theta)+tan(b))));
+			}
 			break;
 		default:
-			horizontal_res = DEFAULT_HOR_RES;
+			a = 1.0/3*M_PI/180;
+			b = max_slope_*M_PI/180;
+			for (int i = 0; i &lt; 64; i++)
+			{
+				if (i &lt;= 31)
+				{
+					if (i == 31) a = -a;
+					theta = (1.0/3*i - 2.0)*M_PI/180;
+					radius_table_[i] = fabs(sensor_height_*(1.0/(tan(theta)+tan(b)) - 1.0/(tan(a+theta)+tan(b))));
+				}
+				else
+				{
+					a = 0.5*M_PI/180;
+					theta = (8.83 + (0.5)*(i - 32.0))*M_PI/180;
+					radius_table_[i] = fabs(sensor_height_*(1.0/(tan(theta)+tan(b)) - 1.0/(tan(a+theta)+tan(b))));
+				}
+			}
 			break;
 	}
 }
 
-void RingGroundFilter::InitLabelArray(int in_model)
-{
-	for(int a = 0; a &lt; vertical_res_; a++)
-	{
-		class_label_[a] = UNKNOWN;
-	}
-}
-
-void RingGroundFilter::InitDepthMap(int in_width)
+void GroundFilter::InitDepthMap(int in_width)
 {
 	const int mOne = -1;
 	index_map_ = cv::Mat_&lt;int&gt;(vertical_res_, in_width, mOne);
 }
 
-void RingGroundFilter::PublishPointCloud(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
-				int in_indices[], int &amp;in_out_index_size,
-				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;in_cloud)
-{
-	velodyne_pointcloud::PointXYZIR point;
-	for (int i = 0; i &lt; in_out_index_size; i++)
-	{
-		point.x = in_cloud_msg-&gt;points[in_indices[i]].x;
-		point.y = in_cloud_msg-&gt;points[in_indices[i]].y;
-		point.z = in_cloud_msg-&gt;points[in_indices[i]].z;
-		point.intensity = in_cloud_msg-&gt;points[in_indices[i]].intensity;
-		point.ring = in_cloud_msg-&gt;points[in_indices[i]].ring;
-		in_cloud.push_back(point);
-	}
-	in_out_index_size = 0;
-}
-
-void RingGroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
+void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
 			pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_groundless_points,
 			pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_ground_points)
 {
 
 	velodyne_pointcloud::PointXYZIR point;
-
-	//This line is not necessary
-	//horizontal_res_ = int(in_cloud_msg-&gt;points.size() / vertical_res_);
 	InitDepthMap(horizontal_res_);
 
 	for (size_t i = 0; i &lt; in_cloud_msg-&gt;points.size(); i++)
@@ -188,15 +212,13 @@ void RingGroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::P
 	for (int i = 0; i &lt; horizontal_res_; i++)
 	{
 		Label point_class[vertical_res_];
-		int unknown_index[vertical_res_];
 		int point_index[vertical_res_];
-		int unknown_index_size = 0;
 		int point_index_size = 0;
-		double z_ref = 0;
+		double z_max = 0;
+		double z_min = 0;
 		double r_ref = 0;
 		std::copy(class_label_, class_label_ + vertical_res_, point_class);
-
-		for (int j = vertical_res_ - 1; j &gt;= 0; j--)
+		for (int j = 0; j &lt; vertical_res_; j++)
 		{
 			if (index_map_.at&lt;int&gt;(j,i) &gt; -1 &amp;&amp; point_class[j] == UNKNOWN)
 			{
@@ -204,35 +226,18 @@ void RingGroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::P
 				double y0 = in_cloud_msg-&gt;points[index_map_.at&lt;int&gt;(j, i)].y;
 				double z0 = in_cloud_msg-&gt;points[index_map_.at&lt;int&gt;(j, i)].z;
 				double r0 = sqrt(x0*x0 + y0*y0);
-				double r_diff = r0 - r_ref;
-				double z_diff = fabs(z0 - z_ref);
-				double pair_angle;
-
-				if (r_diff != 0.)
-				{
-					pair_angle = z_diff/r_diff;
-				}
-				else
-				{//this should never execute due to Sensor specs
-					ROS_WARN("RingGroundFilter: Division by Zero avoided on pair_angle");
-					pair_angle = 0;
-				}
-				if (
-					 (	(pair_angle &gt; 0 &amp;&amp; pair_angle &lt; limiting_ratio_)
-						&amp;&amp; z_diff &lt; gap_thres_
-						&amp;&amp; z0 &lt; clipping_thres_
-					 )
-					|| point_index_size == 0
-					)
+				double r_diff = fabs(r0 - r_ref);
+				if (r_diff &lt; radius_table_[j] || r_ref == 0)
 				{
 					r_ref = r0;
-					z_ref = z0;
+					if (z0 &gt; z_max || r_ref == 0) z_max = z0;
+					if (z0 &lt; z_min || r_ref == 0) z_min = z0;
 					point_index[point_index_size] = j;
 					point_index_size++;
 				}
 				else
 				{
-					if (point_index_size &gt; min_point_)
+					if (point_index_size &gt; 1 &amp;&amp; (z_max - z_min) &gt; vertical_thres_)
 					{
 						for (int m = 0; m &lt; point_index_size; m++)
 						{
@@ -242,8 +247,8 @@ void RingGroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::P
 							point.z = in_cloud_msg-&gt;points[index].z;
 							point.intensity = in_cloud_msg-&gt;points[index].intensity;
 							point.ring = in_cloud_msg-&gt;points[index].ring;
-							out_ground_points.push_back(point);
-							point_class[point_index[m]] = GROUND;
+							out_groundless_points.push_back(point);
+							point_class[point_index[m]] = VERTICAL;
 						}
 						point_index_size = 0;
 					}
@@ -252,36 +257,26 @@ void RingGroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::P
 						for (int m = 0; m &lt; point_index_size; m++)
 						{
 							int index = index_map_.at&lt;int&gt;(point_index[m],i);
+							point.x = in_cloud_msg-&gt;points[index].x;
+							point.y = in_cloud_msg-&gt;points[index].y;
 							point.z = in_cloud_msg-&gt;points[index].z;
-							if (point.z &gt; clipping_thres_ - sensor_height_)
-							{
-								point.x = in_cloud_msg-&gt;points[index].x;
-								point.y = in_cloud_msg-&gt;points[index].y;
-								point.intensity = in_cloud_msg-&gt;points[index].intensity;
-								point.ring = in_cloud_msg-&gt;points[index].ring;
-								out_groundless_points.push_back(point);
-								point_class[point_index[m]] = VERTICAL;
-							}
-							else
-							{
-								unknown_index[unknown_index_size] = index;
-								unknown_index_size++;
-							}
+							point.intensity = in_cloud_msg-&gt;points[index].intensity;
+							point.ring = in_cloud_msg-&gt;points[index].ring;
+							out_ground_points.push_back(point);
+							point_class[point_index[m]] = GROUND;
 						}
 						point_index_size = 0;
 					}
-					//These line were missing
 					r_ref = r0;
-					z_ref = z0;
+					z_max = z0;
+					z_min = z0;
 					point_index[point_index_size] = j;
 					point_index_size++;
 				}
 			}
-			if (j == 0)
+			if (j == vertical_res_ - 1 &amp;&amp; point_index_size != 0)
 			{
-				if (point_index_size != 0)
-				{
-					if (point_index_size &gt; min_point_)
+					if (point_index_size &gt; 1 &amp;&amp; (z_max - z_min) &gt; vertical_thres_)
 					{
 						for (int m = 0; m &lt; point_index_size; m++)
 						{
@@ -291,8 +286,8 @@ void RingGroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::P
 							point.z = in_cloud_msg-&gt;points[index].z;
 							point.intensity = in_cloud_msg-&gt;points[index].intensity;
 							point.ring = in_cloud_msg-&gt;points[index].ring;
-							out_ground_points.push_back(point);
-							point_class[point_index[m]] = GROUND;
+							out_groundless_points.push_back(point);
+							point_class[point_index[m]] = VERTICAL;
 						}
 						point_index_size = 0;
 					}
@@ -301,99 +296,25 @@ void RingGroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::P
 						for (int m = 0; m &lt; point_index_size; m++)
 						{
 							int index = index_map_.at&lt;int&gt;(point_index[m],i);
+							point.x = in_cloud_msg-&gt;points[index].x;
+							point.y = in_cloud_msg-&gt;points[index].y;
 							point.z = in_cloud_msg-&gt;points[index].z;
-							if (point.z &gt; clipping_thres_ - sensor_height_)
-							{
-								point.x = in_cloud_msg-&gt;points[index].x;
-								point.y = in_cloud_msg-&gt;points[index].y;
-								point.intensity = in_cloud_msg-&gt;points[index].intensity;
-								point.ring = in_cloud_msg-&gt;points[index].ring;
-								out_groundless_points.push_back(point);
-								point_class[point_index[m]] = VERTICAL;
-							}
-							else
-							{
-								unknown_index[unknown_index_size] = index;
-								unknown_index_size++;
-							}
+							point.intensity = in_cloud_msg-&gt;points[index].intensity;
+							point.ring = in_cloud_msg-&gt;points[index].ring;
+							out_ground_points.push_back(point);
+							point_class[point_index[m]] = GROUND;
 						}
 						point_index_size = 0;
-					}//end else
-				}//end if (point_index_size != 0)
-
-				double centroid = 0;
-				int cluster_index[vertical_res_];
-				int cluster_index_size = 0;
-				for (int m = unknown_index_size - 1; m &gt;= 0; m--)
-				{
-					double x0 = in_cloud_msg-&gt;points[unknown_index[m]].x;
-					double y0 = in_cloud_msg-&gt;points[unknown_index[m]].y;
-					double r0 = sqrt(x0*x0 + y0*y0);
-					double r_diff = fabs(r0 - centroid);
-					if ((r_diff &lt; point_distance_) || cluster_index_size == 0)
-					{
-						cluster_index[cluster_index_size] = unknown_index[m];
-						cluster_index_size++;
-						centroid = r0;
-						if (m == 0)
-						{
-							if(cluster_index_size &gt; 1)
-							{
-								PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_groundless_points);
-							}
-							else
-							{
-								PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_ground_points);
-							}
-						}
-					}
-					else
-					{
-						if(cluster_index_size &gt; 1)
-						{
-							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_groundless_points);
-						}
-						else
-						{
-							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_ground_points);
-						}
-						cluster_index[cluster_index_size] = unknown_index[m];
-						cluster_index_size++;
-						centroid = r0;
 					}
-					if (m == 0)
-					{
-						if(cluster_index_size &gt; 1)
-						{
-							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_groundless_points);
-						}
-						else
-						{
-							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_ground_points);
-						}
-					}
-				}//end for (int m = unknown_index_size - 1; m &gt;= 0; m--)
-			}//end if (j == 0)
+			}
 		}
 	}
-
-}
-
-void RingGroundFilter::ConfigCallback(const autoware_msgs::ConfigRingGroundFilterConstPtr &amp;config)
-{
-  sensor_model_ = std::stoi(config-&gt;sensor_model);
-  sensor_height_ = config-&gt;sensor_height;
-	max_slope_ = config-&gt;max_slope;
-	point_distance_ = config-&gt;point_distance;
-	min_point_ = config-&gt;min_point;
-	clipping_thres_ = config-&gt;clipping_thres;
-	gap_thres_ = config-&gt;gap_thres;
-	SetHorizontalRes(sensor_model_, horizontal_res_);
 }
 
-void RingGroundFilter::VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg)
+void GroundFilter::VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg)
 {
 
+	t1_ = boost::chrono::high_resolution_clock::now();
 	pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; vertical_points;
 	pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; ground_points;
 	vertical_points.header = in_cloud_msg-&gt;header;
@@ -410,14 +331,16 @@ void RingGroundFilter::VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointclou
 
 	groundless_points_pub_.publish(vertical_points);
 	ground_points_pub_.publish(ground_points);
-
+	t2_ = boost::chrono::high_resolution_clock::now();
+	elap_time_ = boost::chrono::duration_cast&lt;boost::chrono::nanoseconds&gt;(t2_-t1_);
+	std::cout &lt;&lt; "Computational Time for one frame: " &lt;&lt; elap_time_ &lt;&lt; '\n';
 }
 
 int main(int argc, char **argv)
 {
 
 	ros::init(argc, argv, "ring_ground_filter");
-	RingGroundFilter node;
+	GroundFilter node;
 	ros::spin();
 
 	return 0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="537dedd782f95368d698631b16ad6176aa773655" author="hatem-darweesh">
		<msg>Update op_utility files for csv files loading
Update MappingHelpers with latest modifications
Update PlanningHelpers with latest modifications
add op_common_param node, for setting OpenPlanner parameter for all related nodes such as lidar_kf_contour_track
Improve tracking by including size different in association function
Update way_planner, dp_planner for compatibility with new Mapping Modifications, Map format is backward compatible</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\SimpleTracker.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\SimpleTracker.h" added_lines="1" deleted_lines="1">
				<diff>@@ -24,7 +24,7 @@ namespace ContourTrackerNS
 #define ACCELERATION_DECISION_VALUE 0.5
 #define PREV_TRACK_SIZE 25
 #define PREV_TRACK_SMOOTH_DATA 0.475
-#define PREV_TRACK_SMOOTH_SMOOTH 0.1
+#define PREV_TRACK_SMOOTH_SMOOTH 0.3
 
 enum TRACKING_TYPE {ASSOCIATE_ONLY = 0, SIMPLE_TRACKER = 1, CONTOUR_TRACKER = 2};
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\SimpleTracker.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\SimpleTracker.cpp" added_lines="14" deleted_lines="4">
				<diff>@@ -505,6 +505,7 @@ void SimpleTracker::AssociateDistanceOnlyAndTrack()
 		double iClosest_obj = -1;
 		double dClosest = m_MAX_ASSOCIATION_DISTANCE;
 		double size_diff = -1;
+		double angle_diff = 0;
 
 		//std::cout &lt;&lt; "DetObjSize: " &lt;&lt;  m_DetectedObjects.size() &lt;&lt;  ", TracksSize: " &lt;&lt; m_TrackSimply.size() &lt;&lt; std::endl;
 		for(unsigned int jj = 0; jj &lt; m_DetectedObjects.size(); jj++)
@@ -518,13 +519,22 @@ void SimpleTracker::AssociateDistanceOnlyAndTrack()
 				d_x = m_DetectedObjects.at(jj).center.pos.x-m_TrackSimply.at(i).obj.center.pos.x;
 				d = hypot(d_y, d_x);
 				double old_size = sqrt(m_TrackSimply.at(i).obj.w*m_TrackSimply.at(i).obj.w + m_TrackSimply.at(i).obj.l*m_TrackSimply.at(i).obj.l + m_TrackSimply.at(i).obj.h*m_TrackSimply.at(i).obj.h);
-
-				if(d &lt; dClosest)
+				size_diff = fabs(old_size - object_size);
+//				if(m_TrackSimply.at(i).obj.bDirection &amp;&amp; m_TrackSimply.at(i).obj.bVelocity &amp;&amp; m_TrackSimply.at(i).obj.center.v*3.6 &gt; 3)
+//				{
+//					double a_check =  UtilityHNS::UtilityH::FixNegativeAngle(atan2(d_y, d_x));
+//					double a_old = UtilityHNS::UtilityH::FixNegativeAngle(m_TrackSimply.at(i).obj.center.pos.a);
+//					angle_diff = UtilityHNS::UtilityH::AngleBetweenTwoAnglesPositive(a_check, a_old);
+//				}
+//				else
+//					angle_diff = 0;
+
+				if(d &lt; dClosest &amp;&amp; size_diff &lt; m_MAX_ASSOCIATION_SIZE_DIFF)
 				{
 					dClosest = d;
 					iClosest_track = i;
 					iClosest_obj = jj;
-					size_diff = fabs(old_size - object_size);
+
 				}
 				//std::cout &lt;&lt; "Test: " &lt;&lt; m_TrackSimply.at(i).obj.id &lt;&lt; ", MinD: " &lt;&lt; d &lt;&lt; ", ObjS: " &lt;&lt; object_size &lt;&lt; ", ObjI: " &lt;&lt; jj &lt;&lt; ", TrackS: " &lt;&lt; old_size &lt;&lt; ", TrackI: " &lt;&lt; i &lt;&lt; std::endl;
 			}
@@ -532,7 +542,7 @@ void SimpleTracker::AssociateDistanceOnlyAndTrack()
 
 		if(iClosest_obj != -1 &amp;&amp; iClosest_track != -1 &amp;&amp; dClosest &lt; m_MAX_ASSOCIATION_DISTANCE)
 		{
-			std::cout &lt;&lt; "MatchObj: " &lt;&lt; m_TrackSimply.at(iClosest_track).obj.id &lt;&lt; ", MinD: " &lt;&lt; dClosest &lt;&lt; ", Sdiff: " &lt;&lt; size_diff &lt;&lt; ", ObjI: " &lt;&lt; iClosest_obj &lt;&lt;", TrackI: " &lt;&lt; iClosest_track &lt;&lt; std::endl;
+			//std::cout &lt;&lt; "MatchObj: " &lt;&lt; m_TrackSimply.at(iClosest_track).obj.id &lt;&lt; ", MinD: " &lt;&lt; dClosest &lt;&lt; ", Sdiff: " &lt;&lt; size_diff &lt;&lt; ", ObjI: " &lt;&lt; iClosest_obj &lt;&lt;", TrackI: " &lt;&lt; iClosest_track &lt;&lt; std::endl;
 			m_DetectedObjects.at(iClosest_obj).id = m_TrackSimply.at(iClosest_track).obj.id;
 			MergeObjectAndTrack(m_TrackSimply.at(iClosest_track), m_DetectedObjects.at(iClosest_obj));
 			AssociateToRegions(m_TrackSimply.at(iClosest_track));
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\MappingHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\MappingHelpers.h" added_lines="112" deleted_lines="8">
				<diff>@@ -1,9 +1,10 @@
-/*
- * MappingHelpers.h
- *
- *  Created on: Jul 2, 2016
- *      Author: Hatem
- */
+
+/// \file MappingHelpers.h
+/// \brief Helper functions for mapping operation such as (load and initialize vector maps , convert map from one format to another, .. )
+/// \author Hatem Darweesh
+/// \date Jul 2, 2016
+
+
 
 #ifndef MAPPINGHELPERS_H_
 #define MAPPINGHELPERS_H_
@@ -34,11 +35,37 @@ public:
 			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
 			const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
 			const std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt;&amp; roadedge_data,
+			const std::vector&lt;UtilityHNS::AisanWayareaFileReader::AisanWayarea&gt;&amp; wayarea_data,
+			const std::vector&lt;UtilityHNS::AisanCrossWalkFileReader::AisanCrossWalk&gt;&amp; crosswalk_data,
+			const std::vector&lt;UtilityHNS::AisanNodesFileReader::AisanNode&gt;&amp; nodes_data,
 			const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
 			const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag = false);
 
+	static void ConstructRoadNetworkFromRosMessageV2(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
+			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+				const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
+				const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
+				const std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt;&amp; area_data,
+				const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
+				const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
+				const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
+				const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
+				const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
+				const std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt;&amp; roadedge_data,
+				const std::vector&lt;UtilityHNS::AisanWayareaFileReader::AisanWayarea&gt;&amp; wayarea_data,
+				const std::vector&lt;UtilityHNS::AisanCrossWalkFileReader::AisanCrossWalk&gt;&amp; crosswalk_data,
+				const std::vector&lt;UtilityHNS::AisanNodesFileReader::AisanNode&gt;&amp; nodes_data,
+				const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
+				UtilityHNS::AisanLanesFileReader* pLaneData,
+				UtilityHNS::AisanPointsFileReader* pPointsData,
+				UtilityHNS::AisanNodesFileReader* pNodesData,
+				UtilityHNS::AisanLinesFileReader* pLinedata,
+				const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag = false);
+
 	static void ConstructRoadNetworkFromDataFiles(const std::string vectoMapPath, RoadNetwork&amp; map, const bool&amp; bZeroOrigin = false);
 
+	static void UpdateMapWithOccupancyGrid(OccupancyToGridMap&amp; map_info, const std::vector&lt;int&gt;&amp; data, RoadNetwork&amp; map, std::vector&lt;WayPoint*&gt;&amp; updated_list);
+
 	//static void SaveTrajectoryLonLatToKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectory);
 
 	static void GetWayPoint(const int&amp; pid, const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points, std::vector&lt;WayPoint&gt;&amp; path);
@@ -47,20 +74,25 @@ public:
 			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
 			const GPSPoint&amp; origin, WayPoint&amp; way_point);
 
+	static bool GetWayPointV2(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; pid,
+			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
+				const GPSPoint&amp; origin, WayPoint&amp; way_point);
+
 	//static void WriteKML(const std::string&amp; kmlFile, const std::string&amp; kmlTemplat, RoadNetwork&amp; ap);
 	static void LoadKML(const std::string&amp; kmlMap, RoadNetwork&amp; map);
 
 	static TiXmlElement* GetHeadElement(TiXmlElement* pMainElem);
 	static TiXmlElement* GetDataFolder(const std::string&amp; folderName, TiXmlElement* pMainElem);
 
-	static std::vector&lt;Lane*&gt; GetClosestLanesFast(const WayPoint&amp; center, RoadNetwork&amp; map, const double&amp; distance);
+
 	static Lane* GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0, const bool bDirectionBased = true);
 	static std::vector&lt;Lane*&gt; GetClosestLanesListFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 2.0, const bool bDirectionBased = true);
 	static Lane* GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
 	static std::vector&lt;Lane*&gt; GetClosestMultipleLanesFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
 	static WayPoint* GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const bool bDirectionBased = true);
+	static std::vector&lt;Lane*&gt; GetClosestLanesFast(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 10.0);
 
-	static std::vector&lt;WayPoint*&gt; GetClosestWaypointsListFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 2.0, const bool bDirectionBased = true);
+	static std::vector&lt;WayPoint*&gt; GetClosestWaypointsListFromMap(const WayPoint&amp; center, RoadNetwork&amp; map, const double&amp; distance = 2.0, const bool bDirectionBased = true);
 
 	static WayPoint* GetClosestBackWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
 	static WayPoint GetFirstWaypoint(RoadNetwork&amp; map);
@@ -71,16 +103,37 @@ public:
 			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
 			const GPSPoint&amp; origin, RoadNetwork&amp; map);
 
+	static void ExtractSignalDataV2(const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
+				const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
+				UtilityHNS::AisanPointsFileReader* pPointsData,
+				const GPSPoint&amp; origin, RoadNetwork&amp; map);
+
 	static void ExtractStopLinesData(const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
 			const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
 			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
 			const GPSPoint&amp; origin, RoadNetwork&amp; map);
 
+	static void ExtractStopLinesDataV2(const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
+				UtilityHNS::AisanLinesFileReader* pLineData,
+				UtilityHNS::AisanPointsFileReader* pPointData,
+				const GPSPoint&amp; origin, RoadNetwork&amp; map);
+
 	static void ExtractCurbData(const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
 				const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
 				const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
 				const GPSPoint&amp; origin, RoadNetwork&amp; map);
 
+	static void ExtractCurbDataV2(const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
+					UtilityHNS::AisanLinesFileReader* pLinedata,
+					UtilityHNS::AisanPointsFileReader* pPointsData,
+					const GPSPoint&amp; origin, RoadNetwork&amp; map);
+
+	static void ExtractWayArea(const std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt;&amp; area_data,
+			const std::vector&lt;UtilityHNS::AisanWayareaFileReader::AisanWayarea&gt;&amp; wayarea_data,
+			const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
+			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+			const GPSPoint&amp; origin, RoadNetwork&amp; map);
+
 	static void LinkMissingBranchingWayPoints(RoadNetwork&amp; map);
 	static void LinkTrafficLightsAndStopLinesConData(const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
 			const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; id_replace_list, RoadNetwork&amp; map);
@@ -98,6 +151,11 @@ public:
 	static WayPoint* FindWaypoint(const int&amp; id, RoadNetwork&amp; map);
 
 
+	static std::vector&lt;Curb&gt; GetCurbsList(TiXmlElement* pElem);
+	static std::vector&lt;Boundary&gt; GetBoundariesList(TiXmlElement* pElem);
+	static std::vector&lt;Marking&gt; GetMarkingsList(TiXmlElement* pElem);
+	static std::vector&lt;Crossing&gt; GetCrossingsList(TiXmlElement* pElem);
+	static std::vector&lt;TrafficSign&gt; GetTrafficSignsList(TiXmlElement* pElem);
 	static std::vector&lt;TrafficLight&gt; GetTrafficLightsList(TiXmlElement* pElem);
 	static std::vector&lt;StopLine&gt; GetStopLinesList(TiXmlElement* pElem);
 	static std::vector&lt;Lane&gt; GetLanesList(TiXmlElement* pElem);
@@ -112,10 +170,56 @@ public:
 
 	//static void CreateKmlFromLocalizationPathFile(const std::string&amp; pathFileName,const double&amp; maxLaneDistance, const double&amp; density,const std::vector&lt;TrafficLight&gt;&amp; trafficLights, const std::vector&lt;GPSPoint&gt;&amp; stopLines);
 
+	static void AssignActionCostToLane(Lane* pL, ACTION_TYPE action, double cost);
+
 	static int ReplaceMyID(int&amp; id, const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; rep_list);
 
+	static void GetLanesStartPoints(UtilityHNS::AisanLanesFileReader* pLaneData,
+				std::vector&lt;int&gt;&amp; m_LanesStartIds);
+
+	static void GetLanePoints(UtilityHNS::AisanLanesFileReader* pLaneData,
+				UtilityHNS::AisanPointsFileReader* pPointsData,
+				UtilityHNS::AisanNodesFileReader* pNodesData, int lnID,
+				PlannerHNS::Lane&amp; out_lane);
+
+	static void CreateLanes(UtilityHNS::AisanLanesFileReader* pLaneData,
+			UtilityHNS::AisanPointsFileReader* pPointsData,
+			UtilityHNS::AisanNodesFileReader* pNodesData,
+			std::vector&lt;PlannerHNS::Lane&gt;&amp; out_lanes);
+
+	static void ConnectLanes(UtilityHNS::AisanLanesFileReader* pLaneData,
+			std::vector&lt;PlannerHNS::Lane&gt;&amp; lanes);
+
+	static bool GetPointFromDataList(UtilityHNS::AisanPointsFileReader* pPointsData,const int&amp; pid, WayPoint&amp; out_wp);
+
+	static int GetBeginPointIdFromLaneNo(UtilityHNS::AisanLanesFileReader* pLaneData,
+			UtilityHNS::AisanPointsFileReader* pPointsData,
+			UtilityHNS::AisanNodesFileReader* pNodesData, const int&amp; LnID);
+	static int GetEndPointIdFromLaneNo(UtilityHNS::AisanLanesFileReader* pLaneData,
+			UtilityHNS::AisanPointsFileReader* pPointsData,
+			UtilityHNS::AisanNodesFileReader* pNodesData,const int&amp; LnID);
+
+	static bool IsStartLanePoint(UtilityHNS::AisanLanesFileReader* pLaneData, UtilityHNS::AisanLanesFileReader::AisanLane* pL);
+	static bool IsEndLanePoint(UtilityHNS::AisanLanesFileReader* pLaneData, UtilityHNS::AisanLanesFileReader::AisanLane* pL);
+
+	static void FixRedundantPointsLanes(std::vector&lt;Lane&gt;&amp; lanes);
+	static void FixTwoPointsLanes(std::vector&lt;Lane&gt;&amp; lanes);
+	static void FixTwoPointsLane(Lane&amp; lanes);
+	static void FixUnconnectedLanes(std::vector&lt;Lane&gt;&amp; lanes);
+	static void InsertWayPointToBackOfLane(const WayPoint&amp; wp, Lane&amp; lane, int&amp; global_id);
+	static void InsertWayPointToFrontOfLane(const WayPoint&amp; wp, Lane&amp; lane, int&amp; global_id);
+
+	static void LinkLanesPointers(PlannerHNS::RoadNetwork&amp; map);
+
+	static void GetMapMaxIds(PlannerHNS::RoadNetwork&amp; map);
+
 	static double m_USING_VER_ZERO;
 
+	static int g_max_point_id;
+	static int g_max_lane_id;
+	static int g_max_stop_line_id;
+	static int g_max_traffic_light_id ;
+
 };
 
 } /* namespace PlannerHNS */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\MatrixOperations.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\MatrixOperations.h" added_lines="6" deleted_lines="6">
				<diff>@@ -1,9 +1,9 @@
-/*
- * MatrixOperations.h
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
+
+/// \file MatrixOperations.h
+/// \brief Simple matrix operations
+/// \author Hatem Darweesh
+/// \date Jun 19, 2016
+
 
 #ifndef MATRIXOPERATIONS_H_
 #define MATRIXOPERATIONS_H_
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlannerCommonDef.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlannerCommonDef.h" added_lines="9" deleted_lines="7">
				<diff>@@ -1,9 +1,9 @@
-/*
- * PlannerCommonDef.h
- *
- *  Created on: Dec 14, 2016
- *      Author: hatem
- */
+
+/// \file PlannerCommonDef.h
+/// \brief Definition file for control related data types
+/// \author Hatem Darweesh
+/// \date Dec 14, 2016
+
 
 #ifndef PLANNERCOMMONDEF_H_
 #define PLANNERCOMMONDEF_H_
@@ -18,7 +18,9 @@ enum MAP_SOURCE_TYPE
 {
 	MAP_AUTOWARE,
 	MAP_FOLDER,
-	MAP_KML_FILE
+	MAP_KML_FILE,
+	MAP_ONE_CSV_FILE,
+	MAP_LANES_CSV_FILES
 };
 
 enum CAR_TYPE
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlanningHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlanningHelpers.h" added_lines="40" deleted_lines="40">
				<diff>@@ -1,9 +1,9 @@
-/*
- * PlanningHelpers.h
- *
- *  Created on: Jun 16, 2016
- *      Author: hatem
- */
+
+/// \file PlanningHelpers.h
+/// \brief Helper functions for planning algorithms
+/// \author Hatem Darweesh
+/// \date Jun 16, 2016
+
 
 #ifndef PLANNINGHELPERS_H_
 #define PLANNINGHELPERS_H_
@@ -35,46 +35,16 @@ public:
 	PlanningHelpers();
 	virtual ~PlanningHelpers();
 
-	/**
-	 * @brief Find all relative information from the point p to the trajectory such as (perpendicular distance , closest next point , closest back point, distance from perpendicular intersection point to next point, distance from perpendicular intersection point to previous point)
-	 * @param trajectory list of waypoints
-	 * @param p query point
-	 * @param info collection of calculated information
-	 * @param prevIndex initial search index
-	 * @return true if success without errors, false otherwise
-	 */
 	static bool GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex = 0);
 
-
 	static bool GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectories, const WayPoint&amp; p, const double&amp; searchDistance, RelativeInfo&amp; info);
 
 	static bool GetRelativeInfoLimited(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex = 0);
 
-	/**
-	 * @brief Find point on the trajectory after initial relative point with specific distance
-	 * @param trajectory list of waypoints
-	 * @param init_p initial relative point on trajectory
-	 * @param distance distance from initial relative point to follow point
-	 * @return point on trajectory
-	 */
 	static WayPoint GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; init_p, const double&amp; distance, unsigned int&amp; point_index);
 
-	/**
-	 * @brief Calculate the precise distance from projection of point p2 (relative) to projection of point 1 (relative)
-	 * @param trajectory list of waypoints
-	 * @param p1 first relative point
-	 * @param p2 second relative point
-	 * @return distance on trajectory
-	 */
 	static double GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; p1,const RelativeInfo&amp; p2);
 
-	/**
-	 * @brief Find the closest next point on the trajectory index
-	 * @param trajectory list of waypoints
-	 * @param p query point
-	 * @param prevIndex initial search index
-	 * @return index of the closest next point from trajectory
-	 */
 	static int GetClosestNextPointIndex_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
 
 	static int GetClosestNextPointIndexFast(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
@@ -86,23 +56,35 @@ public:
 	static int GetClosestNextPointIndexDirectionFastV2(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
 
 	static int GetClosestPointIndex_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex = 0 );
-	static WayPoint GetPerpendicularOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, double&amp; distance, const int&amp; prevIndex = 0);
-	static double GetPerpDistanceToTrajectorySimple_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
+
+	static WayPoint GetPerpendicularOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, double&amp; distance, const int&amp; prevIndex = 0);	static double GetPerpDistanceToTrajectorySimple_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
+
 	static double GetPerpDistanceToVectorSimple_obsolete(const WayPoint&amp; p1, const WayPoint&amp; p2, const WayPoint&amp; pose);
+
 	static WayPoint GetNextPointOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const double&amp; distance, const int&amp; currIndex = 0);
-	static double GetDistanceOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
 
+	static double GetDistanceOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
 
 	static void CreateManualBranch(std::vector&lt;WayPoint&gt;&amp; path, const int&amp; degree, const DIRECTION_TYPE&amp; direction);
+
 	static void CreateManualBranchFromTwoPoints(WayPoint&amp; p1,WayPoint&amp; p2 , const double&amp; distance, const DIRECTION_TYPE&amp; direction, std::vector&lt;WayPoint&gt;&amp; path);
 
 	static void FixPathDensity(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; distanceDensity);
+
 	static void SmoothPath(std::vector&lt;WayPoint&gt;&amp; path, double weight_data =0.25,double weight_smooth = 0.25,double tolerance = 0.01);
+
 	static double CalcCircle(const GPSPoint&amp; pt1, const GPSPoint&amp; pt2, const GPSPoint&amp; pt3, GPSPoint&amp; center);
+
+	static void FixAngleOnly(std::vector&lt;WayPoint&gt;&amp; path);
+
 	static double CalcAngleAndCost(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0, const bool&amp; bSmooth = true );
+
 	//static double CalcAngleAndCostSimple(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0);
+
 	static double CalcAngleAndCostAndCurvatureAnd2D(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0);
 
+	static void PredictConstantTimeCostForTrajectory(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::WayPoint&amp; currPose, const double&amp; minVelocity, const double&amp; minDist);
+
 	static double GetAccurateDistanceOnTrajectory(std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
 
 	static void ExtractPartFromPointToDistance(const std::vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
@@ -111,6 +93,9 @@ public:
 	static void ExtractPartFromPointToDistanceFast(const std::vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
 				const double&amp; pathDensity, std::vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance);
 
+	static void ExtractPartFromPointToDistanceDirectionFast(const std::vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
+			const double&amp; pathDensity, std::vector&lt;WayPoint&gt;&amp; extractedPath);
+
 	static void CalculateRollInTrajectories(const WayPoint&amp; carPos, const double&amp; speed, const std::vector&lt;WayPoint&gt;&amp; originalCenter, int&amp; start_index,
 			int&amp; end_index, std::vector&lt;double&gt;&amp; end_laterals ,
 			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; rollInPaths, const double&amp; max_roll_distance,
@@ -121,12 +106,15 @@ public:
 			std::vector&lt;WayPoint&gt;&amp; sampledPoints);
 
 	static void SmoothSpeedProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
+
 	static void SmoothCurvatureProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance = 0.1);
+
 	static void SmoothWayPointsDirections(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
 
 	static void SmoothGlobalPathSpeed(std::vector&lt;WayPoint&gt;&amp; path);
 
 	static void GenerateRecommendedSpeed(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor);
+
 //	static WayPoint* BuildPlanningSearchTree(Lane* l, const WayPoint&amp; prevWayPointIndex,
 //			const WayPoint&amp; startPos, const WayPoint&amp; goalPos,
 //			const std::vector&lt;int&gt;&amp; globalPath, const double&amp; DistanceLimit,
@@ -150,11 +138,14 @@ public:
 				std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete, std::vector&lt;WayPoint*&gt;&amp; end_waypoints, std::vector&lt;int&gt;&amp; lanes_ids);
 
 	static bool CheckLaneIdExits(const std::vector&lt;int&gt;&amp; lanes, const Lane* pL);
+
 	static WayPoint* CheckLaneExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const Lane* pL);
+
 	static WayPoint* CheckNodeExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const WayPoint* pL);
 
 	static WayPoint* CreateLaneHeadCell(Lane* pLane, WayPoint* pLeft, WayPoint* pRight,
 			WayPoint* pBack);
+
 	static double GetLanePoints(Lane* l, const WayPoint&amp; prevWayPointIndex,
 			const double&amp; minDistance , const double&amp; prevCost, std::vector&lt;WayPoint&gt;&amp; points);
 
@@ -168,6 +159,7 @@ public:
 	static std::vector&lt;int&gt; GetUniqueLeftRightIds(const std::vector&lt;WayPoint&gt;&amp; path);
 
 	static bool FindInList(const std::vector&lt;int&gt;&amp; list,const int&amp; x);
+
 	static void RemoveWithValue(std::vector&lt;int&gt;&amp; list,const int&amp; x);
 
 	static ACTION_TYPE GetBranchingDirection(WayPoint&amp; currWP, WayPoint&amp; nextWP);
@@ -175,17 +167,25 @@ public:
 	static void CalcContourPointsForDetectedObjects(const WayPoint&amp; currPose, std::vector&lt;DetectedObject&gt;&amp; obj_list, const double&amp; filterDistance = 100);
 
 	static double GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const RelativeInfo&amp; info,int&amp; prev_index, const double&amp; reasonable_brake_distance);
+
 	static bool CompareTrajectories(const std::vector&lt;WayPoint&gt;&amp; path1, const std::vector&lt;WayPoint&gt;&amp; path2);
 
-	static double GetDistanceToClosestStopLineAndCheck(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; p, int&amp; stopLineID,int&amp; stopSignID, int&amp; trafficLightID, const int&amp; prevIndex = 0);
+	static double GetDistanceToClosestStopLineAndCheck(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; p, const double&amp; giveUpDistance, int&amp; stopLineID,int&amp; stopSignID, int&amp; trafficLightID, const int&amp; prevIndex = 0);
 
 	static bool GetThreePointsInfo(const WayPoint&amp; p0, const WayPoint&amp; p1, const WayPoint&amp; p2, WayPoint&amp; perp_p, double&amp; long_d, double lat_d);
 
 	static void WritePathToFile(const std::string&amp; fileName, const std::vector&lt;WayPoint&gt;&amp; path);
 
+	static LIGHT_INDICATOR GetIndicatorsFromPath(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; pose, const double&amp; seachDistance);
+
+	static PlannerHNS::WayPoint GetRealCenter(const PlannerHNS::WayPoint&amp; currState, const double&amp; wheel_base);
+
 	static void TestQuadraticSpline(const std::vector&lt;WayPoint&gt;&amp; center_line, std::vector&lt;WayPoint&gt;&amp; path);
+
 	static double frunge ( double x );
+
 	static double fprunge ( double x );
+
 	static double fpprunge ( double x );
 
 };
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\RoadNetwork.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\RoadNetwork.h" added_lines="262" deleted_lines="25">
				<diff>@@ -1,9 +1,9 @@
-/*
- * RoadNetwork.h
- *
- *  Created on: May 19, 2016
- *      Author: hatem
- */
+
+/// \file RoadNetwork.h
+/// \brief Definition of OpenPlanner's data types
+/// \author Hatem Darweesh
+/// \date May 19, 2016
+
 
 #ifndef ROADNETWORK_H_
 #define ROADNETWORK_H_
@@ -41,8 +41,16 @@ enum ACTION_TYPE {FORWARD_ACTION, BACKWARD_ACTION, STOP_ACTION, LEFT_TURN_ACTION
 
 enum BEH_STATE_TYPE {BEH_FORWARD_STATE=0,BEH_STOPPING_STATE=1, BEH_BRANCH_LEFT_STATE=2, BEH_BRANCH_RIGHT_STATE=3, BEH_YIELDING_STATE=4, BEH_ACCELERATING_STATE=5, BEH_SLOWDOWN_STATE=6};
 
+enum SEGMENT_TYPE {NORMAL_ROAD_SEG, INTERSECTION_ROAD_SEG, UTURN_ROAD_SEG, EXIT_ROAD_SEG, MERGE_ROAD_SEG, HIGHWAY_ROAD_SEG};
+enum RoadSegmentType {NORMAL_ROAD, INTERSECTION_ROAD, UTURN_ROAD, EXIT_ROAD, MERGE_ROAD, HIGHWAY_ROAD};
+
+enum MARKING_TYPE {UNKNOWN_MARK, TEXT_MARK, AF_MARK, AL_MARK, AR_MARK, AFL_MARK, AFR_MARK, ALR_MARK, UTURN_MARK, NOUTURN_MARK};
+
+enum TrafficSignTypes {UNKNOWN_SIGN, STOP_SIGN, MAX_SPEED_SIGN, MIN_SPEED_SIGN};
+
 class Lane;
 class TrafficLight;
+class RoadSegment;
 
 class ObjTimeStamp
 {
@@ -129,6 +137,11 @@ public:
     return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
   }
 
+  inline bool PointInsideRect(GPSPoint p)
+  {
+    return p.x &gt; bottom_left.x &amp;&amp; p.x &lt; top_right.x &amp;&amp; p.y &gt; bottom_left.y &amp;&amp; p.y &lt; top_right.y;
+  }
+
   inline bool HitTest(GPSPoint p)
   {
     return PointInRect(p) &amp;&amp; bObstacle;
@@ -461,6 +474,9 @@ public:
 
 	RelativeInfo()
 	{
+		after_angle = 0;
+		bBefore = false;
+		bAfter = false;
 		perp_distance = 0;
 		to_front_distance = 0;
 		from_back_distance = 0;
@@ -468,9 +484,22 @@ public:
 		iBack = 0;
 		iGlobalPath = 0;
 		angle_diff = 0;
-		after_angle = 0;
-		bBefore = false;
-		bAfter = false;
+	}
+};
+
+class Boundary //represent wayarea in vector map
+{
+public:
+	int id;
+	int roadId;
+	std::vector&lt;GPSPoint&gt; points;
+	RoadSegment* pSegment;
+
+	Boundary()
+	{
+		id    = 0;
+		roadId =0;
+		pSegment = nullptr;
 	}
 };
 
@@ -492,6 +521,22 @@ public:
 	}
 };
 
+class Crossing
+{
+public:
+	int id;
+	int roadId;
+	std::vector&lt;GPSPoint&gt; points;
+	RoadSegment* pSegment;
+
+	Crossing()
+	{
+		id    = 0;
+		roadId =0;
+		pSegment = nullptr;
+	}
+};
+
 class StopLine
 {
 public:
@@ -534,8 +579,6 @@ public:
 	}
 };
 
-enum TrafficSignTypes {UNKNOWN_SIGN, STOP_SIGN, MAX_SPEED_SIGN, MIN_SPEED_SIGN};
-
 class TrafficSign
 {
 public:
@@ -603,13 +646,37 @@ public:
 	}
 };
 
-enum RoadSegmentType {NORMAL_ROAD, INTERSECTION_ROAD, UTURN_ROAD, EXIT_ROAD, MERGE_ROAD, HIGHWAY_ROAD};
+class Marking
+{
+public:
+	int id;
+	int laneId;
+	int roadId;
+	MARKING_TYPE  mark_type;
+	GPSPoint center;
+	std::vector&lt;GPSPoint&gt; points;
+	Lane* pLane;
+
+	Marking()
+	{
+		id = 0;
+		laneId = 0;
+		roadId = 0;
+		mark_type = UNKNOWN_MARK;
+		pLane = nullptr;
+	}
+};
 
 class RoadSegment
 {
 public:
 	int id;
-	RoadSegmentType roadType;
+
+	SEGMENT_TYPE 	roadType;
+	Boundary	boundary;
+	Crossing	start_crossing;
+	Crossing	finish_crossing;
+	double 		avgWidth;
 	std::vector&lt;int&gt; fromIds;
 	std::vector&lt;int&gt; toIds;
 	std::vector&lt;Lane&gt; Lanes;
@@ -621,7 +688,8 @@ public:
 	RoadSegment()
 	{
 		id = 0;
-		roadType = NORMAL_ROAD;
+		avgWidth = 0;
+		roadType = NORMAL_ROAD_SEG;
 	}
 
 
@@ -644,7 +712,7 @@ public:
 	double length;
 	double dir;
 	LaneType type;
-	std::vector&lt;TrafficSign&gt; signs;
+	double width;
 	std::vector&lt;WayPoint&gt; points;
 	std::vector&lt;TrafficLight&gt; trafficlights;
 	std::vector&lt;StopLine&gt; stopLines;
@@ -665,6 +733,7 @@ public:
 		length 	= 0;
 		dir		= 0;
 		type 	= NORMAL_LANE;
+		width 	= 0;
 		pLeftLane = 0;
 		pRightLane = 0;
 		pRoad	= 0;
@@ -683,7 +752,10 @@ public:
 	std::vector&lt;TrafficLight&gt; trafficLights;
 	std::vector&lt;StopLine&gt; stopLines;
 	std::vector&lt;Curb&gt; curbs;
-
+	std::vector&lt;Boundary&gt; boundaries;
+	std::vector&lt;Crossing&gt; crossings;
+	std::vector&lt;Marking&gt; markings;
+	std::vector&lt;TrafficSign&gt; signs;
 };
 
 class VehicleState : public ObjTimeStamp
@@ -713,6 +785,7 @@ public:
 	double followDistance;
 	LIGHT_INDICATOR indicator;
 	bool bNewPlan;
+	int iTrajectory;
 
 
 	BehaviorState()
@@ -725,6 +798,7 @@ public:
 		followDistance = 0;
 		indicator  = INDICATOR_NONE;
 		bNewPlan = false;
+		iTrajectory = -1;
 
 	}
 
@@ -758,6 +832,7 @@ public:
 
 	int acceleration_desc;
 	double acceleration_raw;
+
 	LIGHT_INDICATOR indicator_state;
 
 	int originalID;
@@ -768,6 +843,8 @@ public:
 		bDirection = false;
 		bVelocity = false;
 		acceleration = 0;
+		acceleration_desc = 0;
+		acceleration_raw = 0.0;
 		id = 0;
 		w = 0;
 		l = 0;
@@ -810,11 +887,16 @@ public:
 	double 	smoothingSmoothWeight;
 	double 	smoothingToleranceError;
 
+	double stopSignStopTime;
 
 	double additionalBrakingDistance;
 	double verticalSafetyDistance;
 	double horizontalSafetyDistancel;
 
+	double giveUpDistance;
+
+	int nReliableCount;
+
 	bool 	enableLaneChange;
 	bool 	enableSwerving;
 	bool 	enableFollowing;
@@ -823,6 +905,7 @@ public:
 	bool 	enableStopSignBehavior;
 
 	bool 	enabTrajectoryVelocities;
+	double minIndicationDistance;
 
 	PlanningParams()
 	{
@@ -849,6 +932,9 @@ public:
 		verticalSafetyDistance 			= 0.0;
 		horizontalSafetyDistancel		= 0.0;
 
+		giveUpDistance					= -4;
+		nReliableCount					= 2;
+
 		enableHeadingSmoothing			= false;
 		enableSwerving 					= false;
 		enableFollowing					= false;
@@ -856,6 +942,7 @@ public:
 		enableLaneChange 				= false;
 		enableStopSignBehavior			= false;
 		enabTrajectoryVelocities 		= false;
+		minIndicationDistance			= 15;
 	}
 };
 
@@ -1074,15 +1161,15 @@ public:
 	{
 		std::ostringstream str;
 		str.precision(4);
-		str &lt;&lt; "LaneIndex    : " &lt;&lt; lane_index;
-		str &lt;&lt; ", Index      : " &lt;&lt; relative_index;
-		str &lt;&lt; ", TotalCost  : " &lt;&lt; cost;
-		str &lt;&lt; ", Priority   : " &lt;&lt; priority_cost;
-		str &lt;&lt; ", Transition : " &lt;&lt; transition_cost;
-		str &lt;&lt; ", Lateral    : " &lt;&lt; lateral_cost;
-		str &lt;&lt; ", Longitu    : " &lt;&lt; longitudinal_cost;
-		str &lt;&lt; ", LaneChange : " &lt;&lt; lane_change_cost;
-		str &lt;&lt; ", Blocked    : " &lt;&lt; bBlocked;
+		str &lt;&lt; "LI   : " &lt;&lt; lane_index;
+		str &lt;&lt; ", In : " &lt;&lt; relative_index;
+		str &lt;&lt; ", Co : " &lt;&lt; cost;
+		str &lt;&lt; ", Pr : " &lt;&lt; priority_cost;
+		str &lt;&lt; ", Tr : " &lt;&lt; transition_cost;
+		str &lt;&lt; ", La : " &lt;&lt; lateral_cost;
+		str &lt;&lt; ", Lo : " &lt;&lt; longitudinal_cost;
+		str &lt;&lt; ", Ln : " &lt;&lt; lane_change_cost;
+		str &lt;&lt; ", Bl : " &lt;&lt; bBlocked;
 		str &lt;&lt; "\n";
 		for (unsigned int i=0; i&lt;lateral_costs.size(); i++ )
 		{
@@ -1094,6 +1181,156 @@ public:
 	}
 };
 
+class OccupancyToGridMap
+{
+public:
+	int width;
+	int length;
+	double res;
+	WayPoint center;
+
+	OccupancyToGridMap(const int&amp; _width, const int&amp; _length, const double&amp; _res, const WayPoint&amp; _center)
+	{
+		width = _width;
+		length = _length;
+		res = _res;
+		center = _center;
+	}
+
+	OccupancyToGridMap()
+	{
+		width = 0;
+		length  = 0;
+		res = 0.0;
+	}
+
+	bool GetCellIndexFromPoint(const GPSPoint&amp; p, const std::vector&lt;int&gt;&amp; data, int&amp; _cell)
+	{
+		int col = floor(p.x / res);
+		int row = floor(p.y / res);
+
+		int index = -1;
+		if(row &gt;= 0 &amp;&amp; row &lt; length &amp;&amp; col &gt;=0 &amp;&amp; col &lt; width)
+		{
+			index = get2dIndex(row,col);
+
+			if(index &gt;= 0 &amp;&amp; index &lt; (int)data.size())
+			{
+				_cell = data.at((unsigned int)index);
+				//printf("Cell Info: P(%f,%f) , D(%f,%f), G(%d,%d), index = %d \n", p.x, p.y, p.x-center.pos.x, p.y-center.pos.y, col, row , index);
+				return true;
+			}
+		}
+
+		if(row+1 &gt;= 0 &amp;&amp; row+1 &lt; length &amp;&amp; col &gt;=0 &amp;&amp; col &lt; width)
+		{
+			index = get2dIndex(row+1,col);
+			if(index &gt;= 0 &amp;&amp; index &lt; (int)data.size())
+			{
+				_cell = data.at((unsigned int)index);
+				return true;
+			}
+		}
+
+		if(row &gt;= 0 &amp;&amp; row &lt; length &amp;&amp; col+1 &gt;=0 &amp;&amp; col+1 &lt; width)
+		{
+			index = get2dIndex(row,col+1);
+			if(index &gt;= 0 &amp;&amp; index &lt; (int)data.size())
+			{
+				_cell = data.at((unsigned int)index);
+				return true;
+			}
+		}
+
+		if(row-1 &gt;= 0 &amp;&amp; row-1 &lt; length &amp;&amp; col &gt;=0 &amp;&amp; col &lt; width)
+		{
+			index = get2dIndex(row-1,col);
+			if(index &gt;= 0 &amp;&amp; index &lt; (int)data.size())
+			{
+				_cell = data.at((unsigned int)index);
+				return true;
+			}
+		}
+
+		if(row &gt;= 0 &amp;&amp; row &lt; length &amp;&amp; col-1 &gt;=0 &amp;&amp; col-1 &lt; width)
+		{
+			index = get2dIndex(row,col-1);
+			if(index &gt;= 0 &amp;&amp; index &lt; (int)data.size())
+			{
+				_cell = data.at((unsigned int)index);
+				return true;
+			}
+		}
+
+		if(row+1 &gt;= 0 &amp;&amp; row+1 &lt; length &amp;&amp; col+1 &gt;=0 &amp;&amp; col+1 &lt; width)
+		{
+			index = get2dIndex(row+1,col+1);
+			if(index &gt;= 0 &amp;&amp; index &lt; (int)data.size())
+			{
+				_cell = data.at((unsigned int)index);
+				return true;
+			}
+		}
+
+		if(row-1 &gt;= 0 &amp;&amp; row-1 &lt; length &amp;&amp; col-1 &gt;=0 &amp;&amp; col-1 &lt; width)
+		{
+			index = get2dIndex(row-1,col-1);
+			if(index &gt;= 0 &amp;&amp; index &lt; (int)data.size())
+			{
+				_cell = data.at((unsigned int)index);
+				return true;
+			}
+		}
+
+		if(row-1 &gt;= 0 &amp;&amp; row-1 &lt; length &amp;&amp; col+1 &gt;=0 &amp;&amp; col+1 &lt; width)
+		{
+			index = get2dIndex(row-1,col+1);
+			if(index &gt;= 0 &amp;&amp; index &lt; (int)data.size())
+			{
+				_cell = data.at((unsigned int)index);
+				return true;
+			}
+		}
+
+		if(row+1 &gt;= 0 &amp;&amp; row+1 &lt; length &amp;&amp; col-1 &gt;=0 &amp;&amp; col-1 &lt; width)
+		{
+			index = get2dIndex(row+1,col-1);
+			if(index &gt;= 0 &amp;&amp; index &lt; (int)data.size())
+			{
+				_cell = data.at((unsigned int)index);
+				return true;
+			}
+		}
+
+		//printf("Error Getting Cell with Info: P(%f,%f) , C(%d,%d), index = %d \n", p.x, p.y, row, col, index);
+		return false;
+	}
+private:
+
+	int get2dIndex(const int&amp; r,const int&amp; c)
+	{
+		return ((r*width) + c);
+	}
+
+};
+
+class ParticleInfo
+{
+public:
+	double vel;
+	int acl; //slow down -1 braking , 0 cruising , 1 accelerating
+	PlannerHNS::LIGHT_INDICATOR indicator;
+	PlannerHNS::STATE_TYPE state;
+
+	ParticleInfo()
+	{
+		vel = 0;
+		acl = 0;
+		indicator = PlannerHNS::INDICATOR_NONE;
+		state = PlannerHNS::FORWARD_STATE;
+	}
+};
+
 }
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\LocalPlannerH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\LocalPlannerH.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -351,7 +351,7 @@ void LocalPlannerH::ReInitializePlanner(const WayPoint&amp; start_pose)
  	bool bGreenTrafficLight = true;
 
  	if(m_TotalPath.size()&gt;0)
- 		distanceToClosestStopLine = PlanningHelpers::GetDistanceToClosestStopLineAndCheck(m_TotalPath.at(pValues-&gt;iCurrSafeLane), state, stopLineID, stopSignID, trafficLightID) - critical_long_front_distance;
+ 		distanceToClosestStopLine = PlanningHelpers::GetDistanceToClosestStopLineAndCheck(m_TotalPath.at(pValues-&gt;iCurrSafeLane), state, 0, stopLineID, stopSignID, trafficLightID) - critical_long_front_distance;
 
  	if(distanceToClosestStopLine &gt; 0 &amp;&amp; distanceToClosestStopLine &lt; pValues-&gt;minStoppingDistance)
  	{
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" added_lines="1562" deleted_lines="97">
				<diff>@@ -1,14 +1,15 @@
-/*
- * MappingHelpers.cpp
- *
- *  Created on: Jul 2, 2016
- *      Author: Hatem
- */
+
+/// \file MappingHelpers.cpp
+/// \brief Helper functions for mapping operation such as (load and initialize vector maps , convert map from one format to another, .. )
+/// \author Hatem Darweesh
+/// \date Jul 2, 2016
+
 
 
 #include "op_planner/MappingHelpers.h"
 #include "op_planner/MatrixOperations.h"
 #include "op_planner/PlanningHelpers.h"
+#include &lt;float.h&gt;
 
 #include "math.h"
 #include &lt;fstream&gt;
@@ -18,10 +19,15 @@ using namespace std;
 #define _FIND_LEFT_RIGHT_LANES
 #define RIGHT_INITIAL_TURNS_COST 0
 #define LEFT_INITIAL_TURNS_COST 0
+#define DEBUG_MAP_PARSING 0
 
+namespace PlannerHNS
+{
 
-namespace PlannerHNS {
-
+int MappingHelpers::g_max_point_id = 0;
+int MappingHelpers::g_max_lane_id = 0;
+int MappingHelpers::g_max_stop_line_id = 0;
+int MappingHelpers::g_max_traffic_light_id = 0;
 double MappingHelpers::m_USING_VER_ZERO = 0;
 
 MappingHelpers::MappingHelpers() {
@@ -52,7 +58,7 @@ Lane* MappingHelpers::GetLaneById(const int&amp; id,RoadNetwork&amp; map)
 		}
 	}
 
-	return 0;
+	return nullptr;
 }
 
 int MappingHelpers::GetLaneIdByWaypointId(const int&amp; id,std::vector&lt;Lane&gt;&amp; lanes)
@@ -96,6 +102,9 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 		const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
 		const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
 		const std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt;&amp; roadedge_data,
+		const std::vector&lt;UtilityHNS::AisanWayareaFileReader::AisanWayarea&gt;&amp; wayarea_data,
+		const std::vector&lt;UtilityHNS::AisanCrossWalkFileReader::AisanCrossWalk&gt;&amp; crosswalk_data,
+		const std::vector&lt;UtilityHNS::AisanNodesFileReader::AisanNode&gt;&amp; nodes_data,
 		const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
 		const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag)
 {
@@ -111,6 +120,7 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 	for(unsigned int l= 0; l &lt; lanes_data.size(); l++)
 	{
 		curr_lane_point = lanes_data.at(l);
+		curr_lane_point.originalMapID = -1;
 
 		if(l+1 &lt; lanes_data.size())
 		{
@@ -167,7 +177,9 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 					prev_lane_point.FLID = next_lane_point.LnID;
 
 				id_replace_list.push_back(make_pair(curr_lane_point.LnID, next_lane_point.LnID));
+				int originalMapID = curr_lane_point.LnID;
 				curr_lane_point = next_lane_point;
+				curr_lane_point.originalMapID = originalMapID;
 				l++;
 			}
 		}
@@ -194,6 +206,8 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 		bool bFound = GetWayPoint(curr_lane_point.LnID, lane_obj.id, curr_lane_point.RefVel,curr_lane_point.DID,
 				dt_data, points_data,origin, wp);
 
+		wp.originalMapID = curr_lane_point.originalMapID;
+
 		if(curr_lane_point.LaneDir == 'L')
 		{
 			wp.actionCost.push_back(make_pair(LEFT_TURN_ACTION, LEFT_INITIAL_TURNS_COST));
@@ -386,6 +400,31 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 		}
 	}
 
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
+			for(unsigned int j = 0 ; j &lt; pL-&gt;points.size(); j++)
+			{
+			    if(pL-&gt;points.at(j).actionCost.size() &gt; 0)
+			      {
+				  if(pL-&gt;points.at(j).actionCost.at(0).first == LEFT_TURN_ACTION)
+				    {
+				      AssignActionCostToLane(pL, LEFT_TURN_ACTION, LEFT_INITIAL_TURNS_COST);
+				      break;
+				    }
+				  else if(pL-&gt;points.at(j).actionCost.at(0).first == RIGHT_TURN_ACTION)
+				    {
+				      AssignActionCostToLane(pL, RIGHT_TURN_ACTION, RIGHT_INITIAL_TURNS_COST);
+				    break;
+
+				    }
+			      }
+			}
+		}
+	}
+
 #ifdef FIND_LEFT_RIGHT_LANES
 	FindAdjacentLanes(map);
 #endif
@@ -409,10 +448,31 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 	//Curbs
 	ExtractCurbData(curb_data, line_data, points_data, origin, map);
 
+	//Wayarea
+	ExtractWayArea(area_data, wayarea_data, line_data, points_data, origin, map);
+
+	//Fix angle for lanes
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
+			PlannerHNS::PlanningHelpers::FixAngleOnly(pL-&gt;points);
+		}
+	}
 
 	cout &lt;&lt; "Map loaded from data with " &lt;&lt; roadLanes.size()  &lt;&lt; " lanes" &lt;&lt; endl;
 }
 
+void MappingHelpers::AssignActionCostToLane(Lane* pL, ACTION_TYPE action, double cost)
+{
+  for(unsigned int j = 0 ; j &lt; pL-&gt;points.size(); j++)
+  {
+      pL-&gt;points.at(j).actionCost.clear();
+      pL-&gt;points.at(j).actionCost.push_back(make_pair(action, cost));
+  }
+}
+
 WayPoint* MappingHelpers::FindWaypoint(const int&amp; id, RoadNetwork&amp; map)
 {
 	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
@@ -427,7 +487,7 @@ WayPoint* MappingHelpers::FindWaypoint(const int&amp; id, RoadNetwork&amp; map)
 		}
 	}
 
-	return 0;
+	return nullptr;
 }
 
 void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMapPath, RoadNetwork&amp; map, const bool&amp; bZeroOrigin)
@@ -446,12 +506,14 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 	string vector_info = vectoMapPath + "vector.csv";
 	string curb_info = vectoMapPath + "curb.csv";
 	string roadedge_info = vectoMapPath + "roadedge.csv";
-
+	string wayarea_info = vectoMapPath + "wayarea.csv";
+	string crosswalk_info = vectoMapPath + "crosswalk.csv";
 	string conn_info = vectoMapPath + "dataconnection.csv";
 
 
 	string intersection_info = vectoMapPath + "intersection.csv";
 
+	cout &lt;&lt; " &gt;&gt; Loading vector map data files ... " &lt;&lt; endl;
 	AisanCenterLinesFileReader  center_lanes(center_lines_info);
 	AisanLanesFileReader lanes(lane_info);
 	AisanPointsFileReader points(laneLinesDetails);
@@ -463,10 +525,9 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 	AisanCurbFileReader curb(curb_info);
 	AisanRoadEdgeFileReader roadedge(roadedge_info);
 	AisanDataConnFileReader conn(conn_info);
-
-	//AisanAreasFileReader areas(node_info);
-	//AisanIntersectionFileReader intersections(node_info);
-
+	AisanAreasFileReader areas(area_info);
+	AisanWayareaFileReader way_area(wayarea_info);
+	AisanCrossWalkFileReader cross_walk(crosswalk_info);
 
 
 	vector&lt;AisanNodesFileReader::AisanNode&gt; nodes_data;
@@ -481,7 +542,6 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 	vector&lt;AisanCenterLinesFileReader::AisanCenterLine&gt; dt_data;
 	center_lanes.ReadAllData(dt_data);
 
-	vector&lt;AisanAreasFileReader::AisanArea&gt; area_data;
 	vector&lt;AisanIntersectionFileReader::AisanIntersection&gt; intersection_data;
 	vector&lt;AisanLinesFileReader::AisanLine&gt; line_data;
 	lines.ReadAllData(line_data);
@@ -497,10 +557,22 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 
 	vector&lt;AisanRoadEdgeFileReader::AisanRoadEdge&gt; roadedge_data;
 	roadedge.ReadAllData(roadedge_data);
-
+	vector&lt;AisanAreasFileReader::AisanArea&gt; area_data;
+	areas.ReadAllData(area_data);
+	vector&lt;AisanWayareaFileReader::AisanWayarea&gt; way_area_data;
+	way_area.ReadAllData(way_area_data);
+	vector&lt;AisanCrossWalkFileReader::AisanCrossWalk&gt; crosswalk_data;
+	cross_walk.ReadAllData(crosswalk_data);
 	vector&lt;AisanDataConnFileReader::DataConn&gt; conn_data;
 	conn.ReadAllData(conn_data);
 
+
+	if(points_data.size() == 0)
+	{
+		std::cout &lt;&lt; std::endl &lt;&lt; "## Alert Can't Read Points Data from vector map files in path: " &lt;&lt; vectoMapPath &lt;&lt; std::endl;
+		return;
+	}
+
 	//Traffic Light Type from the file
 	// 4 , 5 -&gt; pedestrian crossing light
 	// 1 Red , 2 Green, 3 Yellow -&gt; traffic light that is important for cars (normal traffic lights )
@@ -513,9 +585,20 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 		bToyotaCityMap = 2;
 
 	// use this to transform data to origin (0,0,0)
-	ConstructRoadNetworkFromRosMessage(lanes_data, points_data, dt_data, intersection_data, area_data,
-			line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data, conn_data,
-			GetTransformationOrigin(bToyotaCityMap), map, bToyotaCityMap == 1);
+	if(nodes_data.size() &gt; 0)
+	{
+		ConstructRoadNetworkFromRosMessageV2(lanes_data, points_data, dt_data, intersection_data, area_data,
+				line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data,
+				way_area_data, crosswalk_data, nodes_data, conn_data, &amp;lanes, &amp;points, &amp;nodes, &amp;lines,
+				GetTransformationOrigin(bToyotaCityMap), map, bToyotaCityMap == 1);
+	}
+	else
+	{
+		ConstructRoadNetworkFromRosMessage(lanes_data, points_data, dt_data, intersection_data, area_data,
+						line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data,
+						way_area_data, crosswalk_data, nodes_data, conn_data,
+						GetTransformationOrigin(bToyotaCityMap), map, bToyotaCityMap == 1);
+	}
 
 	//use this when using the same coordinates as the map
 //	ConstructRoadNetworkFromRosMessage(lanes_data, points_data, dt_data, intersection_data, area_data, GPSPoint(), map);
@@ -595,7 +678,7 @@ bool MappingHelpers::GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp;
 		}
 	}
 
-	return 0;
+	return false;
 }
 
 void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
@@ -611,6 +694,8 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 		return;
 	}
 
+	std::cout &lt;&lt; " &gt;&gt; Loading KML Map file ... " &lt;&lt; std::endl;
+
 	TiXmlDocument doc(kmlFile);
 	try
 	{
@@ -624,31 +709,67 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 	}
 
 
+	std::cout &lt;&lt; " &gt;&gt; Reading Data from KML map file ... " &lt;&lt; std::endl;
+
 	pElem = doc.FirstChildElement();
 	pHeadElem = GetHeadElement(pElem);
 
+	std::cout &lt;&lt; " &gt;&gt; Load Lanes from KML file .. " &lt;&lt; std::endl;
 	vector&lt;Lane&gt; laneLinksList = GetLanesList(pHeadElem);
-	vector&lt;RoadSegment&gt; roadLinksList = GetRoadSegmentsList(pHeadElem);
-	vector&lt;StopLine&gt; stopLines = GetStopLinesList(pHeadElem);
+
+	map.roadSegments.clear();
+	map.roadSegments = GetRoadSegmentsList(pHeadElem);
+
+	std::cout &lt;&lt; " &gt;&gt; Load Traffic lights from KML file .. " &lt;&lt; std::endl;
 	vector&lt;TrafficLight&gt; trafficLights = GetTrafficLightsList(pHeadElem);
 
+	std::cout &lt;&lt; " &gt;&gt; Load Stop lines from KML file .. " &lt;&lt; std::endl;
+	vector&lt;StopLine&gt; stopLines = GetStopLinesList(pHeadElem);
+
+	std::cout &lt;&lt; " &gt;&gt; Load Signes from KML file .. " &lt;&lt; std::endl;
+	vector&lt;TrafficSign&gt; signs = GetTrafficSignsList(pHeadElem);
+
+	std::cout &lt;&lt; " &gt;&gt; Load Crossings from KML file .. " &lt;&lt; std::endl;
+	vector&lt;Crossing&gt; crossings = GetCrossingsList(pHeadElem);
+
+	std::cout &lt;&lt; " &gt;&gt; Load Markings from KML file .. " &lt;&lt; std::endl;
+	vector&lt;Marking&gt; markings = GetMarkingsList(pHeadElem);
+
+	std::cout &lt;&lt; " &gt;&gt; Load Road boundaries from KML file .. " &lt;&lt; std::endl;
+	vector&lt;Boundary&gt; boundaries = GetBoundariesList(pHeadElem);
+
+	std::cout &lt;&lt; " &gt;&gt; Load Curbs from KML file .. " &lt;&lt; std::endl;
+	vector&lt;Curb&gt; curbs = GetCurbsList(pHeadElem);
+
+
+	std::cout &lt;&lt; " &gt;&gt; Linking data pointers ... " &lt;&lt; stopLines.size() &lt;&lt; std::endl;
+
+	map.signs.clear();
+	map.signs = signs;
+
+	map.crossings.clear();
+	map.crossings = crossings;
+
+	map.markings.clear();
+	map.markings = markings;
+
+	map.boundaries.clear();
+	map.boundaries = boundaries;
+
+	map.curbs.clear();
+	map.curbs = curbs;
 
 	//Fill the relations
-	for(unsigned int i= 0; i&lt;roadLinksList.size(); i++ )
+	for(unsigned int i= 0; i&lt;map.roadSegments.size(); i++ )
 	{
 		for(unsigned int j=0; j &lt; laneLinksList.size(); j++)
 		{
-			//if(laneLinksList.at(j).roadId == roadLinksList.at(i).id)
-			{
-				PlanningHelpers::CalcAngleAndCost(laneLinksList.at(j).points);
-				roadLinksList.at(i).Lanes.push_back(laneLinksList.at(j));
-			}
+			PlanningHelpers::CalcAngleAndCost(laneLinksList.at(j).points);
+			map.roadSegments.at(i).Lanes.push_back(laneLinksList.at(j));
 		}
 	}
 
-	map.roadSegments.clear();
-	map.roadSegments = roadLinksList;
-
+	cout &lt;&lt; " &gt;&gt; Link lanes and waypoints with pointers ... " &lt;&lt; endl;
 	//Link Lanes and lane's waypoints by pointers
 	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
 	{
@@ -686,6 +807,7 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 	}
 
 	//Link waypoints
+	cout &lt;&lt; " &gt;&gt; Link Lane change semantics ... " &lt;&lt; endl;
 	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
 	{
 		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
@@ -724,6 +846,7 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 	map.trafficLights = trafficLights;
 
 	//Link waypoints &amp;&amp; StopLines
+	cout &lt;&lt; " &gt;&gt; Link Stop lines and Traffic lights ... " &lt;&lt; endl;
 	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
 	{
 		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
@@ -750,6 +873,9 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 		}
 	}
 
+	cout &lt;&lt; " &gt;&gt; Find Max IDs ... " &lt;&lt; endl;
+	GetMapMaxIds(map);
+
 	cout &lt;&lt; "Map loaded from kml file with (" &lt;&lt; laneLinksList.size()  &lt;&lt; ") lanes, First Point ( " &lt;&lt; GetFirstWaypoint(map).pos.ToString() &lt;&lt; ")"&lt;&lt; endl;
 
 }
@@ -766,13 +892,15 @@ TiXmlElement* MappingHelpers::GetHeadElement(TiXmlElement* pMainElem)
 		pElem = pElem-&gt;FirstChildElement("Document");
 
 	if(!pElem)
-		return 0;
+	{
+		return nullptr;
+	}
 	return pElem;
 }
 
 TiXmlElement* MappingHelpers::GetDataFolder(const string&amp; folderName, TiXmlElement* pMainElem)
 {
-	if(!pMainElem) return 0;
+	if(!pMainElem) return nullptr;
 
 	TiXmlElement* pElem = pMainElem-&gt;FirstChildElement("Folder");
 
@@ -785,7 +913,7 @@ TiXmlElement* MappingHelpers::GetDataFolder(const string&amp; folderName, TiXmlEleme
 		if(folderID.compare(folderName)==0)
 			return pElem;
 	}
-	return 0;
+	return nullptr;
 }
 
 WayPoint* MappingHelpers::GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const bool bDirectionBased)
@@ -798,7 +926,7 @@ WayPoint* MappingHelpers::GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNet
 		distance_to_nearest_lane += 1;
 	}
 
-	if(!pLane) return 0;
+	if(!pLane) return nullptr;
 
 	int closest_index = PlanningHelpers::GetClosestNextPointIndexFast(pLane-&gt;points, pos);
 
@@ -835,7 +963,7 @@ WayPoint* MappingHelpers::GetClosestBackWaypointFromMap(const WayPoint&amp; pos, Roa
 		distance_to_nearest_lane += 1;
 	}
 
-	if(!pLane) return 0;
+	if(!pLane) return nullptr;
 
 	int closest_index = PlanningHelpers::GetClosestNextPointIndexFast(pLane-&gt;points, pos);
 
@@ -874,14 +1002,14 @@ Lane* MappingHelpers::GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; ma
 {
 	vector&lt;pair&lt;double, Lane*&gt; &gt; laneLinksList;
 	double d = 0;
-	double min_d = 9999999999;
+	double min_d = DBL_MAX;
 	for(unsigned int j=0; j&lt; map.roadSegments.size(); j ++)
 	{
 		for(unsigned int k=0; k&lt; map.roadSegments.at(j).Lanes.size(); k ++)
 		{
 			//Lane* pLane = &amp;pEdge-&gt;lanes.at(k);
 			 d = 0;
-			min_d = 9999999999;
+			min_d = DBL_MAX;
 			for(unsigned int pindex=0; pindex&lt; map.roadSegments.at(j).Lanes.at(k).points.size(); pindex ++)
 			{
 
@@ -895,9 +1023,9 @@ Lane* MappingHelpers::GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; ma
 		}
 	}
 
-	if(laneLinksList.size() == 0) return 0;
+	if(laneLinksList.size() == 0) return nullptr;
 
-	min_d = 999999999;
+	min_d = DBL_MAX;
 	Lane* closest_lane = 0;
 	for(unsigned int i = 0; i &lt; laneLinksList.size(); i++)
 	{
@@ -926,14 +1054,14 @@ vector&lt;Lane*&gt; MappingHelpers::GetClosestLanesListFromMap(const WayPoint&amp; pos, Ro
 {
 	vector&lt;pair&lt;double, Lane*&gt; &gt; laneLinksList;
 	double d = 0;
-	double min_d = 9999999999;
+	double min_d = DBL_MAX;
 	for(unsigned int j=0; j&lt; map.roadSegments.size(); j ++)
 	{
 		for(unsigned int k=0; k&lt; map.roadSegments.at(j).Lanes.size(); k ++)
 		{
 			//Lane* pLane = &amp;pEdge-&gt;lanes.at(k);
 			 d = 0;
-			min_d = 9999999999;
+			min_d = DBL_MAX;
 			for(unsigned int pindex=0; pindex&lt; map.roadSegments.at(j).Lanes.at(k).points.size(); pindex ++)
 			{
 
@@ -959,7 +1087,7 @@ vector&lt;Lane*&gt; MappingHelpers::GetClosestLanesListFromMap(const WayPoint&amp; pos, Ro
 		if(info.perp_distance == 0 &amp;&amp; laneLinksList.at(i).first != 0)
 			continue;
 
-		if(bDirectionBased &amp;&amp; fabs(info.perp_distance) &lt; distance &amp;&amp; fabs(info.angle_diff) &lt; 45)
+		if(bDirectionBased &amp;&amp; fabs(info.perp_distance) &lt; distance &amp;&amp; fabs(info.angle_diff) &lt; 30)
 		{
 			closest_lanes.push_back(laneLinksList.at(i).second);
 		}
@@ -976,7 +1104,7 @@ Lane* MappingHelpers::GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, R
 {
 	vector&lt;pair&lt;double, WayPoint*&gt; &gt; laneLinksList;
 	double d = 0;
-	double min_d = 9999999999;
+	double min_d = DBL_MAX;
 	int min_i = 0;
 	for(unsigned int j=0; j&lt; map.roadSegments.size(); j ++)
 	{
@@ -984,7 +1112,7 @@ Lane* MappingHelpers::GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, R
 		{
 			//Lane* pLane = &amp;pEdge-&gt;lanes.at(k);
 			d = 0;
-			min_d = 9999999999;
+			min_d = DBL_MAX;
 			for(unsigned int pindex=0; pindex&lt; map.roadSegments.at(j).Lanes.at(k).points.size(); pindex ++)
 			{
 
@@ -1001,9 +1129,9 @@ Lane* MappingHelpers::GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, R
 		}
 	}
 
-	if(laneLinksList.size() == 0) return 0;
+	if(laneLinksList.size() == 0) return nullptr;
 
-	min_d = 999999999;
+	min_d = DBL_MAX;
 	Lane* closest_lane = 0;
 	double a_diff = 0;
 	for(unsigned int i = 0; i &lt; laneLinksList.size(); i++)
@@ -1090,7 +1218,7 @@ WayPoint* MappingHelpers::GetLastWaypoint(RoadNetwork&amp; map)
 			return &amp;lanes-&gt;at(lanes-&gt;size()-1).points.at(lanes-&gt;at(lanes-&gt;size()-1).points.size()-1);
 	}
 
-	return 0;
+	return nullptr;
 }
 
 void MappingHelpers::GetUniqueNextLanes(const Lane* l,  const vector&lt;Lane*&gt;&amp; traversed_lanes, vector&lt;Lane*&gt;&amp; lanes_list)
@@ -1114,19 +1242,205 @@ void MappingHelpers::GetUniqueNextLanes(const Lane* l,  const vector&lt;Lane*&gt;&amp; tra
 
 Lane* MappingHelpers::GetLaneFromPath(const WayPoint&amp; currPos, const std::vector&lt;WayPoint&gt;&amp; currPath)
 {
-	if(currPath.size() &lt; 1) return 0;
+	if(currPath.size() &lt; 1) return nullptr;
 
 	int closest_index = PlanningHelpers::GetClosestNextPointIndexFast(currPath, currPos);
 
 	return currPath.at(closest_index).pLane;
 }
 
+std::vector&lt;Curb&gt; MappingHelpers::GetCurbsList(TiXmlElement* pElem)
+{
+	vector&lt;Curb&gt; cList;
+	TiXmlElement* pCurbs = GetDataFolder("CurbsLines", pElem);
+	if(!pCurbs)
+		return cList;
+
+	TiXmlElement* pE = pCurbs-&gt;FirstChildElement("Placemark");
+	for( ; pE; pE=pE-&gt;NextSiblingElement())
+	{
+		string tfID;
+		TiXmlElement* pNameXml = pE-&gt;FirstChildElement("name");
+
+		if(pNameXml)
+		{
+			tfID = pNameXml-&gt;GetText();
+			Curb c;
+			c.id = GetIDsFromPrefix(tfID, "BID", "LnID").at(0);
+			c.laneId = GetIDsFromPrefix(tfID, "LnID", "RdID").at(0);
+			c.roadId = GetIDsFromPrefix(tfID, "RdID", "").at(0);
+
+			TiXmlElement* pPoints = pE-&gt;FirstChildElement("LineString")-&gt;FirstChildElement("coordinates");
+			c.points = GetPointsData(pPoints);
+
+			cList.push_back(c);
+		}
+	}
+
+	return cList;
+}
+
+std::vector&lt;Boundary&gt; MappingHelpers::GetBoundariesList(TiXmlElement* pElem)
+{
+	vector&lt;Boundary&gt; bList;
+	TiXmlElement* pBoundaries = GetDataFolder("Boundaries", pElem);
+	if(!pBoundaries)
+		return bList;
+
+	TiXmlElement* pE = pBoundaries-&gt;FirstChildElement("Placemark");
+	for( ; pE; pE=pE-&gt;NextSiblingElement())
+	{
+		string tfID;
+		TiXmlElement* pNameXml = pE-&gt;FirstChildElement("name");
+
+		if(pNameXml)
+		{
+			tfID = pNameXml-&gt;GetText();
+			Boundary b;
+			b.id = GetIDsFromPrefix(tfID, "BID", "RdID").at(0);
+			b.roadId = GetIDsFromPrefix(tfID, "RdID", "").at(0);
+
+			TiXmlElement* pPoints = pE-&gt;FirstChildElement("LineString")-&gt;FirstChildElement("coordinates");
+			b.points = GetPointsData(pPoints);
+
+			bList.push_back(b);
+		}
+	}
+
+	return bList;
+}
+
+std::vector&lt;Marking&gt; MappingHelpers::GetMarkingsList(TiXmlElement* pElem)
+{
+	vector&lt;Marking&gt; mList;
+	TiXmlElement* pMarkings= GetDataFolder("Markings", pElem);
+	if(!pMarkings)
+		return mList;
+
+	TiXmlElement* pE = pMarkings-&gt;FirstChildElement("Placemark");
+	for( ; pE; pE=pE-&gt;NextSiblingElement())
+	{
+		string tfID;
+		TiXmlElement* pNameXml =pE-&gt;FirstChildElement("name");
+
+		if(pNameXml)
+		{
+			tfID = pNameXml-&gt;GetText();
+			Marking m;
+			m.id = GetIDsFromPrefix(tfID, "MID", "LnID").at(0);
+			m.laneId = GetIDsFromPrefix(tfID, "LnID", "RdID").at(0);
+			m.roadId = GetIDsFromPrefix(tfID, "RdID", "").at(0);
+
+			TiXmlElement* pPoints = pE-&gt;FirstChildElement("LineString")-&gt;FirstChildElement("coordinates");
+
+			m.points = GetPointsData(pPoints);
+
+			if(m.points.size() &gt; 0)
+			{
+				//first item is the center of the marking
+				m.center = m.points.at(0);
+				m.points.erase(m.points.begin()+0);
+			}
+
+			mList.push_back(m);
+		}
+	}
+
+	return mList;
+}
+
+std::vector&lt;Crossing&gt; MappingHelpers::GetCrossingsList(TiXmlElement* pElem)
+{
+	vector&lt;Crossing&gt; crossList;
+	TiXmlElement* pCrossings= GetDataFolder("Crossings", pElem);
+
+	if(!pCrossings)
+		return crossList;
+
+	TiXmlElement* pE = pCrossings-&gt;FirstChildElement("Placemark");
+	for( ; pE; pE=pE-&gt;NextSiblingElement())
+	{
+		string tfID;
+		TiXmlElement* pNameXml =pE-&gt;FirstChildElement("name");
+
+		if(pNameXml)
+		{
+			tfID = pNameXml-&gt;GetText();
+			Crossing cross;
+			cross.id = GetIDsFromPrefix(tfID, "CRID", "RdID").at(0);
+			cross.roadId = GetIDsFromPrefix(tfID, "RdID", "").at(0);
+
+			TiXmlElement* pPoints = pE-&gt;FirstChildElement("LineString")-&gt;FirstChildElement("coordinates");
+			cross.points = GetPointsData(pPoints);
+
+			crossList.push_back(cross);
+		}
+	}
+
+	return crossList;
+}
+
+std::vector&lt;TrafficSign&gt; MappingHelpers::GetTrafficSignsList(TiXmlElement* pElem)
+{
+	vector&lt;TrafficSign&gt; tsList;
+	TiXmlElement* pSigns = GetDataFolder("TrafficSigns", pElem);
+
+	if(!pSigns)
+		return tsList;
+
+	TiXmlElement* pE = pSigns-&gt;FirstChildElement("Placemark");
+	for( ; pE; pE=pE-&gt;NextSiblingElement())
+	{
+		string tfID;
+		TiXmlElement* pNameXml =pE-&gt;FirstChildElement("name");
+
+		if(pNameXml)
+		{
+		  tfID = pNameXml-&gt;GetText();
+
+		  	TrafficSign ts;
+			ts.id = GetIDsFromPrefix(tfID, "TSID", "LnID").at(0);
+			ts.laneId = GetIDsFromPrefix(tfID, "LnID", "RdID").at(0);
+			ts.roadId = GetIDsFromPrefix(tfID, "RdID", "Type").at(0);
+			int iType = GetIDsFromPrefix(tfID, "Type", "").at(0);
+			switch(iType)
+			{
+			case 0:
+				ts.signType = UNKNOWN_SIGN;
+				break;
+			case 1:
+				ts.signType = STOP_SIGN;
+				break;
+			case 2:
+				ts.signType = MAX_SPEED_SIGN;
+				break;
+			case 3:
+				ts.signType = MIN_SPEED_SIGN;
+				break;
+			default:
+				ts.signType = STOP_SIGN;
+				break;
+			}
+
+
+			TiXmlElement* pPoints = pE-&gt;FirstChildElement("LineString")-&gt;FirstChildElement("coordinates");
+			ts.pos = GetPointsData(pPoints).at(0);
+
+			tsList.push_back(ts);
+		}
+	}
+
+	return tsList;
+}
 
 std::vector&lt;StopLine&gt; MappingHelpers::GetStopLinesList(TiXmlElement* pElem)
 {
 	vector&lt;StopLine&gt; slList;
 	TiXmlElement* pStopLines = GetDataFolder("StopLines", pElem);
 
+	if(!pStopLines)
+		return slList;
+
 	TiXmlElement* pE = pStopLines-&gt;FirstChildElement("Placemark");
 	for( ; pE; pE=pE-&gt;NextSiblingElement())
 	{
@@ -1140,8 +1454,10 @@ std::vector&lt;StopLine&gt; MappingHelpers::GetStopLinesList(TiXmlElement* pElem)
 			StopLine sl;
 			sl.id = GetIDsFromPrefix(tfID, "SLID", "LnID").at(0);
 			sl.laneId = GetIDsFromPrefix(tfID, "LnID", "TSID").at(0);
-			sl.stopSignID = GetIDsFromPrefix(tfID, "TSID", "TLTID").at(0);
-			sl.trafficLightID = GetIDsFromPrefix(tfID, "TLTID", "").at(0);
+//			sl.stopSignID = GetIDsFromPrefix(tfID, "TSID", "TLTID").at(0);
+//			sl.trafficLightID = GetIDsFromPrefix(tfID, "TLTID", "").at(0);
+			sl.stopSignID = GetIDsFromPrefix(tfID, "TSID", "TLID").at(0);
+			sl.trafficLightID = GetIDsFromPrefix(tfID, "TLID", "").at(0);
 
 
 			TiXmlElement* pPoints = pE-&gt;FirstChildElement("LineString")-&gt;FirstChildElement("coordinates");
@@ -1159,6 +1475,9 @@ std::vector&lt;TrafficLight&gt; MappingHelpers::GetTrafficLightsList(TiXmlElement* pEl
 	vector&lt;TrafficLight&gt; tlList;
 	TiXmlElement* pLightsLines = GetDataFolder("TrafficLights", pElem);
 
+	if(!pLightsLines)
+		return tlList;
+
 	TiXmlElement* pE = pLightsLines-&gt;FirstChildElement("Placemark");
 	for( ; pE; pE=pE-&gt;NextSiblingElement())
 	{
@@ -1170,7 +1489,8 @@ std::vector&lt;TrafficLight&gt; MappingHelpers::GetTrafficLightsList(TiXmlElement* pEl
 		  tfID = pNameXml-&gt;GetText();
 
 			TrafficLight tl;
-			tl.id = GetIDsFromPrefix(tfID, "SLID", "LnID").at(0);
+			//tl.id = GetIDsFromPrefix(tfID, "SLID", "LnID").at(0);
+			tl.id = GetIDsFromPrefix(tfID, "TLID", "LnID").at(0);
 			tl.laneIds = GetIDsFromPrefix(tfID, "LnID", "");
 
 			TiXmlElement* pPoints = pE-&gt;FirstChildElement("Point")-&gt;FirstChildElement("coordinates");
@@ -1188,6 +1508,9 @@ vector&lt;Lane&gt; MappingHelpers::GetLanesList(TiXmlElement* pElem)
 	vector&lt;Lane&gt; llList;
 	TiXmlElement* pLaneLinks = GetDataFolder("Lanes", pElem);
 
+	if(!pLaneLinks)
+		return llList;
+
 	TiXmlElement* pE = pLaneLinks-&gt;FirstChildElement("Folder");
 	for( ; pE; pE=pE-&gt;NextSiblingElement())
 	{
@@ -1221,6 +1544,9 @@ vector&lt;RoadSegment&gt; MappingHelpers::GetRoadSegmentsList(TiXmlElement* pElem)
 	vector&lt;RoadSegment&gt; rlList;
 	TiXmlElement* pRoadLinks = GetDataFolder("RoadSegments", pElem);
 
+	if(!pRoadLinks)
+		return rlList;
+
 	TiXmlElement* pE = pRoadLinks-&gt;FirstChildElement("Placemark");
 	for( ; pE; pE=pE-&gt;NextSiblingElement())
 	{
@@ -1565,7 +1891,7 @@ void MappingHelpers::FindAdjacentLanes(RoadNetwork&amp; map)
 
 					if(pL-&gt;id != map.roadSegments.at(rs_2).Lanes.at(i2).id &amp;&amp; angle_diff &lt; 0.05 &amp;&amp; distance &lt; 3.5 &amp;&amp; distance &gt; 2.5)
 					{
-						double perp_distance = 99999;
+						double perp_distance = DBL_MAX;
 						if(pL-&gt;points.size() &gt; 2 &amp;&amp; map.roadSegments.at(rs_2).Lanes.at(i2).points.size()&gt;2)
 						{
 							RelativeInfo info;
@@ -1636,6 +1962,8 @@ void MappingHelpers::ExtractSignalData(const std::vector&lt;UtilityHNS::AisanSignal
 				}
 			}
 			map.trafficLights.push_back(tl);
+			if(tl.id &gt; g_max_traffic_light_id)
+				g_max_traffic_light_id = tl.id;
 		}
 	}
 }
@@ -1650,6 +1978,10 @@ void MappingHelpers::ExtractStopLinesData(const std::vector&lt;UtilityHNS::AisanSto
 		StopLine sl;
 		sl.linkID = stop_line_data.at(ist).LinkID;
 		sl.id = stop_line_data.at(ist).ID;
+		if(stop_line_data.at(ist).TLID&gt;0)
+			sl.trafficLightID = stop_line_data.at(ist).TLID;
+		else
+			sl.stopSignID = 100+ist;
 
 		for(unsigned int il=0; il &lt; line_data.size(); il++)
 		{
@@ -1667,6 +1999,8 @@ void MappingHelpers::ExtractStopLinesData(const std::vector&lt;UtilityHNS::AisanSto
 			}
 		}
 		map.stopLines.push_back(sl);
+		if(sl.id &gt; g_max_stop_line_id)
+			g_max_stop_line_id = sl.id;
 	}
 }
 
@@ -1685,7 +2019,7 @@ void MappingHelpers::ExtractCurbData(const std::vector&lt;UtilityHNS::AisanCurbFile
 				if(curb_data.at(ic).LID == line_data.at(il).LID)
 				{
 					int s_id = line_data.at(il).BPID;
-					int e_id = line_data.at(il).FPID;
+					//int e_id = line_data.at(il).FPID;
 					for(unsigned int ip = 0; ip &lt; points_data.size(); ip++)
 					{
 						if(points_data.at(ip).PID == s_id)
@@ -1707,6 +2041,45 @@ void MappingHelpers::ExtractCurbData(const std::vector&lt;UtilityHNS::AisanCurbFile
 		}
 }
 
+void MappingHelpers::ExtractWayArea(const std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt;&amp; area_data,
+		const std::vector&lt;UtilityHNS::AisanWayareaFileReader::AisanWayarea&gt;&amp; wayarea_data,
+			const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
+			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+			const GPSPoint&amp; origin, RoadNetwork&amp; map)
+{
+	for(unsigned int iw=0; iw &lt; wayarea_data.size(); iw ++)
+	{
+		Boundary bound;
+		bound.id = wayarea_data.at(iw).ID;
+
+		for(unsigned int ia=0; ia &lt; area_data.size(); ia ++)
+		{
+			if(wayarea_data.at(iw).AID == area_data.at(ia).AID)
+			{
+				int s_id = area_data.at(ia).SLID;
+				int e_id = area_data.at(ia).ELID;
+
+				for(unsigned int il=0; il&lt; line_data.size(); il++)
+				{
+					if(line_data.at(il).LID &gt;= s_id &amp;&amp; line_data.at(il).LID &lt;= e_id)
+					{
+						for(unsigned int ip=0; ip &lt; points_data.size(); ip++)
+						{
+							if(points_data.at(ip).PID == line_data.at(il).BPID)
+							{
+								GPSPoint p(points_data.at(ip).Ly + origin.x, points_data.at(ip).Bx + origin.y, points_data.at(ip).H + origin.z, 0);
+								bound.points.push_back(p);
+							}
+						}
+					}
+				}
+			}
+		}
+
+		map.boundaries.push_back(bound);
+	}
+}
+
 void MappingHelpers::LinkMissingBranchingWayPoints(RoadNetwork&amp; map)
 {
 	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
@@ -1727,6 +2100,40 @@ void MappingHelpers::LinkMissingBranchingWayPoints(RoadNetwork&amp; map)
 
 void MappingHelpers::LinkTrafficLightsAndStopLines(RoadNetwork&amp; map)
 {
+
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
+			{
+				for(unsigned int isl = 0; isl &lt; map.stopLines.size(); isl++)
+				{
+					WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
+
+					if(map.stopLines.at(isl).linkID == pWP-&gt;id || map.stopLines.at(isl).linkID == pWP-&gt;originalMapID)
+					{
+						map.stopLines.at(isl).laneId = pWP-&gt;laneId;
+						map.stopLines.at(isl).pLane = pWP-&gt;pLane;
+						map.roadSegments.at(rs).Lanes.at(i).stopLines.push_back(map.stopLines.at(isl));
+
+						pWP-&gt;stopLineID = map.stopLines.at(isl).id;
+
+						for(unsigned int itl = 0; itl &lt; map.trafficLights.size(); itl++)
+						{
+							if(map.trafficLights.at(itl).id == map.stopLines.at(isl).trafficLightID)
+							{
+								map.trafficLights.at(itl).laneIds.push_back(pWP-&gt;laneId);
+								map.trafficLights.at(itl).pLanes.push_back(pWP-&gt;pLane);
+							}
+						}
+						break;
+					}
+				}
+			}
+		}
+	}
+
 	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
 	{
 		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
@@ -1736,10 +2143,8 @@ void MappingHelpers::LinkTrafficLightsAndStopLines(RoadNetwork&amp; map)
 				for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
 				{
 					WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
-					if(map.trafficLights.at(itl).linkID == pWP-&gt;id)
+					if(map.trafficLights.at(itl).linkID == pWP-&gt;id || map.trafficLights.at(itl).linkID == pWP-&gt;originalMapID)
 					{
-						map.trafficLights.at(itl).laneIds.push_back(pWP-&gt;laneId);
-						map.trafficLights.at(itl).pLanes.push_back(pWP-&gt;pLane);
 						map.roadSegments.at(rs).Lanes.at(i).trafficlights.push_back(map.trafficLights.at(itl));
 						break;
 					}
@@ -1747,77 +2152,1137 @@ void MappingHelpers::LinkTrafficLightsAndStopLines(RoadNetwork&amp; map)
 			}
 		}
 	}
+}
 
+void MappingHelpers::LinkTrafficLightsAndStopLinesConData(const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
+		const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; id_replace_list, RoadNetwork&amp; map)
+{
 	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
 		{
-			for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+
+			for(unsigned int ic = 0; ic &lt; conn_data.size(); ic++)
 			{
-				for(unsigned int isl = 0; isl &lt; map.stopLines.size(); isl++)
+				UtilityHNS::AisanDataConnFileReader::DataConn data_conn = conn_data.at(ic);
+				ReplaceMyID(data_conn.LID , id_replace_list);
+
+				if(map.roadSegments.at(rs).Lanes.at(i).id == data_conn.LID)
 				{
-					for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
+					for(unsigned int itl = 0; itl &lt; map.trafficLights.size(); itl++)
+					{
+						if(map.trafficLights.at(itl).id == data_conn.SID)
+						{
+							map.trafficLights.at(itl).laneIds.push_back(map.roadSegments.at(rs).Lanes.at(i).id);
+							map.trafficLights.at(itl).pLanes.push_back(&amp;map.roadSegments.at(rs).Lanes.at(i));
+							map.roadSegments.at(rs).Lanes.at(i).trafficlights.push_back(map.trafficLights.at(itl));
+						}
+					}
+
+					for(unsigned int isl = 0; isl &lt; map.stopLines.size(); isl++)
 					{
-						WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
-						if(map.stopLines.at(isl).linkID == pWP-&gt;id)
+						if(map.stopLines.at(isl).id == data_conn.SLID)
 						{
-							map.stopLines.at(isl).laneId = pWP-&gt;laneId;
-							map.stopLines.at(isl).pLane = pWP-&gt;pLane;
-							if(pWP-&gt;pLane-&gt;trafficlights.size() &gt; 0)
-								map.stopLines.at(isl).trafficLightID = pWP-&gt;pLane-&gt;trafficlights.at(0).id;
-							map.stopLines.at(isl).stopSignID = 100+isl;
+							map.stopLines.at(isl).laneId = map.roadSegments.at(rs).Lanes.at(i).id;
+							map.stopLines.at(isl).pLane = &amp;map.roadSegments.at(rs).Lanes.at(i);
+							map.stopLines.at(isl).trafficLightID = data_conn.SID;
+							map.stopLines.at(isl).stopSignID = data_conn.SSID;
 							map.roadSegments.at(rs).Lanes.at(i).stopLines.push_back(map.stopLines.at(isl));
 							WayPoint wp((map.stopLines.at(isl).points.at(0).x+map.stopLines.at(isl).points.at(1).x)/2.0, (map.stopLines.at(isl).points.at(0).y+map.stopLines.at(isl).points.at(1).y)/2.0, (map.stopLines.at(isl).points.at(0).z+map.stopLines.at(isl).points.at(1).z)/2.0, (map.stopLines.at(isl).points.at(0).a+map.stopLines.at(isl).points.at(1).a)/2.0);
 							map.roadSegments.at(rs).Lanes.at(i).points.at(PlanningHelpers::GetClosestNextPointIndexFast(map.roadSegments.at(rs).Lanes.at(i).points, wp)).stopLineID = map.stopLines.at(isl).id;
-							break;
 						}
 					}
 				}
 			}
+
 		}
+	}
 }
 
-void MappingHelpers::LinkTrafficLightsAndStopLinesConData(const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
-		const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; id_replace_list, RoadNetwork&amp; map)
+void MappingHelpers::UpdateMapWithOccupancyGrid(OccupancyToGridMap&amp; map_info, const std::vector&lt;int&gt;&amp; data, RoadNetwork&amp; map, std::vector&lt;WayPoint*&gt;&amp; updated_list)
 {
+	PlannerHNS::Mat3 rotationMat(- map_info.center.pos.a);
+	PlannerHNS::Mat3 translationMat(-map_info.center.pos.x, -map_info.center.pos.y);
+	updated_list.clear();
+
 	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
 		{
-			for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+			for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
 			{
+				WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
 
-				for(unsigned int ic = 0; ic &lt; conn_data.size(); ic++)
-				{
-					UtilityHNS::AisanDataConnFileReader::DataConn data_conn = conn_data.at(ic);
-					ReplaceMyID(data_conn.LID , id_replace_list);
+				GPSPoint relative_point = pWP-&gt;pos;
+				relative_point = translationMat * relative_point;
+				relative_point = rotationMat *relative_point;
 
-					if(map.roadSegments.at(rs).Lanes.at(i).id == data_conn.LID)
+				int cell_value = 0;
+				if(map_info.GetCellIndexFromPoint(relative_point, data, cell_value) == true)
+				{
+					if(cell_value == 0)
 					{
-						for(unsigned int itl = 0; itl &lt; map.trafficLights.size(); itl++)
+						bool bFound = false;
+						for(unsigned int i_action=0; i_action &lt; pWP-&gt;actionCost.size(); i_action++)
 						{
-							if(map.trafficLights.at(itl).id == data_conn.SID)
+							if(pWP-&gt;actionCost.at(i_action).first == FORWARD_ACTION)
 							{
-								map.trafficLights.at(itl).laneIds.push_back(map.roadSegments.at(rs).Lanes.at(i).id);
-								map.trafficLights.at(itl).pLanes.push_back(&amp;map.roadSegments.at(rs).Lanes.at(i));
-								map.roadSegments.at(rs).Lanes.at(i).trafficlights.push_back(map.trafficLights.at(itl));
+								pWP-&gt;actionCost.at(i_action).second = 100;
+								bFound = true;
 							}
 						}
 
-						for(unsigned int isl = 0; isl &lt; map.stopLines.size(); isl++)
-						{
-							if(map.stopLines.at(isl).id == data_conn.SLID)
-							{
-								map.stopLines.at(isl).laneId = map.roadSegments.at(rs).Lanes.at(i).id;
-								map.stopLines.at(isl).pLane = &amp;map.roadSegments.at(rs).Lanes.at(i);
-								map.stopLines.at(isl).trafficLightID = data_conn.SID;
-								map.stopLines.at(isl).stopSignID = data_conn.SSID;
-								map.roadSegments.at(rs).Lanes.at(i).stopLines.push_back(map.stopLines.at(isl));
-								WayPoint wp((map.stopLines.at(isl).points.at(0).x+map.stopLines.at(isl).points.at(1).x)/2.0, (map.stopLines.at(isl).points.at(0).y+map.stopLines.at(isl).points.at(1).y)/2.0, (map.stopLines.at(isl).points.at(0).z+map.stopLines.at(isl).points.at(1).z)/2.0, (map.stopLines.at(isl).points.at(0).a+map.stopLines.at(isl).points.at(1).a)/2.0);
-								map.roadSegments.at(rs).Lanes.at(i).points.at(PlanningHelpers::GetClosestNextPointIndexFast(map.roadSegments.at(rs).Lanes.at(i).points, wp)).stopLineID = map.stopLines.at(isl).id;
-							}
-						}
+						if(!bFound)
+							pWP-&gt;actionCost.push_back(make_pair(FORWARD_ACTION, 100));
+
+						updated_list.push_back(pWP);
 					}
 				}
-
 			}
 		}
-
+	}
+}
+
+bool MappingHelpers::GetPointFromDataList(UtilityHNS::AisanPointsFileReader* pPointsData,const int&amp; pid, WayPoint&amp; out_wp)
+{
+	AisanPointsFileReader::AisanPoints* pP =  pPointsData-&gt;GetDataRowById(pid);
+
+	if(pP!=nullptr)
+	{
+		out_wp.id = pP-&gt;PID;
+		out_wp.pos.x = pP-&gt;Ly;
+		out_wp.pos.y = pP-&gt;Bx;
+		out_wp.pos.z = pP-&gt;H;
+		return true;
+	}
+
+	return false;
+}
+
+int MappingHelpers::GetBeginPointIdFromLaneNo(UtilityHNS::AisanLanesFileReader* pLaneData,
+		UtilityHNS::AisanPointsFileReader* pPointsData,
+		UtilityHNS::AisanNodesFileReader* pNodesData,const int&amp; LnID)
+{
+	UtilityHNS::AisanLanesFileReader::AisanLane* pL = nullptr;
+	UtilityHNS::AisanPointsFileReader::AisanPoints* pP = nullptr;
+	UtilityHNS::AisanNodesFileReader::AisanNode* pN = nullptr;
+
+	pL = pLaneData-&gt;GetDataRowById(LnID);
+	if(pL!=nullptr)
+		return pL-&gt;BNID;
+
+	return 0;
+}
+
+int MappingHelpers::GetEndPointIdFromLaneNo(UtilityHNS::AisanLanesFileReader* pLaneData,
+		UtilityHNS::AisanPointsFileReader* pPointsData,
+		UtilityHNS::AisanNodesFileReader* pNodesData,const int&amp; LnID)
+{
+	UtilityHNS::AisanLanesFileReader::AisanLane* pL = nullptr;
+	UtilityHNS::AisanPointsFileReader::AisanPoints* pP = nullptr;
+	UtilityHNS::AisanNodesFileReader::AisanNode* pN = nullptr;
+
+	pL = pLaneData-&gt;GetDataRowById(LnID);
+	if(pL!=nullptr)
+		return pL-&gt;FNID;
+
+	return 0;
+}
+
+bool MappingHelpers::IsStartLanePoint(UtilityHNS::AisanLanesFileReader* pLaneData, UtilityHNS::AisanLanesFileReader::AisanLane* pL)
+{
+	if(pL-&gt;JCT &gt; 0 || pL-&gt;BLID == 0)
+		return true;
+
+	if(pL-&gt;BLID2 != 0 || pL-&gt;BLID3 != 0 || pL-&gt;BLID4 != 0)
+		return true;
+
+	UtilityHNS::AisanLanesFileReader::AisanLane* pPrevL = pLaneData-&gt;GetDataRowById(pL-&gt;BLID);
+	if(pPrevL == nullptr || pPrevL-&gt;FLID2 &gt; 0 || pPrevL-&gt;FLID3 &gt; 0 || pPrevL-&gt;FLID4 &gt; 0 || pPrevL-&gt;JCT &gt; 0)
+		return true;
+
+	return false;
+}
+
+bool MappingHelpers::IsEndLanePoint(UtilityHNS::AisanLanesFileReader* pLaneData, UtilityHNS::AisanLanesFileReader::AisanLane* pL)
+{
+	if(pL-&gt;FLID2 &gt; 0 || pL-&gt;FLID3 &gt; 0 || pL-&gt;FLID4 &gt; 0)
+		return true;
+
+	UtilityHNS::AisanLanesFileReader::AisanLane* pNextL = pLaneData-&gt;GetDataRowById(pL-&gt;FLID);
+
+	return IsStartLanePoint(pLaneData, pNextL);
+}
+
+void MappingHelpers::GetLanesStartPoints(UtilityHNS::AisanLanesFileReader* pLaneData,
+				std::vector&lt;int&gt;&amp; m_LanesStartIds)
+{
+	m_LanesStartIds.clear();
+	UtilityHNS::AisanLanesFileReader::AisanLane* pL = nullptr;
+	UtilityHNS::AisanLanesFileReader::AisanLane* pPrevL = nullptr;
+	for(unsigned int il=0; il &lt; pLaneData-&gt;m_data_list.size(); il++)
+	{
+		pL = &amp;pLaneData-&gt;m_data_list.at(il);
+
+		if(IsStartLanePoint(pLaneData, pL) == true)
+		{
+			m_LanesStartIds.push_back(pL-&gt;LnID);
+		}
+
+		if(DEBUG_MAP_PARSING)
+		{
+			if(IsStartLanePoint(pLaneData, pL) &amp;&amp; IsEndLanePoint(pLaneData, pL))
+				cout &lt;&lt; " :( :( :( Start And End in the same time !! " &lt;&lt; pL-&gt;LnID &lt;&lt; endl;
+		}
+	}
+}
+
+void MappingHelpers::ConnectLanes(UtilityHNS::AisanLanesFileReader* pLaneData, std::vector&lt;PlannerHNS::Lane&gt;&amp; lanes)
+{
+	for(unsigned int il = 0; il &lt; lanes.size(); il++)
+	{
+		WayPoint fp = lanes.at(il).points.at(0);
+		UtilityHNS::AisanLanesFileReader::AisanLane* pFirstL = pLaneData-&gt;GetDataRowById(fp.originalMapID);
+		if(pFirstL!=nullptr)
+		{
+			if(pFirstL-&gt;BLID &gt; 0)
+				lanes.at(il).fromIds.push_back(pFirstL-&gt;BLID);
+			if(pFirstL-&gt;BLID2 &gt; 0)
+				lanes.at(il).fromIds.push_back(pFirstL-&gt;BLID2);
+			if(pFirstL-&gt;BLID3 &gt; 0)
+				lanes.at(il).fromIds.push_back(pFirstL-&gt;BLID3);
+			if(pFirstL-&gt;BLID4 &gt; 0)
+				lanes.at(il).fromIds.push_back(pFirstL-&gt;BLID4);
+		}
+
+		WayPoint ep = lanes.at(il).points.at(lanes.at(il).points.size()-1);
+		UtilityHNS::AisanLanesFileReader::AisanLane* pEndL = pLaneData-&gt;GetDataRowById(ep.originalMapID);
+		if(pEndL!=nullptr)
+		{
+			if(pEndL-&gt;FLID &gt; 0)
+				lanes.at(il).toIds.push_back(pEndL-&gt;FLID);
+			if(pEndL-&gt;FLID2 &gt; 0)
+				lanes.at(il).toIds.push_back(pEndL-&gt;FLID2);
+			if(pEndL-&gt;FLID3 &gt; 0)
+				lanes.at(il).toIds.push_back(pEndL-&gt;FLID3);
+			if(pEndL-&gt;FLID4 &gt; 0)
+				lanes.at(il).toIds.push_back(pEndL-&gt;FLID4);
+		}
+	}
+}
+
+void MappingHelpers::CreateLanes(UtilityHNS::AisanLanesFileReader* pLaneData,
+				UtilityHNS::AisanPointsFileReader* pPointsData,
+				UtilityHNS::AisanNodesFileReader* pNodesData,
+				std::vector&lt;PlannerHNS::Lane&gt;&amp; out_lanes)
+{
+
+	out_lanes.clear();
+	std::vector&lt;int&gt; start_lines;
+	GetLanesStartPoints(pLaneData, start_lines);
+	for(unsigned int l =0; l &lt; start_lines.size(); l++)
+	{
+		Lane _lane;
+		GetLanePoints(pLaneData, pPointsData, pNodesData, start_lines.at(l), _lane);
+		out_lanes.push_back(_lane);
+	}
+}
+
+void MappingHelpers::GetLanePoints(UtilityHNS::AisanLanesFileReader* pLaneData,
+			UtilityHNS::AisanPointsFileReader* pPointsData,
+			UtilityHNS::AisanNodesFileReader* pNodesData, int lnID,
+			PlannerHNS::Lane&amp; out_lane)
+{
+	int _lnid = lnID;
+	bool bStart = false;
+	bool bLast = false;
+	int _rID = 0;
+	out_lane.points.clear();
+	UtilityHNS::AisanLanesFileReader::AisanLane* pL = nullptr;
+	out_lane.id = lnID;
+
+	while(!bStart)
+	{
+		pL = pLaneData-&gt;GetDataRowById(_lnid);
+
+		//if(_lnid == 16347) // || _lnid == 1267 || _lnid == 1268 || _lnid == 1269 || _lnid == 958)
+			//out_lane.id = lnID;
+
+		if(out_lane.points.size() == 0)
+		{
+			WayPoint wp1, wp2;
+			GetPointFromDataList(pPointsData, pNodesData-&gt;GetDataRowById(pL-&gt;BNID)-&gt;PID, wp1);
+			wp1.id = pL-&gt;BNID;
+
+			if(pL-&gt;BLID != 0)
+			{
+				_rID = GetBeginPointIdFromLaneNo(pLaneData, pPointsData, pNodesData, pL-&gt;BLID);
+				if(_rID &gt; 0)
+					wp1.fromIds.push_back(_rID);
+			}
+			if(pL-&gt;BLID2 != 0)
+			{
+				_rID = GetBeginPointIdFromLaneNo(pLaneData, pPointsData, pNodesData, pL-&gt;BLID2);
+				if(_rID &gt; 0)
+					wp1.fromIds.push_back(_rID);
+			}
+			if(pL-&gt;BLID3 != 0)
+			{
+				_rID = GetBeginPointIdFromLaneNo(pLaneData, pPointsData, pNodesData, pL-&gt;BLID3);
+				if(_rID &gt; 0)
+					wp1.fromIds.push_back(_rID);
+			}
+			if(pL-&gt;BLID4 != 0)
+			{
+				_rID = GetBeginPointIdFromLaneNo(pLaneData, pPointsData, pNodesData, pL-&gt;BLID4);
+				if(_rID &gt; 0)
+					wp1.fromIds.push_back(_rID);
+			}
+
+			GetPointFromDataList(pPointsData, pNodesData-&gt;GetDataRowById(pL-&gt;FNID)-&gt;PID, wp2);
+			wp2.id = pL-&gt;FNID;
+			if(pL-&gt;FLID != 0)
+			{
+				_rID = GetEndPointIdFromLaneNo(pLaneData, pPointsData, pNodesData, pL-&gt;FLID);
+				if(_rID &gt; 0)
+					wp2.toIds.push_back(_rID);
+			}
+			if(pL-&gt;FLID2 != 0)
+			{
+				_rID = GetEndPointIdFromLaneNo(pLaneData, pPointsData, pNodesData, pL-&gt;FLID2);
+				if(_rID &gt; 0)
+					wp2.toIds.push_back(_rID);
+			}
+			if(pL-&gt;FLID3 != 0)
+			{
+				_rID = GetEndPointIdFromLaneNo(pLaneData, pPointsData, pNodesData, pL-&gt;FLID3);
+				if(_rID &gt; 0)
+					wp2.toIds.push_back(_rID);
+			}
+			if(pL-&gt;FLID4 != 0)
+			{
+				_rID = GetEndPointIdFromLaneNo(pLaneData, pPointsData, pNodesData, pL-&gt;FLID4);
+				if(_rID &gt; 0)
+					wp2.toIds.push_back(_rID);
+			}
+
+			if(pL-&gt;LaneDir == 'L')
+			{
+				wp1.actionCost.push_back(make_pair(LEFT_TURN_ACTION, LEFT_INITIAL_TURNS_COST));
+				wp2.actionCost.push_back(make_pair(LEFT_TURN_ACTION, LEFT_INITIAL_TURNS_COST));
+			}
+			else  if(pL-&gt;LaneDir == 'R')
+			{
+				wp1.actionCost.push_back(make_pair(RIGHT_TURN_ACTION, RIGHT_INITIAL_TURNS_COST));
+				wp2.actionCost.push_back(make_pair(RIGHT_TURN_ACTION, RIGHT_INITIAL_TURNS_COST));
+			}
+			else
+			{
+				wp1.actionCost.push_back(make_pair(FORWARD_ACTION, 0));
+				wp2.actionCost.push_back(make_pair(FORWARD_ACTION, 0));
+			}
+
+			wp1.originalMapID = pL-&gt;LnID;
+			wp2.originalMapID = pL-&gt;LnID;
+
+			wp1.laneId = lnID;
+			wp2.laneId = lnID;
+
+			wp1.toIds.push_back(wp2.id);
+			wp2.fromIds.push_back(wp1.id);
+			out_lane.points.push_back(wp1);
+			out_lane.points.push_back(wp2);
+		}
+		else
+		{
+			WayPoint wp;
+			GetPointFromDataList(pPointsData, pNodesData-&gt;GetDataRowById(pL-&gt;FNID)-&gt;PID, wp);
+			wp.id = pL-&gt;FNID;
+			wp.fromIds.push_back(out_lane.points.at(out_lane.points.size()-1).id);
+
+			if(pL-&gt;FLID != 0)
+			{
+				_rID = GetEndPointIdFromLaneNo(pLaneData, pPointsData, pNodesData, pL-&gt;FLID);
+				if(_rID &gt; 0)
+					wp.toIds.push_back(_rID);
+			}
+			if(pL-&gt;FLID2 != 0)
+			{
+				_rID = GetEndPointIdFromLaneNo(pLaneData, pPointsData, pNodesData, pL-&gt;FLID2);
+				if(_rID &gt; 0)
+					wp.toIds.push_back(_rID);
+			}
+			if(pL-&gt;FLID3 != 0)
+			{
+				_rID = GetEndPointIdFromLaneNo(pLaneData, pPointsData, pNodesData, pL-&gt;FLID3);
+				if(_rID &gt; 0)
+					wp.toIds.push_back(_rID);
+			}
+			if(pL-&gt;FLID4 != 0)
+			{
+				_rID = GetEndPointIdFromLaneNo(pLaneData, pPointsData, pNodesData, pL-&gt;FLID4);
+				if(_rID &gt; 0)
+					wp.toIds.push_back(_rID);
+			}
+
+			if(pL-&gt;LaneDir == 'L')
+			{
+				wp.actionCost.push_back(make_pair(LEFT_TURN_ACTION, LEFT_INITIAL_TURNS_COST));
+			}
+			else  if(pL-&gt;LaneDir == 'R')
+			{
+				wp.actionCost.push_back(make_pair(RIGHT_TURN_ACTION, RIGHT_INITIAL_TURNS_COST));
+			}
+			else
+			{
+				wp.actionCost.push_back(make_pair(FORWARD_ACTION, 0));
+			}
+
+			wp.originalMapID = pL-&gt;LnID;
+			wp.laneId = lnID;
+
+			out_lane.points.push_back(wp);
+		}
+
+		_lnid = pL-&gt;FLID;
+
+		if(_lnid == 0)
+			break;
+
+		bStart = IsStartLanePoint(pLaneData, pLaneData-&gt;GetDataRowById(_lnid));
+	}
+}
+
+void MappingHelpers::FixRedundantPointsLanes(std::vector&lt;Lane&gt;&amp; lanes)
+{
+	for(unsigned int il=0; il &lt; lanes.size(); il ++)
+	{
+		for(int ip = 1; ip &lt; lanes.at(il).points.size(); ip++)
+		{
+			WayPoint* p1 = &amp;lanes.at(il).points.at(ip-1);
+			WayPoint* p2 = &amp;lanes.at(il).points.at(ip);
+			WayPoint* p3 = nullptr;
+			if(ip+1 &lt; lanes.at(il).points.size())
+				p3 = &amp;lanes.at(il).points.at(ip+1);
+
+			double d = hypot(p2-&gt;pos.y-p1-&gt;pos.y, p2-&gt;pos.x-p1-&gt;pos.x);
+			if(d == 0)
+			{
+				p1-&gt;toIds = p2-&gt;toIds;
+				p1-&gt;originalMapID = p2-&gt;originalMapID;
+				if(p3 != nullptr)
+					p3-&gt;fromIds = p2-&gt;fromIds;
+
+				lanes.at(il).points.erase(lanes.at(il).points.begin()+ip);
+				ip--;
+
+				if(DEBUG_MAP_PARSING)
+					cout &lt;&lt; "Fixed Redundant Points for Lane:" &lt;&lt; lanes.at(il).id &lt;&lt; ", Current: " &lt;&lt; ip &lt;&lt; ", Size: " &lt;&lt; lanes.at(il).points.size() &lt;&lt; endl;
+			}
+		}
+	}
+}
+
+void MappingHelpers::FixTwoPointsLane(Lane&amp; l)
+{
+	if(l.points.size() == 2)
+	{
+		g_max_point_id++;
+		WayPoint wp = l.points.at(0);
+		wp.id = g_max_point_id;
+		wp.fromIds.clear();
+		wp.fromIds.push_back(l.points.at(0).id);
+		wp.toIds.clear();
+		wp.toIds.push_back(l.points.at(1).id);
+
+		l.points.at(0).toIds.clear();
+		l.points.at(0).toIds.push_back(wp.id);
+
+		l.points.at(1).fromIds.clear();
+		l.points.at(1).fromIds.push_back(wp.id);
+
+		wp.pos.x = (l.points.at(0).pos.x + l.points.at(1).pos.x)/2.0;
+		wp.pos.y = (l.points.at(0).pos.y + l.points.at(1).pos.y)/2.0;
+		wp.pos.z = (l.points.at(0).pos.z + l.points.at(1).pos.z)/2.0;
+
+		l.points.insert(l.points.begin()+1, wp);
+	}
+	else if(l.points.size() &lt; 2)
+	{
+		cout &lt;&lt; "## WOW Lane " &lt;&lt;  l.id &lt;&lt; " With Size (" &lt;&lt; l.points.size() &lt;&lt; ") " &lt;&lt; endl;
+	}
+}
+
+void MappingHelpers::FixTwoPointsLanes(std::vector&lt;Lane&gt;&amp; lanes)
+{
+	for(unsigned int il=0; il &lt; lanes.size(); il ++)
+	{
+		for(unsigned int ip = 0; ip &lt; lanes.at(il).points.size(); ip++)
+		{
+			if(lanes.at(il).points.at(ip).id &gt; g_max_point_id)
+			{
+				g_max_point_id = lanes.at(il).points.at(ip).id;
+			}
+		}
+	}
+
+	for(unsigned int il=0; il &lt; lanes.size(); il ++)
+	{
+		FixTwoPointsLane(lanes.at(il));
+		PlannerHNS::PlanningHelpers::CalcAngleAndCost(lanes.at(il).points);
+	}
+}
+
+void MappingHelpers::InsertWayPointToBackOfLane(const WayPoint&amp; wp, Lane&amp; lane, int&amp; global_id)
+{
+	WayPoint* pFirst = &amp;lane.points.at(0);
+	pFirst-&gt;pos = wp.pos;
+
+//	WayPoint f_wp = *pFirst;
+//	f_wp.pos = wp.pos;
+//
+//	//Give old first new ID
+//	global_id++;
+//	pFirst-&gt;id = global_id;
+//
+//	//link ids
+//	f_wp.toIds.clear(); //only see front
+//	f_wp.toIds.push_back(pFirst-&gt;id);
+//
+//	pFirst-&gt;fromIds.clear();
+//	pFirst-&gt;fromIds.push_back(f_wp.id);
+//
+//	if(lane.points.size() &gt; 1)
+//	{
+//		lane.points.at(1).fromIds.clear();
+//		lane.points.at(1).fromIds.push_back(pFirst-&gt;id);
+//	}
+//
+//	lane.points.insert(lane.points.begin(), f_wp);
+}
+
+void MappingHelpers::InsertWayPointToFrontOfLane(const WayPoint&amp; wp, Lane&amp; lane, int&amp; global_id)
+{
+	WayPoint* pLast = &amp;lane.points.at(lane.points.size()-1);
+	pLast-&gt;pos = wp.pos;
+
+//	WayPoint l_wp = *pLast;
+//	l_wp.pos = wp.pos;
+//
+//	//Give old first new ID
+//	global_id++;
+//	pLast-&gt;id = global_id;
+//
+//	//link ids
+//	l_wp.fromIds.clear(); //only see front
+//	l_wp.fromIds.push_back(pLast-&gt;id);
+//
+//	pLast-&gt;toIds.clear();
+//	pLast-&gt;toIds.push_back(l_wp.id);
+//
+//	if(lane.points.size() &gt; 1)
+//	{
+//		lane.points.at(lane.points.size()-2).toIds.clear();
+//		lane.points.at(lane.points.size()-2).toIds.push_back(pLast-&gt;id);
+//	}
+//
+//	lane.points.push_back(l_wp);
+}
+
+void MappingHelpers::FixUnconnectedLanes(std::vector&lt;Lane&gt;&amp; lanes)
+{
+	std::vector&lt;Lane&gt; sp_lanes = lanes;
+	bool bAtleastOneChange = false;
+	//Find before lanes
+	for(unsigned int il=0; il &lt; lanes.size(); il ++)
+	{
+		if(lanes.at(il).fromIds.size() == 0)
+		{
+			double closest_d = DBL_MAX;
+			Lane* pL = nullptr;
+			Lane* pFL = nullptr;
+			for(int l=0; l &lt; sp_lanes.size(); l ++)
+			{
+				if(lanes.at(il).id == sp_lanes.at(l).id)
+				{
+					pFL = &amp;sp_lanes.at(l);
+					break;
+				}
+			}
+
+			PlannerHNS::RelativeInfo closest_info;
+			int closest_index = -1;
+			for(int l=0; l &lt; sp_lanes.size(); l ++)
+			{
+				if(pFL-&gt;id != sp_lanes.at(l).id )
+				{
+					PlannerHNS::RelativeInfo info;
+					WayPoint lastofother = sp_lanes.at(l).points.at(sp_lanes.at(l).points.size()-1);
+					PlanningHelpers::GetRelativeInfoLimited(sp_lanes.at(l).points, pFL-&gt;points.at(0), info, 0);
+					double back_distance = hypot(lastofother.pos.y - pFL-&gt;points.at(0).pos.y, lastofother.pos.x - pFL-&gt;points.at(0).pos.x);
+					bool bCloseFromBack = false;
+					if((info.bAfter == true &amp;&amp; back_distance &lt; 15.0) || info.bAfter == false)
+						bCloseFromBack = true;
+
+
+					if(fabs(info.perp_distance) &lt; 2 &amp;&amp; fabs(info.perp_distance) &lt; closest_d &amp;&amp; info.bBefore == false &amp;&amp; bCloseFromBack)
+					{
+						closest_d = fabs(info.perp_distance);
+						pL = &amp;sp_lanes.at(l);
+						closest_info = info;
+						closest_info.angle_diff = back_distance;
+						closest_index = l;
+					}
+				}
+			}
+
+			if(pL != nullptr &amp;&amp; pFL != nullptr)
+			{
+				if(closest_info.iFront == pL-&gt;points.size()-1)
+				{
+					pL-&gt;toIds.push_back(pFL-&gt;id);
+					pL-&gt;points.at(closest_info.iFront).toIds.push_back(pFL-&gt;points.at(0).id);
+
+					pFL-&gt;points.at(0).fromIds.push_back(pL-&gt;points.at(closest_info.iFront).id);
+					pFL-&gt;fromIds.push_back(pL-&gt;id);
+					bAtleastOneChange = true;
+					if(DEBUG_MAP_PARSING)
+					{
+						cout &lt;&lt; "Closest Next Lane For: " &lt;&lt; pFL-&gt;id &lt;&lt; " , Is:" &lt;&lt; pL-&gt;id &lt;&lt; ", Distance=" &lt;&lt; fabs(closest_info.perp_distance) &lt;&lt; ", Size: " &lt;&lt; pL-&gt;points.size() &lt;&lt; ", back_index: " &lt;&lt; closest_info.iBack &lt;&lt;", front_index: " &lt;&lt; closest_info.iFront &lt;&lt; ", Direct: " &lt;&lt; closest_info.angle_diff &lt;&lt; endl;
+						cout &lt;&lt; "Don't Split , Perfect !" &lt;&lt; endl;
+					}
+				}
+				else
+				{
+					 // split from previous point
+					if(DEBUG_MAP_PARSING)
+						cout &lt;&lt; "Closest Next Lane For: " &lt;&lt; pFL-&gt;id &lt;&lt; " , Is:" &lt;&lt; pL-&gt;id &lt;&lt; ", Distance=" &lt;&lt; fabs(closest_info.perp_distance) &lt;&lt; ", Size: " &lt;&lt; pL-&gt;points.size() &lt;&lt; ", back_index: " &lt;&lt; closest_info.iBack &lt;&lt;", front_index: " &lt;&lt; closest_info.iFront &lt;&lt; ", Direct: " &lt;&lt; closest_info.angle_diff &lt;&lt; endl;
+
+					Lane front_half, back_half;
+					front_half.points.insert(front_half.points.begin(), pL-&gt;points.begin()+closest_info.iFront, pL-&gt;points.end());
+					front_half.toIds = pL-&gt;toIds;
+					front_half.fromIds.push_back(pL-&gt;id);
+					front_half.id = front_half.points.at(0).originalMapID;
+					front_half.areaId = pL-&gt;areaId;
+					front_half.dir = pL-&gt;dir;
+					front_half.num = pL-&gt;num;
+					front_half.roadId = pL-&gt;roadId;
+					front_half.speed = pL-&gt;speed;
+					front_half.type = pL-&gt;type;
+					front_half.width = pL-&gt;width;
+
+					back_half.points.insert(back_half.points.begin(), pL-&gt;points.begin(), pL-&gt;points.begin()+closest_info.iFront);
+					back_half.toIds.clear();
+					back_half.toIds.push_back(front_half.id);
+					back_half.toIds.push_back(pFL-&gt;id);
+					back_half.fromIds = pL-&gt;fromIds;
+					back_half.id = pL-&gt;id;
+					back_half.areaId = pL-&gt;areaId;
+					back_half.dir = pL-&gt;dir;
+					back_half.num = pL-&gt;num;
+					back_half.roadId = pL-&gt;roadId;
+					back_half.speed = pL-&gt;speed;
+					back_half.type = pL-&gt;type;
+					back_half.width = pL-&gt;width;
+
+					WayPoint* last_from_back =  &amp;back_half.points.at(back_half.points.size()-1);
+					WayPoint* first_from_front =  &amp;pFL-&gt;points.at(0);
+
+					last_from_back-&gt;toIds.push_back(first_from_front-&gt;id);
+					first_from_front-&gt;fromIds.push_back(last_from_back-&gt;id);
+
+					if(front_half.points.size() &gt; 1 &amp;&amp; back_half.points.size() &gt; 1)
+					{
+						if(DEBUG_MAP_PARSING)
+							cout &lt;&lt; "Split this one Nicely! first_half_size: " &lt;&lt; front_half.points.size() &lt;&lt; ", second_hald_size: " &lt;&lt; back_half.points.size() &lt;&lt; endl;
+
+						pFL-&gt;fromIds.push_back(back_half.id);
+
+						if(closest_index &gt;= 0)
+							sp_lanes.erase(sp_lanes.begin()+closest_index);
+						else
+							cout &lt;&lt; "## Alert Alert Alert !!!! " &lt;&lt; endl;
+
+						// add perp point to lane points
+						InsertWayPointToBackOfLane(closest_info.perp_point, front_half, g_max_point_id);
+						InsertWayPointToFrontOfLane(closest_info.perp_point, back_half, g_max_point_id);
+
+						sp_lanes.push_back(front_half);
+						sp_lanes.push_back(back_half);
+						bAtleastOneChange = true;
+					}
+					else
+					{
+						if(DEBUG_MAP_PARSING)
+							cout &lt;&lt; "=&gt; Can't Split this one :( !" &lt;&lt; endl;
+					}
+				}
+			}
+			else
+			{
+				if(DEBUG_MAP_PARSING)
+					cout &lt;&lt; "=&gt; Can't find Before Lanes For:  " &lt;&lt; lanes.at(il).id  &lt;&lt; endl;
+			}
+		}
+	}
+
+	lanes = sp_lanes;
+
+	//Find to lanes
+
+	for(unsigned int il=0; il &lt; lanes.size(); il ++)
+	{
+		if(lanes.at(il).toIds.size() == 0)
+		{
+			double closest_d = DBL_MAX;
+			Lane* pL = nullptr;
+			Lane* pBL = nullptr;
+			for(int l=0; l &lt; sp_lanes.size(); l ++)
+			{
+				if(lanes.at(il).id == sp_lanes.at(l).id)
+				{
+					pBL = &amp;sp_lanes.at(l);
+					break;
+				}
+			}
+
+			PlannerHNS::RelativeInfo closest_info;
+			int closest_index = -1;
+			for(int l=0; l &lt; sp_lanes.size(); l ++)
+			{
+				if(pBL-&gt;id != sp_lanes.at(l).id )
+				{
+					PlannerHNS::RelativeInfo info;
+					WayPoint firstofother = sp_lanes.at(l).points.at(0);
+					WayPoint last_point = pBL-&gt;points.at(pBL-&gt;points.size()-1);
+					PlanningHelpers::GetRelativeInfoLimited(sp_lanes.at(l).points, last_point, info, 0);
+					double front_distance = hypot(firstofother.pos.y - last_point.pos.y, firstofother.pos.x - last_point.pos.x);
+					bool bCloseFromFront = false;
+					if((info.bBefore == true &amp;&amp; front_distance &lt; 15.0) || info.bBefore == false)
+						bCloseFromFront = true;
+
+					if(fabs(info.perp_distance) &lt; 2 &amp;&amp; fabs(info.perp_distance) &lt; closest_d &amp;&amp; info.bAfter == false &amp;&amp; bCloseFromFront)
+					{
+						closest_d = fabs(info.perp_distance);
+						pL = &amp;sp_lanes.at(l);
+						closest_info = info;
+						closest_info.angle_diff = front_distance;
+						closest_index = l;
+					}
+				}
+			}
+
+			if(pL != nullptr &amp;&amp; pBL != nullptr)
+			{
+				if(closest_info.iFront == 0)
+				{
+					pL-&gt;fromIds.push_back(pBL-&gt;id);
+					pL-&gt;points.at(closest_info.iFront).fromIds.push_back(pBL-&gt;points.at(pBL-&gt;points.size()-1).id);
+
+					pBL-&gt;points.at(pBL-&gt;points.size()-1).toIds.push_back(pL-&gt;points.at(closest_info.iFront).id);
+					pBL-&gt;toIds.push_back(pL-&gt;id);
+
+					bAtleastOneChange = true;
+					if(DEBUG_MAP_PARSING)
+					{
+						cout &lt;&lt; "Closest Back Lane For: " &lt;&lt; pBL-&gt;id &lt;&lt; " , Is:" &lt;&lt; pL-&gt;id &lt;&lt; ", Distance=" &lt;&lt; fabs(closest_info.perp_distance) &lt;&lt; ", Size: " &lt;&lt; pL-&gt;points.size() &lt;&lt; ", back_index: " &lt;&lt; closest_info.iBack &lt;&lt;", front_index: " &lt;&lt; closest_info.iFront &lt;&lt; ", Direct: " &lt;&lt; closest_info.angle_diff &lt;&lt; endl;
+						cout &lt;&lt; "Don't Split , Perfect !" &lt;&lt; endl;
+					}
+				}
+				else
+				{
+					 // split from previous point
+					if(DEBUG_MAP_PARSING)
+						cout &lt;&lt; "Closest Back Lane For: " &lt;&lt; pBL-&gt;id &lt;&lt; " , Is:" &lt;&lt; pL-&gt;id &lt;&lt; ", Distance=" &lt;&lt; fabs(closest_info.perp_distance) &lt;&lt; ", Size: " &lt;&lt; pL-&gt;points.size() &lt;&lt; ", back_index: " &lt;&lt; closest_info.iBack &lt;&lt;", front_index: " &lt;&lt; closest_info.iFront &lt;&lt; ", Direct: " &lt;&lt; closest_info.angle_diff &lt;&lt; endl;
+
+					Lane front_half, back_half;
+					front_half.points.insert(front_half.points.begin(), pL-&gt;points.begin()+closest_info.iFront, pL-&gt;points.end());
+					front_half.toIds = pL-&gt;toIds;
+					front_half.fromIds.push_back(pL-&gt;id);
+					front_half.fromIds.push_back(pBL-&gt;id);
+					front_half.id = front_half.points.at(0).originalMapID;
+					front_half.areaId = pL-&gt;areaId;
+					front_half.dir = pL-&gt;dir;
+					front_half.num = pL-&gt;num;
+					front_half.roadId = pL-&gt;roadId;
+					front_half.speed = pL-&gt;speed;
+					front_half.type = pL-&gt;type;
+					front_half.width = pL-&gt;width;
+
+					back_half.points.insert(back_half.points.begin(), pL-&gt;points.begin(), pL-&gt;points.begin()+closest_info.iFront);
+					back_half.toIds.push_back(front_half.id);
+					back_half.fromIds = pL-&gt;fromIds;
+					back_half.id = pL-&gt;id;
+					back_half.areaId = pL-&gt;areaId;
+					back_half.dir = pL-&gt;dir;
+					back_half.num = pL-&gt;num;
+					back_half.roadId = pL-&gt;roadId;
+					back_half.speed = pL-&gt;speed;
+					back_half.type = pL-&gt;type;
+					back_half.width = pL-&gt;width;
+
+					WayPoint* first_from_next =  &amp;front_half.points.at(0);
+					WayPoint* last_from_front =  &amp;pBL-&gt;points.at(pBL-&gt;points.size()-1);
+
+					first_from_next-&gt;fromIds.push_back(last_from_front-&gt;id);
+					last_from_front-&gt;toIds.push_back(first_from_next-&gt;id);
+
+					if(front_half.points.size() &gt; 1 &amp;&amp; back_half.points.size() &gt; 1)
+					{
+						if(DEBUG_MAP_PARSING)
+							cout &lt;&lt; "Split this one Nicely! first_half_size: " &lt;&lt; front_half.points.size() &lt;&lt; ", second_hald_size: " &lt;&lt; back_half.points.size() &lt;&lt; endl;
+
+						pBL-&gt;toIds.push_back(front_half.id);
+
+						if(closest_index &gt;= 0)
+							sp_lanes.erase(sp_lanes.begin()+closest_index);
+						else
+							cout &lt;&lt; "## Alert Alert Alert !!!! " &lt;&lt; endl;
+
+						// add perp point to lane points
+						InsertWayPointToBackOfLane(closest_info.perp_point, front_half, g_max_point_id);
+						InsertWayPointToFrontOfLane(closest_info.perp_point, back_half, g_max_point_id);
+
+						sp_lanes.push_back(front_half);
+						sp_lanes.push_back(back_half);
+						bAtleastOneChange = true;
+					}
+					else
+					{
+						if(DEBUG_MAP_PARSING)
+							cout &lt;&lt; "=&gt; Can't Split this one :( !" &lt;&lt; endl;
+					}
+				}
+			}
+			else
+			{
+				if(DEBUG_MAP_PARSING)
+					cout &lt;&lt; "=&gt; Can't find After Lanes For:  " &lt;&lt; lanes.at(il).id  &lt;&lt; endl;
+			}
+		}
+	}
+
+	lanes = sp_lanes;
+}
+
+void MappingHelpers::LinkLanesPointers(PlannerHNS::RoadNetwork&amp; map)
+{
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		//Link Lanes
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
+			for(unsigned int j = 0 ; j &lt; pL-&gt;fromIds.size(); j++)
+			{
+				for(unsigned int l= 0; l &lt; map.roadSegments.at(rs).Lanes.size(); l++)
+				{
+					if(map.roadSegments.at(rs).Lanes.at(l).id == pL-&gt;fromIds.at(j))
+					{
+						pL-&gt;fromLanes.push_back(&amp;map.roadSegments.at(rs).Lanes.at(l));
+					}
+				}
+			}
+
+			for(unsigned int j = 0 ; j &lt; pL-&gt;toIds.size(); j++)
+			{
+				for(unsigned int l= 0; l &lt; map.roadSegments.at(rs).Lanes.size(); l++)
+				{
+					if(map.roadSegments.at(rs).Lanes.at(l).id == pL-&gt;toIds.at(j))
+					{
+						pL-&gt;toLanes.push_back(&amp;map.roadSegments.at(rs).Lanes.at(l));
+					}
+				}
+			}
+
+			for(unsigned int j = 0 ; j &lt; pL-&gt;points.size(); j++)
+			{
+				pL-&gt;points.at(j).pLane  = pL;
+			}
+		}
+	}
+}
+
+void MappingHelpers::ConstructRoadNetworkFromRosMessageV2(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
+		const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+		const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
+		const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
+		const std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt;&amp; area_data,
+		const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
+		const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
+		const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
+		const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
+		const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
+		const std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt;&amp; roadedge_data,
+		const std::vector&lt;UtilityHNS::AisanWayareaFileReader::AisanWayarea&gt;&amp; wayarea_data,
+		const std::vector&lt;UtilityHNS::AisanCrossWalkFileReader::AisanCrossWalk&gt;&amp; crosswalk_data,
+		const std::vector&lt;UtilityHNS::AisanNodesFileReader::AisanNode&gt;&amp; nodes_data,
+		const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
+		UtilityHNS::AisanLanesFileReader* pLaneData,
+		UtilityHNS::AisanPointsFileReader* pPointsData,
+		UtilityHNS::AisanNodesFileReader* pNodesData,
+		UtilityHNS::AisanLinesFileReader* pLinedata,
+		const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag)
+{
+	vector&lt;Lane&gt; roadLanes;
+
+	for(unsigned int i=0; i&lt; pLaneData-&gt;m_data_list.size(); i++)
+	{
+		if(pLaneData-&gt;m_data_list.at(i).LnID &gt; g_max_lane_id)
+			g_max_lane_id = pLaneData-&gt;m_data_list.at(i).LnID;
+	}
+
+	cout &lt;&lt; " &gt;&gt; Extracting Lanes ... " &lt;&lt; endl;
+	CreateLanes(pLaneData, pPointsData, pNodesData, roadLanes);
+
+	cout &lt;&lt; " &gt;&gt; Fix Waypoints errors ... " &lt;&lt; endl;
+	FixTwoPointsLanes(roadLanes);
+	FixRedundantPointsLanes(roadLanes);
+
+	ConnectLanes(pLaneData, roadLanes);
+
+	cout &lt;&lt; " &gt;&gt; Create Missing lane connections ... " &lt;&lt; endl;
+	FixUnconnectedLanes(roadLanes);
+	//FixTwoPointsLanes(roadLanes);
+
+	//map has one road segment
+	RoadSegment roadSegment1;
+	roadSegment1.id = 1;
+	roadSegment1.Lanes = roadLanes;
+	map.roadSegments.push_back(roadSegment1);
+
+	//Link Lanes and lane's waypoints by pointers
+	cout &lt;&lt; " &gt;&gt; Link lanes and waypoints with pointers ... " &lt;&lt; endl;
+	LinkLanesPointers(map);
+
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
+			for(unsigned int j = 0 ; j &lt; pL-&gt;points.size(); j++)
+			{
+			    if(pL-&gt;points.at(j).actionCost.size() &gt; 0)
+			  {
+				  if(pL-&gt;points.at(j).actionCost.at(0).first == LEFT_TURN_ACTION)
+					{
+					  AssignActionCostToLane(pL, LEFT_TURN_ACTION, LEFT_INITIAL_TURNS_COST);
+					  break;
+					}
+				  else if(pL-&gt;points.at(j).actionCost.at(0).first == RIGHT_TURN_ACTION)
+					{
+					  AssignActionCostToLane(pL, RIGHT_TURN_ACTION, RIGHT_INITIAL_TURNS_COST);
+					break;
+
+					}
+				  }
+			}
+		}
+	}
+
+#ifdef FIND_LEFT_RIGHT_LANES
+	FindAdjacentLanes(map);
+#endif
+
+//	//Extract Signals and StopLines
+//	// Signals
+	cout &lt;&lt; " &gt;&gt; Extract Signal data ... " &lt;&lt; endl;
+	ExtractSignalDataV2(signal_data, vector_data, pPointsData, origin, map);
+
+
+	//Stop Lines
+	cout &lt;&lt; " &gt;&gt; Extract Stop lines data ... " &lt;&lt; endl;
+	ExtractStopLinesDataV2(stop_line_data, pLinedata, pPointsData, origin, map);
+
+	//Curbs
+	//cout &lt;&lt; " &gt;&gt; Extract curbs data ... " &lt;&lt; endl;
+	ExtractCurbDataV2(curb_data, pLinedata, pPointsData, origin, map);
+
+	//Wayarea
+	//cout &lt;&lt; " &gt;&gt; Extract wayarea data ... " &lt;&lt; endl;
+	ExtractWayArea(area_data, wayarea_data, line_data, points_data, origin, map);
+
+//	//Link waypoints
+	cout &lt;&lt; " &gt;&gt; Check for missing branches and signs ... " &lt;&lt; endl;
+	LinkMissingBranchingWayPoints(map);
+//
+//	//Link StopLines and Traffic Lights
+	LinkTrafficLightsAndStopLines(map);
+//	//LinkTrafficLightsAndStopLinesConData(conn_data, id_replace_list, map);
+//
+
+	//Fix angle for lanes
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
+			PlannerHNS::PlanningHelpers::FixAngleOnly(pL-&gt;points);
+		}
+	}
+
+	cout &lt;&lt; " &gt;&gt; Map loaded from data with " &lt;&lt; roadLanes.size()  &lt;&lt; " lanes" &lt;&lt; endl;
+}
+
+void MappingHelpers::ExtractCurbDataV2(const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
+				UtilityHNS::AisanLinesFileReader* pLinedata,
+				UtilityHNS::AisanPointsFileReader* pPointsData,
+				const GPSPoint&amp; origin, RoadNetwork&amp; map)
+{
+	for(unsigned int ic=0; ic &lt; curb_data.size(); ic++)
+	{
+		Curb c;
+		c.id = curb_data.at(ic).ID;
+
+		for(unsigned int il=0; il &lt; pLinedata-&gt;m_data_list.size() ; il++)
+		{
+			if(curb_data.at(ic).LID == pLinedata-&gt;m_data_list.at(il).LID)
+			{
+				int s_id = pLinedata-&gt;m_data_list.at(il).BPID;
+				if(s_id == 0)
+					s_id = pLinedata-&gt;m_data_list.at(il).FPID;
+
+				AisanPointsFileReader::AisanPoints* pP = pPointsData-&gt;GetDataRowById(s_id);
+				if(pP != nullptr)
+				{
+					c.points.push_back(GPSPoint(pP-&gt;Ly + origin.x, pP-&gt;Bx + origin.y, pP-&gt;H + origin.z, 0));
+					WayPoint wp;
+					wp.pos = c.points.at(0);
+					Lane* pLane = GetClosestLaneFromMap(wp, map, 5);
+					if(pLane != nullptr)
+					{
+						c.laneId = pLane-&gt;id;
+						c.pLane = pLane;
+					}
+				}
+			}
+		}
+		map.curbs.push_back(c);
+	}
 }
+
+void MappingHelpers::ExtractSignalDataV2(const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
+			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
+			UtilityHNS::AisanPointsFileReader* pPointData,
+			const GPSPoint&amp; origin, RoadNetwork&amp; map)
+{
+	for(unsigned int is=0; is&lt; signal_data.size(); is++)
+	{
+		//if(signal_data.at(is).Type == 2)
+		{
+			TrafficLight tl;
+			tl.id = signal_data.at(is).ID;
+			tl.linkID = signal_data.at(is).LinkID;
+			tl.stoppingDistance = 0;
+
+			for(unsigned int iv = 0; iv &lt; vector_data.size(); iv++)
+			{
+				if(signal_data.at(is).VID == vector_data.at(iv).VID)
+				{
+					AisanPointsFileReader::AisanPoints* pP =  pPointData-&gt;GetDataRowById(vector_data.at(iv).PID);
+					if(pP != nullptr)
+					{
+						tl.pos = GPSPoint(pP-&gt;Ly + origin.x, pP-&gt;Bx + origin.y, pP-&gt;H + origin.z, vector_data.at(iv).Hang*DEG2RAD);
+					}
+				}
+			}
+			map.trafficLights.push_back(tl);
+			if(tl.id &gt; g_max_traffic_light_id)
+				g_max_traffic_light_id = tl.id;
+		}
+	}
+}
+
+void MappingHelpers::ExtractStopLinesDataV2(const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
+			UtilityHNS::AisanLinesFileReader* pLineData,
+			UtilityHNS::AisanPointsFileReader* pPointData,
+			const GPSPoint&amp; origin, RoadNetwork&amp; map)
+{
+	for(unsigned int ist=0; ist &lt; stop_line_data.size(); ist++)
+	{
+		StopLine sl;
+		sl.linkID = stop_line_data.at(ist).LinkID;
+		sl.id = stop_line_data.at(ist).ID;
+		if(stop_line_data.at(ist).TLID&gt;0)
+			sl.trafficLightID = stop_line_data.at(ist).TLID;
+		else
+			sl.stopSignID = 100+ist;
+
+		AisanLinesFileReader::AisanLine* pLine = pLineData-&gt;GetDataRowById(stop_line_data.at(ist).LID);
+		if(pLine != nullptr)
+		{
+			UtilityHNS::AisanPointsFileReader::AisanPoints* pStart = pPointData-&gt;GetDataRowById(pLine-&gt;BPID);
+			UtilityHNS::AisanPointsFileReader::AisanPoints* pEnd = pPointData-&gt;GetDataRowById(pLine-&gt;FPID);
+			if(pStart != nullptr)
+				sl.points.push_back(GPSPoint(pStart-&gt;Ly + origin.x, pStart-&gt;Bx + origin.y, pStart-&gt;H + origin.z, 0));
+
+			if(pEnd != nullptr)
+				sl.points.push_back(GPSPoint(pEnd-&gt;Ly + origin.x, pEnd-&gt;Bx + origin.y, pEnd-&gt;H + origin.z, 0));
+		}
+
+		map.stopLines.push_back(sl);
+		if(sl.id &gt; g_max_stop_line_id)
+			g_max_stop_line_id = sl.id;
+	}
+}
+
+bool MappingHelpers::GetWayPointV2(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; pid,
+		const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
+			const GPSPoint&amp; origin, WayPoint&amp; way_point)
+{
+
+	for(unsigned int p =0; p &lt; points.size(); p++)
+	{
+		if(pid == points.at(p).PID)
+		{
+			way_point.id = id;
+			//way_point.id = pid;
+			way_point.laneId = laneID;
+			way_point.v = refVel;
+			way_point.pos = GPSPoint(points.at(p).Ly + origin.x, points.at(p).Bx + origin.y, points.at(p).H + origin.z, 0);
+			way_point.pos.lat = points.at(p).L;
+			way_point.pos.lon = points.at(p).B;
+			way_point.pos.alt = points.at(p).H;
+			way_point.iOriginalIndex = p;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void MappingHelpers::GetMapMaxIds(PlannerHNS::RoadNetwork&amp; map)
+{
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
+			if(pL-&gt;id &gt; g_max_lane_id)
+				g_max_lane_id = pL-&gt;id;
+
+			for(unsigned int j = 0 ; j &lt; pL-&gt;points.size(); j++)
+			{
+				if(pL-&gt;points.at(j).id &gt; g_max_point_id)
+				{
+					g_max_point_id = pL-&gt;points.at(j).id;
+				}
+			}
+		}
+	}
+
+	for(unsigned int i=0; i &lt; map.stopLines.size(); i++)
+	{
+		if(map.stopLines.at(i).id &gt; g_max_stop_line_id)
+			g_max_stop_line_id = map.stopLines.at(i).id;
+	}
+
+	for(unsigned int i=0; i &lt; map.trafficLights.size(); i++)
+	{
+		if(map.trafficLights.at(i).id &gt; g_max_traffic_light_id)
+			g_max_traffic_light_id = map.trafficLights.at(i).id;
+	}
+}
+
+
 } /* namespace PlannerHNS */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" added_lines="199" deleted_lines="264">
				<diff>@@ -1,16 +1,14 @@
-/*
- * PlanningHelpers.cpp
- *
- *  Created on: Jun 16, 2016
- *      Author: hatem
- */
+
+/// \file PlanningHelpers.cpp
+/// \brief Helper functions for planning algorithms
+/// \author Hatem Darweesh
+/// \date Jun 16, 2016
+
 
 #include "op_planner/PlanningHelpers.h"
 #include "op_planner/MatrixOperations.h"
 #include &lt;string&gt;
-//#include "spline.hpp"
-
-
+#include &lt;float.h&gt;
 
 using namespace UtilityHNS;
 using namespace std;
@@ -55,7 +53,7 @@ bool PlanningHelpers::GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoin
 		return true;
 	}
 
-	double minCost = 9999999999;
+	double minCost = DBL_MAX;
 	int min_index = 0;
 
 	for(unsigned int i=0 ; i&lt; infos.size(); i++)
@@ -453,7 +451,7 @@ int PlanningHelpers::GetClosestNextPointIndex_obsolete(const vector&lt;WayPoint&gt;&amp; t
 {
 	if(trajectory.size() == 0 || prevIndex &lt; 0) return 0;
 
-	double d = 0, minD = 9999999999;
+	double d = 0, minD = DBL_MAX;
 	int min_index  = prevIndex;
 
 	for(unsigned int i=prevIndex; i&lt; trajectory.size(); i++)
@@ -497,7 +495,7 @@ int PlanningHelpers::GetClosestNextPointIndexFastV2(const vector&lt;WayPoint&gt;&amp; traj
 
 		if(size &lt; 2 || prevIndex &lt; 0) return 0;
 
-		double d = 0, minD = 9999999999;
+		double d = 0, minD = DBL_MAX;
 
 
 		double resolution = hypot(trajectory[1].pos.y -trajectory[0].pos.y , trajectory[1].pos.x -trajectory[0].pos.x);
@@ -615,7 +613,7 @@ int PlanningHelpers::GetClosestNextPointIndexFast(const vector&lt;WayPoint&gt;&amp; trajec
 
 		if(size &lt; 2 || prevIndex &lt; 0) return 0;
 
-		double d = 0, minD = 9999999999;
+		double d = 0, minD = DBL_MAX;
 		int min_index  = prevIndex;
 		int iStart = prevIndex;
 		int iEnd = size;
@@ -623,7 +621,13 @@ int PlanningHelpers::GetClosestNextPointIndexFast(const vector&lt;WayPoint&gt;&amp; trajec
 
 		//divide every 5 meters
 		int skip_factor = 5;
-		int skip = skip_factor/resolution;
+		if(resolution &gt; skip_factor)
+			resolution = skip_factor;
+
+
+		int skip = 1;
+		if(resolution &gt; 0)
+			skip = skip_factor/resolution;
 
 		for(int i=0; i&lt; size; i+=skip)
 		{
@@ -666,7 +670,7 @@ int PlanningHelpers::GetClosestNextPointIndexFast(const vector&lt;WayPoint&gt;&amp; trajec
 			}
 		}
 
-		if(min_index &lt; size-2)
+		if(min_index &lt; size-1)
 		{
 			GPSPoint curr, next;
 			curr = trajectory[min_index].pos;
@@ -692,7 +696,7 @@ int PlanningHelpers::GetClosestNextPointIndexDirectionFast(const vector&lt;WayPoint
 
 	if(size &lt; 2 || prevIndex &lt; 0) return 0;
 
-	double d = 0, minD = 9999999999;
+	double d = 0, minD = DBL_MAX;
 	int min_index  = prevIndex;
 
 	for(unsigned int i=prevIndex; i&lt; size; i++)
@@ -729,7 +733,7 @@ int PlanningHelpers::GetClosestPointIndex_obsolete(const vector&lt;WayPoint&gt;&amp; traje
 {
 	if(trajectory.size() == 0 || prevIndex &lt; 0) return 0;
 
-	double d = 0, minD = 9999999999;
+	double d = 0, minD = DBL_MAX;
 	int min_index  = prevIndex;
 
 	for(unsigned int i=prevIndex; i&lt; trajectory.size(); i++)
@@ -760,7 +764,7 @@ WayPoint PlanningHelpers::GetPerpendicularOnTrajectory_obsolete(const vector&lt;Way
 	}
 	else
 	{
-		int next_index = GetClosestNextPointIndexFast(trajectory, p, prevIndex);
+		int next_index = GetClosestNextPointIndex_obsolete(trajectory, p, prevIndex);
 
 		if(next_index == 0)
 		{
@@ -992,40 +996,8 @@ bool PlanningHelpers::CompareTrajectories(const std::vector&lt;WayPoint&gt;&amp; path1, co
 	return true;
 }
 
-double PlanningHelpers::GetDistanceToClosestStopLineAndCheck(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; p, int&amp; stopLineID, int&amp; stopSignID, int&amp; trafficLightID, const int&amp; prevIndex)
+double PlanningHelpers::GetDistanceToClosestStopLineAndCheck(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; p, const double&amp; giveUpDistance, int&amp; stopLineID, int&amp; stopSignID, int&amp; trafficLightID, const int&amp; prevIndex)
 {
-
-//	trafficLightID = stopSignID = stopLineID = -1;
-//
-//	RelativeInfo info;
-//	GetRelativeInfo(path, p, info);
-//
-//	for(unsigned int i=info.iBack; i&lt;path.size(); i++)
-//	{
-//		if(path.at(i).pLane &amp;&amp; path.at(i).pLane-&gt;stopLines.size() &gt; 0)
-//		{
-//			stopSignID = path.at(i).pLane-&gt;stopLines.at(0).stopSignID;
-//			trafficLightID = path.at(i).pLane-&gt;stopLines.at(0).trafficLightID;
-//			return 1;
-////			for(unsigned int j = 0; j &lt; path.at(i).pLane-&gt;stopLines.size(); j++)
-////			{
-////				RelativeInfo local_info;
-////				WayPoint stopLineWP;
-////				stopLineWP.pos = path.at(i).pLane-&gt;stopLines.at(j).points.at(0);
-////
-////				GetRelativeInfo(path, stopLineWP, local_info, i);
-////
-////				double d = GetExactDistanceOnTrajectory(path, info, local_info);
-////				if(d &gt; 0)
-////				{
-////						stopSignID = path.at(i).pLane-&gt;stopLines.at(j).stopSignID;
-////						trafficLightID = path.at(i).pLane-&gt;stopLines.at(j).trafficLightID;
-////						return d;
-////				}
-////			}
-//		}
-//	}
-
 	trafficLightID = stopSignID = stopLineID = -1;
 
 	RelativeInfo info;
@@ -1035,8 +1007,10 @@ double PlanningHelpers::GetDistanceToClosestStopLineAndCheck(const std::vector&lt;W
 	{
 		if(path.at(i).stopLineID &gt; 0 &amp;&amp; path.at(i).pLane)
 		{
+
 			for(unsigned int j = 0; j &lt; path.at(i).pLane-&gt;stopLines.size(); j++)
 			{
+
 				if(path.at(i).pLane-&gt;stopLines.at(j).id == path.at(i).stopLineID)
 				{
 					stopLineID = path.at(i).stopLineID;
@@ -1047,7 +1021,7 @@ double PlanningHelpers::GetDistanceToClosestStopLineAndCheck(const std::vector&lt;W
 					GetRelativeInfo(path, stopLineWP, stop_info);
 					double localDistance = GetExactDistanceOnTrajectory(path, info, stop_info);
 
-					if(localDistance&gt;0)
+					if(localDistance &gt; giveUpDistance)
 					{
 						stopSignID = path.at(i).pLane-&gt;stopLines.at(j).stopSignID;
 						trafficLightID = path.at(i).pLane-&gt;stopLines.at(j).trafficLightID;
@@ -1087,14 +1061,11 @@ void PlanningHelpers::CreateManualBranchFromTwoPoints(WayPoint&amp; p1,WayPoint&amp; p2
 	path.push_back(p2);
 	path.push_back(endWP);
 
-	PlanningHelpers::SmoothPath(path, 0.35, 0.25);
-	PlanningHelpers::FixPathDensity(path, 1.5);
-	PlanningHelpers::SmoothPath(path, 0.35, 0.25);
+	//PlanningHelpers::SmoothPath(path, 0.4, 0.1);
 	PlanningHelpers::FixPathDensity(path, 1);
-	PlanningHelpers::SmoothPath(path, 0.25, 0.35);
-
-
-	PlanningHelpers::CalcAngleAndCost(path);
+	PlanningHelpers::SmoothPath(path, 0.4, 0.25);
+	PlanningHelpers::FixPathDensity(path, 0.5);
+	PlanningHelpers::SmoothPath(path, 0.25, 0.4);
 
 	for(unsigned int i=0; i &lt; path.size(); i++)
 	{
@@ -1102,13 +1073,13 @@ void PlanningHelpers::CreateManualBranchFromTwoPoints(WayPoint&amp; p1,WayPoint&amp; p2
 		{
 			path.at(i).state = INITIAL_STATE;
 			path.at(i).beh_state = BEH_BRANCH_LEFT_STATE;
-			path.at(i).laneId = -1;
+			path.at(i).laneId = -2;
 		}
 		if(direction == FORWARD_RIGHT_DIR)
 		{
 			path.at(i).state = INITIAL_STATE;
 			path.at(i).beh_state = BEH_BRANCH_RIGHT_STATE;
-			path.at(i).laneId = -2;
+			path.at(i).laneId = -3;
 		}
 	}
 }
@@ -1271,36 +1242,63 @@ void PlanningHelpers::SmoothPath(vector&lt;WayPoint&gt;&amp; path, double weight_data,
 	path = smoothPath_out;
 }
 
-//double PlanningHelpers::CalcAngleAndCostSimple(vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost)
-//{
-//	if(path.size() &lt;= 2) return 0;
-//
-//	path[0].pos.a = atan2(path[1].pos.y - path[0].pos.y, path[1].pos.x - path[0].pos.x );
-//	path[0].cost = lastCost;
-//
-//	for(int j = 1; j &lt; path.size()-1; j++)
-//	{
-//		path[j].pos.a 	= atan2(path[j+1].pos.y - path[j].pos.y, path[j+1].pos.x - path[j].pos.x );
-//		path[j].cost 	= path[j-1].cost +  hypot(path[j-1].pos.y- path[j].pos.y, path[j-1].pos.x- path[j].pos.x);
-//	}
-//
-//	int j = (int)path.size()-1;
-//
-//	path[j].pos.a 	= path[j-1].pos.a;
-//	path[j].cost 	= path[j-1].cost + hypot(path[j-1].pos.y- path[j].pos.y, path[j-1].pos.x- path[j].pos.x);
-//
-//	for(int j = 0; j &lt; path.size()-1; j++)
-//	{
-//		if(path.at(j).pos.x == path.at(j+1).pos.x &amp;&amp; path.at(j).pos.y == path.at(j+1).pos.y)
-//			path.at(j).pos.a = path.at(j+1).pos.a;
-//	}
-//
-//	return path[j].cost;
-//}
+void PlanningHelpers::PredictConstantTimeCostForTrajectory(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::WayPoint&amp; currPose, const double&amp; minVelocity, const double&amp; minDist)
+{
+	if(path.size() == 0) return;
+
+	for(unsigned int i = 0 ; i &lt; path.size(); i++)
+		path.at(i).timeCost = -1;
+
+	if(currPose.v == 0 || currPose.v &lt; minVelocity) return;
+
+	RelativeInfo info;
+	PlanningHelpers::GetRelativeInfo(path, currPose, info);
+
+	double total_distance = 0;
+	double accum_time = 0;
+
+	path.at(info.iFront).timeCost = 0;
+	if(info.iFront == 0 ) info.iFront++;
+
+	for(unsigned int i=info.iFront; i&lt;path.size(); i++)
+	{
+		total_distance += hypot(path.at(i).pos.x- path.at(i-1).pos.x,path.at(i).pos.y- path.at(i-1).pos.y);
+		accum_time = total_distance/currPose.v;
+		path.at(i).timeCost = accum_time;
+	}
+}
+
+void PlanningHelpers::FixAngleOnly(std::vector&lt;WayPoint&gt;&amp; path)
+{
+	if(path.size() &lt;= 2) return;
+
+	path[0].pos.a = UtilityH::FixNegativeAngle(atan2(path[1].pos.y - path[0].pos.y, path[1].pos.x - path[0].pos.x ));
+
+	for(int j = 1; j &lt; path.size()-1; j++)
+		path[j].pos.a 		= UtilityH::FixNegativeAngle(atan2(path[j+1].pos.y - path[j].pos.y, path[j+1].pos.x - path[j].pos.x ));
+
+	int j = (int)path.size()-1;
+
+	path[j].pos.a = path[j-1].pos.a;
+
+	for(int j = 0; j &lt; path.size()-1; j++)
+	{
+		if(path.at(j).pos.x == path.at(j+1).pos.x &amp;&amp; path.at(j).pos.y == path.at(j+1).pos.y)
+			path.at(j).pos.a = path.at(j+1).pos.a;
+	}
+}
 
 double PlanningHelpers::CalcAngleAndCost(vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost, const bool&amp; bSmooth)
 {
-	if(path.size() &lt;= 2) return 0;
+	if(path.size() &lt; 2) return 0;
+	if(path.size() == 2)
+	{
+		path[0].pos.a = UtilityH::FixNegativeAngle(atan2(path[1].pos.y - path[0].pos.y, path[1].pos.x - path[0].pos.x ));
+		path[0].cost = lastCost;
+		path[1].pos.a = path[0].pos.a;
+		path[1].cost = path[0].cost +  distance2points(path[0].pos, path[1].pos);
+		return path[1].cost;
+	}
 
 	path[0].pos.a = UtilityH::FixNegativeAngle(atan2(path[1].pos.y - path[0].pos.y, path[1].pos.x - path[0].pos.x ));
 	path[0].cost = lastCost;
@@ -1327,6 +1325,8 @@ double PlanningHelpers::CalcAngleAndCost(vector&lt;WayPoint&gt;&amp; path, const double&amp; l
 
 double PlanningHelpers::CalcAngleAndCostAndCurvatureAnd2D(vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost)
 {
+	if(path.size() &lt; 2) return -1;
+
 	path[0].pos.a 	= atan2(path[1].pos.y - path[0].pos.y, path[1].pos.x - path[0].pos.x );
 	path[0].cost 	= lastCost;
 
@@ -1393,7 +1393,7 @@ void PlanningHelpers::ExtractPartFromPointToDistance(const vector&lt;WayPoint&gt;&amp; ori
 //		cout &lt;&lt; "Aler Alert !!! fast: " &lt;&lt; close_index &lt;&lt; ", slow: " &lt;&lt; i_slow  &lt;&lt; endl;
 	//vector&lt;WayPoint&gt; tempPath;
 	double d_limit = 0;
-	if(close_index &gt;= 5) close_index -=5;
+	if(close_index &gt;= 2) close_index -=2;
 	else close_index = 0;
 
 	for(unsigned int i=close_index; i&lt; originalPath.size(); i++)
@@ -1422,6 +1422,49 @@ void PlanningHelpers::ExtractPartFromPointToDistance(const vector&lt;WayPoint&gt;&amp; ori
 	//TestQuadraticSpline(extractedPath, tempPath);
 }
 
+void PlanningHelpers::ExtractPartFromPointToDistanceDirectionFast(const vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
+		const double&amp; pathDensity, vector&lt;WayPoint&gt;&amp; extractedPath)
+{
+	if(originalPath.size() &lt; 2 ) return;
+
+	extractedPath.clear();
+
+	int close_index = GetClosestNextPointIndexDirectionFast(originalPath, pos);
+	double d = 0;
+
+	if(close_index + 1 &gt;= originalPath.size())
+		close_index = originalPath.size() - 2;
+
+	for(int i=close_index; i &gt;=  0; i--)
+	{
+		extractedPath.insert(extractedPath.begin(),  originalPath.at(i));
+		if(i &lt; originalPath.size())
+			d += hypot(originalPath.at(i).pos.y - originalPath.at(i+1).pos.y, originalPath.at(i).pos.x - originalPath.at(i+1).pos.x);
+		if(d &gt; 10)
+			break;
+	}
+
+	//extractedPath.push_back(info.perp_point);
+	d = 0;
+	for(int i=close_index+1; i &lt; (int)originalPath.size(); i++)
+	{
+		extractedPath.push_back(originalPath.at(i));
+		if(i &gt; 0)
+			d += hypot(originalPath.at(i).pos.y - originalPath.at(i-1).pos.y, originalPath.at(i).pos.x - originalPath.at(i-1).pos.x);
+		if(d &gt; minDistance)
+			break;
+	}
+
+	if(extractedPath.size() &lt; 2)
+	{
+		cout &lt;&lt; endl &lt;&lt; "### Planner Z . Extracted Rollout Path is too Small, Size = " &lt;&lt; extractedPath.size() &lt;&lt; endl;
+		return;
+	}
+
+	FixPathDensity(extractedPath, pathDensity);
+	CalcAngleAndCost(extractedPath);
+}
+
 void PlanningHelpers::ExtractPartFromPointToDistanceFast(const vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
 		const double&amp; pathDensity, vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance)
 {
@@ -1680,10 +1723,7 @@ void PlanningHelpers::CalculateRollInTrajectories(const WayPoint&amp; carPos, const
 //	}
 	///***   -------------------------------- ***///
 
-	for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
-	{
-		SmoothPath(rollInPaths.at(i), SmoothDataWeight, SmoothWeight, SmoothTolerance);
-	}
+
 
 	d_limit = 0;
 	for(unsigned int j = smoothing_end_index; j &lt; originalCenter.size(); j++)
@@ -1713,6 +1753,11 @@ void PlanningHelpers::CalculateRollInTrajectories(const WayPoint&amp; carPos, const
 		  }
 	  }
 
+	for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
+	{
+		SmoothPath(rollInPaths.at(i), SmoothDataWeight, SmoothWeight, SmoothTolerance);
+	}
+
 //	for(unsigned int i=0; i&lt; rollInPaths.size(); i++)
 //		CalcAngleAndCost(rollInPaths.at(i));
 }
@@ -1930,7 +1975,7 @@ WayPoint* PlanningHelpers::BuildPlanningSearchTreeV2(WayPoint* pStart,
 		nCounter++;
 
 		unsigned int min_cost_index = 0;
-		double min_cost = 99999999999;
+		double min_cost = DBL_MAX;
 
 		for(unsigned int i=0; i &lt; nextLeafToTrace.size(); i++)
 		{
@@ -2066,7 +2111,7 @@ WayPoint* PlanningHelpers::BuildPlanningSearchTreeStraight(WayPoint* pStart,
 		nCounter++;
 
 		unsigned int min_cost_index = 0;
-		double min_cost = 99999999999;
+		double min_cost = DBL_MAX;
 
 		for(unsigned int i=0; i &lt; nextLeafToTrace.size(); i++)
 		{
@@ -2310,7 +2355,7 @@ bool PlanningHelpers::CheckLaneIdExits(const std::vector&lt;int&gt;&amp; lanes, const Lane
 
 WayPoint* PlanningHelpers::CheckLaneExits(const vector&lt;WayPoint*&gt;&amp; nodes, const Lane* pL)
 {
-	if(nodes.size()==0) return 0;
+	if(nodes.size()==0) return nullptr;
 
 	for(unsigned int i=0; i&lt; nodes.size(); i++)
 	{
@@ -2318,12 +2363,12 @@ WayPoint* PlanningHelpers::CheckLaneExits(const vector&lt;WayPoint*&gt;&amp; nodes, const
 			return nodes.at(i);
 	}
 
-	return 0;
+	return nullptr;
 }
 
 WayPoint* PlanningHelpers::CheckNodeExits(const vector&lt;WayPoint*&gt;&amp; nodes, const WayPoint* pL)
 {
-	if(nodes.size()==0) return 0;
+	if(nodes.size()==0) return nullptr;
 
 	for(unsigned int i=0; i&lt; nodes.size(); i++)
 	{
@@ -2331,14 +2376,14 @@ WayPoint* PlanningHelpers::CheckNodeExits(const vector&lt;WayPoint*&gt;&amp; nodes, const
 			return nodes.at(i);
 	}
 
-	return 0;
+	return nullptr;
 }
 
 WayPoint* PlanningHelpers::CreateLaneHeadCell(Lane* pLane, WayPoint* pLeft, WayPoint* pRight,
 		WayPoint* pBack)
 {
-	if(!pLane) return 0;
-	if(pLane-&gt;points.size()==0) return 0;
+	if(!pLane) return nullptr;
+	if(pLane-&gt;points.size()==0) return nullptr;
 
 	WayPoint* c = new WayPoint;
 	c-&gt;pLane 		= pLane;
@@ -2661,171 +2706,61 @@ void PlanningHelpers::WritePathToFile(const string&amp; fileName, const vector&lt;WayPo
 	 dataFile.WriteLogData("", fileName, str_header.str(), dataList);
 }
 
-void PlanningHelpers::TestQuadraticSpline (const std::vector&lt;WayPoint&gt;&amp; center_line, std::vector&lt;WayPoint&gt;&amp; path)
+LIGHT_INDICATOR PlanningHelpers::GetIndicatorsFromPath(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; pose,  const double&amp; seachDistance)
 {
+	if(path.size() &lt; 2)
+		return INDICATOR_NONE;
 
-//  int N = center_line.size();
-//  int i;
-//	int ibcbeg;
-//	int ibcend;
-//	int j;
-//	int jhi;
-//	int k;
-//	double t[N];
-//	double tval;
-//	double y[N];
-//	double ybcbeg;
-//	double ybcend;
-//	double *ypp;
-//	double yppval;
-//	double ypval;
-//	double yval;
-//
-//  cout &lt;&lt; "\n";
-//  cout &lt;&lt; "TEST24\n";
-//  cout &lt;&lt; "  SPLINE_QUADRATIC_VAL evaluates a\n";
-//  cout &lt;&lt; "    quadratic spline.\n";
-//  cout &lt;&lt; "\n";
-//  cout &lt;&lt; "  Runge''s function, evenly spaced knots.\n";
-//
-//  for ( i = 0; i &lt; N; i++ )
-//  {
-//    t[i] =  center_line.at(i).pos.x;
-//    y[i] =  center_line.at(i).pos.y;
-//  }
-//
-//  //
-//  //  Try various boundary conditions.
-//  //
-//    for ( k = 0; k &lt;= 4; k++ )
-//    {
-//      if ( k == 0 )
-//      {
-//        ibcbeg = 0;
-//        ybcbeg = 0.0;
-//
-//        ibcend = 0;
-//        ybcend = 0.0;
-//
-//        cout &lt;&lt; "\n";
-//        cout &lt;&lt; "  Boundary condition 0 at both ends:\n";
-//        cout &lt;&lt; "  Spline is quadratic in boundary intervals.\n";
-//      }
-//      else if ( k == 1 )
-//      {
-//        ibcbeg = 1;
-//        ybcbeg = t[0];
-//
-//        ibcend = 1;
-//        ybcend = t[N-1] ;
-//
-//        cout &lt;&lt; "\n";
-//        cout &lt;&lt; "  Boundary condition 1 at both ends:\n";
-//        cout &lt;&lt; "  Y'(left) =  " &lt;&lt; ybcbeg &lt;&lt; "\n";
-//        cout &lt;&lt; "  Y'(right) = " &lt;&lt; ybcend &lt;&lt; "\n";
-//
-//      }
-//      else if ( k == 2 )
-//      {
-//        ibcbeg = 2;
-//        ybcbeg = fpprunge ( t[0] );
-//
-//        ibcend = 2;
-//        ybcend = fpprunge ( t[N-1] );
-//
-//        cout &lt;&lt; "\n";
-//        cout &lt;&lt; "  Boundary condition 2 at both ends:\n";
-//        cout &lt;&lt; "  YP''(left) =  " &lt;&lt; ybcbeg &lt;&lt; "\n";
-//        cout &lt;&lt; "  YP''(right) = " &lt;&lt; ybcend &lt;&lt; "\n";
-//      }
-//      else if ( k == 3 )
-//      {
-//        ibcbeg = 2;
-//        ybcbeg = 0.0;
-//
-//        ibcend = 2;
-//        ybcend = 0.0;
-//
-//        cout &lt;&lt; "\n";
-//        cout &lt;&lt; "  Natural spline:\n";
-//        cout &lt;&lt; "  YP''(left) =  " &lt;&lt; ybcbeg &lt;&lt; "\n";
-//        cout &lt;&lt; "  YP''(right) = " &lt;&lt; ybcend &lt;&lt; "\n";
-//      }
-//      else if ( k == 4 )
-//      {
-//        ibcbeg = 3;
-//        ibcend = 3;
-//
-//        cout &lt;&lt; "\n";
-//        cout &lt;&lt; "  \"Not-a-knot\" spline:\n";
-//      }
-//
-//      ypp = spline_cubic_set ( N, t, y, ibcbeg, ybcbeg, ibcend, ybcend );
-//
-//      cout &lt;&lt; "\n";
-//      cout &lt;&lt; "  SPLINE''(T), F''(T):\n";
-//      cout &lt;&lt; "\n";
-//      for ( i = 0; i &lt; N; i++ )
-//      {
-//        cout &lt;&lt; ypp[i] &lt;&lt; "  "
-//             &lt;&lt; fpprunge ( t[i] ) &lt;&lt; "\n";
-//      }
-//
-//      cout &lt;&lt; "\n";
-//      cout &lt;&lt; "  T, SPLINE(T), F(T)\n";
-//      cout &lt;&lt; "\n";
-//
-//      for ( i = 0; i &lt;= N; i++ )
-//      {
-//        if ( i == 0 )
-//        {
-//          jhi = 1;
-//        }
-//        else if ( i &lt; N )
-//        {
-//          jhi = 2;
-//        }
-//        else
-//        {
-//          jhi = 2;
-//        }
-//
-//        for ( j = 1; j &lt;= jhi; j++ )
-//        {
-//          if ( i == 0 )
-//          {
-//            tval = t[0] - 1.0;
-//          }
-//          else if ( i &lt; N )
-//          {
-//            tval = (
-//                ( double ) ( jhi - j + 1 ) * t[i-1]
-//              + ( double ) (       j - 1 ) * t[i] )
-//              / ( double ) ( jhi         );
-//          }
-//          else
-//          {
-//            if ( j == 1 )
-//            {
-//              tval = t[N-1];
-//            }
-//            else
-//            {
-//              tval = t[N-1] + 1.0;
-//            }
-//          }
-//
-//          yval = spline_cubic_val ( N, t, y, ypp, tval, &amp;ypval, &amp;yppval );
-//
-//          cout &lt;&lt; tval &lt;&lt; "  "
-//               &lt;&lt; yval &lt;&lt; "  "
-//               &lt;&lt; frunge ( tval ) &lt;&lt; "\n";
-//        }
-//      }
-//      delete [] ypp;
-//    }
-//
-//    return;
+	LIGHT_INDICATOR ind = INDICATOR_NONE;
+	RelativeInfo info;
+	PlanningHelpers::GetRelativeInfo(path, pose, info);
+
+	if(info.perp_point.actionCost.size() &gt; 0)
+	{
+		if(info.perp_point.actionCost.at(0).first == LEFT_TURN_ACTION)
+			ind = INDICATOR_LEFT;
+		else if(info.perp_point.actionCost.at(0).first == RIGHT_TURN_ACTION)
+			ind = INDICATOR_RIGHT;
+	}
+
+	double total_d = 0;
+	for(unsigned int i=info.iFront; i &lt; path.size()-2; i++)
+	{
+
+		total_d+= hypot(path.at(i+1).pos.y - path.at(i).pos.y, path.at(i+1).pos.x - path.at(i).pos.x);
+		if(path.at(i).actionCost.size() &gt; 0)
+		{
+			if(path.at(i).actionCost.at(0).first == LEFT_TURN_ACTION)
+				return INDICATOR_LEFT;
+			else if(path.at(i).actionCost.at(0).first == RIGHT_TURN_ACTION)
+				return INDICATOR_RIGHT;
+		}
+
+		if(total_d &gt; seachDistance)
+			break;
+	}
+
+	return ind;
+}
+
+PlannerHNS::WayPoint PlanningHelpers::GetRealCenter(const PlannerHNS::WayPoint&amp; currState, const double&amp; wheel_base)
+{
+	PlannerHNS::WayPoint pose_center = currState;
+	PlannerHNS::Mat3 rotationMat(-currState.pos.a);
+	PlannerHNS::Mat3 translationMat(-currState.pos.x, -currState.pos.y);
+
+	PlannerHNS::Mat3 rotationMatInv(currState.pos.a);
+	PlannerHNS::Mat3 translationMatInv(currState.pos.x, currState.pos.y);
+
+	pose_center.pos = translationMat*pose_center.pos;
+	pose_center.pos = rotationMat*pose_center.pos;
+
+	pose_center.pos.x += wheel_base/3.0;
+
+	pose_center.pos = rotationMatInv*pose_center.pos;
+	pose_center.pos = translationMatInv*pose_center.pos;
+
+	return pose_center;
 }
 
 double PlanningHelpers::frunge ( double x )
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\op_RosHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\op_RosHelpers.cpp" added_lines="4" deleted_lines="1">
				<diff>@@ -1508,10 +1508,13 @@ void RosHelpers::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::R
 	std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt; vector_data;
 	std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt; curb_data;
 	std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt; roadedge_data;
+	std::vector&lt;UtilityHNS::AisanWayareaFileReader::AisanWayarea&gt; way_area;
+	std::vector&lt;UtilityHNS::AisanCrossWalkFileReader::AisanCrossWalk&gt; crossing;
+	std::vector&lt;UtilityHNS::AisanNodesFileReader::AisanNode &gt; nodes_data;
 	std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;
 
 	PlannerHNS::GPSPoint origin;//(m_OriginPos.position.x, m_OriginPos.position.y, m_OriginPos.position.z, 0);
-	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data, conn_data, origin, out_map);
+	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data,way_area, crossing, nodes_data,  conn_data, origin, out_map);
 }
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\DataRW.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\DataRW.h" added_lines="108" deleted_lines="10">
				<diff>@@ -1,9 +1,9 @@
-/*
- * DataRW.h
- *
- *  Created on: Jun 23, 2016
- *      Author: hatem
- */
+
+/// \file DataRW.h
+/// \brief File operations for loading vector map files, loading kml map files and writing log .csv files
+/// \author Hatem Darweesh
+/// \date Jun 23, 2016
+
 
 #ifndef DATARW_H_
 #define DATARW_H_
@@ -13,6 +13,7 @@
 #include &lt;sstream&gt;
 #include &lt;vector&gt;
 #include &lt;iostream&gt;
+#include &lt;limits&gt;
 
 namespace UtilityHNS {
 
@@ -192,11 +193,20 @@ public:
 		int MCODE3;
 	};
 
-	AisanPointsFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanPointsFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
 	~AisanPointsFileReader(){}
 
+	std::vector&lt;AisanPoints&gt; m_data_list;
 	bool ReadNextLine(AisanPoints&amp; data);
 	int ReadAllData(std::vector&lt;AisanPoints&gt;&amp; data_list);
+	AisanPoints* GetDataRowById(int _pid);
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanPoints*&gt; m_data_map;
 };
 
 class AisanNodesFileReader : public SimpleReaderBase
@@ -209,11 +219,21 @@ public:
 		int PID;
 	};
 
-	AisanNodesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanNodesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
 	~AisanNodesFileReader(){}
 
+	std::vector&lt;AisanNode&gt; m_data_list;
 	bool ReadNextLine(AisanNode&amp; data);
 	int ReadAllData(std::vector&lt;AisanNode&gt;&amp; data_list);
+	AisanNode* GetDataRowById(int _nid);
+
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanNode*&gt; m_data_map;
 };
 
 class AisanLinesFileReader : public SimpleReaderBase
@@ -229,11 +249,41 @@ public:
 		int FLID;
 	};
 
-	AisanLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
 	~AisanLinesFileReader(){}
 
+	std::vector&lt;AisanLine&gt; m_data_list;
 	bool ReadNextLine(AisanLine&amp; data);
 	int ReadAllData(std::vector&lt;AisanLine&gt;&amp; data_list);
+	AisanLine* GetDataRowById(int _lid);
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanLine*&gt; m_data_map;
+};
+
+class AisanCLinesFileReader : public SimpleReaderBase
+{
+public:
+
+	struct AisanCLine
+	{
+		int ID;
+		int LID;
+		double width;
+		char color;
+		int type;
+		int LinkID;
+	};
+
+	AisanCLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	~AisanCLinesFileReader(){}
+
+	bool ReadNextLine(AisanCLine&amp; data);
+	int ReadAllData(std::vector&lt;AisanCLine&gt;&amp; data_list);
 };
 
 class AisanCenterLinesFileReader : public SimpleReaderBase
@@ -330,13 +380,23 @@ public:
 		int  LeftLaneId;
 		int RightLaneId;
 
+		int originalMapID;
 	};
 
-	AisanLanesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanLanesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
 	~AisanLanesFileReader(){}
 
+	std::vector&lt;AisanLane&gt; m_data_list;
 	bool ReadNextLine(AisanLane&amp; data);
 	int ReadAllData(std::vector&lt;AisanLane&gt;&amp; data_list);
+	AisanLane* GetDataRowById(int _lnid);
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanLane*&gt; m_data_map;
 };
 
 class AisanStopLineFileReader : public SimpleReaderBase
@@ -457,6 +517,44 @@ public:
 	int ReadAllData(std::vector&lt;AisanRoadEdge&gt;&amp; data_list);
 };
 
+class AisanCrossWalkFileReader : public SimpleReaderBase
+{
+public:
+
+	struct AisanCrossWalk
+	{
+		int 	ID;
+		int 	AID;
+		int 	Type;
+		int		BdID;
+		int 	LinkID;
+	};
+
+	AisanCrossWalkFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	~AisanCrossWalkFileReader(){}
+
+	bool ReadNextLine(AisanCrossWalk&amp; data);
+	int ReadAllData(std::vector&lt;AisanCrossWalk&gt;&amp; data_list);
+};
+
+class AisanWayareaFileReader : public SimpleReaderBase
+{
+public:
+
+	struct AisanWayarea
+	{
+		int 	ID;
+		int 	AID;
+		int 	LinkID;
+	};
+
+	AisanWayareaFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	~AisanWayareaFileReader(){}
+
+	bool ReadNextLine(AisanWayarea&amp; data);
+	int ReadAllData(std::vector&lt;AisanWayarea&gt;&amp; data_list);
+};
+
 class AisanDataConnFileReader : public SimpleReaderBase
 {
 public:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" added_lines="263" deleted_lines="26">
				<diff>@@ -1,9 +1,8 @@
-/*
- * DataRW.cpp
- *
- *  Created on: Jun 23, 2016
- *      Author: hatem
- */
+
+/// \file DataRW.cpp
+/// \brief File operations for loading vector map files, loading kml map files and writing log .csv files
+/// \author Hatem Darweesh
+/// \date Jun 23, 2016
 
 #include "op_utility/DataRW.h"
 #include &lt;stdlib.h&gt;
@@ -17,7 +16,7 @@ using namespace std;
 namespace UtilityHNS
 {
 
-std::string DataRW::LoggingMainfolderName 	= "/SimuLogs/";
+std::string DataRW::LoggingMainfolderName 	= "/autoware_openplanner_logs/";
 std::string DataRW::ControlLogFolderName 	= "ControlLogs/";
 std::string DataRW::GlobalPathLogFolderName = "GlobalPathLogs/";
 std::string DataRW::PathLogFolderName 		= "TrajectoriesLogs/";
@@ -458,7 +457,7 @@ bool AisanNodesFileReader::ReadNextLine(AisanNode&amp; data)
 	if(ReadSingleLine(lineData))
 	{
 		if(lineData.size()==0) return false;
-		if(lineData.at(0).size() &lt; 10) return false;
+		if(lineData.at(0).size() &lt; 2) return false;
 
 		data.NID = strtol(lineData.at(0).at(0).c_str(), NULL, 10);
 		data.PID = strtol(lineData.at(0).at(1).c_str(), NULL, 10);
@@ -472,16 +471,49 @@ bool AisanNodesFileReader::ReadNextLine(AisanNode&amp; data)
 
 int AisanNodesFileReader::ReadAllData(vector&lt;AisanNode&gt;&amp; data_list)
 {
-	data_list.clear();
+	m_data_list.clear();
 	AisanNode data;
 	//double logTime = 0;
-	int count = 0;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
 	while(ReadNextLine(data))
 	{
-		data_list.push_back(data);
-		count++;
+		m_data_list.push_back(data);
+		if(data.NID &lt; m_min_id)
+			m_min_id = data.NID;
+
+		if(data.NID &gt; max_id)
+			max_id = data.NID;
 	}
-	return count;
+
+	m_data_map.resize(max_id - m_min_id + 2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).NID-m_min_id) = &amp;m_data_list.at(i);
+	}
+
+	data_list = m_data_list;
+	return m_data_list.size();
+}
+
+AisanNodesFileReader::AisanNode* AisanNodesFileReader::GetDataRowById(int _nid)
+{
+	int index = _nid-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
+	{
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+		{
+			if(m_data_list.at(i).NID == _nid)
+			{
+				return &amp;m_data_list.at(i);
+			}
+		}
+	}
+
+	return nullptr;
 }
 
 bool AisanPointsFileReader::ReadNextLine(AisanPoints&amp; data)
@@ -513,16 +545,49 @@ bool AisanPointsFileReader::ReadNextLine(AisanPoints&amp; data)
 
 int AisanPointsFileReader::ReadAllData(vector&lt;AisanPoints&gt;&amp; data_list)
 {
-	data_list.clear();
+	m_data_list.clear();
 	AisanPoints data;
 	//double logTime = 0;
-	int count = 0;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
 	while(ReadNextLine(data))
 	{
-		data_list.push_back(data);
-		count++;
+		m_data_list.push_back(data);
+		if(data.PID &lt; m_min_id)
+			m_min_id = data.PID;
+
+		if(data.PID &gt; max_id)
+			max_id = data.PID;
 	}
-	return count;
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).PID-m_min_id) = &amp;m_data_list.at(i);
+	}
+
+	data_list = m_data_list;
+	return m_data_list.size();
+}
+
+AisanPointsFileReader::AisanPoints* AisanPointsFileReader::GetDataRowById(int _pid)
+{
+	int index = _pid-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
+	{
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+		{
+			if(m_data_list.at(i).PID == _pid)
+			{
+				return &amp;m_data_list.at(i);
+			}
+		}
+	}
+
+	return nullptr;
 }
 
 bool AisanLinesFileReader::ReadNextLine(AisanLine&amp; data)
@@ -550,6 +615,75 @@ int AisanLinesFileReader::ReadAllData(vector&lt;AisanLine&gt;&amp; data_list)
 	data_list.clear();
 	AisanLine data;
 	//double logTime = 0;
+
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+	while(ReadNextLine(data))
+	{
+		m_data_list.push_back(data);
+		if(data.LID &lt; m_min_id)
+			m_min_id = data.LID;
+
+		if(data.LID &gt; max_id)
+			max_id = data.LID;
+	}
+
+	m_data_map.resize(max_id - m_min_id + 2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).LID-m_min_id) = &amp;m_data_list.at(i);
+	}
+
+	data_list = m_data_list;
+	return m_data_list.size();
+}
+
+AisanLinesFileReader::AisanLine* AisanLinesFileReader::GetDataRowById(int _lid)
+{
+	int index = _lid-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
+	{
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+		{
+			if(m_data_list.at(i).LID == _lid)
+			{
+				return &amp;m_data_list.at(i);
+			}
+		}
+	}
+
+	return nullptr;
+}
+
+bool AisanCLinesFileReader::ReadNextLine(AisanCLine&amp; data)
+{
+	vector&lt;vector&lt;string&gt; &gt; lineData;
+	if(ReadSingleLine(lineData))
+	{
+		if(lineData.size()==0) return false;
+		if(lineData.at(0).size() &lt; 5) return false;
+
+		data.ID = strtol(lineData.at(0).at(0).c_str(), NULL, 10);
+		data.LID = strtol(lineData.at(0).at(1).c_str(), NULL, 10);
+		data.width = strtod(lineData.at(0)[2].c_str(), NULL);
+		if(lineData.at(0).at(3).size()&gt;0)
+			data.type = lineData.at(0).at(3).at(0);
+		data.LinkID = strtol(lineData.at(0).at(4).c_str(), NULL, 10);
+
+		return true;
+	}
+	else
+		return false;
+}
+
+int AisanCLinesFileReader::ReadAllData(vector&lt;AisanCLine&gt;&amp; data_list)
+{
+	data_list.clear();
+	AisanCLine data;
+	//double logTime = 0;
 	int count = 0;
 	while(ReadNextLine(data))
 	{
@@ -565,7 +699,7 @@ bool AisanCenterLinesFileReader::ReadNextLine(AisanCenterLine&amp; data)
 	if(ReadSingleLine(lineData))
 	{
 		if(lineData.size()==0) return false;
-		if(lineData.at(0).size() &lt; 5) return false;
+		if(lineData.at(0).size() &lt; 10) return false;
 
 		data.DID 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
 		data.Dist 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
@@ -662,13 +796,48 @@ int AisanLanesFileReader::ReadAllData(vector&lt;AisanLane&gt;&amp; data_list)
 	data_list.clear();
 	AisanLane data;
 	//double logTime = 0;
-	int count = 0;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
 	while(ReadNextLine(data))
 	{
-		data_list.push_back(data);
-		count++;
+		m_data_list.push_back(data);
+		if(data.LnID &lt; m_min_id)
+			m_min_id = data.LnID;
+
+		if(data.LnID &gt; max_id)
+			max_id = data.LnID;
 	}
-	return count;
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).LnID-m_min_id) = &amp;m_data_list.at(i);
+	}
+
+	data_list = m_data_list;
+
+	return m_data_list.size();
+}
+
+AisanLanesFileReader::AisanLane* AisanLanesFileReader::GetDataRowById(int _lnid)
+{
+int index = _lnid-m_min_id;
+if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+{
+	return m_data_map.at(index);
+}
+else
+{
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		if(m_data_list.at(i).LnID == _lnid)
+		{
+			return &amp;m_data_list.at(i);
+		}
+	}
+}
+
+return nullptr;
 }
 
 bool AisanAreasFileReader::ReadNextLine(AisanArea&amp; data)
@@ -889,8 +1058,8 @@ bool AisanCurbFileReader::ReadNextLine(AisanCurb&amp; data)
 		data.LID 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
 		data.Height = strtod(lineData.at(0).at(2).c_str(), NULL);
 		data.Width 	= strtod(lineData.at(0).at(3).c_str(), NULL);
-		data.dir 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
-		data.LinkID = strtol(lineData.at(0).at(1).c_str(), NULL, 10);
+		data.dir 	= strtol(lineData.at(0).at(4).c_str(), NULL, 10);
+		data.LinkID = strtol(lineData.at(0).at(5).c_str(), NULL, 10);
 
 		return true;
 
@@ -923,7 +1092,7 @@ bool AisanRoadEdgeFileReader::ReadNextLine(AisanRoadEdge&amp; data)
 
 		data.ID 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
 		data.LID 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
-		data.LinkID = strtol(lineData.at(0).at(1).c_str(), NULL, 10);
+		data.LinkID = strtol(lineData.at(0).at(2).c_str(), NULL, 10);
 
 		return true;
 
@@ -946,6 +1115,74 @@ int AisanRoadEdgeFileReader::ReadAllData(vector&lt;AisanRoadEdge&gt;&amp; data_list)
 	return count;
 }
 
+bool AisanCrossWalkFileReader::ReadNextLine(AisanCrossWalk&amp; data)
+{
+	vector&lt;vector&lt;string&gt; &gt; lineData;
+	if(ReadSingleLine(lineData))
+	{
+		if(lineData.size()==0) return false;
+		if(lineData.at(0).size() &lt; 5) return false;
+
+		data.ID 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
+		data.AID 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
+		data.Type 	= strtol(lineData.at(0).at(2).c_str(), NULL, 10);
+		data.BdID 	= strtol(lineData.at(0).at(3).c_str(), NULL, 10);
+		data.LinkID = strtol(lineData.at(0).at(4).c_str(), NULL, 10);
+
+		return true;
+
+	}
+	else
+		return false;
+}
+
+int AisanCrossWalkFileReader::ReadAllData(vector&lt;AisanCrossWalk&gt;&amp; data_list)
+{
+	data_list.clear();
+	AisanCrossWalk data;
+	//double logTime = 0;
+	int count = 0;
+	while(ReadNextLine(data))
+	{
+		data_list.push_back(data);
+		count++;
+	}
+	return count;
+}
+
+bool AisanWayareaFileReader::ReadNextLine(AisanWayarea&amp; data)
+{
+	vector&lt;vector&lt;string&gt; &gt; lineData;
+	if(ReadSingleLine(lineData))
+	{
+		if(lineData.size()==0) return false;
+		if(lineData.at(0).size() &lt; 3) return false;
+
+		data.ID 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
+		data.AID 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
+		data.LinkID = strtol(lineData.at(0).at(2).c_str(), NULL, 10);
+
+		return true;
+
+	}
+	else
+		return false;
+}
+
+int AisanWayareaFileReader::ReadAllData(vector&lt;AisanWayarea&gt;&amp; data_list)
+{
+	data_list.clear();
+	AisanWayarea data;
+	//double logTime = 0;
+	int count = 0;
+	while(ReadNextLine(data))
+	{
+		data_list.push_back(data);
+		count++;
+	}
+	return count;
+}
+
 bool AisanDataConnFileReader::ReadNextLine(DataConn&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" added_lines="4" deleted_lines="1">
				<diff>@@ -364,10 +364,13 @@ void way_planner_core::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, Planner
 	std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt; vector_data;
 	std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt; curb_data;
 	std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt; roadedge_data;
+	std::vector&lt;UtilityHNS::AisanWayareaFileReader::AisanWayarea&gt; way_area;
+	std::vector&lt;UtilityHNS::AisanCrossWalkFileReader::AisanCrossWalk&gt; crossing;
+	std::vector&lt;UtilityHNS::AisanNodesFileReader::AisanNode &gt; nodes_data;
 	std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;
 
 	PlannerHNS::GPSPoint origin;//(m_OriginPos.position.x, m_OriginPos.position.y, m_OriginPos.position.z, 0);
-	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data, conn_data, origin, out_map);
+	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data,way_area, crossing, nodes_data, conn_data, origin, out_map);
 }
 
 bool way_planner_core::GenerateGlobalPlan(PlannerHNS::WayPoint&amp; startPoint, PlannerHNS::WayPoint&amp; goalPoint, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; generatedTotalPaths)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\RosHelpers.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\RosHelpers.cpp" added_lines="4" deleted_lines="1">
				<diff>@@ -841,10 +841,13 @@ void RosHelpers::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::R
 	std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt; vector_data;
 	std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt; curb_data;
 	std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt; roadedge_data;
+	std::vector&lt;UtilityHNS::AisanWayareaFileReader::AisanWayarea&gt; way_area;
+	std::vector&lt;UtilityHNS::AisanCrossWalkFileReader::AisanCrossWalk&gt; crossing;
+	std::vector&lt;UtilityHNS::AisanNodesFileReader::AisanNode &gt; nodes_data;
 	std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;
 
 	PlannerHNS::GPSPoint origin;//(m_OriginPos.position.x, m_OriginPos.position.y, m_OriginPos.position.z, 0);
-	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data,curb_data, roadedge_data, conn_data, origin, out_map);
+	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data,curb_data, roadedge_data, way_area, crossing, nodes_data, conn_data, origin, out_map);
 }
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\MainWindowWrapper.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\MainWindowWrapper.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -289,7 +289,7 @@ void MainWindowWrapper::KeyboardExitCommand(unsigned char key, int x, int y)
 
 void MainWindowWrapper::KeyboardCommand(unsigned char key, int x, int y)
 {
-	cout &lt;&lt; "Char : " &lt;&lt; (int)key &lt;&lt;  endl;
+	//cout &lt;&lt; "Char : " &lt;&lt; (int)key &lt;&lt;  endl;
 	if(m_DrawAndControl)
 		m_DrawAndControl-&gt;OnKeyboardPress(0, key);
 
@@ -303,7 +303,7 @@ void MainWindowWrapper::KeyboardCommand(unsigned char key, int x, int y)
 
 void MainWindowWrapper::KeyboardSpecialCommand(int key, int x, int y)
 {
-	cout &lt;&lt; "Control : " &lt;&lt; key &lt;&lt; endl;
+	//cout &lt;&lt; "Control : " &lt;&lt; key &lt;&lt; endl;
 
 	if(m_DrawAndControl)
 		m_DrawAndControl-&gt;OnKeyboardPress(key, 0);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c39d7f64cabeeb0ae884e10a691d686e633d857b" author="Yusuke FUJII">
		<msg>fix to get wheel_base</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -66,7 +66,7 @@ void PurePursuitNode::initForROS()
   private_nh_.param("is_linear_interpolation", is_linear_interpolation_, bool(true));
   // ROS_INFO_STREAM("is_linear_interpolation : " &lt;&lt; is_linear_interpolation_);
   private_nh_.param("publishes_for_steering_robot", publishes_for_steering_robot_, bool(false));
-  private_nh_.param("vehicle_info/wheel_base", wheel_base_, double(2.7));
+  nh_.param("vehicle_info/wheel_base", wheel_base_, double(2.7));
 
   // setup subscriber
   sub1_ = nh_.subscribe("final_waypoints", 10, &amp;PurePursuitNode::callbackFromWayPoints, this);
@@ -157,9 +157,8 @@ double PurePursuitNode::computeLookaheadDistance() const
   double maximum_lookahead_distance = current_linear_velocity_ * 10;
   double ld = current_linear_velocity_ * lookahead_distance_ratio_;
 
-  return ld &lt; minimum_lookahead_distance_ ? minimum_lookahead_distance_
-        : ld &gt; maximum_lookahead_distance ? maximum_lookahead_distance
-        : ld;
+  return ld &lt; minimum_lookahead_distance_ ? minimum_lookahead_distance_ :
+                                            ld &gt; maximum_lookahead_distance ? maximum_lookahead_distance : ld;
 }
 
 double PurePursuitNode::computeCommandVelocity() const
@@ -176,17 +175,18 @@ double PurePursuitNode::computeCommandAccel() const
   const geometry_msgs::Pose target_pose = pp_.getCurrentWaypoints().at(1).pose.pose;
 
   // v^2 - v0^2 = 2ax
-  const double x =  std::hypot(current_pose.position.x-target_pose.position.x, current_pose.position.y-target_pose.position.y);
+  const double x =
+      std::hypot(current_pose.position.x - target_pose.position.x, current_pose.position.y - target_pose.position.y);
   const double v0 = current_linear_velocity_;
   const double v = computeCommandVelocity();
-  const double a = (v*v - v0*v0) / (2*x);
+  const double a = (v * v - v0 * v0) / (2 * x);
   return a;
 }
 
 double PurePursuitNode::computeAngularGravity(double velocity, double kappa) const
 {
   const double gravity = 9.80665;
-  return (velocity*velocity) / (1.0/kappa*gravity);
+  return (velocity * velocity) / (1.0 / kappa * gravity);
 }
 
 void PurePursuitNode::callbackFromConfig(const autoware_msgs::ConfigWaypointFollowerConstPtr &amp;config)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -284,7 +284,7 @@ int main(int argc, char **argv)
 
   private_nh.param("position_error", g_position_error, double(0.0));
   private_nh.param("angle_error", g_angle_error, double(0.0));
-  private_nh.param("vehicle_info/wheel_base", g_wheel_base_m, double(2.7));
+  nh.param("vehicle_info/wheel_base", g_wheel_base_m, double(2.7));
 
   private_nh.param("use_ctrl_cmd", _use_ctrl_cmd, false);
   // publish topic
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="429a119d300d5b736b3eefb0d80aa923e086dd08" author="hatem-darweesh">
		<msg>Fix Vector Map parser problem, tested with three different maps
Fix Global Planning function for the new map modification
Add OpenPlanner Simulator for perception, traffic lights, cars
Add OpenPlanner new version to replace wp_planner and dp_planner
Remove unnecessary files from OpenPlanner libraries
Test Global and Local planning
Test Tracking node (kf_contour_track)
Test Simulation Nodes
Test Utility Nodes</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\lidar_kf_contour_track_core.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\lidar_kf_contour_track_core.h" added_lines="9" deleted_lines="0">
				<diff>@@ -62,6 +62,7 @@ public:
 	bool    bEnableSimulation;
 	bool 	bEnableStepByStep;
 	bool 	bEnableLogging;
+	bool bEnableTTC;
 
 	PerceptionParams()
 	{
@@ -76,6 +77,7 @@ public:
 		bEnableStepByStep = false;
 		bEnableSimulation = false;
 		bEnableLogging = false;
+		bEnableTTC = false;
 	}
 };
 
@@ -101,6 +103,10 @@ protected:
 	std::vector&lt;visualization_msgs::MarkerArray&gt; m_MatchingInfoDummy;
 	std::vector&lt;visualization_msgs::MarkerArray&gt; m_MatchingInfoActual;
 
+
+	visualization_msgs::MarkerArray m_TTC_Path;
+	visualization_msgs::Marker m_TTC_Info;
+
 	std::vector&lt;std::string&gt;    m_LogData;
 	PlannerHNS::MAP_SOURCE_TYPE m_MapType;
 	std::string m_MapPath;
@@ -127,6 +133,7 @@ protected:
 
 	ros::Publisher pub_DetectedPolygonsRviz;
 	ros::Publisher pub_TrackedObstaclesRviz;
+	ros::Publisher pub_TTC_PathRviz;
 
 	// define subscribers.
 	ros::Subscriber sub_cloud_clusters;
@@ -141,6 +148,8 @@ protected:
 	void VisualizeLocalTracking();
 	void ImportCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr&amp; msg, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; originalClusters);
 	bool IsCar(const PlannerHNS::DetectedObject&amp; obj, const PlannerHNS::WayPoint&amp; currState, PlannerHNS::RoadNetwork&amp; map);
+	void CalculateTTC(const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; objs, const PlannerHNS::WayPoint&amp; currState, PlannerHNS::RoadNetwork&amp; map);
+	void GetFrontTrajectories(std::vector&lt;PlannerHNS::Lane*&gt;&amp; lanes, const PlannerHNS::WayPoint&amp; currState, const double&amp; max_distance, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; trajectories);
 	void ReadNodeParams();
 	void ReadCommonParams();
 	void LogAndSend();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track_core.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track_core.cpp" added_lines="84" deleted_lines="0">
				<diff>@@ -33,6 +33,7 @@
 #include "lidar_kf_contour_track_core.h"
 #include "op_ros_helpers/op_RosHelpers.h"
 #include "op_planner/MappingHelpers.h"
+#include "op_planner/PlannerH.h"
 
 namespace ContourTrackerNS
 {
@@ -67,6 +68,7 @@ ContourTracker::ContourTracker()
 	pub_AllTrackedObjects 	= nh.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("tracked_objects", 1);
 	pub_DetectedPolygonsRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detected_polygons", 1);
 	pub_TrackedObstaclesRviz = nh.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("op_planner_tracked_boxes", 1);
+	pub_TTC_PathRviz		= nh.advertise&lt;visualization_msgs::MarkerArray&gt;("ttc_direct_path", 1);
 
 
 	m_nDummyObjPerRep = 150;
@@ -168,6 +170,8 @@ void ContourTracker::callbackGetCloudClusters(const autoware_msgs::CloudClusterA
 
 		LogAndSend();
 		VisualizeLocalTracking();
+
+		CalculateTTC(m_ObstacleTracking.m_DetectedObjects, m_CurrentPos, m_Map);
 	}
 }
 
@@ -411,6 +415,86 @@ void ContourTracker::LogAndSend()
 	pub_AllTrackedObjects.publish(m_OutPutResults);
 }
 
+void ContourTracker::GetFrontTrajectories(std::vector&lt;PlannerHNS::Lane*&gt;&amp; lanes, const PlannerHNS::WayPoint&amp; currState, const double&amp; max_distance, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; trajectories)
+{
+	double min_d = DBL_MAX;
+	PlannerHNS::WayPoint* pClosest = nullptr;
+	for(unsigned int i =0 ; i &lt; lanes.size(); i++)
+	{
+		PlannerHNS::RelativeInfo info;
+		PlannerHNS::PlanningHelpers::GetRelativeInfoLimited(lanes.at(i)-&gt;points, currState, info);
+		PlannerHNS::WayPoint wp = lanes.at(i)-&gt;points.at(info.iFront);
+
+		if(!info.bAfter &amp;&amp; !info.bBefore &amp;&amp; fabs(info.perp_distance) &lt; min_d)
+		{
+			min_d = fabs(info.perp_distance);
+			pClosest = &amp;lanes.at(i)-&gt;points.at(info.iBack);
+		}
+	}
+
+	if(pClosest == nullptr) return;
+
+	PlannerHNS::PlannerH planner;
+	std::vector&lt;PlannerHNS::WayPoint*&gt; closest_pts;
+	closest_pts.push_back(pClosest);
+	planner.PredictTrajectoriesUsingDP(currState, closest_pts, max_distance, trajectories, false, false);
+
+}
+
+void ContourTracker::CalculateTTC(const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; objs, const PlannerHNS::WayPoint&amp; currState, PlannerHNS::RoadNetwork&amp; map)
+{
+	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; paths;
+	GetFrontTrajectories(m_ClosestLanesList, currState, m_Params.DetectionRadius, paths);
+
+	double min_d = DBL_MAX;
+	int closest_obj_id = -1;
+	int closest_path_id = -1;
+	int i_start = -1;
+	int i_end = -1;
+
+
+	for(unsigned int i_obj = 0; i_obj &lt; objs.size(); i_obj++)
+	{
+		for(unsigned int i =0 ; i &lt; paths.size(); i++)
+		{
+			PlannerHNS::RelativeInfo obj_info, car_info;
+			PlannerHNS::PlanningHelpers::GetRelativeInfoLimited(paths.at(i), objs.at(i_obj).center , obj_info);
+
+			if(!obj_info.bAfter &amp;&amp; !obj_info.bBefore &amp;&amp; fabs(obj_info.perp_distance) &lt; m_MapFilterDistance)
+			{
+				PlannerHNS::PlanningHelpers::GetRelativeInfoLimited(paths.at(i), currState , car_info);
+				double longitudinalDist = PlannerHNS::PlanningHelpers::GetExactDistanceOnTrajectory(paths.at(i), car_info, obj_info);
+				if(longitudinalDist  &lt; min_d)
+				{
+					min_d = longitudinalDist;
+					closest_obj_id = i_obj;
+					closest_path_id = i;
+					i_start = car_info.iFront;
+					i_end = obj_info.iBack;
+				}
+			}
+		}
+	}
+
+	std::vector&lt;PlannerHNS::WayPoint&gt; direct_paths;
+	if(closest_path_id &gt;= 0 &amp;&amp; closest_obj_id &gt;= 0)
+	{
+		for(unsigned int i=i_start; i&lt;i_end; i++)
+		{
+			direct_paths.push_back(paths.at(closest_path_id).at(i));
+		}
+	}
+
+	cout &lt;&lt; "TTC Path Size: " &lt;&lt; direct_paths.size() &lt;&lt; endl;
+
+	//Visualize Direct Path
+	m_TTC_Path.markers.clear();
+	if(direct_paths.size() == 0)
+		direct_paths.push_back(currState);
+	PlannerHNS::RosHelpers::TTC_PathRviz(direct_paths, m_TTC_Path);
+	pub_TTC_PathRviz.publish(m_TTC_Path);
+}
+
 void ContourTracker::MainLoop()
 {
 	ros::Rate loop_rate(50);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\BehaviorStateMachine.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\BehaviorStateMachine.h" added_lines="107" deleted_lines="6">
				<diff>@@ -1,9 +1,9 @@
-/*
- * BehaviorStateMachine.h
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
+
+/// \file BehaviorStateMachine.h
+/// \author Hatem Darweesh
+/// \brief OpenPlanner's state machine implementation for different driving behaviors
+/// \date Jun 19, 2016
+
 
 #ifndef BEHAVIORSTATEMACHINE_H_
 #define BEHAVIORSTATEMACHINE_H_
@@ -27,6 +27,7 @@ public:
 	int m_currentStopSignID	;
 	int m_currentTrafficLightID ;
 	double decisionMakingTime;
+	int decisionMakingCount;
 	double m_zero_velocity;
 
 	PreCalculatedConditions* GetCalcParams()
@@ -52,6 +53,11 @@ public:
 	std::vector&lt;BehaviorStateMachine*&gt; pNextStates;
 
 	BehaviorStateMachine* FindBehaviorState(const STATE_TYPE&amp; behavior);
+	void UpdateLogCount(BehaviorStateMachine* pState);
+	BehaviorStateMachine* FindBestState(int nMinCount);
+
+private:
+	std::vector&lt;std::pair&lt;BehaviorStateMachine*, int&gt; &gt; m_BehaviorsLog;
 };
 
 class ForwardState : public BehaviorStateMachine
@@ -63,6 +69,15 @@ public:
 	virtual BehaviorStateMachine* GetNextState();
 };
 
+class ForwardStateII : public BehaviorStateMachine
+{
+public:
+	ForwardStateII(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
+	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FORWARD_STATE;}
+	virtual ~ForwardStateII(){}
+	virtual BehaviorStateMachine* GetNextState();
+};
+
 class MissionAccomplishedState : public BehaviorStateMachine
 {
 public:
@@ -72,6 +87,15 @@ public:
 	virtual BehaviorStateMachine* GetNextState();
 };
 
+class MissionAccomplishedStateII : public BehaviorStateMachine
+{
+public:
+	MissionAccomplishedStateII(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
+	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FINISH_STATE;}
+	virtual ~MissionAccomplishedStateII(){}
+	virtual BehaviorStateMachine* GetNextState();
+};
+
 class FollowState : public BehaviorStateMachine
 {
 public:
@@ -82,6 +106,16 @@ public:
 
 };
 
+class FollowStateII : public BehaviorStateMachine
+{
+public:
+	FollowStateII(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
+	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FOLLOW_STATE;}
+	virtual ~FollowStateII(){}
+	virtual BehaviorStateMachine* GetNextState();
+
+};
+
 class SwerveState : public BehaviorStateMachine
 {
 public:
@@ -92,6 +126,16 @@ public:
 
 };
 
+class SwerveStateII : public BehaviorStateMachine
+{
+public:
+	SwerveStateII(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
+	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = OBSTACLE_AVOIDANCE_STATE;}
+	virtual ~SwerveStateII(){}
+	virtual BehaviorStateMachine* GetNextState();
+
+};
+
 class StopState : public BehaviorStateMachine
 {
 public:
@@ -131,6 +175,16 @@ public:
 
 };
 
+class StopSignStopStateII : public BehaviorStateMachine
+{
+public:
+	StopSignStopStateII(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
+	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOP_SIGN_STOP_STATE;}
+	virtual ~StopSignStopStateII(){}
+	virtual BehaviorStateMachine* GetNextState();
+
+};
+
 class StopSignWaitState : public BehaviorStateMachine
 {
 public:
@@ -141,6 +195,16 @@ public:
 
 };
 
+class StopSignWaitStateII : public BehaviorStateMachine
+{
+public:
+	StopSignWaitStateII(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
+	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOP_SIGN_WAIT_STATE;}
+	virtual ~StopSignWaitStateII(){}
+	virtual BehaviorStateMachine* GetNextState();
+
+};
+
 class WaitState : public BehaviorStateMachine
 {
 public:
@@ -161,6 +225,15 @@ public:
 
 };
 
+class InitStateII : public BehaviorStateMachine
+{
+public:
+	InitStateII(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
+	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = INITIAL_STATE;}
+	virtual ~InitStateII(){}
+	virtual BehaviorStateMachine* GetNextState();
+};
+
 class GoalState : public BehaviorStateMachine
 {
 public:
@@ -171,6 +244,34 @@ public:
 
 };
 
+class GoalStateII : public BehaviorStateMachine
+{
+public:
+	GoalStateII(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
+	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = GOAL_STATE;}
+	virtual ~GoalStateII(){}
+	virtual BehaviorStateMachine* GetNextState();
+
+};
+
+class TrafficLightStopStateII : public BehaviorStateMachine
+{
+public:
+	TrafficLightStopStateII(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
+	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = TRAFFIC_LIGHT_STOP_STATE;}
+	virtual ~TrafficLightStopStateII(){}
+	virtual BehaviorStateMachine* GetNextState();
+};
+
+class TrafficLightWaitStateII : public BehaviorStateMachine
+{
+public:
+	TrafficLightWaitStateII(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
+	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = TRAFFIC_LIGHT_WAIT_STATE;}
+	virtual ~TrafficLightWaitStateII(){}
+	virtual BehaviorStateMachine* GetNextState();
+};
+
 } /* namespace PlannerHNS */
 
 #endif /* BEHAVIORSTATEMACHINE_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\LocalPlannerH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\LocalPlannerH.h" added_lines="6" deleted_lines="8">
				<diff>@@ -1,9 +1,9 @@
-/*
- * CarState.h
- *
- *  Created on: Dec 14, 2016
- *      Author: hatem
- */
+
+/// \file LocalPlannerH.h
+/// \brief OpenPlanner's local planing functions combines in one process, used in simulation vehicle and OpenPlanner old implementation like dp_planner node.
+/// \author Hatem Darweesh
+/// \date Dec 14, 2016
+
 
 #ifndef LOCALPLANNERH_H_
 #define LOCALPLANNERH_H_
@@ -12,7 +12,6 @@
 #include "PlannerCommonDef.h"
 #include "RoadNetwork.h"
 #include "TrajectoryCosts.h"
-#include "TrajectoryPrediction.h"
 
 #define AVOIDANCE_SPEED_FACTOR 0.75
 namespace PlannerHNS
@@ -61,7 +60,6 @@ public:
 	StopSignWaitState* 			m_pStopSignWaitState;
 
 	TrajectoryCosts m_TrajectoryCostsCalculatotor;
-	TrajectoryPrediction m_TrajectoryPredictionForMovingObstacles;
 
 	//for debugging
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\MappingHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\MappingHelpers.h" added_lines="5" deleted_lines="9">
				<diff>@@ -66,19 +66,11 @@ public:
 
 	static void UpdateMapWithOccupancyGrid(OccupancyToGridMap&amp; map_info, const std::vector&lt;int&gt;&amp; data, RoadNetwork&amp; map, std::vector&lt;WayPoint*&gt;&amp; updated_list);
 
-	//static void SaveTrajectoryLonLatToKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectory);
-
-	static void GetWayPoint(const int&amp; pid, const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points, std::vector&lt;WayPoint&gt;&amp; path);
 	static bool GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; did,
 			const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dtpoints,
 			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
 			const GPSPoint&amp; origin, WayPoint&amp; way_point);
 
-	static bool GetWayPointV2(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; pid,
-			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
-				const GPSPoint&amp; origin, WayPoint&amp; way_point);
-
-	//static void WriteKML(const std::string&amp; kmlFile, const std::string&amp; kmlTemplat, RoadNetwork&amp; ap);
 	static void LoadKML(const std::string&amp; kmlMap, RoadNetwork&amp; map);
 
 	static TiXmlElement* GetHeadElement(TiXmlElement* pMainElem);
@@ -98,6 +90,7 @@ public:
 	static WayPoint GetFirstWaypoint(RoadNetwork&amp; map);
 	static WayPoint* GetLastWaypoint(RoadNetwork&amp; map);
 	static void FindAdjacentLanes(RoadNetwork&amp; map);
+	static void FindAdjacentLanesV2(RoadNetwork&amp; map);
 	static void ExtractSignalData(const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
 			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
 			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
@@ -135,11 +128,14 @@ public:
 			const GPSPoint&amp; origin, RoadNetwork&amp; map);
 
 	static void LinkMissingBranchingWayPoints(RoadNetwork&amp; map);
+	static void LinkMissingBranchingWayPointsV2(RoadNetwork&amp; map);
 	static void LinkTrafficLightsAndStopLinesConData(const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
 			const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; id_replace_list, RoadNetwork&amp; map);
 
 	static void LinkTrafficLightsAndStopLines(RoadNetwork&amp; map);
 
+	static void LinkTrafficLightsAndStopLinesV2(RoadNetwork&amp; map);
+
 	static void GetUniqueNextLanes(const Lane* l,  const std::vector&lt;Lane*&gt;&amp; traversed_lanes, std::vector&lt;Lane*&gt;&amp; lanes_list);
 
 	static GPSPoint GetTransformationOrigin(const int&amp; bToyotaCityMap = 0);
@@ -149,7 +145,7 @@ public:
 	static int GetLaneIdByWaypointId(const int&amp; id,std::vector&lt;Lane&gt;&amp; lanes);
 
 	static WayPoint* FindWaypoint(const int&amp; id, RoadNetwork&amp; map);
-
+	static WayPoint* FindWaypointV2(const int&amp; id, const int&amp; l_id, RoadNetwork&amp; map);
 
 	static std::vector&lt;Curb&gt; GetCurbsList(TiXmlElement* pElem);
 	static std::vector&lt;Boundary&gt; GetBoundariesList(TiXmlElement* pElem);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlannerH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlannerH.h" added_lines="10" deleted_lines="64">
				<diff>@@ -1,16 +1,16 @@
-/*
- * PlannerH.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
 
-#include "RSPlanner.h"
+/// \file PlannerH.h
+/// \brief Main functions for path generation (global and local)
+/// \author Hatem Darweesh
+/// \date Dec 14, 2016
+
 
 #define START_POINT_MAX_DISTANCE 8 // meters
 #define GOAL_POINT_MAX_DISTANCE 8 // meters
 #define LANE_CHANGE_SMOOTH_FACTOR_DISTANCE 8 // meters
 
+#include "RoadNetwork.h"
+
 namespace PlannerHNS
 {
 
@@ -21,40 +21,8 @@ class PlannerH
 {
 public:
 	PlannerH();
-	virtual ~PlannerH(); 
-
-	/**
-	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles , but if there an obstacle on the trajectory function will fail. , also this function does not guaranteed to generate trajectories
-	 * @param start: Start position for the trajectory (x,y,theta)
-	 * @param goal:  Goal position (Destination point) (x,y,theta)
-	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
-	 * @return path length
-	 */
-	double PlanUsingReedShepp(const WayPoint&amp; start, const WayPoint&amp; goal, std::vector&lt;WayPoint&gt;&amp; generatedPath,
-			const double pathDensity = 0.25, const double smoothFactor = 12.0);
-
-
-	/**
-	 * @brief Generate Roll outs for global generated path
-	 * @param referencePath center lint reference path
-	 * @param carPos current car position
-	 * @param bEnableLaneChange is lane change is available
-	 * @param speed current car speed
-	 * @param microPlanDistance distance limit for roll outs
-	 * @param maxSpeed maximum forward speed
-	 * @param minSpeed minimum forward speed
-	 * @param carTipMargin 1st roll out smoothing parameter
-	 * @param rollInMargin 2nd roll out smoothing parameter
-	 * @param rollInSpeedFactor roll out 3rd smoothing parameter
-	 * @param pathDensity distance between every two waypoints in the generated trajectory
-	 * @param rollOutDensity distance between the center line and adjacent trajectories
-	 * @param rollOutNumber number of sampled trajectories
-	 * @param SmoothDataWeight general smoothing parameter , how smoother keep close to original data 0 - 0.5
-	 * @param SmoothWeight general smoothing parameter, how smoother is trying to pull away to form the shortest and strait line possible
-	 * @param SmoothTolerance performance measure , conjugate gradient conversion factor should be 0.1 - 0.01
-	 * @param speedProfileFactor how car should slow for corners
-	 * @param bHeadingSmooth follow car heading direction or center line path heading for sampling direction
-	 */
+	virtual ~PlannerH();
+
 	void GenerateRunoffTrajectory(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; referencePaths, const WayPoint&amp; carPos, const bool&amp; bEnableLaneChange, const double&amp; speed, const double&amp; microPlanDistance,
 				const double&amp; maxSpeed,const double&amp; minSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
 				const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
@@ -64,17 +32,6 @@ public:
 				std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOutsPaths,
 				std::vector&lt;WayPoint&gt;&amp; sampledPoints);
 
-	/**
-	 * @brief Path planning for structured environment using dynamic programming
-	 * @param lane
-	 * @param carPos
-	 * @param goalPos
-	 * @param prevWayPoint
-	 * @param maxPlanningDistance
-	 * @param globalPath
-	 * @param path
-	 * @return generated path length
-	 */
 	double PlanUsingDP(const WayPoint&amp; carPos,const WayPoint&amp; goalPos,
 			const double&amp; maxPlanningDistance, const bool bEnableLaneChange, const std::vector&lt;int&gt;&amp; globalPath,
 			RoadNetwork&amp; map, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, std::vector&lt;WayPoint*&gt;* all_cell_to_delete = 0);
@@ -84,25 +41,14 @@ public:
 	 		 RoadNetwork&amp; map,
 	 		 std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
 
-
-	/**
-	 * @brief Return all possible trajectories from current position to max planning distance in all directions
-	 * @param lane
-	 * @param carPos
-	 * @param maxPlanningDistance
-	 * @param paths
-	 * @return
-	 */
 	double PredictPlanUsingDP(Lane* lane, const WayPoint&amp; carPos, const double&amp; maxPlanningDistance,
 			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
 
 	double PredictPlanUsingDP(const WayPoint&amp; startPose, WayPoint* closestWP, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, const bool&amp; bFindBranches = true);
 
-	double PredictTrajectoriesUsingDP(const WayPoint&amp; startPose, std::vector&lt;WayPoint*&gt; closestWPs, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, const bool&amp; bFindBranches = true, const bool bDirectionBased = false);
+	double PredictTrajectoriesUsingDP(const WayPoint&amp; startPose, std::vector&lt;WayPoint*&gt; closestWPs, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, const bool&amp; bFindBranches = true, const bool bDirectionBased = false, const bool pathDensity = 1.0);
 
 	void DeleteWaypoints(std::vector&lt;WayPoint*&gt;&amp; wps);
-
-	//PlanningInternalParams m_Params;
 };
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlanningHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlanningHelpers.h" added_lines="1" deleted_lines="0">
				<diff>@@ -24,6 +24,7 @@ namespace PlannerHNS {
 #define LANE_CHANGE_SPEED_FACTOR 0.5
 #define LANE_CHANGE_COST 3.0 // meters
 #define BACKUP_STRAIGHT_PLAN_DISTANCE 75 //meters
+#define LANE_CHANGE_MIN_DISTANCE 5
 
 class PlanningHelpers
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\RSPlanner.h" new_path="" added_lines="0" deleted_lines="77">
				<diff>@@ -1,77 +0,0 @@
-/*
- * RSPlanner.h
- *
- *  Created on: Aug 9, 2015
- *      Author: hatem
- */
-
-#include "PlanningHelpers.h"
-#ifndef RSPLANNERSA_H_
-#define RSPLANNERSA_H_
-
-namespace PlannerHNS
-{
-
-#define EPS1 1.0e-12
-#define EPS2 1.0e-12
-#define EPS3 1.0e-12
-#define EPS4 1.0e-12
-#define MYINFINITY 1000000
-
-#define MPI 3.1415926536
-#define MPIMUL2 6.2831853072
-#define MPIDIV2 1.5707963268
-
-
-
-
-class RSPlanner
-{
-public:
-	double RADCURV ;
-	double RADCURVMUL2 ;
-	double RADCURVMUL4 ;
-	double SQRADCURV ;
-	double SQRADCURVMUL2 ;
-	double PATHDENSITY;
-	RSPlanner(double curvatureFactor = 15.6);
-	virtual ~RSPlanner();
-
-	double min_length_rs(const double&amp; x1,const double&amp; y1,const double&amp; t1,const double&amp; x2,const double&amp; y2,const double&amp; t2,int&amp; numero,double&amp; t,double&amp; u,double&amp; v);
-	int constRS(int num,double t,double u,double v,double x1,double y1,double t1,double delta,std::vector&lt;WayPoint&gt;&amp; path);
-
-private:
-	struct ConfigItem
-	{
-		double length;
-		int num;
-		double t,u,v;
-	};
-
-
-	double mod2pi(const double&amp; a);
-	double my_atan2(const double&amp;  y, const double&amp; x);
-	double c_c_c(const double&amp; x,const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_cc(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double cscb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double ccu_cuc(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_cucu_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2sca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2scb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2sc2_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double cc_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csc2_ca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csc2_cb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-
-	double reed_shepp(const double&amp; x1,const double&amp; y1,const double&amp; t1,const double&amp; x2,const double&amp; y2,const double&amp; t2,int&amp; numero,double&amp; tr,double&amp; ur,double&amp; vr);
-
-	int fct_curve(const int&amp; ty,const int&amp; orientation,const double&amp; val,double&amp; x1,double&amp; y1,double&amp; t1,const double&amp; delta,std::vector&lt;WayPoint&gt;&amp; path,int n);
-
-
-
-};
-
-} /* namespace PlannerZNS */
-
-#endif /* RSPLANNER_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\RoadNetwork.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\RoadNetwork.h" added_lines="14" deleted_lines="8">
				<diff>@@ -349,8 +349,6 @@ public:
 
 };
 
-
-
 class Rotation
 {
 public:
@@ -381,8 +379,10 @@ public:
 	double 		laneChangeCost;
 	int 		laneId;
 	int 		id;
-	int 		LeftLaneId;
-	int 		RightLaneId;
+	int 		LeftPointId;
+	int 		RightPointId;
+	int 		LeftLnId;
+	int 		RightLnId;
 	int 		stopLineID;
 	DIRECTION_TYPE bDir;
 	STATE_TYPE	state;
@@ -411,8 +411,10 @@ public:
 		pLeft = 0;
 		pRight = 0;
 		bDir = FORWARD_DIR;
-		LeftLaneId = 0;
-		RightLaneId = 0;
+		LeftPointId = 0;
+		RightPointId = 0;
+		LeftLnId = 0;
+		RightLnId = 0;
 		timeCost = 0;
 		totalReward = 0;
 		collisionCost = 0;
@@ -441,8 +443,10 @@ public:
 		pLeft = 0;
 		pRight = 0;
 		bDir = FORWARD_DIR;
-		LeftLaneId = 0;
-		RightLaneId = 0;
+		LeftPointId = 0;
+		RightPointId = 0;
+		LeftLnId = 0;
+		RightLnId = 0;
 		timeCost = 0;
 		totalReward = 0;
 		collisionCost = 0;
@@ -928,6 +932,8 @@ public:
 		smoothingSmoothWeight			= 0.2;
 		smoothingToleranceError			= 0.05;
 
+		stopSignStopTime 				= 2.0;
+
 		additionalBrakingDistance		= 10.0;
 		verticalSafetyDistance 			= 0.0;
 		horizontalSafetyDistancel		= 0.0;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\TrajectoryCosts.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\TrajectoryCosts.h" added_lines="6" deleted_lines="8">
				<diff>@@ -1,9 +1,9 @@
-/*
- * TrajectoryCosts.h
- *
- *  Created on: Dec 14, 2016
- *      Author: user
- */
+
+/// \file TrajectoryCosts.h
+/// \brief Calculate collision costs for roll out trajectory for free trajectory evaluation for dp_planner
+/// \author Hatem Darweesh
+/// \date Dec 14, 2016
+
 
 #ifndef TRAJECTORYCOSTS_H_
 #define TRAJECTORYCOSTS_H_
@@ -49,8 +49,6 @@ private:
 	void NormalizeCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts);
 	void CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths, const WayPoint&amp; currState, const vector&lt;WayPoint&gt;&amp; contourPoints, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState);
 	void CalculateTransitionCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const int&amp; currTrajectoryIndex, const PlanningParams&amp; params);
-	bool CalculateIntersectionVelocities(const std::vector&lt;WayPoint&gt;&amp; path, const DetectedObject&amp; obj, const WayPoint&amp; currState,const CAR_BASIC_INFO&amp; carInfo, WayPoint&amp; collisionPoint);
-
 };
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\TrajectoryPrediction.h" new_path="" added_lines="0" deleted_lines="34">
				<diff>@@ -1,34 +0,0 @@
-/*
- * TrajectoryPrediction.h
- *
- *  Created on: Aug 8, 2017
- *      Author: user
- */
-
-#ifndef TRAJECTORYPREDICTION_H_
-#define TRAJECTORYPREDICTION_H_
-
-#include &lt;op_planner/RoadNetwork.h&gt;
-#include "PlannerCommonDef.h"
-#include "PlanningHelpers.h"
-
-namespace PlannerHNS
-{
-
-class TrajectoryPrediction
-{
-public:
-	TrajectoryPrediction();
-	virtual ~TrajectoryPrediction();
-
-	void DoOneStep(PlannerHNS::RoadNetwork&amp; map, const PlannerHNS::VehicleState&amp; vstatus, const PlannerHNS::WayPoint&amp; currState, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; currPath, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list, const double&amp; minfDist);
-	double PredictTimeCostForTrajectory(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::VehicleState&amp; vstatus, const PlannerHNS::WayPoint&amp; currState,const double&amp; minfDist);
-	void PredictObstacleTrajectory(PlannerHNS::RoadNetwork&amp; map, const DetectedObject&amp; obj, const double&amp; predTime, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths,const double&amp; minfDist);
-public:
-	double m_MaxCollisionPredictionTime;
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* TRAJECTORYPREDICTION_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\BehaviorStateMachine.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\BehaviorStateMachine.cpp" added_lines="222" deleted_lines="12">
				<diff>@@ -1,9 +1,8 @@
-/*
- * BehaviorStateMachine.cpp
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
+
+/// \file BehaviorStateMachine.cpp
+/// \author Hatem Darweesh
+/// \brief OpenPlanner's state machine implementation for different driving behaviors
+/// \date Jun 19, 2016
 
 #include "op_planner/BehaviorStateMachine.h"
 #include "op_utility/UtilityH.h"
@@ -12,10 +11,8 @@
 using namespace UtilityHNS;
 
 
-namespace PlannerHNS {
-
-//PreCalculatedConditions* BehaviorStateMachine::m_pCalculatedValues = 0;
-//PlanningParams BehaviorStateMachine::m_PlanningParams;
+namespace PlannerHNS
+{
 
 BehaviorStateMachine::BehaviorStateMachine(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* nextState)
 {
@@ -24,7 +21,8 @@ BehaviorStateMachine::BehaviorStateMachine(PlanningParams* pParams, PreCalculate
 	m_currentStopSignID		= -1;
 	m_currentTrafficLightID	= -1;
 	decisionMakingTime		= 0.0;
-	m_zero_velocity 		= 0.2;
+	decisionMakingCount		= 1;
+	m_zero_velocity 		= 0.1;
 
 	if(!pPreCalcVal)
 		m_pCalculatedValues = new PreCalculatedConditions();
@@ -50,6 +48,41 @@ void BehaviorStateMachine::InsertNextState(BehaviorStateMachine* nextState)
 		pNextStates.push_back(nextState);
 }
 
+void BehaviorStateMachine::UpdateLogCount(BehaviorStateMachine* pState)
+{
+	if(!pState) return;
+
+	bool bFound = false;
+	for(unsigned int i = 0; i &lt; m_BehaviorsLog.size(); i++)
+	{
+		if(m_BehaviorsLog.at(i).first-&gt;m_Behavior == pState-&gt;m_Behavior)
+		{
+			m_BehaviorsLog.at(i).second++;
+			bFound = true;
+			break;
+		}
+	}
+
+	if(!bFound)
+	{
+		m_BehaviorsLog.push_back(std::make_pair(pState, 1));
+	}
+}
+
+BehaviorStateMachine* BehaviorStateMachine::FindBestState(int nMinCount)
+{
+	for(unsigned int i = 0; i &lt; m_BehaviorsLog.size(); i++)
+	{
+		if(m_BehaviorsLog.at(i).second &gt;= nMinCount)
+		{
+			//std::cout &lt;&lt; "Found Next Beh: " &lt;&lt; m_BehaviorsLog.at(i).first-&gt;m_Behavior &lt;&lt; ", Count: " &lt;&lt; m_BehaviorsLog.at(i).second  &lt;&lt; ", LogSize: " &lt;&lt; m_BehaviorsLog.size() &lt;&lt; std::endl;
+			return m_BehaviorsLog.at(i).first;
+		}
+	}
+
+	return nullptr;
+}
+
 BehaviorStateMachine* BehaviorStateMachine::FindBehaviorState(const STATE_TYPE&amp; behavior)
 {
 	for(unsigned int i = 0 ; i &lt; pNextStates.size(); i++)
@@ -57,12 +90,18 @@ BehaviorStateMachine* BehaviorStateMachine::FindBehaviorState(const STATE_TYPE&amp;
 		BehaviorStateMachine* pState = pNextStates.at(i);
 		if(pState &amp;&amp; behavior == pState-&gt;m_Behavior )
 		{
+			//UpdateLogCount(pState);
+			//pState = FindBestState(decisionMakingCount);
+
+			if(pState == 0) return this;
+
+			m_BehaviorsLog.clear();
 			pState-&gt;ResetTimer();
 			return pState;
 		}
 	}
 
-	return 0;
+	return nullptr;
 }
 
 void BehaviorStateMachine::Init()
@@ -305,4 +344,175 @@ BehaviorStateMachine* GoalState::GetNextState()
 		return FindBehaviorState(this-&gt;m_Behavior); // return and reset
 }
 
+BehaviorStateMachine* ForwardStateII::GetNextState()
+{
+	PreCalculatedConditions* pCParams = GetCalcParams();
+
+	if(pCParams-&gt;currentGoalID != pCParams-&gt;prevGoalID)
+		return FindBehaviorState(GOAL_STATE);
+
+	else if(m_pParams-&gt;enableTrafficLightBehavior
+				&amp;&amp; pCParams-&gt;currentTrafficLightID &gt; 0
+				&amp;&amp; pCParams-&gt;bTrafficIsRed
+				&amp;&amp; pCParams-&gt;currentTrafficLightID != pCParams-&gt;prevTrafficLightID)
+			return FindBehaviorState(TRAFFIC_LIGHT_STOP_STATE);
+
+	else if(m_pParams-&gt;enableStopSignBehavior
+			&amp;&amp; pCParams-&gt;currentStopSignID &gt; 0
+			&amp;&amp; pCParams-&gt;currentStopSignID != pCParams-&gt;prevStopSignID)
+		return FindBehaviorState(STOP_SIGN_STOP_STATE);
+
+	else if(m_pParams-&gt;enableFollowing &amp;&amp; pCParams-&gt;bFullyBlock)
+		return FindBehaviorState(FOLLOW_STATE);
+
+	else if(m_pParams-&gt;enableSwerving
+			&amp;&amp; pCParams-&gt;distanceToNext &lt;= m_pParams-&gt;minDistanceToAvoid
+			&amp;&amp; !pCParams-&gt;bFullyBlock
+			&amp;&amp; pCParams-&gt;iCurrSafeTrajectory != pCParams-&gt;iPrevSafeTrajectory)
+		return FindBehaviorState(OBSTACLE_AVOIDANCE_STATE);
+
+	else
+		return FindBehaviorState(this-&gt;m_Behavior);
+}
+
+BehaviorStateMachine* FollowStateII::GetNextState()
+{
+	PreCalculatedConditions* pCParams = GetCalcParams();
+
+	if(pCParams-&gt;currentGoalID != pCParams-&gt;prevGoalID)
+		return FindBehaviorState(GOAL_STATE);
+
+	else if(m_pParams-&gt;enableTrafficLightBehavior
+				&amp;&amp; pCParams-&gt;currentTrafficLightID &gt; 0
+				&amp;&amp; pCParams-&gt;bTrafficIsRed
+				&amp;&amp; pCParams-&gt;currentTrafficLightID != pCParams-&gt;prevTrafficLightID)
+			return FindBehaviorState(TRAFFIC_LIGHT_STOP_STATE);
+
+	else if(m_pParams-&gt;enableStopSignBehavior
+			&amp;&amp; pCParams-&gt;currentStopSignID &gt; 0
+			&amp;&amp; pCParams-&gt;currentStopSignID != pCParams-&gt;prevStopSignID)
+		return FindBehaviorState(STOP_SIGN_STOP_STATE);
+
+	else if(m_pParams-&gt;enableSwerving
+			&amp;&amp; pCParams-&gt;distanceToNext &lt;= m_pParams-&gt;minDistanceToAvoid
+			&amp;&amp; !pCParams-&gt;bFullyBlock
+			&amp;&amp; pCParams-&gt;iCurrSafeTrajectory != pCParams-&gt;iPrevSafeTrajectory)
+		return FindBehaviorState(OBSTACLE_AVOIDANCE_STATE);
+
+	else if(!pCParams-&gt;bFullyBlock)
+		return FindBehaviorState(FORWARD_STATE);
+
+	else
+		return FindBehaviorState(this-&gt;m_Behavior); // return and reset
+}
+
+BehaviorStateMachine* SwerveStateII::GetNextState()
+{
+	PreCalculatedConditions* pCParams = GetCalcParams();
+
+	pCParams-&gt;iPrevSafeTrajectory = pCParams-&gt;iCurrSafeTrajectory;
+	pCParams-&gt;bRePlan = true;
+
+	return FindBehaviorState(FORWARD_STATE);
+}
+
+BehaviorStateMachine* InitStateII::GetNextState()
+{
+	PreCalculatedConditions* pCParams = GetCalcParams();
+
+	if(pCParams-&gt;currentGoalID &gt; 0)
+		return FindBehaviorState(FORWARD_STATE);
+	else
+		return FindBehaviorState(this-&gt;m_Behavior);
+}
+
+BehaviorStateMachine* GoalStateII::GetNextState()
+{
+	PreCalculatedConditions* pCParams = GetCalcParams();
+
+	if(pCParams-&gt;currentGoalID == -1)
+		return FindBehaviorState(FINISH_STATE);
+
+	else
+	{
+		pCParams-&gt;prevGoalID = pCParams-&gt;currentGoalID;
+		return FindBehaviorState(FORWARD_STATE);
+	}
+}
+
+BehaviorStateMachine* MissionAccomplishedStateII::GetNextState()
+{
+	return FindBehaviorState(this-&gt;m_Behavior);
+}
+
+BehaviorStateMachine* StopSignStopStateII::GetNextState()
+{
+	PreCalculatedConditions* pCParams = GetCalcParams();
+
+	if(pCParams-&gt;currentGoalID != pCParams-&gt;prevGoalID)
+		return FindBehaviorState(GOAL_STATE);
+
+	else if(pCParams-&gt;currentVelocity &lt; m_zero_velocity)
+		return FindBehaviorState(STOP_SIGN_WAIT_STATE);
+
+	else
+		return FindBehaviorState(this-&gt;m_Behavior); // return and reset
+}
+
+BehaviorStateMachine* StopSignWaitStateII::GetNextState()
+{
+	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
+		return this;
+
+	PreCalculatedConditions* pCParams = GetCalcParams();
+
+	pCParams-&gt;prevStopSignID = pCParams-&gt;currentStopSignID;
+
+	return FindBehaviorState(FORWARD_STATE);
+}
+
+BehaviorStateMachine* TrafficLightStopStateII::GetNextState()
+{
+	PreCalculatedConditions* pCParams = GetCalcParams();
+
+	//std::cout &lt;&lt; "Stopping for trafficLight "  &lt;&lt; std::endl;
+	if(!pCParams-&gt;bTrafficIsRed)
+	{
+		//std::cout &lt;&lt; "Color Changed Stopping for trafficLight "  &lt;&lt; std::endl;
+		pCParams-&gt;prevTrafficLightID = pCParams-&gt;currentTrafficLightID;
+		return FindBehaviorState(FORWARD_STATE);
+	}
+
+	else if(pCParams-&gt;bTrafficIsRed &amp;&amp; pCParams-&gt;currentVelocity &lt;= m_zero_velocity)
+	{
+		//std::cout &lt;&lt; "Velocity Changed Stopping for trafficLight ("  &lt;&lt;pCParams-&gt;currentVelocity &lt;&lt; ", " &lt;&lt; m_zero_velocity &lt;&lt; ")" &lt;&lt;  std::endl;
+		return FindBehaviorState(TRAFFIC_LIGHT_WAIT_STATE);
+	}
+
+	else
+	{
+		return FindBehaviorState(this-&gt;m_Behavior); // return and reset
+	}
+}
+
+BehaviorStateMachine* TrafficLightWaitStateII::GetNextState()
+{
+	PreCalculatedConditions* pCParams = GetCalcParams();
+
+	//std::cout &lt;&lt; "Wait for trafficLight "  &lt;&lt; std::endl;
+
+	if(!pCParams-&gt;bTrafficIsRed)
+	{
+		pCParams-&gt;prevTrafficLightID = pCParams-&gt;currentTrafficLightID;
+		return FindBehaviorState(FORWARD_STATE);
+	}
+
+//	else if(pCParams-&gt;currentVelocity &gt; m_zero_velocity)
+//		return FindBehaviorState(TRAFFIC_LIGHT_STOP_STATE);
+
+	else
+		return FindBehaviorState(this-&gt;m_Behavior); // return and reset
+
+}
+
 } /* namespace PlannerHNS */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\LocalPlannerH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\LocalPlannerH.cpp" added_lines="16" deleted_lines="30">
				<diff>@@ -1,9 +1,7 @@
-/*
- * CarState.cpp
- *
- *  Created on: Jun 20, 2016
- *      Author: hatem
- */
+/// \file LocalPlannerH.cpp
+/// \brief OpenPlanner's local planing functions combines in one process, used in simulation vehicle and OpenPlanner old implementation like dp_planner node.
+/// \author Hatem Darweesh
+/// \date Dec 14, 2016
 
 #include "op_planner/LocalPlannerH.h"
 #include "op_utility/UtilityH.h"
@@ -267,7 +265,6 @@ void LocalPlannerH::ReInitializePlanner(const WayPoint&amp; start_pose)
 		 double d = hypot(trafficLights.at(i).pos.y - state.pos.y, trafficLights.at(i).pos.x - state.pos.x);
 		 if(d &lt;= trafficLights.at(i).stoppingDistance)
 		 {
-			 //double a = UtilityH::FixNegativeAngle(atan2(trafficLights.at(i).pos.y - state.pos.y, trafficLights.at(i).pos.x - state.pos.x));
 			 double a_diff = UtilityH::AngleBetweenTwoAnglesPositive(UtilityH::FixNegativeAngle(trafficLights.at(i).pos.a) , UtilityH::FixNegativeAngle(state.pos.a));
 
 			 if(a_diff &lt; M_PI_2 &amp;&amp; trafficLights.at(i).id != prevTrafficLightId)
@@ -289,7 +286,6 @@ void LocalPlannerH::ReInitializePlanner(const WayPoint&amp; start_pose)
  	PreCalculatedConditions* pValues = m_pCurrentBehaviorState-&gt;GetCalcParams();
 
  	double critical_long_front_distance =  m_CarInfo.wheel_base/2.0 + m_CarInfo.length/2.0 + m_params.verticalSafetyDistance;
-	//double critical_long_back_distance =  m_CarInfo.length/2.0 + m_params.verticalSafetyDistance - m_CarInfo.wheel_base/2.0;
 
  	pValues-&gt;minStoppingDistance = -pow(car_state.speed, 2)/(m_CarInfo.max_deceleration);
 
@@ -305,7 +301,6 @@ void LocalPlannerH::ReInitializePlanner(const WayPoint&amp; start_pose)
  	pValues-&gt;currentVelocity 		= car_state.speed;
  	pValues-&gt;bTrafficIsRed 			= false;
  	pValues-&gt;currentTrafficLightID 	= -1;
-// 	pValues-&gt;currentStopSignID		= -1;
  	pValues-&gt;bRePlan 				= false;
  	pValues-&gt;bFullyBlock 			= false;
 
@@ -338,12 +333,6 @@ void LocalPlannerH::ReInitializePlanner(const WayPoint&amp; start_pose)
  	m_iSafeTrajectory = pValues-&gt;iCurrSafeTrajectory;
  	m_iCurrentTotalPathId = pValues-&gt;iCurrSafeLane;
 
-
-// 	if(bestTrajectory.index == -1 &amp;&amp; pValues-&gt;distanceToNext &lt; m_pCurrentBehaviorState-&gt;m_pParams-&gt;minFollowingDistance)
-// 		pValues-&gt;bFullyBlock = true;
-
-
-
  	int stopLineID = -1;
  	int stopSignID = -1;
  	int trafficLightID = -1;
@@ -501,22 +490,26 @@ void LocalPlannerH::ReInitializePlanner(const WayPoint&amp; start_pose)
 	PlannerHNS::PreCalculatedConditions *preCalcPrams = m_pCurrentBehaviorState-&gt;GetCalcParams();
 
 	m_pCurrentBehaviorState = m_pCurrentBehaviorState-&gt;GetNextState();
+	if(m_pCurrentBehaviorState==0)
+		m_pCurrentBehaviorState = m_pInitState;
+
 	PlannerHNS::BehaviorState currentBehavior;
 
 	currentBehavior.state = m_pCurrentBehaviorState-&gt;m_Behavior;
 	currentBehavior.followDistance = preCalcPrams-&gt;distanceToNext;
 
-	if(preCalcPrams-&gt;bUpcomingRight)
-		currentBehavior.indicator = PlannerHNS::INDICATOR_RIGHT;
-	else if(preCalcPrams-&gt;bUpcomingLeft)
-		currentBehavior.indicator = PlannerHNS::INDICATOR_LEFT;
-	else
-		currentBehavior.indicator = PlannerHNS::INDICATOR_NONE;
 
 	currentBehavior.minVelocity		= 0;
 	currentBehavior.stopDistance 	= preCalcPrams-&gt;distanceToStop();
 	currentBehavior.followVelocity 	= preCalcPrams-&gt;velocityOfNext;
 
+	double average_braking_distance = -pow(vehicleState.speed, 2)/(m_CarInfo.max_deceleration) + m_params.additionalBrakingDistance;
+
+	if(average_braking_distance  &lt; 15)
+		average_braking_distance = 15;
+
+	currentBehavior.indicator = PlanningHelpers::GetIndicatorsFromPath(m_Path, state, average_braking_distance );
+
 	return currentBehavior;
  }
 
@@ -762,6 +755,7 @@ void LocalPlannerH::ReInitializePlanner(const WayPoint&amp; start_pose)
 		const std::vector&lt;TrafficLight&gt;&amp; trafficLight,
 		const bool&amp; bLive)
 {
+	 PlannerHNS::BehaviorState beh;
 
 	 m_params.minFollowingDistance = m_InitialFollowingDistance + vehicleState.speed*1.5;
 
@@ -775,7 +769,6 @@ void LocalPlannerH::ReInitializePlanner(const WayPoint&amp; start_pose)
 
 
 	m_PredictedTrajectoryObstacles = obj_list;
-	//m_TrajectoryPredictionForMovingObstacles.DoOneStep(map, vehicleState, state, m_TotalPath.at(m_iCurrentTotalPathId), m_PredictedTrajectoryObstacles, m_params.minFollowingDistance);
 
 	timespec t;
 	UtilityH::GetTickCount(t);
@@ -785,22 +778,15 @@ void LocalPlannerH::ReInitializePlanner(const WayPoint&amp; start_pose)
 	m_CostCalculationTime = UtilityH::GetTimeDiffNow(t);
 
 
-
-
 	UtilityH::GetTickCount(t);
 	CalculateImportantParameterForDecisionMaking(vehicleState, goalID, bEmergencyStop, trafficLight, tc);
 
-
-
-	PlannerHNS::BehaviorState beh = GenerateBehaviorState(vehicleState);
+	beh = GenerateBehaviorState(vehicleState);
 	m_BehaviorGenTime = UtilityH::GetTimeDiffNow(t);
 
-
 	UtilityH::GetTickCount(t);
 	beh.bNewPlan = SelectSafeTrajectoryAndSpeedProfile(vehicleState);
 
-
-
 	m_RollOutsGenerationTime = UtilityH::GetTimeDiffNow(t);
 
 	beh.maxVelocity = UpdateVelocityDirectlyToTrajectory(beh, vehicleState, dt);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" added_lines="393" deleted_lines="242">
				<diff>@@ -20,6 +20,8 @@ using namespace std;
 #define RIGHT_INITIAL_TURNS_COST 0
 #define LEFT_INITIAL_TURNS_COST 0
 #define DEBUG_MAP_PARSING 0
+#define MAP_PERF_ENABLE_CURB_AND_WAYAREA
+#define DEFAULT_REF_VELOCITY 60 //km/h
 
 namespace PlannerHNS
 {
@@ -426,6 +428,7 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 	}
 
 #ifdef FIND_LEFT_RIGHT_LANES
+	cout &lt;&lt; " &gt;&gt; Extract Lane Change Information... " &lt;&lt; endl;
 	FindAdjacentLanes(map);
 #endif
 
@@ -445,11 +448,13 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 	LinkTrafficLightsAndStopLines(map);
 	//LinkTrafficLightsAndStopLinesConData(conn_data, id_replace_list, map);
 
+#ifdef MAP_PERF_ENABLE_CURB_AND_WAYAREA
 	//Curbs
 	ExtractCurbData(curb_data, line_data, points_data, origin, map);
 
 	//Wayarea
 	ExtractWayArea(area_data, wayarea_data, line_data, points_data, origin, map);
+#endif
 
 	//Fix angle for lanes
 	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
@@ -490,6 +495,27 @@ WayPoint* MappingHelpers::FindWaypoint(const int&amp; id, RoadNetwork&amp; map)
 	return nullptr;
 }
 
+WayPoint* MappingHelpers::FindWaypointV2(const int&amp; id, const int&amp; l_id, RoadNetwork&amp; map)
+{
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			Lane* pLane = &amp;map.roadSegments.at(rs).Lanes.at(i);
+			if(pLane -&gt;id != l_id)
+			{
+				for(unsigned int p= 0; p &lt; pLane-&gt;points.size(); p++)
+				{
+					if(pLane-&gt;points.at(p).id == id)
+						return &amp;pLane-&gt;points.at(p);
+				}
+			}
+		}
+	}
+
+	return nullptr;
+}
+
 void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMapPath, RoadNetwork&amp; map, const bool&amp; bZeroOrigin)
 {
 	/**
@@ -509,8 +535,6 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 	string wayarea_info = vectoMapPath + "wayarea.csv";
 	string crosswalk_info = vectoMapPath + "crosswalk.csv";
 	string conn_info = vectoMapPath + "dataconnection.csv";
-
-
 	string intersection_info = vectoMapPath + "intersection.csv";
 
 	cout &lt;&lt; " &gt;&gt; Loading vector map data files ... " &lt;&lt; endl;
@@ -530,109 +554,67 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 	AisanCrossWalkFileReader cross_walk(crosswalk_info);
 
 
+	vector&lt;AisanIntersectionFileReader::AisanIntersection&gt; intersection_data;
 	vector&lt;AisanNodesFileReader::AisanNode&gt; nodes_data;
-	nodes.ReadAllData(nodes_data);
-
 	vector&lt;AisanLanesFileReader::AisanLane&gt; lanes_data;
-	lanes.ReadAllData(lanes_data);
-
 	vector&lt;AisanPointsFileReader::AisanPoints&gt; points_data;
-	points.ReadAllData(points_data);
-
 	vector&lt;AisanCenterLinesFileReader::AisanCenterLine&gt; dt_data;
-	center_lanes.ReadAllData(dt_data);
-
-	vector&lt;AisanIntersectionFileReader::AisanIntersection&gt; intersection_data;
 	vector&lt;AisanLinesFileReader::AisanLine&gt; line_data;
-	lines.ReadAllData(line_data);
 	vector&lt;AisanStopLineFileReader::AisanStopLine&gt; stop_line_data;
-	stop_line.ReadAllData(stop_line_data);
 	vector&lt;AisanSignalFileReader::AisanSignal&gt; signal_data;
-	signal.ReadAllData(signal_data);
 	vector&lt;AisanVectorFileReader::AisanVector&gt; vector_data;
-	vec.ReadAllData(vector_data);
-
 	vector&lt;AisanCurbFileReader::AisanCurb&gt; curb_data;
-	curb.ReadAllData(curb_data);
-
 	vector&lt;AisanRoadEdgeFileReader::AisanRoadEdge&gt; roadedge_data;
-	roadedge.ReadAllData(roadedge_data);
 	vector&lt;AisanAreasFileReader::AisanArea&gt; area_data;
-	areas.ReadAllData(area_data);
 	vector&lt;AisanWayareaFileReader::AisanWayarea&gt; way_area_data;
-	way_area.ReadAllData(way_area_data);
 	vector&lt;AisanCrossWalkFileReader::AisanCrossWalk&gt; crosswalk_data;
-	cross_walk.ReadAllData(crosswalk_data);
 	vector&lt;AisanDataConnFileReader::DataConn&gt; conn_data;
-	conn.ReadAllData(conn_data);
 
 
+	nodes.ReadAllData(nodes_data);
+	lanes.ReadAllData(lanes_data);
+	points.ReadAllData(points_data);
+	center_lanes.ReadAllData(dt_data);
+	lines.ReadAllData(line_data);
+	stop_line.ReadAllData(stop_line_data);
+	signal.ReadAllData(signal_data);
+	vec.ReadAllData(vector_data);
+	curb.ReadAllData(curb_data);
+	roadedge.ReadAllData(roadedge_data);
+	areas.ReadAllData(area_data);
+	way_area.ReadAllData(way_area_data);
+	cross_walk.ReadAllData(crosswalk_data);
+	conn.ReadAllData(conn_data);
+
 	if(points_data.size() == 0)
 	{
 		std::cout &lt;&lt; std::endl &lt;&lt; "## Alert Can't Read Points Data from vector map files in path: " &lt;&lt; vectoMapPath &lt;&lt; std::endl;
 		return;
 	}
 
-	//Traffic Light Type from the file
-	// 4 , 5 -&gt; pedestrian crossing light
-	// 1 Red , 2 Green, 3 Yellow -&gt; traffic light that is important for cars (normal traffic lights )
-
-
-	int bToyotaCityMap = 0;
-	if((vectoMapPath.find("toyota") &gt;= 0 || vectoMapPath.find("Toyota") &gt;= 0) &amp;&amp; !bZeroOrigin)
-		bToyotaCityMap = 1;
-	else if((vectoMapPath.find("moriyama") &gt;= 0 || vectoMapPath.find("Moriyama") &gt;= 0) &amp;&amp; ! bZeroOrigin)
-		bToyotaCityMap = 2;
+	//Special Condtion to be able to pars old data structures
+	int bSpecialMap = 0;
 
 	// use this to transform data to origin (0,0,0)
-	if(nodes_data.size() &gt; 0)
+	if(nodes_data.size() &gt; 0 &amp;&amp; bSpecialMap == 0)
 	{
 		ConstructRoadNetworkFromRosMessageV2(lanes_data, points_data, dt_data, intersection_data, area_data,
 				line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data,
 				way_area_data, crosswalk_data, nodes_data, conn_data, &amp;lanes, &amp;points, &amp;nodes, &amp;lines,
-				GetTransformationOrigin(bToyotaCityMap), map, bToyotaCityMap == 1);
+				GetTransformationOrigin(0), map, false);
 	}
 	else
 	{
 		ConstructRoadNetworkFromRosMessage(lanes_data, points_data, dt_data, intersection_data, area_data,
 						line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data,
 						way_area_data, crosswalk_data, nodes_data, conn_data,
-						GetTransformationOrigin(bToyotaCityMap), map, bToyotaCityMap == 1);
+						GetTransformationOrigin(0), map, bSpecialMap == 1);
 	}
 
-	//use this when using the same coordinates as the map
-//	ConstructRoadNetworkFromRosMessage(lanes_data, points_data, dt_data, intersection_data, area_data, GPSPoint(), map);
-
-
-
 	WayPoint origin = GetFirstWaypoint(map);
-//	WayPoint origin2 = GetFirstWaypoint(map);
-//	WayPoint lastPoint2 = lastPoint;
-//
-//	llaToxyz(origin.pos, GPSPoint());
-//	llaToxyz(lastPoint.pos, GPSPoint());
-//
-//	double distance = distance2points(origin.pos, lastPoint.pos);
-//
 	cout &lt;&lt; origin.pos.ToString() ;
 }
 
-void MappingHelpers::GetWayPoint(const int&amp; pid, const vector&lt;AisanPointsFileReader::AisanPoints&gt;&amp; points, std::vector&lt;WayPoint&gt;&amp; path)
-{
-
-	for(unsigned int p =0; p &lt; points.size(); p++)
-	{
-		if(pid == points.at(p).PID)
-		{
-			WayPoint wp;
-			wp.laneId = points.at(p).PID;
-			wp.pos = GPSPoint(points.at(p).L, points.at(p).B, points.at(p).H, 0);
-			path.push_back(wp);
-			break;
-		}
-	}
-}
-
 bool MappingHelpers::GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; did,
 		const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dtpoints,
 		const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
@@ -670,7 +652,6 @@ bool MappingHelpers::GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp;
 					wp.pos.dir = dtpoints.at(dtp).Dir;
 					wp.iOriginalIndex = p;
 
-
 					way_point = wp;
 					return 1;
 				}
@@ -741,9 +722,6 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 	std::cout &lt;&lt; " &gt;&gt; Load Curbs from KML file .. " &lt;&lt; std::endl;
 	vector&lt;Curb&gt; curbs = GetCurbsList(pHeadElem);
 
-
-	std::cout &lt;&lt; " &gt;&gt; Linking data pointers ... " &lt;&lt; stopLines.size() &lt;&lt; std::endl;
-
 	map.signs.clear();
 	map.signs = signs;
 
@@ -807,6 +785,9 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 	}
 
 	//Link waypoints
+	cout &lt;&lt; " &gt;&gt; Link missing branches and waypoints... " &lt;&lt; endl;
+	LinkMissingBranchingWayPointsV2(map);
+
 	cout &lt;&lt; " &gt;&gt; Link Lane change semantics ... " &lt;&lt; endl;
 	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
 	{
@@ -815,26 +796,38 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 			for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
 			{
 				WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
-				for(unsigned int j = 0 ; j &lt; pWP-&gt;toIds.size(); j++)
+				if(pWP-&gt;pLeft == 0 &amp;&amp; pWP-&gt;LeftPointId &gt; 0)
 				{
-					pWP-&gt;pFronts.push_back(FindWaypoint(pWP-&gt;toIds.at(j), map));
-					if(pWP-&gt;LeftLaneId &gt; 0)
+					pWP-&gt;pLeft = FindWaypointV2(pWP-&gt;LeftPointId, pWP-&gt;laneId, map);
+
+					if(pWP-&gt;pLeft != nullptr)
 					{
-						pWP-&gt;pLeft = FindWaypoint(pWP-&gt;LeftLaneId, map);
-						if(pWP-&gt;pLeft)
+						pWP-&gt;LeftLnId = pWP-&gt;pLeft-&gt;laneId;
+						pWP-&gt;pLane-&gt;pLeftLane = pWP-&gt;pLeft-&gt;pLane;
+
+						if(pWP-&gt;pLeft-&gt;RightPointId == pWP-&gt;id)
 						{
-							pWP-&gt;LeftLaneId = pWP-&gt;pLeft-&gt;laneId;
-							pWP-&gt;pLane-&gt;pLeftLane = pWP-&gt;pLeft-&gt;pLane;
+							pWP-&gt;pLeft-&gt;pRight = pWP;
+							pWP-&gt;pLeft-&gt;RightLnId = pWP-&gt;laneId;
+							pWP-&gt;pLeft-&gt;pLane-&gt;pRightLane = pWP-&gt;pLane;
 						}
 					}
+				}
 
-					if(pWP-&gt;RightLaneId &gt; 0)
+				if(pWP-&gt;pRight == 0 &amp;&amp; pWP-&gt;RightPointId &gt; 0)
+				{
+					pWP-&gt;pRight = FindWaypointV2(pWP-&gt;RightPointId, pWP-&gt;laneId, map);
+
+					if(pWP-&gt;pRight != nullptr)
 					{
-						pWP-&gt;pRight = FindWaypoint(pWP-&gt;RightLaneId, map);
-						if(pWP-&gt;pRight)
+						pWP-&gt;RightLnId = pWP-&gt;pRight-&gt;laneId;
+						pWP-&gt;pLane-&gt;pRightLane = pWP-&gt;pRight-&gt;pLane;
+
+						if(pWP-&gt;pRight-&gt;LeftPointId == pWP-&gt;id)
 						{
-							pWP-&gt;RightLaneId = pWP-&gt;pRight-&gt;laneId;
-							pWP-&gt;pLane-&gt;pRightLane = pWP-&gt;pRight-&gt;pLane;
+							pWP-&gt;pRight-&gt;pLeft = pWP;
+							pWP-&gt;pRight-&gt;LeftLnId = pWP-&gt;laneId;
+							pWP-&gt;pRight-&gt;pLane-&gt;pLeftLane = pWP-&gt;pLane;
 						}
 					}
 				}
@@ -880,7 +873,6 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 
 }
 
-
 TiXmlElement* MappingHelpers::GetHeadElement(TiXmlElement* pMainElem)
 {
 	TiXmlElement* pElem = pMainElem;
@@ -1454,8 +1446,6 @@ std::vector&lt;StopLine&gt; MappingHelpers::GetStopLinesList(TiXmlElement* pElem)
 			StopLine sl;
 			sl.id = GetIDsFromPrefix(tfID, "SLID", "LnID").at(0);
 			sl.laneId = GetIDsFromPrefix(tfID, "LnID", "TSID").at(0);
-//			sl.stopSignID = GetIDsFromPrefix(tfID, "TSID", "TLTID").at(0);
-//			sl.trafficLightID = GetIDsFromPrefix(tfID, "TLTID", "").at(0);
 			sl.stopSignID = GetIDsFromPrefix(tfID, "TSID", "TLID").at(0);
 			sl.trafficLightID = GetIDsFromPrefix(tfID, "TLID", "").at(0);
 
@@ -1489,7 +1479,6 @@ std::vector&lt;TrafficLight&gt; MappingHelpers::GetTrafficLightsList(TiXmlElement* pEl
 		  tfID = pNameXml-&gt;GetText();
 
 			TrafficLight tl;
-			//tl.id = GetIDsFromPrefix(tfID, "SLID", "LnID").at(0);
 			tl.id = GetIDsFromPrefix(tfID, "TLID", "LnID").at(0);
 			tl.laneIds = GetIDsFromPrefix(tfID, "LnID", "");
 
@@ -1667,11 +1656,11 @@ vector&lt;WayPoint&gt; MappingHelpers::GetCenterLaneData(TiXmlElement* pElem, const in
 
 				vector&lt;int&gt; ids = GetIDsFromPrefix(add_info_list.at(i), "Lid", "Rid");
 				if(ids.size() &gt; 0)
-					gps_points.at(i).LeftLaneId =  ids.at(0);
+					gps_points.at(i).LeftPointId =  ids.at(0);
 
 				ids = GetIDsFromPrefix(add_info_list.at(i), "Rid", "Vel");
 				if(ids.size() &gt; 0)
-					gps_points.at(i).RightLaneId =  ids.at(0);
+					gps_points.at(i).RightPointId =  ids.at(0);
 
 				vector&lt;double&gt; dnums = GetDoubleFromPrefix(add_info_list.at(i), "Vel", "Dir");
 				if(dnums.size() &gt; 0)
@@ -1907,7 +1896,7 @@ void MappingHelpers::FindAdjacentLanes(RoadNetwork&amp; map)
 							{
 								if(i_internal&lt;map.roadSegments.at(rs_2).Lanes.at(i2).points.size())
 								{
-									pL-&gt;points.at(i_internal).RightLaneId = map.roadSegments.at(rs_2).Lanes.at(i2).id;
+									pL-&gt;points.at(i_internal).RightPointId = map.roadSegments.at(rs_2).Lanes.at(i2).id;
 									pL-&gt;points.at(i_internal).pRight = &amp;map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal);
 //									map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal).pLeft = &amp;pL-&gt;points.at(i_internal);
 								}
@@ -1920,7 +1909,7 @@ void MappingHelpers::FindAdjacentLanes(RoadNetwork&amp; map)
 							{
 								if(i_internal&lt;map.roadSegments.at(rs_2).Lanes.at(i2).points.size())
 								{
-									pL-&gt;points.at(i_internal).LeftLaneId = map.roadSegments.at(rs_2).Lanes.at(i2).id;
+									pL-&gt;points.at(i_internal).LeftPointId = map.roadSegments.at(rs_2).Lanes.at(i2).id;
 									pL-&gt;points.at(i_internal).pLeft = &amp;map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal);
 //									map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal).pRight = &amp;pL-&gt;points.at(i_internal);
 								}
@@ -2098,6 +2087,42 @@ void MappingHelpers::LinkMissingBranchingWayPoints(RoadNetwork&amp; map)
 	}
 }
 
+void MappingHelpers::LinkMissingBranchingWayPointsV2(RoadNetwork&amp; map)
+{
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			Lane* pLane = &amp;map.roadSegments.at(rs).Lanes.at(i);
+			for(unsigned int p= 0; p &lt; pLane-&gt;points.size(); p++)
+			{
+				WayPoint* pWP = &amp;pLane-&gt;points.at(p);
+
+				if(p+1 == pLane-&gt;points.size()) // Last Point in Lane
+				{
+					for(unsigned int j = 0 ; j &lt; pLane-&gt;toLanes.size(); j++)
+					{
+						//cout &lt;&lt; "Link, Next Lane: " &lt;&lt; pWP-&gt;laneId &lt;&lt; ", WP: " &lt;&lt; pWP-&gt;id &lt;&lt; " To WP: " &lt;&lt; pWP-&gt;toIds.at(j) &lt;&lt; endl;
+						pWP-&gt;pFronts.push_back(&amp;pLane-&gt;toLanes.at(j)-&gt;points.at(0));
+					}
+				}
+				else
+				{
+					if(pWP-&gt;toIds.size() &gt; 1)
+					{
+						cout &lt;&lt; "Error Error Erro ! Lane: " &lt;&lt; pWP-&gt;laneId &lt;&lt; ", Point: " &lt;&lt; pWP-&gt;originalMapID &lt;&lt; endl;
+					}
+					else
+					{
+					//	cout &lt;&lt; "Link, Same Lane: " &lt;&lt; pWP-&gt;laneId &lt;&lt; ", WP: " &lt;&lt; pWP-&gt;id &lt;&lt; " To WP: " &lt;&lt; map.roadSegments.at(rs).Lanes.at(i).points.at(p+1).id &lt;&lt; endl;
+						pWP-&gt;pFronts.push_back(&amp;pLane-&gt;points.at(p+1));
+					}
+				}
+			}
+		}
+	}
+}
+
 void MappingHelpers::LinkTrafficLightsAndStopLines(RoadNetwork&amp; map)
 {
 
@@ -2111,7 +2136,7 @@ void MappingHelpers::LinkTrafficLightsAndStopLines(RoadNetwork&amp; map)
 				{
 					WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
 
-					if(map.stopLines.at(isl).linkID == pWP-&gt;id || map.stopLines.at(isl).linkID == pWP-&gt;originalMapID)
+					if(map.stopLines.at(isl).linkID == pWP-&gt;id)
 					{
 						map.stopLines.at(isl).laneId = pWP-&gt;laneId;
 						map.stopLines.at(isl).pLane = pWP-&gt;pLane;
@@ -2143,7 +2168,7 @@ void MappingHelpers::LinkTrafficLightsAndStopLines(RoadNetwork&amp; map)
 				for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
 				{
 					WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
-					if(map.trafficLights.at(itl).linkID == pWP-&gt;id || map.trafficLights.at(itl).linkID == pWP-&gt;originalMapID)
+					if(map.trafficLights.at(itl).linkID == pWP-&gt;id)
 					{
 						map.roadSegments.at(rs).Lanes.at(i).trafficlights.push_back(map.trafficLights.at(itl));
 						break;
@@ -2243,8 +2268,132 @@ void MappingHelpers::UpdateMapWithOccupancyGrid(OccupancyToGridMap&amp; map_info, co
 	}
 }
 
+void MappingHelpers::ConstructRoadNetworkFromRosMessageV2(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
+		const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+		const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
+		const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
+		const std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt;&amp; area_data,
+		const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
+		const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
+		const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
+		const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
+		const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
+		const std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt;&amp; roadedge_data,
+		const std::vector&lt;UtilityHNS::AisanWayareaFileReader::AisanWayarea&gt;&amp; wayarea_data,
+		const std::vector&lt;UtilityHNS::AisanCrossWalkFileReader::AisanCrossWalk&gt;&amp; crosswalk_data,
+		const std::vector&lt;UtilityHNS::AisanNodesFileReader::AisanNode&gt;&amp; nodes_data,
+		const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
+		UtilityHNS::AisanLanesFileReader* pLaneData,
+		UtilityHNS::AisanPointsFileReader* pPointsData,
+		UtilityHNS::AisanNodesFileReader* pNodesData,
+		UtilityHNS::AisanLinesFileReader* pLinedata,
+		const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag)
+{
+	vector&lt;Lane&gt; roadLanes;
+
+	for(unsigned int i=0; i&lt; pLaneData-&gt;m_data_list.size(); i++)
+	{
+		if(pLaneData-&gt;m_data_list.at(i).LnID &gt; g_max_lane_id)
+			g_max_lane_id = pLaneData-&gt;m_data_list.at(i).LnID;
+	}
+
+	cout &lt;&lt; " &gt;&gt; Extracting Lanes ... " &lt;&lt; endl;
+	CreateLanes(pLaneData, pPointsData, pNodesData, roadLanes);
+
+	cout &lt;&lt; " &gt;&gt; Fix Waypoints errors ... " &lt;&lt; endl;
+	FixTwoPointsLanes(roadLanes);
+	FixRedundantPointsLanes(roadLanes);
+
+	ConnectLanes(pLaneData, roadLanes);
+
+	cout &lt;&lt; " &gt;&gt; Create Missing lane connections ... " &lt;&lt; endl;
+	FixUnconnectedLanes(roadLanes);
+	////FixTwoPointsLanes(roadLanes);
+
+	//map has one road segment
+	RoadSegment roadSegment1;
+	roadSegment1.id = 1;
+	roadSegment1.Lanes = roadLanes;
+	map.roadSegments.push_back(roadSegment1);
+
+	//Fix angle for lanes
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
+			PlannerHNS::PlanningHelpers::FixAngleOnly(pL-&gt;points);
+		}
+	}
+
+	//Link Lanes and lane's waypoints by pointers
+	cout &lt;&lt; " &gt;&gt; Link lanes and waypoints with pointers ... " &lt;&lt; endl;
+	LinkLanesPointers(map);
+
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
+			for(unsigned int j = 0 ; j &lt; pL-&gt;points.size(); j++)
+			{
+			    if(pL-&gt;points.at(j).actionCost.size() &gt; 0)
+			  {
+				  if(pL-&gt;points.at(j).actionCost.at(0).first == LEFT_TURN_ACTION)
+					{
+					  AssignActionCostToLane(pL, LEFT_TURN_ACTION, LEFT_INITIAL_TURNS_COST);
+					  break;
+					}
+				  else if(pL-&gt;points.at(j).actionCost.at(0).first == RIGHT_TURN_ACTION)
+					{
+					  AssignActionCostToLane(pL, RIGHT_TURN_ACTION, RIGHT_INITIAL_TURNS_COST);
+					break;
+
+					}
+				  }
+			}
+		}
+	}
+
+#ifdef FIND_LEFT_RIGHT_LANES
+	cout &lt;&lt; " &gt;&gt; Extract Lane Change Information... " &lt;&lt; endl;
+	FindAdjacentLanesV2(map);
+#endif
+
+	//Extract Signals and StopLines
+	cout &lt;&lt; " &gt;&gt; Extract Signal data ... " &lt;&lt; endl;
+	ExtractSignalDataV2(signal_data, vector_data, pPointsData, origin, map);
+
+	//Stop Lines
+	cout &lt;&lt; " &gt;&gt; Extract Stop lines data ... " &lt;&lt; endl;
+	ExtractStopLinesDataV2(stop_line_data, pLinedata, pPointsData, origin, map);
+
+#ifdef MAP_PERF_ENABLE_CURB_AND_WAYAREA
+	//Curbs
+	cout &lt;&lt; " &gt;&gt; Extract curbs data ... " &lt;&lt; endl;
+	ExtractCurbDataV2(curb_data, pLinedata, pPointsData, origin, map);
+
+	//Wayarea
+	cout &lt;&lt; " &gt;&gt; Extract wayarea data ... " &lt;&lt; endl;
+	ExtractWayArea(area_data, wayarea_data, line_data, points_data, origin, map);
+#endif
+
+	//Link waypoints
+	cout &lt;&lt; " &gt;&gt; Link missing branches and waypoints... " &lt;&lt; endl;
+	LinkMissingBranchingWayPointsV2(map);
+
+	//Link StopLines and Traffic Lights
+	cout &lt;&lt; " &gt;&gt; Link StopLines and Traffic Lights ... " &lt;&lt; endl;
+	LinkTrafficLightsAndStopLinesV2(map);
+//	//LinkTrafficLightsAndStopLinesConData(conn_data, id_replace_list, map);
+
+	cout &lt;&lt; " &gt;&gt; Map loaded from data with " &lt;&lt; roadLanes.size()  &lt;&lt; " lanes" &lt;&lt; endl;
+}
+
 bool MappingHelpers::GetPointFromDataList(UtilityHNS::AisanPointsFileReader* pPointsData,const int&amp; pid, WayPoint&amp; out_wp)
 {
+	if(pPointsData == nullptr) return false;
+
 	AisanPointsFileReader::AisanPoints* pP =  pPointsData-&gt;GetDataRowById(pid);
 
 	if(pP!=nullptr)
@@ -2263,13 +2412,16 @@ int MappingHelpers::GetBeginPointIdFromLaneNo(UtilityHNS::AisanLanesFileReader*
 		UtilityHNS::AisanPointsFileReader* pPointsData,
 		UtilityHNS::AisanNodesFileReader* pNodesData,const int&amp; LnID)
 {
+	if(pLaneData == nullptr) return false;
 	UtilityHNS::AisanLanesFileReader::AisanLane* pL = nullptr;
 	UtilityHNS::AisanPointsFileReader::AisanPoints* pP = nullptr;
 	UtilityHNS::AisanNodesFileReader::AisanNode* pN = nullptr;
 
 	pL = pLaneData-&gt;GetDataRowById(LnID);
 	if(pL!=nullptr)
-		return pL-&gt;BNID;
+	{
+		return pL-&gt;FNID;
+	}
 
 	return 0;
 }
@@ -2284,7 +2436,9 @@ int MappingHelpers::GetEndPointIdFromLaneNo(UtilityHNS::AisanLanesFileReader* pL
 
 	pL = pLaneData-&gt;GetDataRowById(LnID);
 	if(pL!=nullptr)
-		return pL-&gt;FNID;
+	{
+		return pL-&gt;BNID;
+	}
 
 	return 0;
 }
@@ -2393,25 +2547,39 @@ void MappingHelpers::GetLanePoints(UtilityHNS::AisanLanesFileReader* pLaneData,
 			UtilityHNS::AisanNodesFileReader* pNodesData, int lnID,
 			PlannerHNS::Lane&amp; out_lane)
 {
-	int _lnid = lnID;
+	int next_lnid = lnID;
 	bool bStart = false;
 	bool bLast = false;
 	int _rID = 0;
 	out_lane.points.clear();
 	UtilityHNS::AisanLanesFileReader::AisanLane* pL = nullptr;
 	out_lane.id = lnID;
+	out_lane.speed = 0;
 
 	while(!bStart)
 	{
-		pL = pLaneData-&gt;GetDataRowById(_lnid);
+		pL = pLaneData-&gt;GetDataRowById(next_lnid);
+		if(pL == nullptr)
+		{
+			cout &lt;&lt; "## Error, Can't find lane from ID: " &lt;&lt; next_lnid &lt;&lt;endl;
+			break;
+		}
+
+		next_lnid = pL-&gt;FLID;
+		if(next_lnid == 0)
+			bStart = true;
+		else
+			bStart = IsStartLanePoint(pLaneData, pLaneData-&gt;GetDataRowById(next_lnid));
 
-		//if(_lnid == 16347) // || _lnid == 1267 || _lnid == 1268 || _lnid == 1269 || _lnid == 958)
-			//out_lane.id = lnID;
+//		if(_lnid == 1267 ) //|| _lnid == 1268 || _lnid == 1269 || _lnid == 958)
+//			out_lane.id = lnID;
 
 		if(out_lane.points.size() == 0)
 		{
 			WayPoint wp1, wp2;
 			GetPointFromDataList(pPointsData, pNodesData-&gt;GetDataRowById(pL-&gt;BNID)-&gt;PID, wp1);
+			wp1.v = pL-&gt;RefVel == 0 ? DEFAULT_REF_VELOCITY : pL-&gt;RefVel;
+
 			wp1.id = pL-&gt;BNID;
 
 			if(pL-&gt;BLID != 0)
@@ -2440,8 +2608,10 @@ void MappingHelpers::GetLanePoints(UtilityHNS::AisanLanesFileReader* pLaneData,
 			}
 
 			GetPointFromDataList(pPointsData, pNodesData-&gt;GetDataRowById(pL-&gt;FNID)-&gt;PID, wp2);
+			wp2.v = pL-&gt;RefVel == 0 ? DEFAULT_REF_VELOCITY : pL-&gt;RefVel;
 			wp2.id = pL-&gt;FNID;
-			if(pL-&gt;FLID != 0)
+
+			if(bStart &amp;&amp; pL-&gt;FLID != 0)
 			{
 				_rID = GetEndPointIdFromLaneNo(pLaneData, pPointsData, pNodesData, pL-&gt;FLID);
 				if(_rID &gt; 0)
@@ -2492,15 +2662,19 @@ void MappingHelpers::GetLanePoints(UtilityHNS::AisanLanesFileReader* pLaneData,
 			wp2.fromIds.push_back(wp1.id);
 			out_lane.points.push_back(wp1);
 			out_lane.points.push_back(wp2);
+			out_lane.speed = pL-&gt;RefVel == 0 ? DEFAULT_REF_VELOCITY : pL-&gt;RefVel;
 		}
 		else
 		{
 			WayPoint wp;
 			GetPointFromDataList(pPointsData, pNodesData-&gt;GetDataRowById(pL-&gt;FNID)-&gt;PID, wp);
+			wp.v = pL-&gt;RefVel == 0 ? DEFAULT_REF_VELOCITY : pL-&gt;RefVel;
 			wp.id = pL-&gt;FNID;
+
+			out_lane.points.at(out_lane.points.size()-1).toIds.push_back(wp.id);
 			wp.fromIds.push_back(out_lane.points.at(out_lane.points.size()-1).id);
 
-			if(pL-&gt;FLID != 0)
+			if(bStart &amp;&amp; pL-&gt;FLID != 0)
 			{
 				_rID = GetEndPointIdFromLaneNo(pLaneData, pPointsData, pNodesData, pL-&gt;FLID);
 				if(_rID &gt; 0)
@@ -2544,17 +2718,14 @@ void MappingHelpers::GetLanePoints(UtilityHNS::AisanLanesFileReader* pLaneData,
 			out_lane.points.push_back(wp);
 		}
 
-		_lnid = pL-&gt;FLID;
-
-		if(_lnid == 0)
-			break;
-
-		bStart = IsStartLanePoint(pLaneData, pLaneData-&gt;GetDataRowById(_lnid));
+//		if(next_lnid == 0)
+//			break;
 	}
 }
 
 void MappingHelpers::FixRedundantPointsLanes(std::vector&lt;Lane&gt;&amp; lanes)
 {
+	//Fix Redundant point for two points in a row
 	for(unsigned int il=0; il &lt; lanes.size(); il ++)
 	{
 		for(int ip = 1; ip &lt; lanes.at(il).points.size(); ip++)
@@ -3003,127 +3174,6 @@ void MappingHelpers::LinkLanesPointers(PlannerHNS::RoadNetwork&amp; map)
 	}
 }
 
-void MappingHelpers::ConstructRoadNetworkFromRosMessageV2(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
-		const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
-		const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
-		const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
-		const std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt;&amp; area_data,
-		const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
-		const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
-		const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
-		const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
-		const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
-		const std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt;&amp; roadedge_data,
-		const std::vector&lt;UtilityHNS::AisanWayareaFileReader::AisanWayarea&gt;&amp; wayarea_data,
-		const std::vector&lt;UtilityHNS::AisanCrossWalkFileReader::AisanCrossWalk&gt;&amp; crosswalk_data,
-		const std::vector&lt;UtilityHNS::AisanNodesFileReader::AisanNode&gt;&amp; nodes_data,
-		const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
-		UtilityHNS::AisanLanesFileReader* pLaneData,
-		UtilityHNS::AisanPointsFileReader* pPointsData,
-		UtilityHNS::AisanNodesFileReader* pNodesData,
-		UtilityHNS::AisanLinesFileReader* pLinedata,
-		const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag)
-{
-	vector&lt;Lane&gt; roadLanes;
-
-	for(unsigned int i=0; i&lt; pLaneData-&gt;m_data_list.size(); i++)
-	{
-		if(pLaneData-&gt;m_data_list.at(i).LnID &gt; g_max_lane_id)
-			g_max_lane_id = pLaneData-&gt;m_data_list.at(i).LnID;
-	}
-
-	cout &lt;&lt; " &gt;&gt; Extracting Lanes ... " &lt;&lt; endl;
-	CreateLanes(pLaneData, pPointsData, pNodesData, roadLanes);
-
-	cout &lt;&lt; " &gt;&gt; Fix Waypoints errors ... " &lt;&lt; endl;
-	FixTwoPointsLanes(roadLanes);
-	FixRedundantPointsLanes(roadLanes);
-
-	ConnectLanes(pLaneData, roadLanes);
-
-	cout &lt;&lt; " &gt;&gt; Create Missing lane connections ... " &lt;&lt; endl;
-	FixUnconnectedLanes(roadLanes);
-	//FixTwoPointsLanes(roadLanes);
-
-	//map has one road segment
-	RoadSegment roadSegment1;
-	roadSegment1.id = 1;
-	roadSegment1.Lanes = roadLanes;
-	map.roadSegments.push_back(roadSegment1);
-
-	//Link Lanes and lane's waypoints by pointers
-	cout &lt;&lt; " &gt;&gt; Link lanes and waypoints with pointers ... " &lt;&lt; endl;
-	LinkLanesPointers(map);
-
-	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
-	{
-		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
-		{
-			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
-			for(unsigned int j = 0 ; j &lt; pL-&gt;points.size(); j++)
-			{
-			    if(pL-&gt;points.at(j).actionCost.size() &gt; 0)
-			  {
-				  if(pL-&gt;points.at(j).actionCost.at(0).first == LEFT_TURN_ACTION)
-					{
-					  AssignActionCostToLane(pL, LEFT_TURN_ACTION, LEFT_INITIAL_TURNS_COST);
-					  break;
-					}
-				  else if(pL-&gt;points.at(j).actionCost.at(0).first == RIGHT_TURN_ACTION)
-					{
-					  AssignActionCostToLane(pL, RIGHT_TURN_ACTION, RIGHT_INITIAL_TURNS_COST);
-					break;
-
-					}
-				  }
-			}
-		}
-	}
-
-#ifdef FIND_LEFT_RIGHT_LANES
-	FindAdjacentLanes(map);
-#endif
-
-//	//Extract Signals and StopLines
-//	// Signals
-	cout &lt;&lt; " &gt;&gt; Extract Signal data ... " &lt;&lt; endl;
-	ExtractSignalDataV2(signal_data, vector_data, pPointsData, origin, map);
-
-
-	//Stop Lines
-	cout &lt;&lt; " &gt;&gt; Extract Stop lines data ... " &lt;&lt; endl;
-	ExtractStopLinesDataV2(stop_line_data, pLinedata, pPointsData, origin, map);
-
-	//Curbs
-	//cout &lt;&lt; " &gt;&gt; Extract curbs data ... " &lt;&lt; endl;
-	ExtractCurbDataV2(curb_data, pLinedata, pPointsData, origin, map);
-
-	//Wayarea
-	//cout &lt;&lt; " &gt;&gt; Extract wayarea data ... " &lt;&lt; endl;
-	ExtractWayArea(area_data, wayarea_data, line_data, points_data, origin, map);
-
-//	//Link waypoints
-	cout &lt;&lt; " &gt;&gt; Check for missing branches and signs ... " &lt;&lt; endl;
-	LinkMissingBranchingWayPoints(map);
-//
-//	//Link StopLines and Traffic Lights
-	LinkTrafficLightsAndStopLines(map);
-//	//LinkTrafficLightsAndStopLinesConData(conn_data, id_replace_list, map);
-//
-
-	//Fix angle for lanes
-	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
-	{
-		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
-		{
-			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
-			PlannerHNS::PlanningHelpers::FixAngleOnly(pL-&gt;points);
-		}
-	}
-
-	cout &lt;&lt; " &gt;&gt; Map loaded from data with " &lt;&lt; roadLanes.size()  &lt;&lt; " lanes" &lt;&lt; endl;
-}
-
 void MappingHelpers::ExtractCurbDataV2(const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
 				UtilityHNS::AisanLinesFileReader* pLinedata,
 				UtilityHNS::AisanPointsFileReader* pPointsData,
@@ -3226,29 +3276,130 @@ void MappingHelpers::ExtractStopLinesDataV2(const std::vector&lt;UtilityHNS::AisanS
 	}
 }
 
-bool MappingHelpers::GetWayPointV2(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; pid,
-		const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
-			const GPSPoint&amp; origin, WayPoint&amp; way_point)
+void MappingHelpers::LinkTrafficLightsAndStopLinesV2(RoadNetwork&amp; map)
 {
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
+			{
+				WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
+
+				for(unsigned int isl = 0; isl &lt; map.stopLines.size(); isl++)
+				{
+					if(map.stopLines.at(isl).linkID == pWP-&gt;originalMapID)
+					{
+						map.stopLines.at(isl).laneId = pWP-&gt;laneId;
+						map.stopLines.at(isl).pLane = pWP-&gt;pLane;
+						map.roadSegments.at(rs).Lanes.at(i).stopLines.push_back(map.stopLines.at(isl));
 
-	for(unsigned int p =0; p &lt; points.size(); p++)
+						pWP-&gt;stopLineID = map.stopLines.at(isl).id;
+
+						for(unsigned int itl = 0; itl &lt; map.trafficLights.size(); itl++)
+						{
+							if(map.trafficLights.at(itl).id == map.stopLines.at(isl).trafficLightID)
+							{
+								map.trafficLights.at(itl).laneIds.push_back(pWP-&gt;laneId);
+								map.trafficLights.at(itl).pLanes.push_back(pWP-&gt;pLane);
+							}
+						}
+						break;
+					}
+				}
+			}
+		}
+	}
+
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
 	{
-		if(pid == points.at(p).PID)
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
 		{
-			way_point.id = id;
-			//way_point.id = pid;
-			way_point.laneId = laneID;
-			way_point.v = refVel;
-			way_point.pos = GPSPoint(points.at(p).Ly + origin.x, points.at(p).Bx + origin.y, points.at(p).H + origin.z, 0);
-			way_point.pos.lat = points.at(p).L;
-			way_point.pos.lon = points.at(p).B;
-			way_point.pos.alt = points.at(p).H;
-			way_point.iOriginalIndex = p;
-			return true;
+			for(unsigned int itl = 0; itl &lt; map.trafficLights.size(); itl++)
+			{
+				for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
+				{
+					WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
+					if(map.trafficLights.at(itl).linkID == pWP-&gt;originalMapID)
+					{
+						map.roadSegments.at(rs).Lanes.at(i).trafficlights.push_back(map.trafficLights.at(itl));
+						break;
+					}
+				}
+			}
 		}
 	}
+}
 
-	return false;
+void MappingHelpers::FindAdjacentLanesV2(RoadNetwork&amp; map)
+{
+	bool bTestDebug = false;
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
+			for(unsigned int i2 =0; i2 &lt; map.roadSegments.at(rs).Lanes.size(); i2++)
+			{
+				Lane* pL2 = &amp;map.roadSegments.at(rs).Lanes.at(i2);
+
+				if(pL-&gt;id == pL2-&gt;id) continue;
+
+
+				if(pL-&gt;id == 1683)
+					bTestDebug = true;
+
+				for(unsigned int p=0; p &lt; pL-&gt;points.size(); p++)
+				{
+					WayPoint* pWP = &amp;pL-&gt;points.at(p);
+					RelativeInfo info;
+					PlanningHelpers::GetRelativeInfoLimited(pL2-&gt;points, *pWP, info);
+
+					if(!info.bAfter &amp;&amp; !info.bBefore &amp;&amp; fabs(info.perp_distance) &gt; 1.2 &amp;&amp; fabs(info.perp_distance) &lt; 3.5 &amp;&amp; UtilityH::AngleBetweenTwoAnglesPositive(info.perp_point.pos.a, pWP-&gt;pos.a) &lt; 0.06)
+					{
+						WayPoint* pWP2 = &amp;pL2-&gt;points.at(info.iFront);
+						if(info.perp_distance &lt; 0)
+						{
+							if(pWP-&gt;pRight == 0)
+							{
+								pWP-&gt;pRight = pWP2;
+								pWP-&gt;RightPointId = pWP2-&gt;id;
+								pWP-&gt;RightLnId = pL2-&gt;id;
+								pL-&gt;pRightLane = pL2;
+
+							}
+
+							if(pWP2-&gt;pLeft == 0)
+							{
+								pWP2-&gt;pLeft = pWP;
+								pWP2-&gt;LeftPointId = pWP-&gt;id;
+								pWP2-&gt;LeftLnId = pL-&gt;id;
+								pL2-&gt;pLeftLane = pL;
+							}
+						}
+						else
+						{
+							if(pWP-&gt;pLeft == 0)
+							{
+								pWP-&gt;pLeft = pWP2;
+								pWP-&gt;LeftPointId = pWP2-&gt;id;
+								pWP-&gt;LeftLnId = pL2-&gt;id;
+								pL-&gt;pLeftLane = pL2;
+							}
+
+							if(pWP2-&gt;pRight == 0)
+							{
+								pWP2-&gt;pRight = pWP-&gt;pLeft;
+								pWP2-&gt;RightPointId = pWP-&gt;id;
+								pWP2-&gt;RightLnId = pL-&gt;id;
+								pL2-&gt;pRightLane = pL;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
 }
 
 void MappingHelpers::GetMapMaxIds(PlannerHNS::RoadNetwork&amp; map)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MatrixOperations.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MatrixOperations.cpp" added_lines="4" deleted_lines="6">
				<diff>@@ -1,9 +1,7 @@
-/*
- * MatrixOperations.cpp
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
+/// \file MatrixOperations.cpp
+/// \brief Simple matrix operations
+/// \author Hatem Darweesh
+/// \date Jun 19, 2016
 
 #include "op_planner/MatrixOperations.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlannerH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlannerH.cpp" added_lines="32" deleted_lines="38">
				<diff>@@ -1,9 +1,7 @@
-/*
- * HelperFunctions.cpp
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
+/// \file PlannerH.cpp
+/// \brief Main functions for path generation (global and local)
+/// \author Hatem Darweesh
+/// \date Dec 14, 2016
 
 #include "op_planner/PlannerH.h"
 #include "op_planner/PlanningHelpers.h"
@@ -24,17 +22,6 @@ PlannerH::~PlannerH()
 {
 }
 
-double PlannerH::PlanUsingReedShepp(const WayPoint&amp; start, const WayPoint&amp; goal, vector&lt;WayPoint&gt;&amp; generatedPath, const double pathDensity, const double smoothFactor)
- {
- 	RSPlanner rs_planner(smoothFactor);
- 	int numero = 0;
- 	double t=0, u=0 , v=0;
- 	rs_planner.PATHDENSITY = pathDensity;
- 	double length = rs_planner.min_length_rs(start.pos.x, start.pos.y, start.pos.a, goal.pos.x, goal.pos.y, goal.pos.a, numero, t , u , v);
- 	rs_planner.constRS(numero, t, u , v, start.pos.x, start.pos.y, start.pos.a, rs_planner.PATHDENSITY, generatedPath);
- 	return length;
- }
-
 void PlannerH::GenerateRunoffTrajectory(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; referencePaths,const WayPoint&amp; carPos, const bool&amp; bEnableLaneChange, const double&amp; speed, const double&amp; microPlanDistance,
 		const double&amp; maxSpeed,const double&amp; minSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
 		const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
@@ -178,18 +165,11 @@ double PlannerH::PlanUsingDP(const WayPoint&amp; start,
 
 	if(fabs(start_info.perp_distance) &gt; START_POINT_MAX_DISTANCE)
 	{
-		//if(fabs(start_info.perp_distance) &gt; 20)
-		{
-			GPSPoint sp = start.pos;
-			cout &lt;&lt; endl &lt;&lt; "Error: PlannerH -&gt; Start Distance to Lane is: " &lt;&lt; start_info.perp_distance
-					&lt;&lt; ", Pose: " &lt;&lt; sp.ToString() &lt;&lt; ", LanePose:" &lt;&lt; start_info.perp_point.pos.ToString()
-					&lt;&lt; ", LaneID: " &lt;&lt; pStart-&gt;pLane-&gt;id &lt;&lt; " -&gt; Check origin and vector map. " &lt;&lt; endl;
-			return 0;
-		}
-		// 		else
-		// 		{
-		// 			//PlanUsingReedShepp(start, *pStart, start_path, 1.0, 1);
-		// 		}
+		GPSPoint sp = start.pos;
+		cout &lt;&lt; endl &lt;&lt; "Error: PlannerH -&gt; Start Distance to Lane is: " &lt;&lt; start_info.perp_distance
+				&lt;&lt; ", Pose: " &lt;&lt; sp.ToString() &lt;&lt; ", LanePose:" &lt;&lt; start_info.perp_point.pos.ToString()
+				&lt;&lt; ", LaneID: " &lt;&lt; pStart-&gt;pLane-&gt;id &lt;&lt; " -&gt; Check origin and vector map. " &lt;&lt; endl;
+		return 0;
 	}
 
 	if(fabs(goal_info.perp_distance) &gt; GOAL_POINT_MAX_DISTANCE)
@@ -295,7 +275,7 @@ double PlannerH::PlanUsingDP(const WayPoint&amp; start,
 	return totalPlanningDistance;
 }
 
-double PlannerH::PredictPlanUsingDP(Lane* l, const WayPoint&amp; start, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths)
+double PlannerH::PredictPlanUsingDP(PlannerHNS::Lane* l, const WayPoint&amp; start, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths)
 {
 	if(!l)
 	{
@@ -350,7 +330,7 @@ double PlannerH::PredictPlanUsingDP(Lane* l, const WayPoint&amp; start, const double
 	return totalPlanDistance;
 }
 
-double PlannerH::PredictTrajectoriesUsingDP(const WayPoint&amp; startPose, std::vector&lt;WayPoint*&gt; closestWPs, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, const bool&amp; bFindBranches , const bool bDirectionBased)
+double PlannerH::PredictTrajectoriesUsingDP(const WayPoint&amp; startPose, std::vector&lt;WayPoint*&gt; closestWPs, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, const bool&amp; bFindBranches , const bool bDirectionBased, const bool pathDensity)
 {
 	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
 	vector&lt;WayPoint*&gt; all_cell_to_delete;
@@ -390,8 +370,12 @@ double PlannerH::PredictTrajectoriesUsingDP(const WayPoint&amp; startPose, std::vect
 				if(!bDirectionBased)
 					path.at(0).pos.a = path.at(1).pos.a;
 
-				PlanningHelpers::FixPathDensity(path, 1.0);
-				PlanningHelpers::SmoothPath(path, 0.3 , 0.3,0.1);
+				path.at(0).beh_state = path.at(1).beh_state = PlannerHNS::BEH_FORWARD_STATE;
+				path.at(0).laneId = path.at(1).laneId;
+
+				PlanningHelpers::FixPathDensity(path, pathDensity);
+				PlanningHelpers::SmoothPath(path,0.4,0.3,0.1);
+				PlanningHelpers::CalcAngleAndCost(path);
 				paths.push_back(path);
 			}
 		}
@@ -405,14 +389,24 @@ double PlannerH::PredictTrajectoriesUsingDP(const WayPoint&amp; startPose, std::vect
 		else
 			p2 = p1 = startPose;
 
-		p2.pos.y = p1.pos.y + maxPlanningDistance*0.5*sin(p1.pos.a);
-		p2.pos.x = p1.pos.x + maxPlanningDistance*0.5*cos(p1.pos.a);
+		double branch_length = maxPlanningDistance*0.5;
+
+		p2.pos.y = p1.pos.y + branch_length*0.4*sin(p1.pos.a);
+		p2.pos.x = p1.pos.x + branch_length*0.4*cos(p1.pos.a);
 
 		vector&lt;WayPoint&gt; l_branch;
 		vector&lt;WayPoint&gt; r_branch;
 
-		PlanningHelpers::CreateManualBranchFromTwoPoints(p1, p2, maxPlanningDistance*0.75, FORWARD_RIGHT_DIR,r_branch);
-		PlanningHelpers::CreateManualBranchFromTwoPoints(p1, p2, maxPlanningDistance*0.75, FORWARD_LEFT_DIR, l_branch);
+		PlanningHelpers::CreateManualBranchFromTwoPoints(p1, p2, branch_length, FORWARD_RIGHT_DIR,r_branch);
+		PlanningHelpers::CreateManualBranchFromTwoPoints(p1, p2, branch_length, FORWARD_LEFT_DIR, l_branch);
+
+		PlanningHelpers::FixPathDensity(l_branch, pathDensity);
+		PlanningHelpers::SmoothPath(l_branch,0.4,0.3,0.1);
+		PlanningHelpers::CalcAngleAndCost(l_branch);
+
+		PlanningHelpers::FixPathDensity(r_branch, pathDensity);
+		PlanningHelpers::SmoothPath(r_branch,0.4,0.3,0.1);
+		PlanningHelpers::CalcAngleAndCost(r_branch);
 
 		paths.push_back(l_branch);
 		paths.push_back(r_branch);
@@ -420,7 +414,7 @@ double PlannerH::PredictTrajectoriesUsingDP(const WayPoint&amp; startPose, std::vect
 
 	DeleteWaypoints(all_cell_to_delete);
 
-	return 1;
+	return paths.size();
 }
 
 double PlannerH::PredictPlanUsingDP(const WayPoint&amp; startPose, WayPoint* closestWP, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, const bool&amp; bFindBranches)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" added_lines="18" deleted_lines="15">
				<diff>@@ -13,10 +13,8 @@
 using namespace UtilityHNS;
 using namespace std;
 
-
-
-namespace PlannerHNS {
-
+namespace PlannerHNS
+{
 
 std::vector&lt;std::pair&lt;GPSPoint, GPSPoint&gt; &gt; PlanningHelpers::m_TestingClosestPoint;
 
@@ -177,7 +175,7 @@ bool PlanningHelpers::GetRelativeInfoLimited(const std::vector&lt;WayPoint&gt;&amp; trajec
 					  (trajectory.at(0).pos.z+trajectory.at(1).pos.z)/2.0, trajectory.at(0).pos.a);
 		_trajectory.push_back(p0);
 		_trajectory.push_back(p1);
-		_trajectory.push_back(trajectory.at(0));
+		_trajectory.push_back(trajectory.at(1));
 
 		info.iFront = GetClosestNextPointIndexFast(_trajectory, p, prevIndex);
 		if(info.iFront &gt; 0)
@@ -1788,12 +1786,12 @@ std::vector&lt;int&gt; PlanningHelpers::GetUniqueLeftRightIds(const std::vector&lt;WayPoi
 	 vector&lt;int&gt; sideLanes;
 	for(unsigned int iwp = 0; iwp &lt; path.size(); iwp++)
 	 {
-		 if(path.at(iwp).LeftLaneId&gt;0)
+		 if(path.at(iwp).LeftPointId&gt;0)
 		 {
 			 bool bFound = false;
 			 for(unsigned int is = 0 ; is &lt; sideLanes.size(); is++)
 			 {
-				 if(sideLanes.at(is) == path.at(iwp).LeftLaneId)
+				 if(sideLanes.at(is) == path.at(iwp).LeftPointId)
 				 {
 					 bFound = true;
 					 break;
@@ -1801,15 +1799,15 @@ std::vector&lt;int&gt; PlanningHelpers::GetUniqueLeftRightIds(const std::vector&lt;WayPoi
 			 }
 
 			 if(!bFound)
-				 sideLanes.push_back(path.at(iwp).LeftLaneId);
+				 sideLanes.push_back(path.at(iwp).LeftPointId);
 		 }
 
-		 if(path.at(iwp).RightLaneId&gt;0)
+		 if(path.at(iwp).RightPointId&gt;0)
 		 {
 			 bool bFound = false;
 			 for(unsigned int is = 0 ; is &lt; sideLanes.size(); is++)
 			 {
-				 if(sideLanes.at(is) == path.at(iwp).RightLaneId)
+				 if(sideLanes.at(is) == path.at(iwp).RightPointId)
 				 {
 					 bFound = true;
 					 break;
@@ -1817,7 +1815,7 @@ std::vector&lt;int&gt; PlanningHelpers::GetUniqueLeftRightIds(const std::vector&lt;WayPoi
 			 }
 
 			 if(!bFound)
-				 sideLanes.push_back(path.at(iwp).RightLaneId);
+				 sideLanes.push_back(path.at(iwp).RightPointId);
 		 }
 
 		 //RemoveWithValue(sideLanes, path.at(iwp).laneId);
@@ -1966,6 +1964,7 @@ WayPoint* PlanningHelpers::BuildPlanningSearchTreeV2(WayPoint* pStart,
 	all_cells_to_delete.push_back(wp);
 
 	double 		distance 		= 0;
+	double 		before_change_distance	= 0;
 	WayPoint* 	pGoalCell 		= 0;
 	double 		nCounter 		= 0;
 
@@ -2003,12 +2002,13 @@ WayPoint* PlanningHelpers::BuildPlanningSearchTreeV2(WayPoint* pStart,
 		else
 		{
 
-			if(pH-&gt;pLeft &amp;&amp; !CheckLaneExits(all_cells_to_delete, pH-&gt;pLeft-&gt;pLane) &amp;&amp; bEnableLaneChange)
+			if(pH-&gt;pLeft &amp;&amp; !CheckLaneExits(all_cells_to_delete, pH-&gt;pLeft-&gt;pLane) &amp;&amp; !CheckNodeExits(all_cells_to_delete, pH-&gt;pLeft) &amp;&amp; bEnableLaneChange &amp;&amp; before_change_distance &gt; LANE_CHANGE_MIN_DISTANCE)
 			{
 				wp = new WayPoint();
 				*wp = *pH-&gt;pLeft;
 				double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
 				distance += d;
+				before_change_distance = -LANE_CHANGE_MIN_DISTANCE*3;
 
 				for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
 				{
@@ -2024,12 +2024,13 @@ WayPoint* PlanningHelpers::BuildPlanningSearchTreeV2(WayPoint* pStart,
 				all_cells_to_delete.push_back(wp);
 			}
 
-			if(pH-&gt;pRight &amp;&amp; !CheckLaneExits(all_cells_to_delete, pH-&gt;pRight-&gt;pLane) &amp;&amp; bEnableLaneChange)
+			if(pH-&gt;pRight &amp;&amp; !CheckLaneExits(all_cells_to_delete, pH-&gt;pRight-&gt;pLane) &amp;&amp; !CheckNodeExits(all_cells_to_delete, pH-&gt;pRight) &amp;&amp; bEnableLaneChange &amp;&amp; before_change_distance &gt; LANE_CHANGE_MIN_DISTANCE)
 			{
 				wp = new WayPoint();
 				*wp = *pH-&gt;pRight;
 				double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
 				distance += d;
+				before_change_distance = -LANE_CHANGE_MIN_DISTANCE*3;
 
 				for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
 				{
@@ -2053,6 +2054,7 @@ WayPoint* PlanningHelpers::BuildPlanningSearchTreeV2(WayPoint* pStart,
 
 					double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
 					distance += d;
+					before_change_distance += d;
 
 					for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
 					{
@@ -2213,6 +2215,7 @@ int PlanningHelpers::PredictiveIgnorIdsDP(WayPoint* pStart, const double&amp; Distan
 		WayPoint* pZero = 0;
 		WayPoint* wp    = new WayPoint();
 		*wp = *pStart;
+		wp-&gt;cost = 0;
 		wp-&gt;pLeft = 0;
 		wp-&gt;pRight = 0;
 		nextLeafToTrace.push_back(make_pair(pZero, wp));
@@ -2372,7 +2375,7 @@ WayPoint* PlanningHelpers::CheckNodeExits(const vector&lt;WayPoint*&gt;&amp; nodes, const
 
 	for(unsigned int i=0; i&lt; nodes.size(); i++)
 	{
-		if(nodes.at(i)-&gt;id == pL-&gt;id)
+		if(nodes.at(i)-&gt;laneId == pL-&gt;laneId &amp;&amp; nodes.at(i)-&gt;id == pL-&gt;id)
 			return nodes.at(i);
 	}
 
@@ -2544,7 +2547,7 @@ void PlanningHelpers::ExtractPlanAlernatives(const std::vector&lt;WayPoint&gt;&amp; single
 void PlanningHelpers::TraversePathTreeBackwards(WayPoint* pHead, WayPoint* pStartWP,const vector&lt;int&gt;&amp; globalPathIds,
 		vector&lt;WayPoint&gt;&amp; localPath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; localPaths)
 {
-	if(pHead != NULL &amp;&amp; pHead != pStartWP)
+	if(pHead != NULL &amp;&amp; pHead-&gt;id != pStartWP-&gt;id)
 	{
 		if(pHead-&gt;pBacks.size()&gt;0)
 		{
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\RSPlanner.cpp" new_path="" added_lines="0" deleted_lines="1198">
				<diff>@@ -1,1198 +0,0 @@
-/*
- * RSPlannerSA.cpp
- *
- *  Created on: Aug 9, 2015
- *      Author: hatem
- */
-
-#include "op_planner/RSPlanner.h"
-
-
-using namespace std;
-
-namespace PlannerHNS
-{
-
-RSPlanner::RSPlanner(double curvatureFactor)
-{
-	RADCURV = curvatureFactor;
-	RADCURVMUL2  = 2. * RADCURV;
-	RADCURVMUL4  = 4. * RADCURV;
-	SQRADCURV = RADCURV*RADCURV;
-	SQRADCURVMUL2 = 4. * RADCURV*RADCURV;
-	PATHDENSITY = 0.1; // 10 cm
-
-}
-
-RSPlanner::~RSPlanner()
-{
-	// TODO Auto-generated destructor stub
-}
-
-
-double RSPlanner::mod2pi(const double&amp; a)
-	{
-	double angle = a;
-	   while (angle &lt; 0.0) angle = angle + MPIMUL2;
-	   while (angle &gt;= MPIMUL2) angle = angle - MPIMUL2;
-	   return angle;
-	}
-
-double RSPlanner::my_atan2(const double &amp; y, const double&amp; x)
-{
-//   double a;
-//   if ((x == 0.0) &amp;&amp; (y == 0.0)) return 0.0;
-//   if (x == 0.0)
-//   {
-//      if (y &gt; 0)
-//    	  return MPIDIV2;
-//      else
-//    	  return -MPIDIV2;
-//   }
-//   a = atan(y/x);
-//   if (a &gt; 0.0)
-//      if (x &gt; 0) return a;
-//            else return (a+MPI);
-//   else
-//      if (x &gt; 0) return (a+MPIMUL2);
-//            else return (a+MPI);
-	return atan2(y,x);
-}
-
-double RSPlanner::c_c_c(const double&amp; x,const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v)
-{
-	double a,b,u1,theta,alpha,length_rs;
-
-	   a = x-rs;
-	   b = y+rc;
-	   if ((fabs(a)&lt;EPS3) &amp;&amp; (fabs(b)&lt;EPS3)) return(INFINITY);
-	   u1 = sqrt(a*a+b*b);
-	   if (u1&gt;RADCURVMUL4) return(INFINITY);
-	   theta = my_atan2(b,a);
-	   alpha = acos(u1/RADCURVMUL4);
-	   t = mod2pi(MPIDIV2 + alpha + theta);
-	   u = mod2pi(MPI-2*alpha);
-	   v = mod2pi(phi-t-u);
-
-	   length_rs = RADCURV*(t+u+v);
-	   return(length_rs);
-}
-
-double RSPlanner::c_cc(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v)
-{
-   double a,b,u1,theta,alpha,length_rs;
-
-   a = x-rs;
-   b = y+rc;
-   if ((fabs(a)&lt;EPS3) &amp;&amp; (fabs(b)&lt;EPS3)) return(INFINITY);
-   u1 = sqrt(a*a+b*b);
-   if (u1&gt;RADCURVMUL4) return(INFINITY);
-   theta = my_atan2(b,a);
-   alpha = acos(u1/RADCURVMUL4);
-   t = mod2pi(MPIDIV2 + alpha + theta);
-   u = mod2pi(MPI-2*alpha);
-   v = mod2pi(t+u-phi);
-
-   length_rs = RADCURV*(t+u+v);
-   return(length_rs);
-}
-
-double RSPlanner::csca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v)
-{
-   double a,b,length_rs;
-
-   a = x-rs;
-   b = y+rc;
-   t = mod2pi(my_atan2(b,a));
-   u = sqrt(a*a+b*b);
-   v = mod2pi(phi-t);
-
-   length_rs = RADCURV*(t+v) + u;
-   return(length_rs);
-}
-
-double RSPlanner::cscb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v)
-{
-   double a,b,u1,theta,alpha,length_rs;
-
-   a = x+rs;
-   b = y-rc;
-   u1 = sqrt(a*a+b*b);
-   if (u1 &lt; RADCURVMUL2) return(INFINITY);
-   theta = my_atan2(b,a);
-   u = sqrt(u1*u1 - SQRADCURVMUL2);
-   alpha = my_atan2(RADCURVMUL2,u);
-   t = mod2pi(theta+alpha);
-   v = mod2pi(t-phi);
-
-   length_rs = RADCURV*(t+v) + u;
-   return(length_rs);
-}
-
-double RSPlanner::ccu_cuc(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v)
-{
-   double a,b,u1,theta,alpha,length_rs;
-
-   a = x+rs;
-   b = y-rc;
-   if ((fabs(a)&lt;EPS3) &amp;&amp; (fabs(b)&lt;EPS3)) return(INFINITY);
-   u1 = sqrt(a*a+b*b);
-   if (u1 &gt; RADCURVMUL4) return(INFINITY);
-   theta = my_atan2(b,a);
-   if (u1&gt;RADCURVMUL2)
-     {
-      alpha = acos((u1/2-RADCURV)/RADCURVMUL2);
-      t = mod2pi(MPIDIV2+theta-alpha);
-      u = mod2pi(MPI-alpha);
-      v = mod2pi(phi-t+2*(u));
-     }
-   else
-     {
-      alpha = acos((u1/2+RADCURV)/(RADCURVMUL2));
-      t = mod2pi(MPIDIV2+theta+alpha);
-      u = mod2pi(alpha);
-      v = mod2pi(phi-t+2*(u));
-     }
-
-   length_rs = RADCURV*(2*(u)+t+v);
-   return(length_rs);
-}
-
-double RSPlanner::c_cucu_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v)
-{
-   double a,b,u1,theta,alpha,length_rs,va1,va2;
-
-   a = x+rs;
-   b = y-rc;
-   if ((fabs(a)&lt;EPS3) &amp;&amp; (fabs(b)&lt;EPS3)) return(INFINITY);
-   u1 = sqrt(a*a+b*b);
-   if (u1 &gt; 6*RADCURV) return(INFINITY);
-   theta = my_atan2(b,a);
-   va1 = (5*SQRADCURV - u1*u1/4)/SQRADCURVMUL2;
-   if ((va1 &lt; 0.0) || (va1 &gt; 1.0)) return(INFINITY);
-   u = acos(va1);
-   va2 = sin(u);
-   alpha = asin(RADCURVMUL2*va2/u1);
-   t = mod2pi(MPIDIV2+theta+alpha);
-   v = mod2pi(t-phi);
-
-   length_rs = RADCURV*(2*(u)+t+v);
-   return(length_rs);
-}
-
-double RSPlanner::c_c2sca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v)
-{
-   double a,b,u1,theta,alpha,length_rs;
-
-   a = x-rs;
-   b = y+rc;
-   u1 = sqrt(a*a+b*b);
-   if (u1 &lt; RADCURVMUL2) return(INFINITY);
-   theta = my_atan2(b,a);
-   u = sqrt(u1*u1-SQRADCURVMUL2) - RADCURVMUL2;
-   if (u &lt; 0.0) return(INFINITY);
-   alpha = my_atan2(RADCURVMUL2,(u+RADCURVMUL2));
-   t = mod2pi(MPIDIV2+theta+alpha);
-   v = mod2pi(t+MPIDIV2-phi);
-
-   length_rs = RADCURV*(t+MPIDIV2+v) + u;
-   return(length_rs);
-}
-
-double RSPlanner::c_c2scb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v)
-{
-   double a,b,u1,theta,length_rs;
-
-   a = x+rs;
-   b = y-rc;
-   u1 = sqrt(a*a+b*b);
-   if (u1 &lt; RADCURVMUL2) return(INFINITY);
-   theta = my_atan2(b,a);
-   t = mod2pi(MPIDIV2+theta);
-   u = u1-RADCURVMUL2;
-   v = mod2pi(phi-t-MPIDIV2);
-
-   length_rs = RADCURV*(t+MPIDIV2+v) + u;
-   return(length_rs);
-}
-
-double RSPlanner::c_c2sc2_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v)
-{
-   double a,b,u1,theta,alpha,length_rs;
-
-   a = x+rs;
-   b = y-rc;
-   u1 = sqrt(a*a+b*b);
-   if (u1 &lt; RADCURVMUL4) return(INFINITY);
-   theta = my_atan2(b,a);
-   u = sqrt(u1*u1-SQRADCURVMUL2) - RADCURVMUL4;
-   if (u &lt; 0.0) return(INFINITY);
-   alpha = my_atan2(RADCURVMUL2,(u+RADCURVMUL4));
-   t = mod2pi(MPIDIV2+theta+alpha);
-   v = mod2pi(t-phi);
-
-   length_rs = RADCURV*(t+MPI+v) + u;
-   return(length_rs);
-}
-
-double RSPlanner::cc_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v)
-{
-   double a,b,u1,theta,alpha,length_rs,va;
-
-   a = x-rs;
-   b = y+rc;
-   if ((fabs(a)&lt;EPS3) &amp;&amp; (fabs(b)&lt;EPS3))
-	   return(INFINITY);
-
-   u1 = sqrt(a*a+b*b);
-
-   if (u1&gt;RADCURVMUL4)
-	   return(INFINITY);
-
-   theta = my_atan2(b,a);
-
-   u = acos((8*SQRADCURV - u1*u1)/(8*SQRADCURV));
-
-   va = sin(u);
-
-   if (fabs(va)&lt;0.001)
-	   va = 0.0;
-
-   if ((fabs(va)&lt;0.001) &amp;&amp; (fabs(u1)&lt;0.001))
-	   return(INFINITY);
-
-   alpha = asin(RADCURVMUL2*va/u1);
-   t = mod2pi(MPIDIV2 - alpha + theta);
-   v = mod2pi(t-u-phi);
-
-   length_rs = RADCURV*(t+u+v);
-   return(length_rs);
-}
-
-double RSPlanner::csc2_ca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v)
-{
-   double a,b,u1,theta,alpha,length_rs;
-
-   a = x-rs;
-   b = y+rc;
-   u1 = sqrt(a*a+b*b);
-   if (u1 &lt; RADCURVMUL2) return(INFINITY);
-   theta = my_atan2(b,a);
-   u = sqrt(u1*u1-SQRADCURVMUL2) - RADCURVMUL2;
-   if (u &lt; 0.0) return(INFINITY);
-   alpha = my_atan2((u+RADCURVMUL2),RADCURVMUL2);
-   t = mod2pi(MPIDIV2+theta-alpha);
-   v = mod2pi(t-MPIDIV2-phi);
-
-   length_rs = RADCURV*(t+MPIDIV2+v) + u;
-   return(length_rs);
-}
-
-double RSPlanner::csc2_cb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v)
-{
-   double a,b,u1,theta,length_rs;
-
-   a = x+rs;
-   b = y-rc;
-   u1 = sqrt(a*a+b*b);
-   if (u1 &lt; RADCURVMUL2) return(INFINITY);
-   theta = my_atan2(b,a);
-   t = mod2pi(theta);
-   u = u1 - RADCURVMUL2;
-   v = mod2pi(-t-MPIDIV2+phi);
-
-   length_rs = RADCURV*(t+MPIDIV2+v) + u;
-   return(length_rs);
-}
-
-
-double RSPlanner::reed_shepp(const double&amp; x1,const double&amp; y1,const double&amp; t1,const double&amp; x2,const double&amp; y2,const double&amp; t2,int&amp; numero,double&amp; tr,double&amp; ur,double&amp; vr)
-{
-   double x,y,phi;
-   double tn,un,vn;
-
-   double vard,theta,alpha,dx,dy;
-   double sphi,cphi;
-   double ap,am,b1,b2;
-
-/* coordinate change */
-   dx = x2 - x1;
-   dy = y2 - y1;
-   theta = my_atan2(dy,dx);
-   alpha = theta - t1;
-   vard = sqrt(dx*dx+dy*dy);
-   x = cos(alpha)*vard;
-   y = sin(alpha)*vard;
-   phi = t2 - t1;
-
-   sphi = sin(phi);
-   cphi = cos(phi);
-
-   ap = RADCURV*sphi;
-   am = -RADCURV*sphi;
-   b1 = RADCURV*(cphi-1);
-   b2 = RADCURV*(cphi+1);
-
-/*   C | C | C   */
-   vector&lt;ConfigItem&gt; configList;
-   ConfigItem conf;
-
-   conf.length = (float)c_c_c(x,y,phi,ap,b1,tn,un,vn);
-   conf.num = 1;
-   conf.t = tn; conf.u = un; conf.v = vn;
-   if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_c_c(-x,y,-phi,am,b1,tn,un,vn);
-   conf.num = 2;
-   conf.t = tn; conf.u = un; conf.v = vn;
-   if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_c_c(x,-y,-phi,am,b1,tn,un,vn);
-   conf.num = 3;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_c_c(-x,-y,phi,ap,b1,tn,un,vn);
-   conf.num = 4;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-/*   C | C C   */
-
-   conf.length = (float)c_cc(x,y,phi,ap,b1,tn,un,vn);
-   conf.num = 5;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_cc(-x,y,-phi,am,b1,tn,un,vn);
-   conf.num = 6;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_cc(x,-y,-phi,am,b1,tn,un,vn);
-   conf.num = 7;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_cc(-x,-y,phi,ap,b1,tn,un,vn);
-   conf.num = 8;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-/*   C S C   */
-
-   conf.length = (float)csca(x,y,phi,ap,b1,tn,un,vn);
-   conf.num = 9;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)csca(x,-y,-phi,am,b1,tn,un,vn);
-   conf.num = 10;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)csca(-x,y,-phi,am,b1,tn,un,vn);
-   conf.num = 11;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)csca(-x,-y,phi,ap,b1,tn,un,vn);
-   conf.num = 12;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)cscb(x,y,phi,ap,b2,tn,un,vn);
-   conf.num = 13;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)cscb(x,-y,-phi,am,b2,tn,un,vn);
-   conf.num = 14;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)cscb(-x,y,-phi,am,b2,tn,un,vn);
-   conf.num = 15;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)cscb(-x,-y,phi,ap,b2,tn,un,vn);
-   conf.num = 16;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-/*   C Cu | Cu C   */
-
-   conf.length = (float)ccu_cuc(x,y,phi,ap,b2,tn,un,vn);
-   conf.num = 17;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)ccu_cuc(x,-y,-phi,am,b2,tn,un,vn);
-   conf.num = 18;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)ccu_cuc(-x,y,-phi,am,b2,tn,un,vn);
-   conf.num = 19;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)ccu_cuc(-x,-y,phi,ap,b2,tn,un,vn);
-   conf.num = 20;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-/*   C | Cu Cu | C   */
-
-   conf.length = (float)c_cucu_c(x,y,phi,ap,b2,tn,un,vn);
-   conf.num = 21;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_cucu_c(x,-y,-phi,am,b2,tn,un,vn);
-   conf.num = 22;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_cucu_c(-x,y,-phi,am,b2,tn,un,vn);
-   conf.num = 23;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_cucu_c(-x,-y,phi,ap,b2,tn,un,vn);
-   conf.num = 24;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-/*   C | C2 S C   */
-
-   conf.length = (float)c_c2sca(x,y,phi,ap,b1,tn,un,vn);
-   conf.num = 25;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_c2sca(x,-y,-phi,am,b1,tn,un,vn);
-   conf.num = 26;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_c2sca(-x,y,-phi,am,b1,tn,un,vn);
-   conf.num = 27;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_c2sca(-x,-y,phi,ap,b1,tn,un,vn);
-   conf.num = 28;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_c2scb(x,y,phi,ap,b2,tn,un,vn);
-   conf.num = 29;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_c2scb(x,-y,-phi,am,b2,tn,un,vn);
-   conf.num = 30;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_c2scb(-x,y,-phi,am,b2,tn,un,vn);
-   conf.num = 31;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_c2scb(-x,-y,phi,ap,b2,tn,un,vn);
-   conf.num = 32;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-/*   C | C2 S C2 | C   */
-
-   conf.length = (float)c_c2sc2_c(x,y,phi,ap,b2,tn,un,vn);
-   conf.num = 33;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_c2sc2_c(x,-y,-phi,am,b2,tn,un,vn);
-   conf.num = 34;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_c2sc2_c(-x,y,-phi,am,b2,tn,un,vn);
-   conf.num = 35;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)c_c2sc2_c(-x,-y,phi,ap,b2,tn,un,vn);
-   conf.num = 36;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-/*   C C | C   */
-
-   conf.length = (float)cc_c(x,y,phi,ap,b1,tn,un,vn);
-   conf.num = 37;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)cc_c(x,-y,-phi,am,b1,tn,un,vn);
-   conf.num = 38;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)cc_c(-x,y,-phi,am,b1,tn,un,vn);
-   conf.num = 39;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)cc_c(-x,-y,phi,ap,b1,tn,un,vn);
-   conf.num = 40;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-/*   C S C2 | C   */
-
-   conf.length = (float)csc2_ca(x,y,phi,ap,b1,tn,un,vn);
-   conf.num = 41;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)csc2_ca(x,-y,-phi,am,b1,tn,un,vn);
-   conf.num = 42;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)csc2_ca(-x,y,-phi,am,b1,tn,un,vn);
-   conf.num = 43;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)csc2_ca(-x,-y,phi,ap,b1,tn,un,vn);
-   conf.num = 44;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)csc2_cb(x,y,phi,ap,b2,tn,un,vn);
-   conf.num = 45;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)csc2_cb(x,-y,-phi,am,b2,tn,un,vn);
-   conf.num = 46;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)csc2_cb(-x,y,-phi,am,b2,tn,un,vn);
-   conf.num = 47;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-   conf.length = (float)csc2_cb(-x,-y,phi,ap,b2,tn,un,vn);
-   conf.num = 48;
-      conf.t = tn; conf.u = un; conf.v = vn;
-      if(conf.length &gt; 0) configList.push_back(conf);
-
-
-	  if(configList.size() &gt; 0)
-	  {
-		   conf = configList.at(0);
-		  for(unsigned int i=0; i&lt; configList.size(); i++)
-		  {
-			  if(configList.at(i).length &gt; 0 &amp;&amp;  configList.at(i).length &lt; conf.length)
-			  {
-				  conf = configList.at(i);
-			  }
-		  }
-	  }
-
-   tr = conf.t; ur = conf.u; vr = conf.v;
-   numero = conf.num;
-   return(conf.length);
-}
-
-double RSPlanner::min_length_rs(const double&amp; x1,const double&amp; y1,const double&amp; t1,const double&amp; x2,const double&amp; y2,const double&amp; t2,int&amp; numero,double&amp; t,double&amp; u,double&amp; v)
-{
-   double length_rs;
-
-   if ((fabs(x1-x2)&lt;EPS1) &amp;&amp; (fabs(y1-y2)&lt;EPS1) &amp;&amp; (fabs(t1-t2)&lt;EPS1))
-	   length_rs = 0.0;
-   else
-	   length_rs = reed_shepp(x1,y1,t1,x2,y2,t2,numero,t,u,v);
-
-   return(length_rs);
-}
-
-int RSPlanner::fct_curve(const int&amp; ty,const int&amp; orientation,const double&amp; val,double&amp; x1,double&amp; y1,double&amp; t1,const double&amp; delta,vector&lt;WayPoint&gt;&amp; path,int n)
-{
-   int i;
-   double va1,va2,newval,incrt,remain;
-   double center_x,center_y;
-   double x2,y2,t2;
-   int nnew;
-   double local_delta = delta;
-
-   if (ty == 3) //TODO check this if the planner doesn't work
-   {
-      if (fabs(val/RADCURV)&lt;EPS4) return(0);
-   else
-      if (fabs(val)&lt;EPS4) return(0);
-   }
-
-   if(path.size()==1)
-   {
-	   if(orientation == -1) path.at(0).bDir = BACKWARD_DIR;
-	   	else path.at(0).bDir = FORWARD_DIR;
-   }
-
-   WayPoint p;
-
-   switch(ty)
-     {
-      case 1 : /* circular arc toward the right */
-      {
-    	  local_delta = local_delta/RADCURV;
-			center_x = x1 + RADCURV*sin(t1);
-			center_y = y1 - RADCURV*cos(t1);
-			va1 = t1+MPIDIV2;
-
-			if (orientation == 1)
-				va2 = va1-val;
-			else
-				va2 = va1+val;
-
-			x2 = center_x + RADCURV*cos(va2);
-			y2 = center_y + RADCURV*sin(va2);
-			t2 = t1 - orientation*val;
-
-			nnew = val/local_delta;
-
-			remain = val - nnew*local_delta;
-
-			nnew = nnew+n;
-
-			if (orientation == -1)
-				local_delta = -local_delta;
-
-			incrt = 0;
-			for (i = n; i&lt;nnew; i++)
-			{
-			   va1 = va1-local_delta;
-//			   *(pathx+i) = center_x + RADCURV*cos(va1);
-//			   *(pathy+i) = center_y + RADCURV*sin(va1);
-
-			   incrt = incrt - local_delta;
-//			   *(patht+i) = mod2pi(t1 + incrt);
-			   p.pos.x = center_x + RADCURV*cos(va1);
-			   p.pos.y = center_y + RADCURV*sin(va1);
-			   p.pos.a = mod2pi(t1 + incrt);
-			   if(orientation == -1) p.bDir = BACKWARD_DIR;
-			   else p.bDir = FORWARD_DIR;
-			   path.push_back(p);
-			}
-			n = nnew;
-			if (remain &gt; fabs(local_delta)/5.)
-			{
-				p = WayPoint(x2, y2, 0, mod2pi(t2));
-				if(orientation == -1) p.bDir = BACKWARD_DIR;
-				else p.bDir = FORWARD_DIR;
-				path.push_back(p);
-//			   *(pathx+nnew) = x2;
-//			   *(pathy+nnew) = y2;
-//			   *(patht+nnew) = mod2pi(t2);
-			   n++;
-			}
-			else
-			{
-				p = WayPoint(x2, y2,0, mod2pi(t2));
-				if(orientation == -1) p.bDir = BACKWARD_DIR;
-				else p.bDir = FORWARD_DIR;
-				path.at(path.size()-1) = p;
-//			   *(pathx+nnew-1) = x2;
-//			   *(pathy+nnew-1) = y2;
-//			   *(patht+nnew-1) = mod2pi(t2);
-			}
-		}
-        break;
-
-      case 2 : /* circular arc toward the left */
-      {
-    	  local_delta = local_delta/RADCURV;
-        center_x = x1 - RADCURV*sin(t1);
-        center_y = y1 + RADCURV*cos(t1);
-        va1 = t1-MPIDIV2;
-        if (orientation == 1)
-        	va2 = va1+val;
-        else
-        	va2 = va1-val;
-
-        x2 = center_x + RADCURV*cos(va2);
-        y2 = center_y + RADCURV*sin(va2);
-        t2 = t1 + orientation*val;
-
-        nnew = val/local_delta;
-        remain = val - nnew*local_delta;
-        nnew = nnew+n;
-
-        if (orientation == -1) local_delta = -local_delta;
-        incrt = 0;
-        for (i = n; i&lt;nnew; i++)
-	  {
-           va1 = va1+local_delta;
-           incrt = incrt + local_delta;
-//           *(pathx+i) = center_x + RADCURV*cos(va1);
-//           *(pathy+i) = center_y + RADCURV*sin(va1);
-//           *(patht+i) = mod2pi(t1 + incrt);
-           p.pos.x = center_x + RADCURV*cos(va1);
-		   p.pos.y = center_y + RADCURV*sin(va1);
-		   p.pos.a = mod2pi(t1 + incrt);
-		   if(orientation == -1) p.bDir = BACKWARD_DIR;
-		   else p.bDir = FORWARD_DIR;
-		   path.push_back(p);
-	  }
-        n = nnew;
-        if (remain &gt; fabs(local_delta)/5.)
-	  {
-//           *(pathx+nnew) = x2;
-//           *(pathy+nnew) = y2;
-//           *(patht+nnew) = mod2pi(t2);
-        	p = WayPoint(x2, y2, 0, mod2pi(t2));
-			if(orientation == -1) p.bDir = BACKWARD_DIR;
-			else p.bDir = FORWARD_DIR;
-			path.push_back(p);
-           n++;
-	 }
-        else
-	  {
-//           *(pathx+nnew-1) = x2;
-//           *(pathy+nnew-1) = y2;
-//           *(patht+nnew-1) = mod2pi(t2);
-        	p = WayPoint(x2, y2,0, mod2pi(t2));
-			if(orientation == -1) p.bDir = BACKWARD_DIR;
-			else p.bDir = FORWARD_DIR;
-			path.at(path.size()-1) = p;
-	  }
-      }
-        break;
-
-      case 3 : /* straight line */
-        x2 = x1 + orientation*val*cos(t1);
-        y2 = y1 + orientation*val*sin(t1);
-        t1 = mod2pi(t1);
-        t2 = t1;
-
-        va1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
-        i = va1/PATHDENSITY;
-        remain = va1 - i*PATHDENSITY;
-        nnew = n+i;
-        newval = PATHDENSITY;
-        va1 = orientation*cos(t1);
-        va2 = orientation*sin(t1);
-        for (i = n; i&lt;nnew; i++)
-	  {
-//           *(pathx+i) = x1 + va1*newval;
-//           *(pathy+i) = y1 + va2*newval;
-//           *(patht+i) = t1;
-        	p = WayPoint(x1 + va1*newval, y1 + va2*newval,0, t1);
-			if(orientation == -1) p.bDir = BACKWARD_DIR;
-			else p.bDir = FORWARD_DIR;
-			path.push_back(p);
-           newval = newval + PATHDENSITY;
-
-	  }
-        n = nnew;
-        if (remain &gt; 0.04)
-	  {
-//            *(pathx+nnew) = x2;
-//            *(pathy+nnew) = y2;
-//            *(patht+nnew) = t2;
-        	p = WayPoint(x2, y2,0, t2);
-			if(orientation == -1) p.bDir = BACKWARD_DIR;
-			else p.bDir = FORWARD_DIR;
-			path.push_back(p);
-            n = nnew+1;
-	  }
-        else
-	  {
-//            *(pathx+nnew-1) = x2;
-//            *(pathy+nnew-1) = y2;
-//            *(patht+nnew-1) = t2;
-        	p = WayPoint(x2, y2,0, t2);
-			if(orientation == -1) p.bDir = BACKWARD_DIR;
-			else p.bDir = FORWARD_DIR;
-			path.at(path.size()-1) = p;
-            n = nnew;
-	  }
-     }
-
-   x1 = x2;
-   y1 = y2;
-   t1 = t2;
-
-   return(n);
-}
-
-int RSPlanner::constRS(int num,double t,double u,double v,double x1,double y1,double t1,double delta,vector&lt;WayPoint&gt;&amp; path)
-{
-   int left,right,straight,fwd,bwd;
-   int n;
-
-//   *pathx = x1;
-//   *pathy = y1;
-//   *patht = t1;
-//
-   path.push_back(WayPoint(x1,y1,0,t1));
-   n = 1;
-
-   right = 1; left = 2; straight = 3;
-   fwd = 1; bwd = -1;
-
-   switch(num)
-     {
-
-/*   C | C | C   */
-
-       case 1 :
-         n = fct_curve(left,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 2 :
-         n = fct_curve(left,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 3 :
-         n = fct_curve(right,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 4 :
-         n = fct_curve(right,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-/*   C | C C   */
-
-       case 5 :
-         n = fct_curve(left,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 6 :
-         n = fct_curve(left,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 7 :
-         n = fct_curve(right,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 8 :
-         n = fct_curve(right,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-/*   C S C   */
-
-       case 9 :
-         n = fct_curve(left,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 10 :
-         n = fct_curve(right,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 11 :
-         n = fct_curve(left,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 12 :
-         n = fct_curve(right,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 13 :
-         n = fct_curve(left,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 14 :
-         n = fct_curve(right,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 15 :
-         n = fct_curve(left,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 16 :
-         n = fct_curve(right,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-/*   C Cu | Cu C   */
-
-       case 17 :
-         n = fct_curve(left,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 18 :
-         n = fct_curve(right,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 19 :
-         n = fct_curve(left,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 20 :
-         n = fct_curve(right,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-/*   C | Cu Cu | C   */
-
-       case 21 :
-         n = fct_curve(left,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 22 :
-         n = fct_curve(right,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 23 :
-         n = fct_curve(left,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 24 :
-         n = fct_curve(right,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-/*   C | C2 S C   */
-
-       case 25 :
-         n = fct_curve(left,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,bwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(straight,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 26 :
-         n = fct_curve(right,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,bwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(straight,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 27 :
-         n = fct_curve(left,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,fwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(straight,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 28 :
-         n = fct_curve(right,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,fwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(straight,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 29 :
-         n = fct_curve(left,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,bwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(straight,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 30 :
-         n = fct_curve(right,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,bwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(straight,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 31 :
-         n = fct_curve(left,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,fwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(straight,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 32 :
-         n = fct_curve(right,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,fwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(straight,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-/*   C | C2 S C2 | C   */
-
-       case 33 :
-         n = fct_curve(left,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,bwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(straight,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 34 :
-         n = fct_curve(right,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,bwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(straight,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 35 :
-         n = fct_curve(left,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,fwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(straight,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 36 :
-         n = fct_curve(right,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,fwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(straight,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-/*   C C | C   */
-
-       case 37 :
-         n = fct_curve(left,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 38 :
-         n = fct_curve(right,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 39 :
-         n = fct_curve(left,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(right,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 40 :
-         n = fct_curve(right,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(left,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-/*   C S C2 | C   */
-
-       case 41 :
-         n = fct_curve(left,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 42 :
-         n = fct_curve(right,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 43 :
-         n = fct_curve(left,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 44 :
-         n = fct_curve(right,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 45 :
-         n = fct_curve(left,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 46 :
-         n = fct_curve(right,fwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,fwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 47 :
-         n = fct_curve(left,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,bwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-
-       case 48 :
-         n = fct_curve(right,bwd,t,x1,y1,t1,delta,path,1);
-         n = fct_curve(straight,bwd,u,x1,y1,t1,delta,path,n);
-         n = fct_curve(right,bwd,MPIDIV2,x1,y1,t1,delta,path,n);
-         n = fct_curve(left,fwd,v,x1,y1,t1,delta,path,n);
-         break;
-       default:
-    	   break;
-         //printf("Error: RS curve type %d unknown\n",num);
-     }
-
-   return n;
-}
-
-} /* namespace PlannerZNS */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\TrajectoryCosts.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\TrajectoryCosts.cpp" added_lines="13" deleted_lines="104">
				<diff>@@ -1,17 +1,15 @@
-/*
- * TrajectoryCosts.cpp
- *
- *  Created on: Dec 14, 2016
- *      Author: user
- */
+/// \file TrajectoryCosts.cpp
+/// \brief Calculate collision costs for roll out trajectory for free trajectory evaluation for dp_planner
+/// \author Hatem Darweesh
+/// \date Dec 14, 2016
 
 #include "op_planner/TrajectoryCosts.h"
 #include "op_planner/MatrixOperations.h"
+#include "float.h"
 
 namespace PlannerHNS
 {
 
-
 TrajectoryCosts::TrajectoryCosts()
 {
 	m_PrevCostIndex = -1;
@@ -77,8 +75,8 @@ TrajectoryCost TrajectoryCosts::DoOneStep(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt;
 	NormalizeCosts(m_TrajectoryCosts);
 
 	int smallestIndex = -1;
-	double smallestCost = 9999999999;
-	double smallestDistance = 9999999999;
+	double smallestCost = DBL_MAX;
+	double smallestDistance = DBL_MAX;
 	double velo_of_next = 0;
 
 	//cout &lt;&lt; "Trajectory Costs Log : CurrIndex: " &lt;&lt; currIndex &lt;&lt; " --------------------- " &lt;&lt; endl;
@@ -202,7 +200,7 @@ void TrajectoryCosts::CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost
 						longitudinalDist = -longitudinalDist;
 
 					double direct_distance = hypot(obj_info.perp_point.pos.y-contourPoints.at(icon).pos.y, obj_info.perp_point.pos.x-contourPoints.at(icon).pos.x);
-					if(contourPoints.at(icon).v &lt; 0.1 &amp;&amp; direct_distance &gt; (m_LateralSkipDistance+contourPoints.at(icon).cost))
+					if(contourPoints.at(icon).v &lt; params.minSpeed &amp;&amp; direct_distance &gt; (m_LateralSkipDistance+contourPoints.at(icon).cost))
 					{
 						skip_id = contourPoints.at(icon).id;
 						continue;
@@ -236,8 +234,11 @@ void TrajectoryCosts::CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost
 						trajectoryCosts.at(iCostIndex).bBlocked = true;
 
 
-					trajectoryCosts.at(iCostIndex).lateral_cost += 1.0/lateralDist;
-					trajectoryCosts.at(iCostIndex).longitudinal_cost += 1.0/fabs(longitudinalDist);
+					if(lateralDist != 0)
+						trajectoryCosts.at(iCostIndex).lateral_cost += 1.0/lateralDist;
+
+					if(longitudinalDist != 0)
+						trajectoryCosts.at(iCostIndex).longitudinal_cost += 1.0/fabs(longitudinalDist);
 
 
 					if(longitudinalDist &gt;= -critical_long_front_distance &amp;&amp; longitudinalDist &lt; trajectoryCosts.at(iCostIndex).closest_obj_distance)
@@ -385,97 +386,5 @@ bool TrajectoryCosts::ValidateRollOutsInput(const vector&lt;vector&lt;vector&lt;WayPoint&gt;
 
 	return true;
 }
-
-
-bool TrajectoryCosts::CalculateIntersectionVelocities(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::DetectedObject&amp; obj, const WayPoint&amp; currState,const CAR_BASIC_INFO&amp; carInfo, WayPoint&amp; collisionPoint)
-{
-	bool bCollisionDetected = false;
-	m_CollisionPoints.clear();
-
-	for(unsigned int k = 0; k &lt; obj.predTrajectories.size(); k++)
-	{
-		for(unsigned int j = 0; j &lt; obj.predTrajectories.at(k).size(); j++)
-		{
-			bool bCollisionFound =false;
-			for(unsigned int i = 0; i &lt; path.size(); i++)
-			{
-				if(path.at(i).timeCost &gt; 0.0)
-				{
-					double collision_distance = hypot(path.at(i).pos.x-obj.predTrajectories.at(k).at(j).pos.x, path.at(i).pos.y-obj.predTrajectories.at(k).at(j).pos.y);
-					double contact_distance = hypot(currState.pos.x - path.at(i).pos.x,currState.pos.y - path.at(i).pos.y);
-					if(collision_distance &lt;= carInfo.width  &amp;&amp; fabs(path.at(i).timeCost - obj.predTrajectories.at(k).at(j).timeCost)&lt;3.0)
-					{
-						//m_CollisionPoints.push_back(path.at(i));
-						collisionPoint = path.at(i);
-						return true;
-//						double a = UtilityHNS::UtilityH::AngleBetweenTwoAnglesPositive(path.at(i).pos.a, obj.predTrajectories.at(k).at(j).pos.a)*RAD2DEG;
-//						if(a &lt; 10)
-//							path.at(i).v = obj.center.v;
-//						else
-//							path.at(i).v = 0;
-//						//obj.predTrajectories.at(k).at(j).collisionCost = 1;
-						bCollisionFound = true;
-						bCollisionDetected = true;
-						break;
-					}
-				}
-			}
-
-			if(bCollisionFound)
-				break;
-		}
-	}
-
-	return bCollisionDetected;
-}
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\TrajectoryPrediction.cpp" new_path="" added_lines="0" deleted_lines="125">
				<diff>@@ -1,125 +0,0 @@
-/*
- * TrajectoryPrediction.cpp
- *
- *  Created on: Aug 8, 2017
- *      Author: user
- */
-
-#include "op_planner/TrajectoryPrediction.h"
-#include "op_planner/PlannerH.h"
-#include "op_planner/MappingHelpers.h"
-
-namespace PlannerHNS
-{
-
-TrajectoryPrediction::TrajectoryPrediction()
-{
-	m_MaxCollisionPredictionTime = 6;
-}
-
-TrajectoryPrediction::~TrajectoryPrediction()
-{
-}
-
-void TrajectoryPrediction::DoOneStep(PlannerHNS::RoadNetwork&amp; map, const PlannerHNS::VehicleState&amp; vstatus, const PlannerHNS::WayPoint&amp; currState, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; currPath, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list, const double&amp; minfDist)
-{
-	double predTime = PredictTimeCostForTrajectory(currPath, vstatus, currState, minfDist);
-	if(predTime &gt; m_MaxCollisionPredictionTime)
-		predTime = m_MaxCollisionPredictionTime;
-
-	for(unsigned int i = 0; i &lt; obj_list.size(); i++)
-	{
-		if(obj_list.at(i).bVelocity &amp;&amp; obj_list.at(i).center.v &gt; 0.1)
-		{
-			obj_list.at(i).predTrajectories.clear();
-			PredictObstacleTrajectory(map, obj_list.at(i), predTime, obj_list.at(i).predTrajectories, minfDist);
-		}
-		else
-		{
-			obj_list.at(i).bVelocity = false;
-		}
-	}
-}
-
-double TrajectoryPrediction::PredictTimeCostForTrajectory(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::VehicleState&amp; vstatus, const PlannerHNS::WayPoint&amp; currState, const double&amp; minfDist)
-{
-
-	//1- Calculate time prediction for each trajectory
-	if(path.size() == 0) return 0;
-	double accum_time = 0;
-	double endDistance = minfDist;
-
-	for(unsigned int i = 0 ; i &lt; path.size(); i++)
-	{
-		path.at(i).collisionCost = 0;
-		path.at(i).timeCost = -1;
-	}
-
-	RelativeInfo info;
-	PlanningHelpers::GetRelativeInfo(path, currState, info);
-	double total_distance = 0;
-	path.at(info.iFront).timeCost = 0;
-	if(info.iFront == 0 ) info.iFront++;
-	for(unsigned int i=info.iFront; i&lt;path.size(); i++)
-	{
-		total_distance += hypot(path.at(i).pos.x- path.at(i-1).pos.x,path.at(i).pos.y- path.at(i-1).pos.y);
-		if(vstatus.speed &gt; 0.1 &amp;&amp; total_distance &gt; 0.1)
-			accum_time = total_distance/vstatus.speed;
-
-		path.at(i).timeCost = accum_time;
-		if(total_distance &gt; endDistance)
-			break;
-	}
-
-	return accum_time;
-}
-
-void TrajectoryPrediction::PredictObstacleTrajectory(PlannerHNS::RoadNetwork&amp; map, const DetectedObject&amp; obj, const double&amp; predTime, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths,const double&amp; minfDist)
-{
-	PlannerHNS::PlanningParams planningDefaultParams;
-	planningDefaultParams.rollOutNumber = 0;
-	planningDefaultParams.microPlanDistance = predTime*obj.center.v;
-	if(planningDefaultParams.microPlanDistance &gt; minfDist)
-		planningDefaultParams.microPlanDistance = minfDist;
-
-	planningDefaultParams.pathDensity = 1;
-
-	//cout &lt;&lt; "Pred Time: " &lt;&lt; predTime &lt;&lt; ", Object Speed: " &lt;&lt;obj.center.v &lt;&lt; endl;
-	WayPoint* pClosestWP =  MappingHelpers::GetClosestWaypointFromMap(obj.center, map, obj.bDirection);
-	PlannerHNS::PlannerH planner;
-
-	if(planningDefaultParams.microPlanDistance &gt; 0)
-	{
-		WayPoint obj_center = obj.center;
-		obj_center.pos.a = pClosestWP-&gt;pos.a;
-		planner.PredictPlanUsingDP(obj_center, pClosestWP, planningDefaultParams.microPlanDistance, paths, false);
-		for(unsigned int j=0; j &lt; paths.size(); j++)
-		{
-			PlanningHelpers::FixPathDensity(paths.at(j), planningDefaultParams.pathDensity);
-			PlanningHelpers::CalcAngleAndCost(paths.at(j));
-		}
-
-		for(unsigned int j=0; j &lt; paths.size(); j++)
-		{
-			if(paths.at(j).size() &gt; 0)
-			{
-				double timeDelay = 0;
-				double total_distance = 0;
-				paths.at(j).at(0).timeCost = 0;
-				paths.at(j).at(0).v = obj.center.v;
-				for(unsigned int i=1; i&lt;paths.at(j).size(); i++)
-				{
-					paths.at(j).at(i).v = obj.center.v;
-					total_distance += hypot(paths.at(j).at(i).pos.y- paths.at(j).at(i-1).pos.y, paths.at(j).at(i).pos.x- paths.at(j).at(i-1).pos.x);
-					if(obj.center.v &gt; 0.1 &amp;&amp; total_distance &gt; 0.1)
-						timeDelay = total_distance/obj.center.v;
-					paths.at(j).at(i).timeCost = timeDelay;
-					if(total_distance &gt; planningDefaultParams.microPlanDistance)
-						break;
-				}
-			}
-		}
-	}
-}
-
-} /* namespace PlannerHNS */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_ros_helpers\PolygonGenerator.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_ros_helpers\PolygonGenerator.h" added_lines="7" deleted_lines="9">
				<diff>@@ -1,12 +1,10 @@
-/*
- * PolygonGenerator.h
- *
- *  Created on: Nov 2, 2016
- *      Author: ai-driver
- */
+/// \file  PolygonGenerator.h
+/// \brief Generate convex hull from point cloud cluster of detected object
+/// \author Hatem Darweesh
+/// \date Nov 2, 2016
 
-#ifndef POLYGONGENERATOR_H_
-#define POLYGONGENERATOR_H_
+#ifndef OP_POLYGONGENERATOR_H_
+#define OP_POLYGONGENERATOR_H_
 
 #include "op_planner/RoadNetwork.h"
 #include &lt;sensor_msgs/PointCloud2.h&gt;
@@ -93,4 +91,4 @@ public:
 
 } /* namespace PlannerXNS */
 
-#endif /* POLYGONGENERATOR_H_ */
+#endif /* OP_POLYGONGENERATOR_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_ros_helpers\op_RosHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_ros_helpers\op_RosHelpers.h" added_lines="43" deleted_lines="35">
				<diff>@@ -1,12 +1,10 @@
-/*
- * RosHelpers.h
- *
- *  Created on: Jun 30, 2016
- *      Author: ai-driver
- */
+/// \file  RosHelpers.h
+/// \brief Helper functions for rviz visualization
+/// \author Hatem Darweesh
+/// \date Jun 30, 2016
 
-#ifndef ROSHELPERS_H_
-#define ROSHELPERS_H_
+#ifndef OP_ROSHELPERS_H_
+#define OP_ROSHELPERS_H_
 
 #include &lt;ros/ros.h&gt;
 #include "op_planner/RoadNetwork.h"
@@ -174,29 +172,22 @@ class RosHelpers
 public:
 	RosHelpers();
 	virtual ~RosHelpers();
-	/**
-	 * Used
-	 */
+
 	static void GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform);
 
-	/**
-	 * Used
-	 */
 	static void ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const double&amp; car_width,
 			const double&amp; car_length, const autoware_msgs::CloudClusterArray&amp; clusters,
 			std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; impObstacles, const double max_obj_size, const double&amp; min_obj_size, const double&amp; detection_radius,
 			const int&amp; n_poly_quarters,const double&amp; poly_resolution, int&amp; nOriginalPoints, int&amp; nContourPoints);
 
-
-	/**
-	 * Used
-	 */
 	static visualization_msgs::Marker CreateGenMarker(const double&amp; x, const double&amp; y, const double&amp; z,const double&amp; a,
 			const double&amp; r, const double&amp; g, const double&amp; b, const double&amp; scale, const int&amp; id, const std::string&amp; ns, const int&amp; type);
 
-	/**
-	 * Used
-	 */
+	static void InitMatchingMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; connections);
+
+	static void ConvertMatchingMarkers(const std::vector&lt;std::pair&lt;PlannerHNS::WayPoint, PlannerHNS::WayPoint&gt; &gt;&amp; match_list,
+			visualization_msgs::MarkerArray&amp; tracked_traj_d, visualization_msgs::MarkerArray&amp; tracked_traj, int start_id=0);
+
 	static void InitMarkers(const int&amp; nMarkers,
 			visualization_msgs::MarkerArray&amp; centers,
 			visualization_msgs::MarkerArray&amp; dirs,
@@ -204,14 +195,6 @@ public:
 			visualization_msgs::MarkerArray&amp; polygons,
 			visualization_msgs::MarkerArray&amp; trajectories);
 
-	static void InitMatchingMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; connections);
-
-	static void ConvertMatchingMarkers(const std::vector&lt;std::pair&lt;PlannerHNS::WayPoint, PlannerHNS::WayPoint&gt; &gt;&amp; match_list,
-			visualization_msgs::MarkerArray&amp; tracked_traj_d, visualization_msgs::MarkerArray&amp; tracked_traj, int start_id=0);
-
-	/**
-	 * Used
-	 */
 	static int ConvertTrackedObjectsMarkers(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
 			visualization_msgs::MarkerArray&amp; centers_d,
 			visualization_msgs::MarkerArray&amp; dirs_d,
@@ -224,14 +207,28 @@ public:
 			visualization_msgs::MarkerArray&amp; polygons,
 			visualization_msgs::MarkerArray&amp; tracked_traj);
 
-	/**
-	 * Used
-	 */
 	static void CreateCircleMarker(const PlannerHNS::WayPoint&amp; _center, const double&amp; radius, const int&amp; start_id, visualization_msgs::Marker&amp; circle_points);
 
+	static void InitPredMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; paths);
+
+	static void InitCurbsMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; curbs);
+
+	static void ConvertPredictedTrqajectoryMarkers(std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths,visualization_msgs::MarkerArray&amp; path_markers, visualization_msgs::MarkerArray&amp; path_markers_d);
+
+	static void ConvertCurbsMarkers(const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; curbs, visualization_msgs::MarkerArray&amp; curbs_markers, visualization_msgs::MarkerArray&amp; curbs_markers_d);
 
 	static void TrajectoriesToMarkers(const std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt;&amp; paths, visualization_msgs::MarkerArray&amp; markerArray);
 
+	static void TrajectoriesToColoredMarkers(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths,const std::vector&lt;PlannerHNS::TrajectoryCost&gt;&amp; traj_costs, const int&amp; iClosest, visualization_msgs::MarkerArray&amp; markerArray);
+
+	static void InitCollisionPointsMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; col_points);
+
+	static void ConvertCollisionPointsMarkers(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; col_pointss, visualization_msgs::MarkerArray&amp; collision_markers, visualization_msgs::MarkerArray&amp; collision_markers_d);
+
+	static void InitPredParticlesMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; paths);
+
+	static void ConvertParticles(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; points, visualization_msgs::MarkerArray&amp; part_mkrs, visualization_msgs::MarkerArray&amp; part_markers_d);
+
 	static void ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
 				autoware_msgs::lane &amp; trajectory);
 
@@ -249,31 +246,42 @@ public:
 	static void ConvertFromAutowareBoundingBoxObstaclesToPlannerH(const jsk_recognition_msgs::BoundingBoxArray&amp; detectedObstacles,
 			std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; impObstacles);
 
-
-
 	static void ConvertFromPlannerObstaclesToAutoware(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
 			visualization_msgs::MarkerArray&amp; detectedPolygons);
 
 	static void ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, autoware_msgs::lane&amp; trajectory , const unsigned int&amp; iStart = 0);
+
 	static void ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path, autoware_msgs::lane&amp; trajectory);
+
 	static void ConvertFromAutowareLaneToLocalLane(const autoware_msgs::lane&amp; trajectory, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path);
+
 	static void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const autoware_msgs::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray);
+
 	static void createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array , visualization_msgs::MarkerArray&amp; markerArray);
+
 	static void createGlobalLaneArrayOrientationMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array , visualization_msgs::MarkerArray&amp; markerArray);
+
 	static void GetTrafficLightForVisualization(std::vector&lt;PlannerHNS::TrafficLight&gt;&amp; lights, visualization_msgs::MarkerArray&amp; markerArray);
 
 	static void ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(const autoware_msgs::DetectedObject&amp; det_obj, PlannerHNS::DetectedObject&amp; obj);
+
 	static void ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(const PlannerHNS::DetectedObject&amp; det_obj, const bool&amp; bSimulationMode, autoware_msgs::DetectedObject&amp; obj);
 
 	static PlannerHNS::SHIFT_POS ConvertShiftFromAutowareToPlannerH(const PlannerHNS::AUTOWARE_SHIFT_POS&amp; shift);
+
 	static PlannerHNS::AUTOWARE_SHIFT_POS ConvertShiftFromPlannerHToAutoware(const PlannerHNS::SHIFT_POS&amp; shift);
+
 	static PlannerHNS::AutowareBehaviorState ConvertBehaviorStateFromPlannerHToAutoware(const PlannerHNS::BehaviorState&amp; beh);
+
 	static std::string GetBehaviorNameFromCode(const PlannerHNS::STATE_TYPE&amp; behState);
 
-	static void VisualizeBehaviorState(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::BehaviorState&amp; beh, const bool&amp; bGreenLight,const int&amp; avoidDirection, visualization_msgs::Marker&amp; behaviorMarker);
+	static void VisualizeBehaviorState(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::BehaviorState&amp; beh, const bool&amp; bGreenLight, const int&amp; avoidDirection, visualization_msgs::Marker&amp; behaviorMarker, std::string ns,double size_factor = 1);
 
 	static void UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::RoadNetwork&amp; out_map);
 
+	static void GetIndicatorArrows(const PlannerHNS::WayPoint&amp; center, const double&amp; width,const double&amp; length, const PlannerHNS::LIGHT_INDICATOR&amp; indicator, const int&amp; id,visualization_msgs::MarkerArray&amp; markerArray);
+
+	static void TTC_PathRviz(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, visualization_msgs::MarkerArray&amp; markerArray);
 };
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\PolygonGenerator.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\PolygonGenerator.cpp" added_lines="4" deleted_lines="6">
				<diff>@@ -1,9 +1,7 @@
-/*
- * PolygonGenerator.cpp
- *
- *  Created on: Nov 2, 2016
- *      Author: ai-driver
- */
+/// \file  PolygonGenerator.cpp
+/// \brief Generate convex hull from point cloud cluster of detected object
+/// \author Hatem Darweesh
+/// \date Nov 2, 2016
 
 #include "op_ros_helpers/PolygonGenerator.h"
 #include "op_planner/PlanningHelpers.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\op_RosHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\op_RosHelpers.cpp" added_lines="348" deleted_lines="17">
				<diff>@@ -1,9 +1,7 @@
-/*
- * RosHelpers.cpp
- *
- *  Created on: Jun 30, 2016
- *      Author: ai-driver
- */
+/// \file  RosHelpers.cpp
+/// \brief Helper functions for rviz visualization
+/// \author Hatem Darweesh
+/// \date Jun 30, 2016
 
 #include "op_ros_helpers/op_RosHelpers.h"
 
@@ -300,6 +298,145 @@ void RosHelpers::CreateCircleMarker(const PlannerHNS::WayPoint&amp; _center, const d
 	}
 }
 
+void RosHelpers::InitPredMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; paths)
+{
+	paths.markers.clear();
+	for(int i=0; i&lt;nMarkers; i++)
+	{
+		visualization_msgs::Marker mkr = CreateGenMarker(0,0,0,0,1,1,1,1,i,"Predicted_Trajectories", visualization_msgs::Marker::LINE_STRIP);
+		paths.markers.push_back(mkr);
+	}
+}
+
+void RosHelpers::InitCurbsMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; curbs)
+{
+	curbs.markers.clear();
+	for(int i=0; i&lt;nMarkers; i++)
+	{
+		visualization_msgs::Marker mkr = CreateGenMarker(0,0,0,0,1,1,1,1,i,"map_detected_curbs", visualization_msgs::Marker::SPHERE);
+		curbs.markers.push_back(mkr);
+	}
+}
+
+void RosHelpers::ConvertPredictedTrqajectoryMarkers(std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths,visualization_msgs::MarkerArray&amp; path_markers, visualization_msgs::MarkerArray&amp; path_markers_d)
+{
+
+	path_markers = path_markers_d;
+	for(unsigned int i = 0; i &lt; paths.size(); i++)
+	{
+		double additional_z = 0;
+		double basic_color = 0.5;
+		double prop = 1.0;
+		bool bCurrent = false;
+//		if(paths.at(i).size()&gt;0)
+//		{
+//
+//			prop = paths.at(i).at(0).collisionCost;
+//			if(prop &lt; 0.5)
+//				continue;
+//
+//			if(prop &gt; 0.5)
+//			{
+//				additional_z = prop;
+//				bCurrent = true;
+//			}
+//		}
+
+
+//		double r = 0, g = 0, b = 0;
+//		if(bCurrent == true)
+//		{
+//			r = basic_color+additional_z;
+//			g = basic_color+additional_z;
+//			b = basic_color+additional_z;
+//		}
+//		else if(i == 0)
+//		{
+//			r = basic_color+additional_z;
+//		}
+//		else if(i == 1)
+//		{
+//			g = basic_color+additional_z;
+//		}
+//		else if(i == 2)
+//		{
+//			b = basic_color+additional_z;
+//		}
+//		else if(i == 3)
+//		{
+//			r = basic_color+additional_z;
+//			b = basic_color+additional_z;
+//		}
+//		else
+//		{
+//			g = basic_color+additional_z;
+//			b = basic_color+additional_z;
+//		}
+//
+//		visualization_msgs::Marker path_mkr = CreateGenMarker(0,0,0,0,r,g,b,0.1,i,"Predicted_Trajectories", visualization_msgs::Marker::LINE_STRIP);
+
+		visualization_msgs::Marker path_mkr = CreateGenMarker(0,0,0,0,1.0*prop,0.1*prop,0.1*prop,0.1,i,"Predicted_Trajectories", visualization_msgs::Marker::LINE_STRIP);
+
+
+		for(unsigned int p = 0; p &lt; paths.at(i).size(); p++)
+		{
+			geometry_msgs::Point point;
+			point.x = paths.at(i).at(p).pos.x;
+			point.y = paths.at(i).at(p).pos.y;
+			point.z = paths.at(i).at(p).pos.z + additional_z;
+			path_mkr.points.push_back(point);
+		}
+
+		if(i &lt; path_markers.markers.size())
+			path_markers.markers.at(i) = path_mkr;
+		else
+			path_markers.markers.push_back(path_mkr);
+	}
+}
+
+void RosHelpers::ConvertCurbsMarkers(const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; curbs, visualization_msgs::MarkerArray&amp; curbs_markers, visualization_msgs::MarkerArray&amp; curbs_markers_d)
+{
+
+	curbs_markers = curbs_markers_d;
+	for(unsigned int i = 0; i &lt; curbs.size(); i++)
+	{
+		if(curbs.at(i).contour.size() &gt; 0)
+		{
+			visualization_msgs::Marker curb_mkr = CreateGenMarker(curbs.at(i).contour.at(0).x,curbs.at(i).contour.at(0).y,curbs.at(i).contour.at(0).z,0,1,0.54,0,0.2,i,"map_detected_curbs", visualization_msgs::Marker::SPHERE);
+
+			if(i &lt; curbs_markers.markers.size())
+				curbs_markers.markers.at(i) = curb_mkr;
+			else
+				curbs_markers.markers.push_back(curb_mkr);
+		}
+	}
+}
+
+void RosHelpers::InitCollisionPointsMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; col_points)
+{
+	col_points.markers.clear();
+	for(int i=0; i&lt;nMarkers; i++)
+	{
+		visualization_msgs::Marker mkr = CreateGenMarker(0,0,0,0,1,1,1,1,i,"collision_points_rviz", visualization_msgs::Marker::SPHERE);
+		col_points.markers.push_back(mkr);
+	}
+}
+
+void RosHelpers::ConvertCollisionPointsMarkers(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; col_points, visualization_msgs::MarkerArray&amp; collision_markers, visualization_msgs::MarkerArray&amp; collision_markers_d)
+{
+	collision_markers = collision_markers_d;
+	for(unsigned int i = 0; i &lt; col_points.size(); i++)
+	{
+		visualization_msgs::Marker mkr = CreateGenMarker(col_points.at(i).pos.x, col_points.at(i).pos.y, col_points.at(i).pos.z,0,1,0,0,0.5,i,"collision_points_rviz", visualization_msgs::Marker::SPHERE);
+
+		if(i &lt; collision_markers.markers.size())
+			collision_markers.markers.at(i) = mkr;
+		else
+			collision_markers.markers.push_back(mkr);
+
+	}
+}
+
 void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
 		autoware_msgs::lane&amp; trajectory)
 {
@@ -369,6 +506,44 @@ void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const Planne
 	}
 }
 
+void RosHelpers::InitPredParticlesMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; paths)
+{
+	paths.markers.clear();
+	for(int i=0; i&lt;nMarkers; i++)
+	{
+		visualization_msgs::Marker mkr = CreateGenMarker(0,0,0,0,1,1,1,0.05,i,"Particles", visualization_msgs::Marker::ARROW);
+		mkr.scale.x = 0.3;
+		paths.markers.push_back(mkr);
+	}
+}
+
+void RosHelpers::ConvertParticles(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; points, visualization_msgs::MarkerArray&amp; part_mkrs, visualization_msgs::MarkerArray&amp; part_markers_d)
+{
+	part_mkrs = part_markers_d;
+	for(unsigned int i = 0; i &lt; points.size(); i++)
+	{
+		visualization_msgs::Marker mkr;
+		if(points.at(i).bDir == PlannerHNS::STANDSTILL_DIR)
+			mkr = CreateGenMarker(points.at(i).pos.x, points.at(i).pos.y,points.at(i).pos.z,points.at(i).pos.a,1,0,0,0.05,i,"Particles", visualization_msgs::Marker::ARROW);
+		else if(points.at(i).bDir == PlannerHNS::FORWARD_DIR)
+			mkr = CreateGenMarker(points.at(i).pos.x, points.at(i).pos.y,points.at(i).pos.z,points.at(i).pos.a,1,1,1,0.05,i,"Particles", visualization_msgs::Marker::ARROW);
+		else if(points.at(i).bDir == PlannerHNS::FORWARD_RIGHT_DIR)
+			mkr = CreateGenMarker(points.at(i).pos.x, points.at(i).pos.y,points.at(i).pos.z,points.at(i).pos.a,0,1,0,0.05,i,"Particles", visualization_msgs::Marker::ARROW);
+		else if(points.at(i).bDir == PlannerHNS::FORWARD_LEFT_DIR)
+			mkr = CreateGenMarker(points.at(i).pos.x, points.at(i).pos.y,points.at(i).pos.z,points.at(i).pos.a,0,0,1,0.05,i,"Particles", visualization_msgs::Marker::ARROW);
+		else if(points.at(i).bDir == PlannerHNS::BACKWARD_DIR)
+			mkr = CreateGenMarker(points.at(i).pos.x, points.at(i).pos.y,points.at(i).pos.z,points.at(i).pos.a,1,0,1,0.05,i,"Particles", visualization_msgs::Marker::ARROW);
+		else
+			mkr = CreateGenMarker(points.at(i).pos.x, points.at(i).pos.y,points.at(i).pos.z,points.at(i).pos.a,1,1,0,0.05,i,"Particles", visualization_msgs::Marker::ARROW);
+
+		mkr.scale.x = 0.3;
+		if(i &lt; part_mkrs.markers.size())
+			part_mkrs.markers.at(i) = mkr;
+		else
+			part_mkrs.markers.push_back(mkr);
+	}
+}
+
 void RosHelpers::ConvertFromPlannerHRectangleToAutowareRviz(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; safety_rect,
 		visualization_msgs::Marker&amp; marker)
 {
@@ -479,6 +654,81 @@ void RosHelpers::TrajectoriesToMarkers(const std::vector&lt;std::vector&lt;std::vector
 	}
 }
 
+void RosHelpers::TrajectoriesToColoredMarkers(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths, const std::vector&lt;PlannerHNS::TrajectoryCost&gt;&amp; traj_costs,const int&amp; iClosest, visualization_msgs::MarkerArray&amp; markerArray)
+{
+	visualization_msgs::Marker lane_waypoint_marker;
+	lane_waypoint_marker.header.frame_id = "map";
+	lane_waypoint_marker.header.stamp = ros::Time();
+	lane_waypoint_marker.ns = "local_lane_array_marker_colored";
+	lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
+	lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
+	lane_waypoint_marker.scale.x = 0.1;
+	lane_waypoint_marker.scale.y = 0.1;
+	//lane_waypoint_marker.scale.z = 0.1;
+	lane_waypoint_marker.color.a = 0.9;
+	lane_waypoint_marker.color.r = 1.0;
+	lane_waypoint_marker.color.g = 1.0;
+	lane_waypoint_marker.color.b = 1.0;
+	lane_waypoint_marker.frame_locked = false;
+
+	int count = 0;
+	for (unsigned int i = 0; i &lt; paths.size(); i++)
+	{
+		lane_waypoint_marker.points.clear();
+		lane_waypoint_marker.id = count;
+
+		for (unsigned int j=0; j &lt; paths.at(i).size(); j++)
+		{
+			geometry_msgs::Point point;
+
+			point.x = paths.at(i).at(j).pos.x;
+			point.y = paths.at(i).at(j).pos.y;
+			point.z = paths.at(i).at(j).pos.z;
+
+			lane_waypoint_marker.points.push_back(point);
+		}
+
+		lane_waypoint_marker.color.b = 0;
+
+		if(traj_costs.size() == paths.size())
+		{
+			float norm_cost = traj_costs.at(i).cost * paths.size();
+			if(norm_cost &lt;= 1.0)
+			{
+				lane_waypoint_marker.color.r = norm_cost;
+				lane_waypoint_marker.color.g = 1.0;
+			}
+			else if(norm_cost &gt; 1.0)
+			{
+				lane_waypoint_marker.color.r = 1.0;
+				lane_waypoint_marker.color.g = 2.0 - norm_cost;
+			}
+		}
+		else
+		{
+			lane_waypoint_marker.color.r = 1.0;
+			lane_waypoint_marker.color.g = 0.0;
+		}
+
+		if(traj_costs.at(i).bBlocked)
+		{
+			lane_waypoint_marker.color.r = 1.0;
+			lane_waypoint_marker.color.g = 0.0;
+			lane_waypoint_marker.color.b = 0.0;
+		}
+
+		if(i == iClosest)
+		{
+			lane_waypoint_marker.color.r = 1.0;
+			lane_waypoint_marker.color.g = 0.0;
+			lane_waypoint_marker.color.b = 1.0;
+		}
+
+		markerArray.markers.push_back(lane_waypoint_marker);
+		count++;
+	}
+}
+
 void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; curr_path,
 		const std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt;&amp; paths, const PlannerHNS::LocalPlannerH&amp; localPlanner,
 			visualization_msgs::MarkerArray&amp; markerArray)
@@ -823,15 +1073,15 @@ std::string RosHelpers::GetBehaviorNameFromCode(const PlannerHNS::STATE_TYPE&amp; be
 	return str;
 }
 
-void RosHelpers::VisualizeBehaviorState(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::BehaviorState&amp; beh, const bool&amp; bGreenLight, const int&amp; avoidDirection, visualization_msgs::Marker&amp; behaviorMarker)
+void RosHelpers::VisualizeBehaviorState(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::BehaviorState&amp; beh, const bool&amp; bGreenLight, const int&amp; avoidDirection, visualization_msgs::Marker&amp; behaviorMarker, std::string ns,double size_factor)
 {
 	behaviorMarker.header.frame_id = "map";
 	behaviorMarker.header.stamp = ros::Time();
-	behaviorMarker.ns = "detected_polygons_velocity";
+	behaviorMarker.ns = ns;
 	behaviorMarker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
-	behaviorMarker.scale.z = 1.0;
-	behaviorMarker.scale.x = 1.0;
-	behaviorMarker.scale.y = 1.0;
+	behaviorMarker.scale.z = 1.0*size_factor;
+	behaviorMarker.scale.x = 1.0*size_factor;
+	behaviorMarker.scale.y = 1.0*size_factor;
 	behaviorMarker.color.a = 0.9;
 	behaviorMarker.frame_locked = false;
 	if(bGreenLight)
@@ -845,13 +1095,15 @@ void RosHelpers::VisualizeBehaviorState(const PlannerHNS::WayPoint&amp; currState, c
 		behaviorMarker.color.r = 1;//trackedObstacles.at(i).center.v/16.0;
 		behaviorMarker.color.g = 0.1;// - trackedObstacles.at(i).center.v/16.0;
 		behaviorMarker.color.b = 0.1;
-		behaviorMarker.id = 0;
 	}
+
+	behaviorMarker.id = 0;
+
 	geometry_msgs::Point point;
 
 	point.x = currState.pos.x;
 	point.y = currState.pos.y;
-	point.z = currState.pos.z+2.0;
+	point.z = currState.pos.z+3.0;
 
 	behaviorMarker.pose.position = point;
 
@@ -1063,8 +1315,8 @@ void RosHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS
 		wp.twist.twist.linear.x = path.at(i).v;
 		wp.lane_id = path.at(i).laneId;
 		wp.stop_line_id = path.at(i).stopLineID;
-		wp.left_lane_id = path.at(i).LeftLaneId;
-		wp.right_lane_id = path.at(i).RightLaneId;
+		wp.left_lane_id = path.at(i).LeftPointId;
+		wp.right_lane_id = path.at(i).RightPointId;
 		wp.time_cost = path.at(i).timeCost;
 
 		wp.gid = path.at(i).gid;
@@ -1115,8 +1367,8 @@ void RosHelpers::ConvertFromAutowareLaneToLocalLane(const autoware_msgs::lane&amp; t
 		wp.gid = trajectory.waypoints.at(i).gid;
 		wp.laneId = trajectory.waypoints.at(i).lane_id;
 		wp.stopLineID = trajectory.waypoints.at(i).stop_line_id;
-		wp.LeftLaneId = trajectory.waypoints.at(i).left_lane_id;
-		wp.RightLaneId = trajectory.waypoints.at(i).right_lane_id;
+		wp.LeftPointId = trajectory.waypoints.at(i).left_lane_id;
+		wp.RightPointId = trajectory.waypoints.at(i).right_lane_id;
 		wp.timeCost = trajectory.waypoints.at(i).time_cost;
 
 		if(trajectory.waypoints.at(i).direction == 0)
@@ -1517,4 +1769,83 @@ void RosHelpers::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::R
 	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data,way_area, crossing, nodes_data,  conn_data, origin, out_map);
 }
 
+void RosHelpers::GetIndicatorArrows(const PlannerHNS::WayPoint&amp; center, const double&amp; width,const double&amp; length, const PlannerHNS::LIGHT_INDICATOR&amp; indicator, const int&amp; id, visualization_msgs::MarkerArray&amp; markerArray)
+{
+	double critical_lateral_distance =  width/2.0 + 0.2;
+	//double critical_long_front_distance =  carInfo.length/2.0 ;
+	PlannerHNS::GPSPoint top_right(critical_lateral_distance, length, center.pos.z, 0);
+	PlannerHNS::GPSPoint top_left(-critical_lateral_distance, length, center.pos.z, 0);
+
+	PlannerHNS::Mat3 invRotationMat(center.pos.a-M_PI_2);
+	PlannerHNS::Mat3 invTranslationMat(center.pos.x, center.pos.y);
+
+	top_right = invRotationMat*top_right;
+	top_right = invTranslationMat*top_right;
+	top_left = invRotationMat*top_left;
+	top_left = invTranslationMat*top_left;
+
+	top_right.a = center.pos.a - M_PI_2;
+	top_left.a = center.pos.a + M_PI_2;
+
+	std_msgs::ColorRGBA color_l, color_r;
+	color_l.r = 1; color_l.g = 1;color_l.b = 1;
+	color_r.r = 1; color_r.g = 1;color_r.b = 1;
+
+	if(indicator == PlannerHNS::INDICATOR_LEFT)
+	{
+		color_l.b = 0;
+	}
+	else if(indicator == PlannerHNS::INDICATOR_RIGHT )
+	{
+		color_r.b = 0;
+	}
+	else if(indicator == PlannerHNS::INDICATOR_BOTH)
+	{
+		color_l.b = 0;
+		color_r.b = 0;
+	}
+
+	visualization_msgs::Marker mkr_l = PlannerHNS::RosHelpers::CreateGenMarker(top_left.x,top_left.y,top_left.z,top_left.a,color_l.r,color_l.g,color_l.b,1.0, id,"simu_car_indicator_left", visualization_msgs::Marker::ARROW);
+	mkr_l.scale.y = 0.4;
+	mkr_l.scale.z = 0.4;
+	visualization_msgs::Marker mkr_r = PlannerHNS::RosHelpers::CreateGenMarker(top_right.x,top_right.y,top_right.z,top_right.a,color_r.r,color_r.g,color_r.b,1.0, id,"simu_car_indicator_right", visualization_msgs::Marker::ARROW);
+	mkr_r.scale.y = 0.4;
+	mkr_r.scale.z = 0.4;
+	markerArray.markers.push_back(mkr_l);
+	markerArray.markers.push_back(mkr_r);
+}
+
+void RosHelpers::TTC_PathRviz(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, visualization_msgs::MarkerArray&amp; markerArray)
+{
+	visualization_msgs::Marker lane_waypoint_marker;
+	lane_waypoint_marker.header.frame_id = "map";
+	lane_waypoint_marker.header.stamp = ros::Time();
+	lane_waypoint_marker.ns = "ttc_path";
+	lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
+	lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
+	lane_waypoint_marker.scale.x = 1;
+	lane_waypoint_marker.scale.y = 1;
+	lane_waypoint_marker.scale.z = 1;
+	lane_waypoint_marker.frame_locked = false;
+	std_msgs::ColorRGBA  total_color, curr_color;
+
+	lane_waypoint_marker.color.a = 0.9;
+	lane_waypoint_marker.color.r = 0.5;
+	lane_waypoint_marker.color.g = 1.0;
+	lane_waypoint_marker.color.b = 0.0;
+
+	lane_waypoint_marker.id = 1;
+	for (unsigned int i = 0; i &lt; path.size(); i++)
+	{
+		geometry_msgs::Point point;
+		point.x = path.at(i).pos.x;
+		point.y = path.at(i).pos.y;
+		point.z = path.at(i).pos.z;
+
+		lane_waypoint_marker.points.push_back(point);
+
+		markerArray.markers.push_back(lane_waypoint_marker);
+	}
+}
+
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\AlternativeVisualizer.h" new_path="" added_lines="0" deleted_lines="60">
				<diff>@@ -1,60 +0,0 @@
-/*
- * AlternativeVisualizer.h
- *
- *  Created on: Jun 17, 2016
- *      Author: hatem
- */
-
-#ifndef AlternativeVisualizer_H_
-#define AlternativeVisualizer_H_
-#include &lt;iostream&gt;
-#include "DrawObjBase.h"
-#include "op_planner/RoadNetwork.h"
-#include "CarState.h"
-#include "DrawingHelpers.h"
-#include "TrajectoryFollower.h"
-#include "SimulatedTrajectoryFollower.h"
-#include "Graph2dBase.h"
-
-namespace Graphics
-{
-
-class AlternativeVisualizer : public DrawObjBase
-{
-public:
-	AlternativeVisualizer();
-	virtual ~AlternativeVisualizer();
-
-	void DrawSimu();
-	void DrawInfo(const int&amp; centerX, const int&amp; centerY, const int&amp; maxX, const int&amp; maxY);
-	void OnLeftClick(const double&amp; x, const double&amp; y);
-	void OnRightClick(const double&amp; x, const double&amp; y);
-	void OnKeyboardPress(const SPECIAL_KEYS_TYPE&amp; sKey, const unsigned char&amp; key);
-	void LoadMaterials();
-	void Reset();
-    bool IsInitState();
-    void UpdatePlaneStartGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2);
-    void AddSimulatedCarPos(const double&amp; x,const double&amp; y, const double&amp; a);
-
-
-public:
-    PlannerHNS::RoadNetwork m_RoadMap;
-	PlannerHNS::WayPoint m_start;
-	PlannerHNS::WayPoint m_goal;
-	std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt; m_ReadyToDrawLanes;
-	std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt; m_ReadyToDrawCenterLines;
-	std::vector&lt;PlannerHNS::WayPoint&gt; m_GeneratedPath;
-
-private:
-	void PrepareVectorMapForDrawing();
-	void DrawVectorMap();
-	void DrawGPSData();
-	void TransToCarCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-	void TransToWorldCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-	void medianfilter(std::vector&lt;double&gt; signal, std::vector&lt;double&gt;&amp; result, int nOrder);
-
-};
-
-} /* namespace Graphics */
-
-#endif /* AlternativeVisualizer_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\CarState.h" new_path="" added_lines="0" deleted_lines="218">
				<diff>@@ -1,218 +0,0 @@
-/*
- * CarState.h
- *
- *  Created on: Jun 20, 2016
- *      Author: hatem
- */
-
-#ifndef CARSTATE_H_
-#define CARSTATE_H_
-
-#include "op_planner/BehaviorStateMachine.h"
-#include "op_planner/PlannerCommonDef.h"
-#include "op_planner/RoadNetwork.h"
-
-namespace SimulationNS
-{
-
-class CarState
-{
-public:
-	PlannerHNS::PlanningParams m_Params;
-	PlannerHNS::WayPoint state;
-	PlannerHNS::CAR_BASIC_INFO m_CarInfo;
-	PlannerHNS::ControllerParams m_ControlParams;
-	std::vector&lt;PlannerHNS::GPSPoint&gt; m_CarShapePolygon;
-	std::vector&lt;PlannerHNS::WayPoint&gt; m_Path;
-	std::vector&lt;PlannerHNS::WayPoint&gt; m_TotalPath;
-	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; m_PredictedPath;
-	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; m_RollOuts;
-	std::string carId;
-	PlannerHNS::Lane* pLane;
-	double m_SimulationSteeringDelayFactor; //second , time that every degree change in the steering wheel takes
-	timespec m_SteerDelayTimer;
-	double m_PredictionTime;
-
-	PlannerHNS::BehaviorStateMachine* 		m_pCurrentBehaviorState;
-	PlannerHNS::ForwardState * 				m_pGoToGoalState;
-	PlannerHNS::StopState* 					m_pStopState;
-	PlannerHNS::WaitState* 					m_pWaitState;
-	PlannerHNS::InitState* 					m_pInitState;
-	PlannerHNS::MissionAccomplishedState*	m_pMissionCompleteState;
-	PlannerHNS::FollowState*				m_pFollowState;
-	PlannerHNS::SwerveState*				m_pAvoidObstacleState;
-	PlannerHNS::TrafficLightStopState*		m_pTrafficLightStopState;
-	PlannerHNS::TrafficLightWaitState*		m_pTrafficLightWaitState;
-
-
-	std::vector&lt;PlannerHNS::TrajectoryCost&gt; m_TrajectoryCosts;
-
-	void InitBehaviorStates();
-
-	void SetSimulatedTargetOdometryReadings(const double&amp; velocity_d, const double&amp; steering_d, const PlannerHNS::SHIFT_POS&amp; shift_d)
-	{
-		m_CurrentVelocityD = velocity_d;
-		m_CurrentSteeringD = steering_d;
-		m_CurrentShiftD = shift_d;
-	}
-
-	double GetSimulatedVelocity()
-	{
-		return m_CurrentVelocity;
-	}
-
-	double GetSimulatedSteering()
-	{
-		return m_CurrentSteering;
-	}
-
-	double GetSimulatedShift()
-	{
-		return m_CurrentShift;
-	}
-
-
-	//For Simulation
-	PlannerHNS::WayPoint m_OdometryState;
-	double m_CurrentVelocity, m_CurrentVelocityD; //meter/second
-	double m_CurrentSteering, m_CurrentSteeringD; //radians
-	PlannerHNS::SHIFT_POS m_CurrentShift , m_CurrentShiftD;
-
-	double m_CurrentAccSteerAngle; //degrees steer wheel range
-	double m_CurrentAccVelocity; // kilometer/hour
-	std::vector&lt;PlannerHNS::TrafficLight&gt; m_TrafficLights;
-
-public:
-
-	CarState();
-	virtual ~CarState();
-	void Init(const PlannerHNS::ControllerParams ctrlParams, const PlannerHNS::PlanningParams&amp; params, const PlannerHNS::CAR_BASIC_INFO&amp; carInfo);
-	void InitPolygons();
-	void FirstLocalizeMe(const PlannerHNS::WayPoint&amp; initCarPos);
-	void LocalizeMe(const double&amp; dt); // in seconds
-	void UpdateState(const PlannerHNS::VehicleState&amp; state, const bool&amp; bUseDelay = false);
-	void CalculateImportantParameterForDecisionMaking(const PlannerHNS::VehicleState&amp; car_state,
-			const PlannerHNS::GPSPoint&amp; goal,
-			const bool&amp; bEmergencyStop,
-			const bool&amp; bGreenTrafficLight);
-
-//	PlannerHNS::BehaviorState DoOneStep(
-//			const double&amp; dt,
-//			const PlannerHNS::VehicleState&amp; state,
-//			const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list,
-//			const PlannerHNS::GPSPoint&amp; goal,
-//			PlannerHNS::RoadNetwork&amp; map,
-//			const bool&amp; bEmergencyStop,
-//			const bool&amp; bGreenTrafficLight,
-//			const bool&amp; bLive = false);
-
-	void SimulateOdoPosition(const double&amp; dt, const PlannerHNS::VehicleState&amp; vehicleState);
-
-private:
-
-	//Obstacle avoidance functionalities
-	void InitializeTrajectoryCosts();
-	void CalculateTransitionCosts();
-	//void CalculateDistanceCosts(const PlannerHNS::VehicleState&amp; vstatus, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-	bool CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const PlannerHNS::VehicleState&amp; vstatus, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-
-	double PredictTimeCostForTrajectory(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
-			const PlannerHNS::VehicleState&amp; vstatus,
-			const PlannerHNS::WayPoint&amp; currState);
-
-	void PredictObstacleTrajectory(PlannerHNS::RoadNetwork&amp; map,
-			const PlannerHNS::WayPoint&amp; pos,
-			const double&amp; predTime,
-			std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths);
-
-	bool CalculateIntersectionVelocities(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
-			std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; predctedPath,
-			const PlannerHNS::DetectedObject&amp; obj);
-	void FindSafeTrajectory(int&amp; safe_index, double&amp; closest_distance, double&amp; closest_velocity);
-	void FindNextBestSafeTrajectory(int&amp; safe_index);
-	bool GetNextTrafficLight(const int&amp; prevTrafficLightId, const std::vector&lt;PlannerHNS::TrafficLight&gt;&amp; trafficLights, PlannerHNS::TrafficLight&amp; trafficL);
-	bool IsGoalAchieved(const PlannerHNS::GPSPoint&amp; goal);
-	void UpdateCurrentLane(PlannerHNS::RoadNetwork&amp; map, const double&amp; search_distance);
-	bool SelectSafeTrajectoryAndSpeedProfile(const PlannerHNS::VehicleState&amp; vehicleState);
-	PlannerHNS::BehaviorState GenerateBehaviorState(const PlannerHNS::VehicleState&amp; vehicleState);
-	void TransformPoint(const PlannerHNS::WayPoint&amp; refPose, PlannerHNS::GPSPoint&amp; p);
-	void AddAndTransformContourPoints(const PlannerHNS::DetectedObject&amp; obj, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; contourPoints);
-};
-
-class SimulatedCarState
-{
-public:
-	PlannerHNS::WayPoint state;
-	PlannerHNS::CAR_BASIC_INFO m_CarInfo;
-	std::vector&lt;PlannerHNS::GPSPoint&gt; m_CarShapePolygon;
-	std::vector&lt;PlannerHNS::WayPoint&gt; m_Path;
-	std::vector&lt;PlannerHNS::WayPoint&gt; m_TotalPath;
-	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; m_RollOuts;
-	std::string carId;
-	PlannerHNS::Lane* pLane;
-	bool bDetected;
-
-	void SetSimulatedTargetOdometryReadings(const double&amp; velocity_d, const double&amp; steering_d, const PlannerHNS::SHIFT_POS&amp; shift_d)
-	{
-		m_CurrentVelocityD = velocity_d;
-		m_CurrentSteeringD = steering_d;
-		m_CurrentShiftD = shift_d;
-	}
-
-	double GetSimulatedVelocity()
-	{
-		return m_CurrentVelocity;
-	}
-
-	double GetSimulatedSteering()
-	{
-		return m_CurrentSteering;
-	}
-
-	double GetSimulatedShift()
-	{
-		return m_CurrentShift;
-	}
-
-
-	//For Simulation
-	PlannerHNS::WayPoint m_OdometryState;
-	double m_CurrentVelocity, m_CurrentVelocityD; //meter/second
-	double m_CurrentSteering, m_CurrentSteeringD; //radians
-	PlannerHNS::SHIFT_POS m_CurrentShift , m_CurrentShiftD;
-
-	//double m_CurrentAccSteerAngle; //degrees steer wheel range
-	//double m_CurrentAccVelocity; // kilometer/hour
-
-public:
-
-	SimulatedCarState();
-	virtual ~SimulatedCarState();
-	void Init(const PlannerHNS::CAR_BASIC_INFO&amp; carInfo);
-	void InitPolygons();
-	void FirstLocalizeMe(const PlannerHNS::WayPoint&amp; initCarPos);
-	void LocalizeMe(const double&amp; dt); // in seconds
-
-	void UpdateState(const bool&amp; bUseDelay = false);
-	void CalculateImportantParameterForDecisionMaking(const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list,
-			const PlannerHNS::VehicleState&amp; car_state, const PlannerHNS::GPSPoint&amp; goal, PlannerHNS::RoadNetwork&amp; map);
-
-	PlannerHNS::BehaviorState DoOneStep(
-			const double&amp; dt,
-			const PlannerHNS::VehicleState&amp; state,
-			const PlannerHNS::WayPoint&amp; currPose,
-			const PlannerHNS::GPSPoint&amp; goal,
-			PlannerHNS::RoadNetwork&amp; map);
-
-private:
-	void SimulateOdoPosition(const double&amp; dt, const PlannerHNS::VehicleState&amp; vehicleState);
-	void UpdateCurrentLane(PlannerHNS::RoadNetwork&amp; map, const double&amp; search_distance);
-	PlannerHNS::BehaviorState GenerateBehaviorState(const PlannerHNS::VehicleState&amp; vehicleState);
-	bool SelectSafeTrajectoryAndSpeedProfile(const PlannerHNS::VehicleState&amp; vehicleState);
-
-
-};
-
-} /* namespace SimulationNS */
-
-#endif /* CARSTATE_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\DrawObjBase.h" new_path="" added_lines="0" deleted_lines="60">
				<diff>@@ -1,60 +0,0 @@
-/*
- * DrawObjBase.h
- *
- *  Created on: Jun 17, 2016
- *      Author: hatem
- */
-
-#ifndef DRAWOBJBASE_H_
-#define DRAWOBJBASE_H_
-
-#include &lt;string&gt;
-namespace Graphics
-{
-
-enum DISPLAY_SHAP {DISP_WHEEL, DISP_PEDAL, DISP_TEXT};
-enum SPECIAL_KEYS_TYPE { UP_KEY, DOWN_KEY, LEFT_KEY, RIGHT_KEY, LEFT_CTRL_KEY, RIGHT_CTRL_KEY, LEFT_SHIFT_KEY, RIGHT_SHIFT_KEY, SPACE_KEY, CHAR_KEY,};
-
-class DisplayDataObj
-{
-public:
-	double x;
-	double y;
-	double value;
-	std::string text;
-	DISPLAY_SHAP shape;
-
-	DisplayDataObj()
-	{
-		x = y = value = 0;
-		shape = DISP_TEXT;
-	}
-};
-
-class DrawObjBase
-  {
-  public:
-
-    virtual void DrawSimu()=0;
-    virtual void DrawInfo(const int&amp; centerX, const int&amp; centerY, const int&amp; maxX, const int&amp; maxY)=0;
-    virtual void OnLeftClick(const double&amp; x, const double&amp; y) = 0;
-    virtual void OnRightClick(const double&amp; x, const double&amp; y) = 0;
-    virtual void OnKeyboardPress(const SPECIAL_KEYS_TYPE&amp; sKey, const unsigned char&amp; key) = 0;
-    virtual void LoadMaterials() = 0;
-    virtual void Reset() = 0;
-    virtual bool IsInitState() = 0;
-    virtual void UpdatePlaneStartGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2) = 0;
-    virtual void AddSimulatedCarPos(const double&amp; x,const double&amp; y, const double&amp; a) = 0;
-
-    DrawObjBase();
-    virtual ~DrawObjBase();
-
-    double m_followX;
-    double m_followY;
-    double m_followZ;
-    double m_followA;
-  };
-
-} /* namespace Graphics */
-
-#endif /* DRAWOBJBASE_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\DrawingHelpers.h" new_path="" added_lines="0" deleted_lines="63">
				<diff>@@ -1,63 +0,0 @@
-/*
- * DrawingHelpers.h
- *
- *  Created on: May 31, 2016
- *      Author: hatem
- */
-
-#ifndef DRAWINGHELPERS_H_
-#define DRAWINGHELPERS_H_
-
-#include "glm.h"
-#include "op_planner/RoadNetwork.h"
-#include "glm.h"
-
-namespace Graphics {
-
-class DrawingHelpers {
-public:
-	DrawingHelpers();
-	virtual ~DrawingHelpers();
-	static void DrawString(float x, float y, GLvoid *font_style, char* format, ...);
-	static void DrawGrid(const double&amp; x, const double&amp; y, const double&amp; w, const double&amp; h, const double&amp; cell_l);
-	static void DrawCustomOrigin(const double&amp; x, const double&amp; y, const double&amp; z,
-			const int&amp; yaw, const int&amp; roll, const int&amp; pitch, const double&amp; length);
-	static void DrawArrow(const double&amp; x, const double&amp; y, const double&amp; a);
-
-	static std::vector&lt;std::vector&lt;float&gt; &gt; PreparePathForDrawing(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
-			std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; redyForDraw, double w, double resolution = 1);
-
-	static void DrawPrePreparedPolygons(std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; path,
-			double z, float color[3],int nSkipPoints = 1, const std::vector&lt;std::vector&lt;float&gt; &gt;* colorProfile = 0);
-
-	static void DrawWidePath(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path_points, const double&amp; z,
-			const double&amp; width, float color[3], bool bGadient = true);
-
-	static void DrawCostPath(const std::vector&lt;PlannerHNS::WayPoint*&gt;&amp; path_points, const double&amp; z, const double&amp; width);
-
-	static void DrawLinePoygonFromCenterX(const PlannerHNS::WayPoint&amp; p1, const double&amp; z,
-			const PlannerHNS::WayPoint&amp; p2, const double&amp; z2, const double&amp; w, const double&amp; h,
-			PlannerHNS::WayPoint&amp; prev_point);
-
-	static void DrawLinePoygonline(const PlannerHNS::GPSPoint&amp; p1, const PlannerHNS::GPSPoint&amp; p2, const double&amp; w);
-
-	static void DrawCustomCarModel(const PlannerHNS::WayPoint&amp; pose, const double&amp; steeringAngle, const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; carPoints,float color[3], const double&amp; angleFix);
-
-	static GLMmodel* LoadModel(const char* fileName);
-
-	static void DrawModel(GLMmodel* pmod,double length, double width, double height, double x, double y,double z, double heading, double pitch , double roll );
-
-	static void DrawFilledEllipse(float x, float y, float z, float width, float height);
-
-	static void DrawWideEllipse(float x, float y, float z, float outer_width, float outer_height, float inner_width,float color[3]);
-
-	static void DrawSimpleEllipse(float x, float y, float z, float outer_width, float outer_height);
-
-	static void DrawPedal(float x, float y, float z, float width, float height, float inner_height, float color[3]);
-
-};
-
-} /* namespace Graphics */
-
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\Graph2dBase.h" new_path="" added_lines="0" deleted_lines="49">
				<diff>@@ -1,49 +0,0 @@
-/*
- * Graph2dBase.h
- *
- *  Created on: Oct 8, 2016
- *      Author: hatem
- */
-
-#ifndef GRAPH2DBASE_H_
-#define GRAPH2DBASE_H_
-
-#include "DrawingHelpers.h"
-#include "op_planner/RoadNetwork.h"
-#include &lt;vector&gt;
-
-namespace Graphics {
-
-class Graph2dBase {
-public:
-	void ReInitGraphResolution(double width, double height, int nMaxPoints, double a_color[], double g_color[]);
-	Graph2dBase(double width, double height, int nMaxPoints, double max_y, double min_y, std::string str_title, std::string str_x, std::string str_y, double a_color[], double g_color[]);
-	void UpdateComment(const std::string&amp; str_com);
-	virtual ~Graph2dBase();
-	double DrawGraph();
-	void InsertPoint(const double&amp; x, const double&amp; y);
-	void InsertPointTimeStamp(const timespec&amp; tStamp, const double&amp; y);
-	void InsertPointsList(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; points);
-
-
-protected:
-	double w,h;
-	double nPoints;
-	std::vector&lt;PlannerHNS::GPSPoint&gt; xy_arr;
-	std::vector&lt;PlannerHNS::GPSPoint&gt; xy_arr_original;
-
-	double axes_color[3];
-	double graph_color[3];
-	std::string graph_title;
-	std::string x_name;
-	std::string y_name;
-	std::string str_comment;
-	PlannerHNS::GPSPoint max_point;
-	PlannerHNS::GPSPoint min_point;
-
-	timespec m_PrevTimeStamp;
-};
-
-} /* namespace Graphics */
-
-#endif /* GRAPH2DBASE_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\MainWindowWrapper.h" new_path="" added_lines="0" deleted_lines="159">
				<diff>@@ -1,159 +0,0 @@
-/*
- * MainWindowWrapper.h
- *
- *  Created on: May 31, 2016
- *      Author: hatem
- */
-
-
-#include &lt;string&gt;
-#include "DrawObjBase.h"
-#include &lt;vector&gt;
-
-namespace Graphics {
-
-enum DisplayMode{DISPLAY_FREE, DISPLAY_TOP_FREE, DISPLAY_FOLLOW};
-
-class WindowParams
-{
-public:
-	int x;
-	int y;
-	int w;
-	int h;
-	double info_ratio;
-	std::string title;
-	struct info_window
-	{
-		int x;
-		int y;
-		int w;
-		int h;
-	}info_window;
-
-	struct simu_window
-	{
-		int x;
-		int y;
-		int w;
-		int h;
-	}simu_window;
-
-	struct UI_CONST
-	{
-		int GAP;
-		double MAX_ZOOM;
-		double MIN_ZOOM;
-		double INIT_ZOOM;
-		double FOLLOW_CONST_ZOOM;
-
-	}UI_CONST;
-
-	bool bNew;
-	bool bGPU;
-
-
-	WindowParams();
-	void ReCalcSimuWindow();
-};
-
-class DisplayParams
-{
-public:
-
-	int prev_x;
-	int prev_y;
-	int currRotationZ; //degrees, scaled radians
-	int currRotationX; //degrees, scaled radians
-	int currRotationY; //degrees, scaled radians
-
-	double centerRotX;
-	double centerRotY;
-
-	double translateX;
-	double translateY;
-
-	float eye[3];
-	float at[3] ;
-	float up[3] ;
-
-	bool bFullScreen;
-	DisplayMode  bDisplayMode;
-	double prespective_z;
-	double prespective_fov;
-
-	bool bLeftDown;
-	bool bRightDown;
-	bool bCenterDown;
-	int  bSelectPosition; //0 nothing,  1 start , 2 goal, 3 simulation
-	double StartPos[3];
-	double GoalPos[3];
-	double StartPosFinal[3];
-	double GoalPosFinal[3];
-
-	double SimulatedCarPos[3];
-	double SimulatedCarPosFinal[3];
-
-
-	double zoom;
-	double actualViewX;
-	double actualViewY;
-	double initScreenToCenterMargin[2];
-
-	DisplayParams();
-};
-
-class MainWindowWrapper {
-public:
-
-	MainWindowWrapper(DrawObjBase* pDraw);
-	virtual ~MainWindowWrapper();
-
-	void InitOpenGLWindow(int argc, char** argv);
-	void UpdateParams(const WindowParams&amp; params, const DisplayParams&amp; display_params);
-	static void MainReshape(int width,  int height);
-	static void SimuReshape(int width,  int height);
-	static void InfoReshape(int width,  int height);
-
-	static void MainDisplay();
-	static void SimuDisplay();
-	static void InfoDisplay();
-
-	static void MouseMove(int x, int y);
-	static void MouseCommand(int button, int state, int x, int y);
-	static void KeyboardCommand(unsigned char key, int x, int y);
-	static void KeyboardExitCommand(unsigned char key, int x, int y);
-	static void KeyboardSpecialCommand(int key, int x, int y);
-
-	//Menu functions
-	static void CreateRightClickMenu();
-	static void MenuCommand(int value);
-	static void ProcessMenuStatus(int status, int x, int y);
-	static void ModifyPopupMenu();
-
-	static void InitLighting();
-	static void FromScreenToModelCoordinate(int sx, int sy, double&amp; modelX, double&amp; modelY);
-	static void FromModelToScreenCoordinate(double modelX, double modelY, int&amp; sx, int&amp; sy);
-
-	static void DrawGrid(const double&amp; x, const double&amp; y, const double&amp; w, const double&amp; h, const double&amp; cell_l);
-
-	static void CleanUp();
-	void RedisplayAll();
-
-private:
-	static DrawObjBase* m_DrawAndControl;
-	static int m_MainWindow;
-	static int m_SimuWindow;
-	static int m_InfoWindow;
-	static int m_PopupMenu;
-	static WindowParams m_params;
-	static DisplayParams m_DisplayParam;
-
-
-
-private:
-	//this area for code testing , remove later
-
-
-};
-} /* namespace Graphics */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\PlannerTestDraw.h" new_path="" added_lines="0" deleted_lines="159">
				<diff>@@ -1,159 +0,0 @@
-/*
- * PlannerTestDraw.h
- *
- *  Created on: Jun 17, 2016
- *      Author: hatem
- */
-
-#ifndef PLANNERTESTDRAW_H_
-#define PLANNERTESTDRAW_H_
-#include &lt;iostream&gt;
-#include "DrawObjBase.h"
-#include "op_planner/RoadNetwork.h"
-#include "CarState.h"
-#include "DrawingHelpers.h"
-#include "TrajectoryFollower.h"
-#include "SimulatedTrajectoryFollower.h"
-#include "Graph2dBase.h"
-#include "op_planner/LocalPlannerH.h"
-
-namespace Graphics
-{
-
-#define STEERING_AXIS 0
-#define ACCELERATION_AXIS 1
-#define BRAKE_AXIS 2
-#define BUTTON_INDEX 0
-#define START_BUTTON_VALUE 512
-
-class PlannerTestDraw : public DrawObjBase
-{
-public:
-	PlannerTestDraw();
-	virtual ~PlannerTestDraw();
-
-	void DrawSimu();
-	void DrawInfo(const int&amp; centerX, const int&amp; centerY, const int&amp; maxX, const int&amp; maxY);
-	void OnLeftClick(const double&amp; x, const double&amp; y);
-	void OnRightClick(const double&amp; x, const double&amp; y);
-	void OnKeyboardPress(const SPECIAL_KEYS_TYPE&amp; sKey, const unsigned char&amp; key);
-	void LoadMaterials();
-	void Reset();
-    bool IsInitState();
-    void UpdatePlaneStartGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2);
-    void AddSimulatedCarPos(const double&amp; x,const double&amp; y, const double&amp; a);
-
-	 static void* PlanningThreadStaticEntryPoint(void* pThis);
-	 static void* ControlThreadStaticEntryPoint(void* pThis);
-	 static void* SimulationThreadStaticEntryPoint(void* pThis);
-	 static void* GameWheelThreadStaticEntryPoint(void* pThis);
-
-
-	 void InitStartAndGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2);
-
-
-public:
-	 PlannerHNS::RoadNetwork m_RoadMap;
-
-	std::vector&lt;PlannerHNS::WayPoint&gt; m_goals;
-	int m_iCurrentGoal;
-	PlannerHNS::WayPoint m_start;
-	bool				 m_bMakeNewPlan;
-	bool 				 m_bResetForSimulation;
-	bool				 m_bGreenTrafficLight;
-//	PlannerHNS::WayPoint m_SlowDown;
-//	PlannerHNS::WayPoint m_GoNormal;
-	bool m_bStartSlow;
-
-	pthread_mutex_t planning_mutex;
-	pthread_mutex_t control_mutex;
-	pthread_mutex_t simulation_mutex;
-
-	pthread_t planning_thread_tid;
-	pthread_t control_thread_tid;
-	pthread_t simulation_thread_tid;
-	pthread_t game_wheel_thread_tid;
-
-	bool m_bCancelThread;
-	PlannerHNS::ControllerParams m_ControlParams;
-	PlannerHNS::CAR_BASIC_INFO m_CarInfo;
-	PlannerHNS::PlanningParams m_PlanningParams;
-	double m_PlanningCycleTime;
-	double m_ControlCycleTime;
-	double m_SimulationCycleTime;
-
-	PlannerHNS::VehicleState m_VehicleTargetState;
-	PlannerHNS::VehicleState m_VehicleCurrentState;
-	PlannerHNS::BehaviorState m_CurrentBehavior;
-
-	PlannerHNS::LocalPlannerH 	m_LocalPlanner;
-	PlannerHNS::GPSPoint 		m_FollowPoint;
-	PlannerHNS::GPSPoint 		m_PerpPoint;
-	double m_LateralError;
-	std::vector&lt;DisplayDataObj&gt; m_DisplayList;
-
-	GLMmodel* m_CarModel;
-	std::vector&lt;PlannerHNS::WayPoint&gt; m_ActualPath;
-	std::vector&lt;PlannerHNS::DetectedObject&gt; m_dummyObstacles;
-	std::vector&lt;SimulationNS::SimulatedCarState&gt; m_SimulatedCars;
-	std::vector&lt;PlannerHNS::BehaviorState&gt; m_SimulatedBehaviors;
-	std::vector&lt;PlannerHNS::VehicleState&gt;  m_SimulatedVehicleState;
-	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; m_SimulatedPrevTrajectory;
-	std::vector&lt;SimulationNS::SimulatedTrajectoryFollower&gt; m_SimulatedPathFollower;
-
-	std::vector&lt;PlannerHNS::WayPoint*&gt; m_all_cell_to_delete;
-
-	//Game Wheel Controller
-	double m_SteeringAngle;
-	double m_Acceleration;
-	double m_Braking;
-	bool   m_bStart;
-
-private:
-	void PrepareVectorMapForDrawing();
-	void DrawVectorMap();
-
-
-	std::vector&lt;int&gt; m_LanesIds;
-	std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt; m_ReadyToDrawLanes;
-	std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt; m_ReadyToDrawCenterLines;
-
-
-	void DetectSimulatedObstacles(std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-	void TransToCarCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-	void TransToWorldCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-
-	void SaveSimulationData();
-	void LoadSimulationData();
-	void AddSimulatedCar(const double&amp; x,const double&amp; y, const double&amp; a, const double&amp; v);
-
-
-	/**
-	 * Draw Infor Section
-	 */
-	Graph2dBase* m_pVelocityGraph;
-	Graph2dBase* m_pSteeringGraph;
-	Graph2dBase* m_pLateralErrGraph;
-
-	double m_GlobalPlanningTime;
-	double m_LocalPlanningTime;
-	double m_ControllingTime;
-	double m_ObjectTrakingTime;
-	double m_SimulationTime;
-	int m_iStepNumber;
-
-
-	//Sub drawing functions
-private:
-	void DrawStartsAndGoals();
-	void DrawTrafficInfo_StopLines_Lights();
-	void DrawCarModels();
-	void DrawPaths();
-	void DrawAdditionalDebugInfo();
-
-
-};
-
-} /* namespace Graphics */
-
-#endif /* PLANNERTESTDRAW_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\SimpleTracker.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\SimpleTracker.h" added_lines="5" deleted_lines="6">
				<diff>@@ -1,9 +1,8 @@
-/*
- * SimpleTracker.h
- *
- *  Created on: Aug 11, 2016
- *      Author: hatem
- */
+
+/// \file SimpleTracker.h
+/// \brief Kalman Filter based object tracker
+/// \author Hatem Darweesh
+/// \date Aug 11, 2016
 
 #ifndef SimpleTracker_H_
 #define SimpleTracker_H_
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\TrajectoryFollower.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\TrajectoryFollower.h" added_lines="6" deleted_lines="6">
				<diff>@@ -1,9 +1,9 @@
-/*
- * TrajectoryFollower.h
- *
- *  Created on: Jun 18, 2016
- *      Author: hatem
- */
+
+/// \file TrajectoryFollower.h
+/// \brief PID based trajectory follower
+/// \author Hatem Darweesh
+/// \date Jun 18, 2016
+
 
 #ifndef TRAJECTORYFOLLOWER_H_
 #define TRAJECTORYFOLLOWER_H_
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\glm.h" new_path="" added_lines="0" deleted_lines="259">
				<diff>@@ -1,259 +0,0 @@
-
-#ifndef GLM_MODELDRAW_
-#define GLM_MODELDRAW_
-
-#include "GL/glut.h"
-
-namespace Graphics
-{
-
-#ifndef M_PI
-#define M_PI 3.14159265
-#endif
-
-#define GLM_NONE     (0)            /* render with only vertices */
-#define GLM_FLAT     (1 &lt;&lt; 0)       /* render with facet normals */
-#define GLM_SMOOTH   (1 &lt;&lt; 1)       /* render with vertex normals */
-#define GLM_TEXTURE  (1 &lt;&lt; 2)       /* render with texture coords */
-#define GLM_COLOR    (1 &lt;&lt; 3)       /* render with colors */
-#define GLM_MATERIAL (1 &lt;&lt; 4)       /* render with materials */
-
-
-/* GLMmaterial: Structure that defines a material in a model. 
- */
-typedef struct _GLMmaterial
-{
-  char*   name;                 /* name of material */
-  GLfloat diffuse[4];           /* diffuse component */
-  GLfloat ambient[4];           /* ambient component */
-  GLfloat specular[4];          /* specular component */
-  GLfloat emmissive[4];         /* emmissive component */
-  GLfloat shininess;            /* specular exponent */
-} GLMmaterial;
-
-/* GLMtriangle: Structure that defines a triangle in a model.
- */
-typedef struct _GLMtriangle {
-  GLuint vindices[3];           /* array of triangle vertex indices */
-  GLuint nindices[3];           /* array of triangle normal indices */
-  GLuint tindices[3];           /* array of triangle texcoord indices*/
-  GLuint findex;                /* index of triangle facet normal */
-} GLMtriangle;
-
-/* GLMgroup: Structure that defines a group in a model.
- */
-typedef struct _GLMgroup {
-  char*             name;           /* name of this group */
-  GLuint            numtriangles;   /* number of triangles in this group */
-  GLuint*           triangles;      /* array of triangle indices */
-  GLuint            material;       /* index to material for group */
-  struct _GLMgroup* next;           /* pointer to next group in model */
-} GLMgroup;
-
-/* GLMmodel: Structure that defines a model.
- */
-typedef struct _GLMmodel {
-  char*    pathname;            /* path to this model */
-  char*    mtllibname;          /* name of the material library */
-
-  GLuint   numvertices;         /* number of vertices in model */
-  GLfloat* vertices;            /* array of vertices  */
-
-  GLuint   numnormals;          /* number of normals in model */
-  GLfloat* normals;             /* array of normals */
-
-  GLuint   numtexcoords;        /* number of texcoords in model */
-  GLfloat* texcoords;           /* array of texture coordinates */
-
-  GLuint   numfacetnorms;       /* number of facetnorms in model */
-  GLfloat* facetnorms;          /* array of facetnorms */
-
-  GLuint       numtriangles;    /* number of triangles in model */
-  GLMtriangle* triangles;       /* array of triangles */
-
-  GLuint       nummaterials;    /* number of materials in model */
-  GLMmaterial* materials;       /* array of materials */
-
-  GLuint       numgroups;       /* number of groups in model */
-  GLMgroup*    groups;          /* linked list of groups */
-
-  GLfloat position[3];          /* position of the model */
-
-} GLMmodel;
-
-
-/* glmUnitize: "unitize" a model by translating it to the origin and
- * scaling it to fit in a unit cube around the origin.  Returns the
- * scalefactor used.
- *
- * model - properly initialized GLMmodel structure 
- */
-GLfloat glmUnitize(GLMmodel* model);
-
-/* glmDimensions: Calculates the dimensions (width, height, depth) of
- * a model.
- *
- * model      - initialized GLMmodel structure
- * dimensions - array of 3 GLfloats (GLfloat dimensions[3])
- */
-GLvoid glmDimensions(GLMmodel* model, GLfloat* dimensions);
-
-/* glmScale: Scales a model by a given amount.
- * 
- * model - properly initialized GLMmodel structure
- * scale - scalefactor (0.5 = half as large, 2.0 = twice as large)
- */
-GLvoid glmScale(GLMmodel* model, GLfloat scale);
-
-/* glmReverseWinding: Reverse the polygon winding for all polygons in
- * this model.  Default winding is counter-clockwise.  Also changes
- * the direction of the normals.
- * 
- * model - properly initialized GLMmodel structure 
- */
-GLvoid glmReverseWinding(GLMmodel* model);
-
-/* glmFacetNormals: Generates facet normals for a model (by taking the
- * cross product of the two vectors derived from the sides of each
- * triangle).  Assumes a counter-clockwise winding.
- *
- * model - initialized GLMmodel structure
- */
-GLvoid glmFacetNormals(GLMmodel* model);
-
-/* glmVertexNormals: Generates smooth vertex normals for a model.
- * First builds a list of all the triangles each vertex is in.  Then
- * loops through each vertex in the the list averaging all the facet
- * normals of the triangles each vertex is in.  Finally, sets the
- * normal index in the triangle for the vertex to the generated smooth
- * normal.  If the dot product of a facet normal and the facet normal
- * associated with the first triangle in the list of triangles the
- * current vertex is in is greater than the cosine of the angle
- * parameter to the function, that facet normal is not added into the
- * average normal calculation and the corresponding vertex is given
- * the facet normal.  This tends to preserve hard edges.  The angle to
- * use depends on the model, but 90 degrees is usually a good start.
- *
- * model - initialized GLMmodel structure
- * angle - maximum angle (in degrees) to smooth across
- */
-GLvoid glmVertexNormals(GLMmodel* model, GLfloat angle);
-
-/* glmLinearTexture: Generates texture coordinates according to a
- * linear projection of the texture map.  It generates these by
- * linearly mapping the vertices onto a square.
- *
- * model - pointer to initialized GLMmodel structure
- */
-GLvoid glmLinearTexture(GLMmodel* model);
-
-/* glmSpheremapTexture: Generates texture coordinates according to a
- * spherical projection of the texture map.  Sometimes referred to as
- * spheremap, or reflection map texture coordinates.  It generates
- * these by using the normal to calculate where that vertex would map
- * onto a sphere.  Since it is impossible to map something flat
- * perfectly onto something spherical, there is distortion at the
- * poles.  This particular implementation causes the poles along the X
- * axis to be distorted.
- *
- * model - pointer to initialized GLMmodel structure
- */
-GLvoid glmSpheremapTexture(GLMmodel* model);
-
-/* glmDelete: Deletes a GLMmodel structure.
- *
- * model - initialized GLMmodel structure
- */
-GLvoid glmDelete(GLMmodel* model);
-
-/* glmReadOBJ: Reads a model description from a Wavefront .OBJ file.
- * Returns a pointer to the created object which should be free'd with
- * glmDelete().
- *
- * filename - name of the file containing the Wavefront .OBJ format data.  
- */
-GLMmodel*  glmReadOBJ(char* filename);
-
-/* glmWriteOBJ: Writes a model description in Wavefront .OBJ format to
- * a file.
- *
- * model    - initialized GLMmodel structure
- * filename - name of the file to write the Wavefront .OBJ format data to
- * mode     - a bitwise or of values describing what is written to the file
- *            GLM_NONE    -  write only vertices
- *            GLM_FLAT    -  write facet normals
- *            GLM_SMOOTH  -  write vertex normals
- *            GLM_TEXTURE -  write texture coords
- *            GLM_FLAT and GLM_SMOOTH should not both be specified.
- */
-GLvoid glmWriteOBJ(GLMmodel* model, char* filename, GLuint mode);
-
-/* glmDraw: Renders the model to the current OpenGL context using the
- * mode specified.
- *
- * model    - initialized GLMmodel structure
- * mode     - a bitwise OR of values describing what is to be rendered.
- *            GLM_NONE    -  render with only vertices
- *            GLM_FLAT    -  render with facet normals
- *            GLM_SMOOTH  -  render with vertex normals
- *            GLM_TEXTURE -  render with texture coords
- *            GLM_FLAT and GLM_SMOOTH should not both be specified.
- */
-GLvoid glmDraw(GLMmodel* model, GLuint mode);
-
-/* glmList: Generates and returns a display list for the model using
- * the mode specified.
- *
- * model    - initialized GLMmodel structure
- * mode     - a bitwise OR of values describing what is to be rendered.
- *            GLM_NONE    -  render with only vertices
- *            GLM_FLAT    -  render with facet normals
- *            GLM_SMOOTH  -  render with vertex normals
- *            GLM_TEXTURE -  render with texture coords
- *            GLM_FLAT and GLM_SMOOTH should not both be specified.  
- */
-GLuint glmList(GLMmodel* model, GLuint mode);
-
-/* glmWeld: eliminate (weld) vectors that are within an epsilon of
- * each other.
- *
- * model      - initialized GLMmodel structure
- * epsilon    - maximum difference between vertices
- *              ( 0.00001 is a good start for a unitized model)
- *
- */
-GLvoid glmWeld(GLMmodel* model, GLfloat epsilon);
-
-/* glmReadPPM: read a PPM raw (type P6) file.  The PPM file has a header
- * that should look something like:
- *
- *    P6
- *    # comment
- *    width height max_value
- *    rgbrgbrgb...
- *
- * where "P6" is the magic cookie which identifies the file type and
- * should be the only characters on the first line followed by a
- * carriage return.  Any line starting with a # mark will be treated
- * as a comment and discarded.   After the magic cookie, three integer
- * values are expected: width, height of the image and the maximum
- * value for a pixel (max_value must be &lt; 256 for PPM raw files).  The
- * data section consists of width*height rgb triplets (one byte each)
- * in binary format (i.e., such as that written with fwrite() or
- * equivalent).
- *
- * The rgb data is returned as an array of unsigned chars (packed
- * rgb).  The malloc()'d memory should be free()'d by the caller.  If
- * an error occurs, an error message is sent to stderr and NULL is
- * returned.
- *
- * filename   - name of the .ppm file.
- * width      - will contain the width of the image on return.
- * height     - will contain the height of the image on return.
- *
- */
-GLubyte* glmReadPPM(char* filename, int* width, int* height);
-
-}
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\main.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\main.cpp" added_lines="0" deleted_lines="29">
				<diff>@@ -6,38 +6,9 @@
  */
 
 #include &lt;iostream&gt;
-#include "op_simu/AlternativeVisualizer.h"
-#include "op_simu/MainWindowWrapper.h"
-#include "op_simu/PlannerTestDraw.h"
-
-using namespace  Graphics;
-#define USE_ALT_VISUALIZER 1
 
 int main(int argc, char** argv)
 {
-	DrawObjBase* pSimulator =  0;
-	if(USE_ALT_VISUALIZER == 1)
-		pSimulator = new AlternativeVisualizer();
-	else
-		pSimulator = new PlannerTestDraw();
-
-	WindowParams pms;
-	DisplayParams dpms;
-	dpms.centerRotX = 0;
-	dpms.centerRotY = 0;
-	dpms.translateX = 0;
-	dpms.translateY = 0;
-	MainWindowWrapper wrapper(pSimulator);
-	wrapper.UpdateParams(pms, dpms);
-	wrapper.InitOpenGLWindow(argc, argv);
-
-//	delete pSimulator;
-//	pSimulator = 0;
-
-//	glutInit(&amp;argc, argv);
-//	MainGlWindow mw;
-//	glutMainLoop();
-
 
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\AlternativeVisualizer.cpp" new_path="" added_lines="0" deleted_lines="412">
				<diff>@@ -1,412 +0,0 @@
-/*
- * AlternativeVisualizer.cpp
- *
- *  Created on: Jun 17, 2016
- *      Author: hatem
- */
-
-#include "op_simu/AlternativeVisualizer.h"
-#include "op_planner/PlannerH.h"
-#include "op_planner/PlanningHelpers.h"
-#include "op_planner/MappingHelpers.h"
-#include &lt;sstream&gt;
-#include "op_planner/MatrixOperations.h"
-#include "op_simu/SimpleTracker.h"
-#include "op_utility/DataRW.h"
-#include &lt;algorithm&gt;
-
-
-using namespace std;
-using namespace SimulationNS;
-using namespace UtilityHNS;
-using namespace PlannerHNS;
-
-
-namespace Graphics
-{
-
-AlternativeVisualizer::AlternativeVisualizer()
-{
-	/**
-	 * Writing the kml file for the RoadNetwork Map
-	 */
-//	std::vector&lt;TrafficLight&gt; trafficLights;
-//	std::vector&lt;GPSPoint&gt; stopLines;
-//	PlannerHNS::MappingHelpers::CreateKmlFromLocalizationPathFile("/home/user/Downloads/pose.csv", 50, 0.5, trafficLights, stopLines);
-//	string kml_templateFilePath = UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmlTemplateFile;
-//	string kml_fileToSave =UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmltargetFile;
-//	PlannerHNS::MappingHelpers::WriteKML(kml_fileToSave, kml_templateFilePath, m_RoadMap);
-//	PlannerHNS::MappingHelpers::LoadKML("/home/user/SimuLogs/road_network_test.kml", m_RoadMap);
-
-	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles("/media/hatem/8ac0c5d5-8793-4b98-8728-55f8d67ec0f4/data/ToyotaCity2/map/vector_map/", m_RoadMap);
-	m_start =  PlannerHNS::MappingHelpers::GetFirstWaypoint(m_RoadMap);
-	PrepareVectorMapForDrawing();
-}
-
-void AlternativeVisualizer::LoadMaterials()
-{
-}
-
-AlternativeVisualizer::~AlternativeVisualizer()
-{
-}
-
-bool AlternativeVisualizer::IsInitState()
-{
-	return false;
-}
-
-void AlternativeVisualizer::UpdatePlaneStartGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2)
-{
-	m_start.pos.x = x1;
-	m_start.pos.y = y1;
-	m_start.pos.a = a1;
-
-	m_goal.pos.x = x2;
-	m_goal.pos.y = y2;
-	m_goal.pos.a = a2;
-
-	PlannerHNS::PlannerH planner;
-	m_GeneratedPath.clear();
-	planner.PlanUsingReedShepp(m_start, m_goal, m_GeneratedPath, 0.5, 20);
-	cout &lt;&lt; "Path is Generated: " &lt;&lt; m_GeneratedPath.size() &lt;&lt; endl;
-}
-
-void AlternativeVisualizer::AddSimulatedCarPos(const double&amp; x,const double&amp; y, const double&amp; a)
-{
-}
-
-void AlternativeVisualizer::Reset()
-{
-}
-
-void AlternativeVisualizer::PrepareVectorMapForDrawing()
-{
-	double distance_to_nearest_lane = 1;
-	int j=0;
-	int max_number_of_lanes = 500;
-	double width_ratio = 2.0;
-
-	vector&lt;PlannerHNS::Lane*&gt; currLane;
-	vector&lt;PlannerHNS::Lane*&gt; lanes_list;
-	vector&lt;PlannerHNS::Lane*&gt; traversed_lanes;
-
-	while(distance_to_nearest_lane &lt; 100 &amp;&amp; currLane.size() == 0)
-	{
-		PlannerHNS::Lane* pL = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(m_start, m_RoadMap, distance_to_nearest_lane);
-		if(pL)
-			currLane.push_back(pL);
-		distance_to_nearest_lane += 2;
-	}
-
-	if(currLane.size()==0)
-	{
-		if(m_RoadMap.roadSegments.size() &gt; 0)
-			if(m_RoadMap.roadSegments.at(0).Lanes.size()&gt;0)
-				currLane.push_back(&amp;m_RoadMap.roadSegments.at(0).Lanes.at(0));
-	}
-
-	for(unsigned int i=0; i&lt; currLane.size(); i++)
-		lanes_list.push_back(currLane[i]);
-
-	m_ReadyToDrawLanes.clear();
-	m_ReadyToDrawCenterLines.clear();
-
-	if(currLane.size() &gt; 0)
-	{
-		std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; ready_to_draw;
-
-		while(lanes_list.size()&gt;0 &amp;&amp; j &lt;max_number_of_lanes)
-		{
-			ready_to_draw.clear();
-			PlannerHNS::Lane* l = lanes_list.at(0);
-			lanes_list.erase(lanes_list.begin()+0);
-			traversed_lanes.push_back(l);
-
-
-			vector&lt;PlannerHNS::WayPoint&gt; path_local = l-&gt;points;
-
-			DrawingHelpers::PreparePathForDrawing(path_local,ready_to_draw, 2.8 / width_ratio, 0.5);
-			m_ReadyToDrawLanes.push_back(ready_to_draw);
-
-			ready_to_draw.clear();
-			DrawingHelpers::PreparePathForDrawing(path_local,ready_to_draw, 0.1, 0.5);
-			m_ReadyToDrawCenterLines.push_back(ready_to_draw);
-
-
-			j++;
-
-			PlannerHNS::MappingHelpers::GetUniqueNextLanes(l, traversed_lanes, lanes_list);
-		}
-	}
-}
-
-void AlternativeVisualizer::medianfilter(std::vector&lt;double&gt; signal, std::vector&lt;double&gt;&amp; result, int nOrder)
-{
-	int nNewSize = signal.size()/nOrder;
-
-	for(int i=0; i &lt; nNewSize; i++)
-	{
-		int index = i*nOrder;
-		vector&lt;double&gt; temp;
-		temp.insert(temp.begin(), signal.begin()+index, signal.begin()+index+nOrder);
-		std::sort(temp.begin(), temp.end());
-		result.push_back(temp.at(nOrder/2));
-	}
-
-}
-
-void AlternativeVisualizer::DrawGPSData()
-{
-
-	// 1- Load Data From file
-	vector&lt;UtilityHNS::GPSDataReader::GPSBasicData&gt; gps_data;
-	GPSDataReader gps_reader("/home/user/Temp_folder/GPSRawData-noisy.csv");
-	gps_reader.ReadAllData(gps_data);
-	vector&lt;WayPoint&gt; gpsDataPath;
-
-	// 2- Convert to OpenPlanner data structure
-	for(int i = gps_data.size()-1; i &gt;=0 ; i--)
-	{
-		WayPoint p ;
-		p.pos.lat = p.pos.x = gps_data.at(i).lat;
-		p.pos.lon = p.pos.y = gps_data.at(i).lon;
-		p.pos.alt = p.pos.z = gps_data.at(i).alt;
-		gpsDataPath.push_back(p);
-	}
-
-	// 3- Specify Origini for transformation
-	GPSPoint origin;
-	if(gpsDataPath.size() &gt; 0)
-	{
-		origin = gpsDataPath.at(0).pos;
-		m_followX = gpsDataPath.at(0).pos.x;
-		m_followY = gpsDataPath.at(0).pos.y;
-		m_followZ = gpsDataPath.at(0).pos.z;
-		m_followA = gpsDataPath.at(0).pos.a;
-	}
-
-	// 4- Convert to Cartesian and scale Up
-//	MappingHelpers::llaToxyz(origin, GPSPoint());
-//	GPSPoint prevP = origin;
-//	vector&lt;double&gt; x_signal;
-//	vector&lt;double&gt; y_signal;
-//	for(unsigned int i = 0 ; i &lt; gpsDataPath.size(); i++)
-//	{
-//		MappingHelpers::llaToxyz(gpsDataPath.at(i).pos, origin);
-//		gpsDataPath.at(i).pos.x = gpsDataPath.at(i).pos.x * 100000;
-//		gpsDataPath.at(i).pos.y = gpsDataPath.at(i).pos.y * 100000;
-//
-//		x_signal.push_back(gpsDataPath.at(i).pos.x);
-//		y_signal.push_back(gpsDataPath.at(i).pos.y);
-//
-//		prevP = gpsDataPath.at(i).pos;
-//	}
-
-
-	// 5- using cojugate grandient
-	vector&lt;WayPoint&gt; gpsDataPathSmoothed;
-	gpsDataPathSmoothed = gpsDataPath;
-	PlanningHelpers::CalcAngleAndCost(gpsDataPathSmoothed);
-
-	PlanningHelpers::SmoothPath(gpsDataPathSmoothed, 0.3, 0.46, 1.5);
-
-
-	// 6- using kalman filter
-	vector&lt;WayPoint&gt; gpsDataPathSmoothedKalman = gpsDataPath;
-/*	KFTrackV kf(origin.x, origin.y, origin.a, 0, 1);
-	for(unsigned int i = 0 ; i &lt; gpsDataPathSmoothedKalman.size(); i++)
-	{
-		GPSPoint p = gpsDataPathSmoothedKalman.at(i).pos;
-		kf.UpdateTracking(0.1, p.x, p.y, p.a, p.x, p.y, p.a, gpsDataPathSmoothedKalman.at(i).v);
-		gpsDataPathSmoothedKalman.at(i).pos = p;
-	}
-*/
-	// 7- using median filter with order n
-	vector&lt;double&gt; x_signal_res;
-	vector&lt;double&gt; y_signal_res;
-	vector&lt;WayPoint&gt; gpsDataPathSmoothedMedian;
-
-	//medianfilter(x_signal, x_signal_res, 3);
-	//medianfilter(y_signal, y_signal_res, 3);
-
-	for(unsigned int i =0 ; i &lt; x_signal_res.size(); i++)
-	{
-		WayPoint p ;
-		p.pos.x = x_signal_res.at(i);
-		p.pos.y = y_signal_res.at(i);
-
-		gpsDataPathSmoothedMedian.push_back(p);
-	}
-
-
-	// 8- Visualizing results
-	float PathColor[3] = {1.0, 0.0, 0.0};
-	float SmoothPathColor[3] = {0.0, 1.0, 0.0};
-	float kalmanPathColor[3] = {0.0, 0.0, 1.0};
-	float medianPathColor[3] = {1.0, 1.0, 0.0};
-
-	glDisable(GL_LIGHTING);
-	glPushMatrix();
-	glTranslated(3,10,0);
-	DrawingHelpers::DrawWidePath(gpsDataPath, 0.2, 0.05, PathColor , false);
-	glPopMatrix();
-
-	glPushMatrix();
-	glTranslated(6,10,0);
-	DrawingHelpers::DrawWidePath(gpsDataPathSmoothed, 0.1, 0.05, SmoothPathColor , false);
-	glPopMatrix();
-
-	glPushMatrix();
-	glTranslated(9,10,0);
-	DrawingHelpers::DrawWidePath(gpsDataPathSmoothedKalman, 0.3, 0.05, kalmanPathColor , false);
-	glPopMatrix();
-
-	glPushMatrix();
-	glTranslated(12,10,0);
-	DrawingHelpers::DrawWidePath(gpsDataPathSmoothedMedian, 0.4, 0.05, medianPathColor , false);
-	glPopMatrix();
-
-	glEnable(GL_LIGHTING);
-
-}
-
-void AlternativeVisualizer::DrawVectorMap()
-{
-	glDisable(GL_LIGHTING);
-	float PathColor[3];
-	float Color1[3]; Color1[0] = 1.0; Color1[1] = 204.0/256.0; Color1[2] = 51.0/256.0;
-	float Color2[3]; Color2[0] = 1.0; Color2[1] = 102.0/256.0; Color2[2] = 51.0/256.0;
-	float Color3[3]; Color3[0] = 1.0; Color3[1] = 51.0/256.0;  Color3[2] = 102.0/256.0;
-	float Color4[3]; Color4[0] = 204.0/256.0; Color4[1] = 51.0/256.0; Color4[2] = 1.0;
-
-	const float mapdata_z = 0.005;
-
-	for(unsigned int i=0; i&lt;m_ReadyToDrawLanes.size(); i++)
-	{
-		//PathColor[0]=0.5;PathColor[1] = j/20.0; PathColor[2] = j;
-		if(i==0)
-		{
-			PathColor[0]=0.25 ;PathColor[1] = 0.25; PathColor[2] = 0.25;
-		}
-		else
-		{
-			double inc_color = (double)i/25.0;
-			PathColor[0]=0.25 + inc_color; ;PathColor[1] = 0.25+inc_color; PathColor[2] = 0.25 + inc_color;
-		}
-
-		//PathColor[0]=0.25 ;PathColor[1] = 0.25; PathColor[2] = 0.25;
-		if(i%4 == 0)
-		{
-			PathColor[0] = Color1[0]; PathColor[1] = Color1[1]; PathColor[2] = Color1[2];
-		}
-		else if(i%4 == 1)
-		{
-			PathColor[0] = Color2[0]; PathColor[1] = Color2[1]; PathColor[2] = Color2[2];
-		}
-		else if(i%4 == 2)
-		{
-			PathColor[0] = Color3[0]; PathColor[1] = Color3[1]; PathColor[2] = Color3[2];
-		}
-		else if(i%4 == 3)
-		{
-			PathColor[0] = Color4[0]; PathColor[1] = Color4[1]; PathColor[2] = Color4[2];
-		}
-
-		PathColor[0] = PathColor[0]*0.15;
-		PathColor[1] = PathColor[1]*0.95;
-		PathColor[2] = PathColor[2]*0.95;
-		PathColor[0]=0.4;PathColor[1] = 0.4; PathColor[2] = 0.4;
-		DrawingHelpers::DrawPrePreparedPolygons(m_ReadyToDrawLanes[i], mapdata_z, PathColor);
-
-		PathColor[0]=0.97;PathColor[1] = 0.97; PathColor[2] = 0.97;
-		DrawingHelpers::DrawPrePreparedPolygons(m_ReadyToDrawCenterLines[i], mapdata_z+0.015, PathColor, 1);
-	}
-
-	glEnable(GL_LIGHTING);
-}
-
-void AlternativeVisualizer::DrawSimu()
-{
-
-
-	//DrawGPSData();
-	//DrawVectorMap();
-	float color[] = {0, 1, 0};
-	DrawingHelpers::DrawWidePath(m_GeneratedPath, 0.5, 0.5, color);
-}
-
-void AlternativeVisualizer::DrawInfo(const int&amp; centerX, const int&amp; centerY, const int&amp; maxX, const int&amp; maxY)
-{
-}
-
-void AlternativeVisualizer::OnLeftClick(const double&amp; x, const double&amp; y)
-{}
-
-void AlternativeVisualizer::OnRightClick(const double&amp; x, const double&amp; y)
-{}
-
-void AlternativeVisualizer::OnKeyboardPress(const SPECIAL_KEYS_TYPE&amp; sKey, const unsigned char&amp; key)
-{
-	//std::cout &lt;&lt; "key" &lt;&lt; std::endl;
-
-	switch(key)
-	{
-	case 's':
-		break;
-	case 'v':
-	{
-	}
-	break;
-	case 'l':
-	{
-	}
-	break;
-	case 'n':
-	{
-	}
-	break;
-	case 'g':
-	{
-	}
-	break;
-	default:
-		break;
-
-	}
-}
-
-void AlternativeVisualizer::TransToCarCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
-{
-	PlannerHNS::Mat3 rotationMat(-currPose.pos.a);
-	PlannerHNS::Mat3 translationMat(-currPose.pos.x, -currPose.pos.y);
-	for(unsigned int i=0; i &lt; obj_list.size(); i++)
-	{
-		obj_list.at(i).center.pos = translationMat*obj_list.at(i).center.pos;
-		obj_list.at(i).center.pos = rotationMat*obj_list.at(i).center.pos;
-		for(unsigned int j = 0 ; j &lt; obj_list.at(i).contour.size(); j++)
-		{
-			obj_list.at(i).contour.at(j) = translationMat*obj_list.at(i).contour.at(j);
-			obj_list.at(i).contour.at(j) = rotationMat*obj_list.at(i).contour.at(j);
-		}
-	}
-}
-
-void AlternativeVisualizer::TransToWorldCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
-{
-	PlannerHNS::Mat3 rotationMat(currPose.pos.a);
-	PlannerHNS::Mat3 translationMat(currPose.pos.x, currPose.pos.y);
-	for(unsigned int i=0; i &lt; obj_list.size(); i++)
-	{
-		obj_list.at(i).center.pos = rotationMat*obj_list.at(i).center.pos;
-		obj_list.at(i).center.pos = translationMat*obj_list.at(i).center.pos;
-
-		for(unsigned int j = 0 ; j &lt; obj_list.at(i).contour.size(); j++)
-		{
-			obj_list.at(i).contour.at(j) = translationMat*obj_list.at(i).contour.at(j);
-			obj_list.at(i).contour.at(j) = rotationMat*obj_list.at(i).contour.at(j);
-		}
-	}
-}
-
-} /* namespace Graphics */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\CarState.cpp" new_path="" added_lines="0" deleted_lines="1124">
				<diff>@@ -1,1124 +0,0 @@
-/*
- * CarState.cpp
- *
- *  Created on: Jun 20, 2016
- *      Author: hatem
- */
-
-#include "op_simu/CarState.h"
-#include "op_utility/UtilityH.h"
-#include "op_planner/PlanningHelpers.h"
-#include "op_planner/MappingHelpers.h"
-#include "op_planner/MatrixOperations.h"
-#include "op_planner/PlannerH.h"
-#include "op_simu/SimulatedTrajectoryFollower.h"
-
-
-using namespace PlannerHNS;
-using namespace UtilityHNS;
-
-namespace SimulationNS
-{
-
-CarState::CarState()
-{
-	pLane = 0;
-	m_CurrentVelocity =  m_CurrentVelocityD =0;
-	m_CurrentSteering = m_CurrentSteeringD =0;
-	m_CurrentShift 		=  m_CurrentShiftD = SHIFT_POS_NN;
-	m_CurrentAccSteerAngle = m_CurrentAccVelocity = 0;
-	m_pCurrentBehaviorState = 0;
-	m_pGoToGoalState = 0;
-	m_pStopState= 0;
-	m_pWaitState= 0;
-	m_pMissionCompleteState= 0;
-	m_pAvoidObstacleState = 0;
-	m_pTrafficLightStopState = 0;
-	m_pTrafficLightWaitState = 0;
-	m_pFollowState = 0;
-	m_SimulationSteeringDelayFactor = 0.1;
-	UtilityH::GetTickCount(m_SteerDelayTimer);
-	m_PredictionTime = 0;
-
-	InitBehaviorStates();
-}
-
-CarState::~CarState()
-{
-
-}
-
-void CarState::Init(const ControllerParams ctrlParams, const PlannerHNS::PlanningParams&amp; params,const CAR_BASIC_INFO&amp; carInfo)
- 	{
- 		m_CarInfo = carInfo;
- 		m_ControlParams = ctrlParams;
- 		m_CurrentVelocity =  m_CurrentVelocityD =0;
- 		m_CurrentSteering = m_CurrentSteeringD =0;
- 		m_CurrentShift 		=  m_CurrentShiftD = SHIFT_POS_NN;
- 		m_CurrentAccSteerAngle = m_CurrentAccVelocity = 0;
- 		m_Params = params;
-
- 		if(m_pCurrentBehaviorState)
- 			m_pCurrentBehaviorState-&gt;SetBehaviorsParams(&amp;m_Params);
- 	}
-
-void CarState::InitBehaviorStates()
-{
-
-	m_pStopState 				= new StopState(0, 0, 0);
-	m_pMissionCompleteState 	= new MissionAccomplishedState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), 0);
-	m_pGoToGoalState 			= new ForwardState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pMissionCompleteState);
-	m_pWaitState 				= new WaitState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
-	m_pInitState 				= new InitState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
-	m_pFollowState				= new FollowState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
-	m_pAvoidObstacleState		= new SwerveState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
-	m_pTrafficLightStopState	= new TrafficLightStopState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
-	m_pTrafficLightWaitState	= new TrafficLightWaitState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
-
-
-	m_pGoToGoalState-&gt;InsertNextState(m_pStopState);
-	m_pGoToGoalState-&gt;InsertNextState(m_pWaitState);
-	m_pGoToGoalState-&gt;InsertNextState(m_pFollowState);
-	m_pGoToGoalState-&gt;InsertNextState(m_pAvoidObstacleState);
-	m_pGoToGoalState-&gt;InsertNextState(m_pTrafficLightStopState);
-
-	m_pAvoidObstacleState-&gt;InsertNextState(m_pStopState);
-	m_pAvoidObstacleState-&gt;InsertNextState(m_pWaitState);
-	m_pAvoidObstacleState-&gt;InsertNextState(m_pFollowState);
-	m_pAvoidObstacleState-&gt;decisionMakingTime = 0.0;
-	m_pAvoidObstacleState-&gt;InsertNextState(m_pTrafficLightStopState);
-
-	m_pFollowState-&gt;InsertNextState(m_pStopState);
-	m_pFollowState-&gt;InsertNextState(m_pWaitState);
-	m_pFollowState-&gt;InsertNextState(m_pAvoidObstacleState);
-	m_pFollowState-&gt;InsertNextState(m_pTrafficLightStopState);
-
-	m_pStopState-&gt;InsertNextState(m_pGoToGoalState);
-
-	m_pTrafficLightStopState-&gt;InsertNextState(m_pTrafficLightWaitState);
-
-	m_pTrafficLightWaitState-&gt;InsertNextState(m_pTrafficLightStopState);
-
-
-	m_pCurrentBehaviorState = m_pInitState;
-
-}
-
-void CarState::InitPolygons()
-{
-	double l2 = m_CarInfo.length/2.0;
-	double w2 = m_CarInfo.width/2.0;
-
-	m_CarShapePolygon.push_back(GPSPoint(-w2, -l2, 0,0));
-	m_CarShapePolygon.push_back(GPSPoint(w2, -l2, 0,0));
-	m_CarShapePolygon.push_back(GPSPoint(w2, l2, 0,0));
-	m_CarShapePolygon.push_back(GPSPoint(-w2, l2, 0,0));
-
-//	m_CarShapePolygon.push_back(GPSPoint(-w2, -l2, 1,0));
-//	m_CarShapePolygon.push_back(GPSPoint(w2, -l2, 1,0));
-//	m_CarShapePolygon.push_back(GPSPoint(w2, l2, 1,0));
-//	m_CarShapePolygon.push_back(GPSPoint(-w2, l2, 1,0));
-}
-
- void CarState::FirstLocalizeMe(const WayPoint&amp; initCarPos)
- {
-	pLane = initCarPos.pLane;
-	state = initCarPos;
-	m_OdometryState.pos.a = initCarPos.pos.a;
-	m_OdometryState.pos.x = initCarPos.pos.x + (m_CarInfo.wheel_base/2.0 * cos(initCarPos.pos.a));
-	m_OdometryState.pos.y = initCarPos.pos.y + (m_CarInfo.wheel_base/2.0 * sin(initCarPos.pos.a));
- }
-
- void CarState::LocalizeMe(const double&amp; dt)
-{
-	//calculate the new x, y ,
-	 WayPoint currPose = state;
-
-	if(m_CurrentShift == SHIFT_POS_DD)
-	{
-		m_OdometryState.pos.x	 +=  m_CurrentVelocity * dt * cos(currPose.pos.a);
-		m_OdometryState.pos.y	 +=  m_CurrentVelocity * dt * sin(currPose.pos.a);
-		m_OdometryState.pos.a	 +=  m_CurrentVelocity * dt * tan(m_CurrentSteering)  / m_CarInfo.wheel_base;
-
-	}
-	else if(m_CurrentShift == SHIFT_POS_RR )
-	{
-		m_OdometryState.pos.x	 +=  -m_CurrentVelocity * dt * cos(currPose.pos.a);
-		m_OdometryState.pos.y	 +=  -m_CurrentVelocity * dt * sin(currPose.pos.a);
-		m_OdometryState.pos.a	 +=  -m_CurrentVelocity * dt * tan(m_CurrentSteering);
-	}
-
-	m_OdometryState.pos.a = atan2(sin(m_OdometryState.pos.a), cos(m_OdometryState.pos.a));
-	m_OdometryState.pos.a = UtilityH::FixNegativeAngle(m_OdometryState.pos.a);
-
-	state.pos.a = m_OdometryState.pos.a;
-	state.pos.x = m_OdometryState.pos.x	 - (m_CurrentVelocity*dt* (m_CarInfo.wheel_base) * cos (m_OdometryState.pos.a));
-	state.pos.y = m_OdometryState.pos.y	 - (m_CurrentVelocity*dt* (m_CarInfo.wheel_base/2.0) * sin (m_OdometryState.pos.a));
-}
-
- void CarState::UpdateState(const PlannerHNS::VehicleState&amp; state, const bool&amp; bUseDelay)
-  {
-	 if(!bUseDelay)
-	 {
-		 m_CurrentSteering 	= m_CurrentSteeringD;
-		 std::cout &lt;&lt; " No Delay " &lt;&lt; std::endl;
-	 }
-	 else
-	 {
-		 double currSteerDeg = RAD2DEG * m_CurrentSteering;
-		 double desiredSteerDeg = RAD2DEG * m_CurrentSteeringD;
-
-		 double mFact = UtilityH::GetMomentumScaleFactor(state.speed);
-		 double diff = desiredSteerDeg - currSteerDeg;
-		 double diffSign = UtilityH::GetSign(diff);
-		 double inc = 1.0*diffSign;
-		 if(abs(diff) &lt; 1.0 )
-			 inc = diff;
-
-		 std::cout &lt;&lt; "Delay: " &lt;&lt; m_SimulationSteeringDelayFactor
-				 &lt;&lt; ", Fact: " &lt;&lt; mFact
-				 &lt;&lt; ", Diff: " &lt;&lt; diff
-				 &lt;&lt; ", inc: " &lt;&lt; inc &lt;&lt; std::endl;
-		 if(UtilityH::GetTimeDiffNow(m_SteerDelayTimer) &gt; m_SimulationSteeringDelayFactor*mFact)
-		 {
-			 UtilityH::GetTickCount(m_SteerDelayTimer);
-			 currSteerDeg += inc;
-		 }
-
-		 m_CurrentSteering = DEG2RAD * currSteerDeg;
-	 }
-
-	 m_CurrentShift 	= m_CurrentShiftD;
-	 m_CurrentVelocity = m_CurrentVelocityD;
-  }
-
- void CarState::AddAndTransformContourPoints(const PlannerHNS::DetectedObject&amp; obj, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; contourPoints)
- {
-	 contourPoints.clear();
-	 WayPoint  p, p_center = obj.center;
-	 p_center.pos.a += M_PI_2;
-	 for(unsigned int i=0; i&lt; obj.contour.size(); i++)
-	 {
-		 p.pos = obj.contour.at(i);
-		 //TransformPoint(p_center, p.pos);
-		 contourPoints.push_back(p);
-	 }
-
-	 contourPoints.push_back(obj.center);
- }
-
- void CarState::TransformPoint(const PlannerHNS::WayPoint&amp; refPose, PlannerHNS::GPSPoint&amp; p)
- {
- 	PlannerHNS::Mat3 rotationMat(refPose.pos.a);
- 	PlannerHNS::Mat3 translationMat(refPose.pos.x, refPose.pos.y);
-	p = rotationMat*p;
-	p = translationMat*p;
- }
-
- bool CarState::GetNextTrafficLight(const int&amp; prevTrafficLightId, const std::vector&lt;PlannerHNS::TrafficLight&gt;&amp; trafficLights, PlannerHNS::TrafficLight&amp; trafficL)
- {
-	 for(unsigned int i = 0; i &lt; trafficLights.size(); i++)
-	 {
-		 double d = hypot(trafficLights.at(i).pos.y - state.pos.y, trafficLights.at(i).pos.x - state.pos.x);
-		 if(d &lt;= trafficLights.at(i).stoppingDistance)
-		 {
-			 //double a = UtilityH::FixNegativeAngle(atan2(trafficLights.at(i).pos.y - state.pos.y, trafficLights.at(i).pos.x - state.pos.x));
-			 double a_diff = UtilityH::AngleBetweenTwoAnglesPositive(UtilityH::FixNegativeAngle(trafficLights.at(i).pos.a) , UtilityH::FixNegativeAngle(state.pos.a));
-
-			 if(a_diff &lt; M_PI_2 &amp;&amp; trafficLights.at(i).id != prevTrafficLightId)
-			 {
-				 std::cout &lt;&lt; "Detected Light, ID = " &lt;&lt; trafficLights.at(i).id &lt;&lt; ", Distance = " &lt;&lt; d &lt;&lt; ", Angle = " &lt;&lt; trafficLights.at(i).pos.a*RAD2DEG &lt;&lt; ", Car Heading = " &lt;&lt; state.pos.a*RAD2DEG &lt;&lt; ", Diff = " &lt;&lt; a_diff*RAD2DEG &lt;&lt; std::endl;
-				 trafficL = trafficLights.at(i);
-				 return true;
-			 }
-		 }
-	 }
-
-	 return false;
- }
-
- void CarState::CalculateImportantParameterForDecisionMaking(const PlannerHNS::VehicleState&amp; car_state,
-		 const PlannerHNS::GPSPoint&amp; goal,
-			const bool&amp; bEmergencyStop,
-			const bool&amp; bGreenTrafficLight)
- {
- 	PreCalculatedConditions* pValues = m_pCurrentBehaviorState-&gt;GetCalcParams();
-
- 	//Mission Complete
- 	//pValues-&gt;bGoalReached = IsGoalAchieved(goal);
- 	pValues-&gt;minStoppingDistance	= car_state.speed * 3.6 * 1.5;
- 	if(pValues-&gt;distanceToNext &gt; 0 || pValues-&gt;distanceToStop()&gt;0)
- 		pValues-&gt;minStoppingDistance += 1.0;
- 	pValues-&gt;iCentralTrajectory		= m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutNumber/2;
- 	pValues-&gt;stoppingDistances.clear();
- 	pValues-&gt;currentVelocity 		= car_state.speed;
- 	pValues-&gt;bTrafficIsRed 			= false;
- 	pValues-&gt;currentTrafficLightID 	= -1;
- 	pValues-&gt;bRePlan 				= false;
- 	pValues-&gt;bFullyBlock 			= false;
-
- 	FindSafeTrajectory(pValues-&gt;iCurrSafeTrajectory, pValues-&gt;distanceToNext, pValues-&gt;velocityOfNext);
- 	if((pValues-&gt;iCurrSafeTrajectory == -1 &amp;&amp; pValues-&gt;distanceToNext &lt; m_pCurrentBehaviorState-&gt;m_pParams-&gt;minFollowingDistance) || bEmergencyStop )
- 		pValues-&gt;bFullyBlock = true;
-
-
- 	TrafficLight tl;
-
- 	if(GetNextTrafficLight(pValues-&gt;prevTrafficLightID, m_TrafficLights, tl))
- 	{
- 		pValues-&gt;currentTrafficLightID = tl.id;
-
- 	}
-
- 	pValues-&gt;bTrafficIsRed = !bGreenTrafficLight;
-
- 	//cout &lt;&lt; "Distances: " &lt;&lt; pValues-&gt;stoppingDistances.size() &lt;&lt; ", Distance To Stop : " &lt;&lt; pValues-&gt;distanceToStop &lt;&lt; endl;
- }
-
-void CarState::InitializeTrajectoryCosts()
-{
-	PlanningParams* pParams = m_pCurrentBehaviorState-&gt;m_pParams;
-	int centralIndex = pParams-&gt;rollOutNumber/2;
-	std::vector&lt;double&gt; end_distance_list;
-
-	m_TrajectoryCosts.clear();
-
-	//double totalCost = 1.0 / (double)pParams-&gt;rollOutNumber;
-	double totalDistance = 0;
-	for(int i=0; i&lt; pParams-&gt;rollOutNumber+1; i++)
-	{
-		PlannerHNS::TrajectoryCost tc;
-		tc.index = i;
-		tc.relative_index = i - centralIndex;
-		tc.distance_from_center = pParams-&gt;rollOutDensity*tc.relative_index;
-		tc.priority_cost = fabs(tc.distance_from_center);
-		totalDistance += tc.priority_cost;
-		m_TrajectoryCosts.push_back(tc);
-	}
-
-	if(totalDistance==0) return ;
-
-	//Normalize cost
-	for(unsigned int i = 0; i&lt; m_TrajectoryCosts.size(); i++)
-	{
-		m_TrajectoryCosts.at(i).priority_cost = m_TrajectoryCosts.at(i).priority_cost/totalDistance;
-	}
-}
-
-void CarState::CalculateTransitionCosts()
-{
-	PreCalculatedConditions* pValues = m_pCurrentBehaviorState-&gt;GetCalcParams();
-	PlanningParams* pParams = m_pCurrentBehaviorState-&gt;m_pParams;
-
-	double totalDistance = 0;
-	//pValues-&gt;iCurrSafeTrajectory = 4;
-	if(pValues-&gt;iCentralTrajectory &lt; 0)
-		pValues-&gt;iCentralTrajectory = pParams-&gt;rollOutNumber / 2;
-
-	if(pValues-&gt;iCurrSafeTrajectory &lt; 0)
-		pValues-&gt;iCurrSafeTrajectory = pValues-&gt;iCentralTrajectory;
-
-	if(pValues-&gt;iPrevSafeTrajectory &lt; 0)
-		pValues-&gt;iPrevSafeTrajectory = pValues-&gt;iCentralTrajectory;
-
-	for(unsigned int i = 0; i&lt; m_TrajectoryCosts.size(); i++)
-	{
-		m_TrajectoryCosts.at(i).transition_cost = fabs(pParams-&gt;rollOutDensity* (m_TrajectoryCosts.at(i).index - pValues-&gt;iCurrSafeTrajectory));
-		totalDistance += m_TrajectoryCosts.at(i).transition_cost;
-	}
-
-	if(totalDistance==0) return ;
-
-	//Normalize cost
-	for(unsigned int i = 0; i&lt; m_TrajectoryCosts.size(); i++)
-	{
-		m_TrajectoryCosts.at(i).transition_cost = m_TrajectoryCosts.at(i).transition_cost/totalDistance;
-	}
-}
-
-double CarState::PredictTimeCostForTrajectory(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::VehicleState&amp; vstatus, const PlannerHNS::WayPoint&amp; currState)
-{
-	PlanningParams* pParams = m_pCurrentBehaviorState-&gt;m_pParams;
-
-		//1- Calculate time prediction for each trajectory
-	if(path.size() == 0) return 0;
-
-	SimulationNS::SimulatedTrajectoryFollower predControl;
-	ControllerParams params;
-	params.Steering_Gain = PID_CONST(1.5, 0.0, 0.0);
-	params.Velocity_Gain = PID_CONST(0.2, 0.01, 0.1);
-	params.minPursuiteDistance = 3.0;
-
-	predControl.Init(params, m_CarInfo);
-	//double totalDistance = 0;
-	VehicleState CurrentState = vstatus;
-	VehicleState CurrentSteeringD;
-	bool bNewPath = true;
-	WayPoint localState = currState;
-	WayPoint prevState = currState;
-	int iPrevIndex = 0;
-	double accum_time = 0;
-	double pred_max_time = 10.0;
-	double endDistance = pParams-&gt;microPlanDistance/2.0;
-
-	for(unsigned int i = 0 ; i &lt; path.size(); i++)
-	{
-		path.at(i).collisionCost = 0;
-		path.at(i).timeCost = -1;
-	}
-
-	int startIndex = PlanningHelpers::GetClosestNextPointIndexFast(path, state);
-	double total_distance = 0;
-	path.at(startIndex).timeCost = 0;
-	for(unsigned int i=startIndex+1; i&lt;path.size(); i++)
-	{
-		total_distance += hypot(path.at(i).pos.x- path.at(i-1).pos.x,path.at(i).pos.y- path.at(i-1).pos.y);
-		if(m_CurrentVelocity &gt; 0.1 &amp;&amp; total_distance &gt; 0.1)
-			accum_time = total_distance/m_CurrentVelocity;
-		path.at(i).timeCost = accum_time;
-		if(total_distance &gt; endDistance)
-			break;
-	}
-
-//	while(totalDistance &lt; pParams-&gt;microPlanDistance/2.0 &amp;&amp; accum_time &lt; pred_max_time)
-//	{
-//		double dt = 0.05;
-//		PlannerHNS::BehaviorState currMessage;
-//		currMessage.state = FORWARD_STATE;
-//		currMessage.maxVelocity = PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*CurrentState.speed*3.6);
-//
-//		SimulationNS::ControllerParams c_params = m_ControlParams;
-//		c_params.SteeringDelay = m_ControlParams.SteeringDelay / (1.0-UtilityH::GetMomentumScaleFactor(CurrentState.speed));
-//		predControl.Init(c_params, m_CarInfo);
-//		CurrentSteeringD = predControl.DoOneStep(dt, currMessage, path, localState, CurrentState, bNewPath);
-//
-//		if(bNewPath) // first call
-//		{
-//			if(predControl.m_iCalculatedIndex &gt; 0)
-//			{
-//				for(unsigned int j=0; j &lt; predControl.m_iCalculatedIndex; j++)
-//					path.at(j).timeCost = -1;
-//			}
-//		}
-//		else
-//		{
-//			if(predControl.m_iCalculatedIndex != iPrevIndex)
-//				path.at(iPrevIndex).timeCost = accum_time;
-//		}
-//
-//		accum_time+=dt;
-//		bNewPath = false;
-//
-//		//Update State
-//		CurrentState = CurrentSteeringD;
-//
-//		//Localize Me
-//		localState.pos.x	 +=  CurrentState.speed * dt * cos(localState.pos.a);
-//		localState.pos.y	 +=  CurrentState.speed * dt * sin(localState.pos.a);
-//		localState.pos.a	 +=  CurrentState.speed * dt * tan(CurrentState.steer)  / m_CarInfo.wheel_base;
-//
-//		totalDistance += distance2points(prevState.pos, localState.pos);
-//
-//		prevState = localState;
-//		iPrevIndex = predControl.m_iCalculatedIndex;
-//	}
-
-	return accum_time;
-}
-
-void CarState::PredictObstacleTrajectory(PlannerHNS::RoadNetwork&amp; map, const PlannerHNS::WayPoint&amp; pos, const double&amp; predTime, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths)
-{
-	PlannerHNS::PlanningParams planningDefaultParams;
-	planningDefaultParams.rollOutNumber = 0;
-	planningDefaultParams.microPlanDistance = predTime*pos.v;
-
-	planningDefaultParams.pathDensity = 0.5;
-	//PlannerHNS::Lane* pMapLane  = MappingHelpers::GetClosestLaneFromMapDirectionBased(pos, map, 3.0);
-	std::vector&lt;PlannerHNS::Lane*&gt; pMapLanes = MappingHelpers::GetClosestMultipleLanesFromMap(pos, map, 1.5);
-
-	PlannerHNS::PlannerH planner;
-	std::vector&lt;int&gt; LanesIds;
-	std::vector&lt; std::vector&lt;PlannerHNS::WayPoint&gt; &gt;  rollOuts;
-	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; generatedPath;
-
-	if(planningDefaultParams.microPlanDistance &gt; 0)
-	{
-		for(unsigned int i = 0; i &lt; pMapLanes.size(); i++)
-		{
-			std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; loca_generatedPath;
-			planner.PredictPlanUsingDP(pMapLanes.at(i), pos, planningDefaultParams.microPlanDistance, loca_generatedPath);
-			if(loca_generatedPath.size() &gt; 0)
-				generatedPath.insert(generatedPath.begin(),loca_generatedPath.begin(), loca_generatedPath.end());
-		}
-	}
-
-//	planner.GenerateRunoffTrajectory(generatedPath, pos,
-//			planningDefaultParams.enableLaneChange,
-//			pos.v,
-//			planningDefaultParams.microPlanDistance,
-//			m_CarInfo.max_speed_forward,
-//			planningDefaultParams.minSpeed,
-//			planningDefaultParams.carTipMargin,
-//			planningDefaultParams.rollInMargin,
-//			planningDefaultParams.rollInSpeedFactor,
-//			planningDefaultParams.pathDensity,
-//			planningDefaultParams.rollOutDensity,
-//			planningDefaultParams.rollOutNumber,
-//			planningDefaultParams.smoothingDataWeight,
-//			planningDefaultParams.smoothingSmoothWeight,
-//			planningDefaultParams.smoothingToleranceError,
-//			planningDefaultParams.speedProfileFactor,
-//			planningDefaultParams.enableHeadingSmoothing,
-//			rollOuts);
-
-	if(generatedPath.size() &gt; 0)
-	{
-		//path = rollOuts.at(0);
-		paths = generatedPath;
-
-//		PlanningHelpers::GenerateRecommendedSpeed(path,
-//				m_CarInfo.max_speed_forward,
-//				planningDefaultParams.speedProfileFactor);
-//		PlanningHelpers::SmoothSpeedProfiles(path, 0.15,0.35, 0.1);
-	}
-
-	if(pMapLanes.size() ==0 || paths.size() == 0)
-	{
-		paths.clear();
-		generatedPath.clear();
-	}
-	else
-	{
-		//std::cout &lt;&lt; "------------------------------------------------" &lt;&lt;  std::endl;
-		//std::cout &lt;&lt; "Predicted Trajectories for Distance : " &lt;&lt;  planningDefaultParams.microPlanDistance &lt;&lt; std::endl;
-		for(unsigned int j=0; j &lt; paths.size(); j++)
-		{
-			if(paths.at(j).size()==0)
-				continue;
-
-			double timeDelay = 0;
-			double total_distance = 0;
-			paths.at(j).at(0).timeCost = 0;
-			paths.at(j).at(0).v = pos.v;
-			for(unsigned int i=1; i&lt;paths.at(j).size(); i++)
-			{
-				paths.at(j).at(i).v = pos.v;
-				paths.at(j).at(i).pos.a = atan2(paths.at(j).at(i).pos.y - paths.at(j).at(i-1).pos.y, paths.at(j).at(i).pos.x - paths.at(j).at(i-1).pos.x);
-				total_distance += distance2points(paths.at(j).at(i).pos, paths.at(j).at(i-1).pos);
-				if(pos.v &gt; 0.1 &amp;&amp; total_distance &gt; 0.1)
-					timeDelay = total_distance/pos.v;
-				paths.at(j).at(i).timeCost = timeDelay;
-			}
-
-			//std::cout &lt;&lt; "ID : " &lt;&lt;  j &lt;&lt; ", timeDelay : " &lt;&lt; timeDelay &lt;&lt; ", Distance : " &lt;&lt; total_distance &lt;&lt; std::endl;
-		}
-
-		//std::cout &lt;&lt; "------------------------------------------------" &lt;&lt;  std::endl;
-	}
-}
-
-bool CarState::CalculateIntersectionVelocities(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; ego_path, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; predctedPath, const PlannerHNS::DetectedObject&amp; obj)
-{
-	bool bCollisionDetected = false;
-	for(unsigned int k = 0; k &lt; predctedPath.size(); k++)
-	{
-		for(unsigned int j = 0; j &lt; predctedPath.at(k).size(); j++)
-		{
-			bool bCollisionFound =false;
-			for(unsigned int i = 0; i &lt; ego_path.size(); i++)
-			{
-				if(ego_path.at(i).timeCost &gt; 0.0)
-				{
-					double collision_distance = hypot(ego_path.at(i).pos.x-predctedPath.at(k).at(j).pos.x, ego_path.at(i).pos.y-predctedPath.at(k).at(j).pos.y);
-					double contact_distance = hypot(state.pos.x - ego_path.at(i).pos.x,state.pos.y - ego_path.at(i).pos.y);
-					if(collision_distance &lt;= m_CarInfo.width  &amp;&amp; abs(ego_path.at(i).timeCost - predctedPath.at(k).at(j).timeCost)&lt;4.0)
-					{
-						ego_path.at(i).collisionCost = 1;
-						double a = UtilityH::AngleBetweenTwoAnglesPositive(ego_path.at(i).pos.a, predctedPath.at(k).at(j).pos.a);
-						if(a &lt; M_PI_4/2.0)
-							ego_path.at(i).v = obj.center.v;
-						else
-							ego_path.at(i).v = 0;
-						predctedPath.at(k).at(j).collisionCost = 1;
-						bCollisionFound = true;
-						bCollisionDetected = true;
-						break;
-					}
-				}
-			}
-
-			if(bCollisionFound)
-				break;
-		}
-	}
-
-	return bCollisionDetected;
-}
-
-bool CarState::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const PlannerHNS::VehicleState&amp; vstatus, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
-{
-	double predTime = PredictTimeCostForTrajectory(m_Path, vstatus, state);
-	m_PredictedPath.clear();
-	bool bObstacleDetected = false;
-	for(unsigned int i = 0; i &lt; obj_list.size(); i++)
-	{
-		//std::vector&lt;WayPoint&gt; predPath;
-		PredictObstacleTrajectory(map, obj_list.at(i).center, 10.0, m_PredictedPath);
-		bool bObstacle = CalculateIntersectionVelocities(m_Path, m_PredictedPath, obj_list.at(i));
-		if(bObstacle)
-			bObstacleDetected = true;
-	}
-
-	return bObstacleDetected;
-}
-
-//void CarState::CalculateDistanceCosts(const PlannerHNS::VehicleState&amp; vstatus, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
-//{
-//	PlanningParams* pParams = &amp;m_pCurrentBehaviorState-&gt;m_PlanningParams;
-//	double critical_lateral_distance = pParams-&gt;rollOutDensity + m_CarInfo.width/2.0;
-//
-//	if(m_TotalPath.size()==0) return;
-//
-//	//First Filtering
-//	int iEgoIndex = PlanningHelpers::GetClosestPointIndex(m_TotalPath, state);
-//	for(unsigned int i = 0 ; i &lt; obj_list.size(); i++)
-//	{
-//		std::vector&lt;WayPoint&gt; contourPoints;
-//		AddAndTransformContourPoints(obj_list.at(i), contourPoints);
-//
-//		double distance_direct_smallest = 9999999;
-//		double distance_on_trajectory_smallest = 9999999;
-//		for(unsigned int j = 0; j &lt; contourPoints.size(); j++)
-//		{
-//			double distance_direct = distance2points(state.pos, contourPoints.at(j).pos);
-//			if(distance_direct &lt; distance_direct_smallest)
-//				distance_direct_smallest = distance_direct;
-//
-//			double distance_on_trajectory  = PlanningHelpers::GetDistanceOnTrajectory(m_TotalPath, iEgoIndex, contourPoints.at(j)) - m_CarInfo.length/2.0;
-//			if(distance_on_trajectory &gt; 0 &amp;&amp; distance_on_trajectory &lt; distance_on_trajectory_smallest)
-//				distance_on_trajectory_smallest = distance_on_trajectory;
-//		}
-//
-//		for(unsigned int j = 0; j &lt; contourPoints.size(); j++)
-//		{
-//			PlannerHNS::WayPoint wp;
-//			wp = contourPoints.at(j);
-//
-//			double distance_lateral = PlanningHelpers::GetPerpDistanceToTrajectorySimple(m_TotalPath, wp, iEgoIndex);
-//
-////			if(distance_direct &gt; pParams-&gt;horizonDistance)
-////				continue;
-//
-//			for(unsigned int c = 0; c &lt; m_TrajectoryCosts.size(); c++)
-//			{
-//				double normalized_cost = 1.0 - (distance_on_trajectory_smallest / pParams-&gt;minFollowingDistance);
-//				double d_diff = fabs(distance_lateral - m_TrajectoryCosts.at(c).distance_from_center);
-//				m_TrajectoryCosts.at(c).lateral_costs.push_back(std::make_pair(j,d_diff));
-//
-//				if(d_diff &lt; critical_lateral_distance &amp;&amp; (distance_on_trajectory_smallest &lt; m_TrajectoryCosts.at(c).closest_obj_distance || m_TrajectoryCosts.at(c).closest_obj_distance &lt;= 0))
-//				{
-//					//if(normalized_cost &gt; m_TrajectoryCosts.at(c).closest_obj_cost)
-//					{
-//						m_TrajectoryCosts.at(c).closest_obj_cost = normalized_cost;
-//						m_TrajectoryCosts.at(c).closest_obj_distance = distance_on_trajectory_smallest;
-//						m_TrajectoryCosts.at(c).closest_obj_velocity = obj_list.at(i).center.v;
-//
-//					}
-//				}
-//			}
-//		}
-//	}
-//}
-
-void  CarState::FindSafeTrajectory(int&amp; safe_index, double&amp; closest_distance, double&amp; closest_velocity)
-{
-	PlanningParams* pParams = m_pCurrentBehaviorState-&gt;m_pParams;
-
-	//if the  closest_obj_cost is less than 0.9 (12 meter) consider this trajectory blocked
-	closest_distance = pParams-&gt;horizonDistance;
-//	std::cout &lt;&lt; "----------------------------------------------------" &lt;&lt; std::endl;
-//	std::cout &lt;&lt; "&gt;&gt; Costs: " &lt;&lt; std::endl;
-	for(unsigned int c = 0; c &lt; m_TrajectoryCosts.size(); c++)
-	{
-//		std::cout &lt;&lt; m_TrajectoryCosts.at(c).ToString() &lt;&lt; std::endl;
-
-		if(m_TrajectoryCosts.at(c).closest_obj_cost &gt;= 0.6)
-			m_TrajectoryCosts.at(c).cost = 1;
-		else
-			m_TrajectoryCosts.at(c).cost =
-					(m_TrajectoryCosts.at(c).closest_obj_cost +
-					m_TrajectoryCosts.at(c).priority_cost +
-					m_TrajectoryCosts.at(c).transition_cost)/3.0;
-
-		if(m_TrajectoryCosts.at(c).closest_obj_distance &gt; 0 &amp;&amp; m_TrajectoryCosts.at(c).closest_obj_distance &lt; closest_distance)
-		{
-			closest_distance = m_TrajectoryCosts.at(c).closest_obj_distance;
-			closest_velocity = m_TrajectoryCosts.at(c).closest_obj_velocity;
-		}
-	}
-
-	int smallestIndex = -1;
-	double smallestCost = 1;
-	for(unsigned int c = 0; c &lt; m_TrajectoryCosts.size(); c++)
-	{
-		if(m_TrajectoryCosts.at(c).cost &lt; smallestCost)
-		{
-			smallestCost = m_TrajectoryCosts.at(c).cost;
-			smallestIndex = c;
-		}
-	}
-
-	safe_index = smallestIndex;
-
-//	std::cout &lt;&lt; "Selected Trajectory: " &lt;&lt; safe_index &lt;&lt; ", Closest Distance: " &lt;&lt; closest_distance &lt;&lt; std::endl;
-//	std::cout &lt;&lt; "----------------------------------------------------" &lt;&lt; std::endl;
-}
-
-void CarState::FindNextBestSafeTrajectory(int&amp; safe_index)
-{
-	PreCalculatedConditions* pValues = m_pCurrentBehaviorState-&gt;GetCalcParams();
-	for(unsigned int c = 0; c &lt; m_TrajectoryCosts.size(); c++)
-	{
-		m_TrajectoryCosts.at(c).cost =
-				(m_TrajectoryCosts.at(c).priority_cost +
-				m_TrajectoryCosts.at(c).transition_cost)/2.0;
-	}
-
-	int smallestIndex = pValues-&gt;iCentralTrajectory;
-	double smallestCost = 1;
-	for(unsigned int c = 0; c &lt; m_TrajectoryCosts.size(); c++)
-	{
-		if(m_TrajectoryCosts.at(c).cost &lt; smallestCost)
-		{
-			smallestCost = m_TrajectoryCosts.at(c).cost;
-			smallestIndex = c;
-		}
-	}
-
-	safe_index = smallestIndex;
-}
-
- void CarState::UpdateCurrentLane(PlannerHNS::RoadNetwork&amp; map, const double&amp; search_distance)
- {
-	 PlannerHNS::Lane* pMapLane = 0;
-	PlannerHNS::Lane* pPathLane = 0;
-	pPathLane = MappingHelpers::GetLaneFromPath(state, m_Path);
-	if(!pPathLane)
-		pMapLane  = MappingHelpers::GetClosestLaneFromMap(state, map, search_distance);
-
-	if(pPathLane)
-		pLane = pPathLane;
-	else if(pMapLane)
-		pLane = pMapLane;
-	else
-		pLane = 0;
- }
-
- void CarState::SimulateOdoPosition(const double&amp; dt, const PlannerHNS::VehicleState&amp; vehicleState)
- {
-	SetSimulatedTargetOdometryReadings(vehicleState.speed, vehicleState.steer, vehicleState.shift);
-	UpdateState(vehicleState, true);
-	LocalizeMe(dt);
- }
-
- bool CarState::IsGoalAchieved(const PlannerHNS::GPSPoint&amp; goal)
- {
-	double distance_to_goal = distance2points(state.pos , goal);
-	if(distance_to_goal &lt; 1.5)
-		return true;
-	else
-		return false;
- }
-
- bool CarState::SelectSafeTrajectoryAndSpeedProfile(const PlannerHNS::VehicleState&amp; vehicleState)
- {
-	 PlannerHNS::PreCalculatedConditions *preCalcPrams = m_pCurrentBehaviorState-&gt;GetCalcParams();
-
-	bool bNewTrajectory = false;
-//	if(m_TotalPath.size()&gt;0)
-//	{
-//		int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndexFast(m_Path, state);
-//		int index_limit = 0;//m_Path.size() - 20;
-//		if(index_limit&lt;=0)
-//			index_limit =  m_Path.size()/2.0;
-//		if(m_RollOuts.size() == 0
-//				|| currIndex &gt; index_limit
-//				|| m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bRePlan
-//				|| m_pCurrentBehaviorState-&gt;m_Behavior == OBSTACLE_AVOIDANCE_STATE)
-//		{
-//			PlannerHNS::PlannerH planner;
-//			std::vector&lt;PlannerHNS::WayPoint&gt; tempSec, tempSampledPoints;
-//
-//			planner.GenerateRunoffTrajectory(m_TotalPath, state,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;enableLaneChange,
-//					vehicleState.speed,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;microPlanDistance,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;minSpeed,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;carTipMargin,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollInMargin,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollInSpeedFactor,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;pathDensity,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutDensity,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutNumber,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingDataWeight,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingSmoothWeight,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingToleranceError,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;enableHeadingSmoothing,
-//					m_RollOuts,tempSec, tempSampledPoints);
-//
-//			m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bRePlan = false;
-//
-//			//FindNextBestSafeTrajectory(pValues-&gt;iCurrSafeTrajectory);
-//			if(preCalcPrams-&gt;iCurrSafeTrajectory &gt;= 0
-//					&amp;&amp; preCalcPrams-&gt;iCurrSafeTrajectory &lt; m_RollOuts.size()
-//					&amp;&amp; m_pCurrentBehaviorState-&gt;m_Behavior == OBSTACLE_AVOIDANCE_STATE)
-//			{
-//				preCalcPrams-&gt;iPrevSafeTrajectory = preCalcPrams-&gt;iCurrSafeTrajectory;
-//				m_Path = m_RollOuts.at(preCalcPrams-&gt;iCurrSafeTrajectory);
-//				bNewTrajectory = true;
-//			}
-//			else
-//			{
-//				preCalcPrams-&gt;iPrevSafeTrajectory = preCalcPrams-&gt;iCentralTrajectory;
-//				m_Path = m_RollOuts.at(preCalcPrams-&gt;iCentralTrajectory);
-//				bNewTrajectory = true;
-//			}
-//
-//			PlanningHelpers::GenerateRecommendedSpeed(m_Path,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed,
-//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
-//			PlanningHelpers::SmoothSpeedProfiles(m_Path, 0.15,0.35, 0.1);
-//			std::ostringstream str_out;
-//			str_out &lt;&lt; UtilityH::GetHomeDirectory();
-//			str_out &lt;&lt; DataRW::LoggingMainfolderName;
-//			str_out &lt;&lt; DataRW::PathLogFolderName;
-//			str_out &lt;&lt; "_";
-//			PlanningHelpers::WritePathToFile(str_out.str(), m_Path);
-////			}
-////			else if(m_RollOuts.size() &gt; 0)
-////				std::cout &lt;&lt; "Error .. Error .. Slected Trajectory is out of range !! ( " &lt;&lt; preCalcPrams-&gt;iCurrSafeTrajectory &lt;&lt; ")" &lt;&lt; std::endl;
-//
-//		}
-//	}
-
-	return bNewTrajectory;
- }
-
- PlannerHNS::BehaviorState CarState::GenerateBehaviorState(const PlannerHNS::VehicleState&amp; vehicleState)
- {
-	PlannerHNS::PreCalculatedConditions *preCalcPrams = m_pCurrentBehaviorState-&gt;GetCalcParams();
-
-	m_pCurrentBehaviorState = m_pCurrentBehaviorState-&gt;GetNextState();
-	PlannerHNS::BehaviorState currentBehavior;
-
-	currentBehavior.state = m_pCurrentBehaviorState-&gt;m_Behavior;
-	if(currentBehavior.state == PlannerHNS::FOLLOW_STATE)
-		currentBehavior.followDistance = preCalcPrams-&gt;distanceToNext;
-	else
-		currentBehavior.followDistance = 0;
-
-	if(preCalcPrams-&gt;bUpcomingRight)
-		currentBehavior.indicator = PlannerHNS::INDICATOR_RIGHT;
-	else if(preCalcPrams-&gt;bUpcomingLeft)
-		currentBehavior.indicator = PlannerHNS::INDICATOR_LEFT;
-	else
-		currentBehavior.indicator = PlannerHNS::INDICATOR_NONE;
-	//currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, vehicleState.speed*3.6);
-	currentBehavior.maxVelocity = 0;
-	currentBehavior.minVelocity		= 0;
-	currentBehavior.stopDistance 	= preCalcPrams-&gt;distanceToStop();
-	currentBehavior.followVelocity 	= preCalcPrams-&gt;velocityOfNext;
-
-	return currentBehavior;
- }
-
-// PlannerHNS::BehaviorState CarState::DoOneStep(const double&amp; dt,
-//		 const PlannerHNS::VehicleState&amp; vehicleState,
-//		 const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list,
-//		 const PlannerHNS::GPSPoint&amp; goal, PlannerHNS::RoadNetwork&amp; map	,
-//		const bool&amp; bEmergencyStop,
-//		const bool&amp; bGreenTrafficLight,
-//		const bool&amp; bLive)
-//{
-//	 if(!bLive)
-//		 SimulateOdoPosition(dt, vehicleState);
-//
-//	UpdateCurrentLane(map, 3.0);
-//
-//	InitializeTrajectoryCosts();
-//
-//	CalculateTransitionCosts();
-//
-//	CalculateDistanceCosts(vehicleState, obj_list);
-//
-//	CalculateImportantParameterForDecisionMaking(vehicleState, goal, bEmergencyStop, bGreenTrafficLight);
-//
-//	PlannerHNS::BehaviorState beh = GenerateBehaviorState(vehicleState);
-//
-//	beh.bNewPlan = SelectSafeTrajectoryAndSpeedProfile(vehicleState);
-//
-//
-////	timespec predictionTime;
-////	UtilityH::GetTickCount(predictionTime);
-//	//if(UtilityH::GetTimeDiffNow(m_PredictionTimer) &gt; 0.5 || beh.bNewPlan)
-//	{
-//		//CalculateObstacleCosts(map, vehicleState, obj_list);
-//		//m_PredictionTime = UtilityH::GetTimeDiffNow(predictionTime);
-//	}
-//
-//
-////	bool bCollision = false;
-////	int wp_id = -1;
-////	for(unsigned int i=0; i &lt; m_Path.size(); i++)
-////	{
-////		if(m_Path.at(i).collisionCost &gt; 0)
-////		{
-////			bCollision = true;
-////			wp_id = i;
-////			beh.maxVelocity = m_Path.at(i).v;//PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*vehicleState.speed*3.6);
-////			break;
-////		}
-////	}
-//
-////	std::cout &lt;&lt; "------------------------------------------------" &lt;&lt;  std::endl;
-////	std::cout &lt;&lt; "Max Velocity = " &lt;&lt; beh.maxVelocity &lt;&lt; ", New Plan : " &lt;&lt; beh.bNewPlan &lt;&lt;  std::endl;
-////	std::cout &lt;&lt; "Collision = " &lt;&lt; bCollision &lt;&lt; ", @ WayPoint : " &lt;&lt; wp_id &lt;&lt;  std::endl;
-////	std::cout &lt;&lt; "------------------------------------------------" &lt;&lt;  std::endl;
-//
-//	return beh;
-// }
-
-
- SimulatedCarState::SimulatedCarState()
- {
- 	pLane = 0;
- 	m_CurrentVelocity =  m_CurrentVelocityD =0;
- 	m_CurrentSteering = m_CurrentSteeringD =0;
- 	m_CurrentShift 		=  m_CurrentShiftD = SHIFT_POS_NN;
- 	bDetected = false;
- }
-
- SimulatedCarState::~SimulatedCarState()
- {
- }
-
- void SimulatedCarState::Init(const CAR_BASIC_INFO&amp; carInfo)
-{
-	m_CarInfo = carInfo;
-	m_CurrentVelocity =  m_CurrentVelocityD =0;
-	m_CurrentSteering = m_CurrentSteeringD =0;
-	m_CurrentShift 		=  m_CurrentShiftD = SHIFT_POS_NN;
-}
-
-
- void SimulatedCarState::InitPolygons()
- {
- 	double l2 = m_CarInfo.length/2.0;
- 	double w2 = m_CarInfo.width/2.0;
-
- 	m_CarShapePolygon.push_back(GPSPoint(-w2, -l2, 0,0));
- 	m_CarShapePolygon.push_back(GPSPoint(w2, -l2, 0,0));
- 	m_CarShapePolygon.push_back(GPSPoint(w2, l2, 0,0));
- 	m_CarShapePolygon.push_back(GPSPoint(-w2, l2, 0,0));
-
-// 	m_CarShapePolygon.push_back(GPSPoint(-w2, -l2, 1,0));
-// 	m_CarShapePolygon.push_back(GPSPoint(w2, -l2, 1,0));
-// 	m_CarShapePolygon.push_back(GPSPoint(w2, l2, 1,0));
-// 	m_CarShapePolygon.push_back(GPSPoint(-w2, l2, 1,0));
- }
-
-  void SimulatedCarState::FirstLocalizeMe(const WayPoint&amp; initCarPos)
-  {
- 	pLane = initCarPos.pLane;
- 	state = initCarPos;
- 	m_OdometryState.pos.a = initCarPos.pos.a;
- 	m_OdometryState.pos.x = initCarPos.pos.x;
- 	m_OdometryState.pos.y = initCarPos.pos.y;
-  }
-
-  void SimulatedCarState::LocalizeMe(const double&amp; dt)
- {
- 	//calculate the new x, y ,
- 	 WayPoint currPose = state;
-
- 	if(m_CurrentShift == SHIFT_POS_DD)
- 	{
- 		m_OdometryState.pos.x	 +=  m_CurrentVelocity * dt * cos(currPose.pos.a);
- 		m_OdometryState.pos.y	 +=  m_CurrentVelocity * dt * sin(currPose.pos.a);
- 		m_OdometryState.pos.a	 +=  m_CurrentVelocity * dt * tan(m_CurrentSteering)  / m_CarInfo.wheel_base;
-
- 	}
- 	else if(m_CurrentShift == SHIFT_POS_RR )
- 	{
- 		m_OdometryState.pos.x	 +=  -m_CurrentVelocity * dt * cos(currPose.pos.a);
- 		m_OdometryState.pos.y	 +=  -m_CurrentVelocity * dt * sin(currPose.pos.a);
- 		m_OdometryState.pos.a	 +=  -m_CurrentVelocity * dt * tan(m_CurrentSteering);
- 	}
-
- 	m_OdometryState.pos.a = atan2(sin(m_OdometryState.pos.a), cos(m_OdometryState.pos.a));
- 	m_OdometryState.pos.a = UtilityH::FixNegativeAngle(m_OdometryState.pos.a);
-
- 	state.pos.a = m_OdometryState.pos.a;
- 	state.pos.x = m_OdometryState.pos.x;
- 	state.pos.y = m_OdometryState.pos.y;
- 	state.v = m_CurrentVelocity;
-
- }
-
-  void SimulatedCarState::UpdateState(const bool&amp; bUseDelay)
-   {
- 	 m_CurrentSteering 	= m_CurrentSteeringD;
- 	 m_CurrentShift 	= m_CurrentShiftD;
- 	 m_CurrentVelocity = m_CurrentVelocityD;
-   }
-
-  void SimulatedCarState::CalculateImportantParameterForDecisionMaking(const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list,
- 		 const PlannerHNS::VehicleState&amp; car_state, const PlannerHNS::GPSPoint&amp; goal, PlannerHNS::RoadNetwork&amp; map)
-  {
-
-  	PlannerHNS::Lane* pPathLane = MappingHelpers::GetLaneFromPath(state, m_Path);
-  	PlannerHNS::Lane* pMapLane  = MappingHelpers::GetClosestLaneFromMap(state, map, 3.0);
-
-  	if(pPathLane)
-  		pLane = pPathLane;
-  	else if(pMapLane)
-  		pLane = pMapLane;
-  	else
-  		pLane = 0;
-
-  	//cout &lt;&lt; "Distances: " &lt;&lt; pValues-&gt;stoppingDistances.size() &lt;&lt; ", Distance To Stop : " &lt;&lt; pValues-&gt;distanceToStop &lt;&lt; endl;
-
-  }
-
-  void SimulatedCarState::SimulateOdoPosition(const double&amp; dt, const PlannerHNS::VehicleState&amp; vehicleState)
-  {
- 	SetSimulatedTargetOdometryReadings(vehicleState.speed, vehicleState.steer, vehicleState.shift);
- 	UpdateState(false);
- 	LocalizeMe(dt);
-  }
-
-  void SimulatedCarState::UpdateCurrentLane(PlannerHNS::RoadNetwork&amp; map, const double&amp; search_distance)
-  {
-	  PlannerHNS::Lane* pMapLane = 0;
- 	PlannerHNS::Lane* pPathLane = MappingHelpers::GetLaneFromPath(state, m_Path);
- 	if(!pPathLane)
- 		pMapLane  = MappingHelpers::GetClosestLaneFromMap(state, map, search_distance);
-
- 	if(pPathLane)
- 		pLane = pPathLane;
- 	else if(pMapLane)
- 		pLane = pMapLane;
- 	else
- 		pLane = 0;
-  }
-
-PlannerHNS::BehaviorState SimulatedCarState::GenerateBehaviorState(const PlannerHNS::VehicleState&amp; vehicleState)
-{
-	PlannerHNS::BehaviorState currentBehavior;
-	currentBehavior.state = PlannerHNS::FORWARD_STATE;
-
-	/**
-	 * Use for future simulation of other detecing other cars indicator and act accordingly
-	 */
-	//    	if(preCalcPrams-&gt;bUpcomingRight)
-	//    		currentBehavior.indicator = PlannerHNS::INDICATOR_RIGHT;
-	//    	else if(preCalcPrams-&gt;bUpcomingLeft)
-	//    		currentBehavior.indicator = PlannerHNS::INDICATOR_LEFT;
-	//    	else
-	//    		currentBehavior.indicator = PlannerHNS::INDICATOR_NONE;
-
-	//currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*vehicleState.speed*3.6);
-	currentBehavior.maxVelocity  = 0;
-	currentBehavior.minVelocity		= 0;
-	currentBehavior.stopDistance 	= 0;
-	currentBehavior.followVelocity 	= 0;
-
-	return currentBehavior;
-}
-
-bool SimulatedCarState::SelectSafeTrajectoryAndSpeedProfile(const PlannerHNS::VehicleState&amp; vehicleState)
-{
-	PlannerHNS::PlanningParams planningDefaultParams;
-	planningDefaultParams.rollOutNumber = 0;
-
-	int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndexFast(m_Path, state);
-	int index_limit = 0;//m_Path.size() - 15;
-	if(index_limit&lt;=0)
-		index_limit =  m_Path.size()/2.0;
-	if(m_RollOuts.size() == 0 || currIndex &gt; index_limit)
-	{
-		PlannerHNS::PlannerH planner;
-		std::vector&lt;int&gt; LanesIds;
-
-		std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; generatedPath;
-//		planner.PlanUsingDP(state, PlannerHNS::WayPoint(),
-//				150, LanesIds, m_ generatedPath);
-//		m_RollOuts.clear();
-//		if(generatedPath.size()&gt;0)
-//			m_TotalPath = generatedPath.at(0);
-
-		std::vector&lt;PlannerHNS::WayPoint&gt; tempSec, tempSampledPoints;
-
-
-//		planner.GenerateRunoffTrajectory(generatedPath, state,
-//				planningDefaultParams.enableLaneChange,
-//				vehicleState.speed,
-//				planningDefaultParams.microPlanDistance,
-//				m_CarInfo.max_speed_forward,
-//				planningDefaultParams.minSpeed,
-//				planningDefaultParams.carTipMargin,
-//				planningDefaultParams.rollInMargin,
-//				planningDefaultParams.rollInSpeedFactor,
-//				planningDefaultParams.pathDensity,
-//				planningDefaultParams.rollOutDensity,
-//				planningDefaultParams.rollOutNumber,
-//				planningDefaultParams.smoothingDataWeight,
-//				planningDefaultParams.smoothingSmoothWeight,
-//				planningDefaultParams.smoothingToleranceError,
-//				planningDefaultParams.speedProfileFactor,
-//				planningDefaultParams.enableHeadingSmoothing,
-//				m_RollOuts, tempSec, tempSampledPoints);
-
-		if(m_RollOuts.size() &gt; 0)
-		{
-			m_Path = m_RollOuts.at(0);
-			PlanningHelpers::GenerateRecommendedSpeed(m_Path,
-					m_CarInfo.max_speed_forward,
-								planningDefaultParams.speedProfileFactor);
-			PlanningHelpers::SmoothSpeedProfiles(m_Path, 0.15,0.35, 0.1);
-		}
-	}
-
-	if(!pLane || m_TotalPath.size() &lt; 3 || m_Path.size() &lt; 3)
-	{
-		m_Path.clear();
-		m_TotalPath.clear();
-		return false;
-	}
-
-	return m_Path.size() &gt; 0;
-}
-
-  PlannerHNS::BehaviorState SimulatedCarState::DoOneStep(
-		  const double&amp; dt,
-		  const PlannerHNS::VehicleState&amp; vehicleState,
-		  const PlannerHNS::WayPoint&amp; currPose,
-		  const PlannerHNS::GPSPoint&amp; goal,
-		  PlannerHNS::RoadNetwork&amp; map)
-{
-
-
-	SimulateOdoPosition(dt, vehicleState);
-
-	UpdateCurrentLane(map, 3.0);
-
-	PlannerHNS::BehaviorState beh = GenerateBehaviorState(vehicleState);
-
-	beh.bNewPlan = SelectSafeTrajectoryAndSpeedProfile(vehicleState);
-
-	return beh;
-}
-
-} /* namespace SimulationNS */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\DrawObjBase.cpp" new_path="" added_lines="0" deleted_lines="24">
				<diff>@@ -1,24 +0,0 @@
-/*
- * DrawObjBase.cpp
- *
- *  Created on: Jun 17, 2016
- *      Author: hatem
- */
-
-#include "op_simu/DrawObjBase.h"
-
-namespace Graphics {
-
-DrawObjBase::DrawObjBase() {
-		m_followX = 0;
-		m_followY = 0;
-		m_followZ = 0;
-		m_followA = 0;
-
-}
-
-DrawObjBase::~DrawObjBase() {
-	// TODO Auto-generated destructor stub
-}
-
-} /* namespace Graphics */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\DrawingHelpers.cpp" new_path="" added_lines="0" deleted_lines="649">
				<diff>@@ -1,649 +0,0 @@
-/*
- * DrawingHelpers.cpp
- *
- *  Created on: May 31, 2016
- *      Author: hatem
- */
-
-#include "op_simu/DrawingHelpers.h"
-#include &lt;stdarg.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;cmath&gt;
-#include "op_utility/UtilityH.h"
-#include "op_planner/PlanningHelpers.h"
-#include &lt;GL/freeglut.h&gt;
-
-using namespace std;
-using namespace PlannerHNS;
-using namespace UtilityHNS;
-
-namespace Graphics
-{
-
-DrawingHelpers::DrawingHelpers() {
-	// TODO Auto-generated constructor stub
-
-}
-
-DrawingHelpers::~DrawingHelpers() {
-	// TODO Auto-generated destructor stub
-}
-
-void DrawingHelpers::DrawString(float x, float y, GLvoid* font_style, char* format, ...)
-{
-	glDisable(GL_LIGHTING);
-
-	va_list args;
-	char buffer[1000], *s;
-
-	va_start(args, format);
-	vsprintf(buffer, format, args);
-	va_end(args);
-	//GLuint ox = x;
-	GLuint oy = y;
-
-	glRasterPos2f(x, y);
-	for (s = buffer; *s; s++)
-	{
-		if(*s == ',')
-		{
-			x += 220;
-			y = oy;
-			glRasterPos2f(x, y);
-			continue;
-		}
-		else if(*s == '\n')
-		{
-			y+=12;
-			glRasterPos2f(x, y);
-			continue;
-		}
-
-		glutBitmapCharacter(font_style, *s);
-	}
-	glEnable(GL_LIGHTING);
-}
-
-void DrawingHelpers::DrawGrid(const double&amp; x, const double&amp; y, const double&amp; w, const double&amp; h, const double&amp; cell_l)
-{
-	glPushMatrix();
-	int nVerticalLisne   = floor(w/cell_l);
-	int nHorizontalLines = floor(h/cell_l);
-
-	glBegin(GL_LINES);
-	glColor3ub(210,210,210);
-	double incr = y;
-	for(int r=0; r&lt;= nHorizontalLines; r++)
-	{
-		glNormal3f(1.0, 1.0, 1.0);
-		glVertex3f(x, incr, 0);
-		glVertex3f(x+w, incr, 0);
-		incr+=cell_l;
-	}
-
-	double incc = x;
-	for(int r=0; r&lt;= nVerticalLisne; r++)
-	{
-		glNormal3f(1.0, 1.0, 1.0);
-		glVertex3f(incc, y,  0);
-		glVertex3f(incc, y + h, 0);
-		incc+=cell_l;
-	}
-	glEnd();
-
-	glPopMatrix();
-}
-
-void DrawingHelpers::DrawArrow(const double&amp; x, const double&amp; y, const double&amp; a)
-{
-	const int nSlicesStacks = 50;
-	const double percent = 20.0;
-	const double innerPercent = 15.0;
-	double half_length = 10/2.0;
-
-	glPushMatrix();
-	//Draw one cylender and cone
-	glTranslated(x, y, 0.5);
-	glRotated(a*RAD2DEG, 0,0,1);
-
-	//X Axis
-	glPushMatrix();
-	glColor3ub(200,200,200);
-	glRotated(90, 0,1,0);
-	glutSolidCylinder(half_length/percent, half_length,nSlicesStacks,nSlicesStacks);
-	glTranslated(0,0,half_length);
-	glColor3f(1,1,0);
-	glutSolidCone(half_length/innerPercent, half_length/innerPercent,nSlicesStacks,nSlicesStacks);
-	glPopMatrix();
-
-	glPopMatrix();
-}
-
-void DrawingHelpers::DrawCustomOrigin(const double&amp; x, const double&amp; y, const double&amp; z, const int&amp; yaw, const int&amp; roll, const int&amp; pitch, const double&amp; length)
-{
-	const int nSlicesStacks = 50;
-	const double percent = 20.0;
-	const double innerPercent = 15.0;
-	double half_length = length/2.0;
-
-	glPushMatrix();
-	//Draw one cylender and cone
-	glTranslated(x, y, z);
-	glRotated(yaw, 0,0,1);
-	glRotated(roll, 1,0,0);
-	glRotated(pitch, 0,1,0);
-
-	//Z Axis
-	glPushMatrix();
-	glColor3f(0.65,0.65,0.65);
-	glutSolidCylinder(half_length/percent, half_length,nSlicesStacks,nSlicesStacks);
-	glTranslated(0,0,half_length);
-	glColor3f(0,0,1);
-	glutSolidCone(half_length/innerPercent, half_length/innerPercent,nSlicesStacks,nSlicesStacks);
-	glPopMatrix();
-
-	//X Axis
-	glPushMatrix();
-	glColor3f(0.65,0.65,0.65);
-	glRotated(90, 0,1,0);
-	glutSolidCylinder(half_length/percent, half_length,nSlicesStacks,nSlicesStacks);
-	glTranslated(0,0,half_length);
-	glColor3f(1,1,0);
-	glutSolidCone(half_length/innerPercent, half_length/innerPercent,nSlicesStacks,nSlicesStacks);
-	glPopMatrix();
-
-//	//Y Axis
-	glPushMatrix();
-	glColor3f(0.65,0.65,0.65);
-	glRotated(90, 1,0,0);
-	glutSolidCylinder(half_length/percent, half_length, nSlicesStacks, nSlicesStacks);
-	glTranslated(0,0,half_length);
-	glColor3f(1,0,0);
-	glutSolidCone(half_length/innerPercent, half_length/innerPercent, nSlicesStacks,nSlicesStacks);
-	glPopMatrix();
-
-	//glDisable(GL_LIGHTING);
-	glPopMatrix();
-
-}
-
-vector&lt;vector&lt;float&gt; &gt; DrawingHelpers::PreparePathForDrawing(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
-		std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; redyForDraw, double w, double resolution)
-{
-	vector&lt;vector&lt;float&gt; &gt; colorProfiles;
-	if(path.size() &lt; 2) return colorProfiles;
-	int size = path.size();
-	WayPoint p1 = path[0];
-	WayPoint p2 =p1;
-	WayPoint prev_point = p1;
-	WayPoint center, prev_center ,pa, pb, pc, pd;
-	double a = 0;
-	double prev_angle = 0;
-	vector&lt;WayPoint&gt; four_temp;
-	vector&lt;float&gt; color_vector;
-
-	for(int i=0; i &lt; size ; i++)
-	{
-
-		color_vector.clear();
-		four_temp.clear();
-
-		pa = p2 = path[i];
-
-		color_vector.push_back(p1.v/12.0);
-		color_vector.push_back(p1.v/12.0);
-		color_vector.push_back(p1.v/12.0);
-		colorProfiles.push_back(color_vector);
-
-		if(distance2points(p1.pos, p2.pos) &lt; resolution)
-		  continue;
-
-		center.pos.x = p1.pos.x + (p2.pos.x-p1.pos.x)/2.0;
-		center.pos.y = p1.pos.y + (p2.pos.y-p1.pos.y)/2.0;
-
-		a = atan2(p2.pos.y- p1.pos.y, p2.pos.x- p1.pos.x);
-
-		pa.pos.x = p1.pos.x - w * cos(a - M_PI/2.0);
-		pa.pos.y = p1.pos.y - w * sin(a - M_PI/2.0);
-		pa.pos.z = p1.pos.z;
-
-		pb.pos.x = p1.pos.x + w * cos(a - M_PI/2.0);
-		pb.pos.y = p1.pos.y + w * sin(a - M_PI/2.0);
-		pb.pos.z = p1.pos.z;
-
-
-		pc.pos.x = p2.pos.x + w * cos(a - M_PI/2.0);
-		pc.pos.y = p2.pos.y + w * sin(a - M_PI/2.0);
-		pc.pos.z = p2.pos.z;
-
-		pd.pos.x = p2.pos.x - w * cos(a - M_PI/2.0);
-		pd.pos.y = p2.pos.y - w * sin(a - M_PI/2.0);
-		pd.pos.z = p2.pos.z;
-
-		if(!(prev_point.pos.x == p1.pos.x &amp;&amp;  prev_point.pos.y == p1.pos.y))
-		{
-			prev_angle = atan2(p1.pos.y- prev_point.pos.y, p1.pos.x- prev_point.pos.x);
-
-			pa.pos.x = p1.pos.x - w * cos(prev_angle - M_PI/2.0);
-			pa.pos.y = p1.pos.y - w * sin(prev_angle - M_PI/2.0);
-
-			pb.pos.x = p1.pos.x + w * cos(prev_angle - M_PI/2.0);
-			pb.pos.y = p1.pos.y + w * sin(prev_angle - M_PI/2.0);
-		}
-
-	  	four_temp.push_back(pa);
-	  	four_temp.push_back(pb);
-	  	four_temp.push_back(pc);
-	  	four_temp.push_back(pd);
-
-	  	redyForDraw.push_back(four_temp);
-
-		prev_point = p1;
-		p1 = p2;
-	}
-	  return colorProfiles;
-}
-
-void DrawingHelpers::DrawPrePreparedPolygons(std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; path,
-		double z, float color[3],int nSkipPoints, const std::vector&lt;std::vector&lt;float&gt; &gt;* colorProfile)
-{
-
-
-	if(!colorProfile)
-		glColor3f(color[0], color[1], color[2]);
-
-	for(unsigned int i=0; i&lt; path.size(); i+=nSkipPoints)
-	{
-		if(path[i].size() == 4)
-		{
-			if(path[i][0].pLane &amp;&amp; (path[i][0].pLane-&gt;pRightLane || path[i][0].pLane-&gt;pLeftLane))
-				glColor3f(1, 0, 0);
-			else if(colorProfile)
-			{
-				glColor3f(color[0]*(*colorProfile)[i][0], color[1] * (*colorProfile)[i][1], color[2] * (*colorProfile)[i][2]);
-			}
-
-			 glBegin(GL_POLYGON);
-				  glNormal3f(0.0, 0.0, 0.1);
-//				  glVertex3f(path[i][0].p.x, path[i][0].p.y,path[i][0].p.z+z);
-//				  glVertex3f(path[i][1].p.x, path[i][1].p.y,path[i][1].p.z+z);
-//				  glVertex3f(path[i][2].p.x, path[i][2].p.y,path[i][2].p.z+z);
-//				  glVertex3f(path[i][3].p.x, path[i][3].p.y,path[i][3].p.z+z);
-				  glVertex3f(path[i][0].pos.x, path[i][0].pos.y,z);
-				  glVertex3f(path[i][1].pos.x, path[i][1].pos.y,z);
-				  glVertex3f(path[i][2].pos.x, path[i][2].pos.y,z);
-				  //glVertex3f((path[i][2].p.x+path[i][1].p.x)/2.0, (path[i][2].p.y+path[i][1].p.y)/2.0,z);
-				  glVertex3f(path[i][3].pos.x, path[i][3].pos.y,z);
-			  glEnd();
-		}
-	}
-
-
-}
-
-void DrawingHelpers::DrawCostPath(const std::vector&lt;PlannerHNS::WayPoint*&gt;&amp; path_points, const double&amp; z, const double&amp; width)
-{
-	if(path_points.size()==0) return;
-
-	WayPoint p1 = *path_points[0];
-	float color[3] = {0,0,0};
-
-	double max_cost = 0;
-	for(unsigned int i=0; i &lt; path_points.size(); i++)
-	{
-		if(path_points.at(i)-&gt;cost &gt; max_cost)
-			max_cost = path_points.at(i)-&gt;cost;
-	}
-
-	int size = path_points.size();
-
-	for(int i=0; i &lt; size; i++)
-	{
-		p1 = *path_points[i];
-		double norm_cost = path_points.at(i)-&gt;cost / max_cost * 2.0;
-		if(norm_cost &lt;= 1.0)
-		{
-			color[0] = norm_cost;
-			color[1] = 1.0;
-		}
-		else if(norm_cost &gt; 1.0)
-		{
-			color[0] = 1.0;
-			color[1] = 2.0 - norm_cost;
-		}
-
-		glColor3f(color[0], color[1], color[2]);
-
-		//DrawLinePoygonFromCenterX(p1, z, p2, z, width, 0, prev_point);
-		DrawWideEllipse(p1.pos.x, p1.pos.y, z, 0.5, 0.5, 0.25, color);
-	}
-}
-
-void DrawingHelpers::DrawWidePath(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path_points, const double&amp; z, const double&amp; width, float color[3], bool bGadient)
-{
-	if(path_points.size()==0) return;
-
-	WayPoint p1 = path_points[0];
-	WayPoint p2 = p1;
-
-	float localColor[3] = {color[0],color[1],color[2]};
-
-	int size = path_points.size();
-	WayPoint prev_point = p1;
-
-	for(int i=1; i &lt; size; i+=2)
-	{
-		p2 = path_points[i];
-		if(bGadient)
-		{
-			localColor[0] = color[0] * (float)(i+20)*3/(float)size;
-			localColor[1] = color[1] * (float)(i+20)*3/(float)size;
-			localColor[2] = color[2] * (float)(i+20)*3/(float)size;
-		}
-
-		if(p2.bDir == BACKWARD_DIR)
-			glColor3f(1,0, 0);
-		else
-			glColor3f(localColor[0],localColor[1],localColor[2]);
-
-		DrawLinePoygonFromCenterX(p1, z, p2, z, width, 0, prev_point);
-
-		prev_point = p1;
-
-		p1 = p2;
-	}
-}
-
-void DrawingHelpers::DrawLinePoygonline(const PlannerHNS::GPSPoint&amp; p1, const PlannerHNS::GPSPoint&amp; p2, const double&amp; w)
-{
-	GPSPoint center, prev_center ,pa, pb, pc, pd, prev_pa,prev_pb;
-	double a = 0;
-
-	center.x = p1.x + (p2.x-p1.x)/2.0;
-	center.y = p1.y + (p2.y-p1.y)/2.0;
-
-	 a = atan2(p2.y- p1.y, p2.x- p1.x);
-
-	pa.x = p1.x - w * cos(a - M_PI/2.0);
-	pa.y = p1.y - w * sin(a - M_PI/2.0);
-
-	pb.x = p1.x + w * cos(a - M_PI/2.0);
-	pb.y = p1.y + w * sin(a - M_PI/2.0);
-
-
-	pc.x = p2.x + w * cos(a - M_PI/2.0);
-	pc.y = p2.y + w * sin(a - M_PI/2.0);
-
-	pd.x = p2.x - w * cos(a - M_PI/2.0);
-	pd.y = p2.y - w * sin(a - M_PI/2.0);
-
-	glBegin(GL_POLYGON);
-	  glNormal3f(0.1, 0.1, 0.1);
-	  glVertex3f(pa.x, pa.y, p1.z);
-	  glVertex3f(pb.x, pb.y, p1.z);
-	  glVertex3f(pc.x, pc.y, p2.z);
-	  glVertex3f(pd.x, pd.y, p2.z);
-	glEnd();
-}
-
-void DrawingHelpers::DrawLinePoygonFromCenterX(const PlannerHNS::WayPoint&amp; p1, const double&amp; z,
-		const PlannerHNS::WayPoint&amp; p2, const double&amp; z2, const double&amp; w, const double&amp; h,
-		PlannerHNS::WayPoint&amp; prev_point)
-{
-	GPSPoint center, prev_center ,pa, pb, pc, pd, prev_pa,prev_pb;
-	double a = 0;
-	double prev_angle = 0;
-
-	center.x = p1.pos.x + (p2.pos.x-p1.pos.x)/2.0;
-	center.y = p1.pos.y + (p2.pos.y-p1.pos.y)/2.0;
-
-	 a = atan2(p2.pos.y- p1.pos.y, p2.pos.x- p1.pos.x);
-
-	pa.x = p1.pos.x - w * cos(a - M_PI/2.0);
-	pa.y = p1.pos.y - w * sin(a - M_PI/2.0);
-
-	pb.x = p1.pos.x + w * cos(a - M_PI/2.0);
-	pb.y = p1.pos.y + w * sin(a - M_PI/2.0);
-
-
-	pc.x = p2.pos.x + w * cos(a - M_PI/2.0);
-	pc.y = p2.pos.y + w * sin(a - M_PI/2.0);
-
-	pd.x = p2.pos.x - w * cos(a - M_PI/2.0);
-	pd.y = p2.pos.y - w * sin(a - M_PI/2.0);
-
-	if(!(prev_point.pos.x == p1.pos.x &amp;&amp;  prev_point.pos.y == p1.pos.y))
-	{
-		prev_angle = atan2(p1.pos.y- prev_point.pos.y, p1.pos.x- prev_point.pos.x);
-
-		pa.x = p1.pos.x - w * cos(prev_angle - M_PI/2.0);
-		pa.y = p1.pos.y - w * sin(prev_angle - M_PI/2.0);
-
-		pb.x = p1.pos.x + w * cos(prev_angle - M_PI/2.0);
-		pb.y = p1.pos.y + w * sin(prev_angle - M_PI/2.0);
-
-	}
-
-	  glBegin(GL_POLYGON);
-		  glNormal3f(0.1, 0.1, 0.1);
-		  glVertex3f(pa.x, pa.y,z);
-		  glVertex3f(pb.x, pb.y, z);
-		  glVertex3f(pc.x, pc.y,z);
-		  glVertex3f(pd.x, pd.y, z);
-	  glEnd();
-
-}
-
-void DrawingHelpers::DrawCustomCarModel(const PlannerHNS::WayPoint&amp; pose,const double&amp; steeringAngle, const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; carPoints,float color[3], const double&amp; angleFix)
-{
-	if(carPoints.size() == 4)
-	{
-		double z_margin = 0.05;
-
-		glPushMatrix();
-		glTranslated(pose.pos.x, pose.pos.y, pose.pos.z);
-		glRotated(pose.pos.a*RAD2DEG + angleFix, 0,0,1);
-		for(unsigned  int i = 0; i &lt; 4; i++)
-		{
-			glBegin(GL_LINE_STRIP);
-			//glColor3f(0,1,1);
-			glColor3f(color[0],color[1],color[2]);
-			glVertex3f(carPoints[i].x, carPoints[i].y, carPoints[i].z);
-			glVertex3f(carPoints[i].x, carPoints[i].y, carPoints[i].z+1);
-
-			glEnd();
-		}
-
-		glBegin(GL_POLYGON);
-		//glColor3f(0,0,1);
-		glColor3f(color[0],color[0],color[2]);
-			glVertex3f(carPoints[0].x, carPoints[0].y, carPoints[0].z+z_margin);
-			glVertex3f(carPoints[1].x, carPoints[1].y, carPoints[1].z+z_margin);
-			glVertex3f(carPoints[2].x, carPoints[2].y, carPoints[2].z+z_margin);
-			glVertex3f(carPoints[3].x, carPoints[3].y, carPoints[3].z+z_margin);
-			glVertex3f(carPoints[0].x, carPoints[0].y, carPoints[0].z+z_margin);
-
-			glVertex3f(carPoints[0].x, carPoints[0].y, carPoints[0].z+z_margin);
-			glVertex3f(carPoints[2].x, carPoints[2].y, carPoints[2].z+z_margin);
-
-			glVertex3f(carPoints[1].x, carPoints[1].y, carPoints[1].z+z_margin);
-			glVertex3f(carPoints[3].x, carPoints[3].y, carPoints[3].z+z_margin);
-
-		glEnd();
-
-		glBegin(GL_LINE_LOOP);
-		glColor3f(color[0],color[0],color[2]);
-			glVertex3f(carPoints[0].x, carPoints[0].y, carPoints[0].z+1);
-			glVertex3f(carPoints[1].x, carPoints[1].y, carPoints[1].z+1);
-			glVertex3f(carPoints[2].x, carPoints[2].y, carPoints[2].z+1);
-			glVertex3f(carPoints[3].x, carPoints[3].y, carPoints[3].z+1);
-			glVertex3f(carPoints[0].x, carPoints[0].y, carPoints[0].z+1);
-
-			glVertex3f(carPoints[0].x, carPoints[0].y, carPoints[0].z+1);
-			glVertex3f(carPoints[2].x, carPoints[2].y, carPoints[2].z+1);
-
-			glVertex3f(carPoints[1].x, carPoints[1].y, carPoints[1].z+1);
-			glVertex3f(carPoints[3].x, carPoints[3].y, carPoints[3].z+1);
-
-		glEnd();
-
-
-		double width = fabs(carPoints[0].x - carPoints[2].x);
-		double length = fabs(carPoints[0].y - carPoints[2].y);
-		double innerRad = 1.0;
-		double scale_factor = 0.1;
-		glColor3f(0.05,0.05,0.05);
-
-		glPushMatrix();
-		glTranslated(width/2.0,length/2.0 - 0.5,0);
-		glScaled(scale_factor, scale_factor, scale_factor);
-		glRotated(90, 0,0,1);
-		glRotated(90, 1,0,0);
-		glutSolidTorus(innerRad, 3.0, 20, 20);
-		glPopMatrix();
-
-		glPushMatrix();
-		glTranslated(-width/2.0,length/2.0 - 0.5,0);
-		glScaled(scale_factor, scale_factor, scale_factor);
-		glRotated(90, 0,0,1);
-		glRotated(90, 1,0,0);
-		glutSolidTorus(innerRad, 3.0, 20, 20);
-		glPopMatrix();
-
-		glPushMatrix();
-		glTranslated(width/2.0,-length/2.0 + 0.5,0);
-		glScaled(scale_factor, scale_factor, scale_factor);
-		glRotated(90+steeringAngle*RAD2DEG, 0,0,1);
-		glRotated(90, 1,0,0);
-		glutSolidTorus(innerRad, 3.0, 20, 20);
-		glPopMatrix();
-
-		glPushMatrix();
-		glTranslated(-width/2.0,-length/2.0 + 0.5,0);
-		glScaled(scale_factor, scale_factor, scale_factor);
-		glRotated(90+steeringAngle*RAD2DEG, 0,0,1);
-		glRotated(90, 1,0,0);
-		glutSolidTorus(innerRad, 3.0, 20, 20);
-		glPopMatrix();
-
-
-
-
-		glPopMatrix();
-	}
-
-	DrawCustomOrigin(pose.pos.x, pose.pos.y, pose.pos.z, pose.pos.a*RAD2DEG, 0,0, 2);
-}
-
-GLMmodel* DrawingHelpers::LoadModel(const char* fileName)
-{
-	GLMmodel* pmodel = glmReadOBJ((char*)fileName);
-	if (!pmodel) exit(0);
-	glmUnitize(pmodel);
-	glmFacetNormals(pmodel);
-	glmVertexNormals(pmodel, 90.0);
-
-	return pmodel;
-}
-
-void DrawingHelpers::DrawModel(GLMmodel* pmod,double length, double width, double height, double x, double y,double z, double heading, double pitch , double roll )
-{
-	if (pmod)
-	{
-		if(!glIsEnabled(GL_LIGHTING))
-			  glEnable(GL_LIGHTING);
-
-		glPushMatrix();
-		glTranslated(x,y,z);
-		glRotated(heading*RAD2DEG,0.0, 0.0, 1.0);
-		glRotated(pitch*RAD2DEG,0.0, 1.0, 0.0);
-		glRotated(roll*RAD2DEG,1.0, 0.0, 0.0);
-
-		glScaled(length, width, height);
-		glmDraw(pmod, GLM_FLAT | GLM_MATERIAL );
-		glPopMatrix();
-
-		glDisable(GL_LIGHTING);
-	}
-}
-
-void DrawingHelpers::DrawFilledEllipse(float x, float y, float z, float width, float height)
-{
-	glDisable(GL_LIGHTING);
-	glBegin(GL_TRIANGLE_FAN);
-		//All triangles fan out starting with this point
-		glVertex3f (x,y,z);
-		for (float i = 0; i &lt;=M_PI*2*RAD2DEG; i+=0.1)
-		{
-			glVertex3f(x + width*cos(i), y+height*sin(i), z);
-		}
-	glEnd();
-	glEnable(GL_LIGHTING);
-}
-
-void DrawingHelpers::DrawWideEllipse(float x, float y, float z, float outer_width, float outer_height,
-		float inner_width,float color[3])
-{
-	//std::vector&lt;WayPoint&gt; ellipse_points;
-	glColor3f(color[0], color[1], color[2]);
-	GPSPoint p1 = GPSPoint(x + outer_width*cos(0),y + outer_height*sin(0),z,0);
-	GPSPoint p2 = p1;
-	for (float i = 0.1; i &lt;= M_PI*2 + 0.1; i+=0.1)
-	{
-		//ellipse_points.push_back(WayPoint(x + outer_width*cos(i), y+outer_height*sin(i), z, 0));
-		p2.x = x + outer_width*cos(i);
-		p2.y = y + outer_height*sin(i);
-		p2.z = z;
-
-		DrawLinePoygonline(p1,p2, outer_width - inner_width);
-		p1 = p2;
-
-	}
-
-	//DrawWidePath(ellipse_points, z, outer_width - inner_width,color);
-}
-
-void DrawingHelpers::DrawSimpleEllipse(float x, float y, float z, float outer_width, float outer_height)
-{
-	glBegin(GL_LINE_STRIP);
-	for (float jj = 0; jj &lt;=M_PI*2.0; jj+=0.1)
-	{
-		glVertex3f(x + outer_width*cos(jj), y+ outer_height*sin(jj),z);
-	}
-	glEnd();
-}
-
-void DrawingHelpers::DrawPedal(float x, float y, float z, float width, float height, float inner_height, float color[3])
-{
-	GPSPoint pa, pb, pc, pd;
-	double w2 = width/2.0;
-	double h2 = height/2.0;
-
-	pa.x = x - w2;
-	pa.y = y - h2;
-
-	pb.x = x + w2;
-	pb.y = y - h2;
-
-	pc.x = x + w2;
-	pc.y = y + h2;
-
-	pd.x = x - w2;
-	pd.y = y + h2;
-
-	glBegin(GL_LINE_LOOP);
-	  glVertex3f(pa.x, pa.y, z);
-	  glVertex3f(pb.x, pb.y, z);
-	  glVertex3f(pc.x, pc.y, z);
-	  glVertex3f(pd.x, pd.y, z);
-	glEnd();
-
-	GPSPoint p1(x, y + h2, z, 0);
-	GPSPoint p2(x, y + h2 - inner_height, z, 0);
-
-	glColor3f(color[0], color[1], color[2]);
-	DrawLinePoygonline(p1,p2,w2);
-
-}
-
-} /* namespace Graphics */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\Graph2dBase.cpp" new_path="" added_lines="0" deleted_lines="201">
				<diff>@@ -1,201 +0,0 @@
-/*
- * Graph2dBase.cpp
- *
- *  Created on: Oct 8, 2016
- *      Author: hatem
- */
-
-#include "op_simu/Graph2dBase.h"
-#include "op_utility/UtilityH.h"
-
-using namespace PlannerHNS;
-
-
-namespace Graphics
-{
-
-#define BORDER_MARGIN 20
-#define AXE_WIDTH 2
-
-Graph2dBase::Graph2dBase(double width, double height, int nMaxPoints, double max_y, double min_y, std::string str_title, std::string str_x, std::string str_y, double a_color[], double g_color[]) {
-
-	w = width;
-	h = height;
-	nPoints = nMaxPoints;
-	graph_title = str_title;
-	x_name = str_x;
-	y_name = str_y;
-
-
-	axes_color[0] = a_color[0];
-	axes_color[1] = a_color[1];
-	axes_color[2] = a_color[2];
-
-	graph_color[0] = g_color[0];
-	graph_color[1] = g_color[1];
-	graph_color[2] = g_color[2];
-
-	m_PrevTimeStamp.tv_nsec = 0;
-	m_PrevTimeStamp.tv_sec = 0;
-	max_point.y = max_y;
-	min_point.y = min_y;
-
-
-}
-
-void Graph2dBase::ReInitGraphResolution(double width, double height, int nMaxPoints, double a_color[], double g_color[])
-{
-	w = width;
-	h = height;
-	nPoints = nMaxPoints;
-	axes_color[0] = a_color[0];
-	axes_color[1] = a_color[1];
-	axes_color[2] = a_color[2];
-
-	graph_color[0] = g_color[0];
-	graph_color[1] = g_color[1];
-	graph_color[2] = g_color[2];
-}
-
-Graph2dBase::~Graph2dBase()
-{
-
-}
-
-
-double Graph2dBase::DrawGraph()
-{
-
-	glDisable(GL_LIGHTING);
-
-	glBegin(GL_POLYGON);
-		glColor3f(0.9,0.9,0.9);
-		glNormal3f(0.1, 0.1, 0.1);
-		glVertex3f(0, 0, 0);
-		glVertex3f(0, h, 0);
-		glVertex3f(w, h, 0);
-		glVertex3f(w, 0, 0);
-	glEnd();
-
-
-	GPSPoint p_origin, x_end, y_end;
-	p_origin.x = BORDER_MARGIN;
-	p_origin.y = h - BORDER_MARGIN*2;
-
-	x_end.x = w - BORDER_MARGIN*2;
-	x_end.y = h - BORDER_MARGIN*2;
-
-	y_end.x = BORDER_MARGIN;
-	y_end.y = BORDER_MARGIN;
-
-
-	glColor3f(axes_color[0],axes_color[1],axes_color[2]);
-	DrawingHelpers::DrawLinePoygonline(p_origin, x_end, AXE_WIDTH);
-	DrawingHelpers::DrawLinePoygonline(p_origin, y_end, AXE_WIDTH);
-
-	glColor3f(graph_color[0],graph_color[1],graph_color[2]);
-	DrawingHelpers::DrawString(x_end.x, x_end.y, GLUT_BITMAP_HELVETICA_18, (char*)x_name.c_str());
-	DrawingHelpers::DrawString(y_end.x, y_end.y, GLUT_BITMAP_HELVETICA_18, (char*)y_name.c_str());
-	DrawingHelpers::DrawString(BORDER_MARGIN, p_origin.y+BORDER_MARGIN, GLUT_BITMAP_HELVETICA_18, (char*)graph_title.c_str());
-
-
-	glPointSize(4);
-	glBegin(GL_POINTS);
-		for(unsigned int i = 1 ; i &lt; xy_arr.size(); i++)
-		{
-			//glVertex3f(xy_arr.at(i-1).x, xy_arr.at(i-1).y, 0);
-			glVertex3f(xy_arr.at(i).x, xy_arr.at(i).y, 0);
-		}
-	glEnd();
-	glBegin(GL_LINES);
-		for(unsigned int i = 1 ; i &lt; xy_arr.size(); i++)
-		{
-			glVertex3f(xy_arr.at(i-1).x, xy_arr.at(i-1).y, 0);
-			glVertex3f(xy_arr.at(i).x, xy_arr.at(i).y, 0);
-		}
-	glEnd();
-
-
-	glEnable(GL_LIGHTING);
-}
-
-void Graph2dBase::InsertPointTimeStamp(const timespec&amp; tStamp, const double&amp; y)
-{
-	GPSPoint p(0,y,0,0);
-	if(xy_arr_original.size() == 0)
-	{
-		xy_arr_original.push_back(p);
-	}
-	else
-	{
-		if(tStamp.tv_nsec == 0 &amp;&amp; tStamp.tv_sec == 0)
-		{
-			p.x = xy_arr_original.at(xy_arr_original.size()-1).x+1;
-		}
-		else
-		{
-			double t = UtilityHNS::UtilityH::GetTimeDiff(m_PrevTimeStamp, tStamp);
-			p.x = xy_arr_original.at(xy_arr_original.size()-1).x+t;
-		}
-	}
-
-
-
-	double initial_x = xy_arr_original.at(0).x;
-
-//	if(xy_arr_original.size() &gt; nPoints)
-//	{
-//		initial_x = xy_arr_original.at(0).x;
-//		xy_arr_original.erase(xy_arr_original.begin()+0);
-//	}
-
-
-
-	xy_arr_original.push_back(p);
-
-	xy_arr.clear();
-
-
-	for(unsigned int i=0; i&lt;xy_arr_original.size(); i++ )
-	{
-		//p.x = BORDER_MARGIN + ((xy_arr_original.at(i).x - avg_x) / (max_point.x - min_point.x) * 10.0);
-		//p.y = h - BORDER_MARGIN*2 - ((xy_arr_original.at(i).y - avg_y) / (max_point.y - min_point.y) * 10.0);
-		double y_val = (h - BORDER_MARGIN*3) * ((xy_arr_original.at(i).y - min_point.y) / (max_point.y - min_point.y));
-		double x_val = (xy_arr_original.at(i).x - initial_x)*10.0;
-
-		p.x = BORDER_MARGIN + x_val;
-		p.y = (h - BORDER_MARGIN*2) - y_val;
-		xy_arr.push_back(p);
-	}
-
-	double total_x = 0;
-
-	for(int i=xy_arr.size()-1; i&gt;0; i-- )
-	{
-		total_x += (xy_arr.at(i).x - xy_arr.at(i-1).x);
-		if(total_x &gt; (w - BORDER_MARGIN*3))
-		{
-			xy_arr_original.erase(xy_arr_original.begin(), xy_arr_original.begin()+i);
-			break;
-		}
-	}
-
-	m_PrevTimeStamp = tStamp;
-}
-
-void Graph2dBase::InsertPoint(const double&amp; x, const double&amp; y)
-{
-
-}
-
-void Graph2dBase::InsertPointsList(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; points)
-{
-
-}
-
-void Graph2dBase::UpdateComment(const std::string&amp; str_com)
-{
-	str_comment = str_com;
-}
-
-} /* namespace Graphics */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\MainWindowWrapper.cpp" new_path="" added_lines="0" deleted_lines="922">
				<diff>@@ -1,922 +0,0 @@
-/*
- * MainWindowWrapper.cpp
- *
- *  Created on: May 31, 2016
- *      Author: hatem
- */
-
-#include "op_simu/MainWindowWrapper.h"
-#include "op_simu/DrawingHelpers.h"
-#include &lt;iostream&gt;
-#include &lt;cmath&gt;
-#include "op_utility/UtilityH.h"
-#include "GL/freeglut_ext.h"
-
-using namespace std;
-using namespace UtilityHNS;
-#include "op_planner/MatrixOperations.h"
-
-namespace Graphics {
-
-WindowParams MainWindowWrapper::m_params;
-DisplayParams MainWindowWrapper::m_DisplayParam;
-
-WindowParams::WindowParams()
-{
-	title = "Simple Simulator";
-
-	x = 10;
-	y = 10;
-	w = 1200;
-	h = 800;
-	info_ratio = 0.25;
-
-	UI_CONST.GAP = 20;
-	UI_CONST.MAX_ZOOM = 600000.0;
-	UI_CONST.MIN_ZOOM = 2.01;
-	UI_CONST.INIT_ZOOM = 7.0;
-	UI_CONST.FOLLOW_CONST_ZOOM = 2.5;
-
-	ReCalcSimuWindow();
-
-	bNew = true;
-	bGPU = true;
-}
-
-void WindowParams::ReCalcSimuWindow()
-{
-	info_window.x = w*(1.0-info_ratio) - UI_CONST.GAP;
-	info_window.y = UI_CONST.GAP;
-	info_window.w = w*info_ratio;
-	info_window.h = h - 2.0*UI_CONST.GAP;
-
-	simu_window.x = UI_CONST.GAP;
-	simu_window.y = UI_CONST.GAP;
-	simu_window.w = w - UI_CONST.GAP * 3 - info_window.w;
-	simu_window.h = h - UI_CONST.GAP * 2;
-}
-
-DisplayParams::DisplayParams()
-{
-
-	prev_x = prev_y = -999999;
-	currRotationZ = currRotationX = currRotationY  = 0;
-
-	zoom = 15;
-	centerRotX = 5;
-	centerRotY = 5;
-
-	eye[0] = 0.0; eye[1] = 0.0; eye[2] = zoom;
-	at[0] = 0.0; at[1] = 0.0; at[2] = 0.0;
-	up[0] = 0.0; up[1] = 1.0; up[2] = 0.0;
-
-	bDisplayMode = DISPLAY_TOP_FREE;
-
-	bLeftDown =	bRightDown = bCenterDown = false;;
-
-	prespective_z   = 100;
-	prespective_fov = 45;
-
-	translateX = 5;
-	translateY = 5;
-
-	actualViewX = 0;
-	actualViewY = 0;
-
-	bFullScreen = false;
-
-	bSelectPosition = 0;
-	StartPos[0] = StartPosFinal[0] = 0;
-	StartPos[1] = StartPosFinal[1] = 0;
-	StartPos[2] = StartPosFinal[2] = 0;
-	GoalPos[0] = GoalPosFinal[0] = 0;
-	GoalPos[1] = GoalPosFinal[1] = 0;
-	GoalPos[2] = GoalPosFinal[1] = 0;
-	SimulatedCarPos[0] = SimulatedCarPos[1] = SimulatedCarPos[2] = 0;
-
-}
-
-int MainWindowWrapper::m_MainWindow = 0;
-int MainWindowWrapper::m_SimuWindow = 0;
-int MainWindowWrapper::m_InfoWindow = 0;
-int MainWindowWrapper::m_PopupMenu = 0;
-DrawObjBase* MainWindowWrapper::m_DrawAndControl = 0;
-
-MainWindowWrapper::MainWindowWrapper(DrawObjBase* pDraw)
-{
-	m_DrawAndControl = pDraw;
-}
-
-MainWindowWrapper::~MainWindowWrapper(){}
-
-void MainWindowWrapper::CleanUp()
-{
-	if(m_DrawAndControl)
-		delete m_DrawAndControl;
-}
-
-void MainWindowWrapper::InitOpenGLWindow(int argc, char** argv)
-{
-	if(m_params.bGPU)
-		glutInitDisplayMode(GLUT_RGBA | GLUT_MULTISAMPLE);
-	else
-		glutInitDisplayMode(GLUT_RGB | GLUT_DEPTH | GLUT_SINGLE);
-	glutInitWindowSize(m_params.w, m_params.h );
-	glutInitWindowPosition(m_params.x, m_params.y);
-	glutInit(&amp;argc, argv);
-
-
-
-
-	m_MainWindow = glutCreateWindow(m_params.title.c_str());
-	glutReshapeFunc(MainWindowWrapper::MainReshape);
-	glutDisplayFunc(MainWindowWrapper::MainDisplay);
-	glutKeyboardFunc(MainWindowWrapper::KeyboardExitCommand);
-
-
-	m_SimuWindow = glutCreateSubWindow(m_MainWindow, m_params.simu_window.x, m_params.simu_window.y, m_params.simu_window.w, m_params.simu_window.h);
-	glutReshapeFunc(MainWindowWrapper::SimuReshape);
-	glutDisplayFunc(MainWindowWrapper::SimuDisplay);
-	glutMotionFunc(MainWindowWrapper::MouseMove);
-	glutMouseFunc(MainWindowWrapper::MouseCommand);
-	glutKeyboardFunc(MainWindowWrapper::KeyboardCommand);
-	glutSpecialFunc(MainWindowWrapper::KeyboardSpecialCommand);
-	if(m_DrawAndControl)
-		m_DrawAndControl-&gt;LoadMaterials();
-	CreateRightClickMenu();
-
-	m_InfoWindow = glutCreateSubWindow(m_MainWindow, m_params.info_window.x, m_params.info_window.y, m_params.info_window.w, m_params.info_window.h);
-	glutReshapeFunc(MainWindowWrapper::InfoReshape);
-	glutDisplayFunc(MainWindowWrapper::InfoDisplay);
-	glutKeyboardFunc(MainWindowWrapper::KeyboardExitCommand);
-
-	//RedisplayAll();
-	glutPostRedisplay();
-
-	KeyboardCommand('f', 0,0);
-
-	atexit(CleanUp);
-
-	glutMainLoop();
-}
-
-void MainWindowWrapper::InitLighting()
-{
-	float light_ambient[] = { 0.5,1.0, 0.5, 0.0 };
-	float defuse[] = {1.0, 1.0, 1.0,1.0};
-	float mat_specular[] = { 1.0, 1.0, 1.0, 0.0 };
-	float mat_shininess[] = { 50.0 };
-	//float light_position[4] = { 0.0, 0.0, 20.0, 0.0 };
-	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, defuse);
-	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, light_ambient);
-	glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat_specular);
-	glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
-	//glLightfv(GL_LIGHT0, GL_POSITION, light_position);
-	glEnable(GL_LIGHTING);
-	glEnable(GL_LIGHT0);
-	glEnable(GL_COLOR_MATERIAL);
-	glEnable(GL_DEPTH_TEST);
-	glShadeModel(GL_SMOOTH);
-}
-
-void MainWindowWrapper::UpdateParams(const WindowParams&amp; params, const DisplayParams&amp; display_params)
-{
-	m_params = params;
-	m_DisplayParam = display_params;
-	FromScreenToModelCoordinate(m_params.simu_window.w/2.0, m_params.simu_window.h/2.0,
-				m_DisplayParam.initScreenToCenterMargin[0], m_DisplayParam.initScreenToCenterMargin[1]);
-}
-
-void MainWindowWrapper::MainReshape(int width,  int height)
-{
-	m_params.w = width;
-	m_params.h = height;
-	m_params.ReCalcSimuWindow();
-
-	glViewport(0,0, m_params.w, m_params.h);
-	glMatrixMode(GL_PROJECTION);
-	glLoadIdentity();
-	gluOrtho2D(0, m_params.w, m_params.h, 0);
-	glMatrixMode(GL_MODELVIEW);
-	glLoadIdentity();
-
-	glutPostWindowRedisplay(m_InfoWindow);
-	glutPostWindowRedisplay(m_SimuWindow);
-}
-
-void MainWindowWrapper::SimuReshape(int width,  int height)
-{
-	glutPositionWindow(m_params.simu_window.x, m_params.simu_window.y);
-	glutReshapeWindow(m_params.simu_window.w, m_params.simu_window.h);
-
-	glViewport(0,0, m_params.simu_window.w, m_params.simu_window.h);
-
-	//this should rely on the map not the window
-	double y_max = sqrt(pow(m_params.simu_window.w,2) + pow(m_params.simu_window.h,2))/2.0;
-	if(y_max &gt; 0.05 &amp;&amp; y_max &lt; (m_params.simu_window.w*m_params.simu_window.h))
-		m_DisplayParam.prespective_z = y_max;
-
-	m_DisplayParam.prespective_z = 10000;
-
-	glMatrixMode(GL_PROJECTION);
-	glLoadIdentity();
-	double aspect_ratio = (double)m_params.simu_window.w/(double)m_params.simu_window.h;
-//	if(aspect_ratio &lt; m_params.simu_window.h/m_params.simu_window.w)
-//		aspect_ratio = m_params.simu_window.h/m_params.simu_window.w;
-
-	gluPerspective(m_DisplayParam.prespective_fov,aspect_ratio,0.05,m_DisplayParam.prespective_z);
-	glMatrixMode(GL_MODELVIEW);
-	glLoadIdentity();
-
-	//double x = 0, y =0;
-
-	if(m_DisplayParam.bDisplayMode == DISPLAY_FOLLOW &amp;&amp; m_DrawAndControl)
-	{
-//			m_DisplayParam.eye[0] = m_DrawAndControl-&gt;m_followX-m_DisplayParam.translateX;
-//			m_DisplayParam.eye[1] = m_DrawAndControl-&gt;m_followY-m_DisplayParam.translateY;
-//			m_DisplayParam.at[0] = m_DrawAndControl-&gt;m_followX-m_DisplayParam.translateX;
-//			m_DisplayParam.at[1] = m_DrawAndControl-&gt;m_followY-m_DisplayParam.translateY;
-		m_DisplayParam.eye[0] = m_DisplayParam.centerRotX;
-		m_DisplayParam.eye[1] = m_DisplayParam.centerRotY;
-		m_DisplayParam.at[0] = m_DisplayParam.centerRotX;
-		m_DisplayParam.at[1] = m_DisplayParam.centerRotY;
-	}
-
-
-	gluLookAt(m_DisplayParam.eye[0], m_DisplayParam.eye[1], m_DisplayParam.zoom,
-			m_DisplayParam.at[0], m_DisplayParam.at[1], m_DisplayParam.at[2],
-			m_DisplayParam.up[0], m_DisplayParam.up[1],m_DisplayParam.up[2]);
-
-	InitLighting();
-
-}
-
-void MainWindowWrapper::FromScreenToModelCoordinate(int sx, int sy, double&amp; modelX, double&amp; modelY)
-{
-	double whole = (double)(m_params.simu_window.w + m_params.simu_window.h)/2.0;
-	double actualViewX = tan(m_DisplayParam.prespective_fov*DEG2RAD) * m_DisplayParam.zoom / whole;
-
-	modelX = sx * actualViewX ;
-	modelY = sy * actualViewX ;
-}
-
-void MainWindowWrapper::FromModelToScreenCoordinate(double modelX, double modelY, int&amp; sx, int&amp; sy)
-{
-	double actualViewX = tan(m_DisplayParam.prespective_fov*DEG2RAD) * m_DisplayParam.zoom / m_params.simu_window.w;
-
-	sx = modelX / actualViewX ;
-	sy = modelY / actualViewX ;
-}
-
-void MainWindowWrapper::SimuDisplay()
-{
-
-	//glClearColor(1,1,1,0);
-	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-
-	if(m_DisplayParam.bDisplayMode == DISPLAY_FOLLOW &amp;&amp; m_DrawAndControl)
-	{
-		//glTranslated(-m_DisplayParam.translateX, -m_DisplayParam.translateY, 0);
-		m_DisplayParam.centerRotX = m_DrawAndControl-&gt;m_followX;
-		m_DisplayParam.centerRotY = m_DrawAndControl-&gt;m_followY;
-
-
-		int yaw = (m_DisplayParam.currRotationZ/8)%360;
-		int roll = (m_DisplayParam.currRotationX/8)%360;
-		int pitch = (m_DisplayParam.currRotationY/8)%360;
-
-		glTranslated(m_DisplayParam.centerRotX, m_DisplayParam.centerRotY, 0);
-		glRotated(yaw, 0,0,1);
-		glRotated(roll, 1,0,0);
-		glRotated(pitch, 0,1,0);
-		glTranslated(-m_DisplayParam.centerRotX, -m_DisplayParam.centerRotY, 0);
-	}
-	else if(m_DisplayParam.bDisplayMode == DISPLAY_FREE)
-	{
-		glTranslated(-m_DisplayParam.translateX, -m_DisplayParam.translateY, 0);
-
-		int yaw = (m_DisplayParam.currRotationZ/8)%360;
-		int roll = (m_DisplayParam.currRotationX/8)%360;
-		int pitch = (m_DisplayParam.currRotationY/8)%360;
-
-		glTranslated(m_DisplayParam.centerRotX, m_DisplayParam.centerRotY, 0);
-		glRotated(yaw, 0,0,1);
-		glRotated(roll, 1,0,0);
-		glRotated(pitch, 0,1,0);
-		glTranslated(-m_DisplayParam.centerRotX, -m_DisplayParam.centerRotY, 0);
-	}
-	else if(m_DisplayParam.bDisplayMode == DISPLAY_TOP_FREE)
-	{
-		glTranslated(-m_DisplayParam.translateX, -m_DisplayParam.translateY, 0);
-
-		int yaw = (m_DisplayParam.currRotationZ/8)%360;
-		//int roll = (m_DisplayParam.currRotationX/8)%360;
-		//int pitch = (m_DisplayParam.currRotationY/8)%360;
-
-
-		glTranslated(m_DisplayParam.centerRotX, m_DisplayParam.centerRotY, 0);
-		glRotated(yaw, 0,0,1);
-		//glRotated(roll, 1,0,0);
-		//glRotated(pitch, 0,1,0);
-		glTranslated(-m_DisplayParam.centerRotX, -m_DisplayParam.centerRotY, 0);
-	}
-
-
-//	glPushMatrix();
-//	glTranslated(5, 5, 0);
-//	glutSolidTeapot(3);
-//	glPopMatrix();
-
-//
-
-	DrawingHelpers::DrawCustomOrigin(m_DisplayParam.centerRotX, m_DisplayParam.centerRotY, 0, 0, 0, 0, 2.5 );
-
-	if(m_DrawAndControl)
-		m_DrawAndControl-&gt;DrawSimu();
-	else
-		DrawingHelpers::DrawGrid(m_DisplayParam.centerRotX-5, m_DisplayParam.centerRotY-5, 10, 10, 1);
-
-	int yaw = (m_DisplayParam.currRotationZ/8)%360;
-	PlannerHNS::Mat3 rotationMat(-yaw*DEG2RAD);
-	PlannerHNS::Mat3 translationMat(m_DisplayParam.centerRotX, m_DisplayParam.centerRotY);
-	PlannerHNS::Mat3 invTranslationMat(-m_DisplayParam.centerRotX, -m_DisplayParam.centerRotY);
-
-	if(m_DisplayParam.bSelectPosition == 1)
-	{
-		double sx=0, sy=0;
-		FromScreenToModelCoordinate(m_DisplayParam.StartPos[0]-m_params.simu_window.w/2.0,
-				m_params.simu_window.h/2.0 - m_DisplayParam.StartPos[1],sx,sy);
-
-		PlannerHNS::GPSPoint sp(sx+m_DisplayParam.translateX, sy+m_DisplayParam.translateY, 0, 0);
-		sp = translationMat * sp;
-		sp = rotationMat * sp;
-		sp = invTranslationMat  * sp;
-		m_DisplayParam.StartPosFinal[0] = sp.x;
-		m_DisplayParam.StartPosFinal[1] = sp.y;
-		m_DisplayParam.StartPosFinal[2] = m_DisplayParam.StartPos[2];
-
-	}
-	else if(m_DisplayParam.bSelectPosition == 2)
-	{
-		double gx=0,gy=0;
-		FromScreenToModelCoordinate(m_DisplayParam.GoalPos[0]-m_params.simu_window.w/2.0,
-						m_params.simu_window.h/2.0 - m_DisplayParam.GoalPos[1],gx,gy);
-
-		PlannerHNS::GPSPoint gp(gx+m_DisplayParam.translateX, gy+m_DisplayParam.translateY, 0, m_DisplayParam.GoalPos[2]);
-		gp = translationMat * gp;
-		gp = rotationMat * gp;
-		gp = invTranslationMat * gp;
-		m_DisplayParam.GoalPosFinal[0] = gp.x;
-		m_DisplayParam.GoalPosFinal[1] = gp.y;
-		m_DisplayParam.GoalPosFinal[2] = m_DisplayParam.GoalPos[2];
-	}
-	else if(m_DisplayParam.bSelectPosition == 3)
-	{
-		double x=0,y=0;
-		FromScreenToModelCoordinate(m_DisplayParam.SimulatedCarPos[0]-m_params.simu_window.w/2.0,
-						m_params.simu_window.h/2.0 - m_DisplayParam.SimulatedCarPos[1],x,y);
-
-		PlannerHNS::GPSPoint gp(x+m_DisplayParam.translateX, y+m_DisplayParam.translateY, 0, m_DisplayParam.SimulatedCarPos[2]);
-		gp = translationMat * gp;
-		gp = rotationMat * gp;
-		gp = invTranslationMat * gp;
-		m_DisplayParam.SimulatedCarPosFinal[0] = gp.x;
-		m_DisplayParam.SimulatedCarPosFinal[1] = gp.y;
-		m_DisplayParam.SimulatedCarPosFinal[2] = m_DisplayParam.SimulatedCarPos[2];
-	}
-
-	glPushMatrix();
-	DrawingHelpers::DrawArrow(m_DisplayParam.StartPosFinal[0], m_DisplayParam.StartPosFinal[1], m_DisplayParam.StartPosFinal[2]);
-	DrawingHelpers::DrawArrow(m_DisplayParam.GoalPosFinal[0], m_DisplayParam.GoalPosFinal[1], m_DisplayParam.GoalPosFinal[2]);
-	DrawingHelpers::DrawArrow(m_DisplayParam.SimulatedCarPosFinal[0], m_DisplayParam.SimulatedCarPosFinal[1], m_DisplayParam.SimulatedCarPosFinal[2]);
-	glPopMatrix();
-
-
-	glutSwapBuffers();
-}
-
-void MainWindowWrapper::InfoReshape(int width,  int height)
-{
-	glutPositionWindow(m_params.info_window.x, m_params.info_window.y);
-	glutReshapeWindow(m_params.info_window.w, m_params.info_window.h);
-
-	glViewport(0,0, m_params.info_window.w, m_params.info_window.h);
-	glMatrixMode(GL_PROJECTION);
-	glLoadIdentity();
-	gluOrtho2D(0, m_params.info_window.w, m_params.info_window.h, 0);
-	glMatrixMode(GL_MODELVIEW);
-	glLoadIdentity();
-
-	//cout &lt;&lt; "Info: width = " &lt;&lt; width &lt;&lt; ", height = " &lt;&lt; height &lt;&lt; ", x=" &lt;&lt;m_params.info_window.x &lt;&lt; ", y=" &lt;&lt;m_params.info_window.y&lt;&lt;  endl;
-}
-
-void MainWindowWrapper::MainDisplay()
-{
-
-	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-
-	glDisable(GL_LIGHTING);
-	glPushMatrix();
-	glBegin(GL_POLYGON);
-	glColor3f(0.1,0.1,0.1);
-	glVertex2i(0, m_params.h);
-	glVertex2i(m_params.w,m_params.h);
-	glColor3f(0.9,0.9,0.9);
-	glVertex2i(m_params.w, 0);
-	glVertex2i(0,0);
-	glEnd();
-	glPopMatrix();
-	glEnable(GL_LIGHTING);
-
-	glPushMatrix();
-	glColor3f(0.9, 0.2, 0.2);
-	glTranslated(m_params.simu_window.x, m_params.UI_CONST.GAP-1, 0);
-	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)"Simulation View");
-	glPopMatrix();
-
-	glPushMatrix();
-	glColor3f(0.9, 0.2, 0.2);
-	glTranslated(m_params.info_window.x, m_params.UI_CONST.GAP-1, 0);
-	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)"Info View");
-	glPopMatrix();
-
-	glutSwapBuffers();
-}
-
-void MainWindowWrapper::InfoDisplay()
-{
-	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-
-	glDisable(GL_LIGHTING);
-	glPushMatrix();
-	glBegin(GL_POLYGON);
-	glColor3f(0.1,0.1,0.1);
-	glVertex2i(0,0);
-	glVertex2i(0,m_params.info_window.h);
-	glColor3f(0.3,0.3,0.3);
-	glVertex2i(m_params.info_window.w,m_params.info_window.h);
-	glVertex2i(m_params.info_window.w,0);
-	glEnd();
-	glPopMatrix();
-	glEnable(GL_LIGHTING);
-
-	//cout &lt;&lt; "InfoDisplay" &lt;&lt; endl;
-
-	if(m_DisplayParam.bSelectPosition == 1)
-	{
-		glPushMatrix();
-		glColor3f(0.9, 0.2, 0.2);
-		glTranslated(10, m_params.info_window.h - 40, 0);
-		DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)"Start Position");
-		glPopMatrix();
-	}
-	else if(m_DisplayParam.bSelectPosition == 2)
-	{
-		glPushMatrix();
-		glColor3f(0.9, 0.2, 0.2);
-		glTranslated(10, m_params.info_window.h - 40, 0);
-		DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)"Goal Position");
-		glPopMatrix();
-	}
-	else if(m_DisplayParam.bSelectPosition == 3)
-	{
-		glPushMatrix();
-		glColor3f(0.9, 0.2, 0.2);
-		glTranslated(10, m_params.info_window.h - 40, 0);
-		DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)"Simulation Positions");
-		glPopMatrix();
-	}
-
-	if(m_DrawAndControl)
-		m_DrawAndControl-&gt;DrawInfo(m_params.info_window.w/2, m_params.info_window.h/2, m_params.info_window.w, m_params.info_window.h);
-
-	glutSwapBuffers();
-}
-
-void MainWindowWrapper::RedisplayAll()
-{
-//	glutSetWindow(m_InfoWindow);
-//	glutPostRedisplay();
-//	glutSetWindow(m_SimuWindow);
-//	glutPostRedisplay();
-//	glutSetWindow(m_MainWindow);
-//	glutPostRedisplay();
-}
-
-void MainWindowWrapper::MouseMove(int x, int y)
-{
-	if(m_DisplayParam.bSelectPosition == 1)
-	{
-		if(m_DisplayParam.bLeftDown)
-		{
-			m_DisplayParam.StartPos[2] = atan2(m_DisplayParam.StartPos[1] - y, x - m_DisplayParam.StartPos[0]);
-		}
-	}
-	else if(m_DisplayParam.bSelectPosition == 2)
-	{
-		if(m_DisplayParam.bLeftDown)
-		{
-			m_DisplayParam.GoalPos[2] = atan2(m_DisplayParam.GoalPos[1] - y, x - m_DisplayParam.GoalPos[0]);
-		}
-	}
-	else if(m_DisplayParam.bSelectPosition == 3)
-	{
-		if(m_DisplayParam.bLeftDown)
-		{
-			m_DisplayParam.SimulatedCarPos[2] = atan2(m_DisplayParam.SimulatedCarPos[1] - y, x - m_DisplayParam.SimulatedCarPos[0]);
-		}
-	}
-	else if(m_DisplayParam.bLeftDown)
-	{
-		m_DisplayParam.currRotationZ += x-m_DisplayParam.prev_x;
-		m_DisplayParam.prev_x = x;
-
-		//if(m_DisplayParam.bFreeDisplay)
-		{
-			double zdir = (m_DisplayParam.currRotationZ/8)%360 * DEG2RAD;
-			double xRatio = cos(zdir);
-			double yRatio = sin(zdir);
-
-			m_DisplayParam.currRotationX += (y-m_DisplayParam.prev_y) * xRatio;
-			m_DisplayParam.currRotationY += (m_DisplayParam.prev_y - y) * yRatio;
-
-			m_DisplayParam.prev_y = y;
-		}
-	}
-	else if (m_DisplayParam.bRightDown)
-	{
-	}
-	else if (m_DisplayParam.bCenterDown)
-	{
-
-		m_DisplayParam.actualViewX = (tan(m_DisplayParam.prespective_fov/2.0*DEG2RAD) * m_DisplayParam.zoom * 2.0)/m_params.simu_window.w;
-		m_DisplayParam.actualViewY = (tan(m_DisplayParam.prespective_fov/2.0*DEG2RAD) * m_DisplayParam.zoom * 2.0)/m_params.simu_window.h;
-
-		m_DisplayParam.translateX += (m_DisplayParam.prev_x-x)*m_DisplayParam.actualViewX;
-		m_DisplayParam.translateY += (y-m_DisplayParam.prev_y)*m_DisplayParam.actualViewY;
-
-		m_DisplayParam.prev_x = x;
-		m_DisplayParam.prev_y = y;
-
-	}
-	else
-	{
-
-	}
-
-}
-
-void MainWindowWrapper::MouseCommand(int button, int state, int x, int y)
-{
-	//cout &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; endl;
-	if(m_DisplayParam.bSelectPosition == 1)
-	{
-		if(button == 0 &amp;&amp; state == 0 &amp;&amp; !m_DisplayParam.bLeftDown)
-		{
-			m_DisplayParam.bLeftDown = true;
-			m_DisplayParam.StartPos[0] = x;
-			m_DisplayParam.StartPos[1] = y;
-			//cout &lt;&lt; "Left Down" &lt;&lt; endl;
-		}
-		else if(button == 0 &amp;&amp; state == 1)
-		{
-			m_DisplayParam.bLeftDown = false;
-			m_DisplayParam.bSelectPosition = 0;
-		}
-	}
-	else if(m_DisplayParam.bSelectPosition == 2)
-	{
-		if(button == 0 &amp;&amp; state == 0 &amp;&amp; !m_DisplayParam.bLeftDown)
-		{
-			m_DisplayParam.bLeftDown = true;
-			m_DisplayParam.GoalPos[0] = x;
-			m_DisplayParam.GoalPos[1] = y;
-			//cout &lt;&lt; "Left Down" &lt;&lt; endl;
-		}
-		else if(button == 0 &amp;&amp; state == 1)
-		{
-			m_DisplayParam.bLeftDown = false;
-			m_DisplayParam.bSelectPosition = 0;
-			m_DrawAndControl-&gt;UpdatePlaneStartGoal(m_DisplayParam.StartPosFinal[0],
-					m_DisplayParam.StartPosFinal[1], m_DisplayParam.StartPosFinal[2],
-					m_DisplayParam.GoalPosFinal[0], m_DisplayParam.GoalPosFinal[1], m_DisplayParam.GoalPosFinal[2]);
-		}
-	}
-	else if(m_DisplayParam.bSelectPosition == 3)
-	{
-//		if(button == 0 &amp;&amp; state == 1)
-//		{
-//			int yaw = (m_DisplayParam.currRotationZ/8)%360;
-//			PlannerHNS::Mat3 rotationMat(-yaw*DEG2RAD);
-//			PlannerHNS::Mat3 translationMat(m_DisplayParam.centerRotX, m_DisplayParam.centerRotY);
-//			PlannerHNS::Mat3 invTranslationMat(-m_DisplayParam.centerRotX, -m_DisplayParam.centerRotY);
-//
-//			double gx=0,gy=0;
-//			FromScreenToModelCoordinate(x-m_params.simu_window.w/2.0, m_params.simu_window.h/2.0 - y,gx,gy);
-//
-//			PlannerHNS::GPSPoint gp(gx+m_DisplayParam.translateX, gy+m_DisplayParam.translateY, 0, 0);
-//			gp = translationMat * gp;
-//			gp = rotationMat * gp;
-//			gp = invTranslationMat * gp;
-//
-//			m_DisplayParam.bSelectPosition = 0;
-//
-//		}
-
-		if(button == 0 &amp;&amp; state == 0 &amp;&amp; !m_DisplayParam.bLeftDown)
-		{
-			m_DisplayParam.bLeftDown = true;
-			m_DisplayParam.SimulatedCarPos[0] = x;
-			m_DisplayParam.SimulatedCarPos[1] = y;
-			//cout &lt;&lt; "Left Down" &lt;&lt; endl;
-		}
-		else if(button == 0 &amp;&amp; state == 1)
-		{
-			m_DisplayParam.bLeftDown = false;
-			m_DisplayParam.bSelectPosition = 0;
-			m_DrawAndControl-&gt;AddSimulatedCarPos(m_DisplayParam.SimulatedCarPosFinal[0],
-					m_DisplayParam.SimulatedCarPosFinal[1], m_DisplayParam.SimulatedCarPosFinal[2]);
-		}
-	}
-	else if(button == 0 &amp;&amp; state == 0 &amp;&amp; !m_DisplayParam.bLeftDown)
-	{
-		m_DisplayParam.bLeftDown = true;
-		m_DisplayParam.prev_x = x;
-		m_DisplayParam.prev_y = y;
-		//cout &lt;&lt; "Left Down" &lt;&lt; endl;
-	}
-	else if(button == 0 &amp;&amp; state == 1)
-	{
-		m_DisplayParam.bLeftDown = false;
-	}
-	else if(button == 2 &amp;&amp; state == 0 &amp;&amp; !m_DisplayParam.bRightDown)
-	{
-		m_DisplayParam.bRightDown = true;
-		m_DisplayParam.prev_x = x;
-		m_DisplayParam.prev_y = y;
-		//cout &lt;&lt; "Right Down" &lt;&lt; endl;
-	}
-	else if(button == 2 &amp;&amp; state == 1)
-	{
-		m_DisplayParam.bRightDown = false;
-
-	}
-	else if(button == 1 &amp;&amp; state == 0 &amp;&amp; !m_DisplayParam.bCenterDown)
-	{
-		m_DisplayParam.bCenterDown = true;
-		m_DisplayParam.prev_x = x;
-		m_DisplayParam.prev_y = y;
-		//cout &lt;&lt; "Right Down" &lt;&lt; endl;
-	}
-	else if(button == 1 &amp;&amp; state == 1)
-	{
-		m_DisplayParam.bCenterDown = false;
-
-	}
-	else if(button == 3)
-	{
-		m_DisplayParam.zoom-=1;
-		if(m_DisplayParam.zoom &lt; 2)
-			m_DisplayParam.zoom = 2;
-	}
-	else if (button == 4)
-	{
-		m_DisplayParam.zoom+=1;
-		if(m_DisplayParam.zoom &gt; m_DisplayParam.prespective_z/10.0)
-			m_DisplayParam.zoom = m_DisplayParam.prespective_z/10.0;
-	}
-
-	if(m_DrawAndControl)
-		m_DrawAndControl-&gt;OnLeftClick(x,y);
-
-}
-
-void MainWindowWrapper::KeyboardExitCommand(unsigned char key, int x, int y)
-{
-	switch (key)
-	{
-	case 27:
-		exit(0);
-		break;
-	}
-}
-
-void MainWindowWrapper::KeyboardCommand(unsigned char key, int x, int y)
-{
-	//cout &lt;&lt; "Char : " &lt;&lt; key &lt;&lt;  endl;
-	switch (key)
-	{
-	case 27:
-		exit(0);
-		break;
-	case 'e':
-	{
-			m_DisplayParam.bDisplayMode = DISPLAY_FREE;
-			m_DisplayParam.translateX = 0;
-			m_DisplayParam.translateY = 0;
-	}
-		break;
-	case 'c':
-	{
-			m_DisplayParam.bDisplayMode = DISPLAY_FOLLOW;
-	}
-		break;
-	case 't':
-	{
-			m_DisplayParam.bDisplayMode = DISPLAY_TOP_FREE;
-	}
-		break;
-	case 'f':
-	{
-		if(m_DisplayParam.bFullScreen)
-		{
-			glutSetWindow(m_MainWindow);
-			glutFullScreenToggle();
-			m_DisplayParam.bFullScreen = false;
-		}
-		else
-		{
-			m_DisplayParam.bFullScreen = true;
-		}
-	}
-		break;
-	case 'r':
-	{
-		if(m_DrawAndControl)
-			m_DrawAndControl-&gt;Reset();
-	}
-	break;
-	case 'p':
-	{
-		if(m_DisplayParam.bSelectPosition == 1)
-		{
-			m_DisplayParam.bSelectPosition = 0;
-		}
-		else
-		{
-			m_DisplayParam.bSelectPosition = 1;
-		}
-
-	}
-	break;
-	case 'o':
-	{
-		if(m_DisplayParam.bSelectPosition == 2)
-		{
-			m_DisplayParam.bSelectPosition = 0;
-		}
-		else
-		{
-			m_DisplayParam.bSelectPosition = 2;
-		}
-	}
-	break;
-	case 'u':
-	{
-		if(m_DisplayParam.bSelectPosition == 3)
-		{
-			m_DisplayParam.bSelectPosition = 0;
-		}
-		else
-		{
-			m_DisplayParam.bSelectPosition = 3;
-		}
-	}
-	break;
-	}
-
-	if(m_DrawAndControl)
-		m_DrawAndControl-&gt;OnKeyboardPress(CHAR_KEY, key);
-}
-
-void MainWindowWrapper::KeyboardSpecialCommand(int key, int x, int y)
-{
-	//cout &lt;&lt; "Control : " &lt;&lt; key &lt;&lt; endl;
-	switch (key)
-	{
-	case 101: // Up
-	{
-//		double prevAngle = angle;
-//		angle += rand()%5;
-//		//double a = circ_angle-&gt;CalcAngle(3.0*DEG2RAD);
-//		angle = UtilityH::GetCircularAngle(prevAngle*DEG2RAD, angle*DEG2RAD) * RAD2DEG;
-//		cout &lt;&lt; endl &lt;&lt; "angle = " &lt;&lt; angle &lt;&lt; endl;
-	}
-	break;
-	case 103: //Down
-	{
-//		double prevAngle = angle;
-//		angle -= rand()%5;
-//		//double a = circ_angle-&gt;CalcAngle(357.0*DEG2RAD);
-//		angle = UtilityH::GetCircularAngle(prevAngle*DEG2RAD, angle*DEG2RAD) * RAD2DEG;
-//		cout &lt;&lt; "angle = " &lt;&lt; angle &lt;&lt; endl;
-	}
-	break;
-	case 102: //Right
-	{
-
-	}
-	break;
-	case 100: //Left
-	{
-
-	}
-	break;
-	case 112: //left shift key
-	{
-
-	}
-	break;
-	case 114: //left Ctrl key
-	{
-
-	}
-	break;
-	case 113: //Right shift key
-	{
-
-	}
-	break;
-	case 115: // right Ctrl key
-	{
-
-	}
-	break;
-	case 116: //ALT key
-	{
-
-	}
-	break;
-	default:
-		//m_RandomObstacle =0;
-		break;
-	}
-}
-
-void MainWindowWrapper::MenuCommand(int value)
-{
-	KeyboardCommand(value, 0,0);
-}
-
-void MainWindowWrapper::ProcessMenuStatus(int status, int x, int y)
-{
-	if (status != GLUT_MENU_IN_USE)
-	{
-		ModifyPopupMenu();
-	}
-}
-
-void MainWindowWrapper::ModifyPopupMenu()
-{
-//	glutSetMenu(m_PopupMenu);
-//
-//	if(m_DisplayParam.bDisplayMode == DISPLAY_FOLLOW)
-//		glutChangeToMenuEntry(5, "&gt; Follow CAM(c)", 1004);
-//	else if(m_DisplayParam.bDisplayMode == DISPLAY_TOP_FREE)
-//		glutChangeToMenuEntry(6, "&gt; Top CAM   (t)", 1005);
-//	else if(m_DisplayParam.bDisplayMode == DISPLAY_FREE)
-//		glutChangeToMenuEntry(7, "&gt; Free CAM  (e)", 1006);
-
-//	if(m_DisplayParam.bFullScreen)
-//	{
-//		glutChangeToMenuEntry(8, "Hide V Window", 'h');
-//	}
-}
-
-void MainWindowWrapper::CreateRightClickMenu()
-{
-	if(m_PopupMenu==0)
-		m_PopupMenu = glutCreateMenu(MenuCommand);
-	else
-		glutSetMenu(m_PopupMenu);
-
-	glutAddMenuEntry("Start/Stop  (s)", 's');
-	glutAddMenuEntry("Restart     (r)", 'r');
-
-	glutAddMenuEntry("------------", 0);
-
-	glutAddMenuEntry("Full Screen (f)", 'f');
-	glutAddMenuEntry("Follow CAM  (c)", 'c');
-	glutAddMenuEntry("Top CAM     (t)", 't');
-	glutAddMenuEntry("Free CAM    (e)", 'e');
-
-	glutAddMenuEntry("------------", 0);
-
-	glutAddMenuEntry("Start Pose  (p)", 0);
-	glutAddMenuEntry("End   Pose  (o)", 0);
-	glutAddMenuEntry("Add Sim Car (u)", 0);
-	glutAddMenuEntry("Delete Sim Cars (n)", 0);
-	glutAddMenuEntry("Save Sim Points(v)", 0);
-	glutAddMenuEntry("Load Sim Points(l)", 0);
-
-	glutAddMenuEntry("------------", 0);
-
-	glutAddMenuEntry("Exit        (Esc)", 27);
-
-	glutAttachMenu(GLUT_RIGHT_BUTTON);
-	//glutMenuStatusFunc(ProcessMenuStatus);
-}
-
-
-
-} /* namespace Graphics */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\PlannerTestDraw.cpp" new_path="" added_lines="0" deleted_lines="1874">
				<diff>@@ -1,1874 +0,0 @@
-/*
- * PlannerTestDraw.cpp
- *
- *  Created on: Jun 17, 2016
- *      Author: hatem
- */
-
-#include "op_simu/PlannerTestDraw.h"
-#include "op_planner/PlannerH.h"
-#include "op_planner/PlanningHelpers.h"
-#include "op_planner/MappingHelpers.h"
-#include &lt;sstream&gt;
-#include "op_planner/MatrixOperations.h"
-#include "op_simu/SimpleTracker.h"
-#include "op_utility/DataRW.h"
-#include "op_planner/PlannerCommonDef.h"
-//#include &lt;plib/js.h&gt;
-
-
-using namespace std;
-using namespace SimulationNS;
-using namespace UtilityHNS;
-
-#define VectorMap "/media/hatem/8ac0c5d5-8793-4b98-8728-55f8d67ec0f4/data/ToyotaCity2/map/vector_map/"
-//#define kmlMap	"tsukuba_multy_2_11.kml"
-
-#define kmlMapPath	"/media/user/8ac0c5d5-8793-4b98-8728-55f8d67ec0f4/data/ToyotaCity2/map/kml/ToyotaCityCustomInfo.kml"
-
-#define kmlTemplateFile "PlannerX_MapTemplate.kml"
-#define kmltargetFile "ToyotaKML.kml"
-#define PreDefinedPath  "11,333,1090,1704,147, 1791,801, 431, 1522, 372, 791, 1875, 1872,171,108,21,"
-
-namespace Graphics
-{
-
-#define EnableThreadBody
-
-PlannerTestDraw::PlannerTestDraw()
-{
-	planning_mutex =  PTHREAD_MUTEX_INITIALIZER;
-	control_mutex = PTHREAD_MUTEX_INITIALIZER;
-	simulation_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-	m_LateralError = 0;
-	m_pVelocityGraph = 0;
-	planning_thread_tid = 0;
-	control_thread_tid = 0;
-	game_wheel_thread_tid = 0;
-	simulation_thread_tid = 0;
-	m_bCancelThread = false;
-	m_PlanningCycleTime = 0.01;
-	m_ControlCycleTime  = 0.01;
-	m_SimulationCycleTime = 0.02;
-	m_bResetForSimulation = false;
-	m_GlobalPlanningTime = 0;
-	m_LocalPlanningTime = 0;
-	m_ControllingTime = 0;
-	m_ObjectTrakingTime = 0;
-	m_SimulationTime = 0;
-	m_iCurrentGoal = 0;
-	m_CarModel = 0;
-	m_iStepNumber = 0;
-
-
-	std::vector&lt;PlannerHNS::TrafficLight&gt; trafficLights;
-	std::vector&lt;PlannerHNS::GPSPoint&gt; stopLines;
-	PlannerHNS::RoadNetwork roadMap;
-
-//	PlannerHNS::MappingHelpers::CreateKmlFromLocalizationPathFile("/home/user/Downloads/path1016_3.csv", 105, 1.5, trafficLights, stopLines);
-
-	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(VectorMap, m_RoadMap);
-//	string kml_templateFilePath = UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName + UtilityHNS::DataRW::KmlMapsFolderName+"PlannerX_MapTemplate.kml";
-//	PlannerHNS::MappingHelpers::WriteKML("/home/user/data/Moriyama2/map/kml/Moriyama_Test.kml",kml_templateFilePath , roadMap);
-
-	//string kml_templateFilePath = UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmlTemplateFile;
-	//string kml_fileToSave =UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+ "ToyotaCityCustomInfo.kml";
-	//PlannerHNS::MappingHelpers::WriteKML(kml_fileToSave, kml_templateFilePath, m_RoadMap);
-
-	//PlannerHNS::MappingHelpers::LoadKML(kmlMapPath, m_RoadMap);
-
-	//stop line : 554.318849669619908,183.992441420792119,31.8523999999999994
-	//Traffic Light : 552.116878887182907,187.472750477604876,27.5702239999999996
-	//Stop Line : 552.116878887182907,187.472750477604876,27.5702239999999996
-	//TGraffic Light: 549.620514013766524,153.862837466717821,29.4425120000000007
-
-	/**
-	 * Writing the kml file for the RoadNetwork Map
-	 */
-//	ostringstream fileName;
-//	fileName &lt;&lt; UtilityH::GetFilePrefixHourMinuteSeconds();
-//	fileName &lt;&lt; "_RoadNetwork.kml";
-//	PlannerHNS::MappingHelpers::WriteKML(fileName.str(),UtilityH::GetHomeDirectory()+
-//			DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmlTemplateFile, m_RoadMap);
-//
-//	PlannerHNS::StopLine st1, st2, st3, st4,st5,st6,st7;
-//	st1.id = 1;
-//	st1.stopSignID = 1;
-//	st1.trafficLightID = -1;
-//	st1.points.push_back(PlannerHNS::GPSPoint(102,-27.9,1.59,0));
-//	st1.points.push_back(PlannerHNS::GPSPoint(105,-25.9,1.59,0));
-//	PlannerHNS::WayPoint wp;
-//	wp.pos = PlannerHNS::GPSPoint(102,-27.9,1.59,0);
-//	st1.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap, 30);
-//	if(st1.pLane)
-//		st1.laneId = st1.pLane-&gt;id;
-//
-//	st2.id = 2;
-//	st2.stopSignID = -1;
-//	st2.trafficLightID = 1;
-//	st2.points.push_back(PlannerHNS::GPSPoint(172,2.06,6,0));
-//	st2.points.push_back(PlannerHNS::GPSPoint(174,-2.97,6,0));
-//	wp.pos = PlannerHNS::GPSPoint(172,2.06,6,0);
-//	st2.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap);
-//	if(st2.pLane)
-//		st2.laneId = st2.pLane-&gt;id;
-//
-//	st3.id = 3;
-//	st3.stopSignID = -1;
-//	st3.trafficLightID = 2;
-//	st3.points.push_back(PlannerHNS::GPSPoint(257,46.7,20.5,0));
-//	st3.points.push_back(PlannerHNS::GPSPoint(260,40,20.5,0));
-//	wp.pos = PlannerHNS::GPSPoint(257,46.7,20.5,0);
-//	st3.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap);
-//	if(st3.pLane)
-//		st3.laneId = st3.pLane-&gt;id;
-//
-//	st4.id = 4;
-//	st4.stopSignID = 2;
-//	st4.trafficLightID = -1;
-//	st4.points.push_back(PlannerHNS::GPSPoint(311,69.3,34.4,0));
-//	st4.points.push_back(PlannerHNS::GPSPoint(313,67,34.4,0));
-//	wp.pos = PlannerHNS::GPSPoint(311,69.3,34.4,0);
-//	st4.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap);
-//	if(st4.pLane)
-//		st4.laneId = st4.pLane-&gt;id;
-//
-//	st5.id = 5;
-//	st5.stopSignID = 3;
-//	st5.trafficLightID = -1;
-//	st5.points.push_back(PlannerHNS::GPSPoint(250,31,18,0));
-//	st5.points.push_back(PlannerHNS::GPSPoint(247,35,18,0));
-//	wp.pos = PlannerHNS::GPSPoint(250,31,18,0);
-//	st5.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap);
-//	if(st5.pLane)
-//		st5.laneId = st5.pLane-&gt;id;
-//
-//	st6.id = 6;
-//	st6.stopSignID = -1;
-//	st6.trafficLightID = 3;
-//	st6.points.push_back(PlannerHNS::GPSPoint(127,-24.5,3,0));
-//	st6.points.push_back(PlannerHNS::GPSPoint(125,-21.5,3,0));
-//	wp.pos = PlannerHNS::GPSPoint(127,-24.5,3,0);
-//	st6.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap);
-//	if(st6.pLane)
-//		st6.laneId = st6.pLane-&gt;id;
-//
-//	st7.id = 7;
-//	st7.stopSignID = -1;
-//	st7.trafficLightID = 4;
-//	st7.points.push_back(PlannerHNS::GPSPoint(89.8,47.8,-2.0,0));
-//	st7.points.push_back(PlannerHNS::GPSPoint(91.7,49.1,-2.0,0));
-//	wp.pos = PlannerHNS::GPSPoint(89.8,47.8,-2.0,0);
-//	st7.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap);
-//	if(st7.pLane)
-//		st7.laneId = st7.pLane-&gt;id;
-//
-//
-//	PlannerHNS::TrafficLight t1, t2, t3, t4;
-//	t1.id = 1;
-//	t1.laneIds.push_back(st2.laneId);
-//	t1.pLanes.push_back(st2.pLane);
-//	t1.pos = PlannerHNS::GPSPoint(189,14.1,8.9,0);
-//
-//	t2.id = 2;
-//	t2.laneIds.push_back(st3.laneId);
-//	t2.pLanes.push_back(st3.pLane);
-//	t2.pos = PlannerHNS::GPSPoint(268,50.8,21.9,0);
-//
-//	t3.id = 3;
-//	t3.laneIds.push_back(st6.laneId);
-//	t3.pLanes.push_back(st6.pLane);
-//	t3.pos = PlannerHNS::GPSPoint(122,-29.6,-7.0,0);
-//
-//	t4.id = 4;
-//	t4.laneIds.push_back(st7.laneId);
-//	t4.pLanes.push_back(st7.pLane);
-//	t4.pos = PlannerHNS::GPSPoint(88,56.7,-1.5,0);
-//
-//
-//	m_RoadMap.trafficLights.push_back(t1);
-//	m_RoadMap.trafficLights.push_back(t2);
-//	m_RoadMap.trafficLights.push_back(t3);
-//	m_RoadMap.trafficLights.push_back(t4);
-//
-//	m_RoadMap.stopLines.push_back(st1);
-//	m_RoadMap.stopLines.push_back(st2);
-//	m_RoadMap.stopLines.push_back(st3);
-//	m_RoadMap.stopLines.push_back(st4);
-//	m_RoadMap.stopLines.push_back(st5);
-//	m_RoadMap.stopLines.push_back(st6);
-//	m_RoadMap.stopLines.push_back(st7);
-
-
-//	PlannerHNS::StopLine st_tsu_1, st_tsu2;
-//	st_tsu_1.id = 1;
-//	st_tsu_1.stopSignID = -1;
-//	st_tsu_1.trafficLightID = 1;
-//	st_tsu_1.points.push_back(PlannerHNS::GPSPoint(555.0,178.1,31.8,0));
-//	st_tsu_1.points.push_back(PlannerHNS::GPSPoint(556.3,179.9,31.8,0));
-//	PlannerHNS::WayPoint wp;
-//	wp.pos = PlannerHNS::GPSPoint(555.0,178.1,31.8,0);
-//	st_tsu_1.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap, 30);
-//	if(st_tsu_1.pLane)
-//		st_tsu_1.laneId = st_tsu_1.pLane-&gt;id;
-//
-//	st_tsu2.id = 2;
-//	st_tsu2.stopSignID = -1;
-//	st_tsu2.trafficLightID = 2;
-//	st_tsu2.points.push_back(PlannerHNS::GPSPoint(551.2,197.6,26.6,0));
-//	st_tsu2.points.push_back(PlannerHNS::GPSPoint(550.6,196.2,26.6,0));
-//	wp.pos = PlannerHNS::GPSPoint(551.2,197.6,26.6,0);
-//	st_tsu2.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap);
-//	if(st_tsu2.pLane)
-//		st_tsu2.laneId = st_tsu2.pLane-&gt;id;
-//
-//	PlannerHNS::TrafficLight t1, t2, t3, t4;
-//	t1.id = 1;
-//	t1.laneIds.push_back(st_tsu_1.laneId);
-//	t1.pLanes.push_back(st_tsu_1.pLane);
-//	t1.pos = PlannerHNS::GPSPoint(553.5,214.6,26.6,0);
-//
-//	t2.id = 2;
-//	t2.laneIds.push_back(st_tsu2.laneId);
-//	t2.pLanes.push_back(st_tsu2.pLane);
-//	t2.pos = PlannerHNS::GPSPoint(554.4,168.2,29.3,0);
-//	m_RoadMap.trafficLights.push_back(t1);
-//	m_RoadMap.trafficLights.push_back(t2);
-//
-//	m_RoadMap.stopLines.push_back(st_tsu_1);
-//	m_RoadMap.stopLines.push_back(st_tsu2);
-//
-//	string kml_templateFilePath = UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmlTemplateFile;
-//	string kml_fileToSave =UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+ "TsukubaMapWithStopLines.kml";
-//	PlannerHNS::MappingHelpers::WriteKML(kml_fileToSave, kml_templateFilePath, m_RoadMap);
-
-
-	m_CarInfo.width = 2.0;
-	m_CarInfo.length = 4.2;
-	m_CarInfo.wheel_base = 2.5;
-	m_CarInfo.turning_radius = 5.2;
-	m_CarInfo.max_steer_angle = 0.5;
-
-	// 6 -&gt; 8.3, 5 -&gt; 6.8 , 4 -&gt; 5.4 , 3 -&gt; 3.9, 2 -&gt; 2.6
-	//1.3, 1.3, 1.35, 1.36, 1.38
-
-	m_CarInfo.max_speed_forward = 3.0;
-
-	m_CarInfo.min_speed_forward = 0.2;
-	m_ControlParams.SteeringDelay = 1.2;
-	m_ControlParams.minPursuiteDistance = 3.0;
-	m_ControlParams.Steering_Gain = PlannerHNS::PID_CONST(0.07, 0.02, 0.001);
-	m_ControlParams.maxAccel = 0.6;
-	m_ControlParams.maxDecel = -1.0;
-
-	m_PlanningParams.maxSpeed = 3.0;
-
-	m_PlanningParams.minSpeed = 0.2;
-	m_PlanningParams.microPlanDistance = 50;
-
-	m_LocalPlanner.m_SimulationSteeringDelayFactor = m_ControlParams.SimulationSteeringDelay = 0;
-	m_PlanningParams.smoothingDataWeight = 0.45;
-	m_PlanningParams.smoothingSmoothWeight = 0.35;
-	m_PlanningParams.smoothingToleranceError = 0.01;
-	//m_PlanningParams.carTipMargin = 3.0;
-	//m_PlanningParams.rollInMargin = 12.0;
-	//m_PlanningParams.rollInSpeedFactor = 0.25;
-	m_PlanningParams.pathDensity = 0.5;
-	m_PlanningParams.rollOutDensity = 0.25;
-	m_PlanningParams.rollOutNumber = 8;
-	m_PlanningParams.horizonDistance = 200;
-	m_PlanningParams.minFollowingDistance = 8.0;
-	m_PlanningParams.minDistanceToAvoid = 16.0;
-	m_PlanningParams.maxDistanceToAvoid = 6.0;
-	m_PlanningParams.speedProfileFactor = 2.0;
-	m_PlanningParams.horizonDistance = 0.2;
-	m_PlanningParams.verticalSafetyDistance = 0.4;
-
-	m_PlanningParams.enableSwerving = true;
-	m_PlanningParams.enableFollowing = true;
-	m_PlanningParams.enableTrafficLightBehavior = true;
-	m_PlanningParams.enableStopSignBehavior = true;
-	m_PlanningParams.enableLaneChange = false;
-
-	m_LocalPlanner.Init(m_ControlParams, m_PlanningParams, m_CarInfo);
-	m_LocalPlanner.InitPolygons();
-
-	m_start =  PlannerHNS::MappingHelpers::GetFirstWaypoint(m_RoadMap);
-	m_followX = m_start.pos.x;
-	m_followY = m_start.pos.y;
-	m_followZ = m_start.pos.z;
-	m_followA = m_start.pos.a;
-
-	m_bMakeNewPlan = false;
-
-	double axes_color[3] = {0.1, 0.1, 0.8};
-	double graph_color[3] = {0.9, 0.2, 0.1};
-	m_pVelocityGraph = new Graph2dBase(20, 200,1000, 12, 0, "Car Velocity", "T s", "V km/h", axes_color, graph_color );
-	m_pSteeringGraph = new Graph2dBase(20, 200,1000, m_CarInfo.max_steer_angle*RAD2DEG, -m_CarInfo.max_steer_angle*RAD2DEG, "Car Steering", "T s", "A deg", axes_color, graph_color );
-	m_pLateralErrGraph  = new Graph2dBase(20, 200,1000, 1.0, -1.0, "Lateral Error", "T s", "D meter", axes_color, graph_color );
-
-	pthread_create(&amp;planning_thread_tid, NULL, &amp;PlannerTestDraw::PlanningThreadStaticEntryPoint, this);
-	//pthread_create(&amp;control_thread_tid, NULL, &amp;PlannerTestDraw::ControlThreadStaticEntryPoint, this);
-	//pthread_create(&amp;game_wheel_thread_tid, NULL, &amp;PlannerTestDraw::GameWheelThreadStaticEntryPoint, this);
-	//pthread_create(&amp;simulation_thread_tid, NULL, &amp;PlannerTestDraw::SimulationThreadStaticEntryPoint, this);
-	//InitStartAndGoal(2, -50, M_PI, 100, 100, M_PI_2);
-
-	PrepareVectorMapForDrawing();
-
-
-}
-
-void PlannerTestDraw::InitStartAndGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2)
-{
-	m_start = PlannerHNS::WayPoint(x1, y1, 0, a1);
-	//m_start = PlannerHNS::MappingHelpers::GetFirstWaypoint(m_RoadMap);
-	PlannerHNS::WayPoint* pWS = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(m_start, m_RoadMap);
-	if(pWS)
-		m_start = *pWS;
-	else
-		cout &lt;&lt; "#Planning Error: Start Position is too far from the road network map!" &lt;&lt; endl;
-
-	m_start.pos.z = 0;
-	m_start.bDir = PlannerHNS::FORWARD_DIR;
-
-	m_LocalPlanner.FirstLocalizeMe(m_start);
-
-	/**
-	 * Planning using goad point
-	 */
-
-
-	PlannerHNS::WayPoint gp(x2, y2, 0, a2);
-	PlannerHNS::WayPoint* pW = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(gp, m_RoadMap);
-	if(pW)
-	{
-		pW-&gt;bDir = PlannerHNS::FORWARD_DIR;
-		m_goals.push_back(*pW);
-	}
-	else
-		cout &lt;&lt; "#Planning Error: Goal Position is too far from the road network map!" &lt;&lt; endl;
-
-	//try fixed goal positions :
-
-//	PlannerHNS::WayPoint g1(557.1, 177.43, 0, 0);
-//	PlannerHNS::WayPoint g2(553.03, 195.59, 0, 0);
-//	PlannerHNS::WayPoint g3(-57.23, 60.67, 0, 0);
-//
-//	PlannerHNS::WayPoint* pW = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(g1, m_RoadMap);
-//	if(pW)
-//	{
-//		//pW-&gt;pos = g1.pos;
-//		pW-&gt;bDir = PlannerHNS::FORWARD_DIR;
-//		m_goals.push_back(*pW);
-//	}
-//	else
-//		cout &lt;&lt; "#Planning Error: Goal Position is too far from the road network map!" &lt;&lt; endl;
-//
-//	 pW = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(g2, m_RoadMap);
-//	if(pW)
-//	{
-//		pW-&gt;bDir = PlannerHNS::FORWARD_DIR;
-//		//pW-&gt;pos = g2.pos;
-//		m_goals.push_back(*pW);
-//	}
-//	else
-//		cout &lt;&lt; "#Planning Error: Goal Position is too far from the road network map!" &lt;&lt; endl;
-//
-//	pW = PlannerHNS::MappingHelpers::GetLastWaypoint(m_RoadMap);
-//	if(pW)
-//	{
-//		//pW-&gt;pos = g3.pos;
-//		pW-&gt;bDir = PlannerHNS::FORWARD_DIR;
-//		m_goals.push_back(*pW);
-//	}
-//	else
-//		cout &lt;&lt; "#Planning Error: Goal Position is too far from the road network map!" &lt;&lt; endl;
-
-
-	m_bMakeNewPlan = true;
-
-}
-
-void PlannerTestDraw::SaveSimulationData()
-{
-	std::vector&lt;std::string&gt; simulationDataPoints;
-	std::ostringstream startStr;
-	startStr &lt;&lt; m_start.pos.x &lt;&lt; "," &lt;&lt; m_start.pos.y &lt;&lt; "," &lt;&lt; m_start.pos.z &lt;&lt; ","
-			&lt;&lt; m_start.pos.a &lt;&lt; "," &lt;&lt; m_start.cost &lt;&lt; "," &lt;&lt; m_start.v &lt;&lt; "," ;
-	simulationDataPoints.push_back(startStr.str());
-
-	std::ostringstream goalStr;
-	if(m_goals.size()&gt;0)
-		goalStr &lt;&lt; m_goals.at(0).pos.x &lt;&lt; "," &lt;&lt; m_goals.at(0).pos.y &lt;&lt; "," &lt;&lt; m_goals.at(0).pos.z &lt;&lt; ","
-				&lt;&lt; m_goals.at(0).pos.a &lt;&lt; "," &lt;&lt; m_goals.at(0).cost &lt;&lt; "," &lt;&lt; m_goals.at(0).v &lt;&lt; "," ;
-	simulationDataPoints.push_back(goalStr.str());
-
-	for(unsigned int i = 0; i &lt; m_SimulatedCars.size(); i++)
-	{
-		std::ostringstream carStr;
-		carStr &lt;&lt; m_SimulatedCars.at(i).state.pos.x &lt;&lt; ","
-				&lt;&lt; m_SimulatedCars.at(i).state.pos.y &lt;&lt; ","
-				&lt;&lt; m_SimulatedCars.at(i).state.pos.z &lt;&lt; ","
-				&lt;&lt; m_SimulatedCars.at(i).state.pos.a &lt;&lt; ","
-				&lt;&lt; m_SimulatedCars.at(i).state.cost &lt;&lt; ","
-				&lt;&lt; m_SimulatedCars.at(i).m_CarInfo.max_speed_forward &lt;&lt; "," ;
-		simulationDataPoints.push_back(carStr.str());
-	}
-
-	DataRW::WriteLogData(UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName+DataRW::SimulationFolderName, "SimulationFile",
-				"X,Y,Z,A,C,V,",	simulationDataPoints);
-}
-
-void PlannerTestDraw::LoadSimulationData()
-{
-	m_bCancelThread = true;
-	PlannerTestDraw* pRet = 0;
-	if(planning_thread_tid&gt;0)
-		pthread_join(planning_thread_tid, (void**)&amp;pRet);
-	if(control_thread_tid&gt;0)
-		pthread_join(control_thread_tid, (void**)&amp;pRet);
-	if(simulation_thread_tid&gt;0)
-		pthread_join(simulation_thread_tid, (void**)&amp;pRet);
-
-	m_LocalPlanner = PlannerHNS::LocalPlannerH();
-
-	m_LocalPlanner.m_SimulationSteeringDelayFactor = m_ControlParams.SimulationSteeringDelay;
-	m_LocalPlanner.Init(m_ControlParams, m_PlanningParams, m_CarInfo);
-	m_LocalPlanner.InitPolygons();
-	m_ActualPath.clear();
-
-	string simuDataFileName = UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName+DataRW::SimulationFolderName + "s1.csv";
-	SimulationFileReader sfr(simuDataFileName);
-	SimulationFileReader::SimulationData data;
-
-	sfr.ReadAllData(data);
-	InitStartAndGoal(data.startPoint.x, data.startPoint.y, data.startPoint.a,
-			data.goalPoint.x, data.goalPoint.y, data.goalPoint.a);
-
-	for(unsigned  int i=0; i &lt; data.simuCars.size(); i++)
-	{
-		AddSimulatedCar(data.simuCars.at(i).x, data.simuCars.at(i).y,
-				data.simuCars.at(i).a, (6.0 + rand()%6)/3.6);
-	}
-
-	//m_bResetForSimulation = true;
-
-	m_bCancelThread = false;
-	pthread_create(&amp;planning_thread_tid, NULL, &amp;PlannerTestDraw::PlanningThreadStaticEntryPoint, this);
-	pthread_create(&amp;control_thread_tid, NULL, &amp;PlannerTestDraw::ControlThreadStaticEntryPoint, this);
-	pthread_create(&amp;simulation_thread_tid, NULL, &amp;PlannerTestDraw::SimulationThreadStaticEntryPoint, this);
-}
-
-void PlannerTestDraw::LoadMaterials()
-{
-	if(!m_CarModel)
-		m_CarModel = DrawingHelpers::LoadModel("libs/data/porsche.obj");
-}
-
-PlannerTestDraw::~PlannerTestDraw()
-{
-	m_bCancelThread = true;
-	PlannerTestDraw* pRet = 0;
-	if(planning_thread_tid&gt;0)
-		pthread_join(planning_thread_tid, (void**)&amp;pRet);
-	if(control_thread_tid&gt;0)
-		pthread_join(control_thread_tid, (void**)&amp;pRet);
-	if(simulation_thread_tid&gt;0)
-		pthread_join(simulation_thread_tid, (void**)&amp;pRet);
-
-	if(game_wheel_thread_tid&gt;0)
-		pthread_join(game_wheel_thread_tid, (void**)&amp;pRet);
-
-}
-
-bool PlannerTestDraw::IsInitState()
-{
-	if(m_LocalPlanner.m_TotalPath.size() &gt; 0)
-		return false;
-	else
-		return true;
-}
-
-void PlannerTestDraw::UpdatePlaneStartGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2)
-{
-	InitStartAndGoal(x1, y1, a1, x2, y2, a2);
-}
-
-void PlannerTestDraw::DetectSimulatedObstacles(std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
-{
-	obj_list.clear();
-	for(unsigned int i =0; i &lt; m_SimulatedCars.size(); i++)
-	{
-		PlannerHNS::DetectedObject ob;
-		ob.id = 0;
-		ob.l = m_SimulatedCars.at(i).m_CarInfo.length;
-		ob.w = m_SimulatedCars.at(i).m_CarInfo.width;
-		ob.center.pos = m_SimulatedCars.at(i).state.pos;
-		ob.center.v = m_SimulatedCars.at(i).state.v;
-		ob.contour = m_SimulatedCars.at(i).m_CarShapePolygon;
-		ob.center.pLane = m_SimulatedCars.at(i).state.pLane;
-		obj_list.push_back(ob);
-	}
-}
-
-void PlannerTestDraw::AddSimulatedCarPos(const double&amp; x,const double&amp; y, const double&amp; a)
-{
-	double v  = 4.0;//(6.0 + rand()%6)/3.6;
-	AddSimulatedCar(x,y,a,v);
-}
-
-void PlannerTestDraw::AddSimulatedCar(const double&amp; x,const double&amp; y, const double&amp; a, const double&amp; v)
-{
-	SimulatedCarState car;
-	PlannerHNS::CAR_BASIC_INFO carInfo;
-	PlannerHNS::ControllerParams params;
-
-
-	carInfo.width  = 1.8;
-	carInfo.length = 4.1;
-	carInfo.max_speed_forward = v;
-	carInfo.max_steer_angle = 0.42;
-	carInfo.min_steer_angle = -0.42;
-	carInfo.turning_radius = 4.0;
-	carInfo.wheel_base = 2.0;
-
-	params.Steering_Gain = PlannerHNS::PID_CONST(1.5, 0.0, 0.0);
-	params.Velocity_Gain = PlannerHNS::PID_CONST(0.2, 0.05, 0.1);
-	params.minPursuiteDistance = 3.0;
-
-
-	car.Init(carInfo);
-	car.InitPolygons();
-	car.state.pos = PlannerHNS::GPSPoint(x,y,0,a);
-
-	PlannerHNS::WayPoint* pWS = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(car.state, m_RoadMap);
-	if(pWS)
-	{
-		car.pLane = pWS-&gt;pLane;
-	}
-	else
-		cout &lt;&lt; "#Planning Error: Start Position is too far from the road network map!" &lt;&lt; endl;
-
-
-	car.state.bDir = PlannerHNS::FORWARD_DIR;
-	car.FirstLocalizeMe(car.state);
-
-	pthread_mutex_lock(&amp;simulation_mutex);
-	m_SimulatedCars.push_back(car);
-	m_SimulatedBehaviors.push_back(PlannerHNS::BehaviorState());
-	m_SimulatedVehicleState.push_back(PlannerHNS::VehicleState());
-	m_SimulatedPrevTrajectory.push_back(vector&lt;PlannerHNS::WayPoint&gt;());
-	SimulatedTrajectoryFollower pf;
-	pf.Init(params, carInfo);
-	m_SimulatedPathFollower.push_back(pf);
-	pthread_mutex_unlock(&amp;simulation_mutex);
-}
-
-void PlannerTestDraw::Reset()
-{
-//	pthread_mutex_lock(&amp;planning_mutex);
-//	m_LocalPlanner.m_Path.clear();
-//	m_LocalPlanner.m_RollOuts.clear();
-//	pthread_mutex_unlock(&amp;planning_mutex);
-//
-//	m_followX = m_start.pos.x;
-//	m_followY = m_start.pos.y;
-//	m_followZ = m_start.pos.z;
-//	m_followA = m_start.pos.a;
-//
-//	m_bNewPath = false;
-//
-//	m_LocalPlanner.state = m_start;
-//
-//	pthread_mutex_lock(&amp;behaviors_mutex);
-//	m_CurrentBehavior.state = INITIAL_STATE ;
-//	pthread_mutex_unlock(&amp;behaviors_mutex);
-}
-
-void PlannerTestDraw::PrepareVectorMapForDrawing()
-{
-	double distance_to_nearest_lane = 1;
-	int j=0;
-	int max_number_of_lanes = 500;
-	double width_ratio = 2.0;
-
-	vector&lt;PlannerHNS::Lane*&gt; currLane;
-	vector&lt;PlannerHNS::Lane*&gt; lanes_list;
-	vector&lt;PlannerHNS::Lane*&gt; traversed_lanes;
-
-	while(distance_to_nearest_lane &lt; 100 &amp;&amp; currLane.size() == 0)
-	{
-		PlannerHNS::Lane* pL = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(m_start, m_RoadMap, distance_to_nearest_lane);
-		if(pL)
-			currLane.push_back(pL);
-		distance_to_nearest_lane += 2;
-	}
-
-	if(currLane.size()==0)
-	{
-		if(m_RoadMap.roadSegments.size() &gt; 0)
-			if(m_RoadMap.roadSegments.at(0).Lanes.size()&gt;0)
-				currLane.push_back(&amp;m_RoadMap.roadSegments.at(0).Lanes.at(0));
-	}
-
-	for(unsigned int i=0; i&lt; currLane.size(); i++)
-		lanes_list.push_back(currLane[i]);
-
-	m_ReadyToDrawLanes.clear();
-	m_ReadyToDrawCenterLines.clear();
-//	m_TrafficLights.clear();
-//	m_StopSigns.clear();
-//	m_OtherSigns.clear();
-
-	if(currLane.size() &gt; 0)
-	{
-		std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; ready_to_draw;
-
-		while(lanes_list.size()&gt;0 &amp;&amp; j &lt;max_number_of_lanes)
-		{
-			ready_to_draw.clear();
-			PlannerHNS::Lane* l = lanes_list.at(0);
-			lanes_list.erase(lanes_list.begin()+0);
-			traversed_lanes.push_back(l);
-
-
-			vector&lt;PlannerHNS::WayPoint&gt; path_local = l-&gt;points;
-
-			DrawingHelpers::PreparePathForDrawing(path_local,ready_to_draw, 2.8 / width_ratio);
-			m_ReadyToDrawLanes.push_back(ready_to_draw);
-
-			ready_to_draw.clear();
-			DrawingHelpers::PreparePathForDrawing(path_local,ready_to_draw, 0.1);
-			m_ReadyToDrawCenterLines.push_back(ready_to_draw);
-
-			j++;
-
-			PlannerHNS::MappingHelpers::GetUniqueNextLanes(l, traversed_lanes, lanes_list);
-
-			//Get the traffic lights pos
-//			for(unsigned int itl = 0; itl &lt; l-&gt;trafficLights.size(); itl++)
-//			{
-//
-//				Vector2D p(l-&gt;trafficLights[itl]-&gt;position.x, l-&gt;trafficLights[itl]-&gt;position.y, l-&gt;trafficLights[itl]-&gt;position.z,0);
-//				int iNextIndex = MappingHelpers::GetClosestNextPointIndex(path_local, p);
-//				if(iNextIndex &gt; 0)
-//					p.a = MathUtil::AngleBetweenVectorsPositive(path_local.at(iNextIndex), path_local.at(iNextIndex-1));
-//				else
-//					p.a = MathUtil::AngleBetweenVectorsPositive(path_local.at(iNextIndex+1), path_local.at(iNextIndex));
-//
-//				m_TrafficLights.push_back(p);
-//			}
-//
-//			for(unsigned int itl = 0; itl &lt; l-&gt;roadSigns.size(); itl++)
-//			{
-//				Vector2D p(l-&gt;roadSigns[itl]-&gt;position.x, l-&gt;roadSigns[itl]-&gt;position.y, l-&gt;roadSigns[itl]-&gt;position.z,0);
-//				int iNextIndex = MappingHelpers::GetClosestNextPointIndex(path_local, p);
-//				if(iNextIndex &gt; 0)
-//					p.a = MathUtil::AngleBetweenVectorsPositive(path_local.at(iNextIndex), path_local.at(iNextIndex-1));
-//				else
-//					p.a = MathUtil::AngleBetweenVectorsPositive(path_local.at(iNextIndex+1), path_local.at(iNextIndex));
-//
-//				if(l-&gt;roadSigns[itl]-&gt;signtype == STOP_SIGN)
-//					m_StopSigns.push_back(p);
-//				else if(l-&gt;roadSigns[itl]-&gt;signtype == STOP_LINE)
-//				{
-//					vector&lt;Vector2D&gt; path_temp;
-//					for(unsigned int k=0; k&lt; l-&gt;roadSigns[itl]-&gt;points.size(); k++)
-//					{
-//						path_temp.push_back(Vector2D(l-&gt;roadSigns[itl]-&gt;points.at(k).x, l-&gt;roadSigns[itl]-&gt;points.at(k).y, l-&gt;roadSigns[itl]-&gt;points.at(k).z,p.a));
-//					}
-//					m_StopLines.push_back(path_temp);
-//				}
-//				else
-//					m_OtherSigns.push_back(p);
-//			}
-		}
-	}
-}
-
-void PlannerTestDraw::DrawVectorMap()
-{
-	glDisable(GL_LIGHTING);
-	float PathColor[3];
-	float Color1[3]; Color1[0] = 1.0; Color1[1] = 204.0/256.0; Color1[2] = 51.0/256.0;
-	float Color2[3]; Color2[0] = 1.0; Color2[1] = 102.0/256.0; Color2[2] = 51.0/256.0;
-	float Color3[3]; Color3[0] = 1.0; Color3[1] = 51.0/256.0;  Color3[2] = 102.0/256.0;
-	float Color4[3]; Color4[0] = 204.0/256.0; Color4[1] = 51.0/256.0; Color4[2] = 1.0;
-
-	const float mapdata_z = 0.005;
-
-	for(unsigned int i=0; i&lt;m_ReadyToDrawLanes.size(); i++)
-	{
-		//PathColor[0]=0.5;PathColor[1] = j/20.0; PathColor[2] = j;
-		if(i==0)
-		{
-			PathColor[0]=0.25 ;PathColor[1] = 0.25; PathColor[2] = 0.25;
-		}
-		else
-		{
-			double inc_color = (double)i/25.0;
-			PathColor[0]=0.25 + inc_color; ;PathColor[1] = 0.25+inc_color; PathColor[2] = 0.25 + inc_color;
-		}
-
-		//PathColor[0]=0.25 ;PathColor[1] = 0.25; PathColor[2] = 0.25;
-		if(i%4 == 0)
-		{
-			PathColor[0] = Color1[0]; PathColor[1] = Color1[1]; PathColor[2] = Color1[2];
-		}
-		else if(i%4 == 1)
-		{
-			PathColor[0] = Color2[0]; PathColor[1] = Color2[1]; PathColor[2] = Color2[2];
-		}
-		else if(i%4 == 2)
-		{
-			PathColor[0] = Color3[0]; PathColor[1] = Color3[1]; PathColor[2] = Color3[2];
-		}
-		else if(i%4 == 3)
-		{
-			PathColor[0] = Color4[0]; PathColor[1] = Color4[1]; PathColor[2] = Color4[2];
-		}
-
-		PathColor[0] = PathColor[0]*0.15;
-		PathColor[1] = PathColor[1]*0.95;
-		PathColor[2] = PathColor[2]*0.95;
-		PathColor[0]=0.4;PathColor[1] = 0.4; PathColor[2] = 0.4;
-		//DrawingHelpers::DrawPrePreparedPolygons(m_ReadyToDrawLanes[i], mapdata_z, PathColor);
-
-		PathColor[0]=0.1;PathColor[1] = 0.1; PathColor[2] = 0.1;
-		DrawingHelpers::DrawPrePreparedPolygons(m_ReadyToDrawCenterLines[i], mapdata_z+0.015, PathColor, 1);
-	}
-
-	glEnable(GL_LIGHTING);
-}
-
-void PlannerTestDraw::DrawSimu()
-{
-
-	m_followX = m_LocalPlanner.state.pos.x;
-	m_followY = m_LocalPlanner.state.pos.y;
-	m_followZ = m_LocalPlanner.state.pos.z;
-	m_followA = m_LocalPlanner.state.pos.a;
-
-	DrawVectorMap();
-
-
-	DrawPaths();
-	DrawStartsAndGoals();
-	DrawCarModels();
-	DrawAdditionalDebugInfo();
-	DrawTrafficInfo_StopLines_Lights();
-}
-
-void PlannerTestDraw::DrawAdditionalDebugInfo()
-{
-	glColor3f(1,0,0);
-	DrawingHelpers::DrawFilledEllipse(m_FollowPoint.x, m_FollowPoint.y, 0.2, 0.2, 0.2);
-
-	glColor3f(0,0,1);
-	DrawingHelpers::DrawFilledEllipse(m_PerpPoint.x, m_PerpPoint.y, 0.2, 0.2, 0.2);
-}
-
-void PlannerTestDraw::DrawStartsAndGoals()
-{
-	for(unsigned int i=0 ; i &lt; m_goals.size(); i++)
-	{
-		glColor3f(1,0,1);
-		DrawingHelpers::DrawFilledEllipse(m_goals.at(i).pos.x, m_goals.at(i).pos.y, 1.2, 0.2,0.2);
-		DrawingHelpers::DrawArrow(m_goals.at(i).pos.x+2.5, m_goals.at(i).pos.y, m_goals.at(i).pos.a);
-	}
-}
-
-void PlannerTestDraw::DrawTrafficInfo_StopLines_Lights()
-{
-	//Draw Traffic Light :
-	glDisable(GL_LIGHTING);
-	for(unsigned int i=0 ; i &lt; m_RoadMap.trafficLights.size(); i++)
-	{
-		glPushMatrix();
-		if(m_bGreenTrafficLight)
-			glColor3f(0.3,0,0);
-		else
-			glColor3f(1,0,0);
-		glTranslated(m_RoadMap.trafficLights.at(i).pos.x, m_RoadMap.trafficLights.at(i).pos.y, 1);
-		glRotated(m_RoadMap.trafficLights.at(i).pos.a*RAD2DEG, 0,0,1);
-		glRotated(90, 1,0,0);
-		glTranslated(-m_RoadMap.trafficLights.at(i).pos.x, -m_RoadMap.trafficLights.at(i).pos.y, -1);
-		DrawingHelpers::DrawFilledEllipse(m_RoadMap.trafficLights.at(i).pos.x, m_RoadMap.trafficLights.at(i).pos.y, 1, 0.5,0.5);
-		if(m_bGreenTrafficLight)
-			glColor3f(0,1,0);
-		else
-			glColor3f(0,0.3,0);
-		DrawingHelpers::DrawFilledEllipse(m_RoadMap.trafficLights.at(i).pos.x+1.2, m_RoadMap.trafficLights.at(i).pos.y, 1, 0.5,0.5);
-		glPopMatrix();
-
-//		glPushMatrix();
-//		glTranslated(m_RoadMap.trafficLights.at(i).pos.x, m_RoadMap.trafficLights.at(i).pos.y, 1.5);
-//		std::ostringstream str_out ;
-//		str_out.precision(4);
-//		str_out &lt;&lt; "TFID: "&lt;&lt; m_RoadMap.trafficLights.at(i).id;
-//		DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
-//		glPopMatrix();
-	}
-
-	for(unsigned int i=0 ; i &lt; m_RoadMap.stopLines.size(); i++)
-	{
-		float stop_line_Color[3] = {0.8, 0.99, 0.99};
-		vector&lt;PlannerHNS::WayPoint&gt; line_points;
-		for(unsigned int islp = 0; islp &lt; m_RoadMap.stopLines.at(i).points.size(); islp++)
-		{
-			PlannerHNS::WayPoint wp;
-			wp.pos = m_RoadMap.stopLines.at(i).points.at(islp);
-			line_points.push_back(wp);
-		}
-		DrawingHelpers::DrawWidePath(line_points, 0.2, 0.15, stop_line_Color);
-		PlannerHNS::GPSPoint p;
-		if(m_RoadMap.stopLines.at(i).points.size() &gt; 1)
-		{
-			p.x = (m_RoadMap.stopLines.at(i).points.at(0).x + m_RoadMap.stopLines.at(i).points.at(1).x)/2.0;
-			p.y = (m_RoadMap.stopLines.at(i).points.at(0).y + m_RoadMap.stopLines.at(i).points.at(1).y)/2.0;
-		}
-
-//		glPushMatrix();
-//		glTranslated(p.x, p.y, 1.5);
-//		std::ostringstream str_out ;
-//		str_out.precision(4);
-//		str_out &lt;&lt; "SLID: "&lt;&lt; m_RoadMap.stopLines.at(i).id;
-//		glColor3f(0,1,0);
-//		DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
-//		glPopMatrix();
-	}
-
-//	if(m_RoadMap.roadSegments.size()&gt;0)
-//	{
-//		for(unsigned int i=0 ; i &lt; m_RoadMap.roadSegments.at(0).Lanes.size(); i++)
-//		{
-//			if(m_RoadMap.roadSegments.at(0).Lanes.at(i).points.size() &gt; 0)
-//			{
-//				PlannerHNS::GPSPoint p = m_RoadMap.roadSegments.at(0).Lanes.at(i).points.at(m_RoadMap.roadSegments.at(0).Lanes.at(i).points.size()/2).pos;
-//				glPushMatrix();
-//				glTranslated(p.x, p.y, 1.5);
-//				std::ostringstream str_out ;
-//				str_out.precision(4);
-//				str_out &lt;&lt; "LID: "&lt;&lt; m_RoadMap.roadSegments.at(0).Lanes.at(i).id;
-//				glColor3f(1,0,0);
-//				DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
-//				glPopMatrix();
-//			}
-//		}
-//	}
-
-	glEnable(GL_LIGHTING);
-}
-
-void PlannerTestDraw::DrawCarModels()
-{
-	glDisable(GL_LIGHTING);
-	for(unsigned int i =0; i &lt;m_dummyObstacles.size(); i++)
-	{
-		float CarColor[3] = {0.9, 0.1, 0.9};
-		DrawingHelpers::DrawCustomCarModel(m_dummyObstacles.at(i).center, 0,m_LocalPlanner.m_CarShapePolygon, CarColor, 90);
-		//std::cout &lt;&lt; " &gt;&gt;&gt; Calculated Angle : " &lt;&lt; (m_dummyObstacles.at(i).center.pos.a*RAD2DEG + 90)*DEG2RAD &lt;&lt; std::endl;
-		glPushMatrix();
-		glTranslated(m_dummyObstacles.at(i).center.pos.x, m_dummyObstacles.at(i).center.pos.y, 1.3);
-		std::ostringstream str_out ;
-		str_out.precision(4);
-		str_out &lt;&lt;  m_dummyObstacles.at(i).center.v *3.6;
-		DrawingHelpers::DrawString(0, 0,
-				GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
-		glPopMatrix();
-	}
-
-	float CarColor[3] = {0.1, 0.9, 0.9};
-
-	pthread_mutex_lock(&amp;simulation_mutex);
-	for(unsigned int i =0; i &lt;m_SimulatedCars.size(); i++)
-	{
-		DrawingHelpers::DrawCustomCarModel(m_SimulatedCars.at(i).state, m_SimulatedVehicleState.at(i).steer, m_LocalPlanner.m_CarShapePolygon, CarColor, 90);
-//
-//		glPushMatrix();
-//		glTranslated(m_SimulatedCars.at(i).state.pos.x, m_SimulatedCars.at(i).state.pos.y, 1.3);
-//		std::ostringstream str_out ;
-//		str_out.precision(2);
-//		str_out &lt;&lt;  m_SimulatedVehicleState.at(i).speed *3.6;
-//		DrawingHelpers::DrawString(0, 1,
-//				GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
-//		glPopMatrix();
-
-		float TotalPathColor[3] = {0.5, 0.0, 0.99};
-		DrawingHelpers::DrawWidePath(m_SimulatedCars.at(i).m_TotalPath, 0.08, 0.15, TotalPathColor);
-
-//		for(unsigned int ii = 0; ii &lt; m_SimulatedCars.at(i).m_TotalPath.size(); ii++ )
-//		{
-//			if(m_SimulatedCars.at(i).m_TotalPath.at(ii).collisionCost &gt;= 1)
-//				glColor3f(1, 0, 0);
-//			else
-//				glColor3f(TotalPathColor[0], TotalPathColor[1], TotalPathColor[2]);
-//			DrawingHelpers::DrawSimpleEllipse(m_SimulatedCars.at(i).m_TotalPath.at(ii).pos.x,
-//					m_SimulatedCars.at(i).m_TotalPath.at(ii).pos.y, 0.25, 1.0, 1.0);
-//
-//
-//		}
-	}
-	pthread_mutex_unlock(&amp;simulation_mutex);
-
-	if(m_CarModel)
-	{
-//		DrawingHelpers::DrawModel(m_CarModel, m_LocalPlanner.m_CarInfo.wheel_base *0.9,
-//				m_LocalPlanner.m_CarInfo.wheel_base*0.9, m_LocalPlanner.m_CarInfo.wheel_base*0.9,
-//				m_LocalPlanner.state.pos.x,m_LocalPlanner.state.pos.y,
-//				m_LocalPlanner.state.pos.z+0.275, m_LocalPlanner.state.pos.a, 0,0);
-	}
-
-	DrawingHelpers::DrawCustomCarModel(m_LocalPlanner.state, m_LocalPlanner.m_CurrentSteering , m_LocalPlanner.m_CarShapePolygon, CarColor, 90);
-
-	glEnable(GL_LIGHTING);
-}
-
-void PlannerTestDraw::DrawPaths()
-{
-	float TotalPathColor[3] = {0.99, 0.2, 0.2};
-	float PlannedPathColor[3] = {0.9, 0.1, 0.9};
-	float ActualPathColor[3] = {0.1, 0.1, 0.9};
-	float RollOutsColor[3] = {0.1, 0.9, 0.1};
-
-	glDisable(GL_LIGHTING);
-	pthread_mutex_lock(&amp;planning_mutex);
-
-	if(m_iStepNumber%4 == 0)
-	{
-		//DrawingHelpers::DrawWidePath(m_LocalPlanner.m_PathSection, 0.08, 0.25, TotalPathColor);
-
-		//DrawingHelpers::DrawCostPath(m_all_cell_to_delete, 0.5, 0.5);
-
-	}
-	else if(m_iStepNumber%4 == 1)
-	{
-		for(unsigned int i = 0; i &lt; m_LocalPlanner.m_SampledPoints.size(); i++)
-			{
-				glPointSize(8);
-				glBegin(GL_POINTS);
-					glColor3f(0.1,0.9,0.1);
-					glVertex3f(m_LocalPlanner.m_SampledPoints.at(i).pos.x, m_LocalPlanner.m_SampledPoints.at(i).pos.y, 0.21);
-				glEnd();
-				glPointSize(1);
-			}
-	}
-	else if(m_iStepNumber%4 == 2)
-	{
-
-	for(unsigned int i=0; i&lt; m_LocalPlanner.m_TotalPath.size(); i++)
-		DrawingHelpers::DrawWidePath(m_LocalPlanner.m_TotalPath.at(i), 0.08, 0.1, TotalPathColor);
-
-	DrawingHelpers::DrawWidePath(m_LocalPlanner.m_Path, 0.16, 0.06, PlannedPathColor);
-	DrawingHelpers::DrawWidePath(m_ActualPath, 0.1, 0.15, ActualPathColor);
-
-	for(unsigned int i = 0; i &lt; m_LocalPlanner.m_Path.size(); i+=2 )
-	{
-//		if(m_LocalPlanner.m_Path.at(i).collisionCost &gt;= 1)
-//		{
-//			glColor3f(1, 0, 0);
-//			float collisionColor[3] = {1, 0, 0};
-//			DrawingHelpers::DrawWideEllipse(m_LocalPlanner.m_Path.at(i).pos.x,
-//					m_LocalPlanner.m_Path.at(i).pos.y, 0.2, 1.0, 1.0, 0.8, collisionColor);
-//		}
-//		else
-//		{
-//			glColor3f(PlannedPathColor[0], PlannedPathColor[1], PlannedPathColor[2]);
-//			DrawingHelpers::DrawSimpleEllipse(m_LocalPlanner.m_Path.at(i).pos.x,
-//					m_LocalPlanner.m_Path.at(i).pos.y, 0.2, 1.0, 1.0);
-//		}
-
-//		glPointSize(10);
-//		glBegin(GL_POINTS);
-//			glColor3f(0,0,1);
-//			glVertex3f(m_LocalPlanner.m_Path.at(i).pos.x, m_LocalPlanner.m_Path.at(i).pos.y, 0.21);
-//		glEnd();
-//		glPointSize(1);
-
-//		glPushMatrix();
-//		glTranslated(m_LocalPlanner.m_Path.at(i).pos.x, m_LocalPlanner.m_Path.at(i).pos.y, 0.25);
-//		std::ostringstream str_out ;
-//		str_out.precision(4);
-//		str_out &lt;&lt;  m_LocalPlanner.m_Path.at(i).timeCost;
-//		glColor3f(1,0.9,1);
-//		DrawingHelpers::DrawString(0, 0,
-//				GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
-//		glPopMatrix();
-	}
-
-
-	for(unsigned int li=0; li &lt; m_LocalPlanner.m_RollOuts.size();li++)
-	{
-		for(unsigned int ti=0; ti &lt; m_LocalPlanner.m_RollOuts.at(li).size(); ti++)
-		{
-			DrawingHelpers::DrawWidePath(m_LocalPlanner.m_RollOuts.at(li).at(ti), 0.14, 0.06, RollOutsColor);
-
-			for(unsigned int i = 0; i &lt; m_LocalPlanner.m_RollOuts.at(li).at(ti).size(); i+=2 )
-			{
-//				if(m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).collisionCost &gt;= 1)
-//				{
-//					glColor3f(1, 0, 0);
-//					float collisionColor[3] = {1, 0, 0};
-//					DrawingHelpers::DrawWideEllipse(m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.x,
-//							m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.y, 0.2, 1.0, 1.0, 0.8, collisionColor);
-//				}
-//				else
-//				{
-//					glColor3f(PlannedPathColor[0], PlannedPathColor[1], PlannedPathColor[2]);
-//					DrawingHelpers::DrawSimpleEllipse(m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.x,
-//							m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.y, 0.2, 1.0, 1.0);
-//				}
-
-//				glDisable(GL_LIGHTING);
-//				glPointSize(10);
-//				glBegin(GL_POINTS);
-//				int j_dec = 0;
-//				int r_inc = i*8;
-//				if(r_inc &gt; 255)
-//				{
-//					//j_dec = i*5 - 255;
-//					r_inc = 255;
-//				}
-//					//glColor3ub(r_inc,255-j_dec,0);
-//					glVertex3f(m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.x, m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.y, 0.21);
-//				glEnd();
-//				glPointSize(1);
-
-//				glPushMatrix();
-//				glTranslated(m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.x, m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.y, 0.25);
-//				std::ostringstream str_out ;
-//				str_out.precision(4);
-//				str_out &lt;&lt;  m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).timeCost;
-//				glColor3f(1,0.9,1);
-//				DrawingHelpers::DrawString(0, 0,
-//						GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
-//				glPopMatrix();
-			}
-		}
-	}
-
-
-
-//	for(unsigned int ii = 0; ii &lt; m_LocalPlanner.m_PredictedPath.size(); ii++ )
-//	{
-//		DrawingHelpers::DrawWidePath(m_LocalPlanner.m_PredictedPath.at(ii), 0.08, 0.25, TotalPathColor);
-//
-//		for(unsigned int k = 0; k &lt; m_LocalPlanner.m_PredictedPath.at(ii).size(); k++ )
-//		{
-//			if(m_LocalPlanner.m_PredictedPath.at(ii).at(k).collisionCost &gt;= 1)
-//				glColor3f(1, 0, 0);
-//			else
-//				glColor3f(TotalPathColor[0], TotalPathColor[1], TotalPathColor[2]);
-//			DrawingHelpers::DrawSimpleEllipse(m_LocalPlanner.m_PredictedPath.at(ii).at(k).pos.x,
-//					m_LocalPlanner.m_PredictedPath.at(ii).at(k).pos.y, 0.25, 1.0, 1.0);
-//
-//			glPushMatrix();
-//			glTranslated(m_LocalPlanner.m_PredictedPath.at(ii).at(k).pos.x, m_LocalPlanner.m_PredictedPath.at(ii).at(k).pos.y, 0.25);
-//			std::ostringstream str_out ;
-//			str_out.precision(4);
-//			str_out &lt;&lt;  m_LocalPlanner.m_PredictedPath.at(ii).at(k).timeCost;
-//			glColor3f(1,0.9,1);
-//			DrawingHelpers::DrawString(0, 0,
-//					GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
-//			glPopMatrix();
-//		}
-//
-//	}
-
-	}
-	pthread_mutex_unlock(&amp;planning_mutex);
-	glEnable(GL_LIGHTING);
-}
-
-void PlannerTestDraw::DrawInfo(const int&amp; centerX, const int&amp; centerY, const int&amp; maxX, const int&amp; maxY)
-{
-	double left_shift = 25;
-	glDisable(GL_LIGHTING);
-	glPushMatrix();
-	glTranslated(centerX-left_shift, 70, 0);
-	glRotated(-1*m_VehicleCurrentState.steer*RAD2DEG*16, 0,0,1);
-	glTranslated(-(centerX-left_shift), -70, 0);
-
-	float wheel_color[3] = {0.6, 0.7, 0.8};
-	DrawingHelpers::DrawWideEllipse(centerX-left_shift, 70, 0.5, 60, 55, 54, wheel_color);
-
-	glColor3f(0.5,0.4, 0.3);
-	PlannerHNS::GPSPoint p1(centerX-left_shift, 70, 0.52, 0), p2(centerX-left_shift+38, 70-38, 0.52, 0);
-	DrawingHelpers::DrawLinePoygonline(p1, p2, 5);
-
-	PlannerHNS::GPSPoint p11(centerX-left_shift, 70, 0.52, 0), p22(centerX-left_shift-38, 70-38, 0.52, 0);
-	DrawingHelpers::DrawLinePoygonline(p11, p22, 5);
-
-	PlannerHNS::GPSPoint p111(centerX-left_shift, 70, 0.52, 0), p222(centerX-left_shift, 70+52, 0.52, 0);
-	DrawingHelpers::DrawLinePoygonline(p111, p222, 5);
-	glPopMatrix();
-
-	double speed = m_VehicleCurrentState.speed*3.6;
-	float pedal_color[3] = {0.5,0.4, 0.3};
-	glColor3f(wheel_color[0],wheel_color[1],wheel_color[2]);
-	DrawingHelpers::DrawPedal(centerX + 70, 70, 0, 30.0, 100.0, speed*5.5,pedal_color );
-
-	glPushMatrix();
-	glTranslated(centerX-left_shift-15, 70+85, 0);
-	glColor3f(0.8, 0.1, 0.7);
-	std::ostringstream str_out ;
-	str_out.precision(2);
-	str_out &lt;&lt;  m_VehicleCurrentState.steer*RAD2DEG;
-	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
-	glPopMatrix();
-
-	glPushMatrix();
-	glTranslated(centerX+60, 70+85, 0);
-	glColor3f(0.8, 0.1, 0.7);
-	std::ostringstream v_out ;
-	v_out.precision(2);
-	v_out &lt;&lt;  speed;
-	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)v_out.str().c_str());
-	glPopMatrix();
-
-	glEnable(GL_LIGHTING);
-//
-//	INITIAL_STATE, WAITING_STATE, FORWARD_STATE, STOPPING_STATE, EMERGENCY_STATE,
-//		TRAFFIC_LIGHT_STOP_STATE, STOP_SIGN_STOP_STATE, FOLLOW_STATE, LANE_CHANGE_STATE, OBSTACLE_AVOIDANCE_STATE, FINISH_STATE
-
-	std::ostringstream state_out ;
-	state_out.precision(4);
-	state_out &lt;&lt; "State-&gt; ";
-	string str = "Unknown";
-	switch(m_CurrentBehavior.state)
-	{
-	case PlannerHNS::INITIAL_STATE:
-		str = "Init";
-		break;
-	case PlannerHNS::WAITING_STATE:
-		str = "Waiting";
-		break;
-	case PlannerHNS::FORWARD_STATE:
-		str = "Forward";
-		break;
-	case PlannerHNS::STOPPING_STATE:
-		str = "Stop";
-		break;
-	case PlannerHNS::FINISH_STATE:
-		str = "End";
-		break;
-	case PlannerHNS::FOLLOW_STATE:
-		str = "Follow";
-		break;
-	case PlannerHNS::OBSTACLE_AVOIDANCE_STATE:
-		str = "Swerving";
-		break;
-	case PlannerHNS::TRAFFIC_LIGHT_STOP_STATE:
-		str = "Light Stop";
-		break;
-	case PlannerHNS::TRAFFIC_LIGHT_WAIT_STATE:
-		str = "Light Wait";
-		break;
-	case PlannerHNS::STOP_SIGN_STOP_STATE:
-		str = "Sign Stop";
-		break;
-	case PlannerHNS::STOP_SIGN_WAIT_STATE:
-		str = "Sign Wait";
-		break;
-	default:
-		str = "Unknown";
-		break;
-	}
-	state_out &lt;&lt; str;
-	state_out &lt;&lt; " (" &lt;&lt; m_CurrentBehavior.followDistance &lt;&lt; ";"
-			&lt;&lt; m_CurrentBehavior.followVelocity*3.6 &lt;&lt; ";"
-			&lt;&lt; m_CurrentBehavior.stopDistance &lt;&lt; ";"
-			&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory &lt;&lt; ";"
-			&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iPrevSafeTrajectory &lt;&lt; ")";
-
-	double verticalTranslation = 200;
-	glPushMatrix();
-	glColor3f(0.8, 0.5, 0.7);
-	glTranslated(10, verticalTranslation, 0);
-	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)state_out.str().c_str());
-
-	double y = 30;
-	for(unsigned int i = 0; i &lt; m_dummyObstacles.size(); i++)
-	{
-		std::ostringstream sim_n_out ;
-		sim_n_out &lt;&lt; "Simu Car (:" &lt;&lt; m_dummyObstacles.at(i).id &lt;&lt; ") -&gt; ";
-		sim_n_out &lt;&lt; m_dummyObstacles.at(i).center.v;
-		glColor3f(0.6, 0.6, 0.9);
-		DrawingHelpers::DrawString(0, y, GLUT_BITMAP_TIMES_ROMAN_24, (char*)sim_n_out.str().c_str());
-		y+=30;
-	}
-
-	glPopMatrix();
-
-//	glPushMatrix();
-//	verticalTranslation += 300;
-//	glTranslated(10, verticalTranslation, 0);
-//	if(m_pVelocityGraph)
-//	{
-//		double axes_color[3] = {0.1, 0.1, 0.8};
-//		double graph_color[3] = {0.9, 0.2, 0.1};
-//		m_pVelocityGraph-&gt;ReInitGraphResolution(maxX-20, 200,1000, axes_color, graph_color );
-//		//if(m_VehicleCurrentState.speed&gt;0)
-//		{
-//			m_pVelocityGraph-&gt;InsertPointTimeStamp(m_VehicleCurrentState.tStamp, m_VehicleCurrentState.speed*3.6);
-//		}
-//		m_pVelocityGraph-&gt;DrawGraph();
-//	}
-//	glPopMatrix();
-//
-//	glPushMatrix();
-//	verticalTranslation+=250;
-//	glTranslated(10, verticalTranslation, 0);
-//	if(m_pSteeringGraph)
-//	{
-//		double axes_color[3] = {0.1, 0.1, 0.8};
-//		double graph_color[3] = {0.9, 0.2, 0.1};
-//		m_pSteeringGraph-&gt;ReInitGraphResolution(maxX-20, 200,1000, axes_color, graph_color );
-//		//if(m_VehicleCurrentState.steer&gt;0)
-//		{
-//			m_pSteeringGraph-&gt;InsertPointTimeStamp(m_VehicleCurrentState.tStamp, m_VehicleCurrentState.steer*RAD2DEG);
-//		}
-//		m_pSteeringGraph-&gt;DrawGraph();
-//	}
-//	glPopMatrix();
-//
-//	glPushMatrix();
-//	verticalTranslation+=250;
-//	glTranslated(10, verticalTranslation, 0);
-//	if(m_pLateralErrGraph)
-//	{
-//		double axes_color[3] = {0.1, 0.1, 0.8};
-//		double graph_color[3] = {0.9, 0.2, 0.1};
-//		m_pLateralErrGraph-&gt;ReInitGraphResolution(maxX-20, 200,1000, axes_color, graph_color );
-//		//if(m_VehicleCurrentState.steer&gt;0)
-//		{
-//			m_pLateralErrGraph-&gt;InsertPointTimeStamp(m_VehicleCurrentState.tStamp, m_LateralError);
-//		}
-//		m_pLateralErrGraph-&gt;DrawGraph();
-//	}
-//	glPopMatrix();
-
-	glPushMatrix();
-	std::ostringstream performance_str ;
-	performance_str.precision(6);
-	glColor3f(0.8, 0.5, 0.7);
-	verticalTranslation+=250;
-	glTranslated(10, verticalTranslation, 0);
-	performance_str &lt;&lt; 				"DP Time 		= ";
-	performance_str &lt;&lt; m_GlobalPlanningTime;
-	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)performance_str.str().c_str());
-	glPopMatrix();
-	glPushMatrix();
-	std::ostringstream local_performance_str ;
-	local_performance_str.precision(6);
-	glColor3f(0.8, 0.5, 0.7);
-	verticalTranslation+=30;
-	glTranslated(10, verticalTranslation, 0);
-	local_performance_str &lt;&lt; 		"Local Planner 	= ";
-	local_performance_str &lt;&lt; m_LocalPlanningTime;
-	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)local_performance_str.str().c_str());
-	glPopMatrix();
-	glPushMatrix();
-	std::ostringstream track_performance_str ;
-	track_performance_str.precision(6);
-	glColor3f(0.8, 0.5, 0.7);
-	verticalTranslation+=30;
-	glTranslated(10, verticalTranslation, 0);
-	track_performance_str &lt;&lt; 		"Tracking Timer	= ";
-	track_performance_str &lt;&lt; m_ObjectTrakingTime;
-	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)track_performance_str.str().c_str());
-	glPopMatrix();
-	glPushMatrix();
-	std::ostringstream control_performance_str ;
-	control_performance_str.precision(6);
-	glColor3f(0.8, 0.5, 0.7);
-	verticalTranslation+=30;
-	glTranslated(10, verticalTranslation, 0);
-	control_performance_str &lt;&lt; 		"Control Time	= ";
-	control_performance_str &lt;&lt; m_ControllingTime;
-	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)control_performance_str.str().c_str());
-	glPopMatrix();
-	glPushMatrix();
-	std::ostringstream simu_performance_str ;
-	simu_performance_str.precision(6);
-	glColor3f(0.8, 0.5, 0.7);
-	verticalTranslation+=30;
-	glTranslated(10, verticalTranslation, 0);
-	simu_performance_str &lt;&lt; 		"Simu Time 		= ";
-	simu_performance_str &lt;&lt; m_SimulationTime;
-	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)simu_performance_str.str().c_str());
-	glPopMatrix();
-
-}
-
-void PlannerTestDraw::OnLeftClick(const double&amp; x, const double&amp; y)
-{
-//	if(m_LocalPlanner.m_TotalPath.size() &gt; 0)
-//	{
-//		PlannerHNS::WayPoint wp1(x,y,0,0);
-//		int index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_LocalPlanner.m_TotalPath.at(0), wp1);
-//		PlannerHNS::WayPoint wp2 = m_LocalPlanner.m_TotalPath.at(0).at(index);
-//		vector&lt;PlannerHNS::WayPoint&gt; line;
-//		line.push_back(wp1);
-//		line.push_back(wp2);
-//		float color[3] = {0.99, 0.0, 0.0};
-//		DrawingHelpers::DrawWidePath(line,0.1,1, color);
-//	}
-
-}
-
-void PlannerTestDraw::OnRightClick(const double&amp; x, const double&amp; y)
-{}
-
-void PlannerTestDraw::OnKeyboardPress(const SPECIAL_KEYS_TYPE&amp; sKey, const unsigned char&amp; key)
-{
-	//std::cout &lt;&lt; "key" &lt;&lt; std::endl;
-
-	switch(key)
-	{
-	case 's':
-		if(m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl == 0)
-			m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = 1;
-		else if(m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl == 1)
-			m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = 0;
-		break;
-	case 'v':
-	{
-		SaveSimulationData();
-	}
-	break;
-	case 'l':
-	{
-		LoadSimulationData();
-	}
-	break;
-	case 'n':
-	{
-		pthread_mutex_lock(&amp;simulation_mutex);
-		m_SimulatedCars.clear();
-		m_SimulatedBehaviors.clear();
-		m_SimulatedVehicleState.clear();
-		m_SimulatedPrevTrajectory.clear();
-		m_SimulatedPathFollower.clear();
-		pthread_mutex_unlock(&amp;simulation_mutex);
-	}
-	break;
-	case 'g':
-	{
-		if(m_bGreenTrafficLight)
-			m_bGreenTrafficLight = false;
-		else
-			m_bGreenTrafficLight = true;
-	}
-	break;
-	case '1':
-	{
-		m_iStepNumber++;
-	}
-	break;
-	default:
-		break;
-
-	}
-}
-
-void PlannerTestDraw::TransToCarCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
-{
-	PlannerHNS::Mat3 rotationMat(-currPose.pos.a);
-	PlannerHNS::Mat3 translationMat(-currPose.pos.x, -currPose.pos.y);
-	for(unsigned int i=0; i &lt; obj_list.size(); i++)
-	{
-		obj_list.at(i).center.pos = translationMat*obj_list.at(i).center.pos;
-		obj_list.at(i).center.pos = rotationMat*obj_list.at(i).center.pos;
-		for(unsigned int j = 0 ; j &lt; obj_list.at(i).contour.size(); j++)
-		{
-			obj_list.at(i).contour.at(j) = translationMat*obj_list.at(i).contour.at(j);
-			obj_list.at(i).contour.at(j) = rotationMat*obj_list.at(i).contour.at(j);
-		}
-	}
-}
-
-void PlannerTestDraw::TransToWorldCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
-{
-	PlannerHNS::Mat3 rotationMat(currPose.pos.a);
-	PlannerHNS::Mat3 translationMat(currPose.pos.x, currPose.pos.y);
-	for(unsigned int i=0; i &lt; obj_list.size(); i++)
-	{
-		obj_list.at(i).center.pos = rotationMat*obj_list.at(i).center.pos;
-		obj_list.at(i).center.pos = translationMat*obj_list.at(i).center.pos;
-
-		for(unsigned int j = 0 ; j &lt; obj_list.at(i).contour.size(); j++)
-		{
-			obj_list.at(i).contour.at(j) = translationMat*obj_list.at(i).contour.at(j);
-			obj_list.at(i).contour.at(j) = rotationMat*obj_list.at(i).contour.at(j);
-		}
-	}
-}
-
-void* PlannerTestDraw::PlanningThreadStaticEntryPoint(void* pThis)
-{
-	PlannerTestDraw* pR = (PlannerTestDraw*)pThis;
-	struct timespec moveTimer;
-	UtilityH::GetTickCount(moveTimer);
-	vector&lt;string&gt; logData;
-	PlannerHNS::PlannerH planner;
-	SimpleTracker obstacleTracking;
-	obstacleTracking.m_MAX_ASSOCIATION_DISTANCE = 1;
-	obstacleTracking.m_bUseCenterOnly = true;
-
-	vector&lt;string&gt; behaviorsLogData;
-
-	while(!pR-&gt;m_bCancelThread)
-	{
-		double time_elapsed  = UtilityH::GetTimeDiffNow(moveTimer);
-
-		if(time_elapsed &gt;= pR-&gt;m_PlanningCycleTime)
-		{
-			double dt = time_elapsed;
-			UtilityH::GetTickCount(moveTimer);
-#ifdef EnableThreadBody
-			vector&lt;vector&lt;PlannerHNS::WayPoint&gt; &gt; generatedTotalPath;// = pR-&gt;m_LocalPlanner.m_TotalPath;
-			bool bNewPlan = false;
-			PlannerHNS::VehicleState currTargetState;
-			pthread_mutex_lock(&amp;pR-&gt;control_mutex);
-			currTargetState = pR-&gt;m_VehicleTargetState;
-			pthread_mutex_unlock(&amp;pR-&gt;control_mutex);
-
-			/**
-			 * Path Planning Step (Global Planning)
-			 */
-			int currIndexToGoal = 0;
-			if(pR-&gt;m_LocalPlanner.m_TotalPath.size()&gt;0)
-				currIndexToGoal = PlannerHNS::PlanningHelpers::GetClosestNextPointIndexFast(pR-&gt;m_LocalPlanner.m_TotalPath.at(0), pR-&gt;m_LocalPlanner.state);
-//			int index_limit_total = pR-&gt;m_LocalPlanner.m_TotalPath.size() - 25;
-//			if(index_limit_total&lt;=0)
-//				index_limit_total =  pR-&gt;m_LocalPlanner.m_TotalPath.size()/2.0;
-//
-//			if(currIndexToal &gt; index_limit_total)
-//			{
-//				pR-&gt;m_bMakeNewPlan = true;
-//				PlannerHNS::WayPoint g_p = pR-&gt;m_goals.at(m_iCurrentGoal);
-//				pR-&gt;m_goal = pR-&gt;m_start;
-//				pR-&gt;m_start = g_p;
-//			}
-
-
-			if(pR-&gt;m_bMakeNewPlan == false &amp;&amp; pR-&gt;m_CurrentBehavior.state == PlannerHNS::STOPPING_STATE &amp;&amp; (pR-&gt;m_iCurrentGoal+1) &lt; pR-&gt;m_goals.size())
-			{
-				if(pR-&gt;m_LocalPlanner.m_TotalPath.size() &gt; 0 &amp;&amp; currIndexToGoal &gt; pR-&gt;m_LocalPlanner.m_TotalPath.size() - 8)
-				{
-					pR-&gt;m_iCurrentGoal = pR-&gt;m_iCurrentGoal + 1;
-					pR-&gt;m_bMakeNewPlan = true;
-					pR-&gt;m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bRePlan = true;
-				}
-			}
-
-			if((pR-&gt;m_CurrentBehavior.state == PlannerHNS::INITIAL_STATE &amp;&amp; pR-&gt;m_LocalPlanner.m_Path.size() == 0 &amp;&amp; pR-&gt;m_bMakeNewPlan) || pR-&gt;m_bMakeNewPlan )
-			{
-				//planner.PlanUsingReedShepp(pR-&gt;m_LocalPlanner.state, pR-&gt;m_goal, generatedPath);
-				timespec planTime;
-				UtilityH::GetTickCount(planTime);
-				planner.PlanUsingDP(pR-&gt;m_LocalPlanner.state,
-						pR-&gt;m_goals.at(pR-&gt;m_iCurrentGoal),
-						1000000,
-						false,
-						pR-&gt;m_LanesIds,
-						pR-&gt;m_RoadMap,
-						generatedTotalPath, &amp;pR-&gt;m_all_cell_to_delete);
-				pR-&gt;m_GlobalPlanningTime = UtilityH::GetTimeDiffNow(planTime);
-
-				if(generatedTotalPath.size()&gt;0 &amp;&amp; generatedTotalPath.at(0).size()&gt;0)
-				{
-					pR-&gt;m_goals.at(pR-&gt;m_iCurrentGoal) = generatedTotalPath.at(0).at(generatedTotalPath.at(0).size()-1);
-					pR-&gt;m_bMakeNewPlan = false;
-					bNewPlan = true;
-				}
-
-			}
-
-			/**
-			 * Behavior Generator , State Machine , Decision making Step
-			 */
-			pthread_mutex_lock(&amp;pR-&gt;planning_mutex);
-			if(bNewPlan)
-				pR-&gt;m_LocalPlanner.m_TotalPath = generatedTotalPath;
-
-
-
-			timespec trackingTimer;
-			UtilityH::GetTickCount(trackingTimer);
-			std::vector&lt;PlannerHNS::DetectedObject&gt; obj_list;
-			pthread_mutex_lock(&amp;pR-&gt;simulation_mutex);
-			pR-&gt;DetectSimulatedObstacles(obj_list);
-			pthread_mutex_unlock(&amp;pR-&gt;simulation_mutex);
-
-			obstacleTracking.DoOneStep(pR-&gt;m_LocalPlanner.state, obj_list);
-			obj_list = obstacleTracking.m_DetectedObjects;
-
-
-			pR-&gt;m_ObjectTrakingTime = UtilityH::GetTimeDiffNow(trackingTimer);
-
-			timespec localPlannerTimer;
-			UtilityH::GetTickCount(localPlannerTimer);
-			PlannerHNS::WayPoint goal_wp;
-			if(pR-&gt;m_goals.size() &gt; 0)
-				goal_wp = pR-&gt;m_goals.at(0);
-//			if(pR-&gt;m_iCurrentGoal+1 &lt; pR-&gt;m_goals.size())
-//				goal_wp = pR-&gt;m_goals.at(pR-&gt;m_iCurrentGoal);
-
-			bool bEmergencyStop = false;
-
-			if(pR-&gt;m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl == 1 &amp;&amp; pR-&gt;m_CurrentBehavior.state != PlannerHNS::INITIAL_STATE)
-				bEmergencyStop = true;
-
-			PlannerHNS::TrafficLight tl;
-			vector&lt;PlannerHNS::TrafficLight&gt; tls;
-			if(pR-&gt;m_bGreenTrafficLight)
-				tl.lightState = PlannerHNS::GREEN_LIGHT;
-			else
-				tl.lightState = PlannerHNS::RED_LIGHT;
-
-			tls.push_back(tl);
-
-			pR-&gt;m_CurrentBehavior = pR-&gt;m_LocalPlanner.DoOneStep(dt, currTargetState, obj_list, 1, pR-&gt;m_RoadMap, bEmergencyStop, tls);
-
-			PlannerHNS::PlanningHelpers::WritePathToFile("/home/hatem/SimuLogs/Test", pR-&gt;m_LocalPlanner.m_Path);
-
-//			double d_slowDown = hypot(pR-&gt;m_SlowDown.pos.y - pR-&gt;m_LocalPlanner.state.pos.y, pR-&gt;m_SlowDown.pos.x - pR-&gt;m_LocalPlanner.state.pos.x);
-//			if(d_slowDown &lt; 3)
-//				pR-&gt;m_bStartSlow = true;
-//
-//			if(pR-&gt;m_bStartSlow)
-//				pR-&gt;m_CurrentBehavior.maxVelocity = 1;
-//
-//			double d_goNormal = hypot(pR-&gt;m_GoNormal.pos.y - pR-&gt;m_LocalPlanner.state.pos.y, pR-&gt;m_GoNormal.pos.x - pR-&gt;m_LocalPlanner.state.pos.x);
-//			if(d_slowDown &lt; 3)
-//				pR-&gt;m_bStartSlow = false;
-
-
-			pR-&gt;m_LocalPlanningTime = UtilityH::GetTimeDiffNow(localPlannerTimer);
-			pR-&gt;m_VehicleCurrentState.steer = pR-&gt;m_LocalPlanner.m_CurrentSteering;
-			pR-&gt;m_VehicleCurrentState.speed = pR-&gt;m_LocalPlanner.m_CurrentVelocity;
-			pR-&gt;m_VehicleCurrentState.shift = pR-&gt;m_LocalPlanner.m_CurrentShift;
-			UtilityH::GetTickCount(pR-&gt;m_VehicleCurrentState.tStamp);
-
-			if(pR-&gt;m_CurrentBehavior.state != PlannerHNS::INITIAL_STATE)
-				behaviorsLogData.push_back(pR-&gt;m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;ToString(pR-&gt;m_CurrentBehavior.state));
-
-			pR-&gt;m_dummyObstacles = obj_list;
-
-			pthread_mutex_unlock(&amp;pR-&gt;planning_mutex);
-
-			double d = 0;
-			if(pR-&gt;m_ActualPath.size()&gt;0)
-				d = distance2points(pR-&gt;m_ActualPath.at(pR-&gt;m_ActualPath.size()-1).pos, pR-&gt;m_LocalPlanner.state.pos);
-
-
-			if(pR-&gt;m_ActualPath.size() &gt; 0 &amp;&amp; d &gt; 0.5 )
-			{
-				pR-&gt;m_ActualPath.push_back(pR-&gt;m_LocalPlanner.state);
-			}
-			else if(pR-&gt;m_ActualPath.size()==0 &amp;&amp; pR-&gt;m_LocalPlanner.m_Path.size() &gt; 0)
-			{
-				pR-&gt;m_ActualPath.push_back(pR-&gt;m_LocalPlanner.state);
-			}
-#endif
-		}
-	}
-
-	DataRW::WriteLogData(UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName+DataRW::StatesLogFolderName, "BehaviorsLog",
-			pR-&gt;m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;ToStringHeader(), behaviorsLogData );
-
-	return 0;
-}
-
-void* PlannerTestDraw::ControlThreadStaticEntryPoint(void* pThis)
-{
-	PlannerTestDraw* pR = (PlannerTestDraw*)pThis;
-	struct timespec moveTimer;
-	TrajectoryFollower predControl;
-	double timeOfHalf = 0;
-	double timeTotal = 0;
-	int counter = 0;
-	PlannerHNS::VehicleState calibrationTargetState;
-
-	bool bCalibrationMode = false;
-	bool bStartCalibration = false;
-	timespec delayTimer;
-	double timeDelay = 0;
-	double totalLateralError = 0;
-
-
-	predControl.Init(pR-&gt;m_ControlParams, pR-&gt;m_CarInfo);
-
-	UtilityH::GetTickCount(moveTimer);
-	vector&lt;string&gt; logData;
-	vector&lt;PlannerHNS::WayPoint&gt; generatedPath;
-	vector&lt;vector&lt;PlannerHNS::WayPoint&gt; &gt; simulationGeneratedPaths;
-
-	while(!pR-&gt;m_bCancelThread)
-	{
-		double time_elapsed  = UtilityH::GetTimeDiffNow(moveTimer);
-
-		if(time_elapsed &gt;= pR-&gt;m_ControlCycleTime)
-		{
-			double dt = time_elapsed;
-			UtilityH::GetTickCount(moveTimer);
-
-#ifdef EnableThreadBody
-			pthread_mutex_lock(&amp;pR-&gt;planning_mutex);
-
-			PlannerHNS::BehaviorState currMessage = pR-&gt;m_CurrentBehavior;
-			PlannerHNS::VehicleState currState, targetState;
-			if(pR-&gt;m_bResetForSimulation)
-			{
-				predControl.Init(pR-&gt;m_ControlParams, pR-&gt;m_CarInfo);
-				generatedPath.clear();
-				pR-&gt;m_bResetForSimulation = false;
-			}
-
-			currState.steer = pR-&gt;m_LocalPlanner.m_CurrentSteering;
-			currState.speed = pR-&gt;m_LocalPlanner.m_CurrentVelocity;
-			currState.shift = pR-&gt;m_LocalPlanner.m_CurrentShift;
-
-			pthread_mutex_unlock(&amp;pR-&gt;planning_mutex);
-
-//			if(bCalibrationMode)
-//			{
-//				if(!bStartCalibration)
-//				{
-//					calibrationTargetState.speed = 0;
-//					if(counter == 0)
-//						calibrationTargetState.steer = pR-&gt;m_LocalPlanner.m_CarInfo.max_steer_angle/2.0;
-//					else if(counter == 1)
-//						calibrationTargetState.steer = 0;
-//					else if(counter == 2)
-//						calibrationTargetState.steer = -pR-&gt;m_LocalPlanner.m_CarInfo.max_steer_angle/2.0;
-//					else if(counter == 3)
-//						calibrationTargetState.steer = 0;
-//
-//					UtilityH::GetTickCount(delayTimer);
-//					timeOfHalf = 0;
-//					bStartCalibration = true;
-//				}
-//				else
-//				{
-//					if(abs(abs(currState.steer*RAD2DEG) - abs(calibrationTargetState.steer*RAD2DEG)) &lt; 0.5)
-//					{
-//						timeOfHalf = UtilityH::GetTimeDiffNow(delayTimer);
-//						counter++;
-//						timeTotal += timeOfHalf;
-//						bStartCalibration = false;
-//						if(counter==4)
-//						{
-//							bCalibrationMode = false;
-//							timeDelay = (timeTotal / (double)counter) / (pR-&gt;m_LocalPlanner.m_CarInfo.max_steer_angle*RAD2DEG/2.0);
-//							timeDelay = timeDelay*17.5;
-//
-//						}
-//					}
-//				}
-//
-//				targetState = calibrationTargetState;
-//			}
-//			else if(!bCalibrationMode)
-//			{
-//				timespec controlTimer;
-//				UtilityH::GetTickCount(controlTimer);
-//				bool bNewPath = false;
-//				if(PlannerHNS::PlanningHelpers::CompareTrajectories(generatedPath, pR-&gt;m_LocalPlanner.m_Path) == false &amp;&amp; pR-&gt;m_LocalPlanner.m_Path.size()&gt;0)
-//				{
-//					generatedPath = pR-&gt;m_LocalPlanner.m_Path;
-//					bNewPath = true;
-//					cout &lt;&lt; "Path is Updated in the controller .. " &lt;&lt; pR-&gt;m_LocalPlanner.m_Path.size() &lt;&lt; endl;
-//				}
-//
-//				PlannerHNS::ControllerParams c_params = pR-&gt;m_ControlParams;
-//				c_params.SteeringDelay = pR-&gt;m_ControlParams.SteeringDelay / (1.0-UtilityH::GetMomentumScaleFactor(currState.speed));
-//				predControl.Init(c_params, pR-&gt;m_CarInfo);
-//				targetState = predControl.DoOneStep(dt, currMessage, generatedPath, pR-&gt;m_LocalPlanner.state, currState, bNewPath);
-//				pR-&gt;m_ControllingTime = UtilityH::GetTimeDiffNow(controlTimer);
-//			}
-
-			timespec controlTimer;
-			UtilityH::GetTickCount(controlTimer);
-			bool bNewPath = false;
-			if(PlannerHNS::PlanningHelpers::CompareTrajectories(generatedPath, pR-&gt;m_LocalPlanner.m_Path) == false &amp;&amp; pR-&gt;m_LocalPlanner.m_Path.size()&gt;0)
-			{
-				generatedPath = pR-&gt;m_LocalPlanner.m_Path;
-				bNewPath = true;
-				cout &lt;&lt; "Path is Updated in the controller .. " &lt;&lt; pR-&gt;m_LocalPlanner.m_Path.size() &lt;&lt; endl;
-			}
-
-			targetState = predControl.DoOneStep(dt, currMessage, generatedPath, pR-&gt;m_LocalPlanner.state, currState, bNewPath);
-			pR-&gt;m_ControllingTime = UtilityH::GetTimeDiffNow(controlTimer);
-
-			//cout &lt;&lt; pR-&gt;m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;ToString(currMessage.state) &lt;&lt; endl;
-
-			pR-&gt;m_FollowPoint  = predControl.m_FollowMePoint.pos;
-			pR-&gt;m_PerpPoint    = predControl.m_PerpendicularPoint.pos;
-			pR-&gt;m_LateralError = predControl.m_LateralError;
-
-			//if(abs(pR-&gt;m_LateralError) &gt; 0.5)
-				totalLateralError = abs(pR-&gt;m_LateralError);
-
-//			cout &lt;&lt; "S D P  = " &lt;&lt; pR-&gt;m_ControlParams.SteeringDelayPercent
-//				 &lt;&lt; ", S D  = " &lt;&lt; pR-&gt;m_ControlParams.SteeringDelay
-//				 &lt;&lt; ", T D  = " &lt;&lt; timeDelay
-//				 &lt;&lt; ", L E  = " &lt;&lt; pR-&gt;m_LateralError
-//				 &lt;&lt; ", T E  = " &lt;&lt; totalLateralError
-//				 &lt;&lt; ", K P " &lt;&lt; pR-&gt;m_ControlParams.Steering_Gain.kP
-//				 &lt;&lt; ", K I " &lt;&lt; pR-&gt;m_ControlParams.Steering_Gain.kI &lt;&lt; endl;
-
-
-//			if(totalLateralError &gt;= 3.0)
-//			{
-//				break;
-//			}
-
-			pthread_mutex_lock(&amp;pR-&gt;control_mutex);
-			pR-&gt;m_VehicleTargetState = targetState;
-			pthread_mutex_unlock(&amp;pR-&gt;control_mutex);
-#endif
-		}
-	}
-
-//	if(totalLateralError &gt;= 3.0)
-//	{
-//		pR-&gt;LoadSimulationData();
-//		totalLateralError = 0;
-//		//pR-&gt;m_ControlParams.Steering_Gain.kP += 0.5;
-//		//pR-&gt;m_ControlParams.Steering_Gain.kD-=0.001;
-//		//pR-&gt;m_ControlParams.SteeringDelayPercent+=1.0;
-//	}
-
-	return 0;
-}
-
-void* PlannerTestDraw::SimulationThreadStaticEntryPoint(void* pThis)
-{
-	PlannerTestDraw* pR = (PlannerTestDraw*)pThis;
-	struct timespec moveTimer;
-	UtilityH::GetTickCount(moveTimer);
-	vector&lt;string&gt; logData;
-	PlannerHNS::PlannerH planner;
-	std::vector&lt;PlannerHNS::DetectedObject&gt; dummyObstacles;
-
-
-	while(!pR-&gt;m_bCancelThread)
-	{
-		double time_elapsed  = UtilityH::GetTimeDiffNow(moveTimer);
-
-		if(time_elapsed &gt;= 0.05)
-		{
-			double dt = 0.05;
-			UtilityH::GetTickCount(moveTimer);
-
-#ifdef EnableThreadBody
-			PlannerHNS::BehaviorState currMessage = pR-&gt;m_CurrentBehavior;
-
-			if(currMessage.state != PlannerHNS::INITIAL_STATE &amp;&amp; currMessage.state != PlannerHNS::WAITING_STATE)
-			{
-				pthread_mutex_lock(&amp;pR-&gt;simulation_mutex);
-				for(unsigned int i = 0 ; i &lt; pR-&gt;m_SimulatedCars.size(); i++)
-				{
-					pR-&gt;m_SimulatedBehaviors.at(i) = pR-&gt;m_SimulatedCars.at(i).DoOneStep(
-							dt, pR-&gt;m_SimulatedVehicleState.at(i),
-							pR-&gt;m_SimulatedCars.at(i).state,
-							PlannerHNS::GPSPoint(), pR-&gt;m_RoadMap);
-
-					if(pR-&gt;m_SimulatedCars.at(i).m_Path.size() == 0)
-					{
-						pR-&gt;m_SimulatedCars.erase(pR-&gt;m_SimulatedCars.begin()+i);
-						pR-&gt;m_SimulatedBehaviors.erase(pR-&gt;m_SimulatedBehaviors.begin()+i);
-						pR-&gt;m_SimulatedVehicleState.erase(pR-&gt;m_SimulatedVehicleState.begin()+i);
-						pR-&gt;m_SimulatedPrevTrajectory.erase(pR-&gt;m_SimulatedPrevTrajectory.begin()+i);
-						pR-&gt;m_SimulatedPathFollower.erase(pR-&gt;m_SimulatedPathFollower.begin()+i);
-						i--;
-						continue;
-					}
-
-					bool bNewPath = false;
-					if(PlannerHNS::PlanningHelpers::CompareTrajectories(pR-&gt;m_SimulatedPrevTrajectory.at(i), pR-&gt;m_SimulatedCars.at(i).m_Path) == false &amp;&amp; pR-&gt;m_SimulatedCars.at(i).m_Path.size()&gt;0)
-					{
-						pR-&gt;m_SimulatedPrevTrajectory.at(i) = pR-&gt;m_SimulatedCars.at(i).m_Path;
-
-						bNewPath = true;
-						cout &lt;&lt; "Path is Updated in the controller .. " &lt;&lt; pR-&gt;m_SimulatedCars.at(i).m_Path.size() &lt;&lt; endl;
-					}
-
-					PlannerHNS::VehicleState currState;
-					currState.steer = pR-&gt;m_SimulatedCars.at(i).m_CurrentSteering;
-					currState.speed = pR-&gt;m_SimulatedCars.at(i).m_CurrentVelocity;
-					currState.shift = PlannerHNS::SHIFT_POS_DD;
-
-					pR-&gt;m_SimulatedVehicleState.at(i) = pR-&gt;m_SimulatedPathFollower.at(i).DoOneStep(dt, pR-&gt;m_SimulatedBehaviors.at(i), pR-&gt;m_SimulatedPrevTrajectory.at(i),
-							pR-&gt;m_SimulatedCars.at(i).state, currState, bNewPath);
-					//pR-&gt;m_SimulatedCars.at(i).state.v = pR-&gt;m_SimulatedVehicleState.at(i).speed;
-				}
-				pthread_mutex_unlock(&amp;pR-&gt;simulation_mutex);
-			}
-			pR-&gt;m_SimulationTime = UtilityH::GetTimeDiffNow(moveTimer);
-#endif
-		}
-	}
-
-	return 0;
-}
-
-
-void* PlannerTestDraw::GameWheelThreadStaticEntryPoint(void* pThis)
-{
-
-	PlannerTestDraw* pR = (PlannerTestDraw*)pThis;
-	/*jsJoystick* pWheel = new jsJoystick(0);
-	int nAxis = pWheel-&gt;getNumAxes();
-	float* pAxis = new float[nAxis];
-	int nButtons = pWheel-&gt;getNumButtons();
-	int* pButtons = new int[nButtons];
-
-	cout &lt;&lt; "Axis Number: " &lt;&lt; nAxis &lt;&lt; endl;
-
-	while(!pR-&gt;m_bCancelThread)
-	{
-		pWheel-&gt;read(pButtons, pAxis);
-
-		if(pButtons[BUTTON_INDEX] == START_BUTTON_VALUE)
-			cout &lt;&lt; "Start Button Value: " &lt;&lt; 1 &lt;&lt; endl;
-		else
-			cout &lt;&lt; "Start Button Value: " &lt;&lt; 0 &lt;&lt; endl;
-
-		cout &lt;&lt; "Steering Axis Value: " &lt;&lt; -pAxis[STEERING_AXIS] &lt;&lt; endl;
-		cout &lt;&lt; "Acceleration Axis Value: " &lt;&lt; 1 - pAxis[ACCELERATION_AXIS] &lt;&lt; endl;
-		cout &lt;&lt; "Braking Axis Value: " &lt;&lt; 1 - pAxis[BRAKE_AXIS] &lt;&lt; endl;
-
-		pR-&gt;m_SteeringAngle = -pAxis[STEERING_AXIS];
-		pR-&gt;m_Acceleration = 1 - pAxis[ACCELERATION_AXIS];
-		pR-&gt;m_Braking = 1 - pAxis[BRAKE_AXIS];
-
-		pthread_mutex_lock(&amp;pR-&gt;control_mutex);
-		if(pR-&gt;m_Acceleration &gt; 0)
-			pR-&gt;m_VehicleTargetState.shift = PlannerHNS::SHIFT_POS_DD;
-		pR-&gt;m_VehicleTargetState.speed = pR-&gt;m_LocalPlanner.m_CarInfo.max_speed_forward * pR-&gt;m_Acceleration;
-
-		if(pR-&gt;m_Braking &gt; 0)
-			pR-&gt;m_VehicleTargetState.speed = 0;
-
-		pR-&gt;m_VehicleTargetState.steer = pR-&gt;m_SteeringAngle*pR-&gt;m_LocalPlanner.m_CarInfo.max_steer_angle;
-
-		pthread_mutex_unlock(&amp;pR-&gt;control_mutex);
-
-		usleep(10000);
-	}
-
-	delete [] pAxis;
-	delete [] pButtons;
-	delete pWheel;
-
-	cout &lt;&lt; "Exit Game Wheel Loop." &lt;&lt; endl;
-	*/
-	return pR;
-}
-
-} /* namespace Graphics */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\SimpleTracker.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\SimpleTracker.cpp" added_lines="4" deleted_lines="6">
				<diff>@@ -1,9 +1,7 @@
-/*
- * SimpleTracker.cpp
- *
- *  Created on: Aug 11, 2016
- *      Author: hatem
- */
+/// \file SimpleTracker.cpp
+/// \brief Kalman Filter based object tracker
+/// \author Hatem Darweesh
+/// \date Aug 11, 2016
 
 #include "op_simu/SimpleTracker.h"
 #include "op_planner/MatrixOperations.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\TrajectoryFollower.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\TrajectoryFollower.cpp" added_lines="4" deleted_lines="9">
				<diff>@@ -1,9 +1,7 @@
-/*
- * TrajectoryFollower.cpp
- *
- *  Created on: Jun 18, 2016
- *      Author: hatem
- */
+/// \file TrajectoryFollower.cpp
+/// \brief PID based trajectory follower
+/// \author Hatem Darweesh
+/// \date Jun 18, 2016
 
 #include "op_simu/TrajectoryFollower.h"
 #include "op_planner/PlanningHelpers.h"
@@ -287,9 +285,6 @@ int TrajectoryFollower::VeclocityControllerUpdate(const double&amp; dt, const Planne
 		desiredVelocity = m_VehicleInfo.max_speed_forward;
 	else if (desiredVelocity &lt; 0)
 		desiredVelocity = 0;
-	//desiredVelocity = 2.0;
-
-
 
 	desiredShift = PlannerHNS::SHIFT_POS_DD;
 	if(m_bEnableLog)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\glm.cpp" new_path="" added_lines="0" deleted_lines="1925">
				<diff>@@ -1,1925 +0,0 @@
-/*    
-      glm.c
-      Nate Robins, 1997, 2000
-      nate@pobox.com, http://www.pobox.com/~nate
- 
-      Wavefront OBJ model file format reader/writer/manipulator.
-
-      Includes routines for generating smooth normals with
-      preservation of edges, welding redundant vertices &amp; texture
-      coordinate generation (spheremap and planar projections) + more.
-  
-*/
-
-
-#include &lt;math.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;assert.h&gt;
-#include "op_simu/glm.h"
-
-namespace Graphics
-{
-
-#define T(x) (model-&gt;triangles[(x)])
-
-
-
-/* _GLMnode: general purpose node */
-typedef struct _GLMnode {
-    GLuint index;
-    GLboolean averaged;
-    struct _GLMnode* next;
-} GLMnode;
-
-
-/* glmMax: returns the maximum of two floats */
-static GLfloat
-glmMax(GLfloat a, GLfloat b) 
-{
-    if (b &gt; a)
-        return b;
-    return a;
-}
-
-/* glmAbs: returns the absolute value of a float */
-static GLfloat
-glmAbs(GLfloat f)
-{
-    if (f &lt; 0)
-        return -f;
-    return f;
-}
-
-/* glmDot: compute the dot product of two vectors
- *
- * u - array of 3 GLfloats (GLfloat u[3])
- * v - array of 3 GLfloats (GLfloat v[3])
- */
-static GLfloat
-glmDot(GLfloat* u, GLfloat* v)
-{
-    assert(u); assert(v);
-    
-    return u[0]*v[0] + u[1]*v[1] + u[2]*v[2];
-}
-
-/* glmCross: compute the cross product of two vectors
- *
- * u - array of 3 GLfloats (GLfloat u[3])
- * v - array of 3 GLfloats (GLfloat v[3])
- * n - array of 3 GLfloats (GLfloat n[3]) to return the cross product in
- */
-static GLvoid
-glmCross(GLfloat* u, GLfloat* v, GLfloat* n)
-{
-    assert(u); assert(v); assert(n);
-    
-    n[0] = u[1]*v[2] - u[2]*v[1];
-    n[1] = u[2]*v[0] - u[0]*v[2];
-    n[2] = u[0]*v[1] - u[1]*v[0];
-}
-
-/* glmNormalize: normalize a vector
- *
- * v - array of 3 GLfloats (GLfloat v[3]) to be normalized
- */
-static GLvoid
-glmNormalize(GLfloat* v)
-{
-    GLfloat l;
-    
-    assert(v);
-    
-    l = (GLfloat)sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
-    v[0] /= l;
-    v[1] /= l;
-    v[2] /= l;
-}
-
-/* glmEqual: compares two vectors and returns GL_TRUE if they are
- * equal (within a certain threshold) or GL_FALSE if not. An epsilon
- * that works fairly well is 0.000001.
- *
- * u - array of 3 GLfloats (GLfloat u[3])
- * v - array of 3 GLfloats (GLfloat v[3]) 
- */
-static GLboolean
-glmEqual(GLfloat* u, GLfloat* v, GLfloat epsilon)
-{
-    if (glmAbs(u[0] - v[0]) &lt; epsilon &amp;&amp;
-        glmAbs(u[1] - v[1]) &lt; epsilon &amp;&amp;
-        glmAbs(u[2] - v[2]) &lt; epsilon) 
-    {
-        return GL_TRUE;
-    }
-    return GL_FALSE;
-}
-
-/* glmWeldVectors: eliminate (weld) vectors that are within an
- * epsilon of each other.
- *
- * vectors     - array of GLfloat[3]'s to be welded
- * numvectors - number of GLfloat[3]'s in vectors
- * epsilon     - maximum difference between vectors 
- *
- */
-GLfloat*
-glmWeldVectors(GLfloat* vectors, GLuint* numvectors, GLfloat epsilon)
-{
-    GLfloat* copies;
-    GLuint copied;
-    GLuint i, j;
-    
-    copies = (GLfloat*)malloc(sizeof(GLfloat) * 3 * (*numvectors + 1));
-    memcpy(copies, vectors, (sizeof(GLfloat) * 3 * (*numvectors + 1)));
-    
-    copied = 1;
-    for (i = 1; i &lt;= *numvectors; i++) {
-        for (j = 1; j &lt;= copied; j++) {
-            if (glmEqual(&amp;vectors[3 * i], &amp;copies[3 * j], epsilon)) {
-                goto duplicate;
-            }
-        }
-        
-        /* must not be any duplicates -- add to the copies array */
-        copies[3 * copied + 0] = vectors[3 * i + 0];
-        copies[3 * copied + 1] = vectors[3 * i + 1];
-        copies[3 * copied + 2] = vectors[3 * i + 2];
-        j = copied;             /* pass this along for below */
-        copied++;
-        
-duplicate:
-        /* set the first component of this vector to point at the correct
-        index into the new copies array */
-        vectors[3 * i + 0] = (GLfloat)j;
-    }
-    
-    *numvectors = copied-1;
-    return copies;
-}
-
-/* glmFindGroup: Find a group in the model */
-GLMgroup*
-glmFindGroup(GLMmodel* model, char* name)
-{
-    GLMgroup* group;
-    
-    assert(model);
-    
-    group = model-&gt;groups;
-    while(group) {
-        if (!strcmp(name, group-&gt;name))
-            break;
-        group = group-&gt;next;
-    }
-    
-    return group;
-}
-
-/* glmAddGroup: Add a group to the model */
-GLMgroup*
-glmAddGroup(GLMmodel* model, char* name)
-{
-    GLMgroup* group;
-    
-    group = glmFindGroup(model, name);
-    if (!group) {
-        group = (GLMgroup*)malloc(sizeof(GLMgroup));
-        group-&gt;name = strdup(name);
-        group-&gt;material = 0;
-        group-&gt;numtriangles = 0;
-        group-&gt;triangles = NULL;
-        group-&gt;next = model-&gt;groups;
-        model-&gt;groups = group;
-        model-&gt;numgroups++;
-    }
-    
-    return group;
-}
-
-/* glmFindGroup: Find a material in the model */
-GLuint
-glmFindMaterial(GLMmodel* model, char* name)
-{
-    GLuint i;
-    
-    /* XXX doing a linear search on a string key'd list is pretty lame,
-    but it works and is fast enough for now. */
-    for (i = 0; i &lt; model-&gt;nummaterials; i++) {
-        if (!strcmp(model-&gt;materials[i].name, name))
-            goto found;
-    }
-    
-    /* didn't find the name, so print a warning and return the default
-    material (0). */
-    printf("glmFindMaterial():  can't find material \"%s\".\n", name);
-    i = 0;
-    
-found:
-    return i;
-}
-
-
-/* glmDirName: return the directory given a path
- *
- * path - filesystem path
- *
- * NOTE: the return value should be free'd.
- */
-static char*
-glmDirName(char* path)
-{
-    char* dir;
-    char* s;
-    
-    dir = strdup(path);
-    
-    s = strrchr(dir, '/');
-    if (s)
-        s[1] = '\0';
-    else
-        dir[0] = '\0';
-    
-    return dir;
-}
-
-
-/* glmReadMTL: read a wavefront material library file
- *
- * model - properly initialized GLMmodel structure
- * name  - name of the material library
- */
-static GLvoid
-glmReadMTL(GLMmodel* model, char* name)
-{
-    FILE* file;
-    char* dir;
-    char* filename;
-    char buf[128];
-    GLuint nummaterials, i;
-    
-    dir = glmDirName(model-&gt;pathname);
-    filename = (char*)malloc(sizeof(char) * (strlen(dir) + strlen(name) + 1));
-    strcpy(filename, dir);
-    strcat(filename, name);
-    free(dir);
-    
-    file = fopen(filename, "r");
-    if (!file) {
-        fprintf(stderr, "glmReadMTL() failed: can't open material file \"%s\".\n",
-            filename);
-        exit(1);
-    }
-    free(filename);
-    
-    /* count the number of materials in the file */
-    nummaterials = 1;
-    while(fscanf(file, "%s", buf) != EOF) {
-        switch(buf[0]) {
-        case '#':               /* comment */
-            /* eat up rest of line */
-            fgets(buf, sizeof(buf), file);
-            break;
-        case 'n':               /* newmtl */
-            fgets(buf, sizeof(buf), file);
-            nummaterials++;
-            sscanf(buf, "%s %s", buf, buf);
-            break;
-        default:
-            /* eat up rest of line */
-            fgets(buf, sizeof(buf), file);
-            break;
-        }
-    }
-    
-    rewind(file);
-    
-    model-&gt;materials = (GLMmaterial*)malloc(sizeof(GLMmaterial) * nummaterials);
-    model-&gt;nummaterials = nummaterials;
-    
-    /* set the default material */
-    for (i = 0; i &lt; nummaterials; i++) {
-        model-&gt;materials[i].name = NULL;
-        model-&gt;materials[i].shininess = 65.0;
-        model-&gt;materials[i].diffuse[0] = 0.8;
-        model-&gt;materials[i].diffuse[1] = 0.8;
-        model-&gt;materials[i].diffuse[2] = 0.8;
-        model-&gt;materials[i].diffuse[3] = 1.0;
-        model-&gt;materials[i].ambient[0] = 0.2;
-        model-&gt;materials[i].ambient[1] = 0.2;
-        model-&gt;materials[i].ambient[2] = 0.2;
-        model-&gt;materials[i].ambient[3] = 1.0;
-        model-&gt;materials[i].specular[0] = 0.0;
-        model-&gt;materials[i].specular[1] = 0.0;
-        model-&gt;materials[i].specular[2] = 0.0;
-        model-&gt;materials[i].specular[3] = 1.0;
-    }
-    model-&gt;materials[0].name = strdup("default");
-    
-    /* now, read in the data */
-    nummaterials = 0;
-    while(fscanf(file, "%s", buf) != EOF) {
-        switch(buf[0]) {
-        case '#':               /* comment */
-            /* eat up rest of line */
-            fgets(buf, sizeof(buf), file);
-            break;
-        case 'n':               /* newmtl */
-            fgets(buf, sizeof(buf), file);
-            sscanf(buf, "%s %s", buf, buf);
-            nummaterials++;
-            model-&gt;materials[nummaterials].name = strdup(buf);
-            break;
-        case 'N':
-            fscanf(file, "%f", &amp;model-&gt;materials[nummaterials].shininess);
-            /* wavefront shininess is from [0, 1000], so scale for OpenGL */
-            model-&gt;materials[nummaterials].shininess /= 1000.0;
-            model-&gt;materials[nummaterials].shininess *= 128.0;
-            break;
-        case 'K':
-            switch(buf[1]) {
-            case 'd':
-                fscanf(file, "%f %f %f",
-                    &amp;model-&gt;materials[nummaterials].diffuse[0],
-                    &amp;model-&gt;materials[nummaterials].diffuse[1],
-                    &amp;model-&gt;materials[nummaterials].diffuse[2]);
-                break;
-            case 's':
-                fscanf(file, "%f %f %f",
-                    &amp;model-&gt;materials[nummaterials].specular[0],
-                    &amp;model-&gt;materials[nummaterials].specular[1],
-                    &amp;model-&gt;materials[nummaterials].specular[2]);
-                break;
-            case 'a':
-                fscanf(file, "%f %f %f",
-                    &amp;model-&gt;materials[nummaterials].ambient[0],
-                    &amp;model-&gt;materials[nummaterials].ambient[1],
-                    &amp;model-&gt;materials[nummaterials].ambient[2]);
-                break;
-            default:
-                /* eat up rest of line */
-                fgets(buf, sizeof(buf), file);
-                break;
-            }
-            break;
-            default:
-                /* eat up rest of line */
-                fgets(buf, sizeof(buf), file);
-                break;
-        }
-    }
-}
-
-/* glmWriteMTL: write a wavefront material library file
- *
- * model   - properly initialized GLMmodel structure
- * modelpath  - pathname of the model being written
- * mtllibname - name of the material library to be written
- */
-static GLvoid glmWriteMTL(GLMmodel* model, char* modelpath, char* mtllibname)
-{
-    FILE* file;
-    char* dir;
-    char* filename;
-    GLMmaterial* material;
-    GLuint i;
-    
-    dir = glmDirName(modelpath);
-    filename = (char*)malloc(sizeof(char) * (strlen(dir)+strlen(mtllibname)));
-    strcpy(filename, dir);
-    strcat(filename, mtllibname);
-    free(dir);
-    
-    /* open the file */
-    file = fopen(filename, "w");
-    if (!file) {
-        fprintf(stderr, "glmWriteMTL() failed: can't open file \"%s\".\n",
-            filename);
-        exit(1);
-    }
-  //  free(filename);
-    
-    /* spit out a header */
-    fprintf(file, "#  \n");
-    fprintf(file, "#  Wavefront MTL generated by GLM library\n");
-    fprintf(file, "#  \n");
-    fprintf(file, "#  GLM library\n");
-    fprintf(file, "#  Nate Robins\n");
-    fprintf(file, "#  ndr@pobox.com\n");
-    fprintf(file, "#  http://www.pobox.com/~ndr\n");
-    fprintf(file, "#  \n\n");
-    
-    for (i = 0; i &lt; model-&gt;nummaterials; i++) {
-        material = &amp;model-&gt;materials[i];
-        fprintf(file, "newmtl %s\n", material-&gt;name);
-        fprintf(file, "Ka %f %f %f\n", 
-            material-&gt;ambient[0], material-&gt;ambient[1], material-&gt;ambient[2]);
-        fprintf(file, "Kd %f %f %f\n", 
-            material-&gt;diffuse[0], material-&gt;diffuse[1], material-&gt;diffuse[2]);
-        fprintf(file, "Ks %f %f %f\n", 
-            material-&gt;specular[0],material-&gt;specular[1],material-&gt;specular[2]);
-        fprintf(file, "Ns %f\n", material-&gt;shininess / 128.0 * 1000.0);
-        fprintf(file, "\n");
-    }
-}
-
-
-/* glmFirstPass: first pass at a Wavefront OBJ file that gets all the
- * statistics of the model (such as #vertices, #normals, etc)
- *
- * model - properly initialized GLMmodel structure
- * file  - (fopen'd) file descriptor 
- */
-static GLvoid glmFirstPass(GLMmodel* model, FILE* file) 
-{
-    GLuint numvertices;        /* number of vertices in model */
-    GLuint numnormals;         /* number of normals in model */
-    GLuint numtexcoords;       /* number of texcoords in model */
-    GLuint numtriangles;       /* number of triangles in model */
-    GLMgroup* group;           /* current group */
-    int v, n, t;
-    char buf[128];
-    
-    /* make a default group */
-    group = glmAddGroup(model, (char*) "default");
-    
-    numvertices = numnormals = numtexcoords = numtriangles = 0;
-    while(fscanf(file, "%s", buf) != EOF) {
-        switch(buf[0]) {
-        case '#':               /* comment */
-            /* eat up rest of line */
-            fgets(buf, sizeof(buf), file);
-            break;
-        case 'v':               /* v, vn, vt */
-            switch(buf[1]) {
-            case '\0':          /* vertex */
-                /* eat up rest of line */
-                fgets(buf, sizeof(buf), file);
-                numvertices++;
-                break;
-            case 'n':           /* normal */
-                /* eat up rest of line */
-                fgets(buf, sizeof(buf), file);
-                numnormals++;
-                break;
-            case 't':           /* texcoord */
-                /* eat up rest of line */
-                fgets(buf, sizeof(buf), file);
-                numtexcoords++;
-                break;
-            default:
-                printf("glmFirstPass(): Unknown token \"%s\".\n", buf);
-                exit(1);
-                break;
-            }
-            break;
-            case 'm':
-                fgets(buf, sizeof(buf), file);
-                sscanf(buf, "%s %s", buf, buf);
-                model-&gt;mtllibname = strdup(buf);
-                glmReadMTL(model, buf);
-                break;
-            case 'u':
-                /* eat up rest of line */
-                fgets(buf, sizeof(buf), file);
-                break;
-            case 'g':               /* group */
-                /* eat up rest of line */
-                fgets(buf, sizeof(buf), file);
-#if SINGLE_STRING_GROUP_NAMES
-                sscanf(buf, "%s", buf);
-#else
-                buf[strlen(buf)-1] = '\0';  /* nuke '\n' */
-#endif
-                group = glmAddGroup(model, buf);
-                break;
-            case 'f':               /* face */
-                v = n = t = 0;
-                fscanf(file, "%s", buf);
-                /* can be one of %d, %d//%d, %d/%d, %d/%d/%d %d//%d */
-                if (strstr(buf, "//")) {
-                    /* v//n */
-                    sscanf(buf, "%d//%d", &amp;v, &amp;n);
-                    fscanf(file, "%d//%d", &amp;v, &amp;n);
-                    fscanf(file, "%d//%d", &amp;v, &amp;n);
-                    numtriangles++;
-                    group-&gt;numtriangles++;
-                    while(fscanf(file, "%d//%d", &amp;v, &amp;n) &gt; 0) {
-                        numtriangles++;
-                        group-&gt;numtriangles++;
-                    }
-                } else if (sscanf(buf, "%d/%d/%d", &amp;v, &amp;t, &amp;n) == 3) {
-                    /* v/t/n */
-                    fscanf(file, "%d/%d/%d", &amp;v, &amp;t, &amp;n);
-                    fscanf(file, "%d/%d/%d", &amp;v, &amp;t, &amp;n);
-                    numtriangles++;
-                    group-&gt;numtriangles++;
-                    while(fscanf(file, "%d/%d/%d", &amp;v, &amp;t, &amp;n) &gt; 0) {
-                        numtriangles++;
-                        group-&gt;numtriangles++;
-                    }
-                } else if (sscanf(buf, "%d/%d", &amp;v, &amp;t) == 2) {
-                    /* v/t */
-                    fscanf(file, "%d/%d", &amp;v, &amp;t);
-                    fscanf(file, "%d/%d", &amp;v, &amp;t);
-                    numtriangles++;
-                    group-&gt;numtriangles++;
-                    while(fscanf(file, "%d/%d", &amp;v, &amp;t) &gt; 0) {
-                        numtriangles++;
-                        group-&gt;numtriangles++;
-                    }
-                } else {
-                    /* v */
-                    fscanf(file, "%d", &amp;v);
-                    fscanf(file, "%d", &amp;v);
-                    numtriangles++;
-                    group-&gt;numtriangles++;
-                    while(fscanf(file, "%d", &amp;v) &gt; 0) {
-                        numtriangles++;
-                        group-&gt;numtriangles++;
-                    }
-                }
-                break;
-                
-            default:
-                /* eat up rest of line */
-                fgets(buf, sizeof(buf), file);
-                break;
-        }
-  }
-  
-  /* set the stats in the model structure */
-  model-&gt;numvertices  = numvertices;
-  model-&gt;numnormals   = numnormals;
-  model-&gt;numtexcoords = numtexcoords;
-  model-&gt;numtriangles = numtriangles;
-  
-  /* allocate memory for the triangles in each group */
-  group = model-&gt;groups;
-  while(group) {
-      group-&gt;triangles = (GLuint*)malloc(sizeof(GLuint) * group-&gt;numtriangles);
-      group-&gt;numtriangles = 0;
-      group = group-&gt;next;
-  }
-}
-
-/* glmSecondPass: second pass at a Wavefront OBJ file that gets all
- * the data.
- *
- * model - properly initialized GLMmodel structure
- * file  - (fopen'd) file descriptor 
- */
-static GLvoid
-glmSecondPass(GLMmodel* model, FILE* file) 
-{
-    GLuint numvertices;        /* number of vertices in model */
-    GLuint numnormals;         /* number of normals in model */
-    GLuint numtexcoords;       /* number of texcoords in model */
-    GLuint numtriangles;       /* number of triangles in model */
-    GLfloat* vertices;         /* array of vertices  */
-    GLfloat* normals;          /* array of normals */
-    GLfloat* texcoords;        /* array of texture coordinates */
-    GLMgroup* group;           /* current group pointer */
-    GLuint material;           /* current material */
-    int v, n, t;
-    char buf[128];
-    
-    /* set the pointer shortcuts */
-    vertices       = model-&gt;vertices;
-    normals    = model-&gt;normals;
-    texcoords    = model-&gt;texcoords;
-    group      = model-&gt;groups;
-    
-    /* on the second pass through the file, read all the data into the
-    allocated arrays */
-    numvertices = numnormals = numtexcoords = 1;
-    numtriangles = 0;
-    material = 0;
-    while(fscanf(file, "%s", buf) != EOF) {
-        switch(buf[0]) {
-        case '#':               /* comment */
-            /* eat up rest of line */
-            fgets(buf, sizeof(buf), file);
-            break;
-        case 'v':               /* v, vn, vt */
-            switch(buf[1]) {
-            case '\0':          /* vertex */
-                fscanf(file, "%f %f %f", 
-                    &amp;vertices[3 * numvertices + 0], 
-                    &amp;vertices[3 * numvertices + 1], 
-                    &amp;vertices[3 * numvertices + 2]);
-                numvertices++;
-                break;
-            case 'n':           /* normal */
-                fscanf(file, "%f %f %f", 
-                    &amp;normals[3 * numnormals + 0],
-                    &amp;normals[3 * numnormals + 1], 
-                    &amp;normals[3 * numnormals + 2]);
-                numnormals++;
-                break;
-            case 't':           /* texcoord */
-                fscanf(file, "%f %f", 
-                    &amp;texcoords[2 * numtexcoords + 0],
-                    &amp;texcoords[2 * numtexcoords + 1]);
-                numtexcoords++;
-                break;
-            }
-            break;
-            case 'u':
-                fgets(buf, sizeof(buf), file);
-                sscanf(buf, "%s %s", buf, buf);
-                group-&gt;material = material = glmFindMaterial(model, buf);
-                break;
-            case 'g':               /* group */
-                /* eat up rest of line */
-                fgets(buf, sizeof(buf), file);
-#if SINGLE_STRING_GROUP_NAMES
-                sscanf(buf, "%s", buf);
-#else
-                buf[strlen(buf)-1] = '\0';  /* nuke '\n' */
-#endif
-                group = glmFindGroup(model, buf);
-                group-&gt;material = material;
-                break;
-            case 'f':               /* face */
-                v = n = t = 0;
-                fscanf(file, "%s", buf);
-                /* can be one of %d, %d//%d, %d/%d, %d/%d/%d %d//%d */
-                if (strstr(buf, "//")) {
-                    /* v//n */
-                    sscanf(buf, "%d//%d", &amp;v, &amp;n);
-                    T(numtriangles).vindices[0] = v &lt; 0 ? v + numvertices : v;
-                    T(numtriangles).nindices[0] = n &lt; 0 ? n + numnormals : n;
-                    fscanf(file, "%d//%d", &amp;v, &amp;n);
-                    T(numtriangles).vindices[1] = v &lt; 0 ? v + numvertices : v;
-                    T(numtriangles).nindices[1] = n &lt; 0 ? n + numnormals : n;
-                    fscanf(file, "%d//%d", &amp;v, &amp;n);
-                    T(numtriangles).vindices[2] = v &lt; 0 ? v + numvertices : v;
-                    T(numtriangles).nindices[2] = n &lt; 0 ? n + numnormals : n;
-                    group-&gt;triangles[group-&gt;numtriangles++] = numtriangles;
-                    numtriangles++;
-                    while(fscanf(file, "%d//%d", &amp;v, &amp;n) &gt; 0) {
-                        T(numtriangles).vindices[0] = T(numtriangles-1).vindices[0];
-                        T(numtriangles).nindices[0] = T(numtriangles-1).nindices[0];
-                        T(numtriangles).vindices[1] = T(numtriangles-1).vindices[2];
-                        T(numtriangles).nindices[1] = T(numtriangles-1).nindices[2];
-                        T(numtriangles).vindices[2] = v &lt; 0 ? v + numvertices : v;
-                        T(numtriangles).nindices[2] = n &lt; 0 ? n + numnormals : n;
-                        group-&gt;triangles[group-&gt;numtriangles++] = numtriangles;
-                        numtriangles++;
-                    }
-                } else if (sscanf(buf, "%d/%d/%d", &amp;v, &amp;t, &amp;n) == 3) {
-                    /* v/t/n */
-                    T(numtriangles).vindices[0] = v &lt; 0 ? v + numvertices : v;
-                    T(numtriangles).tindices[0] = t &lt; 0 ? t + numtexcoords : t;
-                    T(numtriangles).nindices[0] = n &lt; 0 ? n + numnormals : n;
-                    fscanf(file, "%d/%d/%d", &amp;v, &amp;t, &amp;n);
-                    T(numtriangles).vindices[1] = v &lt; 0 ? v + numvertices : v;
-                    T(numtriangles).tindices[1] = t &lt; 0 ? t + numtexcoords : t;
-                    T(numtriangles).nindices[1] = n &lt; 0 ? n + numnormals : n;
-                    fscanf(file, "%d/%d/%d", &amp;v, &amp;t, &amp;n);
-                    T(numtriangles).vindices[2] = v &lt; 0 ? v + numvertices : v;
-                    T(numtriangles).tindices[2] = t &lt; 0 ? t + numtexcoords : t;
-                    T(numtriangles).nindices[2] = n &lt; 0 ? n + numnormals : n;
-                    group-&gt;triangles[group-&gt;numtriangles++] = numtriangles;
-                    numtriangles++;
-                    while(fscanf(file, "%d/%d/%d", &amp;v, &amp;t, &amp;n) &gt; 0) {
-                        T(numtriangles).vindices[0] = T(numtriangles-1).vindices[0];
-                        T(numtriangles).tindices[0] = T(numtriangles-1).tindices[0];
-                        T(numtriangles).nindices[0] = T(numtriangles-1).nindices[0];
-                        T(numtriangles).vindices[1] = T(numtriangles-1).vindices[2];
-                        T(numtriangles).tindices[1] = T(numtriangles-1).tindices[2];
-                        T(numtriangles).nindices[1] = T(numtriangles-1).nindices[2];
-                        T(numtriangles).vindices[2] = v &lt; 0 ? v + numvertices : v;
-                        T(numtriangles).tindices[2] = t &lt; 0 ? t + numtexcoords : t;
-                        T(numtriangles).nindices[2] = n &lt; 0 ? n + numnormals : n;
-                        group-&gt;triangles[group-&gt;numtriangles++] = numtriangles;
-                        numtriangles++;
-                    }
-                } else if (sscanf(buf, "%d/%d", &amp;v, &amp;t) == 2) {
-                    /* v/t */
-                    T(numtriangles).vindices[0] = v &lt; 0 ? v + numvertices : v;
-                    T(numtriangles).tindices[0] = t &lt; 0 ? t + numtexcoords : t;
-                    fscanf(file, "%d/%d", &amp;v, &amp;t);
-                    T(numtriangles).vindices[1] = v &lt; 0 ? v + numvertices : v;
-                    T(numtriangles).tindices[1] = t &lt; 0 ? t + numtexcoords : t;
-                    fscanf(file, "%d/%d", &amp;v, &amp;t);
-                    T(numtriangles).vindices[2] = v &lt; 0 ? v + numvertices : v;
-                    T(numtriangles).tindices[2] = t &lt; 0 ? t + numtexcoords : t;
-                    group-&gt;triangles[group-&gt;numtriangles++] = numtriangles;
-                    numtriangles++;
-                    while(fscanf(file, "%d/%d", &amp;v, &amp;t) &gt; 0) {
-                        T(numtriangles).vindices[0] = T(numtriangles-1).vindices[0];
-                        T(numtriangles).tindices[0] = T(numtriangles-1).tindices[0];
-                        T(numtriangles).vindices[1] = T(numtriangles-1).vindices[2];
-                        T(numtriangles).tindices[1] = T(numtriangles-1).tindices[2];
-                        T(numtriangles).vindices[2] = v &lt; 0 ? v + numvertices : v;
-                        T(numtriangles).tindices[2] = t &lt; 0 ? t + numtexcoords : t;
-                        group-&gt;triangles[group-&gt;numtriangles++] = numtriangles;
-                        numtriangles++;
-                    }
-                } else {
-                    /* v */
-                    sscanf(buf, "%d", &amp;v);
-                    T(numtriangles).vindices[0] = v &lt; 0 ? v + numvertices : v;
-                    fscanf(file, "%d", &amp;v);
-                    T(numtriangles).vindices[1] = v &lt; 0 ? v + numvertices : v;
-                    fscanf(file, "%d", &amp;v);
-                    T(numtriangles).vindices[2] = v &lt; 0 ? v + numvertices : v;
-                    group-&gt;triangles[group-&gt;numtriangles++] = numtriangles;
-                    numtriangles++;
-                    while(fscanf(file, "%d", &amp;v) &gt; 0) {
-                        T(numtriangles).vindices[0] = T(numtriangles-1).vindices[0];
-                        T(numtriangles).vindices[1] = T(numtriangles-1).vindices[2];
-                        T(numtriangles).vindices[2] = v &lt; 0 ? v + numvertices : v;
-                        group-&gt;triangles[group-&gt;numtriangles++] = numtriangles;
-                        numtriangles++;
-                    }
-                }
-                break;
-                
-            default:
-                /* eat up rest of line */
-                fgets(buf, sizeof(buf), file);
-                break;
-    }
-  }
-  
-#if 0
-  /* announce the memory requirements */
-  printf(" Memory: %d bytes\n",
-      numvertices  * 3*sizeof(GLfloat) +
-      numnormals   * 3*sizeof(GLfloat) * (numnormals ? 1 : 0) +
-      numtexcoords * 3*sizeof(GLfloat) * (numtexcoords ? 1 : 0) +
-      numtriangles * sizeof(GLMtriangle));
-#endif
-}
-
-
-/* public functions */
-
-
-/* glmUnitize: "unitize" a model by translating it to the origin and
- * scaling it to fit in a unit cube around the origin.   Returns the
- * scalefactor used.
- *
- * model - properly initialized GLMmodel structure 
- */
-GLfloat
-glmUnitize(GLMmodel* model)
-{
-    GLuint i;
-    GLfloat maxx, minx, maxy, miny, maxz, minz;
-    GLfloat cx, cy, cz, w, h, d;
-    GLfloat scale;
-    
-    assert(model);
-    assert(model-&gt;vertices);
-    
-    /* get the max/mins */
-    maxx = minx = model-&gt;vertices[3 + 0];
-    maxy = miny = model-&gt;vertices[3 + 1];
-    maxz = minz = model-&gt;vertices[3 + 2];
-    for (i = 1; i &lt;= model-&gt;numvertices; i++) {
-        if (maxx &lt; model-&gt;vertices[3 * i + 0])
-            maxx = model-&gt;vertices[3 * i + 0];
-        if (minx &gt; model-&gt;vertices[3 * i + 0])
-            minx = model-&gt;vertices[3 * i + 0];
-        
-        if (maxy &lt; model-&gt;vertices[3 * i + 1])
-            maxy = model-&gt;vertices[3 * i + 1];
-        if (miny &gt; model-&gt;vertices[3 * i + 1])
-            miny = model-&gt;vertices[3 * i + 1];
-        
-        if (maxz &lt; model-&gt;vertices[3 * i + 2])
-            maxz = model-&gt;vertices[3 * i + 2];
-        if (minz &gt; model-&gt;vertices[3 * i + 2])
-            minz = model-&gt;vertices[3 * i + 2];
-    }
-    
-    /* calculate model width, height, and depth */
-    w = glmAbs(maxx) + glmAbs(minx);
-    h = glmAbs(maxy) + glmAbs(miny);
-    d = glmAbs(maxz) + glmAbs(minz);
-    
-    /* calculate center of the model */
-    cx = (maxx + minx) / 2.0;
-    cy = (maxy + miny) / 2.0;
-    cz = (maxz + minz) / 2.0;
-    
-    /* calculate unitizing scale factor */
-    scale = 2.0 / glmMax(glmMax(w, h), d);
-    
-    /* translate around center then scale */
-    for (i = 1; i &lt;= model-&gt;numvertices; i++) {
-        model-&gt;vertices[3 * i + 0] -= cx;
-        model-&gt;vertices[3 * i + 1] -= cy;
-        model-&gt;vertices[3 * i + 2] -= cz;
-        model-&gt;vertices[3 * i + 0] *= scale;
-        model-&gt;vertices[3 * i + 1] *= scale;
-        model-&gt;vertices[3 * i + 2] *= scale;
-    }
-    
-    return scale;
-}
-
-/* glmDimensions: Calculates the dimensions (width, height, depth) of
- * a model.
- *
- * model   - initialized GLMmodel structure
- * dimensions - array of 3 GLfloats (GLfloat dimensions[3])
- */
-GLvoid
-glmDimensions(GLMmodel* model, GLfloat* dimensions)
-{
-    GLuint i;
-    GLfloat maxx, minx, maxy, miny, maxz, minz;
-    
-    assert(model);
-    assert(model-&gt;vertices);
-    assert(dimensions);
-    
-    /* get the max/mins */
-    maxx = minx = model-&gt;vertices[3 + 0];
-    maxy = miny = model-&gt;vertices[3 + 1];
-    maxz = minz = model-&gt;vertices[3 + 2];
-    for (i = 1; i &lt;= model-&gt;numvertices; i++) {
-        if (maxx &lt; model-&gt;vertices[3 * i + 0])
-            maxx = model-&gt;vertices[3 * i + 0];
-        if (minx &gt; model-&gt;vertices[3 * i + 0])
-            minx = model-&gt;vertices[3 * i + 0];
-        
-        if (maxy &lt; model-&gt;vertices[3 * i + 1])
-            maxy = model-&gt;vertices[3 * i + 1];
-        if (miny &gt; model-&gt;vertices[3 * i + 1])
-            miny = model-&gt;vertices[3 * i + 1];
-        
-        if (maxz &lt; model-&gt;vertices[3 * i + 2])
-            maxz = model-&gt;vertices[3 * i + 2];
-        if (minz &gt; model-&gt;vertices[3 * i + 2])
-            minz = model-&gt;vertices[3 * i + 2];
-    }
-    
-    /* calculate model width, height, and depth */
-    dimensions[0] = glmAbs(maxx) + glmAbs(minx);
-    dimensions[1] = glmAbs(maxy) + glmAbs(miny);
-    dimensions[2] = glmAbs(maxz) + glmAbs(minz);
-}
-
-/* glmScale: Scales a model by a given amount.
- * 
- * model - properly initialized GLMmodel structure
- * scale - scalefactor (0.5 = half as large, 2.0 = twice as large)
- */
-GLvoid
-glmScale(GLMmodel* model, GLfloat scale)
-{
-    GLuint i;
-    
-    for (i = 1; i &lt;= model-&gt;numvertices; i++) {
-        model-&gt;vertices[3 * i + 0] *= scale;
-        model-&gt;vertices[3 * i + 1] *= scale;
-        model-&gt;vertices[3 * i + 2] *= scale;
-    }
-}
-
-/* glmReverseWinding: Reverse the polygon winding for all polygons in
- * this model.   Default winding is counter-clockwise.  Also changes
- * the direction of the normals.
- * 
- * model - properly initialized GLMmodel structure 
- */
-GLvoid
-glmReverseWinding(GLMmodel* model)
-{
-    GLuint i, swap;
-    
-    assert(model);
-    
-    for (i = 0; i &lt; model-&gt;numtriangles; i++) {
-        swap = T(i).vindices[0];
-        T(i).vindices[0] = T(i).vindices[2];
-        T(i).vindices[2] = swap;
-        
-        if (model-&gt;numnormals) {
-            swap = T(i).nindices[0];
-            T(i).nindices[0] = T(i).nindices[2];
-            T(i).nindices[2] = swap;
-        }
-        
-        if (model-&gt;numtexcoords) {
-            swap = T(i).tindices[0];
-            T(i).tindices[0] = T(i).tindices[2];
-            T(i).tindices[2] = swap;
-        }
-    }
-    
-    /* reverse facet normals */
-    for (i = 1; i &lt;= model-&gt;numfacetnorms; i++) {
-        model-&gt;facetnorms[3 * i + 0] = -model-&gt;facetnorms[3 * i + 0];
-        model-&gt;facetnorms[3 * i + 1] = -model-&gt;facetnorms[3 * i + 1];
-        model-&gt;facetnorms[3 * i + 2] = -model-&gt;facetnorms[3 * i + 2];
-    }
-    
-    /* reverse vertex normals */
-    for (i = 1; i &lt;= model-&gt;numnormals; i++) {
-        model-&gt;normals[3 * i + 0] = -model-&gt;normals[3 * i + 0];
-        model-&gt;normals[3 * i + 1] = -model-&gt;normals[3 * i + 1];
-        model-&gt;normals[3 * i + 2] = -model-&gt;normals[3 * i + 2];
-    }
-}
-
-/* glmFacetNormals: Generates facet normals for a model (by taking the
- * cross product of the two vectors derived from the sides of each
- * triangle).  Assumes a counter-clockwise winding.
- *
- * model - initialized GLMmodel structure
- */
-GLvoid
-glmFacetNormals(GLMmodel* model)
-{
-    GLuint  i;
-    GLfloat u[3];
-    GLfloat v[3];
-    
-    assert(model);
-    assert(model-&gt;vertices);
-    
-    /* clobber any old facetnormals */
-    if (model-&gt;facetnorms)
-        free(model-&gt;facetnorms);
-    
-    /* allocate memory for the new facet normals */
-    model-&gt;numfacetnorms = model-&gt;numtriangles;
-    model-&gt;facetnorms = (GLfloat*)malloc(sizeof(GLfloat) *
-                       3 * (model-&gt;numfacetnorms + 1));
-    
-    for (i = 0; i &lt; model-&gt;numtriangles; i++) {
-        model-&gt;triangles[i].findex = i+1;
-        
-        u[0] = model-&gt;vertices[3 * T(i).vindices[1] + 0] -
-            model-&gt;vertices[3 * T(i).vindices[0] + 0];
-        u[1] = model-&gt;vertices[3 * T(i).vindices[1] + 1] -
-            model-&gt;vertices[3 * T(i).vindices[0] + 1];
-        u[2] = model-&gt;vertices[3 * T(i).vindices[1] + 2] -
-            model-&gt;vertices[3 * T(i).vindices[0] + 2];
-        
-        v[0] = model-&gt;vertices[3 * T(i).vindices[2] + 0] -
-            model-&gt;vertices[3 * T(i).vindices[0] + 0];
-        v[1] = model-&gt;vertices[3 * T(i).vindices[2] + 1] -
-            model-&gt;vertices[3 * T(i).vindices[0] + 1];
-        v[2] = model-&gt;vertices[3 * T(i).vindices[2] + 2] -
-            model-&gt;vertices[3 * T(i).vindices[0] + 2];
-        
-        glmCross(u, v, &amp;model-&gt;facetnorms[3 * (i+1)]);
-        glmNormalize(&amp;model-&gt;facetnorms[3 * (i+1)]);
-    }
-}
-
-/* glmVertexNormals: Generates smooth vertex normals for a model.
- * First builds a list of all the triangles each vertex is in.   Then
- * loops through each vertex in the the list averaging all the facet
- * normals of the triangles each vertex is in.   Finally, sets the
- * normal index in the triangle for the vertex to the generated smooth
- * normal.   If the dot product of a facet normal and the facet normal
- * associated with the first triangle in the list of triangles the
- * current vertex is in is greater than the cosine of the angle
- * parameter to the function, that facet normal is not added into the
- * average normal calculation and the corresponding vertex is given
- * the facet normal.  This tends to preserve hard edges.  The angle to
- * use depends on the model, but 90 degrees is usually a good start.
- *
- * model - initialized GLMmodel structure
- * angle - maximum angle (in degrees) to smooth across
- */
-GLvoid
-glmVertexNormals(GLMmodel* model, GLfloat angle)
-{
-    GLMnode* node;
-    GLMnode* tail;
-    GLMnode** members;
-    GLfloat* normals;
-    GLuint numnormals;
-    GLfloat average[3];
-    GLfloat dot, cos_angle;
-    GLuint i, avg;
-    
-    assert(model);
-    assert(model-&gt;facetnorms);
-    
-    /* calculate the cosine of the angle (in degrees) */
-    cos_angle = cos(angle * M_PI / 180.0);
-    
-    /* nuke any previous normals */
-    if (model-&gt;normals)
-        free(model-&gt;normals);
-    
-    /* allocate space for new normals */
-    model-&gt;numnormals = model-&gt;numtriangles * 3; /* 3 normals per triangle */
-    model-&gt;normals = (GLfloat*)malloc(sizeof(GLfloat)* 3* (model-&gt;numnormals+1));
-    
-    /* allocate a structure that will hold a linked list of triangle
-    indices for each vertex */
-    members = (GLMnode**)malloc(sizeof(GLMnode*) * (model-&gt;numvertices + 1));
-    for (i = 1; i &lt;= model-&gt;numvertices; i++)
-        members[i] = NULL;
-    
-    /* for every triangle, create a node for each vertex in it */
-    for (i = 0; i &lt; model-&gt;numtriangles; i++) {
-        node = (GLMnode*)malloc(sizeof(GLMnode));
-        node-&gt;index = i;
-        node-&gt;next  = members[T(i).vindices[0]];
-        members[T(i).vindices[0]] = node;
-        
-        node = (GLMnode*)malloc(sizeof(GLMnode));
-        node-&gt;index = i;
-        node-&gt;next  = members[T(i).vindices[1]];
-        members[T(i).vindices[1]] = node;
-        
-        node = (GLMnode*)malloc(sizeof(GLMnode));
-        node-&gt;index = i;
-        node-&gt;next  = members[T(i).vindices[2]];
-        members[T(i).vindices[2]] = node;
-    }
-    
-    /* calculate the average normal for each vertex */
-    numnormals = 1;
-    for (i = 1; i &lt;= model-&gt;numvertices; i++) {
-    /* calculate an average normal for this vertex by averaging the
-        facet normal of every triangle this vertex is in */
-        node = members[i];
-        if (!node)
-            fprintf(stderr, "glmVertexNormals(): vertex w/o a triangle\n");
-        average[0] = 0.0; average[1] = 0.0; average[2] = 0.0;
-        avg = 0;
-        while (node) {
-        /* only average if the dot product of the angle between the two
-        facet normals is greater than the cosine of the threshold
-        angle -- or, said another way, the angle between the two
-            facet normals is less than (or equal to) the threshold angle */
-            dot = glmDot(&amp;model-&gt;facetnorms[3 * T(node-&gt;index).findex],
-                &amp;model-&gt;facetnorms[3 * T(members[i]-&gt;index).findex]);
-            if (dot &gt; cos_angle) {
-                node-&gt;averaged = GL_TRUE;
-                average[0] += model-&gt;facetnorms[3 * T(node-&gt;index).findex + 0];
-                average[1] += model-&gt;facetnorms[3 * T(node-&gt;index).findex + 1];
-                average[2] += model-&gt;facetnorms[3 * T(node-&gt;index).findex + 2];
-                avg = 1;            /* we averaged at least one normal! */
-            } else {
-                node-&gt;averaged = GL_FALSE;
-            }
-            node = node-&gt;next;
-        }
-        
-        if (avg) {
-            /* normalize the averaged normal */
-            glmNormalize(average);
-            
-            /* add the normal to the vertex normals list */
-            model-&gt;normals[3 * numnormals + 0] = average[0];
-            model-&gt;normals[3 * numnormals + 1] = average[1];
-            model-&gt;normals[3 * numnormals + 2] = average[2];
-            avg = numnormals;
-            numnormals++;
-        }
-        
-        /* set the normal of this vertex in each triangle it is in */
-        node = members[i];
-        while (node) {
-            if (node-&gt;averaged) {
-                /* if this node was averaged, use the average normal */
-                if (T(node-&gt;index).vindices[0] == i)
-                    T(node-&gt;index).nindices[0] = avg;
-                else if (T(node-&gt;index).vindices[1] == i)
-                    T(node-&gt;index).nindices[1] = avg;
-                else if (T(node-&gt;index).vindices[2] == i)
-                    T(node-&gt;index).nindices[2] = avg;
-            } else {
-                /* if this node wasn't averaged, use the facet normal */
-                model-&gt;normals[3 * numnormals + 0] = 
-                    model-&gt;facetnorms[3 * T(node-&gt;index).findex + 0];
-                model-&gt;normals[3 * numnormals + 1] = 
-                    model-&gt;facetnorms[3 * T(node-&gt;index).findex + 1];
-                model-&gt;normals[3 * numnormals + 2] = 
-                    model-&gt;facetnorms[3 * T(node-&gt;index).findex + 2];
-                if (T(node-&gt;index).vindices[0] == i)
-                    T(node-&gt;index).nindices[0] = numnormals;
-                else if (T(node-&gt;index).vindices[1] == i)
-                    T(node-&gt;index).nindices[1] = numnormals;
-                else if (T(node-&gt;index).vindices[2] == i)
-                    T(node-&gt;index).nindices[2] = numnormals;
-                numnormals++;
-            }
-            node = node-&gt;next;
-        }
-    }
-    
-    model-&gt;numnormals = numnormals - 1;
-    
-    /* free the member information */
-    for (i = 1; i &lt;= model-&gt;numvertices; i++) {
-        node = members[i];
-        while (node) {
-            tail = node;
-            node = node-&gt;next;
-            free(tail);
-        }
-    }
-    free(members);
-    
-    /* pack the normals array (we previously allocated the maximum
-    number of normals that could possibly be created (numtriangles *
-    3), so get rid of some of them (usually alot unless none of the
-    facet normals were averaged)) */
-    normals = model-&gt;normals;
-    model-&gt;normals = (GLfloat*)malloc(sizeof(GLfloat)* 3* (model-&gt;numnormals+1));
-    for (i = 1; i &lt;= model-&gt;numnormals; i++) {
-        model-&gt;normals[3 * i + 0] = normals[3 * i + 0];
-        model-&gt;normals[3 * i + 1] = normals[3 * i + 1];
-        model-&gt;normals[3 * i + 2] = normals[3 * i + 2];
-    }
-    free(normals);
-}
-
-
-/* glmLinearTexture: Generates texture coordinates according to a
- * linear projection of the texture map.  It generates these by
- * linearly mapping the vertices onto a square.
- *
- * model - pointer to initialized GLMmodel structure
- */
-GLvoid
-glmLinearTexture(GLMmodel* model)
-{
-    GLMgroup *group;
-    GLfloat dimensions[3];
-    GLfloat x, y, scalefactor;
-    GLuint i;
-    
-    assert(model);
-    
-    if (model-&gt;texcoords)
-        free(model-&gt;texcoords);
-    model-&gt;numtexcoords = model-&gt;numvertices;
-    model-&gt;texcoords=(GLfloat*)malloc(sizeof(GLfloat)*2*(model-&gt;numtexcoords+1));
-    
-    glmDimensions(model, dimensions);
-    scalefactor = 2.0 / 
-        glmAbs(glmMax(glmMax(dimensions[0], dimensions[1]), dimensions[2]));
-    
-    /* do the calculations */
-    for(i = 1; i &lt;= model-&gt;numvertices; i++) {
-        x = model-&gt;vertices[3 * i + 0] * scalefactor;
-        y = model-&gt;vertices[3 * i + 2] * scalefactor;
-        model-&gt;texcoords[2 * i + 0] = (x + 1.0) / 2.0;
-        model-&gt;texcoords[2 * i + 1] = (y + 1.0) / 2.0;
-    }
-    
-    /* go through and put texture coordinate indices in all the triangles */
-    group = model-&gt;groups;
-    while(group) {
-        for(i = 0; i &lt; group-&gt;numtriangles; i++) {
-            T(group-&gt;triangles[i]).tindices[0] = T(group-&gt;triangles[i]).vindices[0];
-            T(group-&gt;triangles[i]).tindices[1] = T(group-&gt;triangles[i]).vindices[1];
-            T(group-&gt;triangles[i]).tindices[2] = T(group-&gt;triangles[i]).vindices[2];
-        }    
-        group = group-&gt;next;
-    }
-    
-#if 0
-    printf("glmLinearTexture(): generated %d linear texture coordinates\n",
-        model-&gt;numtexcoords);
-#endif
-}
-
-/* glmSpheremapTexture: Generates texture coordinates according to a
- * spherical projection of the texture map.  Sometimes referred to as
- * spheremap, or reflection map texture coordinates.  It generates
- * these by using the normal to calculate where that vertex would map
- * onto a sphere.  Since it is impossible to map something flat
- * perfectly onto something spherical, there is distortion at the
- * poles.  This particular implementation causes the poles along the X
- * axis to be distorted.
- *
- * model - pointer to initialized GLMmodel structure
- */
-GLvoid
-glmSpheremapTexture(GLMmodel* model)
-{
-    GLMgroup* group;
-    GLfloat theta, phi, rho, x, y, z, r;
-    GLuint i;
-    
-    assert(model);
-    assert(model-&gt;normals);
-    
-    if (model-&gt;texcoords)
-        free(model-&gt;texcoords);
-    model-&gt;numtexcoords = model-&gt;numnormals;
-    model-&gt;texcoords=(GLfloat*)malloc(sizeof(GLfloat)*2*(model-&gt;numtexcoords+1));
-    
-    for (i = 1; i &lt;= model-&gt;numnormals; i++) {
-        z = model-&gt;normals[3 * i + 0];  /* re-arrange for pole distortion */
-        y = model-&gt;normals[3 * i + 1];
-        x = model-&gt;normals[3 * i + 2];
-        r = sqrt((x * x) + (y * y));
-        rho = sqrt((r * r) + (z * z));
-        
-        if(r == 0.0) {
-            theta = 0.0;
-            phi = 0.0;
-        } else {
-            if(z == 0.0)
-                phi = 3.14159265 / 2.0;
-            else
-                phi = acos(z / rho);
-            
-            if(y == 0.0)
-                theta = 3.141592365 / 2.0;
-            else
-                theta = asin(y / r) + (3.14159265 / 2.0);
-        }
-        
-        model-&gt;texcoords[2 * i + 0] = theta / 3.14159265;
-        model-&gt;texcoords[2 * i + 1] = phi / 3.14159265;
-    }
-    
-    /* go through and put texcoord indices in all the triangles */
-    group = model-&gt;groups;
-    while(group) {
-        for (i = 0; i &lt; group-&gt;numtriangles; i++) {
-            T(group-&gt;triangles[i]).tindices[0] = T(group-&gt;triangles[i]).nindices[0];
-            T(group-&gt;triangles[i]).tindices[1] = T(group-&gt;triangles[i]).nindices[1];
-            T(group-&gt;triangles[i]).tindices[2] = T(group-&gt;triangles[i]).nindices[2];
-        }
-        group = group-&gt;next;
-    }
-}
-
-/* glmDelete: Deletes a GLMmodel structure.
- *
- * model - initialized GLMmodel structure
- */
-GLvoid
-glmDelete(GLMmodel* model)
-{
-    GLMgroup* group;
-    GLuint i;
-    
-    assert(model);
-    
-    if (model-&gt;pathname)     free(model-&gt;pathname);
-    if (model-&gt;mtllibname) free(model-&gt;mtllibname);
-    if (model-&gt;vertices)     free(model-&gt;vertices);
-    if (model-&gt;normals)  free(model-&gt;normals);
-    if (model-&gt;texcoords)  free(model-&gt;texcoords);
-    if (model-&gt;facetnorms) free(model-&gt;facetnorms);
-    if (model-&gt;triangles)  free(model-&gt;triangles);
-    if (model-&gt;materials) {
-        for (i = 0; i &lt; model-&gt;nummaterials; i++)
-            free(model-&gt;materials[i].name);
-    }
-    free(model-&gt;materials);
-    while(model-&gt;groups) {
-        group = model-&gt;groups;
-        model-&gt;groups = model-&gt;groups-&gt;next;
-        free(group-&gt;name);
-        free(group-&gt;triangles);
-        free(group);
-    }
-    
-    free(model);
-}
-
-/* glmReadOBJ: Reads a model description from a Wavefront .OBJ file.
- * Returns a pointer to the created object which should be free'd with
- * glmDelete().
- *
- * filename - name of the file containing the Wavefront .OBJ format data.  
- */
-GLMmodel* 
-glmReadOBJ(char* filename)
-{
-    GLMmodel* model;
-    FILE* file;
-    
-    /* open the file */
-    file = fopen(filename, "r");
-    if (!file) {
-        fprintf(stderr, "glmReadOBJ() failed: can't open data file \"%s\".\n",
-            filename);
-        exit(1);
-    }
-    
-    /* allocate a new model */
-    model = (GLMmodel*)malloc(sizeof(GLMmodel));
-    model-&gt;pathname    = strdup(filename);
-    model-&gt;mtllibname    = NULL;
-    model-&gt;numvertices   = 0;
-    model-&gt;vertices    = NULL;
-    model-&gt;numnormals    = 0;
-    model-&gt;normals     = NULL;
-    model-&gt;numtexcoords  = 0;
-    model-&gt;texcoords       = NULL;
-    model-&gt;numfacetnorms = 0;
-    model-&gt;facetnorms    = NULL;
-    model-&gt;numtriangles  = 0;
-    model-&gt;triangles       = NULL;
-    model-&gt;nummaterials  = 0;
-    model-&gt;materials       = NULL;
-    model-&gt;numgroups       = 0;
-    model-&gt;groups      = NULL;
-    model-&gt;position[0]   = 0.0;
-    model-&gt;position[1]   = 0.0;
-    model-&gt;position[2]   = 0.0;
-    
-    /* make a first pass through the file to get a count of the number
-    of vertices, normals, texcoords &amp; triangles */
-    glmFirstPass(model, file);
-    
-    /* allocate memory */
-    model-&gt;vertices = (GLfloat*)malloc(sizeof(GLfloat) *
-        3 * (model-&gt;numvertices + 1));
-    model-&gt;triangles = (GLMtriangle*)malloc(sizeof(GLMtriangle) *
-        model-&gt;numtriangles);
-    if (model-&gt;numnormals) {
-        model-&gt;normals = (GLfloat*)malloc(sizeof(GLfloat) *
-            3 * (model-&gt;numnormals + 1));
-    }
-    if (model-&gt;numtexcoords) {
-        model-&gt;texcoords = (GLfloat*)malloc(sizeof(GLfloat) *
-            2 * (model-&gt;numtexcoords + 1));
-    }
-    
-    /* rewind to beginning of file and read in the data this pass */
-    rewind(file);
-    
-    glmSecondPass(model, file);
-    
-    /* close the file */
-    fclose(file);
-    
-//	model-&gt;mtllibname = new char[strlen("HV_TestObj.mtl")];
-//	strcpy(model-&gt;mtllibname, "HV_TestObj.mtl");
-//	glmWriteOBJ(model, "HV_TestObj.obj", GLM_SMOOTH | GLM_MATERIAL);
-
-    return model;
-}
-
-/* glmWriteOBJ: Writes a model description in Wavefront .OBJ format to
- * a file.
- *
- * model - initialized GLMmodel structure
- * filename - name of the file to write the Wavefront .OBJ format data to
- * mode  - a bitwise or of values describing what is written to the file
- *             GLM_NONE     -  render with only vertices
- *             GLM_FLAT     -  render with facet normals
- *             GLM_SMOOTH   -  render with vertex normals
- *             GLM_TEXTURE  -  render with texture coords
- *             GLM_COLOR    -  render with colors (color material)
- *             GLM_MATERIAL -  render with materials
- *             GLM_COLOR and GLM_MATERIAL should not both be specified.  
- *             GLM_FLAT and GLM_SMOOTH should not both be specified.  
- */
-GLvoid
-glmWriteOBJ(GLMmodel* model, char* filename, GLuint mode)
-{
-    GLuint i;
-    FILE* file;
-    GLMgroup* group;
-    
-    assert(model);
-    
-    /* do a bit of warning */
-    if ((mode &amp; GLM_FLAT) &amp;&amp; !model-&gt;facetnorms) {
-        printf("glmWriteOBJ() warning: flat normal output requested "
-            "with no facet normals defined.\n");
-        mode &amp;= ~GLM_FLAT;
-    }
-    if ((mode &amp; GLM_SMOOTH) &amp;&amp; !model-&gt;normals) {
-        printf("glmWriteOBJ() warning: smooth normal output requested "
-            "with no normals defined.\n");
-        mode &amp;= ~GLM_SMOOTH;
-    }
-    if ((mode &amp; GLM_TEXTURE) &amp;&amp; !model-&gt;texcoords) {
-        printf("glmWriteOBJ() warning: texture coordinate output requested "
-            "with no texture coordinates defined.\n");
-        mode &amp;= ~GLM_TEXTURE;
-    }
-    if ((mode &amp; GLM_FLAT) &amp;&amp; (mode &amp; GLM_SMOOTH)) {
-        printf("glmWriteOBJ() warning: flat normal output requested "
-            "and smooth normal output requested (using smooth).\n");
-        mode &amp;= ~GLM_FLAT;
-    }
-    if ((mode &amp; GLM_COLOR) &amp;&amp; !model-&gt;materials) {
-        printf("glmWriteOBJ() warning: color output requested "
-            "with no colors (materials) defined.\n");
-        mode &amp;= ~GLM_COLOR;
-    }
-    if ((mode &amp; GLM_MATERIAL) &amp;&amp; !model-&gt;materials) {
-        printf("glmWriteOBJ() warning: material output requested "
-            "with no materials defined.\n");
-        mode &amp;= ~GLM_MATERIAL;
-    }
-    if ((mode &amp; GLM_COLOR) &amp;&amp; (mode &amp; GLM_MATERIAL)) {
-        printf("glmWriteOBJ() warning: color and material output requested "
-            "outputting only materials.\n");
-        mode &amp;= ~GLM_COLOR;
-    }
-    
-    
-    /* open the file */
-    file = fopen(filename, "w");
-    if (!file) {
-        fprintf(stderr, "glmWriteOBJ() failed: can't open file \"%s\" to write.\n",
-            filename);
-        exit(1);
-    }
-    
-    /* spit out a header */
-    fprintf(file, "#  \n");
-    fprintf(file, "#  Wavefront OBJ generated by GLM library\n");
-    fprintf(file, "#  \n");
-    fprintf(file, "#  GLM library\n");
-    fprintf(file, "#  Nate Robins\n");
-    fprintf(file, "#  ndr@pobox.com\n");
-    fprintf(file, "#  http://www.pobox.com/~ndr\n");
-    fprintf(file, "#  \n");
-    
-    if ((mode &amp; GLM_MATERIAL) &amp;&amp; model-&gt;mtllibname) {
-        fprintf(file, "\nmtllib %s\n\n", model-&gt;mtllibname);
-        glmWriteMTL(model, filename, model-&gt;mtllibname);
-    }
-    
-    /* spit out the vertices */
-    fprintf(file, "\n");
-    fprintf(file, "# %d vertices\n", model-&gt;numvertices);
-    for (i = 1; i &lt;= model-&gt;numvertices; i++) {
-        fprintf(file, "v %f %f %f\n", 
-            model-&gt;vertices[3 * i + 0],
-            model-&gt;vertices[3 * i + 1],
-            model-&gt;vertices[3 * i + 2]);
-    }
-    
-    /* spit out the smooth/flat normals */
-    if (mode &amp; GLM_SMOOTH) {
-        fprintf(file, "\n");
-        fprintf(file, "# %d normals\n", model-&gt;numnormals);
-        for (i = 1; i &lt;= model-&gt;numnormals; i++) {
-            fprintf(file, "vn %f %f %f\n", 
-                model-&gt;normals[3 * i + 0],
-                model-&gt;normals[3 * i + 1],
-                model-&gt;normals[3 * i + 2]);
-        }
-    } else if (mode &amp; GLM_FLAT) {
-        fprintf(file, "\n");
-        fprintf(file, "# %d normals\n", model-&gt;numfacetnorms);
-        for (i = 1; i &lt;= model-&gt;numnormals; i++) {
-            fprintf(file, "vn %f %f %f\n", 
-                model-&gt;facetnorms[3 * i + 0],
-                model-&gt;facetnorms[3 * i + 1],
-                model-&gt;facetnorms[3 * i + 2]);
-        }
-    }
-    
-    /* spit out the texture coordinates */
-    if (mode &amp; GLM_TEXTURE) {
-        fprintf(file, "\n");
-        fprintf(file, "# %d texcoords\n", model-&gt;numtexcoords);
-        for (i = 1; i &lt;= model-&gt;numtexcoords; i++) {
-            fprintf(file, "vt %f %f\n", 
-                model-&gt;texcoords[2 * i + 0],
-                model-&gt;texcoords[2 * i + 1]);
-        }
-    }
-    
-    fprintf(file, "\n");
-    fprintf(file, "# %d groups\n", model-&gt;numgroups);
-    fprintf(file, "# %d faces (triangles)\n", model-&gt;numtriangles);
-    fprintf(file, "\n");
-    
-    group = model-&gt;groups;
-    while(group) {
-        fprintf(file, "g %s\n", group-&gt;name);
-        if (mode &amp; GLM_MATERIAL)
-            fprintf(file, "usemtl %s\n", model-&gt;materials[group-&gt;material].name);
-        for (i = 0; i &lt; group-&gt;numtriangles; i++) {
-            if ((mode &amp; GLM_SMOOTH) &amp;&amp; (mode &amp; GLM_TEXTURE)) {
-                fprintf(file, "f %d/%d/%d %d/%d/%d %d/%d/%d\n",
-                    T(group-&gt;triangles[i]).vindices[0], 
-                    T(group-&gt;triangles[i]).tindices[0],
-                    T(group-&gt;triangles[i]).nindices[0], 
-                    T(group-&gt;triangles[i]).vindices[1],
-                    T(group-&gt;triangles[i]).tindices[1],
-                    T(group-&gt;triangles[i]).nindices[1],
-                    T(group-&gt;triangles[i]).vindices[2],
-                    T(group-&gt;triangles[i]).tindices[2],
-                    T(group-&gt;triangles[i]).nindices[2]);
-            } else if ((mode &amp; GLM_FLAT) &amp;&amp; (mode &amp; GLM_TEXTURE)) {
-                fprintf(file, "f %d/%d %d/%d %d/%d\n",
-                    T(group-&gt;triangles[i]).vindices[0],
-                    T(group-&gt;triangles[i]).findex,
-                    T(group-&gt;triangles[i]).vindices[1],
-                    T(group-&gt;triangles[i]).findex,
-                    T(group-&gt;triangles[i]).vindices[2],
-                    T(group-&gt;triangles[i]).findex);
-            } else if (mode &amp; GLM_TEXTURE) {
-                fprintf(file, "f %d/%d %d/%d %d/%d\n",
-                    T(group-&gt;triangles[i]).vindices[0],
-                    T(group-&gt;triangles[i]).tindices[0],
-                    T(group-&gt;triangles[i]).vindices[1],
-                    T(group-&gt;triangles[i]).tindices[1],
-                    T(group-&gt;triangles[i]).vindices[2],
-                    T(group-&gt;triangles[i]).tindices[2]);
-            } else if (mode &amp; GLM_SMOOTH) {
-                fprintf(file, "f %d//%d %d//%d %d//%d\n",
-                    T(group-&gt;triangles[i]).vindices[0],
-                    T(group-&gt;triangles[i]).nindices[0],
-                    T(group-&gt;triangles[i]).vindices[1],
-                    T(group-&gt;triangles[i]).nindices[1],
-                    T(group-&gt;triangles[i]).vindices[2], 
-                    T(group-&gt;triangles[i]).nindices[2]);
-            } else if (mode &amp; GLM_FLAT) {
-                fprintf(file, "f %d//%d %d//%d %d//%d\n",
-                    T(group-&gt;triangles[i]).vindices[0], 
-                    T(group-&gt;triangles[i]).findex,
-                    T(group-&gt;triangles[i]).vindices[1],
-                    T(group-&gt;triangles[i]).findex,
-                    T(group-&gt;triangles[i]).vindices[2],
-                    T(group-&gt;triangles[i]).findex);
-            } else {
-                fprintf(file, "f %d %d %d\n",
-                    T(group-&gt;triangles[i]).vindices[0],
-                    T(group-&gt;triangles[i]).vindices[1],
-                    T(group-&gt;triangles[i]).vindices[2]);
-            }
-        }
-        fprintf(file, "\n");
-        group = group-&gt;next;
-    }
-    
-    fclose(file);
-}
-
-/* glmDraw: Renders the model to the current OpenGL context using the
- * mode specified.
- *
- * model - initialized GLMmodel structure
- * mode  - a bitwise OR of values describing what is to be rendered.
- *             GLM_NONE     -  render with only vertices
- *             GLM_FLAT     -  render with facet normals
- *             GLM_SMOOTH   -  render with vertex normals
- *             GLM_TEXTURE  -  render with texture coords
- *             GLM_COLOR    -  render with colors (color material)
- *             GLM_MATERIAL -  render with materials
- *             GLM_COLOR and GLM_MATERIAL should not both be specified.  
- *             GLM_FLAT and GLM_SMOOTH should not both be specified.  
- */
-GLvoid
-glmDraw(GLMmodel* model, GLuint mode)
-{
-    static GLuint i;
-    static GLMgroup* group;
-    static GLMtriangle* triangle;
-    static GLMmaterial* material;
-    
-    assert(model);
-    assert(model-&gt;vertices);
-    
-    /* do a bit of warning */
-    if ((mode &amp; GLM_FLAT) &amp;&amp; !model-&gt;facetnorms) {
-        printf("glmDraw() warning: flat render mode requested "
-            "with no facet normals defined.\n");
-        mode &amp;= ~GLM_FLAT;
-    }
-    if ((mode &amp; GLM_SMOOTH) &amp;&amp; !model-&gt;normals) {
-        printf("glmDraw() warning: smooth render mode requested "
-            "with no normals defined.\n");
-        mode &amp;= ~GLM_SMOOTH;
-    }
-    if ((mode &amp; GLM_TEXTURE) &amp;&amp; !model-&gt;texcoords) {
-        printf("glmDraw() warning: texture render mode requested "
-            "with no texture coordinates defined.\n");
-        mode &amp;= ~GLM_TEXTURE;
-    }
-    if ((mode &amp; GLM_FLAT) &amp;&amp; (mode &amp; GLM_SMOOTH)) {
-        printf("glmDraw() warning: flat render mode requested "
-            "and smooth render mode requested (using smooth).\n");
-        mode &amp;= ~GLM_FLAT;
-    }
-    if ((mode &amp; GLM_COLOR) &amp;&amp; !model-&gt;materials) {
-        printf("glmDraw() warning: color render mode requested "
-            "with no materials defined.\n");
-        mode &amp;= ~GLM_COLOR;
-    }
-    if ((mode &amp; GLM_MATERIAL) &amp;&amp; !model-&gt;materials) {
-        printf("glmDraw() warning: material render mode requested "
-            "with no materials defined.\n");
-        mode &amp;= ~GLM_MATERIAL;
-    }
-    if ((mode &amp; GLM_COLOR) &amp;&amp; (mode &amp; GLM_MATERIAL)) {
-        printf("glmDraw() warning: color and material render mode requested "
-            "using only material mode.\n");
-        mode &amp;= ~GLM_COLOR;
-    }
-    if (mode &amp; GLM_COLOR)
-        glEnable(GL_COLOR_MATERIAL);
-    else if (mode &amp; GLM_MATERIAL)
-        glDisable(GL_COLOR_MATERIAL);
-    
-    /* perhaps this loop should be unrolled into material, color, flat,
-       smooth, etc. loops?  since most cpu's have good branch prediction
-       schemes (and these branches will always go one way), probably
-       wouldn't gain too much?  */
-    glRotatef(90,0.0, 0.0, 1.0);
-
-    glRotatef(90,1.0, 0.0, 0.0);
-
-    group = model-&gt;groups;
-    while (group) {
-        if (mode &amp; GLM_MATERIAL) {
-            material = &amp;model-&gt;materials[group-&gt;material];
-			material-&gt;ambient[0] = material-&gt;ambient[0]/2.0;
-			material-&gt;ambient[1] = material-&gt;ambient[1]/2.0;
-			material-&gt;ambient[2] = material-&gt;ambient[2]/2.0;
-			material-&gt;ambient[3] = material-&gt;ambient[3]/2.0;
-
-            glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, material-&gt;ambient);
-            glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, material-&gt;diffuse);
-            glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, material-&gt;specular);
-			material-&gt;shininess = 0.75 * material-&gt;shininess;
-            glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, material-&gt;shininess);
-			
-        }
-        
-        if (mode &amp; GLM_COLOR) {
-            glColor3fv(material-&gt;diffuse);
-        }
-        
-        glBegin(GL_TRIANGLES);
-        for (i = 0; i &lt; group-&gt;numtriangles; i++) {
-            triangle = &amp;T(group-&gt;triangles[i]);
-            
-            if (mode &amp; GLM_FLAT)
-                glNormal3fv(&amp;model-&gt;facetnorms[3 * triangle-&gt;findex]);
-            
-            if (mode &amp; GLM_SMOOTH)
-                glNormal3fv(&amp;model-&gt;normals[3 * triangle-&gt;nindices[0]]);
-            if (mode &amp; GLM_TEXTURE)
-                glTexCoord2fv(&amp;model-&gt;texcoords[2 * triangle-&gt;tindices[0]]);
-            glVertex3fv(&amp;model-&gt;vertices[3 * triangle-&gt;vindices[0]]);
-            
-            if (mode &amp; GLM_SMOOTH)
-                glNormal3fv(&amp;model-&gt;normals[3 * triangle-&gt;nindices[1]]);
-            if (mode &amp; GLM_TEXTURE)
-                glTexCoord2fv(&amp;model-&gt;texcoords[2 * triangle-&gt;tindices[1]]);
-            glVertex3fv(&amp;model-&gt;vertices[3 * triangle-&gt;vindices[1]]);
-            
-            if (mode &amp; GLM_SMOOTH)
-                glNormal3fv(&amp;model-&gt;normals[3 * triangle-&gt;nindices[2]]);
-            if (mode &amp; GLM_TEXTURE)
-                glTexCoord2fv(&amp;model-&gt;texcoords[2 * triangle-&gt;tindices[2]]);
-            glVertex3fv(&amp;model-&gt;vertices[3 * triangle-&gt;vindices[2]]);
-            
-        }
-        glEnd();
-        
-        group = group-&gt;next;
-    }
-}
-
-/* glmList: Generates and returns a display list for the model using
- * the mode specified.
- *
- * model - initialized GLMmodel structure
- * mode  - a bitwise OR of values describing what is to be rendered.
- *             GLM_NONE     -  render with only vertices
- *             GLM_FLAT     -  render with facet normals
- *             GLM_SMOOTH   -  render with vertex normals
- *             GLM_TEXTURE  -  render with texture coords
- *             GLM_COLOR    -  render with colors (color material)
- *             GLM_MATERIAL -  render with materials
- *             GLM_COLOR and GLM_MATERIAL should not both be specified.  
- * GLM_FLAT and GLM_SMOOTH should not both be specified.  
- */
-GLuint
-glmList(GLMmodel* model, GLuint mode)
-{
-    GLuint list;
-    
-    list = glGenLists(1);
-    glNewList(list, GL_COMPILE);
-    glmDraw(model, mode);
-    glEndList();
-    
-    return list;
-}
-
-/* glmWeld: eliminate (weld) vectors that are within an epsilon of
- * each other.
- *
- * model   - initialized GLMmodel structure
- * epsilon     - maximum difference between vertices
- *               ( 0.00001 is a good start for a unitized model)
- *
- */
-GLvoid
-glmWeld(GLMmodel* model, GLfloat epsilon)
-{
-    GLfloat* vectors;
-    GLfloat* copies;
-    GLuint numvectors;
-    GLuint i;
-    
-    /* vertices */
-    numvectors = model-&gt;numvertices;
-    vectors  = model-&gt;vertices;
-    copies = glmWeldVectors(vectors, &amp;numvectors, epsilon);
-    
-#if 0
-    printf("glmWeld(): %d redundant vertices.\n", 
-        model-&gt;numvertices - numvectors - 1);
-#endif
-    
-    for (i = 0; i &lt; model-&gt;numtriangles; i++) {
-        T(i).vindices[0] = (GLuint)vectors[3 * T(i).vindices[0] + 0];
-        T(i).vindices[1] = (GLuint)vectors[3 * T(i).vindices[1] + 0];
-        T(i).vindices[2] = (GLuint)vectors[3 * T(i).vindices[2] + 0];
-    }
-    
-    /* free space for old vertices */
-    free(vectors);
-    
-    /* allocate space for the new vertices */
-    model-&gt;numvertices = numvectors;
-    model-&gt;vertices = (GLfloat*)malloc(sizeof(GLfloat) * 
-        3 * (model-&gt;numvertices + 1));
-    
-    /* copy the optimized vertices into the actual vertex list */
-    for (i = 1; i &lt;= model-&gt;numvertices; i++) {
-        model-&gt;vertices[3 * i + 0] = copies[3 * i + 0];
-        model-&gt;vertices[3 * i + 1] = copies[3 * i + 1];
-        model-&gt;vertices[3 * i + 2] = copies[3 * i + 2];
-    }
-    
-    free(copies);
-}
-
-/* glmReadPPM: read a PPM raw (type P6) file.  The PPM file has a header
- * that should look something like:
- *
- *    P6
- *    # comment
- *    width height max_value
- *    rgbrgbrgb...
- *
- * where "P6" is the magic cookie which identifies the file type and
- * should be the only characters on the first line followed by a
- * carriage return.  Any line starting with a # mark will be treated
- * as a comment and discarded.   After the magic cookie, three integer
- * values are expected: width, height of the image and the maximum
- * value for a pixel (max_value must be &lt; 256 for PPM raw files).  The
- * data section consists of width*height rgb triplets (one byte each)
- * in binary format (i.e., such as that written with fwrite() or
- * equivalent).
- *
- * The rgb data is returned as an array of unsigned chars (packed
- * rgb).  The malloc()'d memory should be free()'d by the caller.  If
- * an error occurs, an error message is sent to stderr and NULL is
- * returned.
- *
- * filename   - name of the .ppm file.
- * width      - will contain the width of the image on return.
- * height     - will contain the height of the image on return.
- *
- */
-GLubyte* 
-glmReadPPM(char* filename, int* width, int* height)
-{
-    FILE* fp;
-    int i, w, h, d;
-    unsigned char* image;
-    char head[70];          /* max line &lt;= 70 in PPM (per spec). */
-    
-    fp = fopen(filename, "rb");
-    if (!fp) {
-        perror(filename);
-        return NULL;
-    }
-    
-    /* grab first two chars of the file and make sure that it has the
-       correct magic cookie for a raw PPM file. */
-    fgets(head, 70, fp);
-    if (strncmp(head, "P6", 2)) {
-        fprintf(stderr, "%s: Not a raw PPM file\n", filename);
-        return NULL;
-    }
-    
-    /* grab the three elements in the header (width, height, maxval). */
-    i = 0;
-    while(i &lt; 3) {
-        fgets(head, 70, fp);
-        if (head[0] == '#')     /* skip comments. */
-            continue;
-        if (i == 0)
-            i += sscanf(head, "%d %d %d", &amp;w, &amp;h, &amp;d);
-        else if (i == 1)
-            i += sscanf(head, "%d %d", &amp;h, &amp;d);
-        else if (i == 2)
-            i += sscanf(head, "%d", &amp;d);
-    }
-    
-    /* grab all the image data in one fell swoop. */
-    image = (unsigned char*)malloc(sizeof(unsigned char)*w*h*3);
-    fread(image, sizeof(unsigned char), w*h*3, fp);
-    fclose(fp);
-    
-    *width = w;
-    *height = h;
-    return image;
-}
-
-#if 0
-/* normals */
-if (model-&gt;numnormals) {
-    numvectors = model-&gt;numnormals;
-    vectors  = model-&gt;normals;
-    copies = glmOptimizeVectors(vectors, &amp;numvectors);
-    
-    printf("glmOptimize(): %d redundant normals.\n", 
-        model-&gt;numnormals - numvectors);
-    
-    for (i = 0; i &lt; model-&gt;numtriangles; i++) {
-        T(i).nindices[0] = (GLuint)vectors[3 * T(i).nindices[0] + 0];
-        T(i).nindices[1] = (GLuint)vectors[3 * T(i).nindices[1] + 0];
-        T(i).nindices[2] = (GLuint)vectors[3 * T(i).nindices[2] + 0];
-    }
-    
-    /* free space for old normals */
-    free(vectors);
-    
-    /* allocate space for the new normals */
-    model-&gt;numnormals = numvectors;
-    model-&gt;normals = (GLfloat*)malloc(sizeof(GLfloat) * 
-        3 * (model-&gt;numnormals + 1));
-    
-    /* copy the optimized vertices into the actual vertex list */
-    for (i = 1; i &lt;= model-&gt;numnormals; i++) {
-        model-&gt;normals[3 * i + 0] = copies[3 * i + 0];
-        model-&gt;normals[3 * i + 1] = copies[3 * i + 1];
-        model-&gt;normals[3 * i + 2] = copies[3 * i + 2];
-    }
-    
-    free(copies);
-}
-
-/* texcoords */
-if (model-&gt;numtexcoords) {
-    numvectors = model-&gt;numtexcoords;
-    vectors  = model-&gt;texcoords;
-    copies = glmOptimizeVectors(vectors, &amp;numvectors);
-    
-    printf("glmOptimize(): %d redundant texcoords.\n", 
-        model-&gt;numtexcoords - numvectors);
-    
-    for (i = 0; i &lt; model-&gt;numtriangles; i++) {
-        for (j = 0; j &lt; 3; j++) {
-            T(i).tindices[j] = (GLuint)vectors[3 * T(i).tindices[j] + 0];
-        }
-    }
-    
-    /* free space for old texcoords */
-    free(vectors);
-    
-    /* allocate space for the new texcoords */
-    model-&gt;numtexcoords = numvectors;
-    model-&gt;texcoords = (GLfloat*)malloc(sizeof(GLfloat) * 
-        2 * (model-&gt;numtexcoords + 1));
-    
-    /* copy the optimized vertices into the actual vertex list */
-    for (i = 1; i &lt;= model-&gt;numtexcoords; i++) {
-        model-&gt;texcoords[2 * i + 0] = copies[2 * i + 0];
-        model-&gt;texcoords[2 * i + 1] = copies[2 * i + 1];
-    }
-    
-    free(copies);
-}
-#endif
-
-#if 0
-/* look for unused vertices */
-/* look for unused normals */
-/* look for unused texcoords */
-for (i = 1; i &lt;= model-&gt;numvertices; i++) {
-    for (j = 0; j &lt; model-&gt;numtriangles; i++) {
-        if (T(j).vindices[0] == i || 
-            T(j).vindices[1] == i || 
-            T(j).vindices[1] == i)
-            break;
-    }
-}
-#endif
-
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\DataRW.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\DataRW.h" added_lines="0" deleted_lines="31">
				<diff>@@ -76,16 +76,6 @@ protected:
 
 };
 
-//class GPSLocalizerReader : public SimpleReaderBase
-//{
-//	public:
-//		GPSLocalizerReader(const std::string&amp; fileName) : SimpleReaderBase(fileName){}
-//		~GPSLocalizerReader(){}
-//
-//		bool ReadNextLine( MsgEstPose&amp; pos, double&amp; logTime);
-//		int ReadAllData(vector&lt;pair&lt;double,  MsgEstPose&gt; &gt;&amp; pos_list);
-//};
-//
 class GPSDataReader : public SimpleReaderBase
 {
 public:
@@ -107,27 +97,6 @@ public:
 	int ReadAllData(std::vector&lt;GPSBasicData&gt;&amp; data_list);
 };
 
-//
-//class VehicleStateReader : public SimpleReaderBase
-//{
-//	public:
-//	VehicleStateReader(const string&amp; fileName) : SimpleReaderBase(fileName){}
-//	~VehicleStateReader(){}
-//
-//	bool ReadNextLine( MsgVehicleStatus&amp; state, double&amp; logTime);
-//	int ReadAllData(vector&lt;pair&lt;double,  MsgVehicleStatus&gt; &gt;&amp; state_list);
-//};
-//
-//class MovingObjectsReader : public SimpleReaderBase
-//{
-//	public:
-//	MovingObjectsReader(const string&amp; fileName) : SimpleReaderBase(fileName, 2, 1, 28, 4){}
-//	~MovingObjectsReader(){}
-//
-//	bool ReadNextLine( MsgMovingObject&amp; state, double&amp; logTime);
-//	int ReadAllData(vector&lt;pair&lt;double,  MsgMovingObject&gt; &gt;&amp; state_list);
-//};
-
 class SimulationFileReader : public SimpleReaderBase
 {
 public:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\UtilityH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\UtilityH.h" added_lines="5" deleted_lines="6">
				<diff>@@ -1,9 +1,8 @@
-/*
- * UtilityH.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
+
+/// \file UtilityH.h
+/// \brief General Math and Control utility functions
+/// \author Hatem Darweesh
+/// \date May 14, 2016
 
 #ifndef UTILITYH_H_
 #define UTILITYH_H_
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" added_lines="8" deleted_lines="0">
				<diff>@@ -497,6 +497,8 @@ int AisanNodesFileReader::ReadAllData(vector&lt;AisanNode&gt;&amp; data_list)
 
 AisanNodesFileReader::AisanNode* AisanNodesFileReader::GetDataRowById(int _nid)
 {
+	if(m_data_map.size()==0) return nullptr;
+
 	int index = _nid-m_min_id;
 	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
 	{
@@ -571,6 +573,8 @@ int AisanPointsFileReader::ReadAllData(vector&lt;AisanPoints&gt;&amp; data_list)
 
 AisanPointsFileReader::AisanPoints* AisanPointsFileReader::GetDataRowById(int _pid)
 {
+	if(m_data_map.size()==0) return nullptr;
+
 	int index = _pid-m_min_id;
 	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
 	{
@@ -639,6 +643,8 @@ int AisanLinesFileReader::ReadAllData(vector&lt;AisanLine&gt;&amp; data_list)
 
 AisanLinesFileReader::AisanLine* AisanLinesFileReader::GetDataRowById(int _lid)
 {
+	if(m_data_map.size()==0) return nullptr;
+
 	int index = _lid-m_min_id;
 	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
 	{
@@ -821,6 +827,8 @@ int AisanLanesFileReader::ReadAllData(vector&lt;AisanLane&gt;&amp; data_list)
 
 AisanLanesFileReader::AisanLane* AisanLanesFileReader::GetDataRowById(int _lnid)
 {
+	if(m_data_map.size()==0) return nullptr;
+
 int index = _lnid-m_min_id;
 if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\UtilityH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\UtilityH.cpp" added_lines="4" deleted_lines="6">
				<diff>@@ -1,9 +1,7 @@
-/*
- * UtilityH.cpp
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
+/// \file UtilityH.cpp
+/// \brief General Math and Control utility functions
+/// \author Hatem Darweesh
+/// \date May 14, 2016
 
 #include "op_utility/UtilityH.h"
 #include &lt;iostream&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\RosHelpers.h" new_path="ros\src\computing\planning\mission\packages\way_planner\include\RosHelpers.h" added_lines="1" deleted_lines="8">
				<diff>@@ -2,7 +2,7 @@
  * RosHelpers.h
  *
  *  Created on: Jun 30, 2016
- *      Author: ai-driver
+ *      Author: Hatem Darweesh
  */
 
 #ifndef ROSHELPERS_H_
@@ -20,13 +20,6 @@
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 
-//#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
-//#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-//#include &lt;pcl_conversions/pcl_conversions.h&gt;
-//#include &lt;pcl/io/io.h&gt;
-//#include &lt;pcl/io/pcd_io.h&gt;
-//#include &lt;pcl/point_types.h&gt;
-
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "autoware_msgs/LaneArray.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\way_planner_core.h" new_path="ros\src\computing\planning\mission\packages\way_planner\include\way_planner_core.h" added_lines="1" deleted_lines="5">
				<diff>@@ -33,11 +33,6 @@
 
 #include &lt;ros/ros.h&gt;
 
-//#include &lt;map_file/PointClassArray.h&gt;
-//#include &lt;map_file/LaneArray.h&gt;
-//#include &lt;map_file/NodeArray.h&gt;
-//#include &lt;map_file/StopLineArray.h&gt;
-//#include &lt;map_file/DTLaneArray.h&gt;
 #include "vector_map_msgs/PointArray.h"
 #include "vector_map_msgs/LaneArray.h"
 #include "vector_map_msgs/NodeArray.h"
@@ -64,6 +59,7 @@
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
 #include "op_planner/MappingHelpers.h"
+#include "op_planner/PlanningHelpers.h"
 #include "op_planner/PlannerH.h"
 #include "RosHelpers.h"
 #include "SocketServer.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\RosHelpers.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\RosHelpers.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -79,8 +79,8 @@ void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;Plann
 		wp.twist.twist.linear.y = path.at(i).laneId;
 		wp.twist.twist.linear.z = path.at(i).stopLineID;
 		wp.twist.twist.angular.x = path.at(i).laneChangeCost;
-		wp.twist.twist.angular.y = path.at(i).LeftLaneId;
-		wp.twist.twist.angular.z = path.at(i).RightLaneId;
+		wp.twist.twist.angular.y = path.at(i).LeftPointId;
+		wp.twist.twist.angular.z = path.at(i).RightPointId;
 		//std::cout &lt;&lt; "PathID: " &lt;&lt; i &lt;&lt; ", LID:" &lt;&lt; path.at(i).laneId &lt;&lt; ", LeftLaneID: " &lt;&lt;  path.at(i).LeftLaneId &lt;&lt; ", RightLaneID: " &lt;&lt; path.at(i).RightLaneId &lt;&lt; std::endl;
 
 		for(unsigned int iaction = 0; iaction &lt; path.at(i).actionCost.size(); iaction++)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -366,7 +366,7 @@ void way_planner_core::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, Planner
 	std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt; roadedge_data;
 	std::vector&lt;UtilityHNS::AisanWayareaFileReader::AisanWayarea&gt; way_area;
 	std::vector&lt;UtilityHNS::AisanCrossWalkFileReader::AisanCrossWalk&gt; crossing;
-	std::vector&lt;UtilityHNS::AisanNodesFileReader::AisanNode &gt; nodes_data;
+	std::vector&lt;UtilityHNS::AisanNodesFileReader::AisanNode&gt; nodes_data;
 	std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;
 
 	PlannerHNS::GPSPoint origin;//(m_OriginPos.position.x, m_OriginPos.position.y, m_OriginPos.position.z, 0);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" added_lines="13" deleted_lines="45">
				<diff>@@ -59,7 +59,6 @@
 #include "op_planner/RoadNetwork.h"
 #include "op_planner/MappingHelpers.h"
 #include "op_planner/PlanningHelpers.h"
-//#include "CarState.h"
 #include "op_planner/LocalPlannerH.h"
 #include "RosHelpers.h"
 #include "op_simu/SimpleTracker.h"
@@ -79,7 +78,6 @@
 namespace PlannerXNS
 {
 
-#define _DATASET_GENERATION_BLOCK
 #define SIMU_OBSTACLE_WIDTH 3.5
 #define SIMU_OBSTACLE_HEIGHT 0.5
 #define SIMU_OBSTACLE_LENGTH 2.0
@@ -103,7 +101,6 @@ protected:
 
 protected:
 	SimulationNS::SimpleTracker m_ObstacleTracking;
-	//SimulationNS::CarState m_State;
 	PlannerHNS::LocalPlannerH m_LocalPlanner;
 
 	geometry_msgs::Pose m_OriginPos;
@@ -144,7 +141,6 @@ protected:
 	//Planning Related variables
 	PlannerHNS::BehaviorState m_CurrentBehavior;
 	PlannerHNS::BehaviorState m_PrevBehavior;
-	//PlannerHNS::WayPoint m_CurrentGoal;
 	struct timespec m_PlanningTimer;
 	AutowareRoadNetwork m_AwMap;
   	PlannerHNS::RoadNetwork m_Map;
@@ -187,21 +183,21 @@ protected:
 	ros::Publisher pub_SimuBoxPose;
 
 	// define subscribers.
-	ros::Subscriber sub_initialpose			;
-	ros::Subscriber sub_current_pose 		;
-	ros::Subscriber sub_current_velocity	;
-	ros::Subscriber sub_cluster_cloud		;
-	ros::Subscriber sub_bounding_boxs		;
+	ros::Subscriber sub_initialpose;
+	ros::Subscriber sub_current_pose;
+	ros::Subscriber sub_current_velocity;
+	ros::Subscriber sub_cluster_cloud;
+	ros::Subscriber sub_bounding_boxs;
 	ros::Subscriber sub_vehicle_simu_status ;
-	ros::Subscriber sub_robot_odom			;
-	ros::Subscriber sub_can_info			;
-	ros::Subscriber sub_EmergencyStop		;
-	ros::Subscriber sub_TrafficLight		;
-	ros::Subscriber sub_OutsideControl		;
-	ros::Subscriber sub_AStarPath			;
-	ros::Subscriber sub_WayPlannerPaths		;
+	ros::Subscriber sub_robot_odom;
+	ros::Subscriber sub_can_info;
+	ros::Subscriber sub_EmergencyStop;
+	ros::Subscriber sub_TrafficLight;
+	ros::Subscriber sub_OutsideControl;
+	ros::Subscriber sub_AStarPath;
+	ros::Subscriber sub_WayPlannerPaths;
 
-	ros::Subscriber sub_CostMap				;
+	ros::Subscriber sub_CostMap;
 
 	//vector map subscription
 	ros::Subscriber sub_map_points;
@@ -249,34 +245,6 @@ protected:
   void UpdatePlanningParams();
 
   autoware_msgs::CloudCluster GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::PointStamped&amp; centerPose);
-
-#ifdef DATASET_GENERATION_BLOCK
-private:
-  struct DataPairs
-  {
-	  cv::Mat image;
-	  PlannerHNS::VehicleState vehicleState;
-	  PlannerHNS::WayPoint currentPos;
-	  std::vector&lt;PlannerHNS::WayPoint&gt; path;
-	  std::vector&lt; std::vector&lt;PlannerHNS::WayPoint&gt; &gt; predictedPaths;
-  };
-
-  int m_iRecordNumber;
-  cv::Mat m_CurrImage;
-  std::vector&lt;DataPairs&gt; m_DrivePoints;
-
-  //tf::TransformListener m_Transformation;
-  std::ofstream m_ImagesVectors;
-  std::ofstream m_TrajVectors;
-
-  ros::Subscriber sub_image_reader;
-  void callbackReadImage(const sensor_msgs::ImageConstPtr&amp; msg);
-  void ExtractPathFromDriveData(double max_extraction = 50);
-  void WritePathCSV(const std::string&amp; fName, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path);
-  void WriteImageAndPathCSV(cv::Mat img, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path);
-
-#endif
-
 };
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" added_lines="2" deleted_lines="280">
				<diff>@@ -130,35 +130,6 @@ PlannerX::PlannerX()
 	sub_bounding_boxs  	= nh.subscribe("/bounding_boxes",			1,		&amp;PlannerX::callbackGetBoundingBoxes, 	this);
 	sub_WayPlannerPaths = nh.subscribe("/realtime_cost_map",		1,		&amp;PlannerX::callbackGetCostMap, 	this);
 
-#ifdef DATASET_GENERATION_BLOCK
-
-	m_iRecordNumber = 0;
-//	tf::StampedTransform base_transform;
-//	int nFailedCounter = 0;
-//	while (1)
-//	{
-//		try
-//		{
-//			m_Transformation.lookupTransform("base_link", "world", ros::Time(0), base_transform);
-//			break;
-//		}
-//		catch (tf::TransformException&amp; ex)
-//		{
-//			if(nFailedCounter &gt; 2)
-//			{
-//				ROS_ERROR("%s", ex.what());
-//			}
-//			ros::Duration(1.0).sleep();
-//			nFailedCounter ++;
-//		}
-//	}
-
-	m_ImagesVectors.open("/home/user/data/db/input.csv");
-	m_TrajVectors.open("/home/user/data/db/output.csv");
-
-	sub_image_reader = nh.subscribe("/image_raw", 1, &amp;PlannerX::callbackReadImage, 		this);
-#endif
-
 	/**
 	 * @todo This works only in simulation (Autoware or ff_Waypoint_follower), twist_cmd should be changed, consult team
 	 */
@@ -204,148 +175,9 @@ PlannerX::~PlannerX()
 			, m_LogData);
 #endif
 
-#ifdef DATASET_GENERATION_BLOCK
-	m_ImagesVectors.close();
-	m_TrajVectors.close();
-#endif
-}
-
-#ifdef DATASET_GENERATION_BLOCK
-void PlannerX::callbackReadImage(const sensor_msgs::ImageConstPtr&amp; img)
-{
-	//std::cout &lt;&lt; "Reading Image Data ... " &lt;&lt; std::endl;
-	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(img, sensor_msgs::image_encodings::BGR8);
-	m_CurrImage = cv_image-&gt;image;
-
-}
-
-void PlannerX::ExtractPathFromDriveData(double max_extraction)
-{
-	double d = 0;
-	DataPairs dp;
-
-	for(int i = m_DrivePoints.size()-1; i &gt;= 0 ; i--)
-	{
-		d += m_DrivePoints.at(i).currentPos.cost;
-
-		if(d &gt;= 30)
-		{
-			dp.image =  m_DrivePoints.at(i).image.clone();
-			dp.currentPos =  m_DrivePoints.at(i).currentPos;
-			dp.vehicleState = m_DrivePoints.at(i).vehicleState;
-			cv::Mat gray_image;
-			cvtColor( dp.image, gray_image, cv::COLOR_BGR2GRAY);
-			cv::Rect roi;
-			roi.x = 0;
-			roi.y = gray_image.rows/3;
-			roi.width = gray_image.cols;
-			roi.height = gray_image.rows - gray_image.rows/3;
-			cv::Mat halfImg = gray_image(roi);
-
-			std::ostringstream image_name;
-			image_name &lt;&lt; "/home/user/data/db/vis/image_" &lt;&lt; m_iRecordNumber &lt;&lt; ".png";
-			std::ostringstream half_image_name;
-			half_image_name &lt;&lt;  "/home/user/data/db/img/img_"  &lt;&lt; m_iRecordNumber &lt;&lt; ".png";
-			std::ostringstream label_name ;
-			label_name &lt;&lt; "/home/user/data/db/csv/lbl_" &lt;&lt; m_iRecordNumber &lt;&lt; ".csv";
-
-
-			PlannerHNS::Mat3 rotationMat(-dp.currentPos.pos.a);
-			PlannerHNS::Mat3 translationMat(-dp.currentPos.pos.x, -dp.currentPos.pos.y);
-			for(unsigned int ip=0; ip &lt; dp.path.size(); ip++)
-			{
-				dp.path.at(ip).pos = translationMat*dp.path.at(ip).pos;
-				dp.path.at(ip).pos = rotationMat*dp.path.at(ip).pos;
-			}
-
-			PlannerHNS::PlanningHelpers::SmoothPath(dp.path, 0.45, 0.3, 0.01);
-			PlannerHNS::PlanningHelpers::FixPathDensity(dp.path, d/20.0);
-			PlannerHNS::PlanningHelpers::SmoothPath(dp.path, 0.45, 0.35, 0.01);
-
-			for(unsigned int ip=0; ip &lt;dp.path.size()-1; ip++)
-			{
-				cv::Point p1;
-				p1.y = dp.image.rows - (fabs(dp.path.at(ip).pos.x) *  halfImg.rows  / 40.0);
-				p1.x = halfImg.cols/2 + (-dp.path.at(ip).pos.y * halfImg.cols / 20.0);
-
-				cv::Point p2;
-				p2.y = dp.image.rows - (fabs(dp.path.at(ip+1).pos.x) *  halfImg.rows  / 40.0);
-				p2.x = halfImg.cols/2 + (-dp.path.at(ip+1).pos.y * halfImg.cols / 20.0);
-
-				cv::line(dp.image, p1, p2,  cv::Scalar( 0, 255, 0 ), 2, 8);
-			}
-
-			WritePathCSV(label_name.str(), dp.path);
-			imwrite(image_name.str(),  dp.image);
-			imwrite(half_image_name.str(),  halfImg);
-
-			WriteImageAndPathCSV(halfImg.clone(), dp.path);
-
-			for(int j = 0; j &lt;= i; j++)
-				if(m_DrivePoints.size() &gt; 0)
-					m_DrivePoints.erase(m_DrivePoints.begin()+0);
-
-			m_iRecordNumber++;
-			std::cout &lt;&lt; "Extract Data: " &lt;&lt; "Cost: " &lt;&lt; d &lt;&lt; ", Index: " &lt;&lt; i &lt;&lt; ", Path Size: " &lt;&lt; dp.path.size() &lt;&lt; std::endl;
-			return;
-		}
-
-		dp.path.insert(dp.path.begin(), m_DrivePoints.at(i).currentPos);
-	}
-}
-
-void PlannerX::WriteImageAndPathCSV(cv::Mat img,std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
-{
-	if(m_ImagesVectors.is_open())
-	{
-		ostringstream str_img;
-		str_img.precision(0);
-		for(int c=0; c&lt;img.cols; c++)
-		{
-			for(int r=0; r&lt;img.rows; r++)
-			{
-				short x = img.at&lt;uchar&gt;(r, c);
-				str_img &lt;&lt; x &lt;&lt; ',';
-			}
-		}
-
-		m_ImagesVectors &lt;&lt; str_img.str() &lt;&lt; "\r\n";
-	}
-
-	if(m_TrajVectors.is_open())
-	{
-		ostringstream strwp;
-		 for(unsigned int i=0; i&lt;path.size(); i++)
-		 {
-			 strwp &lt;&lt; path.at(i).pos.x&lt;&lt;","&lt;&lt; path.at(i).pos.y &lt;&lt; ",";
-		 }
-		m_TrajVectors &lt;&lt; strwp.str() &lt;&lt; "\r\n";
-	}
-}
-
-void PlannerX::WritePathCSV(const std::string&amp; fName, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
-{
-	vector&lt;string&gt; dataList;
-	 for(unsigned int i=0; i&lt;path.size(); i++)
-	 {
-		 ostringstream strwp;
-		 strwp &lt;&lt; path.at(i).pos.x&lt;&lt;","&lt;&lt; path.at(i).pos.y &lt;&lt;","&lt;&lt; path.at(i).v &lt;&lt; ",";
-		 dataList.push_back(strwp.str());
-	 }
-
-	 std::ofstream f(fName.c_str());
-
-	if(f.is_open())
-	{
-		for(unsigned int i = 0 ; i &lt; dataList.size(); i++)
-			f &lt;&lt; dataList.at(i) &lt;&lt; "\r\n";
-	}
 
-	f.close();
 }
 
-#endif
-
 void PlannerX::callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg)
 {
 	ROS_INFO("Received Map Points");
@@ -511,43 +343,6 @@ void PlannerX::callbackGetRvizPoint(const geometry_msgs::PointStampedConstPtr&amp; m
 
 		pub_TrackedObstaclesRviz.publish(boxes_array);
 	}
-
-//	if(m_LocalPlanner.m_TotalPath.size() &gt; 0)
-//	{
-//		vector&lt;PlannerHNS::WayPoint&gt; line;
-//		PlannerHNS::WayPoint p1(msg-&gt;point.x+m_OriginPos.position.x, msg-&gt;point.y+m_OriginPos.position.y, msg-&gt;point.z+m_OriginPos.position.z, 0);
-//
-//		//int index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_LocalPlanner.m_TotalPath.at(0), p1);
-////		PlannerHNS::WayPoint p_prev = m_LocalPlanner.m_TotalPath.at(0).at(index);
-////		if(index &gt; 0)
-////			p_prev = m_LocalPlanner.m_TotalPath.at(0).at(index-1);
-////
-////
-////		double distance = 0;
-////		PlannerHNS::WayPoint p2 = PlannerHNS::PlanningHelpers::GetPerpendicularOnTrajectory(m_LocalPlanner.m_TotalPath.at(0), p1, distance);
-////
-////		double perpDistance = PlannerHNS::PlanningHelpers::GetPerpDistanceToTrajectorySimple(m_LocalPlanner.m_TotalPath.at(0), p1);
-////
-////		double back_distance = hypot(p2.pos.y - p_prev.pos.y, p2.pos.x - p_prev.pos.x);
-////		double direct_distance = hypot(p2.pos.y - p1.pos.y, p2.pos.x - p1.pos.x);
-//
-//
-//		PlannerHNS::RelativeInfo info;
-//		bool ret = PlannerHNS::PlanningHelpers::GetRelativeInfo(m_LocalPlanner.m_TotalPath.at(0), p1, info);
-//		PlannerHNS::WayPoint p_prev = m_LocalPlanner.m_TotalPath.at(0).at(info.iBack);
-//
-//		std::cout &lt;&lt; "Perp D: " &lt;&lt; info.perp_distance &lt;&lt; ", F D: "&lt;&lt; info.to_front_distance &lt;&lt; ", B D: " &lt;&lt; info.from_back_distance &lt;&lt; ", F Index: "&lt;&lt; info.iFront &lt;&lt; ", B Index: " &lt;&lt; info.iBack &lt;&lt; ", Size: "&lt;&lt; m_LocalPlanner.m_TotalPath.at(0).size() &lt;&lt; std::endl;
-//
-//		line.push_back(p1);
-//		line.push_back(info.perp_point);
-//		line.push_back(p_prev);
-//
-//		std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; lines;
-//		lines.push_back(line);
-//		visualization_msgs::MarkerArray line_vis;
-//		RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(lines, line_vis);
-//		pub_TestLineRviz.publish(line_vis);
-//	}
 }
 
 void PlannerX::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg)
@@ -568,43 +363,6 @@ void PlannerX::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp;
 
 	bNewCurrentPos = true;
 	bInitPos = true;
-#ifdef DATASET_GENERATION_BLOCK
-
-	PlannerHNS::WayPoint p(m_CurrentPos.pos.x, m_CurrentPos.pos.y, 0, m_CurrentPos.pos.a);
-	p.v = m_VehicleState.speed;
-
-	DataPairs dp;
-	if(m_DrivePoints.size() == 0)
-	{
-		dp.image = m_CurrImage;
-		dp.currentPos = p;
-		dp.vehicleState = m_VehicleState;
-		m_DrivePoints.push_back(dp);
-	}
-	else
-	{
-		p.cost = hypot(p.pos.y - m_DrivePoints.at(m_DrivePoints.size()-1).currentPos.pos.y, p.pos.x - m_DrivePoints.at(m_DrivePoints.size()-1).currentPos.pos.x);
-		if(p.cost &gt;= 0.25 &amp;&amp; p.cost &lt;= 3.0)
-		{
-			dp.image = m_CurrImage;
-			dp.currentPos = p;
-			dp.vehicleState = m_VehicleState;
-			m_DrivePoints.push_back(dp);
-			//std::cout &lt;&lt; "Insert Pose: " &lt;&lt; "Cost: " &lt;&lt; p.cost &lt;&lt; ", Speed: " &lt;&lt; p.v &lt;&lt; ", Size: " &lt;&lt; m_DrivePoints.size() &lt;&lt; std::endl;
-		}
-		else
-		{
-			//std::cout &lt;&lt; "Miss Pose: " &lt;&lt; "Cost: " &lt;&lt; p.cost &lt;&lt; ", Speed: " &lt;&lt; p.v &lt;&lt; ", Size: " &lt;&lt; m_DrivePoints.size() &lt;&lt; std::endl;
-			if(m_DrivePoints.size() == 1)
-				m_DrivePoints.clear();
-		}
-	}
-
-
-	if(m_DrivePoints.size() &gt;= 20)
-		ExtractPathFromDriveData();
-
-#endif
 }
 
 autoware_msgs::CloudCluster PlannerX::GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::PointStamped&amp; centerPose)
@@ -783,8 +541,8 @@ void PlannerX::callbackGetWayPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp;
 				wp.laneId = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.linear.y;
 				wp.stopLineID = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.linear.z;
 				wp.laneChangeCost = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.angular.x;
-				wp.LeftLaneId = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.angular.y;
-				wp.RightLaneId = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.angular.z;
+				wp.LeftPointId = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.angular.y;
+				wp.RightPointId = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.angular.z;
 
 				if(msg-&gt;lanes.at(i).waypoints.at(j).dtlane.dir == 0)
 					wp.bDir = PlannerHNS::FORWARD_DIR;
@@ -823,27 +581,6 @@ void PlannerX::callbackGetWayPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp;
 
 			PlannerHNS::PlanningHelpers::CalcAngleAndCost(path);
 
-//			int prevStopID = -1;
-//			for(unsigned int k= 0; k &lt; path.size(); k++)
-//			{
-//				if(path.at(k).pLane)
-//				{
-//					for(unsigned int si = 0; si &lt; path.at(k).pLane-&gt;stopLines.size(); si++)
-//					{
-//						if(prevStopID != path.at(k).pLane-&gt;stopLines.at(si).id)
-//						{
-//							PlannerHNS::WayPoint stopLineWP;
-//							stopLineWP.pos = path.at(k).pLane-&gt;stopLines.at(si).points.at(0);
-//							PlannerHNS::RelativeInfo info;
-//							PlannerHNS::PlanningHelpers::GetRelativeInfo(path, stopLineWP, info, k);
-//
-//							path.at(info.iFront).stopLineID = path.at(k).pLane-&gt;stopLines.at(si).id;
-//							prevStopID = path.at(info.iFront).stopLineID;
-//						}
-//					}
-//				}
-//			}
-
 			m_WayPlannerPaths.push_back(path);
 
 			if(bOldGlobalPath)
@@ -857,18 +594,9 @@ void PlannerX::callbackGetWayPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp;
 		{
 			bWayPlannerPath = true;
 			m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bNewGlobalPath = true;
-			//m_CurrentGoal = m_WayPlannerPaths.at(0).at(m_WayPlannerPaths.at(0).size()-1);
 			m_LocalPlanner.m_TotalOriginalPath = m_WayPlannerPaths;
 
 			cout &lt;&lt; "Global Lanes Size = " &lt;&lt; msg-&gt;lanes.size() &lt;&lt;", Conv Size= " &lt;&lt; m_WayPlannerPaths.size() &lt;&lt; ", First Lane Size: " &lt;&lt; m_WayPlannerPaths.at(0).size() &lt;&lt; endl;
-
-//			for(unsigned int k= 0; k &lt; m_WayPlannerPaths.at(0).size(); k++)
-//			{
-//				if(m_WayPlannerPaths.at(0).at(k).stopLineID &gt; 0 &amp;&amp; m_WayPlannerPaths.at(0).at(k).pLane &amp;&amp; m_WayPlannerPaths.at(0).at(k).pLane-&gt;stopLines.size()&gt;0)
-//				{
-//					cout &lt;&lt; "Stop Line IDs: " &lt;&lt; m_WayPlannerPaths.at(0).at(k).stopLineID &lt;&lt; ", Lane: " &lt;&lt; m_WayPlannerPaths.at(0).at(k).pLane &lt;&lt; ", Stop Lines: "&lt;&lt; m_WayPlannerPaths.at(0).at(k).pLane-&gt;stopLines.size() &lt;&lt; endl;
-//				}
-//			}
 		}
 	}
 }
@@ -892,7 +620,6 @@ void PlannerX::PlannerMainLoop()
 		{
 			bKmlMapLoaded = true;
 			PlannerHNS::MappingHelpers::LoadKML(m_KmlMapPath, m_Map);
-			//sub_WayPlannerPaths = nh.subscribe("/lane_waypoints_array", 	10,		&amp;PlannerX::callbackGetWayPlannerPath, 	this);
 		}
 		else if(m_MapSource == MAP_FOLDER &amp;&amp; !bKmlMapLoaded)
 		{
@@ -915,11 +642,6 @@ void PlannerX::PlannerMainLoop()
 		int iDirection = 0;
 		if(bInitPos &amp;&amp; m_LocalPlanner.m_TotalOriginalPath.size()&gt;0)
 		{
-//			bool bMakeNewPlan = false;
-//			double drift = hypot(m_LocalPlanner.state.pos.y-m_CurrentPos.pos.y, m_LocalPlanner.state .pos.x-m_CurrentPos.pos.x);
-//			if(drift &gt; 10)
-//				bMakeNewPlan = true;
-
 			m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = m_bOutsideControl;
 			m_LocalPlanner.state = m_CurrentPos;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_trajectory_generator_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_trajectory_generator_core.h" added_lines="16" deleted_lines="21">
				<diff>@@ -1,5 +1,5 @@
 /*
-// *  Copyright (c) 2016, Nagoya University
+// *  Copyright (c) 2017, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -31,11 +31,7 @@
 #ifndef OP_TRAJECTORY_GENERATOR_CORE
 #define OP_TRAJECTORY_GENERATOR_CORE
 
-// ROS includes
 #include &lt;ros/ros.h&gt;
-#include "op_planner/PlannerH.h"
-#include "op_planner/PlannerCommonDef.h"
-
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
@@ -45,13 +41,15 @@
 #include &lt;autoware_msgs/LaneArray.h&gt;
 #include &lt;autoware_msgs/CanInfo.h&gt;
 
+#include "op_planner/PlannerH.h"
+#include "op_planner/PlannerCommonDef.h"
+
 namespace TrajectoryGeneratorNS
 {
 
 class TrajectoryGen
 {
-protected: //Planning Related variables
-
+protected:
 	PlannerHNS::PlannerH m_Planner;
 	geometry_msgs::Pose m_OriginPos;
 	PlannerHNS::WayPoint m_InitPos;
@@ -63,38 +61,35 @@ protected: //Planning Related variables
 	PlannerHNS::VehicleState m_VehicleStatus;
 	bool bVehicleStatus;
 
+	std::vector&lt;PlannerHNS::WayPoint&gt; m_temp_path;
 	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; m_GlobalPaths;
 	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; m_GlobalPathSections;
 	std::vector&lt;PlannerHNS::WayPoint&gt; t_centerTrajectorySmoothed;
 	std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt; m_RollOuts;
 	bool bWayGlobalPath;
-
 	struct timespec m_PlanningTimer;
   	std::vector&lt;std::string&gt;    m_LogData;
-
   	PlannerHNS::PlanningParams m_PlanningParams;
   	PlannerHNS::CAR_BASIC_INFO m_CarInfo;
 
 
-protected: //ROS messages (topics)
+  	//ROS messages (topics)
 	ros::NodeHandle nh;
 
 	//define publishers
-	ros::Publisher pub_LocalPath;
-	ros::Publisher pub_LocalBasePath;
+	ros::Publisher pub_LocalTrajectories;
 	ros::Publisher pub_LocalTrajectoriesRviz;
 
 	// define subscribers.
-	ros::Subscriber sub_initialpose			;
-	ros::Subscriber sub_current_pose 		;
-	ros::Subscriber sub_current_velocity	;
-	ros::Subscriber sub_vehicle_simu_status ;
-	ros::Subscriber sub_robot_odom			;
-	ros::Subscriber sub_can_info			;
-	ros::Subscriber sub_GlobalPlannerPaths	;
+	ros::Subscriber sub_initialpose;
+	ros::Subscriber sub_current_pose;
+	ros::Subscriber sub_current_velocity;
+	ros::Subscriber sub_robot_odom;
+	ros::Subscriber sub_can_info;
+	ros::Subscriber sub_GlobalPlannerPaths;
 
 
-protected: // Callback function for subscriber.
+	// Callback function for subscriber.
 	void callbackGetInitPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;input);
 	void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg);
 	void callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr&amp; msg);
@@ -102,7 +97,7 @@ protected: // Callback function for subscriber.
 	void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg);
 	void callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp; msg);
 
-protected: //Helper Functions
+	//Helper Functions
   void UpdatePlanningParams(ros::NodeHandle&amp; _nh);
 
 public:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_common_params\op_common_params.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_common_params\op_common_params.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2017, Nagoya University
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" added_lines="68" deleted_lines="81">
				<diff>@@ -49,73 +49,77 @@ TrajectoryGen::TrajectoryGen()
 	m_OriginPos.position.y  = transform.getOrigin().y();
 	m_OriginPos.position.z  = transform.getOrigin().z();
 
-	pub_LocalPath = nh.advertise&lt;autoware_msgs::lane&gt;("/final_waypoints", 100,true);
-	pub_LocalBasePath = nh.advertise&lt;autoware_msgs::lane&gt;("/base_waypoints", 100,true);
-	pub_LocalTrajectoriesRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("local_trajectories", 1);
+	pub_LocalTrajectories = nh.advertise&lt;autoware_msgs::LaneArray&gt;("local_trajectories", 1);
+	pub_LocalTrajectoriesRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("local_trajectories_gen_rviz", 1);
 
-	sub_initialpose 	= nh.subscribe("/initialpose", 				1,		&amp;TrajectoryGen::callbackGetInitPose, 		this);
-	sub_current_pose 	= nh.subscribe("/current_pose", 			1,		&amp;TrajectoryGen::callbackGetCurrentPose, 		this);
+	sub_initialpose = nh.subscribe("/initialpose", 1, &amp;TrajectoryGen::callbackGetInitPose, this);
+	sub_current_pose = nh.subscribe("/current_pose", 10, &amp;TrajectoryGen::callbackGetCurrentPose, this);
 
 	int bVelSource = 1;
 	_nh.getParam("/op_trajectory_generator/velocitySource", bVelSource);
 	if(bVelSource == 0)
-		sub_robot_odom 			= nh.subscribe("/odom", 					100,	&amp;TrajectoryGen::callbackGetRobotOdom, 	this);
+		sub_robot_odom = nh.subscribe("/odom", 10,	&amp;TrajectoryGen::callbackGetRobotOdom, this);
 	else if(bVelSource == 1)
-		sub_current_velocity 	= nh.subscribe("/current_velocity",		100,	&amp;TrajectoryGen::callbackGetVehicleStatus, 	this);
+		sub_current_velocity = nh.subscribe("/current_velocity", 10, &amp;TrajectoryGen::callbackGetVehicleStatus, this);
 	else if(bVelSource == 2)
-		sub_can_info 			= nh.subscribe("/can_info",		100,	&amp;TrajectoryGen::callbackGetCanInfo, 	this);
+		sub_can_info = nh.subscribe("/can_info", 10, &amp;TrajectoryGen::callbackGetCanInfo, this);
 
-	sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 	1,		&amp;TrajectoryGen::callbackGetGlobalPlannerPath, 	this);
+	sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 1, &amp;TrajectoryGen::callbackGetGlobalPlannerPath, this);
 }
 
 TrajectoryGen::~TrajectoryGen()
 {
 }
 
-
 void TrajectoryGen::UpdatePlanningParams(ros::NodeHandle&amp; _nh)
 {
-	_nh.getParam("/op_trajectory_generator/enableSwerving", m_PlanningParams.enableSwerving);
+	_nh.getParam("/op_trajectory_generator/samplingTipMargin", m_PlanningParams.carTipMargin);
+	_nh.getParam("/op_trajectory_generator/samplingOutMargin", m_PlanningParams.rollInMargin);
+	_nh.getParam("/op_trajectory_generator/samplingSpeedFactor", m_PlanningParams.rollInSpeedFactor);
+	_nh.getParam("/op_trajectory_generator/enableHeadingSmoothing", m_PlanningParams.enableHeadingSmoothing);
+
+	_nh.getParam("/op_common_params/enableSwerving", m_PlanningParams.enableSwerving);
 	if(m_PlanningParams.enableSwerving)
 		m_PlanningParams.enableFollowing = true;
 	else
-		_nh.getParam("/op_trajectory_generator/enableFollowing", m_PlanningParams.enableFollowing);
+		_nh.getParam("/op_common_params/enableFollowing", m_PlanningParams.enableFollowing);
 
-	_nh.getParam("/op_trajectory_generator/enableHeadingSmoothing", m_PlanningParams.enableHeadingSmoothing);
-	_nh.getParam("/op_trajectory_generator/enableTrafficLightBehavior", m_PlanningParams.enableTrafficLightBehavior);
-	_nh.getParam("/op_trajectory_generator/enableStopSignBehavior", m_PlanningParams.enableStopSignBehavior);
+	_nh.getParam("/op_common_params/enableTrafficLightBehavior", m_PlanningParams.enableTrafficLightBehavior);
+	_nh.getParam("/op_common_params/enableStopSignBehavior", m_PlanningParams.enableStopSignBehavior);
 
-	_nh.getParam("/op_trajectory_generator/maxVelocity", m_PlanningParams.maxSpeed);
-	_nh.getParam("/op_trajectory_generator/minVelocity", m_PlanningParams.minSpeed);
-	_nh.getParam("/op_trajectory_generator/maxLocalPlanDistance", m_PlanningParams.microPlanDistance);
-	_nh.getParam("/op_trajectory_generator/samplingTipMargin", m_PlanningParams.carTipMargin);
-	_nh.getParam("/op_trajectory_generator/samplingOutMargin", m_PlanningParams.rollInMargin);
-	_nh.getParam("/op_trajectory_generator/samplingSpeedFactor", m_PlanningParams.rollInSpeedFactor);
+	_nh.getParam("/op_common_params/maxVelocity", m_PlanningParams.maxSpeed);
+	_nh.getParam("/op_common_params/minVelocity", m_PlanningParams.minSpeed);
+	_nh.getParam("/op_common_params/maxLocalPlanDistance", m_PlanningParams.microPlanDistance);
 
-	_nh.getParam("/op_trajectory_generator/pathDensity", m_PlanningParams.pathDensity);
-	_nh.getParam("/op_trajectory_generator/rollOutDensity", m_PlanningParams.rollOutDensity);
+	_nh.getParam("/op_common_params/pathDensity", m_PlanningParams.pathDensity);
+	_nh.getParam("/op_common_params/rollOutDensity", m_PlanningParams.rollOutDensity);
 	if(m_PlanningParams.enableSwerving)
-		_nh.getParam("/op_trajectory_generator/rollOutsNumber", m_PlanningParams.rollOutNumber);
+		_nh.getParam("/op_common_params/rollOutsNumber", m_PlanningParams.rollOutNumber);
 	else
 		m_PlanningParams.rollOutNumber = 0;
 
-	_nh.getParam("/op_trajectory_generator/horizonDistance", m_PlanningParams.horizonDistance);
-	_nh.getParam("/op_trajectory_generator/minFollowingDistance", m_PlanningParams.minFollowingDistance);
-	_nh.getParam("/op_trajectory_generator/minDistanceToAvoid", m_PlanningParams.minDistanceToAvoid);
-	_nh.getParam("/op_trajectory_generator/maxDistanceToAvoid", m_PlanningParams.maxDistanceToAvoid);
-	_nh.getParam("/op_trajectory_generator/speedProfileFactor", m_PlanningParams.speedProfileFactor);
+	_nh.getParam("/op_common_params/horizonDistance", m_PlanningParams.horizonDistance);
+	_nh.getParam("/op_common_params/minFollowingDistance", m_PlanningParams.minFollowingDistance);
+	_nh.getParam("/op_common_params/minDistanceToAvoid", m_PlanningParams.minDistanceToAvoid);
+	_nh.getParam("/op_common_params/maxDistanceToAvoid", m_PlanningParams.maxDistanceToAvoid);
+	_nh.getParam("/op_common_params/speedProfileFactor", m_PlanningParams.speedProfileFactor);
+
+	_nh.getParam("/op_common_params/smoothingDataWeight", m_PlanningParams.smoothingDataWeight);
+	_nh.getParam("/op_common_params/smoothingSmoothWeight", m_PlanningParams.smoothingSmoothWeight);
+
+	_nh.getParam("/op_common_params/horizontalSafetyDistance", m_PlanningParams.horizontalSafetyDistancel);
+	_nh.getParam("/op_common_params/verticalSafetyDistance", m_PlanningParams.verticalSafetyDistance);
 
-	_nh.getParam("/op_trajectory_generator/horizontalSafetyDistance", m_PlanningParams.horizontalSafetyDistancel);
-	_nh.getParam("/op_trajectory_generator/verticalSafetyDistance", m_PlanningParams.verticalSafetyDistance);
+	_nh.getParam("/op_common_params/enableLaneChange", m_PlanningParams.enableLaneChange);
 
-	_nh.getParam("/op_trajectory_generator/enableLaneChange", m_PlanningParams.enableLaneChange);
-	_nh.getParam("/op_trajectory_generator/enabTrajectoryVelocities", m_PlanningParams.enabTrajectoryVelocities);
+	_nh.getParam("/op_common_params/width", m_CarInfo.width);
+	_nh.getParam("/op_common_params/length", m_CarInfo.length);
+	_nh.getParam("/op_common_params/wheelBaseLength", m_CarInfo.wheel_base);
+	_nh.getParam("/op_common_params/turningRadius", m_CarInfo.turning_radius);
+	_nh.getParam("/op_common_params/maxSteerAngle", m_CarInfo.max_steer_angle);
+	_nh.getParam("/op_common_params/maxAcceleration", m_CarInfo.max_acceleration);
+	_nh.getParam("/op_common_params/maxDeceleration", m_CarInfo.max_deceleration);
 
-	_nh.getParam("/op_trajectory_generator/width", m_CarInfo.width);
-	_nh.getParam("/op_trajectory_generator/length", m_CarInfo.length);
-	_nh.getParam("/op_trajectory_generator/wheelBaseLength", m_CarInfo.wheel_base);
-	_nh.getParam("/op_trajectory_generator/turningRadius", m_CarInfo.turning_radius);
-	_nh.getParam("/op_trajectory_generator/maxSteerAngle", m_CarInfo.max_steer_angle);
 	m_CarInfo.max_speed_forward = m_PlanningParams.maxSpeed;
 	m_CarInfo.min_speed_forward = m_PlanningParams.minSpeed;
 
@@ -145,7 +149,7 @@ void TrajectoryGen::callbackGetCurrentPose(const geometry_msgs::PoseStampedConst
 void TrajectoryGen::callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr&amp; msg)
 {
 	m_VehicleStatus.speed = msg-&gt;twist.linear.x;
-
+	m_CurrentPos.v = m_VehicleStatus.speed;
 	if(fabs(msg-&gt;twist.linear.x) &gt; 0.25)
 		m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg-&gt;twist.angular.z/msg-&gt;twist.linear.x);
 	UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
@@ -172,57 +176,27 @@ void TrajectoryGen::callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayC
 {
 	if(msg-&gt;lanes.size() &gt; 0)
 	{
-
 		bool bOldGlobalPath = m_GlobalPaths.size() == msg-&gt;lanes.size();
 
 		m_GlobalPaths.clear();
 
 		for(unsigned int i = 0 ; i &lt; msg-&gt;lanes.size(); i++)
 		{
-			std::vector&lt;PlannerHNS::WayPoint&gt; path;
-			for(unsigned int j = 0 ; j &lt; msg-&gt;lanes.at(i).waypoints.size(); j++)
-			{
-				PlannerHNS::WayPoint wp(msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.x,
-						msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.y,
-						msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.z,
-						tf::getYaw(msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.orientation));
-				wp.v = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.linear.x;
-				wp.laneId = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.linear.y;
-				wp.stopLineID = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.linear.z;
-				wp.laneChangeCost = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.angular.x;
-				wp.LeftLaneId = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.angular.y;
-				wp.RightLaneId = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.angular.z;
-
-				if(msg-&gt;lanes.at(i).waypoints.at(j).dtlane.dir == 0)
-					wp.bDir = PlannerHNS::FORWARD_DIR;
-				else if(msg-&gt;lanes.at(i).waypoints.at(j).dtlane.dir == 1)
-					wp.bDir = PlannerHNS::FORWARD_LEFT_DIR;
-				else if(msg-&gt;lanes.at(i).waypoints.at(j).dtlane.dir == 2)
-					wp.bDir = PlannerHNS::FORWARD_RIGHT_DIR;
-
-				path.push_back(wp);
-			}
+			PlannerHNS::RosHelpers::ConvertFromAutowareLaneToLocalLane(msg-&gt;lanes.at(i), m_temp_path);
 
-			PlannerHNS::PlanningHelpers::CalcAngleAndCost(path);
-			m_GlobalPaths.push_back(path);
+			PlannerHNS::PlanningHelpers::CalcAngleAndCost(m_temp_path);
+			m_GlobalPaths.push_back(m_temp_path);
 
 			if(bOldGlobalPath)
 			{
-				bOldGlobalPath = PlannerHNS::PlanningHelpers::CompareTrajectories(path, m_GlobalPaths.at(i));
+				bOldGlobalPath = PlannerHNS::PlanningHelpers::CompareTrajectories(m_temp_path, m_GlobalPaths.at(i));
 			}
 		}
 
 		if(!bOldGlobalPath)
 		{
 			bWayGlobalPath = true;
-			for(unsigned int i = 0; i &lt; m_GlobalPaths.size(); i++)
-			{
-				PlannerHNS::PlanningHelpers::FixPathDensity(m_GlobalPaths.at(i), m_PlanningParams.pathDensity);
-				PlannerHNS::PlanningHelpers::SmoothPath(m_GlobalPaths.at(i), 0.49, 0.25, 0.05);
-
-				PlannerHNS::PlanningHelpers::GenerateRecommendedSpeed(m_GlobalPaths.at(i), m_CarInfo.max_speed_forward, m_PlanningParams.speedProfileFactor);
-				m_GlobalPaths.at(i).at(m_GlobalPaths.at(i).size()-1).v = 0;
-			}
+			std::cout &lt;&lt; "Received New Global Path Generator ! " &lt;&lt; std::endl;
 		}
 		else
 		{
@@ -248,13 +222,8 @@ void TrajectoryGen::MainLoop()
 			for(unsigned int i = 0; i &lt; m_GlobalPaths.size(); i++)
 			{
 				t_centerTrajectorySmoothed.clear();
-				PlannerHNS::PlanningHelpers::ExtractPartFromPointToDistanceFast(m_GlobalPaths.at(i), m_CurrentPos,
-						m_PlanningParams.horizonDistance ,
-						m_PlanningParams.pathDensity ,
-						t_centerTrajectorySmoothed,
-						m_PlanningParams.smoothingDataWeight,
-						m_PlanningParams.smoothingSmoothWeight,
-						m_PlanningParams.smoothingToleranceError);
+				PlannerHNS::PlanningHelpers::ExtractPartFromPointToDistanceDirectionFast(m_GlobalPaths.at(i), m_CurrentPos, m_PlanningParams.horizonDistance ,
+						m_PlanningParams.pathDensity ,t_centerTrajectorySmoothed);
 
 				m_GlobalPathSections.push_back(t_centerTrajectorySmoothed);
 			}
@@ -279,6 +248,24 @@ void TrajectoryGen::MainLoop()
 								m_PlanningParams.enableHeadingSmoothing,
 								-1 , -1,
 								m_RollOuts, sampledPoints_debug);
+
+			autoware_msgs::LaneArray local_lanes;
+			for(unsigned int i=0; i &lt; m_RollOuts.size(); i++)
+			{
+				for(unsigned int j=0; j &lt; m_RollOuts.at(i).size(); j++)
+				{
+					autoware_msgs::lane lane;
+					PlannerHNS::PlanningHelpers::PredictConstantTimeCostForTrajectory(m_RollOuts.at(i).at(j), m_CurrentPos, m_PlanningParams.minSpeed, m_PlanningParams.microPlanDistance);
+					PlannerHNS::RosHelpers::ConvertFromLocalLaneToAutowareLane(m_RollOuts.at(i).at(j), lane);
+					lane.closest_object_distance = 0;
+					lane.closest_object_velocity = 0;
+					lane.cost = 0;
+					lane.is_blocked = false;
+					lane.lane_index = i;
+					local_lanes.lanes.push_back(lane);
+				}
+			}
+			pub_LocalTrajectories.publish(local_lanes);
 		}
 		else
 			sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 	1,		&amp;TrajectoryGen::callbackGetGlobalPlannerPath, 	this);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\OpenPlannerSimulator_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_car_simulator_core.h" added_lines="72" deleted_lines="35">
				<diff>@@ -28,14 +28,10 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#ifndef OpenPlannerSimulator_CORE_H
-#define OpenPlannerSimulator_CORE_H
+#ifndef OP_CAR_SIMULATOR
+#define OP_CAR_SIMULATOR
 
-#define _ENABLE_ZMP_LIBRARY_LINK
-
-// ROS includes
 #include &lt;ros/ros.h&gt;
-#include "autoware_msgs/obj_label.h"
 
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
@@ -45,22 +41,35 @@
 #include &lt;tf/transform_listener.h&gt;
 #include &lt;tf/tf.h&gt;
 #include &lt;std_msgs/Int8.h&gt;
-#include "op_simu/TrajectoryFollower.h"
-#include "op_planner/LocalPlannerH.h"
-#include "op_planner/PlannerH.h"
-#include "op_planner/MappingHelpers.h"
+
 
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;visualization_msgs/InteractiveMarkerPose.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;std_msgs/Float32.h&gt;
-#include "autoware_msgs/CloudCluster.h"
+#include "autoware_msgs/Signals.h"
+#include "autoware_msgs/DetectedObjectArray.h"
 #include "autoware_msgs/CloudClusterArray.h"
+#include "sensor_msgs/Joy.h"
+
+#include "op_simu/TrajectoryFollower.h"
+#include "op_planner/LocalPlannerH.h"
+#include "op_planner/PlannerH.h"
+#include "op_planner/MappingHelpers.h"
+
 #include "op_simu/SimpleTracker.h"
+#include "op_planner/SimuDecisionMaker.h"
+
 
-namespace OpenPlannerSimulatorNS
+namespace CarSimulatorNS
 {
 
+#define STEERING_AXIS 0
+#define ACCELERATION_AXIS 1
+#define BRAKE_AXIS 2
+#define BUTTON_INDEX 0
+#define START_BUTTON_VALUE 512
+
 enum MAP_SOURCE_TYPE{MAP_AUTOWARE, MAP_FOLDER, MAP_KML_FILE};
 
 class SimuCommandParams
@@ -72,17 +81,20 @@ public:
 	std::string 	meshPath;
 	std::string 	logPath;
 	MAP_SOURCE_TYPE	mapSource;
-	bool			bRandomStart;
+	bool			bRvizPositions;
 	bool 			bLooper;
 	PlannerHNS::WayPoint startPose;
+	PlannerHNS::WayPoint goalPose;
 	std_msgs::ColorRGBA modelColor;
+	bool			bEnableLogs;
 
 	SimuCommandParams()
 	{
-		id = 0;
-		bRandomStart = false;
+		id = 1;
+		bEnableLogs = true;
 		bLooper = false;
-		mapSource = MAP_KML_FILE;
+		bRvizPositions = true;
+		mapSource = MAP_FOLDER;
 		modelColor.a = 1;
 		modelColor.b = 1;
 		modelColor.r = 1;
@@ -90,51 +102,81 @@ public:
 	}
 };
 
-class OpenPlannerSimulator
+class OpenPlannerCarSimulator
 {
 protected:
 	timespec m_PlanningTimer;
 	geometry_msgs::Pose m_OriginPos;
 
+
+	std::string m_BaseLinkFrameID;
+	std::string m_VelodyneFrameID;
+
+	bool m_bStepByStep;
+	bool m_bSimulatedVelodyne;
+	bool m_bGoNextStep;
 	bool 						m_bMap;
 	PlannerHNS::RoadNetwork		m_Map;
 	PlannerHNS::PlannerH		m_GlobalPlanner;
-	PlannerHNS::LocalPlannerH 	m_LocalPlanner;
+	PlannerHNS::SimuDecisionMaker* 	m_LocalPlanner;
 	SimulationNS::TrajectoryFollower m_PredControl;
-	SimulationNS::SimpleTracker m_ObstacleTracking;
-	std::vector&lt;PlannerHNS::DetectedObject&gt; m_OriginalClusters;
-	std::vector&lt;PlannerHNS::DetectedObject&gt; m_TrackedClusters;
+	std::vector&lt;PlannerHNS::DetectedObject&gt; m_PredictedObjects;
+	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; m_GlobalPaths;
+	PlannerHNS::VehicleState  m_JoyDesiredStatus;
+	bool bPredictedObjects;
 
 	bool bInitPos;
-	bool bNewClusters;
+	bool bGoalPos;
+	bool bUseWheelController;
+	bool bNewLightSignal;
+	std::vector&lt;PlannerHNS::TrafficLight&gt; m_CurrTrafficLight;
+	std::vector&lt;PlannerHNS::TrafficLight&gt; m_PrevTrafficLight;
 
 
 	SimuCommandParams m_SimParams;
 	PlannerHNS::CAR_BASIC_INFO m_CarInfo;
 	PlannerHNS::ControllerParams m_ControlParams;
 	PlannerHNS::PlanningParams m_PlanningParams;
+	PlannerHNS::BehaviorState m_CurrBehavior;
+
+	ros::NodeHandle nh;
+
+	tf::TransformListener m_Listener;
 
 	ros::Publisher pub_SafetyBorderRviz;
 	ros::Publisher pub_SimuBoxPose;
-	//ros::Publisher pub_SimuVelocity;
 	ros::Publisher pub_CurrPoseRviz;
 	ros::Publisher pub_LocalTrajectoriesRviz;
 	ros::Publisher pub_BehaviorStateRviz;
+	ros::Publisher pub_PointerBehaviorStateRviz;
+	ros::Publisher pub_InternalInfoRviz;
+	ros::Publisher pub_SimulatedVelodyne;
+	ros::Publisher pub_CurrentLocalPath;
 
 	// define subscribers.
 	ros::Subscriber sub_initialpose;
-	ros::Subscriber sub_cloudClusters;
+	ros::Subscriber sub_goalpose;
+	ros::Subscriber sub_predicted_objects;
+	ros::Subscriber sub_TrafficLightSignals	;
+	ros::Subscriber sub_StepSignal;
+	ros::Subscriber sub_cloud_clusters;
+	ros::Subscriber sub_joystick;
 
 	// Callback function for subscriber.
 	void callbackGetInitPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;msg);
+	void callbackGetGoalPose(const geometry_msgs::PoseStampedConstPtr &amp;msg);
+	void callbackGetPredictedObjects(const autoware_msgs::DetectedObjectArrayConstPtr&amp; msg);
+	void callbackGetTrafficLightSignals(const autoware_msgs::Signals&amp; msg);
+	void callbackGetStepForwardSignals(const geometry_msgs::TwistStampedConstPtr&amp; msg);
 	void callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr&amp; msg);
+	void callbackGetJoyStickInfo(const sensor_msgs::JoyConstPtr&amp; msg);
 
 public:
-	OpenPlannerSimulator();
+	OpenPlannerCarSimulator();
 
-	virtual ~OpenPlannerSimulator();
+	virtual ~OpenPlannerCarSimulator();
 
-	void PlannerMainLoop();
+	void MainLoop();
 
   void GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform);
 
@@ -144,19 +186,14 @@ public:
   void displayFollowingInfo(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; safety_rect, PlannerHNS::WayPoint&amp; curr_pose);
   void visualizePath(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path);
 
-  void ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::CAR_BASIC_INFO&amp; car_info,
-  		const autoware_msgs::CloudClusterArray&amp; clusters, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list,
-  		int&amp; nOriginalPoints, int&amp; nContourPoints);
-
-  PlannerHNS::WayPoint GetRealCenter(const PlannerHNS::WayPoint&amp; currState);
-
   void visualizeBehaviors();
 
   void SaveSimulationData();
-  bool LoadSimulationData(PlannerHNS::WayPoint&amp; start_p);
+  int LoadSimulationData(PlannerHNS::WayPoint&amp; start_p, PlannerHNS::WayPoint&amp; goal_p);
   void InitializeSimuCar(PlannerHNS::WayPoint start_pose);
+  void PublishSpecialTF(const PlannerHNS::WayPoint&amp; pose);
 };
 
 }
 
-#endif  // OpenPlannerSimulator_H
+#endif  // OP_CAR_SIMULATOR
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\OpenPlannerSimulatorPerception_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_perception_simulator_core.h" added_lines="11" deleted_lines="6">
				<diff>@@ -28,10 +28,8 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#ifndef OpenPlannerSimulatorPerception_CORE_H
-#define OpenPlannerSimulatorPerception_CORE_H
-
-#define _ENABLE_ZMP_LIBRARY_LINK
+#ifndef OP_PERCEPTION_SIMULATOR
+#define OP_PERCEPTION_SIMULATOR
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
@@ -48,13 +46,17 @@
 #include &lt;visualization_msgs/InteractiveMarkerPose.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;std_msgs/Float32.h&gt;
+#include &lt;geometry_msgs/PoseArray.h&gt;
 
 #include "autoware_msgs/CloudCluster.h"
 #include "autoware_msgs/CloudClusterArray.h"
 #include &lt;geometry_msgs/PoseArray.h&gt;
 
+#define OBJECT_KEEP_TIME 1
+#define POINT_CLOUD_ADDTIONAL_ERR_NUM 25
+#define CONTOUR_DISTANCE_ERROR 0.5
 
-namespace OpenPlannerSimulatorPerceptionNS
+namespace PerceptionSimulatorNS
 {
 
 class DetectionCommandParams
@@ -62,11 +64,13 @@ class DetectionCommandParams
 public:
 	int 	nSimuObjs;
 	double 	errFactor;
+	double  nPointsPerObj;
 
 	DetectionCommandParams()
 	{
 		nSimuObjs = 3;
 		errFactor = 0;
+		nPointsPerObj = 50;
 	}
 };
 
@@ -93,9 +97,10 @@ public:
 	OpenPlannerSimulatorPerception();
 	virtual ~OpenPlannerSimulatorPerception();
 	autoware_msgs::CloudCluster GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::Pose&amp; centerPose);
+
 	void MainLoop();
 };
 
 }
 
-#endif  // OpenPlannerSimulatorPerception_H
+#endif  // OP_PERCEPTION_SIMULATOR
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\OpenPlannerSimulator.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -27,13 +27,13 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "../include/OpenPlannerSimulator_core.h"
+#include "../include/op_car_simulator_core.h"
 
 
 int main(int argc, char **argv)
 {
-	ros::init(argc, argv, "op_simulator");
-	OpenPlannerSimulatorNS::OpenPlannerSimulator  simulator;
-	simulator.PlannerMainLoop();
+	ros::init(argc, argv, "op_car_simulator");
+	CarSimulatorNS::OpenPlannerCarSimulator simulator;
+	simulator.MainLoop();
 	return 0;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\nodes\OpenPlannerSimulatorPerception.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_perception_simulator\op_perception_simulator.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -27,13 +27,13 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "../include/OpenPlannerSimulatorPerception_core.h"
+#include "../include/op_perception_simulator_core.h"
 
 
 int main(int argc, char **argv)
 {
-	ros::init(argc, argv, "op_simulator_perception");
-	OpenPlannerSimulatorPerceptionNS::OpenPlannerSimulatorPerception  detector;
+	ros::init(argc, argv, "op_perception_simulator");
+	PerceptionSimulatorNS::OpenPlannerSimulatorPerception  detector;
 	detector.MainLoop();
 	return 0;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\nodes\OpenPlannerSimulatorPerception_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_perception_simulator\op_perception_simulator_core.cpp" added_lines="99" deleted_lines="46">
				<diff>@@ -27,42 +27,48 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "../include/OpenPlannerSimulatorPerception_core.h"
-
-#include "op_utility/UtilityH.h"
-#include "math.h"
-#include "op_planner/MatrixOperations.h"
+#include "op_perception_simulator_core.h"
 
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include &lt;pcl/io/io.h&gt;
 #include &lt;pcl/io/pcd_io.h&gt;
 #include &lt;pcl/point_types.h&gt;
+#include &lt;boost/random.hpp&gt;
+#include &lt;boost/math/distributions/normal.hpp&gt;
 
-using namespace std;
+#include "op_utility/UtilityH.h"
+#include "math.h"
+#include "op_planner/MatrixOperations.h"
 
-namespace OpenPlannerSimulatorPerceptionNS
+namespace PerceptionSimulatorNS
 {
 
+typedef boost::mt19937 ENG;
+typedef boost::normal_distribution&lt;double&gt; NormalDIST;
+typedef boost::variate_generator&lt;ENG, NormalDIST&gt; VariatGEN;
+
 OpenPlannerSimulatorPerception::OpenPlannerSimulatorPerception()
 {
-	nh.getParam("/op_simulator_perception/simObjNumber" 			, m_DecParams.nSimuObjs);
-	nh.getParam("/op_simulator_perception/GuassianErrorFactor" 	, m_DecParams.errFactor);
+	nh.getParam("/op_perception_simulator/simObjNumber" , m_DecParams.nSimuObjs);
+	nh.getParam("/op_perception_simulator/GuassianErrorFactor" , m_DecParams.errFactor);
+	nh.getParam("/op_perception_simulator/pointCloudPointsNumber" , m_DecParams.nPointsPerObj);
 
-	pub_DetectedObjects 	= nh.advertise&lt;autoware_msgs::CloudClusterArray&gt;("cloud_clusters",1);
+	pub_DetectedObjects = nh.advertise&lt;autoware_msgs::CloudClusterArray&gt;("cloud_clusters",1);
 
 	for(int i=1; i &lt;= m_DecParams.nSimuObjs; i++)
 	{
 		std::ostringstream str_pose;
-		str_pose &lt;&lt; "/op_simulator" &lt;&lt; i &lt;&lt; "/sim_box_pose_" &lt;&lt; i;
+		//str_pose &lt;&lt; "/op_car_simulator" &lt;&lt; i &lt;&lt; "/sim_box_pose_" &lt;&lt; i;
+		str_pose &lt;&lt; "/sim_box_pose_" &lt;&lt; i;
 		std::cout &lt;&lt; "Subscribe to Topic : " &lt;&lt;  str_pose.str() &lt;&lt;  std::endl;
 
 		ros::Subscriber _sub;
-		_sub =  nh.subscribe(str_pose.str(), 10, &amp;OpenPlannerSimulatorPerception::callbackGetSimuData, 		this);
+		_sub =  nh.subscribe(str_pose.str(), 10, &amp;OpenPlannerSimulatorPerception::callbackGetSimuData, this);
 		sub_objs.push_back(_sub);
 	}
 
 	ros::Subscriber _sub;
-	_sub =  nh.subscribe("/sim_box_pose_ego", 10, &amp;OpenPlannerSimulatorPerception::callbackGetSimuData, 		this);
+	_sub =  nh.subscribe("/sim_box_pose_ego", 10, &amp;OpenPlannerSimulatorPerception::callbackGetSimuData, this);
 	sub_objs.push_back(_sub);
 
 	std::cout &lt;&lt; "OpenPlannerSimulatorPerception initialized successfully " &lt;&lt; std::endl;
@@ -76,83 +82,130 @@ OpenPlannerSimulatorPerception::~OpenPlannerSimulatorPerception()
 void OpenPlannerSimulatorPerception::callbackGetSimuData(const geometry_msgs::PoseArray &amp;msg)
 {
 	int obj_id = -1;
+	double actual_speed = 0;
+	double actual_steering  = 0;
+	int indicator = 3;
+
 	if(msg.poses.size() &gt; 0 )
 	{
 		obj_id = msg.poses.at(0).position.x;
+		actual_speed = msg.poses.at(0).position.y;
+		actual_steering = msg.poses.at(0).position.z;
+	}
 
+	if(msg.poses.size() == 4)
+	{
+		indicator = msg.poses.at(3).orientation.w;
 	}
 
 //	ROS_INFO("Obj ID = %d", obj_id);
 
+
 	if(obj_id &lt; 0)
 		return;
 
 	int index = -1;
-	for(int i = 0; i &lt; m_ObjClustersArray.clusters.size() ; i++ )
+	for(unsigned int i = 0; i &lt; m_ObjClustersArray.clusters.size() ; i++ )
 	{
-		if(m_ObjClustersArray.clusters.at(i).id == obj_id)
+		if((int)m_ObjClustersArray.clusters.at(i).id == obj_id)
 		{
 			index = i;
 			break;
 		}
 	}
 
-	autoware_msgs::CloudCluster c = GenerateSimulatedObstacleCluster(msg.poses.at(2).position.y, msg.poses.at(2).position.x, msg.poses.at(2).position.y, 50, msg.poses.at(1));
+	timespec t;
+	UtilityHNS::UtilityH::GetTickCount(t);
+	srand(t.tv_nsec);
+	int nPoints = m_DecParams.nPointsPerObj + (rand()%POINT_CLOUD_ADDTIONAL_ERR_NUM - POINT_CLOUD_ADDTIONAL_ERR_NUM/2);
+
+	autoware_msgs::CloudCluster c = GenerateSimulatedObstacleCluster(msg.poses.at(2).position.y, msg.poses.at(2).position.x, msg.poses.at(2).position.z, nPoints, msg.poses.at(1));
 	c.id = obj_id;
+	c.score = actual_speed;
+	c.indicator_state = indicator;
 
 	if(index &gt;= 0) // update existing
 	{
 		m_ObjClustersArray.clusters.at(index) = c;
-		m_keepTime.at(index).second = 10;
+		m_keepTime.at(index).second = OBJECT_KEEP_TIME;
 	//	ROS_INFO("Update Obj ID = %d", c.id);
 	}
 	else
 	{
 		m_ObjClustersArray.clusters.push_back(c);
-		m_keepTime.push_back(make_pair(c.id, 10));
+		m_keepTime.push_back(std::make_pair(c.id, OBJECT_KEEP_TIME));
 	//	ROS_INFO("Insert Obj ID = %d", c.id);
 	}
 
-//	geometry_msgs::Pose p;
-//	p.position.x  = msg-&gt;pose.position.x + m_OriginPos.position.x;
-//	p.position.y  = msg-&gt;pose.position.y + m_OriginPos.position.y;
-//	p.position.z  = msg-&gt;pose.position.z + m_OriginPos.position.z;
-//	p.orientation = msg-&gt;pose.orientation;
-
-	//m_SimParams.startPose =  PlannerHNS::WayPoint(p.position.x, p.position.y, p.position.z , tf::getYaw(p.orientation));
-
 }
 
-autoware_msgs::CloudCluster OpenPlannerSimulatorPerception::GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::Pose&amp; centerPose)
+
+autoware_msgs::CloudCluster OpenPlannerSimulatorPerception::GenerateSimulatedObstacleCluster(const double&amp; width, const double&amp; length, const double&amp; height, const int&amp; nPoints, const geometry_msgs::Pose&amp; centerPose)
 {
 	autoware_msgs::CloudCluster cluster;
 
-	cluster.centroid_point.point.x = centerPose.position.x;
-	cluster.centroid_point.point.y = centerPose.position.y;
+	timespec t;
+	UtilityHNS::UtilityH::GetTickCount(t);
+	srand(t.tv_nsec);
+
+	ENG eng(t.tv_nsec);
+	NormalDIST dist_x(0, m_DecParams.errFactor);
+	VariatGEN gen_x(eng, dist_x);
+
+	cluster.centroid_point.point.x = centerPose.position.x + gen_x();
+	cluster.centroid_point.point.y = centerPose.position.y + gen_x();
 	cluster.centroid_point.point.z = centerPose.position.z;
 
-	cluster.dimensions.x = x_rand;
-	cluster.dimensions.y = y_rand;
-	cluster.dimensions.z = z_rand;
-	pcl::PointCloud&lt;pcl::PointXYZ&gt; point_cloud;
+	cluster.avg_point.point.x = centerPose.position.x;
+	cluster.avg_point.point.y = centerPose.position.y;
+	cluster.avg_point.point.z = centerPose.position.z;
+
+	double yaw_angle = tf::getYaw(centerPose.orientation);
+	cluster.estimated_angle = yaw_angle;
+
+	cluster.dimensions.x = width;
+	cluster.dimensions.y = length;
+	cluster.dimensions.z = height;
+	pcl::PointCloud&lt;pcl::PointXYZI&gt; point_cloud;
+
+	PlannerHNS::Mat3 rotationMat(yaw_angle);
+	PlannerHNS::Mat3 translationMat(cluster.avg_point.point.x, cluster.avg_point.point.y);
 
-	timespec t;
 	for(int i=1; i &lt; nPoints; i++)
 	{
 		UtilityHNS::UtilityH::GetTickCount(t);
-		pcl::PointXYZ p;
+		PlannerHNS::WayPoint center_p;
+		srand(t.tv_nsec);
+
+		center_p.pos.x = ((double)(rand()%100)/100.0 - CONTOUR_DISTANCE_ERROR);
+//		if(center_p.pos.x &gt;=0 &amp;&amp; center_p.pos.x &lt;= CONTOUR_DISTANCE_ERROR)
+//			center_p.pos.x += CONTOUR_DISTANCE_ERROR;
+//		else if(center_p.pos.x &lt; 0 &amp;&amp; center_p.pos.x &gt;= -CONTOUR_DISTANCE_ERROR)
+//			center_p.pos.x -= CONTOUR_DISTANCE_ERROR;
+
+		center_p.pos.x *= width;
+
 		srand(t.tv_nsec/i);
-		double x = (double)(rand()%100)/100.0 - 0.5;
+		center_p.pos.y = ((double)(rand()%100)/100.0 - CONTOUR_DISTANCE_ERROR);
+
+//		if(center_p.pos.y &gt;=0 &amp;&amp; center_p.pos.y &lt;= CONTOUR_DISTANCE_ERROR)
+//			center_p.pos.y += CONTOUR_DISTANCE_ERROR;
+//		else if(center_p.pos.y &lt; 0 &amp;&amp; center_p.pos.y &gt;= -CONTOUR_DISTANCE_ERROR)
+//			center_p.pos.y -= CONTOUR_DISTANCE_ERROR;
+
+		center_p.pos.y *= length;
 
 		srand(t.tv_nsec/i*i);
-		double y = (double)(rand()%100)/100.0 - 0.5;
+		center_p.pos.z = ((double)(rand()%100)/100.0 - CONTOUR_DISTANCE_ERROR)* height;
 
-		srand(t.tv_nsec);
-		double z = (double)(rand()%100)/100.0 - 0.5;
+		center_p.pos = rotationMat*center_p.pos;
+		center_p.pos = translationMat*center_p.pos;
+
+		pcl::PointXYZI p;
+		p.x = center_p.pos.x;
+		p.y = center_p.pos.y;
+		p.z = center_p.pos.z;
 
-		p.x = centerPose.position.x + x*x_rand;
-		p.y = centerPose.position.y + y*y_rand;
-		p.z = centerPose.position.z + z*z_rand;
 		point_cloud.points.push_back(p);
 	}
 
@@ -170,9 +223,7 @@ void OpenPlannerSimulatorPerception::MainLoop()
 	{
 		ros::spinOnce();
 
-		if(m_ObjClustersArray.clusters.size()&gt;0)
-			pub_DetectedObjects.publish(m_ObjClustersArray);
-
+		//if(m_ObjClustersArray.clusters.size()&gt;0)
 		//clean old data
 		for(unsigned int i = 0 ; i &lt; m_keepTime.size(); i++)
 		{
@@ -186,7 +237,9 @@ void OpenPlannerSimulatorPerception::MainLoop()
 				m_keepTime.at(i).second -= 1;
 		}
 
-		std::cout &lt;&lt; "Number of Obstacles: (" &lt;&lt; m_keepTime.size() &lt;&lt; ", " &lt;&lt; m_ObjClustersArray.clusters.size() &lt;&lt; ") "&lt;&lt; std::endl;
+		pub_DetectedObjects.publish(m_ObjClustersArray);
+
+	//	std::cout &lt;&lt; "Number of Obstacles: (" &lt;&lt; m_keepTime.size() &lt;&lt; ", " &lt;&lt; m_ObjClustersArray.clusters.size() &lt;&lt; ") "&lt;&lt; std::endl;
 
 		loop_rate.sleep();
 	}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\PolygonGenerator.h" new_path="" added_lines="0" deleted_lines="115">
				<diff>@@ -1,115 +0,0 @@
-/*
- * PolygonGenerator.h
- *
- *  Created on: Nov 2, 2016
- *      Author: ai-driver
- */
-
-#ifndef POLYGONGENERATORSIMU_H_
-#define POLYGONGENERATORSIMU_H_
-
-#include "op_planner/RoadNetwork.h"
-#include "op_planner/PlanningHelpers.h"
-
-
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-#include &lt;visualization_msgs/Marker.h&gt;
-#include &lt;pcl_conversions/pcl_conversions.h&gt;
-#include &lt;pcl/io/io.h&gt;
-#include &lt;pcl/io/pcd_io.h&gt;
-#include &lt;pcl/point_types.h&gt;
-
-namespace OpenPlannerSimulatorNS
-{
-
-using namespace PlannerHNS;
-
-#define QUARTERS_NUMBER 8
-#define MIN_POINTS_PER_QUARTER 1
-#define MIN_DISTANCE_BETWEEN_CORNERS 0.5
-
-class QuarterView
-{
-public:
-	int id;
-	int min_ang;
-	int max_ang;
-	std::vector&lt;WayPoint&gt; vectorsFromCenter;
-
-	QuarterView(const int&amp; min_a, const int&amp; max_a, const int&amp; index)
-	{
-		min_ang = min_a;
-		max_ang = max_a;
-		id = index;
-	}
-
-	void InitQuarterView(const int&amp; min_a, const int&amp; max_a, const int&amp; index)
-	{
-		min_ang = min_a;
-		max_ang = max_a;
-		id = index;
-	}
-
-	bool UpdateQuarterView(const WayPoint&amp; v)
-	{
-		if(v.pos.a &lt;= min_ang || v.pos.a &gt; max_ang)
-			return false;
-
-		bool bGreaterFound = false;
-		unsigned int greaterIndex = 0;
-		for(unsigned int i=0; i&lt; vectorsFromCenter.size(); i++)
-		{
-			if(vectorsFromCenter.at(i).cost &gt; v.cost)
-			{
-				bGreaterFound = true;
-				greaterIndex = i;
-				break;
-			}
-		}
-
-		if(bGreaterFound)
-		{
-			if(greaterIndex &lt; vectorsFromCenter.size())
-				vectorsFromCenter.insert(vectorsFromCenter.begin()+greaterIndex, v);
-			else
-				vectorsFromCenter.push_back(v);
-		}
-		else
-			vectorsFromCenter.push_back(v);
-
-		return true;
-
-	}
-
-	bool GetMaxPoint(WayPoint&amp; maxPoint)
-	{
-		if(vectorsFromCenter.size()==0)
-			return false;
-
-		maxPoint = vectorsFromCenter.at(vectorsFromCenter.size()-1);
-		return vectorsFromCenter.size();
-	}
-
-	int GetPointsNumber()
-	{
-		return vectorsFromCenter.size();
-	}
-};
-
-class PolygonGenerator
-{
-
-public:
-
-	GPSPoint m_Centroid;
-	PolygonGenerator();
-	virtual ~PolygonGenerator();
-	void CheckConvexPoligon(std::vector&lt;WayPoint&gt;&amp; polygon);
-	GPSPoint CalculateCentroid(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster);
-	std::vector&lt;QuarterView&gt; CreateQuarterViews(const int&amp; nResolution);
-	std::vector&lt;GPSPoint&gt; EstimateClusterPolygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster, const GPSPoint&amp; original_centroid );
-};
-
-} /* namespace PlannerSimulator */
-
-#endif /* POLYGONGENERATOR_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\OpenPlannerSimulator_core.cpp" new_path="" added_lines="0" deleted_lines="701">
				<diff>@@ -1,701 +0,0 @@
-/*
- *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#include "../include/OpenPlannerSimulator_core.h"
-
-
-#include "op_utility/UtilityH.h"
-#include "math.h"
-#include "op_planner/MatrixOperations.h"
-#include &lt;geometry_msgs/PoseArray.h&gt;
-#include "PolygonGenerator.h"
-
-using namespace std;
-
-namespace OpenPlannerSimulatorNS
-{
-
-#define REPLANNING_DISTANCE 20
-#define PLANNING_DISTANCE 50
-
-OpenPlannerSimulator::OpenPlannerSimulator()
-{
-
-	m_bMap = false;
-	bNewClusters = false;
-
-	int iSource = 0;
-	ros::NodeHandle nh("~");
-	nh.getParam("mapSource" 			, iSource);
-	if(iSource == 0)
-		m_SimParams.mapSource = MAP_AUTOWARE;
-	else if (iSource == 1)
-		m_SimParams.mapSource = MAP_FOLDER;
-	else if(iSource == 2)
-		m_SimParams.mapSource = MAP_KML_FILE;
-
-	nh.getParam("mapFileName" 		, m_SimParams.KmlMapPath);
-	nh.getParam("id" 		, m_SimParams.strID);
-	nh.getParam("id" 		, m_SimParams.id);
-	nh.getParam("enableRvizPoseEst" 	, m_SimParams.bRandomStart);
-	nh.getParam("enableLooper" 			, m_SimParams.bLooper);
-	nh.getParam("startPoseX" 			, m_SimParams.startPose.pos.x);
-	nh.getParam("startPoseY" 			, m_SimParams.startPose.pos.y);
-	nh.getParam("startPoseA" 			, m_SimParams.startPose.pos.a);
-
-	nh.getParam("meshPath" 				, m_SimParams.meshPath);
-	nh.getParam("baseColorR" 			, m_SimParams.modelColor.r);
-	nh.getParam("baseColorG" 			, m_SimParams.modelColor.g);
-	nh.getParam("baseColorB" 			, m_SimParams.modelColor.b);
-
-	nh.getParam("logFolder" 			, m_SimParams.logPath);
-
-	ReadParamFromLaunchFile(m_CarInfo, m_ControlParams);
-
-	tf::StampedTransform transform;
-	GetTransformFromTF("map", "world", transform);
-	ROS_INFO("Origin : x=%f, y=%f, z=%f", transform.getOrigin().x(),transform.getOrigin().y(), transform.getOrigin().z());
-
-	m_OriginPos.position.x  = transform.getOrigin().x();
-	m_OriginPos.position.y  = transform.getOrigin().y();
-	m_OriginPos.position.z  = transform.getOrigin().z();
-
-
-	m_ObstacleTracking.m_MAX_ASSOCIATION_DISTANCE = 6.0;
-	m_ObstacleTracking.m_dt = 0.12;
-	m_ObstacleTracking.m_bUseCenterOnly = true;
-
-	m_PredControl.Init(m_ControlParams, m_CarInfo, false, false);
-
-	m_LocalPlanner.Init(m_ControlParams, m_PlanningParams, m_CarInfo);
-	m_LocalPlanner.m_SimulationSteeringDelayFactor = 0.2;
-
-	//For rviz visualization
-	std::ostringstream str_s1, str_s2, str_s3, str_s4, str_s5, str_s6;
-	str_s1 &lt;&lt; "curr_simu_pose_";
-	str_s1 &lt;&lt; m_SimParams.id;
-
-	str_s2 &lt;&lt; "sim_beh_txt_" &lt;&lt; m_SimParams.id;
-
-	str_s5 &lt;&lt; "sim_box_pose_";
-	str_s5 &lt;&lt; m_SimParams.id;
-
-	str_s3 &lt;&lt; "sim_velocity_";
-	str_s3 &lt;&lt; m_SimParams.id;
-
-	str_s4 &lt;&lt; "safety_border_";
-	str_s4 &lt;&lt; m_SimParams.id;
-
-	str_s6 &lt;&lt; "simu_local_trajectory_";
-	str_s6 &lt;&lt; m_SimParams.id;
-
-	pub_CurrPoseRviz			= nh.advertise&lt;visualization_msgs::Marker&gt;(str_s1.str() , 100);
-	pub_SimuBoxPose				= nh.advertise&lt;geometry_msgs::PoseArray&gt;(str_s5.str(), 100);
-	//pub_SimuVelocity			= nh.advertise&lt;geometry_msgs::TwistStamped&gt;(str_s3.str(), 100);
-	pub_SafetyBorderRviz  		= nh.advertise&lt;visualization_msgs::Marker&gt;(str_s4.str(), 1);
-	pub_LocalTrajectoriesRviz   = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(str_s6.str(), 1);
-	pub_BehaviorStateRviz		= nh.advertise&lt;visualization_msgs::Marker&gt;(str_s2.str(), 1);
-
-	// define subscribers.
-	if(m_SimParams.bRandomStart)
-	{
-		bInitPos = false;
-		sub_initialpose 		= nh.subscribe("/initialpose", 		100, &amp;OpenPlannerSimulator::callbackGetInitPose, 		this);
-	}
-	else
-	{
-		bInitPos = true;
-		PlannerHNS::WayPoint start_p;
-		if(LoadSimulationData(start_p))
-		{
-			m_SimParams.startPose.pos = start_p.pos;
-			m_CarInfo.max_speed_forward = start_p.v;
-		}
-
-		//InitializeSimuCar(m_SimParams.startPose);
-	}
-
-	sub_cloudClusters 		= nh.subscribe("/cloud_clusters", 	1, &amp;OpenPlannerSimulator::callbackGetCloudClusters, 		this);
-
-	UtilityHNS::UtilityH::GetTickCount(m_PlanningTimer);
-	std::cout &lt;&lt; "OpenPlannerSimulator initialized successfully " &lt;&lt; std::endl;
-}
-
-void OpenPlannerSimulator::ReadParamFromLaunchFile(PlannerHNS::CAR_BASIC_INFO&amp; m_CarInfo,
-		PlannerHNS::ControllerParams&amp; m_ControlParams)
-{
-	ros::NodeHandle nh("~");
-	nh.getParam("width", 			m_CarInfo.width );
-	nh.getParam("length", 		m_CarInfo.length );
-	nh.getParam("wheelBaseLength", m_CarInfo.wheel_base );
-	nh.getParam("turningRadius", m_CarInfo.turning_radius );
-	nh.getParam("maxSteerAngle", m_CarInfo.max_steer_angle );
-
-	nh.getParam("maxVelocity", m_CarInfo.max_speed_forward );
-	nh.getParam("minVelocity", m_CarInfo.min_speed_forward );
-	nh.getParam("minVelocity", m_CarInfo.max_speed_backword );
-	nh.getParam("maxAcceleration", m_CarInfo.max_acceleration );
-	nh.getParam("maxDeceleration", m_CarInfo.max_deceleration );
-
-	nh.getParam("steeringDelay", m_ControlParams.SteeringDelay );
-	nh.getParam("minPursuiteDistance", m_ControlParams.minPursuiteDistance );
-
-	m_ControlParams.Steering_Gain = PlannerHNS::PID_CONST(0.07, 0.02, 0.01); // for 3 m/s
-
-	m_PlanningParams.maxSpeed = m_CarInfo.max_speed_forward;
-	m_PlanningParams.minSpeed = m_CarInfo.min_speed_forward;
-	m_PlanningParams.enableFollowing = true;
-	m_PlanningParams.enableHeadingSmoothing = false;
-	m_PlanningParams.enableLaneChange = false;
-	m_PlanningParams.enableStopSignBehavior = false;
-	m_PlanningParams.enableSwerving = false;
-	m_PlanningParams.enableTrafficLightBehavior = false;
-	m_PlanningParams.horizonDistance = 100;
-	m_PlanningParams.horizontalSafetyDistancel = 0.1;
-	m_PlanningParams.verticalSafetyDistance = 0.8;
-	m_PlanningParams.maxDistanceToAvoid = 2;
-	m_PlanningParams.microPlanDistance = 50;
-	m_PlanningParams.minDistanceToAvoid = 4;
-	m_PlanningParams.minFollowingDistance = 7;
-	m_PlanningParams.pathDensity = 0.5;
-	m_PlanningParams.planningDistance = 1000;
-	m_PlanningParams.carTipMargin = 2;
-	m_PlanningParams.rollInMargin = 10;
-	m_PlanningParams.rollOutDensity = 0.5;
-	m_PlanningParams.rollOutNumber = 0;
-
-}
-
-OpenPlannerSimulator::~OpenPlannerSimulator()
-{
-}
-
-void OpenPlannerSimulator::callbackGetInitPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr&amp; msg)
-{
-	if(!bInitPos)
-	{
-		ROS_INFO("init Simulation Rviz Pose Data: x=%f, y=%f, z=%f, freq=%d", msg-&gt;pose.pose.position.x, msg-&gt;pose.pose.position.y, msg-&gt;pose.pose.position.z);
-
-		geometry_msgs::Pose p;
-		p.position.x  = msg-&gt;pose.pose.position.x + m_OriginPos.position.x;
-		p.position.y  = msg-&gt;pose.pose.position.y + m_OriginPos.position.y;
-		p.position.z  = msg-&gt;pose.pose.position.z + m_OriginPos.position.z;
-		p.orientation = msg-&gt;pose.pose.orientation;
-		m_SimParams.startPose =  PlannerHNS::WayPoint(p.position.x, p.position.y, p.position.z , tf::getYaw(p.orientation));
-
-		SaveSimulationData();
-
-		InitializeSimuCar(m_SimParams.startPose);
-
-		bInitPos = true;
-	}
-}
-
-void OpenPlannerSimulator::InitializeSimuCar(PlannerHNS::WayPoint start_pose)
-{
-	m_LocalPlanner.m_pCurrentBehaviorState = m_LocalPlanner.m_pInitState;
-	m_LocalPlanner.m_TotalPath.clear();
-	m_LocalPlanner.m_Path.clear();
-	m_LocalPlanner.m_pCurrentBehaviorState-&gt;m_Behavior = PlannerHNS::INITIAL_STATE;
-	m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = 1;
-	m_LocalPlanner.FirstLocalizeMe(start_pose);
-	m_LocalPlanner.LocalizeMe(0);
-
-	cout &lt;&lt; endl &lt;&lt; "LocalPlannerInit: ID " &lt;&lt; m_SimParams.strID &lt;&lt; " , Pose = ( "  &lt;&lt; start_pose.pos.ToString() &lt;&lt; ")" &lt;&lt; endl;
-}
-
-void OpenPlannerSimulator::GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
-{
-	static tf::TransformListener listener;
-
-	while (1)
-	{
-		try
-		{
-			listener.lookupTransform(parent_frame, child_frame, ros::Time(0), transform);
-			break;
-		}
-		catch (tf::TransformException&amp; ex)
-		{
-			ROS_ERROR("%s", ex.what());
-			ros::Duration(1.0).sleep();
-		}
-	}
-}
-
-void OpenPlannerSimulator::callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr&amp; msg)
-{
-	m_OriginalClusters.clear();
-	int nOriginalPoints=0, nContourPoints = 0;
-
-	ConvertFromAutowareCloudClusterObstaclesToPlannerH(m_LocalPlanner.state, m_LocalPlanner.m_CarInfo, *msg, m_OriginalClusters, nOriginalPoints, nContourPoints);
-	//m_ObstacleTracking.DoOneStep(m_LocalPlanner.state, m_OriginalClusters);
-	//m_TrackedClusters = m_ObstacleTracking.m_DetectedObjects;
-	m_TrackedClusters = m_OriginalClusters;
-
-	//m_nTrackObjects = m_TrackedClusters.size();
-	//m_TrackingTime = UtilityHNS::UtilityH::GetTimeDiffNow(timerTemp);
-	bNewClusters = true;
-}
-
-PlannerHNS::WayPoint OpenPlannerSimulator::GetRealCenter(const PlannerHNS::WayPoint&amp; currState)
-{
-	PlannerHNS::WayPoint pose_center = currState;
-	PlannerHNS::Mat3 rotationMat(-currState.pos.a);
-	PlannerHNS::Mat3 translationMat(-currState.pos.x, -currState.pos.y);
-
-	PlannerHNS::Mat3 rotationMatInv(currState.pos.a);
-	PlannerHNS::Mat3 translationMatInv(currState.pos.x, currState.pos.y);
-
-	pose_center.pos = translationMat*pose_center.pos;
-	pose_center.pos = rotationMat*pose_center.pos;
-
-	pose_center.pos.x += m_CarInfo.wheel_base/3.0;
-
-	pose_center.pos = rotationMatInv*pose_center.pos;
-	pose_center.pos = translationMatInv*pose_center.pos;
-
-	return pose_center;
-}
-
-void OpenPlannerSimulator::displayFollowingInfo(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; safety_rect, PlannerHNS::WayPoint&amp; curr_pose)
-{
-  static visualization_msgs::Marker m1;
-  m1.header.frame_id = "map";
-  m1.header.stamp = ros::Time();
-  m1.ns = "curr_simu_pose";
-  //m1.type = visualization_msgs::Marker::ARROW;
-  m1.type = visualization_msgs::Marker::MESH_RESOURCE;
-  m1.mesh_resource = m_SimParams.meshPath;
-  m1.mesh_use_embedded_materials = true;
-  m1.action = visualization_msgs::Marker::ADD;
-
-  PlannerHNS::WayPoint pose_center = GetRealCenter(curr_pose);
-
-  m1.pose.position.x = pose_center.pos.x;
-  m1.pose.position.y = pose_center.pos.y;
-  m1.pose.position.z = pose_center.pos.z;
-
-  m1.pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(0, 0, UtilityHNS::UtilityH::SplitPositiveAngle(curr_pose.pos.a));
-  m1.color = m_SimParams.modelColor;
-  m1.scale.x = 1.0*m_CarInfo.length/4.2;
-  m1.scale.y = 1.0*m_CarInfo.width/1.85;
-  m1.scale.z = 1.0;
-  m1.frame_locked = true;
-  pub_CurrPoseRviz.publish(m1);
-
-  visualization_msgs::Marker lane_waypoint_marker;
-  	lane_waypoint_marker.header.frame_id = "map";
-  	lane_waypoint_marker.header.stamp = ros::Time();
-  	lane_waypoint_marker.ns = "safety_simu_box";
-  	lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
-  	lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
-  	lane_waypoint_marker.scale.x = 0.2;
-  	lane_waypoint_marker.scale.y = 0.2;
-  	//lane_waypoint_marker.scale.z = 0.1;
-  	lane_waypoint_marker.frame_locked = false;
-  	lane_waypoint_marker.color.r = 0.0;
-  	lane_waypoint_marker.color.g = 1.0;
-  	lane_waypoint_marker.color.b = 0.0;
-  	lane_waypoint_marker.color.a = 0.6;
-
-  	for(unsigned int i=0; i &lt; safety_rect.size(); i ++)
-  	{
-  		geometry_msgs::Point p1;
-  		p1.x = safety_rect.at(i).x;
-		p1.y = safety_rect.at(i).y;
-		p1.z = safety_rect.at(i).z;
-		lane_waypoint_marker.points.push_back(p1);
-  	}
-  	pub_SafetyBorderRviz.publish(lane_waypoint_marker);
-
-}
-
-void OpenPlannerSimulator::visualizePath(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
-{
-	visualization_msgs::MarkerArray markerArray;
-
-	visualization_msgs::Marker lane_waypoint_marker;
-	lane_waypoint_marker.header.frame_id = "map";
-	lane_waypoint_marker.header.stamp = ros::Time();
-	std::ostringstream str_sn;
-	str_sn &lt;&lt; "simu_car_path_";
-	str_sn &lt;&lt; m_SimParams.id;
-	lane_waypoint_marker.ns = str_sn.str();
-	lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
-	lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
-
-
-	std_msgs::ColorRGBA roll_color, curr_color;
-	lane_waypoint_marker.points.clear();
-	lane_waypoint_marker.id = 1;
-	lane_waypoint_marker.scale.x = 0.1;
-	lane_waypoint_marker.scale.y = 0.1;
-	lane_waypoint_marker.color.a = 0.5;
-	lane_waypoint_marker.color = m_SimParams.modelColor;
-	lane_waypoint_marker.frame_locked = false;
-
-	int count = 0;
-	for (unsigned int i = 0; i &lt; path.size(); i++)
-	{
-		geometry_msgs::Point point;
-		point.x = path.at(i).pos.x;
-		point.y = path.at(i).pos.y;
-		point.z = path.at(i).pos.z;
-
-		lane_waypoint_marker.points.push_back(point);
-		count++;
-	}
-
-	markerArray.markers.push_back(lane_waypoint_marker);
-
-	pub_LocalTrajectoriesRviz.publish(markerArray);
-}
-
-void OpenPlannerSimulator::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::CAR_BASIC_INFO&amp; car_info,
-		const autoware_msgs::CloudClusterArray&amp; clusters, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list,
-		int&amp; nOriginalPoints, int&amp; nContourPoints)
-{
-	PlannerHNS::Mat3 rotationMat(-currState.pos.a);
-	PlannerHNS::Mat3 translationMat(-currState.pos.x, -currState.pos.y);
-
-	int nPoints = 0;
-	int nOrPoints = 0;
-	for(unsigned int i =0; i &lt; clusters.clusters.size(); i++)
-	{
-		if(clusters.clusters.at(i).id == m_SimParams.id)
-		{
-			//std::cout &lt;&lt; "Skip Same ID " &lt;&lt; std::endl;
-			continue;
-		}
-
-		PolygonGenerator polyGen;
-		PlannerHNS::DetectedObject obj;
-		obj.center.pos = GPSPoint(clusters.clusters.at(i).centroid_point.point.x,
-				clusters.clusters.at(i).centroid_point.point.y,
-				clusters.clusters.at(i).centroid_point.point.z,0);
-				//tf::getYaw(clusters.clusters.at(i).bounding_box.pose.orientation));
-
-		pcl::PointCloud&lt;pcl::PointXYZ&gt; point_cloud;
-		pcl::fromROSMsg(clusters.clusters.at(i).cloud, point_cloud);
-		obj.contour = polyGen.EstimateClusterPolygon(point_cloud ,obj.center.pos);
-		obj.w = clusters.clusters.at(i).dimensions.y;
-		obj.l = clusters.clusters.at(i).dimensions.x;
-		obj.h = clusters.clusters.at(i).dimensions.z;
-		obj.id = 0;
-
-
-		PlannerHNS::GPSPoint relative_point;
-		relative_point = translationMat*obj.center.pos;
-		relative_point = rotationMat*relative_point;
-
-		double distance_x = fabs(relative_point.x);
-		double distance_y = fabs(relative_point.y);
-
-//		double size = (obj.w+obj.l)/2.0;
-//		if(size &lt;= 0.25 || size &gt;= 5 || distance_y &gt; 20.0 || distance_x &gt; 20.0)
-//			continue;
-
-//		if(distance_x &lt;= car_info.length &amp;&amp; distance_y &lt;= car_info.width/1.5) // don't detect yourself
-//			continue;
-
-
-		nOrPoints += point_cloud.points.size();
-		nPoints += obj.contour.size();
-		//std::cout &lt;&lt; " Distance_X: " &lt;&lt; distance_x &lt;&lt; ", " &lt;&lt; " Distance_Y: " &lt;&lt; distance_y &lt;&lt; ", " &lt;&lt; " Size: " &lt;&lt; size &lt;&lt; std::endl;
-
-		obstacles_list.push_back(obj);
-	}
-
-	nOriginalPoints = nOrPoints;
-	nContourPoints =  nPoints;
-}
-
-void OpenPlannerSimulator::visualizeBehaviors()
-{
-	visualization_msgs::Marker behaviorMarker;
-	behaviorMarker.header.frame_id = "map";
-	behaviorMarker.header.stamp = ros::Time();
-	std::ostringstream str_sn;
-	str_sn &lt;&lt; "sim_behavior_" &lt;&lt; m_SimParams.id;
-	behaviorMarker.ns = str_sn.str();
-	behaviorMarker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
-	behaviorMarker.scale.z = 1.0;
-	behaviorMarker.scale.x = 1.0;
-	behaviorMarker.scale.y = 1.0;
-	behaviorMarker.color.a = 1.0;
-	behaviorMarker.frame_locked = false;
-
-	behaviorMarker.color.r = 1.0;//trackedObstacles.at(i).center.v/16.0;
-	behaviorMarker.color.g = 1.0;// - trackedObstacles.at(i).center.v/16.0;
-	behaviorMarker.color.b = 1.0;
-
-	geometry_msgs::Point point;
-
-	point.x = m_LocalPlanner.state.pos.x;
-	point.y = m_LocalPlanner.state.pos.y;
-	point.z = m_LocalPlanner.state.pos.z+2.5;
-
-	behaviorMarker.pose.position = point;
-
-	behaviorMarker.id = 1;
-
-	std::string str = "Unknown";
-	switch(m_LocalPlanner.m_pCurrentBehaviorState-&gt;m_Behavior)
-	{
-	case PlannerHNS::INITIAL_STATE:
-		str = "Init";
-		break;
-	case PlannerHNS::WAITING_STATE:
-		str = "Waiting";
-		break;
-	case PlannerHNS::FORWARD_STATE:
-		str = "Forward";
-		break;
-	case PlannerHNS::STOPPING_STATE:
-		str = "Stop";
-		break;
-	case PlannerHNS::FINISH_STATE:
-		str = "End";
-		break;
-	case PlannerHNS::FOLLOW_STATE:
-		str = "Follow";
-		break;
-	case PlannerHNS::OBSTACLE_AVOIDANCE_STATE:
-		str = "Swerving";
-		break;
-	case PlannerHNS::TRAFFIC_LIGHT_STOP_STATE:
-		str = "Light Stop";
-		break;
-	case PlannerHNS::TRAFFIC_LIGHT_WAIT_STATE:
-		str = "Light Wait";
-		break;
-	case PlannerHNS::STOP_SIGN_STOP_STATE:
-		str = "Sign Stop";
-		break;
-	case PlannerHNS::STOP_SIGN_WAIT_STATE:
-		str = "Sign Wait";
-		break;
-	default:
-		str = "Unknown";
-		break;
-	}
-
-	std::ostringstream str_out;
-	str_out &lt;&lt; str &lt;&lt; "(" &lt;&lt; m_SimParams.id &lt;&lt; ")" ;
-	behaviorMarker.text = str_out.str();
-
-	pub_BehaviorStateRviz.publish(behaviorMarker);
-}
-
-void OpenPlannerSimulator::SaveSimulationData()
-{
-	std::vector&lt;std::string&gt; simulationDataPoints;
-	std::ostringstream startStr;
-	startStr &lt;&lt; m_SimParams.startPose.pos.x &lt;&lt; "," &lt;&lt; m_SimParams.startPose.pos.y &lt;&lt; "," &lt;&lt; m_SimParams.startPose.pos.z &lt;&lt; "," &lt;&lt; m_SimParams.startPose.pos.a &lt;&lt; ","&lt;&lt; m_SimParams.startPose.cost &lt;&lt; "," &lt;&lt; m_CarInfo.max_speed_forward &lt;&lt; ",";
-	simulationDataPoints.push_back(startStr.str());
-	std::ostringstream goalStr;
-	simulationDataPoints.push_back(goalStr.str());
-
-	std::string header = "X,Y,Z,A,C,V,";
-
-	ostringstream fileName;
-	fileName &lt;&lt; UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName+UtilityHNS::DataRW::SimulationFolderName;
-	fileName &lt;&lt; "SimuCar_";
-	fileName &lt;&lt; m_SimParams.id;
-	fileName &lt;&lt; ".csv";
-
-	std::ofstream f(fileName.str().c_str());
-
-	if(f.is_open())
-	{
-		if(header.size() &gt; 0)
-			f &lt;&lt; header &lt;&lt; "\r\n";
-		for(unsigned int i = 0 ; i &lt; simulationDataPoints.size(); i++)
-			f &lt;&lt; simulationDataPoints.at(i) &lt;&lt; "\r\n";
-	}
-
-	f.close();
-}
-
-bool OpenPlannerSimulator::LoadSimulationData(PlannerHNS::WayPoint&amp; start_p)
-{
-	ostringstream fileName;
-	fileName &lt;&lt; "SimuCar_";
-	fileName &lt;&lt; m_SimParams.id;
-	fileName &lt;&lt; ".csv";
-
-	string simuDataFileName = UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName+UtilityHNS::DataRW::SimulationFolderName + fileName.str();
-	UtilityHNS::SimulationFileReader sfr(simuDataFileName);
-	UtilityHNS::SimulationFileReader::SimulationData data;
-
-	if(sfr.ReadAllData(data) == 0)
-		return false;
-
-	start_p = PlannerHNS::WayPoint(data.startPoint.x, data.startPoint.y, data.startPoint.z, data.startPoint.a);
-	start_p.v = data.startPoint.v;
-	start_p.cost = data.startPoint.c;
-	return true;
-}
-
-void OpenPlannerSimulator::PlannerMainLoop()
-{
-
-	ros::Rate loop_rate(100);
-	//PlannerHNS::WayPoint defaultStart(3704.15014648,-99459.0743942, 88, 3.12940141294);
-	PlannerHNS::BehaviorState currBehavior;
-	PlannerHNS::VehicleState  currStatus;
-	PlannerHNS::VehicleState  desiredStatus;
-
-	while (ros::ok())
-	{
-		ros::spinOnce();
-
-		bool bMakeNewPlan = false;
-
-		if(m_SimParams.mapSource == MAP_KML_FILE &amp;&amp; !m_bMap)
-		{
-			m_bMap = true;
-			PlannerHNS::MappingHelpers::LoadKML(m_SimParams.KmlMapPath, m_Map);
-			if(!m_SimParams.bRandomStart)
-				InitializeSimuCar(m_SimParams.startPose);
-		}
-		else if (m_SimParams.mapSource == MAP_FOLDER &amp;&amp; !m_bMap)
-		{
-			m_bMap = true;
-			PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_SimParams.KmlMapPath, m_Map, true);
-			if(!m_SimParams.bRandomStart)
-				InitializeSimuCar(m_SimParams.startPose);
-		}
-
-		if(m_bMap &amp;&amp; bInitPos)
-		{
-			double dt  = UtilityHNS::UtilityH::GetTimeDiffNow(m_PlanningTimer);
-			UtilityHNS::UtilityH::GetTickCount(m_PlanningTimer);
-
-			//Global Planning Step
-			if(m_LocalPlanner.m_TotalPath.size() &gt; 0 &amp;&amp; m_LocalPlanner.m_TotalPath.at(0).size() &gt; 3)
-			{
-				PlannerHNS::RelativeInfo info;
-				bool ret = PlannerHNS::PlanningHelpers::GetRelativeInfoRange(m_LocalPlanner.m_TotalPath, m_LocalPlanner.state, 0.75, info);
-				if(ret == true &amp;&amp; info.iGlobalPath &gt;= 0 &amp;&amp;  info.iGlobalPath &lt; m_LocalPlanner.m_TotalPath.size() &amp;&amp; info.iFront &gt; 0 &amp;&amp; info.iFront &lt; m_LocalPlanner.m_TotalPath.at(info.iGlobalPath).size())
-				{
-					double remaining_distance =  m_LocalPlanner.m_TotalPath.at(info.iGlobalPath).at(m_LocalPlanner.m_TotalPath.at(info.iGlobalPath).size()-1).cost - (m_LocalPlanner.m_TotalPath.at(info.iGlobalPath).at(info.iFront).cost + info.to_front_distance);
-					if(remaining_distance &lt;= REPLANNING_DISTANCE)
-					{
-						bMakeNewPlan = true;
-						if(m_SimParams.bLooper)
-							InitializeSimuCar(m_SimParams.startPose);
-					}
-				}
-			}
-			else
-				bMakeNewPlan = true;
-
-			if(bMakeNewPlan)
-			{
-				std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; generatedTotalPaths;
-				double ret = m_GlobalPlanner.PlanUsingDPRandom(m_LocalPlanner.state, PLANNING_DISTANCE, m_Map, generatedTotalPaths);
-				for(unsigned int i=0; i &lt; generatedTotalPaths.size(); i++)
-				{
-					PlannerHNS::PlanningHelpers::CalcAngleAndCost(generatedTotalPaths.at(i));
-				}
-
-				m_LocalPlanner.m_TotalPath = generatedTotalPaths;
-				m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bNewGlobalPath = true;
-			}
-
-			//Local Planning
-			std::vector&lt;TrafficLight&gt; trafficLight;
-			currBehavior = m_LocalPlanner.DoOneStep(dt, currStatus, m_TrackedClusters, 1, m_Map, 0, trafficLight, true);
-
-			 //Odometry Simulation and Update
-			m_LocalPlanner.SetSimulatedTargetOdometryReadings(desiredStatus.speed, desiredStatus.steer, desiredStatus.shift);
-			m_LocalPlanner.UpdateState(desiredStatus, false);
-			m_LocalPlanner.LocalizeMe(dt);
-			currStatus.shift = desiredStatus.shift;
-			currStatus.steer = m_LocalPlanner.m_CurrentSteering;
-			currStatus.speed = m_LocalPlanner.m_CurrentVelocity;
-
-
-			//Path Following and Control
-			desiredStatus = m_PredControl.DoOneStep(dt, currBehavior, m_LocalPlanner.m_Path, m_LocalPlanner.state, currStatus, currBehavior.bNewPlan);
-
-			displayFollowingInfo(m_LocalPlanner.m_TrajectoryCostsCalculatotor.m_SafetyBorder.points, m_LocalPlanner.state);
-			visualizePath(m_LocalPlanner.m_Path);
-			visualizeBehaviors();
-
-
-			geometry_msgs::PoseArray sim_data;
-			geometry_msgs::Pose p_id, p_pose, p_box;
-
-
-			sim_data.header.frame_id = "map";
-			sim_data.header.stamp = ros::Time();
-
-			p_id.position.x = m_SimParams.id;
-
-			PlannerHNS::WayPoint pose_center = GetRealCenter(m_LocalPlanner.state);
-
-			p_pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(0, 0, UtilityHNS::UtilityH::SplitPositiveAngle(pose_center.pos.a));
-			p_pose.position.x = pose_center.pos.x;
-			p_pose.position.y = pose_center.pos.y;
-			p_pose.position.z = pose_center.pos.z;
-
-
-
-			p_box.position.x = m_CarInfo.width;
-			p_box.position.y = m_CarInfo.length;
-			p_box.position.z = 2.2;
-
-			sim_data.poses.push_back(p_id);
-			sim_data.poses.push_back(p_pose);
-			sim_data.poses.push_back(p_box);
-
-			pub_SimuBoxPose.publish(sim_data);
-
-			if(currBehavior.bNewPlan)
-			{
-				std::ostringstream str_out;
-				str_out &lt;&lt; m_SimParams.logPath;
-				str_out &lt;&lt; "LocalPath_";
-				PlannerHNS::PlanningHelpers::WritePathToFile(str_out.str(),  m_LocalPlanner.m_Path);
-			}
-
-			if(m_SimParams.bLooper &amp;&amp; currBehavior.state == PlannerHNS::FINISH_STATE)
-			{
-				InitializeSimuCar(m_SimParams.startPose);
-			}
-		}
-
-		loop_rate.sleep();
-	}
-}
-
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\PolygonGenerator.cpp" new_path="" added_lines="0" deleted_lines="150">
				<diff>@@ -1,150 +0,0 @@
-/*
- * PolygonGenerator.cpp
- *
- *  Created on: Nov 2, 2016
- *      Author: ai-driver
- */
-
-
-#include "PolygonGenerator.h"
-
-
-namespace OpenPlannerSimulatorNS
-{
-
-
-PolygonGenerator::PolygonGenerator() {
-	// TODO Auto-generated constructor stub
-
-}
-
-PolygonGenerator::~PolygonGenerator() {
-	// TODO Auto-generated destructor stub
-}
-
-GPSPoint PolygonGenerator::CalculateCentroid(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster)
-{
-	GPSPoint c;
-
-	for(unsigned int i=0; i&lt; cluster.points.size(); i++)
-	{
-		c.x += cluster.points.at(i).x;
-		c.y += cluster.points.at(i).y;
-	}
-
-	c.x = c.x/cluster.points.size();
-	c.y = c.y/cluster.points.size();
-
-	return c;
-}
-
-std::vector&lt;GPSPoint&gt; PolygonGenerator::EstimateClusterPolygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster, const GPSPoint&amp; original_centroid )
-{
-	std::vector&lt;QuarterView&gt; quarters = CreateQuarterViews(QUARTERS_NUMBER);
-
-
-	for(unsigned int i=0; i&lt; cluster.points.size(); i++)
-	{
-		WayPoint p;
-		p.pos.x = cluster.points.at(i).x;
-		p.pos.y = cluster.points.at(i).y;
-		p.pos.z = original_centroid.z;
-
-		GPSPoint v(p.pos.x - original_centroid.x , p.pos.y - original_centroid.y, p.pos.z,0);
-		p.cost = pointNorm(v);
-		p.pos.a = UtilityHNS::UtilityH::FixNegativeAngle(atan2(v.y, v.x))*(180. / M_PI);
-
-		for(unsigned int j = 0 ; j &lt; quarters.size(); j++)
-		{
-			if(quarters.at(j).UpdateQuarterView(p))
-				break;
-		}
-	}
-
-	std::vector&lt;GPSPoint&gt; polygon;
-
-	for(unsigned int j = 0 ; j &lt; quarters.size(); j++)
-	{
-
-		WayPoint wp;
-		int nPoints = quarters.at(j).GetMaxPoint(wp);
-		if(nPoints &gt;= MIN_POINTS_PER_QUARTER)
-		{
-			polygon.push_back(wp.pos);
-		}
-	}
-
-	//Fix Resolution:
-	bool bChange = true;
-	while (bChange &amp;&amp; polygon.size()&gt;1)
-	{
-		bChange = false;
-		GPSPoint p1 =  polygon.at(polygon.size()-1);
-		for(unsigned int i=0; i&lt; polygon.size(); i++)
-		{
-			GPSPoint p2 = polygon.at(i);
-			double d = hypot(p2.y- p1.y, p2.x - p1.x);
-			if(d &gt; MIN_DISTANCE_BETWEEN_CORNERS)
-			{
-				GPSPoint center_p = p1;
-				center_p.x = (p2.x + p1.x)/2.0;
-				center_p.y = (p2.y + p1.y)/2.0;
-				polygon.insert(polygon.begin()+i, center_p);
-				bChange = true;
-				break;
-			}
-
-			p1 = p2;
-		}
-	}
-
-	return polygon;
-
-}
-
-std::vector&lt;QuarterView&gt; PolygonGenerator::CreateQuarterViews(const int&amp; nResolution)
-{
-	std::vector&lt;QuarterView&gt; quarters;
-	if(nResolution &lt;= 0)
-		return quarters;
-
-	double range = 360.0 / nResolution;
-	double angle = 0;
-	for(int i = 0; i &lt; nResolution; i++)
-	{
-		QuarterView q(angle, angle+range, i);
-		quarters.push_back(q);
-		angle+=range;
-	}
-
-	return quarters;
-}
-
-void CheckConvexPoligon(std::vector&lt;WayPoint&gt;&amp; polygon)
-{
-
-//	if(polygon.size() &lt;= 3)
-//		return;
-//
-//	WayPoint p1 = polygon.at(0);
-//	WayPoint p3;
-//	WayPoint p2;
-//
-//	for(int i=1; i&lt; polygon.size()-1; i++)
-//	{
-//		p1 = polygon.at(i-1);
-//		if(i+2 == polygon.size())
-//		{
-//			p2 = polygon.at(polygon.size()-1);
-//			p3 = polygon.at(0);
-//		}
-//		else
-//		{
-//			p2 = polygon.at(i);
-//			p3 = polygon.at(i+1);
-//		}
-//
-//	}
-}
-
-} /* namespace PlannerXNS */
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5d3169b9c22f8b3f5a08d2be6baa85b4725b5e1b" author="hatem-darweesh">
		<msg>Modify Map loading for OpenPlanner, now it reads from Autoware vector map messages, old behavior still works but from launch file only.
Delete way_planner, dp_planner from UI, but they still accessible from roslaunch.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\lidar_kf_contour_track_core.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\lidar_kf_contour_track_core.h" added_lines="49" deleted_lines="1">
				<diff>@@ -33,6 +33,18 @@
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
+
+#include "vector_map_msgs/PointArray.h"
+#include "vector_map_msgs/LaneArray.h"
+#include "vector_map_msgs/NodeArray.h"
+#include "vector_map_msgs/StopLineArray.h"
+#include "vector_map_msgs/DTLaneArray.h"
+#include "vector_map_msgs/LineArray.h"
+#include "vector_map_msgs/AreaArray.h"
+#include "vector_map_msgs/SignalArray.h"
+#include "vector_map_msgs/StopLine.h"
+#include "vector_map_msgs/VectorArray.h"
+
 #include "op_planner/RoadNetwork.h"
 #include "op_planner/PlannerCommonDef.h"
 #include "op_planner/MatrixOperations.h"
@@ -44,6 +56,8 @@
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
+
+
 namespace ContourTrackerNS
 {
 
@@ -112,7 +126,6 @@ protected:
 	std::string m_MapPath;
 	PlannerHNS::RoadNetwork m_Map;
 	bool bMap;
-	bool bVectorMapCheck;
 	double m_MapFilterDistance;
 
 	std::vector&lt;PlannerHNS::Lane*&gt; m_ClosestLanesList;
@@ -158,6 +171,41 @@ public:
   ContourTracker();
   ~ContourTracker();
   void MainLoop();
+
+	//Mapping Section
+
+	UtilityHNS::MapRaw m_MapRaw;
+
+	ros::Subscriber sub_lanes;
+	ros::Subscriber sub_points;
+	ros::Subscriber sub_dt_lanes;
+	ros::Subscriber sub_intersect;
+	ros::Subscriber sup_area;
+	ros::Subscriber sub_lines;
+	ros::Subscriber sub_stop_line;
+	ros::Subscriber sub_signals;
+	ros::Subscriber sub_vectors;
+	ros::Subscriber sub_curbs;
+	ros::Subscriber sub_edges;
+	ros::Subscriber sub_way_areas;
+	ros::Subscriber sub_cross_walk;
+	ros::Subscriber sub_nodes;
+
+
+	void callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg);
+	void callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg);
+	void callbackGetVMdtLanes(const vector_map_msgs::DTLaneArray&amp; msg);
+	void callbackGetVMIntersections(const vector_map_msgs::CrossRoadArray&amp; msg);
+	void callbackGetVMAreas(const vector_map_msgs::AreaArray&amp; msg);
+	void callbackGetVMLines(const vector_map_msgs::LineArray&amp; msg);
+	void callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg);
+	void callbackGetVMSignal(const vector_map_msgs::SignalArray&amp; msg);
+	void callbackGetVMVectors(const vector_map_msgs::VectorArray&amp; msg);
+	void callbackGetVMCurbs(const vector_map_msgs::CurbArray&amp; msg);
+	void callbackGetVMRoadEdges(const vector_map_msgs::RoadEdgeArray&amp; msg);
+	void callbackGetVMWayAreas(const vector_map_msgs::WayAreaArray&amp; msg);
+	void callbackGetVMCrossWalks(const vector_map_msgs::CrossWalkArray&amp; msg);
+	void callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg);
 };
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track_core.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track_core.cpp" added_lines="186" deleted_lines="23">
				<diff>@@ -51,7 +51,6 @@ ContourTracker::ContourTracker()
 	m_PolyEstimationTime = 0;
 	m_MapType = PlannerHNS::MAP_KML_FILE;
 	bMap = false;
-	bVectorMapCheck = true;
 	bNewCurrentPos = false;
 	ReadNodeParams();
 	ReadCommonParams();
@@ -70,6 +69,21 @@ ContourTracker::ContourTracker()
 	pub_TrackedObstaclesRviz = nh.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("op_planner_tracked_boxes", 1);
 	pub_TTC_PathRviz		= nh.advertise&lt;visualization_msgs::MarkerArray&gt;("ttc_direct_path", 1);
 
+	//Mapping Section
+	sub_lanes = nh.subscribe("/vector_map_info/lane", 1, &amp;ContourTracker::callbackGetVMLanes,  this);
+	sub_points = nh.subscribe("/vector_map_info/point", 1, &amp;ContourTracker::callbackGetVMPoints,  this);
+	sub_dt_lanes = nh.subscribe("/vector_map_info/dtlane", 1, &amp;ContourTracker::callbackGetVMdtLanes,  this);
+	sub_intersect = nh.subscribe("/vector_map_info/cross_road", 1, &amp;ContourTracker::callbackGetVMIntersections,  this);
+	sup_area = nh.subscribe("/vector_map_info/area", 1, &amp;ContourTracker::callbackGetVMAreas,  this);
+	sub_lines = nh.subscribe("/vector_map_info/line", 1, &amp;ContourTracker::callbackGetVMLines,  this);
+	sub_stop_line = nh.subscribe("/vector_map_info/stop_line", 1, &amp;ContourTracker::callbackGetVMStopLines,  this);
+	sub_signals = nh.subscribe("/vector_map_info/signal", 1, &amp;ContourTracker::callbackGetVMSignal,  this);
+	sub_vectors = nh.subscribe("/vector_map_info/vector", 1, &amp;ContourTracker::callbackGetVMVectors,  this);
+	sub_curbs = nh.subscribe("/vector_map_info/curb", 1, &amp;ContourTracker::callbackGetVMCurbs,  this);
+	sub_edges = nh.subscribe("/vector_map_info/road_edge", 1, &amp;ContourTracker::callbackGetVMRoadEdges,  this);
+	sub_way_areas = nh.subscribe("/vector_map_info/way_area", 1, &amp;ContourTracker::callbackGetVMWayAreas,  this);
+	sub_cross_walk = nh.subscribe("/vector_map_info/cross_walk", 1, &amp;ContourTracker::callbackGetVMCrossWalks,  this);
+	sub_nodes = nh.subscribe("/vector_map_info/node", 1, &amp;ContourTracker::callbackGetVMNodes,  this);
 
 	m_nDummyObjPerRep = 150;
 	m_nDetectedObjRepresentations = 5;
@@ -111,6 +125,9 @@ void ContourTracker::ReadNodeParams()
 	_nh.getParam("/lidar_kf_contour_track/max_association_distance" , m_ObstacleTracking.m_MAX_ASSOCIATION_DISTANCE);
 	_nh.getParam("/lidar_kf_contour_track/max_association_size_diff" , m_ObstacleTracking.m_MAX_ASSOCIATION_SIZE_DIFF);
 	_nh.getParam("/lidar_kf_contour_track/enableLogging" , m_Params.bEnableLogging);
+	//_nh.getParam("/lidar_kf_contour_track/enableTTC" , m_Params.bEnableTTC);
+
+
 	int tracking_type = 0;
 	_nh.getParam("/lidar_kf_contour_track/tracking_type" 			, tracking_type);
 	if(tracking_type==0)
@@ -134,22 +151,14 @@ void ContourTracker::ReadCommonParams()
 	m_ObstacleTracking.m_CirclesResolution = m_Params.DetectionRadius*0.05;
 
 	int iSource = 0;
-	if(_nh.getParam("/op_common_params/mapSource" , iSource))
-	{
-		if(iSource == 0)
-			m_MapType = PlannerHNS::MAP_AUTOWARE;
-		else if (iSource == 1)
-			m_MapType = PlannerHNS::MAP_FOLDER;
-		else if(iSource == 2)
-			m_MapType = PlannerHNS::MAP_KML_FILE;
-
-		_nh.getParam("/op_common_params/mapFileName" , m_MapPath);
-		bVectorMapCheck = true;
-	}
-	else
-	{
-		bVectorMapCheck = false;
-	}
+	if(iSource == 0)
+		m_MapType = PlannerHNS::MAP_AUTOWARE;
+	else if (iSource == 1)
+		m_MapType = PlannerHNS::MAP_FOLDER;
+	else if(iSource == 2)
+		m_MapType = PlannerHNS::MAP_KML_FILE;
+
+	_nh.getParam("/op_common_params/mapFileName" , m_MapPath);
 }
 
 void ContourTracker::callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr &amp;msg)
@@ -171,7 +180,10 @@ void ContourTracker::callbackGetCloudClusters(const autoware_msgs::CloudClusterA
 		LogAndSend();
 		VisualizeLocalTracking();
 
-		CalculateTTC(m_ObstacleTracking.m_DetectedObjects, m_CurrentPos, m_Map);
+		if(m_Params.bEnableTTC)
+		{
+			CalculateTTC(m_ObstacleTracking.m_DetectedObjects, m_CurrentPos, m_Map);
+		}
 	}
 }
 
@@ -479,20 +491,33 @@ void ContourTracker::CalculateTTC(const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp;
 	std::vector&lt;PlannerHNS::WayPoint&gt; direct_paths;
 	if(closest_path_id &gt;= 0 &amp;&amp; closest_obj_id &gt;= 0)
 	{
-		for(unsigned int i=i_start; i&lt;i_end; i++)
+		for(unsigned int i=i_start; i&lt;=i_end; i++)
 		{
 			direct_paths.push_back(paths.at(closest_path_id).at(i));
 		}
 	}
 
-	cout &lt;&lt; "TTC Path Size: " &lt;&lt; direct_paths.size() &lt;&lt; endl;
-
 	//Visualize Direct Path
 	m_TTC_Path.markers.clear();
 	if(direct_paths.size() == 0)
 		direct_paths.push_back(currState);
 	PlannerHNS::RosHelpers::TTC_PathRviz(direct_paths, m_TTC_Path);
 	pub_TTC_PathRviz.publish(m_TTC_Path);
+
+
+	//calculate TTC
+	if(direct_paths.size() &gt; 2 &amp;&amp; closest_obj_id &gt;= 0)
+	{
+		double dd = min_d;
+		double dv = objs.at(closest_obj_id).center.v - currState.v;
+		if(fabs(dv) &gt; 0.1)
+		{
+			double ttc = (dd - 4) / dv;
+			cout &lt;&lt; "TTC: " &lt;&lt; ttc &lt;&lt; ", dv: &lt;&lt; " &lt;&lt; dv &lt;&lt;", dd:" &lt;&lt; dd &lt;&lt; endl;
+		}
+		else
+			cout &lt;&lt; "TTC: Inf" &lt;&lt; endl;
+	}
 }
 
 void ContourTracker::MainLoop()
@@ -503,7 +528,7 @@ void ContourTracker::MainLoop()
 	{
 		ReadCommonParams();
 
-		if(bVectorMapCheck &amp;&amp; m_MapType == PlannerHNS::MAP_KML_FILE &amp;&amp; !bMap)
+		if(m_MapFilterDistance &gt; 0 &amp;&amp; m_MapType == PlannerHNS::MAP_KML_FILE &amp;&amp; !bMap)
 		{
 			PlannerHNS::MappingHelpers::LoadKML(m_MapPath, m_Map);
 			if(m_Map.roadSegments.size() &gt; 0)
@@ -512,11 +537,48 @@ void ContourTracker::MainLoop()
 				std::cout &lt;&lt; " ******* Map Is Loaded successfully from the tracker !! " &lt;&lt; std::endl;
 			}
 		}
-		else if (bVectorMapCheck &amp;&amp; m_MapType == PlannerHNS::MAP_FOLDER &amp;&amp; !bMap)
+		else if (m_MapFilterDistance &gt; 0 &amp;&amp; m_MapType == PlannerHNS::MAP_FOLDER &amp;&amp; !bMap)
 		{
 			PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_MapPath, m_Map, true);
 			if(m_Map.roadSegments.size() &gt; 0)
+			{
+				std::cout &lt;&lt; " ******* Map Is Loaded successfully from the tracker !! " &lt;&lt; std::endl;
 				bMap = true;
+			}
+		}
+		else if (m_MapFilterDistance &gt; 0 &amp;&amp; m_MapType == PlannerHNS::MAP_AUTOWARE &amp;&amp; !bMap)
+		{
+			std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;;
+
+			if(m_MapRaw.GetVersion()==2)
+			{
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
+						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
+						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,
+						m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true);
+
+				if(m_Map.roadSegments.size() &gt; 0)
+				{
+					bMap = true;
+					std::cout &lt;&lt; " ******* Map Is Loaded successfully from the tracker !! " &lt;&lt; std::endl;
+				}
+			}
+			else if(m_MapRaw.GetVersion()==1)
+			{
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
+						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
+						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true);
+
+				if(m_Map.roadSegments.size() &gt; 0)
+				{
+					bMap = true;
+					std::cout &lt;&lt; " ******* Map Is Loaded successfully from the tracker !! " &lt;&lt; std::endl;
+				}
+			}
 		}
 
 		ros::spinOnce();
@@ -524,4 +586,105 @@ void ContourTracker::MainLoop()
 	}
 
 }
+
+//Mapping Section
+
+void ContourTracker::callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Lanes" &lt;&lt; endl;
+	if(m_MapRaw.pLanes == nullptr)
+		m_MapRaw.pLanes = new UtilityHNS::AisanLanesFileReader(msg);
+}
+
+void ContourTracker::callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Points" &lt;&lt; endl;
+	if(m_MapRaw.pPoints  == nullptr)
+		m_MapRaw.pPoints = new UtilityHNS::AisanPointsFileReader(msg);
+}
+
+void ContourTracker::callbackGetVMdtLanes(const vector_map_msgs::DTLaneArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received dtLanes" &lt;&lt; endl;
+	if(m_MapRaw.pCenterLines == nullptr)
+		m_MapRaw.pCenterLines = new UtilityHNS::AisanCenterLinesFileReader(msg);
+}
+
+void ContourTracker::callbackGetVMIntersections(const vector_map_msgs::CrossRoadArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received CrossRoads" &lt;&lt; endl;
+	if(m_MapRaw.pIntersections == nullptr)
+		m_MapRaw.pIntersections = new UtilityHNS::AisanIntersectionFileReader(msg);
+}
+
+void ContourTracker::callbackGetVMAreas(const vector_map_msgs::AreaArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Areas" &lt;&lt; endl;
+	if(m_MapRaw.pAreas == nullptr)
+		m_MapRaw.pAreas = new UtilityHNS::AisanAreasFileReader(msg);
+}
+
+void ContourTracker::callbackGetVMLines(const vector_map_msgs::LineArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Lines" &lt;&lt; endl;
+	if(m_MapRaw.pLines == nullptr)
+		m_MapRaw.pLines = new UtilityHNS::AisanLinesFileReader(msg);
+}
+
+void ContourTracker::callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received StopLines" &lt;&lt; endl;
+	if(m_MapRaw.pStopLines == nullptr)
+		m_MapRaw.pStopLines = new UtilityHNS::AisanStopLineFileReader(msg);
+}
+
+void ContourTracker::callbackGetVMSignal(const vector_map_msgs::SignalArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Signals" &lt;&lt; endl;
+	if(m_MapRaw.pSignals  == nullptr)
+		m_MapRaw.pSignals = new UtilityHNS::AisanSignalFileReader(msg);
+}
+
+void ContourTracker::callbackGetVMVectors(const vector_map_msgs::VectorArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Vectors" &lt;&lt; endl;
+	if(m_MapRaw.pVectors  == nullptr)
+		m_MapRaw.pVectors = new UtilityHNS::AisanVectorFileReader(msg);
+}
+
+void ContourTracker::callbackGetVMCurbs(const vector_map_msgs::CurbArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Curbs" &lt;&lt; endl;
+	if(m_MapRaw.pCurbs == nullptr)
+		m_MapRaw.pCurbs = new UtilityHNS::AisanCurbFileReader(msg);
+}
+
+void ContourTracker::callbackGetVMRoadEdges(const vector_map_msgs::RoadEdgeArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Edges" &lt;&lt; endl;
+	if(m_MapRaw.pRoadedges  == nullptr)
+		m_MapRaw.pRoadedges = new UtilityHNS::AisanRoadEdgeFileReader(msg);
+}
+
+void ContourTracker::callbackGetVMWayAreas(const vector_map_msgs::WayAreaArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Wayareas" &lt;&lt; endl;
+	if(m_MapRaw.pWayAreas  == nullptr)
+		m_MapRaw.pWayAreas = new UtilityHNS::AisanWayareaFileReader(msg);
+}
+
+void ContourTracker::callbackGetVMCrossWalks(const vector_map_msgs::CrossWalkArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received CrossWalks" &lt;&lt; endl;
+	if(m_MapRaw.pCrossWalks == nullptr)
+		m_MapRaw.pCrossWalks = new UtilityHNS::AisanCrossWalkFileReader(msg);
+}
+
+void ContourTracker::callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Nodes" &lt;&lt; endl;
+	if(m_MapRaw.pNodes == nullptr)
+		m_MapRaw.pNodes = new UtilityHNS::AisanNodesFileReader(msg);
+}
+
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\DataRW.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\DataRW.h" added_lines="339" deleted_lines="37">
				<diff>@@ -15,6 +15,23 @@
 #include &lt;iostream&gt;
 #include &lt;limits&gt;
 
+#include "vector_map_msgs/PointArray.h"
+#include "vector_map_msgs/LaneArray.h"
+#include "vector_map_msgs/NodeArray.h"
+#include "vector_map_msgs/StopLineArray.h"
+#include "vector_map_msgs/DTLaneArray.h"
+#include "vector_map_msgs/LineArray.h"
+#include "vector_map_msgs/AreaArray.h"
+#include "vector_map_msgs/WayAreaArray.h"
+#include "vector_map_msgs/SignalArray.h"
+#include "vector_map_msgs/VectorArray.h"
+#include "vector_map_msgs/CrossRoadArray.h"
+#include "vector_map_msgs/RoadSignArray.h"
+#include "vector_map_msgs/CurbArray.h"
+#include "vector_map_msgs/RoadEdgeArray.h"
+#include "vector_map_msgs/CrossWalkArray.h"
+
+
 namespace UtilityHNS {
 
 class DataRW
@@ -68,6 +85,7 @@ public:
 	SimpleReaderBase(const std::string&amp; fileName, const int&amp; nHeaders = 2, const char&amp; separator = ',',
 			const int&amp; iDataTitles = 1, const int&amp; nVariablesForOneObject = 0,
 			const int&amp; nLineHeaders = 0, const std::string&amp; headerRepeatKey = "...");
+
 	~SimpleReaderBase();
 
 protected:
@@ -166,12 +184,15 @@ public:
 	{
 		m_min_id = std::numeric_limits&lt;int&gt;::max();
 	}
+
+	AisanPointsFileReader(const vector_map_msgs::PointArray&amp; _points);
 	~AisanPointsFileReader(){}
 
-	std::vector&lt;AisanPoints&gt; m_data_list;
 	bool ReadNextLine(AisanPoints&amp; data);
 	int ReadAllData(std::vector&lt;AisanPoints&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::Point&amp; _rec, AisanPoints&amp; data);
 	AisanPoints* GetDataRowById(int _pid);
+	std::vector&lt;AisanPoints&gt; m_data_list;
 
 private:
 	int m_min_id;
@@ -192,13 +213,15 @@ public:
 	{
 		m_min_id = std::numeric_limits&lt;int&gt;::max();
 	}
+
+	AisanNodesFileReader(const vector_map_msgs::NodeArray&amp; _nodes);
 	~AisanNodesFileReader(){}
 
-	std::vector&lt;AisanNode&gt; m_data_list;
 	bool ReadNextLine(AisanNode&amp; data);
 	int ReadAllData(std::vector&lt;AisanNode&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::Node&amp; _rec, AisanNode&amp; data);
 	AisanNode* GetDataRowById(int _nid);
-
+	std::vector&lt;AisanNode&gt; m_data_list;
 
 private:
 	int m_min_id;
@@ -222,39 +245,20 @@ public:
 	{
 		m_min_id = std::numeric_limits&lt;int&gt;::max();
 	}
+	AisanLinesFileReader(const vector_map_msgs::LineArray &amp; _lines);
 	~AisanLinesFileReader(){}
 
-	std::vector&lt;AisanLine&gt; m_data_list;
 	bool ReadNextLine(AisanLine&amp; data);
 	int ReadAllData(std::vector&lt;AisanLine&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::Line&amp; _rec, AisanLine&amp; data);
 	AisanLine* GetDataRowById(int _lid);
+	std::vector&lt;AisanLine&gt; m_data_list;
 
 private:
 	int m_min_id;
 	std::vector&lt;AisanLine*&gt; m_data_map;
 };
 
-class AisanCLinesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanCLine
-	{
-		int ID;
-		int LID;
-		double width;
-		char color;
-		int type;
-		int LinkID;
-	};
-
-	AisanCLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanCLinesFileReader(){}
-
-	bool ReadNextLine(AisanCLine&amp; data);
-	int ReadAllData(std::vector&lt;AisanCLine&gt;&amp; data_list);
-};
-
 class AisanCenterLinesFileReader : public SimpleReaderBase
 {
 public:
@@ -273,11 +277,22 @@ public:
 		double 	RW;
 	};
 
-	AisanCenterLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanCenterLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
+	AisanCenterLinesFileReader(const vector_map_msgs::DTLaneArray&amp; _dtLanes);
 	~AisanCenterLinesFileReader(){}
 
 	bool ReadNextLine(AisanCenterLine&amp; data);
 	int ReadAllData(std::vector&lt;AisanCenterLine&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::DTLane&amp; _rec, AisanCenterLine&amp; data);
+	AisanCenterLine* GetDataRowById(int _lnid);
+	std::vector&lt;AisanCenterLine&gt; m_data_list;
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanCenterLine*&gt; m_data_map;
 };
 
 class AisanAreasFileReader : public SimpleReaderBase
@@ -291,11 +306,22 @@ public:
 		int 	ELID;
 	};
 
-	AisanAreasFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanAreasFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
+	AisanAreasFileReader(const vector_map_msgs::AreaArray&amp; _areas);
 	~AisanAreasFileReader(){}
 
 	bool ReadNextLine(AisanArea&amp; data);
 	int ReadAllData(std::vector&lt;AisanArea&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::Area&amp; _rec, AisanArea&amp; data);
+	AisanArea* GetDataRowById(int _lnid);
+	std::vector&lt;AisanArea&gt; m_data_list;
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanArea*&gt; m_data_map;
 };
 
 class AisanIntersectionFileReader : public SimpleReaderBase
@@ -309,11 +335,22 @@ public:
 		int 	LinkID;
 	};
 
-	AisanIntersectionFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanIntersectionFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
+	AisanIntersectionFileReader(const vector_map_msgs::CrossRoadArray&amp; _inters);
 	~AisanIntersectionFileReader(){}
 
 	bool ReadNextLine(AisanIntersection&amp; data);
 	int ReadAllData(std::vector&lt;AisanIntersection&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::CrossRoad&amp; _rec, AisanIntersection&amp; data);
+	AisanIntersection* GetDataRowById(int _lnid);
+	std::vector&lt;AisanIntersection&gt; m_data_list;
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanIntersection*&gt; m_data_map;
 };
 
 class AisanLanesFileReader : public SimpleReaderBase
@@ -356,12 +393,14 @@ public:
 	{
 		m_min_id = std::numeric_limits&lt;int&gt;::max();
 	}
+	AisanLanesFileReader(const vector_map_msgs::LaneArray&amp; _lanes);
 	~AisanLanesFileReader(){}
 
-	std::vector&lt;AisanLane&gt; m_data_list;
 	bool ReadNextLine(AisanLane&amp; data);
 	int ReadAllData(std::vector&lt;AisanLane&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::Lane&amp; _rec, AisanLane&amp; data);
 	AisanLane* GetDataRowById(int _lnid);
+	std::vector&lt;AisanLane&gt; m_data_list;
 
 private:
 	int m_min_id;
@@ -381,11 +420,22 @@ public:
 		int 	LinkID;
 	};
 
-	AisanStopLineFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanStopLineFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
+	AisanStopLineFileReader(const vector_map_msgs::StopLineArray&amp; _stopLines);
 	~AisanStopLineFileReader(){}
 
 	bool ReadNextLine(AisanStopLine&amp; data);
 	int ReadAllData(std::vector&lt;AisanStopLine&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::StopLine&amp; _rec, AisanStopLine&amp; data);
+	AisanStopLine* GetDataRowById(int _lnid);
+	std::vector&lt;AisanStopLine&gt; m_data_list;
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanStopLine*&gt; m_data_map;
 };
 
 class AisanRoadSignFileReader : public SimpleReaderBase
@@ -401,11 +451,22 @@ public:
 		int 	LinkID;
 	};
 
-	AisanRoadSignFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanRoadSignFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
+	AisanRoadSignFileReader(const vector_map_msgs::RoadSignArray&amp; _signs);
 	~AisanRoadSignFileReader(){}
 
 	bool ReadNextLine(AisanRoadSign&amp; data);
 	int ReadAllData(std::vector&lt;AisanRoadSign&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::RoadSign&amp; _rec, AisanRoadSign&amp; data);
+	AisanRoadSign* GetDataRowById(int _lnid);
+	std::vector&lt;AisanRoadSign&gt; m_data_list;
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanRoadSign*&gt; m_data_map;
 };
 
 class AisanSignalFileReader : public SimpleReaderBase
@@ -421,11 +482,22 @@ public:
 		int 	LinkID;
 	};
 
-	AisanSignalFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanSignalFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
+	AisanSignalFileReader(const vector_map_msgs::SignalArray&amp; _signals);
 	~AisanSignalFileReader(){}
 
 	bool ReadNextLine(AisanSignal&amp; data);
 	int ReadAllData(std::vector&lt;AisanSignal&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::Signal&amp; _rec, AisanSignal&amp; data);
+	AisanSignal* GetDataRowById(int _lnid);
+	std::vector&lt;AisanSignal&gt; m_data_list;
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanSignal*&gt; m_data_map;
 };
 
 class AisanVectorFileReader : public SimpleReaderBase
@@ -440,11 +512,22 @@ public:
 		double 	Vang;
 	};
 
-	AisanVectorFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanVectorFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
+	AisanVectorFileReader(const vector_map_msgs::VectorArray&amp; _vectors);
 	~AisanVectorFileReader(){}
 
 	bool ReadNextLine(AisanVector&amp; data);
 	int ReadAllData(std::vector&lt;AisanVector&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::Vector&amp; _rec, AisanVector&amp; data);
+	AisanVector* GetDataRowById(int _lnid);
+	std::vector&lt;AisanVector&gt; m_data_list;
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanVector*&gt; m_data_map;
 };
 
 class AisanCurbFileReader : public SimpleReaderBase
@@ -461,11 +544,22 @@ public:
 		int 	LinkID;
 	};
 
-	AisanCurbFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanCurbFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
+	AisanCurbFileReader(const vector_map_msgs::CurbArray&amp; _curbs);
 	~AisanCurbFileReader(){}
 
 	bool ReadNextLine(AisanCurb&amp; data);
 	int ReadAllData(std::vector&lt;AisanCurb&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::Curb&amp; _rec, AisanCurb&amp; data);
+	AisanCurb* GetDataRowById(int _lnid);
+	std::vector&lt;AisanCurb&gt; m_data_list;
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanCurb*&gt; m_data_map;
 };
 
 class AisanRoadEdgeFileReader : public SimpleReaderBase
@@ -479,11 +573,22 @@ public:
 		int 	LinkID;
 	};
 
-	AisanRoadEdgeFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanRoadEdgeFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
+	AisanRoadEdgeFileReader(const vector_map_msgs::RoadEdgeArray&amp; _roadEdges);
 	~AisanRoadEdgeFileReader(){}
 
 	bool ReadNextLine(AisanRoadEdge&amp; data);
 	int ReadAllData(std::vector&lt;AisanRoadEdge&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::RoadEdge&amp; _rec, AisanRoadEdge&amp; data);
+	AisanRoadEdge* GetDataRowById(int _lnid);
+	std::vector&lt;AisanRoadEdge&gt; m_data_list;
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanRoadEdge*&gt; m_data_map;
 };
 
 class AisanCrossWalkFileReader : public SimpleReaderBase
@@ -499,11 +604,22 @@ public:
 		int 	LinkID;
 	};
 
-	AisanCrossWalkFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanCrossWalkFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
+	AisanCrossWalkFileReader(const vector_map_msgs::CrossWalkArray&amp; _crossWalks);
 	~AisanCrossWalkFileReader(){}
 
 	bool ReadNextLine(AisanCrossWalk&amp; data);
 	int ReadAllData(std::vector&lt;AisanCrossWalk&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::CrossWalk&amp; _rec, AisanCrossWalk&amp; data);
+	AisanCrossWalk* GetDataRowById(int _lnid);
+	std::vector&lt;AisanCrossWalk&gt; m_data_list;
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanCrossWalk*&gt; m_data_map;
 };
 
 class AisanWayareaFileReader : public SimpleReaderBase
@@ -517,11 +633,22 @@ public:
 		int 	LinkID;
 	};
 
-	AisanWayareaFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	AisanWayareaFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1)
+	{
+		m_min_id = std::numeric_limits&lt;int&gt;::max();
+	}
+	AisanWayareaFileReader(const vector_map_msgs::WayAreaArray&amp; _wayArea);
 	~AisanWayareaFileReader(){}
 
 	bool ReadNextLine(AisanWayarea&amp; data);
 	int ReadAllData(std::vector&lt;AisanWayarea&gt;&amp; data_list);
+	void ParseNextLine(const vector_map_msgs::WayArea&amp; _rec, AisanWayarea&amp; data);
+	AisanWayarea* GetDataRowById(int _lnid);
+	std::vector&lt;AisanWayarea&gt; m_data_list;
+
+private:
+	int m_min_id;
+	std::vector&lt;AisanWayarea*&gt; m_data_map;
 };
 
 class AisanDataConnFileReader : public SimpleReaderBase
@@ -543,6 +670,181 @@ public:
 	int ReadAllData(std::vector&lt;DataConn&gt;&amp; data_list);
 };
 
+class MapRaw
+{
+public:
+	UtilityHNS::AisanLanesFileReader* pLanes;
+	UtilityHNS::AisanPointsFileReader* pPoints;
+	UtilityHNS::AisanCenterLinesFileReader* pCenterLines;
+	UtilityHNS::AisanIntersectionFileReader* pIntersections;
+	UtilityHNS::AisanAreasFileReader* pAreas;
+	UtilityHNS::AisanLinesFileReader* pLines;
+	UtilityHNS::AisanStopLineFileReader* pStopLines;
+	UtilityHNS::AisanSignalFileReader* pSignals;
+	UtilityHNS::AisanVectorFileReader* pVectors;
+	UtilityHNS::AisanCurbFileReader* pCurbs;
+	UtilityHNS::AisanRoadEdgeFileReader* pRoadedges;
+	UtilityHNS::AisanWayareaFileReader* pWayAreas;
+	UtilityHNS::AisanCrossWalkFileReader* pCrossWalks;
+	UtilityHNS::AisanNodesFileReader* pNodes;
+
+	MapRaw()
+	{
+		pLanes = nullptr;
+		pPoints = nullptr;
+		pCenterLines = nullptr;
+		pIntersections = nullptr;
+		pAreas = nullptr;
+		pLines = nullptr;
+		pStopLines = nullptr;
+		pSignals = nullptr;
+		pVectors = nullptr;
+		pCurbs = nullptr;
+		pRoadedges = nullptr;
+		pWayAreas = nullptr;
+		pCrossWalks = nullptr;
+		pNodes = nullptr;
+	}
+
+	~MapRaw()
+	{
+		if(pLanes != nullptr)
+		{
+			delete pLanes;
+			pLanes = nullptr;
+		}
+
+		if(pPoints != nullptr)
+		{
+			delete pPoints;
+			pPoints = nullptr;
+		}
+
+		if(pCenterLines != nullptr)
+		{
+			delete pCenterLines;
+			pCenterLines = nullptr;
+		}
+
+		if(pIntersections != nullptr)
+		{
+			delete pIntersections;
+			pIntersections = nullptr;
+		}
+
+		if(pAreas != nullptr)
+		{
+			delete pAreas;
+			pAreas = nullptr;
+		}
+
+		if(pLines != nullptr)
+		{
+			delete pLines;
+			pLines = nullptr;
+		}
+
+		if(pStopLines != nullptr)
+		{
+			delete pStopLines;
+			pStopLines = nullptr;
+		}
+
+		if(pSignals != nullptr)
+		{
+			delete pSignals;
+			pSignals = nullptr;
+		}
+
+		if(pVectors != nullptr)
+		{
+			delete pVectors;
+			pVectors = nullptr;
+		}
+
+		if(pCurbs != nullptr)
+		{
+			delete pCurbs;
+			pCurbs = nullptr;
+		}
+
+		if(pRoadedges != nullptr)
+		{
+			delete pRoadedges;
+			pRoadedges = nullptr;
+		}
+
+		if(pWayAreas != nullptr)
+		{
+			delete pWayAreas;
+			pWayAreas = nullptr;
+		}
+
+		if(pCrossWalks != nullptr)
+		{
+			delete pCrossWalks;
+			pCrossWalks = nullptr;
+		}
+
+		if(pNodes != nullptr)
+		{
+			delete pNodes;
+			pNodes = nullptr;
+		}
+	}
+
+	int GetVersion()
+	{
+		bool bLoaded =  pLanes != nullptr &amp;&amp; pPoints != nullptr &amp;&amp; pCenterLines  != nullptr &amp;&amp; pNodes  != nullptr;
+		int iVersion = 0;
+		if(bLoaded)
+		{
+			iVersion = 2;
+		}
+		else
+		{
+			bLoaded =  pLanes != nullptr &amp;&amp; pPoints != nullptr &amp;&amp; pCenterLines  != nullptr;
+			if(bLoaded)
+			{
+				iVersion = 1;
+				if(pNodes  == nullptr)
+					pNodes = new AisanNodesFileReader(vector_map_msgs::NodeArray());
+			}
+		}
+
+		if(bLoaded)
+		{
+			if(pIntersections  == nullptr)
+				pIntersections  = new AisanIntersectionFileReader(vector_map_msgs::CrossRoadArray());
+
+			if(pLines  == nullptr)
+				pLines  = new AisanLinesFileReader(vector_map_msgs::LineArray());
+
+			if(pStopLines  == nullptr)
+				pStopLines  = new AisanStopLineFileReader(vector_map_msgs::StopLineArray());
+
+			if(pSignals  == nullptr)
+				pSignals  = new AisanSignalFileReader(vector_map_msgs::SignalArray());
+
+			if(pVectors  == nullptr)
+				pVectors  = new AisanVectorFileReader(vector_map_msgs::VectorArray());
+
+			if(pCurbs  == nullptr)
+				pCurbs  = new AisanCurbFileReader(vector_map_msgs::CurbArray());
+
+			if(pRoadedges  == nullptr)
+				pRoadedges  = new AisanRoadEdgeFileReader(vector_map_msgs::RoadEdgeArray());
+
+			if(pWayAreas  == nullptr)
+				pWayAreas  = new AisanWayareaFileReader(vector_map_msgs::WayAreaArray());
+
+			if(pCrossWalks  == nullptr)
+				pCrossWalks  = new AisanCrossWalkFileReader(vector_map_msgs::CrossWalkArray());
+		}
+
+		return iVersion;
+	}
+};
 
 } /* namespace UtilityHNS */
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" added_lines="873" deleted_lines="56">
				<diff>@@ -215,6 +215,8 @@ SimpleReaderBase::SimpleReaderBase(const string&amp; fileName, const int&amp; nHeaders,c
 		  const int&amp; iDataTitles, const int&amp; nVariablesForOneObject ,
 		  const int&amp; nLineHeaders, const string&amp; headerRepeatKey)
 {
+	if(fileName.compare("d") != 0)
+	{
 	  m_pFile = new ifstream(fileName.c_str(), ios::in);
 	  if(!m_pFile-&gt;is_open())
 	  {
@@ -231,6 +233,7 @@ SimpleReaderBase::SimpleReaderBase(const string&amp; fileName, const int&amp; nHeaders,c
 	m_pFile-&gt;precision(16);
 
 	ReadHeaders();
+	}
 }
 
 SimpleReaderBase::~SimpleReaderBase()
@@ -451,6 +454,66 @@ int LocalizationPathReader::ReadAllData(vector&lt;LocalizationWayPoint&gt;&amp; data_list)
 	return count;
 }
 
+//Nodes
+
+AisanNodesFileReader::AisanNodesFileReader(const vector_map_msgs::NodeArray&amp; _nodes) : SimpleReaderBase("d", 1)
+{
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
+
+	//TODO Fix PID and NID problem
+
+	m_data_list.clear();
+	AisanNode data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _nodes.data.size(); i++)
+	{
+		ParseNextLine(_nodes.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.NID &lt; m_min_id)
+			m_min_id = data.NID;
+
+		if(data.NID &gt; max_id)
+			max_id = data.NID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).NID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanNodesFileReader::ParseNextLine(const vector_map_msgs::Node&amp; _rec, AisanNode&amp; data)
+{
+	data.NID = _rec.nid;
+	data.PID = _rec.pid;
+}
+
+AisanNodesFileReader::AisanNode* AisanNodesFileReader::GetDataRowById(int _nid)
+{
+	if(m_data_map.size()==0) return nullptr;
+
+	int index = _nid-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
+	{
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+		{
+			if(m_data_list.at(i).NID == _nid)
+			{
+				return &amp;m_data_list.at(i);
+			}
+		}
+	}
+
+	return nullptr;
+}
+
 bool AisanNodesFileReader::ReadNextLine(AisanNode&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
@@ -495,11 +558,54 @@ int AisanNodesFileReader::ReadAllData(vector&lt;AisanNode&gt;&amp; data_list)
 	return m_data_list.size();
 }
 
-AisanNodesFileReader::AisanNode* AisanNodesFileReader::GetDataRowById(int _nid)
+//Points
+
+AisanPointsFileReader::AisanPointsFileReader(const vector_map_msgs::PointArray&amp; _points) : SimpleReaderBase("d", 1)
+{
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
+
+	m_data_list.clear();
+	AisanPoints data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _points.data.size(); i++)
+	{
+		ParseNextLine(_points.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.PID &lt; m_min_id)
+			m_min_id = data.PID;
+
+		if(data.PID &gt; max_id)
+			max_id = data.PID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).PID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanPointsFileReader::ParseNextLine(const vector_map_msgs::Point&amp; _rec, AisanPoints&amp; data)
+{
+	data.B = _rec.b;
+	data.Bx = _rec.bx;
+	data.H = _rec.h;
+	data.L = _rec.l;
+	data.Ly = _rec.ly;
+	data.MCODE1 = _rec.mcode1;
+	data.MCODE2 = _rec.mcode2;
+	data.MCODE3 = _rec.mcode3;
+	data.PID = _rec.pid;
+	data.Ref = _rec.ref;
+}
+
+AisanPointsFileReader::AisanPoints* AisanPointsFileReader::GetDataRowById(int _pid)
 {
 	if(m_data_map.size()==0) return nullptr;
 
-	int index = _nid-m_min_id;
+	int index = _pid-m_min_id;
 	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
 	{
 		return m_data_map.at(index);
@@ -508,7 +614,7 @@ AisanNodesFileReader::AisanNode* AisanNodesFileReader::GetDataRowById(int _nid)
 	{
 		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
 		{
-			if(m_data_list.at(i).NID == _nid)
+			if(m_data_list.at(i).PID == _pid)
 			{
 				return &amp;m_data_list.at(i);
 			}
@@ -571,11 +677,49 @@ int AisanPointsFileReader::ReadAllData(vector&lt;AisanPoints&gt;&amp; data_list)
 	return m_data_list.size();
 }
 
-AisanPointsFileReader::AisanPoints* AisanPointsFileReader::GetDataRowById(int _pid)
+// Lines
+
+AisanLinesFileReader::AisanLinesFileReader(const vector_map_msgs::LineArray&amp; _nodes) : SimpleReaderBase("d", 1)
+{
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
+
+	m_data_list.clear();
+	AisanLine data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _nodes.data.size(); i++)
+	{
+		ParseNextLine(_nodes.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.LID &lt; m_min_id)
+			m_min_id = data.LID;
+
+		if(data.LID &gt; max_id)
+			max_id = data.LID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).LID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanLinesFileReader::ParseNextLine(const vector_map_msgs::Line&amp; _rec, AisanLine&amp; data)
+{
+	data.BLID = _rec.blid;
+	data.BPID = _rec.bpid;
+	data.FLID = _rec.flid;
+	data.FPID = _rec.fpid;
+	data.LID = _rec.lid;
+}
+
+AisanLinesFileReader::AisanLine* AisanLinesFileReader::GetDataRowById(int _lid)
 {
 	if(m_data_map.size()==0) return nullptr;
 
-	int index = _pid-m_min_id;
+	int index = _lid-m_min_id;
 	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
 	{
 		return m_data_map.at(index);
@@ -584,7 +728,7 @@ AisanPointsFileReader::AisanPoints* AisanPointsFileReader::GetDataRowById(int _p
 	{
 		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
 		{
-			if(m_data_list.at(i).PID == _pid)
+			if(m_data_list.at(i).LID == _lid)
 			{
 				return &amp;m_data_list.at(i);
 			}
@@ -641,11 +785,54 @@ int AisanLinesFileReader::ReadAllData(vector&lt;AisanLine&gt;&amp; data_list)
 	return m_data_list.size();
 }
 
-AisanLinesFileReader::AisanLine* AisanLinesFileReader::GetDataRowById(int _lid)
+//dt Lanes (center lines)
+
+AisanCenterLinesFileReader::AisanCenterLinesFileReader(const vector_map_msgs::DTLaneArray&amp; _Lines) : SimpleReaderBase("d", 1)
+{
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
+
+	m_data_list.clear();
+	AisanCenterLine data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _Lines.data.size(); i++)
+	{
+		ParseNextLine(_Lines.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.DID &lt; m_min_id)
+			m_min_id = data.DID;
+
+		if(data.DID &gt; max_id)
+			max_id = data.DID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).DID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanCenterLinesFileReader::ParseNextLine(const vector_map_msgs::DTLane&amp; _rec, AisanCenterLine&amp; data)
+{
+	data.Apara = _rec.apara;
+	data.DID = _rec.did;
+	data.Dir = _rec.dir;
+	data.Dist = _rec.dist;
+	data.LW = _rec.lw;
+	data.PID = _rec.pid;
+	data.RW = _rec.rw;
+	data.cant = _rec.cant;
+	data.r = _rec.r;
+	data.slope = _rec.slope;
+}
+
+AisanCenterLinesFileReader::AisanCenterLine* AisanCenterLinesFileReader::GetDataRowById(int _did)
 {
 	if(m_data_map.size()==0) return nullptr;
 
-	int index = _lid-m_min_id;
+	int index = _did-m_min_id;
 	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
 	{
 		return m_data_map.at(index);
@@ -654,7 +841,7 @@ AisanLinesFileReader::AisanLine* AisanLinesFileReader::GetDataRowById(int _lid)
 	{
 		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
 		{
-			if(m_data_list.at(i).LID == _lid)
+			if(m_data_list.at(i).DID == _did)
 			{
 				return &amp;m_data_list.at(i);
 			}
@@ -664,41 +851,6 @@ AisanLinesFileReader::AisanLine* AisanLinesFileReader::GetDataRowById(int _lid)
 	return nullptr;
 }
 
-bool AisanCLinesFileReader::ReadNextLine(AisanCLine&amp; data)
-{
-	vector&lt;vector&lt;string&gt; &gt; lineData;
-	if(ReadSingleLine(lineData))
-	{
-		if(lineData.size()==0) return false;
-		if(lineData.at(0).size() &lt; 5) return false;
-
-		data.ID = strtol(lineData.at(0).at(0).c_str(), NULL, 10);
-		data.LID = strtol(lineData.at(0).at(1).c_str(), NULL, 10);
-		data.width = strtod(lineData.at(0)[2].c_str(), NULL);
-		if(lineData.at(0).at(3).size()&gt;0)
-			data.type = lineData.at(0).at(3).at(0);
-		data.LinkID = strtol(lineData.at(0).at(4).c_str(), NULL, 10);
-
-		return true;
-	}
-	else
-		return false;
-}
-
-int AisanCLinesFileReader::ReadAllData(vector&lt;AisanCLine&gt;&amp; data_list)
-{
-	data_list.clear();
-	AisanCLine data;
-	//double logTime = 0;
-	int count = 0;
-	while(ReadNextLine(data))
-	{
-		data_list.push_back(data);
-		count++;
-	}
-	return count;
-}
-
 bool AisanCenterLinesFileReader::ReadNextLine(AisanCenterLine&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
@@ -739,6 +891,91 @@ int AisanCenterLinesFileReader::ReadAllData(vector&lt;AisanCenterLine&gt;&amp; data_list)
 	return count;
 }
 
+//Lane
+
+AisanLanesFileReader::AisanLanesFileReader(const vector_map_msgs::LaneArray&amp; _lanes) : SimpleReaderBase("d", 1)
+{
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
+
+	m_data_list.clear();
+	AisanLane data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _lanes.data.size(); i++)
+	{
+		ParseNextLine(_lanes.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.LnID &lt; m_min_id)
+			m_min_id = data.LnID;
+
+		if(data.LnID &gt; max_id)
+			max_id = data.LnID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).LnID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanLanesFileReader::ParseNextLine(const vector_map_msgs::Lane&amp; _rec, AisanLane&amp; data)
+{
+	data.BLID = _rec.blid;
+	data.BLID2 = _rec.blid2;
+	data.BLID3 = _rec.blid3;
+	data.BLID4 = _rec.blid4;
+	data.BNID = _rec.bnid;
+	data.ClossID = _rec.clossid;
+	data.DID = _rec.did;
+	data.FLID = _rec.flid;
+	data.FLID2 = _rec.flid2;
+	data.FLID3 = _rec.flid3;
+	data.FLID4 = _rec.flid4;
+
+	data.FNID = _rec.fnid;
+	data.JCT = _rec.jct;
+	data.LCnt = _rec.lcnt;
+	data.LaneChgFG = _rec.lanecfgfg;
+	//data.LaneDir = _rec.;
+	data.LaneType = _rec.lanetype;
+	//data.LeftLaneId = _rec.;
+	data.LimitVel = _rec.limitvel;
+	data.LinkWAID = _rec.linkwaid;
+	data.LnID = _rec.lnid;
+	data.Lno = _rec.lno;
+	data.RefVel = _rec.refvel;
+	//data.RightLaneId = _rec.;
+	data.RoadSecID = _rec.roadsecid;
+	data.Span = _rec.span;
+	//data.originalMapID = _rec.;
+
+}
+
+AisanLanesFileReader::AisanLane* AisanLanesFileReader::GetDataRowById(int _lnid)
+{
+	if(m_data_map.size()==0) return nullptr;
+
+	int index = _lnid-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
+	{
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+		{
+			if(m_data_list.at(i).LnID == _lnid)
+			{
+				return &amp;m_data_list.at(i);
+			}
+		}
+	}
+
+	return nullptr;
+}
+
 bool AisanLanesFileReader::ReadNextLine(AisanLane&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
@@ -825,27 +1062,63 @@ int AisanLanesFileReader::ReadAllData(vector&lt;AisanLane&gt;&amp; data_list)
 	return m_data_list.size();
 }
 
-AisanLanesFileReader::AisanLane* AisanLanesFileReader::GetDataRowById(int _lnid)
+//Area
+
+AisanAreasFileReader::AisanAreasFileReader(const vector_map_msgs::AreaArray&amp; _areas) : SimpleReaderBase("d", 1)
 {
-	if(m_data_map.size()==0) return nullptr;
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
-int index = _lnid-m_min_id;
-if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	m_data_list.clear();
+	AisanArea data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _areas.data.size(); i++)
+	{
+		ParseNextLine(_areas.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.AID &lt; m_min_id)
+			m_min_id = data.AID;
+
+		if(data.AID &gt; max_id)
+			max_id = data.AID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).AID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanAreasFileReader::ParseNextLine(const vector_map_msgs::Area&amp; _rec, AisanArea&amp; data)
 {
-	return m_data_map.at(index);
+	data.AID = _rec.aid;
+	data.ELID = _rec.elid;
+	data.SLID = _rec.slid;
 }
-else
+
+AisanAreasFileReader::AisanArea* AisanAreasFileReader::GetDataRowById(int _aid)
 {
-	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	if(m_data_map.size()==0) return nullptr;
+
+	int index = _aid-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
 	{
-		if(m_data_list.at(i).LnID == _lnid)
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
 		{
-			return &amp;m_data_list.at(i);
+			if(m_data_list.at(i).AID == _aid)
+			{
+				return &amp;m_data_list.at(i);
+			}
 		}
 	}
-}
 
-return nullptr;
+	return nullptr;
 }
 
 bool AisanAreasFileReader::ReadNextLine(AisanArea&amp; data)
@@ -881,7 +1154,66 @@ int AisanAreasFileReader::ReadAllData(vector&lt;AisanArea&gt;&amp; data_list)
 	return count;
 }
 
-bool AisanIntersectionFileReader::ReadNextLine(AisanIntersection&amp; data)
+//Intersection
+
+AisanIntersectionFileReader::AisanIntersectionFileReader(const vector_map_msgs::CrossRoadArray&amp; _inters) : SimpleReaderBase("d", 1)
+{
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
+
+	m_data_list.clear();
+	AisanIntersection data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _inters.data.size(); i++)
+	{
+		ParseNextLine(_inters.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.ID &lt; m_min_id)
+			m_min_id = data.ID;
+
+		if(data.ID &gt; max_id)
+			max_id = data.ID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).ID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanIntersectionFileReader::ParseNextLine(const vector_map_msgs::CrossRoad&amp; _rec, AisanIntersection&amp; data)
+{
+	data.AID = _rec.aid;
+	data.ID = _rec.id;
+	data.LinkID = _rec.linkid;
+}
+
+AisanIntersectionFileReader::AisanIntersection* AisanIntersectionFileReader::GetDataRowById(int _id)
+{
+	if(m_data_map.size()==0) return nullptr;
+
+	int index = _id-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
+	{
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+		{
+			if(m_data_list.at(i).ID == _id)
+			{
+				return &amp;m_data_list.at(i);
+			}
+		}
+	}
+
+	return nullptr;
+}
+
+bool AisanIntersectionFileReader::ReadNextLine(AisanIntersection&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
 	if(ReadSingleLine(lineData))
@@ -914,6 +1246,67 @@ int AisanIntersectionFileReader::ReadAllData(vector&lt;AisanIntersection&gt;&amp; data_lis
 	return count;
 }
 
+//StopLine
+
+AisanStopLineFileReader::AisanStopLineFileReader(const vector_map_msgs::StopLineArray&amp; _stopLines) : SimpleReaderBase("d", 1)
+{
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
+
+	m_data_list.clear();
+	AisanStopLine data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _stopLines.data.size(); i++)
+	{
+		ParseNextLine(_stopLines.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.ID &lt; m_min_id)
+			m_min_id = data.ID;
+
+		if(data.ID &gt; max_id)
+			max_id = data.ID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).ID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanStopLineFileReader::ParseNextLine(const vector_map_msgs::StopLine&amp; _rec, AisanStopLine&amp; data)
+{
+	data.ID = _rec.id;
+	data.LID = _rec.lid;
+	data.LinkID = _rec.linkid;
+	data.SignID = _rec.signid;
+	data.TLID = _rec.tlid;
+}
+
+AisanStopLineFileReader::AisanStopLine* AisanStopLineFileReader::GetDataRowById(int _id)
+{
+	if(m_data_map.size()==0) return nullptr;
+
+	int index = _id-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
+	{
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+		{
+			if(m_data_list.at(i).ID == _id)
+			{
+				return &amp;m_data_list.at(i);
+			}
+		}
+	}
+
+	return nullptr;
+}
+
 bool AisanStopLineFileReader::ReadNextLine(AisanStopLine&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
@@ -949,6 +1342,67 @@ int AisanStopLineFileReader::ReadAllData(vector&lt;AisanStopLine&gt;&amp; data_list)
 	return count;
 }
 
+//RoadSign
+
+AisanRoadSignFileReader::AisanRoadSignFileReader(const vector_map_msgs::RoadSignArray&amp; _signs) : SimpleReaderBase("d", 1)
+{
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
+
+	m_data_list.clear();
+	AisanRoadSign data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _signs.data.size(); i++)
+	{
+		ParseNextLine(_signs.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.ID &lt; m_min_id)
+			m_min_id = data.ID;
+
+		if(data.ID &gt; max_id)
+			max_id = data.ID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).ID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanRoadSignFileReader::ParseNextLine(const vector_map_msgs::RoadSign&amp; _rec, AisanRoadSign&amp; data)
+{
+	data.ID = _rec.id;
+	data.LinkID = _rec.linkid;
+	data.PLID = _rec.plid;
+	data.Type = _rec.type;
+	data.VID = _rec.vid;
+}
+
+AisanRoadSignFileReader::AisanRoadSign* AisanRoadSignFileReader::GetDataRowById(int _id)
+{
+	if(m_data_map.size()==0) return nullptr;
+
+	int index = _id-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
+	{
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+		{
+			if(m_data_list.at(i).ID == _id)
+			{
+				return &amp;m_data_list.at(i);
+			}
+		}
+	}
+
+	return nullptr;
+}
+
 bool AisanRoadSignFileReader::ReadNextLine(AisanRoadSign&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
@@ -984,6 +1438,67 @@ int AisanRoadSignFileReader::ReadAllData(vector&lt;AisanRoadSign&gt;&amp; data_list)
 	return count;
 }
 
+//Signal
+
+AisanSignalFileReader::AisanSignalFileReader(const vector_map_msgs::SignalArray&amp; _signal) : SimpleReaderBase("d", 1)
+{
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
+
+	m_data_list.clear();
+	AisanSignal data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _signal.data.size(); i++)
+	{
+		ParseNextLine(_signal.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.ID &lt; m_min_id)
+			m_min_id = data.ID;
+
+		if(data.ID &gt; max_id)
+			max_id = data.ID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).ID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanSignalFileReader::ParseNextLine(const vector_map_msgs::Signal&amp; _rec, AisanSignal&amp; data)
+{
+	data.ID = _rec.id;
+	data.LinkID = _rec.linkid;
+	data.PLID = _rec.plid;
+	data.Type = _rec.type;
+	data.VID = _rec.vid;
+}
+
+AisanSignalFileReader::AisanSignal* AisanSignalFileReader::GetDataRowById(int _id)
+{
+	if(m_data_map.size()==0) return nullptr;
+
+	int index = _id-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
+	{
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+		{
+			if(m_data_list.at(i).ID == _id)
+			{
+				return &amp;m_data_list.at(i);
+			}
+		}
+	}
+
+	return nullptr;
+}
+
 bool AisanSignalFileReader::ReadNextLine(AisanSignal&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
@@ -1020,6 +1535,66 @@ int AisanSignalFileReader::ReadAllData(vector&lt;AisanSignal&gt;&amp; data_list)
 	return count;
 }
 
+//Vector
+
+AisanVectorFileReader::AisanVectorFileReader(const vector_map_msgs::VectorArray&amp; _vectors) : SimpleReaderBase("d", 1)
+{
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
+
+	m_data_list.clear();
+	AisanVector data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _vectors.data.size(); i++)
+	{
+		ParseNextLine(_vectors.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.VID &lt; m_min_id)
+			m_min_id = data.VID;
+
+		if(data.VID &gt; max_id)
+			max_id = data.VID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).VID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanVectorFileReader::ParseNextLine(const vector_map_msgs::Vector&amp; _rec, AisanVector&amp; data)
+{
+	data.Hang = _rec.hang;
+	data.PID = _rec.pid;
+	data.VID = _rec.vid;
+	data.Vang = _rec.vang;
+}
+
+AisanVectorFileReader::AisanVector* AisanVectorFileReader::GetDataRowById(int _id)
+{
+	if(m_data_map.size()==0) return nullptr;
+
+	int index = _id-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
+	{
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+		{
+			if(m_data_list.at(i).VID == _id)
+			{
+				return &amp;m_data_list.at(i);
+			}
+		}
+	}
+
+	return nullptr;
+}
+
 bool AisanVectorFileReader::ReadNextLine(AisanVector&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
@@ -1054,6 +1629,68 @@ int AisanVectorFileReader::ReadAllData(vector&lt;AisanVector&gt;&amp; data_list)
 	return count;
 }
 
+//Curb
+
+AisanCurbFileReader::AisanCurbFileReader(const vector_map_msgs::CurbArray&amp; _curbs) : SimpleReaderBase("d", 1)
+{
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
+
+	m_data_list.clear();
+	AisanCurb data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _curbs.data.size(); i++)
+	{
+		ParseNextLine(_curbs.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.ID &lt; m_min_id)
+			m_min_id = data.ID;
+
+		if(data.ID &gt; max_id)
+			max_id = data.ID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).ID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanCurbFileReader::ParseNextLine(const vector_map_msgs::Curb&amp; _rec, AisanCurb&amp; data)
+{
+	data.Height = _rec.height;
+	data.ID = _rec.id;
+	data.LID = _rec.lid;
+	data.LinkID = _rec.linkid;
+	data.Width = _rec.width;
+	data.dir = _rec.dir;
+}
+
+AisanCurbFileReader::AisanCurb* AisanCurbFileReader::GetDataRowById(int _id)
+{
+	if(m_data_map.size()==0) return nullptr;
+
+	int index = _id-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
+	{
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+		{
+			if(m_data_list.at(i).ID == _id)
+			{
+				return &amp;m_data_list.at(i);
+			}
+		}
+	}
+
+	return nullptr;
+}
+
 bool AisanCurbFileReader::ReadNextLine(AisanCurb&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
@@ -1090,6 +1727,65 @@ int AisanCurbFileReader::ReadAllData(vector&lt;AisanCurb&gt;&amp; data_list)
 	return count;
 }
 
+// RoadEdge
+
+AisanRoadEdgeFileReader::AisanRoadEdgeFileReader(const vector_map_msgs::RoadEdgeArray&amp; _edges) : SimpleReaderBase("d", 1)
+{
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
+
+	m_data_list.clear();
+	AisanRoadEdge data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _edges.data.size(); i++)
+	{
+		ParseNextLine(_edges.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.ID &lt; m_min_id)
+			m_min_id = data.ID;
+
+		if(data.ID &gt; max_id)
+			max_id = data.ID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).ID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanRoadEdgeFileReader::ParseNextLine(const vector_map_msgs::RoadEdge&amp; _rec, AisanRoadEdge&amp; data)
+{
+	data.ID = _rec.id;
+	data.LID = _rec.lid;
+	data.LinkID = _rec.linkid;
+}
+
+AisanRoadEdgeFileReader::AisanRoadEdge* AisanRoadEdgeFileReader::GetDataRowById(int _id)
+{
+	if(m_data_map.size()==0) return nullptr;
+
+	int index = _id-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
+	{
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+		{
+			if(m_data_list.at(i).ID == _id)
+			{
+				return &amp;m_data_list.at(i);
+			}
+		}
+	}
+
+	return nullptr;
+}
+
 bool AisanRoadEdgeFileReader::ReadNextLine(AisanRoadEdge&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
@@ -1123,6 +1819,67 @@ int AisanRoadEdgeFileReader::ReadAllData(vector&lt;AisanRoadEdge&gt;&amp; data_list)
 	return count;
 }
 
+//CrossWalk
+
+AisanCrossWalkFileReader::AisanCrossWalkFileReader(const vector_map_msgs::CrossWalkArray&amp; _crossWalks) : SimpleReaderBase("d", 1)
+{
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
+
+	m_data_list.clear();
+	AisanCrossWalk data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _crossWalks.data.size(); i++)
+	{
+		ParseNextLine(_crossWalks.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.ID &lt; m_min_id)
+			m_min_id = data.ID;
+
+		if(data.ID &gt; max_id)
+			max_id = data.ID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).ID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanCrossWalkFileReader::ParseNextLine(const vector_map_msgs::CrossWalk&amp; _rec, AisanCrossWalk&amp; data)
+{
+	data.AID = _rec.aid;
+	data.BdID = _rec.bdid;
+	data.ID = _rec.id;
+	data.LinkID = _rec.linkid;
+	data.Type = _rec.type;
+}
+
+AisanCrossWalkFileReader::AisanCrossWalk* AisanCrossWalkFileReader::GetDataRowById(int _id)
+{
+	if(m_data_map.size()==0) return nullptr;
+
+	int index = _id-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
+	{
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+		{
+			if(m_data_list.at(i).ID == _id)
+			{
+				return &amp;m_data_list.at(i);
+			}
+		}
+	}
+
+	return nullptr;
+}
+
 bool AisanCrossWalkFileReader::ReadNextLine(AisanCrossWalk&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
@@ -1158,6 +1915,65 @@ int AisanCrossWalkFileReader::ReadAllData(vector&lt;AisanCrossWalk&gt;&amp; data_list)
 	return count;
 }
 
+//WayArea
+
+AisanWayareaFileReader::AisanWayareaFileReader(const vector_map_msgs::WayAreaArray&amp; _wayAreas) : SimpleReaderBase("d", 1)
+{
+	m_min_id = std::numeric_limits&lt;int&gt;::max();
+
+	m_data_list.clear();
+	AisanWayarea data;
+	int max_id = std::numeric_limits&lt;int&gt;::min();
+
+	for(unsigned int i=0; i &lt; _wayAreas.data.size(); i++)
+	{
+		ParseNextLine(_wayAreas.data.at(i), data);
+
+		m_data_list.push_back(data);
+		if(data.ID &lt; m_min_id)
+			m_min_id = data.ID;
+
+		if(data.ID &gt; max_id)
+			max_id = data.ID;
+	}
+
+	m_data_map.resize(max_id-m_min_id+2);
+	for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+	{
+		m_data_map.at(m_data_list.at(i).ID-m_min_id) = &amp;m_data_list.at(i);
+	}
+}
+
+void AisanWayareaFileReader::ParseNextLine(const vector_map_msgs::WayArea&amp; _rec, AisanWayarea&amp; data)
+{
+	data.AID = _rec.aid;
+	data.ID = _rec.waid;
+	//data.LinkID = _rec.;
+}
+
+AisanWayareaFileReader::AisanWayarea* AisanWayareaFileReader::GetDataRowById(int _id)
+{
+	if(m_data_map.size()==0) return nullptr;
+
+	int index = _id-m_min_id;
+	if(index &gt;= 0 &amp;&amp; index &lt; m_data_map.size())
+	{
+		return m_data_map.at(index);
+	}
+	else
+	{
+		for(unsigned int i=0; i &lt; m_data_list.size(); i++)
+		{
+			if(m_data_list.at(i).ID == _id)
+			{
+				return &amp;m_data_list.at(i);
+			}
+		}
+	}
+
+	return nullptr;
+}
+
 bool AisanWayareaFileReader::ReadNextLine(AisanWayarea&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
@@ -1191,6 +2007,7 @@ int AisanWayareaFileReader::ReadAllData(vector&lt;AisanWayarea&gt;&amp; data_list)
 	return count;
 }
 
+//Data Conn
 bool AisanDataConnFileReader::ReadNextLine(DataConn&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\include\op_global_planner_core.h" new_path="ros\src\computing\planning\mission\packages\op_global_planner\include\op_global_planner_core.h" added_lines="37" deleted_lines="0">
				<diff>@@ -172,6 +172,43 @@ private:
   	void SaveSimulationData();
   	int LoadSimulationData();
   	void ClearOldCostFromMap();
+
+
+  	//Mapping Section
+
+  	UtilityHNS::MapRaw m_MapRaw;
+
+	ros::Subscriber sub_lanes;
+	ros::Subscriber sub_points;
+	ros::Subscriber sub_dt_lanes;
+	ros::Subscriber sub_intersect;
+	ros::Subscriber sup_area;
+	ros::Subscriber sub_lines;
+	ros::Subscriber sub_stop_line;
+	ros::Subscriber sub_signals;
+	ros::Subscriber sub_vectors;
+	ros::Subscriber sub_curbs;
+	ros::Subscriber sub_edges;
+	ros::Subscriber sub_way_areas;
+	ros::Subscriber sub_cross_walk;
+	ros::Subscriber sub_nodes;
+
+
+	void callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg);
+	void callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg);
+	void callbackGetVMdtLanes(const vector_map_msgs::DTLaneArray&amp; msg);
+	void callbackGetVMIntersections(const vector_map_msgs::CrossRoadArray&amp; msg);
+	void callbackGetVMAreas(const vector_map_msgs::AreaArray&amp; msg);
+	void callbackGetVMLines(const vector_map_msgs::LineArray&amp; msg);
+	void callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg);
+	void callbackGetVMSignal(const vector_map_msgs::SignalArray&amp; msg);
+	void callbackGetVMVectors(const vector_map_msgs::VectorArray&amp; msg);
+	void callbackGetVMCurbs(const vector_map_msgs::CurbArray&amp; msg);
+	void callbackGetVMRoadEdges(const vector_map_msgs::RoadEdgeArray&amp; msg);
+	void callbackGetVMWayAreas(const vector_map_msgs::WayAreaArray&amp; msg);
+	void callbackGetVMCrossWalks(const vector_map_msgs::CrossWalkArray&amp; msg);
+	void callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg);
+
 };
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" added_lines="147" deleted_lines="0">
				<diff>@@ -99,6 +99,22 @@ GlobalPlanner::GlobalPlanner()
 	if(m_params.bEnableDynamicMapUpdate)
 	  sub_road_status_occupancy = nh.subscribe&lt;&gt;("/occupancy_road_status", 1, &amp;GlobalPlanner::callbackGetRoadStatusOccupancyGrid, this);
 
+	//Mapping Section
+	sub_lanes = nh.subscribe("/vector_map_info/lane", 1, &amp;GlobalPlanner::callbackGetVMLanes,  this);
+	sub_points = nh.subscribe("/vector_map_info/point", 1, &amp;GlobalPlanner::callbackGetVMPoints,  this);
+	sub_dt_lanes = nh.subscribe("/vector_map_info/dtlane", 1, &amp;GlobalPlanner::callbackGetVMdtLanes,  this);
+	sub_intersect = nh.subscribe("/vector_map_info/cross_road", 1, &amp;GlobalPlanner::callbackGetVMIntersections,  this);
+	sup_area = nh.subscribe("/vector_map_info/area", 1, &amp;GlobalPlanner::callbackGetVMAreas,  this);
+	sub_lines = nh.subscribe("/vector_map_info/line", 1, &amp;GlobalPlanner::callbackGetVMLines,  this);
+	sub_stop_line = nh.subscribe("/vector_map_info/stop_line", 1, &amp;GlobalPlanner::callbackGetVMStopLines,  this);
+	sub_signals = nh.subscribe("/vector_map_info/signal", 1, &amp;GlobalPlanner::callbackGetVMSignal,  this);
+	sub_vectors = nh.subscribe("/vector_map_info/vector", 1, &amp;GlobalPlanner::callbackGetVMVectors,  this);
+	sub_curbs = nh.subscribe("/vector_map_info/curb", 1, &amp;GlobalPlanner::callbackGetVMCurbs,  this);
+	sub_edges = nh.subscribe("/vector_map_info/road_edge", 1, &amp;GlobalPlanner::callbackGetVMRoadEdges,  this);
+	sub_way_areas = nh.subscribe("/vector_map_info/way_area", 1, &amp;GlobalPlanner::callbackGetVMWayAreas,  this);
+	sub_cross_walk = nh.subscribe("/vector_map_info/cross_walk", 1, &amp;GlobalPlanner::callbackGetVMCrossWalks,  this);
+	sub_nodes = nh.subscribe("/vector_map_info/node", 1, &amp;GlobalPlanner::callbackGetVMNodes,  this);
+
 }
 
 GlobalPlanner::~GlobalPlanner()
@@ -425,7 +441,37 @@ void GlobalPlanner::MainLoop()
 			PlannerHNS::RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
 
 			pub_MapRviz.publish(map_marker_array);
+		}
+		else if (m_params.mapSource == PlannerHNS::MAP_AUTOWARE &amp;&amp; !m_bKmlMap)
+		{
+			std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;;
+
+			if(m_MapRaw.GetVersion()==2)
+			{
+				m_bKmlMap = true;
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
+						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
+						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,
+						m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true);
+			}
+			else if(m_MapRaw.GetVersion()==1)
+			{
+				m_bKmlMap = true;
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
+						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
+						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true);
+			}
 
+			if(m_bKmlMap)
+			{
+				visualization_msgs::MarkerArray map_marker_array;
+				PlannerHNS::RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
+				pub_MapRviz.publish(map_marker_array);
+			}
 		}
 
 		ClearOldCostFromMap();
@@ -474,4 +520,105 @@ void GlobalPlanner::MainLoop()
 	}
 }
 
+
+//Mapping Section
+
+void GlobalPlanner::callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Lanes" &lt;&lt; endl;
+	if(m_MapRaw.pLanes == nullptr)
+		m_MapRaw.pLanes = new UtilityHNS::AisanLanesFileReader(msg);
+}
+
+void GlobalPlanner::callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Points" &lt;&lt; endl;
+	if(m_MapRaw.pPoints  == nullptr)
+		m_MapRaw.pPoints = new UtilityHNS::AisanPointsFileReader(msg);
+}
+
+void GlobalPlanner::callbackGetVMdtLanes(const vector_map_msgs::DTLaneArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received dtLanes" &lt;&lt; endl;
+	if(m_MapRaw.pCenterLines == nullptr)
+		m_MapRaw.pCenterLines = new UtilityHNS::AisanCenterLinesFileReader(msg);
+}
+
+void GlobalPlanner::callbackGetVMIntersections(const vector_map_msgs::CrossRoadArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received CrossRoads" &lt;&lt; endl;
+	if(m_MapRaw.pIntersections == nullptr)
+		m_MapRaw.pIntersections = new UtilityHNS::AisanIntersectionFileReader(msg);
+}
+
+void GlobalPlanner::callbackGetVMAreas(const vector_map_msgs::AreaArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Areas" &lt;&lt; endl;
+	if(m_MapRaw.pAreas == nullptr)
+		m_MapRaw.pAreas = new UtilityHNS::AisanAreasFileReader(msg);
+}
+
+void GlobalPlanner::callbackGetVMLines(const vector_map_msgs::LineArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Lines" &lt;&lt; endl;
+	if(m_MapRaw.pLines == nullptr)
+		m_MapRaw.pLines = new UtilityHNS::AisanLinesFileReader(msg);
+}
+
+void GlobalPlanner::callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received StopLines" &lt;&lt; endl;
+	if(m_MapRaw.pStopLines == nullptr)
+		m_MapRaw.pStopLines = new UtilityHNS::AisanStopLineFileReader(msg);
+}
+
+void GlobalPlanner::callbackGetVMSignal(const vector_map_msgs::SignalArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Signals" &lt;&lt; endl;
+	if(m_MapRaw.pSignals  == nullptr)
+		m_MapRaw.pSignals = new UtilityHNS::AisanSignalFileReader(msg);
+}
+
+void GlobalPlanner::callbackGetVMVectors(const vector_map_msgs::VectorArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Vectors" &lt;&lt; endl;
+	if(m_MapRaw.pVectors  == nullptr)
+		m_MapRaw.pVectors = new UtilityHNS::AisanVectorFileReader(msg);
+}
+
+void GlobalPlanner::callbackGetVMCurbs(const vector_map_msgs::CurbArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Curbs" &lt;&lt; endl;
+	if(m_MapRaw.pCurbs == nullptr)
+		m_MapRaw.pCurbs = new UtilityHNS::AisanCurbFileReader(msg);
+}
+
+void GlobalPlanner::callbackGetVMRoadEdges(const vector_map_msgs::RoadEdgeArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Edges" &lt;&lt; endl;
+	if(m_MapRaw.pRoadedges  == nullptr)
+		m_MapRaw.pRoadedges = new UtilityHNS::AisanRoadEdgeFileReader(msg);
+}
+
+void GlobalPlanner::callbackGetVMWayAreas(const vector_map_msgs::WayAreaArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Wayareas" &lt;&lt; endl;
+	if(m_MapRaw.pWayAreas  == nullptr)
+		m_MapRaw.pWayAreas = new UtilityHNS::AisanWayareaFileReader(msg);
+}
+
+void GlobalPlanner::callbackGetVMCrossWalks(const vector_map_msgs::CrossWalkArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received CrossWalks" &lt;&lt; endl;
+	if(m_MapRaw.pCrossWalks == nullptr)
+		m_MapRaw.pCrossWalks = new UtilityHNS::AisanCrossWalkFileReader(msg);
+}
+
+void GlobalPlanner::callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Nodes" &lt;&lt; endl;
+	if(m_MapRaw.pNodes == nullptr)
+		m_MapRaw.pNodes = new UtilityHNS::AisanNodesFileReader(msg);
+}
+
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_behavior_selector_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_behavior_selector_core.h" added_lines="47" deleted_lines="0">
				<diff>@@ -33,6 +33,17 @@
 
 #include &lt;ros/ros.h&gt;
 
+#include "vector_map_msgs/PointArray.h"
+#include "vector_map_msgs/LaneArray.h"
+#include "vector_map_msgs/NodeArray.h"
+#include "vector_map_msgs/StopLineArray.h"
+#include "vector_map_msgs/DTLaneArray.h"
+#include "vector_map_msgs/LineArray.h"
+#include "vector_map_msgs/AreaArray.h"
+#include "vector_map_msgs/SignalArray.h"
+#include "vector_map_msgs/StopLine.h"
+#include "vector_map_msgs/VectorArray.h"
+
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
@@ -51,6 +62,7 @@
 
 #include "op_planner/PlannerCommonDef.h"
 #include "op_planner/DecisionMaker.h"
+#include "op_utility/DataRW.h"
 
 
 namespace BehaviorGeneratorNS
@@ -155,6 +167,41 @@ public:
   BehaviorGen();
   ~BehaviorGen();
   void MainLoop();
+
+	//Mapping Section
+
+	UtilityHNS::MapRaw m_MapRaw;
+
+	ros::Subscriber sub_lanes;
+	ros::Subscriber sub_points;
+	ros::Subscriber sub_dt_lanes;
+	ros::Subscriber sub_intersect;
+	ros::Subscriber sup_area;
+	ros::Subscriber sub_lines;
+	ros::Subscriber sub_stop_line;
+	ros::Subscriber sub_signals;
+	ros::Subscriber sub_vectors;
+	ros::Subscriber sub_curbs;
+	ros::Subscriber sub_edges;
+	ros::Subscriber sub_way_areas;
+	ros::Subscriber sub_cross_walk;
+	ros::Subscriber sub_nodes;
+
+
+	void callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg);
+	void callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg);
+	void callbackGetVMdtLanes(const vector_map_msgs::DTLaneArray&amp; msg);
+	void callbackGetVMIntersections(const vector_map_msgs::CrossRoadArray&amp; msg);
+	void callbackGetVMAreas(const vector_map_msgs::AreaArray&amp; msg);
+	void callbackGetVMLines(const vector_map_msgs::LineArray&amp; msg);
+	void callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg);
+	void callbackGetVMSignal(const vector_map_msgs::SignalArray&amp; msg);
+	void callbackGetVMVectors(const vector_map_msgs::VectorArray&amp; msg);
+	void callbackGetVMCurbs(const vector_map_msgs::CurbArray&amp; msg);
+	void callbackGetVMRoadEdges(const vector_map_msgs::RoadEdgeArray&amp; msg);
+	void callbackGetVMWayAreas(const vector_map_msgs::WayAreaArray&amp; msg);
+	void callbackGetVMCrossWalks(const vector_map_msgs::CrossWalkArray&amp; msg);
+	void callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg);
 };
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_motion_predictor_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_motion_predictor_core.h" added_lines="47" deleted_lines="0">
				<diff>@@ -33,6 +33,17 @@
 
 #include &lt;ros/ros.h&gt;
 
+#include "vector_map_msgs/PointArray.h"
+#include "vector_map_msgs/LaneArray.h"
+#include "vector_map_msgs/NodeArray.h"
+#include "vector_map_msgs/StopLineArray.h"
+#include "vector_map_msgs/DTLaneArray.h"
+#include "vector_map_msgs/LineArray.h"
+#include "vector_map_msgs/AreaArray.h"
+#include "vector_map_msgs/SignalArray.h"
+#include "vector_map_msgs/StopLine.h"
+#include "vector_map_msgs/VectorArray.h"
+
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
@@ -46,6 +57,7 @@
 
 #include "op_planner/PlannerCommonDef.h"
 #include "op_planner/BehaviorPrediction.h"
+#include "op_utility/DataRW.h"
 
 namespace MotionPredictorNS
 {
@@ -129,6 +141,41 @@ public:
 	MotionPrediction();
 	virtual ~MotionPrediction();
 	void MainLoop();
+
+	//Mapping Section
+
+	UtilityHNS::MapRaw m_MapRaw;
+
+	ros::Subscriber sub_lanes;
+	ros::Subscriber sub_points;
+	ros::Subscriber sub_dt_lanes;
+	ros::Subscriber sub_intersect;
+	ros::Subscriber sup_area;
+	ros::Subscriber sub_lines;
+	ros::Subscriber sub_stop_line;
+	ros::Subscriber sub_signals;
+	ros::Subscriber sub_vectors;
+	ros::Subscriber sub_curbs;
+	ros::Subscriber sub_edges;
+	ros::Subscriber sub_way_areas;
+	ros::Subscriber sub_cross_walk;
+	ros::Subscriber sub_nodes;
+
+
+	void callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg);
+	void callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg);
+	void callbackGetVMdtLanes(const vector_map_msgs::DTLaneArray&amp; msg);
+	void callbackGetVMIntersections(const vector_map_msgs::CrossRoadArray&amp; msg);
+	void callbackGetVMAreas(const vector_map_msgs::AreaArray&amp; msg);
+	void callbackGetVMLines(const vector_map_msgs::LineArray&amp; msg);
+	void callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg);
+	void callbackGetVMSignal(const vector_map_msgs::SignalArray&amp; msg);
+	void callbackGetVMVectors(const vector_map_msgs::VectorArray&amp; msg);
+	void callbackGetVMCurbs(const vector_map_msgs::CurbArray&amp; msg);
+	void callbackGetVMRoadEdges(const vector_map_msgs::RoadEdgeArray&amp; msg);
+	void callbackGetVMWayAreas(const vector_map_msgs::WayAreaArray&amp; msg);
+	void callbackGetVMCrossWalks(const vector_map_msgs::CrossWalkArray&amp; msg);
+	void callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg);
 };
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector_core.cpp" added_lines="149" deleted_lines="0">
				<diff>@@ -82,6 +82,22 @@ BehaviorGen::BehaviorGen()
 	sub_twist_raw = nh.subscribe("/twist_raw", 1, &amp;BehaviorGen::callbackGetTwistRaw, this);
 	sub_twist_cmd = nh.subscribe("/twist_cmd", 1, &amp;BehaviorGen::callbackGetTwistCMD, this);
 	//sub_ctrl_cmd = nh.subscribe("/ctrl_cmd", 1, &amp;BehaviorGen::callbackGetCommandCMD, this);
+
+	//Mapping Section
+	sub_lanes = nh.subscribe("/vector_map_info/lane", 1, &amp;BehaviorGen::callbackGetVMLanes,  this);
+	sub_points = nh.subscribe("/vector_map_info/point", 1, &amp;BehaviorGen::callbackGetVMPoints,  this);
+	sub_dt_lanes = nh.subscribe("/vector_map_info/dtlane", 1, &amp;BehaviorGen::callbackGetVMdtLanes,  this);
+	sub_intersect = nh.subscribe("/vector_map_info/cross_road", 1, &amp;BehaviorGen::callbackGetVMIntersections,  this);
+	sup_area = nh.subscribe("/vector_map_info/area", 1, &amp;BehaviorGen::callbackGetVMAreas,  this);
+	sub_lines = nh.subscribe("/vector_map_info/line", 1, &amp;BehaviorGen::callbackGetVMLines,  this);
+	sub_stop_line = nh.subscribe("/vector_map_info/stop_line", 1, &amp;BehaviorGen::callbackGetVMStopLines,  this);
+	sub_signals = nh.subscribe("/vector_map_info/signal", 1, &amp;BehaviorGen::callbackGetVMSignal,  this);
+	sub_vectors = nh.subscribe("/vector_map_info/vector", 1, &amp;BehaviorGen::callbackGetVMVectors,  this);
+	sub_curbs = nh.subscribe("/vector_map_info/curb", 1, &amp;BehaviorGen::callbackGetVMCurbs,  this);
+	sub_edges = nh.subscribe("/vector_map_info/road_edge", 1, &amp;BehaviorGen::callbackGetVMRoadEdges,  this);
+	sub_way_areas = nh.subscribe("/vector_map_info/way_area", 1, &amp;BehaviorGen::callbackGetVMWayAreas,  this);
+	sub_cross_walk = nh.subscribe("/vector_map_info/cross_walk", 1, &amp;BehaviorGen::callbackGetVMCrossWalks,  this);
+	sub_nodes = nh.subscribe("/vector_map_info/node", 1, &amp;BehaviorGen::callbackGetVMNodes,  this);
 }
 
 BehaviorGen::~BehaviorGen()
@@ -545,6 +561,40 @@ void BehaviorGen::MainLoop()
 			PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_MapPath, m_Map, true);
 
 		}
+		else if (m_MapType == PlannerHNS::MAP_AUTOWARE &amp;&amp; !bMap)
+		{
+			std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;;
+
+			if(m_MapRaw.GetVersion()==2)
+			{
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
+						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
+						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,
+						m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true);
+
+				if(m_Map.roadSegments.size() &gt; 0)
+				{
+					bMap = true;
+					std::cout &lt;&lt; " ******* Map V2 Is Loaded successfully from the Behavior Selector !! " &lt;&lt; std::endl;
+				}
+			}
+			else if(m_MapRaw.GetVersion()==1)
+			{
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
+						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
+						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true);
+
+				if(m_Map.roadSegments.size() &gt; 0)
+				{
+					bMap = true;
+					std::cout &lt;&lt; " ******* Map V1 Is Loaded successfully from the Behavior Selector !! " &lt;&lt; std::endl;
+				}
+			}
+		}
 
 		if(bNewCurrentPos &amp;&amp; m_GlobalPaths.size()&gt;0)
 		{
@@ -574,4 +624,103 @@ void BehaviorGen::MainLoop()
 	}
 }
 
+//Mapping Section
+
+void BehaviorGen::callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Lanes" &lt;&lt; endl;
+	if(m_MapRaw.pLanes == nullptr)
+		m_MapRaw.pLanes = new UtilityHNS::AisanLanesFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Points" &lt;&lt; endl;
+	if(m_MapRaw.pPoints  == nullptr)
+		m_MapRaw.pPoints = new UtilityHNS::AisanPointsFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMdtLanes(const vector_map_msgs::DTLaneArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received dtLanes" &lt;&lt; endl;
+	if(m_MapRaw.pCenterLines == nullptr)
+		m_MapRaw.pCenterLines = new UtilityHNS::AisanCenterLinesFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMIntersections(const vector_map_msgs::CrossRoadArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received CrossRoads" &lt;&lt; endl;
+	if(m_MapRaw.pIntersections == nullptr)
+		m_MapRaw.pIntersections = new UtilityHNS::AisanIntersectionFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMAreas(const vector_map_msgs::AreaArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Areas" &lt;&lt; endl;
+	if(m_MapRaw.pAreas == nullptr)
+		m_MapRaw.pAreas = new UtilityHNS::AisanAreasFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMLines(const vector_map_msgs::LineArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Lines" &lt;&lt; endl;
+	if(m_MapRaw.pLines == nullptr)
+		m_MapRaw.pLines = new UtilityHNS::AisanLinesFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received StopLines" &lt;&lt; endl;
+	if(m_MapRaw.pStopLines == nullptr)
+		m_MapRaw.pStopLines = new UtilityHNS::AisanStopLineFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMSignal(const vector_map_msgs::SignalArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Signals" &lt;&lt; endl;
+	if(m_MapRaw.pSignals  == nullptr)
+		m_MapRaw.pSignals = new UtilityHNS::AisanSignalFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMVectors(const vector_map_msgs::VectorArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Vectors" &lt;&lt; endl;
+	if(m_MapRaw.pVectors  == nullptr)
+		m_MapRaw.pVectors = new UtilityHNS::AisanVectorFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMCurbs(const vector_map_msgs::CurbArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Curbs" &lt;&lt; endl;
+	if(m_MapRaw.pCurbs == nullptr)
+		m_MapRaw.pCurbs = new UtilityHNS::AisanCurbFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMRoadEdges(const vector_map_msgs::RoadEdgeArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Edges" &lt;&lt; endl;
+	if(m_MapRaw.pRoadedges  == nullptr)
+		m_MapRaw.pRoadedges = new UtilityHNS::AisanRoadEdgeFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMWayAreas(const vector_map_msgs::WayAreaArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Wayareas" &lt;&lt; endl;
+	if(m_MapRaw.pWayAreas  == nullptr)
+		m_MapRaw.pWayAreas = new UtilityHNS::AisanWayareaFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMCrossWalks(const vector_map_msgs::CrossWalkArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received CrossWalks" &lt;&lt; endl;
+	if(m_MapRaw.pCrossWalks == nullptr)
+		m_MapRaw.pCrossWalks = new UtilityHNS::AisanCrossWalkFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Nodes" &lt;&lt; endl;
+	if(m_MapRaw.pNodes == nullptr)
+		m_MapRaw.pNodes = new UtilityHNS::AisanNodesFileReader(msg);
+}
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor_core.cpp" added_lines="150" deleted_lines="0">
				<diff>@@ -78,6 +78,22 @@ MotionPrediction::MotionPrediction()
 	PlannerHNS::RosHelpers::InitCurbsMarkers(100, m_CurbsDummy);
 	PlannerHNS::RosHelpers::InitPredParticlesMarkers(500, m_PredictedParticlesDummy);
 
+	//Mapping Section
+	sub_lanes = nh.subscribe("/vector_map_info/lane", 1, &amp;MotionPrediction::callbackGetVMLanes,  this);
+	sub_points = nh.subscribe("/vector_map_info/point", 1, &amp;MotionPrediction::callbackGetVMPoints,  this);
+	sub_dt_lanes = nh.subscribe("/vector_map_info/dtlane", 1, &amp;MotionPrediction::callbackGetVMdtLanes,  this);
+	sub_intersect = nh.subscribe("/vector_map_info/cross_road", 1, &amp;MotionPrediction::callbackGetVMIntersections,  this);
+	sup_area = nh.subscribe("/vector_map_info/area", 1, &amp;MotionPrediction::callbackGetVMAreas,  this);
+	sub_lines = nh.subscribe("/vector_map_info/line", 1, &amp;MotionPrediction::callbackGetVMLines,  this);
+	sub_stop_line = nh.subscribe("/vector_map_info/stop_line", 1, &amp;MotionPrediction::callbackGetVMStopLines,  this);
+	sub_signals = nh.subscribe("/vector_map_info/signal", 1, &amp;MotionPrediction::callbackGetVMSignal,  this);
+	sub_vectors = nh.subscribe("/vector_map_info/vector", 1, &amp;MotionPrediction::callbackGetVMVectors,  this);
+	sub_curbs = nh.subscribe("/vector_map_info/curb", 1, &amp;MotionPrediction::callbackGetVMCurbs,  this);
+	sub_edges = nh.subscribe("/vector_map_info/road_edge", 1, &amp;MotionPrediction::callbackGetVMRoadEdges,  this);
+	sub_way_areas = nh.subscribe("/vector_map_info/way_area", 1, &amp;MotionPrediction::callbackGetVMWayAreas,  this);
+	sub_cross_walk = nh.subscribe("/vector_map_info/cross_walk", 1, &amp;MotionPrediction::callbackGetVMCrossWalks,  this);
+	sub_nodes = nh.subscribe("/vector_map_info/node", 1, &amp;MotionPrediction::callbackGetVMNodes,  this);
+
 	std::cout &lt;&lt; "OpenPlanner Motion Predictor initialized successfully " &lt;&lt; std::endl;
 }
 
@@ -411,6 +427,40 @@ void MotionPrediction::MainLoop()
 			bMap = true;
 			PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_MapPath, m_Map, true);
 		}
+		else if (m_MapType == PlannerHNS::MAP_AUTOWARE &amp;&amp; !bMap)
+		{
+			std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;;
+
+			if(m_MapRaw.GetVersion()==2)
+			{
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
+						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
+						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,
+						m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true);
+
+				if(m_Map.roadSegments.size() &gt; 0)
+				{
+					bMap = true;
+					std::cout &lt;&lt; " ******* Map V2 Is Loaded successfully from the Motion Predictor !! " &lt;&lt; std::endl;
+				}
+			}
+			else if(m_MapRaw.GetVersion()==1)
+			{
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
+						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
+						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true);
+
+				if(m_Map.roadSegments.size() &gt; 0)
+				{
+					bMap = true;
+					std::cout &lt;&lt; " ******* Map V1 Is Loaded successfully from the Motion Predictor !! " &lt;&lt; std::endl;
+				}
+			}
+		}
 
 		if(UtilityHNS::UtilityH::GetTimeDiffNow(m_VisualizationTimer) &gt; m_VisualizationTime)
 		{
@@ -430,4 +480,104 @@ void MotionPrediction::MainLoop()
 	}
 }
 
+//Mapping Section
+
+void MotionPrediction::callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Lanes" &lt;&lt; endl;
+	if(m_MapRaw.pLanes == nullptr)
+		m_MapRaw.pLanes = new UtilityHNS::AisanLanesFileReader(msg);
+}
+
+void MotionPrediction::callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Points" &lt;&lt; endl;
+	if(m_MapRaw.pPoints  == nullptr)
+		m_MapRaw.pPoints = new UtilityHNS::AisanPointsFileReader(msg);
+}
+
+void MotionPrediction::callbackGetVMdtLanes(const vector_map_msgs::DTLaneArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received dtLanes" &lt;&lt; endl;
+	if(m_MapRaw.pCenterLines == nullptr)
+		m_MapRaw.pCenterLines = new UtilityHNS::AisanCenterLinesFileReader(msg);
+}
+
+void MotionPrediction::callbackGetVMIntersections(const vector_map_msgs::CrossRoadArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received CrossRoads" &lt;&lt; endl;
+	if(m_MapRaw.pIntersections == nullptr)
+		m_MapRaw.pIntersections = new UtilityHNS::AisanIntersectionFileReader(msg);
+}
+
+void MotionPrediction::callbackGetVMAreas(const vector_map_msgs::AreaArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Areas" &lt;&lt; endl;
+	if(m_MapRaw.pAreas == nullptr)
+		m_MapRaw.pAreas = new UtilityHNS::AisanAreasFileReader(msg);
+}
+
+void MotionPrediction::callbackGetVMLines(const vector_map_msgs::LineArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Lines" &lt;&lt; endl;
+	if(m_MapRaw.pLines == nullptr)
+		m_MapRaw.pLines = new UtilityHNS::AisanLinesFileReader(msg);
+}
+
+void MotionPrediction::callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received StopLines" &lt;&lt; endl;
+	if(m_MapRaw.pStopLines == nullptr)
+		m_MapRaw.pStopLines = new UtilityHNS::AisanStopLineFileReader(msg);
+}
+
+void MotionPrediction::callbackGetVMSignal(const vector_map_msgs::SignalArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Signals" &lt;&lt; endl;
+	if(m_MapRaw.pSignals  == nullptr)
+		m_MapRaw.pSignals = new UtilityHNS::AisanSignalFileReader(msg);
+}
+
+void MotionPrediction::callbackGetVMVectors(const vector_map_msgs::VectorArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Vectors" &lt;&lt; endl;
+	if(m_MapRaw.pVectors  == nullptr)
+		m_MapRaw.pVectors = new UtilityHNS::AisanVectorFileReader(msg);
+}
+
+void MotionPrediction::callbackGetVMCurbs(const vector_map_msgs::CurbArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Curbs" &lt;&lt; endl;
+	if(m_MapRaw.pCurbs == nullptr)
+		m_MapRaw.pCurbs = new UtilityHNS::AisanCurbFileReader(msg);
+}
+
+void MotionPrediction::callbackGetVMRoadEdges(const vector_map_msgs::RoadEdgeArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Edges" &lt;&lt; endl;
+	if(m_MapRaw.pRoadedges  == nullptr)
+		m_MapRaw.pRoadedges = new UtilityHNS::AisanRoadEdgeFileReader(msg);
+}
+
+void MotionPrediction::callbackGetVMWayAreas(const vector_map_msgs::WayAreaArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Wayareas" &lt;&lt; endl;
+	if(m_MapRaw.pWayAreas  == nullptr)
+		m_MapRaw.pWayAreas = new UtilityHNS::AisanWayareaFileReader(msg);
+}
+
+void MotionPrediction::callbackGetVMCrossWalks(const vector_map_msgs::CrossWalkArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received CrossWalks" &lt;&lt; endl;
+	if(m_MapRaw.pCrossWalks == nullptr)
+		m_MapRaw.pCrossWalks = new UtilityHNS::AisanCrossWalkFileReader(msg);
+}
+
+void MotionPrediction::callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Nodes" &lt;&lt; endl;
+	if(m_MapRaw.pNodes == nullptr)
+		m_MapRaw.pNodes = new UtilityHNS::AisanNodesFileReader(msg);
+}
+
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_car_simulator_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_car_simulator_core.h" added_lines="48" deleted_lines="0">
				<diff>@@ -33,6 +33,17 @@
 
 #include &lt;ros/ros.h&gt;
 
+#include "vector_map_msgs/PointArray.h"
+#include "vector_map_msgs/LaneArray.h"
+#include "vector_map_msgs/NodeArray.h"
+#include "vector_map_msgs/StopLineArray.h"
+#include "vector_map_msgs/DTLaneArray.h"
+#include "vector_map_msgs/LineArray.h"
+#include "vector_map_msgs/AreaArray.h"
+#include "vector_map_msgs/SignalArray.h"
+#include "vector_map_msgs/StopLine.h"
+#include "vector_map_msgs/VectorArray.h"
+
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
@@ -59,6 +70,7 @@
 
 #include "op_simu/SimpleTracker.h"
 #include "op_planner/SimuDecisionMaker.h"
+#include "op_utility/DataRW.h"
 
 
 namespace CarSimulatorNS
@@ -192,6 +204,42 @@ public:
   int LoadSimulationData(PlannerHNS::WayPoint&amp; start_p, PlannerHNS::WayPoint&amp; goal_p);
   void InitializeSimuCar(PlannerHNS::WayPoint start_pose);
   void PublishSpecialTF(const PlannerHNS::WayPoint&amp; pose);
+
+
+	//Mapping Section
+
+	UtilityHNS::MapRaw m_MapRaw;
+
+	ros::Subscriber sub_lanes;
+	ros::Subscriber sub_points;
+	ros::Subscriber sub_dt_lanes;
+	ros::Subscriber sub_intersect;
+	ros::Subscriber sup_area;
+	ros::Subscriber sub_lines;
+	ros::Subscriber sub_stop_line;
+	ros::Subscriber sub_signals;
+	ros::Subscriber sub_vectors;
+	ros::Subscriber sub_curbs;
+	ros::Subscriber sub_edges;
+	ros::Subscriber sub_way_areas;
+	ros::Subscriber sub_cross_walk;
+	ros::Subscriber sub_nodes;
+
+
+	void callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg);
+	void callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg);
+	void callbackGetVMdtLanes(const vector_map_msgs::DTLaneArray&amp; msg);
+	void callbackGetVMIntersections(const vector_map_msgs::CrossRoadArray&amp; msg);
+	void callbackGetVMAreas(const vector_map_msgs::AreaArray&amp; msg);
+	void callbackGetVMLines(const vector_map_msgs::LineArray&amp; msg);
+	void callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg);
+	void callbackGetVMSignal(const vector_map_msgs::SignalArray&amp; msg);
+	void callbackGetVMVectors(const vector_map_msgs::VectorArray&amp; msg);
+	void callbackGetVMCurbs(const vector_map_msgs::CurbArray&amp; msg);
+	void callbackGetVMRoadEdges(const vector_map_msgs::RoadEdgeArray&amp; msg);
+	void callbackGetVMWayAreas(const vector_map_msgs::WayAreaArray&amp; msg);
+	void callbackGetVMCrossWalks(const vector_map_msgs::CrossWalkArray&amp; msg);
+	void callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg);
 };
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_signs_simulator_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_signs_simulator_core.h" added_lines="47" deleted_lines="1">
				<diff>@@ -31,10 +31,20 @@
 #ifndef OP_SIGNS_SIMULATOR
 #define OP_SIGNS_SIMULATOR
 
-// ROS includes
 #include &lt;ros/ros.h&gt;
 //#include &lt;runtime_manager/traffic_light.h&gt;
 
+#include "vector_map_msgs/PointArray.h"
+#include "vector_map_msgs/LaneArray.h"
+#include "vector_map_msgs/NodeArray.h"
+#include "vector_map_msgs/StopLineArray.h"
+#include "vector_map_msgs/DTLaneArray.h"
+#include "vector_map_msgs/LineArray.h"
+#include "vector_map_msgs/AreaArray.h"
+#include "vector_map_msgs/SignalArray.h"
+#include "vector_map_msgs/StopLine.h"
+#include "vector_map_msgs/VectorArray.h"
+
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
@@ -54,6 +64,7 @@
 #include &lt;op_planner/RoadNetwork.h&gt;
 #include &lt;op_planner/MappingHelpers.h&gt;
 #include "op_planner/PlannerCommonDef.h"
+#include "op_utility/DataRW.h"
 
 
 namespace SignsSimulatorNS
@@ -126,6 +137,41 @@ public:
 	OpenPlannerSimulatorSigns();
 	virtual ~OpenPlannerSimulatorSigns();
 	void MainLoop();
+
+	//Mapping Section
+
+	UtilityHNS::MapRaw m_MapRaw;
+
+	ros::Subscriber sub_lanes;
+	ros::Subscriber sub_points;
+	ros::Subscriber sub_dt_lanes;
+	ros::Subscriber sub_intersect;
+	ros::Subscriber sup_area;
+	ros::Subscriber sub_lines;
+	ros::Subscriber sub_stop_line;
+	ros::Subscriber sub_signals;
+	ros::Subscriber sub_vectors;
+	ros::Subscriber sub_curbs;
+	ros::Subscriber sub_edges;
+	ros::Subscriber sub_way_areas;
+	ros::Subscriber sub_cross_walk;
+	ros::Subscriber sub_nodes;
+
+
+	void callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg);
+	void callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg);
+	void callbackGetVMdtLanes(const vector_map_msgs::DTLaneArray&amp; msg);
+	void callbackGetVMIntersections(const vector_map_msgs::CrossRoadArray&amp; msg);
+	void callbackGetVMAreas(const vector_map_msgs::AreaArray&amp; msg);
+	void callbackGetVMLines(const vector_map_msgs::LineArray&amp; msg);
+	void callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg);
+	void callbackGetVMSignal(const vector_map_msgs::SignalArray&amp; msg);
+	void callbackGetVMVectors(const vector_map_msgs::VectorArray&amp; msg);
+	void callbackGetVMCurbs(const vector_map_msgs::CurbArray&amp; msg);
+	void callbackGetVMRoadEdges(const vector_map_msgs::RoadEdgeArray&amp; msg);
+	void callbackGetVMWayAreas(const vector_map_msgs::WayAreaArray&amp; msg);
+	void callbackGetVMCrossWalks(const vector_map_msgs::CrossWalkArray&amp; msg);
+	void callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg);
 };
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator_core.cpp" added_lines="153" deleted_lines="1">
				<diff>@@ -151,6 +151,22 @@ OpenPlannerCarSimulator::OpenPlannerCarSimulator()
 		sub_cloud_clusters 		= nh.subscribe("/cloud_clusters", 1, &amp;OpenPlannerCarSimulator::callbackGetCloudClusters, this);
 	}
 
+	//Mapping Section
+	sub_lanes = nh.subscribe("/vector_map_info/lane", 1, &amp;OpenPlannerCarSimulator::callbackGetVMLanes,  this);
+	sub_points = nh.subscribe("/vector_map_info/point", 1, &amp;OpenPlannerCarSimulator::callbackGetVMPoints,  this);
+	sub_dt_lanes = nh.subscribe("/vector_map_info/dtlane", 1, &amp;OpenPlannerCarSimulator::callbackGetVMdtLanes,  this);
+	sub_intersect = nh.subscribe("/vector_map_info/cross_road", 1, &amp;OpenPlannerCarSimulator::callbackGetVMIntersections,  this);
+	sup_area = nh.subscribe("/vector_map_info/area", 1, &amp;OpenPlannerCarSimulator::callbackGetVMAreas,  this);
+	sub_lines = nh.subscribe("/vector_map_info/line", 1, &amp;OpenPlannerCarSimulator::callbackGetVMLines,  this);
+	sub_stop_line = nh.subscribe("/vector_map_info/stop_line", 1, &amp;OpenPlannerCarSimulator::callbackGetVMStopLines,  this);
+	sub_signals = nh.subscribe("/vector_map_info/signal", 1, &amp;OpenPlannerCarSimulator::callbackGetVMSignal,  this);
+	sub_vectors = nh.subscribe("/vector_map_info/vector", 1, &amp;OpenPlannerCarSimulator::callbackGetVMVectors,  this);
+	sub_curbs = nh.subscribe("/vector_map_info/curb", 1, &amp;OpenPlannerCarSimulator::callbackGetVMCurbs,  this);
+	sub_edges = nh.subscribe("/vector_map_info/road_edge", 1, &amp;OpenPlannerCarSimulator::callbackGetVMRoadEdges,  this);
+	sub_way_areas = nh.subscribe("/vector_map_info/way_area", 1, &amp;OpenPlannerCarSimulator::callbackGetVMWayAreas,  this);
+	sub_cross_walk = nh.subscribe("/vector_map_info/cross_walk", 1, &amp;OpenPlannerCarSimulator::callbackGetVMCrossWalks,  this);
+	sub_nodes = nh.subscribe("/vector_map_info/node", 1, &amp;OpenPlannerCarSimulator::callbackGetVMNodes,  this);
+
 	UtilityHNS::UtilityH::GetTickCount(m_PlanningTimer);
 	std::cout &lt;&lt; "OpenPlannerCarSimulator initialized successfully " &lt;&lt; std::endl;
 }
@@ -227,8 +243,10 @@ void OpenPlannerCarSimulator::ReadParamFromLaunchFile(PlannerHNS::CAR_BASIC_INFO
 	int iSource = 0;
 	_nh.getParam("mapSource" 			, iSource);
 	if(iSource == 0)
-		m_SimParams.mapSource = MAP_FOLDER;
+		m_SimParams.mapSource = MAP_AUTOWARE;
 	else if(iSource == 1)
+		m_SimParams.mapSource = MAP_FOLDER;
+	else if(iSource == 2)
 		m_SimParams.mapSource = MAP_KML_FILE;
 
 	_nh.getParam("mapFileName" 		, m_SimParams.KmlMapPath);
@@ -786,6 +804,40 @@ void OpenPlannerCarSimulator::MainLoop()
 			PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_SimParams.KmlMapPath, m_Map, true);
 			InitializeSimuCar(m_SimParams.startPose);
 		}
+		else if (m_SimParams.mapSource == PlannerHNS::MAP_AUTOWARE &amp;&amp; !m_bMap)
+		{
+			std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;;
+
+			if(m_MapRaw.GetVersion()==2)
+			{
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
+						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
+						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,
+						m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true);
+
+				if(m_Map.roadSegments.size() &gt; 0)
+				{
+					m_bMap = true;
+					std::cout &lt;&lt; " ******* Map V2 Is Loaded successfully from the Behavior Selector !! " &lt;&lt; std::endl;
+				}
+			}
+			else if(m_MapRaw.GetVersion()==1)
+			{
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
+						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
+						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true);
+
+				if(m_Map.roadSegments.size() &gt; 0)
+				{
+					m_bMap = true;
+					std::cout &lt;&lt; " ******* Map V1 Is Loaded successfully from the Behavior Selector !! " &lt;&lt; std::endl;
+				}
+			}
+		}
 
 		if(m_bMap &amp;&amp; bInitPos &amp;&amp; bGoalPos)
 		{
@@ -967,4 +1019,104 @@ void OpenPlannerCarSimulator::MainLoop()
 	}
 }
 
+//Mapping Section
+
+void OpenPlannerCarSimulator::callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Lanes" &lt;&lt; endl;
+	if(m_MapRaw.pLanes == nullptr)
+		m_MapRaw.pLanes = new UtilityHNS::AisanLanesFileReader(msg);
+}
+
+void OpenPlannerCarSimulator::callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Points" &lt;&lt; endl;
+	if(m_MapRaw.pPoints  == nullptr)
+		m_MapRaw.pPoints = new UtilityHNS::AisanPointsFileReader(msg);
+}
+
+void OpenPlannerCarSimulator::callbackGetVMdtLanes(const vector_map_msgs::DTLaneArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received dtLanes" &lt;&lt; endl;
+	if(m_MapRaw.pCenterLines == nullptr)
+		m_MapRaw.pCenterLines = new UtilityHNS::AisanCenterLinesFileReader(msg);
+}
+
+void OpenPlannerCarSimulator::callbackGetVMIntersections(const vector_map_msgs::CrossRoadArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received CrossRoads" &lt;&lt; endl;
+	if(m_MapRaw.pIntersections == nullptr)
+		m_MapRaw.pIntersections = new UtilityHNS::AisanIntersectionFileReader(msg);
+}
+
+void OpenPlannerCarSimulator::callbackGetVMAreas(const vector_map_msgs::AreaArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Areas" &lt;&lt; endl;
+	if(m_MapRaw.pAreas == nullptr)
+		m_MapRaw.pAreas = new UtilityHNS::AisanAreasFileReader(msg);
+}
+
+void OpenPlannerCarSimulator::callbackGetVMLines(const vector_map_msgs::LineArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Lines" &lt;&lt; endl;
+	if(m_MapRaw.pLines == nullptr)
+		m_MapRaw.pLines = new UtilityHNS::AisanLinesFileReader(msg);
+}
+
+void OpenPlannerCarSimulator::callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received StopLines" &lt;&lt; endl;
+	if(m_MapRaw.pStopLines == nullptr)
+		m_MapRaw.pStopLines = new UtilityHNS::AisanStopLineFileReader(msg);
+}
+
+void OpenPlannerCarSimulator::callbackGetVMSignal(const vector_map_msgs::SignalArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Signals" &lt;&lt; endl;
+	if(m_MapRaw.pSignals  == nullptr)
+		m_MapRaw.pSignals = new UtilityHNS::AisanSignalFileReader(msg);
+}
+
+void OpenPlannerCarSimulator::callbackGetVMVectors(const vector_map_msgs::VectorArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Vectors" &lt;&lt; endl;
+	if(m_MapRaw.pVectors  == nullptr)
+		m_MapRaw.pVectors = new UtilityHNS::AisanVectorFileReader(msg);
+}
+
+void OpenPlannerCarSimulator::callbackGetVMCurbs(const vector_map_msgs::CurbArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Curbs" &lt;&lt; endl;
+	if(m_MapRaw.pCurbs == nullptr)
+		m_MapRaw.pCurbs = new UtilityHNS::AisanCurbFileReader(msg);
+}
+
+void OpenPlannerCarSimulator::callbackGetVMRoadEdges(const vector_map_msgs::RoadEdgeArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Edges" &lt;&lt; endl;
+	if(m_MapRaw.pRoadedges  == nullptr)
+		m_MapRaw.pRoadedges = new UtilityHNS::AisanRoadEdgeFileReader(msg);
+}
+
+void OpenPlannerCarSimulator::callbackGetVMWayAreas(const vector_map_msgs::WayAreaArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Wayareas" &lt;&lt; endl;
+	if(m_MapRaw.pWayAreas  == nullptr)
+		m_MapRaw.pWayAreas = new UtilityHNS::AisanWayareaFileReader(msg);
+}
+
+void OpenPlannerCarSimulator::callbackGetVMCrossWalks(const vector_map_msgs::CrossWalkArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received CrossWalks" &lt;&lt; endl;
+	if(m_MapRaw.pCrossWalks == nullptr)
+		m_MapRaw.pCrossWalks = new UtilityHNS::AisanCrossWalkFileReader(msg);
+}
+
+void OpenPlannerCarSimulator::callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Nodes" &lt;&lt; endl;
+	if(m_MapRaw.pNodes == nullptr)
+		m_MapRaw.pNodes = new UtilityHNS::AisanNodesFileReader(msg);
+}
+
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_signs_simulator\op_signs_simulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_signs_simulator\op_signs_simulator_core.cpp" added_lines="154" deleted_lines="1">
				<diff>@@ -56,8 +56,10 @@ OpenPlannerSimulatorSigns::OpenPlannerSimulatorSigns()
 	int iSource = 0;
 	_nh.getParam("mapSource" , iSource);
 	if(iSource == 0)
-		m_MapType = PlannerHNS::MAP_FOLDER;
+		m_MapType = PlannerHNS::MAP_AUTOWARE;
 	else if(iSource == 1)
+		m_MapType = PlannerHNS::MAP_FOLDER;
+	else if(iSource == 2)
 		m_MapType = PlannerHNS::MAP_KML_FILE;
 
 	_nh.getParam("mapFileName" , m_MapPath);
@@ -89,6 +91,23 @@ OpenPlannerSimulatorSigns::OpenPlannerSimulatorSigns()
 	UtilityHNS::UtilityH::GetTickCount(m_Timer);
 	m_CurrLightState = PlannerHNS::GREEN_LIGHT;
 
+
+	//Mapping Section
+	sub_lanes = nh.subscribe("/vector_map_info/lane", 1, &amp;OpenPlannerSimulatorSigns::callbackGetVMLanes,  this);
+	sub_points = nh.subscribe("/vector_map_info/point", 1, &amp;OpenPlannerSimulatorSigns::callbackGetVMPoints,  this);
+	sub_dt_lanes = nh.subscribe("/vector_map_info/dtlane", 1, &amp;OpenPlannerSimulatorSigns::callbackGetVMdtLanes,  this);
+	sub_intersect = nh.subscribe("/vector_map_info/cross_road", 1, &amp;OpenPlannerSimulatorSigns::callbackGetVMIntersections,  this);
+	sup_area = nh.subscribe("/vector_map_info/area", 1, &amp;OpenPlannerSimulatorSigns::callbackGetVMAreas,  this);
+	sub_lines = nh.subscribe("/vector_map_info/line", 1, &amp;OpenPlannerSimulatorSigns::callbackGetVMLines,  this);
+	sub_stop_line = nh.subscribe("/vector_map_info/stop_line", 1, &amp;OpenPlannerSimulatorSigns::callbackGetVMStopLines,  this);
+	sub_signals = nh.subscribe("/vector_map_info/signal", 1, &amp;OpenPlannerSimulatorSigns::callbackGetVMSignal,  this);
+	sub_vectors = nh.subscribe("/vector_map_info/vector", 1, &amp;OpenPlannerSimulatorSigns::callbackGetVMVectors,  this);
+	sub_curbs = nh.subscribe("/vector_map_info/curb", 1, &amp;OpenPlannerSimulatorSigns::callbackGetVMCurbs,  this);
+	sub_edges = nh.subscribe("/vector_map_info/road_edge", 1, &amp;OpenPlannerSimulatorSigns::callbackGetVMRoadEdges,  this);
+	sub_way_areas = nh.subscribe("/vector_map_info/way_area", 1, &amp;OpenPlannerSimulatorSigns::callbackGetVMWayAreas,  this);
+	sub_cross_walk = nh.subscribe("/vector_map_info/cross_walk", 1, &amp;OpenPlannerSimulatorSigns::callbackGetVMCrossWalks,  this);
+	sub_nodes = nh.subscribe("/vector_map_info/node", 1, &amp;OpenPlannerSimulatorSigns::callbackGetVMNodes,  this);
+
 	std::cout &lt;&lt; "OpenPlannerSimulatorSigns initialized successfully " &lt;&lt; std::endl;
 
 }
@@ -151,6 +170,40 @@ void OpenPlannerSimulatorSigns::MainLoop()
 			bMap = true;
 			PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_MapPath, m_Map, true);
 		}
+		else if (m_MapType == PlannerHNS::MAP_AUTOWARE &amp;&amp; !bMap)
+		{
+			std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;;
+
+			if(m_MapRaw.GetVersion()==2)
+			{
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
+						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
+						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,
+						m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true);
+
+				if(m_Map.roadSegments.size() &gt; 0)
+				{
+					bMap = true;
+					std::cout &lt;&lt; " ******* Map V2 Is Loaded successfully from the Sign Simulator!! " &lt;&lt; std::endl;
+				}
+			}
+			else if(m_MapRaw.GetVersion()==1)
+			{
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
+						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
+						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true);
+
+				if(m_Map.roadSegments.size() &gt; 0)
+				{
+					bMap = true;
+					std::cout &lt;&lt; " ******* Map V1 Is Loaded successfully from the Sign Simulator !! " &lt;&lt; std::endl;
+				}
+			}
+		}
 
 		if(m_CurrLightState == PlannerHNS::GREEN_LIGHT)
 		{
@@ -235,4 +288,104 @@ void OpenPlannerSimulatorSigns::MainLoop()
 	}
 }
 
+//Mapping Section
+
+void OpenPlannerSimulatorSigns::callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Lanes" &lt;&lt; endl;
+	if(m_MapRaw.pLanes == nullptr)
+		m_MapRaw.pLanes = new UtilityHNS::AisanLanesFileReader(msg);
+}
+
+void OpenPlannerSimulatorSigns::callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Points" &lt;&lt; endl;
+	if(m_MapRaw.pPoints  == nullptr)
+		m_MapRaw.pPoints = new UtilityHNS::AisanPointsFileReader(msg);
+}
+
+void OpenPlannerSimulatorSigns::callbackGetVMdtLanes(const vector_map_msgs::DTLaneArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received dtLanes" &lt;&lt; endl;
+	if(m_MapRaw.pCenterLines == nullptr)
+		m_MapRaw.pCenterLines = new UtilityHNS::AisanCenterLinesFileReader(msg);
+}
+
+void OpenPlannerSimulatorSigns::callbackGetVMIntersections(const vector_map_msgs::CrossRoadArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received CrossRoads" &lt;&lt; endl;
+	if(m_MapRaw.pIntersections == nullptr)
+		m_MapRaw.pIntersections = new UtilityHNS::AisanIntersectionFileReader(msg);
+}
+
+void OpenPlannerSimulatorSigns::callbackGetVMAreas(const vector_map_msgs::AreaArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Areas" &lt;&lt; endl;
+	if(m_MapRaw.pAreas == nullptr)
+		m_MapRaw.pAreas = new UtilityHNS::AisanAreasFileReader(msg);
+}
+
+void OpenPlannerSimulatorSigns::callbackGetVMLines(const vector_map_msgs::LineArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Lines" &lt;&lt; endl;
+	if(m_MapRaw.pLines == nullptr)
+		m_MapRaw.pLines = new UtilityHNS::AisanLinesFileReader(msg);
+}
+
+void OpenPlannerSimulatorSigns::callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received StopLines" &lt;&lt; endl;
+	if(m_MapRaw.pStopLines == nullptr)
+		m_MapRaw.pStopLines = new UtilityHNS::AisanStopLineFileReader(msg);
+}
+
+void OpenPlannerSimulatorSigns::callbackGetVMSignal(const vector_map_msgs::SignalArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Signals" &lt;&lt; endl;
+	if(m_MapRaw.pSignals  == nullptr)
+		m_MapRaw.pSignals = new UtilityHNS::AisanSignalFileReader(msg);
+}
+
+void OpenPlannerSimulatorSigns::callbackGetVMVectors(const vector_map_msgs::VectorArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Vectors" &lt;&lt; endl;
+	if(m_MapRaw.pVectors  == nullptr)
+		m_MapRaw.pVectors = new UtilityHNS::AisanVectorFileReader(msg);
+}
+
+void OpenPlannerSimulatorSigns::callbackGetVMCurbs(const vector_map_msgs::CurbArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Curbs" &lt;&lt; endl;
+	if(m_MapRaw.pCurbs == nullptr)
+		m_MapRaw.pCurbs = new UtilityHNS::AisanCurbFileReader(msg);
+}
+
+void OpenPlannerSimulatorSigns::callbackGetVMRoadEdges(const vector_map_msgs::RoadEdgeArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Edges" &lt;&lt; endl;
+	if(m_MapRaw.pRoadedges  == nullptr)
+		m_MapRaw.pRoadedges = new UtilityHNS::AisanRoadEdgeFileReader(msg);
+}
+
+void OpenPlannerSimulatorSigns::callbackGetVMWayAreas(const vector_map_msgs::WayAreaArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Wayareas" &lt;&lt; endl;
+	if(m_MapRaw.pWayAreas  == nullptr)
+		m_MapRaw.pWayAreas = new UtilityHNS::AisanWayareaFileReader(msg);
+}
+
+void OpenPlannerSimulatorSigns::callbackGetVMCrossWalks(const vector_map_msgs::CrossWalkArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received CrossWalks" &lt;&lt; endl;
+	if(m_MapRaw.pCrossWalks == nullptr)
+		m_MapRaw.pCrossWalks = new UtilityHNS::AisanCrossWalkFileReader(msg);
+}
+
+void OpenPlannerSimulatorSigns::callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg)
+{
+	std::cout &lt;&lt; "Received Nodes" &lt;&lt; endl;
+	if(m_MapRaw.pNodes == nullptr)
+		m_MapRaw.pNodes = new UtilityHNS::AisanNodesFileReader(msg);
+}
+
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="26f790eec3b619bae87528bf288b869030fa48f8" author="alexampa">
		<msg>[bugfix] Static tf broadcaster in ndt_mapping

Description
When ndt_mapping node is launched and points_callback() function is called, br.sendTransform() command is not executed and thus transform from map frame to base_link frame is not published.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -468,7 +468,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   Eigen::Matrix4f t_localizer(Eigen::Matrix4f::Identity());
   Eigen::Matrix4f t_base_link(Eigen::Matrix4f::Identity());
-  tf::TransformBroadcaster br;
+  static tf::TransformBroadcaster br;
   tf::Transform transform;
 
   current_scan_time = input-&gt;header.stamp;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4d76f702b83ad3d714404e0da8eb621d329aee52" author="Esteve Fernandez">
		<msg>[Feature] Makes sure that all binaries have their dependencies linked (#1385)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\ndt_tku\src\manage_ND.cpp" new_path="ros\src\computing\perception\localization\lib\ndt_tku\src\manage_ND.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -6,9 +6,9 @@
 #include "ndt.h"
 
 
-extern NDMapPtr NDmap;
-extern NDPtr NDs;
-extern int NDs_num;
+NDMapPtr NDmap;
+NDPtr NDs;
+int NDs_num;
 
 int g_map_x, g_map_y, g_map_z;
 double g_map_cellsize;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e65834e3f6d70ae861015bda751696b9a2304124" author="Esteve Fernandez">
		<msg>[Fix] Moved C++11 flag to autoware_build_flags (#1395)</msg>
		<modified_files>
			<file old_path="ros\src\common\cmake\autoware_build_flags\cmake\autoware_build_flags-extras.cmake" new_path="ros\src\common\cmake\autoware_build_flags\cmake\autoware_build_flags-extras.cmake" added_lines="7" deleted_lines="0">
				<diff>@@ -3,3 +3,10 @@ if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
 elseif(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
   set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-undefined,error")
 endif()
+
+# Enable support for C++11
+if(${CMAKE_VERSION} VERSION_LESS "3.1.0")
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
+else()
+  set(CMAKE_CXX_STANDARD 11)
+endif()
\ No newline at end of file
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a426f7a1e1753415a4cf8a57c5a126ec985b17b5" author="Hatem Darweesh">
		<msg>Test Simulated Vehicles
Fix Simulated Vehicle Initialization
Test Following
Test Obstacle Avoidance
Add Visualization information to rviz config file open_planner.rviz</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\open_planner.rviz" new_path="ros\src\.config\rviz\open_planner.rviz" added_lines="161" deleted_lines="94">
				<diff>@@ -8,10 +8,12 @@ Panels:
         - /Points Raw1/Status1
         - /Local Waypoints1/Status1
         - /Vector Map CenterLines1/Namespaces1
-        - /dp Local Rollouts1/Namespaces1
+        - /Global Path1/Namespaces1
+        - /OP Gen Rollouts 1/Namespaces1
+        - /Tracked Contours1/Namespaces1
         - /GlobalPathAnimation1/Status1
       Splitter Ratio: 0.695804
-    Tree Height: 1183
+    Tree Height: 1573
   - Class: rviz/Selection
     Name: Selection
   - Class: rviz/Tool Properties
@@ -30,7 +32,7 @@ Panels:
     Experimental: false
     Name: Time
     SyncMode: 0
-    SyncSource: Points Map
+    SyncSource: ""
 Visualization Manager:
   Class: ""
   Displays:
@@ -59,12 +61,18 @@ Visualization Manager:
         All Enabled: true
         base_link:
           Value: true
+        base_link_2:
+          Value: true
         map:
           Value: true
+        mobility:
+          Value: true
         sim_base_link:
           Value: true
         velodyne:
           Value: true
+        velodyne_2:
+          Value: true
         world:
           Value: true
       Marker Scale: 5
@@ -75,9 +83,11 @@ Visualization Manager:
       Tree:
         world:
           map:
-            base_link:
-              velodyne:
+            base_link_2:
+              velodyne_2:
                 {}
+            mobility:
+              {}
             sim_base_link:
               {}
       Update Interval: 0
@@ -94,7 +104,7 @@ Visualization Manager:
       Color: 255; 255; 255
       Color Transformer: FlatColor
       Decay Time: 0
-      Enabled: true
+      Enabled: false
       Invert Rainbow: false
       Max Color: 255; 255; 255
       Max Intensity: 4096
@@ -111,34 +121,15 @@ Visualization Manager:
       Unreliable: false
       Use Fixed Frame: true
       Use rainbow: true
-      Value: true
+      Value: false
     - Class: rviz/MarkerArray
-      Enabled: true
+      Enabled: false
       Marker Topic: /vector_map
       Name: Vector Map
       Namespaces:
-        cross_road: true
-        cross_walk: true
-        curb: true
-        curve_mirror: true
-        fence: true
-        guard_rail: true
-        gutter: true
-        rail_crossing: true
-        road_edge: true
-        road_mark: true
-        road_pole: true
-        road_sign: true
-        side_walk: true
-        signal: true
-        stop_line: true
-        street_light: true
-        utility_pole: true
-        wall: true
-        white_line: true
-        zebra_zone: true
+        {}
       Queue Size: 100
-      Value: true
+      Value: false
     - Class: rviz/Camera
       Enabled: false
       Image Rendering: overlay
@@ -150,19 +141,25 @@ Visualization Manager:
       Unreliable: false
       Value: false
       Visibility:
+        "": true
         A* Sim Obstacle: true
         Behavior State: true
+        Collision Points: true
         Control Pose: true
+        Curbs: true
         Current Pose: true
         Detection Range: true
         Global Path: true
         Global Waypoints: true
         GlobalPathAnimation: true
+        Goals: true
         Grid: true
-        Local Rollouts: true
         Local Waypoints: true
         Next FF Waypoint Mark: true
         Next Waypoint Mark: true
+        "OP Eval Rollouts ": true
+        "OP Gen Rollouts ": true
+        OP Selected Trajectory: true
         Occupancy Grid Map: true
         OverlayText: true
         PP Trajectory Mark: true
@@ -170,6 +167,12 @@ Visualization Manager:
         Points Map: true
         Points Raw: true
         Safety Box: true
+        Sim Beh 1: true
+        Sim Beh 2: true
+        Sim Car 1: true
+        Sim Car 2: true
+        Sim Traj 1: true
+        Sim Traj 2: true
         Simulated Obstacle: true
         Stixel: true
         TF: false
@@ -293,7 +296,7 @@ Visualization Manager:
       Marker Topic: /follow_pose
       Name: Next FF Waypoint Mark
       Namespaces:
-        follow_pose: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -410,45 +413,7 @@ Visualization Manager:
       Marker Topic: /vector_map_center_lines_rviz
       Name: Vector Map CenterLines
       Namespaces:
-        global_lane_waypoint_orientation_marker: false
-        stop_lines_rviz_1: true
-        stop_lines_rviz_10: true
-        stop_lines_rviz_11: true
-        stop_lines_rviz_12: true
-        stop_lines_rviz_13: true
-        stop_lines_rviz_14: true
-        stop_lines_rviz_15: true
-        stop_lines_rviz_16: true
-        stop_lines_rviz_17: true
-        stop_lines_rviz_18: true
-        stop_lines_rviz_19: true
-        stop_lines_rviz_2: true
-        stop_lines_rviz_20: true
-        stop_lines_rviz_21: true
-        stop_lines_rviz_22: true
-        stop_lines_rviz_23: true
-        stop_lines_rviz_24: true
-        stop_lines_rviz_25: true
-        stop_lines_rviz_26: true
-        stop_lines_rviz_27: true
-        stop_lines_rviz_28: true
-        stop_lines_rviz_29: true
-        stop_lines_rviz_3: true
-        stop_lines_rviz_30: true
-        stop_lines_rviz_31: true
-        stop_lines_rviz_32: true
-        stop_lines_rviz_33: true
-        stop_lines_rviz_34: true
-        stop_lines_rviz_35: true
-        stop_lines_rviz_36: true
-        stop_lines_rviz_37: true
-        stop_lines_rviz_4: true
-        stop_lines_rviz_5: true
-        stop_lines_rviz_6: true
-        stop_lines_rviz_7: true
-        stop_lines_rviz_8: true
-        stop_lines_rviz_9: true
-        vector_map_center_lines_rviz: true
+        road_network_vector_map: true
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -458,39 +423,39 @@ Visualization Manager:
       Namespaces:
         global_lane_array_marker: true
         global_lane_waypoint_orientation_marker: false
-        global_velocity_lane_1: false
+        global_velocity_lane_1: true
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
       Enabled: true
-      Marker Topic: /local_trajectories
-      Name: dp Local Rollouts
+      Marker Topic: /local_trajectories_gen_rviz
+      Name: "OP Gen Rollouts "
       Namespaces:
         global_lane_array_marker: true
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
       Enabled: true
-      Marker Topic: /detected_polygons
-      Name: Tracked Contours
+      Marker Topic: /local_trajectories_eval_rviz
+      Name: "OP Eval Rollouts "
       Namespaces:
-        {}
+        local_lane_array_marker_colored: true
       Queue Size: 100
       Value: true
-    - Class: rviz/Marker
+    - Class: rviz/MarkerArray
       Enabled: true
-      Marker Topic: /behavior_state
-      Name: Behavior State
+      Marker Topic: /local_selected_trajectory_rviz
+      Name: OP Selected Trajectory
       Namespaces:
-        detected_polygons_velocity: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
       Enabled: true
-      Marker Topic: /AnimateGlobalPlan
-      Name: GlobalPathAnimation
+      Marker Topic: /behavior_state
+      Name: Behavior State
       Namespaces:
-        {}
+        beh_state: true
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -501,6 +466,28 @@ Visualization Manager:
         global_lane_array_marker: true
       Queue Size: 100
       Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /detected_polygons
+      Name: Tracked Contours
+      Namespaces:
+        CenterMarker: true
+        Detection_Circles: false
+        Directions: true
+        InfoText: true
+        detected_polygons: true
+        matching_connections: true
+        tracked_trajectories: true
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /AnimateGlobalPlan
+      Name: GlobalPathAnimation
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
     - Class: jsk_rviz_plugin/BoundingBoxArray
       Enabled: true
       Name: Simulated Obstacle
@@ -556,6 +543,86 @@ Visualization Manager:
       text size: 12
       top: 0
       width: 128
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /op_destinations_rviz
+      Name: Goals
+      Namespaces:
+        HMI_Destinations: true
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /map_curbs_rviz
+      Name: Curbs
+      Namespaces:
+        map_detected_curbs: true
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /curr_simu_pose_1
+      Name: Sim Car 1
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /sim_beh_txt_1
+      Name: Sim Beh 1
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /simu_local_trajectory_1
+      Name: Sim Traj 1
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /curr_simu_pose_2
+      Name: Sim Car 2
+      Namespaces:
+        curr_simu_pose: true
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /sim_beh_txt_2
+      Name: Sim Beh 2
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /simu_local_trajectory_2
+      Name: Sim Traj 2
+      Namespaces:
+        simu_car_path_2: true
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /dynamic_collision_points_rviz
+      Name: Collision Points
+      Namespaces:
+        collision_points_rviz: true
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /predicted_trajectories_rviz
+      Name: Predicted Trajectories
+      Namespaces:
+        Predicted_Trajectories: true
+      Queue Size: 100
+      Value: true
   Enabled: true
   Global Options:
     Background Color: 48; 48; 48
@@ -590,21 +657,21 @@ Visualization Manager:
       Invert Z Axis: false
       Name: Current View
       Near Clip Distance: 0.00999999978
-      Scale: 22.3300667
-      Target Frame: &lt;Fixed Frame&gt;
+      Scale: 20.3939095
+      Target Frame: sim_base_link
       Value: TopDownOrtho (rviz)
-      X: 34.414566
-      Y: 13.7549858
+      X: -1.30942333
+      Y: 3.56311941
     Saved: ~
 Window Geometry:
   Camera:
     collapsed: false
   Displays:
     collapsed: false
-  Height: 1416
+  Height: 1746
   Hide Left Dock: false
-  Hide Right Dock: false
-  QMainWindow State: 000000ff00000000fd00000004000000000000016a000004e0fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006100fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc00000028000004e0000000d700fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000c00430061006d0065007200610000000000ffffffff0000006700fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb0000000000000000000000010000010f000004e0fc0200000003fb0000000a005600690065007700730100000028000004e0000000ad00fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e1000001970000000300000a000000005cfc0100000002fb0000000800540069006d0065010000000000000a000000030000fffffffb0000000800540069006d006501000000000000045000000000000000000000077b000004e000000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  Hide Right Dock: true
+  QMainWindow State: 000000ff00000000fd0000000400000000000001ad00000678fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006b00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc0000003400000678000000ef00fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000c00430061006d0065007200610000000000ffffffff0000008500fffffffb000000100044006900730070006c006100790073010000000000000136000001ad00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb0000000000000000000000010000013200000678fc0200000003fb0000000a00560069006500770073000000003400000678000000cd00fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e100000197000000030000069a0000005cfc0100000002fb0000000800540069006d006500000000000000069a0000043900fffffffb0000000800540069006d00650100000000000004500000000000000000000004ff0000067800000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
@@ -612,7 +679,7 @@ Window Geometry:
   Tool Properties:
     collapsed: false
   Views:
-    collapsed: false
-  Width: 2560
-  X: 1080
-  Y: 24
+    collapsed: true
+  Width: 1717
+  X: 1019
+  Y: 36
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track_core.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track_core.cpp" added_lines="8" deleted_lines="5">
				<diff>@@ -170,7 +170,7 @@ void ContourTracker::callbackGetCloudClusters(const autoware_msgs::CloudClusterA
 		struct timespec  tracking_timer;
 		UtilityHNS::UtilityH::GetTickCount(tracking_timer);
 
-		//std::cout &lt;&lt; "Filter the detected Obstacles: " &lt;&lt; msg-&gt;clusters.size() &lt;&lt; std::endl;
+		//std::cout &lt;&lt; "Filter the detected Obstacles: " &lt;&lt; msg-&gt;clusters.size() &lt;&lt; ", " &lt;&lt; m_OriginalClusters.size() &lt;&lt; std::endl;
 		m_ObstacleTracking.DoOneStep(m_CurrentPos, m_OriginalClusters, m_Params.trackingType);
 
 		m_tracking_time = UtilityHNS::UtilityH::GetTimeDiffNow(tracking_timer);
@@ -286,12 +286,15 @@ bool ContourTracker::IsCar(const PlannerHNS::DetectedObject&amp; obj, const PlannerH
 			return false;
 	}
 
-	double object_size = hypot(obj.w, obj.l);
+	if(!m_Params.bEnableSimulation)
+	{
+		double object_size = hypot(obj.w, obj.l);
 
-	//std::cout &lt;&lt; "Filter the detected Obstacles: (" &lt;&lt;  obj.distance_to_center  &lt;&lt; ",&gt;" &lt;&lt;  m_Params.DetectionRadius &lt;&lt; " | "&lt;&lt; object_size &lt;&lt; ",&lt; " &lt;&lt;  m_Params.MinObjSize  &lt;&lt; "| " &lt;&lt;  object_size &lt;&lt; ", &gt;" &lt;&lt;  m_Params.MaxObjSize &lt;&lt; ")"&lt;&lt; std::endl;
+		//std::cout &lt;&lt; "Filter the detected Obstacles: (" &lt;&lt;  obj.distance_to_center  &lt;&lt; ",&gt;" &lt;&lt;  m_Params.DetectionRadius &lt;&lt; " | "&lt;&lt; object_size &lt;&lt; ",&lt; " &lt;&lt;  m_Params.MinObjSize  &lt;&lt; "| " &lt;&lt;  object_size &lt;&lt; ", &gt;" &lt;&lt;  m_Params.MaxObjSize &lt;&lt; ")"&lt;&lt; std::endl;
 
-	if(obj.distance_to_center &gt; m_Params.DetectionRadius || object_size &lt; m_Params.MinObjSize || object_size &gt; m_Params.MaxObjSize)
-		return false;
+		if(obj.distance_to_center &gt; m_Params.DetectionRadius || object_size &lt; m_Params.MinObjSize || object_size &gt; m_Params.MaxObjSize)
+			return false;
+	}
 
 	if(m_Params.bEnableSimulation)
 	{
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -16,7 +16,7 @@
 
 using namespace UtilityHNS;
 using namespace std;
-#define _FIND_LEFT_RIGHT_LANES
+#define FIND_LEFT_RIGHT_LANES
 #define RIGHT_INITIAL_TURNS_COST 0
 #define LEFT_INITIAL_TURNS_COST 0
 #define DEBUG_MAP_PARSING 0
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\DataRW.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\DataRW.h" added_lines="20" deleted_lines="10">
				<diff>@@ -31,6 +31,7 @@
 #include "vector_map_msgs/RoadEdgeArray.h"
 #include "vector_map_msgs/CrossWalkArray.h"
 
+#include "UtilityH.h"
 
 namespace UtilityHNS {
 
@@ -688,6 +689,8 @@ public:
 	UtilityHNS::AisanCrossWalkFileReader* pCrossWalks;
 	UtilityHNS::AisanNodesFileReader* pNodes;
 
+	struct timespec _time_out;
+
 	MapRaw()
 	{
 		pLanes = nullptr;
@@ -704,6 +707,8 @@ public:
 		pWayAreas = nullptr;
 		pCrossWalks = nullptr;
 		pNodes = nullptr;
+
+		UtilityH::GetTickCount(_time_out);
 	}
 
 	~MapRaw()
@@ -795,24 +800,29 @@ public:
 
 	int GetVersion()
 	{
+		bool bTimeOut = UtilityH::GetTimeDiffNow(_time_out) &gt; 2.0;
 		bool bLoaded =  pLanes != nullptr &amp;&amp; pPoints != nullptr &amp;&amp; pCenterLines  != nullptr &amp;&amp; pNodes  != nullptr;
 		int iVersion = 0;
-		if(bLoaded)
+		if(bLoaded &amp;&amp; bTimeOut)
 		{
 			iVersion = 2;
-		}
-		else
-		{
-			bLoaded =  pLanes != nullptr &amp;&amp; pPoints != nullptr &amp;&amp; pCenterLines  != nullptr;
-			if(bLoaded)
+			if(pNodes-&gt;m_data_list.size() == 0)
 			{
 				iVersion = 1;
-				if(pNodes  == nullptr)
-					pNodes = new AisanNodesFileReader(vector_map_msgs::NodeArray());
 			}
 		}
-
-		if(bLoaded)
+//		else
+//		{
+//			bLoaded =  pLanes != nullptr &amp;&amp; pPoints != nullptr &amp;&amp; pCenterLines  != nullptr;
+//			if(bLoaded &amp;&amp; bTimeOut)
+//			{
+//				iVersion = 1;
+//				if(pNodes  == nullptr)
+//					pNodes = new AisanNodesFileReader(vector_map_msgs::NodeArray());
+//			}
+//		}
+
+		if(bLoaded &amp;&amp; bTimeOut)
 		{
 			if(pIntersections  == nullptr)
 				pIntersections  = new AisanIntersectionFileReader(vector_map_msgs::CrossRoadArray());
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" added_lines="30" deleted_lines="0">
				<diff>@@ -458,6 +458,8 @@ int LocalizationPathReader::ReadAllData(vector&lt;LocalizationWayPoint&gt;&amp; data_list)
 
 AisanNodesFileReader::AisanNodesFileReader(const vector_map_msgs::NodeArray&amp; _nodes) : SimpleReaderBase("d", 1)
 {
+	if(_nodes.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	//TODO Fix PID and NID problem
@@ -562,6 +564,8 @@ int AisanNodesFileReader::ReadAllData(vector&lt;AisanNode&gt;&amp; data_list)
 
 AisanPointsFileReader::AisanPointsFileReader(const vector_map_msgs::PointArray&amp; _points) : SimpleReaderBase("d", 1)
 {
+	if(_points.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	m_data_list.clear();
@@ -681,6 +685,8 @@ int AisanPointsFileReader::ReadAllData(vector&lt;AisanPoints&gt;&amp; data_list)
 
 AisanLinesFileReader::AisanLinesFileReader(const vector_map_msgs::LineArray&amp; _nodes) : SimpleReaderBase("d", 1)
 {
+	if(_nodes.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	m_data_list.clear();
@@ -789,6 +795,8 @@ int AisanLinesFileReader::ReadAllData(vector&lt;AisanLine&gt;&amp; data_list)
 
 AisanCenterLinesFileReader::AisanCenterLinesFileReader(const vector_map_msgs::DTLaneArray&amp; _Lines) : SimpleReaderBase("d", 1)
 {
+	if(_Lines.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	m_data_list.clear();
@@ -895,6 +903,8 @@ int AisanCenterLinesFileReader::ReadAllData(vector&lt;AisanCenterLine&gt;&amp; data_list)
 
 AisanLanesFileReader::AisanLanesFileReader(const vector_map_msgs::LaneArray&amp; _lanes) : SimpleReaderBase("d", 1)
 {
+	if(_lanes.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	m_data_list.clear();
@@ -1066,6 +1076,8 @@ int AisanLanesFileReader::ReadAllData(vector&lt;AisanLane&gt;&amp; data_list)
 
 AisanAreasFileReader::AisanAreasFileReader(const vector_map_msgs::AreaArray&amp; _areas) : SimpleReaderBase("d", 1)
 {
+	if(_areas.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	m_data_list.clear();
@@ -1158,6 +1170,8 @@ int AisanAreasFileReader::ReadAllData(vector&lt;AisanArea&gt;&amp; data_list)
 
 AisanIntersectionFileReader::AisanIntersectionFileReader(const vector_map_msgs::CrossRoadArray&amp; _inters) : SimpleReaderBase("d", 1)
 {
+	if(_inters.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	m_data_list.clear();
@@ -1250,6 +1264,8 @@ int AisanIntersectionFileReader::ReadAllData(vector&lt;AisanIntersection&gt;&amp; data_lis
 
 AisanStopLineFileReader::AisanStopLineFileReader(const vector_map_msgs::StopLineArray&amp; _stopLines) : SimpleReaderBase("d", 1)
 {
+	if(_stopLines.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	m_data_list.clear();
@@ -1346,6 +1362,8 @@ int AisanStopLineFileReader::ReadAllData(vector&lt;AisanStopLine&gt;&amp; data_list)
 
 AisanRoadSignFileReader::AisanRoadSignFileReader(const vector_map_msgs::RoadSignArray&amp; _signs) : SimpleReaderBase("d", 1)
 {
+	if(_signs.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	m_data_list.clear();
@@ -1442,6 +1460,8 @@ int AisanRoadSignFileReader::ReadAllData(vector&lt;AisanRoadSign&gt;&amp; data_list)
 
 AisanSignalFileReader::AisanSignalFileReader(const vector_map_msgs::SignalArray&amp; _signal) : SimpleReaderBase("d", 1)
 {
+	if(_signal.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	m_data_list.clear();
@@ -1539,6 +1559,8 @@ int AisanSignalFileReader::ReadAllData(vector&lt;AisanSignal&gt;&amp; data_list)
 
 AisanVectorFileReader::AisanVectorFileReader(const vector_map_msgs::VectorArray&amp; _vectors) : SimpleReaderBase("d", 1)
 {
+	if(_vectors.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	m_data_list.clear();
@@ -1633,6 +1655,8 @@ int AisanVectorFileReader::ReadAllData(vector&lt;AisanVector&gt;&amp; data_list)
 
 AisanCurbFileReader::AisanCurbFileReader(const vector_map_msgs::CurbArray&amp; _curbs) : SimpleReaderBase("d", 1)
 {
+	if(_curbs.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	m_data_list.clear();
@@ -1731,6 +1755,8 @@ int AisanCurbFileReader::ReadAllData(vector&lt;AisanCurb&gt;&amp; data_list)
 
 AisanRoadEdgeFileReader::AisanRoadEdgeFileReader(const vector_map_msgs::RoadEdgeArray&amp; _edges) : SimpleReaderBase("d", 1)
 {
+	if(_edges.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	m_data_list.clear();
@@ -1823,6 +1849,8 @@ int AisanRoadEdgeFileReader::ReadAllData(vector&lt;AisanRoadEdge&gt;&amp; data_list)
 
 AisanCrossWalkFileReader::AisanCrossWalkFileReader(const vector_map_msgs::CrossWalkArray&amp; _crossWalks) : SimpleReaderBase("d", 1)
 {
+	if(_crossWalks.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	m_data_list.clear();
@@ -1919,6 +1947,8 @@ int AisanCrossWalkFileReader::ReadAllData(vector&lt;AisanCrossWalk&gt;&amp; data_list)
 
 AisanWayareaFileReader::AisanWayareaFileReader(const vector_map_msgs::WayAreaArray&amp; _wayAreas) : SimpleReaderBase("d", 1)
 {
+	if(_wayAreas.data.size()==0) return;
+
 	m_min_id = std::numeric_limits&lt;int&gt;::max();
 
 	m_data_list.clear();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" added_lines="16" deleted_lines="14">
				<diff>@@ -448,6 +448,7 @@ void GlobalPlanner::MainLoop()
 
 			if(m_MapRaw.GetVersion()==2)
 			{
+				std::cout &lt;&lt; "Map Version 2" &lt;&lt; endl;
 				m_bKmlMap = true;
 				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
@@ -458,6 +459,7 @@ void GlobalPlanner::MainLoop()
 			}
 			else if(m_MapRaw.GetVersion()==1)
 			{
+				std::cout &lt;&lt; "Map Version 1" &lt;&lt; endl;
 				m_bKmlMap = true;
 				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
@@ -525,98 +527,98 @@ void GlobalPlanner::MainLoop()
 
 void GlobalPlanner::callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg)
 {
-	std::cout &lt;&lt; "Received Lanes" &lt;&lt; endl;
+	std::cout &lt;&lt; "Received Lanes" &lt;&lt; msg.data.size() &lt;&lt; endl;
 	if(m_MapRaw.pLanes == nullptr)
 		m_MapRaw.pLanes = new UtilityHNS::AisanLanesFileReader(msg);
 }
 
 void GlobalPlanner::callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg)
 {
-	std::cout &lt;&lt; "Received Points" &lt;&lt; endl;
+	std::cout &lt;&lt; "Received Points" &lt;&lt; msg.data.size() &lt;&lt; endl;
 	if(m_MapRaw.pPoints  == nullptr)
 		m_MapRaw.pPoints = new UtilityHNS::AisanPointsFileReader(msg);
 }
 
 void GlobalPlanner::callbackGetVMdtLanes(const vector_map_msgs::DTLaneArray&amp; msg)
 {
-	std::cout &lt;&lt; "Received dtLanes" &lt;&lt; endl;
+	std::cout &lt;&lt; "Received dtLanes" &lt;&lt; msg.data.size() &lt;&lt; endl;
 	if(m_MapRaw.pCenterLines == nullptr)
 		m_MapRaw.pCenterLines = new UtilityHNS::AisanCenterLinesFileReader(msg);
 }
 
 void GlobalPlanner::callbackGetVMIntersections(const vector_map_msgs::CrossRoadArray&amp; msg)
 {
-	std::cout &lt;&lt; "Received CrossRoads" &lt;&lt; endl;
+	std::cout &lt;&lt; "Received CrossRoads" &lt;&lt; msg.data.size() &lt;&lt; endl;
 	if(m_MapRaw.pIntersections == nullptr)
 		m_MapRaw.pIntersections = new UtilityHNS::AisanIntersectionFileReader(msg);
 }
 
 void GlobalPlanner::callbackGetVMAreas(const vector_map_msgs::AreaArray&amp; msg)
 {
-	std::cout &lt;&lt; "Received Areas" &lt;&lt; endl;
+	std::cout &lt;&lt; "Received Areas" &lt;&lt; msg.data.size() &lt;&lt; endl;
 	if(m_MapRaw.pAreas == nullptr)
 		m_MapRaw.pAreas = new UtilityHNS::AisanAreasFileReader(msg);
 }
 
 void GlobalPlanner::callbackGetVMLines(const vector_map_msgs::LineArray&amp; msg)
 {
-	std::cout &lt;&lt; "Received Lines" &lt;&lt; endl;
+	std::cout &lt;&lt; "Received Lines" &lt;&lt; msg.data.size() &lt;&lt; endl;
 	if(m_MapRaw.pLines == nullptr)
 		m_MapRaw.pLines = new UtilityHNS::AisanLinesFileReader(msg);
 }
 
 void GlobalPlanner::callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg)
 {
-	std::cout &lt;&lt; "Received StopLines" &lt;&lt; endl;
+	std::cout &lt;&lt; "Received StopLines" &lt;&lt; msg.data.size() &lt;&lt; endl;
 	if(m_MapRaw.pStopLines == nullptr)
 		m_MapRaw.pStopLines = new UtilityHNS::AisanStopLineFileReader(msg);
 }
 
 void GlobalPlanner::callbackGetVMSignal(const vector_map_msgs::SignalArray&amp; msg)
 {
-	std::cout &lt;&lt; "Received Signals" &lt;&lt; endl;
+	std::cout &lt;&lt; "Received Signals" &lt;&lt; msg.data.size() &lt;&lt; endl;
 	if(m_MapRaw.pSignals  == nullptr)
 		m_MapRaw.pSignals = new UtilityHNS::AisanSignalFileReader(msg);
 }
 
 void GlobalPlanner::callbackGetVMVectors(const vector_map_msgs::VectorArray&amp; msg)
 {
-	std::cout &lt;&lt; "Received Vectors" &lt;&lt; endl;
+	std::cout &lt;&lt; "Received Vectors" &lt;&lt; msg.data.size() &lt;&lt; endl;
 	if(m_MapRaw.pVectors  == nullptr)
 		m_MapRaw.pVectors = new UtilityHNS::AisanVectorFileReader(msg);
 }
 
 void GlobalPlanner::callbackGetVMCurbs(const vector_map_msgs::CurbArray&amp; msg)
 {
-	std::cout &lt;&lt; "Received Curbs" &lt;&lt; endl;
+	std::cout &lt;&lt; "Received Curbs" &lt;&lt; msg.data.size() &lt;&lt; endl;
 	if(m_MapRaw.pCurbs == nullptr)
 		m_MapRaw.pCurbs = new UtilityHNS::AisanCurbFileReader(msg);
 }
 
 void GlobalPlanner::callbackGetVMRoadEdges(const vector_map_msgs::RoadEdgeArray&amp; msg)
 {
-	std::cout &lt;&lt; "Received Edges" &lt;&lt; endl;
+	std::cout &lt;&lt; "Received Edges" &lt;&lt; msg.data.size() &lt;&lt; endl;
 	if(m_MapRaw.pRoadedges  == nullptr)
 		m_MapRaw.pRoadedges = new UtilityHNS::AisanRoadEdgeFileReader(msg);
 }
 
 void GlobalPlanner::callbackGetVMWayAreas(const vector_map_msgs::WayAreaArray&amp; msg)
 {
-	std::cout &lt;&lt; "Received Wayareas" &lt;&lt; endl;
+	std::cout &lt;&lt; "Received Wayareas" &lt;&lt; msg.data.size() &lt;&lt; endl;
 	if(m_MapRaw.pWayAreas  == nullptr)
 		m_MapRaw.pWayAreas = new UtilityHNS::AisanWayareaFileReader(msg);
 }
 
 void GlobalPlanner::callbackGetVMCrossWalks(const vector_map_msgs::CrossWalkArray&amp; msg)
 {
-	std::cout &lt;&lt; "Received CrossWalks" &lt;&lt; endl;
+	std::cout &lt;&lt; "Received CrossWalks" &lt;&lt; msg.data.size() &lt;&lt; endl;
 	if(m_MapRaw.pCrossWalks == nullptr)
 		m_MapRaw.pCrossWalks = new UtilityHNS::AisanCrossWalkFileReader(msg);
 }
 
 void GlobalPlanner::callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg)
 {
-	std::cout &lt;&lt; "Received Nodes" &lt;&lt; endl;
+	std::cout &lt;&lt; "Received Nodes" &lt;&lt; msg.data.size() &lt;&lt; endl;
 	if(m_MapRaw.pNodes == nullptr)
 		m_MapRaw.pNodes = new UtilityHNS::AisanNodesFileReader(msg);
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -260,7 +260,7 @@ void MotionPrediction::callbackGetTrackedObjects(const autoware_msgs::DetectedOb
 		{
 			curr_curbs_obstacles.clear();
 			GenerateCurbsObstacles(curr_curbs_obstacles);
-			std::cout &lt;&lt; "Curbs No: " &lt;&lt; curr_curbs_obstacles.size() &lt;&lt; endl;
+			//std::cout &lt;&lt; "Curbs No: " &lt;&lt; curr_curbs_obstacles.size() &lt;&lt; endl;
 			for(unsigned int i = 0 ; i &lt;curr_curbs_obstacles.size(); i++)
 			{
 				PlannerHNS::RosHelpers::ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(curr_curbs_obstacles.at(i), false, pred_obj);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator_core.cpp" added_lines="4" deleted_lines="0">
				<diff>@@ -746,6 +746,8 @@ int OpenPlannerCarSimulator::LoadSimulationData(PlannerHNS::WayPoint&amp; start_p, P
 
 	start_p.v = data.startPoint.v;
 	start_p.cost = data.startPoint.c;
+
+	std::cout &lt;&lt; "Loading from simulation File " &lt;&lt; start_p.pos.ToString() &lt;&lt; std::endl;
 	return nData;
 }
 
@@ -820,6 +822,7 @@ void OpenPlannerCarSimulator::MainLoop()
 				if(m_Map.roadSegments.size() &gt; 0)
 				{
 					m_bMap = true;
+					InitializeSimuCar(m_SimParams.startPose);
 					std::cout &lt;&lt; " ******* Map V2 Is Loaded successfully from the Behavior Selector !! " &lt;&lt; std::endl;
 				}
 			}
@@ -834,6 +837,7 @@ void OpenPlannerCarSimulator::MainLoop()
 				if(m_Map.roadSegments.size() &gt; 0)
 				{
 					m_bMap = true;
+					InitializeSimuCar(m_SimParams.startPose);
 					std::cout &lt;&lt; " ******* Map V1 Is Loaded successfully from the Behavior Selector !! " &lt;&lt; std::endl;
 				}
 			}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_perception_simulator\op_perception_simulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_perception_simulator\op_perception_simulator_core.cpp" added_lines="2" deleted_lines="0">
				<diff>@@ -137,6 +137,8 @@ void OpenPlannerSimulatorPerception::callbackGetSimuData(const geometry_msgs::Po
 	//	ROS_INFO("Insert Obj ID = %d", c.id);
 	}
 
+	//std::cout &lt;&lt; "Current Simulated Objects : " &lt;&lt; m_ObjClustersArray.clusters.size() &lt;&lt; std::endl;
+
 }
 
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1c011afa840ee8b4c91454507fb9db9de4da4e86" author="Hatem Darweesh">
		<msg>Add README files for OpenPlanner packages</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\include\op_global_planner_core.h" new_path="ros\src\computing\planning\mission\packages\op_global_planner\include\op_global_planner_core.h" added_lines="4" deleted_lines="4">
				<diff>@@ -127,10 +127,10 @@ protected:
 	ros::Publisher pub_Paths;
 	ros::Publisher pub_PathsRviz;
 	ros::Publisher pub_TrafficInfo;
-	ros::Publisher pub_TrafficInfoRviz;
-	ros::Publisher pub_StartPointRviz;
-	ros::Publisher pub_GoalPointRviz;
-	ros::Publisher pub_NodesListRviz;
+	//ros::Publisher pub_TrafficInfoRviz;
+	//ros::Publisher pub_StartPointRviz;
+	//ros::Publisher pub_GoalPointRviz;
+	//ros::Publisher pub_NodesListRviz;
 	ros::Publisher pub_GoalsListRviz;
 
 	ros::Subscriber sub_robot_odom;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -68,11 +68,11 @@ GlobalPlanner::GlobalPlanner()
 
 	pub_Paths = nh.advertise&lt;autoware_msgs::LaneArray&gt;("lane_waypoints_array", 1, true);
 	pub_PathsRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("global_waypoints_rviz", 1, true);
-	pub_StartPointRviz = nh.advertise&lt;visualization_msgs::Marker&gt;("Global_StartPoint_rviz", 1, true);
-	pub_GoalPointRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("Global_GoalPoints_rviz", 1, true);
-	pub_NodesListRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("Goal_Nodes_Points_rviz", 1, true);
+	//pub_StartPointRviz = nh.advertise&lt;visualization_msgs::Marker&gt;("Global_StartPoint_rviz", 1, true);
+	//pub_GoalPointRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("Global_GoalPoints_rviz", 1, true);
+	//pub_NodesListRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("Goal_Nodes_Points_rviz", 1, true);
 	pub_MapRviz  = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("vector_map_center_lines_rviz", 1, true);
-	pub_TrafficInfoRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("Traffic_Lights_rviz", 1, true);
+	//pub_TrafficInfoRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("Traffic_Lights_rviz", 1, true);
 	pub_GoalsListRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("op_destinations_rviz", 1, true);
 
 	if(m_params.bEnableRvizInput)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d51177e39421bd91ca0a3fd791338df40ff05f0c" author="yukikitsukawa">
		<msg>add max_scan_range to ConfigNdtMapping/ConfigApproximateNdtMapping</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\approximate_ndt_mapping\approximate_ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\approximate_ndt_mapping\approximate_ndt_mapping.cpp" added_lines="4" deleted_lines="1">
				<diff>@@ -131,6 +131,7 @@ static int initial_scan_loaded = 0;
 static Eigen::Matrix4f gnss_transform = Eigen::Matrix4f::Identity();
 
 static double min_scan_range = 5.0;
+static double max_scan_range = 200.0;
 static double min_add_scan_shift = 1.0;
 static double max_submap_size = 100.0;
 
@@ -161,6 +162,7 @@ static void param_callback(const autoware_msgs::ConfigApproximateNdtMapping::Con
   max_iter = input-&gt;max_iterations;
   voxel_leaf_size = input-&gt;leaf_size;
   min_scan_range = input-&gt;min_scan_range;
+  max_scan_range = input-&gt;max_scan_range;
   min_add_scan_shift = input-&gt;min_add_scan_shift;
   max_submap_size = input-&gt;max_submap_size;
 
@@ -171,6 +173,7 @@ static void param_callback(const autoware_msgs::ConfigApproximateNdtMapping::Con
   std::cout &lt;&lt; "max_iter: " &lt;&lt; max_iter &lt;&lt; std::endl;
   std::cout &lt;&lt; "voxel_leaf_size: " &lt;&lt; voxel_leaf_size &lt;&lt; std::endl;
   std::cout &lt;&lt; "min_scan_range: " &lt;&lt; min_scan_range &lt;&lt; std::endl;
+  std::cout &lt;&lt; "max_scan_range: " &lt;&lt; max_scan_range &lt;&lt; std::endl;
   std::cout &lt;&lt; "min_add_scan_shift: " &lt;&lt; min_add_scan_shift &lt;&lt; std::endl;
   std::cout &lt;&lt; "max_submap_size: " &lt;&lt; max_submap_size &lt;&lt; std::endl;
 }
@@ -469,7 +472,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     p.intensity = (double)item-&gt;intensity;
 
     r = sqrt(pow(p.x, 2.0) + pow(p.y, 2.0));
-    if (r &gt; min_scan_range)
+    if (min_scan_range &lt; r &amp;&amp; r &lt; max_scan_range)
     {
       scan.push_back(p);
     }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="4" deleted_lines="1">
				<diff>@@ -151,6 +151,7 @@ static int initial_scan_loaded = 0;
 static Eigen::Matrix4f gnss_transform = Eigen::Matrix4f::Identity();
 
 static double min_scan_range = 5.0;
+static double max_scan_range = 200.0;
 static double min_add_scan_shift = 1.0;
 
 static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
@@ -179,6 +180,7 @@ static void param_callback(const autoware_msgs::ConfigNdtMapping::ConstPtr&amp; inpu
   max_iter = input-&gt;max_iterations;
   voxel_leaf_size = input-&gt;leaf_size;
   min_scan_range = input-&gt;min_scan_range;
+  max_scan_range = input-&gt;max_scan_range;
   min_add_scan_shift = input-&gt;min_add_scan_shift;
 
   std::cout &lt;&lt; "param_callback" &lt;&lt; std::endl;
@@ -188,6 +190,7 @@ static void param_callback(const autoware_msgs::ConfigNdtMapping::ConstPtr&amp; inpu
   std::cout &lt;&lt; "max_iter: " &lt;&lt; max_iter &lt;&lt; std::endl;
   std::cout &lt;&lt; "voxel_leaf_size: " &lt;&lt; voxel_leaf_size &lt;&lt; std::endl;
   std::cout &lt;&lt; "min_scan_range: " &lt;&lt; min_scan_range &lt;&lt; std::endl;
+  std::cout &lt;&lt; "max_scan_range: " &lt;&lt; max_scan_range &lt;&lt; std::endl;
   std::cout &lt;&lt; "min_add_scan_shift: " &lt;&lt; min_add_scan_shift &lt;&lt; std::endl;
 }
 
@@ -483,7 +486,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     p.intensity = (double)item-&gt;intensity;
 
     r = sqrt(pow(p.x, 2.0) + pow(p.y, 2.0));
-    if (r &gt; min_scan_range)
+    if (min_scan_range &lt; r &amp;&amp; r &lt; max_scan_range)
     {
       scan.push_back(p);
     }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1b48dd4208ff8ed76310da87c8e2833165791937" author="yukikitsukawa">
		<msg>modified to output log</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\approximate_ndt_mapping\approximate_ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\approximate_ndt_mapping\approximate_ndt_mapping.cpp" added_lines="67" deleted_lines="0">
				<diff>@@ -154,6 +154,9 @@ static double submap_size = 0.0;
 static sensor_msgs::Imu imu;
 static nav_msgs::Odometry odom;
 
+static std::ofstream ofs;
+static std::string filename;
+
 static void param_callback(const autoware_msgs::ConfigApproximateNdtMapping::ConstPtr&amp; input)
 {
   ndt_res = input-&gt;resolution;
@@ -733,6 +736,34 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     submap_num++;
   }
 
+  // Write log
+  if (!ofs)
+  {
+    std::cerr &lt;&lt; "Could not open " &lt;&lt; filename &lt;&lt; "." &lt;&lt; std::endl;
+    exit(1);
+  }
+
+  ofs &lt;&lt; input-&gt;header.seq &lt;&lt; ","
+      &lt;&lt; input-&gt;header.stamp &lt;&lt; ","
+      &lt;&lt; input-&gt;header.frame_id &lt;&lt; ","
+      &lt;&lt; scan_ptr-&gt;size() &lt;&lt; ","
+      &lt;&lt; filtered_scan_ptr-&gt;size() &lt;&lt; ","
+      &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; ","
+      &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; ","
+      &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; ","
+      &lt;&lt; current_pose.roll &lt;&lt; ","
+      &lt;&lt; current_pose.pitch &lt;&lt; ","
+      &lt;&lt; current_pose.yaw &lt;&lt; ","
+      &lt;&lt; ndt_res &lt;&lt; ","
+      &lt;&lt; step_size &lt;&lt; ","
+      &lt;&lt; trans_eps &lt;&lt; ","
+      &lt;&lt; max_iter &lt;&lt; ","
+      &lt;&lt; voxel_leaf_size &lt;&lt; ","
+      &lt;&lt; min_scan_range &lt;&lt; ","
+      &lt;&lt; max_scan_range &lt;&lt; ","
+      &lt;&lt; min_add_scan_shift &lt;&lt; ","
+      &lt;&lt; max_submap_size &lt;&lt; std::endl;
+
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
   std::cout &lt;&lt; "Sequence number: " &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
   std::cout &lt;&lt; "Number of scan points: " &lt;&lt; scan_ptr-&gt;size() &lt;&lt; " points." &lt;&lt; std::endl;
@@ -827,6 +858,42 @@ int main(int argc, char** argv)
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
 
+  // Set log file name.
+  char buffer[80];
+  std::time_t now = std::time(NULL);
+  std::tm* pnow = std::localtime(&amp;now);
+  std::strftime(buffer, 80, "%Y%m%d_%H%M%S", pnow);
+  filename = "approximate_ndt_mapping_" + std::string(buffer) + ".csv";
+  ofs.open(filename.c_str(), std::ios::app);
+
+  // write header for log file
+  if (!ofs)
+  {
+    std::cerr &lt;&lt; "Could not open " &lt;&lt; filename &lt;&lt; "." &lt;&lt; std::endl;
+    exit(1);
+  }
+
+  ofs &lt;&lt; "input-&gt;header.seq" &lt;&lt; ","
+      &lt;&lt; "input-&gt;header.stamp" &lt;&lt; ","
+      &lt;&lt; "input-&gt;header.frame_id" &lt;&lt; ","
+      &lt;&lt; "scan_ptr-&gt;size()" &lt;&lt; ","
+      &lt;&lt; "filtered_scan_ptr-&gt;size()" &lt;&lt; ","
+      &lt;&lt; "current_pose.x" &lt;&lt; ","
+      &lt;&lt; "current_pose.y" &lt;&lt; ","
+      &lt;&lt; "current_pose.z" &lt;&lt; ","
+      &lt;&lt; "current_pose.roll" &lt;&lt; ","
+      &lt;&lt; "current_pose.pitch" &lt;&lt; ","
+      &lt;&lt; "current_pose.yaw" &lt;&lt; ","
+      &lt;&lt; "ndt_res" &lt;&lt; ","
+      &lt;&lt; "step_size" &lt;&lt; ","
+      &lt;&lt; "trans_eps" &lt;&lt; ","
+      &lt;&lt; "max_iter" &lt;&lt; ","
+      &lt;&lt; "voxel_leaf_size" &lt;&lt; ","
+      &lt;&lt; "min_scan_range" &lt;&lt; ","
+      &lt;&lt; "max_scan_range" &lt;&lt; ","
+      &lt;&lt; "min_add_scan_shift" &lt;&lt; ","
+      &lt;&lt; "max_submap_size" &lt;&lt; std::endl;
+
   // setting parameters
   private_nh.getParam("use_openmp", _use_openmp);
   private_nh.getParam("use_imu", _use_imu);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="71" deleted_lines="0">
				<diff>@@ -168,10 +168,14 @@ static std::string _imu_topic = "/imu_raw";
 static double fitness_score;
 static bool has_converged;
 static int final_num_iteration;
+static double transformation_probability;
 
 static sensor_msgs::Imu imu;
 static nav_msgs::Odometry odom;
 
+static std::ofstream ofs;
+static std::string filename;
+
 static void param_callback(const autoware_msgs::ConfigNdtMapping::ConstPtr&amp; input)
 {
   ndt_res = input-&gt;resolution;
@@ -612,6 +616,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     t_localizer = ndt.getFinalTransformation();
     has_converged = ndt.hasConverged();
     final_num_iteration = ndt.getFinalNumIteration();
+    transformation_probability = ndt.getTransformationProbability();
   }
   else if (_method_type == MethodType::PCL_ANH)
   {
@@ -804,6 +809,35 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   current_pose_pub.publish(current_pose_msg);
 
+  // Write log
+  if (!ofs)
+  {
+    std::cerr &lt;&lt; "Could not open " &lt;&lt; filename &lt;&lt; "." &lt;&lt; std::endl;
+    exit(1);
+  }
+
+  ofs &lt;&lt; input-&gt;header.seq &lt;&lt; ","
+      &lt;&lt; input-&gt;header.stamp &lt;&lt; ","
+      &lt;&lt; input-&gt;header.frame_id &lt;&lt; ","
+      &lt;&lt; scan_ptr-&gt;size() &lt;&lt; ","
+      &lt;&lt; filtered_scan_ptr-&gt;size() &lt;&lt; ","
+      &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; ","
+      &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; ","
+      &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; ","
+      &lt;&lt; current_pose.roll &lt;&lt; ","
+      &lt;&lt; current_pose.pitch &lt;&lt; ","
+      &lt;&lt; current_pose.yaw &lt;&lt; ","
+      &lt;&lt; final_num_iteration &lt;&lt; ","
+      &lt;&lt; fitness_score &lt;&lt; ","
+      &lt;&lt; ndt_res &lt;&lt; ","
+      &lt;&lt; step_size &lt;&lt; ","
+      &lt;&lt; trans_eps &lt;&lt; ","
+      &lt;&lt; max_iter &lt;&lt; ","
+      &lt;&lt; voxel_leaf_size &lt;&lt; ","
+      &lt;&lt; min_scan_range &lt;&lt; ","
+      &lt;&lt; max_scan_range &lt;&lt; ","
+      &lt;&lt; min_add_scan_shift &lt;&lt; std::endl;
+
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
   std::cout &lt;&lt; "Sequence number: " &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
   std::cout &lt;&lt; "Number of scan points: " &lt;&lt; scan_ptr-&gt;size() &lt;&lt; " points." &lt;&lt; std::endl;
@@ -897,6 +931,43 @@ int main(int argc, char** argv)
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
 
+  // Set log file name.
+  char buffer[80];
+  std::time_t now = std::time(NULL);
+  std::tm* pnow = std::localtime(&amp;now);
+  std::strftime(buffer, 80, "%Y%m%d_%H%M%S", pnow);
+  filename = "ndt_mapping_" + std::string(buffer) + ".csv";
+  ofs.open(filename.c_str(), std::ios::app);
+
+  // write header for log file
+  if (!ofs)
+  {
+    std::cerr &lt;&lt; "Could not open " &lt;&lt; filename &lt;&lt; "." &lt;&lt; std::endl;
+    exit(1);
+  }
+
+  ofs &lt;&lt; "input-&gt;header.seq" &lt;&lt; ","
+      &lt;&lt; "input-&gt;header.stamp" &lt;&lt; ","
+      &lt;&lt; "input-&gt;header.frame_id" &lt;&lt; ","
+      &lt;&lt; "scan_ptr-&gt;size()" &lt;&lt; ","
+      &lt;&lt; "filtered_scan_ptr-&gt;size()" &lt;&lt; ","
+      &lt;&lt; "current_pose.x" &lt;&lt; ","
+      &lt;&lt; "current_pose.y" &lt;&lt; ","
+      &lt;&lt; "current_pose.z" &lt;&lt; ","
+      &lt;&lt; "current_pose.roll" &lt;&lt; ","
+      &lt;&lt; "current_pose.pitch" &lt;&lt; ","
+      &lt;&lt; "current_pose.yaw" &lt;&lt; ","
+      &lt;&lt; "final_num_iteration" &lt;&lt; ","
+      &lt;&lt; "fitness_score" &lt;&lt; ","
+      &lt;&lt; "ndt_res" &lt;&lt; ","
+      &lt;&lt; "step_size" &lt;&lt; ","
+      &lt;&lt; "trans_eps" &lt;&lt; ","
+      &lt;&lt; "max_iter" &lt;&lt; ","
+      &lt;&lt; "voxel_leaf_size" &lt;&lt; ","
+      &lt;&lt; "min_scan_range" &lt;&lt; ","
+      &lt;&lt; "max_scan_range" &lt;&lt; ","
+      &lt;&lt; "min_add_scan_shift" &lt;&lt; std::endl;
+
   // setting parameters
   int method_type_tmp = 0;
   private_nh.getParam("method_type", method_type_tmp);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0955298d38b94406aa7e1b16170ec2bec8542280" author="hatem-darweesh">
		<msg>Fix Indigo build issues</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlanningHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlanningHelpers.h" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
 #ifndef PLANNINGHELPERS_H_
 #define PLANNINGHELPERS_H_
 
-#include &lt;math.h&gt;
+//#include &lt;math.h&gt;
 #include "RoadNetwork.h"
 #include "op_utility/UtilityH.h"
 #include "op_utility/DataRW.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -140,7 +140,7 @@ bool PlanningHelpers::GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, c
 	double m = (p1.pos.y-p0.pos.y)/(p1.pos.x-p0.pos.x);
 	info.perp_distance = p1.pos.y - m*p1.pos.x; // solve for x = 0
 
-	if(isnan(info.perp_distance) || isinf(info.perp_distance)) info.perp_distance = 0;
+	if(std::isnan(info.perp_distance) || std::isinf(info.perp_distance)) info.perp_distance = 0;
 
 	info.to_front_distance = fabs(p1.pos.x); // distance on the x axes
 
@@ -214,7 +214,7 @@ bool PlanningHelpers::GetRelativeInfoLimited(const std::vector&lt;WayPoint&gt;&amp; trajec
 		double m = (p1.pos.y-p0.pos.y)/(p1.pos.x-p0.pos.x);
 		info.perp_distance = p1.pos.y - m*p1.pos.x; // solve for x = 0
 
-		if(isnan(info.perp_distance) || isinf(info.perp_distance)) info.perp_distance = 0;
+		if(std::isnan(info.perp_distance) || std::isinf(info.perp_distance)) info.perp_distance = 0;
 
 		info.to_front_distance = fabs(p1.pos.x); // distance on the x axes
 
@@ -289,7 +289,7 @@ bool PlanningHelpers::GetRelativeInfoLimited(const std::vector&lt;WayPoint&gt;&amp; trajec
 		double m = (p1.pos.y-p0.pos.y)/(p1.pos.x-p0.pos.x);
 		info.perp_distance = p1.pos.y - m*p1.pos.x; // solve for x = 0
 
-		if(isnan(info.perp_distance) || isinf(info.perp_distance)) info.perp_distance = 0;
+		if(std::isnan(info.perp_distance) || std::isinf(info.perp_distance)) info.perp_distance = 0;
 
 		info.to_front_distance = fabs(p1.pos.x); // distance on the x axes
 
@@ -356,7 +356,7 @@ bool PlanningHelpers::GetThreePointsInfo(const WayPoint&amp; p0, const WayPoint&amp; p1,
 	double m = (perp_p.pos.y-first_p.pos.y)/(perp_p.pos.x-first_p.pos.x);
 	lat_d = perp_p.pos.y - m*perp_p.pos.x; // solve for x = 0
 
-	if(isnan(lat_d) || isinf(lat_d)) return false;
+	if(std::isnan(lat_d) || std::isinf(lat_d)) return false;
 
 	if(perp_p.pos.x &lt; 0)
 		return false;
@@ -871,7 +871,7 @@ double PlanningHelpers::GetPerpDistanceToTrajectorySimple_obsolete(const vector&lt;
 	double m = (p1.pos.y-p0.pos.y)/(p1.pos.x-p0.pos.x);
 	double d = p1.pos.y - m*p1.pos.x;
 
-	if(isnan(d) || isinf(d))
+	if(std::isnan(d) || std::isinf(d))
 	{
 	  //assert(false);
 	  d = 0;
@@ -895,7 +895,7 @@ double PlanningHelpers::GetPerpDistanceToVectorSimple_obsolete(const WayPoint&amp; p
 	double m = (p2.pos.y-p1.pos.y)/(p2.pos.x-p1.pos.x);
 	double d = p2.pos.y - m*p2.pos.x;
 
-	if(isnan(d) || isinf(d))
+	if(std::isnan(d) || std::isinf(d))
 	{
 	  //assert(false);
 	  d = 0;
@@ -1334,7 +1334,7 @@ double PlanningHelpers::CalcAngleAndCostAndCurvatureAnd2D(vector&lt;WayPoint&gt;&amp; path
 	for(unsigned int j = 1; j &lt; path.size()-1; j++)
 	{
 		k =  CalcCircle(path[j-1].pos,path[j].pos, path[j+1].pos, center);
-		if(k &gt; 150.0 || isnan(k))
+		if(k &gt; 150.0 || std::isnan(k))
 			k = 150.0;
 
 		if(k&lt;1.0)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\UtilityH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\UtilityH.h" added_lines="1" deleted_lines="1">
				<diff>@@ -8,8 +8,8 @@
 #define UTILITYH_H_
 
 #include &lt;assert.h&gt;
-#include &lt;math.h&gt;
 #include &lt;string&gt;
+#include &lt;math.h&gt;
 
 
 namespace UtilityHNS
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ring_ground_filter\ring_ground_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ring_ground_filter\ring_ground_filter.cpp" added_lines="11" deleted_lines="7">
				<diff>@@ -47,9 +47,12 @@ private:
 	Label 		class_label_[64];
 	double	radius_table_[64];
 
-	boost::chrono::high_resolution_clock::time_point t1_;
-	boost::chrono::high_resolution_clock::time_point t2_;
-	boost::chrono::nanoseconds elap_time_;
+	//boost::chrono::high_resolution_clock::time_point t1_;
+	//boost::chrono::high_resolution_clock::time_point t2_;
+	//boost::chrono::nanoseconds elap_time_;
+	ros::Time t1_;
+	ros::Time t2_;
+	ros::Duration elap_time_;
 
 	const int 	DEFAULT_HOR_RES = 2000;
 
@@ -314,7 +317,7 @@ void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::Point
 void GroundFilter::VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg)
 {
 
-	t1_ = boost::chrono::high_resolution_clock::now();
+	//t1_ = ros::Time().now();
 	pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; vertical_points;
 	pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; ground_points;
 	vertical_points.header = in_cloud_msg-&gt;header;
@@ -331,9 +334,10 @@ void GroundFilter::VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::P
 
 	groundless_points_pub_.publish(vertical_points);
 	ground_points_pub_.publish(ground_points);
-	t2_ = boost::chrono::high_resolution_clock::now();
-	elap_time_ = boost::chrono::duration_cast&lt;boost::chrono::nanoseconds&gt;(t2_-t1_);
-	std::cout &lt;&lt; "Computational Time for one frame: " &lt;&lt; elap_time_ &lt;&lt; '\n';
+	//t2_ = boost::chrono::high_resolution_clock::now();
+	//t2_ = ros::Time().now();
+	//elap_time_ = t2_ - t1_;//boost::chrono::duration_cast&lt;boost::chrono::nanoseconds&gt;(t2_-t1_);
+	//std::cout &lt;&lt; "Computational Time for one frame: " &lt;&lt; elap_time_ &lt;&lt; '\n';
 }
 
 int main(int argc, char **argv)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="96286e300170dd53ce1e38a48b2dc7dec9e44687" author="Esteve Fernandez">
		<msg>Take sysroot path from the AUTOWARE_SYSROOT environment variable</msg>
		<modified_files>
			<file old_path="ros\cross_toolchain.cmake" new_path="ros\cross_toolchain.cmake" added_lines="1" deleted_lines="1">
				<diff>@@ -2,7 +2,7 @@ set(CMAKE_SYSTEM_NAME Linux)
 set(CMAKE_SYSTEM_VERSION 1)
 set(CMAKE_SYSTEM_PROCESSOR aarch64)
 set(CMAKE_CROSSCOMPILING ON)
-set(CMAKE_SYSROOT /sysroot/${CMAKE_SYSTEM_PROCESSOR})
+set(CMAKE_SYSROOT $ENV{AUTOWARE_SYSROOT})
 set(CMAKE_PREFIX_PATH "${CMAKE_SYSROOT}/opt/ros/kinetic")
 
 # specify the cross compiler
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e1b1620027bba9ef4ad53365a93a8bf09cb2ce78" author="Abraham Monrroy">
		<msg>Feature/std perception msg (#1418)

* New standard message definition for the perception nodes

* New Detected Object message applied to:
* SSD
* Integrated RVIZ viewer
* External Viewer

* modified yolo2 and yolo3, compiles but cuda issues, trying different PC

* Boiler plate for range vision fusion node

* Added GenColors for Kinetic
Typo fixes for yolo2

* testing colors in Yolo3

* Completed transformation, projection of 3D boxes

* Fixed error on negative assignation

* code clean up

* removed yolo2 and yolo3, replaced by single darknet node. GUI launches yolo3 for now, to change. Pushing to test code on other PC.

* Readme updated, added gitignore for data folder.

* *Added Runtime manager UI for yolo2, yolo3.
*Support tested for TinyYolo v2 and v3

* Fusion Vision Range
Icons for viewer

* Range Vision Fusion node

* Indigo cv im read

* Indigo compiation fix

* Topic renaming according to new spec

* Try to fix arm64 stuff

* * Added launch file
* Added Runtime manager entry

* * Added Publication of non fused objects
* Fixed topic names</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\cluster.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\cluster.cpp" added_lines="269" deleted_lines="258">
				<diff>@@ -9,338 +9,349 @@
 
 Cluster::Cluster()
 {
-	valid_cluster_ = true;
+    valid_cluster_ = true;
 }
 
 geometry_msgs::PolygonStamped Cluster::GetPolygon()
 {
-	return polygon_;
+    return polygon_;
 }
 
 jsk_recognition_msgs::BoundingBox Cluster::GetBoundingBox()
 {
-	return bounding_box_;
+    return bounding_box_;
 }
 
 pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr Cluster::GetCloud()
 {
-	return pointcloud_;
+    return pointcloud_;
 }
 
 pcl::PointXYZ Cluster::GetMinPoint()
 {
-	return min_point_;
+    return min_point_;
 }
 
 pcl::PointXYZ Cluster::GetMaxPoint()
 {
-	return max_point_;
+    return max_point_;
 }
 
 pcl::PointXYZ Cluster::GetCentroid()
 {
-	return centroid_;
+    return centroid_;
 }
 
 pcl::PointXYZ Cluster::GetAveragePoint()
 {
-	return average_point_;
+    return average_point_;
 }
 
 double Cluster::GetOrientationAngle()
 {
-	return orientation_angle_;
+    return orientation_angle_;
 }
 
 Eigen::Matrix3f Cluster::GetEigenVectors()
 {
-	return eigen_vectors_;
+    return eigen_vectors_;
 }
 
 Eigen::Vector3f Cluster::GetEigenValues()
 {
-	return eigen_values_;
+    return eigen_values_;
 }
 
-void Cluster::ToRosMessage(std_msgs::Header in_ros_header, autoware_msgs::CloudCluster&amp; out_cluster_message)
+void Cluster::ToRosMessage(std_msgs::Header in_ros_header, autoware_msgs::CloudCluster &amp;out_cluster_message)
 {
-	sensor_msgs::PointCloud2 cloud_msg;
+    sensor_msgs::PointCloud2 cloud_msg;
 
-	pcl::toROSMsg(*(this-&gt;GetCloud()), cloud_msg);
-	cloud_msg.header=in_ros_header;
+    pcl::toROSMsg(*(this-&gt;GetCloud()), cloud_msg);
+    cloud_msg.header = in_ros_header;
 
-	out_cluster_message.header = in_ros_header;
+    out_cluster_message.header = in_ros_header;
 
-	out_cluster_message.cloud = cloud_msg;
-	out_cluster_message.min_point.header = in_ros_header;
-	out_cluster_message.min_point.point.x = this-&gt;GetMinPoint().x;
-	out_cluster_message.min_point.point.y = this-&gt;GetMinPoint().y;
-	out_cluster_message.min_point.point.z = this-&gt;GetMinPoint().z;
+    out_cluster_message.cloud = cloud_msg;
+    out_cluster_message.min_point.header = in_ros_header;
+    out_cluster_message.min_point.point.x = this-&gt;GetMinPoint().x;
+    out_cluster_message.min_point.point.y = this-&gt;GetMinPoint().y;
+    out_cluster_message.min_point.point.z = this-&gt;GetMinPoint().z;
 
-	out_cluster_message.max_point.header = in_ros_header;
-	out_cluster_message.max_point.point.x = this-&gt;GetMaxPoint().x;
-	out_cluster_message.max_point.point.y = this-&gt;GetMaxPoint().y;
-	out_cluster_message.max_point.point.z = this-&gt;GetMaxPoint().z;
+    out_cluster_message.max_point.header = in_ros_header;
+    out_cluster_message.max_point.point.x = this-&gt;GetMaxPoint().x;
+    out_cluster_message.max_point.point.y = this-&gt;GetMaxPoint().y;
+    out_cluster_message.max_point.point.z = this-&gt;GetMaxPoint().z;
 
-	out_cluster_message.avg_point.header = in_ros_header;
-	out_cluster_message.avg_point.point.x = this-&gt;GetAveragePoint().x;
-	out_cluster_message.avg_point.point.y = this-&gt;GetAveragePoint().y;
-	out_cluster_message.avg_point.point.z = this-&gt;GetAveragePoint().z;
+    out_cluster_message.avg_point.header = in_ros_header;
+    out_cluster_message.avg_point.point.x = this-&gt;GetAveragePoint().x;
+    out_cluster_message.avg_point.point.y = this-&gt;GetAveragePoint().y;
+    out_cluster_message.avg_point.point.z = this-&gt;GetAveragePoint().z;
 
-	out_cluster_message.centroid_point.header = in_ros_header;
-	out_cluster_message.centroid_point.point.x = this-&gt;GetCentroid().x;
-	out_cluster_message.centroid_point.point.y = this-&gt;GetCentroid().y;
-	out_cluster_message.centroid_point.point.z = this-&gt;GetCentroid().z;
+    out_cluster_message.centroid_point.header = in_ros_header;
+    out_cluster_message.centroid_point.point.x = this-&gt;GetCentroid().x;
+    out_cluster_message.centroid_point.point.y = this-&gt;GetCentroid().y;
+    out_cluster_message.centroid_point.point.z = this-&gt;GetCentroid().z;
 
-	out_cluster_message.estimated_angle = this-&gt;GetOrientationAngle();
+    out_cluster_message.estimated_angle = this-&gt;GetOrientationAngle();
 
-	out_cluster_message.dimensions = this-&gt;GetBoundingBox().dimensions;
+    out_cluster_message.dimensions = this-&gt;GetBoundingBox().dimensions;
 
-	out_cluster_message.bounding_box = this-&gt;GetBoundingBox();
+    out_cluster_message.bounding_box = this-&gt;GetBoundingBox();
 
-	out_cluster_message.convex_hull = this-&gt;GetPolygon();
+    out_cluster_message.convex_hull = this-&gt;GetPolygon();
 
-	Eigen::Vector3f eigen_values = this-&gt;GetEigenValues();
-	out_cluster_message.eigen_values.x = eigen_values.x();
-	out_cluster_message.eigen_values.y = eigen_values.y();
-	out_cluster_message.eigen_values.z = eigen_values.z();
+    Eigen::Vector3f eigen_values = this-&gt;GetEigenValues();
+    out_cluster_message.eigen_values.x = eigen_values.x();
+    out_cluster_message.eigen_values.y = eigen_values.y();
+    out_cluster_message.eigen_values.z = eigen_values.z();
 
-	Eigen::Matrix3f eigen_vectors = this-&gt;GetEigenVectors();
-	for (unsigned int i=0; i &lt; 3 ; i++)
-	{
-		geometry_msgs::Vector3 eigen_vector;
-		eigen_vector.x = eigen_vectors(i, 0);
-		eigen_vector.y = eigen_vectors(i, 1);
-		eigen_vector.z = eigen_vectors(i, 2);
-		out_cluster_message.eigen_vectors.push_back(eigen_vector);
-	}
+    Eigen::Matrix3f eigen_vectors = this-&gt;GetEigenVectors();
+    for (unsigned int i = 0; i &lt; 3; i++)
+    {
+        geometry_msgs::Vector3 eigen_vector;
+        eigen_vector.x = eigen_vectors(i, 0);
+        eigen_vector.y = eigen_vectors(i, 1);
+        eigen_vector.z = eigen_vectors(i, 2);
+        out_cluster_message.eigen_vectors.push_back(eigen_vector);
+    }
 
-	/*std::vector&lt;float&gt; fpfh_descriptor = GetFpfhDescriptor(8, 0.3, 0.3);
-	out_cluster_message.fpfh_descriptor.data = fpfh_descriptor;*/
+    /*std::vector&lt;float&gt; fpfh_descriptor = GetFpfhDescriptor(8, 0.3, 0.3);
+    out_cluster_message.fpfh_descriptor.data = fpfh_descriptor;*/
 }
 
-void Cluster::SetCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_origin_cloud_ptr, const std::vector&lt;int&gt;&amp; in_cluster_indices, std_msgs::Header in_ros_header, int in_id, int in_r, int in_g, int in_b, std::string in_label, bool in_estimate_pose)
+void Cluster::SetCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_origin_cloud_ptr,
+                       const std::vector&lt;int&gt; &amp;in_cluster_indices, std_msgs::Header in_ros_header, int in_id, int in_r,
+                       int in_g, int in_b, std::string in_label, bool in_estimate_pose)
 {
-	label_ 	= in_label;	id_		= in_id;
-	r_		= in_r;	g_		= in_g;	b_		= in_b;
-	//extract pointcloud using the indices
-	//calculate min and max points
-	pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr current_cluster (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
-	float min_x=std::numeric_limits&lt;float&gt;::max();float max_x=-std::numeric_limits&lt;float&gt;::max();
-	float min_y=std::numeric_limits&lt;float&gt;::max();float max_y=-std::numeric_limits&lt;float&gt;::max();
-	float min_z=std::numeric_limits&lt;float&gt;::max();float max_z=-std::numeric_limits&lt;float&gt;::max();
-	float average_x = 0, average_y = 0, average_z = 0;
-
-	for (auto pit = in_cluster_indices.begin(); pit != in_cluster_indices.end(); ++pit)
-	{
-		//fill new colored cluster point by point
-		pcl::PointXYZRGB p;
-		p.x = in_origin_cloud_ptr-&gt;points[*pit].x;
-		p.y = in_origin_cloud_ptr-&gt;points[*pit].y;
-		p.z = in_origin_cloud_ptr-&gt;points[*pit].z;
-		p.r = in_r;
-		p.g = in_g;
-		p.b = in_b;
-
-		average_x+=p.x;		average_y+=p.y;		average_z+=p.z;
-		centroid_.x += p.x; centroid_.y += p.y;	centroid_.z += p.z;
-		current_cluster-&gt;points.push_back(p);
-
-		if(p.x&lt;min_x)	min_x = p.x;
-		if(p.y&lt;min_y)	min_y = p.y;
-		if(p.z&lt;min_z)	min_z = p.z;
-		if(p.x&gt;max_x)	max_x = p.x;
-		if(p.y&gt;max_y)	max_y = p.y;
-		if(p.z&gt;max_z)	max_z = p.z;
-	}
-	//min, max points
-	min_point_.x = min_x;	min_point_.y = min_y;	min_point_.z = min_z;
-	max_point_.x = max_x;	max_point_.y = max_y;	max_point_.z = max_z;
-
-	//calculate centroid, average
-	if (in_cluster_indices.size() &gt; 0)
-	{
-		centroid_.x /= in_cluster_indices.size();
-		centroid_.y /= in_cluster_indices.size();
-		centroid_.z /= in_cluster_indices.size();
-
-		average_x /= in_cluster_indices.size();
-		average_y /= in_cluster_indices.size();
-		average_z /= in_cluster_indices.size();
-	}
-
-	average_point_.x = average_x; average_point_.y = average_y;	average_point_.z = average_z;
-
-	//calculate bounding box
-	length_ = max_point_.x - min_point_.x;
-	width_ = max_point_.y - min_point_.y;
-	height_ = max_point_.z - min_point_.z;
-
-	bounding_box_.header = in_ros_header;
-
-	bounding_box_.pose.position.x = min_point_.x + length_/2;
-	bounding_box_.pose.position.y = min_point_.y + width_/2;
-	bounding_box_.pose.position.z = min_point_.z + height_/2;
-
-	bounding_box_.dimensions.x = ((length_&lt;0)?-1*length_:length_);
-	bounding_box_.dimensions.y = ((width_&lt;0)?-1*width_:width_);
-	bounding_box_.dimensions.z = ((height_&lt;0)?-1*height_:height_);
-
-	//pose estimation
-	double rz = 0;
-
-	{
-		std::vector&lt;cv::Point2f&gt; points;
-		for (unsigned int i=0; i&lt;current_cluster-&gt;points.size(); i++)
-		{
-			cv::Point2f pt;
-			pt.x = current_cluster-&gt;points[i].x;
-			pt.y = current_cluster-&gt;points[i].y;
-			points.push_back(pt);
-		}
-
-		if (in_estimate_pose)
-		{
-			//pose estimation for the cluster
-			//test using linear regressionwidth
-			//Slope(b) = (NΣXY - (ΣX)(ΣY)) / (NΣX2 - (ΣX)2)
-
-			//float sum_x=0, sum_y=0, sum_xy=0, sum_xx=0;
-			//for (unsigned int i=0; i&lt;current_cluster-&gt;points.size(); i++)
-			//{
-			//	sum_x+= current_cluster-&gt;points[i].x;
-			//	sum_y+= current_cluster-&gt;points[i].y;
-			//	sum_xy+= current_cluster-&gt;points[i].x*current_cluster-&gt;points[i].y;
-			//	sum_xx+= current_cluster-&gt;points[i].x*current_cluster-&gt;points[i].x;
-			//}
-			//double slope= (current_cluster-&gt;points.size()*sum_xy - (sum_x*sum_y))/(current_cluster-&gt;points.size()*sum_xx - sum_x*sum_x);
-			//rz = atan(-slope);
-			cv::RotatedRect box = minAreaRect(points);
-			rz = box.angle*3.14/180;
-			bounding_box_.pose.position.x = box.center.x;
-			bounding_box_.pose.position.y = box.center.y;
-			//std::cout &lt;&lt; bounding_box_.pose.position.y &lt;&lt; " " &lt;&lt; bounding_box_.pose.position.x  &lt;&lt; std::endl;
-			bounding_box_.dimensions.x = box.size.width;
-			bounding_box_.dimensions.y = box.size.height;
-		}
-
-		std::vector&lt;cv::Point2f&gt; hull;
-		cv::convexHull(points, hull);
-
-		polygon_.header = in_ros_header;
-		for (size_t i = 0; i&lt; hull.size() + 1 ; i++)
-		{
-			geometry_msgs::Point32 point;
-			point.x = hull[i%hull.size()].x;
-			point.y = hull[i%hull.size()].y;
-			point.z = min_point_.z;
-			polygon_.polygon.points.push_back(point);
-		}
-
-		for (size_t i = 0; i&lt; hull.size() + 1 ; i++)
-		{
-			geometry_msgs::Point32 point;
-			point.x = hull[i%hull.size()].x;
-			point.y = hull[i%hull.size()].y;
-			point.z = max_point_.z;
-			polygon_.polygon.points.push_back(point);
-		}
-
-		/*cv::Point2f rect_points[4];
-		box.points(rect_points);*/
-	}
-
-	//set bounding box direction
-	tf::Quaternion quat = tf::createQuaternionFromRPY(0.0, 0.0, rz);
-	tf::quaternionTFToMsg(quat, bounding_box_.pose.orientation);
-
-	current_cluster-&gt;width = current_cluster-&gt;points.size();
-	current_cluster-&gt;height = 1;
-	current_cluster-&gt;is_dense = true;
-
-	//Get EigenValues, eigenvectors
-	if (current_cluster-&gt;points.size() &gt; 0)
-	{
-		pcl::PCA&lt;pcl::PointXYZ&gt; current_cluster_pca;
-		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr current_cluster_mono (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-
-		pcl::copyPointCloud&lt;pcl::PointXYZRGB, pcl::PointXYZ&gt;(*current_cluster, *current_cluster_mono);
-
-		current_cluster_pca.setInputCloud(current_cluster_mono);
-		eigen_vectors_ = current_cluster_pca.getEigenVectors();
-		eigen_values_ = current_cluster_pca.getEigenValues();
-	}
-
-	valid_cluster_ = true;
-	pointcloud_ = current_cluster;
+    label_ = in_label;
+    id_ = in_id;
+    r_ = in_r;
+    g_ = in_g;
+    b_ = in_b;
+    //extract pointcloud using the indices
+    //calculate min and max points
+    pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr current_cluster(new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
+    float min_x = std::numeric_limits&lt;float&gt;::max();
+    float max_x = -std::numeric_limits&lt;float&gt;::max();
+    float min_y = std::numeric_limits&lt;float&gt;::max();
+    float max_y = -std::numeric_limits&lt;float&gt;::max();
+    float min_z = std::numeric_limits&lt;float&gt;::max();
+    float max_z = -std::numeric_limits&lt;float&gt;::max();
+    float average_x = 0, average_y = 0, average_z = 0;
+
+    for (auto pit = in_cluster_indices.begin(); pit != in_cluster_indices.end(); ++pit)
+    {
+        //fill new colored cluster point by point
+        pcl::PointXYZRGB p;
+        p.x = in_origin_cloud_ptr-&gt;points[*pit].x;
+        p.y = in_origin_cloud_ptr-&gt;points[*pit].y;
+        p.z = in_origin_cloud_ptr-&gt;points[*pit].z;
+        p.r = in_r;
+        p.g = in_g;
+        p.b = in_b;
+
+        average_x += p.x;
+        average_y += p.y;
+        average_z += p.z;
+        centroid_.x += p.x;
+        centroid_.y += p.y;
+        centroid_.z += p.z;
+        current_cluster-&gt;points.push_back(p);
+
+        if (p.x &lt; min_x)
+            min_x = p.x;
+        if (p.y &lt; min_y)
+            min_y = p.y;
+        if (p.z &lt; min_z)
+            min_z = p.z;
+        if (p.x &gt; max_x)
+            max_x = p.x;
+        if (p.y &gt; max_y)
+            max_y = p.y;
+        if (p.z &gt; max_z)
+            max_z = p.z;
+    }
+    //min, max points
+    min_point_.x = min_x;
+    min_point_.y = min_y;
+    min_point_.z = min_z;
+    max_point_.x = max_x;
+    max_point_.y = max_y;
+    max_point_.z = max_z;
+
+    //calculate centroid, average
+    if (in_cluster_indices.size() &gt; 0)
+    {
+        centroid_.x /= in_cluster_indices.size();
+        centroid_.y /= in_cluster_indices.size();
+        centroid_.z /= in_cluster_indices.size();
+
+        average_x /= in_cluster_indices.size();
+        average_y /= in_cluster_indices.size();
+        average_z /= in_cluster_indices.size();
+    }
+
+    average_point_.x = average_x;
+    average_point_.y = average_y;
+    average_point_.z = average_z;
+
+    //calculate bounding box
+    length_ = max_point_.x - min_point_.x;
+    width_ = max_point_.y - min_point_.y;
+    height_ = max_point_.z - min_point_.z;
+
+    bounding_box_.header = in_ros_header;
+
+    bounding_box_.pose.position.x = min_point_.x + length_ / 2;
+    bounding_box_.pose.position.y = min_point_.y + width_ / 2;
+    bounding_box_.pose.position.z = min_point_.z + height_ / 2;
+
+    bounding_box_.dimensions.x = ((length_ &lt; 0) ? -1 * length_ : length_);
+    bounding_box_.dimensions.y = ((width_ &lt; 0) ? -1 * width_ : width_);
+    bounding_box_.dimensions.z = ((height_ &lt; 0) ? -1 * height_ : height_);
+
+    //pose estimation
+    double rz = 0;
+
+    {
+        std::vector&lt;cv::Point2f&gt; points;
+        for (unsigned int i = 0; i &lt; current_cluster-&gt;points.size(); i++)
+        {
+            cv::Point2f pt;
+            pt.x = current_cluster-&gt;points[i].x;
+            pt.y = current_cluster-&gt;points[i].y;
+            points.push_back(pt);
+        }
+
+        std::vector&lt;cv::Point2f&gt; hull;
+        cv::convexHull(points, hull);
+
+        polygon_.header = in_ros_header;
+        for (size_t i = 0; i &lt; hull.size() + 1; i++)
+        {
+            geometry_msgs::Point32 point;
+            point.x = hull[i % hull.size()].x;
+            point.y = hull[i % hull.size()].y;
+            point.z = min_point_.z;
+            polygon_.polygon.points.push_back(point);
+        }
+
+        for (size_t i = 0; i &lt; hull.size() + 1; i++)
+        {
+            geometry_msgs::Point32 point;
+            point.x = hull[i % hull.size()].x;
+            point.y = hull[i % hull.size()].y;
+            point.z = max_point_.z;
+            polygon_.polygon.points.push_back(point);
+        }
+        if (in_estimate_pose)
+        {
+            cv::RotatedRect box = minAreaRect(hull);
+            rz = box.angle * 3.14 / 180;
+            bounding_box_.pose.position.x = box.center.x;
+            bounding_box_.pose.position.y = box.center.y;
+            bounding_box_.dimensions.x = box.size.width;
+            bounding_box_.dimensions.y = box.size.height;
+        }
+    }
+
+    //set bounding box direction
+    tf::Quaternion quat = tf::createQuaternionFromRPY(0.0, 0.0, rz);
+    tf::quaternionTFToMsg(quat, bounding_box_.pose.orientation);
+
+    current_cluster-&gt;width = current_cluster-&gt;points.size();
+    current_cluster-&gt;height = 1;
+    current_cluster-&gt;is_dense = true;
+
+    //Get EigenValues, eigenvectors
+    if (current_cluster-&gt;points.size() &gt; 0)
+    {
+        pcl::PCA&lt;pcl::PointXYZ&gt; current_cluster_pca;
+        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr current_cluster_mono(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+
+        pcl::copyPointCloud&lt;pcl::PointXYZRGB, pcl::PointXYZ&gt;(*current_cluster, *current_cluster_mono);
+
+        current_cluster_pca.setInputCloud(current_cluster_mono);
+        eigen_vectors_ = current_cluster_pca.getEigenVectors();
+        eigen_values_ = current_cluster_pca.getEigenValues();
+    }
+
+    valid_cluster_ = true;
+    pointcloud_ = current_cluster;
 }
 
-std::vector&lt;float&gt; Cluster::GetFpfhDescriptor(const unsigned int&amp; in_ompnum_threads, const double&amp; in_normal_search_radius, const double&amp; in_fpfh_search_radius)
+std::vector&lt;float&gt;
+Cluster::GetFpfhDescriptor(const unsigned int &amp;in_ompnum_threads, const double &amp;in_normal_search_radius,
+                           const double &amp;in_fpfh_search_radius)
 {
-	std::vector&lt;float&gt; cluster_fpfh_histogram(33,0.0);
-
-	pcl::search::KdTree&lt;pcl::PointXYZRGB&gt;::Ptr norm_tree (new pcl::search::KdTree&lt;pcl::PointXYZRGB&gt;);
-	if (pointcloud_-&gt;points.size() &gt; 0)
-		norm_tree-&gt;setInputCloud(pointcloud_);
-
-	pcl::PointCloud&lt;pcl::Normal&gt;::Ptr normals (new pcl::PointCloud&lt;pcl::Normal&gt;);
-	pcl::NormalEstimationOMP&lt;pcl::PointXYZRGB, pcl::Normal&gt; normal_estimation;
-	normal_estimation.setNumberOfThreads(in_ompnum_threads);
-	normal_estimation.setInputCloud (pointcloud_);
-	normal_estimation.setSearchMethod (norm_tree);
-	normal_estimation.setViewPoint (std::numeric_limits&lt;float&gt;::max (), std::numeric_limits&lt;float&gt;::max (),std::numeric_limits&lt;float&gt;::max ());
-	normal_estimation.setRadiusSearch (in_normal_search_radius);
-	normal_estimation.compute (*normals);
-
-	pcl::PointCloud&lt;pcl::FPFHSignature33&gt;::Ptr fpfh_histograms (new pcl::PointCloud&lt;pcl::FPFHSignature33&gt; ());
-
-	pcl::FPFHEstimationOMP&lt;pcl::PointXYZRGB, pcl::Normal, pcl::FPFHSignature33&gt; fpfh;
-	fpfh.setNumberOfThreads(in_ompnum_threads);
-	fpfh.setInputCloud(pointcloud_);
-	fpfh.setInputNormals(normals);
-	fpfh.setSearchMethod(norm_tree);
-	fpfh.setRadiusSearch(in_fpfh_search_radius);
-	fpfh.compute(*fpfh_histograms);
-
-	float fpfh_max = std::numeric_limits&lt;float&gt;::min();
-	float fpfh_min = std::numeric_limits&lt;float&gt;::max();
-
-	for (unsigned int i=0; i&lt;fpfh_histograms-&gt;size(); i++) //for each point fpfh
-	{
-		for(unsigned int j=0; j&lt; cluster_fpfh_histogram.size(); j++)//sum each histogram's bin for all points, get min/max
-		{
-			cluster_fpfh_histogram[j]= cluster_fpfh_histogram[j] + fpfh_histograms-&gt;points[i].histogram[j];
-			if(cluster_fpfh_histogram[j] &lt; fpfh_min)
-				fpfh_min = cluster_fpfh_histogram[j];
-			if(cluster_fpfh_histogram[j] &gt; fpfh_max)
-				fpfh_max = cluster_fpfh_histogram[j];
-		}
-
-		float fpfh_dif = fpfh_max - fpfh_min;
-		for(unsigned int j=0; fpfh_dif &gt; 0 &amp;&amp; j &lt; cluster_fpfh_histogram.size(); j++)//substract the min from each and normalize
-		{
-			cluster_fpfh_histogram[j]= (cluster_fpfh_histogram[j] - fpfh_min)/fpfh_dif;
-		}
-	}
-
-	return cluster_fpfh_histogram;
+    std::vector&lt;float&gt; cluster_fpfh_histogram(33, 0.0);
+
+    pcl::search::KdTree&lt;pcl::PointXYZRGB&gt;::Ptr norm_tree(new pcl::search::KdTree&lt;pcl::PointXYZRGB&gt;);
+    if (pointcloud_-&gt;points.size() &gt; 0)
+        norm_tree-&gt;setInputCloud(pointcloud_);
+
+    pcl::PointCloud&lt;pcl::Normal&gt;::Ptr normals(new pcl::PointCloud&lt;pcl::Normal&gt;);
+    pcl::NormalEstimationOMP&lt;pcl::PointXYZRGB, pcl::Normal&gt; normal_estimation;
+    normal_estimation.setNumberOfThreads(in_ompnum_threads);
+    normal_estimation.setInputCloud(pointcloud_);
+    normal_estimation.setSearchMethod(norm_tree);
+    normal_estimation.setViewPoint(std::numeric_limits&lt;float&gt;::max(), std::numeric_limits&lt;float&gt;::max(),
+                                   std::numeric_limits&lt;float&gt;::max());
+    normal_estimation.setRadiusSearch(in_normal_search_radius);
+    normal_estimation.compute(*normals);
+
+    pcl::PointCloud&lt;pcl::FPFHSignature33&gt;::Ptr fpfh_histograms(new pcl::PointCloud&lt;pcl::FPFHSignature33&gt;());
+
+    pcl::FPFHEstimationOMP&lt;pcl::PointXYZRGB, pcl::Normal, pcl::FPFHSignature33&gt; fpfh;
+    fpfh.setNumberOfThreads(in_ompnum_threads);
+    fpfh.setInputCloud(pointcloud_);
+    fpfh.setInputNormals(normals);
+    fpfh.setSearchMethod(norm_tree);
+    fpfh.setRadiusSearch(in_fpfh_search_radius);
+    fpfh.compute(*fpfh_histograms);
+
+    float fpfh_max = std::numeric_limits&lt;float&gt;::min();
+    float fpfh_min = std::numeric_limits&lt;float&gt;::max();
+
+    for (unsigned int i = 0; i &lt; fpfh_histograms-&gt;size(); i++) //for each point fpfh
+    {
+        for (unsigned int j = 0;
+             j &lt; cluster_fpfh_histogram.size(); j++)//sum each histogram's bin for all points, get min/max
+        {
+            cluster_fpfh_histogram[j] = cluster_fpfh_histogram[j] + fpfh_histograms-&gt;points[i].histogram[j];
+            if (cluster_fpfh_histogram[j] &lt; fpfh_min)
+                fpfh_min = cluster_fpfh_histogram[j];
+            if (cluster_fpfh_histogram[j] &gt; fpfh_max)
+                fpfh_max = cluster_fpfh_histogram[j];
+        }
+
+        float fpfh_dif = fpfh_max - fpfh_min;
+        for (unsigned int j = 0;
+             fpfh_dif &gt; 0 &amp;&amp; j &lt; cluster_fpfh_histogram.size(); j++)//substract the min from each and normalize
+        {
+            cluster_fpfh_histogram[j] = (cluster_fpfh_histogram[j] - fpfh_min) / fpfh_dif;
+        }
+    }
+
+    return cluster_fpfh_histogram;
 }
 
 bool Cluster::IsValid()
 {
-	return valid_cluster_;
+    return valid_cluster_;
 }
 
 void Cluster::SetValidity(bool in_valid)
 {
-	valid_cluster_ = in_valid;
+    valid_cluster_ = in_valid;
 }
 
 int Cluster::GetId()
 {
-	return id_;
+    return id_;
 }
 
-Cluster::~Cluster() {
-	// TODO Auto-generated destructor stub
+Cluster::~Cluster()
+{
+    // TODO Auto-generated destructor stub
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="904" deleted_lines="902">
				<diff>@@ -51,6 +51,8 @@
 #include "autoware_msgs/centroids.h"
 #include "autoware_msgs/CloudCluster.h"
 #include "autoware_msgs/CloudClusterArray.h"
+#include "autoware_msgs/DetectedObject.h"
+#include "autoware_msgs/DetectedObjectArray.h"
 
 #include &lt;grid_map_ros/grid_map_ros.hpp&gt;
 #include &lt;grid_map_msgs/GridMap.h&gt;
@@ -68,73 +70,81 @@
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
 #include &lt;opencv2/core/version.hpp&gt;
+
 #if (CV_MAJOR_VERSION == 3)
-	#include "gencolors.cpp"
+#include "gencolors.cpp"
 #else
-	#include &lt;opencv2/contrib/contrib.hpp&gt;
+
+#include &lt;opencv2/contrib/contrib.hpp&gt;
+#include &lt;autoware_msgs/DetectedObjectArray.h&gt;
+
 #endif
 
 
 #include "cluster.h"
 
 #ifdef GPU_CLUSTERING
-	#include "gpu_euclidean_clustering.h"
+
+#include "gpu_euclidean_clustering.h"
+
 #endif
 
 using namespace cv;
 
-ros::Publisher      _pub_cluster_cloud;
-ros::Publisher      _pub_ground_cloud;
-ros::Publisher      _centroid_pub;
-ros::Publisher      _marker_pub;
-ros::Publisher      _pub_clusters_message;
-ros::Publisher      _pub_text_pictogram;
+ros::Publisher _pub_cluster_cloud;
+ros::Publisher _pub_ground_cloud;
+ros::Publisher _centroid_pub;
+ros::Publisher _marker_pub;
+ros::Publisher _pub_clusters_message;
+ros::Publisher _pub_text_pictogram;
+
+ros::Publisher _pub_points_lanes_cloud;
+ros::Publisher _pub_jsk_boundingboxes;
+ros::Publisher _pub_jsk_hulls;
 
-ros::Publisher      _pub_points_lanes_cloud;
-ros::Publisher      _pub_jsk_boundingboxes;
-ros::Publisher      _pub_jsk_hulls;
+ros::Publisher _pub_grid_map;
 
-ros::Publisher      _pub_grid_map;
+ros::Publisher _pub_detected_objects;
 
-ros::ServiceClient  _vectormap_server;
+ros::ServiceClient _vectormap_server;
 
-std_msgs::Header    _velodyne_header;
+std_msgs::Header _velodyne_header;
 
-std::string         _output_frame;
-std::string         _vectormap_frame;
-std::string         _gridmap_layer;
+std::string _output_frame;
+std::string _vectormap_frame;
+std::string _gridmap_layer;
 
-grid_map::GridMap   _wayarea_gridmap;
+grid_map::GridMap _wayarea_gridmap;
 
-const int           _grid_min_value = 0;
-const int           _grid_max_value = 255;
-static int          _gridmap_no_road_value;
+const int _grid_min_value = 0;
+const int _grid_max_value = 255;
+static int _gridmap_no_road_value;
 
-static bool         _velodyne_transform_available;
-static bool         _downsample_cloud;
-static bool         _pose_estimation;
-static double       _leaf_size;
-static int          _cluster_size_min;
-static int          _cluster_size_max;
+static bool _velodyne_transform_available;
+static bool _downsample_cloud;
+static bool _pose_estimation;
+static double _leaf_size;
+static int _cluster_size_min;
+static int _cluster_size_max;
 
-static bool         _remove_ground;	//only ground
+static bool _remove_ground;    //only ground
 
-static bool         _using_sensor_cloud;
-static bool         _use_diffnormals;
-static bool         _use_vector_map;
+static bool _using_sensor_cloud;
+static bool _use_diffnormals;
+static bool _use_vector_map;
 
-static double       _clip_min_height;
-static double       _clip_max_height;
+static double _clip_min_height;
+static double _clip_max_height;
 
-static bool         _keep_lanes;
-static double       _keep_lane_left_distance;
-static double       _keep_lane_right_distance;
+static bool _keep_lanes;
+static double _keep_lane_left_distance;
+static double _keep_lane_right_distance;
 
-static double       _max_boundingbox_side;
-static double       _remove_points_upto;
-static double       _cluster_merge_threshold;
+static double _max_boundingbox_side;
+static double _remove_points_upto;
+static double _cluster_merge_threshold;
 
-static bool         _use_gpu;
+static bool _use_gpu;
 static std::chrono::system_clock::time_point _start, _end;
 
 std::vector&lt;std::vector&lt;geometry_msgs::Point&gt;&gt; _way_area_points;
@@ -145,840 +155,833 @@ visualization_msgs::Marker _visualization_marker;
 std::vector&lt;double&gt; _clustering_thresholds;
 std::vector&lt;double&gt; _clustering_distances;
 
-tf::StampedTransform* _transform;
-tf::StampedTransform* _velodyne_output_transform;
-tf::TransformListener* _transform_listener;
-tf::TransformListener* _vectormap_transform_listener;
+tf::StampedTransform *_transform;
+tf::StampedTransform *_velodyne_output_transform;
+tf::TransformListener *_transform_listener;
+tf::TransformListener *_vectormap_transform_listener;
 
-tf::StampedTransform findTransform(const std::string&amp; in_target_frame, const std::string&amp; in_source_frame)
-{
-	tf::StampedTransform transform;
+tf::StampedTransform findTransform(const std::string &amp;in_target_frame, const std::string &amp;in_source_frame) {
+    tf::StampedTransform transform;
 
-	try
-	{
-		// What time should we use?
-		_vectormap_transform_listener-&gt;lookupTransform(in_target_frame, in_source_frame, ros::Time(0), transform);
-	}
-	catch (tf::TransformException ex)
-	{
-		ROS_ERROR("%s", ex.what());
-		return transform;
-	}
+    try {
+        // What time should we use?
+        _vectormap_transform_listener-&gt;lookupTransform(in_target_frame, in_source_frame, ros::Time(0), transform);
+    }
+    catch (tf::TransformException ex) {
+        ROS_ERROR("%s", ex.what());
+        return transform;
+    }
 
-	return transform;
+    return transform;
 }
 
-geometry_msgs::Point transformPoint(const geometry_msgs::Point &amp;point, const tf::Transform &amp;tf)
-{
-	tf::Point tf_point;
-	tf::pointMsgToTF(point, tf_point);
+geometry_msgs::Point transformPoint(const geometry_msgs::Point &amp;point, const tf::Transform &amp;tf) {
+    tf::Point tf_point;
+    tf::pointMsgToTF(point, tf_point);
 
-	tf_point = tf * tf_point;
+    tf_point = tf * tf_point;
 
-	geometry_msgs::Point ros_point;
-	tf::pointTFToMsg(tf_point, ros_point);
+    geometry_msgs::Point ros_point;
+    tf::pointTFToMsg(tf_point, ros_point);
 
-	return ros_point;
+    return ros_point;
 }
 
-bool checkPointInGrid(const grid_map::GridMap&amp; in_grid_map, const cv::Mat&amp; in_grid_image, const geometry_msgs::Point&amp; in_point)
-{
-	// calculate out_grid_map position
-	grid_map::Position map_pos = in_grid_map.getPosition();
-	double origin_x_offset = in_grid_map.getLength().x() / 2.0 - map_pos.x();
-	double origin_y_offset = in_grid_map.getLength().y() / 2.0 - map_pos.y();
-	// coordinate conversion for cv image
-	double cv_x = (in_grid_map.getLength().y() - origin_y_offset - in_point.y) / in_grid_map.getResolution();
-	double cv_y = (in_grid_map.getLength().x() - origin_x_offset - in_point.x) / in_grid_map.getResolution();
-
-	//check coords are inside the gridmap
-	if(cv_x &lt; 0 || cv_x &gt; in_grid_image.cols || cv_y &lt; 0 || cv_y &gt; in_grid_image.rows)
-	{
-		return false;
-	}
-
-	//_gridmap_no_road_value if road
-	if(in_grid_image.at&lt;uchar&gt;(cv_y, cv_x) != _gridmap_no_road_value)
-	{
-		return true;
-	}
-
-	return false;
+bool checkPointInGrid(const grid_map::GridMap &amp;in_grid_map, const cv::Mat &amp;in_grid_image,
+                      const geometry_msgs::Point &amp;in_point) {
+    // calculate out_grid_map position
+    grid_map::Position map_pos = in_grid_map.getPosition();
+    double origin_x_offset = in_grid_map.getLength().x() / 2.0 - map_pos.x();
+    double origin_y_offset = in_grid_map.getLength().y() / 2.0 - map_pos.y();
+    // coordinate conversion for cv image
+    double cv_x = (in_grid_map.getLength().y() - origin_y_offset - in_point.y) / in_grid_map.getResolution();
+    double cv_y = (in_grid_map.getLength().x() - origin_x_offset - in_point.x) / in_grid_map.getResolution();
+
+    //check coords are inside the gridmap
+    if (cv_x &lt; 0 || cv_x &gt; in_grid_image.cols || cv_y &lt; 0 || cv_y &gt; in_grid_image.rows) {
+        return false;
+    }
+
+    //_gridmap_no_road_value if road
+    if (in_grid_image.at&lt;uchar&gt;(cv_y, cv_x) != _gridmap_no_road_value) {
+        return true;
+    }
+
+    return false;
 }
 
-void transformBoundingBox(const jsk_recognition_msgs::BoundingBox&amp; in_boundingbox, jsk_recognition_msgs::BoundingBox&amp; out_boundingbox, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
-{
-	geometry_msgs::PoseStamped pose_in, pose_out;
-	pose_in.header = in_header;
-	pose_in.pose = in_boundingbox.pose;
-	try
-	{
-		_transform_listener-&gt;transformPose(in_target_frame, ros::Time(), pose_in, in_header.frame_id,  pose_out);
-	}
-	catch (tf::TransformException &amp;ex)
-	{
-		ROS_ERROR("transformBoundingBox: %s",ex.what());
-	}
-	out_boundingbox.pose = pose_out.pose;
-	out_boundingbox.header = in_header;
-	out_boundingbox.header.frame_id = in_target_frame;
-	out_boundingbox.dimensions = in_boundingbox.dimensions;
-	out_boundingbox.value = in_boundingbox.value;
-	out_boundingbox.label = in_boundingbox.label;
+void transformBoundingBox(const jsk_recognition_msgs::BoundingBox &amp;in_boundingbox,
+                          jsk_recognition_msgs::BoundingBox &amp;out_boundingbox, const std::string &amp;in_target_frame,
+                          const std_msgs::Header &amp;in_header) {
+    geometry_msgs::PoseStamped pose_in, pose_out;
+    pose_in.header = in_header;
+    pose_in.pose = in_boundingbox.pose;
+    try {
+        _transform_listener-&gt;transformPose(in_target_frame, ros::Time(), pose_in, in_header.frame_id, pose_out);
+    }
+    catch (tf::TransformException &amp;ex) {
+        ROS_ERROR("transformBoundingBox: %s", ex.what());
+    }
+    out_boundingbox.pose = pose_out.pose;
+    out_boundingbox.header = in_header;
+    out_boundingbox.header.frame_id = in_target_frame;
+    out_boundingbox.dimensions = in_boundingbox.dimensions;
+    out_boundingbox.value = in_boundingbox.value;
+    out_boundingbox.label = in_boundingbox.label;
 }
 
-void publishCloudClusters(const ros::Publisher* in_publisher, const autoware_msgs::CloudClusterArray&amp; in_clusters, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
+void publishDetectedObjects(const autoware_msgs::CloudClusterArray &amp;in_clusters)
 {
-	if (in_target_frame!=in_header.frame_id)
-	{
-		autoware_msgs::CloudClusterArray clusters_transformed;
-		clusters_transformed.header = in_header;
-		clusters_transformed.header.frame_id = in_target_frame;
-		for (auto i=in_clusters.clusters.begin(); i!= in_clusters.clusters.end(); i++)
-		{
-			autoware_msgs::CloudCluster cluster_transformed;
-			cluster_transformed.header = in_header;
-			try
-			{
-				_transform_listener-&gt;lookupTransform(in_target_frame, _velodyne_header.frame_id,
-										ros::Time(), *_transform);
-				pcl_ros::transformPointCloud(in_target_frame, *_transform, i-&gt;cloud, cluster_transformed.cloud);
-				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;min_point, in_header.frame_id, cluster_transformed.min_point);
-				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;max_point, in_header.frame_id, cluster_transformed.max_point);
-				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;avg_point, in_header.frame_id, cluster_transformed.avg_point);
-				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;centroid_point, in_header.frame_id, cluster_transformed.centroid_point);
-
-				cluster_transformed.dimensions = i-&gt;dimensions;
-				cluster_transformed.eigen_values = i-&gt;eigen_values;
-				cluster_transformed.eigen_vectors = i-&gt;eigen_vectors;
+    autoware_msgs::DetectedObjectArray detected_objects;
+    detected_objects.header = in_clusters.header;
+
+    for (auto i=0; i&lt; in_clusters.clusters.size(); i++)
+    {
+        autoware_msgs::DetectedObject detected_object;
+        detected_object.header = in_clusters.header;
+        detected_object.label = "unknown";
+        detected_object.id = i;
+        detected_object.score = 1.;
+        detected_object.space_frame = in_clusters.header.frame_id;
+        detected_object.pose = in_clusters.clusters[i].bounding_box.pose;
+        detected_object.dimensions = in_clusters.clusters[i].dimensions;
+        detected_object.pointcloud = in_clusters.clusters[i].cloud;
+        detected_object.convex_hull = in_clusters.clusters[i].convex_hull;
+        detected_object.color.r = 0.;
+        detected_object.color.g = 1.;
+        detected_object.color.b = 0.;
+        detected_object.color.a = 1.;
+
+        detected_objects.objects.push_back(detected_object);
+    }
+    _pub_detected_objects.publish(detected_objects);
+}
 
-				transformBoundingBox(i-&gt;bounding_box, cluster_transformed.bounding_box, in_target_frame, in_header);
+void publishCloudClusters(const ros::Publisher *in_publisher, const autoware_msgs::CloudClusterArray &amp;in_clusters,
+                          const std::string &amp;in_target_frame, const std_msgs::Header &amp;in_header) {
+    if (in_target_frame != in_header.frame_id) {
+        autoware_msgs::CloudClusterArray clusters_transformed;
+        clusters_transformed.header = in_header;
+        clusters_transformed.header.frame_id = in_target_frame;
+        for (auto i = in_clusters.clusters.begin(); i != in_clusters.clusters.end(); i++) {
+            autoware_msgs::CloudCluster cluster_transformed;
+            cluster_transformed.header = in_header;
+            try {
+                _transform_listener-&gt;lookupTransform(in_target_frame, _velodyne_header.frame_id,
+                                                     ros::Time(), *_transform);
+                pcl_ros::transformPointCloud(in_target_frame, *_transform, i-&gt;cloud, cluster_transformed.cloud);
+                _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;min_point, in_header.frame_id,
+                                                    cluster_transformed.min_point);
+                _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;max_point, in_header.frame_id,
+                                                    cluster_transformed.max_point);
+                _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;avg_point, in_header.frame_id,
+                                                    cluster_transformed.avg_point);
+                _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;centroid_point, in_header.frame_id,
+                                                    cluster_transformed.centroid_point);
+
+                cluster_transformed.dimensions = i-&gt;dimensions;
+                cluster_transformed.eigen_values = i-&gt;eigen_values;
+                cluster_transformed.eigen_vectors = i-&gt;eigen_vectors;
+
+                transformBoundingBox(i-&gt;bounding_box, cluster_transformed.bounding_box, in_target_frame, in_header);
+
+                clusters_transformed.clusters.push_back(cluster_transformed);
+            }
+            catch (tf::TransformException &amp;ex) {
+                ROS_ERROR("publishCloudClusters: %s", ex.what());
+            }
+        }
+        in_publisher-&gt;publish(clusters_transformed);
+        publishDetectedObjects(clusters_transformed);
+    } else {
+        in_publisher-&gt;publish(in_clusters);
+        publishDetectedObjects(in_clusters);
+    }
 
-				clusters_transformed.clusters.push_back(cluster_transformed);
-			}
-			catch (tf::TransformException &amp;ex)
-			{
-				ROS_ERROR("publishCloudClusters: %s",ex.what());
-			}
-		}
-		in_publisher-&gt;publish(clusters_transformed);
-	}
-	else
-	{
-		in_publisher-&gt;publish(in_clusters);
-	}
 }
 
-void publishCentroids(const ros::Publisher* in_publisher, const autoware_msgs::centroids&amp; in_centroids, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
-{
-	if (in_target_frame!=in_header.frame_id)
-	{
-		autoware_msgs::centroids centroids_transformed;
-		centroids_transformed.header = in_header;
-		centroids_transformed.header.frame_id = in_target_frame;
-		for (auto i=centroids_transformed.points.begin(); i!= centroids_transformed.points.end(); i++)
-		{
-			geometry_msgs::PointStamped centroid_in, centroid_out;
-			centroid_in.header = in_header;
-			centroid_in.point = *i;
-			try
-			{
-				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), centroid_in, in_header.frame_id, centroid_out);
-
-				centroids_transformed.points.push_back(centroid_out.point);
-			}
-			catch (tf::TransformException &amp;ex)
-			{
-				ROS_ERROR("publishCentroids: %s",ex.what());
-			}
-		}
-		in_publisher-&gt;publish(centroids_transformed);
-	}
-	else
-	{
-		in_publisher-&gt;publish(in_centroids);
-	}
+void publishCentroids(const ros::Publisher *in_publisher, const autoware_msgs::centroids &amp;in_centroids,
+                      const std::string &amp;in_target_frame, const std_msgs::Header &amp;in_header) {
+    if (in_target_frame != in_header.frame_id) {
+        autoware_msgs::centroids centroids_transformed;
+        centroids_transformed.header = in_header;
+        centroids_transformed.header.frame_id = in_target_frame;
+        for (auto i = centroids_transformed.points.begin(); i != centroids_transformed.points.end(); i++) {
+            geometry_msgs::PointStamped centroid_in, centroid_out;
+            centroid_in.header = in_header;
+            centroid_in.point = *i;
+            try {
+                _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), centroid_in, in_header.frame_id,
+                                                    centroid_out);
+
+                centroids_transformed.points.push_back(centroid_out.point);
+            }
+            catch (tf::TransformException &amp;ex) {
+                ROS_ERROR("publishCentroids: %s", ex.what());
+            }
+        }
+        in_publisher-&gt;publish(centroids_transformed);
+    } else {
+        in_publisher-&gt;publish(in_centroids);
+    }
 }
 
-void publishBoundingBoxArray(const ros::Publisher* in_publisher, const jsk_recognition_msgs::BoundingBoxArray&amp; in_boundingbox_array, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
-{
-	if (in_target_frame!=in_header.frame_id)
-	{
-		jsk_recognition_msgs::BoundingBoxArray boundingboxes_transformed;
-		boundingboxes_transformed.header = in_header;
-		boundingboxes_transformed.header.frame_id = in_target_frame;
-		for (auto i=in_boundingbox_array.boxes.begin(); i!= in_boundingbox_array.boxes.end(); i++)
-		{
-			jsk_recognition_msgs::BoundingBox boundingbox_transformed;
-			transformBoundingBox(*i, boundingbox_transformed, in_target_frame, in_header);
-			boundingboxes_transformed.boxes.push_back(boundingbox_transformed);
-		}
-		in_publisher-&gt;publish(boundingboxes_transformed);
-	}
-	else
-	{
-		in_publisher-&gt;publish(in_boundingbox_array);
-	}
+void publishBoundingBoxArray(const ros::Publisher *in_publisher,
+                             const jsk_recognition_msgs::BoundingBoxArray &amp;in_boundingbox_array,
+                             const std::string &amp;in_target_frame, const std_msgs::Header &amp;in_header) {
+    if (in_target_frame != in_header.frame_id) {
+        jsk_recognition_msgs::BoundingBoxArray boundingboxes_transformed;
+        boundingboxes_transformed.header = in_header;
+        boundingboxes_transformed.header.frame_id = in_target_frame;
+        for (auto i = in_boundingbox_array.boxes.begin(); i != in_boundingbox_array.boxes.end(); i++) {
+            jsk_recognition_msgs::BoundingBox boundingbox_transformed;
+            transformBoundingBox(*i, boundingbox_transformed, in_target_frame, in_header);
+            boundingboxes_transformed.boxes.push_back(boundingbox_transformed);
+        }
+        in_publisher-&gt;publish(boundingboxes_transformed);
+    } else {
+        in_publisher-&gt;publish(in_boundingbox_array);
+    }
 }
 
-void publishCloud(const ros::Publisher* in_publisher, const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_to_publish_ptr)
-{
-	sensor_msgs::PointCloud2 cloud_msg;
-	pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
-	cloud_msg.header=_velodyne_header;
-	in_publisher-&gt;publish(cloud_msg);
+void
+publishCloud(const ros::Publisher *in_publisher, const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_to_publish_ptr) {
+    sensor_msgs::PointCloud2 cloud_msg;
+    pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
+    cloud_msg.header = _velodyne_header;
+    in_publisher-&gt;publish(cloud_msg);
 }
 
-void publishColorCloud(const ros::Publisher* in_publisher, const pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr in_cloud_to_publish_ptr)
-{
-	sensor_msgs::PointCloud2 cloud_msg;
-	pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
-	cloud_msg.header=_velodyne_header;
-	in_publisher-&gt;publish(cloud_msg);
+void publishColorCloud(const ros::Publisher *in_publisher,
+                       const pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr in_cloud_to_publish_ptr) {
+    sensor_msgs::PointCloud2 cloud_msg;
+    pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
+    cloud_msg.header = _velodyne_header;
+    in_publisher-&gt;publish(cloud_msg);
 }
 
 void keepLanePoints(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
-					pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr,
-					float in_left_lane_threshold = 1.5,
-					float in_right_lane_threshold = 1.5)
-{
-	pcl::PointIndices::Ptr far_indices (new pcl::PointIndices);
-	for(unsigned int i=0; i&lt; in_cloud_ptr-&gt;points.size(); i++)
-	{
-		pcl::PointXYZ current_point;
-		current_point.x=in_cloud_ptr-&gt;points[i].x;
-		current_point.y=in_cloud_ptr-&gt;points[i].y;
-		current_point.z=in_cloud_ptr-&gt;points[i].z;
-
-		if (
-				current_point.y &gt; (in_left_lane_threshold) || current_point.y &lt; -1.0*in_right_lane_threshold
-			)
-		{
-			far_indices-&gt;indices.push_back(i);
-		}
-	}
-	out_cloud_ptr-&gt;points.clear();
-	pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
-	extract.setInputCloud (in_cloud_ptr);
-	extract.setIndices(far_indices);
-	extract.setNegative(true);//true removes the indices, false leaves only the indices
-	extract.filter(*out_cloud_ptr);
+                    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr,
+                    float in_left_lane_threshold = 1.5,
+                    float in_right_lane_threshold = 1.5) {
+    pcl::PointIndices::Ptr far_indices(new pcl::PointIndices);
+    for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++) {
+        pcl::PointXYZ current_point;
+        current_point.x = in_cloud_ptr-&gt;points[i].x;
+        current_point.y = in_cloud_ptr-&gt;points[i].y;
+        current_point.z = in_cloud_ptr-&gt;points[i].z;
+
+        if (
+                current_point.y &gt; (in_left_lane_threshold) || current_point.y &lt; -1.0 * in_right_lane_threshold
+                ) {
+            far_indices-&gt;indices.push_back(i);
+        }
+    }
+    out_cloud_ptr-&gt;points.clear();
+    pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
+    extract.setInputCloud(in_cloud_ptr);
+    extract.setIndices(far_indices);
+    extract.setNegative(true);//true removes the indices, false leaves only the indices
+    extract.filter(*out_cloud_ptr);
 }
 
 #ifdef GPU_CLUSTERING
+
 std::vector&lt;ClusterPtr&gt; clusterAndColorGpu(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
-											pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
-											jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
-											autoware_msgs::centroids&amp; in_out_centroids,
-											double in_max_cluster_distance=0.5)
-{
-	std::vector&lt;ClusterPtr&gt; clusters;
+                                           pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
+                                           jsk_recognition_msgs::BoundingBoxArray &amp;in_out_boundingbox_array,
+                                           autoware_msgs::centroids &amp;in_out_centroids,
+                                           double in_max_cluster_distance = 0.5) {
+    std::vector&lt;ClusterPtr&gt; clusters;
 
-	//Convert input point cloud to vectors of x, y, and z
+    //Convert input point cloud to vectors of x, y, and z
 
-	int size = in_cloud_ptr-&gt;points.size();
+    int size = in_cloud_ptr-&gt;points.size();
 
-	if (size == 0)
-		return clusters;
+    if (size == 0)
+        return clusters;
 
-	float *tmp_x, *tmp_y, *tmp_z;
+    float *tmp_x, *tmp_y, *tmp_z;
 
-	tmp_x = (float *)malloc(sizeof(float) * size);
-	tmp_y = (float *)malloc(sizeof(float) * size);
-	tmp_z = (float *)malloc(sizeof(float) * size);
+    tmp_x = (float *) malloc(sizeof(float) * size);
+    tmp_y = (float *) malloc(sizeof(float) * size);
+    tmp_z = (float *) malloc(sizeof(float) * size);
 
-	for (int i = 0; i &lt; size; i++) {
-		pcl::PointXYZ tmp_point = in_cloud_ptr-&gt;at(i);
+    for (int i = 0; i &lt; size; i++) {
+        pcl::PointXYZ tmp_point = in_cloud_ptr-&gt;at(i);
 
-		tmp_x[i] = tmp_point.x;
-		tmp_y[i] = tmp_point.y;
-		tmp_z[i] = tmp_point.z;
-	}
+        tmp_x[i] = tmp_point.x;
+        tmp_y[i] = tmp_point.y;
+        tmp_z[i] = tmp_point.z;
+    }
 
-	GpuEuclideanCluster gecl_cluster;
+    GpuEuclideanCluster gecl_cluster;
 
-	gecl_cluster.setInputPoints(tmp_x, tmp_y, tmp_z, size);
-	gecl_cluster.setThreshold(in_max_cluster_distance);
-	gecl_cluster.setMinClusterPts (_cluster_size_min);
-	gecl_cluster.setMaxClusterPts (_cluster_size_max);
-	gecl_cluster.extractClusters();
-	std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; cluster_indices = gecl_cluster.getOutput();
+    gecl_cluster.setInputPoints(tmp_x, tmp_y, tmp_z, size);
+    gecl_cluster.setThreshold(in_max_cluster_distance);
+    gecl_cluster.setMinClusterPts(_cluster_size_min);
+    gecl_cluster.setMaxClusterPts(_cluster_size_max);
+    gecl_cluster.extractClusters();
+    std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; cluster_indices = gecl_cluster.getOutput();
 
-	unsigned int k = 0;
+    unsigned int k = 0;
 
-	for (auto it = cluster_indices.begin(); it != cluster_indices.end(); it++)
-	{
-		ClusterPtr cluster(new Cluster());
-		cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;points_in_cluster, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1], (int)_colors[k].val[2], "", _pose_estimation);
-		clusters.push_back(cluster);
+    for (auto it = cluster_indices.begin(); it != cluster_indices.end(); it++) {
+        ClusterPtr cluster(new Cluster());
+        cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;points_in_cluster, _velodyne_header, k, (int) _colors[k].val[0],
+                          (int) _colors[k].val[1], (int) _colors[k].val[2], "", _pose_estimation);
+        clusters.push_back(cluster);
 
-		k++;
-	}
+        k++;
+    }
 
-	free(tmp_x);
-	free(tmp_y);
-	free(tmp_z);
+    free(tmp_x);
+    free(tmp_y);
+    free(tmp_z);
 
-	return clusters;
+    return clusters;
 }
+
 #endif
 
 std::vector&lt;ClusterPtr&gt; clusterAndColor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
-		pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
-		jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
-		autoware_msgs::centroids&amp; in_out_centroids,
-		double in_max_cluster_distance=0.5)
-{
-	pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree (new pcl::search::KdTree&lt;pcl::PointXYZ&gt;);
-
-	//create 2d pc
-	pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_2d(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-	pcl::copyPointCloud(*in_cloud_ptr, *cloud_2d);
-	//make it flat
-	for (size_t i=0; i&lt;cloud_2d-&gt;points.size(); i++)
-	{
-		cloud_2d-&gt;points[i].z = 0;
-	}
-
-	if (cloud_2d-&gt;points.size() &gt; 0)
-		tree-&gt;setInputCloud (cloud_2d);
-
-	std::vector&lt;pcl::PointIndices&gt; cluster_indices;
-
-	//perform clustering on 2d cloud
-	pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;
-	ec.setClusterTolerance (in_max_cluster_distance); //
-	ec.setMinClusterSize (_cluster_size_min);
-	ec.setMaxClusterSize (_cluster_size_max);
-	ec.setSearchMethod(tree);
-	ec.setInputCloud (cloud_2d);
-	ec.extract (cluster_indices);
-	//use indices on 3d cloud
-
-	/*pcl::ConditionalEuclideanClustering&lt;pcl::PointXYZ&gt; cec (true);
-	cec.setInputCloud (in_cloud_ptr);
-	cec.setConditionFunction (&amp;independentDistance);
-	cec.setMinClusterSize (cluster_size_min);
-	cec.setMaxClusterSize (cluster_size_max);
-	cec.setClusterTolerance (_distance*2.0f);
-	cec.segment (cluster_indices);*/
-
-	/////////////////////////////////
-	//---	3. Color clustered points
-	/////////////////////////////////
-	unsigned int k = 0;
-	//pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr final_cluster (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
-
-	std::vector&lt;ClusterPtr&gt; clusters;
-	//pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud_cluster (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);//coord + color cluster
-	for (auto it = cluster_indices.begin(); it != cluster_indices.end(); ++it)
-	{
-		ClusterPtr cluster(new Cluster());
-		cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1], (int)_colors[k].val[2], "", _pose_estimation);
-		clusters.push_back(cluster);
-
-		k++;
-	}
-	//std::cout &lt;&lt; "Clusters: " &lt;&lt; k &lt;&lt; std::endl;
-	return clusters;
+                                        pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
+                                        jsk_recognition_msgs::BoundingBoxArray &amp;in_out_boundingbox_array,
+                                        autoware_msgs::centroids &amp;in_out_centroids,
+                                        double in_max_cluster_distance = 0.5) {
+    pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;);
+
+    //create 2d pc
+    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_2d(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+    pcl::copyPointCloud(*in_cloud_ptr, *cloud_2d);
+    //make it flat
+    for (size_t i = 0; i &lt; cloud_2d-&gt;points.size(); i++) {
+        cloud_2d-&gt;points[i].z = 0;
+    }
+
+    if (cloud_2d-&gt;points.size() &gt; 0)
+        tree-&gt;setInputCloud(cloud_2d);
+
+    std::vector&lt;pcl::PointIndices&gt; cluster_indices;
+
+    //perform clustering on 2d cloud
+    pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;
+    ec.setClusterTolerance(in_max_cluster_distance); //
+    ec.setMinClusterSize(_cluster_size_min);
+    ec.setMaxClusterSize(_cluster_size_max);
+    ec.setSearchMethod(tree);
+    ec.setInputCloud(cloud_2d);
+    ec.extract(cluster_indices);
+    //use indices on 3d cloud
+
+    /*pcl::ConditionalEuclideanClustering&lt;pcl::PointXYZ&gt; cec (true);
+    cec.setInputCloud (in_cloud_ptr);
+    cec.setConditionFunction (&amp;independentDistance);
+    cec.setMinClusterSize (cluster_size_min);
+    cec.setMaxClusterSize (cluster_size_max);
+    cec.setClusterTolerance (_distance*2.0f);
+    cec.segment (cluster_indices);*/
+
+    /////////////////////////////////
+    //---	3. Color clustered points
+    /////////////////////////////////
+    unsigned int k = 0;
+    //pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr final_cluster (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
+
+    std::vector&lt;ClusterPtr&gt; clusters;
+    //pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud_cluster (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);//coord + color cluster
+    for (auto it = cluster_indices.begin(); it != cluster_indices.end(); ++it) {
+        ClusterPtr cluster(new Cluster());
+        cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int) _colors[k].val[0],
+                          (int) _colors[k].val[1], (int) _colors[k].val[2], "", _pose_estimation);
+        clusters.push_back(cluster);
+
+        k++;
+    }
+    //std::cout &lt;&lt; "Clusters: " &lt;&lt; k &lt;&lt; std::endl;
+    return clusters;
 
 }
 
-void checkClusterMerge(size_t in_cluster_id, std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;bool&gt;&amp; in_out_visited_clusters, std::vector&lt;size_t&gt;&amp; out_merge_indices, double in_merge_threshold)
-{
-	//std::cout &lt;&lt; "checkClusterMerge" &lt;&lt; std::endl;
-	pcl::PointXYZ point_a = in_clusters[in_cluster_id]-&gt;GetCentroid();
-	for(size_t i=0; i&lt; in_clusters.size(); i++)
-	{
-		if (i != in_cluster_id &amp;&amp; !in_out_visited_clusters[i])
-		{
-			pcl::PointXYZ point_b = in_clusters[i]-&gt;GetCentroid();
-			double distance = sqrt( pow(point_b.x - point_a.x,2) + pow(point_b.y - point_a.y,2) );
-			if (distance &lt;= in_merge_threshold)
-			{
-				in_out_visited_clusters[i] = true;
-				out_merge_indices.push_back(i);
-				//std::cout &lt;&lt; "Merging " &lt;&lt; in_cluster_id &lt;&lt; " with " &lt;&lt; i &lt;&lt; " dist:" &lt;&lt; distance &lt;&lt; std::endl;
-				checkClusterMerge(i, in_clusters, in_out_visited_clusters, out_merge_indices, in_merge_threshold);
-			}
-		}
-	}
+void checkClusterMerge(size_t in_cluster_id, std::vector&lt;ClusterPtr&gt; &amp;in_clusters,
+                       std::vector&lt;bool&gt; &amp;in_out_visited_clusters, std::vector&lt;size_t&gt; &amp;out_merge_indices,
+                       double in_merge_threshold) {
+    //std::cout &lt;&lt; "checkClusterMerge" &lt;&lt; std::endl;
+    pcl::PointXYZ point_a = in_clusters[in_cluster_id]-&gt;GetCentroid();
+    for (size_t i = 0; i &lt; in_clusters.size(); i++) {
+        if (i != in_cluster_id &amp;&amp; !in_out_visited_clusters[i]) {
+            pcl::PointXYZ point_b = in_clusters[i]-&gt;GetCentroid();
+            double distance = sqrt(pow(point_b.x - point_a.x, 2) + pow(point_b.y - point_a.y, 2));
+            if (distance &lt;= in_merge_threshold) {
+                in_out_visited_clusters[i] = true;
+                out_merge_indices.push_back(i);
+                //std::cout &lt;&lt; "Merging " &lt;&lt; in_cluster_id &lt;&lt; " with " &lt;&lt; i &lt;&lt; " dist:" &lt;&lt; distance &lt;&lt; std::endl;
+                checkClusterMerge(i, in_clusters, in_out_visited_clusters, out_merge_indices, in_merge_threshold);
+            }
+        }
+    }
 }
 
-void mergeClusters(const std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;ClusterPtr&gt;&amp; out_clusters, std::vector&lt;size_t&gt; in_merge_indices, const size_t&amp; current_index, std::vector&lt;bool&gt;&amp; in_out_merged_clusters)
-{
-	//std::cout &lt;&lt; "mergeClusters:" &lt;&lt; in_merge_indices.size() &lt;&lt; std::endl;
-	pcl::PointCloud&lt;pcl::PointXYZRGB&gt; sum_cloud;
-	pcl::PointCloud&lt;pcl::PointXYZ&gt; mono_cloud;
-	ClusterPtr merged_cluster(new Cluster());
-	for (size_t i=0; i&lt;in_merge_indices.size(); i++)
-	{
-		sum_cloud += *(in_clusters[in_merge_indices[i]]-&gt;GetCloud());
-		in_out_merged_clusters[in_merge_indices[i]] = true;
-	}
-	std::vector&lt;int&gt; indices(sum_cloud.points.size(), 0);
-	for (size_t i=0; i&lt;sum_cloud.points.size(); i++)
-	{
-		indices[i]=i;
-	}
-
-	if (sum_cloud.points.size() &gt; 0)
-	{
-		pcl::copyPointCloud(sum_cloud, mono_cloud);
-		//std::cout &lt;&lt; "mergedClusters " &lt;&lt; sum_cloud.points.size() &lt;&lt; " mono:" &lt;&lt; mono_cloud.points.size() &lt;&lt; std::endl;
-		//cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1], (int)_colors[k].val[2], "", _pose_estimation);
-		merged_cluster-&gt;SetCloud(mono_cloud.makeShared(), indices, _velodyne_header, current_index,(int)_colors[current_index].val[0], (int)_colors[current_index].val[1], (int)_colors[current_index].val[2], "", _pose_estimation);
-		out_clusters.push_back(merged_cluster);
-	}
+void mergeClusters(const std::vector&lt;ClusterPtr&gt; &amp;in_clusters, std::vector&lt;ClusterPtr&gt; &amp;out_clusters,
+                   std::vector&lt;size_t&gt; in_merge_indices, const size_t &amp;current_index,
+                   std::vector&lt;bool&gt; &amp;in_out_merged_clusters) {
+    //std::cout &lt;&lt; "mergeClusters:" &lt;&lt; in_merge_indices.size() &lt;&lt; std::endl;
+    pcl::PointCloud&lt;pcl::PointXYZRGB&gt; sum_cloud;
+    pcl::PointCloud&lt;pcl::PointXYZ&gt; mono_cloud;
+    ClusterPtr merged_cluster(new Cluster());
+    for (size_t i = 0; i &lt; in_merge_indices.size(); i++) {
+        sum_cloud += *(in_clusters[in_merge_indices[i]]-&gt;GetCloud());
+        in_out_merged_clusters[in_merge_indices[i]] = true;
+    }
+    std::vector&lt;int&gt; indices(sum_cloud.points.size(), 0);
+    for (size_t i = 0; i &lt; sum_cloud.points.size(); i++) {
+        indices[i] = i;
+    }
+
+    if (sum_cloud.points.size() &gt; 0) {
+        pcl::copyPointCloud(sum_cloud, mono_cloud);
+        //std::cout &lt;&lt; "mergedClusters " &lt;&lt; sum_cloud.points.size() &lt;&lt; " mono:" &lt;&lt; mono_cloud.points.size() &lt;&lt; std::endl;
+        //cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1], (int)_colors[k].val[2], "", _pose_estimation);
+        merged_cluster-&gt;SetCloud(mono_cloud.makeShared(), indices, _velodyne_header, current_index,
+                                 (int) _colors[current_index].val[0], (int) _colors[current_index].val[1],
+                                 (int) _colors[current_index].val[2], "", _pose_estimation);
+        out_clusters.push_back(merged_cluster);
+    }
 }
 
-void checkAllForMerge(std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;ClusterPtr&gt;&amp; out_clusters, float in_merge_threshold)
-{
-	//std::cout &lt;&lt; "checkAllForMerge" &lt;&lt; std::endl;
-	std::vector&lt;bool&gt; visited_clusters(in_clusters.size(), false);
-	std::vector&lt;bool&gt; merged_clusters(in_clusters.size(), false);
-	size_t current_index=0;
-	for (size_t i = 0; i&lt; in_clusters.size(); i++)
-	{
-		if (!visited_clusters[i])
-		{
-			visited_clusters[i] = true;
-			std::vector&lt;size_t&gt; merge_indices;
-			checkClusterMerge(i, in_clusters, visited_clusters, merge_indices, in_merge_threshold);
-			mergeClusters(in_clusters, out_clusters, merge_indices, current_index++, merged_clusters);
-		}
-	}
-	for(size_t i =0; i&lt; in_clusters.size(); i++)
-	{
-		//check for clusters not merged, add them to the output
-		if (!merged_clusters[i])
-		{
-			out_clusters.push_back(in_clusters[i]);
-		}
-	}
-
-	//ClusterPtr cluster(new Cluster());
+void checkAllForMerge(std::vector&lt;ClusterPtr&gt; &amp;in_clusters, std::vector&lt;ClusterPtr&gt; &amp;out_clusters,
+                      float in_merge_threshold) {
+    //std::cout &lt;&lt; "checkAllForMerge" &lt;&lt; std::endl;
+    std::vector&lt;bool&gt; visited_clusters(in_clusters.size(), false);
+    std::vector&lt;bool&gt; merged_clusters(in_clusters.size(), false);
+    size_t current_index = 0;
+    for (size_t i = 0; i &lt; in_clusters.size(); i++) {
+        if (!visited_clusters[i]) {
+            visited_clusters[i] = true;
+            std::vector&lt;size_t&gt; merge_indices;
+            checkClusterMerge(i, in_clusters, visited_clusters, merge_indices, in_merge_threshold);
+            mergeClusters(in_clusters, out_clusters, merge_indices, current_index++, merged_clusters);
+        }
+    }
+    for (size_t i = 0; i &lt; in_clusters.size(); i++) {
+        //check for clusters not merged, add them to the output
+        if (!merged_clusters[i]) {
+            out_clusters.push_back(in_clusters[i]);
+        }
+    }
+
+    //ClusterPtr cluster(new Cluster());
 }
 
 void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
-		pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
-		jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
-		autoware_msgs::centroids&amp; in_out_centroids,
-		autoware_msgs::CloudClusterArray&amp; in_out_clusters,
-		jsk_recognition_msgs::PolygonArray&amp; in_out_polygon_array,
-		jsk_rviz_plugins::PictogramArray&amp; in_out_pictogram_array)
-{
-	//cluster the pointcloud according to the distance of the points using different thresholds (not only one for the entire pc)
-	//in this way, the points farther in the pc will also be clustered
-
-	//0 =&gt; 0-15m d=0.5
-	//1 =&gt; 15-30 d=1
-	//2 =&gt; 30-45 d=1.6
-	//3 =&gt; 45-60 d=2.1
-	//4 =&gt; &gt;60   d=2.6
-
-	std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr&gt; cloud_segments_array(5);
-
-	for(unsigned int i=0; i&lt;cloud_segments_array.size(); i++)
-	{
-		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr tmp_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-		cloud_segments_array[i] = tmp_cloud;
-	}
-
-	for (unsigned int i=0; i&lt;in_cloud_ptr-&gt;points.size(); i++)
-	{
-		pcl::PointXYZ current_point;
-		current_point.x = in_cloud_ptr-&gt;points[i].x;
-		current_point.y = in_cloud_ptr-&gt;points[i].y;
-		current_point.z = in_cloud_ptr-&gt;points[i].z;
-
-		float origin_distance = sqrt( pow(current_point.x,2) + pow(current_point.y,2) );
-
-		if 		(origin_distance &lt; _clustering_distances[0] )	{cloud_segments_array[0]-&gt;points.push_back (current_point);}
-		else if(origin_distance &lt; _clustering_distances[1])		{cloud_segments_array[1]-&gt;points.push_back (current_point);}
-		else if(origin_distance &lt; _clustering_distances[2])		{cloud_segments_array[2]-&gt;points.push_back (current_point);}
-		else if(origin_distance &lt; _clustering_distances[3])		{cloud_segments_array[3]-&gt;points.push_back (current_point);}
-		else													{cloud_segments_array[4]-&gt;points.push_back (current_point);}
-	}
-
-	std::vector &lt;ClusterPtr&gt; all_clusters;
-	for(unsigned int i=0; i&lt;cloud_segments_array.size(); i++)
-	{
+                       pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
+                       jsk_recognition_msgs::BoundingBoxArray &amp;in_out_boundingbox_array,
+                       autoware_msgs::centroids &amp;in_out_centroids,
+                       autoware_msgs::CloudClusterArray &amp;in_out_clusters,
+                       jsk_recognition_msgs::PolygonArray &amp;in_out_polygon_array,
+                       jsk_rviz_plugins::PictogramArray &amp;in_out_pictogram_array) {
+    //cluster the pointcloud according to the distance of the points using different thresholds (not only one for the entire pc)
+    //in this way, the points farther in the pc will also be clustered
+
+    //0 =&gt; 0-15m d=0.5
+    //1 =&gt; 15-30 d=1
+    //2 =&gt; 30-45 d=1.6
+    //3 =&gt; 45-60 d=2.1
+    //4 =&gt; &gt;60   d=2.6
+
+    std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr&gt; cloud_segments_array(5);
+
+    for (unsigned int i = 0; i &lt; cloud_segments_array.size(); i++) {
+        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr tmp_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+        cloud_segments_array[i] = tmp_cloud;
+    }
+
+    for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++) {
+        pcl::PointXYZ current_point;
+        current_point.x = in_cloud_ptr-&gt;points[i].x;
+        current_point.y = in_cloud_ptr-&gt;points[i].y;
+        current_point.z = in_cloud_ptr-&gt;points[i].z;
+
+        float origin_distance = sqrt(pow(current_point.x, 2) + pow(current_point.y, 2));
+
+        if (origin_distance &lt; _clustering_distances[0]) { cloud_segments_array[0]-&gt;points.push_back(current_point); }
+        else if (origin_distance &lt; _clustering_distances[1]) {
+            cloud_segments_array[1]-&gt;points.push_back(current_point);
+        }
+        else if (origin_distance &lt; _clustering_distances[2]) {
+            cloud_segments_array[2]-&gt;points.push_back(current_point);
+        }
+        else if (origin_distance &lt; _clustering_distances[3]) {
+            cloud_segments_array[3]-&gt;points.push_back(current_point);
+        }
+        else { cloud_segments_array[4]-&gt;points.push_back(current_point); }
+    }
+
+    std::vector&lt;ClusterPtr&gt; all_clusters;
+    for (unsigned int i = 0; i &lt; cloud_segments_array.size(); i++) {
 #ifdef GPU_CLUSTERING
-    std::vector&lt;ClusterPtr&gt; local_clusters;
-		if (_use_gpu) {
-			local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
-		} else {
-			local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
-		}
+        std::vector&lt;ClusterPtr&gt; local_clusters;
+        if (_use_gpu) {
+            local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
+                                                in_out_centroids, _clustering_thresholds[i]);
+        } else {
+            local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
+                                             in_out_centroids, _clustering_thresholds[i]);
+        }
 #else
-		std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
+        std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
 #endif
-		all_clusters.insert(all_clusters.end(), local_clusters.begin(), local_clusters.end());
-	}
-
-	//Clusters can be merged or checked in here
-	//....
-	//check for mergable clusters
-	std::vector&lt;ClusterPtr&gt; mid_clusters;
-	std::vector&lt;ClusterPtr&gt; final_clusters;
-
-	if (all_clusters.size() &gt; 0)
-		checkAllForMerge(all_clusters, mid_clusters, _cluster_merge_threshold);
-	else
-		mid_clusters = all_clusters;
-
-	if (mid_clusters.size() &gt; 0)
-			checkAllForMerge(mid_clusters, final_clusters, _cluster_merge_threshold);
-	else
-		final_clusters = mid_clusters;
-
-	tf::StampedTransform vectormap_transform;
-	if (_use_vector_map)
-	{
-		if (_wayarea_gridmap.exists(_gridmap_layer))
-		{
-			//check if centroids are inside the drivable area
-			cv::Mat grid_image;
-			grid_map::GridMapCvConverter::toImage&lt;unsigned char, 1&gt;(_wayarea_gridmap,
-			                                                        _gridmap_layer,
-			                                                        CV_8UC1,
-			                                                        _grid_min_value,
-			                                                        _grid_max_value,
-			                                                        grid_image);
+        all_clusters.insert(all_clusters.end(), local_clusters.begin(), local_clusters.end());
+    }
+
+    //Clusters can be merged or checked in here
+    //....
+    //check for mergable clusters
+    std::vector&lt;ClusterPtr&gt; mid_clusters;
+    std::vector&lt;ClusterPtr&gt; final_clusters;
+
+    if (all_clusters.size() &gt; 0)
+        checkAllForMerge(all_clusters, mid_clusters, _cluster_merge_threshold);
+    else
+        mid_clusters = all_clusters;
+
+    if (mid_clusters.size() &gt; 0)
+        checkAllForMerge(mid_clusters, final_clusters, _cluster_merge_threshold);
+    else
+        final_clusters = mid_clusters;
+
+    tf::StampedTransform vectormap_transform;
+    if (_use_vector_map) {
+        if (_wayarea_gridmap.exists(_gridmap_layer)) {
+            //check if centroids are inside the drivable area
+            cv::Mat grid_image;
+            grid_map::GridMapCvConverter::toImage&lt;unsigned char, 1&gt;(_wayarea_gridmap,
+                                                                    _gridmap_layer,
+                                                                    CV_8UC1,
+                                                                    _grid_min_value,
+                                                                    _grid_max_value,
+                                                                    grid_image);
 
 #pragma omp for
-			for (unsigned int i = 0; i &lt; final_clusters.size(); i++)
-			{
-				pcl::PointXYZ pcl_centroid = final_clusters[i]-&gt;GetCentroid();
-
-				geometry_msgs::Point original_centroid_point, final_centroid_point;
-				original_centroid_point.x = pcl_centroid.x;
-				original_centroid_point.y = pcl_centroid.y;
-				original_centroid_point.z = pcl_centroid.z;
-
-				if (_wayarea_gridmap.getFrameId() != _velodyne_header.frame_id)
-				{
-					tf::StampedTransform grid_sensor_tf = findTransform(_wayarea_gridmap.getFrameId(), _velodyne_header.frame_id);
-					final_centroid_point = transformPoint(original_centroid_point, grid_sensor_tf);
-				}
-				else
-				{
-					final_centroid_point = original_centroid_point;
-				}
-
-				bool point_in_grid = checkPointInGrid(_wayarea_gridmap, grid_image, final_centroid_point);
-				final_clusters[i]-&gt;SetValidity(point_in_grid);
-			}
-			//timer.stop();
-			//std::cout &lt;&lt; "vectormap filtering took " &lt;&lt; timer.getTimeMilli() &lt;&lt; " ms to check " &lt;&lt; final_clusters.size() &lt;&lt; std::endl;
-		}
-		else
-		{
-			ROS_INFO("%s layer not contained in the OccupancyGrid", _gridmap_layer.c_str());
-		}
-
-	}
-	//Get final PointCloud to be published
-	in_out_polygon_array.header = _velodyne_header;
-	in_out_pictogram_array.header = _velodyne_header;
-	for(unsigned int i=0; i&lt;final_clusters.size(); i++)
-	{
-		*out_cloud_ptr = *out_cloud_ptr + *(final_clusters[i]-&gt;GetCloud());
-
-		jsk_recognition_msgs::BoundingBox bounding_box = final_clusters[i]-&gt;GetBoundingBox();
-		geometry_msgs::PolygonStamped polygon = final_clusters[i]-&gt;GetPolygon();
-		jsk_rviz_plugins::Pictogram pictogram_cluster;
-		pictogram_cluster.header = _velodyne_header;
-
-		//PICTO
-		pictogram_cluster.mode = pictogram_cluster.STRING_MODE;
-		pictogram_cluster.pose.position.x = final_clusters[i]-&gt;GetMaxPoint().x;
-		pictogram_cluster.pose.position.y = final_clusters[i]-&gt;GetMaxPoint().y;
-		pictogram_cluster.pose.position.z = final_clusters[i]-&gt;GetMaxPoint().z;
-		tf::Quaternion quat(0.0, -0.7, 0.0, 0.7);
-		tf::quaternionTFToMsg(quat, pictogram_cluster.pose.orientation);
-		pictogram_cluster.size = 4;
-		std_msgs::ColorRGBA color;
-		color.a = 1; color.r = 1; color.g = 1; color.b = 1;
-		pictogram_cluster.color = color;
-		pictogram_cluster.character = std::to_string( i );
-		//PICTO
-
-		//pcl::PointXYZ min_point = final_clusters[i]-&gt;GetMinPoint();
-		//pcl::PointXYZ max_point = final_clusters[i]-&gt;GetMaxPoint();
-		pcl::PointXYZ center_point = final_clusters[i]-&gt;GetCentroid();
-		geometry_msgs::Point centroid;
-		centroid.x = center_point.x; centroid.y = center_point.y; centroid.z = center_point.z;
-		bounding_box.header = _velodyne_header;
-		polygon.header = _velodyne_header;
-
-		if (	final_clusters[i]-&gt;IsValid()
-				//&amp;&amp; bounding_box.dimensions.x &gt;0 &amp;&amp; bounding_box.dimensions.y &gt;0 &amp;&amp; bounding_box.dimensions.z &gt; 0
-				//&amp;&amp;	bounding_box.dimensions.x &lt; _max_boundingbox_side &amp;&amp; bounding_box.dimensions.y &lt; _max_boundingbox_side
-				)
-		{
-			in_out_boundingbox_array.boxes.push_back(bounding_box);
-			in_out_centroids.points.push_back(centroid);
-			_visualization_marker.points.push_back(centroid);
-
-			in_out_polygon_array.polygons.push_back(polygon);
-			in_out_pictogram_array.pictograms.push_back(pictogram_cluster);
-
-			autoware_msgs::CloudCluster cloud_cluster;
-			final_clusters[i]-&gt;ToRosMessage(_velodyne_header, cloud_cluster);
-			in_out_clusters.clusters.push_back(cloud_cluster);
-		}
-	}
-
-	for(size_t i=0; i&lt; in_out_polygon_array.polygons.size();i++)
-	{
-		in_out_polygon_array.labels.push_back(i);
-	}
+            for (unsigned int i = 0; i &lt; final_clusters.size(); i++) {
+                pcl::PointXYZ pcl_centroid = final_clusters[i]-&gt;GetCentroid();
+
+                geometry_msgs::Point original_centroid_point, final_centroid_point;
+                original_centroid_point.x = pcl_centroid.x;
+                original_centroid_point.y = pcl_centroid.y;
+                original_centroid_point.z = pcl_centroid.z;
+
+                if (_wayarea_gridmap.getFrameId() != _velodyne_header.frame_id) {
+                    tf::StampedTransform grid_sensor_tf = findTransform(_wayarea_gridmap.getFrameId(),
+                                                                        _velodyne_header.frame_id);
+                    final_centroid_point = transformPoint(original_centroid_point, grid_sensor_tf);
+                } else {
+                    final_centroid_point = original_centroid_point;
+                }
+
+                bool point_in_grid = checkPointInGrid(_wayarea_gridmap, grid_image, final_centroid_point);
+                final_clusters[i]-&gt;SetValidity(point_in_grid);
+            }
+            //timer.stop();
+            //std::cout &lt;&lt; "vectormap filtering took " &lt;&lt; timer.getTimeMilli() &lt;&lt; " ms to check " &lt;&lt; final_clusters.size() &lt;&lt; std::endl;
+        } else {
+            ROS_INFO("%s layer not contained in the OccupancyGrid", _gridmap_layer.c_str());
+        }
+
+    }
+    //Get final PointCloud to be published
+    in_out_polygon_array.header = _velodyne_header;
+    in_out_pictogram_array.header = _velodyne_header;
+    for (unsigned int i = 0; i &lt; final_clusters.size(); i++) {
+        *out_cloud_ptr = *out_cloud_ptr + *(final_clusters[i]-&gt;GetCloud());
+
+        jsk_recognition_msgs::BoundingBox bounding_box = final_clusters[i]-&gt;GetBoundingBox();
+        geometry_msgs::PolygonStamped polygon = final_clusters[i]-&gt;GetPolygon();
+        jsk_rviz_plugins::Pictogram pictogram_cluster;
+        pictogram_cluster.header = _velodyne_header;
+
+        //PICTO
+        pictogram_cluster.mode = pictogram_cluster.STRING_MODE;
+        pictogram_cluster.pose.position.x = final_clusters[i]-&gt;GetMaxPoint().x;
+        pictogram_cluster.pose.position.y = final_clusters[i]-&gt;GetMaxPoint().y;
+        pictogram_cluster.pose.position.z = final_clusters[i]-&gt;GetMaxPoint().z;
+        tf::Quaternion quat(0.0, -0.7, 0.0, 0.7);
+        tf::quaternionTFToMsg(quat, pictogram_cluster.pose.orientation);
+        pictogram_cluster.size = 4;
+        std_msgs::ColorRGBA color;
+        color.a = 1;
+        color.r = 1;
+        color.g = 1;
+        color.b = 1;
+        pictogram_cluster.color = color;
+        pictogram_cluster.character = std::to_string(i);
+        //PICTO
+
+        //pcl::PointXYZ min_point = final_clusters[i]-&gt;GetMinPoint();
+        //pcl::PointXYZ max_point = final_clusters[i]-&gt;GetMaxPoint();
+        pcl::PointXYZ center_point = final_clusters[i]-&gt;GetCentroid();
+        geometry_msgs::Point centroid;
+        centroid.x = center_point.x;
+        centroid.y = center_point.y;
+        centroid.z = center_point.z;
+        bounding_box.header = _velodyne_header;
+        polygon.header = _velodyne_header;
+
+        if (final_clusters[i]-&gt;IsValid()
+            //&amp;&amp; bounding_box.dimensions.x &gt;0 &amp;&amp; bounding_box.dimensions.y &gt;0 &amp;&amp; bounding_box.dimensions.z &gt; 0
+            //&amp;&amp;	bounding_box.dimensions.x &lt; _max_boundingbox_side &amp;&amp; bounding_box.dimensions.y &lt; _max_boundingbox_side
+                ) {
+            in_out_boundingbox_array.boxes.push_back(bounding_box);
+            in_out_centroids.points.push_back(centroid);
+            _visualization_marker.points.push_back(centroid);
+
+            in_out_polygon_array.polygons.push_back(polygon);
+            in_out_pictogram_array.pictograms.push_back(pictogram_cluster);
+
+            autoware_msgs::CloudCluster cloud_cluster;
+            final_clusters[i]-&gt;ToRosMessage(_velodyne_header, cloud_cluster);
+            in_out_clusters.clusters.push_back(cloud_cluster);
+        }
+    }
+
+    for (size_t i = 0; i &lt; in_out_polygon_array.polygons.size(); i++) {
+        in_out_polygon_array.labels.push_back(i);
+    }
 
 }
 
-void removeFloor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_nofloor_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_onlyfloor_cloud_ptr, float in_max_height=0.2, float in_floor_max_angle=0.1)
-{
-	/*pcl::PointIndicesPtr ground (new pcl::PointIndices);
-	// Create the filtering object
-	pcl::ProgressiveMorphologicalFilter&lt;pcl::PointXYZ&gt; pmf;
-	pmf.setInputCloud (in_cloud_ptr);
-	pmf.setMaxWindowSize (20);
-	pmf.setSlope (1.0f);
-	pmf.setInitialDistance (0.5f);
-	pmf.setMaxDistance (3.0f);
-	pmf.extract (ground-&gt;indices);
-
-	// Create the filtering object
-	pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
-	extract.setInputCloud (in_cloud_ptr);
-	extract.setIndices (ground);
-	extract.setNegative(true);//true removes the indices, false leaves only the indices
-	extract.filter(*out_nofloor_cloud_ptr);
-
-	//EXTRACT THE FLOOR FROM THE CLOUD
-	extract.setNegative(false);//true removes the indices, false leaves only the indices
-	extract.filter(*out_onlyfloor_cloud_ptr);*/
-
-	pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;
-	pcl::PointIndices::Ptr inliers (new pcl::PointIndices);
-	pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients);
-
-	seg.setOptimizeCoefficients (true);
-	seg.setModelType(pcl::SACMODEL_PERPENDICULAR_PLANE);
-	seg.setMethodType(pcl::SAC_RANSAC);
-	seg.setMaxIterations(100);
-	seg.setAxis(Eigen::Vector3f(0,0,1));
-	seg.setEpsAngle(in_floor_max_angle);
-
-	seg.setDistanceThreshold (in_max_height);//floor distance
-	seg.setOptimizeCoefficients(true);
-	seg.setInputCloud(in_cloud_ptr);
-	seg.segment(*inliers, *coefficients);
-	if (inliers-&gt;indices.size () == 0)
-	{
-		std::cout &lt;&lt; "Could not estimate a planar model for the given dataset." &lt;&lt; std::endl;
-	}
-
-	//REMOVE THE FLOOR FROM THE CLOUD
-	pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
-	extract.setInputCloud (in_cloud_ptr);
-	extract.setIndices(inliers);
-	extract.setNegative(true);//true removes the indices, false leaves only the indices
-	extract.filter(*out_nofloor_cloud_ptr);
-
-	//EXTRACT THE FLOOR FROM THE CLOUD
-	extract.setNegative(false);//true removes the indices, false leaves only the indices
-	extract.filter(*out_onlyfloor_cloud_ptr);
+void removeFloor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
+                 pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_nofloor_cloud_ptr,
+                 pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_onlyfloor_cloud_ptr, float in_max_height = 0.2,
+                 float in_floor_max_angle = 0.1) {
+    /*pcl::PointIndicesPtr ground (new pcl::PointIndices);
+    // Create the filtering object
+    pcl::ProgressiveMorphologicalFilter&lt;pcl::PointXYZ&gt; pmf;
+    pmf.setInputCloud (in_cloud_ptr);
+    pmf.setMaxWindowSize (20);
+    pmf.setSlope (1.0f);
+    pmf.setInitialDistance (0.5f);
+    pmf.setMaxDistance (3.0f);
+    pmf.extract (ground-&gt;indices);
+
+    // Create the filtering object
+    pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
+    extract.setInputCloud (in_cloud_ptr);
+    extract.setIndices (ground);
+    extract.setNegative(true);//true removes the indices, false leaves only the indices
+    extract.filter(*out_nofloor_cloud_ptr);
+
+    //EXTRACT THE FLOOR FROM THE CLOUD
+    extract.setNegative(false);//true removes the indices, false leaves only the indices
+    extract.filter(*out_onlyfloor_cloud_ptr);*/
+
+    pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;
+    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
+    pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);
+
+    seg.setOptimizeCoefficients(true);
+    seg.setModelType(pcl::SACMODEL_PERPENDICULAR_PLANE);
+    seg.setMethodType(pcl::SAC_RANSAC);
+    seg.setMaxIterations(100);
+    seg.setAxis(Eigen::Vector3f(0, 0, 1));
+    seg.setEpsAngle(in_floor_max_angle);
+
+    seg.setDistanceThreshold(in_max_height);//floor distance
+    seg.setOptimizeCoefficients(true);
+    seg.setInputCloud(in_cloud_ptr);
+    seg.segment(*inliers, *coefficients);
+    if (inliers-&gt;indices.size() == 0) {
+        std::cout &lt;&lt; "Could not estimate a planar model for the given dataset." &lt;&lt; std::endl;
+    }
+
+    //REMOVE THE FLOOR FROM THE CLOUD
+    pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
+    extract.setInputCloud(in_cloud_ptr);
+    extract.setIndices(inliers);
+    extract.setNegative(true);//true removes the indices, false leaves only the indices
+    extract.filter(*out_nofloor_cloud_ptr);
+
+    //EXTRACT THE FLOOR FROM THE CLOUD
+    extract.setNegative(false);//true removes the indices, false leaves only the indices
+    extract.filter(*out_onlyfloor_cloud_ptr);
 }
 
-void downsampleCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, float in_leaf_size=0.2)
-{
-	pcl::VoxelGrid&lt;pcl::PointXYZ&gt; sor;
-	sor.setInputCloud(in_cloud_ptr);
-	sor.setLeafSize((float)in_leaf_size, (float)in_leaf_size, (float)in_leaf_size);
-	sor.filter(*out_cloud_ptr);
+void downsampleCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
+                     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, float in_leaf_size = 0.2) {
+    pcl::VoxelGrid&lt;pcl::PointXYZ&gt; sor;
+    sor.setInputCloud(in_cloud_ptr);
+    sor.setLeafSize((float) in_leaf_size, (float) in_leaf_size, (float) in_leaf_size);
+    sor.filter(*out_cloud_ptr);
 }
 
-void clipCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, float in_min_height=-1.3, float in_max_height=0.5)
-{
-	out_cloud_ptr-&gt;points.clear();
-	for (unsigned int i=0; i&lt;in_cloud_ptr-&gt;points.size(); i++)
-	{
-		if (in_cloud_ptr-&gt;points[i].z &gt;= in_min_height &amp;&amp;
-				in_cloud_ptr-&gt;points[i].z &lt;= in_max_height)
-		{
-			out_cloud_ptr-&gt;points.push_back(in_cloud_ptr-&gt;points[i]);
-		}
-	}
+void
+clipCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr,
+          float in_min_height = -1.3, float in_max_height = 0.5) {
+    out_cloud_ptr-&gt;points.clear();
+    for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++) {
+        if (in_cloud_ptr-&gt;points[i].z &gt;= in_min_height &amp;&amp;
+            in_cloud_ptr-&gt;points[i].z &lt;= in_max_height) {
+            out_cloud_ptr-&gt;points.push_back(in_cloud_ptr-&gt;points[i]);
+        }
+    }
 }
 
-void differenceNormalsSegmentation(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr)
-{
-	float small_scale=0.5;
-	float large_scale=2.0;
-	float angle_threshold=0.5;
-	pcl::search::Search&lt;pcl::PointXYZ&gt;::Ptr tree;
-	if (in_cloud_ptr-&gt;isOrganized ())
-	{
-		tree.reset (new pcl::search::OrganizedNeighbor&lt;pcl::PointXYZ&gt; ());
-	}
-	else
-	{
-		tree.reset (new pcl::search::KdTree&lt;pcl::PointXYZ&gt; (false));
-	}
+void differenceNormalsSegmentation(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
+                                   pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr) {
+    float small_scale = 0.5;
+    float large_scale = 2.0;
+    float angle_threshold = 0.5;
+    pcl::search::Search&lt;pcl::PointXYZ&gt;::Ptr tree;
+    if (in_cloud_ptr-&gt;isOrganized()) {
+        tree.reset(new pcl::search::OrganizedNeighbor&lt;pcl::PointXYZ&gt;());
+    } else {
+        tree.reset(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;(false));
+    }
 
-	// Set the input pointcloud for the search tree
-	tree-&gt;setInputCloud (in_cloud_ptr);
+    // Set the input pointcloud for the search tree
+    tree-&gt;setInputCloud(in_cloud_ptr);
 
-	pcl::NormalEstimationOMP&lt;pcl::PointXYZ, pcl::PointNormal&gt; normal_estimation;
-	//pcl::gpu::NormalEstimation&lt;pcl::PointXYZ, pcl::PointNormal&gt; normal_estimation;
-	normal_estimation.setInputCloud (in_cloud_ptr);
-	normal_estimation.setSearchMethod (tree);
+    pcl::NormalEstimationOMP&lt;pcl::PointXYZ, pcl::PointNormal&gt; normal_estimation;
+    //pcl::gpu::NormalEstimation&lt;pcl::PointXYZ, pcl::PointNormal&gt; normal_estimation;
+    normal_estimation.setInputCloud(in_cloud_ptr);
+    normal_estimation.setSearchMethod(tree);
 
-	normal_estimation.setViewPoint (std::numeric_limits&lt;float&gt;::max (), std::numeric_limits&lt;float&gt;::max (), std::numeric_limits&lt;float&gt;::max ());
+    normal_estimation.setViewPoint(std::numeric_limits&lt;float&gt;::max(), std::numeric_limits&lt;float&gt;::max(),
+                                   std::numeric_limits&lt;float&gt;::max());
 
-	pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr normals_small_scale (new pcl::PointCloud&lt;pcl::PointNormal&gt;);
-	pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr normals_large_scale (new pcl::PointCloud&lt;pcl::PointNormal&gt;);
+    pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr normals_small_scale(new pcl::PointCloud&lt;pcl::PointNormal&gt;);
+    pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr normals_large_scale(new pcl::PointCloud&lt;pcl::PointNormal&gt;);
 
-	normal_estimation.setRadiusSearch (small_scale);
-	normal_estimation.compute (*normals_small_scale);
+    normal_estimation.setRadiusSearch(small_scale);
+    normal_estimation.compute(*normals_small_scale);
 
-	normal_estimation.setRadiusSearch (large_scale);
-	normal_estimation.compute (*normals_large_scale);
+    normal_estimation.setRadiusSearch(large_scale);
+    normal_estimation.compute(*normals_large_scale);
 
-	pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr diffnormals_cloud (new pcl::PointCloud&lt;pcl::PointNormal&gt;);
-	pcl::copyPointCloud&lt;pcl::PointXYZ, pcl::PointNormal&gt;(*in_cloud_ptr, *diffnormals_cloud);
+    pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr diffnormals_cloud(new pcl::PointCloud&lt;pcl::PointNormal&gt;);
+    pcl::copyPointCloud&lt;pcl::PointXYZ, pcl::PointNormal&gt;(*in_cloud_ptr, *diffnormals_cloud);
 
-	// Create DoN operator
-	pcl::DifferenceOfNormalsEstimation&lt;pcl::PointXYZ, pcl::PointNormal, pcl::PointNormal&gt; diffnormals_estimator;
-	diffnormals_estimator.setInputCloud (in_cloud_ptr);
-	diffnormals_estimator.setNormalScaleLarge (normals_large_scale);
-	diffnormals_estimator.setNormalScaleSmall (normals_small_scale);
+    // Create DoN operator
+    pcl::DifferenceOfNormalsEstimation&lt;pcl::PointXYZ, pcl::PointNormal, pcl::PointNormal&gt; diffnormals_estimator;
+    diffnormals_estimator.setInputCloud(in_cloud_ptr);
+    diffnormals_estimator.setNormalScaleLarge(normals_large_scale);
+    diffnormals_estimator.setNormalScaleSmall(normals_small_scale);
 
-	diffnormals_estimator.initCompute();
+    diffnormals_estimator.initCompute();
 
-	diffnormals_estimator.computeFeature(*diffnormals_cloud);
+    diffnormals_estimator.computeFeature(*diffnormals_cloud);
 
-	pcl::ConditionOr&lt;pcl::PointNormal&gt;::Ptr range_cond (new pcl::ConditionOr&lt;pcl::PointNormal&gt;() );
-	range_cond-&gt;addComparison (pcl::FieldComparison&lt;pcl::PointNormal&gt;::ConstPtr (
-			new pcl::FieldComparison&lt;pcl::PointNormal&gt; ("curvature", pcl::ComparisonOps::GT, angle_threshold) )
-			);
-	// Build the filter
-	pcl::ConditionalRemoval&lt;pcl::PointNormal&gt; cond_removal;
-	cond_removal.setCondition(range_cond);
-	cond_removal.setInputCloud (diffnormals_cloud);
+    pcl::ConditionOr&lt;pcl::PointNormal&gt;::Ptr range_cond(new pcl::ConditionOr&lt;pcl::PointNormal&gt;());
+    range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointNormal&gt;::ConstPtr(
+            new pcl::FieldComparison&lt;pcl::PointNormal&gt;("curvature", pcl::ComparisonOps::GT, angle_threshold))
+    );
+    // Build the filter
+    pcl::ConditionalRemoval&lt;pcl::PointNormal&gt; cond_removal;
+    cond_removal.setCondition(range_cond);
+    cond_removal.setInputCloud(diffnormals_cloud);
 
-	pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr diffnormals_cloud_filtered (new pcl::PointCloud&lt;pcl::PointNormal&gt;);
+    pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr diffnormals_cloud_filtered(new pcl::PointCloud&lt;pcl::PointNormal&gt;);
 
-	// Apply filter
-	cond_removal.filter (*diffnormals_cloud_filtered);
+    // Apply filter
+    cond_removal.filter(*diffnormals_cloud_filtered);
 
-	pcl::copyPointCloud&lt;pcl::PointNormal, pcl::PointXYZ&gt;(*diffnormals_cloud, *out_cloud_ptr);
+    pcl::copyPointCloud&lt;pcl::PointNormal, pcl::PointXYZ&gt;(*diffnormals_cloud, *out_cloud_ptr);
 }
 
-void removePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, const double in_distance)
-{
-	out_cloud_ptr-&gt;points.clear();
-	for (unsigned int i=0; i&lt;in_cloud_ptr-&gt;points.size(); i++)
-	{
-		float origin_distance = sqrt( pow(in_cloud_ptr-&gt;points[i].x,2) + pow(in_cloud_ptr-&gt;points[i].y,2) );
-		if (origin_distance &gt; in_distance)
-		{
-			out_cloud_ptr-&gt;points.push_back(in_cloud_ptr-&gt;points[i]);
-		}
-	}
+void removePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
+                      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, const double in_distance) {
+    out_cloud_ptr-&gt;points.clear();
+    for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++) {
+        float origin_distance = sqrt(pow(in_cloud_ptr-&gt;points[i].x, 2) + pow(in_cloud_ptr-&gt;points[i].y, 2));
+        if (origin_distance &gt; in_distance) {
+            out_cloud_ptr-&gt;points.push_back(in_cloud_ptr-&gt;points[i]);
+        }
+    }
 }
 
-void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
-{
-	//_start = std::chrono::system_clock::now();
+void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr &amp;in_sensor_cloud) {
+    //_start = std::chrono::system_clock::now();
 
-	if (!_using_sensor_cloud)
-	{
-		_using_sensor_cloud = true;
+    if (!_using_sensor_cloud) {
+        _using_sensor_cloud = true;
 
-		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr current_sensor_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr removed_points_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr downsampled_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr inlanes_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr nofloor_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr onlyfloor_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr diffnormals_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr clipped_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-		pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr colored_clustered_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
+        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr current_sensor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr removed_points_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr downsampled_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr inlanes_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr nofloor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr onlyfloor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr diffnormals_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr clipped_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+        pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr colored_clustered_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
 
-		autoware_msgs::centroids centroids;
-		autoware_msgs::CloudClusterArray cloud_clusters;
-		jsk_recognition_msgs::BoundingBoxArray boundingbox_array;
-		jsk_recognition_msgs::PolygonArray polygon_array;
-		jsk_rviz_plugins::PictogramArray pictograms_array;
+        autoware_msgs::centroids centroids;
+        autoware_msgs::CloudClusterArray cloud_clusters;
+        jsk_recognition_msgs::BoundingBoxArray boundingbox_array;
+        jsk_recognition_msgs::PolygonArray polygon_array;
+        jsk_rviz_plugins::PictogramArray pictograms_array;
 
-		pcl::fromROSMsg(*in_sensor_cloud, *current_sensor_cloud_ptr);
+        pcl::fromROSMsg(*in_sensor_cloud, *current_sensor_cloud_ptr);
 
-		_velodyne_header = in_sensor_cloud-&gt;header;
+        _velodyne_header = in_sensor_cloud-&gt;header;
 
-		if (_remove_points_upto &gt; 0.0)
-		{
-			removePointsUpTo(current_sensor_cloud_ptr, removed_points_cloud_ptr, _remove_points_upto);
-		}
-		else
-			removed_points_cloud_ptr = current_sensor_cloud_ptr;
+        if (_remove_points_upto &gt; 0.0) {
+            removePointsUpTo(current_sensor_cloud_ptr, removed_points_cloud_ptr, _remove_points_upto);
+        } else
+            removed_points_cloud_ptr = current_sensor_cloud_ptr;
 
-		if (_downsample_cloud)
-			downsampleCloud(removed_points_cloud_ptr, downsampled_cloud_ptr, _leaf_size);
-		else
-			downsampled_cloud_ptr =removed_points_cloud_ptr;
+        if (_downsample_cloud)
+            downsampleCloud(removed_points_cloud_ptr, downsampled_cloud_ptr, _leaf_size);
+        else
+            downsampled_cloud_ptr = removed_points_cloud_ptr;
 
-		clipCloud(downsampled_cloud_ptr, clipped_cloud_ptr, _clip_min_height, _clip_max_height);
+        clipCloud(downsampled_cloud_ptr, clipped_cloud_ptr, _clip_min_height, _clip_max_height);
 
-		if(_keep_lanes)
-			keepLanePoints(clipped_cloud_ptr, inlanes_cloud_ptr, _keep_lane_left_distance, _keep_lane_right_distance);
-		else
-			inlanes_cloud_ptr = clipped_cloud_ptr;
+        if (_keep_lanes)
+            keepLanePoints(clipped_cloud_ptr, inlanes_cloud_ptr, _keep_lane_left_distance, _keep_lane_right_distance);
+        else
+            inlanes_cloud_ptr = clipped_cloud_ptr;
 
-		if(_remove_ground)
-		{
-			removeFloor(inlanes_cloud_ptr, nofloor_cloud_ptr, onlyfloor_cloud_ptr);
-			publishCloud(&amp;_pub_ground_cloud, onlyfloor_cloud_ptr);
-		}
-		else
-			nofloor_cloud_ptr = inlanes_cloud_ptr;
+        if (_remove_ground) {
+            removeFloor(inlanes_cloud_ptr, nofloor_cloud_ptr, onlyfloor_cloud_ptr);
+            publishCloud(&amp;_pub_ground_cloud, onlyfloor_cloud_ptr);
+        } else
+            nofloor_cloud_ptr = inlanes_cloud_ptr;
 
-		publishCloud(&amp;_pub_points_lanes_cloud, nofloor_cloud_ptr);
+        publishCloud(&amp;_pub_points_lanes_cloud, nofloor_cloud_ptr);
 
-		if (_use_diffnormals)
-			differenceNormalsSegmentation(nofloor_cloud_ptr, diffnormals_cloud_ptr);
-		else
-			diffnormals_cloud_ptr = nofloor_cloud_ptr;
+        if (_use_diffnormals)
+            differenceNormalsSegmentation(nofloor_cloud_ptr, diffnormals_cloud_ptr);
+        else
+            diffnormals_cloud_ptr = nofloor_cloud_ptr;
 
-		segmentByDistance(diffnormals_cloud_ptr, colored_clustered_cloud_ptr, boundingbox_array, centroids, cloud_clusters, polygon_array, pictograms_array);
+        segmentByDistance(diffnormals_cloud_ptr, colored_clustered_cloud_ptr, boundingbox_array, centroids,
+                          cloud_clusters, polygon_array, pictograms_array);
 
-		publishColorCloud(&amp;_pub_cluster_cloud, colored_clustered_cloud_ptr);
+        publishColorCloud(&amp;_pub_cluster_cloud, colored_clustered_cloud_ptr);
 
-		// Publish BB
-		boundingbox_array.header = _velodyne_header;
+        // Publish BB
+        boundingbox_array.header = _velodyne_header;
 
-		_pub_jsk_hulls.publish(polygon_array);//publish convex hulls
-		_pub_text_pictogram.publish(pictograms_array);//publish_ids
+        _pub_jsk_hulls.publish(polygon_array);//publish convex hulls
+        _pub_text_pictogram.publish(pictograms_array);//publish_ids
 
-		publishBoundingBoxArray(&amp;_pub_jsk_boundingboxes, boundingbox_array, _output_frame, _velodyne_header);
-		centroids.header = _velodyne_header;
+        publishBoundingBoxArray(&amp;_pub_jsk_boundingboxes, boundingbox_array, _output_frame, _velodyne_header);
+        centroids.header = _velodyne_header;
 
-		publishCentroids(&amp;_centroid_pub, centroids, _output_frame, _velodyne_header);
+        publishCentroids(&amp;_centroid_pub, centroids, _output_frame, _velodyne_header);
 
-		_marker_pub.publish(_visualization_marker);
-		_visualization_marker.points.clear();//transform? is it used?
-		cloud_clusters.header = _velodyne_header;
+        _marker_pub.publish(_visualization_marker);
+        _visualization_marker.points.clear();//transform? is it used?
+        cloud_clusters.header = _velodyne_header;
 
-		publishCloudClusters(&amp;_pub_clusters_message, cloud_clusters, _output_frame, _velodyne_header);
+        publishCloudClusters(&amp;_pub_clusters_message, cloud_clusters, _output_frame, _velodyne_header);
 
-		_using_sensor_cloud = false;
-	}
-	//_end = std::chrono::system_clock::now();
-	//double elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(_end-_start).count();
-	//ROS_INFO("Euclidean Clustering : %f", elapsed);
+        _using_sensor_cloud = false;
+    }
+    //_end = std::chrono::system_clock::now();
+    //double elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(_end-_start).count();
+    //ROS_INFO("Euclidean Clustering : %f", elapsed);
 }
 
 /*
@@ -1056,154 +1059,153 @@ void vectormap_callback(const visualization_msgs::MarkerArray::Ptr in_vectormap_
 	cv::waitKey(0);
 }*/
 
-void wayarea_gridmap_callback(const grid_map_msgs::GridMap&amp; message)
-{
-	grid_map::GridMapRosConverter::fromMessage(message, _wayarea_gridmap);
+void wayarea_gridmap_callback(const grid_map_msgs::GridMap &amp;message) {
+    grid_map::GridMapRosConverter::fromMessage(message, _wayarea_gridmap);
 }
 
-int main (int argc, char** argv)
-{
-	// Initialize ROS
-	ros::init (argc, argv, "euclidean_cluster");
+int main(int argc, char **argv) {
+    // Initialize ROS
+    ros::init(argc, argv, "euclidean_cluster");
 
-	ros::NodeHandle h;
-	ros::NodeHandle private_nh("~");
+    ros::NodeHandle h;
+    ros::NodeHandle private_nh("~");
 
-	tf::StampedTransform transform;
-	tf::TransformListener listener;
-	tf::TransformListener vectormap_tf_listener;
+    tf::StampedTransform transform;
+    tf::TransformListener listener;
+    tf::TransformListener vectormap_tf_listener;
 
-	_vectormap_transform_listener = &amp;vectormap_tf_listener;
-	_transform = &amp;transform;
-	_transform_listener = &amp;listener;
+    _vectormap_transform_listener = &amp;vectormap_tf_listener;
+    _transform = &amp;transform;
+    _transform_listener = &amp;listener;
 
 #if (CV_MAJOR_VERSION == 3)
-	generateColors(_colors, 100);
+    generateColors(_colors, 100);
 #else
-	cv::generateColors(_colors, 100);
+    cv::generateColors(_colors, 100);
 #endif
 
-	_pub_cluster_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_cluster",1);
-	_pub_ground_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_ground",1);
-	_centroid_pub = h.advertise&lt;autoware_msgs::centroids&gt;("/cluster_centroids",1);
-	_marker_pub = h.advertise&lt;visualization_msgs::Marker&gt;("centroid_marker",1);
-
-	_pub_points_lanes_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_lanes",1);
-	_pub_jsk_boundingboxes = h.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/bounding_boxes",1);
-	_pub_jsk_hulls = h.advertise&lt;jsk_recognition_msgs::PolygonArray&gt;("/cluster_hulls",1);
-	_pub_clusters_message = h.advertise&lt;autoware_msgs::CloudClusterArray&gt;("/cloud_clusters",1);
-	_pub_text_pictogram = h.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;("cluster_ids", 10); ROS_INFO("output pictograms topic: %s", "cluster_id");
-
-	_pub_grid_map = h.advertise&lt;grid_map_msgs::GridMap&gt;("grid_map_wayarea", 1, true);
-
-	std::string points_topic, gridmap_topic;
-
-	_using_sensor_cloud = false;
-
-	if (private_nh.getParam("points_node", points_topic))
-	{
-		ROS_INFO("euclidean_cluster &gt; Setting points node to %s", points_topic.c_str());
-	}
-	else
-	{
-		ROS_INFO("euclidean_cluster &gt; No points node received, defaulting to points_raw, you can use _points_node:=YOUR_TOPIC");
-		points_topic = "/points_raw";
-	}
-
-	_use_diffnormals = false;
-	if (private_nh.getParam("use_diffnormals", _use_diffnormals))
-	{
-		if (_use_diffnormals)
-			ROS_INFO("Euclidean Clustering: Applying difference of normals on clustering pipeline");
-		else
-			ROS_INFO("Euclidean Clustering: Difference of Normals will not be used.");
-	}
-
-	/* Initialize tuning parameter */
-	private_nh.param("downsample_cloud", _downsample_cloud, false);
-	ROS_INFO("downsample_cloud: %d", _downsample_cloud);
-	private_nh.param("remove_ground", _remove_ground, true);
-	ROS_INFO("remove_ground: %d", _remove_ground);
-	private_nh.param("leaf_size", _leaf_size, 0.1);
-	ROS_INFO("leaf_size: %f", _leaf_size);
-	private_nh.param("cluster_size_min", _cluster_size_min, 20);
-	ROS_INFO("cluster_size_min %d", _cluster_size_min);
-	private_nh.param("cluster_size_max", _cluster_size_max, 100000);
-	ROS_INFO("cluster_size_max: %d", _cluster_size_max);
-	private_nh.param("pose_estimation", _pose_estimation, false);
-	ROS_INFO("pose_estimation: %d", _pose_estimation);
-	private_nh.param("clip_min_height", _clip_min_height, -1.3);
-	ROS_INFO("clip_min_height: %f", _clip_min_height);
-	private_nh.param("clip_max_height", _clip_max_height, 0.5);
-	ROS_INFO("clip_max_height: %f", _clip_max_height);
-	private_nh.param("keep_lanes", _keep_lanes, false);
-	ROS_INFO("keep_lanes: %d", _keep_lanes);
-	private_nh.param("keep_lane_left_distance", _keep_lane_left_distance, 5.0);
-	ROS_INFO("keep_lane_left_distance: %f", _keep_lane_left_distance);
-	private_nh.param("keep_lane_right_distance", _keep_lane_right_distance, 5.0);
-	ROS_INFO("keep_lane_right_distance: %f", _keep_lane_right_distance);
-	private_nh.param("clustering_thresholds", _clustering_thresholds);
-	private_nh.param("clustering_distances", _clustering_distances);
-	private_nh.param("max_boundingbox_side", _max_boundingbox_side, 10.0);
-	ROS_INFO("max_boundingbox_side: %f", _max_boundingbox_side);
-	private_nh.param("cluster_merge_threshold", _cluster_merge_threshold, 1.5);
-	ROS_INFO("cluster_merge_threshold: %f", _cluster_merge_threshold);
-	private_nh.param&lt;std::string&gt;("output_frame", _output_frame, "velodyne");
-	ROS_INFO("output_frame: %s", _output_frame.c_str());
-
-	private_nh.param("use_vector_map", _use_vector_map, false);
-	ROS_INFO("use_vector_map: %d", _use_vector_map);
-	private_nh.param&lt;std::string&gt;("vectormap_frame", _vectormap_frame, "map");
-	ROS_INFO("vectormap_frame: %s", _vectormap_frame.c_str());
-
-	private_nh.param("remove_points_upto", _remove_points_upto, 0.0);
-	ROS_INFO("remove_points_upto: %f", _remove_points_upto);
-
-	private_nh.param("use_gpu", _use_gpu, false);
-	ROS_INFO("use_gpu: %d", _use_gpu);
-
-	_velodyne_transform_available = false;
-
-	if (_clustering_distances.size()!=4)
-	{
-		_clustering_distances = {15, 30, 45, 60};//maximum distance from sensor origin to separate segments
-	}
-	if (_clustering_thresholds.size()!=5)
-	{
-		_clustering_thresholds = {0.5, 1.1, 1.6, 2.1, 2.6};//Nearest neighbor distance threshold for each segment
-	}
-
-	std::cout &lt;&lt; "_clustering_thresholds: "; for (auto i = _clustering_thresholds.begin(); i != _clustering_thresholds.end(); ++i)  std::cout &lt;&lt; *i &lt;&lt; ' '; std::cout &lt;&lt; std::endl;
-	std::cout &lt;&lt; "_clustering_distances: ";for (auto i = _clustering_distances.begin(); i != _clustering_distances.end(); ++i)  std::cout &lt;&lt; *i &lt;&lt; ' '; std::cout &lt;&lt;std::endl;
-
-	// Create a ROS subscriber for the input point cloud
-	ros::Subscriber sub = h.subscribe (points_topic, 1, velodyne_callback);
-
-	private_nh.param&lt;std::string&gt;("wayarea_gridmap_topic", gridmap_topic, "grid_map_wayarea");
-	ROS_INFO("wayarea_gridmap_topic: %s", gridmap_topic.c_str());
-	private_nh.param&lt;std::string&gt;("wayarea_gridmap_layer", _gridmap_layer, "wayarea");
-	ROS_INFO("wayarea_gridmap_layer: %s", _gridmap_layer.c_str());
-	private_nh.param&lt;int&gt;("wayarea_no_road_value", _gridmap_no_road_value, _grid_max_value);
-	ROS_INFO("wayarea_no_road_value: %ds", _gridmap_no_road_value);
-	ros::Subscriber wayarea_sub = h.subscribe (gridmap_topic, 1, wayarea_gridmap_callback);
-
-
-	_visualization_marker.header.frame_id = "velodyne";
-	_visualization_marker.header.stamp = ros::Time();
-	_visualization_marker.ns = "my_namespace";
-	_visualization_marker.id = 0;
-	_visualization_marker.type = visualization_msgs::Marker::SPHERE_LIST;
-	_visualization_marker.action = visualization_msgs::Marker::ADD;
-	_visualization_marker.scale.x = 1.0;
-	_visualization_marker.scale.y = 1.0;
-	_visualization_marker.scale.z = 1.0;
-	_visualization_marker.color.a = 1.0;
-	_visualization_marker.color.r = 0.0;
-	_visualization_marker.color.g = 0.0;
-	_visualization_marker.color.b = 1.0;
-	// marker.lifetime = ros::Duration(0.1);
-	_visualization_marker.frame_locked = true;
-
-	// Spin
-	ros::spin ();
+    _pub_cluster_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_cluster", 1);
+    _pub_ground_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_ground", 1);
+    _centroid_pub = h.advertise&lt;autoware_msgs::centroids&gt;("/cluster_centroids", 1);
+    _marker_pub = h.advertise&lt;visualization_msgs::Marker&gt;("centroid_marker", 1);
+
+    _pub_points_lanes_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_lanes", 1);
+    _pub_jsk_boundingboxes = h.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/bounding_boxes", 1);
+    _pub_jsk_hulls = h.advertise&lt;jsk_recognition_msgs::PolygonArray&gt;("/cluster_hulls", 1);
+    _pub_clusters_message = h.advertise&lt;autoware_msgs::CloudClusterArray&gt;("/cloud_clusters", 1);
+    _pub_detected_objects = h.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/lidar_objects", 1);
+    _pub_text_pictogram = h.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;("cluster_ids", 10);
+    ROS_INFO("output pictograms topic: %s", "cluster_id");
+
+    _pub_grid_map = h.advertise&lt;grid_map_msgs::GridMap&gt;("grid_map_wayarea", 1, true);
+
+    std::string points_topic, gridmap_topic;
+
+    _using_sensor_cloud = false;
+
+    if (private_nh.getParam("points_node", points_topic)) {
+        ROS_INFO("euclidean_cluster &gt; Setting points node to %s", points_topic.c_str());
+    } else {
+        ROS_INFO(
+                "euclidean_cluster &gt; No points node received, defaulting to points_raw, you can use _points_node:=YOUR_TOPIC");
+        points_topic = "/points_raw";
+    }
+
+    _use_diffnormals = false;
+    if (private_nh.getParam("use_diffnormals", _use_diffnormals)) {
+        if (_use_diffnormals)
+            ROS_INFO("Euclidean Clustering: Applying difference of normals on clustering pipeline");
+        else
+            ROS_INFO("Euclidean Clustering: Difference of Normals will not be used.");
+    }
+
+    /* Initialize tuning parameter */
+    private_nh.param("downsample_cloud", _downsample_cloud, false);
+    ROS_INFO("downsample_cloud: %d", _downsample_cloud);
+    private_nh.param("remove_ground", _remove_ground, true);
+    ROS_INFO("remove_ground: %d", _remove_ground);
+    private_nh.param("leaf_size", _leaf_size, 0.1);
+    ROS_INFO("leaf_size: %f", _leaf_size);
+    private_nh.param("cluster_size_min", _cluster_size_min, 20);
+    ROS_INFO("cluster_size_min %d", _cluster_size_min);
+    private_nh.param("cluster_size_max", _cluster_size_max, 100000);
+    ROS_INFO("cluster_size_max: %d", _cluster_size_max);
+    private_nh.param("pose_estimation", _pose_estimation, false);
+    ROS_INFO("pose_estimation: %d", _pose_estimation);
+    private_nh.param("clip_min_height", _clip_min_height, -1.3);
+    ROS_INFO("clip_min_height: %f", _clip_min_height);
+    private_nh.param("clip_max_height", _clip_max_height, 0.5);
+    ROS_INFO("clip_max_height: %f", _clip_max_height);
+    private_nh.param("keep_lanes", _keep_lanes, false);
+    ROS_INFO("keep_lanes: %d", _keep_lanes);
+    private_nh.param("keep_lane_left_distance", _keep_lane_left_distance, 5.0);
+    ROS_INFO("keep_lane_left_distance: %f", _keep_lane_left_distance);
+    private_nh.param("keep_lane_right_distance", _keep_lane_right_distance, 5.0);
+    ROS_INFO("keep_lane_right_distance: %f", _keep_lane_right_distance);
+    private_nh.param("clustering_thresholds", _clustering_thresholds);
+    private_nh.param("clustering_distances", _clustering_distances);
+    private_nh.param("max_boundingbox_side", _max_boundingbox_side, 10.0);
+    ROS_INFO("max_boundingbox_side: %f", _max_boundingbox_side);
+    private_nh.param("cluster_merge_threshold", _cluster_merge_threshold, 1.5);
+    ROS_INFO("cluster_merge_threshold: %f", _cluster_merge_threshold);
+    private_nh.param&lt;std::string&gt;("output_frame", _output_frame, "velodyne");
+    ROS_INFO("output_frame: %s", _output_frame.c_str());
+
+    private_nh.param("use_vector_map", _use_vector_map, false);
+    ROS_INFO("use_vector_map: %d", _use_vector_map);
+    private_nh.param&lt;std::string&gt;("vectormap_frame", _vectormap_frame, "map");
+    ROS_INFO("vectormap_frame: %s", _vectormap_frame.c_str());
+
+    private_nh.param("remove_points_upto", _remove_points_upto, 0.0);
+    ROS_INFO("remove_points_upto: %f", _remove_points_upto);
+
+    private_nh.param("use_gpu", _use_gpu, false);
+    ROS_INFO("use_gpu: %d", _use_gpu);
+
+    _velodyne_transform_available = false;
+
+    if (_clustering_distances.size() != 4) {
+        _clustering_distances = {15, 30, 45, 60};//maximum distance from sensor origin to separate segments
+    }
+    if (_clustering_thresholds.size() != 5) {
+        _clustering_thresholds = {0.5, 1.1, 1.6, 2.1, 2.6};//Nearest neighbor distance threshold for each segment
+    }
+
+    std::cout &lt;&lt; "_clustering_thresholds: ";
+    for (auto i = _clustering_thresholds.begin(); i != _clustering_thresholds.end(); ++i) std::cout &lt;&lt; *i &lt;&lt; ' ';
+    std::cout &lt;&lt; std::endl;
+    std::cout &lt;&lt; "_clustering_distances: ";
+    for (auto i = _clustering_distances.begin(); i != _clustering_distances.end(); ++i) std::cout &lt;&lt; *i &lt;&lt; ' ';
+    std::cout &lt;&lt; std::endl;
+
+    // Create a ROS subscriber for the input point cloud
+    ros::Subscriber sub = h.subscribe(points_topic, 1, velodyne_callback);
+
+    private_nh.param&lt;std::string&gt;("wayarea_gridmap_topic", gridmap_topic, "grid_map_wayarea");
+    ROS_INFO("wayarea_gridmap_topic: %s", gridmap_topic.c_str());
+    private_nh.param&lt;std::string&gt;("wayarea_gridmap_layer", _gridmap_layer, "wayarea");
+    ROS_INFO("wayarea_gridmap_layer: %s", _gridmap_layer.c_str());
+    private_nh.param&lt;int&gt;("wayarea_no_road_value", _gridmap_no_road_value, _grid_max_value);
+    ROS_INFO("wayarea_no_road_value: %ds", _gridmap_no_road_value);
+    ros::Subscriber wayarea_sub = h.subscribe(gridmap_topic, 1, wayarea_gridmap_callback);
+
+
+    _visualization_marker.header.frame_id = "velodyne";
+    _visualization_marker.header.stamp = ros::Time();
+    _visualization_marker.ns = "my_namespace";
+    _visualization_marker.id = 0;
+    _visualization_marker.type = visualization_msgs::Marker::SPHERE_LIST;
+    _visualization_marker.action = visualization_msgs::Marker::ADD;
+    _visualization_marker.scale.x = 1.0;
+    _visualization_marker.scale.y = 1.0;
+    _visualization_marker.scale.z = 1.0;
+    _visualization_marker.color.a = 1.0;
+    _visualization_marker.color.r = 0.0;
+    _visualization_marker.color.g = 0.0;
+    _visualization_marker.color.b = 1.0;
+    // marker.lifetime = ros::Duration(0.1);
+    _visualization_marker.frame_locked = true;
+
+    // Spin
+    ros::spin();
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" added_lines="184" deleted_lines="141">
				<diff>@@ -4,159 +4,202 @@
 
 
 #include &lt;opencv2/core/version.hpp&gt;
+#include &lt;opencv2/highgui/highgui.hpp&gt;
+#include "draw_rects.h"
 
 #if (CV_MAJOR_VERSION == 3)
+
 #include "gencolors.cpp"
+
 #else
 #include &lt;opencv2/contrib/contrib.hpp&gt;
+#include &lt;autoware_msgs/DetectedObjectArray.h&gt;
+
 #endif
 
 namespace integrated_viewer
 {
-  const int        DrawRects::kRectangleThickness = 3;
-  const cv::Scalar DrawRects::kBlue               = CV_RGB(0, 0, 255);
-  const cv::Scalar DrawRects::kGreen              = CV_RGB(0, 255, 0);
-  
-  DrawRects::DrawRects(void) {
-    // Generate color map to represent tracked object
+    const int        DrawRects::kRectangleThickness = 3;
+
+    DrawRects::DrawRects(void)
+    {
+        // Generate color map to represent tracked object
 #if (CV_MAJOR_VERSION == 3)
-    generateColors(color_map_, 25);
+        generateColors(color_map_, 25);
 #else
-    cv::generateColors(color_map_, 25);
+        cv::generateColors(color_map_, 25);
 #endif
-
-  } // DrawRects::DrawRects()
-
-
-  void DrawRects::DrawImageObj(const autoware_msgs::image_obj::ConstPtr&amp; rect_data,
-                               cv::Mat &amp;image) {
-    if (rect_data == NULL) {
-      return;
-    }
-
-    cv::Scalar rectangle_color;
-    if (rect_data-&gt;type == "car") {
-      rectangle_color = kBlue;
-    } else {
-      rectangle_color = kGreen;
-    }
-    
-    // Draw rectangles for each objects
-    for (const auto&amp; rectangle : rect_data-&gt;obj) {
-      // Make label shown on a rectangle
-      std::ostringstream label;
-      label &lt;&lt; rect_data-&gt;type &lt;&lt; ":" &lt;&lt; std::setprecision(2) &lt;&lt; rectangle.score;
-
-      // Draw object information label
-      DrawLabel(label.str(), cv::Point(rectangle.x, rectangle.y), image);
-
-      // Draw rectangle
-      cv::rectangle(image,
-                    cv::Point(rectangle.x, rectangle.y),
-                    cv::Point(rectangle.x + rectangle.width, rectangle.y + rectangle.height),
-                    rectangle_color,
-                    kRectangleThickness,
-                    CV_AA,
-                    0);
+        car_image_ = cv::imread(DEFAULT_PATH + "car.png", cv::IMREAD_UNCHANGED);
+        pedestrian_image_ = cv::imread(DEFAULT_PATH + "pedestrian.png", cv::IMREAD_UNCHANGED);
+
+    } // DrawRects::DrawRects()
+
+    void DrawRects::OverlayImage(const cv::Mat &amp;in_background, const cv::Mat &amp;in_foreground,
+                                      cv::Mat &amp;output, cv::Point2i in_location)
+    {
+        in_background.copyTo(output);
+
+        for(int y = std::max(in_location.y , 0); y &lt; in_background.rows; ++y)
+        {
+            int fY = y - in_location.y;
+
+            if(fY &gt;= in_foreground.rows)
+                break;
+            for(int x = std::max(in_location.x, 0); x &lt; in_background.cols; ++x)
+            {
+                int fX = x - in_location.x;
+
+                if(fX &gt;= in_foreground.cols)
+                    break;
+
+                double opacity =
+                        ((double)in_foreground.data[fY * in_foreground.step + fX * in_foreground.channels() + 3])/ 255.;
+                for(int c = 0; opacity &gt; 0 &amp;&amp; c &lt; output.channels(); ++c)
+                {
+                    unsigned char foregroundPx =
+                            in_foreground.data[fY * in_foreground.step + fX * in_foreground.channels() + c];
+                    unsigned char in_backgroundPx =
+                            in_background.data[y * in_background.step + x * in_background.channels() + c];
+                    output.data[y*output.step + output.channels()*x + c] =
+                            in_backgroundPx * (1.-opacity) + foregroundPx * opacity;
+                }
+            }
+        }
     }
-  } // DrawRects::DrawImageObj()
 
-
-  void DrawRects::DrawImageObjRanged(const autoware_msgs::image_obj_ranged::ConstPtr&amp; rect_data,
-                                     cv::Mat &amp;image) {
-    if (rect_data == NULL) {
-      return;
-    }
-
-    cv::Scalar rectangle_color;
-    if (rect_data-&gt;type == "car") {
-      rectangle_color = kBlue;
-    } else {
-      rectangle_color = kGreen;
-    }
-    
-    // Draw rectangles for each objects
-    for (const auto&amp; ojbect : rect_data-&gt;obj) {
-      // Make label shown on a rectangle
-      std::ostringstream label;
-      label &lt;&lt; rect_data-&gt;type &lt;&lt; " : " &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; ojbect.range / 100 &lt;&lt; " m";
-
-      // Draw object information label
-      DrawLabel(label.str(), cv::Point(ojbect.rect.x, ojbect.rect.y), image);
-
-      // Draw rectangle
-      cv::rectangle(image,
-                    cv::Point(ojbect.rect.x, ojbect.rect.y),
-                    cv::Point(ojbect.rect.x + ojbect.rect.width, ojbect.rect.y + ojbect.rect.height),
-                    rectangle_color,
-                    kRectangleThickness,
-                    CV_AA,
-                    0);
-    }
-  } // DrawRects::DrawImageObjRanged()
-
-
-  void DrawRects::DrawImageObjTracked(const autoware_msgs::image_obj_tracked::ConstPtr&amp; rect_data,
-                                      cv::Mat &amp;image) {
-    if (rect_data == NULL) {
-      return;
-    }
-
-    for (const auto&amp; object : rect_data-&gt;rect_ranged) {
-      int index = &amp;object - &amp;(rect_data-&gt;rect_ranged[0]);
-      int object_id = rect_data-&gt;obj_id[index];
-
-      // Make label shown on a rectangle
-      std::ostringstream label;
-      label &lt;&lt; rect_data-&gt;type &lt;&lt; "_" &lt;&lt; object_id &lt;&lt; " : " &lt;&lt; std::setprecision(2) &lt;&lt; rect_data-&gt;lifespan[index];
-
-      // Draw object information label
-      DrawLabel(label.str(), cv::Point(object.rect.x, object.rect.y), image);
-      
-      // Draw rectangle
-      cv::rectangle(image,
-                    cv::Point(object.rect.x, object.rect.y),
-                    cv::Point(object.rect.x + object.rect.width, object.rect.y + object.rect.height),
-                    color_map_[object_id],
-                    kRectangleThickness,
-                    CV_AA,
-                    0);
-    }
-  } // DrawRects::DrawImageObjTracked()
-
-
-  void DrawRects::DrawLabel(const std::string&amp; label,
-                            const cv::Point&amp; rectangle_origin,
-                            cv::Mat &amp;image) {
-    // label's property
-    const int    font_face      = cv::FONT_HERSHEY_COMPLEX;
-    const double font_scale     = 0.5;
-    const int    font_thickness = 1;
-    int          font_baseline  = 0;
-
-    cv::Size label_size = cv::getTextSize(label,
-                                          font_face,
-                                          font_scale,
-                                          font_thickness,
-                                          &amp;font_baseline);
-
-    cv::Point label_origin = cv::Point(rectangle_origin.x - kRectangleThickness,
-                                       rectangle_origin.y - font_baseline - kRectangleThickness);
-
-    // Fill label's background by black
-    cv::rectangle(image,
-                  cv::Point(label_origin.x, label_origin.y + font_baseline),
-                  cv::Point(label_origin.x + label_size.width, label_origin.y - label_size.height),
-                  CV_RGB(0, 0, 0),
-                  CV_FILLED);
-
-    // Draw label text by white
-    cv::putText(image,
-                label,
-                label_origin,
-                font_face,
-                font_scale,
-                CV_RGB(255, 255, 255));
-        
-  } // DrawRects::DrawLabel()
+    void DrawRects::DrawImageRect(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;detected_objects,
+                                  cv::Mat &amp;image)
+    {
+        if (detected_objects == NULL)
+        {
+            return;
+        }
+
+        // Draw rectangles for each object
+        for (const auto &amp;detected_object : detected_objects-&gt;objects)
+        {
+            // Draw object information label
+            DrawLabel(detected_object, image);
+
+            // Draw rectangle
+            cv::rectangle(image,
+                          cv::Point(detected_object.x, detected_object.y),
+                          cv::Point(detected_object.x + detected_object.width,
+                                    detected_object.y + detected_object.height),
+                          cv::Scalar(detected_object.color.r, detected_object.color.g, detected_object.color.b),
+                          kRectangleThickness,
+                          CV_AA,
+                          0);
+        }
+    } // DrawRects::DrawImageRect()
+
+    void DrawRects::DrawImageBox(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;detected_objects,
+                                 cv::Mat &amp;image)
+    {
+        if (detected_objects == NULL)
+        {
+            return;
+        }
+
+        // Draw rectangles for each object
+        for (const auto &amp;detected_object : detected_objects-&gt;objects)
+        {
+            DrawLabel(detected_object, image);
+
+            // Draw rectangle
+            cv::rectangle(image,
+                          cv::Point(detected_object.x, detected_object.y),
+                          cv::Point(detected_object.x + detected_object.width,
+                                    detected_object.y + detected_object.height),
+                          cv::Scalar(detected_object.color.r, detected_object.color.g, detected_object.color.b),
+                          kRectangleThickness,
+                          CV_AA,
+                          0);
+        }
+    } // DrawRects::DrawImageRect()
+
+    void DrawRects::DrawLabel(const autoware_msgs::DetectedObject &amp;in_detected_object,
+                              cv::Mat &amp;image)
+    {
+
+        cv::Point rectangle_origin(in_detected_object.x, in_detected_object.y);
+        // label's property
+        const int font_face = cv::FONT_HERSHEY_DUPLEX;
+        const double font_scale = 0.8;
+        const int font_thickness = 1;
+        int font_baseline = 0;
+        int icon_width = 40;
+        int icon_height = 40;
+        std::ostringstream label_one;
+        std::ostringstream label_two;
+
+        cv::Size label_size = cv::getTextSize("0123456789",
+                                              font_face,
+                                              font_scale,
+                                              font_thickness,
+                                              &amp;font_baseline);
+
+        cv::Point label_origin = cv::Point(rectangle_origin.x,
+                                           rectangle_origin.y - font_baseline - kRectangleThickness*2 - icon_height);
+
+        double distance = sqrt(in_detected_object.pose.position.x*in_detected_object.pose.position.x +
+                                       in_detected_object.pose.position.y*in_detected_object.pose.position.y);
+
+        label_one &lt;&lt; in_detected_object.label;
+        if (distance &gt; 0.1)
+        {
+            label_two &lt;&lt; std::setprecision(2) &lt;&lt; distance &lt;&lt; "meters";
+        }
+
+        if (in_detected_object.label == "car" || in_detected_object.label == "truck")
+        {
+            OverlayImage(image, car_image_, image, label_origin);
+        }
+        else if (in_detected_object.label == "person")
+        {
+            OverlayImage(image, pedestrian_image_, image, label_origin);
+        }
+        else
+        {
+            icon_width = 0;
+        }
+
+        if(label_origin.x &lt; 0)
+            label_origin.x = 0;
+        if(label_origin.y &lt; 0)
+            label_origin.y = 0;
+
+        cv::Rect text_holder_rect;
+        text_holder_rect.x = label_origin.x;
+        text_holder_rect.y = label_origin.y;
+        text_holder_rect.width = label_size.width + icon_width;
+        if (text_holder_rect.x + text_holder_rect.width &gt; image.cols)
+            text_holder_rect.width = image.cols - text_holder_rect.x - 1;
+        text_holder_rect.height = label_size.height + icon_height;
+        if (text_holder_rect.y + text_holder_rect.height &gt; image.rows)
+            text_holder_rect.height = image.rows - text_holder_rect.y - 1;
+
+        cv::Mat roi = image(text_holder_rect);
+
+        cv::Mat text_holder (roi.size(), CV_8UC3, cv::Scalar(0,0,0));
+
+        double alpha = 0.3;
+        cv::addWeighted(text_holder, alpha, roi, 1.0 - alpha, 0.0, roi);
+        label_origin.x+= icon_width;
+        label_origin.y+= text_holder_rect.height / 3;
+        cv::putText(image,
+                    label_one.str(),
+                    label_origin,
+                    font_face,
+                    font_scale,
+                    CV_RGB(255, 255, 255));
+        label_origin.y+= text_holder_rect.height / 3;
+        cv::putText(image,
+                    label_two.str(),
+                    label_origin,
+                    font_face,
+                    font_scale,
+                    CV_RGB(255, 255, 255));
+
+    } // DrawRects::DrawLabel()
 } // end namespace integrated_viewer
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.h" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.h" added_lines="34" deleted_lines="22">
				<diff>@@ -2,27 +2,39 @@
 #define DRAW_RECTS_H
 
 #include &lt;opencv/cv.h&gt;
-#include "autoware_msgs/image_obj.h"
-#include "autoware_msgs/image_obj_ranged.h"
-#include "autoware_msgs/image_obj_tracked.h"
-
-namespace integrated_viewer {
-  // helper class to draw detection result rectangle
-  class DrawRects{
-  public:
-    explicit DrawRects(void);
-    void DrawImageObj(const autoware_msgs::image_obj::ConstPtr&amp; rect_data, cv::Mat&amp; image);
-    void DrawImageObjRanged(const autoware_msgs::image_obj_ranged::ConstPtr&amp; rect_data, cv::Mat&amp; image);
-    void DrawImageObjTracked(const autoware_msgs::image_obj_tracked::ConstPtr&amp; rect_data, cv::Mat&amp; image);
-
-  protected:
-    static const int kRectangleThickness;
-  
-  private:
-    void DrawLabel(const std::string&amp; label, const cv::Point&amp; rectangle_origin, cv::Mat&amp; image);
-    std::vector&lt;cv::Scalar&gt; color_map_;
-    static const cv::Scalar kBlue;
-    static const cv::Scalar kGreen;
-  };
+#include &lt;autoware_msgs/DetectedObjectArray.h&gt;
+
+#define XSTR(x) #x
+#define STR(x) XSTR(x)
+
+const std::string DEFAULT_PATH                                      = STR(IMAGE_VIEWER_DEFAULT_PATH);
+
+namespace integrated_viewer
+{
+    // helper class to draw detection result rectangle
+    class DrawRects
+    {
+    public:
+        explicit DrawRects(void);
+
+        void DrawImageRect(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_objects, cv::Mat &amp;image);
+        void DrawImageBox(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_objects, cv::Mat &amp;image);
+
+    protected:
+        static const int kRectangleThickness;
+
+    private:
+        void DrawLabel(const autoware_msgs::DetectedObject&amp; in_object, cv::Mat &amp;image);
+
+        void OverlayImage(const cv::Mat &amp;in_background, const cv::Mat &amp;in_foreground,
+                          cv::Mat &amp;output, cv::Point2i in_location);
+
+        std::vector&lt;cv::Scalar&gt; color_map_;
+        static const cv::Scalar kBlue;
+        static const cv::Scalar kGreen;
+
+        cv::Mat car_image_;
+        cv::Mat pedestrian_image_;
+    };
 }
 #endif // DRAW_RECTS_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" added_lines="275" deleted_lines="326">
				<diff>@@ -13,355 +13,303 @@
 #include "draw_rects.h"
 #include "draw_points.h"
 
-#define XSTR(x) #x
-#define STR(x) XSTR(x)
-
-namespace integrated_viewer
-{
-  const QString     ImageViewerPlugin::kImageDataType               = "sensor_msgs/Image";
-  const QString     ImageViewerPlugin::kRectDataTypeBase            = "autoware_msgs/image_obj";
-  const QString     ImageViewerPlugin::kPointDataType               = "autoware_msgs/PointsImage";
-  const QString     ImageViewerPlugin::kLaneDataType                = "autoware_msgs/ImageLaneObjects";
-  const QString     ImageViewerPlugin::kBlankTopic                  = "-----";
-  const std::string ImageViewerPlugin::kRectDataTypeImageObjRanged  = "autoware_msgs/image_obj_ranged";
-  const std::string ImageViewerPlugin::kRectDataTypeImageObjTracked = "autoware_msgs/image_obj_tracked";
-
-  ImageViewerPlugin::ImageViewerPlugin(QWidget* parent)
-    : rviz::Panel(parent) {
-
-    // Initialize Form
-    ui_.setupUi(this);
-
-    // Set point size parameter
-    ui_.point_size_spin_box_-&gt;setMinimum(2); // minimum point size is 2x2
-    ui_.point_size_spin_box_-&gt;setValue(3);   // Set default size to 3
-
-    // Load default image
-    default_image_ = cv::imread(STR(IMAGE_VIEWER_DEFAULT_IMAGE));
-
-    points_msg_ = NULL;
-    image_obj_msg_ = NULL;
-    image_obj_ranged_msg_ = NULL;
-    image_obj_tracked_msg_ = NULL;
-    lane_msg_ = NULL;
-
-    UpdateTopicList();
-
-    viewed_image_ = default_image_.clone();
-    default_image_shown_ = true;
-    ShowImageOnUi();
-
-    // If combobox is clicked, topic list will be update
-    ui_.image_topic_combo_box_-&gt;installEventFilter(this);
-    ui_.rect_topic_combo_box_-&gt;installEventFilter(this);
-    ui_.point_topic_combo_box_-&gt;installEventFilter(this);
-    ui_.lane_topic_combo_box_-&gt;installEventFilter(this);
-
-  } // ImageViewerPlugin::ImageViewerPlugin()
-
-
-  void ImageViewerPlugin::UpdateTopicList(void) {
-    // The topic list that can be selected from the UI
-    QStringList image_topic_list;
-    QStringList rect_topic_list;
-    QStringList point_topic_list;
-    QStringList lane_topic_list;
-
-    // The topic name currently chosen
-    QString image_topic_current = ui_.image_topic_combo_box_-&gt;currentText();
-    QString rect_topic_current = ui_.rect_topic_combo_box_-&gt;currentText();
-    QString point_topic_current = ui_.point_topic_combo_box_-&gt;currentText();
-    QString lane_topic_current = ui_.lane_topic_combo_box_-&gt;currentText();
-
-    if (image_topic_current == "") {
-      image_topic_current = kBlankTopic;
-    }
-
-    if (rect_topic_current == "") {
-      rect_topic_current = kBlankTopic;
-    }
-
-    if (point_topic_current == "") {
-      point_topic_current = kBlankTopic;
-    }
-
-    if (lane_topic_current == "") {
-      lane_topic_current = kBlankTopic;
-    }
-
-    // reset topic information list for detection result
-    rect_topic_info_.clear();
-
-    // Insert blank topic name to the top of the lists
-    image_topic_list &lt;&lt; kBlankTopic;
-    rect_topic_list  &lt;&lt; kBlankTopic;
-    point_topic_list &lt;&lt; kBlankTopic;
-    lane_topic_list  &lt;&lt; kBlankTopic;
-
-    // Get all available topic 
-    ros::master::V_TopicInfo master_topics;
-    ros::master::getTopics(master_topics);
-
-    // Analyse topics
-    for (ros::master::V_TopicInfo::iterator it = master_topics.begin(); it != master_topics.end(); it++) {
-      const ros::master::TopicInfo&amp; info = *it;
-      const QString topic_name = QString::fromStdString(info.name);
-      const QString topic_type = QString::fromStdString(info.datatype);
-      
-      // Check whether this topic is image
-      if (topic_type.contains(kImageDataType) == true) {
-        image_topic_list &lt;&lt; topic_name;
-        continue;
-      }
-
-      // Check whether this topic is rectangle
-      if (topic_type.contains(kRectDataTypeBase) == true) { 
-        // This condition will also be true for "image_obj_ranged"and "image_obj_tracked"
-        rect_topic_list &lt;&lt; topic_name;
-        // Insert topic name and data type to a list
-        rect_topic_info_[info.name] = info.datatype;
-        continue;
-      }
-
-      // Check whether this topic is point cloud
-      if (topic_type.contains(kPointDataType) == true) {
-        point_topic_list &lt;&lt; topic_name;
-        continue;
-      }
-
-      // Check whether this topic is lane
-      if (topic_type.contains(kLaneDataType) == true) {
-        lane_topic_list &lt;&lt; topic_name;
-        continue;
-      }
-    }
-
-    // remove all list items from combo box
-    ui_.image_topic_combo_box_-&gt;clear();
-    ui_.rect_topic_combo_box_-&gt;clear();
-    ui_.point_topic_combo_box_-&gt;clear();
-    ui_.lane_topic_combo_box_-&gt;clear();
-
-    // set new items to combo box
-    ui_.image_topic_combo_box_-&gt;addItems(image_topic_list);
-    ui_.rect_topic_combo_box_-&gt;addItems(rect_topic_list);
-    ui_.point_topic_combo_box_-&gt;addItems(point_topic_list);
-    ui_.lane_topic_combo_box_-&gt;addItems(lane_topic_list);
-
-    ui_.image_topic_combo_box_-&gt;insertSeparator(1);
-    ui_.rect_topic_combo_box_-&gt;insertSeparator(1);
-    ui_.point_topic_combo_box_-&gt;insertSeparator(1);
-    ui_.lane_topic_combo_box_-&gt;insertSeparator(1);
-
-    // set last topic as current
-    int image_topic_index = ui_.image_topic_combo_box_-&gt;findText(image_topic_current);
-    int rect_topic_index = ui_.rect_topic_combo_box_-&gt;findText(rect_topic_current);
-    int point_topic_index = ui_.point_topic_combo_box_-&gt;findText(point_topic_current);
-    int lane_topic_index = ui_.lane_topic_combo_box_-&gt;findText(lane_topic_current);
-
-    if (image_topic_index != -1) {
-      ui_.image_topic_combo_box_-&gt;setCurrentIndex(image_topic_index);
-    }
-
-    if (rect_topic_index != -1) {
-      ui_.rect_topic_combo_box_-&gt;setCurrentIndex(rect_topic_index);
-    }
-
-    if (point_topic_index != -1) {
-      ui_.point_topic_combo_box_-&gt;setCurrentIndex(point_topic_index);
-    }
-
-    if (lane_topic_index != -1) {
-      ui_.lane_topic_combo_box_-&gt;setCurrentIndex(lane_topic_index);
-    }
-
-  } // ImageViewerPlugin::UpdateTopicList()
-
-
-
-
-
-  // The behavior of combo box for image
-  void ImageViewerPlugin::on_image_topic_combo_box__activated(int index) {
-    // Extract selected topic name from combo box
-    std::string selected_topic = ui_.image_topic_combo_box_-&gt;itemText(index).toStdString();
-    if (selected_topic == kBlankTopic.toStdString() || selected_topic == "") {
-      image_sub_.shutdown();
-      // If blank name is selected as image topic, show default image
-      viewed_image_ = default_image_.clone();
-      default_image_shown_ = true;
-      ShowImageOnUi();
-      return;
-    }
-    
-    // if selected topic is not blank or empty, start callback function
-    default_image_shown_ = false;
-    image_sub_ = node_handle_.subscribe&lt;sensor_msgs::Image&gt;(selected_topic,
-                                                            1,
-                                                            &amp;ImageViewerPlugin::ImageCallback,
-                                                            this);
-
-  } // ImageViewerPlugin::on_image_topic_combo_box__activated()
-
-
-  void ImageViewerPlugin::ImageCallback(const sensor_msgs::Image::ConstPtr&amp; msg) {
-    // Get image from topic
-    const auto&amp; encoding = sensor_msgs::image_encodings::BGR8;
-    viewed_image_ = cv_bridge::toCvCopy(msg, encoding)-&gt;image;
-
-    ShowImageOnUi();
-  } // ImageViewerPlugin::ImageCallback()
-
-
-  // The behavior of combo box for detection result rectangle
-  void ImageViewerPlugin::on_rect_topic_combo_box__activated(int index) {
-    // Extract selected topic name from combo box
-    std::string selected_topic = ui_.rect_topic_combo_box_-&gt;itemText(index).toStdString();
-    if (selected_topic == kBlankTopic.toStdString() || selected_topic == "") {
-      rect_sub_.shutdown();
-      image_obj_msg_         = NULL;
-      image_obj_ranged_msg_  = NULL;
-      image_obj_tracked_msg_ = NULL;
-      return;
-    }
-
-    // Switch booted callback function by topic name 
-    std::string topic_type = rect_topic_info_[selected_topic];
-    if (topic_type.find(kRectDataTypeImageObjRanged) != std::string::npos) {
-      image_obj_msg_         = NULL;
-      image_obj_ranged_msg_  = NULL;
-      image_obj_tracked_msg_ = NULL;
-      // this topic type is image_obj_ranged
-      rect_sub_ = node_handle_.subscribe&lt;autoware_msgs::image_obj_ranged&gt;(selected_topic,
-                                                                       1,
-                                                                       &amp;ImageViewerPlugin::ImageObjRangedCallback,
-                                                                       this);
-
-    } else if (topic_type.find(kRectDataTypeImageObjTracked) != std::string::npos) {
-      image_obj_msg_         = NULL;
-      image_obj_ranged_msg_  = NULL;
-      image_obj_tracked_msg_ = NULL;
-      // this topic type is image_obj_tracked
-      rect_sub_ = node_handle_.subscribe&lt;autoware_msgs::image_obj_tracked&gt;(selected_topic,
-                                                                       1,
-                                                                       &amp;ImageViewerPlugin::ImageObjTrackedCallback,
-                                                                       this);
-    } else {
-      image_obj_msg_         = NULL;
-      image_obj_ranged_msg_  = NULL;
-      image_obj_tracked_msg_ = NULL;
-      // this topic type is image_obj
-      rect_sub_ = node_handle_.subscribe&lt;autoware_msgs::image_obj&gt;(selected_topic,
+namespace integrated_viewer {
+    const QString     ImageViewerPlugin::kImageDataType                 = "sensor_msgs/Image";
+    const QString     ImageViewerPlugin::kDetectedObjectDataTypeBase    = "autoware_msgs/DetectedObjectArray";
+    const QString     ImageViewerPlugin::kPointDataType                 = "autoware_msgs/PointsImage";
+    const QString     ImageViewerPlugin::kLaneDataType                  = "autoware_msgs/ImageLaneObjects";
+    const QString     ImageViewerPlugin::kBlankTopic                    = "-----";
+
+
+    ImageViewerPlugin::ImageViewerPlugin(QWidget *parent)
+            : rviz::Panel(parent) {
+
+        // Initialize Form
+        ui_.setupUi(this);
+
+        // Set point size parameter
+        ui_.point_size_spin_box_-&gt;setMinimum(2); // minimum point size is 2x2
+        ui_.point_size_spin_box_-&gt;setValue(3);   // Set default size to 3
+
+        // Load default image
+        default_image_ = cv::imread( DEFAULT_PATH + "autoware_logo.png");
+
+        points_msg_ = NULL;
+        detected_objects_msg_ = NULL;
+        lane_msg_ = NULL;
+
+        UpdateTopicList();
+
+        viewed_image_ = default_image_.clone();
+        default_image_shown_ = true;
+        ShowImageOnUi();
+
+        // If combobox is clicked, topic list will be update
+        ui_.image_topic_combo_box_-&gt;installEventFilter(this);
+        ui_.rect_topic_combo_box_-&gt;installEventFilter(this);
+        ui_.point_topic_combo_box_-&gt;installEventFilter(this);
+        ui_.lane_topic_combo_box_-&gt;installEventFilter(this);
+
+    } // ImageViewerPlugin::ImageViewerPlugin()
+
+
+    void ImageViewerPlugin::UpdateTopicList(void) {
+        // The topic list that can be selected from the UI
+        QStringList image_topic_list;
+        QStringList rect_topic_list;
+        QStringList point_topic_list;
+        QStringList lane_topic_list;
+
+        // The topic name currently chosen
+        QString image_topic_current = ui_.image_topic_combo_box_-&gt;currentText();
+        QString rect_topic_current = ui_.rect_topic_combo_box_-&gt;currentText();
+        QString point_topic_current = ui_.point_topic_combo_box_-&gt;currentText();
+        QString lane_topic_current = ui_.lane_topic_combo_box_-&gt;currentText();
+
+        if (image_topic_current == "") {
+            image_topic_current = kBlankTopic;
+        }
+
+        if (rect_topic_current == "") {
+            rect_topic_current = kBlankTopic;
+        }
+
+        if (point_topic_current == "") {
+            point_topic_current = kBlankTopic;
+        }
+
+        if (lane_topic_current == "") {
+            lane_topic_current = kBlankTopic;
+        }
+
+        // Insert blank topic name to the top of the lists
+        image_topic_list &lt;&lt; kBlankTopic;
+        rect_topic_list &lt;&lt; kBlankTopic;
+        point_topic_list &lt;&lt; kBlankTopic;
+        lane_topic_list &lt;&lt; kBlankTopic;
+
+        // Get all available topic
+        ros::master::V_TopicInfo master_topics;
+        ros::master::getTopics(master_topics);
+
+        // Analyse topics
+        for (ros::master::V_TopicInfo::iterator it = master_topics.begin(); it != master_topics.end(); it++) {
+            const ros::master::TopicInfo &amp;info = *it;
+            const QString topic_name = QString::fromStdString(info.name);
+            const QString topic_type = QString::fromStdString(info.datatype);
+
+            // Check whether this topic is image
+            if (topic_type.contains(kImageDataType) == true) {
+                image_topic_list &lt;&lt; topic_name;
+                continue;
+            }
+
+            // Check whether this topic is rectangle
+            if (topic_type.contains(kDetectedObjectDataTypeBase) == true) {
+                rect_topic_list &lt;&lt; topic_name;
+                continue;
+            }
+
+            // Check whether this topic is point cloud
+            if (topic_type.contains(kPointDataType) == true) {
+                point_topic_list &lt;&lt; topic_name;
+                continue;
+            }
+
+            // Check whether this topic is lane
+            if (topic_type.contains(kLaneDataType) == true) {
+                lane_topic_list &lt;&lt; topic_name;
+                continue;
+            }
+        }
+
+        // remove all list items from combo box
+        ui_.image_topic_combo_box_-&gt;clear();
+        ui_.rect_topic_combo_box_-&gt;clear();
+        ui_.point_topic_combo_box_-&gt;clear();
+        ui_.lane_topic_combo_box_-&gt;clear();
+
+        // set new items to combo box
+        ui_.image_topic_combo_box_-&gt;addItems(image_topic_list);
+        ui_.rect_topic_combo_box_-&gt;addItems(rect_topic_list);
+        ui_.point_topic_combo_box_-&gt;addItems(point_topic_list);
+        ui_.lane_topic_combo_box_-&gt;addItems(lane_topic_list);
+
+        ui_.image_topic_combo_box_-&gt;insertSeparator(1);
+        ui_.rect_topic_combo_box_-&gt;insertSeparator(1);
+        ui_.point_topic_combo_box_-&gt;insertSeparator(1);
+        ui_.lane_topic_combo_box_-&gt;insertSeparator(1);
+
+        // set last topic as current
+        int image_topic_index = ui_.image_topic_combo_box_-&gt;findText(image_topic_current);
+        int rect_topic_index = ui_.rect_topic_combo_box_-&gt;findText(rect_topic_current);
+        int point_topic_index = ui_.point_topic_combo_box_-&gt;findText(point_topic_current);
+        int lane_topic_index = ui_.lane_topic_combo_box_-&gt;findText(lane_topic_current);
+
+        if (image_topic_index != -1) {
+            ui_.image_topic_combo_box_-&gt;setCurrentIndex(image_topic_index);
+        }
+
+        if (rect_topic_index != -1) {
+            ui_.rect_topic_combo_box_-&gt;setCurrentIndex(rect_topic_index);
+        }
+
+        if (point_topic_index != -1) {
+            ui_.point_topic_combo_box_-&gt;setCurrentIndex(point_topic_index);
+        }
+
+        if (lane_topic_index != -1) {
+            ui_.lane_topic_combo_box_-&gt;setCurrentIndex(lane_topic_index);
+        }
+
+    } // ImageViewerPlugin::UpdateTopicList()
+
+
+
+
+
+    // The behavior of combo box for image
+    void ImageViewerPlugin::on_image_topic_combo_box__activated(int index) {
+        // Extract selected topic name from combo box
+        std::string selected_topic = ui_.image_topic_combo_box_-&gt;itemText(index).toStdString();
+        if (selected_topic == kBlankTopic.toStdString() || selected_topic == "") {
+            image_sub_.shutdown();
+            // If blank name is selected as image topic, show default image
+            viewed_image_ = default_image_.clone();
+            default_image_shown_ = true;
+            ShowImageOnUi();
+            return;
+        }
+
+        // if selected topic is not blank or empty, start callback function
+        default_image_shown_ = false;
+        image_sub_ = node_handle_.subscribe&lt;sensor_msgs::Image&gt;(selected_topic,
                                                                 1,
-                                                                &amp;ImageViewerPlugin::ImageObjCallback,
+                                                                &amp;ImageViewerPlugin::ImageCallback,
                                                                 this);
-    }
-
-
-  } // ImageViewerPlugin::on_rect_topic_combo_box__activated()
-  
-
-  void ImageViewerPlugin::ImageObjCallback(const autoware_msgs::image_obj::ConstPtr&amp; msg) {
-    image_obj_msg_ = msg;
-  } // ImageViewerPlugin::ImageObjCallback()
-
-  void ImageViewerPlugin::ImageObjRangedCallback(const autoware_msgs::image_obj_ranged::ConstPtr &amp;msg) {
-    image_obj_ranged_msg_ = msg;
-  } // ImageViewerPlugin::ImageObjRangedCallback()
 
-  void ImageViewerPlugin::ImageObjTrackedCallback(const autoware_msgs::image_obj_tracked::ConstPtr &amp;msg) {
-    image_obj_tracked_msg_ = msg;
-  } // ImageViewerPlugin::ImageObjTrackedCallback()
+    } // ImageViewerPlugin::on_image_topic_combo_box__activated()
+
+
+    void ImageViewerPlugin::ImageCallback(const sensor_msgs::Image::ConstPtr &amp;msg) {
+        // Get image from topic
+        const auto &amp;encoding = sensor_msgs::image_encodings::BGR8;
+        viewed_image_ = cv_bridge::toCvCopy(msg, encoding)-&gt;image;
+
+        ShowImageOnUi();
+    } // ImageViewerPlugin::ImageCallback()
+
+
+    // The behavior of combo box for detection result rectangle
+    void ImageViewerPlugin::on_rect_topic_combo_box__activated(int index) {
+        // Extract selected topic name from combo box
+        std::string selected_topic = ui_.rect_topic_combo_box_-&gt;itemText(index).toStdString();
+        if (selected_topic == kBlankTopic.toStdString() || selected_topic == "") {
+            rect_sub_.shutdown();
+            detected_objects_msg_ = NULL;
+            return;
+        }
+
+        // Switch booted callback function by topic name
+        detected_objects_msg_ = NULL;
+        // this topic type is image_obj
+        rect_sub_ = node_handle_.subscribe&lt;autoware_msgs::DetectedObjectArray&gt;(selected_topic,
+                                                                     1,
+                                                                     &amp;ImageViewerPlugin::DetectedObjCallback,
+                                                                     this);
+    } // ImageViewerPlugin::on_detectedobj_topic_combo_box__activated()
+
+
+    void ImageViewerPlugin::DetectedObjCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;msg) {
+        detected_objects_msg_ = msg;
+    } // ImageViewerPlugin::DetectedObjCallback()
+
+    // The behavior of combo box for points image
+    void ImageViewerPlugin::on_point_topic_combo_box__activated(int index) {
+        // Extract selected topic name from combo box
+        std::string selected_topic = ui_.point_topic_combo_box_-&gt;itemText(index).toStdString();
+        if (selected_topic == kBlankTopic.toStdString() || selected_topic == "") {
+            point_sub_.shutdown();
+            points_msg_ = NULL;
+            return;
+        }
+
+        // if selected topic is not blank or empty , start callback function
+        point_sub_ = node_handle_.subscribe&lt;autoware_msgs::PointsImage&gt;(selected_topic,
+                                                                        1,
+                                                                        &amp;ImageViewerPlugin::PointCallback,
+                                                                        this);
 
+    } // ImageViewerPlugin::on_point_topic_combo_box__activated()
 
-  // The behavior of combo box for points image
-  void ImageViewerPlugin::on_point_topic_combo_box__activated(int index) {
-    // Extract selected topic name from combo box
-    std::string selected_topic = ui_.point_topic_combo_box_-&gt;itemText(index).toStdString();
-    if (selected_topic == kBlankTopic.toStdString() || selected_topic == "") {
-      point_sub_.shutdown();
-      points_msg_ = NULL;
-      return;
-    }
 
-    // if selected topic is not blank or empty , start callback function
-    point_sub_ = node_handle_.subscribe&lt;autoware_msgs::PointsImage&gt;(selected_topic,
-                                                                   1,
-                                                                   &amp;ImageViewerPlugin::PointCallback,
-                                                                   this);
+    void ImageViewerPlugin::PointCallback(const autoware_msgs::PointsImage::ConstPtr &amp;msg) {
+        points_msg_ = msg;
+    } // ImageViewerPlugin::PointCallback()
 
-  } // ImageViewerPlugin::on_point_topic_combo_box__activated()
 
+    // The behavior of combo box for detected lane
+    void ImageViewerPlugin::on_lane_topic_combo_box__activated(int index) {
+        // Extract selected topic name from combo box
+        std::string selected_topic = ui_.lane_topic_combo_box_-&gt;itemText(index).toStdString();
+        if (selected_topic == kBlankTopic.toStdString() || selected_topic == "") {
+            lane_sub_.shutdown();
+            lane_msg_ = NULL;
+            return;
+        }
 
-  void ImageViewerPlugin::PointCallback(const autoware_msgs::PointsImage::ConstPtr &amp;msg) {
-    points_msg_ = msg;
-  } // ImageViewerPlugin::PointCallback()
+        // if selected topic is not blank or emtpy, start callback function
+        lane_sub_ = node_handle_.subscribe&lt;autoware_msgs::ImageLaneObjects&gt;(selected_topic,
+                                                                            1,
+                                                                            &amp;ImageViewerPlugin::LaneCallback,
+                                                                            this);
+    }  // void ImageViewerPlugin::on_lane_topic_combo_box__activated()
 
 
-  // The behavior of combo box for detected lane
-  void ImageViewerPlugin::on_lane_topic_combo_box__activated(int index) {
-    // Extract selected topic name from combo box
-    std::string selected_topic = ui_.lane_topic_combo_box_-&gt;itemText(index).toStdString();
-    if (selected_topic == kBlankTopic.toStdString() || selected_topic == "") {
-      lane_sub_.shutdown();
-      lane_msg_ = NULL;
-      return;
+    void ImageViewerPlugin::LaneCallback(const autoware_msgs::ImageLaneObjects::ConstPtr &amp;msg) {
+        lane_msg_ = msg;
     }
 
-    // if selected topic is not blank or emtpy, start callback function
-    lane_sub_ = node_handle_.subscribe&lt;autoware_msgs::ImageLaneObjects&gt;(selected_topic,
-                                                                        1,
-                                                                        &amp;ImageViewerPlugin::LaneCallback,
-                                                                        this);
-  }  // void ImageViewerPlugin::on_lane_topic_combo_box__activated()
-
-
-  void ImageViewerPlugin::LaneCallback(const autoware_msgs::ImageLaneObjects::ConstPtr&amp; msg)  {
-    lane_msg_ = msg;
-  }
+    void ImageViewerPlugin::ShowImageOnUi(void) {
+        // Additional things will be drawn if shown image is not default one
+        if (!default_image_shown_) {
+            // Draw detection result rectangles on the image
+            rects_drawer_.DrawImageRect(detected_objects_msg_, viewed_image_);
 
-  void ImageViewerPlugin::ShowImageOnUi(void) {
-    // Additional things will be drawn if shown image is not default one
-    if (!default_image_shown_) {
-      // Draw detection result rectangles on the image
-      rects_drawer_.DrawImageObj(image_obj_msg_, viewed_image_);
-      rects_drawer_.DrawImageObjRanged(image_obj_ranged_msg_, viewed_image_);
-      rects_drawer_.DrawImageObjTracked(image_obj_tracked_msg_, viewed_image_);
+            // Draw points on the image
+            int point_size = ui_.point_size_spin_box_-&gt;value();
+            points_drawer_.Draw(points_msg_, viewed_image_, point_size);
 
-      // Draw points on the image
-      int point_size = ui_.point_size_spin_box_-&gt;value();
-      points_drawer_.Draw(points_msg_, viewed_image_, point_size);
+            // Draw lane on the image
+            lane_drawer_.Draw(lane_msg_, viewed_image_);
+        }
+        // Convert cv::Mat to QPixmap to show modified image on the UI
+        QPixmap view_on_ui = convert_image::CvMatToQPixmap(viewed_image_);
 
-      // Draw lane on the image
-      lane_drawer_.Draw(lane_msg_, viewed_image_);
-    }
-    // Convert cv::Mat to QPixmap to show modified image on the UI
-    QPixmap view_on_ui = convert_image::CvMatToQPixmap(viewed_image_);
+        // Reflect image on UI
+        int height = ui_.view_-&gt;height();
+        int width = ui_.view_-&gt;width();
+        ui_.view_-&gt;setPixmap(view_on_ui.scaled(width,
+                                               height,
+                                               Qt::KeepAspectRatio,
+                                               Qt::SmoothTransformation));
+    } // ImageViewerPlugin::ShowImageOnUi()
 
-    // Reflect image on UI
-    int height = ui_.view_-&gt;height();
-    int width  = ui_.view_-&gt;width();
-    ui_.view_-&gt;setPixmap(view_on_ui.scaled(width,
-                                           height,
-                                           Qt::KeepAspectRatio,
-                                           Qt::SmoothTransformation));
-  } // ImageViewerPlugin::ShowImageOnUi()
 
+    void ImageViewerPlugin::resizeEvent(QResizeEvent *) {
+        ShowImageOnUi();
+    } // ImageViewerPlugin::resizeEvent()
 
-  void ImageViewerPlugin::resizeEvent(QResizeEvent *) {
-    ShowImageOnUi();
-  } // ImageViewerPlugin::resizeEvent()
 
+    bool ImageViewerPlugin::eventFilter(QObject *object, QEvent *event) {
+        if (event-&gt;type() == QEvent::MouseButtonPress) {
+            // combo box will update its contents if this filter is applied
+            UpdateTopicList();
+        }
 
-  bool ImageViewerPlugin::eventFilter(QObject* object, QEvent* event) {
-    if (event-&gt;type() == QEvent::MouseButtonPress) {
-      // combo box will update its contents if this filter is applied
-      UpdateTopicList();
+        return QObject::eventFilter(object, event);
     }
 
-    return QObject::eventFilter(object, event);
-  }
-
 
 } // end namespace integrated_viewer
 
@@ -370,5 +318,6 @@ namespace integrated_viewer
 // loadable by pluginlib::ClassLoader must have these two lines
 // compiled in its .cpp file, outside of any namespace scope.
 #include &lt;pluginlib/class_list_macros.h&gt;
+
 PLUGINLIB_EXPORT_CLASS(integrated_viewer::ImageViewerPlugin, rviz::Panel)
 // END_TUTORIAL
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" added_lines="4" deleted_lines="14">
				<diff>@@ -20,6 +20,7 @@
 #include &lt;QStringList&gt;
 #include &lt;QWidget&gt;
 #include &lt;QEvent&gt;
+#include &lt;autoware_msgs/DetectedObjectArray.h&gt;
 
 #include "convert_image.h"
 #include "ui_image_viewer_form.h"
@@ -48,9 +49,7 @@ namespace integrated_viewer
     
     // The Callback functions
     void ImageCallback(const sensor_msgs::Image::ConstPtr&amp; msg);
-    void ImageObjCallback(const autoware_msgs::image_obj::ConstPtr&amp; msg);
-    void ImageObjRangedCallback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; msg);
-    void ImageObjTrackedCallback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; msg);
+    void DetectedObjCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;msg);
     void PointCallback(const autoware_msgs::PointsImage::ConstPtr &amp;msg);
     void LaneCallback(const autoware_msgs::ImageLaneObjects::ConstPtr&amp; msg);
 
@@ -59,17 +58,13 @@ namespace integrated_viewer
 
     // The data type of the topic that will be shown in each combo box
     static const QString kImageDataType;
-    static const QString kRectDataTypeBase;
+    static const QString kDetectedObjectDataTypeBase;
     static const QString kPointDataType;
     static const QString kLaneDataType;
 
     // The blank topic name
     static const QString kBlankTopic;
 
-    // The base topic name of detection result rectangles
-    static const std::string  kRectDataTypeImageObjRanged;
-    static const std::string  kRectDataTypeImageObjTracked;
-
     // The ROS node handle.
     ros::NodeHandle node_handle_;
 
@@ -89,14 +84,9 @@ namespace integrated_viewer
 
     // Data pointer to hold subscribed data
     autoware_msgs::PointsImage::ConstPtr points_msg_;
-    autoware_msgs::image_obj::ConstPtr image_obj_msg_;
-    autoware_msgs::image_obj_ranged::ConstPtr image_obj_ranged_msg_;
-    autoware_msgs::image_obj_tracked::ConstPtr image_obj_tracked_msg_;
+    autoware_msgs::DetectedObjectArray::ConstPtr detected_objects_msg_;
     autoware_msgs::ImageLaneObjects::ConstPtr lane_msg_;
 
-    // data structure to hold topic information for detection result
-    std::map&lt;std::string, std::string&gt; rect_topic_info_;
-
     // The helper-class constructor for drawing
     DrawRects rects_drawer_;
     DrawPoints points_drawer_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\image_viewer\image_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\image_viewer\image_viewer.cpp" added_lines="105" deleted_lines="229">
				<diff>@@ -34,52 +34,32 @@
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
 #include &lt;opencv2/core/version.hpp&gt;
+
 #if (CV_MAJOR_VERSION == 3)
 #include "gencolors.cpp"
 #else
+
 #include &lt;opencv2/contrib/contrib.hpp&gt;
+
 #endif
 
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-
-#include &lt;autoware_msgs/image_obj_tracked.h&gt;
-#include &lt;autoware_msgs/image_obj.h&gt;
-
-//DPM related
-static std::vector&lt;cv::Rect&gt; cars;		//objects detected
-static std::vector&lt;float&gt; cars_score;		//score of each object
-//KF related
-static std::vector&lt;cv::Rect&gt; cars_tracked;	//objects tracked for current frame
-static std::vector&lt;int&gt; cars_tracked_lifespan;	//remaining lifespan
-static std::vector&lt;int&gt; cars_tracked_id;	//objects' id
-static std::vector&lt;int&gt; cars_tracked_real_data;	//states if the data contained in the index is real or prediction
-
-//DPM related
-static std::vector&lt;cv::Rect&gt; peds;
-static std::vector&lt;float&gt; peds_score;
-//KF related
-static std::vector&lt;cv::Rect&gt; peds_tracked;
-static std::vector&lt;int&gt; peds_tracked_lifespan;
-static std::vector&lt;int&gt; peds_tracked_id;
-static std::vector&lt;int&gt; peds_tracked_real_data;
+#include &lt;autoware_msgs/DetectedObjectArray.h&gt;
 
 static std::vector&lt;cv::Scalar&gt; _colors;
 
 static const int OBJ_RECT_THICKNESS = 3;
 
 static bool _drawing = false;
-static bool car_track_ready = false;
-static bool car_dpm_ready = false;
-static bool ped_track_ready = false;
-static bool ped_dpm_ready = false;
-
-static bool car_image_obj_ready = false;
-static bool pedestrian_image_obj_ready = false;
 
 static const std::string window_name = "Image Viewer";
 
+autoware_msgs::DetectedObjectArray detected_objects_;
+
+const int kRectangleThickness = 3;
+
 /*static void dashed_rectangle(cv::Mat&amp; img, const cv::Rect&amp; r, const cv::Scalar&amp; color,
 			     int thickness = 2, int dash_length = 10)
 {
@@ -95,231 +75,127 @@ static const std::string window_name = "Image Viewer";
 		cv::line(img, cv::Point(r.x +r.width, r.y+i), cv::Point(r.x+ r.width, r.y+i+(dash_length/2)), color, thickness);
 	}
 }*/
+static void DrawLabel(const std::string &amp;label,
+                      const cv::Point &amp;rectangle_origin,
+                      cv::Mat &amp;image) {
+    // label's property
+    const int font_face = cv::FONT_HERSHEY_COMPLEX;
+    const double font_scale = 0.5;
+    const int font_thickness = 1;
+    int font_baseline = 0;
+
+    cv::Size label_size = cv::getTextSize(label,
+                                          font_face,
+                                          font_scale,
+                                          font_thickness,
+                                          &amp;font_baseline);
+
+    cv::Point label_origin = cv::Point(rectangle_origin.x - kRectangleThickness,
+                                       rectangle_origin.y - font_baseline - kRectangleThickness);
+
+    // Fill label's background by black
+    cv::rectangle(image,
+                  cv::Point(label_origin.x, label_origin.y + font_baseline),
+                  cv::Point(label_origin.x + label_size.width, label_origin.y - label_size.height),
+                  CV_RGB(0, 0, 0),
+                  CV_FILLED);
+
+    // Draw label text by white
+    cv::putText(image,
+                label,
+                label_origin,
+                font_face,
+                font_scale,
+                CV_RGB(255, 255, 255));
 
-static void drawDetections(std::vector&lt;cv::Rect&gt; dets, std::vector&lt;float&gt; scores, std::string objectLabel, IplImage frame)
-{
-	/* variables for object label */
-	CvFont font;
-	const float hscale = 0.5f;
-	const float vscale = 0.5f;
-	const float italicScale = 0.0f;
-	const int thickness = 1;
-	CvSize text_size;
-	int baseline = 0;
-
-	cvInitFont(&amp;font, CV_FONT_HERSHEY_COMPLEX, hscale, vscale, italicScale, thickness, CV_AA);
-
-	//UNTRACKED
-	for(std::size_t i = 0; i &lt; dets.size(); ++i) {
-#ifdef TEMP_DISABLED
-		//temporal way to avoid drawing detections in the sky
-		if (dets[i].y &lt;= frame.height * 0.3)
-			continue;
-#endif
-		std::ostringstream label;
-		label &lt;&lt; objectLabel &lt;&lt; ":" &lt;&lt; std::setprecision(2) &lt;&lt; scores[i];
-		std::string text = label.str();
-
-		//get text size
-		cvGetTextSize(text.data(),
-			&amp;font,
-			&amp;text_size,
-			&amp;baseline);
-
-		//cvRectangle( &amp;frame,
-			//cvPoint(dets[i].x, dets[i].y),
-			//cvPoint(dets[i].x+dets[i].width, dets[i].y+dets[i].height),
-			//CV_RGB(0, 0, 255), OBJ_RECT_THICKNESS, CV_AA, 0);
-		cvCircle(&amp;frame, cvPoint(dets[i].x+dets[i].width/2, dets[i].y+dets[i].height/2), 30, cvScalar(0,255,0),3);		/* draw object label */
-		CvPoint textOrg = cvPoint(dets[i].x - OBJ_RECT_THICKNESS, dets[i].y - baseline - OBJ_RECT_THICKNESS);
-
-		cvRectangle(&amp;frame,
-			cvPoint(textOrg.x + 0 , textOrg.y + baseline),
-			cvPoint(textOrg.x + text_size.width, textOrg.y - text_size.height),
-			CV_RGB(0, 0, 0), // text background is black
-			-1, 8, 0);
-		cvPutText(&amp;frame,
-			text.data(),
-			textOrg,
-			&amp;font,
-			CV_RGB(255, 255, 255) // text color is white
-			);
-	}
 }
 
-static void drawTracked(std::vector&lt;cv::Rect&gt; dets, std::vector&lt;int&gt; lifespan, std::vector&lt;int&gt; obj_id,
-			std::vector&lt;int&gt; real_data, std::string objectLabel, cv::Mat imageTrack)
-{
-	for(std::size_t i=0; i&lt;dets.size();i++) {
-#ifdef TEMP_DISABLED
-		//temporal way to avoid drawing detections in the sky
-		if (dets[i].y &lt;= imageTrack.rows * 0.3)
-			continue;
-#endif
+static void drawDetections(autoware_msgs::DetectedObjectArray detected_objects, cv::Mat frame) {
+    /* variables for object label */
+    for (const auto detected_object : detected_objects.objects) {
+        // Make label shown on a rectangle
+        std::ostringstream label;
+        label &lt;&lt; detected_object.label &lt;&lt; ":" &lt;&lt; std::setprecision(2) &lt;&lt; detected_object.score;
+
+        // Draw object information label
+        DrawLabel(label.str(), cv::Point(detected_object.x, detected_object.y), frame);
+
+        // Draw rectangle
+        cv::rectangle(frame,
+                      cv::Point(detected_object.x, detected_object.y),
+                      cv::Point(detected_object.x + detected_object.width, detected_object.y + detected_object.height),
+                      cv::Scalar(detected_object.color.r, detected_object.color.g, detected_object.color.b),
+                      kRectangleThickness,
+                      CV_AA,
+                      0);
+    }
+}
 
-		std::ostringstream label;
-		label &lt;&lt; objectLabel &lt;&lt; "_" &lt;&lt; obj_id[i] &lt;&lt; ":" &lt;&lt; std::setprecision(2) &lt;&lt; lifespan[i];
-		std::string text = label.str();
+static void image_viewer_callback(const sensor_msgs::Image &amp;image_source) {
+    _drawing = true;
 
-		//if (real_data[i])
-			//rectangle(imageTrack, dets[i], _colors[obj_id[i]], 3);
-	//	else
-			//dashed_rectangle(imageTrack, dets[i], _colors[obj_id[i]], 3, 10);
+    const auto &amp;encoding = sensor_msgs::image_encodings::BGR8;
+    cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source,
+                                                         encoding);
 
-		putText(imageTrack, text.c_str(), cv::Point(dets[i].x + 4, dets[i].y + 15),
-			cv::FONT_HERSHEY_SIMPLEX, 0.55, _colors[obj_id[i]], 2);
-		cv::circle(imageTrack, cv::Point(dets[i].x+dets[i].width/2, dets[i].y+dets[i].height/2), 30, _colors[obj_id[i]],3);
-	}
-}
+    cv::Mat matImage(cv_image-&gt;image);
 
-static void image_viewer_callback(const sensor_msgs::Image&amp; image_source)
-{
-	_drawing = true;
-
-	const auto&amp; encoding = sensor_msgs::image_encodings::BGR8;
-	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source,
-							     encoding);
-	IplImage frame = cv_image-&gt;image;
-
-	cv::Mat matImage(cv_image-&gt;image);
-	cv::Mat imageTrack = matImage.clone();
-
-	//UNTRACKED
-	putText(matImage, "PIXEL_XY", cv::Point(10,10), cv::FONT_HERSHEY_SIMPLEX, 0.55, cv::Scalar(0, 0, 255), 2);
-	if (car_dpm_ready)
-		drawDetections(cars, cars_score, "car", frame);
-	if (ped_dpm_ready)
-		drawDetections(peds, peds_score, "pedestrian", frame);
-
-	if (car_image_obj_ready)
-		drawDetections(cars, cars_score, "car", frame);
-	if (pedestrian_image_obj_ready)
-		drawDetections(peds, peds_score, "pedestrian", frame);
-
-	//TRACKED
-	putText(imageTrack, "PIXEL_XY_TRACKED", cv::Point(10,10), cv::FONT_HERSHEY_SIMPLEX, 0.55, cv::Scalar(0, 255, 0), 2);
-	if(car_track_ready)
-		drawTracked(cars_tracked, cars_tracked_lifespan, cars_tracked_id, cars_tracked_real_data, "car", imageTrack);
-	if(ped_track_ready)
-		drawTracked(peds_tracked, peds_tracked_lifespan, peds_tracked_id, peds_tracked_real_data, "pedestrian", imageTrack);
-
-	cv::Mat merged;
-	hconcat(matImage, imageTrack, merged);
-
-	if (cvGetWindowHandle(window_name.c_str()) != NULL) // Guard not to write destroyed window by using close button on the window
-		{
-			imshow(window_name, merged);
-			cvWaitKey(2);
-		}
-
-	_drawing = false;
-}
+    //UNTRACKED
 
-static void image_obj_update_cb(const autoware_msgs::image_obj&amp; image_objs)
-{
-	if(_drawing)
-		return;
-
-	bool is_car = (image_objs.type == "car");
-	std::vector&lt;cv::Rect&gt;&amp; objs = is_car ? cars : peds;
-	std::vector&lt;float&gt;&amp; scores = is_car ? cars_score : peds_score;
-	
-	objs.clear();
-	scores.clear();
-
-	for (const auto&amp; obj : image_objs.obj) {
-		cv::Rect tmp;
-		tmp.x = obj.x;
-		tmp.y = obj.y;
-		tmp.width = obj.width;
-		tmp.height = obj.height;
-
-		objs.push_back(tmp);
-		scores.push_back(obj.score);
-	}
+    drawDetections(detected_objects_, matImage);
 
-	if (is_car) {
-		car_image_obj_ready = true;
-	} else {
-		pedestrian_image_obj_ready = true;
-	}
+
+    if (cvGetWindowHandle(window_name.c_str()) !=
+        NULL) // Guard not to write destroyed window by using close button on the window
+    {
+        imshow(window_name, matImage);
+        cvWaitKey(2);
+    }
+
+    _drawing = false;
 }
 
-static void image_obj_updater_cb_tracked(const autoware_msgs::image_obj_tracked&amp; image_objs_tracked_msg)
-{
-	if(_drawing)
-		return;
-	bool is_car = (image_objs_tracked_msg.type == "car");
-	std::vector&lt;cv::Rect&gt;&amp; objs_tracked = is_car ? cars_tracked : peds_tracked;
-	std::vector&lt;int&gt;&amp; objs_tracked_lifespan = is_car ? cars_tracked_lifespan : peds_tracked_lifespan;
-	std::vector&lt;int&gt;&amp; objs_tracked_id = is_car ? cars_tracked_id : peds_tracked_id;
-	std::vector&lt;int&gt;&amp; objs_tracked_real_data = is_car ? cars_tracked_real_data : peds_tracked_real_data;
-
-	objs_tracked_lifespan = image_objs_tracked_msg.lifespan;
-	objs_tracked_id = image_objs_tracked_msg.obj_id;
-	objs_tracked_real_data = image_objs_tracked_msg.real_data;
-
-	objs_tracked.clear();
-	for (const auto&amp; rect_ranged : image_objs_tracked_msg.rect_ranged)
-		{
-			cv::Rect tmp;
-			tmp.x = rect_ranged.rect.x;
-			tmp.y = rect_ranged.rect.y;
-			tmp.width = rect_ranged.rect.width;
-			tmp.height = rect_ranged.rect.height;
-
-			objs_tracked.push_back(tmp);
-		}
-
-	if(is_car) {
-		car_track_ready = true;
-	} else {
-		ped_track_ready = true;
-	}
+static void image_obj_update_cb(const autoware_msgs::DetectedObjectArray &amp;image_objs) {
+    if (_drawing)
+        return;
+
+    detected_objects_ = image_objs;
 }
 
-int main(int argc, char **argv)
-{
+int main(int argc, char **argv) {
 
-	/* create resizable window */
-	cv::namedWindow(window_name, cv::WINDOW_NORMAL);
-	cv::startWindowThread();
+    /* create resizable window */
+    cv::namedWindow(window_name, cv::WINDOW_NORMAL);
+    cv::startWindowThread();
 
-	ros::init(argc, argv, "image_viewer");
-	ros::NodeHandle n;
-	ros::NodeHandle private_nh("~");
+    ros::init(argc, argv, "image_viewer");
+    ros::NodeHandle n;
+    ros::NodeHandle private_nh("~");
 
-	std::string image_topic_name;
+    std::string image_topic_name;
 
-	if (private_nh.getParam("image_raw_topic", image_topic_name)) {
-		ROS_INFO("Setting image topic to %s", image_topic_name.c_str());
-	} else {
-		ROS_INFO("No image topic received, defaulting to image_raw, you can use _image_raw_topic:=YOUR_NODE");
-		image_topic_name = "/image_raw";
-	}
+    if (private_nh.getParam("image_raw_topic", image_topic_name)) {
+        ROS_INFO("Setting image topic to %s", image_topic_name.c_str());
+    } else {
+        ROS_INFO("No image topic received, defaulting to image_raw, you can use _image_raw_topic:=YOUR_NODE");
+        image_topic_name = "/image_raw";
+    }
 
 #if (CV_MAJOR_VERSION == 3)
-	generateColors(_colors, 25);
+    generateColors(_colors, 25);
 #else
-	cv::generateColors(_colors, 25);
+    cv::generateColors(_colors, 25);
 #endif
 
-	ros::Subscriber scriber = n.subscribe(image_topic_name, 1, image_viewer_callback);
-
-	ros::Subscriber scriber_car = n.subscribe("/obj_car/image_obj", 1,
-						image_obj_update_cb);
-	ros::Subscriber scriber_ped = n.subscribe("/obj_person/image_obj", 1,
-						image_obj_update_cb);
+    ros::Subscriber scriber = n.subscribe(image_topic_name, 1, image_viewer_callback);
 
-	ros::Subscriber scriber_ped_tracked = n.subscribe("/obj_person/image_obj_tracked", 1,
-						image_obj_updater_cb_tracked);
-	ros::Subscriber scriber_car_tracked = n.subscribe("/obj_car/image_obj_tracked", 1,
-						image_obj_updater_cb_tracked);
+    ros::Subscriber scriber_obj = n.subscribe("/detected_objects", 1,
+                                              image_obj_update_cb);
 
-	ros::spin();
+    ros::spin();
 
-	/* destroy window */
-	cv::destroyWindow(window_name);
+    /* destroy window */
+    cv::destroyWindow(window_name);
 
-	return 0;
+    return 0;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\cfg\yolov3-voc.cfg" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\cfg\yolov3-voc.cfg" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\cfg\yolov3.cfg" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\cfg\yolov3.cfg" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\activation_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\activation_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\activation_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\activation_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\activation_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\activation_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\activations.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\activations.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\activations.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\activations.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\avgpool_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\avgpool_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\avgpool_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\avgpool_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\avgpool_layer_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\avgpool_layer_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\batchnorm_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\batchnorm_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\batchnorm_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\batchnorm_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\blas.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\blas.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\blas.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\blas.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\blas_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\blas_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\box.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\box.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\box.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\box.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\classifier.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\classifier.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\col2im.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\col2im.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\col2im.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\col2im.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\col2im_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\col2im_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\connected_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\connected_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\connected_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\connected_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\convolutional_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\convolutional_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\convolutional_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\convolutional_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\convolutional_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\convolutional_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\cost_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\cost_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\cost_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\cost_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\crnn_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\crnn_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\crnn_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\crnn_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\crop_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\crop_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\crop_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\crop_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\crop_layer_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\crop_layer_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\cuda.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\cuda.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\cuda.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\cuda.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\darknet.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\darknet.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\data.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\data.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\data.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\data.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\deconvolutional_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\deconvolutional_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\deconvolutional_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\deconvolutional_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\deconvolutional_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\deconvolutional_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\demo.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\demo.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\demo.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\demo.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\detection_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\detection_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\detection_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\detection_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\dropout_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\dropout_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\dropout_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\dropout_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\dropout_layer_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\dropout_layer_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\gemm.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\gemm.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\gemm.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\gemm.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\gru_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\gru_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\gru_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\gru_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\im2col.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\im2col.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\im2col.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\im2col.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\im2col_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\im2col_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\image.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\image.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\image.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\image.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\l2norm_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\l2norm_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\l2norm_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\l2norm_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\list.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\list.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\list.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\list.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\local_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\local_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\local_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\local_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\logistic_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\logistic_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\logistic_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\logistic_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\lstm_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\lstm_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\lstm_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\lstm_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\matrix.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\matrix.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\matrix.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\matrix.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\maxpool_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\maxpool_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\maxpool_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\maxpool_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\maxpool_layer_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\maxpool_layer_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\network.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\network.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\network.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\network.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\normalization_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\normalization_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\normalization_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\normalization_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\option_list.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\option_list.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\option_list.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\option_list.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\parser.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\parser.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\parser.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\parser.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\region_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\region_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\region_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\region_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\reorg_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\reorg_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\reorg_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\reorg_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\rnn_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\rnn_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\rnn_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\rnn_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\route_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\route_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\route_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\route_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\shortcut_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\shortcut_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\shortcut_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\shortcut_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\softmax_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\softmax_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\softmax_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\softmax_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\stb_image.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\stb_image.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\stb_image_write.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\stb_image_write.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\tree.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\tree.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\tree.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\tree.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\upsample_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\upsample_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\upsample_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\upsample_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\utils.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\utils.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\utils.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\utils.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\yolo_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\yolo_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\yolo_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\yolo_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\src\vision_yolo3_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.cpp" added_lines="41" deleted_lines="49">
				<diff>@@ -33,7 +33,13 @@
  *
  *  Created on: April 4th, 2018
  */
-#include "vision_yolo3_detect.h"
+#include "vision_darknet_detect.h"
+
+#if (CV_MAJOR_VERSION &lt;= 2)
+#include &lt;opencv2/contrib/contrib.hpp&gt;
+#else
+#include "gencolors.cpp"
+#endif
 
 namespace darknet
 {
@@ -151,46 +157,35 @@ namespace darknet
 
 ///////////////////
 
-void Yolo3DetectorNode::convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, autoware_msgs::image_obj&amp; out_message, std::string in_class)
+void Yolo3DetectorNode::convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, autoware_msgs::DetectedObjectArray&amp; out_message)
 {
     for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
     {
-        if ( (in_class == "car"
-              &amp;&amp; (in_objects[i].class_type == Yolo3::CAR
-                  || in_objects[i].class_type == Yolo3::BUS
-                  || in_objects[i].class_type == Yolo3::TRUCK
-                  || in_objects[i].class_type == Yolo3::MOTORBIKE
-              )
-             ) || (in_class == "person"
-               &amp;&amp; (in_objects[i].class_type == Yolo3::PERSON
-                   || in_objects[i].class_type == Yolo3::BICYCLE
-                   || in_objects[i].class_type == Yolo3::DOG
-                   || in_objects[i].class_type == Yolo3::CAT
-                   || in_objects[i].class_type == Yolo3::HORSE
-                   )
-                  )
-        )
         {
-            autoware_msgs::image_rect rect;
+            autoware_msgs::DetectedObject obj;
 
-            rect.x = (in_objects[i].x /image_ratio_) - image_left_right_border_/image_ratio_;
-            rect.y = (in_objects[i].y /image_ratio_) - image_top_bottom_border_/image_ratio_;
-            rect.width = in_objects[i].w /image_ratio_;
-            rect.height = in_objects[i].h /image_ratio_;
+            obj.x = (in_objects[i].x /image_ratio_) - image_left_right_border_/image_ratio_;
+            obj.y = (in_objects[i].y /image_ratio_) - image_top_bottom_border_/image_ratio_;
+            obj.width = in_objects[i].w /image_ratio_;
+            obj.height = in_objects[i].h /image_ratio_;
             if (in_objects[i].x &lt; 0)
-                rect.x = 0;
+                obj.x = 0;
             if (in_objects[i].y &lt; 0)
-                rect.y = 0;
+                obj.y = 0;
             if (in_objects[i].w &lt; 0)
-                rect.width = 0;
+                obj.width = 0;
             if (in_objects[i].h &lt; 0)
-                rect.height = 0;
+                obj.height = 0;
 
-            rect.score = in_objects[i].score;
+            obj.color.r = colors_[in_objects[i].class_type].val[0];
+            obj.color.g = colors_[in_objects[i].class_type].val[1];
+            obj.color.b = colors_[in_objects[i].class_type].val[2];
+            obj.color.a = 1.0f;
 
-            //std::cout &lt;&lt; "x "&lt;&lt; rect.x&lt;&lt; " y " &lt;&lt; rect.y &lt;&lt; " w "&lt;&lt; rect.width &lt;&lt; " h "&lt;&lt; rect.height&lt;&lt; " s " &lt;&lt; rect.score &lt;&lt; " c " &lt;&lt; in_objects[i].class_type &lt;&lt; std::endl;
+            obj.score = in_objects[i].score;
+            obj.label = in_objects[i].GetClassString();
 
-            out_message.obj.push_back(rect);
+            out_message.objects.push_back(obj);
 
         }
     }
@@ -212,10 +207,10 @@ image Yolo3DetectorNode::convert_ipl_to_image(const sensor_msgs::ImageConstPtr&amp;
     cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(msg, "bgr8");//toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
     cv::Mat mat_image = cv_image-&gt;image;
 
-    uint32_t network_input_width = yolo_detector_.get_network_width();
-    uint32_t network_input_height = yolo_detector_.get_network_height();
+    int network_input_width = yolo_detector_.get_network_width();
+    int network_input_height = yolo_detector_.get_network_height();
 
-    uint32_t image_height = msg-&gt;height,
+    int image_height = msg-&gt;height,
             image_width = msg-&gt;width;
 
     IplImage ipl_image;
@@ -234,7 +229,6 @@ image Yolo3DetectorNode::convert_ipl_to_image(const sensor_msgs::ImageConstPtr&amp;
                            image_top_bottom_border_, image_top_bottom_border_,
                            image_left_right_border_, image_left_right_border_,
                            cv::BORDER_CONSTANT, cv::Scalar(0,0,0));
-
     }
     else
         final_mat = mat_image;
@@ -270,26 +264,19 @@ void Yolo3DetectorNode::image_callback(const sensor_msgs::ImageConstPtr&amp; in_imag
     detections = yolo_detector_.detect(darknet_image_);
 
     //Prepare Output message
-    autoware_msgs::image_obj output_car_message;
-    autoware_msgs::image_obj output_person_message;
-    output_car_message.header = in_image_message-&gt;header;
-    output_car_message.type = "car";
+    autoware_msgs::DetectedObjectArray output_message;
+    output_message.header = in_image_message-&gt;header;
 
-    output_person_message.header = in_image_message-&gt;header;
-    output_person_message.type = "person";
+    convert_rect_to_image_obj(detections, output_message);
 
-    convert_rect_to_image_obj(detections, output_car_message, "car");
-    convert_rect_to_image_obj(detections, output_person_message, "person");
-
-    publisher_car_objects_.publish(output_car_message);
-    publisher_person_objects_.publish(output_person_message);
+    publisher_objects_.publish(output_message);
 
     free(darknet_image_.data);
 }
 
 void Yolo3DetectorNode::config_cb(const autoware_msgs::ConfigSsd::ConstPtr&amp; param)
 {
-    score_threshold_ 	= param-&gt;score_threshold;
+    score_threshold_ = param-&gt;score_threshold;
 }
 
 
@@ -338,12 +325,17 @@ void Yolo3DetectorNode::Run()
     ROS_INFO("[%s] nms_threshold: %f",__APP_NAME__, nms_threshold_);
 
 
-    ROS_INFO("Initializing Yolo3 on Darknet...");
+    ROS_INFO("Initializing Yolo on Darknet...");
     yolo_detector_.load(network_definition_file, pretrained_model_file, score_threshold_, nms_threshold_);
     ROS_INFO("Initialization complete.");
 
-    publisher_car_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;("/obj_car/image_obj", 1);
-    publisher_person_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;("/obj_person/image_obj", 1);
+    #if (CV_MAJOR_VERSION &lt;= 2)
+        cv::generateColors(colors_, 80);
+    #else
+        generateColors(colors_, 80);
+    #endif
+
+    publisher_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/vision_objects", 1);
 
     ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
     subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;Yolo3DetectorNode::image_callback, this);
@@ -355,6 +347,6 @@ void Yolo3DetectorNode::Run()
     ROS_INFO_STREAM( __APP_NAME__ &lt;&lt; "" );
 
     ros::spin();
-    ROS_INFO("END Yolo3");
+    ROS_INFO("END Yolo");
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\src\vision_yolo3_detect.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.h" added_lines="8" deleted_lines="20">
				<diff>@@ -36,7 +36,7 @@
 #ifndef DARKNET_YOLO3_H
 #define DARKNET_YOLO3_H
 
-#define __APP_NAME__ "vision_yolo3_detect"
+#define __APP_NAME__ "vision_darknet_detect"
 
 #include &lt;cstdint&gt;
 #include &lt;cstdlib&gt;
@@ -49,12 +49,14 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 
 #include &lt;autoware_msgs/ConfigSsd.h&gt;
-#include &lt;autoware_msgs/image_obj.h&gt;
+#include &lt;autoware_msgs/DetectedObject.h&gt;
+#include &lt;autoware_msgs/DetectedObjectArray.h&gt;
 
 #include &lt;rect_class_score.h&gt;
 
 #include &lt;opencv2/opencv.hpp&gt;
 
+
 extern "C"
 {
 #undef __cplusplus
@@ -69,21 +71,6 @@ extern "C"
 #define __cplusplus
 }
 
-namespace Yolo3
-{
-    enum YoloDetectorClasses//using coco for default cfg and weights
-    {
-        PERSON, BICYCLE, CAR, MOTORBIKE, AEROPLANE, BUS, TRAIN, TRUCK, BOAT, TRAFFIC_LIGHT,
-        FIRE_HYDRANT, STOP_SIGN, PARKING_METER, BENCH, BIRD, CAT, DOG, HORSE, SHEEP, COW,
-        ELEPHANT, BEAR, ZEBRA, GIRAFFE, BACKPACK, UMBRELLA, HANDBAG, TIE, SUITCASE, FRISBEE,
-        SKIS, SNOWBOARD, SPORTS_BALL, KITE, BASEBALL_BAT, BASEBALL_GLOVE, SKATEBOARD, SURFBOARD, TENNIS_RACKET, BOTTLE,
-        WINE_GLASS, CUP, FORK, KNIFE, SPOON, BOWL, BANANA, APPLE, SANDWICH, ORANGE,
-        BROCCOLI, CARROT, HOT_DOG, PIZZA, DONUT, CAKE, CHAIR, SOFA, POTTEDPLANT, BED,
-        DININGTABLE, TOILET, TVMONITOR, LAPTOP, MOUSE, REMOTE, KEYBOARD, CELL_PHONE, MICROWAVE, OVEN,
-        TOASTER, SINK, REFRIGERATOR, BOOK, CLOCK, VASE, SCISSORS, TEDDY_BEAR, HAIR_DRIER, TOOTHBRUSH,
-    };
-}
-
 namespace darknet {
     class Yolo3Detector {
     private:
@@ -114,8 +101,7 @@ namespace darknet {
 class Yolo3DetectorNode {
     ros::Subscriber subscriber_image_raw_;
     ros::Subscriber subscriber_yolo_config_;
-    ros::Publisher publisher_car_objects_;
-    ros::Publisher publisher_person_objects_;
+    ros::Publisher publisher_objects_;
     ros::NodeHandle node_handle_;
 
     darknet::Yolo3Detector yolo_detector_;
@@ -127,8 +113,10 @@ class Yolo3DetectorNode {
     double image_ratio_;//resdize ratio used to fit input image to network input size
     uint32_t image_top_bottom_border_;//black strips added to the input image to maintain aspect ratio while resizing it to fit the network input size
     uint32_t image_left_right_border_;
+    std::vector&lt;cv::Scalar&gt; colors_;
+
 
-    void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, autoware_msgs::image_obj&amp; out_message, std::string in_class);
+    void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, autoware_msgs::DetectedObjectArray&amp; out_message);
     void rgbgr_image(image&amp; im);
     image convert_ipl_to_image(const sensor_msgs::ImageConstPtr&amp; msg);
     void image_callback(const sensor_msgs::ImageConstPtr&amp; in_image_message);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\src\vision_yolo3_detect_node.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect_node.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -32,11 +32,11 @@
  *  Created on: April 4th, 2018
  */
 
-#include "vision_yolo3_detect.h"
+#include "vision_darknet_detect.h"
 
 int main(int argc, char **argv)
 {
-    ros::init(argc, argv, "vision_yolo3_detect");
+    ros::init(argc, argv, "vision_darknet_detect");
 
     Yolo3DetectorNode app;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -44,7 +44,7 @@ SsdDetector::SsdDetector(const std::string&amp; in_network_definition_file,
 		caffe::Caffe::set_mode(caffe::Caffe::CPU);
 
 	/* Load the network. */
-	net_.reset(new caffe::Net&lt;float&gt;(in_network_definition_file, caffe::TEST));
+	net_.reset(new caffe::Net&lt;float&gt;(in_network_definition_file, caffe::Phase::TEST));
 	net_-&gt;CopyTrainedLayersFrom(in_pre_trained_model_file);
 
 	CHECK_EQ(net_-&gt;num_inputs(), 1)&lt;&lt; "Network should have exactly one input.";
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" added_lines="49" deleted_lines="53">
				<diff>@@ -32,8 +32,9 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include "autoware_msgs/image_obj.h"
 #include "autoware_msgs/ConfigSsd.h"
+#include "autoware_msgs/DetectedObject.h"
+#include "autoware_msgs/DetectedObjectArray.h"
 
 #include &lt;rect_class_score.h&gt;
 
@@ -41,7 +42,9 @@
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 
 #if (CV_MAJOR_VERSION &lt;= 2)
-#include &lt;opencv2/contrib/contrib.hpp&gt;
+    #include &lt;opencv2/contrib/contrib.hpp&gt;
+#else
+    #include "gencolors.cpp"
 #endif
 
 #include "vision_ssd_detect.h"
@@ -50,11 +53,11 @@ class RosSsdApp
 {
 	ros::Subscriber subscriber_image_raw_;
 	ros::Subscriber subscriber_ssd_config_;
-	ros::Publisher publisher_car_objects_;
-	ros::Publisher publisher_person_objects_;
+    ros::Publisher publisher_detected_objects_;
 	ros::NodeHandle node_handle_;
 
 	cv::Scalar pixel_mean_;
+    std::vector&lt;cv::Scalar&gt; colors_;
 
 	//Caffe based Object Detection ConvNet
 	SsdDetector* ssd_detector_;
@@ -71,40 +74,37 @@ class RosSsdApp
 	//vector of indices of the classes to search for
 	std::vector&lt;unsigned int&gt; detect_classes_;
 
-	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, autoware_msgs::image_obj&amp; out_message, cv::Mat&amp; in_image, std::string in_class)
-	{
-		for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
-		{
-			if ( (in_objects[i].score &gt; score_threshold_)
-				&amp;&amp; (	(in_class == "car" &amp;&amp; (in_objects[i].class_type == Ssd::CAR || in_objects[i].class_type == Ssd::BUS))
-						|| (in_class == "person" &amp;&amp; (in_objects[i].class_type == Ssd::PERSON || in_objects[i].class_type == Ssd::BICYCLE))
-					)
-
-				)//check if the score is larger than minimum required
-			{
-				//std::cout &lt;&lt; in_objects[i].toString() &lt;&lt; std::endl;
-				autoware_msgs::image_rect rect;
-
-				rect.x = in_objects[i].x;
-				rect.y = in_objects[i].y;
-				rect.width = in_objects[i].w;
-				rect.height = in_objects[i].h;
-				if (in_objects[i].x &lt; 0)
-					rect.x = 0;
-				if (in_objects[i].y &lt; 0)
-					rect.y = 0;
-				if (in_objects[i].w &lt; 0)
-					rect.width = 0;
-				if (in_objects[i].h &lt; 0)
-					rect.height = 0;
-
-				rect.score = in_objects[i].score;
-
-				out_message.obj.push_back(rect);
-
-			}
-		}
-	}
+	void convert_rect_to_detected_object(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects,
+                                         autoware_msgs::DetectedObjectArray&amp; out_message,
+                                         cv::Mat&amp; in_image)
+    {
+        for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
+        {
+            if (in_objects[i].score &gt;= score_threshold_)
+            {
+                autoware_msgs::DetectedObject obj;
+                obj.header = out_message.header;
+                obj.id = i;
+                obj.label = in_objects[i].GetClassString();
+                obj.score = in_objects[i].score;
+
+                obj.color.r = colors_[in_objects[i].class_type].val[0];
+                obj.color.g = colors_[in_objects[i].class_type].val[1];
+                obj.color.b = colors_[in_objects[i].class_type].val[2];
+                obj.color.a = 1.0f;
+
+                obj.image_frame = out_message.header.frame_id;
+                obj.x = in_objects[i].x;
+                obj.y = in_objects[i].y;
+                obj.width = in_objects[i].w;
+                obj.height = in_objects[i].h;
+
+                //obj.roi_image = in_image(cv::Rect(obj.x, obj.y, obj.width, obj.height));
+
+                out_message.objects.push_back(obj);
+            }
+        }
+    }
 
 	void image_callback(const sensor_msgs::Image&amp; image_source)
 	{
@@ -117,26 +117,17 @@ class RosSsdApp
 		//cv::TickMeter timer; timer.start();
 		//std::cout &lt;&lt; "score:" &lt;&lt; score_threshold_ &lt;&lt; " slices:" &lt;&lt; image_slices_ &lt;&lt; " slices overlap:" &lt;&lt; slices_overlap_ &lt;&lt; "nms" &lt;&lt; group_threshold_ &lt;&lt; std::endl;
 		detections = ssd_detector_-&gt;Detect(image);
-
 		//timer.stop();
 		//std::cout &lt;&lt; "Detection took: " &lt;&lt; timer.getTimeMilli() &lt;&lt; std::endl;
 
 		//Prepare Output message
-		autoware_msgs::image_obj output_car_message;
-		autoware_msgs::image_obj output_person_message;
-		output_car_message.header = image_source.header;
-		output_car_message.type = "car";
-
-		output_person_message.header = image_source.header;
-		output_person_message.type = "person";
-
 		//Convert Objects to Message type
 		//timer.reset(); timer.start();
-		convert_rect_to_image_obj(detections, output_car_message, image, "car");
-		convert_rect_to_image_obj(detections, output_person_message, image, "person");
+        autoware_msgs::DetectedObjectArray output_detected_message;
+        output_detected_message.header = image_source.header;
+        convert_rect_to_detected_object(detections, output_detected_message, image);
 
-		publisher_car_objects_.publish(output_car_message);
-		publisher_person_objects_.publish(output_person_message);
+		publisher_detected_objects_.publish(output_detected_message);
 	}
 
 
@@ -211,8 +202,13 @@ public:
 		}
 		ROS_INFO("SSD Detector initialized.");
 
-		publisher_car_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;("/obj_car/image_obj", 1);
-		publisher_person_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;("/obj_person/image_obj", 1);
+        #if (CV_MAJOR_VERSION &lt;= 2)
+            cv::generateColors(colors_, 20);
+        #else
+            generateColors(colors_, 20);
+        #endif
+
+        publisher_detected_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/vision_objects", 1);
 
 		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
 		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosSsdApp::image_callback, this);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo2_detect\include\darknet\yolo2.h" new_path="" added_lines="0" deleted_lines="44">
				<diff>@@ -1,44 +0,0 @@
-#ifndef DARKNET_YOLO2_H
-#define DARKNET_YOLO2_H
-
-#include &lt;image_transport/image_transport.h&gt;
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include &lt;rect_class_score.h&gt;
-
-extern "C"
-{
-	#undef __cplusplus
-		#include "box.h"
-		#include "image.h"
-		#include "network.h"
-	#define __cplusplus
-}
-
-namespace darknet
-{
-	class Yolo2Detector
-	{
-		private:
-			std::vector&lt; RectClassScore&lt;float&gt; &gt; forward(image&amp; in_darknet_image);
-
-			double min_confidence_, nms_threshold_;
-			network darknet_network_;
-			std::vector&lt;box&gt; darknet_boxes_;
-			std::vector&lt;float *&gt; darknet_box_scores_;
-		public:
-			Yolo2Detector() {}
-			void load(std::string&amp; in_model_file, std::string&amp; in_trained_file, double in_min_confidence, double in_nms_threshold);
-			~Yolo2Detector();
-			image convert_image(const sensor_msgs::ImageConstPtr&amp; in_image_msg);
-			std::vector&lt; RectClassScore&lt;float&gt; &gt; detect(image&amp; in_darknet_image);
-			uint32_t get_network_width();
-			uint32_t get_network_height();
-
-
-	};
-}  // namespace darknet
-
-#endif  // DARKNET_YOLO2_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo2_detect\include\rect_class_score.h" new_path="" added_lines="0" deleted_lines="52">
				<diff>@@ -1,52 +0,0 @@
-#ifndef RECTCLASSSCORE_H_
-#define RECTCLASSSCORE_H_
-
-#include &lt;sstream&gt;
-#include &lt;string&gt;
-
-template&lt;typename _Tp&gt; class RectClassScore
-{
-public:
-	_Tp x, y, w, h;
-	_Tp score;
-	unsigned int class_type;
-	bool enabled;
-
-	inline std::string toString()
-	{
-		std::ostringstream out;
-		out &lt;&lt; "P(" &lt;&lt; GetClassString() &lt;&lt; ") at " &lt;&lt; "(x:" &lt;&lt; x &lt;&lt; ", y:" &lt;&lt; y &lt;&lt; ", w:" &lt;&lt; w &lt;&lt; ", h:" &lt;&lt; h &lt;&lt; ") =" &lt;&lt; score;
-		return out.str();
-	}
-	inline std::string GetClassString()
-	{
-		switch (class_type)
-		{
-			case 0: return "nothing";
-			case 1: return "plane";
-			case 2: return "bicycle";
-			case 3: return "bird";
-			case 4: return "boat";
-			case 5: return "bottle";
-			case 6: return "bus";
-			case 7: return "car";
-			case 8: return "cat";
-			case 9: return "chair";
-			case 10:return "cow";
-			case 11:return "table";
-			case 12:return "dog";
-			case 13:return "horse";
-			case 14:return "motorbike";
-			case 15:return "person";
-			case 16:return "plant";
-			case 17:return "sheep";
-			case 18:return "sofa";
-			case 19:return "train";
-			case 20:return "tv";
-			default:return "error";
-		}
-	}
-};
-
-
-#endif /* RECTCLASSSCORE_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo2_detect\src\darknet\yolo2.cpp" new_path="" added_lines="0" deleted_lines="142">
				<diff>@@ -1,142 +0,0 @@
-#include "darknet/yolo2.h"
-
-#include &lt;image_transport/image_transport.h&gt;
-#include &lt;sensor_msgs/image_encodings.h&gt;
-
-#include &lt;cstdint&gt;
-#include &lt;cstdlib&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include &lt;rect_class_score.h&gt;
-
-extern "C"
-{
-	#undef __cplusplus
-		#include "detection_layer.h"
-		#include "parser.h"
-		#include "region_layer.h"
-		#include "utils.h"
-		#include "image.h"
-	#define __cplusplus
-}
-
-namespace darknet
-{
-	uint32_t Yolo2Detector::get_network_height()
-	{
-		return darknet_network_.h;
-	}
-	uint32_t Yolo2Detector::get_network_width()
-	{
-		return darknet_network_.w;
-	}
-	void Yolo2Detector::load(std::string&amp; in_model_file, std::string&amp; in_trained_file, double in_min_confidence, double in_nms_threshold)
-	{
-		min_confidence_ = in_min_confidence;
-		nms_threshold_ = in_nms_threshold;
-		darknet_network_ = parse_network_cfg(&amp;in_model_file[0]);
-		load_weights(&amp;darknet_network_, &amp;in_trained_file[0]);
-		set_batch_network(&amp;darknet_network_, 1);
-
-		layer output_layer = darknet_network_.layers[darknet_network_.n - 1];
-		darknet_boxes_.resize(output_layer.w * output_layer.h * output_layer.n);
-		darknet_box_scores_.resize(output_layer.w * output_layer.h * output_layer.n);
-		float *probs_mem = static_cast&lt;float *&gt;(calloc(darknet_box_scores_.size() * output_layer.classes, sizeof(float)));
-		for (auto&amp; i : darknet_box_scores_)
-		{
-			i = probs_mem;
-			probs_mem += output_layer.classes;
-		}
-	}
-
-	Yolo2Detector::~Yolo2Detector()
-	{
-		free(darknet_box_scores_[0]);
-		free_network(darknet_network_);
-	}
-
-	std::vector&lt; RectClassScore&lt;float&gt; &gt; Yolo2Detector::detect(image&amp; in_darknet_image)
-	{
-		return forward(in_darknet_image);
-	}
-
-	image Yolo2Detector::convert_image(const sensor_msgs::ImageConstPtr&amp; msg)
-	{
-		if (msg-&gt;encoding != sensor_msgs::image_encodings::BGR8)
-		{
-			ROS_ERROR("Unsupported encoding");
-			exit(-1);
-		}
-
-		auto data = msg-&gt;data;
-		uint32_t height = msg-&gt;height, width = msg-&gt;width, offset = msg-&gt;step - 3 * width;
-		uint32_t i = 0, j = 0;
-		image im = make_image(width, height, 3);
-
-		for (uint32_t line = height; line; line--)
-		{
-			for (uint32_t column = width; column; column--)
-			{
-				for (uint32_t channel = 0; channel &lt; 3; channel++)
-					im.data[i + width * height * channel] = data[j++] / 255.;
-				i++;
-			}
-			j += offset;
-		}
-
-		if (darknet_network_.w == (int) width &amp;&amp; darknet_network_.h == (int) height)
-		{
-			return im;
-		}
-		image resized = resize_image(im, darknet_network_.w, darknet_network_.h);
-		free_image(im);
-		return resized;
-	}
-
-	std::vector&lt; RectClassScore&lt;float&gt; &gt; Yolo2Detector::forward(image&amp; in_darknet_image)
-	{
-		float * in_data = in_darknet_image.data;
-		float *prediction = network_predict(darknet_network_, in_data);
-		layer output_layer = darknet_network_.layers[darknet_network_.n - 1];
-
-		output_layer.output = prediction;
-		if (output_layer.type == DETECTION)
-			get_detection_boxes(output_layer, 1, 1, min_confidence_, darknet_box_scores_.data(), darknet_boxes_.data(), 0);
-		else if (output_layer.type == REGION)
-		{
-			get_region_boxes(output_layer, in_darknet_image.w, in_darknet_image.h,
-							darknet_network_.w, darknet_network_.h,
-							min_confidence_, darknet_box_scores_.data(), darknet_boxes_.data(),
-							0, 0, 0.5, 1);
-		}
-		else
-			error("Last layer must produce detections\n");
-
-		int num_classes = output_layer.classes;
-		do_nms(darknet_boxes_.data(), darknet_box_scores_.data(), output_layer.w * output_layer.h * output_layer.n, num_classes, nms_threshold_);
-		std::vector&lt; RectClassScore&lt;float&gt; &gt; detections;
-
-		for (unsigned i = 0; i &lt; darknet_box_scores_.size(); i++)
-		{
-			int class_id = max_index(darknet_box_scores_[i], num_classes);
-			float prob = darknet_box_scores_[i][class_id];
-			//if (prob &gt; 0.3)
-			{
-				RectClassScore&lt;float&gt; detection;
-				box b = darknet_boxes_[i];
-
-				detection.x = b.x - b.w/2.;
-				detection.y = b.y - b.h/2.;
-				detection.w = b.w;
-				detection.h = b.h;
-				detection.score = prob;
-				detection.class_type = class_id;
-				//std::cout &lt;&lt; "Box:"  &lt;&lt;detection.toString() &lt;&lt; std::endl;
-
-				detections.push_back(detection);
-			}
-		}
-		return detections;
-	}
-}  // namespace darknet
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo2_detect\src\vision_yolo2_detect.cpp" new_path="" added_lines="0" deleted_lines="303">
				<diff>@@ -1,303 +0,0 @@
-#include &lt;ros/ros.h&gt;
-#include &lt;image_transport/image_transport.h&gt;
-#include &lt;sensor_msgs/Image.h&gt;
-#include &lt;sensor_msgs/image_encodings.h&gt;
-
-#include &lt;autoware_msgs/ConfigSsd.h&gt;
-#include &lt;autoware_msgs/image_obj.h&gt;
-
-#include &lt;cv_bridge/cv_bridge.h&gt;
-#include &lt;opencv2/opencv.hpp&gt;
-
-#if (CV_MAJOR_VERSION != 3)
-#include &lt;opencv2/contrib/contrib.hpp&gt;
-#endif
-#include &lt;opencv2/highgui/highgui.hpp&gt;
-
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include &lt;math.h&gt;
-#include &lt;stdlib.h&gt;
-
-#include &lt;rect_class_score.h&gt;
-
-#include "darknet/yolo2.h"
-
-namespace Yolo2
-{
-	enum YoloDetectorClasses//using coco for default cfg and weights
-	{
-		PERSON, BICYCLE, CAR, MOTORBIKE, AEROPLANE, BUS, TRAIN, TRUCK, BOAT, TRAFFIC_LIGHT,
-		FIRE_HYDRANT, STOP_SIGN, PARKING_METER, BENCH, BIRD, CAT, DOG, HORSE, SHEEP, COW,
-		ELEPHANT, BEAR, ZEBRA, GIRAFFE, BACKPACK, UMBRELLA, HANDBAG, TIE, SUITCASE, FRISBEE,
-		SKIS, SNOWBOARD, SPORTS_BALL, KITE, BASEBALL_BAT, BASEBALL_GLOVE, SKATEBOARD, SURFBOARD, TENNIS_RACKET, BOTTLE,
-		WINE_GLASS, CUP, FORK, KNIFE, SPOON, BOWL, BANANA, APPLE, SANDWICH, ORANGE,
-		BROCCOLI, CARROT, HOT_DOG, PIZZA, DONUT, CAKE, CHAIR, SOFA, POTTEDPLANT, BED,
-		DININGTABLE, TOILET, TVMONITOR, LAPTOP, MOUSE, REMOTE, KEYBOARD, CELL_PHONE, MICROWAVE, OVEN,
-		TOASTER, SINK, REFRIGERATOR, BOOK, CLOCK, VASE, SCISSORS, TEDDY_BEAR, HAIR_DRIER, TOOTHBRUSH,
-	};
-}
-
-class Yolo2DetectorNode
-{
-	ros::Subscriber subscriber_image_raw_;
-	ros::Subscriber subscriber_yolo_config_;
-	ros::Publisher publisher_car_objects_;
-	ros::Publisher publisher_person_objects_;
-	ros::NodeHandle node_handle_;
-
-	darknet::Yolo2Detector yolo_detector_;
-
-	image darknet_image = {};
-
-	float score_threshold_;
-	float nms_threshold_;
-	double image_ratio_;//resdize ratio used to fit input image to network input size
-	uint32_t image_top_bottom_border_;//black strips added to the input image to maintain aspect ratio while resizing it to fit the network input size
-	uint32_t image_left_right_border_;
-
-	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, autoware_msgs::image_obj&amp; out_message, std::string in_class)
-	{
-		for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
-		{
-			if ( (in_objects[i].score &gt; score_threshold_)
-				&amp;&amp; (	(in_class == "car"
-							&amp;&amp; (in_objects[i].class_type == Yolo2::CAR
-								|| in_objects[i].class_type == Yolo2::BUS
-								|| in_objects[i].class_type == Yolo2::TRUCK
-								|| in_objects[i].class_type == Yolo2::MOTORBIKE
-								)
-						)
-					|| (in_class == "person"
-							&amp;&amp; (in_objects[i].class_type == Yolo2::PERSON
-								|| in_objects[i].class_type == Yolo2::BICYCLE
-								|| in_objects[i].class_type == Yolo2::DOG
-								|| in_objects[i].class_type == Yolo2::CAT
-								|| in_objects[i].class_type == Yolo2::HORSE
-								)
-						)
-					)
-				)//check if the score is larger than minimum required
-			{
-				autoware_msgs::image_rect rect;
-
-				rect.x = (in_objects[i].x * darknet_image.w /image_ratio_) - image_left_right_border_/image_ratio_;
-				rect.y = (in_objects[i].y * darknet_image.h /image_ratio_) - image_top_bottom_border_/image_ratio_;
-				rect.width = in_objects[i].w * darknet_image.w/image_ratio_;
-				rect.height = in_objects[i].h * darknet_image.h/image_ratio_;
-				if (in_objects[i].x &lt; 0)
-					rect.x = 0;
-				if (in_objects[i].y &lt; 0)
-					rect.y = 0;
-				if (in_objects[i].w &lt; 0)
-					rect.width = 0;
-				if (in_objects[i].h &lt; 0)
-					rect.height = 0;
-
-				rect.score = in_objects[i].score;
-
-				//std::cout &lt;&lt; "x "&lt;&lt; rect.x&lt;&lt; " y " &lt;&lt; rect.y &lt;&lt; " w "&lt;&lt; rect.width &lt;&lt; " h "&lt;&lt; rect.height&lt;&lt; " s " &lt;&lt; rect.score &lt;&lt; " c " &lt;&lt; in_objects[i].class_type &lt;&lt; std::endl;
-
-				out_message.obj.push_back(rect);
-
-			}
-		}
-	}
-
-	void rgbgr_image(image&amp; im)
-	{
-		int i;
-		for(i = 0; i &lt; im.w*im.h; ++i)
-		{
-			float swap = im.data[i];
-			im.data[i] = im.data[i+im.w*im.h*2];
-			im.data[i+im.w*im.h*2] = swap;
-		}
-	}
-
-	image convert_ipl_to_image(const sensor_msgs::ImageConstPtr&amp; msg)
-	{
-		cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(msg, "bgr8");//toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
-		cv::Mat mat_image = cv_image-&gt;image;
-
-		uint32_t network_input_width = yolo_detector_.get_network_width();
-		uint32_t network_input_height = yolo_detector_.get_network_height();
-
-		uint32_t image_height = msg-&gt;height,
-						image_width = msg-&gt;width;
-
-		IplImage ipl_image;
-		cv::Mat final_mat;
-
-		//ROS_INFO("Before Network (%d,%d), Image (%d,%d)", network_input_width, network_input_height, image_width, image_height);
-		if (network_input_width!=image_width
-				|| network_input_height != image_height)
-		{
-			//final_mat = cv::Mat(network_input_width, network_input_height, CV_8UC3, cv::Scalar(0,0,0));
-			image_ratio_ = (double ) network_input_width /  (double)mat_image.cols;
-			//std::cout &lt;&lt; "Ratio:" &lt;&lt; image_ratio_ &lt;&lt; std::endl;
-
-			cv::resize(mat_image, final_mat, cv::Size(), image_ratio_, image_ratio_);
-			image_top_bottom_border_ = abs(final_mat.rows-network_input_height)/2;
-			image_left_right_border_ = abs(final_mat.cols-network_input_width)/2;
-			cv::copyMakeBorder(final_mat, final_mat,
-								image_top_bottom_border_, image_top_bottom_border_,
-								image_left_right_border_, image_left_right_border_,
-								cv::BORDER_CONSTANT, cv::Scalar(0,0,0));
-
-			/*
-			 //CROP CENTER
-			 * uint32_t crop_x, crop_y;
-			crop_x = (image_width-network_input_width)/2;
-			crop_y = (image_height-network_input_height)/2;
-			cv::Rect center_crop(crop_x, crop_y, network_input_width, network_input_height);
-			std::cout &lt;&lt; mat_image.cols &lt;&lt; ", " &lt;&lt; mat_image.rows &lt;&lt; std::endl;
-			cv::Mat cropped_mat = mat_image(center_crop);
-			cropped_mat.copyTo(final_mat);
-			*/
-
-			//VILE RESIZE
-			//cv::resize(mat_image, final_mat, cv::Size(network_input_width, network_input_height));
-		}
-		else
-			final_mat = mat_image;
-
-		//ROS_INFO("After Network (%d,%d), Image (%d,%d)", network_input_width, network_input_height, final_mat.cols, final_mat.rows);
-
-		ipl_image = final_mat;
-
-		unsigned char *data = (unsigned char *)ipl_image.imageData;
-		int h = ipl_image.height;
-		int w = ipl_image.width;
-		int c = ipl_image.nChannels;
-		int step = ipl_image.widthStep;
-		int i, j, k;
-
-		image darknet_image = make_image(w, h, c);
-
-		for(i = 0; i &lt; h; ++i){
-			for(k= 0; k &lt; c; ++k){
-				for(j = 0; j &lt; w; ++j){
-					darknet_image.data[k*w*h + i*w + j] = data[i*step + j*c + k]/255.;
-				}
-			}
-		}
-		rgbgr_image(darknet_image);
-		return darknet_image;
-	}
-
-	void image_callback(const sensor_msgs::ImageConstPtr&amp; in_image_message)
-	{
-		std::vector&lt; RectClassScore&lt;float&gt; &gt; detections;
-		//darknet_image_ = yolo_detector_.convert_image(in_image_message);
-
-		darknet_image = convert_ipl_to_image(in_image_message);
-
-		detections = yolo_detector_.detect(darknet_image);
-
-		//ROS_INFO("Detections: %ud", (unsigned int)detections.size());
-
-		//Prepare Output message
-		autoware_msgs::image_obj output_car_message;
-		autoware_msgs::image_obj output_person_message;
-		output_car_message.header = in_image_message-&gt;header;
-		output_car_message.type = "car";
-
-		output_person_message.header = in_image_message-&gt;header;
-		output_person_message.type = "person";
-
-		convert_rect_to_image_obj(detections, output_car_message, "car");
-		convert_rect_to_image_obj(detections, output_person_message, "person");
-
-		publisher_car_objects_.publish(output_car_message);
-		publisher_person_objects_.publish(output_person_message);
-
-		free(darknet_image.data);
-	}
-
-	void config_cb(const autoware_msgs::ConfigSsd::ConstPtr&amp; param)
-	{
-		score_threshold_ 	= param-&gt;score_threshold;
-	}
-
-public:
-	void Run()
-	{
-		//ROS STUFF
-		ros::NodeHandle private_node_handle("~");//to receive args
-
-		//RECEIVE IMAGE TOPIC NAME
-		std::string image_raw_topic_str;
-		if (private_node_handle.getParam("image_raw_node", image_raw_topic_str))
-		{
-			ROS_INFO("Setting image node to %s", image_raw_topic_str.c_str());
-		}
-		else
-		{
-			ROS_INFO("No image node received, defaulting to /image_raw, you can use _image_raw_node:=YOUR_TOPIC");
-			image_raw_topic_str = "/image_raw";
-		}
-
-		std::string network_definition_file;
-		std::string pretrained_model_file;
-		if (private_node_handle.getParam("network_definition_file", network_definition_file))
-		{
-			ROS_INFO("Network Definition File (Config): %s", network_definition_file.c_str());
-		}
-		else
-		{
-			ROS_INFO("No Network Definition File was received. Finishing execution.");
-			return;
-		}
-		if (private_node_handle.getParam("pretrained_model_file", pretrained_model_file))
-		{
-			ROS_INFO("Pretrained Model File (Weights): %s", pretrained_model_file.c_str());
-		}
-		else
-		{
-			ROS_INFO("No Pretrained Model File was received. Finishing execution.");
-			return;
-		}
-
-		if (private_node_handle.getParam("score_threshold", score_threshold_))
-		{
-			ROS_INFO("Score Threshold: %f", score_threshold_);
-		}
-		if (private_node_handle.getParam("nms_threshold", nms_threshold_))
-		{
-			ROS_INFO("NMS Threshold: %f", nms_threshold_);
-		}
-
-		ROS_INFO("Initializing Yolo2 on Darknet...");
-		yolo_detector_.load(network_definition_file, pretrained_model_file, score_threshold_, nms_threshold_);
-		ROS_INFO("Initialization complete.");
-
-		publisher_car_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;("/obj_car/image_obj", 1);
-		publisher_person_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;("/obj_person/image_obj", 1);
-
-		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
-		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;Yolo2DetectorNode::image_callback, this);
-
-		std::string config_topic("/config");
-		config_topic += "/yolo2";
-		subscriber_yolo_config_ = node_handle_.subscribe(config_topic, 1, &amp;Yolo2DetectorNode::config_cb, this);
-
-		ros::spin();
-		ROS_INFO("END Yolo2");
-
-	}
-};
-
-int main(int argc, char **argv)
-{
-	ros::init(argc, argv, "ssd_unc");
-
-	Yolo2DetectorNode app;
-
-	app.Run();
-
-	return 0;
-}
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\src\rect_class_score.h" new_path="" added_lines="0" deleted_lines="24">
				<diff>@@ -1,24 +0,0 @@
-#ifndef RECTCLASSSCORE_H_
-#define RECTCLASSSCORE_H_
-
-#include &lt;sstream&gt;
-#include &lt;string&gt;
-
-template&lt;typename _Tp&gt; class RectClassScore
-{
-public:
-	_Tp x, y, w, h;
-	_Tp score;
-	unsigned int class_type;
-	bool enabled;
-
-	inline std::string toString()
-	{
-		std::ostringstream out;
-		out &lt;&lt; class_type &lt;&lt; "(x:" &lt;&lt; x &lt;&lt; ", y:" &lt;&lt; y &lt;&lt; ", w:" &lt;&lt; w &lt;&lt; ", h:" &lt;&lt; h &lt;&lt; ") =" &lt;&lt; score;
-		return out.str();
-	}
-};
-
-
-#endif /* RECTCLASSSCORE_H_ */
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="11f0bd544e3f98722197be07e8344bc850da1c42" author="Kosuke Murakami">
		<msg>Add only one segment distance</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="18" deleted_lines="54">
				<diff>@@ -143,6 +143,7 @@ static double _keep_lane_right_distance;
 static double _max_boundingbox_side;
 static double _remove_points_upto;
 static double _cluster_merge_threshold;
+static double _segment_distance;
 
 static bool _use_gpu;
 static std::chrono::system_clock::time_point _start, _end;
@@ -152,9 +153,6 @@ std::vector&lt;cv::Scalar&gt; _colors;
 pcl::PointCloud&lt;pcl::PointXYZ&gt; _sensor_cloud;
 visualization_msgs::Marker _visualization_marker;
 
-std::vector&lt;double&gt; _clustering_thresholds;
-std::vector&lt;double&gt; _clustering_distances;
-
 tf::StampedTransform *_transform;
 tf::StampedTransform *_velodyne_output_transform;
 tf::TransformListener *_transform_listener;
@@ -235,7 +233,7 @@ void publishDetectedObjects(const autoware_msgs::CloudClusterArray &amp;in_clusters)
     autoware_msgs::DetectedObjectArray detected_objects;
     detected_objects.header = in_clusters.header;
 
-    for (auto i=0; i&lt; in_clusters.clusters.size(); i++)
+    for (size_t i=0; i&lt; in_clusters.clusters.size(); i++)
     {
         autoware_msgs::DetectedObject detected_object;
         detected_object.header = in_clusters.header;
@@ -589,12 +587,7 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
     //3 =&gt; 45-60 d=2.1
     //4 =&gt; &gt;60   d=2.6
 
-    std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr&gt; cloud_segments_array(5);
-
-    for (unsigned int i = 0; i &lt; cloud_segments_array.size(); i++) {
-        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr tmp_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-        cloud_segments_array[i] = tmp_cloud;
-    }
+    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
 
     for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++) {
         pcl::PointXYZ current_point;
@@ -602,37 +595,21 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
         current_point.y = in_cloud_ptr-&gt;points[i].y;
         current_point.z = in_cloud_ptr-&gt;points[i].z;
 
-        float origin_distance = sqrt(pow(current_point.x, 2) + pow(current_point.y, 2));
-
-        if (origin_distance &lt; _clustering_distances[0]) { cloud_segments_array[0]-&gt;points.push_back(current_point); }
-        else if (origin_distance &lt; _clustering_distances[1]) {
-            cloud_segments_array[1]-&gt;points.push_back(current_point);
-        }
-        else if (origin_distance &lt; _clustering_distances[2]) {
-            cloud_segments_array[2]-&gt;points.push_back(current_point);
-        }
-        else if (origin_distance &lt; _clustering_distances[3]) {
-            cloud_segments_array[3]-&gt;points.push_back(current_point);
-        }
-        else { cloud_segments_array[4]-&gt;points.push_back(current_point); }
+        cloud_ptr-&gt;points.push_back(current_point);
     }
 
+    #ifdef GPU_CLUSTERING
     std::vector&lt;ClusterPtr&gt; all_clusters;
-    for (unsigned int i = 0; i &lt; cloud_segments_array.size(); i++) {
-#ifdef GPU_CLUSTERING
-        std::vector&lt;ClusterPtr&gt; local_clusters;
-        if (_use_gpu) {
-            local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
-                                                in_out_centroids, _clustering_thresholds[i]);
-        } else {
-            local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
-                                             in_out_centroids, _clustering_thresholds[i]);
-        }
+     if (_use_gpu) {
+             all_clusters = clusterAndColorGpu(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
+
+     } else {
+             all_clusters = clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
+     }
 #else
-        std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
+        std::vector&lt;ClusterPtr&gt; all_clusters = clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
 #endif
-        all_clusters.insert(all_clusters.end(), local_clusters.begin(), local_clusters.end());
-    }
+
 
     //Clusters can be merged or checked in here
     //....
@@ -1079,9 +1056,9 @@ int main(int argc, char **argv) {
     _transform_listener = &amp;listener;
 
 #if (CV_MAJOR_VERSION == 3)
-    generateColors(_colors, 100);
+    generateColors(_colors, 255);
 #else
-    cv::generateColors(_colors, 100);
+    cv::generateColors(_colors, 255);
 #endif
 
     _pub_cluster_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_cluster", 1);
@@ -1142,8 +1119,6 @@ int main(int argc, char **argv) {
     ROS_INFO("keep_lane_left_distance: %f", _keep_lane_left_distance);
     private_nh.param("keep_lane_right_distance", _keep_lane_right_distance, 5.0);
     ROS_INFO("keep_lane_right_distance: %f", _keep_lane_right_distance);
-    private_nh.param("clustering_thresholds", _clustering_thresholds);
-    private_nh.param("clustering_distances", _clustering_distances);
     private_nh.param("max_boundingbox_side", _max_boundingbox_side, 10.0);
     ROS_INFO("max_boundingbox_side: %f", _max_boundingbox_side);
     private_nh.param("cluster_merge_threshold", _cluster_merge_threshold, 1.5);
@@ -1159,25 +1134,14 @@ int main(int argc, char **argv) {
     private_nh.param("remove_points_upto", _remove_points_upto, 0.0);
     ROS_INFO("remove_points_upto: %f", _remove_points_upto);
 
+    private_nh.param("segment_distance", _segment_distance, 0.75);
+    ROS_INFO("segment_distance: %f", _segment_distance);
+
     private_nh.param("use_gpu", _use_gpu, false);
     ROS_INFO("use_gpu: %d", _use_gpu);
 
     _velodyne_transform_available = false;
 
-    if (_clustering_distances.size() != 4) {
-        _clustering_distances = {15, 30, 45, 60};//maximum distance from sensor origin to separate segments
-    }
-    if (_clustering_thresholds.size() != 5) {
-        _clustering_thresholds = {0.5, 1.1, 1.6, 2.1, 2.6};//Nearest neighbor distance threshold for each segment
-    }
-
-    std::cout &lt;&lt; "_clustering_thresholds: ";
-    for (auto i = _clustering_thresholds.begin(); i != _clustering_thresholds.end(); ++i) std::cout &lt;&lt; *i &lt;&lt; ' ';
-    std::cout &lt;&lt; std::endl;
-    std::cout &lt;&lt; "_clustering_distances: ";
-    for (auto i = _clustering_distances.begin(); i != _clustering_distances.end(); ++i) std::cout &lt;&lt; *i &lt;&lt; ' ';
-    std::cout &lt;&lt; std::endl;
-
     // Create a ROS subscriber for the input point cloud
     ros::Subscriber sub = h.subscribe(points_topic, 1, velodyne_callback);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6df3fd67ddf6d19cd721e22f6c65e6f98717f9ac" author="Akihito Ohsato">
		<msg>Add twist subscriber to control fake object</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\include\lidar_fake_perception.h" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\include\lidar_fake_perception.h" added_lines="18" deleted_lines="4">
				<diff>@@ -11,6 +11,7 @@
 #include &lt;tf/transform_listener.h&gt;
 #include &lt;tf_conversions/tf_eigen.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
+#include &lt;geometry_msgs/Twist.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;autoware_msgs/DetectedObject.h&gt;
 #include &lt;autoware_msgs/DetectedObjectArray.h&gt;
@@ -43,22 +44,30 @@ private:
 
   // subscriber
   ros::Subscriber object_initial_pose_sub_;
-  ros::Subscriber objects_sub_;
-  ros::Subscriber points_sub_;
+  ros::Subscriber real_objects_sub_;
+  ros::Subscriber real_points_sub_;
+  ros::Subscriber fake_twist_sub_;
 
   // tf
   tf::TransformListener tf_listener_;
 
-  // rosparam
+  // param, publishing
   bool publish_object_;
   bool publish_points_;
   double publish_rate_;   // [Hz]
+
+  // param, object shape
   double object_length_;  // [m]
   double object_width_;  // [m]
   double object_height_;  // [m]
   double object_z_offset_;  // [m]
+
+  // param, object motion
+  bool use_fake_twist_;
   double object_velocity_;  // [m/s]
   double object_angular_velocity_;  // [rad/s]
+
+  // param, object meta-info
   double object_intensity_;  // 0-255 [-]
   double object_lifetime_;  // minus value -&gt; inifinity [s]
   double object_points_space_;  // [m]
@@ -71,18 +80,23 @@ private:
   ros::Time fake_object_initial_time_;
   std::string global_frame_;
   tf::Transform fake_object_pose_;  // global
+  geometry_msgs::Twist fake_object_twist_;
   autoware_msgs::DetectedObject fake_object_;
   autoware_msgs::DetectedObjectArray fake_objects_;
   autoware_msgs::DetectedObjectArray real_objects_;
   PointCloudT fake_points_;
   PointCloudT real_points_;
 
-
+  // functions, callback
   void objectInitialPoseCallback(const geometry_msgs::PoseStampedConstPtr&amp; msg);
   void objectsCallback(const autoware_msgs::DetectedObjectArray&amp; msg);
   void pointsCallback(const sensor_msgs::PointCloud2&amp; msg);
+  void twistCallback(const geometry_msgs::Twist&amp; msg);
+
+  // functions, mainloop
   void updateFakes();
   bool updateFakeObject();
+  void updatePose(const double&amp; dt, const geometry_msgs::Twist&amp; twist, tf::Transform&amp; tf);
   void updateFakePoints();
   void convertObjectToPoints(const autoware_msgs::DetectedObject&amp; obj, PointCloudT&amp; points);
   void publishFakes();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\nodes\lidar_fake_perception.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\nodes\lidar_fake_perception.cpp" added_lines="40" deleted_lines="10">
				<diff>@@ -8,21 +8,27 @@ LidarFakePerception::LidarFakePerception() : nh_(), private_nh_("~")
   private_nh_.param&lt;bool&gt;("publish_object", publish_object_, true);
   private_nh_.param&lt;bool&gt;("publish_points", publish_points_, true);
   private_nh_.param&lt;double&gt;("publish_rate", publish_rate_, 10.0);
+
   private_nh_.param&lt;double&gt;("object_length", object_length_, 5.0);
   private_nh_.param&lt;double&gt;("object_width", object_width_, 2.0);
   private_nh_.param&lt;double&gt;("object_height", object_height_, 2.0);
   private_nh_.param&lt;double&gt;("object_z_offset", object_z_offset_, 0.0);
+
+  private_nh_.param&lt;bool&gt;("use_fake_twist", use_fake_twist_, false);
   private_nh_.param&lt;double&gt;("object_velocity", object_velocity_, 3.0);
-  private_nh_.param&lt;double&gt;("object_angular_velocity", object_angular_velocity_, 0.5);
+  private_nh_.param&lt;double&gt;("object_angular_velocity", object_angular_velocity_, 0.0);
+
   private_nh_.param&lt;double&gt;("object_intensity", object_intensity_, 100.0);
   private_nh_.param&lt;double&gt;("object_lifetime", object_lifetime_, -1);
   private_nh_.param&lt;double&gt;("object_points_space", object_points_space_, 0.2);
+
   private_nh_.param&lt;std::string&gt;("object_label", object_label_, "Stable");
   private_nh_.param&lt;std::string&gt;("object_frame", object_frame_, "velodyne");
 
   object_initial_pose_sub_ = nh_.subscribe("/move_base_simple/goal", 1, &amp;LidarFakePerception::objectInitialPoseCallback, this);
-  objects_sub_ = nh_.subscribe("/detected_objects", 1, &amp;LidarFakePerception::objectsCallback, this);
-  points_sub_ = nh_.subscribe("/points_raw", 1, &amp;LidarFakePerception::pointsCallback, this);
+  real_objects_sub_ = nh_.subscribe("/detected_objects", 1, &amp;LidarFakePerception::objectsCallback, this);
+  real_points_sub_ = nh_.subscribe("/points_raw", 1, &amp;LidarFakePerception::pointsCallback, this);
+  fake_twist_sub_ = nh_.subscribe("/fake_twist", 1, &amp;LidarFakePerception::twistCallback, this);
 
   fake_objects_pub_ = nh_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/fake_objects", 1);
   fake_points_pub_ = nh_.advertise&lt;sensor_msgs::PointCloud2&gt;("/fake_points", 1);
@@ -70,6 +76,11 @@ void LidarFakePerception::pointsCallback(const sensor_msgs::PointCloud2&amp; msg)
   pcl::fromROSMsg(msg, real_points_);
 }
 
+void LidarFakePerception::twistCallback(const geometry_msgs::Twist&amp; msg)
+{
+  fake_object_twist_ = msg;
+}
+
 void LidarFakePerception::updateFakes()
 {
   // update objects
@@ -80,7 +91,7 @@ void LidarFakePerception::updateFakes()
   {
     fake_objects_.objects.resize(real_objects_.objects.size());
     std::copy(real_objects_.objects.begin(), real_objects_.objects.end(), fake_objects_.objects.begin());
-    fake_object_id_ = (real_objects_.objects.end()-1)-&gt;id + 1;
+    fake_object_id_ = (real_objects_.objects.end()-1)-&gt;id + 1;  // using incremented id
   }
 
   if (real_points_.size() != 0)
@@ -109,6 +120,7 @@ bool LidarFakePerception::updateFakeObject()
     }
   }
 
+  // world -&gt; sensor frame
   tf::StampedTransform global2local;
   try
   {
@@ -122,12 +134,19 @@ bool LidarFakePerception::updateFakeObject()
   }
 
   // update pose
-  tf::Transform dpose;
-  tf::Quaternion dquat;
-  dpose.setOrigin(tf::Vector3(object_velocity_/publish_rate_, 0., 0.));
-  dquat.setRPY(0., 0., object_angular_velocity_/publish_rate_);
-  dpose.setRotation(dquat);
-  fake_object_pose_ *= dpose;
+  if (use_fake_twist_)
+  {
+    // update pose by subscribed twist
+    updatePose(1./publish_rate_, fake_object_twist_, fake_object_pose_);
+  }
+  else
+  {
+    // update pose by rosparam
+    geometry_msgs::Twist twist;
+    twist.linear.x = object_velocity_;
+    twist.angular.z = object_angular_velocity_;
+    updatePose(1./publish_rate_, twist, fake_object_pose_);
+  }
 
   // fix height
   tf::Vector3 objpos = fake_object_pose_.getOrigin();
@@ -154,6 +173,17 @@ bool LidarFakePerception::updateFakeObject()
   return true;
 }
 
+void LidarFakePerception::updatePose(const double&amp; dt, const geometry_msgs::Twist&amp; twist, tf::Transform&amp; tf)
+{
+  // update pose by constant velocity model
+  tf::Transform dpose;
+  tf::Quaternion dquat;
+  dpose.setOrigin(tf::Vector3(twist.linear.x*dt, twist.linear.y*dt, twist.linear.z*dt));
+  dquat.setRPY(twist.angular.x*dt, twist.angular.y*dt, twist.angular.z*dt);
+  dpose.setRotation(dquat);
+  fake_object_pose_ *= dpose; // transform
+}
+
 void LidarFakePerception::updateFakePoints()
 {
   PointCloudT points;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="22fac8c25480d07b850e7311b8ebad3cae49cff5" author="Akihito Ohsato">
		<msg>Fix object velocity/acceleration, pointcloud</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\nodes\lidar_fake_perception.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\nodes\lidar_fake_perception.cpp" added_lines="9" deleted_lines="7">
				<diff>@@ -105,6 +105,7 @@ void LidarFakePerception::updateFakes()
     if (updateFakeObject())
     {
       updateFakePoints();
+      fake_objects_.objects.push_back(fake_object_);
     }
   }
 }
@@ -120,7 +121,7 @@ bool LidarFakePerception::updateFakeObject()
     }
   }
 
-  // world -&gt; sensor frame
+  // obtain world -&gt; sensor frame
   tf::StampedTransform global2local;
   try
   {
@@ -134,19 +135,20 @@ bool LidarFakePerception::updateFakeObject()
   }
 
   // update pose
+  geometry_msgs::Twist twist;
   if (use_fake_twist_)
   {
     // update pose by subscribed twist
-    updatePose(1./publish_rate_, fake_object_twist_, fake_object_pose_);
+    twist = fake_object_twist_;
   }
   else
   {
     // update pose by rosparam
-    geometry_msgs::Twist twist;
     twist.linear.x = object_velocity_;
     twist.angular.z = object_angular_velocity_;
-    updatePose(1./publish_rate_, twist, fake_object_pose_);
+
   }
+  updatePose(1./publish_rate_, twist, fake_object_pose_);
 
   // fix height
   tf::Vector3 objpos = fake_object_pose_.getOrigin();
@@ -160,10 +162,9 @@ bool LidarFakePerception::updateFakeObject()
   fake_object_.dimensions.x = object_length_;
   fake_object_.dimensions.y = object_width_;
   fake_object_.dimensions.z = object_height_;
-  fake_object_.velocity.linear.x = object_velocity_;
-  fake_object_.velocity.angular.z = object_angular_velocity_;
+  fake_object_.velocity = twist;
+  fake_object_.acceleration = geometry_msgs::Twist();  // NOTE: by constant velocity model
   tf::poseTFToMsg(global2local.inverse() * fake_object_pose_, fake_object_.pose); // local
-  fake_objects_.objects.push_back(fake_object_);
 
   // debug
   double r, p, y;
@@ -190,6 +191,7 @@ void LidarFakePerception::updateFakePoints()
   convertObjectToPoints(fake_object_, points);
   fake_points_ += points;
   fake_points_.header = pcl_conversions::toPCL(fake_object_.header);
+  pcl::toROSMsg(fake_points_, fake_object_.pointcloud);
 }
 
 void LidarFakePerception::convertObjectToPoints(const autoware_msgs::DetectedObject&amp; obj, PointCloudT&amp; points)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2ab24320f2a7a09650abd7093ac9d7dcb65c90d5" author="Akihito Ohsato">
		<msg>Fix default shape, based on toyota-estima</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\nodes\lidar_fake_perception.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\nodes\lidar_fake_perception.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -9,9 +9,9 @@ LidarFakePerception::LidarFakePerception() : nh_(), private_nh_("~")
   private_nh_.param&lt;bool&gt;("publish_points", publish_points_, true);
   private_nh_.param&lt;double&gt;("publish_rate", publish_rate_, 10.0);
 
-  private_nh_.param&lt;double&gt;("object_length", object_length_, 5.0);
-  private_nh_.param&lt;double&gt;("object_width", object_width_, 2.0);
-  private_nh_.param&lt;double&gt;("object_height", object_height_, 2.0);
+  private_nh_.param&lt;double&gt;("object_length", object_length_, 4.8);
+  private_nh_.param&lt;double&gt;("object_width", object_width_, 1.8);
+  private_nh_.param&lt;double&gt;("object_height", object_height_, 1.8);
   private_nh_.param&lt;double&gt;("object_z_offset", object_z_offset_, 0.0);
 
   private_nh_.param&lt;bool&gt;("use_fake_twist", use_fake_twist_, false);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="216269d752f232634acca6c3307c9af5c97cb17e" author="Akihito Ohsato">
		<msg>Add comments mainly for rosparams</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\include\lidar_fake_perception.h" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\include\lidar_fake_perception.h" added_lines="21" deleted_lines="21">
				<diff>@@ -39,40 +39,40 @@ private:
   ros::NodeHandle private_nh_;
 
   // publisher
-  ros::Publisher fake_objects_pub_;
-  ros::Publisher fake_points_pub_;
+  ros::Publisher fake_objects_pub_; // output objects, input and fake object are merged
+  ros::Publisher fake_points_pub_;  // output points, input and fake points are merged
 
   // subscriber
-  ros::Subscriber object_initial_pose_sub_;
-  ros::Subscriber real_objects_sub_;
-  ros::Subscriber real_points_sub_;
-  ros::Subscriber fake_twist_sub_;
+  ros::Subscriber object_initial_pose_sub_; // initial fake object pose
+  ros::Subscriber real_objects_sub_;  // input objects
+  ros::Subscriber real_points_sub_; // input points
+  ros::Subscriber fake_twist_sub_;  // input twist command, controlling fake object
 
   // tf
   tf::TransformListener tf_listener_;
 
   // param, publishing
-  bool publish_object_;
-  bool publish_points_;
-  double publish_rate_;   // [Hz]
+  bool publish_objects_;  // enable publishing fake objects
+  bool publish_points_;   // enable publishing fake points
+  double publish_rate_;   // publish rate of fake objects/points [Hz]
 
   // param, object shape
-  double object_length_;  // [m]
-  double object_width_;  // [m]
-  double object_height_;  // [m]
-  double object_z_offset_;  // [m]
+  double object_length_;  // length [m]
+  double object_width_;   // width [m]
+  double object_height_;  // height [m]
+  double object_z_offset_;  // offset from global frame [m]
 
   // param, object motion
-  bool use_fake_twist_;
-  double object_velocity_;  // [m/s]
-  double object_angular_velocity_;  // [rad/s]
+  bool use_fake_twist_;   // using subscribed twist
+  double object_velocity_;  // constant velocity instead of subscribed twist [m/s]
+  double object_angular_velocity_;  // constant angular velocity instead of subscribed twist [rad/s]
 
   // param, object meta-info
-  double object_intensity_;  // 0-255 [-]
-  double object_lifetime_;  // minus value -&gt; inifinity [s]
-  double object_points_space_;  // [m]
-  std::string object_label_;
-  std::string object_frame_;
+  double object_intensity_;  // constant intensity value of fake points, 0-255 [-]
+  double object_lifetime_;  // object meta-info, fake object lifetime (NOTE: when this is negative value, lifetime is inifinity) [s]
+  double object_points_space_;  // fake points space [m]
+  std::string object_label_;  // fake object label (e.g. tracking state)
+  std::string object_frame_;  // fake object frame_id (NOTE: not affected to input object)
 
   // variables
   int fake_object_id_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\nodes\lidar_fake_perception.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\nodes\lidar_fake_perception.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -5,7 +5,7 @@
 
 LidarFakePerception::LidarFakePerception() : nh_(), private_nh_("~")
 {
-  private_nh_.param&lt;bool&gt;("publish_object", publish_object_, true);
+  private_nh_.param&lt;bool&gt;("publish_objects", publish_objects_, true);
   private_nh_.param&lt;bool&gt;("publish_points", publish_points_, true);
   private_nh_.param&lt;double&gt;("publish_rate", publish_rate_, 10.0);
 
@@ -238,7 +238,7 @@ void LidarFakePerception::publishFakes()
     fake_points_.header = pcl_conversions::toPCL(fake_object_.header);
   }
 
-  if (publish_object_)
+  if (publish_objects_)
   {
     fake_objects_pub_.publish(fake_objects_);
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="627799e7f81bba37ab644c22b89e0b49712b7283" author="Akihito Ohsato">
		<msg>Apply clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\include\lidar_fake_perception.h" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\include\lidar_fake_perception.h" added_lines="15" deleted_lines="14">
				<diff>@@ -39,14 +39,14 @@ private:
   ros::NodeHandle private_nh_;
 
   // publisher
-  ros::Publisher fake_objects_pub_; // output objects, input and fake object are merged
-  ros::Publisher fake_points_pub_;  // output points, input and fake points are merged
+  ros::Publisher fake_objects_pub_;  // output objects, input and fake object are merged
+  ros::Publisher fake_points_pub_;   // output points, input and fake points are merged
 
   // subscriber
-  ros::Subscriber object_initial_pose_sub_; // initial fake object pose
-  ros::Subscriber real_objects_sub_;  // input objects
-  ros::Subscriber real_points_sub_; // input points
-  ros::Subscriber fake_twist_sub_;  // input twist command, controlling fake object
+  ros::Subscriber object_initial_pose_sub_;  // initial fake object pose
+  ros::Subscriber real_objects_sub_;         // input objects
+  ros::Subscriber real_points_sub_;          // input points
+  ros::Subscriber fake_twist_sub_;           // input twist command, controlling fake object
 
   // tf
   tf::TransformListener tf_listener_;
@@ -57,22 +57,23 @@ private:
   double publish_rate_;   // publish rate of fake objects/points [Hz]
 
   // param, object shape
-  double object_length_;  // length [m]
-  double object_width_;   // width [m]
-  double object_height_;  // height [m]
+  double object_length_;    // length [m]
+  double object_width_;     // width [m]
+  double object_height_;    // height [m]
   double object_z_offset_;  // offset from global frame [m]
 
   // param, object motion
-  bool use_fake_twist_;   // using subscribed twist
-  double object_velocity_;  // constant velocity instead of subscribed twist [m/s]
+  bool use_fake_twist_;             // using subscribed twist
+  double object_velocity_;          // constant velocity instead of subscribed twist [m/s]
   double object_angular_velocity_;  // constant angular velocity instead of subscribed twist [rad/s]
 
   // param, object meta-info
   double object_intensity_;  // constant intensity value of fake points, 0-255 [-]
-  double object_lifetime_;  // object meta-info, fake object lifetime (NOTE: when this is negative value, lifetime is inifinity) [s]
+  double object_lifetime_;   // object meta-info, fake object lifetime (NOTE: when this is negative value, lifetime is
+                             // inifinity) [s]
   double object_points_space_;  // fake points space [m]
-  std::string object_label_;  // fake object label (e.g. tracking state)
-  std::string object_frame_;  // fake object frame_id (NOTE: not affected to input object)
+  std::string object_label_;    // fake object label (e.g. tracking state)
+  std::string object_frame_;    // fake object frame_id (NOTE: not affected to input object)
 
   // variables
   int fake_object_id_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\nodes\lidar_fake_perception.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\nodes\lidar_fake_perception.cpp" added_lines="11" deleted_lines="16">
				<diff>@@ -25,7 +25,8 @@ LidarFakePerception::LidarFakePerception() : nh_(), private_nh_("~")
   private_nh_.param&lt;std::string&gt;("object_label", object_label_, "Stable");
   private_nh_.param&lt;std::string&gt;("object_frame", object_frame_, "velodyne");
 
-  object_initial_pose_sub_ = nh_.subscribe("/move_base_simple/goal", 1, &amp;LidarFakePerception::objectInitialPoseCallback, this);
+  object_initial_pose_sub_ =
+      nh_.subscribe("/move_base_simple/goal", 1, &amp;LidarFakePerception::objectInitialPoseCallback, this);
   real_objects_sub_ = nh_.subscribe("/detected_objects", 1, &amp;LidarFakePerception::objectsCallback, this);
   real_points_sub_ = nh_.subscribe("/points_raw", 1, &amp;LidarFakePerception::pointsCallback, this);
   fake_twist_sub_ = nh_.subscribe("/fake_twist", 1, &amp;LidarFakePerception::twistCallback, this);
@@ -33,7 +34,7 @@ LidarFakePerception::LidarFakePerception() : nh_(), private_nh_("~")
   fake_objects_pub_ = nh_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/fake_objects", 1);
   fake_points_pub_ = nh_.advertise&lt;sensor_msgs::PointCloud2&gt;("/fake_points", 1);
 
-  fake_object_id_ = 0;  // overwritten by real object ids
+  fake_object_id_ = 0;      // overwritten by real object ids
   global_frame_ = "world";  // overwritten by object initial pose
 
   fake_object_pose_initialized_ = false;
@@ -91,7 +92,7 @@ void LidarFakePerception::updateFakes()
   {
     fake_objects_.objects.resize(real_objects_.objects.size());
     std::copy(real_objects_.objects.begin(), real_objects_.objects.end(), fake_objects_.objects.begin());
-    fake_object_id_ = (real_objects_.objects.end()-1)-&gt;id + 1;  // using incremented id
+    fake_object_id_ = (real_objects_.objects.end() - 1)-&gt;id + 1;  // using incremented id
   }
 
   if (real_points_.size() != 0)
@@ -146,13 +147,12 @@ bool LidarFakePerception::updateFakeObject()
     // update pose by rosparam
     twist.linear.x = object_velocity_;
     twist.angular.z = object_angular_velocity_;
-
   }
-  updatePose(1./publish_rate_, twist, fake_object_pose_);
+  updatePose(1. / publish_rate_, twist, fake_object_pose_);
 
   // fix height
   tf::Vector3 objpos = fake_object_pose_.getOrigin();
-  fake_object_pose_.setOrigin(tf::Vector3(objpos.x(), objpos.y(), object_z_offset_+ object_height_/2.));
+  fake_object_pose_.setOrigin(tf::Vector3(objpos.x(), objpos.y(), object_z_offset_ + object_height_ / 2.));
 
   // update msg
   fake_object_.header.stamp = ros::Time::now();
@@ -163,13 +163,8 @@ bool LidarFakePerception::updateFakeObject()
   fake_object_.dimensions.y = object_width_;
   fake_object_.dimensions.z = object_height_;
   fake_object_.velocity = twist;
-  fake_object_.acceleration = geometry_msgs::Twist();  // NOTE: by constant velocity model
-  tf::poseTFToMsg(global2local.inverse() * fake_object_pose_, fake_object_.pose); // local
-
-  // debug
-  double r, p, y;
-  (global2local.inverse()*fake_object_pose_).getBasis().getRPY(r, p, y);
-  fake_object_.velocity.linear.y = y;
+  fake_object_.acceleration = geometry_msgs::Twist();                              // NOTE: by constant velocity model
+  tf::poseTFToMsg(global2local.inverse() * fake_object_pose_, fake_object_.pose);  // local
 
   return true;
 }
@@ -179,10 +174,10 @@ void LidarFakePerception::updatePose(const double&amp; dt, const geometry_msgs::Twis
   // update pose by constant velocity model
   tf::Transform dpose;
   tf::Quaternion dquat;
-  dpose.setOrigin(tf::Vector3(twist.linear.x*dt, twist.linear.y*dt, twist.linear.z*dt));
-  dquat.setRPY(twist.angular.x*dt, twist.angular.y*dt, twist.angular.z*dt);
+  dpose.setOrigin(tf::Vector3(twist.linear.x * dt, twist.linear.y * dt, twist.linear.z * dt));
+  dquat.setRPY(twist.angular.x * dt, twist.angular.y * dt, twist.angular.z * dt);
   dpose.setRotation(dquat);
-  fake_object_pose_ *= dpose; // transform
+  fake_object_pose_ *= dpose;  // transform
 }
 
 void LidarFakePerception::updateFakePoints()
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\nodes\lidar_fake_perception_node.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\nodes\lidar_fake_perception_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -3,7 +3,7 @@
 
 #include "lidar_fake_perception.h"
 
-int main(int argc, char **argv)
+int main(int argc, char** argv)
 {
   ros::init(argc, argv, "lidar_fake_percetion");
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e3f2a820188c42649295ceffec8b4ebc176385be" author="Kosuke Murakami">
		<msg>applying ros clang formant</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\include\cluster.h" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\include\cluster.h" added_lines="89" deleted_lines="85">
				<diff>@@ -54,92 +54,96 @@
 #include &lt;cmath&gt;
 #include &lt;chrono&gt;
 
-class Cluster {
-	pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr	pointcloud_;
-	pcl::PointXYZ 						min_point_;
-	pcl::PointXYZ 						max_point_;
-	pcl::PointXYZ 						average_point_;
-	pcl::PointXYZ 						centroid_;
-	double 								orientation_angle_;
-	float 								length_, width_, height_;
-
-	jsk_recognition_msgs::BoundingBox 	bounding_box_;
-	geometry_msgs::PolygonStamped 		polygon_;
-
-	std::string							label_;
-	int									id_;
-	int									r_, g_, b_;
-
-	Eigen::Matrix3f 					eigen_vectors_;
-	Eigen::Vector3f 					eigen_values_;
-
-	bool								valid_cluster_;
-	
-public:
-	/* \brief Constructor. Creates a Cluster object using the specified points in a PointCloud
-	 * \param[in] in_origin_cloud_ptr 	Origin PointCloud
-	 * \param[in] in_cluster_indices 	Indices of the Origin Pointcloud to create the Cluster
-	 * \param[in] in_id 				ID of the cluster
-	 * \param[in] in_r 					Amount of Red [0-255]
-	 * \param[in] in_g 					Amount of Green [0-255]
-	 * \param[in] in_b 					Amount of Blue [0-255]
-	 * \param[in] in_label 				Label to identify this cluster (optional)
-	 * \param[in] in_estimate_pose		Flag to enable Pose Estimation of the Bounding Box
-	 * */
-	void SetCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_origin_cloud_ptr, const std::vector&lt;int&gt;&amp; in_cluster_indices, std_msgs::Header in_ros_header, int in_id, int in_r, int in_g, int in_b, std::string in_label, bool in_estimate_pose);
-
-	/* \brief Returns the autoware_msgs::CloudCluster message associated to this Cluster */
-	void ToRosMessage(std_msgs::Header in_ros_header, autoware_msgs::CloudCluster&amp; out_cluster_message);
-
-	Cluster();
-	virtual ~Cluster();
-
-	/* \brief Returns the pointer to the PointCloud containing the points in this Cluster */
-	pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr	GetCloud();
-	/* \brief Returns the minimum point in the cluster */
-	pcl::PointXYZ 						GetMinPoint();
-	/* \brief Returns the maximum point in the cluster*/
-	pcl::PointXYZ 						GetMaxPoint();
-	/* \brief Returns the average point in the cluster*/
-	pcl::PointXYZ 						GetAveragePoint();
-	/* \brief Returns the centroid point in the cluster */
-	pcl::PointXYZ 						GetCentroid();
-	/* \brief Returns the calculated BoundingBox of the object */
-	jsk_recognition_msgs::BoundingBox	GetBoundingBox();
-	/* \brief Returns the calculated PolygonArray of the object */
-	geometry_msgs::PolygonStamped GetPolygon();
-	/* \brief Returns the angle in radians of the BoundingBox. 0 if pose estimation was not enabled. */
-	double								GetOrientationAngle();
-	/* \brief Returns the Length of the Cluster */
-	float								GetLenght();
-	/* \brief Returns the Width of the Cluster */
-	float								GetWidth();
-	/* \brief Returns the Height of the Cluster */
-	float								GetHeight();
-	/* \brief Returns the Id of the Cluster */
-	int									GetId();
-	/* \brief Returns the Label of the Cluster */
-	std::string							GetLabel();
-	/* \brief Returns the Eigen Vectors of the cluster */
-	Eigen::Matrix3f						GetEigenVectors();
-	/* \brief Returns the Eigen Values of the Cluster */
-	Eigen::Vector3f						GetEigenValues();
-
-	/* \brief Returns if the Cluster is marked as valid or not*/
-	bool								IsValid();
-	/* \brief Sets whether the Cluster is valid or not*/
-	void								SetValidity(bool in_valid);
-
-	/* \brief Returns a pointer to a PointCloud object containing the merged points between current Cluster and the specified PointCloud
-	 * \param[in] in_cloud_ptr 	Origin PointCloud
-	 * */
-	pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr	JoinCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr);
-
-	/* \brief Calculates and returns a pointer to the FPFH Descriptor of this cluster
-	 *
-	 */
-	std::vector&lt;float&gt; GetFpfhDescriptor(const unsigned int&amp; in_ompnum_threads, const double&amp; in_normal_search_radius, const double&amp; in_fpfh_search_radius);
+class Cluster
+{
+  pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr pointcloud_;
+  pcl::PointXYZ min_point_;
+  pcl::PointXYZ max_point_;
+  pcl::PointXYZ average_point_;
+  pcl::PointXYZ centroid_;
+  double orientation_angle_;
+  float length_, width_, height_;
+
+  jsk_recognition_msgs::BoundingBox bounding_box_;
+  geometry_msgs::PolygonStamped polygon_;
+
+  std::string label_;
+  int id_;
+  int r_, g_, b_;
 
+  Eigen::Matrix3f eigen_vectors_;
+  Eigen::Vector3f eigen_values_;
+
+  bool valid_cluster_;
+
+public:
+  /* \brief Constructor. Creates a Cluster object using the specified points in a PointCloud
+   * \param[in] in_origin_cloud_ptr 	Origin PointCloud
+   * \param[in] in_cluster_indices 	Indices of the Origin Pointcloud to create the Cluster
+   * \param[in] in_id 				ID of the cluster
+   * \param[in] in_r 					Amount of Red [0-255]
+   * \param[in] in_g 					Amount of Green [0-255]
+   * \param[in] in_b 					Amount of Blue [0-255]
+   * \param[in] in_label 				Label to identify this cluster (optional)
+   * \param[in] in_estimate_pose		Flag to enable Pose Estimation of the Bounding Box
+   * */
+  void SetCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_origin_cloud_ptr,
+                const std::vector&lt;int&gt;&amp; in_cluster_indices, std_msgs::Header in_ros_header, int in_id, int in_r,
+                int in_g, int in_b, std::string in_label, bool in_estimate_pose);
+
+  /* \brief Returns the autoware_msgs::CloudCluster message associated to this Cluster */
+  void ToRosMessage(std_msgs::Header in_ros_header, autoware_msgs::CloudCluster&amp; out_cluster_message);
+
+  Cluster();
+  virtual ~Cluster();
+
+  /* \brief Returns the pointer to the PointCloud containing the points in this Cluster */
+  pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr GetCloud();
+  /* \brief Returns the minimum point in the cluster */
+  pcl::PointXYZ GetMinPoint();
+  /* \brief Returns the maximum point in the cluster*/
+  pcl::PointXYZ GetMaxPoint();
+  /* \brief Returns the average point in the cluster*/
+  pcl::PointXYZ GetAveragePoint();
+  /* \brief Returns the centroid point in the cluster */
+  pcl::PointXYZ GetCentroid();
+  /* \brief Returns the calculated BoundingBox of the object */
+  jsk_recognition_msgs::BoundingBox GetBoundingBox();
+  /* \brief Returns the calculated PolygonArray of the object */
+  geometry_msgs::PolygonStamped GetPolygon();
+  /* \brief Returns the angle in radians of the BoundingBox. 0 if pose estimation was not enabled. */
+  double GetOrientationAngle();
+  /* \brief Returns the Length of the Cluster */
+  float GetLenght();
+  /* \brief Returns the Width of the Cluster */
+  float GetWidth();
+  /* \brief Returns the Height of the Cluster */
+  float GetHeight();
+  /* \brief Returns the Id of the Cluster */
+  int GetId();
+  /* \brief Returns the Label of the Cluster */
+  std::string GetLabel();
+  /* \brief Returns the Eigen Vectors of the cluster */
+  Eigen::Matrix3f GetEigenVectors();
+  /* \brief Returns the Eigen Values of the Cluster */
+  Eigen::Vector3f GetEigenValues();
+
+  /* \brief Returns if the Cluster is marked as valid or not*/
+  bool IsValid();
+  /* \brief Sets whether the Cluster is valid or not*/
+  void SetValidity(bool in_valid);
+
+  /* \brief Returns a pointer to a PointCloud object containing the merged points between current Cluster and the
+   * specified PointCloud
+   * \param[in] in_cloud_ptr 	Origin PointCloud
+   * */
+  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr JoinCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr);
+
+  /* \brief Calculates and returns a pointer to the FPFH Descriptor of this cluster
+   *
+   */
+  std::vector&lt;float&gt; GetFpfhDescriptor(const unsigned int&amp; in_ompnum_threads, const double&amp; in_normal_search_radius,
+                                       const double&amp; in_fpfh_search_radius);
 };
 
 typedef boost::shared_ptr&lt;Cluster&gt; ClusterPtr;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\include\gencolors.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\include\gencolors.cpp" added_lines="86" deleted_lines="86">
				<diff>@@ -50,97 +50,97 @@
 
 using namespace cv;
 
-static void downsamplePoints( const Mat&amp; src, Mat&amp; dst, size_t count )
+static void downsamplePoints(const Mat&amp; src, Mat&amp; dst, size_t count)
 {
-    CV_Assert( count &gt;= 2 );
-    CV_Assert( src.cols == 1 || src.rows == 1 );
-    CV_Assert( src.total() &gt;= count );
-    CV_Assert( src.type() == CV_8UC3);
-
-    dst.create( 1, (int)count, CV_8UC3 );
-    //TODO: optimize by exploiting symmetry in the distance matrix
-    Mat dists( (int)src.total(), (int)src.total(), CV_32FC1, Scalar(0) );
-    if( dists.empty() )
-        std::cerr &lt;&lt; "Such big matrix cann't be created." &lt;&lt; std::endl;
-
-    for( int i = 0; i &lt; dists.rows; i++ )
+  CV_Assert(count &gt;= 2);
+  CV_Assert(src.cols == 1 || src.rows == 1);
+  CV_Assert(src.total() &gt;= count);
+  CV_Assert(src.type() == CV_8UC3);
+
+  dst.create(1, (int)count, CV_8UC3);
+  // TODO: optimize by exploiting symmetry in the distance matrix
+  Mat dists((int)src.total(), (int)src.total(), CV_32FC1, Scalar(0));
+  if (dists.empty())
+    std::cerr &lt;&lt; "Such big matrix cann't be created." &lt;&lt; std::endl;
+
+  for (int i = 0; i &lt; dists.rows; i++)
+  {
+    for (int j = i; j &lt; dists.cols; j++)
     {
-        for( int j = i; j &lt; dists.cols; j++ )
-        {
-            float dist = (float)norm(src.at&lt;Point3_&lt;uchar&gt; &gt;(i) - src.at&lt;Point3_&lt;uchar&gt; &gt;(j));
-            dists.at&lt;float&gt;(j, i) = dists.at&lt;float&gt;(i, j) = dist;
-        }
-    }
-
-    double maxVal;
-    Point maxLoc;
-    minMaxLoc(dists, 0, &amp;maxVal, 0, &amp;maxLoc);
-
-    dst.at&lt;Point3_&lt;uchar&gt; &gt;(0) = src.at&lt;Point3_&lt;uchar&gt; &gt;(maxLoc.x);
-    dst.at&lt;Point3_&lt;uchar&gt; &gt;(1) = src.at&lt;Point3_&lt;uchar&gt; &gt;(maxLoc.y);
-
-    Mat activedDists( 0, dists.cols, dists.type() );
-    Mat candidatePointsMask( 1, dists.cols, CV_8UC1, Scalar(255) );
-    activedDists.push_back( dists.row(maxLoc.y) );
-    candidatePointsMask.at&lt;uchar&gt;(0, maxLoc.y) = 0;
-
-    for( size_t i = 2; i &lt; count; i++ )
-    {
-        activedDists.push_back(dists.row(maxLoc.x));
-        candidatePointsMask.at&lt;uchar&gt;(0, maxLoc.x) = 0;
-
-        Mat minDists;
-        reduce( activedDists, minDists, 0, CV_REDUCE_MIN );
-        minMaxLoc( minDists, 0, &amp;maxVal, 0, &amp;maxLoc, candidatePointsMask );
-        dst.at&lt;Point3_&lt;uchar&gt; &gt;((int)i) = src.at&lt;Point3_&lt;uchar&gt; &gt;(maxLoc.x);
+      float dist = (float)norm(src.at&lt;Point3_&lt;uchar&gt; &gt;(i) - src.at&lt;Point3_&lt;uchar&gt; &gt;(j));
+      dists.at&lt;float&gt;(j, i) = dists.at&lt;float&gt;(i, j) = dist;
     }
+  }
+
+  double maxVal;
+  Point maxLoc;
+  minMaxLoc(dists, 0, &amp;maxVal, 0, &amp;maxLoc);
+
+  dst.at&lt;Point3_&lt;uchar&gt; &gt;(0) = src.at&lt;Point3_&lt;uchar&gt; &gt;(maxLoc.x);
+  dst.at&lt;Point3_&lt;uchar&gt; &gt;(1) = src.at&lt;Point3_&lt;uchar&gt; &gt;(maxLoc.y);
+
+  Mat activedDists(0, dists.cols, dists.type());
+  Mat candidatePointsMask(1, dists.cols, CV_8UC1, Scalar(255));
+  activedDists.push_back(dists.row(maxLoc.y));
+  candidatePointsMask.at&lt;uchar&gt;(0, maxLoc.y) = 0;
+
+  for (size_t i = 2; i &lt; count; i++)
+  {
+    activedDists.push_back(dists.row(maxLoc.x));
+    candidatePointsMask.at&lt;uchar&gt;(0, maxLoc.x) = 0;
+
+    Mat minDists;
+    reduce(activedDists, minDists, 0, CV_REDUCE_MIN);
+    minMaxLoc(minDists, 0, &amp;maxVal, 0, &amp;maxLoc, candidatePointsMask);
+    dst.at&lt;Point3_&lt;uchar&gt; &gt;((int)i) = src.at&lt;Point3_&lt;uchar&gt; &gt;(maxLoc.x);
+  }
 }
 
-void generateColors( std::vector&lt;Scalar&gt;&amp; colors, size_t count, size_t factor=100 )
+void generateColors(std::vector&lt;Scalar&gt;&amp; colors, size_t count, size_t factor = 100)
 {
-    if( count &lt; 1 )
-        return;
-
-    colors.resize(count);
-
-    if( count == 1 )
-    {
-        colors[0] = Scalar(0,0,255); // red
-        return;
-    }
-    if( count == 2 )
-    {
-        colors[0] = Scalar(0,0,255); // red
-        colors[1] = Scalar(0,255,0); // green
-        return;
-    }
-
-    // Generate a set of colors in RGB space. A size of the set is severel times (=factor) larger then
-    // the needed count of colors.
-    Mat bgr( 1, (int)(count*factor), CV_8UC3 );
-    randu( bgr, 0, 256 );
-
-    // Convert the colors set to Lab space.
-    // Distances between colors in this space correspond a human perception.
-    Mat lab;
-    cvtColor( bgr, lab, cv::COLOR_BGR2Lab);
-
-    // Subsample colors from the generated set so that
-    // to maximize the minimum distances between each other.
-    // Douglas-Peucker algorithm is used for this.
-    Mat lab_subset;
-    downsamplePoints( lab, lab_subset, count );
-
-    // Convert subsampled colors back to RGB
-    Mat bgr_subset;
-    cvtColor( lab_subset, bgr_subset, cv::COLOR_BGR2Lab );
-
-    CV_Assert( bgr_subset.total() == count );
-    for( size_t i = 0; i &lt; count; i++ )
-    {
-        Point3_&lt;uchar&gt; c = bgr_subset.at&lt;Point3_&lt;uchar&gt; &gt;((int)i);
-        colors[i] = Scalar(c.x, c.y, c.z);
-    }
+  if (count &lt; 1)
+    return;
+
+  colors.resize(count);
+
+  if (count == 1)
+  {
+    colors[0] = Scalar(0, 0, 255);  // red
+    return;
+  }
+  if (count == 2)
+  {
+    colors[0] = Scalar(0, 0, 255);  // red
+    colors[1] = Scalar(0, 255, 0);  // green
+    return;
+  }
+
+  // Generate a set of colors in RGB space. A size of the set is severel times (=factor) larger then
+  // the needed count of colors.
+  Mat bgr(1, (int)(count * factor), CV_8UC3);
+  randu(bgr, 0, 256);
+
+  // Convert the colors set to Lab space.
+  // Distances between colors in this space correspond a human perception.
+  Mat lab;
+  cvtColor(bgr, lab, cv::COLOR_BGR2Lab);
+
+  // Subsample colors from the generated set so that
+  // to maximize the minimum distances between each other.
+  // Douglas-Peucker algorithm is used for this.
+  Mat lab_subset;
+  downsamplePoints(lab, lab_subset, count);
+
+  // Convert subsampled colors back to RGB
+  Mat bgr_subset;
+  cvtColor(lab_subset, bgr_subset, cv::COLOR_BGR2Lab);
+
+  CV_Assert(bgr_subset.total() == count);
+  for (size_t i = 0; i &lt; count; i++)
+  {
+    Point3_&lt;uchar&gt; c = bgr_subset.at&lt;Point3_&lt;uchar&gt; &gt;((int)i);
+    colors[i] = Scalar(c.x, c.y, c.z);
+  }
 }
 
-#endif //GENCOLORS_CPP
+#endif  // GENCOLORS_CPP
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\include\gpu_euclidean_clustering.h" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\include\gpu_euclidean_clustering.h" added_lines="40" deleted_lines="38">
				<diff>@@ -4,47 +4,49 @@
 #include &lt;iostream&gt;
 #include &lt;vector&gt;
 
-class GpuEuclideanCluster {
+class GpuEuclideanCluster
+{
 public:
-	typedef struct {
-		int index_value;
-		std::vector&lt;int&gt; points_in_cluster;
-	} GClusterIndex;
-
-	typedef struct {
-		float *x;
-		float *y;
-		float *z;
-		int size;
-	} SamplePointListXYZ;
-
-	GpuEuclideanCluster();
-
-	void setInputPoints(float *x, float *y, float *z, int size);
-	void setThreshold(double threshold);
-	void setMinClusterPts(int min_cluster_pts);
-	void setMaxClusterPts(int max_cluster_pts);
-	void extractClustersOld();
-	void extractClusters();
-	void extractClusters2();
-	std::vector&lt;GClusterIndex&gt; getOutput();
-
-	SamplePointListXYZ generateSample();
-
-	~GpuEuclideanCluster();
+  typedef struct
+  {
+    int index_value;
+    std::vector&lt;int&gt; points_in_cluster;
+  } GClusterIndex;
+
+  typedef struct
+  {
+    float* x;
+    float* y;
+    float* z;
+    int size;
+  } SamplePointListXYZ;
+
+  GpuEuclideanCluster();
+
+  void setInputPoints(float* x, float* y, float* z, int size);
+  void setThreshold(double threshold);
+  void setMinClusterPts(int min_cluster_pts);
+  void setMaxClusterPts(int max_cluster_pts);
+  void extractClustersOld();
+  void extractClusters();
+  void extractClusters2();
+  std::vector&lt;GClusterIndex&gt; getOutput();
+
+  SamplePointListXYZ generateSample();
+
+  ~GpuEuclideanCluster();
 
 private:
-	float *x_, *y_, *z_;
-	int size_;
-	double threshold_;
-	int *cluster_indices_;
-	int *cluster_indices_host_;
-	int min_cluster_pts_;
-	int max_cluster_pts_;
-	int cluster_num_;
-
-
-	void exclusiveScan(int *input, int ele_num, int *sum);
+  float *x_, *y_, *z_;
+  int size_;
+  double threshold_;
+  int* cluster_indices_;
+  int* cluster_indices_host_;
+  int min_cluster_pts_;
+  int max_cluster_pts_;
+  int cluster_num_;
+
+  void exclusiveScan(int* input, int ele_num, int* sum);
 };
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\cluster.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\cluster.cpp" added_lines="249" deleted_lines="249">
				<diff>@@ -9,349 +9,349 @@
 
 Cluster::Cluster()
 {
-    valid_cluster_ = true;
+  valid_cluster_ = true;
 }
 
 geometry_msgs::PolygonStamped Cluster::GetPolygon()
 {
-    return polygon_;
+  return polygon_;
 }
 
 jsk_recognition_msgs::BoundingBox Cluster::GetBoundingBox()
 {
-    return bounding_box_;
+  return bounding_box_;
 }
 
 pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr Cluster::GetCloud()
 {
-    return pointcloud_;
+  return pointcloud_;
 }
 
 pcl::PointXYZ Cluster::GetMinPoint()
 {
-    return min_point_;
+  return min_point_;
 }
 
 pcl::PointXYZ Cluster::GetMaxPoint()
 {
-    return max_point_;
+  return max_point_;
 }
 
 pcl::PointXYZ Cluster::GetCentroid()
 {
-    return centroid_;
+  return centroid_;
 }
 
 pcl::PointXYZ Cluster::GetAveragePoint()
 {
-    return average_point_;
+  return average_point_;
 }
 
 double Cluster::GetOrientationAngle()
 {
-    return orientation_angle_;
+  return orientation_angle_;
 }
 
 Eigen::Matrix3f Cluster::GetEigenVectors()
 {
-    return eigen_vectors_;
+  return eigen_vectors_;
 }
 
 Eigen::Vector3f Cluster::GetEigenValues()
 {
-    return eigen_values_;
+  return eigen_values_;
 }
 
-void Cluster::ToRosMessage(std_msgs::Header in_ros_header, autoware_msgs::CloudCluster &amp;out_cluster_message)
+void Cluster::ToRosMessage(std_msgs::Header in_ros_header, autoware_msgs::CloudCluster&amp; out_cluster_message)
 {
-    sensor_msgs::PointCloud2 cloud_msg;
+  sensor_msgs::PointCloud2 cloud_msg;
 
-    pcl::toROSMsg(*(this-&gt;GetCloud()), cloud_msg);
-    cloud_msg.header = in_ros_header;
+  pcl::toROSMsg(*(this-&gt;GetCloud()), cloud_msg);
+  cloud_msg.header = in_ros_header;
 
-    out_cluster_message.header = in_ros_header;
+  out_cluster_message.header = in_ros_header;
 
-    out_cluster_message.cloud = cloud_msg;
-    out_cluster_message.min_point.header = in_ros_header;
-    out_cluster_message.min_point.point.x = this-&gt;GetMinPoint().x;
-    out_cluster_message.min_point.point.y = this-&gt;GetMinPoint().y;
-    out_cluster_message.min_point.point.z = this-&gt;GetMinPoint().z;
+  out_cluster_message.cloud = cloud_msg;
+  out_cluster_message.min_point.header = in_ros_header;
+  out_cluster_message.min_point.point.x = this-&gt;GetMinPoint().x;
+  out_cluster_message.min_point.point.y = this-&gt;GetMinPoint().y;
+  out_cluster_message.min_point.point.z = this-&gt;GetMinPoint().z;
 
-    out_cluster_message.max_point.header = in_ros_header;
-    out_cluster_message.max_point.point.x = this-&gt;GetMaxPoint().x;
-    out_cluster_message.max_point.point.y = this-&gt;GetMaxPoint().y;
-    out_cluster_message.max_point.point.z = this-&gt;GetMaxPoint().z;
+  out_cluster_message.max_point.header = in_ros_header;
+  out_cluster_message.max_point.point.x = this-&gt;GetMaxPoint().x;
+  out_cluster_message.max_point.point.y = this-&gt;GetMaxPoint().y;
+  out_cluster_message.max_point.point.z = this-&gt;GetMaxPoint().z;
 
-    out_cluster_message.avg_point.header = in_ros_header;
-    out_cluster_message.avg_point.point.x = this-&gt;GetAveragePoint().x;
-    out_cluster_message.avg_point.point.y = this-&gt;GetAveragePoint().y;
-    out_cluster_message.avg_point.point.z = this-&gt;GetAveragePoint().z;
+  out_cluster_message.avg_point.header = in_ros_header;
+  out_cluster_message.avg_point.point.x = this-&gt;GetAveragePoint().x;
+  out_cluster_message.avg_point.point.y = this-&gt;GetAveragePoint().y;
+  out_cluster_message.avg_point.point.z = this-&gt;GetAveragePoint().z;
 
-    out_cluster_message.centroid_point.header = in_ros_header;
-    out_cluster_message.centroid_point.point.x = this-&gt;GetCentroid().x;
-    out_cluster_message.centroid_point.point.y = this-&gt;GetCentroid().y;
-    out_cluster_message.centroid_point.point.z = this-&gt;GetCentroid().z;
+  out_cluster_message.centroid_point.header = in_ros_header;
+  out_cluster_message.centroid_point.point.x = this-&gt;GetCentroid().x;
+  out_cluster_message.centroid_point.point.y = this-&gt;GetCentroid().y;
+  out_cluster_message.centroid_point.point.z = this-&gt;GetCentroid().z;
 
-    out_cluster_message.estimated_angle = this-&gt;GetOrientationAngle();
+  out_cluster_message.estimated_angle = this-&gt;GetOrientationAngle();
 
-    out_cluster_message.dimensions = this-&gt;GetBoundingBox().dimensions;
+  out_cluster_message.dimensions = this-&gt;GetBoundingBox().dimensions;
 
-    out_cluster_message.bounding_box = this-&gt;GetBoundingBox();
+  out_cluster_message.bounding_box = this-&gt;GetBoundingBox();
 
-    out_cluster_message.convex_hull = this-&gt;GetPolygon();
+  out_cluster_message.convex_hull = this-&gt;GetPolygon();
 
-    Eigen::Vector3f eigen_values = this-&gt;GetEigenValues();
-    out_cluster_message.eigen_values.x = eigen_values.x();
-    out_cluster_message.eigen_values.y = eigen_values.y();
-    out_cluster_message.eigen_values.z = eigen_values.z();
+  Eigen::Vector3f eigen_values = this-&gt;GetEigenValues();
+  out_cluster_message.eigen_values.x = eigen_values.x();
+  out_cluster_message.eigen_values.y = eigen_values.y();
+  out_cluster_message.eigen_values.z = eigen_values.z();
 
-    Eigen::Matrix3f eigen_vectors = this-&gt;GetEigenVectors();
-    for (unsigned int i = 0; i &lt; 3; i++)
-    {
-        geometry_msgs::Vector3 eigen_vector;
-        eigen_vector.x = eigen_vectors(i, 0);
-        eigen_vector.y = eigen_vectors(i, 1);
-        eigen_vector.z = eigen_vectors(i, 2);
-        out_cluster_message.eigen_vectors.push_back(eigen_vector);
-    }
+  Eigen::Matrix3f eigen_vectors = this-&gt;GetEigenVectors();
+  for (unsigned int i = 0; i &lt; 3; i++)
+  {
+    geometry_msgs::Vector3 eigen_vector;
+    eigen_vector.x = eigen_vectors(i, 0);
+    eigen_vector.y = eigen_vectors(i, 1);
+    eigen_vector.z = eigen_vectors(i, 2);
+    out_cluster_message.eigen_vectors.push_back(eigen_vector);
+  }
 
-    /*std::vector&lt;float&gt; fpfh_descriptor = GetFpfhDescriptor(8, 0.3, 0.3);
-    out_cluster_message.fpfh_descriptor.data = fpfh_descriptor;*/
+  /*std::vector&lt;float&gt; fpfh_descriptor = GetFpfhDescriptor(8, 0.3, 0.3);
+  out_cluster_message.fpfh_descriptor.data = fpfh_descriptor;*/
 }
 
 void Cluster::SetCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_origin_cloud_ptr,
-                       const std::vector&lt;int&gt; &amp;in_cluster_indices, std_msgs::Header in_ros_header, int in_id, int in_r,
+                       const std::vector&lt;int&gt;&amp; in_cluster_indices, std_msgs::Header in_ros_header, int in_id, int in_r,
                        int in_g, int in_b, std::string in_label, bool in_estimate_pose)
 {
-    label_ = in_label;
-    id_ = in_id;
-    r_ = in_r;
-    g_ = in_g;
-    b_ = in_b;
-    //extract pointcloud using the indices
-    //calculate min and max points
-    pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr current_cluster(new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
-    float min_x = std::numeric_limits&lt;float&gt;::max();
-    float max_x = -std::numeric_limits&lt;float&gt;::max();
-    float min_y = std::numeric_limits&lt;float&gt;::max();
-    float max_y = -std::numeric_limits&lt;float&gt;::max();
-    float min_z = std::numeric_limits&lt;float&gt;::max();
-    float max_z = -std::numeric_limits&lt;float&gt;::max();
-    float average_x = 0, average_y = 0, average_z = 0;
-
-    for (auto pit = in_cluster_indices.begin(); pit != in_cluster_indices.end(); ++pit)
+  label_ = in_label;
+  id_ = in_id;
+  r_ = in_r;
+  g_ = in_g;
+  b_ = in_b;
+  // extract pointcloud using the indices
+  // calculate min and max points
+  pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr current_cluster(new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
+  float min_x = std::numeric_limits&lt;float&gt;::max();
+  float max_x = -std::numeric_limits&lt;float&gt;::max();
+  float min_y = std::numeric_limits&lt;float&gt;::max();
+  float max_y = -std::numeric_limits&lt;float&gt;::max();
+  float min_z = std::numeric_limits&lt;float&gt;::max();
+  float max_z = -std::numeric_limits&lt;float&gt;::max();
+  float average_x = 0, average_y = 0, average_z = 0;
+
+  for (auto pit = in_cluster_indices.begin(); pit != in_cluster_indices.end(); ++pit)
+  {
+    // fill new colored cluster point by point
+    pcl::PointXYZRGB p;
+    p.x = in_origin_cloud_ptr-&gt;points[*pit].x;
+    p.y = in_origin_cloud_ptr-&gt;points[*pit].y;
+    p.z = in_origin_cloud_ptr-&gt;points[*pit].z;
+    p.r = in_r;
+    p.g = in_g;
+    p.b = in_b;
+
+    average_x += p.x;
+    average_y += p.y;
+    average_z += p.z;
+    centroid_.x += p.x;
+    centroid_.y += p.y;
+    centroid_.z += p.z;
+    current_cluster-&gt;points.push_back(p);
+
+    if (p.x &lt; min_x)
+      min_x = p.x;
+    if (p.y &lt; min_y)
+      min_y = p.y;
+    if (p.z &lt; min_z)
+      min_z = p.z;
+    if (p.x &gt; max_x)
+      max_x = p.x;
+    if (p.y &gt; max_y)
+      max_y = p.y;
+    if (p.z &gt; max_z)
+      max_z = p.z;
+  }
+  // min, max points
+  min_point_.x = min_x;
+  min_point_.y = min_y;
+  min_point_.z = min_z;
+  max_point_.x = max_x;
+  max_point_.y = max_y;
+  max_point_.z = max_z;
+
+  // calculate centroid, average
+  if (in_cluster_indices.size() &gt; 0)
+  {
+    centroid_.x /= in_cluster_indices.size();
+    centroid_.y /= in_cluster_indices.size();
+    centroid_.z /= in_cluster_indices.size();
+
+    average_x /= in_cluster_indices.size();
+    average_y /= in_cluster_indices.size();
+    average_z /= in_cluster_indices.size();
+  }
+
+  average_point_.x = average_x;
+  average_point_.y = average_y;
+  average_point_.z = average_z;
+
+  // calculate bounding box
+  length_ = max_point_.x - min_point_.x;
+  width_ = max_point_.y - min_point_.y;
+  height_ = max_point_.z - min_point_.z;
+
+  bounding_box_.header = in_ros_header;
+
+  bounding_box_.pose.position.x = min_point_.x + length_ / 2;
+  bounding_box_.pose.position.y = min_point_.y + width_ / 2;
+  bounding_box_.pose.position.z = min_point_.z + height_ / 2;
+
+  bounding_box_.dimensions.x = ((length_ &lt; 0) ? -1 * length_ : length_);
+  bounding_box_.dimensions.y = ((width_ &lt; 0) ? -1 * width_ : width_);
+  bounding_box_.dimensions.z = ((height_ &lt; 0) ? -1 * height_ : height_);
+
+  // pose estimation
+  double rz = 0;
+
+  {
+    std::vector&lt;cv::Point2f&gt; points;
+    for (unsigned int i = 0; i &lt; current_cluster-&gt;points.size(); i++)
     {
-        //fill new colored cluster point by point
-        pcl::PointXYZRGB p;
-        p.x = in_origin_cloud_ptr-&gt;points[*pit].x;
-        p.y = in_origin_cloud_ptr-&gt;points[*pit].y;
-        p.z = in_origin_cloud_ptr-&gt;points[*pit].z;
-        p.r = in_r;
-        p.g = in_g;
-        p.b = in_b;
-
-        average_x += p.x;
-        average_y += p.y;
-        average_z += p.z;
-        centroid_.x += p.x;
-        centroid_.y += p.y;
-        centroid_.z += p.z;
-        current_cluster-&gt;points.push_back(p);
-
-        if (p.x &lt; min_x)
-            min_x = p.x;
-        if (p.y &lt; min_y)
-            min_y = p.y;
-        if (p.z &lt; min_z)
-            min_z = p.z;
-        if (p.x &gt; max_x)
-            max_x = p.x;
-        if (p.y &gt; max_y)
-            max_y = p.y;
-        if (p.z &gt; max_z)
-            max_z = p.z;
-    }
-    //min, max points
-    min_point_.x = min_x;
-    min_point_.y = min_y;
-    min_point_.z = min_z;
-    max_point_.x = max_x;
-    max_point_.y = max_y;
-    max_point_.z = max_z;
-
-    //calculate centroid, average
-    if (in_cluster_indices.size() &gt; 0)
-    {
-        centroid_.x /= in_cluster_indices.size();
-        centroid_.y /= in_cluster_indices.size();
-        centroid_.z /= in_cluster_indices.size();
-
-        average_x /= in_cluster_indices.size();
-        average_y /= in_cluster_indices.size();
-        average_z /= in_cluster_indices.size();
+      cv::Point2f pt;
+      pt.x = current_cluster-&gt;points[i].x;
+      pt.y = current_cluster-&gt;points[i].y;
+      points.push_back(pt);
     }
 
-    average_point_.x = average_x;
-    average_point_.y = average_y;
-    average_point_.z = average_z;
-
-    //calculate bounding box
-    length_ = max_point_.x - min_point_.x;
-    width_ = max_point_.y - min_point_.y;
-    height_ = max_point_.z - min_point_.z;
-
-    bounding_box_.header = in_ros_header;
-
-    bounding_box_.pose.position.x = min_point_.x + length_ / 2;
-    bounding_box_.pose.position.y = min_point_.y + width_ / 2;
-    bounding_box_.pose.position.z = min_point_.z + height_ / 2;
-
-    bounding_box_.dimensions.x = ((length_ &lt; 0) ? -1 * length_ : length_);
-    bounding_box_.dimensions.y = ((width_ &lt; 0) ? -1 * width_ : width_);
-    bounding_box_.dimensions.z = ((height_ &lt; 0) ? -1 * height_ : height_);
+    std::vector&lt;cv::Point2f&gt; hull;
+    cv::convexHull(points, hull);
 
-    //pose estimation
-    double rz = 0;
+    polygon_.header = in_ros_header;
+    for (size_t i = 0; i &lt; hull.size() + 1; i++)
+    {
+      geometry_msgs::Point32 point;
+      point.x = hull[i % hull.size()].x;
+      point.y = hull[i % hull.size()].y;
+      point.z = min_point_.z;
+      polygon_.polygon.points.push_back(point);
+    }
 
+    for (size_t i = 0; i &lt; hull.size() + 1; i++)
     {
-        std::vector&lt;cv::Point2f&gt; points;
-        for (unsigned int i = 0; i &lt; current_cluster-&gt;points.size(); i++)
-        {
-            cv::Point2f pt;
-            pt.x = current_cluster-&gt;points[i].x;
-            pt.y = current_cluster-&gt;points[i].y;
-            points.push_back(pt);
-        }
-
-        std::vector&lt;cv::Point2f&gt; hull;
-        cv::convexHull(points, hull);
-
-        polygon_.header = in_ros_header;
-        for (size_t i = 0; i &lt; hull.size() + 1; i++)
-        {
-            geometry_msgs::Point32 point;
-            point.x = hull[i % hull.size()].x;
-            point.y = hull[i % hull.size()].y;
-            point.z = min_point_.z;
-            polygon_.polygon.points.push_back(point);
-        }
-
-        for (size_t i = 0; i &lt; hull.size() + 1; i++)
-        {
-            geometry_msgs::Point32 point;
-            point.x = hull[i % hull.size()].x;
-            point.y = hull[i % hull.size()].y;
-            point.z = max_point_.z;
-            polygon_.polygon.points.push_back(point);
-        }
-        if (in_estimate_pose)
-        {
-            cv::RotatedRect box = minAreaRect(hull);
-            rz = box.angle * 3.14 / 180;
-            bounding_box_.pose.position.x = box.center.x;
-            bounding_box_.pose.position.y = box.center.y;
-            bounding_box_.dimensions.x = box.size.width;
-            bounding_box_.dimensions.y = box.size.height;
-        }
+      geometry_msgs::Point32 point;
+      point.x = hull[i % hull.size()].x;
+      point.y = hull[i % hull.size()].y;
+      point.z = max_point_.z;
+      polygon_.polygon.points.push_back(point);
     }
+    if (in_estimate_pose)
+    {
+      cv::RotatedRect box = minAreaRect(hull);
+      rz = box.angle * 3.14 / 180;
+      bounding_box_.pose.position.x = box.center.x;
+      bounding_box_.pose.position.y = box.center.y;
+      bounding_box_.dimensions.x = box.size.width;
+      bounding_box_.dimensions.y = box.size.height;
+    }
+  }
 
-    //set bounding box direction
-    tf::Quaternion quat = tf::createQuaternionFromRPY(0.0, 0.0, rz);
-    tf::quaternionTFToMsg(quat, bounding_box_.pose.orientation);
+  // set bounding box direction
+  tf::Quaternion quat = tf::createQuaternionFromRPY(0.0, 0.0, rz);
+  tf::quaternionTFToMsg(quat, bounding_box_.pose.orientation);
 
-    current_cluster-&gt;width = current_cluster-&gt;points.size();
-    current_cluster-&gt;height = 1;
-    current_cluster-&gt;is_dense = true;
+  current_cluster-&gt;width = current_cluster-&gt;points.size();
+  current_cluster-&gt;height = 1;
+  current_cluster-&gt;is_dense = true;
 
-    //Get EigenValues, eigenvectors
-    if (current_cluster-&gt;points.size() &gt; 0)
-    {
-        pcl::PCA&lt;pcl::PointXYZ&gt; current_cluster_pca;
-        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr current_cluster_mono(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+  // Get EigenValues, eigenvectors
+  if (current_cluster-&gt;points.size() &gt; 0)
+  {
+    pcl::PCA&lt;pcl::PointXYZ&gt; current_cluster_pca;
+    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr current_cluster_mono(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
 
-        pcl::copyPointCloud&lt;pcl::PointXYZRGB, pcl::PointXYZ&gt;(*current_cluster, *current_cluster_mono);
+    pcl::copyPointCloud&lt;pcl::PointXYZRGB, pcl::PointXYZ&gt;(*current_cluster, *current_cluster_mono);
 
-        current_cluster_pca.setInputCloud(current_cluster_mono);
-        eigen_vectors_ = current_cluster_pca.getEigenVectors();
-        eigen_values_ = current_cluster_pca.getEigenValues();
-    }
+    current_cluster_pca.setInputCloud(current_cluster_mono);
+    eigen_vectors_ = current_cluster_pca.getEigenVectors();
+    eigen_values_ = current_cluster_pca.getEigenValues();
+  }
 
-    valid_cluster_ = true;
-    pointcloud_ = current_cluster;
+  valid_cluster_ = true;
+  pointcloud_ = current_cluster;
 }
 
-std::vector&lt;float&gt;
-Cluster::GetFpfhDescriptor(const unsigned int &amp;in_ompnum_threads, const double &amp;in_normal_search_radius,
-                           const double &amp;in_fpfh_search_radius)
+std::vector&lt;float&gt; Cluster::GetFpfhDescriptor(const unsigned int&amp; in_ompnum_threads,
+                                              const double&amp; in_normal_search_radius,
+                                              const double&amp; in_fpfh_search_radius)
 {
-    std::vector&lt;float&gt; cluster_fpfh_histogram(33, 0.0);
-
-    pcl::search::KdTree&lt;pcl::PointXYZRGB&gt;::Ptr norm_tree(new pcl::search::KdTree&lt;pcl::PointXYZRGB&gt;);
-    if (pointcloud_-&gt;points.size() &gt; 0)
-        norm_tree-&gt;setInputCloud(pointcloud_);
-
-    pcl::PointCloud&lt;pcl::Normal&gt;::Ptr normals(new pcl::PointCloud&lt;pcl::Normal&gt;);
-    pcl::NormalEstimationOMP&lt;pcl::PointXYZRGB, pcl::Normal&gt; normal_estimation;
-    normal_estimation.setNumberOfThreads(in_ompnum_threads);
-    normal_estimation.setInputCloud(pointcloud_);
-    normal_estimation.setSearchMethod(norm_tree);
-    normal_estimation.setViewPoint(std::numeric_limits&lt;float&gt;::max(), std::numeric_limits&lt;float&gt;::max(),
-                                   std::numeric_limits&lt;float&gt;::max());
-    normal_estimation.setRadiusSearch(in_normal_search_radius);
-    normal_estimation.compute(*normals);
-
-    pcl::PointCloud&lt;pcl::FPFHSignature33&gt;::Ptr fpfh_histograms(new pcl::PointCloud&lt;pcl::FPFHSignature33&gt;());
-
-    pcl::FPFHEstimationOMP&lt;pcl::PointXYZRGB, pcl::Normal, pcl::FPFHSignature33&gt; fpfh;
-    fpfh.setNumberOfThreads(in_ompnum_threads);
-    fpfh.setInputCloud(pointcloud_);
-    fpfh.setInputNormals(normals);
-    fpfh.setSearchMethod(norm_tree);
-    fpfh.setRadiusSearch(in_fpfh_search_radius);
-    fpfh.compute(*fpfh_histograms);
-
-    float fpfh_max = std::numeric_limits&lt;float&gt;::min();
-    float fpfh_min = std::numeric_limits&lt;float&gt;::max();
-
-    for (unsigned int i = 0; i &lt; fpfh_histograms-&gt;size(); i++) //for each point fpfh
+  std::vector&lt;float&gt; cluster_fpfh_histogram(33, 0.0);
+
+  pcl::search::KdTree&lt;pcl::PointXYZRGB&gt;::Ptr norm_tree(new pcl::search::KdTree&lt;pcl::PointXYZRGB&gt;);
+  if (pointcloud_-&gt;points.size() &gt; 0)
+    norm_tree-&gt;setInputCloud(pointcloud_);
+
+  pcl::PointCloud&lt;pcl::Normal&gt;::Ptr normals(new pcl::PointCloud&lt;pcl::Normal&gt;);
+  pcl::NormalEstimationOMP&lt;pcl::PointXYZRGB, pcl::Normal&gt; normal_estimation;
+  normal_estimation.setNumberOfThreads(in_ompnum_threads);
+  normal_estimation.setInputCloud(pointcloud_);
+  normal_estimation.setSearchMethod(norm_tree);
+  normal_estimation.setViewPoint(std::numeric_limits&lt;float&gt;::max(), std::numeric_limits&lt;float&gt;::max(),
+                                 std::numeric_limits&lt;float&gt;::max());
+  normal_estimation.setRadiusSearch(in_normal_search_radius);
+  normal_estimation.compute(*normals);
+
+  pcl::PointCloud&lt;pcl::FPFHSignature33&gt;::Ptr fpfh_histograms(new pcl::PointCloud&lt;pcl::FPFHSignature33&gt;());
+
+  pcl::FPFHEstimationOMP&lt;pcl::PointXYZRGB, pcl::Normal, pcl::FPFHSignature33&gt; fpfh;
+  fpfh.setNumberOfThreads(in_ompnum_threads);
+  fpfh.setInputCloud(pointcloud_);
+  fpfh.setInputNormals(normals);
+  fpfh.setSearchMethod(norm_tree);
+  fpfh.setRadiusSearch(in_fpfh_search_radius);
+  fpfh.compute(*fpfh_histograms);
+
+  float fpfh_max = std::numeric_limits&lt;float&gt;::min();
+  float fpfh_min = std::numeric_limits&lt;float&gt;::max();
+
+  for (unsigned int i = 0; i &lt; fpfh_histograms-&gt;size(); i++)  // for each point fpfh
+  {
+    for (unsigned int j = 0; j &lt; cluster_fpfh_histogram.size();
+         j++)  // sum each histogram's bin for all points, get min/max
+    {
+      cluster_fpfh_histogram[j] = cluster_fpfh_histogram[j] + fpfh_histograms-&gt;points[i].histogram[j];
+      if (cluster_fpfh_histogram[j] &lt; fpfh_min)
+        fpfh_min = cluster_fpfh_histogram[j];
+      if (cluster_fpfh_histogram[j] &gt; fpfh_max)
+        fpfh_max = cluster_fpfh_histogram[j];
+    }
+
+    float fpfh_dif = fpfh_max - fpfh_min;
+    for (unsigned int j = 0; fpfh_dif &gt; 0 &amp;&amp; j &lt; cluster_fpfh_histogram.size();
+         j++)  // substract the min from each and normalize
     {
-        for (unsigned int j = 0;
-             j &lt; cluster_fpfh_histogram.size(); j++)//sum each histogram's bin for all points, get min/max
-        {
-            cluster_fpfh_histogram[j] = cluster_fpfh_histogram[j] + fpfh_histograms-&gt;points[i].histogram[j];
-            if (cluster_fpfh_histogram[j] &lt; fpfh_min)
-                fpfh_min = cluster_fpfh_histogram[j];
-            if (cluster_fpfh_histogram[j] &gt; fpfh_max)
-                fpfh_max = cluster_fpfh_histogram[j];
-        }
-
-        float fpfh_dif = fpfh_max - fpfh_min;
-        for (unsigned int j = 0;
-             fpfh_dif &gt; 0 &amp;&amp; j &lt; cluster_fpfh_histogram.size(); j++)//substract the min from each and normalize
-        {
-            cluster_fpfh_histogram[j] = (cluster_fpfh_histogram[j] - fpfh_min) / fpfh_dif;
-        }
+      cluster_fpfh_histogram[j] = (cluster_fpfh_histogram[j] - fpfh_min) / fpfh_dif;
     }
+  }
 
-    return cluster_fpfh_histogram;
+  return cluster_fpfh_histogram;
 }
 
 bool Cluster::IsValid()
 {
-    return valid_cluster_;
+  return valid_cluster_;
 }
 
 void Cluster::SetValidity(bool in_valid)
 {
-    valid_cluster_ = in_valid;
+  valid_cluster_ = in_valid;
 }
 
 int Cluster::GetId()
 {
-    return id_;
+  return id_;
 }
 
 Cluster::~Cluster()
 {
-    // TODO Auto-generated destructor stub
+  // TODO Auto-generated destructor stub
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="955" deleted_lines="875">
				<diff>@@ -80,7 +80,6 @@
 
 #endif
 
-
 #include "cluster.h"
 
 #ifdef GPU_CLUSTERING
@@ -127,7 +126,7 @@ static double _leaf_size;
 static int _cluster_size_min;
 static int _cluster_size_max;
 
-static bool _remove_ground;    //only ground
+static bool _remove_ground;  // only ground
 
 static bool _using_sensor_cloud;
 static bool _use_diffnormals;
@@ -153,1023 +152,1104 @@ std::vector&lt;cv::Scalar&gt; _colors;
 pcl::PointCloud&lt;pcl::PointXYZ&gt; _sensor_cloud;
 visualization_msgs::Marker _visualization_marker;
 
-tf::StampedTransform *_transform;
-tf::StampedTransform *_velodyne_output_transform;
-tf::TransformListener *_transform_listener;
-tf::TransformListener *_vectormap_transform_listener;
-
-tf::StampedTransform findTransform(const std::string &amp;in_target_frame, const std::string &amp;in_source_frame) {
-    tf::StampedTransform transform;
-
-    try {
-        // What time should we use?
-        _vectormap_transform_listener-&gt;lookupTransform(in_target_frame, in_source_frame, ros::Time(0), transform);
-    }
-    catch (tf::TransformException ex) {
-        ROS_ERROR("%s", ex.what());
-        return transform;
-    }
+tf::StampedTransform* _transform;
+tf::StampedTransform* _velodyne_output_transform;
+tf::TransformListener* _transform_listener;
+tf::TransformListener* _vectormap_transform_listener;
 
+tf::StampedTransform findTransform(const std::string&amp; in_target_frame, const std::string&amp; in_source_frame)
+{
+  tf::StampedTransform transform;
+
+  try
+  {
+    // What time should we use?
+    _vectormap_transform_listener-&gt;lookupTransform(in_target_frame, in_source_frame, ros::Time(0), transform);
+  }
+  catch (tf::TransformException ex)
+  {
+    ROS_ERROR("%s", ex.what());
     return transform;
+  }
+
+  return transform;
 }
 
-geometry_msgs::Point transformPoint(const geometry_msgs::Point &amp;point, const tf::Transform &amp;tf) {
-    tf::Point tf_point;
-    tf::pointMsgToTF(point, tf_point);
+geometry_msgs::Point transformPoint(const geometry_msgs::Point&amp; point, const tf::Transform&amp; tf)
+{
+  tf::Point tf_point;
+  tf::pointMsgToTF(point, tf_point);
 
-    tf_point = tf * tf_point;
+  tf_point = tf * tf_point;
 
-    geometry_msgs::Point ros_point;
-    tf::pointTFToMsg(tf_point, ros_point);
+  geometry_msgs::Point ros_point;
+  tf::pointTFToMsg(tf_point, ros_point);
 
-    return ros_point;
+  return ros_point;
 }
 
-bool checkPointInGrid(const grid_map::GridMap &amp;in_grid_map, const cv::Mat &amp;in_grid_image,
-                      const geometry_msgs::Point &amp;in_point) {
-    // calculate out_grid_map position
-    grid_map::Position map_pos = in_grid_map.getPosition();
-    double origin_x_offset = in_grid_map.getLength().x() / 2.0 - map_pos.x();
-    double origin_y_offset = in_grid_map.getLength().y() / 2.0 - map_pos.y();
-    // coordinate conversion for cv image
-    double cv_x = (in_grid_map.getLength().y() - origin_y_offset - in_point.y) / in_grid_map.getResolution();
-    double cv_y = (in_grid_map.getLength().x() - origin_x_offset - in_point.x) / in_grid_map.getResolution();
-
-    //check coords are inside the gridmap
-    if (cv_x &lt; 0 || cv_x &gt; in_grid_image.cols || cv_y &lt; 0 || cv_y &gt; in_grid_image.rows) {
-        return false;
-    }
+bool checkPointInGrid(const grid_map::GridMap&amp; in_grid_map, const cv::Mat&amp; in_grid_image,
+                      const geometry_msgs::Point&amp; in_point)
+{
+  // calculate out_grid_map position
+  grid_map::Position map_pos = in_grid_map.getPosition();
+  double origin_x_offset = in_grid_map.getLength().x() / 2.0 - map_pos.x();
+  double origin_y_offset = in_grid_map.getLength().y() / 2.0 - map_pos.y();
+  // coordinate conversion for cv image
+  double cv_x = (in_grid_map.getLength().y() - origin_y_offset - in_point.y) / in_grid_map.getResolution();
+  double cv_y = (in_grid_map.getLength().x() - origin_x_offset - in_point.x) / in_grid_map.getResolution();
+
+  // check coords are inside the gridmap
+  if (cv_x &lt; 0 || cv_x &gt; in_grid_image.cols || cv_y &lt; 0 || cv_y &gt; in_grid_image.rows)
+  {
+    return false;
+  }
 
-    //_gridmap_no_road_value if road
-    if (in_grid_image.at&lt;uchar&gt;(cv_y, cv_x) != _gridmap_no_road_value) {
-        return true;
-    }
+  //_gridmap_no_road_value if road
+  if (in_grid_image.at&lt;uchar&gt;(cv_y, cv_x) != _gridmap_no_road_value)
+  {
+    return true;
+  }
 
-    return false;
+  return false;
 }
 
-void transformBoundingBox(const jsk_recognition_msgs::BoundingBox &amp;in_boundingbox,
-                          jsk_recognition_msgs::BoundingBox &amp;out_boundingbox, const std::string &amp;in_target_frame,
-                          const std_msgs::Header &amp;in_header) {
-    geometry_msgs::PoseStamped pose_in, pose_out;
-    pose_in.header = in_header;
-    pose_in.pose = in_boundingbox.pose;
-    try {
-        _transform_listener-&gt;transformPose(in_target_frame, ros::Time(), pose_in, in_header.frame_id, pose_out);
-    }
-    catch (tf::TransformException &amp;ex) {
-        ROS_ERROR("transformBoundingBox: %s", ex.what());
-    }
-    out_boundingbox.pose = pose_out.pose;
-    out_boundingbox.header = in_header;
-    out_boundingbox.header.frame_id = in_target_frame;
-    out_boundingbox.dimensions = in_boundingbox.dimensions;
-    out_boundingbox.value = in_boundingbox.value;
-    out_boundingbox.label = in_boundingbox.label;
+void transformBoundingBox(const jsk_recognition_msgs::BoundingBox&amp; in_boundingbox,
+                          jsk_recognition_msgs::BoundingBox&amp; out_boundingbox, const std::string&amp; in_target_frame,
+                          const std_msgs::Header&amp; in_header)
+{
+  geometry_msgs::PoseStamped pose_in, pose_out;
+  pose_in.header = in_header;
+  pose_in.pose = in_boundingbox.pose;
+  try
+  {
+    _transform_listener-&gt;transformPose(in_target_frame, ros::Time(), pose_in, in_header.frame_id, pose_out);
+  }
+  catch (tf::TransformException&amp; ex)
+  {
+    ROS_ERROR("transformBoundingBox: %s", ex.what());
+  }
+  out_boundingbox.pose = pose_out.pose;
+  out_boundingbox.header = in_header;
+  out_boundingbox.header.frame_id = in_target_frame;
+  out_boundingbox.dimensions = in_boundingbox.dimensions;
+  out_boundingbox.value = in_boundingbox.value;
+  out_boundingbox.label = in_boundingbox.label;
 }
 
-void publishDetectedObjects(const autoware_msgs::CloudClusterArray &amp;in_clusters)
+void publishDetectedObjects(const autoware_msgs::CloudClusterArray&amp; in_clusters)
 {
-    autoware_msgs::DetectedObjectArray detected_objects;
-    detected_objects.header = in_clusters.header;
-
-    for (size_t i=0; i&lt; in_clusters.clusters.size(); i++)
-    {
-        autoware_msgs::DetectedObject detected_object;
-        detected_object.header = in_clusters.header;
-        detected_object.label = "unknown";
-        detected_object.id = i;
-        detected_object.score = 1.;
-        detected_object.space_frame = in_clusters.header.frame_id;
-        detected_object.pose = in_clusters.clusters[i].bounding_box.pose;
-        detected_object.dimensions = in_clusters.clusters[i].dimensions;
-        detected_object.pointcloud = in_clusters.clusters[i].cloud;
-        detected_object.convex_hull = in_clusters.clusters[i].convex_hull;
-        detected_object.color.r = 0.;
-        detected_object.color.g = 1.;
-        detected_object.color.b = 0.;
-        detected_object.color.a = 1.;
-
-        detected_objects.objects.push_back(detected_object);
-    }
-    _pub_detected_objects.publish(detected_objects);
+  autoware_msgs::DetectedObjectArray detected_objects;
+  detected_objects.header = in_clusters.header;
+
+  for (size_t i = 0; i &lt; in_clusters.clusters.size(); i++)
+  {
+    autoware_msgs::DetectedObject detected_object;
+    detected_object.header = in_clusters.header;
+    detected_object.label = "unknown";
+    detected_object.id = i;
+    detected_object.score = 1.;
+    detected_object.space_frame = in_clusters.header.frame_id;
+    detected_object.pose = in_clusters.clusters[i].bounding_box.pose;
+    detected_object.dimensions = in_clusters.clusters[i].dimensions;
+    detected_object.pointcloud = in_clusters.clusters[i].cloud;
+    detected_object.convex_hull = in_clusters.clusters[i].convex_hull;
+    detected_object.color.r = 0.;
+    detected_object.color.g = 1.;
+    detected_object.color.b = 0.;
+    detected_object.color.a = 1.;
+
+    detected_objects.objects.push_back(detected_object);
+  }
+  _pub_detected_objects.publish(detected_objects);
 }
 
-void publishCloudClusters(const ros::Publisher *in_publisher, const autoware_msgs::CloudClusterArray &amp;in_clusters,
-                          const std::string &amp;in_target_frame, const std_msgs::Header &amp;in_header) {
-    if (in_target_frame != in_header.frame_id) {
-        autoware_msgs::CloudClusterArray clusters_transformed;
-        clusters_transformed.header = in_header;
-        clusters_transformed.header.frame_id = in_target_frame;
-        for (auto i = in_clusters.clusters.begin(); i != in_clusters.clusters.end(); i++) {
-            autoware_msgs::CloudCluster cluster_transformed;
-            cluster_transformed.header = in_header;
-            try {
-                _transform_listener-&gt;lookupTransform(in_target_frame, _velodyne_header.frame_id,
-                                                     ros::Time(), *_transform);
-                pcl_ros::transformPointCloud(in_target_frame, *_transform, i-&gt;cloud, cluster_transformed.cloud);
-                _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;min_point, in_header.frame_id,
-                                                    cluster_transformed.min_point);
-                _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;max_point, in_header.frame_id,
-                                                    cluster_transformed.max_point);
-                _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;avg_point, in_header.frame_id,
-                                                    cluster_transformed.avg_point);
-                _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;centroid_point, in_header.frame_id,
-                                                    cluster_transformed.centroid_point);
-
-                cluster_transformed.dimensions = i-&gt;dimensions;
-                cluster_transformed.eigen_values = i-&gt;eigen_values;
-                cluster_transformed.eigen_vectors = i-&gt;eigen_vectors;
-
-                transformBoundingBox(i-&gt;bounding_box, cluster_transformed.bounding_box, in_target_frame, in_header);
-
-                clusters_transformed.clusters.push_back(cluster_transformed);
-            }
-            catch (tf::TransformException &amp;ex) {
-                ROS_ERROR("publishCloudClusters: %s", ex.what());
-            }
-        }
-        in_publisher-&gt;publish(clusters_transformed);
-        publishDetectedObjects(clusters_transformed);
-    } else {
-        in_publisher-&gt;publish(in_clusters);
-        publishDetectedObjects(in_clusters);
+void publishCloudClusters(const ros::Publisher* in_publisher, const autoware_msgs::CloudClusterArray&amp; in_clusters,
+                          const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
+{
+  if (in_target_frame != in_header.frame_id)
+  {
+    autoware_msgs::CloudClusterArray clusters_transformed;
+    clusters_transformed.header = in_header;
+    clusters_transformed.header.frame_id = in_target_frame;
+    for (auto i = in_clusters.clusters.begin(); i != in_clusters.clusters.end(); i++)
+    {
+      autoware_msgs::CloudCluster cluster_transformed;
+      cluster_transformed.header = in_header;
+      try
+      {
+        _transform_listener-&gt;lookupTransform(in_target_frame, _velodyne_header.frame_id, ros::Time(), *_transform);
+        pcl_ros::transformPointCloud(in_target_frame, *_transform, i-&gt;cloud, cluster_transformed.cloud);
+        _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;min_point, in_header.frame_id,
+                                            cluster_transformed.min_point);
+        _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;max_point, in_header.frame_id,
+                                            cluster_transformed.max_point);
+        _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;avg_point, in_header.frame_id,
+                                            cluster_transformed.avg_point);
+        _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;centroid_point, in_header.frame_id,
+                                            cluster_transformed.centroid_point);
+
+        cluster_transformed.dimensions = i-&gt;dimensions;
+        cluster_transformed.eigen_values = i-&gt;eigen_values;
+        cluster_transformed.eigen_vectors = i-&gt;eigen_vectors;
+
+        transformBoundingBox(i-&gt;bounding_box, cluster_transformed.bounding_box, in_target_frame, in_header);
+
+        clusters_transformed.clusters.push_back(cluster_transformed);
+      }
+      catch (tf::TransformException&amp; ex)
+      {
+        ROS_ERROR("publishCloudClusters: %s", ex.what());
+      }
     }
-
+    in_publisher-&gt;publish(clusters_transformed);
+    publishDetectedObjects(clusters_transformed);
+  }
+  else
+  {
+    in_publisher-&gt;publish(in_clusters);
+    publishDetectedObjects(in_clusters);
+  }
 }
 
-void publishCentroids(const ros::Publisher *in_publisher, const autoware_msgs::centroids &amp;in_centroids,
-                      const std::string &amp;in_target_frame, const std_msgs::Header &amp;in_header) {
-    if (in_target_frame != in_header.frame_id) {
-        autoware_msgs::centroids centroids_transformed;
-        centroids_transformed.header = in_header;
-        centroids_transformed.header.frame_id = in_target_frame;
-        for (auto i = centroids_transformed.points.begin(); i != centroids_transformed.points.end(); i++) {
-            geometry_msgs::PointStamped centroid_in, centroid_out;
-            centroid_in.header = in_header;
-            centroid_in.point = *i;
-            try {
-                _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), centroid_in, in_header.frame_id,
-                                                    centroid_out);
-
-                centroids_transformed.points.push_back(centroid_out.point);
-            }
-            catch (tf::TransformException &amp;ex) {
-                ROS_ERROR("publishCentroids: %s", ex.what());
-            }
-        }
-        in_publisher-&gt;publish(centroids_transformed);
-    } else {
-        in_publisher-&gt;publish(in_centroids);
+void publishCentroids(const ros::Publisher* in_publisher, const autoware_msgs::centroids&amp; in_centroids,
+                      const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
+{
+  if (in_target_frame != in_header.frame_id)
+  {
+    autoware_msgs::centroids centroids_transformed;
+    centroids_transformed.header = in_header;
+    centroids_transformed.header.frame_id = in_target_frame;
+    for (auto i = centroids_transformed.points.begin(); i != centroids_transformed.points.end(); i++)
+    {
+      geometry_msgs::PointStamped centroid_in, centroid_out;
+      centroid_in.header = in_header;
+      centroid_in.point = *i;
+      try
+      {
+        _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), centroid_in, in_header.frame_id,
+                                            centroid_out);
+
+        centroids_transformed.points.push_back(centroid_out.point);
+      }
+      catch (tf::TransformException&amp; ex)
+      {
+        ROS_ERROR("publishCentroids: %s", ex.what());
+      }
     }
+    in_publisher-&gt;publish(centroids_transformed);
+  }
+  else
+  {
+    in_publisher-&gt;publish(in_centroids);
+  }
 }
 
-void publishBoundingBoxArray(const ros::Publisher *in_publisher,
-                             const jsk_recognition_msgs::BoundingBoxArray &amp;in_boundingbox_array,
-                             const std::string &amp;in_target_frame, const std_msgs::Header &amp;in_header) {
-    if (in_target_frame != in_header.frame_id) {
-        jsk_recognition_msgs::BoundingBoxArray boundingboxes_transformed;
-        boundingboxes_transformed.header = in_header;
-        boundingboxes_transformed.header.frame_id = in_target_frame;
-        for (auto i = in_boundingbox_array.boxes.begin(); i != in_boundingbox_array.boxes.end(); i++) {
-            jsk_recognition_msgs::BoundingBox boundingbox_transformed;
-            transformBoundingBox(*i, boundingbox_transformed, in_target_frame, in_header);
-            boundingboxes_transformed.boxes.push_back(boundingbox_transformed);
-        }
-        in_publisher-&gt;publish(boundingboxes_transformed);
-    } else {
-        in_publisher-&gt;publish(in_boundingbox_array);
+void publishBoundingBoxArray(const ros::Publisher* in_publisher,
+                             const jsk_recognition_msgs::BoundingBoxArray&amp; in_boundingbox_array,
+                             const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
+{
+  if (in_target_frame != in_header.frame_id)
+  {
+    jsk_recognition_msgs::BoundingBoxArray boundingboxes_transformed;
+    boundingboxes_transformed.header = in_header;
+    boundingboxes_transformed.header.frame_id = in_target_frame;
+    for (auto i = in_boundingbox_array.boxes.begin(); i != in_boundingbox_array.boxes.end(); i++)
+    {
+      jsk_recognition_msgs::BoundingBox boundingbox_transformed;
+      transformBoundingBox(*i, boundingbox_transformed, in_target_frame, in_header);
+      boundingboxes_transformed.boxes.push_back(boundingbox_transformed);
     }
+    in_publisher-&gt;publish(boundingboxes_transformed);
+  }
+  else
+  {
+    in_publisher-&gt;publish(in_boundingbox_array);
+  }
 }
 
-void
-publishCloud(const ros::Publisher *in_publisher, const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_to_publish_ptr) {
-    sensor_msgs::PointCloud2 cloud_msg;
-    pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
-    cloud_msg.header = _velodyne_header;
-    in_publisher-&gt;publish(cloud_msg);
+void publishCloud(const ros::Publisher* in_publisher, const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_to_publish_ptr)
+{
+  sensor_msgs::PointCloud2 cloud_msg;
+  pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
+  cloud_msg.header = _velodyne_header;
+  in_publisher-&gt;publish(cloud_msg);
 }
 
-void publishColorCloud(const ros::Publisher *in_publisher,
-                       const pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr in_cloud_to_publish_ptr) {
-    sensor_msgs::PointCloud2 cloud_msg;
-    pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
-    cloud_msg.header = _velodyne_header;
-    in_publisher-&gt;publish(cloud_msg);
+void publishColorCloud(const ros::Publisher* in_publisher,
+                       const pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr in_cloud_to_publish_ptr)
+{
+  sensor_msgs::PointCloud2 cloud_msg;
+  pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
+  cloud_msg.header = _velodyne_header;
+  in_publisher-&gt;publish(cloud_msg);
 }
 
 void keepLanePoints(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
-                    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr,
-                    float in_left_lane_threshold = 1.5,
-                    float in_right_lane_threshold = 1.5) {
-    pcl::PointIndices::Ptr far_indices(new pcl::PointIndices);
-    for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++) {
-        pcl::PointXYZ current_point;
-        current_point.x = in_cloud_ptr-&gt;points[i].x;
-        current_point.y = in_cloud_ptr-&gt;points[i].y;
-        current_point.z = in_cloud_ptr-&gt;points[i].z;
-
-        if (
-                current_point.y &gt; (in_left_lane_threshold) || current_point.y &lt; -1.0 * in_right_lane_threshold
-                ) {
-            far_indices-&gt;indices.push_back(i);
-        }
+                    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, float in_left_lane_threshold = 1.5,
+                    float in_right_lane_threshold = 1.5)
+{
+  pcl::PointIndices::Ptr far_indices(new pcl::PointIndices);
+  for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++)
+  {
+    pcl::PointXYZ current_point;
+    current_point.x = in_cloud_ptr-&gt;points[i].x;
+    current_point.y = in_cloud_ptr-&gt;points[i].y;
+    current_point.z = in_cloud_ptr-&gt;points[i].z;
+
+    if (current_point.y &gt; (in_left_lane_threshold) || current_point.y &lt; -1.0 * in_right_lane_threshold)
+    {
+      far_indices-&gt;indices.push_back(i);
     }
-    out_cloud_ptr-&gt;points.clear();
-    pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
-    extract.setInputCloud(in_cloud_ptr);
-    extract.setIndices(far_indices);
-    extract.setNegative(true);//true removes the indices, false leaves only the indices
-    extract.filter(*out_cloud_ptr);
+  }
+  out_cloud_ptr-&gt;points.clear();
+  pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
+  extract.setInputCloud(in_cloud_ptr);
+  extract.setIndices(far_indices);
+  extract.setNegative(true);  // true removes the indices, false leaves only the indices
+  extract.filter(*out_cloud_ptr);
 }
 
 #ifdef GPU_CLUSTERING
 
 std::vector&lt;ClusterPtr&gt; clusterAndColorGpu(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
                                            pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
-                                           jsk_recognition_msgs::BoundingBoxArray &amp;in_out_boundingbox_array,
-                                           autoware_msgs::centroids &amp;in_out_centroids,
-                                           double in_max_cluster_distance = 0.5) {
-    std::vector&lt;ClusterPtr&gt; clusters;
+                                           jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
+                                           autoware_msgs::centroids&amp; in_out_centroids,
+                                           double in_max_cluster_distance = 0.5)
+{
+  std::vector&lt;ClusterPtr&gt; clusters;
 
-    //Convert input point cloud to vectors of x, y, and z
+  // Convert input point cloud to vectors of x, y, and z
 
-    int size = in_cloud_ptr-&gt;points.size();
+  int size = in_cloud_ptr-&gt;points.size();
 
-    if (size == 0)
-        return clusters;
+  if (size == 0)
+    return clusters;
 
-    float *tmp_x, *tmp_y, *tmp_z;
+  float *tmp_x, *tmp_y, *tmp_z;
 
-    tmp_x = (float *) malloc(sizeof(float) * size);
-    tmp_y = (float *) malloc(sizeof(float) * size);
-    tmp_z = (float *) malloc(sizeof(float) * size);
+  tmp_x = (float*)malloc(sizeof(float) * size);
+  tmp_y = (float*)malloc(sizeof(float) * size);
+  tmp_z = (float*)malloc(sizeof(float) * size);
 
-    for (int i = 0; i &lt; size; i++) {
-        pcl::PointXYZ tmp_point = in_cloud_ptr-&gt;at(i);
+  for (int i = 0; i &lt; size; i++)
+  {
+    pcl::PointXYZ tmp_point = in_cloud_ptr-&gt;at(i);
 
-        tmp_x[i] = tmp_point.x;
-        tmp_y[i] = tmp_point.y;
-        tmp_z[i] = tmp_point.z;
-    }
+    tmp_x[i] = tmp_point.x;
+    tmp_y[i] = tmp_point.y;
+    tmp_z[i] = tmp_point.z;
+  }
 
-    GpuEuclideanCluster gecl_cluster;
+  GpuEuclideanCluster gecl_cluster;
 
-    gecl_cluster.setInputPoints(tmp_x, tmp_y, tmp_z, size);
-    gecl_cluster.setThreshold(in_max_cluster_distance);
-    gecl_cluster.setMinClusterPts(_cluster_size_min);
-    gecl_cluster.setMaxClusterPts(_cluster_size_max);
-    gecl_cluster.extractClusters();
-    std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; cluster_indices = gecl_cluster.getOutput();
+  gecl_cluster.setInputPoints(tmp_x, tmp_y, tmp_z, size);
+  gecl_cluster.setThreshold(in_max_cluster_distance);
+  gecl_cluster.setMinClusterPts(_cluster_size_min);
+  gecl_cluster.setMaxClusterPts(_cluster_size_max);
+  gecl_cluster.extractClusters();
+  std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; cluster_indices = gecl_cluster.getOutput();
 
-    unsigned int k = 0;
+  unsigned int k = 0;
 
-    for (auto it = cluster_indices.begin(); it != cluster_indices.end(); it++) {
-        ClusterPtr cluster(new Cluster());
-        cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;points_in_cluster, _velodyne_header, k, (int) _colors[k].val[0],
-                          (int) _colors[k].val[1], (int) _colors[k].val[2], "", _pose_estimation);
-        clusters.push_back(cluster);
+  for (auto it = cluster_indices.begin(); it != cluster_indices.end(); it++)
+  {
+    ClusterPtr cluster(new Cluster());
+    cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;points_in_cluster, _velodyne_header, k, (int)_colors[k].val[0],
+                      (int)_colors[k].val[1], (int)_colors[k].val[2], "", _pose_estimation);
+    clusters.push_back(cluster);
 
-        k++;
-    }
+    k++;
+  }
 
-    free(tmp_x);
-    free(tmp_y);
-    free(tmp_z);
+  free(tmp_x);
+  free(tmp_y);
+  free(tmp_z);
 
-    return clusters;
+  return clusters;
 }
 
 #endif
 
 std::vector&lt;ClusterPtr&gt; clusterAndColor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
                                         pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
-                                        jsk_recognition_msgs::BoundingBoxArray &amp;in_out_boundingbox_array,
-                                        autoware_msgs::centroids &amp;in_out_centroids,
-                                        double in_max_cluster_distance = 0.5) {
-    pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;);
-
-    //create 2d pc
-    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_2d(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-    pcl::copyPointCloud(*in_cloud_ptr, *cloud_2d);
-    //make it flat
-    for (size_t i = 0; i &lt; cloud_2d-&gt;points.size(); i++) {
-        cloud_2d-&gt;points[i].z = 0;
-    }
-
-    if (cloud_2d-&gt;points.size() &gt; 0)
-        tree-&gt;setInputCloud(cloud_2d);
-
-    std::vector&lt;pcl::PointIndices&gt; cluster_indices;
-
-    //perform clustering on 2d cloud
-    pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;
-    ec.setClusterTolerance(in_max_cluster_distance); //
-    ec.setMinClusterSize(_cluster_size_min);
-    ec.setMaxClusterSize(_cluster_size_max);
-    ec.setSearchMethod(tree);
-    ec.setInputCloud(cloud_2d);
-    ec.extract(cluster_indices);
-    //use indices on 3d cloud
-
-    /*pcl::ConditionalEuclideanClustering&lt;pcl::PointXYZ&gt; cec (true);
-    cec.setInputCloud (in_cloud_ptr);
-    cec.setConditionFunction (&amp;independentDistance);
-    cec.setMinClusterSize (cluster_size_min);
-    cec.setMaxClusterSize (cluster_size_max);
-    cec.setClusterTolerance (_distance*2.0f);
-    cec.segment (cluster_indices);*/
-
-    /////////////////////////////////
-    //---	3. Color clustered points
-    /////////////////////////////////
-    unsigned int k = 0;
-    //pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr final_cluster (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
-
-    std::vector&lt;ClusterPtr&gt; clusters;
-    //pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud_cluster (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);//coord + color cluster
-    for (auto it = cluster_indices.begin(); it != cluster_indices.end(); ++it) {
-        ClusterPtr cluster(new Cluster());
-        cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int) _colors[k].val[0],
-                          (int) _colors[k].val[1], (int) _colors[k].val[2], "", _pose_estimation);
-        clusters.push_back(cluster);
-
-        k++;
-    }
-    //std::cout &lt;&lt; "Clusters: " &lt;&lt; k &lt;&lt; std::endl;
-    return clusters;
-
+                                        jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
+                                        autoware_msgs::centroids&amp; in_out_centroids,
+                                        double in_max_cluster_distance = 0.5)
+{
+  pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;);
+
+  // create 2d pc
+  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_2d(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+  pcl::copyPointCloud(*in_cloud_ptr, *cloud_2d);
+  // make it flat
+  for (size_t i = 0; i &lt; cloud_2d-&gt;points.size(); i++)
+  {
+    cloud_2d-&gt;points[i].z = 0;
+  }
+
+  if (cloud_2d-&gt;points.size() &gt; 0)
+    tree-&gt;setInputCloud(cloud_2d);
+
+  std::vector&lt;pcl::PointIndices&gt; cluster_indices;
+
+  // perform clustering on 2d cloud
+  pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;
+  ec.setClusterTolerance(in_max_cluster_distance);  //
+  ec.setMinClusterSize(_cluster_size_min);
+  ec.setMaxClusterSize(_cluster_size_max);
+  ec.setSearchMethod(tree);
+  ec.setInputCloud(cloud_2d);
+  ec.extract(cluster_indices);
+  // use indices on 3d cloud
+
+  /*pcl::ConditionalEuclideanClustering&lt;pcl::PointXYZ&gt; cec (true);
+  cec.setInputCloud (in_cloud_ptr);
+  cec.setConditionFunction (&amp;independentDistance);
+  cec.setMinClusterSize (cluster_size_min);
+  cec.setMaxClusterSize (cluster_size_max);
+  cec.setClusterTolerance (_distance*2.0f);
+  cec.segment (cluster_indices);*/
+
+  /////////////////////////////////
+  //---	3. Color clustered points
+  /////////////////////////////////
+  unsigned int k = 0;
+  // pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr final_cluster (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
+
+  std::vector&lt;ClusterPtr&gt; clusters;
+  // pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud_cluster (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);//coord + color
+  // cluster
+  for (auto it = cluster_indices.begin(); it != cluster_indices.end(); ++it)
+  {
+    ClusterPtr cluster(new Cluster());
+    cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1],
+                      (int)_colors[k].val[2], "", _pose_estimation);
+    clusters.push_back(cluster);
+
+    k++;
+  }
+  // std::cout &lt;&lt; "Clusters: " &lt;&lt; k &lt;&lt; std::endl;
+  return clusters;
 }
 
-void checkClusterMerge(size_t in_cluster_id, std::vector&lt;ClusterPtr&gt; &amp;in_clusters,
-                       std::vector&lt;bool&gt; &amp;in_out_visited_clusters, std::vector&lt;size_t&gt; &amp;out_merge_indices,
-                       double in_merge_threshold) {
-    //std::cout &lt;&lt; "checkClusterMerge" &lt;&lt; std::endl;
-    pcl::PointXYZ point_a = in_clusters[in_cluster_id]-&gt;GetCentroid();
-    for (size_t i = 0; i &lt; in_clusters.size(); i++) {
-        if (i != in_cluster_id &amp;&amp; !in_out_visited_clusters[i]) {
-            pcl::PointXYZ point_b = in_clusters[i]-&gt;GetCentroid();
-            double distance = sqrt(pow(point_b.x - point_a.x, 2) + pow(point_b.y - point_a.y, 2));
-            if (distance &lt;= in_merge_threshold) {
-                in_out_visited_clusters[i] = true;
-                out_merge_indices.push_back(i);
-                //std::cout &lt;&lt; "Merging " &lt;&lt; in_cluster_id &lt;&lt; " with " &lt;&lt; i &lt;&lt; " dist:" &lt;&lt; distance &lt;&lt; std::endl;
-                checkClusterMerge(i, in_clusters, in_out_visited_clusters, out_merge_indices, in_merge_threshold);
-            }
-        }
+void checkClusterMerge(size_t in_cluster_id, std::vector&lt;ClusterPtr&gt;&amp; in_clusters,
+                       std::vector&lt;bool&gt;&amp; in_out_visited_clusters, std::vector&lt;size_t&gt;&amp; out_merge_indices,
+                       double in_merge_threshold)
+{
+  // std::cout &lt;&lt; "checkClusterMerge" &lt;&lt; std::endl;
+  pcl::PointXYZ point_a = in_clusters[in_cluster_id]-&gt;GetCentroid();
+  for (size_t i = 0; i &lt; in_clusters.size(); i++)
+  {
+    if (i != in_cluster_id &amp;&amp; !in_out_visited_clusters[i])
+    {
+      pcl::PointXYZ point_b = in_clusters[i]-&gt;GetCentroid();
+      double distance = sqrt(pow(point_b.x - point_a.x, 2) + pow(point_b.y - point_a.y, 2));
+      if (distance &lt;= in_merge_threshold)
+      {
+        in_out_visited_clusters[i] = true;
+        out_merge_indices.push_back(i);
+        // std::cout &lt;&lt; "Merging " &lt;&lt; in_cluster_id &lt;&lt; " with " &lt;&lt; i &lt;&lt; " dist:" &lt;&lt; distance &lt;&lt; std::endl;
+        checkClusterMerge(i, in_clusters, in_out_visited_clusters, out_merge_indices, in_merge_threshold);
+      }
     }
+  }
 }
 
-void mergeClusters(const std::vector&lt;ClusterPtr&gt; &amp;in_clusters, std::vector&lt;ClusterPtr&gt; &amp;out_clusters,
-                   std::vector&lt;size_t&gt; in_merge_indices, const size_t &amp;current_index,
-                   std::vector&lt;bool&gt; &amp;in_out_merged_clusters) {
-    //std::cout &lt;&lt; "mergeClusters:" &lt;&lt; in_merge_indices.size() &lt;&lt; std::endl;
-    pcl::PointCloud&lt;pcl::PointXYZRGB&gt; sum_cloud;
-    pcl::PointCloud&lt;pcl::PointXYZ&gt; mono_cloud;
-    ClusterPtr merged_cluster(new Cluster());
-    for (size_t i = 0; i &lt; in_merge_indices.size(); i++) {
-        sum_cloud += *(in_clusters[in_merge_indices[i]]-&gt;GetCloud());
-        in_out_merged_clusters[in_merge_indices[i]] = true;
-    }
-    std::vector&lt;int&gt; indices(sum_cloud.points.size(), 0);
-    for (size_t i = 0; i &lt; sum_cloud.points.size(); i++) {
-        indices[i] = i;
-    }
-
-    if (sum_cloud.points.size() &gt; 0) {
-        pcl::copyPointCloud(sum_cloud, mono_cloud);
-        //std::cout &lt;&lt; "mergedClusters " &lt;&lt; sum_cloud.points.size() &lt;&lt; " mono:" &lt;&lt; mono_cloud.points.size() &lt;&lt; std::endl;
-        //cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1], (int)_colors[k].val[2], "", _pose_estimation);
-        merged_cluster-&gt;SetCloud(mono_cloud.makeShared(), indices, _velodyne_header, current_index,
-                                 (int) _colors[current_index].val[0], (int) _colors[current_index].val[1],
-                                 (int) _colors[current_index].val[2], "", _pose_estimation);
-        out_clusters.push_back(merged_cluster);
-    }
+void mergeClusters(const std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;ClusterPtr&gt;&amp; out_clusters,
+                   std::vector&lt;size_t&gt; in_merge_indices, const size_t&amp; current_index,
+                   std::vector&lt;bool&gt;&amp; in_out_merged_clusters)
+{
+  // std::cout &lt;&lt; "mergeClusters:" &lt;&lt; in_merge_indices.size() &lt;&lt; std::endl;
+  pcl::PointCloud&lt;pcl::PointXYZRGB&gt; sum_cloud;
+  pcl::PointCloud&lt;pcl::PointXYZ&gt; mono_cloud;
+  ClusterPtr merged_cluster(new Cluster());
+  for (size_t i = 0; i &lt; in_merge_indices.size(); i++)
+  {
+    sum_cloud += *(in_clusters[in_merge_indices[i]]-&gt;GetCloud());
+    in_out_merged_clusters[in_merge_indices[i]] = true;
+  }
+  std::vector&lt;int&gt; indices(sum_cloud.points.size(), 0);
+  for (size_t i = 0; i &lt; sum_cloud.points.size(); i++)
+  {
+    indices[i] = i;
+  }
+
+  if (sum_cloud.points.size() &gt; 0)
+  {
+    pcl::copyPointCloud(sum_cloud, mono_cloud);
+    // std::cout &lt;&lt; "mergedClusters " &lt;&lt; sum_cloud.points.size() &lt;&lt; " mono:" &lt;&lt; mono_cloud.points.size() &lt;&lt; std::endl;
+    // cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1],
+    // (int)_colors[k].val[2], "", _pose_estimation);
+    merged_cluster-&gt;SetCloud(mono_cloud.makeShared(), indices, _velodyne_header, current_index,
+                             (int)_colors[current_index].val[0], (int)_colors[current_index].val[1],
+                             (int)_colors[current_index].val[2], "", _pose_estimation);
+    out_clusters.push_back(merged_cluster);
+  }
 }
 
-void checkAllForMerge(std::vector&lt;ClusterPtr&gt; &amp;in_clusters, std::vector&lt;ClusterPtr&gt; &amp;out_clusters,
-                      float in_merge_threshold) {
-    //std::cout &lt;&lt; "checkAllForMerge" &lt;&lt; std::endl;
-    std::vector&lt;bool&gt; visited_clusters(in_clusters.size(), false);
-    std::vector&lt;bool&gt; merged_clusters(in_clusters.size(), false);
-    size_t current_index = 0;
-    for (size_t i = 0; i &lt; in_clusters.size(); i++) {
-        if (!visited_clusters[i]) {
-            visited_clusters[i] = true;
-            std::vector&lt;size_t&gt; merge_indices;
-            checkClusterMerge(i, in_clusters, visited_clusters, merge_indices, in_merge_threshold);
-            mergeClusters(in_clusters, out_clusters, merge_indices, current_index++, merged_clusters);
-        }
+void checkAllForMerge(std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;ClusterPtr&gt;&amp; out_clusters,
+                      float in_merge_threshold)
+{
+  // std::cout &lt;&lt; "checkAllForMerge" &lt;&lt; std::endl;
+  std::vector&lt;bool&gt; visited_clusters(in_clusters.size(), false);
+  std::vector&lt;bool&gt; merged_clusters(in_clusters.size(), false);
+  size_t current_index = 0;
+  for (size_t i = 0; i &lt; in_clusters.size(); i++)
+  {
+    if (!visited_clusters[i])
+    {
+      visited_clusters[i] = true;
+      std::vector&lt;size_t&gt; merge_indices;
+      checkClusterMerge(i, in_clusters, visited_clusters, merge_indices, in_merge_threshold);
+      mergeClusters(in_clusters, out_clusters, merge_indices, current_index++, merged_clusters);
     }
-    for (size_t i = 0; i &lt; in_clusters.size(); i++) {
-        //check for clusters not merged, add them to the output
-        if (!merged_clusters[i]) {
-            out_clusters.push_back(in_clusters[i]);
-        }
+  }
+  for (size_t i = 0; i &lt; in_clusters.size(); i++)
+  {
+    // check for clusters not merged, add them to the output
+    if (!merged_clusters[i])
+    {
+      out_clusters.push_back(in_clusters[i]);
     }
+  }
 
-    //ClusterPtr cluster(new Cluster());
+  // ClusterPtr cluster(new Cluster());
 }
 
 void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
                        pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
-                       jsk_recognition_msgs::BoundingBoxArray &amp;in_out_boundingbox_array,
-                       autoware_msgs::centroids &amp;in_out_centroids,
-                       autoware_msgs::CloudClusterArray &amp;in_out_clusters,
-                       jsk_recognition_msgs::PolygonArray &amp;in_out_polygon_array,
-                       jsk_rviz_plugins::PictogramArray &amp;in_out_pictogram_array) {
-    //cluster the pointcloud according to the distance of the points using different thresholds (not only one for the entire pc)
-    //in this way, the points farther in the pc will also be clustered
-
-    //0 =&gt; 0-15m d=0.5
-    //1 =&gt; 15-30 d=1
-    //2 =&gt; 30-45 d=1.6
-    //3 =&gt; 45-60 d=2.1
-    //4 =&gt; &gt;60   d=2.6
-
-    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-
-    for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++) {
-        pcl::PointXYZ current_point;
-        current_point.x = in_cloud_ptr-&gt;points[i].x;
-        current_point.y = in_cloud_ptr-&gt;points[i].y;
-        current_point.z = in_cloud_ptr-&gt;points[i].z;
-
-        cloud_ptr-&gt;points.push_back(current_point);
-    }
+                       jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
+                       autoware_msgs::centroids&amp; in_out_centroids, autoware_msgs::CloudClusterArray&amp; in_out_clusters,
+                       jsk_recognition_msgs::PolygonArray&amp; in_out_polygon_array,
+                       jsk_rviz_plugins::PictogramArray&amp; in_out_pictogram_array)
+{
+  // cluster the pointcloud according to the distance of the points using different thresholds (not only one for the
+  // entire pc)
+  // in this way, the points farther in the pc will also be clustered
 
-    #ifdef GPU_CLUSTERING
-    std::vector&lt;ClusterPtr&gt; all_clusters;
-     if (_use_gpu) {
-             all_clusters = clusterAndColorGpu(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
+  // 0 =&gt; 0-15m d=0.5
+  // 1 =&gt; 15-30 d=1
+  // 2 =&gt; 30-45 d=1.6
+  // 3 =&gt; 45-60 d=2.1
+  // 4 =&gt; &gt;60   d=2.6
 
-     } else {
-             all_clusters = clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
-     }
-#else
-        std::vector&lt;ClusterPtr&gt; all_clusters = clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
-#endif
+  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
 
+  for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++)
+  {
+    pcl::PointXYZ current_point;
+    current_point.x = in_cloud_ptr-&gt;points[i].x;
+    current_point.y = in_cloud_ptr-&gt;points[i].y;
+    current_point.z = in_cloud_ptr-&gt;points[i].z;
 
-    //Clusters can be merged or checked in here
-    //....
-    //check for mergable clusters
-    std::vector&lt;ClusterPtr&gt; mid_clusters;
-    std::vector&lt;ClusterPtr&gt; final_clusters;
+    cloud_ptr-&gt;points.push_back(current_point);
+  }
 
-    if (all_clusters.size() &gt; 0)
-        checkAllForMerge(all_clusters, mid_clusters, _cluster_merge_threshold);
-    else
-        mid_clusters = all_clusters;
+#ifdef GPU_CLUSTERING
+  std::vector&lt;ClusterPtr&gt; all_clusters;
+  if (_use_gpu)
+  {
+    all_clusters =
+        clusterAndColorGpu(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
+  }
+  else
+  {
+    all_clusters =
+        clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
+  }
+#else
+  std::vector&lt;ClusterPtr&gt; all_clusters =
+      clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
+#endif
 
-    if (mid_clusters.size() &gt; 0)
-        checkAllForMerge(mid_clusters, final_clusters, _cluster_merge_threshold);
-    else
-        final_clusters = mid_clusters;
-
-    tf::StampedTransform vectormap_transform;
-    if (_use_vector_map) {
-        if (_wayarea_gridmap.exists(_gridmap_layer)) {
-            //check if centroids are inside the drivable area
-            cv::Mat grid_image;
-            grid_map::GridMapCvConverter::toImage&lt;unsigned char, 1&gt;(_wayarea_gridmap,
-                                                                    _gridmap_layer,
-                                                                    CV_8UC1,
-                                                                    _grid_min_value,
-                                                                    _grid_max_value,
-                                                                    grid_image);
+  // Clusters can be merged or checked in here
+  //....
+  // check for mergable clusters
+  std::vector&lt;ClusterPtr&gt; mid_clusters;
+  std::vector&lt;ClusterPtr&gt; final_clusters;
+
+  if (all_clusters.size() &gt; 0)
+    checkAllForMerge(all_clusters, mid_clusters, _cluster_merge_threshold);
+  else
+    mid_clusters = all_clusters;
+
+  if (mid_clusters.size() &gt; 0)
+    checkAllForMerge(mid_clusters, final_clusters, _cluster_merge_threshold);
+  else
+    final_clusters = mid_clusters;
+
+  tf::StampedTransform vectormap_transform;
+  if (_use_vector_map)
+  {
+    if (_wayarea_gridmap.exists(_gridmap_layer))
+    {
+      // check if centroids are inside the drivable area
+      cv::Mat grid_image;
+      grid_map::GridMapCvConverter::toImage&lt;unsigned char, 1&gt;(_wayarea_gridmap, _gridmap_layer, CV_8UC1,
+                                                              _grid_min_value, _grid_max_value, grid_image);
 
 #pragma omp for
-            for (unsigned int i = 0; i &lt; final_clusters.size(); i++) {
-                pcl::PointXYZ pcl_centroid = final_clusters[i]-&gt;GetCentroid();
-
-                geometry_msgs::Point original_centroid_point, final_centroid_point;
-                original_centroid_point.x = pcl_centroid.x;
-                original_centroid_point.y = pcl_centroid.y;
-                original_centroid_point.z = pcl_centroid.z;
-
-                if (_wayarea_gridmap.getFrameId() != _velodyne_header.frame_id) {
-                    tf::StampedTransform grid_sensor_tf = findTransform(_wayarea_gridmap.getFrameId(),
-                                                                        _velodyne_header.frame_id);
-                    final_centroid_point = transformPoint(original_centroid_point, grid_sensor_tf);
-                } else {
-                    final_centroid_point = original_centroid_point;
-                }
-
-                bool point_in_grid = checkPointInGrid(_wayarea_gridmap, grid_image, final_centroid_point);
-                final_clusters[i]-&gt;SetValidity(point_in_grid);
-            }
-            //timer.stop();
-            //std::cout &lt;&lt; "vectormap filtering took " &lt;&lt; timer.getTimeMilli() &lt;&lt; " ms to check " &lt;&lt; final_clusters.size() &lt;&lt; std::endl;
-        } else {
-            ROS_INFO("%s layer not contained in the OccupancyGrid", _gridmap_layer.c_str());
+      for (unsigned int i = 0; i &lt; final_clusters.size(); i++)
+      {
+        pcl::PointXYZ pcl_centroid = final_clusters[i]-&gt;GetCentroid();
+
+        geometry_msgs::Point original_centroid_point, final_centroid_point;
+        original_centroid_point.x = pcl_centroid.x;
+        original_centroid_point.y = pcl_centroid.y;
+        original_centroid_point.z = pcl_centroid.z;
+
+        if (_wayarea_gridmap.getFrameId() != _velodyne_header.frame_id)
+        {
+          tf::StampedTransform grid_sensor_tf = findTransform(_wayarea_gridmap.getFrameId(), _velodyne_header.frame_id);
+          final_centroid_point = transformPoint(original_centroid_point, grid_sensor_tf);
+        }
+        else
+        {
+          final_centroid_point = original_centroid_point;
         }
 
+        bool point_in_grid = checkPointInGrid(_wayarea_gridmap, grid_image, final_centroid_point);
+        final_clusters[i]-&gt;SetValidity(point_in_grid);
+      }
+      // timer.stop();
+      // std::cout &lt;&lt; "vectormap filtering took " &lt;&lt; timer.getTimeMilli() &lt;&lt; " ms to check " &lt;&lt; final_clusters.size() &lt;&lt;
+      // std::endl;
     }
-    //Get final PointCloud to be published
-    in_out_polygon_array.header = _velodyne_header;
-    in_out_pictogram_array.header = _velodyne_header;
-    for (unsigned int i = 0; i &lt; final_clusters.size(); i++) {
-        *out_cloud_ptr = *out_cloud_ptr + *(final_clusters[i]-&gt;GetCloud());
-
-        jsk_recognition_msgs::BoundingBox bounding_box = final_clusters[i]-&gt;GetBoundingBox();
-        geometry_msgs::PolygonStamped polygon = final_clusters[i]-&gt;GetPolygon();
-        jsk_rviz_plugins::Pictogram pictogram_cluster;
-        pictogram_cluster.header = _velodyne_header;
-
-        //PICTO
-        pictogram_cluster.mode = pictogram_cluster.STRING_MODE;
-        pictogram_cluster.pose.position.x = final_clusters[i]-&gt;GetMaxPoint().x;
-        pictogram_cluster.pose.position.y = final_clusters[i]-&gt;GetMaxPoint().y;
-        pictogram_cluster.pose.position.z = final_clusters[i]-&gt;GetMaxPoint().z;
-        tf::Quaternion quat(0.0, -0.7, 0.0, 0.7);
-        tf::quaternionTFToMsg(quat, pictogram_cluster.pose.orientation);
-        pictogram_cluster.size = 4;
-        std_msgs::ColorRGBA color;
-        color.a = 1;
-        color.r = 1;
-        color.g = 1;
-        color.b = 1;
-        pictogram_cluster.color = color;
-        pictogram_cluster.character = std::to_string(i);
-        //PICTO
-
-        //pcl::PointXYZ min_point = final_clusters[i]-&gt;GetMinPoint();
-        //pcl::PointXYZ max_point = final_clusters[i]-&gt;GetMaxPoint();
-        pcl::PointXYZ center_point = final_clusters[i]-&gt;GetCentroid();
-        geometry_msgs::Point centroid;
-        centroid.x = center_point.x;
-        centroid.y = center_point.y;
-        centroid.z = center_point.z;
-        bounding_box.header = _velodyne_header;
-        polygon.header = _velodyne_header;
-
-        if (final_clusters[i]-&gt;IsValid()
-            //&amp;&amp; bounding_box.dimensions.x &gt;0 &amp;&amp; bounding_box.dimensions.y &gt;0 &amp;&amp; bounding_box.dimensions.z &gt; 0
-            //&amp;&amp;	bounding_box.dimensions.x &lt; _max_boundingbox_side &amp;&amp; bounding_box.dimensions.y &lt; _max_boundingbox_side
-                ) {
-            in_out_boundingbox_array.boxes.push_back(bounding_box);
-            in_out_centroids.points.push_back(centroid);
-            _visualization_marker.points.push_back(centroid);
-
-            in_out_polygon_array.polygons.push_back(polygon);
-            in_out_pictogram_array.pictograms.push_back(pictogram_cluster);
-
-            autoware_msgs::CloudCluster cloud_cluster;
-            final_clusters[i]-&gt;ToRosMessage(_velodyne_header, cloud_cluster);
-            in_out_clusters.clusters.push_back(cloud_cluster);
-        }
+    else
+    {
+      ROS_INFO("%s layer not contained in the OccupancyGrid", _gridmap_layer.c_str());
     }
+  }
+  // Get final PointCloud to be published
+  in_out_polygon_array.header = _velodyne_header;
+  in_out_pictogram_array.header = _velodyne_header;
+  for (unsigned int i = 0; i &lt; final_clusters.size(); i++)
+  {
+    *out_cloud_ptr = *out_cloud_ptr + *(final_clusters[i]-&gt;GetCloud());
+
+    jsk_recognition_msgs::BoundingBox bounding_box = final_clusters[i]-&gt;GetBoundingBox();
+    geometry_msgs::PolygonStamped polygon = final_clusters[i]-&gt;GetPolygon();
+    jsk_rviz_plugins::Pictogram pictogram_cluster;
+    pictogram_cluster.header = _velodyne_header;
+
+    // PICTO
+    pictogram_cluster.mode = pictogram_cluster.STRING_MODE;
+    pictogram_cluster.pose.position.x = final_clusters[i]-&gt;GetMaxPoint().x;
+    pictogram_cluster.pose.position.y = final_clusters[i]-&gt;GetMaxPoint().y;
+    pictogram_cluster.pose.position.z = final_clusters[i]-&gt;GetMaxPoint().z;
+    tf::Quaternion quat(0.0, -0.7, 0.0, 0.7);
+    tf::quaternionTFToMsg(quat, pictogram_cluster.pose.orientation);
+    pictogram_cluster.size = 4;
+    std_msgs::ColorRGBA color;
+    color.a = 1;
+    color.r = 1;
+    color.g = 1;
+    color.b = 1;
+    pictogram_cluster.color = color;
+    pictogram_cluster.character = std::to_string(i);
+    // PICTO
+
+    // pcl::PointXYZ min_point = final_clusters[i]-&gt;GetMinPoint();
+    // pcl::PointXYZ max_point = final_clusters[i]-&gt;GetMaxPoint();
+    pcl::PointXYZ center_point = final_clusters[i]-&gt;GetCentroid();
+    geometry_msgs::Point centroid;
+    centroid.x = center_point.x;
+    centroid.y = center_point.y;
+    centroid.z = center_point.z;
+    bounding_box.header = _velodyne_header;
+    polygon.header = _velodyne_header;
+
+    if (final_clusters[i]-&gt;IsValid()
+        //&amp;&amp; bounding_box.dimensions.x &gt;0 &amp;&amp; bounding_box.dimensions.y &gt;0 &amp;&amp; bounding_box.dimensions.z &gt; 0
+        //&amp;&amp;	bounding_box.dimensions.x &lt; _max_boundingbox_side &amp;&amp; bounding_box.dimensions.y &lt; _max_boundingbox_side
+        )
+    {
+      in_out_boundingbox_array.boxes.push_back(bounding_box);
+      in_out_centroids.points.push_back(centroid);
+      _visualization_marker.points.push_back(centroid);
 
-    for (size_t i = 0; i &lt; in_out_polygon_array.polygons.size(); i++) {
-        in_out_polygon_array.labels.push_back(i);
+      in_out_polygon_array.polygons.push_back(polygon);
+      in_out_pictogram_array.pictograms.push_back(pictogram_cluster);
+
+      autoware_msgs::CloudCluster cloud_cluster;
+      final_clusters[i]-&gt;ToRosMessage(_velodyne_header, cloud_cluster);
+      in_out_clusters.clusters.push_back(cloud_cluster);
     }
+  }
 
+  for (size_t i = 0; i &lt; in_out_polygon_array.polygons.size(); i++)
+  {
+    in_out_polygon_array.labels.push_back(i);
+  }
 }
 
 void removeFloor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
                  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_nofloor_cloud_ptr,
                  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_onlyfloor_cloud_ptr, float in_max_height = 0.2,
-                 float in_floor_max_angle = 0.1) {
-    /*pcl::PointIndicesPtr ground (new pcl::PointIndices);
-    // Create the filtering object
-    pcl::ProgressiveMorphologicalFilter&lt;pcl::PointXYZ&gt; pmf;
-    pmf.setInputCloud (in_cloud_ptr);
-    pmf.setMaxWindowSize (20);
-    pmf.setSlope (1.0f);
-    pmf.setInitialDistance (0.5f);
-    pmf.setMaxDistance (3.0f);
-    pmf.extract (ground-&gt;indices);
-
-    // Create the filtering object
-    pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
-    extract.setInputCloud (in_cloud_ptr);
-    extract.setIndices (ground);
-    extract.setNegative(true);//true removes the indices, false leaves only the indices
-    extract.filter(*out_nofloor_cloud_ptr);
-
-    //EXTRACT THE FLOOR FROM THE CLOUD
-    extract.setNegative(false);//true removes the indices, false leaves only the indices
-    extract.filter(*out_onlyfloor_cloud_ptr);*/
-
-    pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;
-    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
-    pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);
-
-    seg.setOptimizeCoefficients(true);
-    seg.setModelType(pcl::SACMODEL_PERPENDICULAR_PLANE);
-    seg.setMethodType(pcl::SAC_RANSAC);
-    seg.setMaxIterations(100);
-    seg.setAxis(Eigen::Vector3f(0, 0, 1));
-    seg.setEpsAngle(in_floor_max_angle);
-
-    seg.setDistanceThreshold(in_max_height);//floor distance
-    seg.setOptimizeCoefficients(true);
-    seg.setInputCloud(in_cloud_ptr);
-    seg.segment(*inliers, *coefficients);
-    if (inliers-&gt;indices.size() == 0) {
-        std::cout &lt;&lt; "Could not estimate a planar model for the given dataset." &lt;&lt; std::endl;
-    }
-
-    //REMOVE THE FLOOR FROM THE CLOUD
-    pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
-    extract.setInputCloud(in_cloud_ptr);
-    extract.setIndices(inliers);
-    extract.setNegative(true);//true removes the indices, false leaves only the indices
-    extract.filter(*out_nofloor_cloud_ptr);
-
-    //EXTRACT THE FLOOR FROM THE CLOUD
-    extract.setNegative(false);//true removes the indices, false leaves only the indices
-    extract.filter(*out_onlyfloor_cloud_ptr);
+                 float in_floor_max_angle = 0.1)
+{
+  /*pcl::PointIndicesPtr ground (new pcl::PointIndices);
+  // Create the filtering object
+  pcl::ProgressiveMorphologicalFilter&lt;pcl::PointXYZ&gt; pmf;
+  pmf.setInputCloud (in_cloud_ptr);
+  pmf.setMaxWindowSize (20);
+  pmf.setSlope (1.0f);
+  pmf.setInitialDistance (0.5f);
+  pmf.setMaxDistance (3.0f);
+  pmf.extract (ground-&gt;indices);
+
+  // Create the filtering object
+  pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
+  extract.setInputCloud (in_cloud_ptr);
+  extract.setIndices (ground);
+  extract.setNegative(true);//true removes the indices, false leaves only the indices
+  extract.filter(*out_nofloor_cloud_ptr);
+
+  //EXTRACT THE FLOOR FROM THE CLOUD
+  extract.setNegative(false);//true removes the indices, false leaves only the indices
+  extract.filter(*out_onlyfloor_cloud_ptr);*/
+
+  pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;
+  pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
+  pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);
+
+  seg.setOptimizeCoefficients(true);
+  seg.setModelType(pcl::SACMODEL_PERPENDICULAR_PLANE);
+  seg.setMethodType(pcl::SAC_RANSAC);
+  seg.setMaxIterations(100);
+  seg.setAxis(Eigen::Vector3f(0, 0, 1));
+  seg.setEpsAngle(in_floor_max_angle);
+
+  seg.setDistanceThreshold(in_max_height);  // floor distance
+  seg.setOptimizeCoefficients(true);
+  seg.setInputCloud(in_cloud_ptr);
+  seg.segment(*inliers, *coefficients);
+  if (inliers-&gt;indices.size() == 0)
+  {
+    std::cout &lt;&lt; "Could not estimate a planar model for the given dataset." &lt;&lt; std::endl;
+  }
+
+  // REMOVE THE FLOOR FROM THE CLOUD
+  pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
+  extract.setInputCloud(in_cloud_ptr);
+  extract.setIndices(inliers);
+  extract.setNegative(true);  // true removes the indices, false leaves only the indices
+  extract.filter(*out_nofloor_cloud_ptr);
+
+  // EXTRACT THE FLOOR FROM THE CLOUD
+  extract.setNegative(false);  // true removes the indices, false leaves only the indices
+  extract.filter(*out_onlyfloor_cloud_ptr);
 }
 
 void downsampleCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
-                     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, float in_leaf_size = 0.2) {
-    pcl::VoxelGrid&lt;pcl::PointXYZ&gt; sor;
-    sor.setInputCloud(in_cloud_ptr);
-    sor.setLeafSize((float) in_leaf_size, (float) in_leaf_size, (float) in_leaf_size);
-    sor.filter(*out_cloud_ptr);
+                     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, float in_leaf_size = 0.2)
+{
+  pcl::VoxelGrid&lt;pcl::PointXYZ&gt; sor;
+  sor.setInputCloud(in_cloud_ptr);
+  sor.setLeafSize((float)in_leaf_size, (float)in_leaf_size, (float)in_leaf_size);
+  sor.filter(*out_cloud_ptr);
 }
 
-void
-clipCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr,
-          float in_min_height = -1.3, float in_max_height = 0.5) {
-    out_cloud_ptr-&gt;points.clear();
-    for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++) {
-        if (in_cloud_ptr-&gt;points[i].z &gt;= in_min_height &amp;&amp;
-            in_cloud_ptr-&gt;points[i].z &lt;= in_max_height) {
-            out_cloud_ptr-&gt;points.push_back(in_cloud_ptr-&gt;points[i]);
-        }
+void clipCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
+               pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, float in_min_height = -1.3, float in_max_height = 0.5)
+{
+  out_cloud_ptr-&gt;points.clear();
+  for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++)
+  {
+    if (in_cloud_ptr-&gt;points[i].z &gt;= in_min_height &amp;&amp; in_cloud_ptr-&gt;points[i].z &lt;= in_max_height)
+    {
+      out_cloud_ptr-&gt;points.push_back(in_cloud_ptr-&gt;points[i]);
     }
+  }
 }
 
 void differenceNormalsSegmentation(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
-                                   pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr) {
-    float small_scale = 0.5;
-    float large_scale = 2.0;
-    float angle_threshold = 0.5;
-    pcl::search::Search&lt;pcl::PointXYZ&gt;::Ptr tree;
-    if (in_cloud_ptr-&gt;isOrganized()) {
-        tree.reset(new pcl::search::OrganizedNeighbor&lt;pcl::PointXYZ&gt;());
-    } else {
-        tree.reset(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;(false));
-    }
-
-    // Set the input pointcloud for the search tree
-    tree-&gt;setInputCloud(in_cloud_ptr);
-
-    pcl::NormalEstimationOMP&lt;pcl::PointXYZ, pcl::PointNormal&gt; normal_estimation;
-    //pcl::gpu::NormalEstimation&lt;pcl::PointXYZ, pcl::PointNormal&gt; normal_estimation;
-    normal_estimation.setInputCloud(in_cloud_ptr);
-    normal_estimation.setSearchMethod(tree);
-
-    normal_estimation.setViewPoint(std::numeric_limits&lt;float&gt;::max(), std::numeric_limits&lt;float&gt;::max(),
-                                   std::numeric_limits&lt;float&gt;::max());
-
-    pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr normals_small_scale(new pcl::PointCloud&lt;pcl::PointNormal&gt;);
-    pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr normals_large_scale(new pcl::PointCloud&lt;pcl::PointNormal&gt;);
-
-    normal_estimation.setRadiusSearch(small_scale);
-    normal_estimation.compute(*normals_small_scale);
-
-    normal_estimation.setRadiusSearch(large_scale);
-    normal_estimation.compute(*normals_large_scale);
-
-    pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr diffnormals_cloud(new pcl::PointCloud&lt;pcl::PointNormal&gt;);
-    pcl::copyPointCloud&lt;pcl::PointXYZ, pcl::PointNormal&gt;(*in_cloud_ptr, *diffnormals_cloud);
-
-    // Create DoN operator
-    pcl::DifferenceOfNormalsEstimation&lt;pcl::PointXYZ, pcl::PointNormal, pcl::PointNormal&gt; diffnormals_estimator;
-    diffnormals_estimator.setInputCloud(in_cloud_ptr);
-    diffnormals_estimator.setNormalScaleLarge(normals_large_scale);
-    diffnormals_estimator.setNormalScaleSmall(normals_small_scale);
-
-    diffnormals_estimator.initCompute();
-
-    diffnormals_estimator.computeFeature(*diffnormals_cloud);
-
-    pcl::ConditionOr&lt;pcl::PointNormal&gt;::Ptr range_cond(new pcl::ConditionOr&lt;pcl::PointNormal&gt;());
-    range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointNormal&gt;::ConstPtr(
-            new pcl::FieldComparison&lt;pcl::PointNormal&gt;("curvature", pcl::ComparisonOps::GT, angle_threshold))
-    );
-    // Build the filter
-    pcl::ConditionalRemoval&lt;pcl::PointNormal&gt; cond_removal;
-    cond_removal.setCondition(range_cond);
-    cond_removal.setInputCloud(diffnormals_cloud);
-
-    pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr diffnormals_cloud_filtered(new pcl::PointCloud&lt;pcl::PointNormal&gt;);
-
-    // Apply filter
-    cond_removal.filter(*diffnormals_cloud_filtered);
-
-    pcl::copyPointCloud&lt;pcl::PointNormal, pcl::PointXYZ&gt;(*diffnormals_cloud, *out_cloud_ptr);
+                                   pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr)
+{
+  float small_scale = 0.5;
+  float large_scale = 2.0;
+  float angle_threshold = 0.5;
+  pcl::search::Search&lt;pcl::PointXYZ&gt;::Ptr tree;
+  if (in_cloud_ptr-&gt;isOrganized())
+  {
+    tree.reset(new pcl::search::OrganizedNeighbor&lt;pcl::PointXYZ&gt;());
+  }
+  else
+  {
+    tree.reset(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;(false));
+  }
+
+  // Set the input pointcloud for the search tree
+  tree-&gt;setInputCloud(in_cloud_ptr);
+
+  pcl::NormalEstimationOMP&lt;pcl::PointXYZ, pcl::PointNormal&gt; normal_estimation;
+  // pcl::gpu::NormalEstimation&lt;pcl::PointXYZ, pcl::PointNormal&gt; normal_estimation;
+  normal_estimation.setInputCloud(in_cloud_ptr);
+  normal_estimation.setSearchMethod(tree);
+
+  normal_estimation.setViewPoint(std::numeric_limits&lt;float&gt;::max(), std::numeric_limits&lt;float&gt;::max(),
+                                 std::numeric_limits&lt;float&gt;::max());
+
+  pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr normals_small_scale(new pcl::PointCloud&lt;pcl::PointNormal&gt;);
+  pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr normals_large_scale(new pcl::PointCloud&lt;pcl::PointNormal&gt;);
+
+  normal_estimation.setRadiusSearch(small_scale);
+  normal_estimation.compute(*normals_small_scale);
+
+  normal_estimation.setRadiusSearch(large_scale);
+  normal_estimation.compute(*normals_large_scale);
+
+  pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr diffnormals_cloud(new pcl::PointCloud&lt;pcl::PointNormal&gt;);
+  pcl::copyPointCloud&lt;pcl::PointXYZ, pcl::PointNormal&gt;(*in_cloud_ptr, *diffnormals_cloud);
+
+  // Create DoN operator
+  pcl::DifferenceOfNormalsEstimation&lt;pcl::PointXYZ, pcl::PointNormal, pcl::PointNormal&gt; diffnormals_estimator;
+  diffnormals_estimator.setInputCloud(in_cloud_ptr);
+  diffnormals_estimator.setNormalScaleLarge(normals_large_scale);
+  diffnormals_estimator.setNormalScaleSmall(normals_small_scale);
+
+  diffnormals_estimator.initCompute();
+
+  diffnormals_estimator.computeFeature(*diffnormals_cloud);
+
+  pcl::ConditionOr&lt;pcl::PointNormal&gt;::Ptr range_cond(new pcl::ConditionOr&lt;pcl::PointNormal&gt;());
+  range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointNormal&gt;::ConstPtr(
+      new pcl::FieldComparison&lt;pcl::PointNormal&gt;("curvature", pcl::ComparisonOps::GT, angle_threshold)));
+  // Build the filter
+  pcl::ConditionalRemoval&lt;pcl::PointNormal&gt; cond_removal;
+  cond_removal.setCondition(range_cond);
+  cond_removal.setInputCloud(diffnormals_cloud);
+
+  pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr diffnormals_cloud_filtered(new pcl::PointCloud&lt;pcl::PointNormal&gt;);
+
+  // Apply filter
+  cond_removal.filter(*diffnormals_cloud_filtered);
+
+  pcl::copyPointCloud&lt;pcl::PointNormal, pcl::PointXYZ&gt;(*diffnormals_cloud, *out_cloud_ptr);
 }
 
 void removePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
-                      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, const double in_distance) {
-    out_cloud_ptr-&gt;points.clear();
-    for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++) {
-        float origin_distance = sqrt(pow(in_cloud_ptr-&gt;points[i].x, 2) + pow(in_cloud_ptr-&gt;points[i].y, 2));
-        if (origin_distance &gt; in_distance) {
-            out_cloud_ptr-&gt;points.push_back(in_cloud_ptr-&gt;points[i]);
-        }
+                      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, const double in_distance)
+{
+  out_cloud_ptr-&gt;points.clear();
+  for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++)
+  {
+    float origin_distance = sqrt(pow(in_cloud_ptr-&gt;points[i].x, 2) + pow(in_cloud_ptr-&gt;points[i].y, 2));
+    if (origin_distance &gt; in_distance)
+    {
+      out_cloud_ptr-&gt;points.push_back(in_cloud_ptr-&gt;points[i]);
     }
+  }
 }
 
-void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr &amp;in_sensor_cloud) {
-    //_start = std::chrono::system_clock::now();
+void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
+{
+  //_start = std::chrono::system_clock::now();
 
-    if (!_using_sensor_cloud) {
-        _using_sensor_cloud = true;
+  if (!_using_sensor_cloud)
+  {
+    _using_sensor_cloud = true;
 
-        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr current_sensor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr removed_points_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr downsampled_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr inlanes_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr nofloor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr onlyfloor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr diffnormals_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr clipped_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-        pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr colored_clustered_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
+    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr current_sensor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr removed_points_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr downsampled_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr inlanes_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr nofloor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr onlyfloor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr diffnormals_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr clipped_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+    pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr colored_clustered_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
 
-        autoware_msgs::centroids centroids;
-        autoware_msgs::CloudClusterArray cloud_clusters;
-        jsk_recognition_msgs::BoundingBoxArray boundingbox_array;
-        jsk_recognition_msgs::PolygonArray polygon_array;
-        jsk_rviz_plugins::PictogramArray pictograms_array;
+    autoware_msgs::centroids centroids;
+    autoware_msgs::CloudClusterArray cloud_clusters;
+    jsk_recognition_msgs::BoundingBoxArray boundingbox_array;
+    jsk_recognition_msgs::PolygonArray polygon_array;
+    jsk_rviz_plugins::PictogramArray pictograms_array;
 
-        pcl::fromROSMsg(*in_sensor_cloud, *current_sensor_cloud_ptr);
+    pcl::fromROSMsg(*in_sensor_cloud, *current_sensor_cloud_ptr);
 
-        _velodyne_header = in_sensor_cloud-&gt;header;
+    _velodyne_header = in_sensor_cloud-&gt;header;
 
-        if (_remove_points_upto &gt; 0.0) {
-            removePointsUpTo(current_sensor_cloud_ptr, removed_points_cloud_ptr, _remove_points_upto);
-        } else
-            removed_points_cloud_ptr = current_sensor_cloud_ptr;
+    if (_remove_points_upto &gt; 0.0)
+    {
+      removePointsUpTo(current_sensor_cloud_ptr, removed_points_cloud_ptr, _remove_points_upto);
+    }
+    else
+      removed_points_cloud_ptr = current_sensor_cloud_ptr;
 
-        if (_downsample_cloud)
-            downsampleCloud(removed_points_cloud_ptr, downsampled_cloud_ptr, _leaf_size);
-        else
-            downsampled_cloud_ptr = removed_points_cloud_ptr;
+    if (_downsample_cloud)
+      downsampleCloud(removed_points_cloud_ptr, downsampled_cloud_ptr, _leaf_size);
+    else
+      downsampled_cloud_ptr = removed_points_cloud_ptr;
 
-        clipCloud(downsampled_cloud_ptr, clipped_cloud_ptr, _clip_min_height, _clip_max_height);
+    clipCloud(downsampled_cloud_ptr, clipped_cloud_ptr, _clip_min_height, _clip_max_height);
 
-        if (_keep_lanes)
-            keepLanePoints(clipped_cloud_ptr, inlanes_cloud_ptr, _keep_lane_left_distance, _keep_lane_right_distance);
-        else
-            inlanes_cloud_ptr = clipped_cloud_ptr;
+    if (_keep_lanes)
+      keepLanePoints(clipped_cloud_ptr, inlanes_cloud_ptr, _keep_lane_left_distance, _keep_lane_right_distance);
+    else
+      inlanes_cloud_ptr = clipped_cloud_ptr;
 
-        if (_remove_ground) {
-            removeFloor(inlanes_cloud_ptr, nofloor_cloud_ptr, onlyfloor_cloud_ptr);
-            publishCloud(&amp;_pub_ground_cloud, onlyfloor_cloud_ptr);
-        } else
-            nofloor_cloud_ptr = inlanes_cloud_ptr;
+    if (_remove_ground)
+    {
+      removeFloor(inlanes_cloud_ptr, nofloor_cloud_ptr, onlyfloor_cloud_ptr);
+      publishCloud(&amp;_pub_ground_cloud, onlyfloor_cloud_ptr);
+    }
+    else
+      nofloor_cloud_ptr = inlanes_cloud_ptr;
 
-        publishCloud(&amp;_pub_points_lanes_cloud, nofloor_cloud_ptr);
+    publishCloud(&amp;_pub_points_lanes_cloud, nofloor_cloud_ptr);
 
-        if (_use_diffnormals)
-            differenceNormalsSegmentation(nofloor_cloud_ptr, diffnormals_cloud_ptr);
-        else
-            diffnormals_cloud_ptr = nofloor_cloud_ptr;
+    if (_use_diffnormals)
+      differenceNormalsSegmentation(nofloor_cloud_ptr, diffnormals_cloud_ptr);
+    else
+      diffnormals_cloud_ptr = nofloor_cloud_ptr;
 
-        segmentByDistance(diffnormals_cloud_ptr, colored_clustered_cloud_ptr, boundingbox_array, centroids,
-                          cloud_clusters, polygon_array, pictograms_array);
+    segmentByDistance(diffnormals_cloud_ptr, colored_clustered_cloud_ptr, boundingbox_array, centroids, cloud_clusters,
+                      polygon_array, pictograms_array);
 
-        publishColorCloud(&amp;_pub_cluster_cloud, colored_clustered_cloud_ptr);
+    publishColorCloud(&amp;_pub_cluster_cloud, colored_clustered_cloud_ptr);
 
-        // Publish BB
-        boundingbox_array.header = _velodyne_header;
+    // Publish BB
+    boundingbox_array.header = _velodyne_header;
 
-        _pub_jsk_hulls.publish(polygon_array);//publish convex hulls
-        _pub_text_pictogram.publish(pictograms_array);//publish_ids
+    _pub_jsk_hulls.publish(polygon_array);          // publish convex hulls
+    _pub_text_pictogram.publish(pictograms_array);  // publish_ids
 
-        publishBoundingBoxArray(&amp;_pub_jsk_boundingboxes, boundingbox_array, _output_frame, _velodyne_header);
-        centroids.header = _velodyne_header;
+    publishBoundingBoxArray(&amp;_pub_jsk_boundingboxes, boundingbox_array, _output_frame, _velodyne_header);
+    centroids.header = _velodyne_header;
 
-        publishCentroids(&amp;_centroid_pub, centroids, _output_frame, _velodyne_header);
+    publishCentroids(&amp;_centroid_pub, centroids, _output_frame, _velodyne_header);
 
-        _marker_pub.publish(_visualization_marker);
-        _visualization_marker.points.clear();//transform? is it used?
-        cloud_clusters.header = _velodyne_header;
+    _marker_pub.publish(_visualization_marker);
+    _visualization_marker.points.clear();  // transform? is it used?
+    cloud_clusters.header = _velodyne_header;
 
-        publishCloudClusters(&amp;_pub_clusters_message, cloud_clusters, _output_frame, _velodyne_header);
+    publishCloudClusters(&amp;_pub_clusters_message, cloud_clusters, _output_frame, _velodyne_header);
 
-        _using_sensor_cloud = false;
-    }
-    //_end = std::chrono::system_clock::now();
-    //double elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(_end-_start).count();
-    //ROS_INFO("Euclidean Clustering : %f", elapsed);
+    _using_sensor_cloud = false;
+  }
+  //_end = std::chrono::system_clock::now();
+  // double elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(_end-_start).count();
+  // ROS_INFO("Euclidean Clustering : %f", elapsed);
 }
 
 /*
 void vectormap_callback(const visualization_msgs::MarkerArray::Ptr in_vectormap_markers)
 {
-	float min_x=std::numeric_limits&lt;float&gt;::max();float max_x=-std::numeric_limits&lt;float&gt;::max();
-	float min_y=std::numeric_limits&lt;float&gt;::max();float max_y=-std::numeric_limits&lt;float&gt;::max();
-	pcl::PointXYZ min_point;
-	pcl::PointXYZ max_point;
-	std::vector&lt;geometry_msgs::Point&gt; vectormap_points;
-	std::string marker_frame;
-	double map_scale = -10.0;
-	for(auto i=in_vectormap_markers-&gt;markers.begin(); i!= in_vectormap_markers-&gt;markers.end(); i++)
-	{
-		visualization_msgs::Marker current_marker = *i;
-		marker_frame = current_marker.header.frame_id;
-		if (current_marker.ns == "road_edge")
-		{
-			for (unsigned int j=0; j&lt; current_marker.points.size(); j++)
-			{
-				geometry_msgs::Point p = current_marker.points[j];
-				p.x*=map_scale;
-				p.y*=map_scale;
-				if(p.x&lt;min_x)	min_x = p.x;
-				if(p.y&lt;min_y)	min_y = p.y;
-				if(p.x&gt;max_x)	max_x = p.x;
-				if(p.y&gt;max_y)	max_y = p.y;
-				vectormap_points.push_back(p);
-			}
-		}
-	}
-	min_point.x = min_x;	min_point.y = min_y;
-	max_point.x = max_x;	max_point.y = max_y;
-
-	min_point.x*=-1.0;
-	min_point.y*=-1.0;
-	//translate the points to the minimum point
-	for (auto i=vectormap_points.begin(); i!=vectormap_points.end(); i++)
-	{
-		(*i).x+=min_point.x;
-		(*i).y+=min_point.y;
-	}
-	max_point.x+=min_point.x;
-	max_point.y+=min_point.y;
-	//get world tf
-	std::string error_transform_msg;
-	tf::Vector3 map_origin_point;
-	if(_transform_listener-&gt;waitForTransform("/map", marker_frame, ros::Time(0), ros::Duration(5), ros::Duration(0.1), &amp;error_transform_msg))
-	{
-		_transform_listener-&gt;lookupTransform("/map", marker_frame, ros::Time(0), *_transform);
-		map_origin_point = _transform-&gt;getOrigin();
-		map_origin_point.setX( map_origin_point.x() - min_point.x);
-		map_origin_point.setY( map_origin_point.y() - min_point.y);
-	}
-	else
-	{
-		ROS_INFO("Euclidean Cluster (vectormap_callback): %s", error_transform_msg.c_str());
-	}
-
-	cv::Mat map_image = cv::Mat::zeros(max_point.y, max_point.x, CV_8UC3);
-
-	std::cout &lt;&lt; "W,H:" &lt;&lt; max_point &lt;&lt; std::endl;
-
-	cv::Point image_start_point (vectormap_points[0].x, vectormap_points[0].y);
-	cv::Point prev_point = image_start_point;
-	for (auto i=vectormap_points.begin(); i!=vectormap_points.end(); i++)
-	{
-		cv::line(map_image, prev_point, cv::Point((int)(i-&gt;x), (int)(i-&gt;y)), cv::Scalar::all(255));
-
-		prev_point.x = (int)(i-&gt;x);
-		prev_point.y = (int)(i-&gt;y);
-	}
-	cv::circle(map_image, image_start_point, 3, cv::Scalar(255,0,0));
-	cv::imshow("vectormap", map_image);
-	cv::waitKey(0);
+  float min_x=std::numeric_limits&lt;float&gt;::max();float max_x=-std::numeric_limits&lt;float&gt;::max();
+  float min_y=std::numeric_limits&lt;float&gt;::max();float max_y=-std::numeric_limits&lt;float&gt;::max();
+  pcl::PointXYZ min_point;
+  pcl::PointXYZ max_point;
+  std::vector&lt;geometry_msgs::Point&gt; vectormap_points;
+  std::string marker_frame;
+  double map_scale = -10.0;
+  for(auto i=in_vectormap_markers-&gt;markers.begin(); i!= in_vectormap_markers-&gt;markers.end(); i++)
+  {
+    visualization_msgs::Marker current_marker = *i;
+    marker_frame = current_marker.header.frame_id;
+    if (current_marker.ns == "road_edge")
+    {
+      for (unsigned int j=0; j&lt; current_marker.points.size(); j++)
+      {
+        geometry_msgs::Point p = current_marker.points[j];
+        p.x*=map_scale;
+        p.y*=map_scale;
+        if(p.x&lt;min_x)	min_x = p.x;
+        if(p.y&lt;min_y)	min_y = p.y;
+        if(p.x&gt;max_x)	max_x = p.x;
+        if(p.y&gt;max_y)	max_y = p.y;
+        vectormap_points.push_back(p);
+      }
+    }
+  }
+  min_point.x = min_x;	min_point.y = min_y;
+  max_point.x = max_x;	max_point.y = max_y;
+
+  min_point.x*=-1.0;
+  min_point.y*=-1.0;
+  //translate the points to the minimum point
+  for (auto i=vectormap_points.begin(); i!=vectormap_points.end(); i++)
+  {
+    (*i).x+=min_point.x;
+    (*i).y+=min_point.y;
+  }
+  max_point.x+=min_point.x;
+  max_point.y+=min_point.y;
+  //get world tf
+  std::string error_transform_msg;
+  tf::Vector3 map_origin_point;
+  if(_transform_listener-&gt;waitForTransform("/map", marker_frame, ros::Time(0), ros::Duration(5), ros::Duration(0.1),
+&amp;error_transform_msg))
+  {
+    _transform_listener-&gt;lookupTransform("/map", marker_frame, ros::Time(0), *_transform);
+    map_origin_point = _transform-&gt;getOrigin();
+    map_origin_point.setX( map_origin_point.x() - min_point.x);
+    map_origin_point.setY( map_origin_point.y() - min_point.y);
+  }
+  else
+  {
+    ROS_INFO("Euclidean Cluster (vectormap_callback): %s", error_transform_msg.c_str());
+  }
+
+  cv::Mat map_image = cv::Mat::zeros(max_point.y, max_point.x, CV_8UC3);
+
+  std::cout &lt;&lt; "W,H:" &lt;&lt; max_point &lt;&lt; std::endl;
+
+  cv::Point image_start_point (vectormap_points[0].x, vectormap_points[0].y);
+  cv::Point prev_point = image_start_point;
+  for (auto i=vectormap_points.begin(); i!=vectormap_points.end(); i++)
+  {
+    cv::line(map_image, prev_point, cv::Point((int)(i-&gt;x), (int)(i-&gt;y)), cv::Scalar::all(255));
+
+    prev_point.x = (int)(i-&gt;x);
+    prev_point.y = (int)(i-&gt;y);
+  }
+  cv::circle(map_image, image_start_point, 3, cv::Scalar(255,0,0));
+  cv::imshow("vectormap", map_image);
+  cv::waitKey(0);
 }*/
 
-void wayarea_gridmap_callback(const grid_map_msgs::GridMap &amp;message) {
-    grid_map::GridMapRosConverter::fromMessage(message, _wayarea_gridmap);
+void wayarea_gridmap_callback(const grid_map_msgs::GridMap&amp; message)
+{
+  grid_map::GridMapRosConverter::fromMessage(message, _wayarea_gridmap);
 }
 
-int main(int argc, char **argv) {
-    // Initialize ROS
-    ros::init(argc, argv, "euclidean_cluster");
+int main(int argc, char** argv)
+{
+  // Initialize ROS
+  ros::init(argc, argv, "euclidean_cluster");
 
-    ros::NodeHandle h;
-    ros::NodeHandle private_nh("~");
+  ros::NodeHandle h;
+  ros::NodeHandle private_nh("~");
 
-    tf::StampedTransform transform;
-    tf::TransformListener listener;
-    tf::TransformListener vectormap_tf_listener;
+  tf::StampedTransform transform;
+  tf::TransformListener listener;
+  tf::TransformListener vectormap_tf_listener;
 
-    _vectormap_transform_listener = &amp;vectormap_tf_listener;
-    _transform = &amp;transform;
-    _transform_listener = &amp;listener;
+  _vectormap_transform_listener = &amp;vectormap_tf_listener;
+  _transform = &amp;transform;
+  _transform_listener = &amp;listener;
 
 #if (CV_MAJOR_VERSION == 3)
-    generateColors(_colors, 255);
+  generateColors(_colors, 255);
 #else
-    cv::generateColors(_colors, 255);
+  cv::generateColors(_colors, 255);
 #endif
 
-    _pub_cluster_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_cluster", 1);
-    _pub_ground_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_ground", 1);
-    _centroid_pub = h.advertise&lt;autoware_msgs::centroids&gt;("/cluster_centroids", 1);
-    _marker_pub = h.advertise&lt;visualization_msgs::Marker&gt;("centroid_marker", 1);
-
-    _pub_points_lanes_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_lanes", 1);
-    _pub_jsk_boundingboxes = h.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/bounding_boxes", 1);
-    _pub_jsk_hulls = h.advertise&lt;jsk_recognition_msgs::PolygonArray&gt;("/cluster_hulls", 1);
-    _pub_clusters_message = h.advertise&lt;autoware_msgs::CloudClusterArray&gt;("/cloud_clusters", 1);
-    _pub_detected_objects = h.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/lidar_objects", 1);
-    _pub_text_pictogram = h.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;("cluster_ids", 10);
-    ROS_INFO("output pictograms topic: %s", "cluster_id");
-
-    _pub_grid_map = h.advertise&lt;grid_map_msgs::GridMap&gt;("grid_map_wayarea", 1, true);
-
-    std::string points_topic, gridmap_topic;
-
-    _using_sensor_cloud = false;
-
-    if (private_nh.getParam("points_node", points_topic)) {
-        ROS_INFO("euclidean_cluster &gt; Setting points node to %s", points_topic.c_str());
-    } else {
-        ROS_INFO(
-                "euclidean_cluster &gt; No points node received, defaulting to points_raw, you can use _points_node:=YOUR_TOPIC");
-        points_topic = "/points_raw";
-    }
-
-    _use_diffnormals = false;
-    if (private_nh.getParam("use_diffnormals", _use_diffnormals)) {
-        if (_use_diffnormals)
-            ROS_INFO("Euclidean Clustering: Applying difference of normals on clustering pipeline");
-        else
-            ROS_INFO("Euclidean Clustering: Difference of Normals will not be used.");
-    }
-
-    /* Initialize tuning parameter */
-    private_nh.param("downsample_cloud", _downsample_cloud, false);
-    ROS_INFO("downsample_cloud: %d", _downsample_cloud);
-    private_nh.param("remove_ground", _remove_ground, true);
-    ROS_INFO("remove_ground: %d", _remove_ground);
-    private_nh.param("leaf_size", _leaf_size, 0.1);
-    ROS_INFO("leaf_size: %f", _leaf_size);
-    private_nh.param("cluster_size_min", _cluster_size_min, 20);
-    ROS_INFO("cluster_size_min %d", _cluster_size_min);
-    private_nh.param("cluster_size_max", _cluster_size_max, 100000);
-    ROS_INFO("cluster_size_max: %d", _cluster_size_max);
-    private_nh.param("pose_estimation", _pose_estimation, false);
-    ROS_INFO("pose_estimation: %d", _pose_estimation);
-    private_nh.param("clip_min_height", _clip_min_height, -1.3);
-    ROS_INFO("clip_min_height: %f", _clip_min_height);
-    private_nh.param("clip_max_height", _clip_max_height, 0.5);
-    ROS_INFO("clip_max_height: %f", _clip_max_height);
-    private_nh.param("keep_lanes", _keep_lanes, false);
-    ROS_INFO("keep_lanes: %d", _keep_lanes);
-    private_nh.param("keep_lane_left_distance", _keep_lane_left_distance, 5.0);
-    ROS_INFO("keep_lane_left_distance: %f", _keep_lane_left_distance);
-    private_nh.param("keep_lane_right_distance", _keep_lane_right_distance, 5.0);
-    ROS_INFO("keep_lane_right_distance: %f", _keep_lane_right_distance);
-    private_nh.param("max_boundingbox_side", _max_boundingbox_side, 10.0);
-    ROS_INFO("max_boundingbox_side: %f", _max_boundingbox_side);
-    private_nh.param("cluster_merge_threshold", _cluster_merge_threshold, 1.5);
-    ROS_INFO("cluster_merge_threshold: %f", _cluster_merge_threshold);
-    private_nh.param&lt;std::string&gt;("output_frame", _output_frame, "velodyne");
-    ROS_INFO("output_frame: %s", _output_frame.c_str());
-
-    private_nh.param("use_vector_map", _use_vector_map, false);
-    ROS_INFO("use_vector_map: %d", _use_vector_map);
-    private_nh.param&lt;std::string&gt;("vectormap_frame", _vectormap_frame, "map");
-    ROS_INFO("vectormap_frame: %s", _vectormap_frame.c_str());
-
-    private_nh.param("remove_points_upto", _remove_points_upto, 0.0);
-    ROS_INFO("remove_points_upto: %f", _remove_points_upto);
-
-    private_nh.param("segment_distance", _segment_distance, 0.75);
-    ROS_INFO("segment_distance: %f", _segment_distance);
-
-    private_nh.param("use_gpu", _use_gpu, false);
-    ROS_INFO("use_gpu: %d", _use_gpu);
-
-    _velodyne_transform_available = false;
-
-    // Create a ROS subscriber for the input point cloud
-    ros::Subscriber sub = h.subscribe(points_topic, 1, velodyne_callback);
-
-    private_nh.param&lt;std::string&gt;("wayarea_gridmap_topic", gridmap_topic, "grid_map_wayarea");
-    ROS_INFO("wayarea_gridmap_topic: %s", gridmap_topic.c_str());
-    private_nh.param&lt;std::string&gt;("wayarea_gridmap_layer", _gridmap_layer, "wayarea");
-    ROS_INFO("wayarea_gridmap_layer: %s", _gridmap_layer.c_str());
-    private_nh.param&lt;int&gt;("wayarea_no_road_value", _gridmap_no_road_value, _grid_max_value);
-    ROS_INFO("wayarea_no_road_value: %ds", _gridmap_no_road_value);
-    ros::Subscriber wayarea_sub = h.subscribe(gridmap_topic, 1, wayarea_gridmap_callback);
-
-
-    _visualization_marker.header.frame_id = "velodyne";
-    _visualization_marker.header.stamp = ros::Time();
-    _visualization_marker.ns = "my_namespace";
-    _visualization_marker.id = 0;
-    _visualization_marker.type = visualization_msgs::Marker::SPHERE_LIST;
-    _visualization_marker.action = visualization_msgs::Marker::ADD;
-    _visualization_marker.scale.x = 1.0;
-    _visualization_marker.scale.y = 1.0;
-    _visualization_marker.scale.z = 1.0;
-    _visualization_marker.color.a = 1.0;
-    _visualization_marker.color.r = 0.0;
-    _visualization_marker.color.g = 0.0;
-    _visualization_marker.color.b = 1.0;
-    // marker.lifetime = ros::Duration(0.1);
-    _visualization_marker.frame_locked = true;
-
-    // Spin
-    ros::spin();
+  _pub_cluster_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_cluster", 1);
+  _pub_ground_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_ground", 1);
+  _centroid_pub = h.advertise&lt;autoware_msgs::centroids&gt;("/cluster_centroids", 1);
+  _marker_pub = h.advertise&lt;visualization_msgs::Marker&gt;("centroid_marker", 1);
+
+  _pub_points_lanes_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_lanes", 1);
+  _pub_jsk_boundingboxes = h.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/bounding_boxes", 1);
+  _pub_jsk_hulls = h.advertise&lt;jsk_recognition_msgs::PolygonArray&gt;("/cluster_hulls", 1);
+  _pub_clusters_message = h.advertise&lt;autoware_msgs::CloudClusterArray&gt;("/cloud_clusters", 1);
+  _pub_detected_objects = h.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/lidar_objects", 1);
+  _pub_text_pictogram = h.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;("cluster_ids", 10);
+  ROS_INFO("output pictograms topic: %s", "cluster_id");
+
+  _pub_grid_map = h.advertise&lt;grid_map_msgs::GridMap&gt;("grid_map_wayarea", 1, true);
+
+  std::string points_topic, gridmap_topic;
+
+  _using_sensor_cloud = false;
+
+  if (private_nh.getParam("points_node", points_topic))
+  {
+    ROS_INFO("euclidean_cluster &gt; Setting points node to %s", points_topic.c_str());
+  }
+  else
+  {
+    ROS_INFO("euclidean_cluster &gt; No points node received, defaulting to points_raw, you can use "
+             "_points_node:=YOUR_TOPIC");
+    points_topic = "/points_raw";
+  }
+
+  _use_diffnormals = false;
+  if (private_nh.getParam("use_diffnormals", _use_diffnormals))
+  {
+    if (_use_diffnormals)
+      ROS_INFO("Euclidean Clustering: Applying difference of normals on clustering pipeline");
+    else
+      ROS_INFO("Euclidean Clustering: Difference of Normals will not be used.");
+  }
+
+  /* Initialize tuning parameter */
+  private_nh.param("downsample_cloud", _downsample_cloud, false);
+  ROS_INFO("downsample_cloud: %d", _downsample_cloud);
+  private_nh.param("remove_ground", _remove_ground, true);
+  ROS_INFO("remove_ground: %d", _remove_ground);
+  private_nh.param("leaf_size", _leaf_size, 0.1);
+  ROS_INFO("leaf_size: %f", _leaf_size);
+  private_nh.param("cluster_size_min", _cluster_size_min, 20);
+  ROS_INFO("cluster_size_min %d", _cluster_size_min);
+  private_nh.param("cluster_size_max", _cluster_size_max, 100000);
+  ROS_INFO("cluster_size_max: %d", _cluster_size_max);
+  private_nh.param("pose_estimation", _pose_estimation, false);
+  ROS_INFO("pose_estimation: %d", _pose_estimation);
+  private_nh.param("clip_min_height", _clip_min_height, -1.3);
+  ROS_INFO("clip_min_height: %f", _clip_min_height);
+  private_nh.param("clip_max_height", _clip_max_height, 0.5);
+  ROS_INFO("clip_max_height: %f", _clip_max_height);
+  private_nh.param("keep_lanes", _keep_lanes, false);
+  ROS_INFO("keep_lanes: %d", _keep_lanes);
+  private_nh.param("keep_lane_left_distance", _keep_lane_left_distance, 5.0);
+  ROS_INFO("keep_lane_left_distance: %f", _keep_lane_left_distance);
+  private_nh.param("keep_lane_right_distance", _keep_lane_right_distance, 5.0);
+  ROS_INFO("keep_lane_right_distance: %f", _keep_lane_right_distance);
+  private_nh.param("max_boundingbox_side", _max_boundingbox_side, 10.0);
+  ROS_INFO("max_boundingbox_side: %f", _max_boundingbox_side);
+  private_nh.param("cluster_merge_threshold", _cluster_merge_threshold, 1.5);
+  ROS_INFO("cluster_merge_threshold: %f", _cluster_merge_threshold);
+  private_nh.param&lt;std::string&gt;("output_frame", _output_frame, "velodyne");
+  ROS_INFO("output_frame: %s", _output_frame.c_str());
+
+  private_nh.param("use_vector_map", _use_vector_map, false);
+  ROS_INFO("use_vector_map: %d", _use_vector_map);
+  private_nh.param&lt;std::string&gt;("vectormap_frame", _vectormap_frame, "map");
+  ROS_INFO("vectormap_frame: %s", _vectormap_frame.c_str());
+
+  private_nh.param("remove_points_upto", _remove_points_upto, 0.0);
+  ROS_INFO("remove_points_upto: %f", _remove_points_upto);
+
+  private_nh.param("segment_distance", _segment_distance, 0.75);
+  ROS_INFO("segment_distance: %f", _segment_distance);
+
+  private_nh.param("use_gpu", _use_gpu, false);
+  ROS_INFO("use_gpu: %d", _use_gpu);
+
+  _velodyne_transform_available = false;
+
+  // Create a ROS subscriber for the input point cloud
+  ros::Subscriber sub = h.subscribe(points_topic, 1, velodyne_callback);
+
+  private_nh.param&lt;std::string&gt;("wayarea_gridmap_topic", gridmap_topic, "grid_map_wayarea");
+  ROS_INFO("wayarea_gridmap_topic: %s", gridmap_topic.c_str());
+  private_nh.param&lt;std::string&gt;("wayarea_gridmap_layer", _gridmap_layer, "wayarea");
+  ROS_INFO("wayarea_gridmap_layer: %s", _gridmap_layer.c_str());
+  private_nh.param&lt;int&gt;("wayarea_no_road_value", _gridmap_no_road_value, _grid_max_value);
+  ROS_INFO("wayarea_no_road_value: %ds", _gridmap_no_road_value);
+  ros::Subscriber wayarea_sub = h.subscribe(gridmap_topic, 1, wayarea_gridmap_callback);
+
+  _visualization_marker.header.frame_id = "velodyne";
+  _visualization_marker.header.stamp = ros::Time();
+  _visualization_marker.ns = "my_namespace";
+  _visualization_marker.id = 0;
+  _visualization_marker.type = visualization_msgs::Marker::SPHERE_LIST;
+  _visualization_marker.action = visualization_msgs::Marker::ADD;
+  _visualization_marker.scale.x = 1.0;
+  _visualization_marker.scale.y = 1.0;
+  _visualization_marker.scale.z = 1.0;
+  _visualization_marker.color.a = 1.0;
+  _visualization_marker.color.r = 0.0;
+  _visualization_marker.color.g = 0.0;
+  _visualization_marker.color.b = 1.0;
+  // marker.lifetime = ros::Duration(0.1);
+  _visualization_marker.frame_locked = true;
+
+  // Spin
+  ros::spin();
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cc7b0a86abbc01fcaf22a2d855ba53045e8c728a" author="Akihito Ohsato">
		<msg>Fix some comments and arguments</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\include\lidar_fake_perception.h" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\include\lidar_fake_perception.h" added_lines="2" deleted_lines="3">
				<diff>@@ -60,7 +60,7 @@ private:
   double object_length_;    // length [m]
   double object_width_;     // width [m]
   double object_height_;    // height [m]
-  double object_z_offset_;  // offset from global frame [m]
+  double object_z_offset_;  // z offset from global frame [m]
 
   // param, object motion
   bool use_fake_twist_;             // using subscribed twist
@@ -69,8 +69,7 @@ private:
 
   // param, object meta-info
   double object_intensity_;  // constant intensity value of fake points, 0-255 [-]
-  double object_lifetime_;   // object meta-info, fake object lifetime (NOTE: when this is negative value, lifetime is
-                             // inifinity) [s]
+  double object_lifetime_;   // fake object lifetime (NOTE: when this is negative value, lifetime is inifinity) [s]
   double object_points_space_;  // fake points space [m]
   std::string object_label_;    // fake object label (e.g. tracking state)
   std::string object_frame_;    // fake object frame_id (NOTE: not affected to input object)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="beb18419c4160c5ee0b883fd0aeb73234875138f" author="Kosuke Murakami">
		<msg>Add optional multiple threshold euclidean clustert</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="117" deleted_lines="18">
				<diff>@@ -152,6 +152,10 @@ std::vector&lt;cv::Scalar&gt; _colors;
 pcl::PointCloud&lt;pcl::PointXYZ&gt; _sensor_cloud;
 visualization_msgs::Marker _visualization_marker;
 
+static bool _use_multiple_thres;
+std::vector&lt;double&gt; _clustering_thresholds;
+std::vector&lt;double&gt; _clustering_distances;
+
 tf::StampedTransform* _transform;
 tf::StampedTransform* _velodyne_output_transform;
 tf::TransformListener* _transform_listener;
@@ -635,34 +639,92 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
   // 3 =&gt; 45-60 d=2.1
   // 4 =&gt; &gt;60   d=2.6
 
-  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+  std::vector&lt;ClusterPtr&gt; all_clusters;
 
-  for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++)
+  if(!_use_multiple_thres)
   {
-    pcl::PointXYZ current_point;
-    current_point.x = in_cloud_ptr-&gt;points[i].x;
-    current_point.y = in_cloud_ptr-&gt;points[i].y;
-    current_point.z = in_cloud_ptr-&gt;points[i].z;
+    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
 
-    cloud_ptr-&gt;points.push_back(current_point);
-  }
+    for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++)
+    {
+      pcl::PointXYZ current_point;
+      current_point.x = in_cloud_ptr-&gt;points[i].x;
+      current_point.y = in_cloud_ptr-&gt;points[i].y;
+      current_point.z = in_cloud_ptr-&gt;points[i].z;
 
+      cloud_ptr-&gt;points.push_back(current_point);
+    }
 #ifdef GPU_CLUSTERING
-  std::vector&lt;ClusterPtr&gt; all_clusters;
-  if (_use_gpu)
-  {
-    all_clusters =
-        clusterAndColorGpu(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
+    if (_use_gpu)
+    {
+      all_clusters =
+          clusterAndColorGpu(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
+    }
+    else
+    {
+      all_clusters =
+          clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
+    }
+#else
+    std::vector&lt;ClusterPtr&gt; all_clusters =
+        clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
+#endif
   }
   else
   {
-    all_clusters =
-        clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
-  }
+    std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr&gt; cloud_segments_array(5);
+    for (unsigned int i = 0; i &lt; cloud_segments_array.size(); i++)
+    {
+      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr tmp_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+      cloud_segments_array[i] = tmp_cloud;
+    }
+
+    for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++) {
+      pcl::PointXYZ current_point;
+      current_point.x = in_cloud_ptr-&gt;points[i].x;
+      current_point.y = in_cloud_ptr-&gt;points[i].y;
+      current_point.z = in_cloud_ptr-&gt;points[i].z;
+
+      float origin_distance = sqrt(pow(current_point.x, 2) + pow(current_point.y, 2));
+
+      if (origin_distance &lt; _clustering_distances[0])
+      {
+        cloud_segments_array[0]-&gt;points.push_back(current_point);
+      }
+      else if (origin_distance &lt; _clustering_distances[1])
+      {
+        cloud_segments_array[1]-&gt;points.push_back(current_point);
+      }
+      else if (origin_distance &lt; _clustering_distances[2])
+      {
+        cloud_segments_array[2]-&gt;points.push_back(current_point);
+      }
+      else if (origin_distance &lt; _clustering_distances[3])
+      {
+        cloud_segments_array[3]-&gt;points.push_back(current_point);
+      }
+      else
+      {
+        cloud_segments_array[4]-&gt;points.push_back(current_point);
+      }
+    }
+
+    for (unsigned int i = 0; i &lt; cloud_segments_array.size(); i++) {
+#ifdef GPU_CLUSTERING
+        std::vector&lt;ClusterPtr&gt; local_clusters;
+        if (_use_gpu) {
+            local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
+                                                in_out_centroids, _clustering_thresholds[i]);
+        } else {
+            local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
+                                             in_out_centroids, _clustering_thresholds[i]);
+        }
 #else
-  std::vector&lt;ClusterPtr&gt; all_clusters =
-      clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
+        std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
 #endif
+        all_clusters.insert(all_clusters.end(), local_clusters.begin(), local_clusters.end());
+    }
+  }
 
   // Clusters can be merged or checked in here
   //....
@@ -1221,6 +1283,43 @@ int main(int argc, char** argv)
   private_nh.param("use_gpu", _use_gpu, false);
   ROS_INFO("use_gpu: %d", _use_gpu);
 
+  double first_euclid_thres;
+  double second_euclid_thres;
+  double third_euclid_thres;
+  double fourth_euclid_thres;
+  double fifth_euclid_thres;
+
+  double first_segment_range;
+  double second_segment_range;
+  double third_segment_range;
+  double fourth_segment_range;
+
+  private_nh.param("use_multiple_thres", _use_multiple_thres, false);
+  ROS_INFO("use_multiple_thres: %d", _use_multiple_thres);
+
+  private_nh.param("first_euclid_thres",  first_euclid_thres, 0.5);
+  ROS_INFO("first_euclid_thres: %f",      first_euclid_thres);
+  private_nh.param("second_euclid_thres", second_euclid_thres, 1.1);
+  ROS_INFO("second_euclid_thres: %f",     second_euclid_thres);
+  private_nh.param("third_euclid_thres",  third_euclid_thres, 1.6);
+  ROS_INFO("third_euclid_thres: %f",      third_euclid_thres);
+  private_nh.param("fourth_euclid_thres", fourth_euclid_thres, 2.1);
+  ROS_INFO("fourth_euclid_thres: %f",     fourth_euclid_thres);
+  private_nh.param("fifth_euclid_thres",  fifth_euclid_thres, 2.6);
+  ROS_INFO("fifth_euclid_thres: %f",      fifth_euclid_thres);
+
+  private_nh.param("first_segment_range",  first_segment_range, 15.0);
+  ROS_INFO("first_segment_range: %f",      first_segment_range);
+  private_nh.param("second_segment_range", second_segment_range, 30.0);
+  ROS_INFO("second_segment_range: %f",     second_segment_range);
+  private_nh.param("third_segment_range",  third_segment_range, 45.0);
+  ROS_INFO("third_segment_range: %f",      third_segment_range);
+  private_nh.param("fourth_segment_range", fourth_segment_range, 60.0);
+  ROS_INFO("fourth_segment_range: %f",     fourth_segment_range);
+
+  _clustering_thresholds = {first_euclid_thres, second_euclid_thres, third_euclid_thres, fourth_euclid_thres, fifth_euclid_thres};
+  _clustering_distances  = {first_segment_range, second_segment_range, third_segment_range, fourth_segment_range};
+
   _velodyne_transform_available = false;
 
   // Create a ROS subscriber for the input point cloud
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="dd620e04128181b4e312b050670994680a317164" author="Kosuke Murakami">
		<msg>Apllying ros clang</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="37" deleted_lines="29">
				<diff>@@ -641,7 +641,7 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 
   std::vector&lt;ClusterPtr&gt; all_clusters;
 
-  if(!_use_multiple_thres)
+  if (!_use_multiple_thres)
   {
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
 
@@ -679,7 +679,8 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
       cloud_segments_array[i] = tmp_cloud;
     }
 
-    for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++) {
+    for (unsigned int i = 0; i &lt; in_cloud_ptr-&gt;points.size(); i++)
+    {
       pcl::PointXYZ current_point;
       current_point.x = in_cloud_ptr-&gt;points[i].x;
       current_point.y = in_cloud_ptr-&gt;points[i].y;
@@ -709,20 +710,26 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
       }
     }
 
-    for (unsigned int i = 0; i &lt; cloud_segments_array.size(); i++) {
+    for (unsigned int i = 0; i &lt; cloud_segments_array.size(); i++)
+    {
 #ifdef GPU_CLUSTERING
-        std::vector&lt;ClusterPtr&gt; local_clusters;
-        if (_use_gpu) {
-            local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
-                                                in_out_centroids, _clustering_thresholds[i]);
-        } else {
-            local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
-                                             in_out_centroids, _clustering_thresholds[i]);
-        }
+      std::vector&lt;ClusterPtr&gt; local_clusters;
+      if (_use_gpu)
+      {
+        local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
+                                            in_out_centroids, _clustering_thresholds[i]);
+      }
+      else
+      {
+        local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
+                                         in_out_centroids, _clustering_thresholds[i]);
+      }
 #else
-        std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
+      std::vector&lt;ClusterPtr&gt; local_clusters =
+          clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids,
+                          _clustering_thresholds[i]);
 #endif
-        all_clusters.insert(all_clusters.end(), local_clusters.begin(), local_clusters.end());
+      all_clusters.insert(all_clusters.end(), local_clusters.begin(), local_clusters.end());
     }
   }
 
@@ -1297,28 +1304,29 @@ int main(int argc, char** argv)
   private_nh.param("use_multiple_thres", _use_multiple_thres, false);
   ROS_INFO("use_multiple_thres: %d", _use_multiple_thres);
 
-  private_nh.param("first_euclid_thres",  first_euclid_thres, 0.5);
-  ROS_INFO("first_euclid_thres: %f",      first_euclid_thres);
+  private_nh.param("first_euclid_thres", first_euclid_thres, 0.5);
+  ROS_INFO("first_euclid_thres: %f", first_euclid_thres);
   private_nh.param("second_euclid_thres", second_euclid_thres, 1.1);
-  ROS_INFO("second_euclid_thres: %f",     second_euclid_thres);
-  private_nh.param("third_euclid_thres",  third_euclid_thres, 1.6);
-  ROS_INFO("third_euclid_thres: %f",      third_euclid_thres);
+  ROS_INFO("second_euclid_thres: %f", second_euclid_thres);
+  private_nh.param("third_euclid_thres", third_euclid_thres, 1.6);
+  ROS_INFO("third_euclid_thres: %f", third_euclid_thres);
   private_nh.param("fourth_euclid_thres", fourth_euclid_thres, 2.1);
-  ROS_INFO("fourth_euclid_thres: %f",     fourth_euclid_thres);
-  private_nh.param("fifth_euclid_thres",  fifth_euclid_thres, 2.6);
-  ROS_INFO("fifth_euclid_thres: %f",      fifth_euclid_thres);
+  ROS_INFO("fourth_euclid_thres: %f", fourth_euclid_thres);
+  private_nh.param("fifth_euclid_thres", fifth_euclid_thres, 2.6);
+  ROS_INFO("fifth_euclid_thres: %f", fifth_euclid_thres);
 
-  private_nh.param("first_segment_range",  first_segment_range, 15.0);
-  ROS_INFO("first_segment_range: %f",      first_segment_range);
+  private_nh.param("first_segment_range", first_segment_range, 15.0);
+  ROS_INFO("first_segment_range: %f", first_segment_range);
   private_nh.param("second_segment_range", second_segment_range, 30.0);
-  ROS_INFO("second_segment_range: %f",     second_segment_range);
-  private_nh.param("third_segment_range",  third_segment_range, 45.0);
-  ROS_INFO("third_segment_range: %f",      third_segment_range);
+  ROS_INFO("second_segment_range: %f", second_segment_range);
+  private_nh.param("third_segment_range", third_segment_range, 45.0);
+  ROS_INFO("third_segment_range: %f", third_segment_range);
   private_nh.param("fourth_segment_range", fourth_segment_range, 60.0);
-  ROS_INFO("fourth_segment_range: %f",     fourth_segment_range);
+  ROS_INFO("fourth_segment_range: %f", fourth_segment_range);
 
-  _clustering_thresholds = {first_euclid_thres, second_euclid_thres, third_euclid_thres, fourth_euclid_thres, fifth_euclid_thres};
-  _clustering_distances  = {first_segment_range, second_segment_range, third_segment_range, fourth_segment_range};
+  _clustering_thresholds = { first_euclid_thres, second_euclid_thres, third_euclid_thres, fourth_euclid_thres,
+                             fifth_euclid_thres };
+  _clustering_distances = { first_segment_range, second_segment_range, third_segment_range, fourth_segment_range };
 
   _velodyne_transform_available = false;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="106965e8dd737aa87136fe80cf61be8d1d6b221d" author="Kosuke Murakami">
		<msg>Naming change from segment to clustering</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="49" deleted_lines="49">
				<diff>@@ -142,7 +142,7 @@ static double _keep_lane_right_distance;
 static double _max_boundingbox_side;
 static double _remove_points_upto;
 static double _cluster_merge_threshold;
-static double _segment_distance;
+static double _clustering_distance;
 
 static bool _use_gpu;
 static std::chrono::system_clock::time_point _start, _end;
@@ -153,8 +153,8 @@ pcl::PointCloud&lt;pcl::PointXYZ&gt; _sensor_cloud;
 visualization_msgs::Marker _visualization_marker;
 
 static bool _use_multiple_thres;
-std::vector&lt;double&gt; _clustering_thresholds;
 std::vector&lt;double&gt; _clustering_distances;
+std::vector&lt;double&gt; _clustering_ranges;
 
 tf::StampedTransform* _transform;
 tf::StampedTransform* _velodyne_output_transform;
@@ -657,17 +657,17 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 #ifdef GPU_CLUSTERING
     if (_use_gpu)
     {
-      all_clusters =
-          clusterAndColorGpu(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
+      all_clusters = clusterAndColorGpu(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids,
+                                        _clustering_distance);
     }
     else
     {
       all_clusters =
-          clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
+          clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_distance);
     }
 #else
     std::vector&lt;ClusterPtr&gt; all_clusters =
-        clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _segment_distance);
+        clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_distance);
 #endif
   }
   else
@@ -688,19 +688,19 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 
       float origin_distance = sqrt(pow(current_point.x, 2) + pow(current_point.y, 2));
 
-      if (origin_distance &lt; _clustering_distances[0])
+      if (origin_distance &lt; _clustering_ranges[0])
       {
         cloud_segments_array[0]-&gt;points.push_back(current_point);
       }
-      else if (origin_distance &lt; _clustering_distances[1])
+      else if (origin_distance &lt; _clustering_ranges[1])
       {
         cloud_segments_array[1]-&gt;points.push_back(current_point);
       }
-      else if (origin_distance &lt; _clustering_distances[2])
+      else if (origin_distance &lt; _clustering_ranges[2])
       {
         cloud_segments_array[2]-&gt;points.push_back(current_point);
       }
-      else if (origin_distance &lt; _clustering_distances[3])
+      else if (origin_distance &lt; _clustering_ranges[3])
       {
         cloud_segments_array[3]-&gt;points.push_back(current_point);
       }
@@ -717,17 +717,16 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
       if (_use_gpu)
       {
         local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
-                                            in_out_centroids, _clustering_thresholds[i]);
+                                            in_out_centroids, _clustering_distances[i]);
       }
       else
       {
         local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
-                                         in_out_centroids, _clustering_thresholds[i]);
+                                         in_out_centroids, _clustering_distances[i]);
       }
 #else
-      std::vector&lt;ClusterPtr&gt; local_clusters =
-          clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids,
-                          _clustering_thresholds[i]);
+      std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColor(
+          cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_distances[i]);
 #endif
       all_clusters.insert(all_clusters.end(), local_clusters.begin(), local_clusters.end());
     }
@@ -1284,49 +1283,50 @@ int main(int argc, char** argv)
   private_nh.param("remove_points_upto", _remove_points_upto, 0.0);
   ROS_INFO("remove_points_upto: %f", _remove_points_upto);
 
-  private_nh.param("segment_distance", _segment_distance, 0.75);
-  ROS_INFO("segment_distance: %f", _segment_distance);
+  private_nh.param("clustering_distance", _clustering_distance, 0.75);
+  ROS_INFO("clustering_distance: %f", _clustering_distance);
 
   private_nh.param("use_gpu", _use_gpu, false);
   ROS_INFO("use_gpu: %d", _use_gpu);
 
-  double first_euclid_thres;
-  double second_euclid_thres;
-  double third_euclid_thres;
-  double fourth_euclid_thres;
-  double fifth_euclid_thres;
+  double first_clustering_distance;
+  double second_clustering_distance;
+  double third_clustering_distance;
+  double fourth_clustering_distance;
+  double fifth_clustering_distance;
 
-  double first_segment_range;
-  double second_segment_range;
-  double third_segment_range;
-  double fourth_segment_range;
+  double first_clustering_range;
+  double second_clustering_range;
+  double third_clustering_range;
+  double fourth_clustering_range;
 
   private_nh.param("use_multiple_thres", _use_multiple_thres, false);
   ROS_INFO("use_multiple_thres: %d", _use_multiple_thres);
 
-  private_nh.param("first_euclid_thres", first_euclid_thres, 0.5);
-  ROS_INFO("first_euclid_thres: %f", first_euclid_thres);
-  private_nh.param("second_euclid_thres", second_euclid_thres, 1.1);
-  ROS_INFO("second_euclid_thres: %f", second_euclid_thres);
-  private_nh.param("third_euclid_thres", third_euclid_thres, 1.6);
-  ROS_INFO("third_euclid_thres: %f", third_euclid_thres);
-  private_nh.param("fourth_euclid_thres", fourth_euclid_thres, 2.1);
-  ROS_INFO("fourth_euclid_thres: %f", fourth_euclid_thres);
-  private_nh.param("fifth_euclid_thres", fifth_euclid_thres, 2.6);
-  ROS_INFO("fifth_euclid_thres: %f", fifth_euclid_thres);
-
-  private_nh.param("first_segment_range", first_segment_range, 15.0);
-  ROS_INFO("first_segment_range: %f", first_segment_range);
-  private_nh.param("second_segment_range", second_segment_range, 30.0);
-  ROS_INFO("second_segment_range: %f", second_segment_range);
-  private_nh.param("third_segment_range", third_segment_range, 45.0);
-  ROS_INFO("third_segment_range: %f", third_segment_range);
-  private_nh.param("fourth_segment_range", fourth_segment_range, 60.0);
-  ROS_INFO("fourth_segment_range: %f", fourth_segment_range);
-
-  _clustering_thresholds = { first_euclid_thres, second_euclid_thres, third_euclid_thres, fourth_euclid_thres,
-                             fifth_euclid_thres };
-  _clustering_distances = { first_segment_range, second_segment_range, third_segment_range, fourth_segment_range };
+  private_nh.param("first_clustering_distance", first_clustering_distance, 0.5);
+  ROS_INFO("first_clustering_distance: %f", first_clustering_distance);
+  private_nh.param("second_clustering_distance", second_clustering_distance, 1.1);
+  ROS_INFO("second_clustering_distance: %f", second_clustering_distance);
+  private_nh.param("third_clustering_distance", third_clustering_distance, 1.6);
+  ROS_INFO("third_clustering_distance: %f", third_clustering_distance);
+  private_nh.param("fourth_clustering_distance", fourth_clustering_distance, 2.1);
+  ROS_INFO("fourth_clustering_distance: %f", fourth_clustering_distance);
+  private_nh.param("fifth_clustering_distance", fifth_clustering_distance, 2.6);
+  ROS_INFO("fifth_clustering_distance: %f", fifth_clustering_distance);
+
+  private_nh.param("first_clustering_range", first_clustering_range, 15.0);
+  ROS_INFO("first_clustering_range: %f", first_clustering_range);
+  private_nh.param("second_clustering_range", second_clustering_range, 30.0);
+  ROS_INFO("second_clustering_range: %f", second_clustering_range);
+  private_nh.param("third_clustering_range", third_clustering_range, 45.0);
+  ROS_INFO("third_clustering_range: %f", third_clustering_range);
+  private_nh.param("fourth_clustering_range", fourth_clustering_range, 60.0);
+  ROS_INFO("fourth_clustering_range: %f", fourth_clustering_range);
+
+  _clustering_distances = { first_clustering_distance, second_clustering_distance, third_clustering_distance,
+                            fourth_clustering_distance, fifth_clustering_distance };
+  _clustering_ranges = { first_clustering_range, second_clustering_range, third_clustering_range,
+                         fourth_clustering_range };
 
   _velodyne_transform_available = false;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9be0881b619adea8dfd9d0b0941527dc61fe4cb3" author="Kosuke Murakami">
		<msg>load multiple thres params from string: less rosparam</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="23" deleted_lines="35">
				<diff>@@ -67,6 +67,8 @@
 
 #include &lt;tf/tf.h&gt;
 
+#include &lt;yaml-cpp/yaml.h&gt;
+
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
 #include &lt;opencv2/core/version.hpp&gt;
@@ -1289,44 +1291,30 @@ int main(int argc, char** argv)
   private_nh.param("use_gpu", _use_gpu, false);
   ROS_INFO("use_gpu: %d", _use_gpu);
 
-  double first_clustering_distance;
-  double second_clustering_distance;
-  double third_clustering_distance;
-  double fourth_clustering_distance;
-  double fifth_clustering_distance;
-
-  double first_clustering_range;
-  double second_clustering_range;
-  double third_clustering_range;
-  double fourth_clustering_range;
-
   private_nh.param("use_multiple_thres", _use_multiple_thres, false);
   ROS_INFO("use_multiple_thres: %d", _use_multiple_thres);
 
-  private_nh.param("first_clustering_distance", first_clustering_distance, 0.5);
-  ROS_INFO("first_clustering_distance: %f", first_clustering_distance);
-  private_nh.param("second_clustering_distance", second_clustering_distance, 1.1);
-  ROS_INFO("second_clustering_distance: %f", second_clustering_distance);
-  private_nh.param("third_clustering_distance", third_clustering_distance, 1.6);
-  ROS_INFO("third_clustering_distance: %f", third_clustering_distance);
-  private_nh.param("fourth_clustering_distance", fourth_clustering_distance, 2.1);
-  ROS_INFO("fourth_clustering_distance: %f", fourth_clustering_distance);
-  private_nh.param("fifth_clustering_distance", fifth_clustering_distance, 2.6);
-  ROS_INFO("fifth_clustering_distance: %f", fifth_clustering_distance);
-
-  private_nh.param("first_clustering_range", first_clustering_range, 15.0);
-  ROS_INFO("first_clustering_range: %f", first_clustering_range);
-  private_nh.param("second_clustering_range", second_clustering_range, 30.0);
-  ROS_INFO("second_clustering_range: %f", second_clustering_range);
-  private_nh.param("third_clustering_range", third_clustering_range, 45.0);
-  ROS_INFO("third_clustering_range: %f", third_clustering_range);
-  private_nh.param("fourth_clustering_range", fourth_clustering_range, 60.0);
-  ROS_INFO("fourth_clustering_range: %f", fourth_clustering_range);
-
-  _clustering_distances = { first_clustering_distance, second_clustering_distance, third_clustering_distance,
-                            fourth_clustering_distance, fifth_clustering_distance };
-  _clustering_ranges = { first_clustering_range, second_clustering_range, third_clustering_range,
-                         fourth_clustering_range };
+  std::string str_distances;
+  std::string str_ranges;
+  private_nh.param("clustering_distances", str_distances, std::string("[0.5,1.1,1.6,2.1,2.6]"));
+  ROS_INFO("clustering_distances: %s", str_distances.c_str());
+  private_nh.param("clustering_ranges", str_ranges, std::string("[15,30,45,60]"));
+  ROS_INFO("clustering_ranges: %s", str_ranges.c_str());
+
+  YAML::Node distances = YAML::Load(str_distances);
+  YAML::Node ranges = YAML::Load(str_ranges);
+  size_t distances_size = distances.size();
+  size_t ranges_size = ranges.size();
+  if (distances_size != 5 || ranges_size != 4)
+  {
+    ROS_ERROR("Invalid size of clustering_ranges or/and clustering_distance. \
+    The size of clustering distance and clustering_ranges shoule be 5 and 4 respectively");
+    ros::shutdown();
+  }
+  _clustering_distances = { distances[0].as&lt;double&gt;(), distances[1].as&lt;double&gt;(), distances[2].as&lt;double&gt;(),
+                            distances[3].as&lt;double&gt;(), distances[4].as&lt;double&gt;() };
+  _clustering_ranges = { ranges[0].as&lt;double&gt;(), ranges[1].as&lt;double&gt;(), ranges[2].as&lt;double&gt;(),
+                         ranges[3].as&lt;double&gt;() };
 
   _velodyne_transform_available = false;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="77df140f485b4511e45210a4b698022283b38d43" author="Kosuke Murakami">
		<msg>Add variable number of params for clustering_ranges and clustering_distances</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="16" deleted_lines="6">
				<diff>@@ -1305,16 +1305,26 @@ int main(int argc, char** argv)
   YAML::Node ranges = YAML::Load(str_ranges);
   size_t distances_size = distances.size();
   size_t ranges_size = ranges.size();
-  if (distances_size != 5 || ranges_size != 4)
+  if (distances_size == 0 || ranges_size == 0)
   {
     ROS_ERROR("Invalid size of clustering_ranges or/and clustering_distance. \
-    The size of clustering distance and clustering_ranges shoule be 5 and 4 respectively");
+    The size of clustering distance and clustering_ranges shoule not be 0");
     ros::shutdown();
   }
-  _clustering_distances = { distances[0].as&lt;double&gt;(), distances[1].as&lt;double&gt;(), distances[2].as&lt;double&gt;(),
-                            distances[3].as&lt;double&gt;(), distances[4].as&lt;double&gt;() };
-  _clustering_ranges = { ranges[0].as&lt;double&gt;(), ranges[1].as&lt;double&gt;(), ranges[2].as&lt;double&gt;(),
-                         ranges[3].as&lt;double&gt;() };
+  if ((distances_size - ranges_size) != 1)
+  {
+    ROS_ERROR("Invalid size of clustering_ranges or/and clustering_distance. \
+    Expecting that (distances_size - ranges_size) == 1 ");
+    ros::shutdown();
+  }
+  for (size_t i_distance = 0; i_distance &lt; distances_size; i_distance++)
+  {
+    _clustering_distances.push_back(distances[i_distance].as&lt;double&gt;());
+  }
+  for (size_t i_range = 0; i_range &lt; ranges_size; i_range++)
+  {
+    _clustering_ranges.push_back(ranges[i_range].as&lt;double&gt;());
+  }
 
   _velodyne_transform_available = false;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4476edbbb796788a590bb0fa6f688bf8956a2545" author="hatem-darweesh">
		<msg>Update BehaviorPrediction.h

pass pointer as "const" for function "DeleteFromList" in both (BehaviorPrediction and LLP) classes</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\BehaviorPrediction.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\BehaviorPrediction.h" added_lines="2" deleted_lines="2">
				<diff>@@ -646,7 +646,7 @@ public:
 		}
 	};
 
-	void DeleteFromList(std::vector&lt;TrajectoryTracker*&gt;&amp; delete_me_track, TrajectoryTracker* track)
+	void DeleteFromList(std::vector&lt;TrajectoryTracker*&gt;&amp; delete_me_track, const TrajectoryTracker* track)
 	{
 		for(unsigned int k = 0; k &lt; delete_me_track.size(); k++)
 		{
@@ -852,7 +852,7 @@ protected:
 
 public:
 	//move to CPP later
-	void DeleteFromList(std::vector&lt;ObjParticles*&gt;&amp; delete_me, ObjParticles* pElement)
+	void DeleteFromList(std::vector&lt;ObjParticles*&gt;&amp; delete_me, const ObjParticles* pElement)
 	{
 		for(unsigned int k = 0; k &lt; delete_me.size(); k++)
 		{
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2b5b9525c356fc92d2eda177c94b05f4fb162f5c" author="hatem-darweesh">
		<msg>Update PlanningHelpers.h

Delete useless comment for including math.h</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlanningHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlanningHelpers.h" added_lines="0" deleted_lines="1">
				<diff>@@ -8,7 +8,6 @@
 #ifndef PLANNINGHELPERS_H_
 #define PLANNINGHELPERS_H_
 
-//#include &lt;math.h&gt;
 #include "RoadNetwork.h"
 #include "op_utility/UtilityH.h"
 #include "op_utility/DataRW.h"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="01f2ba7efcff01c376dd8e4418e31cbb91607dd1" author="hatem-darweesh">
		<msg>Support old behavior of insert static object for obstacle avoidance testing
Only one simulated car available in the runtime manager
update for copywrite note
insert autoware_build_flags to new nodes</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\open_planner.rviz" new_path="ros\src\.config\rviz\open_planner.rviz" added_lines="21" deleted_lines="70">
				<diff>@@ -13,7 +13,7 @@ Panels:
         - /Tracked Contours1/Namespaces1
         - /GlobalPathAnimation1/Status1
       Splitter Ratio: 0.695804
-    Tree Height: 1573
+    Tree Height: 1281
   - Class: rviz/Selection
     Name: Selection
   - Class: rviz/Tool Properties
@@ -61,18 +61,10 @@ Visualization Manager:
         All Enabled: true
         base_link:
           Value: true
-        base_link_2:
-          Value: true
         map:
           Value: true
-        mobility:
-          Value: true
-        sim_base_link:
-          Value: true
         velodyne:
           Value: true
-        velodyne_2:
-          Value: true
         world:
           Value: true
       Marker Scale: 5
@@ -83,13 +75,7 @@ Visualization Manager:
       Tree:
         world:
           map:
-            base_link_2:
-              velodyne_2:
-                {}
-            mobility:
-              {}
-            sim_base_link:
-              {}
+            {}
       Update Interval: 0
       Value: true
     - Alpha: 0.0500000007
@@ -141,7 +127,6 @@ Visualization Manager:
       Unreliable: false
       Value: false
       Visibility:
-        "": true
         A* Sim Obstacle: true
         Behavior State: true
         Collision Points: true
@@ -166,13 +151,11 @@ Visualization Manager:
         Points Cluster: true
         Points Map: true
         Points Raw: true
+        Predicted Trajectories: true
         Safety Box: true
         Sim Beh 1: true
-        Sim Beh 2: true
         Sim Car 1: true
-        Sim Car 2: true
         Sim Traj 1: true
-        Sim Traj 2: true
         Simulated Obstacle: true
         Stixel: true
         TF: false
@@ -288,7 +271,7 @@ Visualization Manager:
       Marker Topic: /next_target_mark
       Name: Next Waypoint Mark
       Namespaces:
-        next_target_marker: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -304,7 +287,7 @@ Visualization Manager:
       Marker Topic: /trajectory_circle_mark
       Name: PP Trajectory Mark
       Namespaces:
-        trajectory_circle_marker: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -413,7 +396,7 @@ Visualization Manager:
       Marker Topic: /vector_map_center_lines_rviz
       Name: Vector Map CenterLines
       Namespaces:
-        road_network_vector_map: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -421,9 +404,7 @@ Visualization Manager:
       Marker Topic: /global_waypoints_rviz
       Name: Global Path
       Namespaces:
-        global_lane_array_marker: true
-        global_lane_waypoint_orientation_marker: false
-        global_velocity_lane_1: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -431,7 +412,7 @@ Visualization Manager:
       Marker Topic: /local_trajectories_gen_rviz
       Name: "OP Gen Rollouts "
       Namespaces:
-        global_lane_array_marker: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -439,7 +420,7 @@ Visualization Manager:
       Marker Topic: /local_trajectories_eval_rviz
       Name: "OP Eval Rollouts "
       Namespaces:
-        local_lane_array_marker_colored: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -455,7 +436,7 @@ Visualization Manager:
       Marker Topic: /behavior_state
       Name: Behavior State
       Namespaces:
-        beh_state: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -463,7 +444,7 @@ Visualization Manager:
       Marker Topic: /safety_border
       Name: Safety Box
       Namespaces:
-        global_lane_array_marker: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -471,13 +452,7 @@ Visualization Manager:
       Marker Topic: /detected_polygons
       Name: Tracked Contours
       Namespaces:
-        CenterMarker: true
-        Detection_Circles: false
-        Directions: true
-        InfoText: true
-        detected_polygons: true
-        matching_connections: true
-        tracked_trajectories: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -548,7 +523,7 @@ Visualization Manager:
       Marker Topic: /op_destinations_rviz
       Name: Goals
       Namespaces:
-        HMI_Destinations: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -556,7 +531,7 @@ Visualization Manager:
       Marker Topic: /map_curbs_rviz
       Name: Curbs
       Namespaces:
-        map_detected_curbs: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -583,36 +558,12 @@ Visualization Manager:
         {}
       Queue Size: 100
       Value: true
-    - Class: rviz/Marker
-      Enabled: true
-      Marker Topic: /curr_simu_pose_2
-      Name: Sim Car 2
-      Namespaces:
-        curr_simu_pose: true
-      Queue Size: 100
-      Value: true
-    - Class: rviz/Marker
-      Enabled: true
-      Marker Topic: /sim_beh_txt_2
-      Name: Sim Beh 2
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/MarkerArray
-      Enabled: true
-      Marker Topic: /simu_local_trajectory_2
-      Name: Sim Traj 2
-      Namespaces:
-        simu_car_path_2: true
-      Queue Size: 100
-      Value: true
     - Class: rviz/MarkerArray
       Enabled: true
       Marker Topic: /dynamic_collision_points_rviz
       Name: Collision Points
       Namespaces:
-        collision_points_rviz: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -620,7 +571,7 @@ Visualization Manager:
       Marker Topic: /predicted_trajectories_rviz
       Name: Predicted Trajectories
       Namespaces:
-        Predicted_Trajectories: true
+        {}
       Queue Size: 100
       Value: true
   Enabled: true
@@ -668,10 +619,10 @@ Window Geometry:
     collapsed: false
   Displays:
     collapsed: false
-  Height: 1746
+  Height: 1416
   Hide Left Dock: false
   Hide Right Dock: true
-  QMainWindow State: 000000ff00000000fd0000000400000000000001ad00000678fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006b00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc0000003400000678000000ef00fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000c00430061006d0065007200610000000000ffffffff0000008500fffffffb000000100044006900730070006c006100790073010000000000000136000001ad00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb0000000000000000000000010000013200000678fc0200000003fb0000000a00560069006500770073000000003400000678000000cd00fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e100000197000000030000069a0000005cfc0100000002fb0000000800540069006d006500000000000000069a0000043900fffffffb0000000800540069006d00650100000000000004500000000000000000000004ff0000067800000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  QMainWindow State: 000000ff00000000fd0000000400000000000001ad00000542fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006100fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc0000002800000542000000d700fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000c00430061006d0065007200610000000000ffffffff0000006700fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb0000000000000000000000010000013200000678fc0200000003fb0000000a00560069006500770073000000003400000678000000ad00fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e100000197000000030000069a0000005cfc0100000002fb0000000800540069006d006500000000000000069a0000030000fffffffb0000000800540069006d006501000000000000045000000000000000000000084d0000054200000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
@@ -680,6 +631,6 @@ Window Geometry:
     collapsed: false
   Views:
     collapsed: true
-  Width: 1717
-  X: 1019
-  Y: 36
+  Width: 2560
+  X: 1080
+  Y: 24
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\PolygonGenerator.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\PolygonGenerator.h" added_lines="30" deleted_lines="0">
				<diff>@@ -4,6 +4,36 @@
 /// \author Hatem Darweesh
 /// \date Nov 2, 2016
 
+/*
+ *  Copyright (c) 2016, Nagoya University
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 #ifndef OP_POLYGONGENERATOR_H_
 #define OP_POLYGONGENERATOR_H_
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\SimpleTracker.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\SimpleTracker.h" added_lines="30" deleted_lines="0">
				<diff>@@ -4,6 +4,36 @@
 /// \author Hatem Darweesh
 /// \date Aug 11, 2016
 
+/*
+ *  Copyright (c) 2016, Nagoya University
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 #ifndef SimpleTracker_H_
 #define SimpleTracker_H_
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\lidar_kf_contour_track_core.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\lidar_kf_contour_track_core.h" added_lines="3" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
-// *  Copyright (c) 2016, Nagoya University
+// *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -77,6 +77,7 @@ public:
 	bool 	bEnableStepByStep;
 	bool 	bEnableLogging;
 	bool bEnableTTC;
+	bool bEnableLaneChange;
 
 	PerceptionParams()
 	{
@@ -92,6 +93,7 @@ public:
 		bEnableSimulation = false;
 		bEnableLogging = false;
 		bEnableTTC = false;
+		bEnableLaneChange = false;
 	}
 };
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\PolygonGenerator.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\PolygonGenerator.cpp" added_lines="30" deleted_lines="0">
				<diff>@@ -4,6 +4,36 @@
 /// \author Hatem Darweesh
 /// \date Nov 2, 2016
 
+/*
+ *  Copyright (c) 2016, Nagoya University
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 #include "PolygonGenerator.h"
 #include "op_planner/PlanningHelpers.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\SimpleTracker.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\SimpleTracker.cpp" added_lines="30" deleted_lines="0">
				<diff>@@ -4,6 +4,36 @@
 /// \author Hatem Darweesh
 /// \date Aug 11, 2016
 
+/*
+ *  Copyright (c) 2016, Nagoya University
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 #include "SimpleTracker.h"
 #include "op_planner/MatrixOperations.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track_core.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track_core.cpp" added_lines="13" deleted_lines="11">
				<diff>@@ -1,11 +1,11 @@
 /*
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions are met:
  *
- *  * Redistributions of source code must retain the above copyright notice,
- * this
+ *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
  *
  *  * Redistributions in binary form must reproduce the above copyright notice,
@@ -18,18 +18,16 @@
  *
  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ */
+
 #include "lidar_kf_contour_track_core.h"
 #include "op_ros_helpers/op_RosHelpers.h"
 #include "op_planner/MappingHelpers.h"
@@ -150,6 +148,9 @@ void ContourTracker::ReadCommonParams()
 
 	m_ObstacleTracking.m_CirclesResolution = m_Params.DetectionRadius*0.05;
 
+	if(!_nh.getParam("/op_common_params/enableLaneChange" , m_Params.bEnableLaneChange))
+		m_Params.bEnableLaneChange = false;
+
 	int iSource = 0;
 	if(iSource == 0)
 		m_MapType = PlannerHNS::MAP_AUTOWARE;
@@ -171,6 +172,7 @@ void ContourTracker::callbackGetCloudClusters(const autoware_msgs::CloudClusterA
 		UtilityHNS::UtilityH::GetTickCount(tracking_timer);
 
 		//std::cout &lt;&lt; "Filter the detected Obstacles: " &lt;&lt; msg-&gt;clusters.size() &lt;&lt; ", " &lt;&lt; m_OriginalClusters.size() &lt;&lt; std::endl;
+
 		m_ObstacleTracking.DoOneStep(m_CurrentPos, m_OriginalClusters, m_Params.trackingType);
 
 		m_tracking_time = UtilityHNS::UtilityH::GetTimeDiffNow(tracking_timer);
@@ -560,7 +562,7 @@ void ContourTracker::MainLoop()
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
 						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,
-						m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true);
+						m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true, m_Params.bEnableLaneChange, true);
 
 				if(m_Map.roadSegments.size() &gt; 0)
 				{
@@ -574,7 +576,7 @@ void ContourTracker::MainLoop()
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
-						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true);
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true, m_Params.bEnableLaneChange, true);
 
 				if(m_Map.roadSegments.size() &gt; 0)
 				{
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\MappingHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\MappingHelpers.h" added_lines="6" deleted_lines="2">
				<diff>@@ -39,7 +39,9 @@ public:
 			const std::vector&lt;UtilityHNS::AisanCrossWalkFileReader::AisanCrossWalk&gt;&amp; crosswalk_data,
 			const std::vector&lt;UtilityHNS::AisanNodesFileReader::AisanNode&gt;&amp; nodes_data,
 			const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
-			const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag = false);
+			const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag = false,
+			const bool&amp; bFindLaneChangeLanes = false,
+			const bool&amp; bFindCurbsAndWayArea = false);
 
 	static void ConstructRoadNetworkFromRosMessageV2(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
 			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
@@ -60,7 +62,9 @@ public:
 				UtilityHNS::AisanPointsFileReader* pPointsData,
 				UtilityHNS::AisanNodesFileReader* pNodesData,
 				UtilityHNS::AisanLinesFileReader* pLinedata,
-				const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag = false);
+				const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag = false,
+				const bool&amp; bFindLaneChangeLanes = false,
+				const bool&amp; bFindCurbsAndWayArea = false);
 
 	static void ConstructRoadNetworkFromDataFiles(const std::string vectoMapPath, RoadNetwork&amp; map, const bool&amp; bZeroOrigin = false);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" added_lines="30" deleted_lines="26">
				<diff>@@ -16,11 +16,9 @@
 
 using namespace UtilityHNS;
 using namespace std;
-#define FIND_LEFT_RIGHT_LANES
 #define RIGHT_INITIAL_TURNS_COST 0
 #define LEFT_INITIAL_TURNS_COST 0
 #define DEBUG_MAP_PARSING 0
-#define MAP_PERF_ENABLE_CURB_AND_WAYAREA
 #define DEFAULT_REF_VELOCITY 60 //km/h
 
 namespace PlannerHNS
@@ -108,7 +106,8 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 		const std::vector&lt;UtilityHNS::AisanCrossWalkFileReader::AisanCrossWalk&gt;&amp; crosswalk_data,
 		const std::vector&lt;UtilityHNS::AisanNodesFileReader::AisanNode&gt;&amp; nodes_data,
 		const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
-		const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag)
+		const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag,
+		const bool&amp; bFindLaneChangeLanes, const bool&amp; bFindCurbsAndWayArea)
 {
 	vector&lt;Lane&gt; roadLanes;
 	Lane lane_obj;
@@ -427,10 +426,11 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 		}
 	}
 
-#ifdef FIND_LEFT_RIGHT_LANES
-	cout &lt;&lt; " &gt;&gt; Extract Lane Change Information... " &lt;&lt; endl;
-	FindAdjacentLanes(map);
-#endif
+	if(bFindLaneChangeLanes)
+	{
+		cout &lt;&lt; " &gt;&gt; Extract Lane Change Information... " &lt;&lt; endl;
+		FindAdjacentLanes(map);
+	}
 
 	//Extract Signals and StopLines
 	// Signals
@@ -448,13 +448,14 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 	LinkTrafficLightsAndStopLines(map);
 	//LinkTrafficLightsAndStopLinesConData(conn_data, id_replace_list, map);
 
-#ifdef MAP_PERF_ENABLE_CURB_AND_WAYAREA
-	//Curbs
-	ExtractCurbData(curb_data, line_data, points_data, origin, map);
+	if(bFindCurbsAndWayArea)
+	{
+		//Curbs
+		ExtractCurbData(curb_data, line_data, points_data, origin, map);
 
-	//Wayarea
-	ExtractWayArea(area_data, wayarea_data, line_data, points_data, origin, map);
-#endif
+		//Wayarea
+		ExtractWayArea(area_data, wayarea_data, line_data, points_data, origin, map);
+	}
 
 	//Fix angle for lanes
 	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
@@ -2287,7 +2288,8 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessageV2(const std::vector&lt;Util
 		UtilityHNS::AisanPointsFileReader* pPointsData,
 		UtilityHNS::AisanNodesFileReader* pNodesData,
 		UtilityHNS::AisanLinesFileReader* pLinedata,
-		const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag)
+		const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag,
+		const bool&amp; bFindLaneChangeLanes, const bool&amp; bFindCurbsAndWayArea)
 {
 	vector&lt;Lane&gt; roadLanes;
 
@@ -2355,10 +2357,11 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessageV2(const std::vector&lt;Util
 		}
 	}
 
-#ifdef FIND_LEFT_RIGHT_LANES
-	cout &lt;&lt; " &gt;&gt; Extract Lane Change Information... " &lt;&lt; endl;
-	FindAdjacentLanesV2(map);
-#endif
+	if(bFindLaneChangeLanes)
+	{
+		cout &lt;&lt; " &gt;&gt; Extract Lane Change Information... " &lt;&lt; endl;
+		FindAdjacentLanesV2(map);
+	}
 
 	//Extract Signals and StopLines
 	cout &lt;&lt; " &gt;&gt; Extract Signal data ... " &lt;&lt; endl;
@@ -2368,15 +2371,16 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessageV2(const std::vector&lt;Util
 	cout &lt;&lt; " &gt;&gt; Extract Stop lines data ... " &lt;&lt; endl;
 	ExtractStopLinesDataV2(stop_line_data, pLinedata, pPointsData, origin, map);
 
-#ifdef MAP_PERF_ENABLE_CURB_AND_WAYAREA
-	//Curbs
-	cout &lt;&lt; " &gt;&gt; Extract curbs data ... " &lt;&lt; endl;
-	ExtractCurbDataV2(curb_data, pLinedata, pPointsData, origin, map);
+	if(bFindCurbsAndWayArea)
+	{
+		//Curbs
+		cout &lt;&lt; " &gt;&gt; Extract curbs data ... " &lt;&lt; endl;
+		ExtractCurbDataV2(curb_data, pLinedata, pPointsData, origin, map);
 
-	//Wayarea
-	cout &lt;&lt; " &gt;&gt; Extract wayarea data ... " &lt;&lt; endl;
-	ExtractWayArea(area_data, wayarea_data, line_data, points_data, origin, map);
-#endif
+		//Wayarea
+		cout &lt;&lt; " &gt;&gt; Extract wayarea data ... " &lt;&lt; endl;
+		ExtractWayArea(area_data, wayarea_data, line_data, points_data, origin, map);
+	}
 
 	//Link waypoints
 	cout &lt;&lt; " &gt;&gt; Link missing branches and waypoints... " &lt;&lt; endl;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\include\op_global_planner_core.h" new_path="ros\src\computing\planning\mission\packages\op_global_planner\include\op_global_planner_core.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
-// *  Copyright (c) 2017, Nagoya University
+// *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner.cpp" new_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2017, Nagoya University
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -29,7 +29,7 @@
 */
 
 /**
- * @brief Way Planner represents the Global planning Module, to generate global plan (reference path) the nodes takes start position, goal position and return sequence of waypoints.
+ * @brief global Planner represents the Global planning Module, to generate global plan (reference path) the nodes takes start position, goal position and return sequence of waypoints.
  * @brief Once the node starts (depending on the mapping option) it will load the vector map (road network) and send it to be visualized by RViz. topic name "/vector_map_center_lines_rviz"
  * @param Start_Position in simulation environment like rviz, this node require the user to select start position using "2D Pose Estimate" button and select starting position from the global path, //
  * if localization node is working and ndt_pose or curr_pose messages are published the node will use localization as starting position instead of "2D Pose Estimate"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" added_lines="3" deleted_lines="7">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2017, Nagoya University
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -68,11 +68,7 @@ GlobalPlanner::GlobalPlanner()
 
 	pub_Paths = nh.advertise&lt;autoware_msgs::LaneArray&gt;("lane_waypoints_array", 1, true);
 	pub_PathsRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("global_waypoints_rviz", 1, true);
-	//pub_StartPointRviz = nh.advertise&lt;visualization_msgs::Marker&gt;("Global_StartPoint_rviz", 1, true);
-	//pub_GoalPointRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("Global_GoalPoints_rviz", 1, true);
-	//pub_NodesListRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("Goal_Nodes_Points_rviz", 1, true);
 	pub_MapRviz  = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("vector_map_center_lines_rviz", 1, true);
-	//pub_TrafficInfoRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("Traffic_Lights_rviz", 1, true);
 	pub_GoalsListRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("op_destinations_rviz", 1, true);
 
 	if(m_params.bEnableRvizInput)
@@ -455,7 +451,7 @@ void GlobalPlanner::MainLoop()
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
 						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,
-						m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true);
+						m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true, m_params.bEnableLaneChange, false);
 			}
 			else if(m_MapRaw.GetVersion()==1)
 			{
@@ -465,7 +461,7 @@ void GlobalPlanner::MainLoop()
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
-						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true);
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true, m_params.bEnableLaneChange, false);
 			}
 
 			if(m_bKmlMap)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_motion_predictor_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_motion_predictor_core.h" added_lines="4" deleted_lines="3">
				<diff>@@ -49,6 +49,7 @@
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;geometry_msgs/PoseArray.h&gt;
+#include &lt;geometry_msgs/PointStamped.h&gt;
 #include &lt;nav_msgs/Odometry.h&gt;
 #include &lt;autoware_msgs/LaneArray.h&gt;
 #include &lt;autoware_msgs/CanInfo.h&gt;
@@ -111,9 +112,9 @@ protected:
 
 
 	ros::NodeHandle nh;
-	ros::Publisher  pub_predicted_objects_trajectories;
-	ros::Publisher  pub_PredictedTrajectoriesRviz ;
-	ros::Publisher  pub_CurbsRviz ;
+	ros::Publisher pub_predicted_objects_trajectories;
+	ros::Publisher pub_PredictedTrajectoriesRviz ;
+	ros::Publisher pub_CurbsRviz ;
 	ros::Publisher pub_ParticlesRviz;
 
 	// define subscribers.
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2016, Nagoya University
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector_core.cpp" added_lines="4" deleted_lines="2">
				<diff>@@ -1,4 +1,5 @@
 /*
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -26,6 +27,7 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
+
 #include "op_behavior_selector_core.h"
 #include "op_ros_helpers/op_RosHelpers.h"
 #include "op_planner/MappingHelpers.h"
@@ -572,7 +574,7 @@ void BehaviorGen::MainLoop()
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
 						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,
-						m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true);
+						m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true, m_PlanningParams.enableLaneChange, false);
 
 				if(m_Map.roadSegments.size() &gt; 0)
 				{
@@ -586,7 +588,7 @@ void BehaviorGen::MainLoop()
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
-						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true);
+						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true, m_PlanningParams.enableLaneChange, false);
 
 				if(m_Map.roadSegments.size() &gt; 0)
 				{
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor.cpp" added_lines="2" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2017, Nagoya University
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -27,6 +27,7 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
+
 #include &lt;ros/ros.h&gt;
 #include "../include/op_motion_predictor_core.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2017, Nagoya University
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -438,7 +438,7 @@ void MotionPrediction::MainLoop()
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
 						m_MapRaw.pCrossWalks-&gt;m_data_list, m_MapRaw.pNodes-&gt;m_data_list, conn_data,
-						m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true);
+						m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true, m_PlanningParams.enableLaneChange, true);
 
 				if(m_Map.roadSegments.size() &gt; 0)
 				{
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_evaluator\op_trajectory_evaluator.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_evaluator\op_trajectory_evaluator.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2016, Nagoya University
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_evaluator\op_trajectory_evaluator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_evaluator\op_trajectory_evaluator_core.cpp" added_lines="2" deleted_lines="0">
				<diff>@@ -1,4 +1,5 @@
 /*
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -26,6 +27,7 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
+
 #include "op_trajectory_evaluator_core.h"
 #include "op_ros_helpers/op_RosHelpers.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2016, Nagoya University
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" added_lines="2" deleted_lines="0">
				<diff>@@ -1,4 +1,5 @@
 /*
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -26,6 +27,7 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
+
 #include "op_trajectory_generator_core.h"
 #include "op_ros_helpers/op_RosHelpers.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_car_simulator_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_car_simulator_core.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
-// *  Copyright (c) 2017, Nagoya University
+// *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_perception_simulator_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_perception_simulator_core.h" added_lines="7" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
-// *  Copyright (c) 2017, Nagoya University
+// *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -81,17 +81,23 @@ protected:
 	timespec m_Timer;
 	DetectionCommandParams m_DecParams;
 
+	autoware_msgs::CloudCluster m_SimulatedCluter;
+
 	autoware_msgs::CloudClusterArray m_ObjClustersArray;
+	autoware_msgs::CloudClusterArray m_AllObjClustersArray;
+	bool m_bSetSimulatedObj;
 	std::vector&lt;std::pair&lt;int, double&gt; &gt; m_keepTime;
 
 	ros::Publisher pub_DetectedObjects;
 
 	// define subscribers.
 	std::vector&lt;ros::Subscriber&gt; sub_objs;
+	ros::Subscriber sub_simulated_obstacle_pose_rviz;
 
 
 	// Callback function for subscriber.
 	void callbackGetSimuData(const geometry_msgs::PoseArray &amp;msg);
+	void callbackGetRvizPoint(const geometry_msgs::PointStampedConstPtr&amp; msg);
 
 public:
 	OpenPlannerSimulatorPerception();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_signs_simulator_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_signs_simulator_core.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
-// *  Copyright (c) 2017, Nagoya University
+// *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2017, Nagoya University
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -27,7 +27,7 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "../include/op_car_simulator_core.h"
+#include "op_car_simulator_core.h"
 
 
 int main(int argc, char **argv)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator_core.cpp" added_lines="3" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2017, Nagoya University
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -27,7 +27,8 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "../include/op_car_simulator_core.h"
+
+#include "op_car_simulator_core.h"
 
 #include "op_utility/UtilityH.h"
 #include "math.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_perception_simulator\op_perception_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_perception_simulator\op_perception_simulator.cpp" added_lines="3" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2017, Nagoya University
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -27,7 +27,8 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "../include/op_perception_simulator_core.h"
+
+#include "op_perception_simulator_core.h"
 
 
 int main(int argc, char **argv)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_perception_simulator\op_perception_simulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_perception_simulator\op_perception_simulator_core.cpp" added_lines="42" deleted_lines="24">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2017, Nagoya University
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -27,6 +27,7 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
+
 #include "op_perception_simulator_core.h"
 
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
@@ -35,6 +36,7 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;boost/random.hpp&gt;
 #include &lt;boost/math/distributions/normal.hpp&gt;
+#include "op_ros_helpers/op_RosHelpers.h"
 
 #include "op_utility/UtilityH.h"
 #include "math.h"
@@ -47,14 +49,23 @@ typedef boost::mt19937 ENG;
 typedef boost::normal_distribution&lt;double&gt; NormalDIST;
 typedef boost::variate_generator&lt;ENG, NormalDIST&gt; VariatGEN;
 
+constexpr double SIMU_OBSTACLE_WIDTH = 1.5;
+constexpr double SIMU_OBSTACLE_LENGTH = 1.5;
+constexpr double SIMU_OBSTACLE_HEIGHT = 1.4;
+constexpr double SIMU_OBSTACLE_POINTS_NUM = 50;
+constexpr int SIMU_OBSTACLE_ID = 100001;
+
 OpenPlannerSimulatorPerception::OpenPlannerSimulatorPerception()
 {
+	m_bSetSimulatedObj = false;
 	nh.getParam("/op_perception_simulator/simObjNumber" , m_DecParams.nSimuObjs);
 	nh.getParam("/op_perception_simulator/GuassianErrorFactor" , m_DecParams.errFactor);
 	nh.getParam("/op_perception_simulator/pointCloudPointsNumber" , m_DecParams.nPointsPerObj);
 
 	pub_DetectedObjects = nh.advertise&lt;autoware_msgs::CloudClusterArray&gt;("cloud_clusters",1);
 
+	sub_simulated_obstacle_pose_rviz = nh.subscribe("/clicked_point", 1, &amp;OpenPlannerSimulatorPerception::callbackGetRvizPoint,	this);
+
 	for(int i=1; i &lt;= m_DecParams.nSimuObjs; i++)
 	{
 		std::ostringstream str_pose;
@@ -79,6 +90,26 @@ OpenPlannerSimulatorPerception::~OpenPlannerSimulatorPerception()
 {
 }
 
+
+void OpenPlannerSimulatorPerception::callbackGetRvizPoint(const geometry_msgs::PointStampedConstPtr&amp; msg)
+{
+	tf::StampedTransform transform;
+	PlannerHNS::RosHelpers::GetTransformFromTF("map", "world", transform);
+
+	geometry_msgs::Pose point;
+	point.position.x = msg-&gt;point.x + transform.getOrigin().x();
+	point.position.y = msg-&gt;point.y + transform.getOrigin().y();
+	point.position.z = msg-&gt;point.z + transform.getOrigin().z();
+	point.orientation =  tf::createQuaternionMsgFromRollPitchYaw(0, 0, 0);
+
+	m_SimulatedCluter = GenerateSimulatedObstacleCluster(SIMU_OBSTACLE_WIDTH , SIMU_OBSTACLE_LENGTH, SIMU_OBSTACLE_HEIGHT, SIMU_OBSTACLE_POINTS_NUM, point);
+	m_SimulatedCluter.id = SIMU_OBSTACLE_ID;
+	m_SimulatedCluter.score = 0; //zero velocity
+	m_SimulatedCluter.indicator_state = 3; // default indicator value
+
+	m_bSetSimulatedObj = true;
+}
+
 void OpenPlannerSimulatorPerception::callbackGetSimuData(const geometry_msgs::PoseArray &amp;msg)
 {
 	int obj_id = -1;
@@ -98,9 +129,6 @@ void OpenPlannerSimulatorPerception::callbackGetSimuData(const geometry_msgs::Po
 		indicator = msg.poses.at(3).orientation.w;
 	}
 
-//	ROS_INFO("Obj ID = %d", obj_id);
-
-
 	if(obj_id &lt; 0)
 		return;
 
@@ -128,17 +156,12 @@ void OpenPlannerSimulatorPerception::callbackGetSimuData(const geometry_msgs::Po
 	{
 		m_ObjClustersArray.clusters.at(index) = c;
 		m_keepTime.at(index).second = OBJECT_KEEP_TIME;
-	//	ROS_INFO("Update Obj ID = %d", c.id);
 	}
 	else
 	{
 		m_ObjClustersArray.clusters.push_back(c);
 		m_keepTime.push_back(std::make_pair(c.id, OBJECT_KEEP_TIME));
-	//	ROS_INFO("Insert Obj ID = %d", c.id);
 	}
-
-	//std::cout &lt;&lt; "Current Simulated Objects : " &lt;&lt; m_ObjClustersArray.clusters.size() &lt;&lt; std::endl;
-
 }
 
 
@@ -180,21 +203,10 @@ autoware_msgs::CloudCluster OpenPlannerSimulatorPerception::GenerateSimulatedObs
 		srand(t.tv_nsec);
 
 		center_p.pos.x = ((double)(rand()%100)/100.0 - CONTOUR_DISTANCE_ERROR);
-//		if(center_p.pos.x &gt;=0 &amp;&amp; center_p.pos.x &lt;= CONTOUR_DISTANCE_ERROR)
-//			center_p.pos.x += CONTOUR_DISTANCE_ERROR;
-//		else if(center_p.pos.x &lt; 0 &amp;&amp; center_p.pos.x &gt;= -CONTOUR_DISTANCE_ERROR)
-//			center_p.pos.x -= CONTOUR_DISTANCE_ERROR;
-
 		center_p.pos.x *= width;
 
 		srand(t.tv_nsec/i);
 		center_p.pos.y = ((double)(rand()%100)/100.0 - CONTOUR_DISTANCE_ERROR);
-
-//		if(center_p.pos.y &gt;=0 &amp;&amp; center_p.pos.y &lt;= CONTOUR_DISTANCE_ERROR)
-//			center_p.pos.y += CONTOUR_DISTANCE_ERROR;
-//		else if(center_p.pos.y &lt; 0 &amp;&amp; center_p.pos.y &gt;= -CONTOUR_DISTANCE_ERROR)
-//			center_p.pos.y -= CONTOUR_DISTANCE_ERROR;
-
 		center_p.pos.y *= length;
 
 		srand(t.tv_nsec/i*i);
@@ -225,7 +237,6 @@ void OpenPlannerSimulatorPerception::MainLoop()
 	{
 		ros::spinOnce();
 
-		//if(m_ObjClustersArray.clusters.size()&gt;0)
 		//clean old data
 		for(unsigned int i = 0 ; i &lt; m_keepTime.size(); i++)
 		{
@@ -239,9 +250,16 @@ void OpenPlannerSimulatorPerception::MainLoop()
 				m_keepTime.at(i).second -= 1;
 		}
 
-		pub_DetectedObjects.publish(m_ObjClustersArray);
-
-	//	std::cout &lt;&lt; "Number of Obstacles: (" &lt;&lt; m_keepTime.size() &lt;&lt; ", " &lt;&lt; m_ObjClustersArray.clusters.size() &lt;&lt; ") "&lt;&lt; std::endl;
+		if(m_bSetSimulatedObj)
+		{
+			m_AllObjClustersArray = m_ObjClustersArray;
+			m_AllObjClustersArray.clusters.push_back(m_SimulatedCluter);
+			pub_DetectedObjects.publish(m_AllObjClustersArray);
+		}
+		else
+		{
+			pub_DetectedObjects.publish(m_ObjClustersArray);
+		}
 
 		loop_rate.sleep();
 	}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_signs_simulator\op_signs_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_signs_simulator\op_signs_simulator.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2017, Nagoya University
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -27,8 +27,8 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "../include/op_signs_simulator_core.h"
 
+#include "op_signs_simulator_core.h"
 
 int main(int argc, char **argv)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_signs_simulator\op_signs_simulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_signs_simulator\op_signs_simulator_core.cpp" added_lines="2" deleted_lines="3">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2017, Nagoya University
+ *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -27,9 +27,8 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "op_signs_simulator_core.h"
-
 
+#include "op_signs_simulator_core.h"
 #include "op_utility/UtilityH.h"
 #include "math.h"
 #include "op_planner/MatrixOperations.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\BagTopicPlayer.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\BagTopicPlayer.h" added_lines="27" deleted_lines="4">
				<diff>@@ -1,9 +1,32 @@
 /*
- * BagTopicPlayer.h
+// *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
  *
- *  Created on: May 30, 2018
- *      Author: hatem
- */
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 
 #ifndef BAGTOPICPLAYER_H_
 #define BAGTOPICPLAYER_H_
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\DrawObjBase.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\DrawObjBase.h" added_lines="27" deleted_lines="4">
				<diff>@@ -1,9 +1,32 @@
 /*
- * DrawObjBase.h
+// *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
  *
- *  Created on: Jun 17, 2016
- *      Author: hatem
- */
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 
 #ifndef DRAWOBJBASE_TESTING
 #define DRAWOBJBASE_TESTING
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\DrawingHelpers.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\DrawingHelpers.h" added_lines="27" deleted_lines="4">
				<diff>@@ -1,9 +1,32 @@
 /*
- * DrawingHelpers.h
+// *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
  *
- *  Created on: May 31, 2016
- *      Author: hatem
- */
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 
 #ifndef DRAWINGHELPERS_TEST
 #define DRAWINGHELPERS_TEST
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\MainWindowWrapper.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\MainWindowWrapper.h" added_lines="27" deleted_lines="4">
				<diff>@@ -1,9 +1,32 @@
 /*
- * MainWindowWrapper.h
+// *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
  *
- *  Created on: May 31, 2016
- *      Author: hatem
- */
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 
 #ifndef WINDOWWRAPPER_TEST
 #define WINDOWWRAPPER_TEST
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_bag_player_core.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_bag_player_core.h" added_lines="27" deleted_lines="4">
				<diff>@@ -1,9 +1,32 @@
 /*
- * AlternativeVisualizer.h
+// *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
  *
- *  Created on: Jun 17, 2016
- *      Author: hatem
- */
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 
 #ifndef OP_TESTING_CORE
 #define OP_TESTING_CORE
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_data_logger_core.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_data_logger_core.h" added_lines="2" deleted_lines="3">
				<diff>@@ -1,5 +1,5 @@
 /*
-// *  Copyright (c) 2017, Nagoya University
+// *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -31,9 +31,8 @@
 #ifndef OP_DATALOGGER
 #define OP_DATALOGGER
 
-// ROS includes
+
 #include &lt;ros/ros.h&gt;
-//#include &lt;runtime_manager/traffic_light.h&gt;
 
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\BagTopicPlayer.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\BagTopicPlayer.cpp" added_lines="27" deleted_lines="4">
				<diff>@@ -1,9 +1,32 @@
 /*
- * BagTopicPlayer.cpp
+// *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
  *
- *  Created on: May 30, 2018
- *      Author: hatem
- */
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 
 #include "BagTopicPlayer.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\DrawObjBase.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\DrawObjBase.cpp" added_lines="27" deleted_lines="4">
				<diff>@@ -1,9 +1,32 @@
 /*
- * DrawObjBase.cpp
+// *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
  *
- *  Created on: Jun 17, 2016
- *      Author: hatem
- */
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 
 #include "DrawObjBase.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\DrawingHelpers.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\DrawingHelpers.cpp" added_lines="27" deleted_lines="4">
				<diff>@@ -1,9 +1,32 @@
 /*
- * DrawingHelpers.cpp
+// *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
  *
- *  Created on: May 31, 2016
- *      Author: hatem
- */
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 
 #include "DrawingHelpers.h"
 #include &lt;stdarg.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\MainWindowWrapper.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\MainWindowWrapper.cpp" added_lines="27" deleted_lines="4">
				<diff>@@ -1,9 +1,32 @@
 /*
- * MainWindowWrapper.cpp
+// *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
  *
- *  Created on: May 31, 2016
- *      Author: hatem
- */
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 
 #include "MainWindowWrapper.h"
 #include "DrawingHelpers.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\op_bag_player.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\op_bag_player.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2017, Nagoya University
+// *  Copyright (c) 2018, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\op_bag_player_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\op_bag_player_core.cpp" added_lines="27" deleted_lines="5">
				<diff>@@ -1,10 +1,32 @@
 /*
- * TestingUI.cpp
+// *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
  *
- *  Created on: Jun 17, 2016
- *      Author: hatem
- */
-
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 #include "op_bag_player_core.h"
 #include &lt;sstream&gt;
 #include &lt;algorithm&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_data_logger\op_data_logger.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_data_logger\op_data_logger.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -27,8 +27,8 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "../include/op_data_logger_core.h"
 
+#include "op_data_logger_core.h"
 
 int main(int argc, char **argv)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_data_logger\op_data_logger_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_data_logger\op_data_logger_core.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -27,9 +27,8 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "op_data_logger_core.h"
-
 
+#include "op_data_logger_core.h"
 #include "op_utility/UtilityH.h"
 #include "math.h"
 #include "op_planner/MatrixOperations.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_pose2tf\op_pose2tf_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_pose2tf\op_pose2tf_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -27,8 +27,8 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "op_pose2tf_core.h"
 
+#include "op_pose2tf_core.h"
 #include "math.h"
 #include &lt;std_msgs/Empty.h&gt;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="76be880d871cf8a850d00e702ff0f26bc8125292" author="Abraham Monrroy">
		<msg>fixes two typos in yolo class name/id file (#1486)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\rect_class_score.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\rect_class_score.h" added_lines="2" deleted_lines="2">
				<diff>@@ -46,7 +46,7 @@ public:
             case Yolo3::TRAIN: return "train";
             case Yolo3::TRUCK: return "truck";
             case Yolo3::BOAT: return "boat";
-            case Yolo3::TRAFFIC_LIGHT: return "traffic_lost";
+            case Yolo3::TRAFFIC_LIGHT: return "traffic_light";
             case Yolo3::FIRE_HYDRANT: return "fire_hydrant";
             case Yolo3::STOP_SIGN: return "stop_sign";
             case Yolo3::PARKING_METER: return "parking_meter";
@@ -126,7 +126,7 @@ public:
         {
             case Yolo3::PERSON: return 0;
             case Yolo3::BICYCLE: return 1;
-            case Yolo3::CAR: return 3;
+            case Yolo3::CAR: return 2;
             case Yolo3::MOTORBIKE: return 3;
             case Yolo3::AEROPLANE: return 4;
             case Yolo3::BUS: return 5;
</diff>
			</file>
		</modified_files>
	</commit>
</Root>
