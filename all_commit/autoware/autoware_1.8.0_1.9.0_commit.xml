<?xml version="1.0" encoding="utf-8"?>
<Root>
	<commit hash="ada31fa3f13d698a831c720d672718478a28cf29" author="Abraham Monrroy">
		<msg>Feature/beyond pixel tracker (#1473)

* Add beyond_pixel node

* Update prototype of beyond pixel (#1430)

* Add parser of DetectedObjectArray for beyond tracker(#1430)

* * Adaptations to the original code
* Added README
* Added Runtime Manager entry

* Added Video link

* Added install commands for cmake

* * Add ID only to tracked objects
* Display valid IDs on the 3D labels
* Display only objects with image coords

* * Added Minimum dimensions
* Register angle from the vision tracker if available

* Keep message publishing rate continuous

* Revert platform_automation_msgs (#1498)

* Code cleanup

* Fixed a crash when the dimensions are outside of the image

* Fix annoying catkin_make causing to run twice the Cmake generation</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\include\range_vision_fusion\range_vision_fusion.h" new_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\include\range_vision_fusion\range_vision_fusion.h" added_lines="9" deleted_lines="0">
				<diff>@@ -63,6 +63,8 @@
 #include &lt;opencv2/imgproc/imgproc.hpp&gt;
 #include &lt;opencv2/calib3d/calib3d.hpp&gt;
 
+#include &lt;yaml-cpp/yaml.h&gt;
+
 #include &lt;Eigen/Core&gt;
 #include &lt;Eigen/Geometry&gt;
 
@@ -96,6 +98,7 @@ class RosRangeVisionFusionApp
     autoware_msgs::DetectedObjectArray::ConstPtr  vision_detections_, range_detections_;
 
     std::string                         image_frame_id_;
+    std::string                         boxes_frame_;
 
     bool                                processing_;
     bool                                camera_info_ok_;
@@ -104,6 +107,10 @@ class RosRangeVisionFusionApp
     float                               fx_, fy_, cx_, cy_;
     double                              overlap_threshold_;
 
+    double                              car_width_, car_height_, car_depth_;
+    double                              person_width_, person_height_, person_depth_;
+    double                              truck_width_, truck_depth_, truck_height_;
+
     size_t                              empty_frames_;
 
     typedef
@@ -116,6 +123,8 @@ class RosRangeVisionFusionApp
     message_filters::Synchronizer&lt;SyncPolicyT&gt;
                                         *detections_synchronizer_;
 
+    void CheckMinimumDimensions(autoware_msgs::DetectedObject &amp;in_out_object);
+
     jsk_recognition_msgs::BoundingBoxArray ObjectsToBoxes(const autoware_msgs::DetectedObjectArray &amp;in_objects);
 
     void VisionDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_image_msg);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\src\range_vision_fusion.cpp" new_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\src\range_vision_fusion.cpp" added_lines="122" deleted_lines="42">
				<diff>@@ -287,6 +287,38 @@ double RosRangeVisionFusionApp::GetDistanceToObject(const autoware_msgs::Detecte
                 in_object.dimensions.z*in_object.dimensions.z);
 }
 
+void RosRangeVisionFusionApp::CheckMinimumDimensions(autoware_msgs::DetectedObject &amp;in_out_object)
+{
+    if (in_out_object.label == "car")
+    {
+        if (in_out_object.dimensions.x &lt; car_depth_)
+            in_out_object.dimensions.x = car_depth_;
+        if (in_out_object.dimensions.y &lt; car_width_)
+            in_out_object.dimensions.y = car_width_;
+        if (in_out_object.dimensions.z &lt; car_height_)
+            in_out_object.dimensions.z = car_height_;
+    }
+    if (in_out_object.label == "person")
+    {
+        if (in_out_object.dimensions.x &lt; person_depth_)
+            in_out_object.dimensions.x = person_depth_;
+        if (in_out_object.dimensions.y &lt; person_width_)
+            in_out_object.dimensions.y = person_width_;
+        if (in_out_object.dimensions.z &lt; person_height_)
+            in_out_object.dimensions.z = person_height_;
+    }
+
+    if (in_out_object.label == "truck" || in_out_object.label == "bus")
+    {
+        if (in_out_object.dimensions.x &lt; truck_depth_)
+            in_out_object.dimensions.x = truck_depth_;
+        if (in_out_object.dimensions.y &lt; truck_width_)
+            in_out_object.dimensions.y = truck_width_;
+        if (in_out_object.dimensions.z &lt; truck_height_)
+            in_out_object.dimensions.z = truck_height_;
+    }
+}
+
 autoware_msgs::DetectedObjectArray
 RosRangeVisionFusionApp::FuseRangeVisionDetections(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections,
                                                    const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections)
@@ -300,6 +332,7 @@ RosRangeVisionFusionApp::FuseRangeVisionDetections(const autoware_msgs::Detected
     fused_objects.header = in_range_detections-&gt;header;
 
     std::vector&lt; std::vector&lt;size_t&gt; &gt; vision_range_assignments (in_vision_detections-&gt;objects.size());
+    std::vector&lt;bool&gt; used_vision_detections(in_vision_detections-&gt;objects.size(), false);
     std::vector&lt; long &gt; vision_range_closest (in_vision_detections-&gt;objects.size());
 
     for (size_t i = 0; i &lt; in_vision_detections-&gt;objects.size(); i++)
@@ -334,13 +367,22 @@ RosRangeVisionFusionApp::FuseRangeVisionDetections(const autoware_msgs::Detected
                 range_in_cv.objects[j].width = vision_object.width;
                 range_in_cv.objects[j].height = vision_object.height;
                 range_in_cv.objects[j].angle = vision_object.angle;
+                range_in_cv.objects[j].id = vision_object.id;
+                CheckMinimumDimensions(range_in_cv.objects[j]);
+                if (vision_object.pose.orientation.x &gt; 0
+                    || vision_object.pose.orientation.y &gt; 0
+                    || vision_object.pose.orientation.z &gt; 0)
+                {
+                    range_in_cv.objects[i].pose.orientation = vision_object.pose.orientation;
+                }
                 if(current_distance &lt; closest_distance)
                 {
                     closest_index = j;
                     closest_distance = current_distance;
                 }
-            }
-        }
+                used_vision_detections[i] = true;
+            }//end if overlap
+        }//end for range_in_cv
         vision_range_closest[i] = closest_index;
     }
 
@@ -354,32 +396,12 @@ RosRangeVisionFusionApp::FuseRangeVisionDetections(const autoware_msgs::Detected
             fused_objects.objects.push_back(range_in_cv.objects[vision_range_closest[i]]);
         }
     }
-
-    /*
-    for(size_t i = 0; i &lt; vision_range_assignments.size(); i++)
+    for(size_t i = 0; i &lt; used_vision_detections.size(); i++)
     {
-        autoware_msgs::DetectedObject merged_object = range_in_cv.objects[0];
-
-        for(const auto&amp; range_detection_idx: vision_range_assignments[i])
-        {
-            if(merged_object.label == range_in_cv.objects[range_detection_idx].label)
-            {
-                used_range_detections[range_detection_idx] = true;
-
-                merged_object = MergeObjects(merged_object, range_in_cv.objects[range_detection_idx]);
-            }
-        }
-        if(!vision_range_assignments[i].empty())
+        if (!used_vision_detections[i])
         {
-            CalculateObjectFeatures(merged_object, true);
-            fused_objects.objects.push_back(merged_object);
+            fused_objects.objects.push_back(in_vision_detections-&gt;objects[i]);
         }
-    }*/
-
-    //add objects outside image
-    for(size_t i=0; i &lt; range_out_cv.objects.size(); i++)
-    {
-        fused_objects.objects.push_back(range_out_cv.objects[i]);
     }
 
     return fused_objects;
@@ -393,17 +415,38 @@ RosRangeVisionFusionApp::SyncedDetectionsCallback(const autoware_msgs::DetectedO
     jsk_recognition_msgs::BoundingBoxArray fused_boxes;
     visualization_msgs::MarkerArray fused_objects_labels;
 
-    if (nullptr == in_vision_detections ||
-        nullptr == in_range_detections)
+    fused_boxes.boxes.clear();
+    fusion_objects.objects.clear();
+    fused_objects_labels.markers.clear();
+
+    if (empty_frames_ &gt; 5)
     {
-        ROS_INFO("[%s] Empty Detections, check that vision and range detectors are running and publishing.", __APP_NAME__);
-        if (empty_frames_ &gt; 5)
-        {
-            publisher_fused_objects_.publish(fusion_objects);
-            publisher_fused_boxes_.publish(fused_boxes);
-            publisher_fused_text_.publish(fused_objects_labels);
-            empty_frames_++;
-        }
+        ROS_INFO("[%s] Empty Detections. Make sure the vision and range detectors are running.", __APP_NAME__);
+    }
+
+    if (nullptr == in_vision_detections
+        &amp;&amp; nullptr == in_range_detections)
+    {
+        empty_frames_++;
+        return;
+    }
+
+    if (nullptr == in_vision_detections
+        &amp;&amp; nullptr != in_range_detections
+        &amp;&amp; !in_range_detections-&gt;objects.empty())
+    {
+        publisher_fused_boxes_.publish(fused_boxes);
+        publisher_fused_objects_.publish(in_range_detections);
+        empty_frames_++;
+        return;
+    }
+    if (nullptr == in_range_detections
+        &amp;&amp; nullptr != in_vision_detections
+        &amp;&amp; !in_vision_detections-&gt;objects.empty())
+    {
+        publisher_fused_boxes_.publish(fused_boxes);
+        publisher_fused_objects_.publish(in_vision_detections);
+        empty_frames_++;
         return;
     }
 
@@ -427,6 +470,7 @@ RosRangeVisionFusionApp::SyncedDetectionsCallback(const autoware_msgs::DetectedO
     publisher_fused_objects_.publish(fusion_objects);
     publisher_fused_boxes_.publish(fused_boxes);
     publisher_fused_text_.publish(fused_objects_labels);
+    boxes_frame_ = fused_boxes.header.frame_id;
     empty_frames_ = 0;
 
     vision_detections_ = nullptr;
@@ -441,7 +485,10 @@ RosRangeVisionFusionApp::ObjectsToMarkers(const autoware_msgs::DetectedObjectArr
 
     for(const autoware_msgs::DetectedObject&amp; object : in_objects.objects)
     {
-        if (object.label != "unknown")
+        if (object.label != "unknown"
+            &amp;&amp; object.pose.position.x != 0
+            &amp;&amp; object.pose.position.y != 0
+            &amp;&amp; object.pose.position.z != 0)
         {
             visualization_msgs::Marker marker;
             marker.header = in_objects.header;
@@ -450,6 +497,8 @@ RosRangeVisionFusionApp::ObjectsToMarkers(const autoware_msgs::DetectedObjectArr
             marker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
             marker.scale.z = 1.0;
             marker.text = object.label;
+            if (object.id != 0)
+                marker.text += " " + std::to_string(object.id);
             marker.pose.position = object.pose.position;
             marker.pose.position.z += 1.5;
             marker.color.r = 1.0;
@@ -483,7 +532,10 @@ RosRangeVisionFusionApp::ObjectsToBoxes(const autoware_msgs::DetectedObjectArray
         box.pose = object.pose;
         box.value = object.score;
 
-        final_boxes.boxes.push_back(box);
+        if (box.dimensions.x &gt; 0 &amp;&amp; box.dimensions.y &gt; 0 &amp;&amp; box.dimensions.z &gt; 0)
+        {
+            final_boxes.boxes.push_back(box);
+        }
     }
     return final_boxes;
 }
@@ -581,7 +633,7 @@ void
 RosRangeVisionFusionApp::InitializeRosIo(ros::NodeHandle &amp;in_private_handle)
 {
     //get params
-    std::string camera_info_src, detected_objects_vision;
+    std::string camera_info_src, detected_objects_vision, min_car_dimensions, min_person_dimensions, min_truck_dimensions;
     std::string detected_objects_range, fused_topic_str = "/detection/combined_objects", fused_boxes_str = "/detection/combined_objects_boxes";
     std::string fused_text_str = "detection/combined_objects_labels";
     std::string name_space_str = ros::this_node::getNamespace();
@@ -600,10 +652,42 @@ RosRangeVisionFusionApp::InitializeRosIo(ros::NodeHandle &amp;in_private_handle)
     in_private_handle.param&lt;double&gt;("overlap_threshold", overlap_threshold_, 0.5);
     ROS_INFO("[%s] overlap_threshold: %f", __APP_NAME__, overlap_threshold_);
 
+    in_private_handle.param&lt;std::string&gt;("min_car_dimensions", min_car_dimensions, "[2,2,4]");//w,h,d
+    ROS_INFO("[%s] min_car_dimensions: %s", __APP_NAME__, min_car_dimensions.c_str());
+
+    in_private_handle.param&lt;std::string&gt;("min_person_dimensions", min_person_dimensions, "[1,2,1]");
+    ROS_INFO("[%s] min_person_dimensions: %s", __APP_NAME__, min_person_dimensions.c_str());
+
+    in_private_handle.param&lt;std::string&gt;("min_truck_dimensions", min_truck_dimensions, "[2,2,4.5]");
+    ROS_INFO("[%s] min_truck_dimensions: %s", __APP_NAME__, min_truck_dimensions.c_str());
+
 
     in_private_handle.param&lt;bool&gt;("sync_topics", sync_topics, false);
     ROS_INFO("[%s] sync_topics: %d", __APP_NAME__, sync_topics);
 
+    YAML::Node car_dimensions = YAML::Load(min_car_dimensions);
+    YAML::Node person_dimensions = YAML::Load(min_person_dimensions);
+    YAML::Node truck_dimensions = YAML::Load(min_truck_dimensions);
+
+    if (car_dimensions.size() == 3)
+    {
+        car_width_ = car_dimensions[0].as&lt;double&gt;();
+        car_height_ = car_dimensions[1].as&lt;double&gt;();
+        car_depth_ = car_dimensions[2].as&lt;double&gt;();
+    }
+    if (person_dimensions.size() == 3)
+    {
+        person_width_ = person_dimensions[0].as&lt;double&gt;();
+        person_height_ = person_dimensions[1].as&lt;double&gt;();
+        person_depth_ = person_dimensions[2].as&lt;double&gt;();
+    }
+    if (truck_dimensions.size() == 3)
+    {
+        truck_width_ = truck_dimensions[0].as&lt;double&gt;();
+        truck_height_ = truck_dimensions[1].as&lt;double&gt;();
+        truck_depth_ = truck_dimensions[2].as&lt;double&gt;();
+    }
+
     if (name_space_str != "/")
     {
         if (name_space_str.substr(0, 2) == "//")
@@ -619,10 +703,6 @@ RosRangeVisionFusionApp::InitializeRosIo(ros::NodeHandle &amp;in_private_handle)
                                                          1,
                                                          &amp;RosRangeVisionFusionApp::IntrinsicsCallback, this);
 
-    /*image_subscriber_ = in_private_handle.subscribe("/image_raw",
-                                                    1,
-                                                    &amp;RosRangeVisionFusionApp::ImageCallback, this);*/
-
     ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, detected_objects_vision.c_str());
     ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, detected_objects_range.c_str());
     if (!sync_topics)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="23" deleted_lines="21">
				<diff>@@ -253,7 +253,6 @@ void publishDetectedObjects(const autoware_msgs::CloudClusterArray&amp; in_clusters)
     autoware_msgs::DetectedObject detected_object;
     detected_object.header = in_clusters.header;
     detected_object.label = "unknown";
-    detected_object.id = i;
     detected_object.score = 1.;
     detected_object.space_frame = in_clusters.header.frame_id;
     detected_object.pose = in_clusters.clusters[i].bounding_box.pose;
@@ -1301,29 +1300,32 @@ int main(int argc, char** argv)
   private_nh.param("clustering_ranges", str_ranges, std::string("[15,30,45,60]"));
   ROS_INFO("clustering_ranges: %s", str_ranges.c_str());
 
-  YAML::Node distances = YAML::Load(str_distances);
-  YAML::Node ranges = YAML::Load(str_ranges);
-  size_t distances_size = distances.size();
-  size_t ranges_size = ranges.size();
-  if (distances_size == 0 || ranges_size == 0)
+  if (_use_multiple_thres)
   {
-    ROS_ERROR("Invalid size of clustering_ranges or/and clustering_distance. \
+    YAML::Node distances = YAML::Load(str_distances);
+    YAML::Node ranges = YAML::Load(str_ranges);
+    size_t distances_size = distances.size();
+    size_t ranges_size = ranges.size();
+    if (distances_size == 0 || ranges_size == 0)
+    {
+      ROS_ERROR("Invalid size of clustering_ranges or/and clustering_distance. \
     The size of clustering distance and clustering_ranges shoule not be 0");
-    ros::shutdown();
-  }
-  if ((distances_size - ranges_size) != 1)
-  {
-    ROS_ERROR("Invalid size of clustering_ranges or/and clustering_distance. \
+      ros::shutdown();
+    }
+    if ((distances_size - ranges_size) != 1)
+    {
+      ROS_ERROR("Invalid size of clustering_ranges or/and clustering_distance. \
     Expecting that (distances_size - ranges_size) == 1 ");
-    ros::shutdown();
-  }
-  for (size_t i_distance = 0; i_distance &lt; distances_size; i_distance++)
-  {
-    _clustering_distances.push_back(distances[i_distance].as&lt;double&gt;());
-  }
-  for (size_t i_range = 0; i_range &lt; ranges_size; i_range++)
-  {
-    _clustering_ranges.push_back(ranges[i_range].as&lt;double&gt;());
+      ros::shutdown();
+    }
+    for (size_t i_distance = 0; i_distance &lt; distances_size; i_distance++)
+    {
+      _clustering_distances.push_back(distances[i_distance].as&lt;double&gt;());
+    }
+    for (size_t i_range = 0; i_range &lt; ranges_size; i_range++)
+    {
+      _clustering_ranges.push_back(ranges[i_range].as&lt;double&gt;());
+    }
   }
 
   _velodyne_transform_available = false;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" added_lines="48" deleted_lines="15">
				<diff>@@ -78,18 +78,44 @@ namespace integrated_viewer
         // Draw rectangles for each object
         for (const auto &amp;detected_object : detected_objects-&gt;objects)
         {
-            // Draw object information label
-            DrawLabel(detected_object, image);
+            if (detected_object.x &gt;= 0
+                &amp;&amp; detected_object.y &gt;= 0
+                &amp;&amp; detected_object.width &gt; 0
+                &amp;&amp; detected_object.height &gt; 0)
+            {
+                // Draw object information label
+                DrawLabel(detected_object, image);
+
+                int x2 = detected_object.x + detected_object.width;
+                if (x2 &gt;= image.cols)
+                    x2 = image.cols - 1;
+                int y2 = detected_object.y + detected_object.height;
+                if (y2 &gt;= image.rows)
+                    y2 = image.rows - 1;
+
+                if (detected_object.dimensions.x &gt; 0
+                    &amp;&amp; detected_object.dimensions.y &gt; 0
+                    &amp;&amp; detected_object.dimensions.z &gt; 0)
+                {
+                    cv::Mat image_roi = image(cv::Rect(cv::Point(detected_object.x, detected_object.y),
+                                                       cv::Point(x2,
+                                                                 y2)));
+                    cv::Mat color_fill(image_roi.size(), CV_8UC3,
+                                       cv::Scalar(detected_object.color.r, detected_object.color.g, detected_object.color.b));
+                    double alpha = 0.3;
+                    cv::addWeighted(color_fill, alpha, image_roi, 1.0 - alpha , 0.0, image_roi);
+                }
 
-            // Draw rectangle
-            cv::rectangle(image,
-                          cv::Point(detected_object.x, detected_object.y),
-                          cv::Point(detected_object.x + detected_object.width,
-                                    detected_object.y + detected_object.height),
-                          cv::Scalar(detected_object.color.r, detected_object.color.g, detected_object.color.b),
-                          kRectangleThickness,
-                          CV_AA,
-                          0);
+                // Draw rectangle
+                cv::rectangle(image,
+                              cv::Point(detected_object.x, detected_object.y),
+                              cv::Point(x2,
+                                        y2),
+                              cv::Scalar(detected_object.color.r, detected_object.color.g, detected_object.color.b),
+                              kRectangleThickness,
+                              CV_AA,
+                              0);
+            }
         }
     } // DrawRects::DrawImageRect()
 
@@ -125,7 +151,7 @@ namespace integrated_viewer
         cv::Point rectangle_origin(in_detected_object.x, in_detected_object.y);
         // label's property
         const int font_face = cv::FONT_HERSHEY_DUPLEX;
-        const double font_scale = 0.8;
+        const double font_scale = 0.7;
         const int font_thickness = 1;
         int font_baseline = 0;
         int icon_width = 40;
@@ -146,11 +172,14 @@ namespace integrated_viewer
                                        in_detected_object.pose.position.y*in_detected_object.pose.position.y);
 
         label_one &lt;&lt; in_detected_object.label;
+        if (in_detected_object.id &gt; 0)
+        {
+            label_one &lt;&lt; " " &lt;&lt; std::to_string(in_detected_object.id);
+        }
         if (distance &gt; 0.1)
         {
             label_two &lt;&lt; std::setprecision(2) &lt;&lt; distance &lt;&lt; "meters";
         }
-
         if (in_detected_object.label == "car" || in_detected_object.label == "truck")
         {
             OverlayImage(image, car_image_, image, label_origin);
@@ -192,14 +221,18 @@ namespace integrated_viewer
                     label_origin,
                     font_face,
                     font_scale,
-                    CV_RGB(255, 255, 255));
+                    CV_RGB(255, 255, 255),
+                    1,
+                    CV_AA);
         label_origin.y+= text_holder_rect.height / 3;
         cv::putText(image,
                     label_two.str(),
                     label_origin,
                     font_face,
                     font_scale,
-                    CV_RGB(255, 255, 255));
+                    CV_RGB(255, 255, 255),
+                    1,
+                    CV_AA);
 
     } // DrawRects::DrawLabel()
 } // end namespace integrated_viewer
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -84,7 +84,6 @@ class RosSsdApp
             {
                 autoware_msgs::DetectedObject obj;
                 obj.header = out_message.header;
-                obj.id = i;
                 obj.label = in_objects[i].GetClassString();
                 obj.score = in_objects[i].score;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8061ea06c02e9f259373a663a3e6c6b713e11f21" author="David">
		<msg>Persistent configuration and alphabetically ordered topic lists on ImageViewerPlugin (#1511)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\data_rate_checker_plugin\data_rate_checker_plugin.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\data_rate_checker_plugin\data_rate_checker_plugin.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -226,7 +226,7 @@ namespace integrated_viewer {
 
           timer_ = node_handle_.createWallTimer(ros::WallDuration(1.0),
                                                 &amp;DataRateCheckerPlugin::TimerCallback,
-                                               this);
+                                                this);
         }
       }
       if(config.mapGetInt ("Min rate", &amp;min_frequency)) {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" added_lines="140" deleted_lines="0">
				<diff>@@ -101,24 +101,28 @@ namespace integrated_viewer {
             // Check whether this topic is image
             if (topic_type.contains(kImageDataType) == true) {
                 image_topic_list &lt;&lt; topic_name;
+                image_topic_list.sort();
                 continue;
             }
 
             // Check whether this topic is rectangle
             if (topic_type.contains(kDetectedObjectDataTypeBase) == true) {
                 rect_topic_list &lt;&lt; topic_name;
+                rect_topic_list.sort();
                 continue;
             }
 
             // Check whether this topic is point cloud
             if (topic_type.contains(kPointDataType) == true) {
                 point_topic_list &lt;&lt; topic_name;
+                point_topic_list.sort();
                 continue;
             }
 
             // Check whether this topic is lane
             if (topic_type.contains(kLaneDataType) == true) {
                 lane_topic_list &lt;&lt; topic_name;
+                lane_topic_list.sort();
                 continue;
             }
         }
@@ -149,18 +153,41 @@ namespace integrated_viewer {
         if (image_topic_index != -1) {
             ui_.image_topic_combo_box_-&gt;setCurrentIndex(image_topic_index);
         }
+        else {
+          ui_.image_topic_combo_box_-&gt;setCurrentIndex(ui_.image_topic_combo_box_-&gt;findText(kBlankTopic));
+          image_sub_.shutdown();
+          // If blank name is selected as image topic, show default image
+          viewed_image_ = default_image_.clone();
+          default_image_shown_ = true;
+          ShowImageOnUi();
+        }
 
         if (rect_topic_index != -1) {
             ui_.rect_topic_combo_box_-&gt;setCurrentIndex(rect_topic_index);
         }
+        else {
+          ui_.rect_topic_combo_box_-&gt;setCurrentIndex(ui_.rect_topic_combo_box_-&gt;findText(kBlankTopic));
+          rect_sub_.shutdown();
+          detected_objects_msg_ = NULL;
+        }
 
         if (point_topic_index != -1) {
             ui_.point_topic_combo_box_-&gt;setCurrentIndex(point_topic_index);
         }
+        else {
+          ui_.point_topic_combo_box_-&gt;setCurrentIndex(ui_.point_topic_combo_box_-&gt;findText(kBlankTopic));
+          point_sub_.shutdown();
+          points_msg_ = NULL;
+        }
 
         if (lane_topic_index != -1) {
             ui_.lane_topic_combo_box_-&gt;setCurrentIndex(lane_topic_index);
         }
+        else {
+          ui_.lane_topic_combo_box_-&gt;setCurrentIndex(ui_.lane_topic_combo_box_-&gt;findText(kBlankTopic));
+          lane_sub_.shutdown();
+          lane_msg_ = NULL;
+        }
 
     } // ImageViewerPlugin::UpdateTopicList()
 
@@ -310,6 +337,119 @@ namespace integrated_viewer {
         return QObject::eventFilter(object, event);
     }
 
+    void ImageViewerPlugin::save(rviz::Config config) const {
+      rviz::Panel::save(config);
+      config.mapSetValue("Image topic", ui_.image_topic_combo_box_-&gt;currentText());
+      config.mapSetValue("Rect topic", ui_.rect_topic_combo_box_-&gt;currentText());
+      config.mapSetValue("Point topic", ui_.point_topic_combo_box_-&gt;currentText());
+      config.mapSetValue("Lane topic", ui_.lane_topic_combo_box_-&gt;currentText());
+      config.mapSetValue("Point size", ui_.point_size_spin_box_-&gt;value());
+    } // ImageViewerPlugin::save
+
+    void ImageViewerPlugin::load(const rviz::Config&amp; config) {
+      rviz::Panel::load(config);
+      QString image_topic;
+      QString rect_topic;
+      QString point_topic;
+      QString lane_topic;
+      int point_size;
+
+      if(config.mapGetString ("Image topic", &amp;image_topic))
+      {
+        // Extract selected topic name from combo box
+        std::string selected_topic = image_topic.toStdString();
+        if (selected_topic != kBlankTopic.toStdString() &amp;&amp; selected_topic != "") {
+          UpdateTopicList();
+          int topic_index = ui_.image_topic_combo_box_-&gt;findText(image_topic);
+          // If the load topic doesn't exist, load it anyway to wait for the topic to become active
+          if (topic_index == -1) {
+            QStringList dummy_topic_list;
+            dummy_topic_list &lt;&lt; image_topic;
+            ui_.image_topic_combo_box_-&gt;addItems(dummy_topic_list);
+            topic_index = ui_.image_topic_combo_box_-&gt;findText(image_topic);
+          }
+          ui_.image_topic_combo_box_-&gt;setCurrentIndex(topic_index);
+          default_image_shown_ = false;
+          image_sub_ = node_handle_.subscribe&lt;sensor_msgs::Image&gt;(selected_topic,
+                                                                  1,
+                                                                  &amp;ImageViewerPlugin::ImageCallback,
+                                                                  this);
+        }
+      }
+
+      if(config.mapGetString ("Rect topic", &amp;rect_topic))
+      {
+        // Extract selected topic name from combo box
+        std::string selected_topic = rect_topic.toStdString();
+        if (selected_topic != kBlankTopic.toStdString() &amp;&amp; selected_topic != "") {
+          UpdateTopicList();
+          int topic_index = ui_.rect_topic_combo_box_-&gt;findText(rect_topic);
+          // If the load topic doesn't exist, load it anyway to wait for the topic to become active
+          if (topic_index == -1) {
+            QStringList dummy_topic_list;
+            dummy_topic_list &lt;&lt; rect_topic;
+            ui_.rect_topic_combo_box_-&gt;addItems(dummy_topic_list);
+            topic_index = ui_.rect_topic_combo_box_-&gt;findText(rect_topic);
+          }
+          ui_.rect_topic_combo_box_-&gt;setCurrentIndex(topic_index);
+          // Switch booted callback function by topic name
+          detected_objects_msg_ = NULL;
+          rect_sub_ = node_handle_.subscribe&lt;autoware_msgs::DetectedObjectArray&gt;(selected_topic,
+                                                                       1,
+                                                                       &amp;ImageViewerPlugin::DetectedObjCallback,
+                                                                       this);
+        }
+      }
+
+      if(config.mapGetString ("Point topic", &amp;point_topic))
+      {
+        // Extract selected topic name from combo box
+        std::string selected_topic = point_topic.toStdString();
+        if (selected_topic != kBlankTopic.toStdString() &amp;&amp; selected_topic != "") {
+          UpdateTopicList();
+          int topic_index = ui_.image_topic_combo_box_-&gt;findText(point_topic);
+          // If the load topic doesn't exist, load it anyway to wait for the topic to become active
+          if (topic_index == -1) {
+            QStringList dummy_topic_list;
+            dummy_topic_list &lt;&lt; point_topic;
+            ui_.point_topic_combo_box_-&gt;addItems(dummy_topic_list);
+            topic_index = ui_.point_topic_combo_box_-&gt;findText(point_topic);
+          }
+          ui_.point_topic_combo_box_-&gt;setCurrentIndex(topic_index);
+          point_sub_ = node_handle_.subscribe&lt;autoware_msgs::PointsImage&gt;(selected_topic,
+                                                                          1,
+                                                                          &amp;ImageViewerPlugin::PointCallback,
+                                                                          this);
+        }
+      }
+
+      if(config.mapGetString ("Lane topic", &amp;lane_topic))
+      {
+        // Extract selected topic name from combo box
+        std::string selected_topic = lane_topic.toStdString();
+        if (selected_topic != kBlankTopic.toStdString() &amp;&amp; selected_topic != "") {
+          UpdateTopicList();
+          int topic_index = ui_.lane_topic_combo_box_-&gt;findText(lane_topic);
+          // If the load topic doesn't exist, load it anyway to wait for the topic to become active
+          if (topic_index == -1) {
+            QStringList dummy_topic_list;
+            dummy_topic_list &lt;&lt; point_topic;
+            ui_.lane_topic_combo_box_-&gt;addItems(dummy_topic_list);
+            topic_index = ui_.lane_topic_combo_box_-&gt;findText(lane_topic);
+          }
+          ui_.lane_topic_combo_box_-&gt;setCurrentIndex(topic_index);
+          lane_sub_ = node_handle_.subscribe&lt;autoware_msgs::ImageLaneObjects&gt;(selected_topic,
+                                                                              1,
+                                                                              &amp;ImageViewerPlugin::LaneCallback,
+                                                                              this);
+        }
+      }
+
+      if(config.mapGetInt ("Point_size", &amp;point_size)) {
+        ui_.point_size_spin_box_-&gt;setValue(point_size);
+      }
+    } // ImageViewerPlugin::load
+
 
 } // end namespace integrated_viewer
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" added_lines="6" deleted_lines="2">
				<diff>@@ -39,14 +39,14 @@ namespace integrated_viewer
 
     // override resize event
     virtual void resizeEvent(QResizeEvent *);
-    
+
   protected:
     // The function to update topic list that can be selected from the UI
     void UpdateTopicList(void);
 
     // The event filter to catch clicking on combo box
     bool eventFilter(QObject* object, QEvent* event);
-    
+
     // The Callback functions
     void ImageCallback(const sensor_msgs::Image::ConstPtr&amp; msg);
     void DetectedObjCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;msg);
@@ -74,6 +74,10 @@ namespace integrated_viewer
     ros::Subscriber point_sub_;
     ros::Subscriber lane_sub_;
 
+    // Save and load overrides
+    virtual void save(rviz::Config config) const;
+    virtual void load(const rviz::Config&amp; config);
+
   private:
     // The UI components
     Ui::image_viewer_form ui_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3471e19c289d53fa1a90f719461e6628050f71f5" author="David">
		<msg>[Fix] Minor fixes for RViz plugins (#1515)

* Fixed bug in persistant configuration for point size in ImageViewerPlugin

* Fix Topic Frequency label becoming obscured with smaller view sizes in DataRateCheckerPlugin.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -445,7 +445,7 @@ namespace integrated_viewer {
         }
       }
 
-      if(config.mapGetInt ("Point_size", &amp;point_size)) {
+      if(config.mapGetInt ("Point size", &amp;point_size)) {
         ui_.point_size_spin_box_-&gt;setValue(point_size);
       }
     } // ImageViewerPlugin::load
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6453b6733ccf8f62e7b03504400b53548d7a0e0f" author="Masaya Kataoka">
		<msg>add disable mode for diag_manager</msg>
		<modified_files>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\diag_manager.h" new_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\diag_manager.h" added_lines="10" deleted_lines="1">
				<diff>@@ -40,6 +40,8 @@ public:
     template&lt;typename T&gt;
     void DIAG_ASSERT_VALUE_RANGE(T min, T max, T value, int num)
     {
+        if(enable_diag_ == false)
+            return;
         std::vector&lt;int&gt; required_error_code = {INVALID_INITIAL_VALUE, INVALID_VALUE};
         if(check_error_code(num, required_error_code))
         {
@@ -61,6 +63,8 @@ public:
     template&lt;typename T&gt;
     void DIAG_ASSERT_VALUE_MIN(T min, T value, int num)
     {
+        if(enable_diag_ == false)
+            return;
         std::vector&lt;int&gt; required_error_code = {INVALID_INITIAL_VALUE, INVALID_VALUE};
         if(check_error_code(num, required_error_code))
         {
@@ -76,6 +80,8 @@ public:
     template&lt;typename T&gt;
     void DIAG_ASSERT_VALUE_MAX(T max, T value, int num)
     {
+        if(enable_diag_ == false)
+            return;
         std::vector&lt;int&gt; required_error_code = {INVALID_INITIAL_VALUE, INVALID_VALUE};
         if(check_error_code(num, required_error_code))
         {
@@ -91,6 +97,8 @@ public:
     template&lt;class T&gt;
     void DIAG_ASSERT_EXCEPTION(T exception,int num)
     {
+        if(enable_diag_ == false)
+            return;
         std::vector&lt;int&gt; required_error_code = {EXCEPTION};
         if(check_error_code(num, required_error_code))
         {
@@ -113,7 +121,8 @@ private:
     bool check_error_code(int requested_error_code, std::vector&lt;int&gt; right_categories);
     void publish_diag_(diag_info info);
     // check resource for diag_manager
-    void diag_resource(std::string target_resource_path);
+    bool diag_resource(std::string target_resource_path);
+    volatile bool enable_diag_;
     std::vector&lt;diag_info&gt; diag_info_;
     std::vector&lt;std::string&gt; diag_log_;
     ros::Publisher diag_pub_;
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\src\diag_manager.cpp" new_path="ros\src\common\libs\diagnostics_lib\diag_lib\src\diag_manager.cpp" added_lines="16" deleted_lines="7">
				<diff>@@ -2,8 +2,12 @@
 
 diag_manager::diag_manager()
 {
+    enable_diag_ = false;
     nh_.param&lt;std::string&gt;("/error_code_config_path", error_code_config_path_, std::string(""));
-    diag_resource(error_code_config_path_);
+    if(!diag_resource(error_code_config_path_))
+    {
+        return;
+    }
     YAML::Node config = YAML::LoadFile(error_code_config_path_.c_str());
     error_code_config_ = config[ros::this_node::getName()];
     try
@@ -44,6 +48,7 @@ diag_manager::diag_manager()
     }
     diag_pub_ = nh_.advertise&lt;diag_msgs::diag_error&gt;(ros::this_node::getName() + "/diag", 10);
     boost::thread rate_check_thread(boost::bind(&amp;diag_manager::check_rate_, this));;
+    enable_diag_ = true;
 }
 
 diag_manager::~diag_manager()
@@ -84,6 +89,8 @@ void diag_manager::check_rate_()
 
 void diag_manager::DIAG_LOW_RELIABILITY(int num)
 {
+    if(enable_diag_ == false)
+        return;    
     std::vector&lt;int&gt; required_error_code = {LOW_RELIABILITY};
     if(check_error_code(num, required_error_code))
     {
@@ -96,6 +103,8 @@ void diag_manager::DIAG_LOW_RELIABILITY(int num)
 
 void diag_manager::DIAG_RATE_CHECK(int num)
 {
+    if(enable_diag_ == false)
+        return;
     std::vector&lt;int&gt; required_error_code = {LOW_SUBSCRIBE_RATE, LOW_PUBLISH_RATE, LOW_OPERATION_CYCLE};
     if(check_error_code(num, required_error_code))
     {
@@ -180,6 +189,8 @@ void diag_manager::ADD_DIAG_LOG_WARN(std::string log_text)
 
 void diag_manager::DIAG_RESOURCE(std::string target_resource_path, int num)
 {
+    if(enable_diag_ == false)
+        return;
     std::vector&lt;int&gt; required_error_code = {RESOURCE_NOT_FOUND};
     if(check_error_code(num, required_error_code))
     {
@@ -209,7 +220,7 @@ void diag_manager::DIAG_RESOURCE(std::string target_resource_path, int num)
     }
 }
 
-void diag_manager::diag_resource(std::string target_resource_path)
+bool diag_manager::diag_resource(std::string target_resource_path)
 {
     namespace fs = boost::filesystem;
     fs::path path(target_resource_path);
@@ -217,13 +228,11 @@ void diag_manager::diag_resource(std::string target_resource_path)
     const bool result = fs::exists(path, error);
     if (!result || error)
     {
-        //ROS_ERROR_STREAM("required resource " &lt;&lt; path &lt;&lt; " does not found.");
         ADD_DIAG_LOG_ERROR("required resource " + target_resource_path + " does not found.");
-        ROS_ERROR_STREAM("shutdonw " &lt;&lt; ros::this_node::getName());
-        WRITE_LOG();
-        std::exit(-1);
+        ADD_DIAG_LOG_ERROR("disable diag module in " + ros::this_node::getName());
+        return false;
     }
-    return;
+    return true;
 }
 
 bool diag_manager::check_error_code(int requested_error_number, std::vector&lt;int&gt; right_categories)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5bf3bd5ccb678c61a8793c20e77e08fce3357e40" author="Masaya Kataoka">
		<msg>dd diag_filter to the fake_subscriber</msg>
		<modified_files>
			<file old_path="ros\src\common\libs\diagnostics_lib\fake_autoware_nodes\include\fake_autoware_nodes\fake_subscriber.h" new_path="ros\src\common\libs\diagnostics_lib\fake_autoware_nodes\include\fake_autoware_nodes\fake_subscriber.h" added_lines="5" deleted_lines="0">
				<diff>@@ -3,6 +3,10 @@
 
 //headers in diag_lib
 #include &lt;diag_lib/diag_manager.h&gt;
+#include &lt;diag_lib/diag_filter.h&gt;
+
+//hdaders in diag_msg
+#include &lt;diag_msgs/diag_error.h&gt;
 
 //headers in std_msgs
 #include &lt;std_msgs/Float64.h&gt;
@@ -20,6 +24,7 @@ class fake_subscriber
         ros::NodeHandle nh_;
         ros::Subscriber fake_sub_;
         diag_manager diag_manager_;
+        diag_filter diag_filter_;
 };
 
 #endif  //FAKE_SUBSCRIBER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="91c244ccd1725d43afbca18cee47dec211a38277" author="Masaya Kataoka">
		<msg>add filter function by using node number</msg>
		<modified_files>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\diag_filter.h" new_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\diag_filter.h" added_lines="11" deleted_lines="1">
				<diff>@@ -2,17 +2,27 @@
 #define DIAG_FILTER_H_INCLUDED
 
 //headers in diag_msgs
+#include &lt;diag_msgs/diag.h&gt;
 #include &lt;diag_msgs/diag_error.h&gt;
+#include &lt;diag_msgs/diag_node_errors.h&gt;
 
 //headers in ROS
 #include &lt;ros/ros.h&gt;
 
+//headers in Boost
+#include &lt;boost/optional.hpp&gt;
+
 class diag_filter
 {
 public:
     diag_filter();
     ~diag_filter();
+    boost::optional&lt;diag_msgs::diag_node_errors&gt; filter(diag_msgs::diag diag, std::string target_node);
+    boost::optional&lt;diag_msgs::diag_node_errors&gt; filter(diag_msgs::diag diag, int target_node_number);
 private:
-
+    ros::NodeHandle nh_;
+    bool check_resource_(std::string target_resource_path);
+    volatile bool enable_;
+    std::string error_code_config_path_;
 };
 #endif  //DIAG_FILTER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\src\diag_filter.cpp" new_path="ros\src\common\libs\diagnostics_lib\diag_lib\src\diag_filter.cpp" added_lines="39" deleted_lines="1">
				<diff>@@ -4,12 +4,50 @@
 // headers in YAML-CPP
 #include &lt;yaml-cpp/yaml.h&gt;
 
+//headers in boost
+#include &lt;boost/filesystem.hpp&gt;
+
 diag_filter::diag_filter()
 {
-
+    nh_.param&lt;std::string&gt;("/error_code_config_path", error_code_config_path_, std::string(""));
+    if(check_resource_(error_code_config_path_))
+    {
+        enable_ = true;
+    }
+    else
+    {
+        enable_ = false;
+    }
 }
 
 diag_filter::~diag_filter()
 {
 
+}
+
+bool diag_filter::check_resource_(std::string target_resource_path)
+{
+    namespace fs = boost::filesystem;
+    fs::path path(target_resource_path);
+    boost::system::error_code error;
+    const bool result = fs::exists(path, error);
+    if (!result || error)
+        return false;
+    return true;
+}
+
+boost::optional&lt;diag_msgs::diag_node_errors&gt; diag_filter::filter(diag_msgs::diag diag, std::string target_node)
+{
+    boost::optional&lt;diag_msgs::diag_node_errors&gt; ret;
+    return ret;
+}
+
+boost::optional&lt;diag_msgs::diag_node_errors&gt; diag_filter::filter(diag_msgs::diag diag, int target_node_number)
+{
+    for(int i=0; i&lt;diag.nodes.size() ; i++)
+    {
+        if(diag.nodes[i].node_number == target_node_number)
+            return diag.nodes[i];
+    }
+    return boost::none;
 }
\ No newline at end of file
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="531184d6665114712a282f7f0541c20dca163eb9" author="Masaya Kataoka">
		<msg>add filter to the fake_autoware_node</msg>
		<modified_files>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\diag_filter.h" new_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\diag_filter.h" added_lines="4" deleted_lines="0">
				<diff>@@ -12,6 +12,9 @@
 //headers in Boost
 #include &lt;boost/optional.hpp&gt;
 
+//headers in STL
+#include &lt;map&gt;
+
 class diag_filter
 {
 public:
@@ -20,6 +23,7 @@ public:
     boost::optional&lt;diag_msgs::diag_node_errors&gt; filter(diag_msgs::diag diag, std::string target_node);
     boost::optional&lt;diag_msgs::diag_node_errors&gt; filter(diag_msgs::diag diag, int target_node_number);
 private:
+    std::map&lt;std::string,int&gt; node_number_data_;
     ros::NodeHandle nh_;
     bool check_resource_(std::string target_resource_path);
     volatile bool enable_;
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\src\diag_filter.cpp" new_path="ros\src\common\libs\diagnostics_lib\diag_lib\src\diag_filter.cpp" added_lines="15" deleted_lines="2">
				<diff>@@ -17,6 +17,20 @@ diag_filter::diag_filter()
     else
     {
         enable_ = false;
+        return;
+    }
+    YAML::Node config = YAML::LoadFile(error_code_config_path_.c_str());
+    try
+    {
+        for(YAML::const_iterator it=config.begin();it != config.end();++it)
+        {
+            YAML::Node single_node_data = config[it-&gt;first.as&lt;std::string&gt;()];
+            node_number_data_[it-&gt;first.as&lt;std::string&gt;()] = single_node_data["node_number"].as&lt;int&gt;();
+        }
+    }
+    catch(...)
+    {
+        ROS_ERROR_STREAM("Failed to parse error code yaml file.");
     }
 }
 
@@ -38,8 +52,7 @@ bool diag_filter::check_resource_(std::string target_resource_path)
 
 boost::optional&lt;diag_msgs::diag_node_errors&gt; diag_filter::filter(diag_msgs::diag diag, std::string target_node)
 {
-    boost::optional&lt;diag_msgs::diag_node_errors&gt; ret;
-    return ret;
+    return filter(diag,node_number_data_[target_node]);
 }
 
 boost::optional&lt;diag_msgs::diag_node_errors&gt; diag_filter::filter(diag_msgs::diag diag, int target_node_number)
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\src\watchdog.cpp" new_path="ros\src\common\libs\diagnostics_lib\diag_lib\src\watchdog.cpp" added_lines="4" deleted_lines="1">
				<diff>@@ -104,7 +104,10 @@ void watchdog::publish_diag_()
                     errors.errors.push_back(error);
                 }
             }
-            diag_msg.nodes.push_back(errors);
+            if(errors.errors.size() != 0)
+            {
+                diag_msg.nodes.push_back(errors);
+            }
         }
         diag_msg.header.stamp = ros::Time::now();
         diag_pub_.publish(diag_msg);
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\fake_autoware_nodes\include\fake_autoware_nodes\fake_subscriber.h" new_path="ros\src\common\libs\diagnostics_lib\fake_autoware_nodes\include\fake_autoware_nodes\fake_subscriber.h" added_lines="4" deleted_lines="1">
				<diff>@@ -5,8 +5,9 @@
 #include &lt;diag_lib/diag_manager.h&gt;
 #include &lt;diag_lib/diag_filter.h&gt;
 
-//hdaders in diag_msg
+//headers in diag_msg
 #include &lt;diag_msgs/diag_error.h&gt;
+#include &lt;diag_msgs/diag.h&gt;
 
 //headers in std_msgs
 #include &lt;std_msgs/Float64.h&gt;
@@ -20,9 +21,11 @@ class fake_subscriber
         fake_subscriber();
         ~fake_subscriber();
     private:
+        void diag_callback_(const diag_msgs::diagConstPtr msg);
         void callback_(const std_msgs::Float64ConstPtr msg);
         ros::NodeHandle nh_;
         ros::Subscriber fake_sub_;
+        ros::Subscriber diag_sub_;
         diag_manager diag_manager_;
         diag_filter diag_filter_;
 };
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\fake_autoware_nodes\src\fake_subscriber.cpp" new_path="ros\src\common\libs\diagnostics_lib\fake_autoware_nodes\src\fake_subscriber.cpp" added_lines="11" deleted_lines="0">
				<diff>@@ -2,6 +2,7 @@
 
 fake_subscriber::fake_subscriber()
 {
+    diag_sub_ = nh_.subscribe("watchdog_node/diag/all", 1, &amp;fake_subscriber::diag_callback_, this);
     fake_sub_ = nh_.subscribe(ros::this_node::getName()+"/data", 1, &amp;fake_subscriber::callback_, this);
 }
 
@@ -14,4 +15,14 @@ void fake_subscriber::callback_(const std_msgs::Float64ConstPtr msg)
 {
     diag_manager_.DIAG_ASSERT_VALUE_MIN(0.0, msg-&gt;data, 0);
     return;
+}
+
+void fake_subscriber::diag_callback_(const diag_msgs::diagConstPtr msg)
+{
+    boost::optional&lt;diag_msgs::diag_node_errors&gt; error = diag_filter_.filter(*msg, ros::this_node::getName());
+    if(error)
+    {
+        ROS_ERROR_STREAM(error.get());
+    }
+    return;
 }
\ No newline at end of file
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="15585d382001b69f2418e220cf057164d6530fe3" author="Abraham Monrroy">
		<msg>Added support for custom class "names files" in darknet format. (#1535)

* Added support for custom class "names files" in darknet format.

* Fixed launch file, not including source topic arg

* Fix the default path of coco.names (#1550)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.cpp" added_lines="36" deleted_lines="2">
				<diff>@@ -183,7 +183,17 @@ void Yolo3DetectorNode::convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;fl
             obj.color.a = 1.0f;
 
             obj.score = in_objects[i].score;
-            obj.label = in_objects[i].GetClassString();
+            if (use_coco_names_)
+            {
+                obj.label = in_objects[i].GetClassString();
+            }
+            else
+            {
+                if (in_objects[i].class_type &lt; custom_names_.size())
+                    obj.label = custom_names_[in_objects[i].class_type];
+                else
+                    obj.label = "unknown label";
+            }
 
             out_message.objects.push_back(obj);
 
@@ -279,6 +289,18 @@ void Yolo3DetectorNode::config_cb(const autoware_msgs::ConfigSsd::ConstPtr&amp; para
     score_threshold_ = param-&gt;score_threshold;
 }
 
+std::vector&lt;std::string&gt; Yolo3DetectorNode::read_custom_names_file(const std::string&amp; in_names_path)
+{
+    std::ifstream file(in_names_path);
+    std::string str;
+    std::vector&lt;std::string&gt; names;
+    while (std::getline(file, str))
+    {
+        names.push_back(str);
+        std::cout &lt;&lt; str &lt;&lt;  std::endl;
+    }
+    return names;
+}
 
 void Yolo3DetectorNode::Run()
 {
@@ -298,7 +320,7 @@ void Yolo3DetectorNode::Run()
     }
 
     std::string network_definition_file;
-    std::string pretrained_model_file;
+    std::string pretrained_model_file, names_file;
     if (private_node_handle.getParam("network_definition_file", network_definition_file))
     {
         ROS_INFO("Network Definition File (Config): %s", network_definition_file.c_str());
@@ -318,6 +340,18 @@ void Yolo3DetectorNode::Run()
         return;
     }
 
+    if (private_node_handle.getParam("names_file", names_file))
+    {
+        ROS_INFO("Names File: %s", names_file.c_str());
+        use_coco_names_ = false;
+        custom_names_ = read_custom_names_file(names_file);
+    }
+    else
+    {
+        ROS_INFO("No Names file was received. Using default COCO names.");
+        use_coco_names_ = true;
+    }
+
     private_node_handle.param&lt;float&gt;("score_threshold", score_threshold_, 0.5);
     ROS_INFO("[%s] score_threshold: %f",__APP_NAME__, score_threshold_);
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.h" added_lines="22" deleted_lines="17">
				<diff>@@ -99,30 +99,35 @@ namespace darknet {
 }  // namespace darknet
 
 class Yolo3DetectorNode {
-    ros::Subscriber subscriber_image_raw_;
-    ros::Subscriber subscriber_yolo_config_;
-    ros::Publisher publisher_objects_;
-    ros::NodeHandle node_handle_;
+    ros::Subscriber                 subscriber_image_raw_;
+    ros::Subscriber                 subscriber_yolo_config_;
+    ros::Publisher                  publisher_objects_;
+    ros::NodeHandle                 node_handle_;
 
-    darknet::Yolo3Detector yolo_detector_;
+    darknet::Yolo3Detector          yolo_detector_;
 
     image darknet_image_ = {};
 
-    float score_threshold_;
-    float nms_threshold_;
-    double image_ratio_;//resdize ratio used to fit input image to network input size
-    uint32_t image_top_bottom_border_;//black strips added to the input image to maintain aspect ratio while resizing it to fit the network input size
-    uint32_t image_left_right_border_;
-    std::vector&lt;cv::Scalar&gt; colors_;
+    float                           score_threshold_;
+    float                           nms_threshold_;
+    double                          image_ratio_;//resize ratio used to fit input image to network input size
+    uint32_t                        image_top_bottom_border_;//black strips added to the input image to maintain aspect ratio while resizing it to fit the network input size
+    uint32_t                        image_left_right_border_;
+    std::vector&lt;cv::Scalar&gt;         colors_;
 
+    std::vector&lt;std::string&gt;        custom_names_;
+    bool                            use_coco_names_;
 
-    void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, autoware_msgs::DetectedObjectArray&amp; out_message);
-    void rgbgr_image(image&amp; im);
-    image convert_ipl_to_image(const sensor_msgs::ImageConstPtr&amp; msg);
-    void image_callback(const sensor_msgs::ImageConstPtr&amp; in_image_message);
-    void config_cb(const autoware_msgs::ConfigSsd::ConstPtr&amp; param);
+
+    void                            convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects,
+                                      autoware_msgs::DetectedObjectArray&amp; out_message);
+    void                            rgbgr_image(image&amp; im);
+    image                           convert_ipl_to_image(const sensor_msgs::ImageConstPtr&amp; msg);
+    void                            image_callback(const sensor_msgs::ImageConstPtr&amp; in_image_message);
+    void                            config_cb(const autoware_msgs::ConfigSsd::ConstPtr&amp; param);
+    std::vector&lt;std::string&gt;        read_custom_names_file(const std::string&amp; in_path);
 public:
-    void Run();
+    void    Run();
 };
 
 #endif  // DARKNET_YOLO3_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c8321638979afe2c43e96b71170be2315627f2b1" author="Akihito OHSATO">
		<msg>Fix condition for pcl::PCA, issue:#1604</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\cluster.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\cluster.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -264,7 +264,7 @@ void Cluster::SetCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_origin_cloud
   current_cluster-&gt;is_dense = true;
 
   // Get EigenValues, eigenvectors
-  if (current_cluster-&gt;points.size() &gt; 0)
+  if (current_cluster-&gt;points.size() &gt; 3)
   {
     pcl::PCA&lt;pcl::PointXYZ&gt; current_cluster_pca;
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr current_cluster_mono(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="94ce2a5d9725ef821e5c00f911727f895cea29f8" author="Akihito OHSATO">
		<msg>Fix multiple definition</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -667,7 +667,7 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
           clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_distance);
     }
 #else
-    std::vector&lt;ClusterPtr&gt; all_clusters =
+    all_clusters =
         clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_distance);
 #endif
   }
@@ -711,10 +711,10 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
       }
     }
 
+    std::vector&lt;ClusterPtr&gt; local_clusters;
     for (unsigned int i = 0; i &lt; cloud_segments_array.size(); i++)
     {
 #ifdef GPU_CLUSTERING
-      std::vector&lt;ClusterPtr&gt; local_clusters;
       if (_use_gpu)
       {
         local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
@@ -726,7 +726,7 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
                                          in_out_centroids, _clustering_distances[i]);
       }
 #else
-      std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColor(
+      local_clusters = clusterAndColor(
           cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_distances[i]);
 #endif
       all_clusters.insert(all_clusters.end(), local_clusters.begin(), local_clusters.end());
@@ -1309,7 +1309,7 @@ int main(int argc, char** argv)
     if (distances_size == 0 || ranges_size == 0)
     {
       ROS_ERROR("Invalid size of clustering_ranges or/and clustering_distance. \
-    The size of clustering distance and clustering_ranges shoule not be 0");
+    The size of clustering dista_use_multiple_thrnce and clustering_ranges shoule not be 0");
       ros::shutdown();
     }
     if ((distances_size - ranges_size) != 1)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b4f602f7ba14136b146a74e38daf3dc42c0afb41" author="amc-nu">
		<msg>* Fixed typo
* Changed default values</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1309,7 +1309,7 @@ int main(int argc, char** argv)
     if (distances_size == 0 || ranges_size == 0)
     {
       ROS_ERROR("Invalid size of clustering_ranges or/and clustering_distance. \
-    The size of clustering dista_use_multiple_thrnce and clustering_ranges shoule not be 0");
+    The size of clustering distance and clustering_ranges should not be 0");
       ros::shutdown();
     }
     if ((distances_size - ranges_size) != 1)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3d4dd614aeae5662a85755545d443939e6bd7dd7" author="Abraham Monrroy">
		<msg>renamed topics to match, sensing workflow (#1600)

[fix] renamed topics to match, sensing workflow on CompareMapFilter</msg>
		<modified_files>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\compare_map_filter\compare_map_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\compare_map_filter\compare_map_filter.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -91,8 +91,8 @@ CompareMapFilter::CompareMapFilter()
   config_sub_ = nh_.subscribe("/config/compare_map_filter", 10, &amp;CompareMapFilter::configCallback, this);
   sensor_points_sub_ = nh_.subscribe("/points_raw", 1, &amp;CompareMapFilter::sensorPointsCallback, this);
   map_sub_ = nh_.subscribe("/points_map", 10, &amp;CompareMapFilter::pointsMapCallback, this);
-  match_points_pub_ = nh_.advertise&lt;sensor_msgs::PointCloud2&gt;("/match_points", 10);
-  unmatch_points_pub_ = nh_.advertise&lt;sensor_msgs::PointCloud2&gt;("/unmatch_points", 10);
+  match_points_pub_ = nh_.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_ground", 10);
+  unmatch_points_pub_ = nh_.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_no_ground", 10);
 }
 
 void CompareMapFilter::configCallback(const autoware_msgs::ConfigCompareMapFilter::ConstPtr&amp; config_msg_ptr)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a23c5f09c1b70ccf99002a2520e395e12f92f43b" author="Abraham Monrroy">
		<msg>include fstream header (#1608)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.h" added_lines="1" deleted_lines="0">
				<diff>@@ -38,6 +38,7 @@
 
 #define __APP_NAME__ "vision_darknet_detect"
 
+#include &lt;fstream&gt;
 #include &lt;cstdint&gt;
 #include &lt;cstdlib&gt;
 #include &lt;string&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6583285db5a7d9728e0892bb4654e69281d71c15" author="Kosuke Murakami">
		<msg>[Feature] DetectedObject type immukfpda (#1582)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\imm_ukf_pda.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\imm_ukf_pda.h" added_lines="86" deleted_lines="36">
				<diff>@@ -1,3 +1,33 @@
+/*
+ *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 #ifndef OBJECT_TRACKING_IMM_UKF_JPDAF_H
 #define OBJECT_TRACKING_IMM_UKF_JPDAF_H
 
@@ -10,12 +40,11 @@
 
 #include &lt;tf/transform_listener.h&gt;
 
-#include "autoware_msgs/CloudCluster.h"
-#include "autoware_msgs/CloudClusterArray.h"
-
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 
+#include &lt;visualization_msgs/MarkerArray.h&gt;
+
 #include "autoware_msgs/DetectedObject.h"
 #include "autoware_msgs/DetectedObjectArray.h"
 
@@ -24,88 +53,109 @@
 class ImmUkfPda
 {
 private:
+  int target_id_;
   bool init_;
   double timestamp_;
 
   std::vector&lt;UKF&gt; targets_;
 
   // probabilistic data association params
-  double gating_thres_;           // 9.22
-  double gate_probability_;       // 0.99;
-  double detection_probability_;  // 0.9;
+  double gating_thres_;
+  double gate_probability_;
+  double detection_probability_;
 
   // bbox association param
-  double distance_thres_;  // 0.25;
-  int life_time_thres_;    // 8;
-  // bbox update params
-  double bb_yaw_change_thres_;  // 0.2;
-
-  double static_distance_thres_;
+  double distance_thres_;
+  int life_time_thres_;
 
+  // bbox update params
+  double bb_yaw_change_thres_;
+  double static_velocity_thres_;
   double init_yaw_;
 
   // Tracking state paramas
   int stable_num_;
   int lost_num_;
 
+  // switch sukf and ImmUkfPda
+  bool use_sukf_;
+
+  // whether if publish debug ros markers
+  bool is_debug_;
+
+  // prevent explode param for ukf
+  double prevent_explosion_thres_;
+
   std::string input_topic_;
   std::string output_topic_;
 
   std::string pointcloud_frame_;
   std::string tracking_frame_;
 
-  tf::TransformListener* tf_listener_;
+  tf::TransformListener tf_listener_;
+  tf::StampedTransform local2global_;
 
   ros::NodeHandle node_handle_;
-  ros::Subscriber sub_cloud_array_;
+  ros::Subscriber sub_detected_array_;
   ros::Publisher pub_object_array_;
   ros::Publisher pub_jskbbox_array_;
-
-  void callback(const autoware_msgs::CloudClusterArray&amp; input);
-  void transformPoseToGlobal(const autoware_msgs::CloudClusterArray&amp; input,
-                                   autoware_msgs::CloudClusterArray&amp; transformed_input);
+  ros::Publisher pub_adas_direction_array_;
+  ros::Publisher pub_adas_prediction_array_;
+  ros::Publisher pub_points_array_;
+  ros::Publisher pub_texts_array_;
+
+  void callback(const autoware_msgs::DetectedObjectArray&amp; input);
+  void setPredictionObject();
+  void relayJskbbox(const autoware_msgs::DetectedObjectArray&amp; input,
+                    jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output);
+  void transformPoseToGlobal(const autoware_msgs::DetectedObjectArray&amp; input,
+                             autoware_msgs::DetectedObjectArray&amp; transformed_input);
   void transformPoseToLocal(jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                             autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
-  void findMaxZandS(const UKF &amp;target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s);
-  void measurementValidation(const autoware_msgs::CloudClusterArray&amp; input, UKF&amp; target, const bool second_init,
+  void measurementValidation(const autoware_msgs::DetectedObjectArray&amp; input, UKF&amp; target, const bool second_init,
                              const Eigen::VectorXd&amp; max_det_z, const Eigen::MatrixXd&amp; max_det_s,
-                             std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, std::vector&lt;bool&gt;&amp; matching_vec);
-  void filterPDA(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
-                 std::vector&lt;double&gt;&amp; lambda_vec);
-  void getNearestEuclidCluster(const UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
-                               autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist);
+                             std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, std::vector&lt;bool&gt;&amp; matching_vec);
+  void getNearestEuclidCluster(const UKF&amp; target, const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec,
+                               autoware_msgs::DetectedObject&amp; object, double&amp; min_dist);
   void getRightAngleBBox(const std::vector&lt;double&gt; nearest_bbox, std::vector&lt;double&gt;&amp; rightAngle_bbox);
-  void associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, UKF&amp; target);
+  void associateBB(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, UKF&amp; target);
   double getBBoxYaw(const UKF target);
   double getJskBBoxArea(const jsk_recognition_msgs::BoundingBox&amp; jsk_bb);
   double getJskBBoxYaw(const jsk_recognition_msgs::BoundingBox&amp; jsk_bb);
   void updateBB(UKF&amp; target);
   void mergeOverSegmentation(const std::vector&lt;UKF&gt; targets);
 
-  void updateLabel(const UKF&amp; target, autoware_msgs::DetectedObject&amp; dd);
   void updateJskLabel(const UKF&amp; target, jsk_recognition_msgs::BoundingBox&amp; bb);
-  bool isVisible(const UKF&amp; target);
 
-  void initTracker(const autoware_msgs::CloudClusterArray&amp; input, double timestamp);
-  void secondInit(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, double dt);
+  void initTracker(const autoware_msgs::DetectedObjectArray&amp; input, double timestamp);
+  void secondInit(UKF&amp; target, const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, double dt);
 
-  void updateTrackingNum(const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, UKF&amp; target);
+  void updateTrackingNum(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, UKF&amp; target);
 
-  void probabilisticDataAssociation(const autoware_msgs::CloudClusterArray&amp; input, const double dt, const double det_explode_param,
-                                    std::vector&lt;bool&gt;&amp; matching_vec, std::vector&lt;double&gt;&amp; lambda_vec, UKF&amp; target,
+  void probabilisticDataAssociation(const autoware_msgs::DetectedObjectArray&amp; input, const double dt,
+                                    std::vector&lt;bool&gt;&amp; matching_vec,
+                                    std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; lambda_vec, UKF&amp; target,
                                     bool&amp; is_skip_target);
-  void makeNewTargets(const double timestamp, const autoware_msgs::CloudClusterArray&amp; input, const std::vector&lt;bool&gt;&amp; matching_vec);
+  void makeNewTargets(const double timestamp, const autoware_msgs::DetectedObjectArray&amp; input,
+                      const std::vector&lt;bool&gt;&amp; matching_vec);
 
   void staticClassification();
 
-  void makeOutput(const autoware_msgs::CloudClusterArray&amp; input, jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
+  void makeOutput(const autoware_msgs::DetectedObjectArray&amp; input,
+                  jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                   autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
 
-  void tracker(const autoware_msgs::CloudClusterArray&amp; transformed_input, jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
+  void removeUnnecessaryTarget();
+
+  void pubDebugRosMarker(const autoware_msgs::DetectedObjectArray&amp; input);
+
+  void tracker(const autoware_msgs::DetectedObjectArray&amp; transformed_input,
+               jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
 
 public:
   ImmUkfPda();
+  void run();
 };
 
 #endif /* OBJECT_TRACKING_IMM_UKF_JPDAF_H */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\ukf.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\ukf.h" added_lines="125" deleted_lines="38">
				<diff>@@ -1,63 +1,112 @@
+/*
+ *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 #ifndef OBJECT_TRACKING_UKF_H
 #define OBJECT_TRACKING_UKF_H
 
 #include "Eigen/Dense"
+#include &lt;ros/ros.h&gt;
 #include &lt;vector&gt;
 #include &lt;string&gt;
 #include &lt;fstream&gt;
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl/point_cloud.h&gt;
 
+#include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 
+#include "autoware_msgs/DetectedObject.h"
+
+enum TrackingState : int
+{
+  Die = 0,     // No longer tracking
+  Init = 1,    // Start tracking
+  Stable = 4,  // Stable tracking
+  Lost = 10,   // About to lose target
+};
+
 class UKF
 {
+  /*
+  cv: Constant Velocity
+  ctrv: Constatnt Turn Rate and Velocity
+  rm: Random Motion
+  */
+
 public:
-  ///* initially set to false, set to true in first call of ProcessMeasurement
+  int ukf_id_;
+
+  //* initially set to false, set to true in first call of ProcessMeasurement
   bool is_initialized_;
 
-  //    ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
+  //* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
   Eigen::MatrixXd x_merge_;
 
-  ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
+  //* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
   Eigen::MatrixXd x_cv_;
 
-  ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
+  //* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
   Eigen::MatrixXd x_ctrv_;
 
-  ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
+  //* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
   Eigen::MatrixXd x_rm_;
 
-  //    ///* state covariance matrix
+  //* state covariance matrix
   Eigen::MatrixXd p_merge_;
 
-  ///* state covariance matrix
+  //* state covariance matrix
   Eigen::MatrixXd p_cv_;
 
-  ///* state covariance matrix
+  //* state covariance matrix
   Eigen::MatrixXd p_ctrv_;
 
-  ///* state covariance matrix
+  //* state covariance matrix
   Eigen::MatrixXd p_rm_;
 
-  ///* predicted sigma points matrix
+  //* predicted sigma points matrix
   Eigen::MatrixXd x_sig_pred_cv_;
 
-  ///* predicted sigma points matrix
+  //* predicted sigma points matrix
   Eigen::MatrixXd x_sig_pred_ctrv_;
 
-  ///* predicted sigma points matrix
+  //* predicted sigma points matrix
   Eigen::MatrixXd x_sig_pred_rm_;
 
-  ///* time when the state is true, in us
+  //* time when the state is true, in us
   long long time_;
 
-  ///* Process noise standard deviation longitudinal acceleration in m/s^2
+  //* Process noise standard deviation longitudinal acceleration in m/s^2
   double std_a_cv_;
   double std_a_ctrv_;
   double std_a_rm_;
 
-
   // CTRV
   double std_ctrv_yawdd_;
   // CV
@@ -65,27 +114,22 @@ public:
 
   double std_rm_yawdd_;
 
-  ///* Laser measurement noise standard deviation position1 in m
+  //* Laser measurement noise standard deviation position1 in m
   double std_laspx_;
 
-  ///* Laser measurement noise standard deviation position2 in m
+  //* Laser measurement noise standard deviation position2 in m
   double std_laspy_;
 
-  ///* Weights of sigma points
-  Eigen::VectorXd weights_;
+  //* Weights of sigma points
+  Eigen::VectorXd weights_c_;
+  Eigen::VectorXd weights_s_;
 
-  ///* State dimension
+  //* State dimension
   int n_x_;
 
-  ///* Augmented state dimension
-  int n_aug_;
-
-  ///* Sigma point spreading parameter
+  //* Sigma point spreading parameter
   double lambda_;
 
-  ///* Augmented sigma point spreading parameter
-  double lambda_aug_;
-
   int count_;
   int count_empty_;
 
@@ -111,8 +155,6 @@ public:
   double mode_prob_ctrv_;
   double mode_prob_rm_;
 
-  std::vector&lt;double&gt; ini_u_;
-
   std::vector&lt;double&gt; p1_;
 
   std::vector&lt;double&gt; p2_;
@@ -154,7 +196,7 @@ public:
 
   // for env classification
   Eigen::VectorXd init_meas_;
-  double dist_from_init_;
+  std::vector&lt;double&gt; vel_history_;
 
   std::vector&lt;Eigen::VectorXd&gt; local2local_;
   std::vector&lt;double&gt; local2localYawVec_;
@@ -163,6 +205,38 @@ public:
 
   int tracking_num_;
 
+  Eigen::VectorXd cv_meas_;
+  Eigen::VectorXd ctrv_meas_;
+  Eigen::VectorXd rm_meas_;
+
+  Eigen::MatrixXd q_cv_;
+  Eigen::MatrixXd q_ctrv_;
+  Eigen::MatrixXd q_rm_;
+
+  Eigen::MatrixXd r_cv_;
+  Eigen::MatrixXd r_ctrv_;
+  Eigen::MatrixXd r_rm_;
+
+  double nis_cv_;
+  double nis_ctrv_;
+  double nis_rm_;
+
+  Eigen::MatrixXd new_x_sig_cv_;
+  Eigen::MatrixXd new_x_sig_ctrv_;
+  Eigen::MatrixXd new_x_sig_rm_;
+
+  Eigen::MatrixXd new_z_sig_cv_;
+  Eigen::MatrixXd new_z_sig_ctrv_;
+  Eigen::MatrixXd new_z_sig_rm_;
+
+  Eigen::VectorXd new_z_pred_cv_;
+  Eigen::VectorXd new_z_pred_ctrv_;
+  Eigen::VectorXd new_z_pred_rm_;
+
+  Eigen::MatrixXd new_s_cv_;
+  Eigen::MatrixXd new_s_ctrv_;
+  Eigen::MatrixXd new_s_rm_;
+
   /**
    * Constructor
    */
@@ -170,7 +244,7 @@ public:
 
   void updateYawWithHighProb();
 
-  void initialize(const Eigen::VectorXd&amp; z, const double timestamp);
+  void initialize(const Eigen::VectorXd&amp; z, const double timestamp, const int target_ind);
 
   void updateModeProb(const std::vector&lt;double&gt;&amp; lambda_vec);
 
@@ -180,23 +254,36 @@ public:
 
   void interaction();
 
+  void predictionSUKF(const double dt);
+
   void predictionIMMUKF(const double dt);
 
-  void updateIMMUKF(const std::vector&lt;double&gt;&amp; lambda_vec);
+  void findMaxZandS(Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s);
 
-  void ctrv(const double p_x, const double p_y, const double v, const double yaw, const double yawd, const double nu_a,
-            const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp; state);
+  void updateLikelyMeasurementForCTRV(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec);
 
-  void cv(const double p_x, const double p_y, const double v, const double yaw, const double yawd, const double nu_a,
-          const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp; state);
+  void updateEachMotion(const double detection_probability, const double gate_probability, const double gating_thres,
+                        const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, std::vector&lt;double&gt;&amp; lambda_vec);
+
+  void updateSUKF(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec);
+
+  void updateIMMUKF(const double detection_probability, const double gate_probability, const double gating_thres,
+                    const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec);
+
+  void ctrv(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
+            const double delta_t, std::vector&lt;double&gt;&amp; state);
+
+  void cv(const double p_x, const double p_y, const double v, const double yaw, const double yawd, const double delta_t,
+          std::vector&lt;double&gt;&amp; state);
 
   void randomMotion(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
-                    const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp; state);
+                    const double delta_t, std::vector&lt;double&gt;&amp; state);
+
+  void initCovarQs(const double dt, const double yaw);
 
   void prediction(const double delta_t, const int model_ind);
 
   void updateLidar(const int model_ind);
-
 };
 
 #endif /* UKF_H */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\visualize_detected_objects.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\visualize_detected_objects.h" added_lines="38" deleted_lines="4">
				<diff>@@ -1,5 +1,35 @@
-#ifndef OBJECT_TRACKING_VisualizeDetecedObjects_H
-#define OBJECT_TRACKING_VisualizeDetecedObjects_H
+/*
+ *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef OBJECT_TRACKING_VISUALIZEDETECTEDOBJECTS_H
+#define OBJECT_TRACKING_VISUALIZEDETECTEDOBJECTS_H
 
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Header.h&gt;
@@ -18,11 +48,15 @@
 class VisualizeDetectedObjects
 {
 private:
+  const double vis_arrow_height_;
+  const double vis_id_height_;
+  double ignore_velocity_thres_;
+  double visualize_arrow_velocity_thres_;
   std::string input_topic_;
   std::string pointcloud_frame_;
 
   ros::NodeHandle node_handle_;
-  ros::Subscriber sub_cloud_array_;
+  ros::Subscriber sub_object_array_;
 
   ros::Publisher pub_arrow_;
   ros::Publisher pub_id_;
@@ -34,4 +68,4 @@ public:
   VisualizeDetectedObjects();
 };
 
-#endif  // OBJECT_TRACKING_VisualizeCloudCluster_H
+#endif  // OBJECT_TRACKING_VISUALIZEDETECTEDOBJECTS_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda.cpp" added_lines="427" deleted_lines="399">
				<diff>@@ -1,15 +1,43 @@
-#include "ukf.h"
+/*
+ *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include &lt;chrono&gt;
+#include &lt;stdio.h&gt;
+#include &lt;ros/package.h&gt;
+#include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include "imm_ukf_pda.h"
 
-enum TrackingState : int
-{
-  Die = 0,     // No longer tracking
-  Init = 1,    // Start tracking
-  Stable = 4,  // Stable tracking
-  Lost = 10,   // About to lose target
-};
-
 ImmUkfPda::ImmUkfPda()
+  : target_id_(0)
+  ,  // assign unique ukf_id_ to each tracking targets
+  init_(false)
 {
   ros::NodeHandle private_nh_("~");
   private_nh_.param&lt;std::string&gt;("pointcloud_frame", pointcloud_frame_, "velodyne");
@@ -19,21 +47,30 @@ ImmUkfPda::ImmUkfPda()
   private_nh_.param&lt;double&gt;("gate_probability", gate_probability_, 0.99);
   private_nh_.param&lt;double&gt;("detection_probability", detection_probability_, 0.9);
   private_nh_.param&lt;double&gt;("distance_thres", distance_thres_, 99);
-  private_nh_.param&lt;double&gt;("static_distance_thres", static_distance_thres_, 3.0);
+  private_nh_.param&lt;double&gt;("static_velocity_thres", static_velocity_thres_, 0.5);
+  private_nh_.param&lt;double&gt;("prevent_explosion_thres", prevent_explosion_thres_, 1000);
+  private_nh_.param&lt;bool&gt;("use_sukf", use_sukf_, false);
+  private_nh_.param&lt;bool&gt;("is_debug", is_debug_, false);
+}
 
-  init_ = false;
+void ImmUkfPda::run()
+{
+  pub_jskbbox_array_ =
+      node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/detection/lidar_tracker/bounding_boxes", 1);
+  pub_object_array_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/lidar_tracker/objects", 1);
 
-  tf::TransformListener* lr(new tf::TransformListener);
-  tf_listener_ = lr;
+  // for debug
+  pub_points_array_ =
+      node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;("/detection/lidar_tracker/debug_points_markers", 1);
+  pub_texts_array_ =
+      node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;("/detection/lidar_tracker/debug_texts_markers", 1);
 
-  sub_cloud_array_ = node_handle_.subscribe("cloud_clusters", 1, &amp;ImmUkfPda::callback, this);
-  pub_jskbbox_array_ = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/bounding_boxes_tracked", 1);
-  pub_object_array_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detected_objects", 1);
+  sub_detected_array_ = node_handle_.subscribe("/detection/lidar_objects", 1, &amp;ImmUkfPda::callback, this);
 }
 
-void ImmUkfPda::callback(const autoware_msgs::CloudClusterArray&amp; input)
+void ImmUkfPda::callback(const autoware_msgs::DetectedObjectArray&amp; input)
 {
-  autoware_msgs::CloudClusterArray transformed_input;
+  autoware_msgs::DetectedObjectArray transformed_input;
   jsk_recognition_msgs::BoundingBoxArray jskbboxes_output;
   autoware_msgs::DetectedObjectArray detected_objects_output;
 
@@ -41,98 +78,126 @@ void ImmUkfPda::callback(const autoware_msgs::CloudClusterArray&amp; input)
   transformPoseToGlobal(input, transformed_input);
   tracker(transformed_input, jskbboxes_output, detected_objects_output);
   transformPoseToLocal(jskbboxes_output, detected_objects_output);
-
   pub_jskbbox_array_.publish(jskbboxes_output);
   pub_object_array_.publish(detected_objects_output);
 }
 
-void ImmUkfPda::transformPoseToGlobal(const autoware_msgs::CloudClusterArray&amp; input,
-                                            autoware_msgs::CloudClusterArray&amp; transformed_input)
+void ImmUkfPda::relayJskbbox(const autoware_msgs::DetectedObjectArray&amp; input,
+                             jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output)
 {
+  jskbboxes_output.header = input.header;
+  for (size_t i = 0; i &lt; input.objects.size(); i++)
+  {
+    jsk_recognition_msgs::BoundingBox bb;
+    bb.header = input.header;
+    bb.pose = input.objects[i].pose;
+    bb.dimensions = input.objects[i].dimensions;
+    jskbboxes_output.boxes.push_back(bb);
+  }
+}
+
+void ImmUkfPda::transformPoseToGlobal(const autoware_msgs::DetectedObjectArray&amp; input,
+                                      autoware_msgs::DetectedObjectArray&amp; transformed_input)
+{
+  try
+  {
+    tf_listener_.waitForTransform(pointcloud_frame_, tracking_frame_, ros::Time(0), ros::Duration(1.0));
+    // get sensor -&gt; world frame
+    tf_listener_.lookupTransform(tracking_frame_, pointcloud_frame_, ros::Time(0), local2global_);
+  }
+  catch (tf::TransformException ex)
+  {
+    ROS_ERROR("%s", ex.what());
+    ros::Duration(1.0).sleep();
+  }
+
   transformed_input.header = input.header;
-  for (size_t i = 0; i &lt; input.clusters.size(); i++)
+  for (size_t i = 0; i &lt; input.objects.size(); i++)
   {
     geometry_msgs::PoseStamped pose_in, pose_out;
 
     pose_in.header = input.header;
-    pose_in.pose = input.clusters[i].bounding_box.pose;
-    tf_listener_-&gt;waitForTransform(pointcloud_frame_, tracking_frame_, input.header.stamp, ros::Duration(1.0));
-    tf_listener_-&gt;transformPose(tracking_frame_, ros::Time(0), pose_in, input.header.frame_id, pose_out);
-
-    autoware_msgs::CloudCluster cc;
-    cc.header = input.header;
-    cc = input.clusters[i];
-    cc.bounding_box.pose = pose_out.pose;
-    transformed_input.clusters.push_back(cc);
+    pose_in.pose = input.objects[i].pose;
+    tf::Transform input_object_pose;
+    input_object_pose.setOrigin(tf::Vector3(input.objects[i].pose.position.x, input.objects[i].pose.position.y,
+                                            input.objects[i].pose.position.z));
+    input_object_pose.setRotation(
+        tf::Quaternion(input.objects[i].pose.orientation.x, input.objects[i].pose.orientation.y,
+                       input.objects[i].pose.orientation.z, input.objects[i].pose.orientation.w));
+    tf::poseTFToMsg(local2global_ * input_object_pose, pose_out.pose);
+
+    autoware_msgs::DetectedObject dd;
+    dd.header = input.header;
+    dd = input.objects[i];
+    dd.pose = pose_out.pose;
+
+    transformed_input.objects.push_back(dd);
   }
 }
 
 void ImmUkfPda::transformPoseToLocal(jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                                      autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
 {
-  for (size_t i = 0; i &lt; jskbboxes_output.boxes.size(); i++)
+  for (size_t i = 0; i &lt; detected_objects_output.objects.size(); i++)
   {
-    geometry_msgs::PoseStamped pose_in, pose_out;
+    geometry_msgs::PoseStamped detected_pose_in, detected_pose_out;
 
-    pose_in.header = jskbboxes_output.header;
-    pose_in.header.frame_id = tracking_frame_;
-    pose_in.pose = jskbboxes_output.boxes[i].pose;
+    detected_pose_in.header = jskbboxes_output.header;
+    detected_pose_in.header.frame_id = tracking_frame_;
+    detected_pose_in.pose = detected_objects_output.objects[i].pose;
 
-    tf_listener_-&gt;waitForTransform(tracking_frame_, pointcloud_frame_, ros::Time(0), ros::Duration(1.0));
-    tf_listener_-&gt;transformPose(pointcloud_frame_, ros::Time(0), pose_in, tracking_frame_, pose_out);
-    pose_out.header.frame_id = jskbboxes_output.header.frame_id = pointcloud_frame_;
-    jskbboxes_output.boxes[i].pose = pose_out.pose;
-    detected_objects_output.objects[i].pose = pose_out.pose;
-  }
-}
+    tf::Transform output_object_pose;
+    output_object_pose.setOrigin(tf::Vector3(detected_objects_output.objects[i].pose.position.x,
+                                             detected_objects_output.objects[i].pose.position.y,
+                                             detected_objects_output.objects[i].pose.position.z));
+    output_object_pose.setRotation(tf::Quaternion(
+        detected_objects_output.objects[i].pose.orientation.x, detected_objects_output.objects[i].pose.orientation.y,
+        detected_objects_output.objects[i].pose.orientation.z, detected_objects_output.objects[i].pose.orientation.w));
+    tf::poseTFToMsg(local2global_.inverse() * output_object_pose, detected_pose_out.pose);
 
-void ImmUkfPda::findMaxZandS(const UKF&amp; target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s)
-{
-  double cv_det = target.s_cv_.determinant();
-  double ctrv_det = target.s_ctrv_.determinant();
-  double rm_det = target.s_rm_.determinant();
-
-  if (cv_det &gt; ctrv_det)
-  {
-    if (cv_det &gt; rm_det)
-    {
-      max_det_z = target.z_pred_cv_;
-      max_det_s = target.s_cv_;
-    }
-    else
-    {
-      max_det_z = target.z_pred_rm_;
-      max_det_s = target.s_rm_;
-    }
+    detected_objects_output.objects[i].header.frame_id = pointcloud_frame_;
+    detected_objects_output.objects[i].pose = detected_pose_out.pose;
   }
-  else
+  detected_objects_output.header.frame_id = pointcloud_frame_;
+
+  for (size_t i = 0; i &lt; jskbboxes_output.boxes.size(); i++)
   {
-    if (ctrv_det &gt; rm_det)
-    {
-      max_det_z = target.z_pred_ctrv_;
-      max_det_s = target.s_ctrv_;
-    }
-    else
-    {
-      max_det_z = target.z_pred_rm_;
-      max_det_s = target.s_rm_;
-    }
+    geometry_msgs::PoseStamped jsk_pose_in, jsk_pose_out;
+    jsk_pose_in.header = jskbboxes_output.header;
+    jsk_pose_in.header.frame_id = tracking_frame_;
+    jsk_pose_in.pose = jskbboxes_output.boxes[i].pose;
+
+    tf::Transform output_bbox_pose;
+    output_bbox_pose.setOrigin(tf::Vector3(jskbboxes_output.boxes[i].pose.position.x,
+                                           jskbboxes_output.boxes[i].pose.position.y,
+                                           jskbboxes_output.boxes[i].pose.position.z));
+    output_bbox_pose.setRotation(
+        tf::Quaternion(jskbboxes_output.boxes[i].pose.orientation.x, jskbboxes_output.boxes[i].pose.orientation.y,
+                       jskbboxes_output.boxes[i].pose.orientation.z, jskbboxes_output.boxes[i].pose.orientation.w));
+    tf::poseTFToMsg(local2global_.inverse() * output_bbox_pose, jsk_pose_out.pose);
+
+    jskbboxes_output.boxes[i].header.frame_id = pointcloud_frame_;
+    jskbboxes_output.boxes[i].pose = jsk_pose_out.pose;
   }
+  jskbboxes_output.header.frame_id = pointcloud_frame_;
 }
 
-void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray &amp;input, UKF&amp; target, const bool second_init,
-                                      const Eigen::VectorXd &amp;max_det_z, const Eigen::MatrixXd &amp;max_det_s,
-                                      std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
+void ImmUkfPda::measurementValidation(const autoware_msgs::DetectedObjectArray&amp; input, UKF&amp; target,
+                                      const bool second_init, const Eigen::VectorXd&amp; max_det_z,
+                                      const Eigen::MatrixXd&amp; max_det_s,
+                                      std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec,
                                       std::vector&lt;bool&gt;&amp; matching_vec)
 {
-  int count = 0;
+  // alert: different from original imm-pda filter, here picking up most likely measurement
+  // if making it allows to have more than one measurement, you will see non semipositive definite covariance
   bool second_init_done = false;
   double smallest_nis = std::numeric_limits&lt;double&gt;::max();
-  autoware_msgs::CloudCluster smallest_meas_cluster;
-  for (size_t i = 0; i &lt; input.clusters.size(); i++)
+  autoware_msgs::DetectedObject smallest_meas_object;
+  for (size_t i = 0; i &lt; input.objects.size(); i++)
   {
-    double x = input.clusters[i].bounding_box.pose.position.x;
-    double y = input.clusters[i].bounding_box.pose.position.y;
+    double x = input.objects[i].pose.position.x;
+    double y = input.objects[i].pose.position.y;
+
     Eigen::VectorXd meas = Eigen::VectorXd(2);
     meas &lt;&lt; x, y;
 
@@ -141,201 +206,37 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray &amp;in
 
     if (nis &lt; gating_thres_)
     {  // x^2 99% range
-      count++;
       if (matching_vec[i] == false)
-        target.lifetime_++;
-      // pick one meas with smallest nis
-      if (second_init)
       {
-        if (nis &lt; smallest_nis)
-        {
-          smallest_nis = nis;
-          smallest_meas_cluster = input.clusters[i];
-          matching_vec[i] = true;
-          second_init_done = true;
-        }
+        target.lifetime_++;
       }
-      else
+
+      if (nis &lt; smallest_nis)
       {
-        cluster_vec.push_back(input.clusters[i]);
+        smallest_nis = nis;
+        smallest_meas_object = input.objects[i];
         matching_vec[i] = true;
+        second_init_done = true;
       }
     }
   }
   if (second_init_done)
-    cluster_vec.push_back(smallest_meas_cluster);
-}
-
-void ImmUkfPda::filterPDA(UKF&amp; target,
-                          const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
-                          std::vector&lt;double&gt;&amp; lambda_vec)
-{
-  // calculating association probability
-  double num_meas = cluster_vec.size();
-  double b = 2 * num_meas * (1 - detection_probability_ * gate_probability_) / (gating_thres_ * detection_probability_);
-  double e_cv_sum = 0;
-  double e_ctrv_sum = 0;
-  double e_rm_sum = 0;
-
-  std::vector&lt;double&gt; e_cv_vec;
-  std::vector&lt;double&gt; e_ctrv_vec;
-  std::vector&lt;double&gt; e_rm_vec;
-
-  std::vector&lt;Eigen::VectorXd&gt; diff_cv_vec;
-  std::vector&lt;Eigen::VectorXd&gt; diff_ctrv_vec;
-  std::vector&lt;Eigen::VectorXd&gt; diff_rm_vec;
-
-  for (size_t i = 0; i &lt; num_meas; i++)
-  {
-    Eigen::VectorXd meas_vec = Eigen::VectorXd(2);
-    meas_vec(0) = cluster_vec[i].bounding_box.pose.position.x;
-    meas_vec(1) = cluster_vec[i].bounding_box.pose.position.y;
-
-    Eigen::VectorXd diff_cv = meas_vec - target.z_pred_cv_;
-    Eigen::VectorXd diff_ctrv = meas_vec - target.z_pred_ctrv_;
-    Eigen::VectorXd diff_rm = meas_vec - target.z_pred_rm_;
-
-    diff_cv_vec.push_back(diff_cv);
-    diff_ctrv_vec.push_back(diff_ctrv);
-    diff_rm_vec.push_back(diff_rm);
-
-    double e_cv = exp(-0.5 * diff_cv.transpose() * target.s_cv_.inverse() * diff_cv);
-    double e_ctrv = exp(-0.5 * diff_ctrv.transpose() * target.s_ctrv_.inverse() * diff_ctrv);
-    double e_rm = exp(-0.5 * diff_rm.transpose() * target.s_rm_.inverse() * diff_rm);
-
-    e_cv_vec.push_back(e_cv);
-    e_ctrv_vec.push_back(e_ctrv);
-    e_rm_vec.push_back(e_rm);
-
-    e_cv_sum += e_cv;
-    e_ctrv_sum += e_ctrv;
-    e_rm_sum += e_rm;
-  }
-  double beta_cv_zero = b / (b + e_cv_sum);
-  double beta_ctrv_zero = b / (b + e_ctrv_sum);
-  double beta_rm_zero = b / (b + e_rm_sum);
-
-  std::vector&lt;double&gt; beta_cv;
-  std::vector&lt;double&gt; beta_ctrv;
-  std::vector&lt;double&gt; beta_rm;
-
-  for (size_t i = 0; i &lt; num_meas; i++)
-  {
-    double temp_cv = e_cv_vec[i] / (b + e_cv_sum);
-    double temp_ctrv = e_ctrv_vec[i] / (b + e_ctrv_sum);
-    double temp_rm = e_rm_vec[i] / (b + e_rm_sum);
-
-    beta_cv.push_back(temp_cv);
-    beta_ctrv.push_back(temp_ctrv);
-    beta_rm.push_back(temp_rm);
-  }
-  Eigen::VectorXd sigma_x_cv;
-  Eigen::VectorXd sigma_x_ctrv;
-  Eigen::VectorXd sigma_x_rm;
-  sigma_x_cv.setZero(2);
-  sigma_x_ctrv.setZero(2);
-  sigma_x_rm.setZero(2);
-
-  for (size_t i = 0; i &lt; num_meas; i++)
-  {
-    sigma_x_cv += beta_cv[i] * diff_cv_vec[i];
-    sigma_x_ctrv += beta_ctrv[i] * diff_ctrv_vec[i];
-    sigma_x_rm += beta_rm[i] * diff_rm_vec[i];
-  }
-
-  Eigen::MatrixXd sigma_p_cv;
-  Eigen::MatrixXd sigma_p_ctrv;
-  Eigen::MatrixXd sigma_p_rm;
-  sigma_p_cv.setZero(2, 2);
-  sigma_p_ctrv.setZero(2, 2);
-  sigma_p_rm.setZero(2, 2);
-  for (size_t i = 0; i &lt; num_meas; i++)
-  {
-    sigma_p_cv += (beta_cv[i] * diff_cv_vec[i] * diff_cv_vec[i].transpose() - sigma_x_cv * sigma_x_cv.transpose());
-    sigma_p_ctrv +=
-        (beta_ctrv[i] * diff_ctrv_vec[i] * diff_ctrv_vec[i].transpose() - sigma_x_ctrv * sigma_x_ctrv.transpose());
-    sigma_p_rm += (beta_rm[i] * diff_rm_vec[i] * diff_rm_vec[i].transpose() - sigma_x_rm * sigma_x_rm.transpose());
-  }
-
-  // update x and P
-  target.x_cv_ = target.x_cv_ + target.k_cv_ * sigma_x_cv;
-  target.x_ctrv_ = target.x_ctrv_ + target.k_ctrv_ * sigma_x_ctrv;
-  target.x_rm_ = target.x_rm_ + target.k_rm_ * sigma_x_rm;
-
-  while (target.x_cv_(3) &gt; M_PI)
-    target.x_cv_(3) -= 2. * M_PI;
-  while (target.x_cv_(3) &lt; -M_PI)
-    target.x_cv_(3) += 2. * M_PI;
-  while (target.x_ctrv_(3) &gt; M_PI)
-    target.x_ctrv_(3) -= 2. * M_PI;
-  while (target.x_ctrv_(3) &lt; -M_PI)
-    target.x_ctrv_(3) += 2. * M_PI;
-  while (target.x_rm_(3) &gt; M_PI)
-    target.x_rm_(3) -= 2. * M_PI;
-  while (target.x_rm_(3) &lt; -M_PI)
-    target.x_rm_(3) += 2. * M_PI;
-
-  if (num_meas != 0)
-  {
-    target.p_cv_ = beta_cv_zero * target.p_cv_ +
-                   (1 - beta_cv_zero) * (target.p_cv_ - target.k_cv_ * target.s_cv_ * target.k_cv_.transpose()) +
-                   target.k_cv_ * sigma_p_cv * target.k_cv_.transpose();
-    target.p_ctrv_ =
-        beta_ctrv_zero * target.p_ctrv_ +
-        (1 - beta_ctrv_zero) * (target.p_ctrv_ - target.k_ctrv_ * target.s_ctrv_ * target.k_ctrv_.transpose()) +
-        target.k_ctrv_ * sigma_p_ctrv * target.k_ctrv_.transpose();
-    target.p_rm_ = beta_rm_zero * target.p_rm_ +
-                   (1 - beta_rm_zero) * (target.p_rm_ - target.k_rm_ * target.s_rm_ * target.k_rm_.transpose()) +
-                   target.k_rm_ * sigma_p_rm * target.k_rm_.transpose();
-  }
-  else
   {
-    target.p_cv_ = target.p_cv_ - target.k_cv_ * target.s_cv_ * target.k_cv_.transpose();
-    target.p_ctrv_ = target.p_ctrv_ - target.k_ctrv_ * target.s_ctrv_ * target.k_ctrv_.transpose();
-    target.p_rm_ = target.p_rm_ - target.k_rm_ * target.s_rm_ * target.k_rm_.transpose();
+    object_vec.push_back(smallest_meas_object);
   }
-
-  Eigen::VectorXd max_det_z;
-  Eigen::MatrixXd max_det_s;
-
-  findMaxZandS(target, max_det_z, max_det_s);
-  double Vk = M_PI * sqrt(gating_thres_ * max_det_s.determinant());
-
-  double lambda_cv, lambda_ctrv, lambda_rm;
-  if (num_meas != 0)
-  {
-    lambda_cv = (1 - gate_probability_ * detection_probability_) / pow(Vk, num_meas) +
-                detection_probability_ * pow(Vk, 1 - num_meas) * e_cv_sum /
-                    (num_meas * sqrt(2 * M_PI * target.s_cv_.determinant()));
-    lambda_ctrv = (1 - gate_probability_ * detection_probability_) / pow(Vk, num_meas) +
-                  detection_probability_ * pow(Vk, 1 - num_meas) * e_ctrv_sum /
-                      (num_meas * sqrt(2 * M_PI * target.s_ctrv_.determinant()));
-    lambda_rm = (1 - gate_probability_ * detection_probability_) / pow(Vk, num_meas) +
-                detection_probability_ * pow(Vk, 1 - num_meas) * e_rm_sum /
-                    (num_meas * sqrt(2 * M_PI * target.s_rm_.determinant()));
-  }
-  else
-  {
-    lambda_cv = (1 - gate_probability_ * detection_probability_) / pow(Vk, num_meas);
-    lambda_ctrv = (1 - gate_probability_ * detection_probability_) / pow(Vk, num_meas);
-    lambda_rm = (1 - gate_probability_ * detection_probability_) / pow(Vk, num_meas);
-  }
-  lambda_vec.push_back(lambda_cv);
-  lambda_vec.push_back(lambda_ctrv);
-  lambda_vec.push_back(lambda_rm);
 }
 
-void ImmUkfPda::getNearestEuclidCluster(const UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
-                                        autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist)
+void ImmUkfPda::getNearestEuclidCluster(const UKF&amp; target, const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec,
+                                        autoware_msgs::DetectedObject&amp; object, double&amp; min_dist)
 {
   int min_ind = 0;
   double px = target.x_merge_(0);
   double py = target.x_merge_(1);
 
-  for (size_t i = 0; i &lt; cluster_vec.size(); i++)
+  for (size_t i = 0; i &lt; object_vec.size(); i++)
   {
-    double meas_x = cluster_vec[i].bounding_box.pose.position.x;
-    double meas_y = cluster_vec[i].bounding_box.pose.position.y;
+    double meas_x = object_vec[i].pose.position.x;
+    double meas_y = object_vec[i].pose.position.y;
 
     double dist = sqrt((px - meas_x) * (px - meas_x) + (py - meas_y) * (py - meas_y));
     if (dist &lt; min_dist)
@@ -345,27 +246,36 @@ void ImmUkfPda::getNearestEuclidCluster(const UKF&amp; target, const std::vector&lt;aut
     }
   }
 
-  cluster = cluster_vec[min_ind];
+  object = object_vec[min_ind];
 }
 
-void ImmUkfPda::associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, UKF&amp; target)
+void ImmUkfPda::associateBB(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, UKF&amp; target)
 {
   // skip if no validated measurement
-  if (cluster_vec.size() == 0)
+  if (object_vec.size() == 0)
   {
     return;
   }
   if (target.tracking_num_ == TrackingState::Stable &amp;&amp; target.lifetime_ &gt;= life_time_thres_)
   {
-    autoware_msgs::CloudCluster nearest_cluster;
+    autoware_msgs::DetectedObject nearest_object;
     double min_dist = std::numeric_limits&lt;double&gt;::max();
-    getNearestEuclidCluster(target, cluster_vec, nearest_cluster, min_dist);
+    getNearestEuclidCluster(target, object_vec, nearest_object, min_dist);
     if (min_dist &lt; distance_thres_)
     {
       target.is_vis_bb_ = true;
-      target.jsk_bb_ = nearest_cluster.bounding_box;
+      target.jsk_bb_.pose = nearest_object.pose;
+      target.jsk_bb_.dimensions = nearest_object.dimensions;
     }
   }
+  else
+  {
+    autoware_msgs::DetectedObject nearest_object;
+    double min_dist = std::numeric_limits&lt;double&gt;::max();
+    getNearestEuclidCluster(target, object_vec, nearest_object, min_dist);
+    target.jsk_bb_.pose = nearest_object.pose;
+    target.jsk_bb_.dimensions = nearest_object.dimensions;
+  }
 }
 
 double ImmUkfPda::getJskBBoxYaw(const jsk_recognition_msgs::BoundingBox&amp; jsk_bb)
@@ -405,21 +315,20 @@ void ImmUkfPda::updateBB(UKF&amp; target)
   double diff_yaw = yaw - target.best_yaw_;
 
   // diffYaw is within the threshold, apply the diffYaw chamge
-  if(abs(diff_yaw) &lt; bb_yaw_change_thres_)
+  if (abs(diff_yaw) &lt; bb_yaw_change_thres_)
   {
-      target.best_jsk_bb_.pose.orientation = target.jsk_bb_.pose.orientation;
-      target.best_yaw_ = yaw;
+    target.best_jsk_bb_.pose.orientation = target.jsk_bb_.pose.orientation;
+    target.best_yaw_ = yaw;
   }
   else
   {
-      target.jsk_bb_.pose.orientation = target.best_jsk_bb_.pose.orientation;
+    target.jsk_bb_.pose.orientation = target.best_jsk_bb_.pose.orientation;
   }
 
   // // bbox area
   double area = getJskBBoxArea(target.jsk_bb_);
   double best_area = getJskBBoxArea(target.best_jsk_bb_);
 
-
   // start updating bbox params
   double delta_area = area - best_area;
 
@@ -440,32 +349,6 @@ void ImmUkfPda::updateBB(UKF&amp; target)
   }
 }
 
-void ImmUkfPda::updateLabel(const UKF&amp; target, autoware_msgs::DetectedObject&amp; dd)
-{
-  int tracking_num = target.tracking_num_;
-  // cout &lt;&lt; "trackingnum "&lt;&lt; trackingNum &lt;&lt; endl;
-  if (target.is_static_)
-  {
-    dd.label = "Static";
-  }
-  else if (tracking_num &gt; TrackingState::Die &amp;&amp; tracking_num &lt; TrackingState::Stable)
-  {
-    dd.label = "Initialized";
-  }
-  else if (tracking_num == TrackingState::Stable)
-  {
-    dd.label = "Stable";
-  }
-  else if (tracking_num &gt; TrackingState::Stable &amp;&amp; tracking_num &lt;= TrackingState::Lost)
-  {
-    dd.label = "Lost";
-  }
-  else
-  {
-    dd.label = "None";
-  }
-}
-
 void ImmUkfPda::updateJskLabel(const UKF&amp; target, jsk_recognition_msgs::BoundingBox&amp; bb)
 {
   int tracking_num = target.tracking_num_;
@@ -479,42 +362,28 @@ void ImmUkfPda::updateJskLabel(const UKF&amp; target, jsk_recognition_msgs::Bounding
   }
 }
 
-bool ImmUkfPda::isVisible(const UKF&amp; target)
+void ImmUkfPda::initTracker(const autoware_msgs::DetectedObjectArray&amp; input, double timestamp)
 {
-  bool is_visible = false;
-  int tracking_num = target.tracking_num_;
-  if (tracking_num == TrackingState::Stable || target.is_static_)
-  {
-    is_visible = true;
-  }
-  else
+  for (size_t i = 0; i &lt; input.objects.size(); i++)
   {
-    is_visible = false;
-  }
-  return is_visible;
-}
-
-void ImmUkfPda::initTracker(const autoware_msgs::CloudClusterArray&amp; input, double timestamp)
-{
-  for (size_t i = 0; i &lt; input.clusters.size(); i++)
-  {
-    double px = input.clusters[i].bounding_box.pose.position.x;
-    double py = input.clusters[i].bounding_box.pose.position.y;
+    double px = input.objects[i].pose.position.x;
+    double py = input.objects[i].pose.position.y;
     Eigen::VectorXd init_meas = Eigen::VectorXd(2);
     init_meas &lt;&lt; px, py;
 
     UKF ukf;
-    ukf.initialize(init_meas, timestamp);
+    ukf.initialize(init_meas, timestamp, target_id_);
     targets_.push_back(ukf);
+    target_id_++;
   }
   timestamp_ = timestamp;
   init_ = true;
   return;
 }
 
-void ImmUkfPda::secondInit(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, double dt)
+void ImmUkfPda::secondInit(UKF&amp; target, const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, double dt)
 {
-  if (cluster_vec.size() == 0)
+  if (object_vec.size() == 0)
   {
     target.tracking_num_ = TrackingState::Die;
     return;
@@ -523,8 +392,8 @@ void ImmUkfPda::secondInit(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCl
   target.init_meas_ &lt;&lt; target.x_merge_(0), target.x_merge_(1);
 
   // state update
-  double target_x = cluster_vec[0].bounding_box.pose.position.x;
-  double target_y = cluster_vec[0].bounding_box.pose.position.y;
+  double target_x = object_vec[0].pose.position.x;
+  double target_y = object_vec[0].pose.position.y;
   double target_diff_x = target_x - target.x_merge_(0);
   double target_diff_y = target_y - target.x_merge_(1);
   double target_yaw = atan2(target_diff_y, target_diff_x);
@@ -541,13 +410,15 @@ void ImmUkfPda::secondInit(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCl
   target.x_merge_(2) = target.x_cv_(2) = target.x_ctrv_(2) = target.x_rm_(2) = target_v;
   target.x_merge_(3) = target.x_cv_(3) = target.x_ctrv_(3) = target.x_rm_(3) = target_yaw;
 
+  // target.initCovarQs(dt, target_yaw);
+
   target.tracking_num_++;
   return;
 }
 
-void ImmUkfPda::updateTrackingNum(const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, UKF&amp; target)
+void ImmUkfPda::updateTrackingNum(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, UKF&amp; target)
 {
-  if (cluster_vec.size() &gt; 0)
+  if (object_vec.size() &gt; 0)
   {
     if (target.tracking_num_ &lt; TrackingState::Stable)
     {
@@ -585,21 +456,31 @@ void ImmUkfPda::updateTrackingNum(const std::vector&lt;autoware_msgs::CloudCluster&gt;
   return;
 }
 
-void ImmUkfPda::probabilisticDataAssociation(const autoware_msgs::CloudClusterArray&amp; input, const double dt,
-                                             const double det_explode_param, std::vector&lt;bool&gt;&amp; matching_vec,
-                                             std::vector&lt;double&gt;&amp; lambda_vec, UKF&amp; target, bool&amp; is_skip_target)
+void ImmUkfPda::probabilisticDataAssociation(const autoware_msgs::DetectedObjectArray&amp; input, const double dt,
+                                             std::vector&lt;bool&gt;&amp; matching_vec,
+                                             std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, UKF&amp; target,
+                                             bool&amp; is_skip_target)
 {
+  double det_s = 0;
   Eigen::VectorXd max_det_z;
   Eigen::MatrixXd max_det_s;
-  std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec;
   is_skip_target = false;
-  // find maxDetS associated with predZ
-  findMaxZandS(target, max_det_z, max_det_s);
 
-  double det_s = max_det_s.determinant();
+  if (use_sukf_)
+  {
+    max_det_z = target.z_pred_ctrv_;
+    max_det_s = target.s_ctrv_;
+    det_s = max_det_s.determinant();
+  }
+  else
+  {
+    // find maxDetS associated with predZ
+    target.findMaxZandS(max_det_z, max_det_s);
+    det_s = max_det_s.determinant();
+  }
 
   // prevent ukf not to explode
-  if (std::isnan(det_s) || det_s &gt; det_explode_param)
+  if (std::isnan(det_s) || det_s &gt; prevent_explosion_thres_)
   {
     target.tracking_num_ = TrackingState::Die;
     is_skip_target = true;
@@ -617,46 +498,46 @@ void ImmUkfPda::probabilisticDataAssociation(const autoware_msgs::CloudClusterAr
   }
 
   // measurement gating, get measVec, bboxVec, matchingVec through reference
-  measurementValidation(input, target, is_second_init, max_det_z, max_det_s, cluster_vec, matching_vec);
+  measurementValidation(input, target, is_second_init, max_det_z, max_det_s, object_vec, matching_vec);
 
   // bounding box association if target is stable :plus, right angle correction if its needed
   // input: track number, bbox measurements, &amp;target
-  associateBB(cluster_vec, target);
+  associateBB(object_vec, target);
 
   // second detection for a target: update v and yaw
   if (is_second_init)
   {
-    secondInit(target, cluster_vec, dt);
+    secondInit(target, object_vec, dt);
     is_skip_target = true;
     return;
   }
 
   // update tracking number
-  updateTrackingNum(cluster_vec, target);
+  updateTrackingNum(object_vec, target);
 
   if (target.tracking_num_ == TrackingState::Die)
   {
     is_skip_target = true;
     return;
   }
-  filterPDA(target, cluster_vec, lambda_vec);
 }
 
-void ImmUkfPda::makeNewTargets(const double timestamp, const autoware_msgs::CloudClusterArray&amp; input, const std::vector&lt;bool&gt;&amp; matching_vec)
+void ImmUkfPda::makeNewTargets(const double timestamp, const autoware_msgs::DetectedObjectArray&amp; input,
+                               const std::vector&lt;bool&gt;&amp; matching_vec)
 {
-  for (size_t i = 0; i &lt; input.clusters.size(); i++)
+  for (size_t i = 0; i &lt; input.objects.size(); i++)
   {
     if (matching_vec[i] == false)
     {
-      double px = input.clusters[i].bounding_box.pose.position.x;
-      double py = input.clusters[i].bounding_box.pose.position.y;
-
+      double px = input.objects[i].pose.position.x;
+      double py = input.objects[i].pose.position.y;
       Eigen::VectorXd init_meas = Eigen::VectorXd(2);
       init_meas &lt;&lt; px, py;
 
       UKF ukf;
-      ukf.initialize(init_meas, timestamp);
+      ukf.initialize(init_meas, timestamp, target_id_);
       targets_.push_back(ukf);
+      target_id_++;
     }
   }
 }
@@ -665,12 +546,19 @@ void ImmUkfPda::staticClassification()
 {
   for (size_t i = 0; i &lt; targets_.size(); i++)
   {
-    if (!targets_[i].is_static_ &amp;&amp; targets_[i].tracking_num_ == TrackingState::Stable &amp;&amp;
-        targets_[i].lifetime_ &gt; life_time_thres_)
+    targets_[i].vel_history_.push_back(targets_[i].x_merge_(2));
+    if (targets_[i].tracking_num_ == TrackingState::Stable &amp;&amp; targets_[i].lifetime_ &gt; life_time_thres_)
     {
-      if ((targets_[i].dist_from_init_ &lt; static_distance_thres_) &amp;&amp;
-          (targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_cv_ ||
-           targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_ctrv_))
+      double sum_vel = 0;
+      double avg_vel = 0;
+      for (int ind = 1; ind &lt; life_time_thres_; ind++)
+      {
+        sum_vel += targets_[i].vel_history_.end()[-ind];
+      }
+      avg_vel = double(sum_vel / life_time_thres_);
+
+      if ((avg_vel &lt; static_velocity_thres_) &amp;&amp; (targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_cv_ ||
+                                                 targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_ctrv_))
       {
         targets_[i].is_static_ = true;
       }
@@ -678,118 +566,258 @@ void ImmUkfPda::staticClassification()
   }
 }
 
-void ImmUkfPda::makeOutput(const autoware_msgs::CloudClusterArray&amp; input,
+void ImmUkfPda::makeOutput(const autoware_msgs::DetectedObjectArray&amp; input,
                            jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                            autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
 {
-  tf::StampedTransform transform;
-  tf_listener_-&gt;lookupTransform(tracking_frame_, pointcloud_frame_, ros::Time(0), transform);
-
-  // get yaw angle from tracking_frame_ to pointcloud_frame_ for direction(arrow) visualization
-  tf::Matrix3x3 m(transform.getRotation());
-  double roll, pitch, yaw;
-  m.getRPY(roll, pitch, yaw);
-
-  // output.header = input.header;
   jskbboxes_output.header = input.header;
   detected_objects_output.header = input.header;
   for (size_t i = 0; i &lt; targets_.size(); i++)
   {
-    if (targets_[i].is_vis_bb_ &amp;&amp; isVisible(targets_[i]))
-    {
-      double tx = targets_[i].x_merge_(0);
-      double ty = targets_[i].x_merge_(1);
-      double mx = targets_[i].init_meas_(0);
-      double my = targets_[i].init_meas_(1);
-
-      // for static classification
-      targets_[i].dist_from_init_ = sqrt((tx - mx) * (tx - mx) + (ty - my) * (ty - my));
+    double tx = targets_[i].x_merge_(0);
+    double ty = targets_[i].x_merge_(1);
 
-      double tv = targets_[i].x_merge_(2);
-      double tyaw = targets_[i].x_merge_(3) - yaw;
-
-      while (tyaw &gt; M_PI)
-        tyaw -= 2. * M_PI;
-      while (tyaw &lt; -M_PI)
-        tyaw += 2. * M_PI;
+    double tv = targets_[i].x_merge_(2);
+    double tyaw = targets_[i].x_merge_(3);
+    while (tyaw &gt; M_PI)
+      tyaw -= 2. * M_PI;
+    while (tyaw &lt; -M_PI)
+      tyaw += 2. * M_PI;
 
+    if (targets_[i].is_vis_bb_)
+    {
       jsk_recognition_msgs::BoundingBox bb;
       bb.header = input.header;
       bb = targets_[i].jsk_bb_;
       updateJskLabel(targets_[i], bb);
       jskbboxes_output.boxes.push_back(bb);
+    }
+    // RPY to convert: 0, 0, targets_[i].x_merge_(3)
+    tf::Quaternion q = tf::createQuaternionFromRPY(0, 0, tyaw);
+    autoware_msgs::DetectedObject dd;
+    dd.header = input.header;
+    dd.id = targets_[i].ukf_id_;
+    dd.velocity.linear.x = tv;
+    dd.pose = targets_[i].jsk_bb_.pose;
+    dd.pose.position.x = tx;
+    dd.pose.position.y = ty;
+    dd.pose.orientation.x = q[0];
+    dd.pose.orientation.y = q[1];
+    dd.pose.orientation.z = q[2];
+    dd.pose.orientation.w = q[3];
+    dd.dimensions = targets_[i].jsk_bb_.dimensions;
+    dd.pose_reliable = targets_[i].is_vis_bb_;
+    detected_objects_output.objects.push_back(dd);
+  }
+}
 
-      autoware_msgs::DetectedObject dd;
-      dd.header = input.header;
-      dd.id = i;
-      dd.velocity.linear.x = tv;
-      dd.pose = targets_[i].jsk_bb_.pose;
-      // Store tyaw in velocity.linear.y since nowhere to store estimated_yaw
-      dd.velocity.linear.y = tyaw;
-      updateLabel(targets_[i], dd);
-      detected_objects_output.objects.push_back(dd);
+void ImmUkfPda::removeUnnecessaryTarget()
+{
+  std::vector&lt;UKF&gt; temp_targets;
+  for (size_t i = 0; i &lt; targets_.size(); i++)
+  {
+    if (targets_[i].tracking_num_ != TrackingState::Die)
+    {
+      temp_targets.push_back(targets_[i]);
     }
   }
+  std::vector&lt;UKF&gt;().swap(targets_);
+  targets_ = temp_targets;
 }
 
-void ImmUkfPda::tracker(const autoware_msgs::CloudClusterArray&amp; input,
+void ImmUkfPda::pubDebugRosMarker(const autoware_msgs::DetectedObjectArray&amp; input)
+{
+  visualization_msgs::MarkerArray texts_markers, points_markers;
+  visualization_msgs::Marker target_points, meas_points;
+  target_points.header.frame_id = meas_points.header.frame_id = "/world";
+  target_points.header.stamp = meas_points.header.stamp = input.header.stamp;
+  target_points.ns = meas_points.ns = "target_points";
+  target_points.action = meas_points.action = visualization_msgs::Marker::ADD;
+  target_points.pose.orientation.w = meas_points.pose.orientation.w = 1.0;
+
+  target_points.id = 0;
+  meas_points.id = 1;
+
+  target_points.type = meas_points.type = visualization_msgs::Marker::POINTS;
+
+  // POINTS markers use x and y scale for width/height respectively
+  target_points.scale.x = 0.4;
+  target_points.scale.y = 0.4;
+  meas_points.scale.x = 0.3;
+  meas_points.scale.y = 0.3;
+
+  // Points are green
+  target_points.color.r = 1.0f;
+  target_points.color.a = 1.0;
+  meas_points.color.g = 1.0f;
+  meas_points.color.a = 1.0;
+
+  // making rosmarker fot target
+  for (size_t i = 0; i &lt; targets_.size(); i++)
+  {
+    geometry_msgs::Point p;
+    p.x = targets_[i].x_merge_(0);
+    p.y = targets_[i].x_merge_(1);
+    p.z = 1.0;
+
+    target_points.points.push_back(p);
+
+    visualization_msgs::Marker id;
+    id.header.frame_id = "/world";
+    id.header.stamp = input.header.stamp;
+    id.ns = "target_points";
+    id.action = visualization_msgs::Marker::ADD;
+    id.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
+    id.id = targets_[i].ukf_id_ * 100;
+    id.lifetime = ros::Duration(0.1);
+
+    id.color.g = 1.0f;
+    id.color.a = 1.0;
+
+    // Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
+    id.pose.position.x = targets_[i].x_merge_(0);
+    id.pose.position.y = targets_[i].x_merge_(1);
+    id.pose.position.z = 2.5;
+
+    id.scale.z = 0.5;
+
+    double tv = targets_[i].x_merge_(2);
+    std::string s_velocity = std::to_string(tv * 3.6);
+    std::string modified_sv = s_velocity.substr(0, s_velocity.find(".") + 3);
+
+    std::string text = "&lt;" + std::to_string(targets_[i].ukf_id_) + "&gt;" + " " + std::to_string(targets_[i].x_merge_(2)) +
+                       " m/s " + "(" + std::to_string(targets_[i].x_merge_(0)) + ", " +
+                       std::to_string(targets_[i].x_merge_(1)) + ")";
+    id.text = text;
+    texts_markers.markers.push_back(id);
+  }
+
+  // making rosmarker fot measurement
+  for (size_t i = 0; i &lt; input.objects.size(); i++)
+  {
+    geometry_msgs::Point p;
+    p.x = input.objects[i].pose.position.x;
+    p.y = input.objects[i].pose.position.y;
+    p.z = 1.0;
+    meas_points.points.push_back(p);
+
+    visualization_msgs::Marker id;
+    id.header.frame_id = "/world";
+    id.header.stamp = input.header.stamp;
+    id.ns = "target_points";
+    id.action = visualization_msgs::Marker::ADD;
+    id.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
+    id.id = i;
+    id.lifetime = ros::Duration(0.1);
+
+    id.color.g = 1.0f;
+    id.color.a = 1.0;
+
+    id.pose.position.x = input.objects[i].pose.position.x;
+    id.pose.position.y = input.objects[i].pose.position.y;
+    id.pose.position.z = 1.5;
+
+    id.scale.z = 0.5;
+
+    std::string s_px = std::to_string(input.objects[i].pose.position.x);
+    std::string s_py = std::to_string(input.objects[i].pose.position.y);
+
+    std::string text = "(" + s_px + ", " + s_py + ")";
+    id.text = text;
+    texts_markers.markers.push_back(id);
+  }
+  points_markers.markers.push_back(target_points);
+  points_markers.markers.push_back(meas_points);
+
+  pub_points_array_.publish(points_markers);
+  pub_texts_array_.publish(texts_markers);
+}
+
+void ImmUkfPda::tracker(const autoware_msgs::DetectedObjectArray&amp; input,
                         jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                         autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
 {
   double timestamp = input.header.stamp.toSec();
 
-  double det_explode_param = 10;
-  double cov_explode_param = 1000;
-
   if (!init_)
   {
     initTracker(input, timestamp);
+    makeOutput(input, jskbboxes_output, detected_objects_output);
     return;
   }
 
   double dt = (timestamp - timestamp_);
   timestamp_ = timestamp;
-  // // used for making new target with no data association
-  std::vector&lt;bool&gt; matching_vec(input.clusters.size(), false);  // make 0 vector
+  // making new target with no data association
+  std::vector&lt;bool&gt; matching_vec(input.objects.size(), false);
 
   // start UKF process
   for (size_t i = 0; i &lt; targets_.size(); i++)
   {
     // reset is_vis_bb_ to false
     targets_[i].is_vis_bb_ = false;
+    targets_[i].is_static_ = false;
 
-    // todo: modify here. This skips irregular measurement and nan
     if (targets_[i].tracking_num_ == TrackingState::Die)
+    {
       continue;
+    }
     // prevent ukf not to explode
-    if (targets_[i].p_merge_.determinant() &gt; det_explode_param || targets_[i].p_merge_(4, 4) &gt; cov_explode_param)
+    if (targets_[i].p_merge_.determinant() &gt; prevent_explosion_thres_ ||
+        targets_[i].p_merge_(4, 4) &gt; prevent_explosion_thres_)
     {
       targets_[i].tracking_num_ = TrackingState::Die;
       continue;
     }
-    // immukf prediction step
-    targets_[i].predictionIMMUKF(dt);
 
-    bool is_skip_target;
-    std::vector&lt;double&gt; lambda_vec;
-    probabilisticDataAssociation(input, dt, det_explode_param, matching_vec, lambda_vec, targets_[i], is_skip_target);
-    if (is_skip_target)
-      continue;
-
-    // immukf update step
-    targets_[i].updateIMMUKF(lambda_vec);
+    if (use_sukf_)
+    {
+      // standard ukf prediction step
+      targets_[i].predictionSUKF(dt);
+      // data association
+      bool is_skip_target;
+      std::vector&lt;autoware_msgs::DetectedObject&gt; object_vec;
+      probabilisticDataAssociation(input, dt, matching_vec, object_vec, targets_[i], is_skip_target);
+      if (is_skip_target)
+      {
+        continue;
+      }
+      // standard ukf update step
+      targets_[i].updateSUKF(object_vec);
+    }
+    else  // immukfpda filter
+    {
+      // immukf prediction step
+      targets_[i].predictionIMMUKF(dt);
+      // data association
+      bool is_skip_target;
+      std::vector&lt;autoware_msgs::DetectedObject&gt; object_vec;
+      probabilisticDataAssociation(input, dt, matching_vec, object_vec, targets_[i], is_skip_target);
+      if (is_skip_target)
+      {
+        continue;
+      }
+      // immukf update step
+      targets_[i].updateIMMUKF(detection_probability_, gate_probability_, gating_thres_, object_vec);
+    }
   }
   // end UKF process
 
+  // debug, green is for measurement points, red is for estimated points
+  if (is_debug_)
+  {
+    pubDebugRosMarker(input);
+  }
+
   // making new ukf target for no data association clusters
   makeNewTargets(timestamp, input, matching_vec);
 
   // static dynamic classification
   staticClassification();
 
-  // making output(CludClusterArray) for visualization
+  // making output for visualization
   makeOutput(input, jskbboxes_output, detected_objects_output);
 
-  assert(matching_vec.size() == input.clusters.size());
-  assert(jskbboxes_output.boxes.size() == detected_objects_output.objects.size());
+  // remove unnecessary ukf object
+  removeUnnecessaryTarget();
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda_main.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda_main.cpp" added_lines="30" deleted_lines="1">
				<diff>@@ -1,3 +1,32 @@
+/*
+ *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #include "imm_ukf_pda.h"
 
@@ -5,7 +34,7 @@ int main(int argc, char** argv)
 {
   ros::init(argc, argv, "imm_ukf_pda_tracker");
   ImmUkfPda app;
+  app.run();
   ros::spin();
-
   return 0;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\ukf.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\ukf.cpp" added_lines="554" deleted_lines="180">
				<diff>@@ -1,12 +1,47 @@
+/*
+ *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #include "ukf.h"
 
+enum MotionModel : int
+{
+  CV = 0,    // constant velocity
+  CTRV = 1,  // constant turn rate and velocity
+  RM = 2,    // random motion
+};
+
 /**
 * Initializes Unscented Kalman filter
 */
 UKF::UKF()
 {
-
   // initial state vector
   x_merge_ = Eigen::MatrixXd(5, 1);
 
@@ -39,7 +74,6 @@ UKF::UKF()
   std_cv_yawdd_ = 2;
   std_rm_yawdd_ = 3;
 
-  //------------------
   // Laser measurement noise standard deviation position1 in m
   std_laspx_ = 0.15;
   // Laser measurement noise standard deviation position2 in m
@@ -54,35 +88,20 @@ UKF::UKF()
   // state dimension
   n_x_ = 5;
 
-  // Augmented state dimension
-  n_aug_ = 7;
-
-  // Sigma point spreading parameter
-  lambda_ = 3 - n_x_;
-
-  // Augmented sigma point spreading parameter
-  lambda_aug_ = 3 - n_aug_;
-
   // predicted sigma points matrix
-  x_sig_pred_cv_ = Eigen::MatrixXd(n_x_, 2 * n_aug_ + 1);
+  x_sig_pred_cv_ = Eigen::MatrixXd(n_x_, 2 * n_x_ + 1);
 
   // predicted sigma points matrix
-  x_sig_pred_ctrv_ = Eigen::MatrixXd(n_x_, 2 * n_aug_ + 1);
+  x_sig_pred_ctrv_ = Eigen::MatrixXd(n_x_, 2 * n_x_ + 1);
 
   // predicted sigma points matrix
-  x_sig_pred_rm_ = Eigen::MatrixXd(n_x_, 2 * n_aug_ + 1);
+  x_sig_pred_rm_ = Eigen::MatrixXd(n_x_, 2 * n_x_ + 1);
 
   // create vector for weights
-  weights_ = Eigen::VectorXd(2 * n_aug_ + 1);
+  weights_c_ = Eigen::VectorXd(2 * n_x_ + 1);
+  weights_s_ = Eigen::VectorXd(2 * n_x_ + 1);
 
-  count_ = 0;
-  count_empty_ = 0;
-
-  ini_u_.push_back(0.33);
-  ini_u_.push_back(0.33);
-  ini_u_.push_back(0.33);
-
-  // different from paper, might be wrong
+  // transition probability
   p1_.push_back(0.9);
   p1_.push_back(0.05);
   p1_.push_back(0.05);
@@ -119,47 +138,91 @@ UKF::UKF()
   s_ctrv_ = Eigen::MatrixXd(2, 2);
   s_rm_ = Eigen::MatrixXd(2, 2);
 
-  k_cv_ = Eigen::MatrixXd(2, 2);
-  k_ctrv_ = Eigen::MatrixXd(2, 2);
-  k_rm_ = Eigen::MatrixXd(2, 2);
+  k_cv_ = Eigen::MatrixXd(5, 2);
+  k_ctrv_ = Eigen::MatrixXd(5, 2);
+  k_rm_ = Eigen::MatrixXd(5, 2);
 
-  // gamma_g_ = 9.21;
   pd_ = 0.9;
   pg_ = 0.99;
 
-  // track parameter
+  // tracking parameter
   lifetime_ = 0;
   is_static_ = false;
 
   // bounding box params
   is_best_jsk_bb_empty_ = false;
   is_vis_bb_ = false;
+  jsk_bb_.dimensions.x = 1.0;
+  jsk_bb_.dimensions.y = 1.0;
   best_yaw_ = 100;
   bb_yaw_ = 0;
   bb_area_ = 0;
 
-  // for env classification
+  // for static classification
   init_meas_ = Eigen::VectorXd(2);
-  dist_from_init_ = 0;
 
   x_merge_yaw_ = 0;
+
+  // for raukf
+  cv_meas_ = Eigen::VectorXd(2);
+  ctrv_meas_ = Eigen::VectorXd(2);
+  rm_meas_ = Eigen::VectorXd(2);
+
+  r_cv_ = Eigen::MatrixXd(2, 2);
+  r_ctrv_ = Eigen::MatrixXd(2, 2);
+  r_rm_ = Eigen::MatrixXd(2, 2);
+
+  q_cv_ = Eigen::MatrixXd(5, 5);
+  q_ctrv_ = Eigen::MatrixXd(5, 5);
+  q_rm_ = Eigen::MatrixXd(5, 5);
+
+  nis_cv_ = 0;
+  nis_ctrv_ = 0;
+  nis_rm_ = 0;
+
+  new_x_sig_cv_ = Eigen::MatrixXd(n_x_, 2 * n_x_ + 1);
+  new_x_sig_ctrv_ = Eigen::MatrixXd(n_x_, 2 * n_x_ + 1);
+  new_x_sig_rm_ = Eigen::MatrixXd(n_x_, 2 * n_x_ + 1);
+
+  new_z_sig_cv_ = Eigen::MatrixXd(2, 2 * n_x_ + 1);
+  new_z_sig_ctrv_ = Eigen::MatrixXd(2, 2 * n_x_ + 1);
+  new_z_sig_rm_ = Eigen::MatrixXd(2, 2 * n_x_ + 1);
+
+  new_z_pred_cv_ = Eigen::VectorXd(2);
+  new_z_pred_ctrv_ = Eigen::VectorXd(2);
+  new_z_pred_rm_ = Eigen::VectorXd(2);
+
+  new_s_cv_ = Eigen::MatrixXd(2, 2);
+  new_s_ctrv_ = Eigen::MatrixXd(2, 2);
+  new_s_rm_ = Eigen::MatrixXd(2, 2);
 }
 
-void UKF::initialize(const Eigen::VectorXd&amp; z, const double timestamp)
+void UKF::initialize(const Eigen::VectorXd&amp; z, const double timestamp, const int target_id)
 {
+  ukf_id_ = target_id;
+
   // first measurement
-  x_merge_ &lt;&lt; 1, 1, 0, 0, 0.1;
+  x_merge_ &lt;&lt; 0, 0, 0, 0, 0.1;
 
-  // init covariance matrix
+  // init covariance matrix by hardcoding since no clue about initial state covrariance
   p_merge_ &lt;&lt; 0.5, 0, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 1;
 
   // set weights
-  double weight_0 = lambda_aug_ / (lambda_aug_ + n_aug_);
-  weights_(0) = weight_0;
-  for (int i = 1; i &lt; 2 * n_aug_ + 1; i++)
+  // reference from "The Unscented Kalman Filter for Nonlinear Estimation, Eric A. Wan and Rudolph van der Merwe, 2000"
+  // alpha = 0.0025, beta = 2, k = 0
+  double alpha = 0.0025;
+  double beta = 2;
+  double k = 0;
+  lambda_ = alpha * alpha * (n_x_ + k) - n_x_;
+  double weight_s_0 = lambda_ / (lambda_ + n_x_);
+  double weight_c_0 = lambda_ / (lambda_ + n_x_) + (1 - alpha * alpha + beta);
+  weights_s_(0) = weight_s_0;
+  weights_c_(0) = weight_c_0;
+  for (int i = 1; i &lt; 2 * n_x_ + 1; i++)
   {  // 2n+1 weights
-    double weight = 0.5 / (n_aug_ + lambda_aug_);
-    weights_(i) = weight;
+    double weight = 0.5 / (n_x_ + lambda_);
+    weights_s_(i) = weight;
+    weights_c_(i) = weight;
   }
 
   // init timestamp
@@ -184,11 +247,13 @@ void UKF::initialize(const Eigen::VectorXd&amp; z, const double timestamp)
   s_ctrv_ &lt;&lt; 1, 0, 0, 1;
   s_rm_ &lt;&lt; 1, 0, 0, 1;
 
+  // initialize R covariance
+  r_cv_ &lt;&lt; std_laspx_ * std_laspx_, 0, 0, std_laspy_ * std_laspy_;
+  r_ctrv_ &lt;&lt; std_laspx_ * std_laspx_, 0, 0, std_laspy_ * std_laspy_;
+  r_rm_ &lt;&lt; std_laspx_ * std_laspx_, 0, 0, std_laspy_ * std_laspy_;
+
   // init tracking num
   tracking_num_ = 1;
-
-  // prevent transform pose error, if the condition meets, target_.jskBB_ would be updated
-  jsk_bb_.pose.orientation.x = 1.0;
 }
 
 void UKF::updateModeProb(const std::vector&lt;double&gt;&amp; lambda_vec)
@@ -313,9 +378,28 @@ void UKF::interaction()
           mode_match_prob_rm2rm_ * (p_pre_rm + (x_pre_rm - x_rm_) * (x_pre_rm - x_rm_).transpose());
 }
 
+void UKF::predictionSUKF(const double dt)
+{
+  /*****************************************************************************
+  *  Init covariance Q if it is necessary
+  ****************************************************************************/
+  initCovarQs(dt, x_merge_(3));
+  /*****************************************************************************
+  *  Prediction
+  ****************************************************************************/
+  prediction(dt, MotionModel::CTRV);
+  /*****************************************************************************
+  *  Update
+  ****************************************************************************/
+  updateLidar(MotionModel::CTRV);
+}
 
 void UKF::predictionIMMUKF(const double dt)
 {
+  /*****************************************************************************
+  *  Init covariance Q if it is needed
+  ****************************************************************************/
+  initCovarQs(dt, x_merge_(3));
   /*****************************************************************************
   *  IMM Mixing and Interaction
   ****************************************************************************/
@@ -324,20 +408,287 @@ void UKF::predictionIMMUKF(const double dt)
   /*****************************************************************************
   *  Prediction
   ****************************************************************************/
-  prediction(dt, 0);
-  prediction(dt, 1);
-  prediction(dt, 2);
-
+  prediction(dt, MotionModel::CV);
+  prediction(dt, MotionModel::CTRV);
+  prediction(dt, MotionModel::RM);
   /*****************************************************************************
   *  Update
   ****************************************************************************/
-  updateLidar(0);
-  updateLidar(1);
-  updateLidar(2);
+  updateLidar(MotionModel::CV);
+  updateLidar(MotionModel::CTRV);
+  updateLidar(MotionModel::RM);
+}
+
+void UKF::findMaxZandS(Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s)
+{
+  double cv_det = s_cv_.determinant();
+  double ctrv_det = s_ctrv_.determinant();
+  double rm_det = s_rm_.determinant();
+
+  if (cv_det &gt; ctrv_det)
+  {
+    if (cv_det &gt; rm_det)
+    {
+      max_det_z = z_pred_cv_;
+      max_det_s = s_cv_;
+    }
+    else
+    {
+      max_det_z = z_pred_rm_;
+      max_det_s = s_rm_;
+    }
+  }
+  else
+  {
+    if (ctrv_det &gt; rm_det)
+    {
+      max_det_z = z_pred_ctrv_;
+      max_det_s = s_ctrv_;
+    }
+    else
+    {
+      max_det_z = z_pred_rm_;
+      max_det_s = s_rm_;
+    }
+  }
+}
+
+void UKF::updateEachMotion(const double detection_probability, const double gate_probability, const double gating_thres,
+                           const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec,
+                           std::vector&lt;double&gt;&amp; lambda_vec)
+{
+  // calculating association probability
+  double num_meas = object_vec.size();
+  double b = 2 * num_meas * (1 - detection_probability * gate_probability) / (gating_thres * detection_probability);
+  double e_cv_sum = 0;
+  double e_ctrv_sum = 0;
+  double e_rm_sum = 0;
+
+  std::vector&lt;double&gt; e_cv_vec;
+  std::vector&lt;double&gt; e_ctrv_vec;
+  std::vector&lt;double&gt; e_rm_vec;
+
+  std::vector&lt;Eigen::VectorXd&gt; diff_cv_vec;
+  std::vector&lt;Eigen::VectorXd&gt; diff_ctrv_vec;
+  std::vector&lt;Eigen::VectorXd&gt; diff_rm_vec;
+
+  std::vector&lt;Eigen::VectorXd&gt; meas_vec;
+
+  for (size_t i = 0; i &lt; num_meas; i++)
+  {
+    Eigen::VectorXd meas = Eigen::VectorXd(2);
+    meas(0) = object_vec[i].pose.position.x;
+    meas(1) = object_vec[i].pose.position.y;
+    meas_vec.push_back(meas);
+
+    Eigen::VectorXd diff_cv = meas - z_pred_cv_;
+    Eigen::VectorXd diff_ctrv = meas - z_pred_ctrv_;
+    Eigen::VectorXd diff_rm = meas - z_pred_rm_;
+
+    diff_cv_vec.push_back(diff_cv);
+    diff_ctrv_vec.push_back(diff_ctrv);
+    diff_rm_vec.push_back(diff_rm);
+
+    double e_cv = exp(-0.5 * diff_cv.transpose() * s_cv_.inverse() * diff_cv);
+    double e_ctrv = exp(-0.5 * diff_ctrv.transpose() * s_ctrv_.inverse() * diff_ctrv);
+    double e_rm = exp(-0.5 * diff_rm.transpose() * s_rm_.inverse() * diff_rm);
+
+    e_cv_vec.push_back(e_cv);
+    e_ctrv_vec.push_back(e_ctrv);
+    e_rm_vec.push_back(e_rm);
+
+    e_cv_sum += e_cv;
+    e_ctrv_sum += e_ctrv;
+    e_rm_sum += e_rm;
+  }
+  double beta_cv_zero = b / (b + e_cv_sum);
+  double beta_ctrv_zero = b / (b + e_ctrv_sum);
+  double beta_rm_zero = b / (b + e_rm_sum);
+
+  std::vector&lt;double&gt; beta_cv;
+  std::vector&lt;double&gt; beta_ctrv;
+  std::vector&lt;double&gt; beta_rm;
+
+  if (num_meas != 0)
+  {
+    std::vector&lt;double&gt;::iterator max_cv_iter = std::max_element(e_cv_vec.begin(), e_cv_vec.end());
+    std::vector&lt;double&gt;::iterator max_ctrv_iter = std::max_element(e_ctrv_vec.begin(), e_ctrv_vec.end());
+    std::vector&lt;double&gt;::iterator max_rm_iter = std::max_element(e_rm_vec.begin(), e_rm_vec.end());
+    int max_cv_ind = std::distance(e_cv_vec.begin(), max_cv_iter);
+    int max_ctrv_ind = std::distance(e_ctrv_vec.begin(), max_ctrv_iter);
+    int max_rm_ind = std::distance(e_rm_vec.begin(), max_rm_iter);
+    cv_meas_ = meas_vec[max_cv_ind];
+    ctrv_meas_ = meas_vec[max_ctrv_ind];
+    rm_meas_ = meas_vec[max_rm_ind];
+  }
+
+  for (size_t i = 0; i &lt; num_meas; i++)
+  {
+    double temp_cv = e_cv_vec[i] / (b + e_cv_sum);
+    double temp_ctrv = e_ctrv_vec[i] / (b + e_ctrv_sum);
+    double temp_rm = e_rm_vec[i] / (b + e_rm_sum);
+
+    beta_cv.push_back(temp_cv);
+    beta_ctrv.push_back(temp_ctrv);
+    beta_rm.push_back(temp_rm);
+  }
+  Eigen::VectorXd sigma_x_cv;
+  Eigen::VectorXd sigma_x_ctrv;
+  Eigen::VectorXd sigma_x_rm;
+  sigma_x_cv.setZero(2);
+  sigma_x_ctrv.setZero(2);
+  sigma_x_rm.setZero(2);
+
+  for (size_t i = 0; i &lt; num_meas; i++)
+  {
+    sigma_x_cv += beta_cv[i] * diff_cv_vec[i];
+    sigma_x_ctrv += beta_ctrv[i] * diff_ctrv_vec[i];
+    sigma_x_rm += beta_rm[i] * diff_rm_vec[i];
+  }
+
+  Eigen::MatrixXd sigma_p_cv;
+  Eigen::MatrixXd sigma_p_ctrv;
+  Eigen::MatrixXd sigma_p_rm;
+  sigma_p_cv.setZero(2, 2);
+  sigma_p_ctrv.setZero(2, 2);
+  sigma_p_rm.setZero(2, 2);
+
+  for (size_t i = 0; i &lt; num_meas; i++)
+  {
+    sigma_p_cv += (beta_cv[i] * diff_cv_vec[i] * diff_cv_vec[i].transpose() - sigma_x_cv * sigma_x_cv.transpose());
+    sigma_p_ctrv +=
+        (beta_ctrv[i] * diff_ctrv_vec[i] * diff_ctrv_vec[i].transpose() - sigma_x_ctrv * sigma_x_ctrv.transpose());
+    sigma_p_rm += (beta_rm[i] * diff_rm_vec[i] * diff_rm_vec[i].transpose() - sigma_x_rm * sigma_x_rm.transpose());
+  }
+
+  // update x and P
+  x_cv_ = x_cv_ + k_cv_ * sigma_x_cv;
+  x_ctrv_ = x_ctrv_ + k_ctrv_ * sigma_x_ctrv;
+  x_rm_ = x_rm_ + k_rm_ * sigma_x_rm;
+
+  while (x_cv_(3) &gt; M_PI)
+    x_cv_(3) -= 2. * M_PI;
+  while (x_cv_(3) &lt; -M_PI)
+    x_cv_(3) += 2. * M_PI;
+  while (x_ctrv_(3) &gt; M_PI)
+    x_ctrv_(3) -= 2. * M_PI;
+  while (x_ctrv_(3) &lt; -M_PI)
+    x_ctrv_(3) += 2. * M_PI;
+  while (x_rm_(3) &gt; M_PI)
+    x_rm_(3) -= 2. * M_PI;
+  while (x_rm_(3) &lt; -M_PI)
+    x_rm_(3) += 2. * M_PI;
+
+  Eigen::MatrixXd p_pre_cv = p_cv_;
+  Eigen::MatrixXd p_pre_ctrv = p_ctrv_;
+  Eigen::MatrixXd p_pre_rm = p_rm_;
+
+  if (num_meas != 0)
+  {
+    p_cv_ = beta_cv_zero * p_pre_cv + (1 - beta_cv_zero) * (p_pre_cv - k_cv_ * s_cv_ * k_cv_.transpose()) +
+            k_cv_ * sigma_p_cv * k_cv_.transpose();
+    p_ctrv_ = beta_ctrv_zero * p_pre_ctrv +
+              (1 - beta_ctrv_zero) * (p_pre_ctrv - k_ctrv_ * s_ctrv_ * k_ctrv_.transpose()) +
+              k_ctrv_ * sigma_p_ctrv * k_ctrv_.transpose();
+    p_rm_ = beta_rm_zero * p_pre_rm + (1 - beta_rm_zero) * (p_pre_rm - k_rm_ * s_rm_ * k_rm_.transpose()) +
+            k_rm_ * sigma_p_rm * k_rm_.transpose();
+  }
+  else
+  {
+    p_cv_ = p_pre_cv - k_cv_ * s_cv_ * k_cv_.transpose();
+    p_ctrv_ = p_pre_ctrv - k_ctrv_ * s_ctrv_ * k_ctrv_.transpose();
+    p_rm_ = p_pre_rm - k_rm_ * s_rm_ * k_rm_.transpose();
+  }
+
+  Eigen::VectorXd max_det_z;
+  Eigen::MatrixXd max_det_s;
+
+  findMaxZandS(max_det_z, max_det_s);
+  double Vk = M_PI * sqrt(gating_thres * max_det_s.determinant());
+
+  double lambda_cv, lambda_ctrv, lambda_rm;
+  if (num_meas != 0)
+  {
+    lambda_cv =
+        (1 - gate_probability * detection_probability) / pow(Vk, num_meas) +
+        detection_probability * pow(Vk, 1 - num_meas) * e_cv_sum / (num_meas * sqrt(2 * M_PI * s_cv_.determinant()));
+    lambda_ctrv = (1 - gate_probability * detection_probability) / pow(Vk, num_meas) +
+                  detection_probability * pow(Vk, 1 - num_meas) * e_ctrv_sum /
+                      (num_meas * sqrt(2 * M_PI * s_ctrv_.determinant()));
+    lambda_rm =
+        (1 - gate_probability * detection_probability) / pow(Vk, num_meas) +
+        detection_probability * pow(Vk, 1 - num_meas) * e_rm_sum / (num_meas * sqrt(2 * M_PI * s_rm_.determinant()));
+  }
+  else
+  {
+    lambda_cv = (1 - gate_probability * detection_probability);
+    lambda_ctrv = (1 - gate_probability * detection_probability);
+    lambda_rm = (1 - gate_probability * detection_probability);
+  }
+
+  lambda_vec.push_back(lambda_cv);
+  lambda_vec.push_back(lambda_ctrv);
+  lambda_vec.push_back(lambda_rm);
+}
+
+void UKF::updateLikelyMeasurementForCTRV(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec)
+{
+  double num_meas = object_vec.size();
+  std::vector&lt;double&gt; e_ctrv_vec;
+  std::vector&lt;Eigen::VectorXd&gt; meas_vec;
+
+  for (size_t i = 0; i &lt; num_meas; i++)
+  {
+    Eigen::VectorXd meas = Eigen::VectorXd(2);
+    meas(0) = object_vec[i].pose.position.x;
+    meas(1) = object_vec[i].pose.position.y;
+    meas_vec.push_back(meas);
+    Eigen::VectorXd diff_ctrv = meas - z_pred_ctrv_;
+    double e_ctrv = exp(-0.5 * diff_ctrv.transpose() * s_ctrv_.inverse() * diff_ctrv);
+    e_ctrv_vec.push_back(e_ctrv);
+  }
+  // for noise estimation
+  if (num_meas != 0)
+  {
+    std::vector&lt;double&gt;::iterator max_ctrv_iter = std::max_element(e_ctrv_vec.begin(), e_ctrv_vec.end());
+    int max_ctrv_ind = std::distance(e_ctrv_vec.begin(), max_ctrv_iter);
+    ctrv_meas_ = meas_vec[max_ctrv_ind];
+  }
+}
+
+void UKF::updateSUKF(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec)
+{
+  if (object_vec.size() == 0)
+  {
+    return;
+  }
+
+  // get most likely measurement ctrv_meas_
+  updateLikelyMeasurementForCTRV(object_vec);
+
+  Eigen::VectorXd z = Eigen::VectorXd(2);
+  z &lt;&lt; ctrv_meas_(0), ctrv_meas_(1);
+
+  Eigen::VectorXd x = x_ctrv_.col(0);
+  Eigen::VectorXd z_pred = z_pred_ctrv_;
+  Eigen::MatrixXd k = k_ctrv_;
+  Eigen::MatrixXd p = p_ctrv_;
+  Eigen::MatrixXd s = s_ctrv_;
+
+  x_ctrv_.col(0) = x + k * (z - z_pred);
+  p_ctrv_ = p - k * s_ctrv_ * k.transpose();
+  x_merge_.col(0) = x_ctrv_.col(0);
 }
 
-void UKF::updateIMMUKF(const std::vector&lt;double&gt;&amp; lambda_vec)
+void UKF::updateIMMUKF(const double detection_probability, const double gate_probability, const double gating_thres,
+                       const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec)
 {
+  /*****************************************************************************
+  *  IMM Update
+  ****************************************************************************/
+  // update each motion's x and p
+  std::vector&lt;double&gt; lambda_vec;
+  updateEachMotion(detection_probability, gate_probability, gating_thres, object_vec, lambda_vec);
   /*****************************************************************************
   *  IMM Merge Step
   ****************************************************************************/
@@ -346,7 +697,7 @@ void UKF::updateIMMUKF(const std::vector&lt;double&gt;&amp; lambda_vec)
 }
 
 void UKF::ctrv(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
-               const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp; state)
+               const double delta_t, std::vector&lt;double&gt;&amp; state)
 {
   // predicted state values
   double px_p, py_p;
@@ -366,13 +717,10 @@ void UKF::ctrv(const double p_x, const double p_y, const double v, const double
   double yaw_p = yaw + yawd * delta_t;
   double yawd_p = yawd;
 
-  // add noise
-  px_p = px_p + 0.5 * nu_a * delta_t * delta_t * cos(yaw);
-  py_p = py_p + 0.5 * nu_a * delta_t * delta_t * sin(yaw);
-  v_p = v_p + nu_a * delta_t;
-
-  yaw_p = yaw_p + 0.5 * nu_yawdd * delta_t * delta_t;
-  yawd_p = yawd_p + nu_yawdd * delta_t;
+  while (yaw_p &gt; M_PI)
+    yaw_p -= 2. * M_PI;
+  while (yaw_p &lt; -M_PI)
+    yaw_p += 2. * M_PI;
 
   state[0] = px_p;
   state[1] = py_p;
@@ -381,8 +729,8 @@ void UKF::ctrv(const double p_x, const double p_y, const double v, const double
   state[4] = yawd_p;
 }
 
-void UKF::cv(const double p_x, const double p_y, const double v, const double yaw, const double yawd, const double nu_a,
-             const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp; state)
+void UKF::cv(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
+             const double delta_t, std::vector&lt;double&gt;&amp; state)
 {
   // predicted state values
   double px_p = p_x + v * cos(yaw) * delta_t;
@@ -394,14 +742,6 @@ void UKF::cv(const double p_x, const double p_y, const double v, const double ya
 
   double yawd_p = yawd;
 
-  // add noise
-  px_p = px_p + 0.5 * nu_a * delta_t * delta_t * cos(yaw);
-  py_p = py_p + 0.5 * nu_a * delta_t * delta_t * sin(yaw);
-  v_p = v_p + nu_a * delta_t;
-
-  yaw_p = yaw_p + 0.5 * nu_yawdd * delta_t * delta_t;
-  yawd_p = yawd_p + nu_yawdd * delta_t;
-
   state[0] = px_p;
   state[1] = py_p;
   state[2] = v_p;
@@ -410,11 +750,12 @@ void UKF::cv(const double p_x, const double p_y, const double v, const double ya
 }
 
 void UKF::randomMotion(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
-                       const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp; state)
+                       const double delta_t, std::vector&lt;double&gt;&amp; state)
 {
   double px_p = p_x;
   double py_p = p_y;
-  double v_p = v;
+  double v_p = v * 0.9;  // aim to converge velocity for static objects
+  // double v_p = 0.0;
 
   double yaw_p = yaw;
   double yawd_p = yawd;
@@ -426,158 +767,191 @@ void UKF::randomMotion(const double p_x, const double p_y, const double v, const
   state[4] = yawd_p;
 }
 
+void UKF::initCovarQs(const double dt, const double yaw)
+{
+  if (tracking_num_ != TrackingState::Init)
+  {
+    return;
+  }
+  double dt_2 = dt * dt;
+  double dt_3 = dt_2 * dt;
+  double dt_4 = dt_3 * dt;
+  double cos_yaw = cos(yaw);
+  double sin_yaw = sin(yaw);
+  double cos_2_yaw = cos(yaw) * cos(yaw);
+  double sin_2_yaw = sin(yaw) * sin(yaw);
+  double cos_sin = cos_yaw * sin_yaw;
+
+  double cv_var_a = std_a_cv_ * std_a_cv_;
+  double cv_var_yawdd = std_cv_yawdd_ * std_cv_yawdd_;
+
+  double ctrv_var_a = std_a_ctrv_ * std_a_ctrv_;
+  double ctrv_var_yawdd = std_ctrv_yawdd_ * std_ctrv_yawdd_;
+
+  double rm_var_a = std_a_rm_ * std_a_rm_;
+  double rm_var_yawdd = std_rm_yawdd_ * std_rm_yawdd_;
+
+  q_cv_ &lt;&lt; 0.5 * 0.5 * dt_4 * cos_2_yaw * cv_var_a, 0.5 * 0.5 * dt_4 * cos_sin * cv_var_a,
+      0.5 * dt_3 * cos_yaw * cv_var_a, 0, 0, 0.5 * 0.5 * dt_4 * cos_sin * cv_var_a,
+      0.5 * 0.5 * dt_4 * sin_2_yaw * cv_var_a, 0.5 * dt_3 * sin_yaw * cv_var_a, 0, 0, 0.5 * dt_3 * cos_yaw * cv_var_a,
+      0.5 * dt_3 * sin_yaw * cv_var_a, dt_2 * cv_var_a, 0, 0, 0, 0, 0, 0.5 * 0.5 * dt_4 * cv_var_yawdd,
+      0.5 * dt_3 * cv_var_yawdd, 0, 0, 0, 0.5 * dt_3 * cv_var_yawdd, dt_2 * cv_var_yawdd;
+  q_ctrv_ &lt;&lt; 0.5 * 0.5 * dt_4 * cos_2_yaw * ctrv_var_a, 0.5 * 0.5 * dt_4 * cos_sin * ctrv_var_a,
+      0.5 * dt_3 * cos_yaw * ctrv_var_a, 0, 0, 0.5 * 0.5 * dt_4 * cos_sin * ctrv_var_a,
+      0.5 * 0.5 * dt_4 * sin_2_yaw * ctrv_var_a, 0.5 * dt_3 * sin_yaw * ctrv_var_a, 0, 0,
+      0.5 * dt_3 * cos_yaw * ctrv_var_a, 0.5 * dt_3 * sin_yaw * ctrv_var_a, dt_2 * ctrv_var_a, 0, 0, 0, 0, 0,
+      0.5 * 0.5 * dt_4 * ctrv_var_yawdd, 0.5 * dt_3 * ctrv_var_yawdd, 0, 0, 0, 0.5 * dt_3 * ctrv_var_yawdd,
+      dt_2 * ctrv_var_yawdd;
+  q_rm_ &lt;&lt; 0.5 * 0.5 * dt_4 * cos_2_yaw * rm_var_a, 0.5 * 0.5 * dt_4 * cos_sin * rm_var_a,
+      0.5 * dt_3 * cos_yaw * rm_var_a, 0, 0, 0.5 * 0.5 * dt_4 * cos_sin * rm_var_a,
+      0.5 * 0.5 * dt_4 * sin_2_yaw * rm_var_a, 0.5 * dt_3 * sin_yaw * rm_var_a, 0, 0, 0.5 * dt_3 * cos_yaw * rm_var_a,
+      0.5 * dt_3 * sin_yaw * rm_var_a, dt_2 * rm_var_a, 0, 0, 0, 0, 0, 0.5 * 0.5 * dt_4 * rm_var_yawdd,
+      0.5 * dt_3 * rm_var_yawdd, 0, 0, 0, 0.5 * dt_3 * rm_var_yawdd, dt_2 * rm_var_yawdd;
+}
 
 void UKF::prediction(const double delta_t, const int model_ind)
 {
   /*****************************************************************************
  *  Initialize model parameters
  ****************************************************************************/
-  double std_yawdd, std_a;
-  Eigen::MatrixXd x_(x_cv_.rows(), 1);
-  Eigen::MatrixXd p_(p_cv_.rows(), p_cv_.cols());
-  Eigen::MatrixXd x_sig_pred_(x_sig_pred_cv_.rows(), x_sig_pred_cv_.cols());
-  if (model_ind == 0)
-  {
-    x_ = x_cv_.col(0);
-    p_ = p_cv_;
-    x_sig_pred_ = x_sig_pred_cv_;
-    std_yawdd = std_cv_yawdd_;
-    std_a = std_a_cv_;
-  }
-  else if (model_ind == 1)
-  {
-    x_ = x_ctrv_.col(0);
-    p_ = p_ctrv_;
-    x_sig_pred_ = x_sig_pred_ctrv_;
-    std_yawdd = std_ctrv_yawdd_;
-    std_a = std_a_ctrv_;
+  Eigen::MatrixXd x(x_cv_.rows(), 1);
+  Eigen::MatrixXd p(p_cv_.rows(), p_cv_.cols());
+  Eigen::MatrixXd q(p_cv_.rows(), p_cv_.cols());
+  Eigen::MatrixXd x_sig_pred(x_sig_pred_cv_.rows(), x_sig_pred_cv_.cols());
+  if (model_ind == MotionModel::CV)
+  {
+    x = x_cv_.col(0);
+    p = p_cv_;
+    q = q_cv_;
+    x_sig_pred = x_sig_pred_cv_;
+  }
+  else if (model_ind == MotionModel::CTRV)
+  {
+    x = x_ctrv_.col(0);
+    p = p_ctrv_;
+    q = q_ctrv_;
+    x_sig_pred = x_sig_pred_ctrv_;
   }
   else
   {
-    x_ = x_rm_.col(0);
-    p_ = p_rm_;
-    x_sig_pred_ = x_sig_pred_rm_;
-    std_yawdd = std_rm_yawdd_;
-    std_a = std_a_rm_;
+    x = x_rm_.col(0);
+    p = p_rm_;
+    q = q_rm_;
+    x_sig_pred = x_sig_pred_rm_;
   }
 
   /*****************************************************************************
-  *  Augment Sigma Points
+  *  Create Sigma Points
   ****************************************************************************/
-  // create augmented mean vector
-  Eigen::VectorXd x_aug = Eigen::VectorXd(n_aug_);
 
-  // create augmented state covariance
-  Eigen::MatrixXd p_aug = Eigen::MatrixXd(n_aug_, n_aug_);
-
-  // create sigma point matrix
-  Eigen::MatrixXd x_sig_aug = Eigen::MatrixXd(n_aug_, 2 * n_aug_ + 1);
-
-  // create augmented mean state
-  x_aug.head(5) = x_;
-  x_aug(5) = 0;
-  x_aug(6) = 0;
-
-  // create augmented covariance matrix
-  p_aug.fill(0.0);
-  p_aug.topLeftCorner(5, 5) = p_;
-  p_aug(5, 5) = std_a * std_a;
-  p_aug(6, 6) = std_yawdd * std_yawdd;
+  Eigen::MatrixXd x_sig = Eigen::MatrixXd(n_x_, 2 * n_x_ + 1);
 
   // create square root matrix
-  Eigen::MatrixXd L = p_aug.llt().matrixL();
+  Eigen::MatrixXd L = p.llt().matrixL();
 
   // create augmented sigma points
-  x_sig_aug.col(0) = x_aug;
-  for (int i = 0; i &lt; n_aug_; i++)
+  x_sig.col(0) = x;
+  for (int i = 0; i &lt; n_x_; i++)
   {
-    x_sig_aug.col(i + 1) = x_aug + sqrt(lambda_aug_ + n_aug_) * L.col(i);
-    x_sig_aug.col(i + 1 + n_aug_) = x_aug - sqrt(lambda_aug_ + n_aug_) * L.col(i);
+    Eigen::VectorXd pred1 = x + sqrt(lambda_ + n_x_) * L.col(i);
+    Eigen::VectorXd pred2 = x - sqrt(lambda_ + n_x_) * L.col(i);
+
+    while (pred1(3) &gt; M_PI)
+      pred1(3) -= 2. * M_PI;
+    while (pred1(3) &lt; -M_PI)
+      pred1(3) += 2. * M_PI;
+
+    while (pred2(3) &gt; M_PI)
+      pred2(3) -= 2. * M_PI;
+    while (pred2(3) &lt; -M_PI)
+      pred2(3) += 2. * M_PI;
+
+    x_sig.col(i + 1) = pred1;
+    x_sig.col(i + 1 + n_x_) = pred2;
   }
 
   /*****************************************************************************
   *  Predict Sigma Points
   ****************************************************************************/
   // predict sigma points
-  for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
+  for (int i = 0; i &lt; 2 * n_x_ + 1; i++)
   {
     // extract values for better readability
-    double p_x = x_sig_aug(0, i);
-    double p_y = x_sig_aug(1, i);
-    double v = x_sig_aug(2, i);
-    double yaw = x_sig_aug(3, i);
-    double yawd = x_sig_aug(4, i);
-    double nu_a = x_sig_aug(5, i);
-    double nu_yawdd = x_sig_aug(6, i);
+    double p_x = x_sig(0, i);
+    double p_y = x_sig(1, i);
+    double v = x_sig(2, i);
+    double yaw = x_sig(3, i);
+    double yawd = x_sig(4, i);
 
     std::vector&lt;double&gt; state(5);
-    if (model_ind == 0)
-      cv(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
-    else if (model_ind == 1)
-      ctrv(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
+    if (model_ind == MotionModel::CV)
+      cv(p_x, p_y, v, yaw, yawd, delta_t, state);
+    else if (model_ind == MotionModel::CTRV)
+      ctrv(p_x, p_y, v, yaw, yawd, delta_t, state);
     else
-      randomMotion(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
+      randomMotion(p_x, p_y, v, yaw, yawd, delta_t, state);
 
     // write predicted sigma point into right column
-    x_sig_pred_(0, i) = state[0];
-    x_sig_pred_(1, i) = state[1];
-    x_sig_pred_(2, i) = state[2];
-    x_sig_pred_(3, i) = state[3];
-    x_sig_pred_(4, i) = state[4];
+    x_sig_pred(0, i) = state[0];
+    x_sig_pred(1, i) = state[1];
+    x_sig_pred(2, i) = state[2];
+    x_sig_pred(3, i) = state[3];
+    x_sig_pred(4, i) = state[4];
   }
 
   /*****************************************************************************
   *  Convert Predicted Sigma Points to Mean/Covariance
   ****************************************************************************/
   // predicted state mean
-  x_.fill(0.0);
-  for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
+  x.fill(0.0);
+  for (int i = 0; i &lt; 2 * n_x_ + 1; i++)
   {  // iterate over sigma points
-    x_ = x_ + weights_(i) * x_sig_pred_.col(i);
+    x = x + weights_s_(i) * x_sig_pred.col(i);
   }
 
-  while (x_(3) &gt; M_PI)
-    x_(3) -= 2. * M_PI;
-  while (x_(3) &lt; -M_PI)
-    x_(3) += 2. * M_PI;
+  while (x(3) &gt; M_PI)
+    x(3) -= 2. * M_PI;
+  while (x(3) &lt; -M_PI)
+    x(3) += 2. * M_PI;
   // predicted state covariance matrix
-  p_.fill(0.0);
-  for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
+  p.fill(0.0);
+  for (int i = 0; i &lt; 2 * n_x_ + 1; i++)
   {  // iterate over sigma points
     // state difference
-    Eigen::VectorXd x_diff = x_sig_pred_.col(i) - x_;
+    Eigen::VectorXd x_diff = x_sig_pred.col(i) - x;
     // angle normalization
     while (x_diff(3) &gt; M_PI)
       x_diff(3) -= 2. * M_PI;
     while (x_diff(3) &lt; -M_PI)
       x_diff(3) += 2. * M_PI;
-    p_ = p_ + weights_(i) * x_diff * x_diff.transpose();
+    p = p + weights_c_(i) * x_diff * x_diff.transpose();
   }
 
+  p = p + q;
+
   /*****************************************************************************
   *  Update model parameters
   ****************************************************************************/
-  if (model_ind == 0)
+  if (model_ind == MotionModel::CV)
   {
-    x_cv_.col(0) = x_;
-    p_cv_ = p_;
-    x_sig_pred_cv_ = x_sig_pred_;
+    x_cv_.col(0) = x;
+    p_cv_ = p;
+    x_sig_pred_cv_ = x_sig_pred;
   }
-  else if (model_ind == 1)
+  else if (model_ind == MotionModel::CTRV)
   {
-    x_ctrv_.col(0) = x_;
-    p_ctrv_ = p_;
-    x_sig_pred_ctrv_ = x_sig_pred_;
+    x_ctrv_.col(0) = x;
+    p_ctrv_ = p;
+    x_sig_pred_ctrv_ = x_sig_pred;
   }
   else
   {
-    x_rm_.col(0) = x_;
-    p_rm_ = p_;
-    x_sig_pred_rm_ = x_sig_pred_;
+    x_rm_.col(0) = x;
+    p_rm_ = p;
+    x_sig_pred_rm_ = x_sig_pred;
   }
 }
 
-
 void UKF::updateLidar(const int model_ind)
 {
   /*****************************************************************************
@@ -585,23 +959,24 @@ void UKF::updateLidar(const int model_ind)
  ****************************************************************************/
   Eigen::VectorXd x(x_cv_.rows());
   Eigen::MatrixXd P(p_cv_.rows(), p_cv_.cols());
+  Eigen::MatrixXd r(2, 2);
   Eigen::MatrixXd x_sig_pred(x_sig_pred_cv_.rows(), x_sig_pred_cv_.cols());
-  if (model_ind == 0)
+  if (model_ind == MotionModel::CV)
   {
     x = x_cv_.col(0);
-    P = p_cv_;
+    r = r_cv_;
     x_sig_pred = x_sig_pred_cv_;
   }
-  else if (model_ind == 1)
+  else if (model_ind == MotionModel::CTRV)
   {
     x = x_ctrv_.col(0);
-    P = p_ctrv_;
+    r = r_ctrv_;
     x_sig_pred = x_sig_pred_ctrv_;
   }
   else
   {
     x = x_rm_.col(0);
-    P = p_rm_;
+    r = r_rm_;
     x_sig_pred = x_sig_pred_rm_;
   }
 
@@ -609,10 +984,10 @@ void UKF::updateLidar(const int model_ind)
   int n_z = 2;
 
   // create matrix for sigma points in measurement space
-  Eigen::MatrixXd z_sig = Eigen::MatrixXd(n_z, 2 * n_aug_ + 1);
+  Eigen::MatrixXd z_sig = Eigen::MatrixXd(n_z, 2 * n_x_ + 1);
 
   // transform sigma points into measurement space
-  for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
+  for (int i = 0; i &lt; 2 * n_x_ + 1; i++)
   {  // 2n+1 simga points
     // extract values for better readibility
     double p_x = x_sig_pred(0, i);
@@ -626,25 +1001,23 @@ void UKF::updateLidar(const int model_ind)
   // mean predicted measurement
   Eigen::VectorXd z_pred = Eigen::VectorXd(n_z);
   z_pred.fill(0.0);
-  for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
+  for (int i = 0; i &lt; 2 * n_x_ + 1; i++)
   {
-    z_pred = z_pred + weights_(i) * z_sig.col(i);
+    z_pred = z_pred + weights_s_(i) * z_sig.col(i);
   }
 
   // measurement covariance matrix S
   Eigen::MatrixXd S = Eigen::MatrixXd(n_z, n_z);
   S.fill(0.0);
-  for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
+  for (int i = 0; i &lt; 2 * n_x_ + 1; i++)
   {  // 2n+1 simga points
     // residual
     Eigen::VectorXd z_diff = z_sig.col(i) - z_pred;
-    S = S + weights_(i) * z_diff * z_diff.transpose();
+    S = S + weights_c_(i) * z_diff * z_diff.transpose();
   }
 
   // add measurement noise covariance matrix
-  Eigen::MatrixXd R = Eigen::MatrixXd(n_z, n_z);
-  R &lt;&lt; std_laspx_ * std_laspx_, 0, 0, std_laspy_ * std_laspy_;
-  S = S + R;
+  S = S + r;
 
   // create matrix for cross correlation Tc
   Eigen::MatrixXd Tc = Eigen::MatrixXd(n_x_, n_z);
@@ -654,35 +1027,37 @@ void UKF::updateLidar(const int model_ind)
   ****************************************************************************/
   // calculate cross correlation matrix
   Tc.fill(0.0);
-  for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
+  for (int i = 0; i &lt; 2 * n_x_ + 1; i++)
   {  // 2n+1 simga points
     // residual
     Eigen::VectorXd z_diff = z_sig.col(i) - z_pred;
     // state difference
     Eigen::VectorXd x_diff = x_sig_pred.col(i) - x;
 
-    Tc = Tc + weights_(i) * x_diff * z_diff.transpose();
+    while (x_diff(3) &gt; M_PI)
+      x_diff(3) -= 2. * M_PI;
+    while (x_diff(3) &lt; -M_PI)
+      x_diff(3) += 2. * M_PI;
+
+    Tc = Tc + weights_c_(i) * x_diff * z_diff.transpose();
   }
 
-  // Kalman gain K;
   Eigen::MatrixXd K = Tc * S.inverse();
 
   /*****************************************************************************
   *  Update model parameters
   ****************************************************************************/
-  if (model_ind == 0)
+  if (model_ind == MotionModel::CV)
   {
     x_cv_.col(0) = x;
-    p_cv_ = P;
     x_sig_pred_cv_ = x_sig_pred;
     z_pred_cv_ = z_pred;
     s_cv_ = S;
     k_cv_ = K;
   }
-  else if (model_ind == 1)
+  else if (model_ind == MotionModel::CTRV)
   {
     x_ctrv_.col(0) = x;
-    p_ctrv_ = P;
     x_sig_pred_ctrv_ = x_sig_pred;
     z_pred_ctrv_ = z_pred;
     s_ctrv_ = S;
@@ -691,7 +1066,6 @@ void UKF::updateLidar(const int model_ind)
   else
   {
     x_rm_.col(0) = x;
-    p_rm_ = P;
     x_sig_pred_rm_ = x_sig_pred;
     z_pred_rm_ = z_pred;
     s_rm_ = S;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\visualize_detected_objects\visualize_detected_objects.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\visualize_detected_objects\visualize_detected_objects.cpp" added_lines="129" deleted_lines="54">
				<diff>@@ -1,16 +1,50 @@
+/*
+ *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 #include "visualize_detected_objects.h"
 
-#include &lt;visualization_msgs/Marker.h&gt;
+#include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
+#include &lt;cmath&gt;
 
-VisualizeDetectedObjects::VisualizeDetectedObjects()
+VisualizeDetectedObjects::VisualizeDetectedObjects() : vis_arrow_height_(0.5), vis_id_height_(1.5)
 {
   ros::NodeHandle private_nh_("~");
   private_nh_.param&lt;std::string&gt;("pointcloud_frame", pointcloud_frame_, "velodyne");
+  private_nh_.param&lt;double&gt;("ignore_velocity_thres", ignore_velocity_thres_, 0.1);
+  private_nh_.param&lt;double&gt;("visualize_arrow_velocity_thres", visualize_arrow_velocity_thres_, 0.25);
 
-  sub_cloud_array_ = node_handle_.subscribe("/detected_objects", 1, &amp;VisualizeDetectedObjects::callBack, this);
-  pub_arrow_ = node_handle_.advertise&lt;visualization_msgs::Marker&gt;("/detected_objects/velocity_arrow", 1);
-  pub_id_ = node_handle_.advertise&lt;visualization_msgs::Marker&gt;("/detected_objects/target_id", 1);
+  sub_object_array_ =
+      node_handle_.subscribe("/detection/lidar_tracker/objects", 1, &amp;VisualizeDetectedObjects::callBack, this);
+  pub_arrow_ = node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;("/detection/lidar_tracker/arrow_markers", 10);
+  pub_id_ = node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;("/detection/lidar_tracker/id_markes", 10);
 }
 
 void VisualizeDetectedObjects::callBack(const autoware_msgs::DetectedObjectArray&amp; input)
@@ -20,47 +54,82 @@ void VisualizeDetectedObjects::callBack(const autoware_msgs::DetectedObjectArray
 
 void VisualizeDetectedObjects::visMarkers(const autoware_msgs::DetectedObjectArray&amp; input)
 {
+  visualization_msgs::MarkerArray marker_ids, marker_arows;
+
   for (size_t i = 0; i &lt; input.objects.size(); i++)
   {
-    double tv = input.objects[i].velocity.linear.x;
-    double tyaw = input.objects[i].velocity.linear.y;
+    // pose_reliable == true if tracking state is stable
+    // skip vizualizing if tracking state is unstable
+    if (!input.objects[i].pose_reliable)
+    {
+      continue;
+    }
 
-    visualization_msgs::Marker ids;
+    double velocity = input.objects[i].velocity.linear.x;
+
+    tf::Quaternion q(input.objects[i].pose.orientation.x, input.objects[i].pose.orientation.y,
+                     input.objects[i].pose.orientation.z, input.objects[i].pose.orientation.w);
+    double roll, pitch, yaw;
+    tf::Matrix3x3(q).getRPY(roll, pitch, yaw);
+
+    // in the case motion model fit opposite direction
+    if (velocity &lt; -0.1)
+    {
+      velocity *= -1;
+      yaw += M_PI;
+      // normalize angle
+      while (yaw &gt; M_PI)
+        yaw -= 2. * M_PI;
+      while (yaw &lt; -M_PI)
+        yaw += 2. * M_PI;
+    }
 
-    ids.lifetime = ros::Duration(0.15);
-    ids.header.frame_id = pointcloud_frame_;
-    ids.header.stamp = input.header.stamp;
-    ids.ns = "ids";
-    ids.action = visualization_msgs::Marker::ADD;
-    ids.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
+    visualization_msgs::Marker id;
+
+    id.lifetime = ros::Duration(0.2);
+    id.header.frame_id = pointcloud_frame_;
+    id.header.stamp = input.header.stamp;
+    id.ns = "id";
+    id.action = visualization_msgs::Marker::ADD;
+    id.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
     // green
-    ids.color.g = 1.0f;
-    ids.color.a = 1.0;
-    ids.id = i;
+    id.color.g = 1.0f;
+    id.color.a = 1.0;
+    id.id = input.objects[i].id;
 
     // Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
-    ids.pose.position.x = input.objects[i].pose.position.x;
-    ids.pose.position.y = input.objects[i].pose.position.y;
-    ids.pose.position.z = 1.5;
+    id.pose.position.x = input.objects[i].pose.position.x;
+    id.pose.position.y = input.objects[i].pose.position.y;
+    id.pose.position.z = vis_id_height_;
 
     // convert from RPY to quartenion
     tf::Matrix3x3 obs_mat;
-    obs_mat.setEulerYPR(tyaw, 0, 0);  // yaw, pitch, roll
+    obs_mat.setEulerYPR(yaw, 0, 0);  // yaw, pitch, roll
     tf::Quaternion q_tf;
     obs_mat.getRotation(q_tf);
-    ids.pose.orientation.x = q_tf.getX();
-    ids.pose.orientation.y = q_tf.getY();
-    ids.pose.orientation.z = q_tf.getZ();
-    ids.pose.orientation.w = q_tf.getW();
+    id.pose.orientation.x = q_tf.getX();
+    id.pose.orientation.y = q_tf.getY();
+    id.pose.orientation.z = q_tf.getZ();
+    id.pose.orientation.w = q_tf.getW();
+
+    id.scale.z = 1.0;
+
+    if (abs(velocity) &lt; ignore_velocity_thres_)
+    {
+      velocity = 0.0;
+    }
 
-    ids.scale.z = 1.0;
+    // convert unit m/s to km/h
+    std::string s_velocity = std::to_string(velocity * 3.6);
+    std::string modified_sv = s_velocity.substr(0, s_velocity.find(".") + 3);
+    std::string text = "&lt;" + std::to_string(input.objects[i].id) + "&gt; " + modified_sv + " km/h";
 
-    ids.text = std::to_string(input.objects[i].id);
+    id.text = text;
 
-    pub_id_.publish(ids);
+    marker_ids.markers.push_back(id);
 
-    visualization_msgs::Marker arrows;
-    arrows.lifetime = ros::Duration(0.1);
+    visualization_msgs::Marker arrow;
+    arrow.lifetime = ros::Duration(0.2);
 
     // visualize velocity arrow only if its status is Stable
     std::string label = input.objects[i].label;
@@ -68,32 +137,38 @@ void VisualizeDetectedObjects::visMarkers(const autoware_msgs::DetectedObjectArr
     {
       continue;
     }
+    if (abs(velocity) &lt; visualize_arrow_velocity_thres_)
+    {
+      continue;
+    }
 
-    arrows.header.frame_id = pointcloud_frame_;
-    arrows.header.stamp = input.header.stamp;
-    arrows.ns = "arrows";
-    arrows.action = visualization_msgs::Marker::ADD;
-    arrows.type = visualization_msgs::Marker::ARROW;
+    arrow.header.frame_id = pointcloud_frame_;
+    arrow.header.stamp = input.header.stamp;
+    arrow.ns = "arrow";
+    arrow.action = visualization_msgs::Marker::ADD;
+    arrow.type = visualization_msgs::Marker::ARROW;
     // green
-    arrows.color.g = 1.0f;
-    arrows.color.a = 1.0;
-    arrows.id = i;
+    arrow.color.g = 1.0f;
+    arrow.color.a = 1.0;
+    arrow.id = input.objects[i].id;
 
     // Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
-    arrows.pose.position.x = input.objects[i].pose.position.x;
-    arrows.pose.position.y = input.objects[i].pose.position.y;
-    arrows.pose.position.z = 0.5;
-
-    arrows.pose.orientation.x = q_tf.getX();
-    arrows.pose.orientation.y = q_tf.getY();
-    arrows.pose.orientation.z = q_tf.getZ();
-    arrows.pose.orientation.w = q_tf.getW();
-
-    // Set the scale of the arrows -- 1x1x1 here means 1m on a side
-    arrows.scale.x = tv;
-    arrows.scale.y = 0.1;
-    arrows.scale.z = 0.1;
-
-    pub_arrow_.publish(arrows);
-  }
+    arrow.pose.position.x = input.objects[i].pose.position.x;
+    arrow.pose.position.y = input.objects[i].pose.position.y;
+    arrow.pose.position.z = vis_arrow_height_;
+
+    arrow.pose.orientation.x = q_tf.getX();
+    arrow.pose.orientation.y = q_tf.getY();
+    arrow.pose.orientation.z = q_tf.getZ();
+    arrow.pose.orientation.w = q_tf.getW();
+
+    // Set the scale of the arrow -- 1x1x1 here means 1m on a side
+    arrow.scale.x = 3;
+    arrow.scale.y = 0.1;
+    arrow.scale.z = 0.1;
+
+    marker_arows.markers.push_back(arrow);
+  }  // end input.objects loop
+  pub_id_.publish(marker_ids);
+  pub_arrow_.publish(marker_arows);
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\visualize_detected_objects\visualize_detected_objects_main.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\visualize_detected_objects\visualize_detected_objects_main.cpp" added_lines="29" deleted_lines="0">
				<diff>@@ -1,3 +1,32 @@
+/*
+ *  Copyright (c) 2018, Nagoya University
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ *  * Neither the name of Autoware nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 
 #include "visualize_detected_objects.h"
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="86f74272b0d933abb4b5d4e0a28802592843f4f1" author="Esteve Fernandez">
		<msg>[fix] PascalCase messages (#1408)

* Switch message files to pascal case

* Switch message names to pascal case in Runtime Manager

* Switch message names to pascal case in *.yaml

* Rename brake_cmd and steer_cmd to BrakeCmd and SteerCmd in main.yaml</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -48,7 +48,7 @@
 #include &lt;std_msgs/MultiArrayLayout.h&gt;
 #include &lt;std_msgs/MultiArrayDimension.h&gt;
 
-#include "autoware_msgs/centroids.h"
+#include "autoware_msgs/Centroids.h"
 #include "autoware_msgs/CloudCluster.h"
 #include "autoware_msgs/CloudClusterArray.h"
 #include "autoware_msgs/DetectedObject.h"
@@ -317,12 +317,12 @@ void publishCloudClusters(const ros::Publisher* in_publisher, const autoware_msg
   }
 }
 
-void publishCentroids(const ros::Publisher* in_publisher, const autoware_msgs::centroids&amp; in_centroids,
+void publishCentroids(const ros::Publisher* in_publisher, const autoware_msgs::Centroids&amp; in_centroids,
                       const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
 {
   if (in_target_frame != in_header.frame_id)
   {
-    autoware_msgs::centroids centroids_transformed;
+    autoware_msgs::Centroids centroids_transformed;
     centroids_transformed.header = in_header;
     centroids_transformed.header.frame_id = in_target_frame;
     for (auto i = centroids_transformed.points.begin(); i != centroids_transformed.points.end(); i++)
@@ -420,7 +420,7 @@ void keepLanePoints(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 std::vector&lt;ClusterPtr&gt; clusterAndColorGpu(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
                                            pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
                                            jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
-                                           autoware_msgs::centroids&amp; in_out_centroids,
+                                           autoware_msgs::Centroids&amp; in_out_centroids,
                                            double in_max_cluster_distance = 0.5)
 {
   std::vector&lt;ClusterPtr&gt; clusters;
@@ -480,7 +480,7 @@ std::vector&lt;ClusterPtr&gt; clusterAndColorGpu(const pcl::PointCloud&lt;pcl::PointXYZ&gt;:
 std::vector&lt;ClusterPtr&gt; clusterAndColor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
                                         pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
                                         jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
-                                        autoware_msgs::centroids&amp; in_out_centroids,
+                                        autoware_msgs::Centroids&amp; in_out_centroids,
                                         double in_max_cluster_distance = 0.5)
 {
   pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;);
@@ -626,7 +626,7 @@ void checkAllForMerge(std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;ClusterP
 void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
                        pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
                        jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
-                       autoware_msgs::centroids&amp; in_out_centroids, autoware_msgs::CloudClusterArray&amp; in_out_clusters,
+                       autoware_msgs::Centroids&amp; in_out_centroids, autoware_msgs::CloudClusterArray&amp; in_out_clusters,
                        jsk_recognition_msgs::PolygonArray&amp; in_out_polygon_array,
                        jsk_rviz_plugins::PictogramArray&amp; in_out_pictogram_array)
 {
@@ -1031,7 +1031,7 @@ void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr clipped_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
     pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr colored_clustered_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
 
-    autoware_msgs::centroids centroids;
+    autoware_msgs::Centroids centroids;
     autoware_msgs::CloudClusterArray cloud_clusters;
     jsk_recognition_msgs::BoundingBoxArray boundingbox_array;
     jsk_recognition_msgs::PolygonArray polygon_array;
@@ -1209,7 +1209,7 @@ int main(int argc, char** argv)
 
   _pub_cluster_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_cluster", 1);
   _pub_ground_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_ground", 1);
-  _centroid_pub = h.advertise&lt;autoware_msgs::centroids&gt;("/cluster_centroids", 1);
+  _centroid_pub = h.advertise&lt;autoware_msgs::Centroids&gt;("/cluster_centroids", 1);
   _marker_pub = h.advertise&lt;visualization_msgs::Marker&gt;("centroid_marker", 1);
 
   _pub_points_lanes_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_lanes", 1);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\libs\fusion\include\fusion\fusion_func.h" new_path="ros\src\computing\perception\detection\lidar_tracker\libs\fusion\include\fusion\fusion_func.h" added_lines="5" deleted_lines="5">
				<diff>@@ -38,11 +38,11 @@
 #include &lt;vector&gt;
 
 #include &lt;ros/ros.h&gt;
-#include "autoware_msgs/image_obj.h"
-#include "autoware_msgs/image_rect_ranged.h"
+#include "autoware_msgs/ImageObj.h"
+#include "autoware_msgs/ImageRectRanged.h"
 #include "autoware_msgs/ScanImage.h"
 #include "autoware_msgs/PointsImage.h"
-#include "autoware_msgs/image_obj_tracked.h"
+#include "autoware_msgs/ImageObjTracked.h"
 
 #include &lt;opencv2/opencv.hpp&gt;
 
@@ -81,10 +81,10 @@ extern std::vector&lt;float&gt; getMaxHeights();
 extern void setParams(float minLowHeight, float maxLowHeight, float maxHeight, int minPoints, float disp);
 
 extern void calcDistance();
-extern void setDetectedObjects(const autoware_msgs::image_obj&amp; image_objects);
+extern void setDetectedObjects(const autoware_msgs::ImageObj&amp; image_objects);
 extern void setScanImage(const autoware_msgs::ScanImage&amp; scan_image);
 extern void setPointsImage(const autoware_msgs::PointsImage&amp; points_image);
-extern std::vector&lt;autoware_msgs::image_rect_ranged&gt; getObjectsRectRanged();
+extern std::vector&lt;autoware_msgs::ImageRectRanged&gt; getObjectsRectRanged();
 extern std::string getObjectsType();
 extern void init();
 extern void destroy();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\libs\fusion\src\fusion.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\libs\fusion\src\fusion.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -265,7 +265,7 @@ static void showRects(IplImage *image, int object_num, const std::vector&lt;int&gt;&amp; c
 }
 #endif
 
-void setDetectedObjects(const autoware_msgs::image_obj&amp; detected_objects)
+void setDetectedObjects(const autoware_msgs::ImageObj&amp; detected_objects)
 {
 	objectsStored = false;
 	obj_type = detected_objects.type;
@@ -446,13 +446,13 @@ std::vector&lt;float&gt; getMaxHeights()
 	return filtered_max_heights;
 }
 
-std::vector&lt;autoware_msgs::image_rect_ranged&gt; getObjectsRectRanged()
+std::vector&lt;autoware_msgs::ImageRectRanged&gt; getObjectsRectRanged()
 {
-	std::vector&lt;autoware_msgs::image_rect_ranged&gt; fused_objects;
+	std::vector&lt;autoware_msgs::ImageRectRanged&gt; fused_objects;
 	for (int i=0; i&lt;filtered_objects_num; i++)
 	{
 		int base = i * 4;
-		autoware_msgs::image_rect_ranged obj_ranged;
+		autoware_msgs::ImageRectRanged obj_ranged;
 		obj_ranged.rect.x      = filtered_corner_points.at(base);
 		obj_ranged.rect.y      = filtered_corner_points.at(base + 1);
 		obj_ranged.rect.width  = filtered_corner_points.at(base + 2);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_fusion\nodes\obj_fusion\obj_fusion.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_fusion\nodes\obj_fusion\obj_fusion.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -3,7 +3,7 @@
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-#include "autoware_msgs/obj_label.h"
+#include "autoware_msgs/ObjLabel.h"
 #include "autoware_msgs/CloudCluster.h"
 #include "autoware_msgs/CloudClusterArray.h"
 #include &lt;math.h&gt;
@@ -65,7 +65,7 @@ static double euclid_distance(const geometry_msgs::Point pos1, const geometry_ms
 } /* static double distance() */
 
 /* fusion reprojected position and pointcloud centroids */
-void fusion_cb(const autoware_msgs::obj_label::ConstPtr &amp;obj_label_msg,
+void fusion_cb(const autoware_msgs::ObjLabel::ConstPtr &amp;obj_label_msg,
                const autoware_msgs::CloudClusterArray::ConstPtr &amp;in_cloud_cluster_array_ptr)
 {
   tf::StampedTransform tform;
@@ -351,9 +351,9 @@ int main(int argc, char *argv[])
   private_n.param("vmap_threshold", vmap_threshold, 5.0);
   vmap_threshold *= vmap_threshold;  // squared
 
-  typedef message_filters::sync_policies::ApproximateTime&lt;autoware_msgs::obj_label, autoware_msgs::CloudClusterArray&gt;
+  typedef message_filters::sync_policies::ApproximateTime&lt;autoware_msgs::ObjLabel, autoware_msgs::CloudClusterArray&gt;
       SyncPolicy;
-  message_filters::Subscriber&lt;autoware_msgs::obj_label&gt; obj_label_sub(n, "obj_label", SUBSCRIBE_QUEUE_SIZE);
+  message_filters::Subscriber&lt;autoware_msgs::ObjLabel&gt; obj_label_sub(n, "obj_label", SUBSCRIBE_QUEUE_SIZE);
   message_filters::Subscriber&lt;autoware_msgs::CloudClusterArray&gt; cluster_centroids_sub(n, "/cloud_clusters",
                                                                                       SUBSCRIBE_QUEUE_SIZE);
   message_filters::Synchronizer&lt;SyncPolicy&gt; sync(SyncPolicy(SUBSCRIBE_QUEUE_SIZE), obj_label_sub,
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\nodes\obj_reproj\obj_reproj.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\nodes\obj_reproj\obj_reproj.cpp" added_lines="10" deleted_lines="10">
				<diff>@@ -53,9 +53,9 @@
 #include "cal_obj_loc.h"
 #include "calcoordinates.h"
 #include "structure.h"
-#include &lt;autoware_msgs/image_obj_tracked.h&gt;
-#include &lt;autoware_msgs/obj_label.h&gt;
-#include &lt;autoware_msgs/projection_matrix.h&gt;
+#include &lt;autoware_msgs/ImageObjTracked.h&gt;
+#include &lt;autoware_msgs/ObjLabel.h&gt;
+#include &lt;autoware_msgs/ProjectionMatrix.h&gt;
 #include &lt;geometry_msgs/Pose.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;mutex&gt;
@@ -117,7 +117,7 @@ static tf::StampedTransform transformCam2Map;
 std::string camera_id_str;
 
 static visualization_msgs::MarkerArray
-convert_marker_array(const autoware_msgs::obj_label &amp;src) {
+convert_marker_array(const autoware_msgs::ObjLabel &amp;src) {
   visualization_msgs::MarkerArray ret;
   int index = 0;
   std_msgs::ColorRGBA color_red;
@@ -188,7 +188,7 @@ convert_marker_array(const autoware_msgs::obj_label &amp;src) {
 }
 
 static jsk_recognition_msgs::BoundingBoxArray
-convertJskBoundingBoxArray(const autoware_msgs::obj_label &amp;src) {
+convertJskBoundingBoxArray(const autoware_msgs::ObjLabel &amp;src) {
   jsk_recognition_msgs::BoundingBoxArray ret;
   ret.header.frame_id = "map";
 
@@ -208,7 +208,7 @@ convertJskBoundingBoxArray(const autoware_msgs::obj_label &amp;src) {
   return ret;
 }
 
-static void projection_callback(const autoware_msgs::projection_matrix &amp;msg) {
+static void projection_callback(const autoware_msgs::ProjectionMatrix &amp;msg) {
   for (int row = 0; row &lt; 4; row++) {
     for (int col = 0; col &lt; 4; col++) {
       cameraMatrix[row][col] = msg.projection_matrix[row * 4 + col];
@@ -239,7 +239,7 @@ void GetRPY(const geometry_msgs::Pose &amp;pose, double &amp;roll, double &amp;pitch,
 
 void makeSendDataDetectedObj(vector&lt;OBJPOS&gt; car_position_vector,
                              vector&lt;OBJPOS&gt;::iterator cp_iterator,
-                             autoware_msgs::obj_label &amp;send_data) {
+                             autoware_msgs::ObjLabel &amp;send_data) {
   geometry_msgs::Point tmpPoint;
 
   for (uint i = 0; i &lt; car_position_vector.size(); i++, cp_iterator++) {
@@ -283,7 +283,7 @@ void locatePublisher(void) {
   // get values from sample_corner_point , convert latitude and longitude,
   // and send database server.
 
-  autoware_msgs::obj_label obj_label_msg;
+  autoware_msgs::ObjLabel obj_label_msg;
   visualization_msgs::MarkerArray obj_label_marker_msgs;
 
   vector&lt;OBJPOS&gt;::iterator cp_iterator;
@@ -316,7 +316,7 @@ void locatePublisher(void) {
 }
 
 static void
-obj_pos_xyzCallback(const autoware_msgs::image_obj_tracked &amp;fused_objects) {
+obj_pos_xyzCallback(const autoware_msgs::ImageObjTracked &amp;fused_objects) {
   if (!ready_)
     return;
   image_obj_tracked_time = fused_objects.header.stamp;
@@ -394,7 +394,7 @@ int main(int argc, char **argv) {
   ros::Subscriber obj_pos_xyz =
       n.subscribe("image_obj_tracked", 1, obj_pos_xyzCallback);
 
-  pub = n.advertise&lt;autoware_msgs::obj_label&gt;("obj_label", 1);
+  pub = n.advertise&lt;autoware_msgs::ObjLabel&gt;("obj_label", 1);
   marker_pub =
       n.advertise&lt;visualization_msgs::MarkerArray&gt;("obj_label_marker", 1);
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\range_fusion\nodes\range_fusion\range_fusion.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\range_fusion\nodes\range_fusion\range_fusion.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -31,7 +31,7 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Header.h&gt;
 #include &lt;fusion/fusion_func.h&gt;
-#include "autoware_msgs/image_obj_ranged.h"
+#include "autoware_msgs/ImageObjRanged.h"
 #include "autoware_msgs/ConfigCarFusion.h"
 
 static void publishTopic();
@@ -40,7 +40,7 @@ static std_msgs::Header sensor_header;
 
 bool ready_ = false;
 
-static void DetectedObjectsCallback(const autoware_msgs::image_obj&amp; image_object)
+static void DetectedObjectsCallback(const autoware_msgs::ImageObj&amp; image_object)
 {
     sensor_header = image_object.header;
     setDetectedObjects(image_object);
@@ -80,7 +80,7 @@ static void publishTopic()
 	/*
 	 * Publish topic(obj position ranged).
 	 */
-	autoware_msgs::image_obj_ranged fused_objects_msg;
+	autoware_msgs::ImageObjRanged fused_objects_msg;
 	fused_objects_msg.header = sensor_header;
 
 	fused_objects_msg.type = getObjectsType();
@@ -133,7 +133,7 @@ int main(int argc, char **argv)
 #if _DEBUG
 	ros::Subscriber image_sub = n.subscribe(IMAGE_TOPIC, 1, IMAGE_CALLBACK);
 #endif
-	fused_objects = n.advertise&lt;autoware_msgs::image_obj_ranged&gt;("image_obj_ranged", 1);
+	fused_objects = n.advertise&lt;autoware_msgs::ImageObjRanged&gt;("image_obj_ranged", 1);
 
 	ros::Subscriber config_subscriber;
 	std::string config_topic("/config");
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\feat_proj\feat_proj.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\feat_proj\feat_proj.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -21,10 +21,10 @@
 #include "libvectormap/Math.h"
 #include &lt;Eigen/Eigen&gt;
 #include &lt;autoware_msgs/Signals.h&gt;
-#include &lt;autoware_msgs/adjust_xy.h&gt;
+#include &lt;autoware_msgs/AdjustXY.h&gt;
 #include &lt;vector_map/vector_map.h&gt;
 #include &lt;vector_map_server/GetSignal.h&gt;
-#include &lt;autoware_msgs/lane.h&gt;
+#include &lt;autoware_msgs/Lane.h&gt;
 
 static std::string camera_id_str;
 
@@ -65,7 +65,7 @@ namespace
 	{
 	private:
 		geometry_msgs::PoseStamped pose_;
-		autoware_msgs::lane waypoints_;
+		autoware_msgs::Lane waypoints_;
 
 	public:
 		VectorMapClient()
@@ -81,7 +81,7 @@ namespace
 			return pose_;
 		}
 
-		autoware_msgs::lane waypoints() const
+		autoware_msgs::Lane waypoints() const
 		{
 			return waypoints_;
 		}
@@ -91,7 +91,7 @@ namespace
 			pose_ = pose;
 		}
 
-		void set_waypoints(const autoware_msgs::lane &amp;waypoints)
+		void set_waypoints(const autoware_msgs::Lane &amp;waypoints)
 		{
 			waypoints_ = waypoints;
 		}
@@ -101,7 +101,7 @@ static VectorMapClient g_vector_map_client;
 
 
 /* Callback function to shift projection result */
-void adjust_xyCallback(const autoware_msgs::adjust_xy::ConstPtr &amp;config_msg)
+void adjust_xyCallback(const autoware_msgs::AdjustXY::ConstPtr &amp;config_msg)
 {
 	adjust_proj_x = config_msg-&gt;x;
 	adjust_proj_y = config_msg-&gt;y;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr\region_tlr.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr\region_tlr.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -12,7 +12,7 @@
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;autoware_msgs/traffic_light.h&gt;
+#include &lt;autoware_msgs/TrafficLight.h&gt;
 #include &lt;autoware_msgs/Signals.h&gt;
 #include &lt;autoware_msgs/TunedResult.h&gt;
 #include &lt;autoware_msgs/TrafficLightResultArray.h&gt;
@@ -209,7 +209,7 @@ static void extractedPos_cb(const autoware_msgs::Signals::ConstPtr &amp;extractedPos
 	detector.brightnessDetect(frame);
 
 	/* publish result */
-	autoware_msgs::traffic_light state_msg;
+	autoware_msgs::TrafficLight state_msg;
 	autoware_msgs::TrafficLightResultArray tlr_result_array_msg;
 	tlr_result_array_msg.header = extractedPos-&gt;header;
 
@@ -495,7 +495,7 @@ int main(int argc, char *argv[])
 	ros::Subscriber tunedResult_sub = n.subscribe("/tuned_result", 1, tunedResult_cb);
 	ros::Subscriber superimpose_sub = n.subscribe("/config/superimpose", 1, superimpose_cb);
 
-	signalState_pub = n.advertise&lt;autoware_msgs::traffic_light&gt;(camera_light_color_topic_name, ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
+	signalState_pub = n.advertise&lt;autoware_msgs::TrafficLight&gt;(camera_light_color_topic_name, ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
 	signalStateString_pub = n.advertise&lt;std_msgs::String&gt;("/sound_player", ADVERTISE_QUEUE_SIZE);
 	marker_pub = n.advertise&lt;visualization_msgs::MarkerArray&gt;("tlr_result", ADVERTISE_QUEUE_SIZE);
 	superimpose_image_pub = n.advertise&lt;sensor_msgs::Image&gt;("tlr_superimpose_image", ADVERTISE_QUEUE_SIZE);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -1,6 +1,6 @@
 #include &lt;string&gt;
 
-#include &lt;autoware_msgs/traffic_light.h&gt;
+#include &lt;autoware_msgs/TrafficLight.h&gt;
 #include &lt;std_msgs/String.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
@@ -168,7 +168,7 @@ void RegionTlrMxNetRosNode::StartSubscribersAndPublishers()
                                           this);
 
 	// Register publishers
-	signal_state_publisher = node_handle.advertise&lt;autoware_msgs::traffic_light&gt;("light_color", 1);
+	signal_state_publisher = node_handle.advertise&lt;autoware_msgs::TrafficLight&gt;("light_color", 1);
 	signal_state_string_publisher = node_handle.advertise&lt;std_msgs::String&gt;("/sound_player", 1);
 	marker_publisher = node_handle.advertise&lt;visualization_msgs::MarkerArray&gt;("tlr_result", 1, kAdvertiseInLatch_);
 	superimpose_image_publisher = node_handle.advertise&lt;sensor_msgs::Image&gt;("tlr_superimpose_image", 1);
@@ -212,7 +212,7 @@ void RegionTlrMxNetRosNode::DetermineState(LightState in_current_state,
 
 void RegionTlrMxNetRosNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts)
 {
-	autoware_msgs::traffic_light topic;
+	autoware_msgs::TrafficLight topic;
 	static int32_t previous_state = kTrafficLightUnknown;
 	topic.traffic_light = kTrafficLightUnknown;
 	for (const auto ctx: contexts)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -2,7 +2,7 @@
 
 #include &lt;string&gt;
 
-#include &lt;autoware_msgs/traffic_light.h&gt;
+#include &lt;autoware_msgs/TrafficLight.h&gt;
 #include &lt;std_msgs/String.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
@@ -160,7 +160,7 @@ void RegionTlrSsdRosNode::StartSubscribersAndPublishers() {
                                                 this);
 
   // Register publishers
-  signal_state_publisher        = node_handle.advertise&lt;autoware_msgs::traffic_light&gt;("light_color", 1);
+  signal_state_publisher        = node_handle.advertise&lt;autoware_msgs::TrafficLight&gt;("light_color", 1);
   signal_state_string_publisher = node_handle.advertise&lt;std_msgs::String&gt;("/sound_player", 1);
   marker_publisher              = node_handle.advertise&lt;visualization_msgs::MarkerArray&gt;("tlr_result", 1, kAdvertiseInLatch_);
   superimpose_image_publisher   = node_handle.advertise&lt;sensor_msgs::Image&gt;("tlr_superimpose_image", 1);
@@ -192,10 +192,10 @@ LightState RegionTlrSsdRosNode::DetermineState(LightState previous_state,
 
 
 // =================================================================
-// Publish recognition result as autoware_msgs::traffic_light type
+// Publish recognition result as autoware_msgs::TrafficLight type
 // =================================================================
 void RegionTlrSsdRosNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts) {
-  autoware_msgs::traffic_light topic;
+  autoware_msgs::TrafficLight topic;
   static int32_t previous_state = kTrafficLightUnknown;
   topic.traffic_light = kTrafficLightUnknown;
   for (const auto ctx: contexts) {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\tl_switch\tl_switch.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\tl_switch\tl_switch.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -1,6 +1,6 @@
 #include "TrafficLight.h"
 #include "ros/ros.h"
-#include &lt;autoware_msgs/traffic_light.h&gt;
+#include &lt;autoware_msgs/TrafficLight.h&gt;
 #include &lt;chrono&gt;
 #include &lt;thread&gt;
 
@@ -16,16 +16,16 @@ private:
   void reset_light_msg();
   void watchdog_timer();
   void camera_light_color_callback(
-      const autoware_msgs::traffic_light::ConstPtr &amp;input_msg);
+      const autoware_msgs::TrafficLight::ConstPtr &amp;input_msg);
   void ams_light_color_callback(
-      const autoware_msgs::traffic_light::ConstPtr &amp;input_msg);
+      const autoware_msgs::TrafficLight::ConstPtr &amp;input_msg);
 
   std::string light_color_topic_name_;
   std::string camera_light_color_topic_name_;
   std::string ams_light_color_topic_name_;
-  autoware_msgs::traffic_light camera_msg_;
-  autoware_msgs::traffic_light ams_msg_;
-  autoware_msgs::traffic_light state_msg_;
+  autoware_msgs::TrafficLight camera_msg_;
+  autoware_msgs::TrafficLight ams_msg_;
+  autoware_msgs::TrafficLight state_msg_;
   ros::NodeHandle nh_;
   ros::NodeHandle private_nh_;
   ros::Publisher traffic_light_pub_;
@@ -46,7 +46,7 @@ TLSwitch::TLSwitch(const ros::NodeHandle &amp;nh, const ros::NodeHandle &amp;private_nh)
                                  "/camera_light_color");
   private_nh_.param&lt;std::string&gt;(
       "ams_light_color_topic", ams_light_color_topic_name_, "/ams_light_color");
-  traffic_light_pub_ = nh_.advertise&lt;autoware_msgs::traffic_light&gt;(
+  traffic_light_pub_ = nh_.advertise&lt;autoware_msgs::TrafficLight&gt;(
       light_color_topic_name_, 1, ADVERTISE_LATCH);
   camera_sub_ = nh_.subscribe(camera_light_color_topic_name_, 1,
                               &amp;TLSwitch::camera_light_color_callback, this);
@@ -84,13 +84,13 @@ void TLSwitch::watchdog_timer() {
 }
 
 void TLSwitch::camera_light_color_callback(
-    const autoware_msgs::traffic_light::ConstPtr &amp;msg) {
+    const autoware_msgs::TrafficLight::ConstPtr &amp;msg) {
   camera_msg_.traffic_light = msg-&gt;traffic_light;
   switch_color();
 }
 
 void TLSwitch::ams_light_color_callback(
-    const autoware_msgs::traffic_light::ConstPtr &amp;msg) {
+    const autoware_msgs::TrafficLight::ConstPtr &amp;msg) {
   ams_msg_time_ = ros::Time::now();
   is_ams_timeout_ = false;
   ams_msg_.traffic_light = msg-&gt;traffic_light;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" added_lines="3" deleted_lines="3">
				<diff>@@ -6,9 +6,9 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;rviz/panel.h&gt;
-#include "autoware_msgs/image_obj.h"
-#include "autoware_msgs/image_obj_ranged.h"
-#include "autoware_msgs/image_obj_tracked.h"
+#include "autoware_msgs/ImageObj.h"
+#include "autoware_msgs/ImageObjRanged.h"
+#include "autoware_msgs/ImageObjTracked.h"
 #include "autoware_msgs/PointsImage.h"
 
 #include &lt;string&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 #include &lt;ros/ros.h&gt;
-#include "autoware_msgs/traffic_light.h"
+#include "autoware_msgs/TrafficLight.h"
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 #include &lt;opencv2/imgproc/imgproc.hpp&gt;
@@ -30,7 +30,7 @@ namespace integrated_viewer
   } // TrafficLightPlugin::TrafficLightPlugin()
 
 
-  void TrafficLightPlugin::SignalStateCallback(const autoware_msgs::traffic_light::ConstPtr&amp; msg) {
+  void TrafficLightPlugin::SignalStateCallback(const autoware_msgs::TrafficLight::ConstPtr&amp; msg) {
     StateInfo info = {};
     GetStateInfo(static_cast&lt;StateNumber&gt;(msg-&gt;traffic_light), info);
     SetStateInfo(info);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.h" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.h" added_lines="2" deleted_lines="2">
				<diff>@@ -6,7 +6,7 @@
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
 #include &lt;rviz/panel.h&gt;
-#include "autoware_msgs/traffic_light.h"
+#include "autoware_msgs/TrafficLight.h"
 
 #include "convert_image.h"
 #include "ui_form.h"
@@ -36,7 +36,7 @@ namespace integrated_viewer
     };
 
     // The Callback function for signal state
-    void SignalStateCallback(const autoware_msgs::traffic_light::ConstPtr&amp; msg);
+    void SignalStateCallback(const autoware_msgs::TrafficLight::ConstPtr&amp; msg);
 
     // The function to convert recognition result to color and string information
     void GetStateInfo(const StateNumber num, StateInfo&amp; info);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\image_d_viewer\image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\image_d_viewer\image_d_viewer.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -36,7 +36,7 @@
 #include "ros/ros.h"
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;sensor_msgs/CompressedImage.h&gt;
-#include "autoware_msgs/image_obj_ranged.h"
+#include "autoware_msgs/ImageObjRanged.h"
 #include &lt;math.h&gt;
 #include &lt;float.h&gt;
 #define NO_DATA 0
@@ -49,8 +49,8 @@ static IplImage temp;
 static IplImage *image;
 static double ratio = 1;	//resize ratio
 
-static autoware_msgs::image_obj_ranged car_fused_objects;
-static autoware_msgs::image_obj_ranged pedestrian_fused_objects;
+static autoware_msgs::ImageObjRanged car_fused_objects;
+static autoware_msgs::ImageObjRanged pedestrian_fused_objects;
 
 static const int OBJ_RECT_THICKNESS = 3;
 static void showImage();
@@ -64,7 +64,7 @@ static inline bool isNearlyNODATA(float x)
 }
 
 void showRects(IplImage *Image,
-               std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
+               std::vector&lt;autoware_msgs::ImageRectRanged&gt; objects,
                double ratio,
                CvScalar col)
 {
@@ -80,7 +80,7 @@ void showRects(IplImage *Image,
     }
 }
 
-static void obj_carCallback(const autoware_msgs::image_obj_ranged&amp; fused_objects)
+static void obj_carCallback(const autoware_msgs::ImageObjRanged&amp; fused_objects)
 {
     if(image == NULL){
       return;
@@ -89,7 +89,7 @@ static void obj_carCallback(const autoware_msgs::image_obj_ranged&amp; fused_objects
     showImage();
 }
 
-static void obj_personCallback(const autoware_msgs::image_obj_ranged&amp; fused_objects)
+static void obj_personCallback(const autoware_msgs::ImageObjRanged&amp; fused_objects)
 {
     if(image == NULL){
       return;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -44,7 +44,7 @@
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;autoware_msgs/PointsImage.h&gt;
 
-#include "autoware_msgs/image_obj_ranged.h"
+#include "autoware_msgs/ImageObjRanged.h"
 #include &lt;vector&gt;
 #include &lt;iostream&gt;
 #include &lt;math.h&gt;
@@ -63,8 +63,8 @@ static cv::Mat colormap;
 static std::vector&lt;cv::Rect&gt; cars;
 static std::vector&lt;cv::Rect&gt; peds;
 #else
-static autoware_msgs::image_obj_ranged car_fused_objects;
-static autoware_msgs::image_obj_ranged pedestrian_fused_objects;
+static autoware_msgs::ImageObjRanged car_fused_objects;
+static autoware_msgs::ImageObjRanged pedestrian_fused_objects;
 #endif
 
 /* check whether floating value x is nearly 0 or not */
@@ -83,7 +83,7 @@ static std::vector&lt;cv::Scalar&gt; _colors;
 static const int OBJ_RECT_THICKNESS = 3;
 
 static void drawRects(IplImage *Image,
-                      std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
+                      std::vector&lt;autoware_msgs::ImageRectRanged&gt; objects,
                       CvScalar color,
                       int threshold_height)
 {
@@ -98,7 +98,7 @@ static void drawRects(IplImage *Image,
 }
 
 static void putDistance(IplImage *Image,
-                        std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
+                        std::vector&lt;autoware_msgs::ImageRectRanged&gt; objects,
                         int threshold_height,
                         const char* objectLabel)
 {
@@ -283,7 +283,7 @@ static void car_updater_callback(dpm::ImageObjects image_objects_msg)
   }
 }
 #else
-static void car_updater_callback(const autoware_msgs::image_obj_ranged&amp; fused_car_msg)
+static void car_updater_callback(const autoware_msgs::ImageObjRanged&amp; fused_car_msg)
 {
   car_fused_objects = fused_car_msg;
   //  show();
@@ -308,7 +308,7 @@ static void ped_updater_callback(dpm::ImageObjects image_objects_msg)
   }
 }
 #else
-static void ped_updater_callback(const autoware_msgs::image_obj_ranged&amp; fused_pds_msg)
+static void ped_updater_callback(const autoware_msgs::ImageObjRanged&amp; fused_pds_msg)
 {
   pedestrian_fused_objects = fused_pds_msg;
   //  show();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\scan_image_d_viewer\scan_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\scan_image_d_viewer\scan_image_d_viewer.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -42,7 +42,7 @@
 #include &lt;iostream&gt;
 #include &lt;math.h&gt;
 #include &lt;float.h&gt;
-#include "autoware_msgs/image_obj_ranged.h"
+#include "autoware_msgs/ImageObjRanged.h"
 #include "autoware_msgs/ScanImage.h"
 
 #define IMAGE_WIDTH 800
@@ -58,8 +58,8 @@ bool exist_image = false;
 bool exist_scan = false;
 cv::Mat colormap;
 
-autoware_msgs::image_obj_ranged car_fused_objects;
-autoware_msgs::image_obj_ranged pedestrian_fused_objects;
+autoware_msgs::ImageObjRanged car_fused_objects;
+autoware_msgs::ImageObjRanged pedestrian_fused_objects;
 static const int OBJ_RECT_THICKNESS = 3;
 
 /* check whether floating value x is nearly 0 or not */
@@ -71,7 +71,7 @@ static inline bool isNearlyNODATA(float x)
 }
 
 static void putDistance(IplImage *Image,
-                        std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
+                        std::vector&lt;autoware_msgs::ImageRectRanged&gt; objects,
                         int threshold_height,
                         const char* objectLabel)
 {
@@ -147,7 +147,7 @@ static void putDistance(IplImage *Image,
 }
 
 static void drawRects(IplImage *Image,
-                      std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
+                      std::vector&lt;autoware_msgs::ImageRectRanged&gt; objects,
                       CvScalar color,
                       int threshold_height)
 {
@@ -236,13 +236,13 @@ static void scan_image_callback(const autoware_msgs::ScanImage&amp; scan_image_msg)
     show();
 }
 
-static void car_fusion_callback(const autoware_msgs::image_obj_ranged&amp; fused_car_msg)
+static void car_fusion_callback(const autoware_msgs::ImageObjRanged&amp; fused_car_msg)
 {
   car_fused_objects = fused_car_msg;
 //  show();
 }
 
-static void ped_fusion_callback(const autoware_msgs::image_obj_ranged&amp; fused_pds_msg)
+static void ped_fusion_callback(const autoware_msgs::ImageObjRanged&amp; fused_pds_msg)
 {
   pedestrian_fused_objects = fused_pds_msg;
 //  show();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\traffic_light_viewer\traffic_light_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\traffic_light_viewer\traffic_light_viewer.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 #include &lt;ros/ros.h&gt;
-#include &lt;autoware_msgs/traffic_light.h&gt;
+#include &lt;autoware_msgs/TrafficLight.h&gt;
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 #include &lt;opencv2/imgproc/imgproc.hpp&gt;
@@ -13,7 +13,7 @@ static const int32_t TRAFFIC_LIGHT_RED     = 0;
 static const int32_t TRAFFIC_LIGHT_GREEN   = 1;
 static const int32_t TRAFFIC_LIGHT_UNKNOWN = 2;
 
-static void signalState_cb(const autoware_msgs::traffic_light::ConstPtr&amp; msg)
+static void signalState_cb(const autoware_msgs::TrafficLight::ConstPtr&amp; msg)
 {
   const int   fontFace      = cv::FONT_HERSHEY_COMPLEX;
   const float fontScale     = 1.0f;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -35,7 +35,7 @@
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;autoware_msgs/PointsImage.h&gt;
 
-#include &lt;autoware_msgs/image_obj_ranged.h&gt;
+#include &lt;autoware_msgs/ImageObjRanged.h&gt;
 #include &lt;vector&gt;
 #include &lt;iostream&gt;
 #include &lt;math.h&gt;
@@ -58,8 +58,8 @@ static cv::Mat colormap;
 static std::vector&lt;cv::Rect&gt; cars;
 static std::vector&lt;cv::Rect&gt; peds;
 #else
-static autoware_msgs::image_obj_ranged car_fused_objects;
-static autoware_msgs::image_obj_ranged pedestrian_fused_objects;
+static autoware_msgs::ImageObjRanged car_fused_objects;
+static autoware_msgs::ImageObjRanged pedestrian_fused_objects;
 #endif
 
 /* check whether floating value x is nearly 0 or not */
@@ -80,7 +80,7 @@ static std::vector&lt;cv::Scalar&gt; _colors;
 static const int OBJ_RECT_THICKNESS = 3;
 
 static void drawRects(cv::Mat image,
-                    std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
+                    std::vector&lt;autoware_msgs::ImageRectRanged&gt; objects,
 					CvScalar color,
 					int threshold_height,
 					std::string objectClass)
@@ -176,13 +176,13 @@ static void show(void)
 		cvWaitKey(2);
 	}
 }
-static void car_updater_callback(const autoware_msgs::image_obj_ranged&amp; fused_car_msg)
+static void car_updater_callback(const autoware_msgs::ImageObjRanged&amp; fused_car_msg)
 {
 	car_fused_objects = fused_car_msg;
 	//  show();
 }
 
-static void ped_updater_callback(const autoware_msgs::image_obj_ranged&amp; fused_pds_msg)
+static void ped_updater_callback(const autoware_msgs::ImageObjRanged&amp; fused_pds_msg)
 {
   pedestrian_fused_objects = fused_pds_msg;
   //  show();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\nodes\vision_dpm_ttic_detect\vision_dpm_ttic_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\nodes\vision_dpm_ttic_detect\vision_dpm_ttic_detect.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -36,7 +36,7 @@
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 
-#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/ImageObj.h"
 #include "autoware_msgs/ConfigPedestrianDpm.h"
 
 #include &lt;libdpm_ttic/dpm_ttic.hpp&gt;
@@ -66,10 +66,10 @@ static void set_default_param(DPMTTICParam&amp; param)
 	param.num_cells = 8;counter =0;
 }
 
-static void result_to_image_obj_message(autoware_msgs::image_obj&amp; msg, const DPMTTICResult result)
+static void result_to_image_obj_message(autoware_msgs::ImageObj&amp; msg, const DPMTTICResult result)
 {
 	for (int i = 0; i &lt; result.num; ++i) {
-		autoware_msgs::image_rect rect;
+		autoware_msgs::ImageRect rect;
 
 		int base = i * 4;
 		rect.x = result.corner_points[base];
@@ -89,7 +89,7 @@ static void image_raw_cb(const sensor_msgs::Image&amp; image_source)
 	IplImage img = cv_image-&gt;image;
 	IplImage *img_ptr = &amp;img;
 
-	autoware_msgs::image_obj msg;
+	autoware_msgs::ImageObj msg;
 	msg.header = image_source.header;
 	msg.type = object_class;
 
@@ -189,7 +189,7 @@ int main(int argc, char* argv[])
 #endif
 
 	ros::Subscriber sub = n.subscribe(image_topic_name, 1, image_raw_cb);
-	image_obj_pub = n.advertise&lt;autoware_msgs::image_obj&gt;("image_obj", 1);
+	image_obj_pub = n.advertise&lt;autoware_msgs::ImageObj&gt;("image_obj", 1);
 
 	ros::Subscriber config_sub;
 	std::string config_topic("/config");
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\libs\kf\src\kf_lib.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\libs\kf\src\kf_lib.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -38,9 +38,9 @@
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;autoware_msgs/ConfigCarKf.h&gt;
-#include &lt;autoware_msgs/image_obj_ranged.h&gt;
+#include &lt;autoware_msgs/ImageObjRanged.h&gt;
 
-#include &lt;autoware_msgs/image_obj_tracked.h&gt;
+#include &lt;autoware_msgs/ImageObjTracked.h&gt;
 #include &lt;std_msgs/Header.h&gt;
 
 //TRACKING STUFF
@@ -92,7 +92,7 @@ static bool 		USE_ORB;
 
 static bool 		track_ready_;
 static bool 		detect_ready_;
-static autoware_msgs::image_obj_tracked kf_objects_msg_;
+static autoware_msgs::ImageObjTracked kf_objects_msg_;
 
 struct kstate
 {
@@ -819,7 +819,7 @@ void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;ObjectDete
 
 	//ROS
 	int num = tracked_detections.size();
-	std::vector&lt;autoware_msgs::image_rect_ranged&gt; rect_ranged_array;
+	std::vector&lt;autoware_msgs::ImageRectRanged&gt; rect_ranged_array;
 	std::vector&lt;int&gt; real_data(num,0);
 	std::vector&lt;int&gt; obj_id(num, 0);
 	std::vector&lt;int&gt; lifespan(num, 0);
@@ -828,7 +828,7 @@ void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;ObjectDete
 	for (size_t i = 0; i &lt; tracked_detections.size(); i++)
 	{
 		kstate od = tracked_detections[i];
-		autoware_msgs::image_rect_ranged rect_ranged_;
+		autoware_msgs::ImageRectRanged rect_ranged_;
 
 		//od.rect contains x,y, width, height
 		rectangle(image, od.pos, od.color, 3);
@@ -850,7 +850,7 @@ void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;ObjectDete
 		//ENDROS
 	}
 	//more ros
-	autoware_msgs::image_obj_tracked kf_objects_msg;
+	autoware_msgs::ImageObjTracked kf_objects_msg;
 
 	kf_objects_msg.type = object_type;
 	kf_objects_msg.total_num = num;
@@ -882,12 +882,12 @@ void image_callback(const sensor_msgs::Image&amp; image_source)
 	_counter++;
 }
 
-void detections_callback(autoware_msgs::image_obj_ranged image_objects_msg)
+void detections_callback(autoware_msgs::ImageObjRanged image_objects_msg)
 {
 	if(!detect_ready_)
 	{
 		unsigned int num = image_objects_msg.obj.size();
-		std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects = image_objects_msg.obj;
+		std::vector&lt;autoware_msgs::ImageRectRanged&gt; objects = image_objects_msg.obj;
 		object_type = image_objects_msg.type;
 		image_objects_header = image_objects_msg.header;
 		//points are X,Y,W,H and repeat for each instance
@@ -962,7 +962,7 @@ int kf_main(int argc, char* argv[])
 	ros::NodeHandle n;
 	ros::NodeHandle private_nh("~");
 
-	image_objects = n.advertise&lt;autoware_msgs::image_obj_tracked&gt;("image_obj_tracked", 1);
+	image_objects = n.advertise&lt;autoware_msgs::ImageObjTracked&gt;("image_obj_tracked", 1);
 
 #if (CV_MAJOR_VERSION == 3)
 	generateColors(_colors, 25);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_dummy_track\nodes\vision_dummy_track\vision_dummy_track.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_dummy_track\nodes\vision_dummy_track\vision_dummy_track.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -29,14 +29,14 @@
 */
 
 #include &lt;ros/ros.h&gt;
-#include &lt;autoware_msgs/image_obj_tracked.h&gt;
-#include &lt;autoware_msgs/image_obj_ranged.h&gt;
+#include &lt;autoware_msgs/ImageObjTracked.h&gt;
+#include &lt;autoware_msgs/ImageObjRanged.h&gt;
 
 class DummyTrack{
 public:
   DummyTrack(){
     subscriber_image_obj_ = node_handle_.subscribe("image_obj_ranged", 1, &amp;DummyTrack::detections_callback, this);
-		publisher_tracked_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj_tracked&gt;("image_obj_tracked", 1);
+		publisher_tracked_objects_ = node_handle_.advertise&lt;autoware_msgs::ImageObjTracked&gt;("image_obj_tracked", 1);
   }
   void run(){
     ros::spin();
@@ -46,9 +46,9 @@ private:
   ros::Publisher 		publisher_tracked_objects_;//ROS
   ros::NodeHandle 	node_handle_;
 
-  void detections_callback(autoware_msgs::image_obj_ranged image_objects_msg)
+  void detections_callback(autoware_msgs::ImageObjRanged image_objects_msg)
   {
-    autoware_msgs::image_obj_tracked pub_msg;
+    autoware_msgs::ImageObjTracked pub_msg;
     pub_msg.header = image_objects_msg.header;
     pub_msg.type = image_objects_msg.type;
     pub_msg.rect_ranged = image_objects_msg.obj;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_klt_track\nodes\vision_klt_track\vision_klt_track.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_klt_track\nodes\vision_klt_track\vision_klt_track.cpp" added_lines="12" deleted_lines="12">
				<diff>@@ -38,9 +38,9 @@
 #include &lt;message_filters/subscriber.h&gt;
 #include &lt;message_filters/time_synchronizer.h&gt;
 
-#include &lt;autoware_msgs/image_obj.h&gt;
-#include &lt;autoware_msgs/image_obj_ranged.h&gt;
-#include &lt;autoware_msgs/image_obj_tracked.h&gt;
+#include &lt;autoware_msgs/ImageObj.h&gt;
+#include &lt;autoware_msgs/ImageObjRanged.h&gt;
+#include &lt;autoware_msgs/ImageObjTracked.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
@@ -87,7 +87,7 @@ class RosTrackerApp {
   std::vector&lt;float&gt; min_heights_;
   std::vector&lt;float&gt; max_heights_;
 
-  autoware_msgs::image_obj_tracked ros_objects_msg_; // sync
+  autoware_msgs::ImageObjTracked ros_objects_msg_; // sync
 
   void Sort(const std::vector&lt;float&gt; in_scores,
             std::vector&lt;unsigned int&gt; &amp;in_out_indices) {
@@ -247,7 +247,7 @@ public:
 
     // copy results to ros msg
     unsigned int num = obj_trackers_.size();
-    std::vector&lt;autoware_msgs::image_rect_ranged&gt;
+    std::vector&lt;autoware_msgs::ImageRectRanged&gt;
         rect_ranged_array;              // tracked rectangles
     std::vector&lt;int&gt; real_data(num, 0); // boolean array to show if data in
                                         // rect_ranged comes from tracking or
@@ -256,7 +256,7 @@ public:
     std::vector&lt;unsigned int&gt; lifespan(
         num, 0); // remaining lifespan of each rectranged
     for (i = 0; i &lt; num; i++) {
-      autoware_msgs::image_rect_ranged rect_ranged;
+      autoware_msgs::ImageRectRanged rect_ranged;
       LkTracker tracker_tmp = *obj_trackers_[i];
       rect_ranged.rect.x = tracker_tmp.GetTrackedObject().rect.x;
       rect_ranged.rect.y = tracker_tmp.GetTrackedObject().rect.y;
@@ -283,7 +283,7 @@ public:
     obj_detections_.clear();
     ranges_.clear();
 
-    autoware_msgs::image_obj_tracked tmp_objects_msg;
+    autoware_msgs::ImageObjTracked tmp_objects_msg;
 
     tmp_objects_msg.type = tracked_type_;
     tmp_objects_msg.total_num = num;
@@ -311,14 +311,14 @@ public:
     publish_if_possible();
   }
 
-  void detections_callback(autoware_msgs::image_obj_ranged image_objects_msg) {
+  void detections_callback(autoware_msgs::ImageObjRanged image_objects_msg) {
     // if(ready_)
     //	return;
     if (!detect_ready_) // must NOT overwrite, data is probably being used by
                         // tracking.
     {
       unsigned int num = image_objects_msg.obj.size();
-      std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects =
+      std::vector&lt;autoware_msgs::ImageRectRanged&gt; objects =
           image_objects_msg.obj;
       tracked_type_ = image_objects_msg.type;
       // points are X,Y,W,H and repeat for each instance
@@ -345,13 +345,13 @@ public:
     publish_if_possible();
     // ready_ = true;
   }
-  /*void detections_callback(autoware_msgs::image_obj image_objects_msg)
+  /*void detections_callback(autoware_msgs::ImageObj image_objects_msg)
   {
           if (ready_)
                   return;
           ready_ = false;
           unsigned int num = image_objects_msg.obj.size();
-          std::vector&lt;autoware_msgs::image_rect&gt; objects =
+          std::vector&lt;autoware_msgs::ImageRect&gt; objects =
   image_objects_msg.obj;
           //object_type = image_objects_msg.type;
           //points are X,Y,W,H and repeat for each instance
@@ -395,7 +395,7 @@ public:
     }
 
     publisher_tracked_objects_ =
-        node_handle_.advertise&lt;autoware_msgs::image_obj_tracked&gt;(
+        node_handle_.advertise&lt;autoware_msgs::ImageObjTracked&gt;(
             "image_obj_tracked", 1);
 
     ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\icp_matching\icp_matching.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\icp_matching\icp_matching.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -65,7 +65,7 @@
 
 #include "autoware_msgs/ConfigICP.h"
 
-#include "autoware_msgs/icp_stat.h"
+#include "autoware_msgs/ICPStat.h"
 
 #define PREDICT_POSE_THRESHOLD 0.5
 
@@ -156,7 +156,7 @@ static std_msgs::Float32 time_icp_matching;
 static int _queue_size = 1000;
 
 static ros::Publisher icp_stat_pub;
-static autoware_msgs::icp_stat icp_stat_msg;
+static autoware_msgs::ICPStat icp_stat_msg;
 
 static double predict_pose_error = 0.0;
 
@@ -732,7 +732,7 @@ int main(int argc, char** argv)
   estimated_vel_kmph_pub = nh.advertise&lt;std_msgs::Float32&gt;("/estimated_vel_kmph", 1000);
   estimated_vel_pub = nh.advertise&lt;geometry_msgs::Vector3Stamped&gt;("/estimated_vel", 1000);
   time_icp_matching_pub = nh.advertise&lt;std_msgs::Float32&gt;("/time_icp_matching", 1000);
-  icp_stat_pub = nh.advertise&lt;autoware_msgs::icp_stat&gt;("/icp_stat", 1000);
+  icp_stat_pub = nh.advertise&lt;autoware_msgs::ICPStat&gt;("/icp_stat", 1000);
 
   // Subscribers
   ros::Subscriber param_sub = nh.subscribe("config/icp", 10, param_callback);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -79,7 +79,7 @@
 
 #include &lt;autoware_msgs/ConfigNdt.h&gt;
 
-#include &lt;autoware_msgs/ndt_stat.h&gt;
+#include &lt;autoware_msgs/NDTStat.h&gt;
 
 #define PREDICT_POSE_THRESHOLD 0.5
 
@@ -209,7 +209,7 @@ static std_msgs::Float32 time_ndt_matching;
 static int _queue_size = 1000;
 
 static ros::Publisher ndt_stat_pub;
-static autoware_msgs::ndt_stat ndt_stat_msg;
+static autoware_msgs::NDTStat ndt_stat_msg;
 
 static double predict_pose_error = 0.0;
 
@@ -1614,7 +1614,7 @@ int main(int argc, char** argv)
   estimated_vel_kmph_pub = nh.advertise&lt;std_msgs::Float32&gt;("/estimated_vel_kmph", 10);
   estimated_vel_pub = nh.advertise&lt;geometry_msgs::Vector3Stamped&gt;("/estimated_vel", 10);
   time_ndt_matching_pub = nh.advertise&lt;std_msgs::Float32&gt;("/time_ndt_matching", 10);
-  ndt_stat_pub = nh.advertise&lt;autoware_msgs::ndt_stat&gt;("/ndt_stat", 10);
+  ndt_stat_pub = nh.advertise&lt;autoware_msgs::NDTStat&gt;("/ndt_stat", 10);
   ndt_reliability_pub = nh.advertise&lt;std_msgs::Float32&gt;("/ndt_reliability", 10);
 
   // Subscribers
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -43,7 +43,7 @@ void RosNdtMatchingMonitor::gnss_callback(const geometry_msgs::PoseStamped::Cons
     gnss_text_ = " - GNSS available";
 }
 
-void RosNdtMatchingMonitor::ndt_stat_callback(const autoware_msgs::ndt_stat::ConstPtr&amp; input)
+void RosNdtMatchingMonitor::ndt_stat_callback(const autoware_msgs::NDTStat::ConstPtr&amp; input)
 {
     iteration_count_ = input-&gt;iteration;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.h" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.h" added_lines="2" deleted_lines="2">
				<diff>@@ -65,7 +65,7 @@
 
 #include &lt;jsk_rviz_plugins/OverlayText.h&gt;
 
-#include &lt;autoware_msgs/ndt_stat.h&gt;
+#include &lt;autoware_msgs/NDTStat.h&gt;
 
 #define __APP_NAME__ "RosNdtMatchingMonitor"
 
@@ -123,7 +123,7 @@ class RosNdtMatchingMonitor
 	 * Callback for NDT statistics
 	 * @param input message published by ndt
 	 */
-	void ndt_stat_callback(const autoware_msgs::ndt_stat::ConstPtr&amp; input);
+	void ndt_stat_callback(const autoware_msgs::NDTStat::ConstPtr&amp; input);
 
 	/*!
 	 * Callback for transformation result from NDT
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_ros_helpers\op_RosHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_ros_helpers\op_RosHelpers.h" added_lines="4" deleted_lines="4">
				<diff>@@ -230,7 +230,7 @@ public:
 	static void ConvertParticles(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; points, visualization_msgs::MarkerArray&amp; part_mkrs, visualization_msgs::MarkerArray&amp; part_markers_d);
 
 	static void ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
-				autoware_msgs::lane &amp; trajectory);
+				autoware_msgs::Lane &amp; trajectory);
 
 	static void ConvertFromPlannerHRectangleToAutowareRviz(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; safety_rect,
 			visualization_msgs::Marker&amp; marker);
@@ -249,11 +249,11 @@ public:
 	static void ConvertFromPlannerObstaclesToAutoware(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
 			visualization_msgs::MarkerArray&amp; detectedPolygons);
 
-	static void ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, autoware_msgs::lane&amp; trajectory , const unsigned int&amp; iStart = 0);
+	static void ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, autoware_msgs::Lane&amp; trajectory , const unsigned int&amp; iStart = 0);
 
-	static void ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path, autoware_msgs::lane&amp; trajectory);
+	static void ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path, autoware_msgs::Lane&amp; trajectory);
 
-	static void ConvertFromAutowareLaneToLocalLane(const autoware_msgs::lane&amp; trajectory, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path);
+	static void ConvertFromAutowareLaneToLocalLane(const autoware_msgs::Lane&amp; trajectory, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path);
 
 	static void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const autoware_msgs::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\op_RosHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\op_RosHelpers.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -438,12 +438,12 @@ void RosHelpers::ConvertCollisionPointsMarkers(const std::vector&lt;PlannerHNS::Way
 }
 
 void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
-		autoware_msgs::lane&amp; trajectory)
+		autoware_msgs::Lane&amp; trajectory)
 {
 	trajectory.waypoints.clear();
 	for(unsigned int i=iStart; i &lt; path.size(); i++)
 	{
-		autoware_msgs::waypoint wp;
+		autoware_msgs::Waypoint wp;
 		wp.pose.pose.position.x = path.at(i).pos.x;
 		wp.pose.pose.position.y = path.at(i).pos.y;
 		wp.pose.pose.position.z = path.at(i).pos.z;
@@ -1300,13 +1300,13 @@ PlannerHNS::AutowareBehaviorState RosHelpers::ConvertBehaviorStateFromPlannerHTo
 
 }
 
-void RosHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, autoware_msgs::lane&amp; trajectory , const unsigned int&amp; iStart)
+void RosHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, autoware_msgs::Lane&amp; trajectory , const unsigned int&amp; iStart)
 {
 	trajectory.waypoints.clear();
 
 	for(unsigned int i = iStart; i &lt; path.size(); i++)
 	{
-		autoware_msgs::waypoint wp;
+		autoware_msgs::Waypoint wp;
 		wp.pose.pose.position.x = path.at(i).pos.x;
 		wp.pose.pose.position.y = path.at(i).pos.y;
 		wp.pose.pose.position.z = path.at(i).pos.z;
@@ -1334,13 +1334,13 @@ void RosHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS
 	}
 }
 
-void RosHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path, autoware_msgs::lane&amp; trajectory)
+void RosHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path, autoware_msgs::Lane&amp; trajectory)
 {
 	trajectory.waypoints.clear();
 
 	for(unsigned int i=0; i &lt; path.size(); i++)
 	{
-		autoware_msgs::waypoint wp;
+		autoware_msgs::Waypoint wp;
 		wp.pose.pose.position.x = path.at(i).x;
 		wp.pose.pose.position.y = path.at(i).y;
 		wp.pose.pose.position.z = path.at(i).z;
@@ -1350,7 +1350,7 @@ void RosHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS
 	}
 }
 
-void RosHelpers::ConvertFromAutowareLaneToLocalLane(const autoware_msgs::lane&amp; trajectory, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
+void RosHelpers::ConvertFromAutowareLaneToLocalLane(const autoware_msgs::Lane&amp; trajectory, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
 {
 	path.clear();
 
@@ -1655,7 +1655,7 @@ void RosHelpers::ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(co
 	obj.candidate_trajectories.lanes.clear();
 	for(unsigned int j = 0 ; j &lt; det_obj.predTrajectories.size(); j++)
 	{
-		autoware_msgs::lane pred_traj;
+		autoware_msgs::Lane pred_traj;
 		PlannerHNS::RosHelpers::ConvertFromLocalLaneToAutowareLane(det_obj.predTrajectories.at(j), pred_traj);
 		if(det_obj.predTrajectories.at(j).size() &gt; 0)
 		{
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" added_lines="3" deleted_lines="3">
				<diff>@@ -6,7 +6,7 @@
 #include &lt;geometry_msgs/Point.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 
-#include &lt;autoware_msgs/lane.h&gt;
+#include &lt;autoware_msgs/Lane.h&gt;
 
 namespace decision_maker
 {
@@ -18,7 +18,7 @@ public:
   std::vector&lt;geometry_msgs::Point&gt; points;
   jsk_recognition_msgs::BoundingBox bbox;
 
-  std::vector&lt;autoware_msgs::lane&gt; insideLanes;
+  std::vector&lt;autoware_msgs::Lane&gt; insideLanes;
   std::vector&lt;geometry_msgs::Point&gt; insideWaypoint_points;
 
   CrossRoadArea(void)
@@ -30,7 +30,7 @@ public:
     insideWaypoint_points.clear();
   }
 
-  static CrossRoadArea *findClosestCrossRoad(const autoware_msgs::lane &amp;_finalwaypoints,
+  static CrossRoadArea *findClosestCrossRoad(const autoware_msgs::Lane &amp;_finalwaypoints,
                                              std::vector&lt;CrossRoadArea&gt; &amp;intersects);
   static bool isInsideArea(const CrossRoadArea *_TargetArea, geometry_msgs::Point pt);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="9" deleted_lines="9">
				<diff>@@ -7,9 +7,9 @@
 #include &lt;autoware_msgs/ConfigDecisionMaker.h&gt;
 #include &lt;autoware_msgs/CloudClusterArray.h&gt;
 #include &lt;autoware_msgs/LaneArray.h&gt;
-#include &lt;autoware_msgs/waypoint.h&gt;
-#include &lt;autoware_msgs/lane.h&gt;
-#include &lt;autoware_msgs/traffic_light.h&gt;
+#include &lt;autoware_msgs/Waypoint.h&gt;
+#include &lt;autoware_msgs/Lane.h&gt;
+#include &lt;autoware_msgs/TrafficLight.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
@@ -88,7 +88,7 @@ private:
   jsk_rviz_plugins::OverlayText state_text_msg;
 
   // ROS Messages(Autoware)
-  autoware_msgs::lane current_finalwaypoints_;
+  autoware_msgs::Lane current_finalwaypoints_;
   vector_map_msgs::AreaArray vMap_Areas;
   vector_map_msgs::PointArray vMap_Points;
   vector_map_msgs::LineArray vMap_Lines;
@@ -115,7 +115,7 @@ private:
   std::string TextOffset;
   std::vector&lt;CrossRoadArea&gt; intersects;
   double displacement_from_path_;
-  autoware_msgs::waypoint CurrentStoplineTarget_;
+  autoware_msgs::Waypoint CurrentStoplineTarget_;
 
   bool foundOtherVehicleForIntersectionStop_; // In fact this should be defined as state.
   class DetectionArea
@@ -176,11 +176,11 @@ private:
 
   // judge method
   // in near future, these methods will be deprecate to decision_maker library
-  bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
+  bool isCrossRoadByVectorMapServer(const autoware_msgs::Lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
   bool isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw);
   bool handleStateCmd(const uint64_t _state_num);
   // double calcIntersectWayAngle(const CrossRoadArea&amp; area);
-  double calcIntersectWayAngle(const autoware_msgs::lane &amp;laneinArea);
+  double calcIntersectWayAngle(const autoware_msgs::Lane &amp;laneinArea);
 
   void insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects, autoware_msgs::LaneArray &amp;lane_array);
 
@@ -223,10 +223,10 @@ private:
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
   void callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg);
   void callbackFromClosestWaypoint(const std_msgs::Int32 &amp;msg);
-  void callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event);
+  void callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::TrafficLight const&gt; &amp;event);
   void callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg);
   void callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg);
-  void callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg);
+  void callbackFromFinalWaypoint(const autoware_msgs::Lane &amp;msg);
   void callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg);
   void callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg);
   void callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\planner_selector.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\planner_selector.hpp" added_lines="5" deleted_lines="5">
				<diff>@@ -2,7 +2,7 @@
 #define __PLANNER_SELECTOR_HPP__
 
 #include &lt;autoware_msgs/ConfigPlannerSelector.h&gt;
-#include &lt;autoware_msgs/lane.h&gt;
+#include &lt;autoware_msgs/Lane.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 
@@ -22,12 +22,12 @@ class PlannerSelector
 private:
   ros::NodeHandle nh_;
 
-  std::unordered_map&lt;std::string, autoware_msgs::lane&gt; waypoints_;
+  std::unordered_map&lt;std::string, autoware_msgs::Lane&gt; waypoints_;
   std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
   std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;
 
-  autoware_msgs::lane final_waypoints_dp_;
-  autoware_msgs::lane final_waypoints_astar_;
+  autoware_msgs::Lane final_waypoints_dp_;
+  autoware_msgs::Lane final_waypoints_astar_;
 
   std::unordered_map&lt;std::string, int&gt; closest_waypoints_;
   int closest_waypoint_astar_;
@@ -60,7 +60,7 @@ public:
   void initROS();
 
   void callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event);
-  void callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event);
+  void callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::Lane const&gt; &amp;event);
   void callbackFromLattice(const std_msgs::Int32 &amp;msg);
   void callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg);
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -5,7 +5,7 @@
 namespace decision_maker
 {
 #define TARGET_WAYPOINTS_NUM 15  // need to change rosparam
-CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::lane &amp;_finalwaypoints,
+CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::Lane &amp;_finalwaypoints,
                                                    std::vector&lt;CrossRoadArea&gt; &amp;intersects)
 {
   CrossRoadArea *_area = nullptr;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -9,8 +9,8 @@
 #include &lt;std_msgs/UInt8.h&gt;
 
 #include &lt;autoware_msgs/CloudClusterArray.h&gt;
-#include &lt;autoware_msgs/lane.h&gt;
-#include &lt;autoware_msgs/traffic_light.h&gt;
+#include &lt;autoware_msgs/Lane.h&gt;
+#include &lt;autoware_msgs/TrafficLight.h&gt;
 
 #include &lt;cross_road_area.hpp&gt;
 #include &lt;decision_maker_node.hpp&gt;
@@ -110,9 +110,9 @@ void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMa
   detectionArea_.y2 = msg.detection_area_y2;
 }
 
-void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
+void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::TrafficLight const&gt; &amp;event)
 {    
-  const autoware_msgs::traffic_light *light = event.getMessage().get();
+  const autoware_msgs::TrafficLight *light = event.getMessage().get();
 //  const ros::M_string &amp;header = event.getConnectionHeader();
 //  std::string topic = header.at("topic"); 
   
@@ -201,13 +201,13 @@ void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadAr
           // area's
           if (area.insideLanes.empty() || wp.gid != area.insideLanes.back().waypoints.back().gid + 1)
           {
-            autoware_msgs::lane nlane;
+            autoware_msgs::Lane nlane;
             area.insideLanes.push_back(nlane);
 	    area.bbox.pose.orientation = wp.pose.pose.orientation;
           }
           area.insideLanes.back().waypoints.push_back(wp);
           area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
-          // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
+          // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::Waypoint
           // lane's wp
           wp.wpstate.aid = area.area_id;
         }
@@ -333,7 +333,7 @@ state_machine::StateFlags getStateFlags(uint8_t msg_state)
     return state_machine::DRIVE_STR_STRAIGHT_STATE;
 }
 
-void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
+void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::Lane &amp;msg)
 {
   if (!hasvMap())
   {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -12,7 +12,7 @@
 #include &lt;decision_maker_node.hpp&gt;
 //#include &lt;vector_map/vector_map.h&gt;
 
-#include &lt;autoware_msgs/lane.h&gt;
+#include &lt;autoware_msgs/Lane.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 #include &lt;random&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -8,8 +8,8 @@
 #include &lt;std_msgs/String.h&gt;
 #include &lt;tf/transform_listener.h&gt;
 
-#include &lt;autoware_msgs/lane.h&gt;
-#include &lt;autoware_msgs/traffic_light.h&gt;
+#include &lt;autoware_msgs/Lane.h&gt;
+#include &lt;autoware_msgs/TrafficLight.h&gt;
 
 #include &lt;cross_road_area.hpp&gt;
 #include &lt;decision_maker_node.hpp&gt;
@@ -44,7 +44,7 @@ double DecisionMakerNode::calcPosesAngleDiff(const geometry_msgs::Pose &amp;p_from,
   return diff;
 }
 
-double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;laneinArea)
+double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::Lane &amp;laneinArea)
 {
   double diff = 0.0;
   if (laneinArea.waypoints.empty())
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -15,9 +15,9 @@
 #include &lt;decision_maker_node.hpp&gt;
 //#include &lt;vector_map/vector_map.h&gt;
 
-#include &lt;autoware_msgs/lamp_cmd.h&gt;
-#include &lt;autoware_msgs/lane.h&gt;
-#include &lt;autoware_msgs/state.h&gt;
+#include &lt;autoware_msgs/LampCmd.h&gt;
+#include &lt;autoware_msgs/Lane.h&gt;
+#include &lt;autoware_msgs/State.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 #include &lt;random&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
@@ -60,11 +60,11 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   // for controlling other planner
   Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
   Pubs["lane_waypoints_array"] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
-  Pubs["states"] = nh_.advertise&lt;autoware_msgs::state&gt;("/decisionmaker/states", 1, true);
-  Pubs["light_color"] = nh_.advertise&lt;autoware_msgs::traffic_light&gt;("/light_color_managed", 1);
+  Pubs["states"] = nh_.advertise&lt;autoware_msgs::State&gt;("/decisionmaker/states", 1, true);
+  Pubs["light_color"] = nh_.advertise&lt;autoware_msgs::TrafficLight&gt;("/light_color_managed", 1);
 
   // for controlling vehicle
-  Pubs["lamp_cmd"] = nh_.advertise&lt;autoware_msgs::lamp_cmd&gt;("/lamp_cmd", 1);
+  Pubs["lamp_cmd"] = nh_.advertise&lt;autoware_msgs::LampCmd&gt;("/lamp_cmd", 1);
 
   // for visualize status
   Pubs["state_overlay"] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("/state/overlay_text", 1);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -12,8 +12,8 @@
 
 #include &lt;decision_maker_node.hpp&gt;
 
-#include &lt;autoware_msgs/lane.h&gt;
-#include &lt;autoware_msgs/state.h&gt;
+#include &lt;autoware_msgs/Lane.h&gt;
+#include &lt;autoware_msgs/State.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 #include &lt;random&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
@@ -200,7 +200,7 @@ void DecisionMakerNode::update_msgs(void)
       update_pubsub();
     }
 
-    autoware_msgs::state state_msg;
+    autoware_msgs::State state_msg;
     state_msg.main_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::MAIN_STATE);
     state_msg.acc_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::ACC_STATE);
     state_msg.str_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::STR_STATE);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -3,7 +3,7 @@
 #include &lt;state_machine_lib/state.hpp&gt;
 #include &lt;state_machine_lib/state_context.hpp&gt;
 
-#include &lt;autoware_msgs/lamp_cmd.h&gt;
+#include &lt;autoware_msgs/LampCmd.h&gt;
 #include &lt;decision_maker_node.hpp&gt;
 
 namespace decision_maker
@@ -99,7 +99,7 @@ void DecisionMakerNode::callbackOutStateLaneChange(int status)
 
 void DecisionMakerNode::publishLightColor(int status)
 {
-  autoware_msgs::traffic_light msg;
+  autoware_msgs::TrafficLight msg;
   msg.traffic_light = status;
   Pubs["light_color"].publish(msg);
 }
@@ -289,7 +289,7 @@ void DecisionMakerNode::changeVelocityLane(int dir)
   {
     for (auto&amp; lane : current_controlled_lane_array_.lanes)
     {
-      autoware_msgs::lane temp_lane = lane;
+      autoware_msgs::Lane temp_lane = lane;
       for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
       {
         amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
@@ -436,7 +436,7 @@ void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
 }
 void DecisionMakerNode::updateStateSTR(int status)
 {
-  autoware_msgs::lamp_cmd lamp_msg;
+  autoware_msgs::LampCmd lamp_msg;
 
   switch (status)
   {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -1,5 +1,5 @@
 #include &lt;autoware_msgs/ConfigPlannerSelector.h&gt;
-#include &lt;autoware_msgs/lane.h&gt;
+#include &lt;autoware_msgs/Lane.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 
@@ -28,7 +28,7 @@ void PlannerSelector::initROS()
 
   Subs["current_velocity"] = nh_.subscribe("current_velocity", 3, &amp;PlannerSelector::callbackFromCurrentVelocity, this);
 
-  Pubs["final_waypoints"] = nh_.advertise&lt;autoware_msgs::lane&gt;("/final_waypoints", 1);
+  Pubs["final_waypoints"] = nh_.advertise&lt;autoware_msgs::Lane&gt;("/final_waypoints", 1);
   Pubs["closest_waypoint"] = nh_.advertise&lt;std_msgs::Int32&gt;("/closest_waypoint", 1);
 }
 
@@ -48,8 +48,8 @@ void PlannerSelector::callbackFromLattice(const std_msgs::Int32 &amp;msg)
 
   try
   {
-    autoware_msgs::waypoint dp_point = final_waypoints_dp_.waypoints.at(config_waypoints_num_);
-    autoware_msgs::waypoint astar_point = final_waypoints_astar_.waypoints.at(config_waypoints_num_);
+    autoware_msgs::Waypoint dp_point = final_waypoints_dp_.waypoints.at(config_waypoints_num_);
+    autoware_msgs::Waypoint astar_point = final_waypoints_astar_.waypoints.at(config_waypoints_num_);
 
     amathutils::point p_dp, p_astar;
     p_dp.x = dp_point.pose.pose.position.x;
@@ -117,11 +117,11 @@ void PlannerSelector::callbackFromLattice(const std_msgs::Int32 &amp;msg)
   //	ROS_INFO("\n***** EnableLattice = %d  **** \n",enableLattice_,msg.data);
 }
 
-void PlannerSelector::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event)
+void PlannerSelector::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::Lane const&gt; &amp;event)
 {
   const ros::M_string &amp;header = event.getConnectionHeader();
   std::string topic = header.at("topic");
-  const autoware_msgs::lane *waypoints = event.getMessage().get();
+  const autoware_msgs::Lane *waypoints = event.getMessage().get();
 
   _mutex.lock();
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\freespace_planner\nodes\astar_navi\astar_navi.cpp" new_path="ros\src\computing\planning\mission\packages\freespace_planner\nodes\astar_navi\astar_navi.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -7,12 +7,12 @@ namespace
 
 void publishPathAsWaypoints(const ros::Publisher&amp; pub, const nav_msgs::Path&amp; path, const double waypoint_velocity_kmph)
 {
-  autoware_msgs::lane lane;
+  autoware_msgs::Lane lane;
 
   lane.header = path.header;
   lane.increment = 0;
   for (const auto&amp; pose : path.poses) {
-    autoware_msgs::waypoint wp;
+    autoware_msgs::Waypoint wp;
     wp.pose = pose;
     wp.twist.twist.linear.x = waypoint_velocity_kmph / 3.6;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\include\lane_planner\lane_planner_vmap.hpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\include\lane_planner\lane_planner_vmap.hpp" added_lines="5" deleted_lines="5">
				<diff>@@ -40,8 +40,8 @@
 
 #include &lt;vector_map/vector_map.h&gt;
 #include &lt;tablet_socket_msgs/route_cmd.h&gt;
-#include "autoware_msgs/dtlane.h"
-#include "autoware_msgs/lane.h"
+#include "autoware_msgs/DTLane.h"
+#include "autoware_msgs/Lane.h"
 
 namespace lane_planner {
 
@@ -77,11 +77,11 @@ bool is_connection_dtlane(const VectorMap&amp; fine_vmap, int index);
 
 geometry_msgs::Point create_geometry_msgs_point(const vector_map::Point&amp; vp);
 vector_map::Point create_vector_map_point(const geometry_msgs::Point&amp; gp);
-autoware_msgs::dtlane create_waypoint_follower_dtlane(const vector_map::DTLane&amp; vd);
-vector_map::DTLane create_vector_map_dtlane(const autoware_msgs::dtlane&amp; wd);
+autoware_msgs::DTLane create_waypoint_follower_dtlane(const vector_map::DTLane&amp; vd);
+vector_map::DTLane create_vector_map_dtlane(const autoware_msgs::DTLane&amp; wd);
 
 VectorMap create_lane_vmap(const VectorMap&amp; vmap, int lno);
-VectorMap create_coarse_vmap_from_lane(const autoware_msgs::lane&amp; lane);
+VectorMap create_coarse_vmap_from_lane(const autoware_msgs::Lane&amp; lane);
 VectorMap create_coarse_vmap_from_route(const tablet_socket_msgs::route_cmd&amp; route);
 VectorMap create_fine_vmap(const VectorMap&amp; lane_vmap, int lno, const VectorMap&amp; coarse_vmap, double search_radius,
 			   int waypoint_max);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\lib\lane_planner\lane_planner_vmap.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\lib\lane_planner\lane_planner_vmap.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -506,9 +506,9 @@ vector_map::Point create_vector_map_point(const geometry_msgs::Point&amp; gp)
 	return vp;
 }
 
-autoware_msgs::dtlane create_waypoint_follower_dtlane(const vector_map::DTLane&amp; vd)
+autoware_msgs::DTLane create_waypoint_follower_dtlane(const vector_map::DTLane&amp; vd)
 {
-	autoware_msgs::dtlane wd;
+	autoware_msgs::DTLane wd;
 	wd.dist = vd.dist;
 	wd.dir = vd.dir;
 	wd.apara = vd.apara;
@@ -521,7 +521,7 @@ autoware_msgs::dtlane create_waypoint_follower_dtlane(const vector_map::DTLane&amp;
 	return wd;
 }
 
-vector_map::DTLane create_vector_map_dtlane(const autoware_msgs::dtlane&amp; wd)
+vector_map::DTLane create_vector_map_dtlane(const autoware_msgs::DTLane&amp; wd)
 {
 	vector_map::DTLane vd;
 	vd.dist = wd.dist;
@@ -572,10 +572,10 @@ VectorMap create_lane_vmap(const VectorMap&amp; vmap, int lno)
 	return lane_vmap;
 }
 
-VectorMap create_coarse_vmap_from_lane(const autoware_msgs::lane&amp; lane)
+VectorMap create_coarse_vmap_from_lane(const autoware_msgs::Lane&amp; lane)
 {
 	VectorMap coarse_vmap;
-	for (const autoware_msgs::waypoint&amp; w : lane.waypoints)
+	for (const autoware_msgs::Waypoint&amp; w : lane.waypoints)
 		coarse_vmap.points.push_back(create_vector_map_point(w.pose.pose.position));
 
 	return coarse_vmap;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_navi\lane_navi.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_navi\lane_navi.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -125,7 +125,7 @@ void create_waypoint(const tablet_socket_msgs::route_cmd&amp; msg)
 
 	autoware_msgs::LaneArray lane_waypoint;
 	for (const lane_planner::vmap::VectorMap&amp; v : fine_vmaps) {
-		autoware_msgs::lane l;
+		autoware_msgs::Lane l;
 		l.header = header;
 		l.increment = 1;
 
@@ -147,7 +147,7 @@ void create_waypoint(const tablet_socket_msgs::route_cmd&amp; msg)
 				yaw = atan2(p2.y - p1.y, p2.x - p1.x);
 			}
 
-			autoware_msgs::waypoint w;
+			autoware_msgs::Waypoint w;
 			w.pose.header = header;
 			w.pose.pose.position = lane_planner::vmap::create_geometry_msgs_point(v.points[i]);
 			w.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -74,12 +74,12 @@ ros::Publisher marker_pub;
 int marker_cnt;
 #endif // DEBUG
 
-autoware_msgs::lane create_new_lane(const autoware_msgs::lane&amp; lane, const std_msgs::Header&amp; header)
+autoware_msgs::Lane create_new_lane(const autoware_msgs::Lane&amp; lane, const std_msgs::Header&amp; header)
 {
-	autoware_msgs::lane l = lane;
+	autoware_msgs::Lane l = lane;
 	l.header = header;
 
-	for (autoware_msgs::waypoint&amp; w : l.waypoints) {
+	for (autoware_msgs::Waypoint&amp; w : l.waypoints) {
 		w.pose.header = header;
 		w.twist.header = header;
 	}
@@ -87,10 +87,10 @@ autoware_msgs::lane create_new_lane(const autoware_msgs::lane&amp; lane, const std_m
 	return l;
 }
 
-autoware_msgs::lane apply_acceleration(const autoware_msgs::lane&amp; lane, double acceleration,
+autoware_msgs::Lane apply_acceleration(const autoware_msgs::Lane&amp; lane, double acceleration,
 					   size_t start_index, size_t fixed_cnt, double fixed_vel)
 {
-	autoware_msgs::lane l = lane;
+	autoware_msgs::Lane l = lane;
 
 	if (fixed_cnt == 0)
 		return l;
@@ -117,9 +117,9 @@ autoware_msgs::lane apply_acceleration(const autoware_msgs::lane&amp; lane, double a
 	return l;
 }
 
-autoware_msgs::lane apply_crossroad_acceleration(const autoware_msgs::lane&amp; lane, double acceleration)
+autoware_msgs::Lane apply_crossroad_acceleration(const autoware_msgs::Lane&amp; lane, double acceleration)
 {
-	autoware_msgs::lane l = lane;
+	autoware_msgs::Lane l = lane;
 
 	bool crossroad = false;
 	std::vector&lt;size_t&gt; start_indexes;
@@ -163,11 +163,11 @@ autoware_msgs::lane apply_crossroad_acceleration(const autoware_msgs::lane&amp; lane
 	return l;
 }
 
-autoware_msgs::lane apply_stopline_acceleration(const autoware_msgs::lane&amp; lane, double acceleration,
+autoware_msgs::Lane apply_stopline_acceleration(const autoware_msgs::Lane&amp; lane, double acceleration,
 						    const lane_planner::vmap::VectorMap&amp; fine_vmap, size_t ahead_cnt,
 						    size_t behind_cnt)
 {
-	autoware_msgs::lane l = lane;
+	autoware_msgs::Lane l = lane;
 
 	std::vector&lt;size_t&gt; indexes;
 	for (size_t i = 0; i &lt; fine_vmap.stoplines.size(); ++i) {
@@ -226,7 +226,7 @@ std::vector&lt;vector_map::Point&gt; create_stop_points(const lane_planner::vmap::Vect
 }
 
 std::vector&lt;size_t&gt; create_stop_indexes(const lane_planner::vmap::VectorMap&amp; vmap,
-					const autoware_msgs::lane&amp; lane, double stopline_search_radius)
+					const autoware_msgs::Lane&amp; lane, double stopline_search_radius)
 {
 	std::vector&lt;size_t&gt; stop_indexes;
 	for (const vector_map::Point&amp; p : create_stop_points(vmap)) {
@@ -250,10 +250,10 @@ std::vector&lt;size_t&gt; create_stop_indexes(const lane_planner::vmap::VectorMap&amp; vma
 	return stop_indexes;
 }
 
-autoware_msgs::lane apply_stopline_acceleration(const autoware_msgs::lane&amp; lane, double acceleration,
+autoware_msgs::Lane apply_stopline_acceleration(const autoware_msgs::Lane&amp; lane, double acceleration,
 						    double stopline_search_radius, size_t ahead_cnt, size_t behind_cnt)
 {
-	autoware_msgs::lane l = lane;
+	autoware_msgs::Lane l = lane;
 
 	std::vector&lt;size_t&gt; indexes = create_stop_indexes(lane_vmap, l, stopline_search_radius);
 	if (indexes.empty())
@@ -277,7 +277,7 @@ autoware_msgs::lane apply_stopline_acceleration(const autoware_msgs::lane&amp; lane,
 	return l;
 }
 
-bool is_fine_vmap(const lane_planner::vmap::VectorMap&amp; fine_vmap, const autoware_msgs::lane&amp; lane)
+bool is_fine_vmap(const lane_planner::vmap::VectorMap&amp; fine_vmap, const autoware_msgs::Lane&amp; lane)
 {
 	if (fine_vmap.points.size() != lane.waypoints.size())
 		return false;
@@ -375,7 +375,7 @@ void create_waypoint(const autoware_msgs::LaneArray&amp; msg)
 
 	cached_waypoint.lanes.clear();
 	cached_waypoint.lanes.shrink_to_fit();
-	for (const autoware_msgs::lane&amp; l : msg.lanes)
+	for (const autoware_msgs::Lane&amp; l : msg.lanes)
 		cached_waypoint.lanes.push_back(create_new_lane(l, header));
 	if (all_vmap.points.empty() || all_vmap.lanes.empty() || all_vmap.nodes.empty() ||
 	    all_vmap.stoplines.empty() || all_vmap.dtlanes.empty()) {
@@ -391,7 +391,7 @@ void create_waypoint(const autoware_msgs::LaneArray&amp; msg)
 	autoware_msgs::LaneArray red_waypoint;
 	autoware_msgs::LaneArray green_waypoint;
 	for (size_t i = 0; i &lt; msg.lanes.size(); ++i) {
-		autoware_msgs::lane lane = create_new_lane(msg.lanes[i], header);
+		autoware_msgs::Lane lane = create_new_lane(msg.lanes[i], header);
 
 		lane_planner::vmap::VectorMap coarse_vmap =
 			lane_planner::vmap::create_coarse_vmap_from_lane(lane);
@@ -423,7 +423,7 @@ void create_waypoint(const autoware_msgs::LaneArray&amp; msg)
 
 		/* velocity smoothing */
 		for(int k = 0; k &lt; config_number_of_smoothing_count; ++k){
-			autoware_msgs::lane temp_lane = lane;
+			autoware_msgs::Lane temp_lane = lane;
 			if(lane.waypoints.size() &gt;= 3){
 				for (size_t j = 1; j &lt; lane.waypoints.size()-1; ++j) {
 					if(lane.waypoints.at(j).twist.twist.linear.x != 0)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -50,11 +50,11 @@ void getPointAndVectorFromPose(const geometry_msgs::Pose &amp;pose, Element2D *point
   vector-&gt;set(tmp_tf_vevtor.getX(), tmp_tf_vevtor.getY());
 }
 
-std::vector&lt;autoware_msgs::waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
+std::vector&lt;autoware_msgs::Waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
                                                                 const geometry_msgs::Pose &amp;end,
                                                                 const double velocity_mps, const double vlength)
 {
-  std::vector&lt;autoware_msgs::waypoint&gt; wps;
+  std::vector&lt;autoware_msgs::Waypoint&gt; wps;
   Element2D p0(0, 0), v0(0, 0), p1(0, 0), v1(0, 0);
   getPointAndVectorFromPose(start, &amp;p0, &amp;v0);
   getPointAndVectorFromPose(end, &amp;p1, &amp;v1);
@@ -64,7 +64,7 @@ std::vector&lt;autoware_msgs::waypoint&gt; generateHermiteCurveForROS(const geometry_m
   double height_d = fabs(start.position.z - end.position.z);
   for (uint32_t i = 0; i &lt; result.size(); i++)
   {
-    autoware_msgs::waypoint wp;
+    autoware_msgs::Waypoint wp;
     wp.pose.pose.position.x = result.at(i).x;
     wp.pose.pose.position.y = result.at(i).y;
     wp.twist.twist.linear.x = velocity_mps;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.h" added_lines="2" deleted_lines="2">
				<diff>@@ -43,7 +43,7 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
 
-#include "autoware_msgs/waypoint.h"
+#include "autoware_msgs/Waypoint.h"
 
 namespace lane_planner
 {
@@ -65,7 +65,7 @@ struct Element2D
 
 std::vector&lt;Element2D&gt; generateHermiteCurve(const Element2D &amp;p0, const Element2D &amp;v0, const Element2D &amp;p1,
                                             const Element2D &amp;v1, const double vlength = 20);
-std::vector&lt;autoware_msgs::waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
+std::vector&lt;autoware_msgs::Waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
                                                                 const geometry_msgs::Pose &amp;end, const double velocity,
                                                                 const double vlength);
 void createVectorFromPose(const geometry_msgs::Pose &amp;p, tf::Vector3 *v);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -73,7 +73,7 @@ void LaneSelectNode::initForROS()
   private_nh_.param&lt;bool&gt;("enablePlannerDynamicSwitch", enablePlannerDynamicSwitch, false);
   // setup publisher
 
-  pub1_ = nh_.advertise&lt;autoware_msgs::lane&gt;("base_waypoints", 1);
+  pub1_ = nh_.advertise&lt;autoware_msgs::Lane&gt;("base_waypoints", 1);
 
   if (enablePlannerDynamicSwitch)
   {
@@ -206,7 +206,7 @@ void LaneSelectNode::processing()
   resetSubscriptionFlag();
 }
 
-int32_t LaneSelectNode::getClosestLaneChangeWaypointNumber(const std::vector&lt;autoware_msgs::waypoint&gt; &amp;wps,
+int32_t LaneSelectNode::getClosestLaneChangeWaypointNumber(const std::vector&lt;autoware_msgs::Waypoint&gt; &amp;wps,
                                                            int32_t cl_wp)
 {
   for (uint32_t i = cl_wp; i &lt; wps.size(); i++)
@@ -226,7 +226,7 @@ void LaneSelectNode::createLaneForChange()
   std::get&lt;0&gt;(lane_for_change_).waypoints.shrink_to_fit();
   std::get&lt;1&gt;(lane_for_change_) = -1;
 
-  const autoware_msgs::lane &amp;cur_lane = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_));
+  const autoware_msgs::Lane &amp;cur_lane = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_));
   const int32_t &amp;clst_wp = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
 
   int32_t num_lane_change = getClosestLaneChangeWaypointNumber(cur_lane.waypoints, clst_wp);
@@ -252,7 +252,7 @@ void LaneSelectNode::createLaneForChange()
                          current_velocity_.twist.linear.x * lane_change_target_ratio_ :
                          lane_change_target_minimum_;
   ROS_INFO("dt : %lf, dt_by_vel : %lf", dt, dt_by_vel);
-  autoware_msgs::lane &amp;nghbr_lane =
+  autoware_msgs::Lane &amp;nghbr_lane =
       static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right ?
           std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_)) :
           std::get&lt;0&gt;(tuple_vec_.at(left_lane_idx_));
@@ -278,7 +278,7 @@ void LaneSelectNode::createLaneForChange()
     return;
 
   std::get&lt;0&gt;(lane_for_change_).header.stamp = nghbr_lane.header.stamp;
-  std::vector&lt;autoware_msgs::waypoint&gt; hermite_wps = generateHermiteCurveForROS(
+  std::vector&lt;autoware_msgs::Waypoint&gt; hermite_wps = generateHermiteCurveForROS(
       cur_lane.waypoints.at(num_lane_change).pose.pose, nghbr_lane.waypoints.at(target_num).pose.pose,
       cur_lane.waypoints.at(num_lane_change).twist.twist.linear.x, vlength_hermite_curve_);
 
@@ -605,13 +605,13 @@ void LaneSelectNode::publishVisualizer()
   vis_pub1_.publish(marker_array);
 }
 
-void LaneSelectNode::publishLane(const autoware_msgs::lane &amp;lane)
+void LaneSelectNode::publishLane(const autoware_msgs::Lane &amp;lane)
 {
   // publish global lane
   pub1_.publish(lane);
 }
 
-void LaneSelectNode::publishLaneID(const autoware_msgs::lane &amp;lane)
+void LaneSelectNode::publishLaneID(const autoware_msgs::Lane &amp;lane)
 {
   std_msgs::Int32 msg;
   msg.data = lane.lane_id;
@@ -687,7 +687,7 @@ void LaneSelectNode::callbackFromState(const std_msgs::StringConstPtr &amp;msg)
   else
     processing();
 }
-void LaneSelectNode::callbackFromStates(const autoware_msgs::stateConstPtr &amp;msg)
+void LaneSelectNode::callbackFromStates(const autoware_msgs::StateConstPtr &amp;msg)
 {
   is_current_state_subscribed_ = true;
 
@@ -778,7 +778,7 @@ double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry
 }
 
 // get closest waypoint from current pose
-int32_t getClosestWaypointNumber(const autoware_msgs::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
+int32_t getClosestWaypointNumber(const autoware_msgs::Lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
                                  const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number,
                                  const double distance_threshold)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="8" deleted_lines="8">
				<diff>@@ -47,7 +47,7 @@
 // User defined includes
 #include "autoware_msgs/ConfigLaneSelect.h"
 #include "autoware_msgs/LaneArray.h"
-#include "autoware_msgs/state.h"
+#include "autoware_msgs/State.h"
 #include "hermite_curve.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 
@@ -92,9 +92,9 @@ private:
   int32_t current_lane_idx_;  // the index of the lane we are driving
   int32_t right_lane_idx_;
   int32_t left_lane_idx_;
-  std::vector&lt;std::tuple&lt;autoware_msgs::lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint,
+  std::vector&lt;std::tuple&lt;autoware_msgs::Lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint,
                                                                                  // change_flag
-  std::tuple&lt;autoware_msgs::lane, int32_t, ChangeFlag&gt; lane_for_change_;
+  std::tuple&lt;autoware_msgs::Lane, int32_t, ChangeFlag&gt; lane_for_change_;
   bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_,
       is_current_state_subscribed_, is_config_subscribed_;
 
@@ -112,7 +112,7 @@ private:
   void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr &amp;msg);
   void callbackFromState(const std_msgs::StringConstPtr &amp;msg);
-  void callbackFromStates(const autoware_msgs::stateConstPtr &amp;msg);
+  void callbackFromStates(const autoware_msgs::StateConstPtr &amp;msg);
   void callbackFromConfig(const autoware_msgs::ConfigLaneSelectConstPtr &amp;msg);
 
   // initializer
@@ -132,8 +132,8 @@ private:
   void resetSubscriptionFlag();
   bool isAllTopicsSubscribed();
   void processing();
-  void publishLane(const autoware_msgs::lane &amp;lane);
-  void publishLaneID(const autoware_msgs::lane &amp;lane);
+  void publishLane(const autoware_msgs::Lane &amp;lane);
+  void publishLaneID(const autoware_msgs::Lane &amp;lane);
   void publishClosestWaypoint(const int32_t clst_wp);
   void publishChangeFlag(const ChangeFlag flag);
   bool getClosestWaypointNumberForEachLanes();
@@ -143,10 +143,10 @@ private:
   void changeLane();
   void updateChangeFlag();
   void createLaneForChange();
-  int32_t getClosestLaneChangeWaypointNumber(const std::vector&lt;autoware_msgs::waypoint&gt; &amp;wps, int32_t cl_wp);
+  int32_t getClosestLaneChangeWaypointNumber(const std::vector&lt;autoware_msgs::Waypoint&gt; &amp;wps, int32_t cl_wp);
 };
 
-int32_t getClosestWaypointNumber(const autoware_msgs::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
+int32_t getClosestWaypointNumber(const autoware_msgs::Lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
                                  const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number,
                                  const double distance_threshold);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_stop\lane_stop.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_stop\lane_stop.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -31,7 +31,7 @@
 #include &lt;ros/console.h&gt;
 
 #include "autoware_msgs/ConfigLaneStop.h"
-#include "autoware_msgs/traffic_light.h"
+#include "autoware_msgs/TrafficLight.h"
 #include "autoware_msgs/LaneArray.h"
 
 #include &lt;lane_planner/lane_planner_vmap.hpp&gt;
@@ -47,7 +47,7 @@ autoware_msgs::LaneArray current_green_lane;
 
 const autoware_msgs::LaneArray *previous_lane = &amp;current_red_lane;
 
-void select_current_lane(const autoware_msgs::traffic_light&amp; msg)
+void select_current_lane(const autoware_msgs::TrafficLight&amp; msg)
 {
 	const autoware_msgs::LaneArray *current;
 	switch (msg.traffic_light) {
@@ -75,13 +75,13 @@ void select_current_lane(const autoware_msgs::traffic_light&amp; msg)
 	previous_lane = current;
 }
 
-void receive_auto_detection(const autoware_msgs::traffic_light&amp; msg)
+void receive_auto_detection(const autoware_msgs::TrafficLight&amp; msg)
 {
 	if (!config_manual_detection)
 		select_current_lane(msg);
 }
 
-void receive_manual_detection(const autoware_msgs::traffic_light&amp; msg)
+void receive_manual_detection(const autoware_msgs::TrafficLight&amp; msg)
 {
 	if (config_manual_detection)
 		select_current_lane(msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -281,7 +281,7 @@ void GlobalPlanner::VisualizeAndSend(const std::vector&lt;std::vector&lt;PlannerHNS::W
 
 	for(unsigned int i=0; i &lt; generatedTotalPaths.size(); i++)
 	{
-		autoware_msgs::lane lane;
+		autoware_msgs::Lane lane;
 		PlannerHNS::RosHelpers::ConvertFromLocalLaneToAutowareLane(generatedTotalPaths.at(i), lane);
 		lane_array.lanes.push_back(lane);
 	}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\RosHelpers.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\RosHelpers.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -44,11 +44,11 @@ void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::s
 void RosHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path,
 		autoware_msgs::LaneArray&amp; laneArray)
 {
-	autoware_msgs::lane l;
+	autoware_msgs::Lane l;
 
 	for(unsigned int i=0; i &lt; path.size(); i++)
 	{
-		autoware_msgs::waypoint wp;
+		autoware_msgs::Waypoint wp;
 		wp.pose.pose.position.x = path.at(i).x;
 		wp.pose.pose.position.y = path.at(i).y;
 		wp.pose.pose.position.z = path.at(i).z;
@@ -65,11 +65,11 @@ void RosHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(const std::vector
 void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
 		autoware_msgs::LaneArray&amp; laneArray)
 {
-	autoware_msgs::lane l;
+	autoware_msgs::Lane l;
 
 	for(unsigned int i=0; i &lt; path.size(); i++)
 	{
-		autoware_msgs::waypoint wp;
+		autoware_msgs::Waypoint wp;
 		wp.pose.pose.position.x = path.at(i).pos.x;
 		wp.pose.pose.position.y = path.at(i).pos.y;
 		wp.pose.pose.position.z = path.at(i).pos.z;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_avoid.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_avoid.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -35,10 +35,10 @@
 
 namespace
 {
-autoware_msgs::lane createPublishWaypoints(const autoware_msgs::lane&amp; ref_lane, int closest_waypoint,
+autoware_msgs::Lane createPublishWaypoints(const autoware_msgs::Lane&amp; ref_lane, int closest_waypoint,
                                                     int size)
 {
-  autoware_msgs::lane follow_lane;
+  autoware_msgs::Lane follow_lane;
 
   follow_lane.header = ref_lane.header;
   follow_lane.increment = ref_lane.increment;
@@ -56,14 +56,14 @@ autoware_msgs::lane createPublishWaypoints(const autoware_msgs::lane&amp; ref_lane,
 }
 
 void createAvoidWaypoints(const nav_msgs::Path&amp; astar_path, const astar_planner::SearchInfo&amp; search_info, int size,
-                          autoware_msgs::lane* avoid_lane, int* end_of_avoid_index)
+                          autoware_msgs::Lane* avoid_lane, int* end_of_avoid_index)
 {
   int closest_waypoint_index = search_info.getClosestWaypointIndex();
 
   avoid_lane-&gt;waypoints.clear();
 
   // Get global lane
-  const autoware_msgs::lane&amp; current_lane = search_info.getCurrentWaypoints();
+  const autoware_msgs::Lane&amp; current_lane = search_info.getCurrentWaypoints();
   avoid_lane-&gt;header = current_lane.header;
   avoid_lane-&gt;increment = current_lane.increment;
 
@@ -81,7 +81,7 @@ void createAvoidWaypoints(const nav_msgs::Path&amp; astar_path, const astar_planner:
   // Set waypoints for avoiding
   for (const auto&amp; pose : astar_path.poses)
   {
-    autoware_msgs::waypoint wp;
+    autoware_msgs::Waypoint wp;
     wp.pose = pose;
     wp.twist.twist.linear.x = avoid_velocity;
 
@@ -131,12 +131,12 @@ int main(int argc, char** argv)
 
   // ROS publishers
   ros::Publisher path_pub = n.advertise&lt;nav_msgs::Path&gt;("astar_path", 1, true);
-  ros::Publisher waypoints_pub = n.advertise&lt;autoware_msgs::lane&gt;("safety_waypoints", 1, true);
+  ros::Publisher waypoints_pub = n.advertise&lt;autoware_msgs::Lane&gt;("safety_waypoints", 1, true);
 
   ros::Rate loop_rate(10);
 
   // variables for avoidance
-  autoware_msgs::lane avoid_lane;
+  autoware_msgs::Lane avoid_lane;
   int end_of_avoid_index = -1;
   bool avoidance = false;
   while (ros::ok())
@@ -161,7 +161,7 @@ int main(int argc, char** argv)
     // Follow the original waypoints
     if (!avoidance)
     {
-      autoware_msgs::lane publish_lane;
+      autoware_msgs::Lane publish_lane;
       publish_lane = createPublishWaypoints(search_info.getSubscribedWaypoints(), closest_waypoint, 100);
       waypoints_pub.publish(publish_lane);
     }
@@ -169,7 +169,7 @@ int main(int argc, char** argv)
     else
     {
       // create waypoints from closest on avoid_lane
-      autoware_msgs::lane publish_lane;
+      autoware_msgs::Lane publish_lane;
       publish_lane = createPublishWaypoints(avoid_lane, closest_waypoint, 100);
       waypoints_pub.publish(publish_lane);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -58,7 +58,7 @@ SearchInfo::~SearchInfo()
 {
 }
 
-double SearchInfo::calcPathLength(const autoware_msgs::lane &amp;lane, const int start_waypoint_index,
+double SearchInfo::calcPathLength(const autoware_msgs::Lane &amp;lane, const int start_waypoint_index,
                                   const int goal_waypoint_index) const
 {
   if (lane.waypoints.size() &lt;= 1)
@@ -172,7 +172,7 @@ void SearchInfo::goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 }
 
 // get waypoints
-void SearchInfo::waypointsCallback(const autoware_msgs::laneConstPtr &amp;msg)
+void SearchInfo::waypointsCallback(const autoware_msgs::LaneConstPtr &amp;msg)
 {
   subscribed_waypoints_ = *msg;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" added_lines="8" deleted_lines="8">
				<diff>@@ -32,7 +32,7 @@
 #define SEARCH_INFO_ROS_H
 
 #include "astar_util.h"
-#include "autoware_msgs/lane.h"
+#include "autoware_msgs/Lane.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 
 #include &lt;nav_msgs/OccupancyGrid.h&gt;
@@ -55,7 +55,7 @@ public:
   void goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void currentPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void currentVelocityCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg);
-  void waypointsCallback(const autoware_msgs::laneConstPtr &amp;msg);
+  void waypointsCallback(const autoware_msgs::LaneConstPtr &amp;msg);
   void closestWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg);
   void obstacleWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg);
   void stateCallback(const std_msgs::StringConstPtr &amp;msg);
@@ -101,11 +101,11 @@ public:
   {
     return current_velocity_mps_;
   }
-  autoware_msgs::lane getSubscribedWaypoints() const
+  autoware_msgs::Lane getSubscribedWaypoints() const
   {
     return subscribed_waypoints_;
   }
-  autoware_msgs::lane getCurrentWaypoints() const
+  autoware_msgs::Lane getCurrentWaypoints() const
   {
     return current_waypoints_;
   }
@@ -143,7 +143,7 @@ public:
   }
 
   // set method
-  void setCurrentWaypoints(const autoware_msgs::lane &amp;waypoints)
+  void setCurrentWaypoints(const autoware_msgs::Lane &amp;waypoints)
   {
     current_waypoints_ = waypoints;
   }
@@ -152,7 +152,7 @@ public:
   void reset();
 
 private:
-  double calcPathLength(const autoware_msgs::lane &amp;lane, const int start_waypoint_index,
+  double calcPathLength(const autoware_msgs::Lane &amp;lane, const int start_waypoint_index,
                         const int goal_waypoint_index) const;
 
   nav_msgs::OccupancyGrid map_;
@@ -186,8 +186,8 @@ private:
   int obstacle_waypoint_index_;
   int start_waypoint_index_;
   int goal_waypoint_index_;
-  autoware_msgs::lane subscribed_waypoints_;
-  autoware_msgs::lane current_waypoints_;
+  autoware_msgs::Lane subscribed_waypoints_;
+  autoware_msgs::Lane current_waypoints_;
   geometry_msgs::PoseStamped current_pose_;
   double current_velocity_mps_;
   std::string state_;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -248,7 +248,7 @@ void CrossWalk::setCrossWalkPoints()
   set_points = true;
 }
 
-int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const autoware_msgs::lane &amp;lane,
+int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const autoware_msgs::Lane &amp;lane,
                                     const int search_distance)
 {
   if (!set_points || closest_waypoint &lt; 0)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" added_lines="2" deleted_lines="2">
				<diff>@@ -76,7 +76,7 @@ public:
   geometry_msgs::Point getPoint(const int &amp;pid) const;
   void calcCenterPoints();
   void setCrossWalkPoints();
-  int findClosestCrosswalk(const int closest_waypoint, const autoware_msgs::lane &amp;lane, const int search_distance);
+  int findClosestCrosswalk(const int closest_waypoint, const autoware_msgs::Lane &amp;lane, const int search_distance);
   int getSize() const
   {
     return detection_points_.size();
@@ -184,7 +184,7 @@ inline double calcSquareOfLength(const geometry_msgs::Point &amp;p1, const geometry_
 }
 
 // Calculate waypoint index corresponding to distance from begin_waypoint
-inline int calcWaypointIndexReverse(const autoware_msgs::lane &amp;lane, const int begin_waypoint, const double distance)
+inline int calcWaypointIndexReverse(const autoware_msgs::Lane &amp;lane, const int begin_waypoint, const double distance)
 {
   double dist_sum = 0;
   for (int i = begin_waypoint; i &gt; 0; i--)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -97,7 +97,7 @@ void displayObstacle(const EControl&amp; kind, const ObstaclePoints&amp; obstacle_points
   obstacle_pub.publish(marker);
 }
 
-void displayDetectionRange(const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const int closest_waypoint,
+void displayDetectionRange(const autoware_msgs::Lane&amp; lane, const CrossWalk&amp; crosswalk, const int closest_waypoint,
                            const EControl&amp; kind, const int obstacle_waypoint, const double stop_range,
                            const double deceleration_range, const ros::Publisher&amp; detection_range_pub)
 {
@@ -259,7 +259,7 @@ EControl crossWalkDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const
 }
 
 int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint,
-                       const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, double stop_range,
+                       const autoware_msgs::Lane&amp; lane, const CrossWalk&amp; crosswalk, double stop_range,
                        double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose,
                        ObstaclePoints* obstacle_points, EObstacleType* obstacle_type,
                        const int wpidx_detection_result_by_other_nodes)
@@ -335,7 +335,7 @@ int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int c
 }
 
 int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint,
-                             const autoware_msgs::lane&amp; lane, const double stop_range, const double deceleration_range,
+                             const autoware_msgs::Lane&amp; lane, const double stop_range, const double deceleration_range,
                              const double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose,
                              ObstaclePoints* obstacle_points)
 {
@@ -387,7 +387,7 @@ int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const
 
 // Detect an obstacle by using pointcloud
 EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint,
-                         const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo&amp; vs_info,
+                         const autoware_msgs::Lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo&amp; vs_info,
                          int* obstacle_waypoint, ObstaclePoints* obstacle_points)
 {
   // no input for detection || no closest waypoint
@@ -450,7 +450,7 @@ EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int
   }
 }
 
-EControl obstacleDetection(int closest_waypoint, const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk,
+EControl obstacleDetection(int closest_waypoint, const autoware_msgs::Lane&amp; lane, const CrossWalk&amp; crosswalk,
                            const VelocitySetInfo vs_info, const ros::Publisher&amp; detection_range_pub,
                            const ros::Publisher&amp; obstacle_pub, int* obstacle_waypoint)
 {
@@ -586,9 +586,9 @@ int main(int argc, char** argv)
 
   ros::Publisher final_waypoints_pub;
   if(enablePlannerDynamicSwitch){
-	  final_waypoints_pub = nh.advertise&lt;autoware_msgs::lane&gt;("astar/final_waypoints", 1, true);
+	  final_waypoints_pub = nh.advertise&lt;autoware_msgs::Lane&gt;("astar/final_waypoints", 1, true);
   }else{
-	  final_waypoints_pub = nh.advertise&lt;autoware_msgs::lane&gt;("final_waypoints", 1, true);
+	  final_waypoints_pub = nh.advertise&lt;autoware_msgs::Lane&gt;("final_waypoints", 1, true);
   }
 
   ros::Rate loop_rate(LOOP_RATE);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -64,7 +64,7 @@ void VelocitySetPath::setTemporalWaypoints(int temporal_waypoints_size, int clos
   temporal_waypoints_.increment = new_waypoints_.increment;
 
   // push current pose
-  autoware_msgs::waypoint current_point;
+  autoware_msgs::Waypoint current_point;
   current_point.pose = control_pose;
   current_point.twist = new_waypoints_.waypoints[closest_waypoint].twist;
   current_point.dtlane = new_waypoints_.waypoints[closest_waypoint].dtlane;
@@ -228,7 +228,7 @@ void VelocitySetPath::resetFlag()
 }
 
 
-void VelocitySetPath::waypointsCallback(const autoware_msgs::laneConstPtr&amp; msg)
+void VelocitySetPath::waypointsCallback(const autoware_msgs::LaneConstPtr&amp; msg)
 {
   prev_waypoints_ = *msg;
   // temporary, edit waypoints velocity later
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" added_lines="8" deleted_lines="8">
				<diff>@@ -31,14 +31,14 @@
 #ifndef VELOCITY_SET_PATH_H
 #define VELOCITY_SET_PATH_H
 
-#include &lt;autoware_msgs/lane.h&gt;
+#include &lt;autoware_msgs/Lane.h&gt;
 #include "waypoint_follower/libwaypoint_follower.h"
 class VelocitySetPath
 {
  private:
-  autoware_msgs::lane prev_waypoints_;
-  autoware_msgs::lane new_waypoints_;
-  autoware_msgs::lane temporal_waypoints_;
+  autoware_msgs::Lane prev_waypoints_;
+  autoware_msgs::Lane new_waypoints_;
+  autoware_msgs::Lane temporal_waypoints_;
   bool set_path_;
   double current_vel_;
 
@@ -61,22 +61,22 @@ class VelocitySetPath
   void resetFlag();
 
   // ROS Callbacks
-  void waypointsCallback(const autoware_msgs::laneConstPtr&amp; msg);
+  void waypointsCallback(const autoware_msgs::LaneConstPtr&amp; msg);
   void currentVelocityCallback(const geometry_msgs::TwistStampedConstPtr&amp; msg);
 
   double calcInterval(const int begin, const int end) const;
 
-  autoware_msgs::lane getPrevWaypoints() const
+  autoware_msgs::Lane getPrevWaypoints() const
   {
     return prev_waypoints_;
   }
 
-  autoware_msgs::lane getNewWaypoints() const
+  autoware_msgs::Lane getNewWaypoints() const
   {
     return new_waypoints_;
   }
 
-  autoware_msgs::lane getTemporalWaypoints() const
+  autoware_msgs::Lane getTemporalWaypoints() const
   {
     return temporal_waypoints_;
   }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\include\RosHelpers.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\RosHelpers.h" added_lines="1" deleted_lines="1">
				<diff>@@ -175,7 +175,7 @@ public:
 	virtual ~RosHelpers();
 	static void GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform);
 	static void ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
-				autoware_msgs::lane &amp; trajectory);
+				autoware_msgs::Lane &amp; trajectory);
 
 	static void ConvertFromPlannerHRectangleToAutowareRviz(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; safety_rect,
 			visualization_msgs::Marker&amp; marker);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\RosHelpers.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\RosHelpers.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -51,12 +51,12 @@ void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::s
 }
 
 void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
-		autoware_msgs::lane&amp; trajectory)
+		autoware_msgs::Lane&amp; trajectory)
 {
 	trajectory.waypoints.clear();
 	for(unsigned int i=iStart; i &lt; path.size(); i++)
 	{
-		autoware_msgs::waypoint wp;
+		autoware_msgs::Waypoint wp;
 		wp.pose.pose.position.x = path.at(i).pos.x;
 		wp.pose.pose.position.y = path.at(i).pos.y;
 		wp.pose.pose.position.z = path.at(i).pos.z;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -102,8 +102,8 @@ PlannerX::PlannerX()
 		pub_EnableLattice = nh.advertise&lt;std_msgs::Int32&gt;("enableLattice", 1);
 	}
 
-	pub_LocalPath = nh.advertise&lt;autoware_msgs::lane&gt;(topic_prefix + "/final_waypoints", 100,true);
-	pub_LocalBasePath = nh.advertise&lt;autoware_msgs::lane&gt;(topic_prefix + "/base_waypoints", 100,true);
+	pub_LocalPath = nh.advertise&lt;autoware_msgs::Lane&gt;(topic_prefix + "/final_waypoints", 100,true);
+	pub_LocalBasePath = nh.advertise&lt;autoware_msgs::Lane&gt;(topic_prefix + "/base_waypoints", 100,true);
 	pub_ClosestIndex = nh.advertise&lt;std_msgs::Int32&gt;(topic_prefix + "/closest_waypoint", 100,true);
 
 	pub_BehaviorState = nh.advertise&lt;geometry_msgs::TwistStamped&gt;("current_behavior", 1);
@@ -759,7 +759,7 @@ void PlannerX::PlannerMainLoop()
 		}
 
 
-		autoware_msgs::lane current_trajectory;
+		autoware_msgs::Lane current_trajectory;
 		std_msgs::Int32 closest_waypoint;
 		PlannerHNS::RelativeInfo info;
 		PlannerHNS::PlanningHelpers::GetRelativeInfo(m_LocalPlanner.m_Path, m_LocalPlanner.state, info);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\ff_waypoint_follower_core.h" new_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\ff_waypoint_follower_core.h" added_lines="1" deleted_lines="1">
				<diff>@@ -165,7 +165,7 @@ protected:
 	void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg);
 	void callbackGetCurrentVelocity(const geometry_msgs::TwistStampedConstPtr&amp; msg);
 	void callbackGetBehaviorState(const geometry_msgs::TwistStampedConstPtr&amp; msg );
-	void callbackGetCurrentTrajectory(const autoware_msgs::laneConstPtr&amp; msg);
+	void callbackGetCurrentTrajectory(const autoware_msgs::LaneConstPtr&amp; msg);
 	//void callbackGetAutowareOdom(const geometry_msgs::TwistStampedConstPtr &amp;msg);
 	void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg);
 	void callbackGetOutsideControl(const std_msgs::Int8&amp; msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower_core.cpp" new_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -265,7 +265,7 @@ void FFSteerControl::callbackGetBehaviorState(const geometry_msgs::TwistStampedC
 	bNewBehaviorState = true;
 }
 
-void FFSteerControl::callbackGetCurrentTrajectory(const autoware_msgs::laneConstPtr &amp;msg)
+void FFSteerControl::callbackGetCurrentTrajectory(const autoware_msgs::LaneConstPtr &amp;msg)
 {
 	m_State.m_Path.clear();
 	for(unsigned int i = 0 ; i &lt; msg-&gt;waypoints.size(); i++)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_trajectory_gen\lattice_trajectory_gen.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_trajectory_gen\lattice_trajectory_gen.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -124,7 +124,7 @@ static void currentVelCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg)
   g_current_velocity = msg-&gt;twist.linear.x;
 }
 
-static void WayPointCallback(const autoware_msgs::laneConstPtr &amp;msg)
+static void WayPointCallback(const autoware_msgs::LaneConstPtr &amp;msg)
 {
   g_current_waypoints.setPath(*msg);
   g_waypoint_set = true;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_velocity_set\lattice_velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_velocity_set\lattice_velocity_set.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -46,7 +46,7 @@
 #include "autoware_msgs/ConfigLatticeVelocitySet.h"
 #include &lt;iostream&gt;
 
-#include "autoware_msgs/lane.h"
+#include "autoware_msgs/Lane.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "libvelocity_set.h"
 
@@ -97,7 +97,7 @@ WayPoints g_path_dk;
 class PathVset : public WayPoints
 {
 private:
-  autoware_msgs::lane temporal_waypoints_;
+  autoware_msgs::Lane temporal_waypoints_;
 
 public:
   void changeWaypoints(int stop_waypoint);
@@ -106,7 +106,7 @@ public:
   void setDeceleration();
   bool checkWaypoint(int num, const char *name) const;
   void setTemporalWaypoints();
-  autoware_msgs::lane getTemporalWaypoints() const
+  autoware_msgs::Lane getTemporalWaypoints() const
   {
     return temporal_waypoints_;
   }
@@ -138,7 +138,7 @@ void PathVset::setTemporalWaypoints()
   temporal_waypoints_.header = current_waypoints_.header;
   temporal_waypoints_.increment = current_waypoints_.increment;
   // push current pose
-  autoware_msgs::waypoint current_point;
+  autoware_msgs::Waypoint current_point;
 
   current_point.pose = g_control_pose;
   current_point.twist = current_waypoints_.waypoints[g_closest_waypoint].twist;
@@ -279,7 +279,7 @@ void PathVset::changeWaypoints(int stop_waypoint)
 
     changed_vel = sqrt(2.0 * g_decel * (interval * i));  // sqrt(2*a*x)
 
-    autoware_msgs::waypoint initial_waypoint = g_path_dk.getCurrentWaypoints().waypoints[num];
+    autoware_msgs::Waypoint initial_waypoint = g_path_dk.getCurrentWaypoints().waypoints[num];
     if (changed_vel &gt; initial_waypoint.twist.twist.linear.x)
     {  // avoid acceleration
       current_waypoints_.waypoints[num].twist.twist.linear.x = initial_waypoint.twist.twist.linear.x;
@@ -330,7 +330,7 @@ void currentVelCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg)
   g_current_vel = msg-&gt;twist.linear.x;
 }
 
-void baseWaypointCallback(const autoware_msgs::laneConstPtr &amp;msg)
+void baseWaypointCallback(const autoware_msgs::LaneConstPtr &amp;msg)
 {
   g_path_dk.setPath(*msg);
   g_path_change.setPath(*msg);
@@ -838,7 +838,7 @@ int main(int argc, char **argv)
 
   g_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 0);
   g_sound_pub = nh.advertise&lt;std_msgs::String&gt;("sound_player", 10);
-  g_temporal_waypoints_pub = nh.advertise&lt;autoware_msgs::lane&gt;("temporal_waypoints", 1000, true);
+  g_temporal_waypoints_pub = nh.advertise&lt;autoware_msgs::Lane&gt;("temporal_waypoints", 1000, true);
   ros::Publisher closest_waypoint_pub;
   closest_waypoint_pub = nh.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1000);
   g_obstacle_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("obstacle", 0);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\path_select\path_select.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\path_select\path_select.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -29,12 +29,12 @@
  */
 
 #include &lt;ros/ros.h&gt;
-#include "autoware_msgs/lane.h"
+#include "autoware_msgs/Lane.h"
 #include &lt;iostream&gt;
 
 static ros::Publisher _pub;
 
-void callback(const autoware_msgs::lane &amp;msg)
+void callback(const autoware_msgs::Lane &amp;msg)
 {
     _pub.publish(msg);
 }
@@ -46,7 +46,7 @@ int main(int argc, char **argv)
 
     ros::NodeHandle nh;
     ros::Subscriber twist_sub = nh.subscribe("temporal_waypoints", 1, callback);
-    _pub = nh.advertise&lt;autoware_msgs::lane&gt;("final_waypoints", 1000,true);
+    _pub = nh.advertise&lt;autoware_msgs::Lane&gt;("final_waypoints", 1000,true);
 
     ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_behavior_selector_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_behavior_selector_core.h" added_lines="4" deleted_lines="4">
				<diff>@@ -55,7 +55,7 @@
 #include &lt;geometry_msgs/TwistWithCovarianceStamped.h&gt;
 #include &lt;autoware_msgs/CanInfo.h&gt;
 #include &lt;autoware_msgs/DetectedObjectArray.h&gt;
-#include &lt;autoware_msgs/traffic_light.h&gt;
+#include &lt;autoware_msgs/TrafficLight.h&gt;
 #include &lt;autoware_msgs/Signals.h&gt;
 #include &lt;autoware_msgs/ControlCommand.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
@@ -104,7 +104,7 @@ protected: //Planning Related variables
   	PlannerHNS::PlanningParams m_PlanningParams;
   	PlannerHNS::CAR_BASIC_INFO m_CarInfo;
 
-  	autoware_msgs::lane m_CurrentTrajectoryToSend;
+  	autoware_msgs::Lane m_CurrentTrajectoryToSend;
   	bool bNewLightStatus;
 	bool bNewLightSignal;
 	PlannerHNS::TrafficLightState  m_CurrLightStatus;
@@ -149,8 +149,8 @@ protected: //Planning Related variables
 	void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg);
 	void callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp; msg);
 	void callbackGetLocalPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp; msg);
-	void callbackGetLocalTrajectoryCost(const autoware_msgs::laneConstPtr&amp; msg);
-	void callbackGetTrafficLightStatus(const autoware_msgs::traffic_light &amp; msg);
+	void callbackGetLocalTrajectoryCost(const autoware_msgs::LaneConstPtr&amp; msg);
+	void callbackGetTrafficLightStatus(const autoware_msgs::TrafficLight &amp; msg);
 	void callbackGetTrafficLightSignals(const autoware_msgs::Signals&amp; msg);
 
 	void callbackGetTwistCMD(const geometry_msgs::TwistStampedConstPtr&amp; msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector_core.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -56,8 +56,8 @@ BehaviorGen::BehaviorGen()
 	m_OriginPos.position.y  = transform.getOrigin().y();
 	m_OriginPos.position.z  = transform.getOrigin().z();
 
-	pub_LocalPath = nh.advertise&lt;autoware_msgs::lane&gt;("final_waypoints", 1,true);
-	pub_LocalBasePath = nh.advertise&lt;autoware_msgs::lane&gt;("base_waypoints", 1,true);
+	pub_LocalPath = nh.advertise&lt;autoware_msgs::Lane&gt;("final_waypoints", 1,true);
+	pub_LocalBasePath = nh.advertise&lt;autoware_msgs::Lane&gt;("base_waypoints", 1,true);
 	pub_ClosestIndex = nh.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1,true);
 	pub_BehaviorState = nh.advertise&lt;geometry_msgs::TwistStamped&gt;("current_behavior", 1);
 	pub_SimuBoxPose	  = nh.advertise&lt;geometry_msgs::PoseArray&gt;("sim_box_pose_ego", 1);
@@ -307,7 +307,7 @@ void BehaviorGen::callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayCon
 	}
 }
 
-void BehaviorGen::callbackGetLocalTrajectoryCost(const autoware_msgs::laneConstPtr&amp; msg)
+void BehaviorGen::callbackGetLocalTrajectoryCost(const autoware_msgs::LaneConstPtr&amp; msg)
 {
 	bBestCost = true;
 	m_TrajectoryBestCost.bBlocked = msg-&gt;is_blocked;
@@ -356,7 +356,7 @@ void BehaviorGen::callbackGetLocalPlannerPath(const autoware_msgs::LaneArrayCons
 	}
 }
 
-void BehaviorGen::callbackGetTrafficLightStatus(const autoware_msgs::traffic_light&amp; msg)
+void BehaviorGen::callbackGetTrafficLightStatus(const autoware_msgs::TrafficLight&amp; msg)
 {
 	std::cout &lt;&lt; "Received Traffic Light Status : " &lt;&lt; msg.traffic_light &lt;&lt; std::endl;
 	bNewLightStatus = true;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_evaluator\op_trajectory_evaluator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_evaluator\op_trajectory_evaluator_core.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -55,7 +55,7 @@ TrajectoryEval::TrajectoryEval()
 	pub_CollisionPointsRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("dynamic_collision_points_rviz", 1);
 	pub_LocalWeightedTrajectoriesRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("local_trajectories_eval_rviz", 1);
 	pub_LocalWeightedTrajectories = nh.advertise&lt;autoware_msgs::LaneArray&gt;("local_weighted_trajectories", 1);
-	pub_TrajectoryCost = nh.advertise&lt;autoware_msgs::lane&gt;("local_trajectory_cost", 1);
+	pub_TrajectoryCost = nh.advertise&lt;autoware_msgs::Lane&gt;("local_trajectory_cost", 1);
 	pub_SafetyBorderRviz = nh.advertise&lt;visualization_msgs::Marker&gt;("safety_border", 1);
 
 	sub_current_pose = nh.subscribe("/current_pose", 10, &amp;TrajectoryEval::callbackGetCurrentPose, this);
@@ -286,7 +286,7 @@ void TrajectoryEval::MainLoop()
 				else
 					tc = m_TrajectoryCostsCalculator.DoOneStepStatic(m_GeneratedRollOuts, m_GlobalPathSections.at(0), m_CurrentPos,	m_PlanningParams,	m_CarInfo,m_VehicleStatus, m_PredictedObjects);
 
-				autoware_msgs::lane l;
+				autoware_msgs::Lane l;
 				l.closest_object_distance = tc.closest_obj_distance;
 				l.closest_object_velocity = tc.closest_obj_velocity;
 				l.cost = tc.cost;
@@ -300,7 +300,7 @@ void TrajectoryEval::MainLoop()
 				autoware_msgs::LaneArray local_lanes;
 				for(unsigned int i=0; i &lt; m_GeneratedRollOuts.size(); i++)
 				{
-					autoware_msgs::lane lane;
+					autoware_msgs::Lane lane;
 					PlannerHNS::RosHelpers::ConvertFromLocalLaneToAutowareLane(m_GeneratedRollOuts.at(i), lane);
 					lane.closest_object_distance = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).closest_obj_distance;
 					lane.closest_object_velocity = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).closest_obj_velocity;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -256,7 +256,7 @@ void TrajectoryGen::MainLoop()
 			{
 				for(unsigned int j=0; j &lt; m_RollOuts.at(i).size(); j++)
 				{
-					autoware_msgs::lane lane;
+					autoware_msgs::Lane lane;
 					PlannerHNS::PlanningHelpers::PredictConstantTimeCostForTrajectory(m_RollOuts.at(i).at(j), m_CurrentPos, m_PlanningParams.minSpeed, m_PlanningParams.microPlanDistance);
 					PlannerHNS::RosHelpers::ConvertFromLocalLaneToAutowareLane(m_RollOuts.at(i).at(j), lane);
 					lane.closest_object_distance = 0;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -100,7 +100,7 @@ OpenPlannerCarSimulator::OpenPlannerCarSimulator()
 	pub_PointerBehaviorStateRviz	= nh.advertise&lt;visualization_msgs::Marker&gt;(str_s2.str(), 1);
 	pub_InternalInfoRviz			= nh.advertise&lt;visualization_msgs::MarkerArray&gt;(str_s7.str(), 1);
 
-	pub_CurrentLocalPath 			= nh.advertise&lt;autoware_msgs::lane&gt;(str_s8.str(), 1);
+	pub_CurrentLocalPath 			= nh.advertise&lt;autoware_msgs::Lane&gt;(str_s8.str(), 1);
 
 	sub_joystick = nh.subscribe("/joy", 		1, &amp;OpenPlannerCarSimulator::callbackGetJoyStickInfo, 		this);
 	sub_StepSignal = nh.subscribe("/simu_step_signal", 		1, &amp;OpenPlannerCarSimulator::callbackGetStepForwardSignals, 		this);
@@ -1011,7 +1011,7 @@ void OpenPlannerCarSimulator::MainLoop()
 
 			if(m_SimParams.bEnableLogs)
 			{
-				autoware_msgs::lane lane;
+				autoware_msgs::Lane lane;
 				PlannerHNS::RosHelpers::ConvertFromLocalLaneToAutowareLane(m_LocalPlanner-&gt;m_Path, lane);
 				lane.lane_id = m_SimParams.id;
 				lane.lane_index = (int)m_CurrBehavior.state;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_data_logger_core.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_data_logger_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -50,7 +50,7 @@
 #include &lt;autoware_msgs/Signals.h&gt;
 #include &lt;autoware_msgs/ExtractedPosition.h&gt;
 #include &lt;autoware_msgs/DetectedObjectArray.h&gt;
-#include &lt;autoware_msgs/lane.h&gt;
+#include &lt;autoware_msgs/Lane.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;geometry_msgs/PoseArray.h&gt;
 #include "op_planner/RoadNetwork.h"
@@ -99,7 +99,7 @@ protected:
 
 	void callbackGetSimuPose(const geometry_msgs::PoseArray &amp;msg);
 	void callbackGetPredictedObjects(const autoware_msgs::DetectedObjectArrayConstPtr&amp; msg);
-	void callbackGetSimuCarsPathAndState(const autoware_msgs::laneConstPtr&amp; msg);
+	void callbackGetSimuCarsPathAndState(const autoware_msgs::LaneConstPtr&amp; msg);
 	void callbackGetBehaviorState(const geometry_msgs::TwistStampedConstPtr&amp; msg );
 	PlannerHNS::BehaviorState ConvertBehaviorStateFromAutowareToPlannerH(const geometry_msgs::TwistStampedConstPtr&amp; msg);
 	PlannerHNS::STATE_TYPE GetStateFromNumber(const int&amp; iBehState);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_data_logger\op_data_logger_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_data_logger\op_data_logger_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -136,7 +136,7 @@ void OpenPlannerDataLogger::callbackGetSimuPose(const geometry_msgs::PoseArray&amp;
 	}
 }
 
-void OpenPlannerDataLogger::callbackGetSimuCarsPathAndState(const autoware_msgs::laneConstPtr&amp; msg )
+void OpenPlannerDataLogger::callbackGetSimuCarsPathAndState(const autoware_msgs::LaneConstPtr&amp; msg )
 {
 	//std::cout &lt;&lt; "Receive Lane Data ... " &lt;&lt; std::endl;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\include\waypoint_follower\libwaypoint_follower.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\include\waypoint_follower\libwaypoint_follower.h" added_lines="5" deleted_lines="5">
				<diff>@@ -39,15 +39,15 @@
 // ROS header
 #include &lt;tf/transform_broadcaster.h&gt;
 #include &lt;tf/transform_listener.h&gt;
-#include "autoware_msgs/lane.h"
+#include "autoware_msgs/Lane.h"
 
 class WayPoints
 {
 protected:
-  autoware_msgs::lane current_waypoints_;
+  autoware_msgs::Lane current_waypoints_;
 
 public:
-  void setPath(const autoware_msgs::lane &amp;waypoints)
+  void setPath(const autoware_msgs::Lane &amp;waypoints)
   {
     current_waypoints_ = waypoints;
   }
@@ -61,7 +61,7 @@ public:
   geometry_msgs::Quaternion getWaypointOrientation(int waypoint) const;
   geometry_msgs::Pose getWaypointPose(int waypoint) const;
   double getWaypointVelocityMPS(int waypoint) const;
-  autoware_msgs::lane getCurrentWaypoints() const
+  autoware_msgs::Lane getCurrentWaypoints() const
   {
     return current_waypoints_;
   }
@@ -96,7 +96,7 @@ geometry_msgs::Point calcAbsoluteCoordinate(geometry_msgs::Point point,
                                                                                 // coordinate
 double getPlaneDistance(geometry_msgs::Point target1,
                         geometry_msgs::Point target2);  // get 2 dimentional distance between target 1 and target 2
-int getClosestWaypoint(const autoware_msgs::lane &amp;current_path, geometry_msgs::Pose current_pose);
+int getClosestWaypoint(const autoware_msgs::Lane &amp;current_path, geometry_msgs::Pose current_pose);
 bool getLinearEquation(geometry_msgs::Point start, geometry_msgs::Point end, double *a, double *b, double *c);
 double getDistanceBetweenLineAndPoint(geometry_msgs::Point point, double sa, double b, double c);
 double getRelativeAngle(geometry_msgs::Pose waypoint_pose, geometry_msgs::Pose vehicle_pose);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\lib\libwaypoint_follower.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\lib\libwaypoint_follower.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -172,7 +172,7 @@ double getRelativeAngle(geometry_msgs::Pose waypoint_pose, geometry_msgs::Pose v
 }
 
 // get closest waypoint from current pose
-int getClosestWaypoint(const autoware_msgs::lane &amp;current_path, geometry_msgs::Pose current_pose)
+int getClosestWaypoint(const autoware_msgs::Lane &amp;current_path, geometry_msgs::Pose current_pose)
 {
   WayPoints wp;
   wp.setPath(current_path);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" added_lines="4" deleted_lines="4">
				<diff>@@ -38,7 +38,7 @@
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 
 // User defined includes
-#include "autoware_msgs/lane.h"
+#include "autoware_msgs/Lane.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 
 namespace waypoint_follower
@@ -62,7 +62,7 @@ public:
   {
     current_linear_velocity_ = cur_vel;
   }
-  void setCurrentWaypoints(const std::vector&lt;autoware_msgs::waypoint&gt; &amp;wps)
+  void setCurrentWaypoints(const std::vector&lt;autoware_msgs::Waypoint&gt; &amp;wps)
   {
     current_waypoints_ = wps;
   }
@@ -88,7 +88,7 @@ public:
   {
     return current_pose_;
   }
-  std::vector&lt;autoware_msgs::waypoint&gt; getCurrentWaypoints() const
+  std::vector&lt;autoware_msgs::Waypoint&gt; getCurrentWaypoints() const
   {
     return current_waypoints_;
   }
@@ -116,7 +116,7 @@ private:
   double minimum_lookahead_distance_;
   geometry_msgs::Pose current_pose_;
   double current_linear_velocity_;
-  std::vector&lt;autoware_msgs::waypoint&gt; current_waypoints_;
+  std::vector&lt;autoware_msgs::Waypoint&gt; current_waypoints_;
 
   // functions
   double calcCurvature(geometry_msgs::Point target) const;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -203,7 +203,7 @@ void PurePursuitNode::callbackFromConfig(const autoware_msgs::ConfigWaypointFoll
 }
 
 void PurePursuitNode::publishDeviationCurrentPosition(const geometry_msgs::Point &amp;point,
-                                                      const std::vector&lt;autoware_msgs::waypoint&gt; &amp;waypoints) const
+                                                      const std::vector&lt;autoware_msgs::Waypoint&gt; &amp;waypoints) const
 {
   // Calculate the deviation of current position from the waypoint approximate line
 
@@ -235,7 +235,7 @@ void PurePursuitNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStam
   is_velocity_set_ = true;
 }
 
-void PurePursuitNode::callbackFromWayPoints(const autoware_msgs::laneConstPtr &amp;msg)
+void PurePursuitNode::callbackFromWayPoints(const autoware_msgs::LaneConstPtr &amp;msg)
 {
   if (!msg-&gt;waypoints.empty())
     command_linear_velocity_ = msg-&gt;waypoints.at(0).twist.twist.linear.x;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" added_lines="3" deleted_lines="3">
				<diff>@@ -41,7 +41,7 @@
 // User defined includes
 #include "autoware_msgs/ConfigWaypointFollower.h"
 #include "autoware_msgs/ControlCommandStamped.h"
-#include "autoware_msgs/lane.h"
+#include "autoware_msgs/Lane.h"
 #include "pure_pursuit.h"
 #include "pure_pursuit_viz.h"
 
@@ -102,7 +102,7 @@ private:
   void callbackFromConfig(const autoware_msgs::ConfigWaypointFollowerConstPtr &amp;config);
   void callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStampedConstPtr &amp;msg);
-  void callbackFromWayPoints(const autoware_msgs::laneConstPtr &amp;msg);
+  void callbackFromWayPoints(const autoware_msgs::LaneConstPtr &amp;msg);
 
   // initializer
   void initForROS();
@@ -111,7 +111,7 @@ private:
   void publishTwistStamped(const bool &amp;can_get_curvature, const double &amp;kappa) const;
   void publishControlCommandStamped(const bool &amp;can_get_curvature, const double &amp;kappa) const;
   void publishDeviationCurrentPosition(const geometry_msgs::Point &amp;point,
-                                       const std::vector&lt;autoware_msgs::waypoint&gt; &amp;waypoints) const;
+                                       const std::vector&lt;autoware_msgs::Waypoint&gt; &amp;waypoints) const;
 
   double computeLookaheadDistance() const;
   double computeCommandVelocity() const;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" added_lines="11" deleted_lines="11">
				<diff>@@ -43,9 +43,9 @@
 #include "autoware_msgs/VehicleCmd.h"
 #include "tablet_socket_msgs/mode_cmd.h"
 #include "tablet_socket_msgs/gear_cmd.h"
-#include "autoware_msgs/accel_cmd.h"
-#include "autoware_msgs/brake_cmd.h"
-#include "autoware_msgs/steer_cmd.h"
+#include "autoware_msgs/AccelCmd.h"
+#include "autoware_msgs/BrakeCmd.h"
+#include "autoware_msgs/SteerCmd.h"
 #include "autoware_msgs/ControlCommandStamped.h"
 
 class TwistGate
@@ -62,10 +62,10 @@ class TwistGate
     void auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::ConstPtr&amp; input_msg);
     void mode_cmd_callback(const tablet_socket_msgs::mode_cmd::ConstPtr&amp; input_msg);
     void gear_cmd_callback(const tablet_socket_msgs::gear_cmd::ConstPtr&amp; input_msg);
-    void accel_cmd_callback(const autoware_msgs::accel_cmd::ConstPtr&amp; input_msg);
-    void steer_cmd_callback(const autoware_msgs::steer_cmd::ConstPtr&amp; input_msg);
-    void brake_cmd_callback(const autoware_msgs::brake_cmd::ConstPtr&amp; input_msg);
-    void lamp_cmd_callback(const autoware_msgs::lamp_cmd::ConstPtr&amp; input_msg);
+    void accel_cmd_callback(const autoware_msgs::AccelCmd::ConstPtr&amp; input_msg);
+    void steer_cmd_callback(const autoware_msgs::SteerCmd::ConstPtr&amp; input_msg);
+    void brake_cmd_callback(const autoware_msgs::BrakeCmd::ConstPtr&amp; input_msg);
+    void lamp_cmd_callback(const autoware_msgs::LampCmd::ConstPtr&amp; input_msg);
     void ctrl_cmd_callback(const autoware_msgs::ControlCommandStamped::ConstPtr&amp; input_msg);
 
     void reset_vehicle_cmd_msg();
@@ -261,7 +261,7 @@ void TwistGate::gear_cmd_callback(const tablet_socket_msgs::gear_cmd::ConstPtr&amp;
   }
 }
 
-void TwistGate::accel_cmd_callback(const autoware_msgs::accel_cmd::ConstPtr&amp; input_msg)
+void TwistGate::accel_cmd_callback(const autoware_msgs::AccelCmd::ConstPtr&amp; input_msg)
 {
   if(command_mode_ == CommandMode::AUTO)
   {
@@ -273,7 +273,7 @@ void TwistGate::accel_cmd_callback(const autoware_msgs::accel_cmd::ConstPtr&amp; inp
   }
 }
 
-void TwistGate::steer_cmd_callback(const autoware_msgs::steer_cmd::ConstPtr&amp; input_msg)
+void TwistGate::steer_cmd_callback(const autoware_msgs::SteerCmd::ConstPtr&amp; input_msg)
 {
   if(command_mode_ == CommandMode::AUTO)
   {
@@ -285,7 +285,7 @@ void TwistGate::steer_cmd_callback(const autoware_msgs::steer_cmd::ConstPtr&amp; inp
   }
 }
 
-void TwistGate::brake_cmd_callback(const autoware_msgs::brake_cmd::ConstPtr&amp; input_msg)
+void TwistGate::brake_cmd_callback(const autoware_msgs::BrakeCmd::ConstPtr&amp; input_msg)
 {
   if(command_mode_ == CommandMode::AUTO)
   {
@@ -297,7 +297,7 @@ void TwistGate::brake_cmd_callback(const autoware_msgs::brake_cmd::ConstPtr&amp; inp
   }
 }
 
-void TwistGate::lamp_cmd_callback(const autoware_msgs::lamp_cmd::ConstPtr&amp; input_msg)
+void TwistGate::lamp_cmd_callback(const autoware_msgs::LampCmd::ConstPtr&amp; input_msg)
 {
   if(command_mode_ == CommandMode::AUTO)
   {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -149,7 +149,7 @@ void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg)
   _initial_set = true;
 }
 
-void waypointCallback(const autoware_msgs::laneConstPtr &amp;msg)
+void waypointCallback(const autoware_msgs::LaneConstPtr &amp;msg)
 {
   // _path_og.setPath(msg);
   _current_waypoints.setPath(*msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" added_lines="14" deleted_lines="14">
				<diff>@@ -66,7 +66,7 @@ void VelocityReplanner::initParameter(const autoware_msgs::ConfigWaypointLoader:
   vel_param_ = calcVelParam();
 }
 
-void VelocityReplanner::replanLaneWaypointVel(autoware_msgs::lane* lane)
+void VelocityReplanner::replanLaneWaypointVel(autoware_msgs::Lane* lane)
 {
   if (vel_param_ == DBL_MAX)
   {
@@ -99,13 +99,13 @@ void VelocityReplanner::replanLaneWaypointVel(autoware_msgs::lane* lane)
   limitVelocityByRange(lane-&gt;waypoints.size() - 1 - end_point_offset_, lane-&gt;waypoints.size() - 1, 0, 0.0, lane);
 }
 
-void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane)
+void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, autoware_msgs::Lane* lane)
 {
   if (lane-&gt;waypoints.empty())
   {
     return;
   }
-  autoware_msgs::lane original_lane = *lane;
+  autoware_msgs::Lane original_lane = *lane;
   lane-&gt;waypoints.clear();
   lane-&gt;waypoints.push_back(original_lane.waypoints[0]);
   lane-&gt;waypoints.reserve(ceil(1.5 * calcPathLength(original_lane) / resample_interval_));
@@ -134,9 +134,9 @@ void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, aut
 }
 
 void VelocityReplanner::resampleOnStraight(const boost::circular_buffer&lt;geometry_msgs::Point&gt;&amp; curve_point,
-                                           autoware_msgs::lane* lane)
+                                           autoware_msgs::Lane* lane)
 {
-  autoware_msgs::waypoint wp = lane-&gt;waypoints.back();
+  autoware_msgs::Waypoint wp = lane-&gt;waypoints.back();
   const geometry_msgs::Point&amp; pt = wp.pose.pose.position;
   const double yaw = atan2(curve_point[2].y - curve_point[0].y, curve_point[2].x - curve_point[0].x);
   wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
@@ -159,9 +159,9 @@ void VelocityReplanner::resampleOnStraight(const boost::circular_buffer&lt;geometry
 }
 
 void VelocityReplanner::resampleOnCurve(const geometry_msgs::Point&amp; target_point,
-                                        const std::vector&lt;double&gt;&amp; curve_param, autoware_msgs::lane* lane)
+                                        const std::vector&lt;double&gt;&amp; curve_param, autoware_msgs::Lane* lane)
 {
-  autoware_msgs::waypoint wp = lane-&gt;waypoints.back();
+  autoware_msgs::Waypoint wp = lane-&gt;waypoints.back();
   const double&amp; cx = curve_param[0];
   const double&amp; cy = curve_param[1];
   const double&amp; radius = curve_param[2];
@@ -198,12 +198,12 @@ void VelocityReplanner::resampleOnCurve(const geometry_msgs::Point&amp; target_point
 // Three points used for curve detection (the target point is the center)
 // [0] = previous point, [1] = target point, [2] = next point
 const boost::circular_buffer&lt;geometry_msgs::Point&gt; VelocityReplanner::getCrvPointsOnResample(
-    const autoware_msgs::lane&amp; lane, const autoware_msgs::lane&amp; original_lane, unsigned long original_index) const
+    const autoware_msgs::Lane&amp; lane, const autoware_msgs::Lane&amp; original_lane, unsigned long original_index) const
 {
   unsigned long id = original_index;
   boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point(3);
   const unsigned int n = (lookup_crv_width_ - 1) / 2;
-  const autoware_msgs::waypoint cp[3] = {
+  const autoware_msgs::Waypoint cp[3] = {
     (lane.waypoints.size() &lt; n) ? lane.waypoints.front() : lane.waypoints[lane.waypoints.size() - n],
     original_lane.waypoints[id],
     (id &lt; original_lane.waypoints.size() - n) ? original_lane.waypoints[id + n] : original_lane.waypoints.back()
@@ -215,7 +215,7 @@ const boost::circular_buffer&lt;geometry_msgs::Point&gt; VelocityReplanner::getCrvPoin
   return curve_point;
 }
 
-const boost::circular_buffer&lt;geometry_msgs::Point&gt; VelocityReplanner::getCrvPoints(const autoware_msgs::lane&amp; lane,
+const boost::circular_buffer&lt;geometry_msgs::Point&gt; VelocityReplanner::getCrvPoints(const autoware_msgs::Lane&amp; lane,
                                                                                    unsigned long index) const
 {
   boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point(3);
@@ -230,7 +230,7 @@ const boost::circular_buffer&lt;geometry_msgs::Point&gt; VelocityReplanner::getCrvPoin
   return curve_point;
 }
 
-void VelocityReplanner::createRadiusList(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
+void VelocityReplanner::createRadiusList(const autoware_msgs::Lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
 {
   if (lane.waypoints.empty())
   {
@@ -302,7 +302,7 @@ void VelocityReplanner::createCurveList(
 }
 
 void VelocityReplanner::limitVelocityByRange(unsigned long start_idx, unsigned long end_idx, unsigned int offset,
-                                             double vmin, autoware_msgs::lane* lane)
+                                             double vmin, autoware_msgs::Lane* lane)
 {
   if (offset &gt; 0)
   {
@@ -321,7 +321,7 @@ void VelocityReplanner::limitVelocityByRange(unsigned long start_idx, unsigned l
   limitAccelDecel(end_idx, lane);
 }
 
-void VelocityReplanner::limitAccelDecel(const unsigned long idx, autoware_msgs::lane* lane)
+void VelocityReplanner::limitAccelDecel(const unsigned long idx, autoware_msgs::Lane* lane)
 {
   const double acc[2] = { accel_limit_, decel_limit_ };
   const unsigned long end_idx[2] = { lane-&gt;waypoints.size() - idx, idx + 1 };
@@ -365,7 +365,7 @@ const std::vector&lt;double&gt; VelocityReplanner::calcCurveParam(boost::circular_buff
   return std::vector&lt;double&gt;();  // error
 }
 
-const double VelocityReplanner::calcPathLength(const autoware_msgs::lane&amp; lane) const
+const double VelocityReplanner::calcPathLength(const autoware_msgs::Lane&amp; lane) const
 {
   double distance = 0.0;
   for (unsigned long i = 1; i &lt; lane.waypoints.size(); i++)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" added_lines="12" deleted_lines="12">
				<diff>@@ -38,7 +38,7 @@
 #include &lt;unordered_map&gt;
 #include &lt;algorithm&gt;
 #include &lt;boost/circular_buffer.hpp&gt;
-#include "autoware_msgs/lane.h"
+#include "autoware_msgs/Lane.h"
 
 namespace waypoint_maker
 {
@@ -59,31 +59,31 @@ public:
   VelocityReplanner();
   ~VelocityReplanner();
   void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
-  void replanLaneWaypointVel(autoware_msgs::lane* lane);
+  void replanLaneWaypointVel(autoware_msgs::Lane* lane);
 
 protected:
-  void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane);
-  void resampleOnStraight(const boost::circular_buffer&lt;geometry_msgs::Point&gt;&amp; curve_point, autoware_msgs::lane* lane);
+  void resampleLaneWaypoint(const double resample_interval, autoware_msgs::Lane* lane);
+  void resampleOnStraight(const boost::circular_buffer&lt;geometry_msgs::Point&gt;&amp; curve_point, autoware_msgs::Lane* lane);
   void resampleOnCurve(const geometry_msgs::Point&amp; target_point, const std::vector&lt;double&gt;&amp; param,
-                       autoware_msgs::lane* lane);
+                       autoware_msgs::Lane* lane);
 
-  const boost::circular_buffer&lt;geometry_msgs::Point&gt; getCrvPointsOnResample(const autoware_msgs::lane&amp; lane,
-                                                                            const autoware_msgs::lane&amp; original_lane,
+  const boost::circular_buffer&lt;geometry_msgs::Point&gt; getCrvPointsOnResample(const autoware_msgs::Lane&amp; lane,
+                                                                            const autoware_msgs::Lane&amp; original_lane,
                                                                             unsigned long original_index) const;
-  const boost::circular_buffer&lt;geometry_msgs::Point&gt; getCrvPoints(const autoware_msgs::lane&amp; lane,
+  const boost::circular_buffer&lt;geometry_msgs::Point&gt; getCrvPoints(const autoware_msgs::Lane&amp; lane,
                                                                   unsigned long index) const;
 
-  void createRadiusList(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius);
+  void createRadiusList(const autoware_msgs::Lane&amp; lane, std::vector&lt;double&gt;* curve_radius);
   const double calcVelParam() const;
   void createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
                        std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list);
 
   void limitVelocityByRange(unsigned long start_idx, unsigned long end_idx, unsigned int offset, double vmin,
-                            autoware_msgs::lane* lane);
-  void limitAccelDecel(const unsigned long idx, autoware_msgs::lane* lane);
+                            autoware_msgs::Lane* lane);
+  void limitAccelDecel(const unsigned long idx, autoware_msgs::Lane* lane);
 
   const std::vector&lt;double&gt; calcCurveParam(boost::circular_buffer&lt;geometry_msgs::Point&gt; point) const;
-  const double calcPathLength(const autoware_msgs::lane&amp; lane) const;
+  const double calcPathLength(const autoware_msgs::Lane&amp; lane) const;
 };
 }
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="12" deleted_lines="12">
				<diff>@@ -116,7 +116,7 @@ void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt;&amp; paths,
 {
   for (const auto&amp; el : paths)
   {
-    autoware_msgs::lane lane;
+    autoware_msgs::Lane lane;
     createLaneWaypoint(el, &amp;lane);
     if (replanning_mode_)
     {
@@ -146,7 +146,7 @@ void WaypointLoaderNode::saveLaneArray(const std::vector&lt;std::string&gt;&amp; paths,
   }
 }
 
-void WaypointLoaderNode::createLaneWaypoint(const std::string&amp; file_path, autoware_msgs::lane* lane)
+void WaypointLoaderNode::createLaneWaypoint(const std::string&amp; file_path, autoware_msgs::Lane* lane)
 {
   if (!verifyFileConsistency(file_path.c_str()))
   {
@@ -156,7 +156,7 @@ void WaypointLoaderNode::createLaneWaypoint(const std::string&amp; file_path, autowa
 
   ROS_INFO("lane data is valid. publishing...");
   FileFormat format = checkFileFormat(file_path.c_str());
-  std::vector&lt;autoware_msgs::waypoint&gt; wps;
+  std::vector&lt;autoware_msgs::Waypoint&gt; wps;
   if (format == FileFormat::ver1)
   {
     loadWaypointsForVer1(file_path.c_str(), &amp;wps);
@@ -174,7 +174,7 @@ void WaypointLoaderNode::createLaneWaypoint(const std::string&amp; file_path, autowa
   lane-&gt;waypoints = wps;
 }
 
-void WaypointLoaderNode::loadWaypointsForVer1(const char* filename, std::vector&lt;autoware_msgs::waypoint&gt;* wps)
+void WaypointLoaderNode::loadWaypointsForVer1(const char* filename, std::vector&lt;autoware_msgs::Waypoint&gt;* wps)
 {
   std::ifstream ifs(filename);
 
@@ -188,7 +188,7 @@ void WaypointLoaderNode::loadWaypointsForVer1(const char* filename, std::vector&lt;
 
   while (std::getline(ifs, line))
   {
-    autoware_msgs::waypoint wp;
+    autoware_msgs::Waypoint wp;
     parseWaypointForVer1(line, &amp;wp);
     wps-&gt;push_back(wp);
   }
@@ -209,7 +209,7 @@ void WaypointLoaderNode::loadWaypointsForVer1(const char* filename, std::vector&lt;
   }
 }
 
-void WaypointLoaderNode::parseWaypointForVer1(const std::string&amp; line, autoware_msgs::waypoint* wp)
+void WaypointLoaderNode::parseWaypointForVer1(const std::string&amp; line, autoware_msgs::Waypoint* wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
@@ -220,7 +220,7 @@ void WaypointLoaderNode::parseWaypointForVer1(const std::string&amp; line, autoware_
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(columns[3]));
 }
 
-void WaypointLoaderNode::loadWaypointsForVer2(const char* filename, std::vector&lt;autoware_msgs::waypoint&gt;* wps)
+void WaypointLoaderNode::loadWaypointsForVer2(const char* filename, std::vector&lt;autoware_msgs::Waypoint&gt;* wps)
 {
   std::ifstream ifs(filename);
 
@@ -234,13 +234,13 @@ void WaypointLoaderNode::loadWaypointsForVer2(const char* filename, std::vector&lt;
 
   while (std::getline(ifs, line))
   {
-    autoware_msgs::waypoint wp;
+    autoware_msgs::Waypoint wp;
     parseWaypointForVer2(line, &amp;wp);
     wps-&gt;push_back(wp);
   }
 }
 
-void WaypointLoaderNode::parseWaypointForVer2(const std::string&amp; line, autoware_msgs::waypoint* wp)
+void WaypointLoaderNode::parseWaypointForVer2(const std::string&amp; line, autoware_msgs::Waypoint* wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
@@ -252,7 +252,7 @@ void WaypointLoaderNode::parseWaypointForVer2(const std::string&amp; line, autoware_
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(columns[4]));
 }
 
-void WaypointLoaderNode::loadWaypointsForVer3(const char* filename, std::vector&lt;autoware_msgs::waypoint&gt;* wps)
+void WaypointLoaderNode::loadWaypointsForVer3(const char* filename, std::vector&lt;autoware_msgs::Waypoint&gt;* wps)
 {
   std::ifstream ifs(filename);
 
@@ -269,14 +269,14 @@ void WaypointLoaderNode::loadWaypointsForVer3(const char* filename, std::vector&lt;
   // std::getline(ifs, line);  // remove second line
   while (std::getline(ifs, line))
   {
-    autoware_msgs::waypoint wp;
+    autoware_msgs::Waypoint wp;
     parseWaypointForVer3(line, contents, &amp;wp);
     wps-&gt;push_back(wp);
   }
 }
 
 void WaypointLoaderNode::parseWaypointForVer3(const std::string&amp; line, const std::vector&lt;std::string&gt;&amp; contents,
-                                              autoware_msgs::waypoint* wp)
+                                              autoware_msgs::Waypoint* wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="7" deleted_lines="7">
				<diff>@@ -100,19 +100,19 @@ private:
   // functions
   void configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
   void outputCommandCallback(const std_msgs::Bool::ConstPtr&amp; output_cmd);
-  void createLaneWaypoint(const std::string&amp; file_path, autoware_msgs::lane* lane);
+  void createLaneWaypoint(const std::string&amp; file_path, autoware_msgs::Lane* lane);
   void createLaneArray(const std::vector&lt;std::string&gt;&amp; paths, autoware_msgs::LaneArray* lane_array);
   void saveLaneArray(const std::vector&lt;std::string&gt;&amp; paths, const autoware_msgs::LaneArray&amp; lane_array);
 
   FileFormat checkFileFormat(const char* filename);
   bool verifyFileConsistency(const char* filename);
-  void loadWaypointsForVer1(const char* filename, std::vector&lt;autoware_msgs::waypoint&gt;* wps);
-  void parseWaypointForVer1(const std::string&amp; line, autoware_msgs::waypoint* wp);
-  void loadWaypointsForVer2(const char* filename, std::vector&lt;autoware_msgs::waypoint&gt;* wps);
-  void parseWaypointForVer2(const std::string&amp; line, autoware_msgs::waypoint* wp);
-  void loadWaypointsForVer3(const char* filename, std::vector&lt;autoware_msgs::waypoint&gt;* wps);
+  void loadWaypointsForVer1(const char* filename, std::vector&lt;autoware_msgs::Waypoint&gt;* wps);
+  void parseWaypointForVer1(const std::string&amp; line, autoware_msgs::Waypoint* wp);
+  void loadWaypointsForVer2(const char* filename, std::vector&lt;autoware_msgs::Waypoint&gt;* wps);
+  void parseWaypointForVer2(const std::string&amp; line, autoware_msgs::Waypoint* wp);
+  void loadWaypointsForVer3(const char* filename, std::vector&lt;autoware_msgs::Waypoint&gt;* wps);
   void parseWaypointForVer3(const std::string&amp; line, const std::vector&lt;std::string&gt;&amp; contents,
-                            autoware_msgs::waypoint* wp);
+                            autoware_msgs::Waypoint* wp);
 };
 
 const std::string addFileSuffix(std::string file_path, std::string suffix);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -41,7 +41,7 @@
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "autoware_msgs/LaneArray.h"
 #include "autoware_msgs/ConfigLaneStop.h"
-#include "autoware_msgs/traffic_light.h"
+#include "autoware_msgs/TrafficLight.h"
 
 namespace
 {
@@ -204,7 +204,7 @@ void createGlobalLaneArrayChangeFlagMarker(const autoware_msgs::LaneArray&amp; lane_
 }
 
 void createLocalWaypointVelocityMarker(std_msgs::ColorRGBA color, int closest_waypoint,
-                                       const autoware_msgs::lane&amp; lane_waypoint)
+                                       const autoware_msgs::Lane&amp; lane_waypoint)
 {
   // display by markers the velocity of each waypoint.
   visualization_msgs::Marker velocity;
@@ -296,7 +296,7 @@ void createGlobalLaneArrayOrientationMarker(const autoware_msgs::LaneArray&amp; lane
                                        tmp_marker_array.markers.end());
 }
 
-void createLocalPathMarker(std_msgs::ColorRGBA color, const autoware_msgs::lane&amp; lane_waypoint)
+void createLocalPathMarker(std_msgs::ColorRGBA color, const autoware_msgs::Lane&amp; lane_waypoint)
 {
   visualization_msgs::Marker lane_waypoint_marker;
   lane_waypoint_marker.header.frame_id = "map";
@@ -318,7 +318,7 @@ void createLocalPathMarker(std_msgs::ColorRGBA color, const autoware_msgs::lane&amp;
   g_local_waypoints_marker_array.markers.push_back(lane_waypoint_marker);
 }
 
-void createLocalPointMarker(const autoware_msgs::lane&amp; lane_waypoint)
+void createLocalPointMarker(const autoware_msgs::Lane&amp; lane_waypoint)
 {
   visualization_msgs::Marker lane_waypoint_marker;
   lane_waypoint_marker.header.frame_id = "map";
@@ -343,7 +343,7 @@ void createLocalPointMarker(const autoware_msgs::lane&amp; lane_waypoint)
   g_local_waypoints_marker_array.markers.push_back(lane_waypoint_marker);
 }
 
-void lightCallback(const autoware_msgs::traffic_lightConstPtr&amp; msg)
+void lightCallback(const autoware_msgs::TrafficLightConstPtr&amp; msg)
 {
   std_msgs::ColorRGBA global_color;
   global_color.a = g_global_alpha;
@@ -379,13 +379,13 @@ void lightCallback(const autoware_msgs::traffic_lightConstPtr&amp; msg)
   }
 }
 
-void receiveAutoDetection(const autoware_msgs::traffic_lightConstPtr&amp; msg)
+void receiveAutoDetection(const autoware_msgs::TrafficLightConstPtr&amp; msg)
 {
   if (!g_config_manual_detection)
     lightCallback(msg);
 }
 
-void receiveManualDetection(const autoware_msgs::traffic_lightConstPtr&amp; msg)
+void receiveManualDetection(const autoware_msgs::TrafficLightConstPtr&amp; msg)
 {
   if (g_config_manual_detection)
     lightCallback(msg);
@@ -406,7 +406,7 @@ void laneArrayCallback(const autoware_msgs::LaneArrayConstPtr&amp; msg)
   publishMarkerArray(g_global_marker_array, g_global_mark_pub);
 }
 
-void finalCallback(const autoware_msgs::laneConstPtr&amp; msg)
+void finalCallback(const autoware_msgs::LaneConstPtr&amp; msg)
 {
   g_local_waypoints_marker_array.markers.clear();
   if (_closest_waypoint != -1)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -50,7 +50,7 @@
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "autoware_msgs/LaneArray.h"
 #include "autoware_msgs/ConfigLaneStop.h"
-#include "autoware_msgs/traffic_light.h"
+#include "autoware_msgs/TrafficLight.h"
 
 class WaypointVelocityVisualizer
 {
@@ -108,7 +108,7 @@ private:
   void resetBuffers();
 
   void laneWaypointsArrayCallback(const autoware_msgs::LaneArray::ConstPtr&amp; msg);
-  void finalWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg);
+  void finalWaypointsCallback(const autoware_msgs::Lane::ConstPtr&amp; msg);
   void controlCallback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg,
                        const geometry_msgs::TwistStamped::ConstPtr&amp; current_twist_msg,
                        const geometry_msgs::TwistStamped::ConstPtr&amp; command_twist_msg);
@@ -117,7 +117,7 @@ private:
 
   void createVelocityMarker(const std::vector&lt;nav_msgs::Odometry&gt; waypoints, const std::string&amp; ns,
                             const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
-  void createVelocityMarker(const autoware_msgs::lane&amp; lane, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color,
+  void createVelocityMarker(const autoware_msgs::Lane&amp; lane, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color,
                             visualization_msgs::MarkerArray&amp; markers);
   void createVelocityMarker(const boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt;&amp; poses,
                             const boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt;&amp; twists, const std::string&amp; ns,
@@ -220,7 +220,7 @@ void WaypointVelocityVisualizer::laneWaypointsArrayCallback(const autoware_msgs:
   publishVelocityMarker();
 }
 
-void WaypointVelocityVisualizer::finalWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg)
+void WaypointVelocityVisualizer::finalWaypointsCallback(const autoware_msgs::Lane::ConstPtr&amp; msg)
 {
   final_waypoints_marker_array_.markers.clear();
   createVelocityMarker(*msg, "final_waypoints", final_waypoints_color_, final_waypoints_marker_array_);
@@ -292,7 +292,7 @@ void WaypointVelocityVisualizer::createVelocityMarker(const std::vector&lt;nav_msgs
     createVelocityTextMarker(waypoints, ns, color, markers);
 }
 
-void WaypointVelocityVisualizer::createVelocityMarker(const autoware_msgs::lane&amp; lane, const std::string&amp; ns,
+void WaypointVelocityVisualizer::createVelocityMarker(const autoware_msgs::Lane&amp; lane, const std::string&amp; ns,
                                                       const std_msgs::ColorRGBA&amp; color,
                                                       visualization_msgs::MarkerArray&amp; markers)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -79,7 +79,7 @@ void StateMachineNode::publish() const
   pub_.publish(msg);
 }
 
-void StateMachineNode::callbackFromLightColor(const autoware_msgs::traffic_lightConstPtr&amp; msg)
+void StateMachineNode::callbackFromLightColor(const autoware_msgs::TrafficLightConstPtr&amp; msg)
 {
   ROS_INFO("Light color callback");
   if (is_manual_light_detection_)
@@ -90,7 +90,7 @@ void StateMachineNode::callbackFromLightColor(const autoware_msgs::traffic_light
   publish();
 }
 
-void StateMachineNode::callbackFromLightColorManaged(const autoware_msgs::traffic_lightConstPtr&amp; msg)
+void StateMachineNode::callbackFromLightColorManaged(const autoware_msgs::TrafficLightConstPtr&amp; msg)
 {
   ROS_INFO("Light color managed callback");
   if (!is_manual_light_detection_)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.h" added_lines="3" deleted_lines="3">
				<diff>@@ -37,7 +37,7 @@
 #include &lt;std_msgs/Int32.h&gt;
 
 // User Defined includes
-#include "autoware_msgs/traffic_light.h"
+#include "autoware_msgs/TrafficLight.h"
 #include "state_machine.h"
 
 namespace state_machine
@@ -68,8 +68,8 @@ private:
   bool is_manual_light_detection_;
 
   // callbacks
-  void callbackFromLightColor(const autoware_msgs::traffic_lightConstPtr &amp;msg);
-  void callbackFromLightColorManaged(const autoware_msgs::traffic_lightConstPtr &amp;msg);
+  void callbackFromLightColor(const autoware_msgs::TrafficLightConstPtr &amp;msg);
+  void callbackFromLightColorManaged(const autoware_msgs::TrafficLightConstPtr &amp;msg);
   void callbackFromChangeFlag(const std_msgs::Int32ConstPtr&amp; msg);
 
   // initializer
</diff>
			</file>
			<file old_path="ros\src\data\packages\map_file\nodes\points_map_loader\points_map_loader.cpp" new_path="ros\src\data\packages\map_file\nodes\points_map_loader\points_map_loader.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -423,7 +423,7 @@ void request_lookahead_download(const autoware_msgs::LaneArray&amp; msg)
 {
 	request_queue.clear_look_ahead();
 
-	for (const autoware_msgs::lane&amp; l : msg.lanes) {
+	for (const autoware_msgs::Lane&amp; l : msg.lanes) {
 		size_t end = l.waypoints.size() - 1;
 		double distance = 0;
 		double threshold = (MARGIN_UNIT / 2) + margin; // XXX better way?
</diff>
			</file>
			<file old_path="ros\src\data\packages\pos_db\nodes\pos_uploader\pos_uploader.cpp" new_path="ros\src\data\packages\pos_db\nodes\pos_uploader\pos_uploader.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -48,7 +48,7 @@
 
 
 #include &lt;pos_db.h&gt;
-#include "autoware_msgs/obj_label.h"
+#include "autoware_msgs/ObjLabel.h"
 
 #define MYNAME		"pos_uploader"
 #define OWN_TOPIC_NAME	"current_pose"
@@ -58,8 +58,8 @@
 using namespace std;
 
 //store subscribed value
-static std::vector &lt;autoware_msgs::obj_label&gt; car_positions_array;
-static std::vector &lt;autoware_msgs::obj_label&gt; person_positions_array;
+static std::vector &lt;autoware_msgs::ObjLabel&gt; car_positions_array;
+static std::vector &lt;autoware_msgs::ObjLabel&gt; person_positions_array;
 //flag for comfirming whether updating position or not
 static size_t car_num = 0;
 static size_t person_num = 0;
@@ -156,7 +156,7 @@ static std::string point_to_insert_statement(const geometry_msgs::Point&amp; point,
   return oss.str();
 }
 
-static std::string makeSendDataDetectedObj(const autoware_msgs::obj_label&amp; cp_array, const char *name)
+static std::string makeSendDataDetectedObj(const autoware_msgs::ObjLabel&amp; cp_array, const char *name)
 {
   std::string timestamp;
   if(use_current_time  || cp_array.header.stamp.sec == 0) {
@@ -259,7 +259,7 @@ static void car_locate_cb(const jsk_recognition_msgs::BoundingBoxArray&amp; obj_pose
 {
 	if (obj_pose_msg.boxes.size() &gt; 0) {
 		geometry_msgs::Point tmpPoint;
-		autoware_msgs::obj_label tmpLabel;
+		autoware_msgs::ObjLabel tmpLabel;
 
 		pthread_mutex_lock(&amp;pose_lock_);
 
@@ -282,7 +282,7 @@ static void person_locate_cb(const jsk_recognition_msgs::BoundingBoxArray &amp;obj_p
 {
 	if (obj_pose_msg.boxes.size() &gt; 0) {
 		geometry_msgs::Point tmpPoint;
-		autoware_msgs::obj_label tmpLabel;
+		autoware_msgs::ObjLabel tmpLabel;
 
 		pthread_mutex_lock(&amp;pose_lock_);
 
</diff>
			</file>
			<file old_path="ros\src\data\packages\vector_map_server\nodes\vector_map_client\vector_map_client.cpp" new_path="ros\src\data\packages\vector_map_server\nodes\vector_map_client\vector_map_client.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -29,7 +29,7 @@
 */
 
 #include &lt;geometry_msgs/PoseStamped.h&gt;
-#include "autoware_msgs/lane.h"
+#include "autoware_msgs/Lane.h"
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include "vector_map/vector_map.h"
 
@@ -61,7 +61,7 @@ class VectorMapClient
 {
 private:
   geometry_msgs::PoseStamped pose_;
-  autoware_msgs::lane waypoints_;
+  autoware_msgs::Lane waypoints_;
 
 public:
   VectorMapClient()
@@ -73,7 +73,7 @@ public:
     return pose_;
   }
 
-  autoware_msgs::lane getWaypoints() const
+  autoware_msgs::Lane getWaypoints() const
   {
     return waypoints_;
   }
@@ -83,7 +83,7 @@ public:
     pose_ = pose;
   }
 
-  void setWaypoints(const autoware_msgs::lane&amp; waypoints)
+  void setWaypoints(const autoware_msgs::Lane&amp; waypoints)
   {
     waypoints_ = waypoints;
   }
</diff>
			</file>
			<file old_path="ros\src\data\packages\vector_map_server\nodes\vector_map_server\vector_map_server.cpp" new_path="ros\src\data\packages\vector_map_server\nodes\vector_map_server\vector_map_server.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -29,7 +29,7 @@
 */
 
 #include &lt;geometry_msgs/PoseStamped.h&gt;
-#include "autoware_msgs/lane.h"
+#include "autoware_msgs/Lane.h"
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include "vector_map/vector_map.h"
 
@@ -345,7 +345,7 @@ std::vector&lt;Lane&gt; findNearLanes(const VectorMap&amp; vmap, const std::vector&lt;Lane&gt;&amp;
   return near_lanes;
 }
 
-std::vector&lt;Lane&gt; createFineLanes(const VectorMap&amp; vmap, const autoware_msgs::lane&amp; waypoints, double radius,
+std::vector&lt;Lane&gt; createFineLanes(const VectorMap&amp; vmap, const autoware_msgs::Lane&amp; waypoints, double radius,
                                   int loops)
 {
   std::vector&lt;Lane&gt; null_lanes;
@@ -532,7 +532,7 @@ private:
   ros::Publisher marker_array_pub_;
 
   std::vector&lt;Lane&gt; createTravelingRoute(const geometry_msgs::PoseStamped&amp; pose,
-                                         const autoware_msgs::lane&amp; waypoints)
+                                         const autoware_msgs::Lane&amp; waypoints)
   {
     std::vector&lt;Lane&gt; null_lanes;
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_publisher\calibration_publisher.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_publisher\calibration_publisher.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -5,7 +5,7 @@
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 #include &lt;sensor_msgs/Image.h&gt;
-#include "autoware_msgs/projection_matrix.h"
+#include "autoware_msgs/ProjectionMatrix.h"
 
 static cv::Mat CameraExtrinsicMat;
 static cv::Mat CameraMat;
@@ -27,7 +27,7 @@ static bool instrinsics_parsed_;
 static bool extrinsics_parsed_;
 
 static sensor_msgs::CameraInfo camera_info_msg_;
-static autoware_msgs::projection_matrix extrinsic_matrix_msg_;
+static autoware_msgs::ProjectionMatrix extrinsic_matrix_msg_;
 
 void tfRegistration(const cv::Mat &amp;camExtMat, const ros::Time &amp;timeStamp)
 {
@@ -214,7 +214,7 @@ int main(int argc, char *argv[])
 
 	camera_info_pub = n.advertise&lt;sensor_msgs::CameraInfo&gt;(camera_info_name, 10, true);
 
-	projection_matrix_pub = n.advertise&lt;autoware_msgs::projection_matrix&gt;(projection_matrix_name, 10, true);
+	projection_matrix_pub = n.advertise&lt;autoware_msgs::ProjectionMatrix&gt;(projection_matrix_name, 10, true);
 
 	ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\nodes\points2image\points2image.cpp" new_path="ros\src\sensing\fusion\packages\points2image\nodes\points2image\points2image.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -32,7 +32,7 @@
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;sensor_msgs/CameraInfo.h&gt;
 #include "autoware_msgs/PointsImage.h"
-#include "autoware_msgs/projection_matrix.h"
+#include "autoware_msgs/ProjectionMatrix.h"
 //#include "autoware_msgs/CameraExtrinsic.h"
 
 #include &lt;include/points_image/points_image.hpp&gt;
@@ -49,7 +49,7 @@ static cv::Size imageSize;
 
 static ros::Publisher pub;
 
-static void projection_callback(const autoware_msgs::projection_matrix&amp; msg)
+static void projection_callback(const autoware_msgs::ProjectionMatrix&amp; msg)
 {
   cameraExtrinsicMat = cv::Mat(4, 4, CV_64F);
   for (int row = 0; row &lt; 4; row++)
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\nodes\vscan2image\vscan2image.cpp" new_path="ros\src\sensing\fusion\packages\points2image\nodes\vscan2image\vscan2image.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -32,7 +32,7 @@
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;sensor_msgs/CameraInfo.h&gt;
 #include "autoware_msgs/PointsImage.h"
-#include "autoware_msgs/projection_matrix.h"
+#include "autoware_msgs/ProjectionMatrix.h"
 //#include "autoware_msgs/CameraExtrinsic.h"
 
 #include &lt;include/points_image/points_image.hpp&gt;
@@ -48,7 +48,7 @@ static cv::Mat distCoeff;
 static cv::Size imageSize;
 static ros::Publisher pub;
 
-static void projection_callback(const autoware_msgs::projection_matrix&amp; msg)
+static void projection_callback(const autoware_msgs::ProjectionMatrix&amp; msg)
 {
   cameraExtrinsicMat = cv::Mat(4, 4, CV_64F);
   for (int row = 0; row &lt; 4; row++)
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\scan2image\nodes\scan2image\scan2image.cpp" new_path="ros\src\sensing\fusion\packages\scan2image\nodes\scan2image\scan2image.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -14,7 +14,7 @@
 #include "scan2image.h"
 
 #include "autoware_msgs/ScanImage.h"
-#include "autoware_msgs/projection_matrix.h"
+#include "autoware_msgs/ProjectionMatrix.h"
 #include &lt;sensor_msgs/CameraInfo.h&gt;
 
 #if 1 // AXE
@@ -77,7 +77,7 @@ void trans_depth_points_to_image_points(Scan_points_dataset* scan_points_dataset
     }
 }
 
-static void projection_callback(const autoware_msgs::projection_matrix&amp; msg)
+static void projection_callback(const autoware_msgs::ProjectionMatrix&amp; msg)
 {
     printf("projection\n");
 
</diff>
			</file>
			<file old_path="ros\src\socket\packages\tablet_socket\nodes\tablet_sender\tablet_sender.cpp" new_path="ros\src\socket\packages\tablet_socket\nodes\tablet_sender\tablet_sender.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -40,7 +40,7 @@
 #include &lt;tablet_socket_msgs/error_info.h&gt;
 #include &lt;tablet_socket_msgs/mode_info.h&gt;
 #include "autoware_msgs/CanInfo.h"
-#include "autoware_msgs/ndt_stat.h"
+#include "autoware_msgs/NDTStat.h"
 
 static constexpr int DEFAULT_PORT = 5777;
 static constexpr int LISTEN_BACKLOG = 10;
@@ -94,7 +94,7 @@ struct ndt_request {
 	float acceleration;
 	int32_t use_predict_pose;
 
-	ndt_request(const autoware_msgs::ndt_stat&amp; msg) {
+	ndt_request(const autoware_msgs::NDTStat&amp; msg) {
 		type = NDT_STAT_TYPE;
 		exe_time = msg.exe_time;
 		iteration = msg.iteration;
@@ -214,7 +214,7 @@ static void subscribe_mode_info(const tablet_socket_msgs::mode_info&amp; msg)
 	}
 }
 
-static void subscribe_ndt_stat(const autoware_msgs::ndt_stat&amp; msg)
+static void subscribe_ndt_stat(const autoware_msgs::NDTStat&amp; msg)
 {
 	ndt_request request(msg);
 	int response;
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\kf_track\sync_track.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\kf_track\sync_track.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -1,7 +1,7 @@
 #include "ros/ros.h"
 #include "sensor_msgs/Image.h"
-#include "autoware_msgs/image_obj_tracked.h"
-#include "autoware_msgs/image_obj_ranged.h"
+#include "autoware_msgs/ImageObjTracked.h"
+#include "autoware_msgs/ImageObjRanged.h"
 #include "sync.hpp"
 
 int main(int argc, char **argv) {
@@ -13,7 +13,7 @@ int main(int argc, char **argv) {
     std::string pub1("/image_obj_ranged");
     std::string pub2("/image_raw");
 
-    Synchronizer&lt;autoware_msgs::image_obj_ranged, sensor_msgs::Image, autoware_msgs::image_obj_tracked&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
+    Synchronizer&lt;autoware_msgs::ImageObjRange, sensor_msgs::Image, autoware_msgs::ImageObjTracked&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
     synchronizer.run();
 
     return 0;
@@ -40,8 +40,8 @@ int main(int argc, char **argv) {
 #include "t_sync_message.h"
 /* user header */
 #include "sensor_msgs/Image.h"
-#include "autoware_msgs/image_obj_tracked.h"
-#include "autoware_msgs/image_obj_ranged.h"
+#include "autoware_msgs/ImageObjTracked.h"
+#include "autoware_msgs/ImageObjRanged.h"
 
 /* ----mode---- */
 #define _REQ_PUB 1
@@ -51,7 +51,7 @@ int main(int argc, char **argv) {
 bool buf_flag;
 pthread_mutex_t mutex;
 /* user var */
-boost::circular_buffer&lt;autoware_msgs::image_obj_ranged&gt; image_obj_ranged_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::ImageObjRanged&gt; image_obj_ranged_ringbuf(10);
 boost::circular_buffer&lt;sensor_msgs::Image&gt; image_raw_ringbuf(10);
 ros::Publisher image_obj_ranged__pub;
 ros::Publisher image_raw__pub;
@@ -71,10 +71,10 @@ double get_time(const std_msgs::Header *timespec) {
 
 
 #if _REQ_PUB
-autoware_msgs::image_obj_ranged* p_image_obj_ranged_buf;
+autoware_msgs::ImageObjRange* p_image_obj_ranged_buf;
 sensor_msgs::Image* p_image_raw_buf;
 
-void publish_msg(autoware_msgs::image_obj_ranged* p_image_obj_ranged_buf, sensor_msgs::Image* p_image_raw_buf) {
+void publish_msg(autoware_msgs::ImageObjRange* p_image_obj_ranged_buf, sensor_msgs::Image* p_image_raw_buf) {
     ROS_INFO("publish");
     image_obj_ranged__pub.publish(*p_image_obj_ranged_buf);
     image_raw__pub.publish(*p_image_raw_buf);
@@ -97,7 +97,7 @@ bool publish() {
         // image_obj_ranged &gt; image_raw
         if (get_time(&amp;(image_obj_ranged_ringbuf.front().header)) &gt;= get_time(&amp;(image_raw_ringbuf.front().header))) {
             p_image_raw_buf = &amp;(image_raw_ringbuf.front());
-            boost::circular_buffer&lt;autoware_msgs::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::ImageObjRanged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
             if (image_obj_ranged_ringbuf.size() == 1) {
                 p_image_obj_ranged_buf = &amp;*it;
                 publish_msg(p_image_obj_ranged_buf, p_image_raw_buf);
@@ -163,7 +163,7 @@ bool publish() {
     }
 }
 
-void image_obj_ranged_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
+void image_obj_ranged_callback(const autoware_msgs::ImageObjRanged::ConstPtr&amp; image_obj_ranged_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ranged_ringbuf.push_front(*image_obj_ranged_msg);
     //image_raw is empty
@@ -203,7 +203,7 @@ void image_raw_callback(const sensor_msgs::Image::ConstPtr&amp; image_raw_msg) {
 #else
 #endif
 
-void image_obj_tracked_callback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
+void image_obj_tracked_callback(const autoware_msgs::ImageObjTracked::ConstPtr&amp; image_obj_tracked_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_tracked_flag = true;
     ROS_INFO("catch publish request");
@@ -252,7 +252,7 @@ int main(int argc, char **argv) {
 
     ros::Subscriber image_obj_ranged_sub = nh.subscribe("/image_obj_ranged", 1, image_obj_ranged_callback);
     ros::Subscriber image_raw_sub = nh.subscribe("/sync_drivers/image_raw", 1, image_raw_callback);
-    image_obj_ranged__pub = nh.advertise&lt;autoware_msgs::image_obj_ranged&gt;("/sync_tracking/image_obj_ranged", 5);
+    image_obj_ranged__pub = nh.advertise&lt;autoware_msgs::ImageObjRanged&gt;("/sync_tracking/image_obj_ranged", 5);
     image_raw__pub = nh.advertise&lt;sensor_msgs::Image&gt;("/sync_tracking/image_raw", 5);
 
     while ((!buf_flag) &amp;&amp; ros::ok()) {
@@ -284,10 +284,10 @@ int main(int argc, char **argv) {
 
 
 #if 0
-autoware_msgs::image_obj_ranged image_obj_ranged_buf;
+autoware_msgs::ImageObjRanged image_obj_ranged_buf;
 sensor_msgs::Image image_raw_buf;
 
-void image_obj_ranged_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
+void image_obj_ranged_callback(const autoware_msgs::ImageObjRanged::ConstPtr&amp; image_obj_ranged_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ranged_ringbuf.push_front(*image_obj_ranged_msg);
 
@@ -303,7 +303,7 @@ void image_obj_ranged_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp;
     // image_obj_ranged &gt; image_raw
     if (get_time(&amp;(image_obj_ranged_ringbuf.front().header)) &gt;= get_time(&amp;(image_raw_ringbuf.front().header))) {
         image_raw_buf = image_raw_ringbuf.front();
-        boost::circular_buffer&lt;autoware_msgs::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::ImageObjRanged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
         if (image_obj_ranged_ringbuf.size() == 1) {
             image_obj_ranged_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -360,7 +360,7 @@ void image_raw_callback(const sensor_msgs::Image::ConstPtr&amp; image_raw_msg) {
     // image_obj_ranged &gt; image_raw
     if (get_time(&amp;(image_obj_ranged_ringbuf.front().header)) &gt;= get_time(&amp;(image_raw_ringbuf.front().header))) {
         image_raw_buf = image_raw_ringbuf.front();
-        boost::circular_buffer&lt;autoware_msgs::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::ImageObjRanged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
         if (image_obj_ranged_ringbuf.size() == 1) {
             image_obj_ranged_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\sync_obj_reproj.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\sync_obj_reproj.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -1,7 +1,7 @@
 #include "ros/ros.h"
-#include "autoware_msgs/image_obj_tracked.h"
+#include "autoware_msgs/ImageObjTracked.h"
 #include "geometry_msgs/PoseStamped.h"
-#include "autoware_msgs/obj_label.h"
+#include "autoware_msgs/ObjLabel.h"
 #include "sync.hpp"
 
 int main(int argc, char **argv) {
@@ -13,7 +13,7 @@ int main(int argc, char **argv) {
     std::string pub1("/image_obj_tracked");
     std::string pub2("/current_pose");
 
-    Synchronizer&lt;autoware_msgs::image_obj_tracked, geometry_msgs::PoseStamped, autoware_msgs::obj_label&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
+    Synchronizer&lt;autoware_msgs::ImageObjTracked, geometry_msgs::PoseStamped, autoware_msgs::ObjLabel&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
     synchronizer.run();
 
     return 0;
@@ -39,9 +39,9 @@ int main(int argc, char **argv) {
 #include &lt;pthread.h&gt;
 #include "t_sync_message.h"
 /* user header */
-#include "autoware_msgs/image_obj_tracked.h"
+#include "autoware_msgs/ImageObjTracked.h"
 #include "geometry_msgs/PoseStamped.h"
-#include "autoware_msgs/obj_label.h"
+#include "autoware_msgs/ObjLabel.h"
 
 /* ----mode---- */
 #define _REQ_PUB 1
@@ -51,7 +51,7 @@ int main(int argc, char **argv) {
 bool buf_flag;
 pthread_mutex_t mutex;
 /* user var */
-boost::circular_buffer&lt;autoware_msgs::image_obj_tracked&gt; image_obj_tracked_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::ImageObjTracked&gt; image_obj_tracked_ringbuf(10);
 boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt; current_pose_ringbuf(10);
 ros::Publisher image_obj_tracked__pub;
 ros::Publisher current_pose__pub;
@@ -71,10 +71,10 @@ double get_time(const std_msgs::Header *timespec) {
 
 
 #if _REQ_PUB
-autoware_msgs::image_obj_tracked* p_image_obj_tracked_buf;
+autoware_msgs::ImageObjTracked* p_image_obj_tracked_buf;
 geometry_msgs::PoseStamped* p_current_pose_buf;
 
-void publish_msg(autoware_msgs::image_obj_tracked* p_image_obj_tracked_buf, geometry_msgs::PoseStamped* p_current_pose_buf) {
+void publish_msg(autoware_msgs::ImageObjTracked* p_image_obj_tracked_buf, geometry_msgs::PoseStamped* p_current_pose_buf) {
     ROS_INFO("publish");
     image_obj_tracked__pub.publish(*p_image_obj_tracked_buf);
     current_pose__pub.publish(*p_current_pose_buf);
@@ -97,7 +97,7 @@ bool publish() {
         // image_obj_tracked &gt; current_pose
         if (get_time(&amp;(image_obj_tracked_ringbuf.front().header)) &gt;= get_time(&amp;(current_pose_ringbuf.front().header))) {
             p_current_pose_buf = &amp;(current_pose_ringbuf.front());
-            boost::circular_buffer&lt;autoware_msgs::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::ImageObjTracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
             if (image_obj_tracked_ringbuf.size() == 1) {
                 p_image_obj_tracked_buf = &amp;*it;
                 publish_msg(p_image_obj_tracked_buf, p_current_pose_buf);
@@ -163,7 +163,7 @@ bool publish() {
     }
 }
 
-void image_obj_tracked_callback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
+void image_obj_tracked_callback(const autoware_msgs::ImageObjTracked::ConstPtr&amp; image_obj_tracked_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_tracked_ringbuf.push_front(*image_obj_tracked_msg);
     //current_pose is empty
@@ -204,7 +204,7 @@ void current_pose_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_p
 #else
 #endif
 
-void obj_label_callback(const autoware_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
+void obj_label_callback(const autoware_msgs::ObjLabel::ConstPtr&amp; obj_label_msg) {
     pthread_mutex_lock(&amp;mutex);
     obj_label_flag = true;
     ROS_INFO("catch publish request");
@@ -252,7 +252,7 @@ int main(int argc, char **argv) {
 
     ros::Subscriber image_obj_tracked_sub = nh.subscribe("/image_obj_tracked", 1, image_obj_tracked_callback);
     ros::Subscriber current_pose_sub = nh.subscribe("/current_pose", 1, current_pose_callback);
-    image_obj_tracked__pub = nh.advertise&lt;autoware_msgs::image_obj_tracked&gt;("/sync_reprojection/image_obj_tracked", 5);
+    image_obj_tracked__pub = nh.advertise&lt;autoware_msgs::ImageObjTracked&gt;("/sync_reprojection/image_obj_tracked", 5);
     current_pose__pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/sync_reprojection/current_pose", 5);
 
     while (!buf_flag &amp;&amp; ros::ok()) {
@@ -281,10 +281,10 @@ int main(int argc, char **argv) {
 }
 
 #if 0
-autoware_msgs::image_obj_tracked image_obj_tracked_buf;
+autoware_msgs::ImageObjTracked image_obj_tracked_buf;
 geometry_msgs::PoseStamped current_pose_buf;
 
-void image_obj_tracked_callback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
+void image_obj_tracked_callback(const autoware_msgs::ImageObjTracked::ConstPtr&amp; image_obj_tracked_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_tracked_ringbuf.push_front(*image_obj_tracked_msg);
 
@@ -300,7 +300,7 @@ void image_obj_tracked_callback(const autoware_msgs::image_obj_tracked::ConstPtr
     // image_obj_tracked &gt; current_pose
     if (get_time(&amp;(image_obj_tracked_ringbuf.front().header)) &gt;= get_time(&amp;(current_pose_ringbuf.front().header))) {
         current_pose_buf = current_pose_ringbuf.front();
-        boost::circular_buffer&lt;autoware_msgs::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::ImageObjTracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
         if (image_obj_tracked_ringbuf.size() == 1) {
             image_obj_tracked_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -372,7 +372,7 @@ void current_pose_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_p
     // image_obj_tracked &gt; current_pose
     if (get_time(&amp;(image_obj_tracked_ringbuf.front().header)) &gt;= get_time(&amp;(current_pose_ringbuf.front().header))) {
         current_pose_buf = current_pose_ringbuf.front();
-        boost::circular_buffer&lt;autoware_msgs::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::ImageObjTracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
         if (image_obj_tracked_ringbuf.size() == 1) {
             image_obj_tracked_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\range_fusion\sync_range_fusion.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\range_fusion\sync_range_fusion.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -1,7 +1,7 @@
 #include "ros/ros.h"
-#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/ImageObj.h"
 #include "autoware_msgs/PointsImage.h"
-#include "autoware_msgs/image_obj_ranged.h"
+#include "autoware_msgs/ImageObjRanged.h"
 #include "sync.hpp"
 
 int main(int argc, char **argv) {
@@ -13,7 +13,7 @@ int main(int argc, char **argv) {
     std::string pub1("/image_obj");
     std::string pub2("/vscan_image");
 
-    Synchronizer&lt;autoware_msgs::image_obj, autoware_msgs::PointsImage, autoware_msgs::image_obj_ranged&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
+    Synchronizer&lt;autoware_msgs::ImageObj, autoware_msgs::PointsImage, autoware_msgs::ImageObjRanged&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
     synchronizer.run();
 
     return 0;
@@ -39,9 +39,9 @@ int main(int argc, char **argv) {
 #include &lt;pthread.h&gt;
 #include "t_sync_message.h"
 /* user header */
-#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/ImageObj.h"
 #include "autoware_msgs/PointsImage.h"
-#include "autoware_msgs/image_obj_ranged.h"
+#include "autoware_msgs/ImageObjRanged.h"
 
 /* ----mode---- */
 #define _REQ_PUB 1
@@ -51,7 +51,7 @@ int main(int argc, char **argv) {
 bool buf_flag;
 pthread_mutex_t mutex;
 /* user var */
-boost::circular_buffer&lt;autoware_msgs::image_obj&gt; image_obj_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::ImageObj&gt; image_obj_ringbuf(10);
 boost::circular_buffer&lt;autoware_msgs::PointsImage&gt; vscan_image_ringbuf(10);
 ros::Publisher image_obj__pub;
 ros::Publisher vscan_image__pub;
@@ -71,10 +71,10 @@ double get_time(const std_msgs::Header *timespec) {
 
 
 #if _REQ_PUB
-autoware_msgs::image_obj* p_image_obj_buf;
+autoware_msgs::ImageObj* p_image_obj_buf;
 autoware_msgs::PointsImage* p_vscan_image_buf;
 
-void publish_msg(autoware_msgs::image_obj* p_image_obj_buf, autoware_msgs::PointsImage* p_vscan_image_buf) {
+void publish_msg(autoware_msgs::ImageObj* p_image_obj_buf, autoware_msgs::PointsImage* p_vscan_image_buf) {
     ROS_INFO("publish");
     image_obj__pub.publish(*p_image_obj_buf);
     vscan_image__pub.publish(*p_vscan_image_buf);
@@ -97,7 +97,7 @@ bool publish() {
         // image_obj &gt; vscan_image
         if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
             p_vscan_image_buf = &amp;(vscan_image_ringbuf.front());
-            boost::circular_buffer&lt;autoware_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::ImageObj&gt;::iterator it = image_obj_ringbuf.begin();
             if (image_obj_ringbuf.size() == 1) {
                 p_image_obj_buf = &amp;*it;
                 publish_msg(p_image_obj_buf, p_vscan_image_buf);
@@ -163,7 +163,7 @@ bool publish() {
     }
 }
 
-void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
+void image_obj_callback(const autoware_msgs::ImageObj::ConstPtr&amp; image_obj_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ringbuf.push_front(*image_obj_msg);
     //vscan_image is empty
@@ -203,7 +203,7 @@ void vscan_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; vscan_imag
 #else
 #endif
 
-void image_obj_ranged_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
+void image_obj_ranged_callback(const autoware_msgs::ImageObjRanged::ConstPtr&amp; image_obj_ranged_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ranged_flag = true;
     ROS_INFO("catch publish request");
@@ -252,7 +252,7 @@ int main(int argc, char **argv) {
 
     ros::Subscriber image_obj_sub = nh.subscribe("/image_obj", 1, image_obj_callback);
     ros::Subscriber vscan_image_sub = nh.subscribe("/vscan_image", 1, vscan_image_callback);
-    image_obj__pub = nh.advertise&lt;autoware_msgs::image_obj&gt;("/sync_ranging/image_obj", 5);
+    image_obj__pub = nh.advertise&lt;autoware_msgs::ImageObj&gt;("/sync_ranging/image_obj", 5);
     vscan_image__pub = nh.advertise&lt;autoware_msgs::PointsImage&gt;("/sync_ranging/vscan_image", 5);
 
     while ((!buf_flag) &amp;&amp; ros::ok()) {
@@ -284,10 +284,10 @@ int main(int argc, char **argv) {
 
 
 #if 0
-autoware_msgs::image_obj image_obj_buf;
+autoware_msgs::ImageObj image_obj_buf;
 autoware_msgs::PointsImage vscan_image_buf;
 
-void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
+void image_obj_callback(const autoware_msgs::ImageObj::ConstPtr&amp; image_obj_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ringbuf.push_front(*image_obj_msg);
 
@@ -303,7 +303,7 @@ void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg)
     // image_obj &gt; vscan_image
     if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
         vscan_image_buf = vscan_image_ringbuf.front();
-        boost::circular_buffer&lt;autoware_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::ImageObj&gt;::iterator it = image_obj_ringbuf.begin();
         if (image_obj_ringbuf.size() == 1) {
             image_obj_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -360,7 +360,7 @@ void vscan_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; vscan_imag
     // image_obj &gt; vscan_image
     if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
         vscan_image_buf = vscan_image_ringbuf.front();
-        boost::circular_buffer&lt;autoware_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::ImageObj&gt;::iterator it = image_obj_ringbuf.begin();
         if (image_obj_ringbuf.size() == 1) {
             image_obj_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\car_dpm_sync.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\car_dpm_sync.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -19,7 +19,7 @@
 /* user header */
 #include "sensor_msgs/Image.h"
 #include "sensor_msgs/PointCloud2.h"
-#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/ImageObj.h"
 #include "autoware_msgs/PointsImage.h"
 
 /* ----mode---- */
@@ -296,7 +296,7 @@ bool publish() {
 }
 #endif
 
-void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
+void image_obj_callback(const autoware_msgs::ImageObj::ConstPtr&amp; image_obj_msg) {
     if (image_obj_flag) {
         image_obj_flag = false;
         points_image_flag = false;
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\copy.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\copy.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -4,7 +4,7 @@
 /* user header */
 #include "sensor_msgs/Image.h"
 #include "sensor_msgs/PointCloud2.h"
-#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/ImageObj.h"
 #include "autoware_msgs/PointsImage.h"
 
 /* ----mode---- */
@@ -283,7 +283,7 @@ bool publish() {
 }
 #endif
 
-void obj_person__image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
+void obj_person__image_obj_callback(const autoware_msgs::ImageObj::ConstPtr&amp; image_obj_msg) {
     if (obj_person__image_obj_flag) {
         obj_person__image_obj_flag = false;
         obj_car__image_obj_flag = false;
@@ -310,7 +310,7 @@ void obj_person__image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; im
     }
 }
 
-void obj_car__image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
+void obj_car__image_obj_callback(const autoware_msgs::ImageObj::ConstPtr&amp; image_obj_msg) {
     if (obj_car__image_obj_flag) {
         obj_person__image_obj_flag = false;
         obj_car__image_obj_flag = false;
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\dpm_sync_2.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\dpm_sync_2.cpp" added_lines="13" deleted_lines="13">
				<diff>@@ -17,9 +17,9 @@
 #include &lt;pthread.h&gt;
 #include "t_sync_message.h"
 /* user header */
-#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/ImageObj.h"
 #include "autoware_msgs/PointsImage.h"
-#include "autoware_msgs/image_obj_ranged.h"
+#include "autoware_msgs/ImageObjRanged.h"
 
 /* ----mode---- */
 #define _REQ_PUB 1
@@ -30,7 +30,7 @@ bool buf_flag;
 pthread_mutex_t mutex;
 pthread_mutex_t flag_mutex;
 /* user var */
-boost::circular_buffer&lt;autoware_msgs::image_obj&gt; image_obj_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::ImageObj&gt; image_obj_ringbuf(10);
 boost::circular_buffer&lt;autoware_msgs::PointsImage&gt; vscan_image_ringbuf(10);
 ros::Publisher image_obj__pub;
 ros::Publisher vscan_image__pub;
@@ -50,10 +50,10 @@ double get_time(const std_msgs::Header *timespec) {
 
 
 #if _REQ_PUB
-autoware_msgs::image_obj* p_image_obj_buf;
+autoware_msgs::ImageObj* p_image_obj_buf;
 autoware_msgs::PointsImage* p_vscan_image_buf;
 
-void publish_msg(autoware_msgs::image_obj* p_image_obj_buf, autoware_msgs::PointsImage* p_vscan_image_buf) {
+void publish_msg(autoware_msgs::ImageObj* p_image_obj_buf, autoware_msgs::PointsImage* p_vscan_image_buf) {
     ROS_INFO("publish");
     image_obj__pub.publish(*p_image_obj_buf);
     vscan_image__pub.publish(*p_vscan_image_buf);
@@ -80,7 +80,7 @@ bool publish() {
         // image_obj &gt; vscan_image
         if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
             p_vscan_image_buf = &amp;(vscan_image_ringbuf.front());
-            boost::circular_buffer&lt;autoware_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::ImageObj&gt;::iterator it = image_obj_ringbuf.begin();
             if (image_obj_ringbuf.size() == 1) {
                 p_image_obj_buf = &amp;*it;
                 publish_msg(p_image_obj_buf, p_vscan_image_buf);
@@ -136,7 +136,7 @@ bool publish() {
     }
 }
 
-void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
+void image_obj_callback(const autoware_msgs::ImageObj::ConstPtr&amp; image_obj_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ringbuf.push_front(*image_obj_msg);
     //vscan_image is empty
@@ -172,7 +172,7 @@ void vscan_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; vscan_imag
 #else
 #endif
 
-void image_obj_ranged_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
+void image_obj_ranged_callback(const autoware_msgs::ImageObjRanged::ConstPtr&amp; image_obj_ranged_msg) {
     image_obj_ranged_flag= true;
     ROS_INFO("catch publish request");
     if (publish() == false) {
@@ -222,7 +222,7 @@ int main(int argc, char **argv) {
 
     ros::Subscriber image_obj_sub = nh.subscribe("obj_car/image_obj", 1, image_obj_callback);
     ros::Subscriber vscan_image_sub = nh.subscribe("vscan_image", 1, vscan_image_callback);
-    image_obj__pub = nh.advertise&lt;autoware_msgs::image_obj&gt;("obj_car/image_obj_", 5);
+    image_obj__pub = nh.advertise&lt;autoware_msgs::ImageObj&gt;("obj_car/image_obj_", 5);
     vscan_image__pub = nh.advertise&lt;autoware_msgs::PointsImage&gt;("vscan_image_", 5);
 
     pthread_mutex_lock(&amp;flag_mutex);
@@ -253,10 +253,10 @@ int main(int argc, char **argv) {
 
 
 #if 0
-autoware_msgs::image_obj image_obj_buf;
+autoware_msgs::ImageObj image_obj_buf;
 autoware_msgs::PointsImage vscan_image_buf;
 
-void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
+void image_obj_callback(const autoware_msgs::ImageObj::ConstPtr&amp; image_obj_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ringbuf.push_front(*image_obj_msg);
 
@@ -272,7 +272,7 @@ void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg)
     // image_obj &gt; vscan_image
     if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
         vscan_image_buf = vscan_image_ringbuf.front();
-        boost::circular_buffer&lt;autoware_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::ImageObj&gt;::iterator it = image_obj_ringbuf.begin();
         if (image_obj_ringbuf.size() == 1) {
             image_obj_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -329,7 +329,7 @@ void vscan_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; vscan_imag
     // image_obj &gt; vscan_image
     if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
         vscan_image_buf = vscan_image_ringbuf.front();
-        boost::circular_buffer&lt;autoware_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::ImageObj&gt;::iterator it = image_obj_ringbuf.begin();
         if (image_obj_ringbuf.size() == 1) {
             image_obj_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\sync_car_dpm.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\sync_car_dpm.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -19,7 +19,7 @@
 /* user header */
 #include "sensor_msgs/Image.h"
 #include "sensor_msgs/PointCloud2.h"
-#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/ImageObj.h"
 #include "autoware_msgs/PointsImage.h"
 
 /* ----mode---- */
@@ -296,7 +296,7 @@ bool publish() {
 }
 #endif
 
-void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
+void image_obj_callback(const autoware_msgs::ImageObj::ConstPtr&amp; image_obj_msg) {
     if (image_obj_flag) {
         image_obj_flag = false;
         points_image_flag = false;
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\sync_obj_fusion.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\sync_obj_fusion.cpp" added_lines="24" deleted_lines="24">
				<diff>@@ -1,6 +1,6 @@
 #include "ros/ros.h"
-#include "autoware_msgs/obj_label.h"
-#include "autoware_msgs/centroids.h"
+#include "autoware_msgs/ObjLabel.h"
+#include "autoware_msgs/Centroids.h"
 #include "visualization_msgs/MarkerArray.h"
 #include "sync.hpp"
 
@@ -13,7 +13,7 @@ int main(int argc, char **argv) {
     std::string pub1("/obj_label");
     std::string pub2("/cluster_centroids");
 
-    Synchronizer&lt;autoware_msgs::obj_label, autoware_msgs::centroids, visualization_msgs::MarkerArray&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
+    Synchronizer&lt;autoware_msgs::ObjLabel, autoware_msgs::Centroids, visualization_msgs::MarkerArray&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
     synchronizer.run();
 
     return 0;
@@ -39,8 +39,8 @@ int main(int argc, char **argv) {
 #include &lt;pthread.h&gt;
 #include "t_sync_message.h"
 /* user header */
-#include "autoware_msgs/obj_label.h"
-#include "autoware_msgs/centroids.h"
+#include "autoware_msgs/ObjLabel.h"
+#include "autoware_msgs/Centroids.h"
 #include "visualization_msgs/MarkerArray.h"
 
 /* ----mode---- */
@@ -51,8 +51,8 @@ int main(int argc, char **argv) {
 bool buf_flag;
 pthread_mutex_t mutex;
 /* user var */
-boost::circular_buffer&lt;autoware_msgs::obj_label&gt; obj_label_ringbuf(10);
-boost::circular_buffer&lt;autoware_msgs::centroids&gt; cluster_centroids_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::ObjLabel&gt; obj_label_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::Centroids&gt; cluster_centroids_ringbuf(10);
 ros::Publisher obj_label__pub;
 ros::Publisher cluster_centroids__pub;
 bool obj_pose_flag;
@@ -71,10 +71,10 @@ double get_time(const std_msgs::Header *timespec) {
 
 
 #if _REQ_PUB
-autoware_msgs::obj_label* p_obj_label_buf;
-autoware_msgs::centroids* p_cluster_centroids_buf;
+autoware_msgs::ObjLabel* p_obj_label_buf;
+autoware_msgs::Centroids* p_cluster_centroids_buf;
 
-void publish_msg(autoware_msgs::obj_label* p_obj_label_buf, autoware_msgs::centroids* p_cluster_centroids_buf)
+void publish_msg(autoware_msgs::ObjLabel* p_obj_label_buf, autoware_msgs::Centroids* p_cluster_centroids_buf)
 {
     ROS_INFO("publish");
     obj_label__pub.publish(*p_obj_label_buf);
@@ -98,7 +98,7 @@ bool publish() {
         // obj_label &gt; cluster_centroids
         if (get_time(&amp;(obj_label_ringbuf.front().header)) &gt;= get_time(&amp;(cluster_centroids_ringbuf.front().header))) {
             p_cluster_centroids_buf = &amp;(cluster_centroids_ringbuf.front());
-            boost::circular_buffer&lt;autoware_msgs::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::ObjLabel&gt;::iterator it = obj_label_ringbuf.begin();
             if (obj_label_ringbuf.size() == 1) {
                 p_obj_label_buf = &amp;*it;
                 publish_msg(p_obj_label_buf, p_cluster_centroids_buf);
@@ -125,7 +125,7 @@ bool publish() {
         // obj_label &lt; cluster_centroids
         else {
             p_obj_label_buf = &amp;(obj_label_ringbuf.front());
-            boost::circular_buffer&lt;autoware_msgs::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::Centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
             if (cluster_centroids_ringbuf.size() == 1) {
                 p_cluster_centroids_buf = &amp;*it;
                 publish_msg(p_obj_label_buf, p_cluster_centroids_buf);
@@ -163,7 +163,7 @@ bool publish() {
     }
 }
 
-void obj_label_callback(const autoware_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
+void obj_label_callback(const autoware_msgs::ObjLabel::ConstPtr&amp; obj_label_msg) {
     pthread_mutex_lock(&amp;mutex);
     obj_label_ringbuf.push_front(*obj_label_msg);
     //cluster_centroids is empty
@@ -182,7 +182,7 @@ void obj_label_callback(const autoware_msgs::obj_label::ConstPtr&amp; obj_label_msg)
     pthread_mutex_unlock(&amp;mutex);
 }
 
-void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluster_centroids_msg) {
+void cluster_centroids_callback(const autoware_msgs::Centroids::ConstPtr&amp; cluster_centroids_msg) {
     pthread_mutex_lock(&amp;mutex);
     cluster_centroids_ringbuf.push_front(*cluster_centroids_msg);
     //obj_label is empty
@@ -203,8 +203,8 @@ void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluste
 }
 
 #else
-autoware_msgs::obj_label obj_label_buf;
-autoware_msgs::centroids cluster_centroids_buf;
+autoware_msgs::ObjLabel obj_label_buf;
+autoware_msgs::Centroids cluster_centroids_buf;
 
 bool publish() {
     if (buf_flag) {
@@ -224,7 +224,7 @@ bool publish() {
     }
 }
 
-void obj_label_callback(const autoware_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
+void obj_label_callback(const autoware_msgs::ObjLabel::ConstPtr&amp; obj_label_msg) {
     pthread_mutex_lock(&amp;mutex);
     obj_label_ringbuf.push_front(*obj_label_msg);
 
@@ -240,7 +240,7 @@ void obj_label_callback(const autoware_msgs::obj_label::ConstPtr&amp; obj_label_msg)
     // obj_label &gt; cluster_centroids
     if (get_time(&amp;(obj_label_ringbuf.front().header)) &gt;= get_time(&amp;(cluster_centroids_ringbuf.front().header))) {
         cluster_centroids_buf = cluster_centroids_ringbuf.front();
-        boost::circular_buffer&lt;autoware_msgs::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::ObjLabel&gt;::iterator it = obj_label_ringbuf.begin();
         if (obj_label_ringbuf.size() == 1) {
             obj_label_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -265,7 +265,7 @@ void obj_label_callback(const autoware_msgs::obj_label::ConstPtr&amp; obj_label_msg)
 
     } else {
         obj_label_buf = obj_label_ringbuf.front();
-        boost::circular_buffer&lt;autoware_msgs::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::Centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
         if (cluster_centroids_ringbuf.size() == 1) {
             cluster_centroids_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -292,7 +292,7 @@ void obj_label_callback(const autoware_msgs::obj_label::ConstPtr&amp; obj_label_msg)
     pthread_mutex_unlock(&amp;mutex);
 }
 
-void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluster_centroids_msg) {
+void cluster_centroids_callback(const autoware_msgs::Centroids::ConstPtr&amp; cluster_centroids_msg) {
     pthread_mutex_lock(&amp;mutex);
     cluster_centroids_ringbuf.push_front(*cluster_centroids_msg);
     //obj_label is empty
@@ -307,7 +307,7 @@ void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluste
     // obj_label &gt; cluster_centroids
     if (get_time(&amp;(obj_label_ringbuf.front().header)) &gt;= get_time(&amp;(cluster_centroids_ringbuf.front().header))) {
         cluster_centroids_buf = cluster_centroids_ringbuf.front();
-        boost::circular_buffer&lt;autoware_msgs::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::ObjLabel&gt;::iterator it = obj_label_ringbuf.begin();
         if (obj_label_ringbuf.size() == 1) {
             obj_label_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -332,7 +332,7 @@ void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluste
 
     } else {
         obj_label_buf = obj_label_ringbuf.front();
-        boost::circular_buffer&lt;autoware_msgs::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::Centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
         if (cluster_centroids_ringbuf.size() == 1) {
             cluster_centroids_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -409,8 +409,8 @@ int main(int argc, char **argv) {
 
     ros::Subscriber obj_label_sub = nh.subscribe("/obj_label", 1, obj_label_callback);
     ros::Subscriber cluster_centroids_sub = nh.subscribe("/cluster_centroids", 1, cluster_centroids_callback);
-    obj_label__pub = nh.advertise&lt;autoware_msgs::obj_label&gt;("/sync_obj_fusion/obj_label", 5);
-    cluster_centroids__pub = nh.advertise&lt;autoware_msgs::centroids&gt;("/sync_obj_fusion/cluster_centroids", 5);
+    obj_label__pub = nh.advertise&lt;autoware_msgs::ObjLabel&gt;("/sync_obj_fusion/obj_label", 5);
+    cluster_centroids__pub = nh.advertise&lt;autoware_msgs::Centroids&gt;("/sync_obj_fusion/cluster_centroids", 5);
     while (!buf_flag &amp;&amp; ros::ok()) {
         ros::spinOnce();
         usleep(100000);
</diff>
			</file>
			<file old_path="ros\src\system\sync\sync_drivers.cpp" new_path="ros\src\system\sync\sync_drivers.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -36,7 +36,7 @@
 /* user header */
 #include "sensor_msgs/Image.h"
 #include "sensor_msgs/PointCloud2.h"
-#include "autoware_msgs/Sync_time_diff.h"
+#include "autoware_msgs/SyncTimeDiff.h"
 
 /* ----var---- */
 /* common var */
@@ -62,7 +62,7 @@ void image_raw_callback(sensor_msgs::Image image_raw_msg)
 
 void points_raw_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; points_raw_msg)
 {
-    autoware_msgs::Sync_time_diff time_diff_msg;
+    autoware_msgs::SyncTimeDiff time_diff_msg;
     time_diff_msg.header.frame_id = "0";
     time_diff_msg.header.stamp = points_raw_msg-&gt;header.stamp;
     time_diff_msg.time_diff = fabs_time_diff(&amp;(points_raw_msg-&gt;header), &amp;image_raw_buf.header)*1000.0; //msec
@@ -89,7 +89,7 @@ int main(int argc, char **argv)
 
   image_raw__pub = nh.advertise&lt;sensor_msgs::Image&gt;("image_raw", 1);
   points_raw__pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;("points_raw", 1);
-  time_diff_pub = nh.advertise&lt;autoware_msgs::Sync_time_diff&gt;("/time_difference", 1);
+  time_diff_pub = nh.advertise&lt;autoware_msgs::SyncTimeDiff&gt;("/time_difference", 1);
 
   ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\system\sync\test.cpp" new_path="ros\src\system\sync\test.cpp" added_lines="11" deleted_lines="11">
				<diff>@@ -18,7 +18,7 @@
 #include "t_sync_message.h"
 /* user header */
 #include "cv_tracker/obj_label.h"
-#include "autoware_msgs/centroids.h"
+#include "autoware_msgs/Centroids.h"
 #include "visualization_msgs/MarkerArray.h"
 
 /* ----mode---- */
@@ -30,7 +30,7 @@ bool buf_flag;
 pthread_mutex_t mutex;
 /* user var */
 boost::circular_buffer&lt;cv_tracker::obj_label&gt; obj_label_ringbuf(10);
-boost::circular_buffer&lt;autoware_msgs::centroids&gt; cluster_centroids_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::Centroids&gt; cluster_centroids_ringbuf(10);
 ros::Publisher obj_label__pub;
 ros::Publisher cluster_centroids__pub;
 bool obj_pose_flag;
@@ -50,9 +50,9 @@ double get_time(const std_msgs::Header *timespec) {
 
 #if _REQ_PUB
 cv_tracker::obj_label* p_obj_label_buf;
-autoware_msgs::centroids* p_cluster_centroids_buf;
+autoware_msgs::Centroids* p_cluster_centroids_buf;
 
-void publish_msg(cv_tracker::obj_label* p_obj_label_buf, autoware_msgs::centroids* p_cluster_centroids_buf)
+void publish_msg(cv_tracker::obj_label* p_obj_label_buf, autoware_msgs::Centroids* p_cluster_centroids_buf)
 {
     ROS_INFO("publish");
     obj_label__pub.publish(*p_obj_label_buf);
@@ -103,7 +103,7 @@ bool publish() {
         // obj_label &lt; cluster_centroids
         else {
             p_obj_label_buf = &amp;(obj_label_ringbuf.front());
-            boost::circular_buffer&lt;autoware_msgs::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::Centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
             if (cluster_centroids_ringbuf.size() == 1) {
                 p_cluster_centroids_buf = &amp;*it;
                 publish_msg(p_obj_label_buf, p_cluster_centroids_buf);
@@ -159,7 +159,7 @@ void obj_label_callback(const cv_tracker::obj_label::ConstPtr&amp; obj_label_msg) {
     pthread_mutex_unlock(&amp;mutex);
 }
 
-void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluster_centroids_msg) {
+void cluster_centroids_callback(const autoware_msgs::Centroids::ConstPtr&amp; cluster_centroids_msg) {
     pthread_mutex_lock(&amp;mutex);
     cluster_centroids_ringbuf.push_front(*cluster_centroids_msg);
     //obj_label is empty
@@ -180,7 +180,7 @@ void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluste
 
 #else
 cv_tracker::obj_label obj_label_buf;
-autoware_msgs::centroids cluster_centroids_buf;
+autoware_msgs::Centroids cluster_centroids_buf;
 
 bool publish() {
     if (buf_flag) {
@@ -241,7 +241,7 @@ void obj_label_callback(const cv_tracker::obj_label::ConstPtr&amp; obj_label_msg) {
 
     } else {
         obj_label_buf = obj_label_ringbuf.front();
-        boost::circular_buffer&lt;autoware_msgs::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::Centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
         if (cluster_centroids_ringbuf.size() == 1) {
             cluster_centroids_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -268,7 +268,7 @@ void obj_label_callback(const cv_tracker::obj_label::ConstPtr&amp; obj_label_msg) {
     pthread_mutex_unlock(&amp;mutex);
 }
 
-void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluster_centroids_msg) {
+void cluster_centroids_callback(const autoware_msgs::Centroids::ConstPtr&amp; cluster_centroids_msg) {
     pthread_mutex_lock(&amp;mutex);
     cluster_centroids_ringbuf.push_front(*cluster_centroids_msg);
     //obj_label is empty
@@ -308,7 +308,7 @@ void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluste
 
     } else {
         obj_label_buf = obj_label_ringbuf.front();
-        boost::circular_buffer&lt;autoware_msgs::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::Centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
         if (cluster_centroids_ringbuf.size() == 1) {
             cluster_centroids_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -383,7 +383,7 @@ int main(int argc, char **argv) {
     ros::Subscriber obj_label_sub = nh.subscribe("/obj_car/obj_label", 1, obj_label_callback);
     ros::Subscriber cluster_centroids_sub = nh.subscribe("/cluster_centroids", 1, cluster_centroids_callback);
     obj_label__pub = nh.advertise&lt;cv_tracker::obj_label&gt;("/obj_car/obj_label_", 5);
-    cluster_centroids__pub = nh.advertise&lt;autoware_msgs::centroids&gt;("/cluster_centroids_", 5);
+    cluster_centroids__pub = nh.advertise&lt;autoware_msgs::Centroids&gt;("/cluster_centroids_", 5);
     while (!buf_flag) {
         ros::spinOnce();
         usleep(100000);
</diff>
			</file>
			<file old_path="ros\src\system\sync\time_monitor.cpp" new_path="ros\src\system\sync\time_monitor.cpp" added_lines="29" deleted_lines="29">
				<diff>@@ -40,14 +40,14 @@
 #include "geometry_msgs/PoseStamped.h"
 #include "visualization_msgs/MarkerArray.h"
 
-#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/ImageObj.h"
 #include "autoware_msgs/PointsImage.h"
-#include "autoware_msgs/image_obj_ranged.h"
-#include "autoware_msgs/image_obj_tracked.h"
-#include "autoware_msgs/obj_label.h"
-#include "autoware_msgs/centroids.h"
-#include "autoware_msgs/Sync_time_monitor.h"
-#include "autoware_msgs/Sync_time_diff.h"
+#include "autoware_msgs/ImageObjRanged.h"
+#include "autoware_msgs/ImageObjTracked.h"
+#include "autoware_msgs/ObjLabel.h"
+#include "autoware_msgs/Centroids.h"
+#include "autoware_msgs/SyncTimeMonitor.h"
+#include "autoware_msgs/SyncTimeDiff.h"
 
 /* ----var---- */
 /* common var */
@@ -182,21 +182,21 @@ public:
     void points_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; points_image_msg);
     void vscan_points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; vscan_points_msg);
     void vscan_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; vscan_image_msg);
-    void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg);
-    void image_obj_ranged_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg);
-    void image_obj_tracked_callback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg);
+    void image_obj_callback(const autoware_msgs::ImageObj::ConstPtr&amp; image_obj_msg);
+    void image_obj_ranged_callback(const autoware_msgs::ImageObjRanged::ConstPtr&amp; image_obj_ranged_msg);
+    void image_obj_tracked_callback(const autoware_msgs::ImageObjTracked::ConstPtr&amp; image_obj_tracked_msg);
     void current_pose_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg);
-    void obj_label_callback(const autoware_msgs::obj_label::ConstPtr&amp; obj_label_msg) ;
-    void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluster_centroids_msg);
+    void obj_label_callback(const autoware_msgs::ObjLabel::ConstPtr&amp; obj_label_msg) ;
+    void cluster_centroids_callback(const autoware_msgs::Centroids::ConstPtr&amp; cluster_centroids_msg);
 //    void obj_pose_callback(const visualization_msgs::MarkerArray::ConstPtr&amp; obj_pose_msg);
     void obj_pose_callback(const std_msgs::Time::ConstPtr&amp; obj_pose_timestamp_msg);
     // sync
-    void sync_image_obj_ranged_callback(const autoware_msgs::image_obj::ConstPtr&amp; sync_image_obj_msg);
-    void sync_image_obj_tracked_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; sync_image_obj_ranged_msg);
-    void sync_obj_label_callback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; sync_image_obj_tracked_msg);
-    void sync_obj_pose_callback(const autoware_msgs::obj_label::ConstPtr&amp; sync_obj_label_msg);
+    void sync_image_obj_ranged_callback(const autoware_msgs::ImageObj::ConstPtr&amp; sync_image_obj_msg);
+    void sync_image_obj_tracked_callback(const autoware_msgs::ImageObjRanged::ConstPtr&amp; sync_image_obj_ranged_msg);
+    void sync_obj_label_callback(const autoware_msgs::ImageObjTracked::ConstPtr&amp; sync_image_obj_tracked_msg);
+    void sync_obj_pose_callback(const autoware_msgs::ObjLabel::ConstPtr&amp; sync_obj_label_msg);
     // time difference
-    void time_diff_callback(const autoware_msgs::Sync_time_diff::ConstPtr&amp; time_diff_msg);
+    void time_diff_callback(const autoware_msgs::SyncTimeDiff::ConstPtr&amp; time_diff_msg);
     void run();
 };
 
@@ -211,7 +211,7 @@ TimeManager::TimeManager(int buffer_size) {
         is_vscan_image_ = false;
     }
 
-    time_monitor_pub = nh.advertise&lt;autoware_msgs::Sync_time_monitor&gt; ("/times", 10);
+    time_monitor_pub = nh.advertise&lt;autoware_msgs::SyncTimeMonitor&gt; ("/times", 10);
     image_raw_sub = nh.subscribe("/sync_drivers/image_raw", 10, &amp;TimeManager::image_raw_callback, this);
     points_raw_sub = nh.subscribe("/sync_drivers/points_raw", 10, &amp;TimeManager::points_raw_callback, this);
     points_image_sub = nh.subscribe("/points_image", 10, &amp;TimeManager::points_image_callback, this);
@@ -277,17 +277,17 @@ void TimeManager::vscan_image_callback(const autoware_msgs::PointsImage::ConstPt
     vscan_image_.push_front(vscan_image_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
+void TimeManager::image_obj_callback(const autoware_msgs::ImageObj::ConstPtr&amp; image_obj_msg) {
 //    ROS_INFO("image_obj: \t\t\t%d.%d", image_obj_msg-&gt;header.stamp.sec, image_obj_msg-&gt;header.stamp.nsec);
     image_obj_.push_front(image_obj_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::image_obj_ranged_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
+void TimeManager::image_obj_ranged_callback(const autoware_msgs::ImageObjRanged::ConstPtr&amp; image_obj_ranged_msg) {
 //    ROS_INFO("image_obj_ranged: \t\t%d.%d", image_obj_ranged_msg-&gt;header.stamp.sec, image_obj_ranged_msg-&gt;header.stamp.nsec);
     image_obj_ranged_.push_front(image_obj_ranged_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::image_obj_tracked_callback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
+void TimeManager::image_obj_tracked_callback(const autoware_msgs::ImageObjTracked::ConstPtr&amp; image_obj_tracked_msg) {
 //    ROS_INFO("image_obj_tracked: \t\t%d.%d", image_obj_tracked_msg-&gt;header.stamp.sec, image_obj_tracked_msg-&gt;header.stamp.nsec);
     image_obj_tracked_.push_front(image_obj_tracked_msg-&gt;header.stamp, get_walltime_now());
 }
@@ -297,39 +297,39 @@ void TimeManager::current_pose_callback(const geometry_msgs::PoseStamped::ConstP
     current_pose_.push_front(current_pose_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::obj_label_callback(const autoware_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
+void TimeManager::obj_label_callback(const autoware_msgs::ObjLabel::ConstPtr&amp; obj_label_msg) {
 //    ROS_INFO("obj_label: \t\t\t%d.%d", obj_label_msg-&gt;header.stamp.sec, obj_label_msg-&gt;header.stamp.nsec);
     obj_label_.push_front(obj_label_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluster_centroids_msg) {
+void TimeManager::cluster_centroids_callback(const autoware_msgs::Centroids::ConstPtr&amp; cluster_centroids_msg) {
 //    ROS_INFO("cluster_centroids: \t\t%d.%d", cluster_centroids_msg-&gt;header.stamp.sec, cluster_centroids_msg-&gt;header.stamp.nsec);
     cluster_centroids_.push_front(cluster_centroids_msg-&gt;header.stamp, get_walltime_now());
 }
 
 /* sync */
-void TimeManager::sync_image_obj_ranged_callback(const autoware_msgs::image_obj::ConstPtr&amp; sync_image_obj_msg) {
+void TimeManager::sync_image_obj_ranged_callback(const autoware_msgs::ImageObj::ConstPtr&amp; sync_image_obj_msg) {
 //    ROS_INFO("sync_image_obj_ranged: \t\t%d.%d", sync_image_obj_msg-&gt;header.stamp.sec, sync_image_obj_msg-&gt;header.stamp.nsec);
     sync_image_obj_ranged_.push_front(sync_image_obj_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::sync_image_obj_tracked_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; sync_image_obj_ranged_msg) {
+void TimeManager::sync_image_obj_tracked_callback(const autoware_msgs::ImageObjRanged::ConstPtr&amp; sync_image_obj_ranged_msg) {
 //    ROS_INFO("sync_image_obj_tracked: \t%d.%d", sync_image_obj_ranged_msg-&gt;header.stamp.sec, sync_image_obj_ranged_msg-&gt;header.stamp.nsec);
     sync_image_obj_tracked_.push_front(sync_image_obj_ranged_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::sync_obj_label_callback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; sync_image_obj_tracked_msg) {
+void TimeManager::sync_obj_label_callback(const autoware_msgs::ImageObjTracked::ConstPtr&amp; sync_image_obj_tracked_msg) {
 //    ROS_INFO("sync_obj_label: \t\t%d.%d", sync_image_obj_tracked_msg-&gt;header.stamp.sec, sync_image_obj_tracked_msg-&gt;header.stamp.nsec);
     sync_obj_label_.push_front(sync_image_obj_tracked_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::sync_obj_pose_callback(const autoware_msgs::obj_label::ConstPtr&amp; sync_obj_label_msg) {
+void TimeManager::sync_obj_pose_callback(const autoware_msgs::ObjLabel::ConstPtr&amp; sync_obj_label_msg) {
 //    ROS_INFO("sync_obj_pose: \t\t\t%d.%d", sync_obj_label_msg-&gt;header.stamp.sec, sync_obj_label_msg-&gt;header.stamp.nsec);
     sync_obj_pose_.push_front(sync_obj_label_msg-&gt;header.stamp, get_walltime_now());
 }
 
 /* time difference */
-void TimeManager::time_diff_callback(const autoware_msgs::Sync_time_diff::ConstPtr&amp; time_diff_msg) {
+void TimeManager::time_diff_callback(const autoware_msgs::SyncTimeDiff::ConstPtr&amp; time_diff_msg) {
     ros::Time sensors_time_diff;
     double lidar = (double)time_diff_msg-&gt;lidar.sec + (double)time_diff_msg-&gt;lidar.nsec/1000000000.0L;
     double camera = (double)time_diff_msg-&gt;camera.sec + (double)time_diff_msg-&gt;camera.nsec/1000000000.0L;
@@ -369,7 +369,7 @@ void TimeManager::obj_pose_callback(const std_msgs::Time::ConstPtr&amp; obj_pose_tim
     obj_pose_.push_front(obj_pose_timestamp_msg-&gt;data, get_walltime_now());
     static ros::Time pre_sensor_time;
 
-    autoware_msgs::Sync_time_monitor time_monitor_msg;
+    autoware_msgs::SyncTimeMonitor time_monitor_msg;
     time_monitor_msg.header.frame_id = "0";
     time_monitor_msg.header.stamp = ros::Time::now();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="45206ae0b72c5416c0f2bbddc0c6a77d388a8bd4" author="Kosuke Murakami">
		<msg>[Feature] Prediction package template (naive_motion_predictor) (#1616)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\imm_ukf_pda.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\imm_ukf_pda.h" added_lines="1" deleted_lines="0">
				<diff>@@ -126,6 +126,7 @@ private:
   void mergeOverSegmentation(const std::vector&lt;UKF&gt; targets);
 
   void updateJskLabel(const UKF&amp; target, jsk_recognition_msgs::BoundingBox&amp; bb);
+  void updateBehaviorState(const UKF&amp; target, autoware_msgs::DetectedObject&amp; object);
 
   void initTracker(const autoware_msgs::DetectedObjectArray&amp; input, double timestamp);
   void secondInit(UKF&amp; target, const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, double dt);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\ukf.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\ukf.h" added_lines="7" deleted_lines="0">
				<diff>@@ -52,6 +52,13 @@ enum TrackingState : int
   Lost = 10,   // About to lose target
 };
 
+enum MotionModel : int
+{
+  CV = 0,    // constant velocity
+  CTRV = 1,  // constant turn rate and velocity
+  RM = 2,    // random motion
+};
+
 class UKF
 {
   /*
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda.cpp" added_lines="19" deleted_lines="0">
				<diff>@@ -362,6 +362,22 @@ void ImmUkfPda::updateJskLabel(const UKF&amp; target, jsk_recognition_msgs::Bounding
   }
 }
 
+void ImmUkfPda::updateBehaviorState(const UKF&amp; target, autoware_msgs::DetectedObject&amp; object)
+{
+  if(target.mode_prob_cv_ &gt; target.mode_prob_ctrv_ &amp;&amp; target.mode_prob_cv_ &gt; target.mode_prob_rm_)
+  {
+    object.behavior_state = MotionModel::CV;
+  }
+  else if(target.mode_prob_ctrv_ &gt; target.mode_prob_cv_ &amp;&amp; target.mode_prob_ctrv_ &gt; target.mode_prob_rm_)
+  {
+    object.behavior_state = MotionModel::CTRV;
+  }
+  else
+  {
+    object.behavior_state = MotionModel::RM;
+  }
+}
+
 void ImmUkfPda::initTracker(const autoware_msgs::DetectedObjectArray&amp; input, double timestamp)
 {
   for (size_t i = 0; i &lt; input.objects.size(); i++)
@@ -607,6 +623,9 @@ void ImmUkfPda::makeOutput(const autoware_msgs::DetectedObjectArray&amp; input,
     dd.pose.orientation.w = q[3];
     dd.dimensions = targets_[i].jsk_bb_.dimensions;
     dd.pose_reliable = targets_[i].is_vis_bb_;
+    //store yaw rate for motion into dd.accerelation.linear.y
+    dd.acceleration.linear.y = targets_[i].x_merge_(4);
+    updateBehaviorState(targets_[i], dd);
     detected_objects_output.objects.push_back(dd);
   }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\ukf.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\ukf.cpp" added_lines="0" deleted_lines="7">
				<diff>@@ -30,13 +30,6 @@
 
 #include "ukf.h"
 
-enum MotionModel : int
-{
-  CV = 0,    // constant velocity
-  CTRV = 1,  // constant turn rate and velocity
-  RM = 2,    // random motion
-};
-
 /**
 * Initializes Unscented Kalman filter
 */
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8c8a1e0b206e1f8b01958b47c3f76ce91b717fd1" author="Abraham Monrroy Cano">
		<msg>[fix] Added option to publish to specific camera frame on camera publisher (#1565)

* * Added option to publish to specific camera frame on camera publisher
* fixes to the node

* Added New line to UI on each param.

* * Updates to launch files using calibration publisher

* Updated naming after develop merge

* Updated suscription type to topic for calibration publisher</msg>
		<modified_files>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_publisher\calibration_publisher.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_publisher\calibration_publisher.cpp" added_lines="36" deleted_lines="16">
				<diff>@@ -20,7 +20,8 @@ static bool isRegister_tf;
 static bool isPublish_extrinsic;
 static bool isPublish_cameraInfo;
 
-static std::string camera_id_str;
+static std::string camera_id_str_;
+static std::string camera_frame_;
 static std::string target_frame_;
 
 static bool instrinsics_parsed_;
@@ -50,7 +51,7 @@ void tfRegistration(const cv::Mat &amp;camExtMat, const ros::Time &amp;timeStamp)
 
 	transform.setRotation(quaternion);
 
-	broadcaster.sendTransform(tf::StampedTransform(transform, timeStamp, target_frame_, camera_id_str));
+	broadcaster.sendTransform(tf::StampedTransform(transform, timeStamp, target_frame_, camera_frame_));
 }
 
 void projectionMatrix_sender(const cv::Mat &amp;projMat, const ros::Time &amp;timeStamp)
@@ -67,7 +68,7 @@ void projectionMatrix_sender(const cv::Mat &amp;projMat, const ros::Time &amp;timeStamp)
 		extrinsics_parsed_ = true;
 	}
 	extrinsic_matrix_msg_.header.stamp = timeStamp;
-	extrinsic_matrix_msg_.header.frame_id = camera_id_str;
+	extrinsic_matrix_msg_.header.frame_id = camera_frame_;
 	projection_matrix_pub.publish(extrinsic_matrix_msg_);
 }
 
@@ -112,7 +113,7 @@ void cameraInfo_sender(const cv::Mat &amp;camMat, const cv::Mat &amp;distCoeff, const cv
 		instrinsics_parsed_ = true;
 	}
 	camera_info_msg_.header.stamp = timeStamp;
-	camera_info_msg_.header.frame_id = camera_id_str;
+	camera_info_msg_.header.frame_id = camera_frame_;
 
 
 	camera_info_pub.publish(camera_info_msg_);
@@ -148,6 +149,8 @@ int main(int argc, char *argv[])
 	ros::NodeHandle n;
 	ros::NodeHandle private_nh("~");
 
+	char __APP_NAME__[] = "calibration_publisher";
+
 	if (!private_nh.getParam("register_lidar2camera_tf", isRegister_tf))
 	{
 		isRegister_tf = true;
@@ -163,19 +166,28 @@ int main(int argc, char *argv[])
 		isPublish_cameraInfo = true; /* doesn't publish camera_info in default */
 	}
 
+
+	private_nh.param&lt;std::string&gt;("camera_frame", camera_frame_, "camera");
+	ROS_INFO("[%s] camera_frame: '%s'", __APP_NAME__, camera_frame_.c_str());
+
 	private_nh.param&lt;std::string&gt;("target_frame", target_frame_, "velodyne");
-	ROS_INFO("target_frame: %s", target_frame_.c_str());
+	ROS_INFO("[%s] target_frame: '%s'", __APP_NAME__, target_frame_.c_str());
 
-	if (argc &lt; 2)
+	std::string calibration_file;
+	private_nh.param&lt;std::string&gt;("calibration_file", calibration_file, "");
+	ROS_INFO("[%s] calibration_file: '%s'", __APP_NAME__, calibration_file.c_str());
+	if (calibration_file.empty())
 	{
-		std::cout &lt;&lt; "Usage: calibration_publisher &lt;calibration-file&gt;." &lt;&lt; std::endl;
+		ROS_ERROR("[%s] Missing calibration file path '%s'.", __APP_NAME__, calibration_file.c_str());
+		ros::shutdown();
 		return -1;
 	}
 
-	cv::FileStorage fs(argv[1], cv::FileStorage::READ);
+	cv::FileStorage fs(calibration_file, cv::FileStorage::READ);
 	if (!fs.isOpened())
 	{
-		std::cout &lt;&lt; "Cannot open " &lt;&lt; argv[1] &lt;&lt; std::endl;
+		ROS_ERROR("[%s] Cannot open file calibration file '%s'", __APP_NAME__, calibration_file.c_str());
+		ros::shutdown();
 		return -1;
 	}
 
@@ -185,27 +197,35 @@ int main(int argc, char *argv[])
 	fs["ImageSize"] &gt;&gt; ImageSize;
 	fs["DistModel"] &gt;&gt; DistModel;
 
-	std::string image_topic_name("/image_raw");
-	std::string camera_info_name("/camera_info");
-	std::string projection_matrix_name("/projection_matrix");
+	std::string image_topic_name;
+	std::string camera_info_name;
+	std::string projection_matrix_topic;
+
+	private_nh.param&lt;std::string&gt;("image_topic_src", image_topic_name, "/image_raw");
+	ROS_INFO("[%s] image_topic_name: %s", __APP_NAME__, image_topic_name.c_str());
+
+	private_nh.param&lt;std::string&gt;("camera_info_topic", camera_info_name, "/camera_info");
+	ROS_INFO("[%s] camera_info_name: %s", __APP_NAME__, camera_info_name.c_str());
+
+	private_nh.param&lt;std::string&gt;("projection_matrix_topic", projection_matrix_topic, "/projection_matrix");
+	ROS_INFO("[%s] projection_matrix_topic: %s", __APP_NAME__, projection_matrix_topic.c_str());
 
 	instrinsics_parsed_ = false;
 	extrinsics_parsed_ = false;
 
 	std::string name_space_str = ros::this_node::getNamespace();
-	camera_id_str = "camera";
 	if (name_space_str != "/")
 	{
 		image_topic_name = name_space_str + image_topic_name;
 		camera_info_name = name_space_str + camera_info_name;
-		projection_matrix_name = name_space_str + projection_matrix_name;
+		projection_matrix_topic = name_space_str + projection_matrix_topic;
 		if (name_space_str.substr(0, 2) == "//")
 		{
 			/* if name space obtained by ros::this::node::getNamespace()
 			   starts with "//", delete one of them */
 			name_space_str.erase(name_space_str.begin());
 		}
-		camera_id_str = name_space_str;
+		camera_id_str_ = name_space_str;
 	}
 
 	ros::Subscriber image_sub;
@@ -214,7 +234,7 @@ int main(int argc, char *argv[])
 
 	camera_info_pub = n.advertise&lt;sensor_msgs::CameraInfo&gt;(camera_info_name, 10, true);
 
-	projection_matrix_pub = n.advertise&lt;autoware_msgs::ProjectionMatrix&gt;(projection_matrix_name, 10, true);
+	projection_matrix_pub = n.advertise&lt;autoware_msgs::ProjectionMatrix&gt;(projection_matrix_topic, 10, true);
 
 	ros::spin();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8bf1c47fbc18a0303fda23c601dfe959a3afbc41" author="Esteve Fernandez">
		<msg>Moved configuration messages to autoware_config_msgs</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\range_fusion\nodes\range_fusion\range_fusion.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\range_fusion\nodes\range_fusion\range_fusion.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -32,7 +32,7 @@
 #include &lt;std_msgs/Header.h&gt;
 #include &lt;fusion/fusion_func.h&gt;
 #include "autoware_msgs/ImageObjRanged.h"
-#include "autoware_msgs/ConfigCarFusion.h"
+#include "autoware_config_msgs/ConfigCarFusion.h"
 
 static void publishTopic();
 static ros::Publisher fused_objects;
@@ -88,7 +88,7 @@ static void publishTopic()
 	fused_objects.publish(fused_objects_msg);
 }
 
-static void config_cb(const autoware_msgs::ConfigCarFusion::ConstPtr&amp; param)
+static void config_cb(const autoware_config_msgs::ConfigCarFusion::ConstPtr&amp; param)
 {
 	setParams(param-&gt;min_low_height,
 			param-&gt;max_low_height,
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -284,7 +284,7 @@ void Yolo3DetectorNode::image_callback(const sensor_msgs::ImageConstPtr&amp; in_imag
     free(darknet_image_.data);
 }
 
-void Yolo3DetectorNode::config_cb(const autoware_msgs::ConfigSsd::ConstPtr&amp; param)
+void Yolo3DetectorNode::config_cb(const autoware_config_msgs::ConfigSsd::ConstPtr&amp; param)
 {
     score_threshold_ = param-&gt;score_threshold;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.h" added_lines="1" deleted_lines="1">
				<diff>@@ -125,7 +125,7 @@ class Yolo3DetectorNode {
     void                            rgbgr_image(image&amp; im);
     image                           convert_ipl_to_image(const sensor_msgs::ImageConstPtr&amp; msg);
     void                            image_callback(const sensor_msgs::ImageConstPtr&amp; in_image_message);
-    void                            config_cb(const autoware_msgs::ConfigSsd::ConstPtr&amp; param);
+    void                            config_cb(const autoware_config_msgs::ConfigSsd::ConstPtr&amp; param);
     std::vector&lt;std::string&gt;        read_custom_names_file(const std::string&amp; in_path);
 public:
     void    Run();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\nodes\vision_dpm_ttic_detect\vision_dpm_ttic_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\nodes\vision_dpm_ttic_detect\vision_dpm_ttic_detect.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -37,7 +37,7 @@
 #include &lt;sensor_msgs/image_encodings.h&gt;
 
 #include "autoware_msgs/ImageObj.h"
-#include "autoware_msgs/ConfigPedestrianDpm.h"
+#include "autoware_config_msgs/ConfigPedestrianDpm.h"
 
 #include &lt;libdpm_ttic/dpm_ttic.hpp&gt;
 
@@ -109,7 +109,7 @@ static void image_raw_cb(const sensor_msgs::Image&amp; image_source)
 	counter++;
 }
 
-static void config_cb(const autoware_msgs::ConfigPedestrianDpm::ConstPtr&amp; param)
+static void config_cb(const autoware_config_msgs::ConfigPedestrianDpm::ConstPtr&amp; param)
 {
 	ttic_param.threshold = param-&gt;score_threshold;
 	ttic_param.overlap   = param-&gt;group_threshold;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -32,7 +32,7 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include "autoware_msgs/ConfigSsd.h"
+#include "autoware_config_msgs/ConfigSsd.h"
 #include "autoware_msgs/DetectedObject.h"
 #include "autoware_msgs/DetectedObjectArray.h"
 
@@ -130,7 +130,7 @@ class RosSsdApp
 	}
 
 
-	void config_cb(const autoware_msgs::ConfigSsd::ConstPtr&amp; param)
+	void config_cb(const autoware_config_msgs::ConfigSsd::ConstPtr&amp; param)
 	{
 		score_threshold_ 	= param-&gt;score_threshold;
 	}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\libs\kf\src\kf_lib.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\libs\kf\src\kf_lib.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -37,7 +37,7 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;autoware_msgs/ConfigCarKf.h&gt;
+#include &lt;autoware_config_msgs/ConfigCarKf.h&gt;
 #include &lt;autoware_msgs/ImageObjRanged.h&gt;
 
 #include &lt;autoware_msgs/ImageObjTracked.h&gt;
@@ -918,7 +918,7 @@ void detections_callback(autoware_msgs::ImageObjRanged image_objects_msg)
 	publish_if_possible();
 }
 
-static void kf_config_cb(const autoware_msgs::ConfigCarKf::ConstPtr&amp; param)
+static void kf_config_cb(const autoware_config_msgs::ConfigCarKf::ConstPtr&amp; param)
 {
 	if (param-&gt;initial_lifespan &gt; 0)
 		INITIAL_LIFESPAN	= param-&gt;initial_lifespan;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\approximate_ndt_mapping\approximate_ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\approximate_ndt_mapping\approximate_ndt_mapping.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -66,8 +66,8 @@
 #include &lt;pcl/registration/ndt.h&gt;
 #endif
 
-#include &lt;autoware_msgs/ConfigApproximateNdtMapping.h&gt;
-#include &lt;autoware_msgs/ConfigNdtMappingOutput.h&gt;
+#include &lt;autoware_config_msgs/ConfigApproximateNdtMapping.h&gt;
+#include &lt;autoware_config_msgs/ConfigNdtMappingOutput.h&gt;
 
 struct pose
 {
@@ -157,7 +157,7 @@ static nav_msgs::Odometry odom;
 static std::ofstream ofs;
 static std::string filename;
 
-static void param_callback(const autoware_msgs::ConfigApproximateNdtMapping::ConstPtr&amp; input)
+static void param_callback(const autoware_config_msgs::ConfigApproximateNdtMapping::ConstPtr&amp; input)
 {
   ndt_res = input-&gt;resolution;
   step_size = input-&gt;step_size;
@@ -181,7 +181,7 @@ static void param_callback(const autoware_msgs::ConfigApproximateNdtMapping::Con
   std::cout &lt;&lt; "max_submap_size: " &lt;&lt; max_submap_size &lt;&lt; std::endl;
 }
 
-static void output_callback(const autoware_msgs::ConfigNdtMappingOutput::ConstPtr&amp; input)
+static void output_callback(const autoware_config_msgs::ConfigNdtMappingOutput::ConstPtr&amp; input)
 {
   double filter_res = input-&gt;filter_res;
   std::string filename = input-&gt;filename;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\icp_matching\icp_matching.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\icp_matching\icp_matching.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -63,7 +63,7 @@
 #include &lt;pcl/registration/icp.h&gt;
 #include &lt;pcl/filters/voxel_grid.h&gt;
 
-#include "autoware_msgs/ConfigICP.h"
+#include "autoware_config_msgs/ConfigICP.h"
 
 #include "autoware_msgs/ICPStat.h"
 
@@ -169,7 +169,7 @@ static std::string _offset = "linear";  // linear, zero, quadratic
 static std::ofstream ofs;
 static std::string filename;
 
-static void param_callback(const autoware_msgs::ConfigICP::ConstPtr&amp; input)
+static void param_callback(const autoware_config_msgs::ConfigICP::ConstPtr&amp; input)
 {
   if (_use_gnss != input-&gt;init_pos_gnss)
   {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\lazy_ndt_mapping\lazy_ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\lazy_ndt_mapping\lazy_ndt_mapping.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -65,8 +65,8 @@
 #include &lt;pcl/filters/voxel_grid.h&gt;
 #endif
 
-#include "autoware_msgs/ConfigNdtMapping.h"
-#include "autoware_msgs/ConfigNdtMappingOutput.h"
+#include "autoware_config_msgs/ConfigNdtMapping.h"
+#include "autoware_config_msgs/ConfigNdtMappingOutput.h"
 
 struct pose {
     double x;
@@ -125,7 +125,7 @@ static bool _use_openmp = false;
 
 static double fitness_score;
 
-static void param_callback(const autoware_msgs::ConfigNdtMapping::ConstPtr&amp; input)
+static void param_callback(const autoware_config_msgs::ConfigNdtMapping::ConstPtr&amp; input)
 {
   ndt_res = input-&gt;resolution;
   step_size = input-&gt;step_size;
@@ -145,7 +145,7 @@ static void param_callback(const autoware_msgs::ConfigNdtMapping::ConstPtr&amp; inpu
   std::cout &lt;&lt; "min_add_scan_shift: " &lt;&lt; min_add_scan_shift &lt;&lt; std::endl;
 }
 
-static void output_callback(const autoware_msgs::ConfigNdtMappingOutput::ConstPtr&amp; input)
+static void output_callback(const autoware_config_msgs::ConfigNdtMappingOutput::ConstPtr&amp; input)
 {
   double filter_res = input-&gt;filter_res;
   std::string filename = input-&gt;filename;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -67,8 +67,8 @@
 #include &lt;pcl_omp_registration/ndt.h&gt;
 #endif
 
-#include &lt;autoware_msgs/ConfigNdtMapping.h&gt;
-#include &lt;autoware_msgs/ConfigNdtMappingOutput.h&gt;
+#include &lt;autoware_config_msgs/ConfigNdtMapping.h&gt;
+#include &lt;autoware_config_msgs/ConfigNdtMappingOutput.h&gt;
 
 #include &lt;time.h&gt;
 
@@ -176,7 +176,7 @@ static nav_msgs::Odometry odom;
 static std::ofstream ofs;
 static std::string filename;
 
-static void param_callback(const autoware_msgs::ConfigNdtMapping::ConstPtr&amp; input)
+static void param_callback(const autoware_config_msgs::ConfigNdtMapping::ConstPtr&amp; input)
 {
   ndt_res = input-&gt;resolution;
   step_size = input-&gt;step_size;
@@ -198,7 +198,7 @@ static void param_callback(const autoware_msgs::ConfigNdtMapping::ConstPtr&amp; inpu
   std::cout &lt;&lt; "min_add_scan_shift: " &lt;&lt; min_add_scan_shift &lt;&lt; std::endl;
 }
 
-static void output_callback(const autoware_msgs::ConfigNdtMappingOutput::ConstPtr&amp; input)
+static void output_callback(const autoware_config_msgs::ConfigNdtMappingOutput::ConstPtr&amp; input)
 {
   double filter_res = input-&gt;filter_res;
   std::string filename = input-&gt;filename;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -77,7 +77,7 @@
 #include &lt;pcl_ros/point_cloud.h&gt;
 #include &lt;pcl_ros/transforms.h&gt;
 
-#include &lt;autoware_msgs/ConfigNdt.h&gt;
+#include &lt;autoware_config_msgs/ConfigNdt.h&gt;
 
 #include &lt;autoware_msgs/NDTStat.h&gt;
 
@@ -243,7 +243,7 @@ static unsigned int points_map_num = 0;
 
 pthread_mutex_t mutex;
 
-static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
+static void param_callback(const autoware_config_msgs::ConfigNdt::ConstPtr&amp; input)
 {
   if (_use_gnss != input-&gt;init_pos_gnss)
   {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="2" deleted_lines="2">
				<diff>@@ -4,7 +4,7 @@
 #include &lt;mutex&gt;
 #include &lt;unordered_map&gt;
 
-#include &lt;autoware_msgs/ConfigDecisionMaker.h&gt;
+#include &lt;autoware_config_msgs/ConfigDecisionMaker.h&gt;
 #include &lt;autoware_msgs/CloudClusterArray.h&gt;
 #include &lt;autoware_msgs/LaneArray.h&gt;
 #include &lt;autoware_msgs/Waypoint.h&gt;
@@ -231,7 +231,7 @@ private:
   void callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg);
   void callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg);
   void callbackFromStateCmd(const std_msgs::Int32 &amp;msg);
-  void callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg);
+  void callbackFromConfig(const autoware_config_msgs::ConfigDecisionMaker &amp;msg);
   void callbackFromObjectDetector(const autoware_msgs::CloudClusterArray &amp;msg);
 
   void callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\planner_selector.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\planner_selector.hpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,7 +1,7 @@
 #ifndef __PLANNER_SELECTOR_HPP__
 #define __PLANNER_SELECTOR_HPP__
 
-#include &lt;autoware_msgs/ConfigPlannerSelector.h&gt;
+#include &lt;autoware_config_msgs/ConfigPlannerSelector.h&gt;
 #include &lt;autoware_msgs/Lane.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
@@ -62,7 +62,7 @@ public:
   void callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event);
   void callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::Lane const&gt; &amp;event);
   void callbackFromLattice(const std_msgs::Int32 &amp;msg);
-  void callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg);
+  void callbackFromConfig(const autoware_config_msgs::ConfigPlannerSelector &amp;msg);
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
 };
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -89,7 +89,7 @@ void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
   }
 }
 
-void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
+void DecisionMakerNode::callbackFromConfig(const autoware_config_msgs::ConfigDecisionMaker &amp;msg)
 {
   ROS_INFO("Param setted by Runtime Manager");
   enableDisplayMarker = msg.enable_display_marker;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,4 +1,4 @@
-#include &lt;autoware_msgs/ConfigPlannerSelector.h&gt;
+#include &lt;autoware_config_msgs/ConfigPlannerSelector.h&gt;
 #include &lt;autoware_msgs/Lane.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
@@ -175,7 +175,7 @@ void PlannerSelector::callbackFromCurrentVelocity(const geometry_msgs::TwistStam
   current_velocity_ = msg.twist.linear.x;
 }
 
-void PlannerSelector::callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg)
+void PlannerSelector::callbackFromConfig(const autoware_config_msgs::ConfigPlannerSelector &amp;msg)
 {
   config_latency_num_ = msg.latency_num;
   config_waypoints_num_ = msg.waypoints_num;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -37,7 +37,7 @@
 #include &lt;ros/console.h&gt;
 
 #include &lt;vector_map/vector_map.h&gt;
-#include "autoware_msgs/ConfigLaneRule.h"
+#include "autoware_config_msgs/ConfigLaneRule.h"
 #include "autoware_msgs/LaneArray.h"
 
 #include &lt;lane_planner/lane_planner_vmap.hpp&gt;
@@ -541,7 +541,7 @@ void cache_dtlane(const vector_map::DTLaneArray&amp; msg)
 	update_values();
 }
 
-void config_parameter(const autoware_msgs::ConfigLaneRule&amp; msg)
+void config_parameter(const autoware_config_msgs::ConfigLaneRule&amp; msg)
 {
 	config_acceleration = msg.acceleration;
 	config_stopline_search_radius = msg.stopline_search_radius;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -707,7 +707,7 @@ void LaneSelectNode::callbackFromStates(const autoware_msgs::StateConstPtr &amp;msg)
     processing();
 }
 
-void LaneSelectNode::callbackFromConfig(const autoware_msgs::ConfigLaneSelectConstPtr &amp;msg)
+void LaneSelectNode::callbackFromConfig(const autoware_config_msgs::ConfigLaneSelectConstPtr &amp;msg)
 {
   distance_threshold_ = msg-&gt;distance_threshold_neighbor_lanes;
   lane_change_interval_ = msg-&gt;lane_change_interval;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -45,7 +45,7 @@
 #include &lt;tuple&gt;
 
 // User defined includes
-#include "autoware_msgs/ConfigLaneSelect.h"
+#include "autoware_config_msgs/ConfigLaneSelect.h"
 #include "autoware_msgs/LaneArray.h"
 #include "autoware_msgs/State.h"
 #include "hermite_curve.h"
@@ -113,7 +113,7 @@ private:
   void callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr &amp;msg);
   void callbackFromState(const std_msgs::StringConstPtr &amp;msg);
   void callbackFromStates(const autoware_msgs::StateConstPtr &amp;msg);
-  void callbackFromConfig(const autoware_msgs::ConfigLaneSelectConstPtr &amp;msg);
+  void callbackFromConfig(const autoware_config_msgs::ConfigLaneSelectConstPtr &amp;msg);
 
   // initializer
   void initForROS();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_stop\lane_stop.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_stop\lane_stop.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -30,7 +30,7 @@
 
 #include &lt;ros/console.h&gt;
 
-#include "autoware_msgs/ConfigLaneStop.h"
+#include "autoware_config_msgs/ConfigLaneStop.h"
 #include "autoware_msgs/TrafficLight.h"
 #include "autoware_msgs/LaneArray.h"
 
@@ -97,7 +97,7 @@ void cache_green_lane(const autoware_msgs::LaneArray&amp; msg)
 	current_green_lane = msg;
 }
 
-void config_parameter(const autoware_msgs::ConfigLaneStop&amp; msg)
+void config_parameter(const autoware_config_msgs::ConfigLaneStop&amp; msg)
 {
 	config_manual_detection = msg.manual_detection;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -67,7 +67,7 @@ void VelocitySetInfo::clearPoints()
   points_.clear();
 }
 
-void VelocitySetInfo::configCallback(const autoware_msgs::ConfigVelocitySetConstPtr &amp;config)
+void VelocitySetInfo::configCallback(const autoware_config_msgs::ConfigVelocitySetConstPtr &amp;config)
 {
   stop_distance_obstacle_ = config-&gt;stop_distance_obstacle;
   stop_distance_stopline_ = config-&gt;stop_distance_stopline;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" added_lines="2" deleted_lines="2">
				<diff>@@ -36,7 +36,7 @@
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 
-#include "autoware_msgs/ConfigVelocitySet.h"
+#include "autoware_config_msgs/ConfigVelocitySet.h"
 
 class VelocitySetInfo
 {
@@ -70,7 +70,7 @@ class VelocitySetInfo
   ~VelocitySetInfo();
 
   // ROS Callback
-  void configCallback(const autoware_msgs::ConfigVelocitySetConstPtr &amp;msg);
+  void configCallback(const autoware_config_msgs::ConfigVelocitySetConstPtr &amp;msg);
   void pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg);
   void controlPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void localizerPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_trajectory_gen\lattice_trajectory_gen.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_trajectory_gen\lattice_trajectory_gen.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -49,7 +49,7 @@
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;std_msgs/Float32.h&gt;
 #include &lt;std_msgs/Float64MultiArray.h&gt;
-#include "autoware_msgs/ConfigWaypointFollower.h"
+#include "autoware_config_msgs/ConfigWaypointFollower.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "libtraj_gen.h"
 #include "autoware_msgs/CanInfo.h"
@@ -102,7 +102,7 @@ static double g_minimum_look_ahead_threshold = 6.0; // the next waypoint must be
 
 static WayPoints g_current_waypoints;
 
-static void ConfigCallback(const autoware_msgs::ConfigWaypointFollowerConstPtr &amp;config)
+static void ConfigCallback(const autoware_config_msgs::ConfigWaypointFollowerConstPtr &amp;config)
 {
   g_param_flag = config-&gt;param_flag;
   g_lookahead_threshold = config-&gt;lookahead_distance;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_velocity_set\lattice_velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_velocity_set\lattice_velocity_set.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -43,7 +43,7 @@
 #include &lt;std_msgs/String.h&gt;
 #include &lt;std_msgs/Float32.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
-#include "autoware_msgs/ConfigLatticeVelocitySet.h"
+#include "autoware_config_msgs/ConfigLatticeVelocitySet.h"
 #include &lt;iostream&gt;
 
 #include "autoware_msgs/Lane.h"
@@ -312,7 +312,7 @@ void PathVset::changeWaypoints(int stop_waypoint)
 //          Callback
 //===============================
 
-void configCallback(const autoware_msgs::ConfigLatticeVelocitySetConstPtr &amp;config)
+void configCallback(const autoware_config_msgs::ConfigLatticeVelocitySetConstPtr &amp;config)
 {
   g_others_distance = config-&gt;others_distance;
   g_detection_range = config-&gt;detection_range;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -192,7 +192,7 @@ double PurePursuitNode::computeAngularGravity(double velocity, double kappa) con
   return (velocity * velocity) / (1.0 / kappa * gravity);
 }
 
-void PurePursuitNode::callbackFromConfig(const autoware_msgs::ConfigWaypointFollowerConstPtr &amp;config)
+void PurePursuitNode::callbackFromConfig(const autoware_config_msgs::ConfigWaypointFollowerConstPtr &amp;config)
 {
   param_flag_ = config-&gt;param_flag;
   const_lookahead_distance_ = config-&gt;lookahead_distance;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -39,7 +39,7 @@
 #include &lt;visualization_msgs/Marker.h&gt;
 
 // User defined includes
-#include "autoware_msgs/ConfigWaypointFollower.h"
+#include "autoware_config_msgs/ConfigWaypointFollower.h"
 #include "autoware_msgs/ControlCommandStamped.h"
 #include "autoware_msgs/Lane.h"
 #include "pure_pursuit.h"
@@ -99,7 +99,7 @@ private:
   double minimum_lookahead_distance_;  // the next waypoint must be outside of this threshold.
 
   // callbacks
-  void callbackFromConfig(const autoware_msgs::ConfigWaypointFollowerConstPtr &amp;config);
+  void callbackFromConfig(const autoware_config_msgs::ConfigWaypointFollowerConstPtr &amp;config);
   void callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStampedConstPtr &amp;msg);
   void callbackFromWayPoints(const autoware_msgs::LaneConstPtr &amp;msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_filter\twist_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_filter\twist_filter.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -33,7 +33,7 @@
 
 #include &lt;iostream&gt;
 
-#include "autoware_msgs/ConfigTwistFilter.h"
+#include "autoware_config_msgs/ConfigTwistFilter.h"
 
 namespace {
 
@@ -45,7 +45,7 @@ double g_lowpass_gain_angular_z = 0.0;
 constexpr double RADIUS_MAX = 9e10;
 constexpr double ERROR = 1e-8;
 
-void configCallback(const autoware_msgs::ConfigTwistFilterConstPtr &amp;config)
+void configCallback(const autoware_config_msgs::ConfigTwistFilterConstPtr &amp;config)
 {
   g_lateral_accel_limit = config-&gt;lateral_accel_limit;
   ROS_INFO("g_lateral_accel_limit = %lf",g_lateral_accel_limit);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -49,7 +49,7 @@ VelocityReplanner::~VelocityReplanner()
 {
 }
 
-void VelocityReplanner::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
+void VelocityReplanner::initParameter(const autoware_config_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
 {
   velocity_max_ = kmph2mps(conf-&gt;velocity_max);
   velocity_min_ = kmph2mps(conf-&gt;velocity_min);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" added_lines="2" deleted_lines="2">
				<diff>@@ -33,7 +33,7 @@
 
 #include &lt;ros/ros.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
-#include &lt;autoware_msgs/ConfigWaypointLoader.h&gt;
+#include &lt;autoware_config_msgs/ConfigWaypointLoader.h&gt;
 #include &lt;fstream&gt;
 #include &lt;unordered_map&gt;
 #include &lt;algorithm&gt;
@@ -58,7 +58,7 @@ private:
 public:
   VelocityReplanner();
   ~VelocityReplanner();
-  void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
+  void initParameter(const autoware_config_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
   void replanLaneWaypointVel(autoware_msgs::Lane* lane);
 
 protected:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -61,14 +61,14 @@ void WaypointLoaderNode::initPubSub()
       nh_.subscribe("/config/waypoint_loader_output", 1, &amp;WaypointLoaderNode::outputCommandCallback, this);
 }
 
-void WaypointLoaderNode::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
+void WaypointLoaderNode::initParameter(const autoware_config_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
 {
   // parameter settings
   replanning_mode_ = conf-&gt;replanning_mode;
   multi_lane_csv_ = conf-&gt;multi_lane_csv;
 }
 
-void WaypointLoaderNode::configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
+void WaypointLoaderNode::configCallback(const autoware_config_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
 {
   initParameter(conf);
   replanner_.initParameter(conf);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -95,10 +95,10 @@ private:
 
   // initializer
   void initPubSub();
-  void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
+  void initParameter(const autoware_config_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
 
   // functions
-  void configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
+  void configCallback(const autoware_config_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
   void outputCommandCallback(const std_msgs::Bool::ConstPtr&amp; output_cmd);
   void createLaneWaypoint(const std::string&amp; file_path, autoware_msgs::Lane* lane);
   void createLaneArray(const std::vector&lt;std::string&gt;&amp; paths, autoware_msgs::LaneArray* lane_array);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -40,7 +40,7 @@
 
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "autoware_msgs/LaneArray.h"
-#include "autoware_msgs/ConfigLaneStop.h"
+#include "autoware_config_msgs/ConfigLaneStop.h"
 #include "autoware_msgs/TrafficLight.h"
 
 namespace
@@ -391,7 +391,7 @@ void receiveManualDetection(const autoware_msgs::TrafficLightConstPtr&amp; msg)
     lightCallback(msg);
 }
 
-void configParameter(const autoware_msgs::ConfigLaneStopConstPtr&amp; msg)
+void configParameter(const autoware_config_msgs::ConfigLaneStopConstPtr&amp; msg)
 {
   g_config_manual_detection = msg-&gt;manual_detection;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -49,7 +49,7 @@
 
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "autoware_msgs/LaneArray.h"
-#include "autoware_msgs/ConfigLaneStop.h"
+#include "autoware_config_msgs/ConfigLaneStop.h"
 #include "autoware_msgs/TrafficLight.h"
 
 class WaypointVelocityVisualizer
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -35,7 +35,7 @@
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include &lt;pcl/filters/voxel_grid.h&gt;
 
-#include "autoware_msgs/ConfigDistanceFilter.h"
+#include "autoware_config_msgs/ConfigDistanceFilter.h"
 
 #include &lt;points_downsampler/PointsDownsamplerInfo.h&gt;
 
@@ -62,7 +62,7 @@ static std::string filename;
 static std::string POINTS_TOPIC;
 static double measurement_range = MAX_MEASUREMENT_RANGE;
 
-static void config_callback(const autoware_msgs::ConfigDistanceFilter::ConstPtr&amp; input)
+static void config_callback(const autoware_config_msgs::ConfigDistanceFilter::ConstPtr&amp; input)
 {
   sample_num = input-&gt;sample_num;
   measurement_range = input-&gt;measurement_range;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -34,7 +34,7 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#include "autoware_msgs/ConfigRandomFilter.h"
+#include "autoware_config_msgs/ConfigRandomFilter.h"
 
 #include &lt;points_downsampler/PointsDownsamplerInfo.h&gt;
 
@@ -60,7 +60,7 @@ static std::string filename;
 static std::string POINTS_TOPIC;
 static double measurement_range = MAX_MEASUREMENT_RANGE;
 
-static void config_callback(const autoware_msgs::ConfigRandomFilter::ConstPtr&amp; input)
+static void config_callback(const autoware_config_msgs::ConfigRandomFilter::ConstPtr&amp; input)
 {
   sample_num = input-&gt;sample_num;
   measurement_range = input-&gt;measurement_range;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\ring_filter\ring_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\ring_filter\ring_filter.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -37,7 +37,7 @@
 
 #include &lt;velodyne_pointcloud/point_types.h&gt;
 
-#include "autoware_msgs/ConfigRingFilter.h"
+#include "autoware_config_msgs/ConfigRingFilter.h"
 
 #include &lt;points_downsampler/PointsDownsamplerInfo.h&gt;
 
@@ -65,7 +65,7 @@ static std::string filename;
 static std::string POINTS_TOPIC;
 static double measurement_range = MAX_MEASUREMENT_RANGE;
 
-static void config_callback(const autoware_msgs::ConfigRingFilter::ConstPtr&amp; input)
+static void config_callback(const autoware_config_msgs::ConfigRingFilter::ConstPtr&amp; input)
 {
   ring_div = input-&gt;ring_div;
   voxel_leaf_size = input-&gt;voxel_leaf_size;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -35,7 +35,7 @@
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include &lt;pcl/filters/voxel_grid.h&gt;
 
-#include "autoware_msgs/ConfigVoxelGridFilter.h"
+#include "autoware_config_msgs/ConfigVoxelGridFilter.h"
 
 #include &lt;points_downsampler/PointsDownsamplerInfo.h&gt;
 
@@ -62,7 +62,7 @@ static std::string filename;
 static std::string POINTS_TOPIC;
 static double measurement_range = MAX_MEASUREMENT_RANGE;
 
-static void config_callback(const autoware_msgs::ConfigVoxelGridFilter::ConstPtr&amp; input)
+static void config_callback(const autoware_config_msgs::ConfigVoxelGridFilter::ConstPtr&amp; input)
 {
   voxel_leaf_size = input-&gt;voxel_leaf_size;
   measurement_range = input-&gt;measurement_range;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\compare_map_filter\compare_map_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\compare_map_filter\compare_map_filter.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -40,7 +40,7 @@
 #include &lt;pcl/search/kdtree.h&gt;
 #include &lt;pcl/kdtree/kdtree_flann.h&gt;
 
-#include &lt;autoware_msgs/ConfigCompareMapFilter.h&gt;
+#include &lt;autoware_config_msgs/ConfigCompareMapFilter.h&gt;
 
 class CompareMapFilter
 {
@@ -67,7 +67,7 @@ private:
 
   std::string map_frame_;
 
-  void configCallback(const autoware_msgs::ConfigCompareMapFilter::ConstPtr&amp; config_msg_ptr);
+  void configCallback(const autoware_config_msgs::ConfigCompareMapFilter::ConstPtr&amp; config_msg_ptr);
   void pointsMapCallback(const sensor_msgs::PointCloud2::ConstPtr&amp; map_cloud_msg_ptr);
   void sensorPointsCallback(const sensor_msgs::PointCloud2::ConstPtr&amp; sensorTF_cloud_msg_ptr);
   void searchMatchingCloud(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud_ptr,
@@ -95,7 +95,7 @@ CompareMapFilter::CompareMapFilter()
   unmatch_points_pub_ = nh_.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_no_ground", 10);
 }
 
-void CompareMapFilter::configCallback(const autoware_msgs::ConfigCompareMapFilter::ConstPtr&amp; config_msg_ptr)
+void CompareMapFilter::configCallback(const autoware_config_msgs::ConfigCompareMapFilter::ConstPtr&amp; config_msg_ptr)
 {
   distance_threshold_ = config_msg_ptr-&gt;distance_threshold;
   min_clipping_height_ = config_msg_ptr-&gt;min_clipping_height;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\include\ray_ground_filter.h" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\include\ray_ground_filter.h" added_lines="2" deleted_lines="2">
				<diff>@@ -44,7 +44,7 @@
 #include &lt;pcl/features/normal_3d_omp.h&gt;
 #include &lt;pcl/filters/extract_indices.h&gt;
 #include &lt;velodyne_pointcloud/point_types.h&gt;
-#include "autoware_msgs/ConfigRayGroundFilter.h"
+#include "autoware_config_msgs/ConfigRayGroundFilter.h"
 
 #include &lt;opencv2/core/version.hpp&gt;
 #if (CV_MAJOR_VERSION == 3)
@@ -99,7 +99,7 @@ private:
 	};
 	typedef std::vector&lt;PointXYZIRTColor&gt; PointCloudXYZIRTColor;
 
-	void update_config_params(const autoware_msgs::ConfigRayGroundFilter::ConstPtr&amp; param);
+	void update_config_params(const autoware_config_msgs::ConfigRayGroundFilter::ConstPtr&amp; param);
 
 	void publish_cloud(const ros::Publisher&amp; in_publisher,
 	                         const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud_to_publish_ptr,
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\ray_ground_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\ray_ground_filter.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -41,7 +41,7 @@
 #include &lt;pcl/features/normal_3d_omp.h&gt;
 #include &lt;pcl/filters/extract_indices.h&gt;
 #include &lt;velodyne_pointcloud/point_types.h&gt;
-#include "autoware_msgs/ConfigRayGroundFilter.h"
+#include "autoware_config_msgs/ConfigRayGroundFilter.h"
 
 #include &lt;opencv2/core/version.hpp&gt;
 #if (CV_MAJOR_VERSION == 3)
@@ -52,7 +52,7 @@
 
 #include "ray_ground_filter.h"
 
-void RayGroundFilter::update_config_params(const autoware_msgs::ConfigRayGroundFilter::ConstPtr&amp; param)
+void RayGroundFilter::update_config_params(const autoware_config_msgs::ConfigRayGroundFilter::ConstPtr&amp; param)
 {
   sensor_height_          = param-&gt;sensor_height;
   general_max_slope_      = param-&gt;general_max_slope;
</diff>
			</file>
			<file old_path="ros\src\sensing\polygon\packages\points2polygon\nodes\points2polygon\points2polygon.cpp" new_path="ros\src\sensing\polygon\packages\points2polygon\nodes\points2polygon\points2polygon.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -32,7 +32,7 @@
 #include &lt;ros/console.h&gt;
 
 #include &lt;sensor_msgs/PointCloud2.h&gt;
-#include &lt;autoware_msgs/ConfigPoints2Polygon.h&gt;
+#include &lt;autoware_config_msgs/ConfigPoints2Polygon.h&gt;
 
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl/io/pcd_io.h&gt;
@@ -115,7 +115,7 @@ static void points_to_polygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr&amp; cloud)
 	pcl::io::saveVTKFile(points_polygon_vtk, triangles);
 }
 
-static void config_callback(const autoware_msgs::ConfigPoints2Polygon&amp; msg)
+static void config_callback(const autoware_config_msgs::ConfigPoints2Polygon&amp; msg)
 {
 	config_k_search = msg.k_search;
 	config_search_radius = msg.search_radius;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="57b2932ce6757e62eb70010ad35e29f1df9ddd31" author="Esteve Fernandez">
		<msg>Moved CAN mesages to autoware_can_msgs</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_core.h" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_core.h" added_lines="1" deleted_lines="1">
				<diff>@@ -39,7 +39,7 @@
 #include &lt;tf/transform_broadcaster.h&gt;
 
 // User Defined Includes
-#include "autoware_msgs/CanInfo.h"
+#include "autoware_can_msgs/CANInfo.h"
 #include "autoware_msgs/VehicleStatus.h"
 
 namespace autoware_connector
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_status_translator\can_status_translator_core.cpp" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_status_translator\can_status_translator_core.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -67,7 +67,7 @@ void CanStatusTranslatorNode::initForROS()
     v_info_.is_stored = true;
   }
   // setup subscriber
-  sub1_ = nh_.subscribe("can_info", 100, &amp;CanStatusTranslatorNode::callbackFromCanInfo, this);
+  sub1_ = nh_.subscribe("can_info", 100, &amp;CanStatusTranslatorNode::callbackFromCANInfo, this);
   sub2_ = nh_.subscribe("vehicle_status", 10, &amp;CanStatusTranslatorNode::callbackFromVehicleStatus, this);
 
   // setup publisher
@@ -102,13 +102,13 @@ void CanStatusTranslatorNode::publishVelocityViz(const autoware_msgs::VehicleSta
   pub2_.publish(fl);
 }
 
-void CanStatusTranslatorNode::publishVehicleStatus(const autoware_msgs::CanInfoConstPtr&amp; msg)
+void CanStatusTranslatorNode::publishVehicleStatus(const autoware_can_msgs::CANInfoConstPtr&amp; msg)
 {
   // currently, this function is only support to autoware_socket format.
   autoware_msgs::VehicleStatus vs;
   vs.header = msg-&gt;header;
   vs.tm = msg-&gt;tm;
-  vs.drivemode = msg-&gt;devmode;  // I think devmode is typo in CanInfo...
+  vs.drivemode = msg-&gt;devmode;  // I think devmode is typo in CANInfo...
   vs.steeringmode = msg-&gt;strmode;
   vs.gearshift = msg-&gt;driveshift;
   vs.speed = msg-&gt;speed;
@@ -127,7 +127,7 @@ void CanStatusTranslatorNode::callbackFromVehicleStatus(const autoware_msgs::Veh
   publishVelocityViz(msg);
 }
 
-void CanStatusTranslatorNode::callbackFromCanInfo(const autoware_msgs::CanInfoConstPtr&amp; msg)
+void CanStatusTranslatorNode::callbackFromCANInfo(const autoware_can_msgs::CANInfoConstPtr&amp; msg)
 {
   publishVehicleStatus(msg);
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_status_translator\can_status_translator_core.h" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_status_translator\can_status_translator_core.h" added_lines="3" deleted_lines="3">
				<diff>@@ -39,7 +39,7 @@
 #include &lt;tf/transform_broadcaster.h&gt;
 
 // User Defined Includes
-#include "autoware_msgs/CanInfo.h"
+#include "autoware_can_msgs/CANInfo.h"
 #include "autoware_msgs/VehicleStatus.h"
 
 namespace autoware_connector
@@ -116,7 +116,7 @@ private:
   VehicleInfo v_info_;
 
   // callbacks
-  void callbackFromCanInfo(const autoware_msgs::CanInfoConstPtr&amp; msg);
+  void callbackFromCANInfo(const autoware_can_msgs::CANInfoConstPtr&amp; msg);
   void callbackFromVehicleStatus(const autoware_msgs::VehicleStatusConstPtr&amp; msg);
 
   // initializer
@@ -125,7 +125,7 @@ private:
   // functions
   void publishVelocity(const autoware_msgs::VehicleStatusConstPtr&amp; msg);
   void publishVelocityViz(const autoware_msgs::VehicleStatusConstPtr&amp; msg);
-  void publishVehicleStatus(const autoware_msgs::CanInfoConstPtr&amp; msg);
+  void publishVehicleStatus(const autoware_can_msgs::CANInfoConstPtr&amp; msg);
 };
 }
 #endif  // CAN_STATUS_TRANSLATOR_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\include\op_global_planner_core.h" new_path="ros\src\computing\planning\mission\packages\op_global_planner\include\op_global_planner_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -56,7 +56,7 @@
 
 #include &lt;std_msgs/Int8.h&gt;
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "autoware_msgs/CanInfo.h"
+#include "autoware_can_msgs/CANInfo.h"
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
 #include "op_planner/PlannerCommonDef.h"
@@ -156,7 +156,7 @@ private:
   void callbackGetStartPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;input);
   void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg);
   void callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr&amp; msg);
-  void callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg);
+  void callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &amp;msg);
   void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg);
   void callbackGetRoadStatusOccupancyGrid(const nav_msgs::OccupancyGridConstPtr&amp; msg);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -90,7 +90,7 @@ GlobalPlanner::GlobalPlanner()
 	else if(bVelSource == 1)
 		sub_current_velocity = nh.subscribe("/current_velocity", 10, &amp;GlobalPlanner::callbackGetVehicleStatus, this);
 	else if(bVelSource == 2)
-		sub_can_info = nh.subscribe("/can_info", 10, &amp;GlobalPlanner::callbackGetCanInfo, this);
+		sub_can_info = nh.subscribe("/can_info", 10, &amp;GlobalPlanner::callbackGetCANInfo, this);
 
 	if(m_params.bEnableDynamicMapUpdate)
 	  sub_road_status_occupancy = nh.subscribe&lt;&gt;("/occupancy_road_status", 1, &amp;GlobalPlanner::callbackGetRoadStatusOccupancyGrid, this);
@@ -218,7 +218,7 @@ void GlobalPlanner::callbackGetVehicleStatus(const geometry_msgs::TwistStampedCo
 	UtilityHNS::UtilityH::GetTickCount(m_VehicleState.tStamp);
 }
 
-void GlobalPlanner::callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
+void GlobalPlanner::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &amp;msg)
 {
 	m_VehicleState.speed = msg-&gt;speed/3.6;
 	m_CurrentPose.v = m_VehicleState.speed;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\way_planner_core.h" new_path="ros\src\computing\planning\mission\packages\way_planner\include\way_planner_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -55,7 +55,7 @@
 
 #include &lt;std_msgs/Int8.h&gt;
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "autoware_msgs/CanInfo.h"
+#include "autoware_can_msgs/CANInfo.h"
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
 #include "op_planner/MappingHelpers.h"
@@ -191,7 +191,7 @@ private:
   void callbackGetStartPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;input);
   void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg);
   void callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr&amp; msg);
-  void callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg);
+  void callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &amp;msg);
   void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg);
 
   void callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -133,7 +133,7 @@ if(m_params.bEnableHMI)
 	else if(bVelSource == 1)
 		sub_current_velocity 	= nh.subscribe("/current_velocity",		100,	&amp;way_planner_core::callbackGetVehicleStatus, 	this);
 	else if(bVelSource == 2)
-		sub_can_info 			= nh.subscribe("/can_info",		100,	&amp;way_planner_core::callbackGetCanInfo, 	this);
+		sub_can_info 			= nh.subscribe("/can_info",		100,	&amp;way_planner_core::callbackGetCANInfo, 	this);
 
 	//sub_current_velocity 	= nh.subscribe("/current_velocity",			100,	&amp;way_planner_core::callbackGetVehicleStatus, 	this);
 	sub_nodes_list 			= nh.subscribe("/GlobalNodesList", 			1, 		&amp;way_planner_core::callbackGetNodesList, 		this);
@@ -225,7 +225,7 @@ void way_planner_core::callbackGetVehicleStatus(const geometry_msgs::TwistStampe
 	UtilityHNS::UtilityH::GetTickCount(m_VehicleState.tStamp);
 }
 
-void way_planner_core::callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
+void way_planner_core::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &amp;msg)
 {
 	m_VehicleState.speed = msg-&gt;speed/3.6;
 	m_VehicleState.steer = msg-&gt;angle * 0.45 / 660;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -48,7 +48,7 @@
 #include &lt;std_msgs/Int32.h&gt;
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "autoware_msgs/LaneArray.h"
-#include "autoware_msgs/CanInfo.h"
+#include "autoware_can_msgs/CANInfo.h"
 
 #include "autoware_msgs/CloudCluster.h"
 #include "autoware_msgs/CloudClusterArray.h"
@@ -214,7 +214,7 @@ protected:
 	void callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr&amp; msg);
 	void callbackGetBoundingBoxes(const jsk_recognition_msgs::BoundingBoxArrayConstPtr&amp; msg);
 	void callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr&amp; msg);
-	void callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg);
+	void callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &amp;msg);
 	void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg);
 	void callbackGetEmergencyStop(const std_msgs::Int8&amp; msg);
 	void callbackGetTrafficLight(const std_msgs::Int8&amp; msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -140,7 +140,7 @@ PlannerX::PlannerX()
 	else if(bVelSource == 1)
 		sub_current_velocity 	= nh.subscribe("/current_velocity",		100,	&amp;PlannerX::callbackGetVehicleStatus, 	this);
 	else if(bVelSource == 2)
-		sub_can_info 			= nh.subscribe("/can_info",		100,	&amp;PlannerX::callbackGetCanInfo, 	this);
+		sub_can_info 			= nh.subscribe("/can_info",		100,	&amp;PlannerX::callbackGetCANInfo, 	this);
 
 
 
@@ -449,7 +449,7 @@ void PlannerX::callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPt
 	//std::cout &lt;&lt; "PlannerX: Read Status Twist_cmd ("&lt;&lt; m_VehicleState.speed &lt;&lt; ", " &lt;&lt; m_VehicleState.steer&lt;&lt;")" &lt;&lt; std::endl;
 }
 
-void PlannerX::callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
+void PlannerX::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &amp;msg)
 {
 	m_VehicleState.speed = msg-&gt;speed/3.6;
 	m_VehicleState.steer = msg-&gt;angle * m_LocalPlanner.m_CarInfo.max_steer_angle / m_LocalPlanner.m_CarInfo.max_steer_value;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_trajectory_gen\lattice_trajectory_gen.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_trajectory_gen\lattice_trajectory_gen.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -52,7 +52,7 @@
 #include "autoware_config_msgs/ConfigWaypointFollower.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "libtraj_gen.h"
-#include "autoware_msgs/CanInfo.h"
+#include "autoware_can_msgs/CANInfo.h"
 //#include &lt;dbw_mkz_msgs/SteeringReport.h&gt;
 
 
@@ -165,7 +165,7 @@ static double getLookAheadThreshold(int waypoint)
     return current_velocity_mps * g_look_ahead_threshold_calc_ratio;
 }
 
-static void canInfoCallback(const autoware_msgs::CanInfoConstPtr &amp;msg)
+static void canInfoCallback(const autoware_can_msgs::CANInfoConstPtr &amp;msg)
 {
   double steering_wheel_angle = msg-&gt;angle;
   //g_current_velocity = (msg-&gt;speed)*(1000.00/3600);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_behavior_selector_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_behavior_selector_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -53,7 +53,7 @@
 #include &lt;autoware_msgs/LaneArray.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 #include &lt;geometry_msgs/TwistWithCovarianceStamped.h&gt;
-#include &lt;autoware_msgs/CanInfo.h&gt;
+#include &lt;autoware_can_msgs/CANInfo.h&gt;
 #include &lt;autoware_msgs/DetectedObjectArray.h&gt;
 #include &lt;autoware_msgs/TrafficLight.h&gt;
 #include &lt;autoware_msgs/Signals.h&gt;
@@ -145,7 +145,7 @@ protected: //Planning Related variables
 	// Callback function for subscriber.
 	void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg);
 	void callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr&amp; msg);
-	void callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg);
+	void callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &amp;msg);
 	void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg);
 	void callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp; msg);
 	void callbackGetLocalPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp; msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_motion_predictor_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_motion_predictor_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -52,7 +52,7 @@
 #include &lt;geometry_msgs/PointStamped.h&gt;
 #include &lt;nav_msgs/Odometry.h&gt;
 #include &lt;autoware_msgs/LaneArray.h&gt;
-#include &lt;autoware_msgs/CanInfo.h&gt;
+#include &lt;autoware_can_msgs/CANInfo.h&gt;
 #include &lt;autoware_msgs/DetectedObjectArray.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
@@ -129,7 +129,7 @@ protected:
 	void callbackGetTrackedObjects(const autoware_msgs::DetectedObjectArrayConstPtr&amp; msg);
 	void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg);
 	void callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr&amp; msg);
-	void callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg);
+	void callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &amp;msg);
 	void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg);
 	void callbackGetStepForwardSignals(const geometry_msgs::TwistStampedConstPtr&amp; msg);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_trajectory_evaluator_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_trajectory_evaluator_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -39,7 +39,7 @@
 #include &lt;geometry_msgs/PoseArray.h&gt;
 #include &lt;nav_msgs/Odometry.h&gt;
 #include &lt;autoware_msgs/LaneArray.h&gt;
-#include &lt;autoware_msgs/CanInfo.h&gt;
+#include &lt;autoware_can_msgs/CANInfo.h&gt;
 #include &lt;autoware_msgs/DetectedObjectArray.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
@@ -115,7 +115,7 @@ protected:
 	// Callback function for subscriber.
 	void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg);
 	void callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr&amp; msg);
-	void callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg);
+	void callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &amp;msg);
 	void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg);
 	void callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp; msg);
 	void callbackGetLocalPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp; msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_trajectory_generator_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_trajectory_generator_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -39,7 +39,7 @@
 #include &lt;geometry_msgs/PoseArray.h&gt;
 #include &lt;nav_msgs/Odometry.h&gt;
 #include &lt;autoware_msgs/LaneArray.h&gt;
-#include &lt;autoware_msgs/CanInfo.h&gt;
+#include &lt;autoware_can_msgs/CANInfo.h&gt;
 
 #include "op_planner/PlannerH.h"
 #include "op_planner/PlannerCommonDef.h"
@@ -93,7 +93,7 @@ protected:
 	void callbackGetInitPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;input);
 	void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg);
 	void callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr&amp; msg);
-	void callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg);
+	void callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &amp;msg);
 	void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg);
 	void callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp; msg);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -73,7 +73,7 @@ BehaviorGen::BehaviorGen()
 	else if(bVelSource == 1)
 		sub_current_velocity = nh.subscribe("/current_velocity", 10, &amp;BehaviorGen::callbackGetVehicleStatus, this);
 	else if(bVelSource == 2)
-		sub_can_info = nh.subscribe("/can_info", 10, &amp;BehaviorGen::callbackGetCanInfo, this);
+		sub_can_info = nh.subscribe("/can_info", 10, &amp;BehaviorGen::callbackGetCANInfo, this);
 
 	sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 1, &amp;BehaviorGen::callbackGetGlobalPlannerPath, this);
 	sub_LocalPlannerPaths = nh.subscribe("/local_weighted_trajectories", 1, &amp;BehaviorGen::callbackGetLocalPlannerPath, this);
@@ -213,7 +213,7 @@ void BehaviorGen::callbackGetVehicleStatus(const geometry_msgs::TwistStampedCons
 	bVehicleStatus = true;
 }
 
-void BehaviorGen::callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
+void BehaviorGen::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &amp;msg)
 {
 	m_VehicleStatus.speed = msg-&gt;speed/3.6;
 	m_CurrentPos.v = m_VehicleStatus.speed;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -71,7 +71,7 @@ MotionPrediction::MotionPrediction()
 	else if(bVelSource == 1)
 		sub_current_velocity = nh.subscribe("/current_velocity", 10, &amp;MotionPrediction::callbackGetVehicleStatus, this);
 	else if(bVelSource == 2)
-		sub_can_info = nh.subscribe("/can_info", 10, &amp;MotionPrediction::callbackGetCanInfo, this);
+		sub_can_info = nh.subscribe("/can_info", 10, &amp;MotionPrediction::callbackGetCANInfo, this);
 
 	UtilityHNS::UtilityH::GetTickCount(m_VisualizationTimer);
 	PlannerHNS::RosHelpers::InitPredMarkers(100, m_PredictedTrajectoriesDummy);
@@ -195,7 +195,7 @@ void MotionPrediction::callbackGetVehicleStatus(const geometry_msgs::TwistStampe
 	bVehicleStatus = true;
 }
 
-void MotionPrediction::callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
+void MotionPrediction::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &amp;msg)
 {
 	m_VehicleStatus.speed = msg-&gt;speed/3.6;
 	m_VehicleStatus.steer = msg-&gt;angle * m_CarInfo.max_steer_angle / m_CarInfo.max_steer_value;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_evaluator\op_trajectory_evaluator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_evaluator\op_trajectory_evaluator_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -67,7 +67,7 @@ TrajectoryEval::TrajectoryEval()
 	else if(bVelSource == 1)
 		sub_current_velocity = nh.subscribe("/current_velocity", 10, &amp;TrajectoryEval::callbackGetVehicleStatus, this);
 	else if(bVelSource == 2)
-		sub_can_info = nh.subscribe("/can_info", 10, &amp;TrajectoryEval::callbackGetCanInfo, this);
+		sub_can_info = nh.subscribe("/can_info", 10, &amp;TrajectoryEval::callbackGetCANInfo, this);
 
 	sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 1, &amp;TrajectoryEval::callbackGetGlobalPlannerPath, this);
 	sub_LocalPlannerPaths = nh.subscribe("/local_trajectories", 1, &amp;TrajectoryEval::callbackGetLocalPlannerPath, this);
@@ -146,7 +146,7 @@ void TrajectoryEval::callbackGetVehicleStatus(const geometry_msgs::TwistStampedC
 	bVehicleStatus = true;
 }
 
-void TrajectoryEval::callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
+void TrajectoryEval::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &amp;msg)
 {
 	m_VehicleStatus.speed = msg-&gt;speed/3.6;
 	m_CurrentPos.v = m_VehicleStatus.speed;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -64,7 +64,7 @@ TrajectoryGen::TrajectoryGen()
 	else if(bVelSource == 1)
 		sub_current_velocity = nh.subscribe("/current_velocity", 10, &amp;TrajectoryGen::callbackGetVehicleStatus, this);
 	else if(bVelSource == 2)
-		sub_can_info = nh.subscribe("/can_info", 10, &amp;TrajectoryGen::callbackGetCanInfo, this);
+		sub_can_info = nh.subscribe("/can_info", 10, &amp;TrajectoryGen::callbackGetCANInfo, this);
 
 	sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 1, &amp;TrajectoryGen::callbackGetGlobalPlannerPath, this);
 }
@@ -158,7 +158,7 @@ void TrajectoryGen::callbackGetVehicleStatus(const geometry_msgs::TwistStampedCo
 	bVehicleStatus = true;
 }
 
-void TrajectoryGen::callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
+void TrajectoryGen::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &amp;msg)
 {
 	m_VehicleStatus.speed = msg-&gt;speed/3.6;
 	m_VehicleStatus.steer = msg-&gt;angle * m_CarInfo.max_steer_angle / m_CarInfo.max_steer_value;
</diff>
			</file>
			<file old_path="ros\src\data\packages\obj_db\nodes\can_uploader\can_uploader.cpp" new_path="ros\src\data\packages\obj_db\nodes\can_uploader\can_uploader.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -48,7 +48,7 @@
 
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/String.h&gt;
-#include "autoware_msgs/CanInfo.h"
+#include "autoware_can_msgs/CANInfo.h"
 
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
@@ -113,7 +113,7 @@ static void* intervalCall(void *unused)
   return nullptr;
 }
 
-static void can_infoCallback(const autoware_msgs::CanInfo&amp; can)
+static void can_infoCallback(const autoware_can_msgs::CANInfo&amp; can)
 {
   ostringstream oss;
 
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\can\packages\kvaser\nodes\can_converter\can_converter.cpp" new_path="ros\src\sensing\drivers\can\packages\kvaser\nodes\can_converter\can_converter.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -1,8 +1,8 @@
 #include &lt;ros/ros.h&gt;
-#include "autoware_msgs/CANPacket.h"
+#include "autoware_can_msgs/CANPacket.h"
 
 
-void chatterCallback(const autoware_msgs::CANPacket::ConstPtr&amp; msg)
+void chatterCallback(const autoware_can_msgs::CANPacket::ConstPtr&amp; msg)
 {
   unsigned short w;
   static int enc_sum;
@@ -81,7 +81,7 @@ void chatterCallback(const autoware_msgs::CANPacket::ConstPtr&amp; msg)
 
 
 int main (int argc, char *argv[]){
-  autoware_msgs::CANPacket candat;
+  autoware_can_msgs::CANPacket candat;
 
   ros::init(argc, argv, "can_converter");
   ros::NodeHandle n;
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\can\packages\kvaser\nodes\can_draw\can_draw.cpp" new_path="ros\src\sensing\drivers\can\packages\kvaser\nodes\can_draw\can_draw.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -1,5 +1,5 @@
 #include &lt;ros/ros.h&gt;
-#include "autoware_msgs/CANPacket.h"
+#include "autoware_can_msgs/CANPacket.h"
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
@@ -7,7 +7,7 @@
 ros::Publisher pub;
 double g_steer,g_speed;
 
-void chatterCallback(const autoware_msgs::CANPacket::ConstPtr&amp; msg)
+void chatterCallback(const autoware_can_msgs::CANPacket::ConstPtr&amp; msg)
 {
   unsigned short w;
   static int enc_sum;
@@ -85,7 +85,7 @@ void chatterCallback(const autoware_msgs::CANPacket::ConstPtr&amp; msg)
 
 
 int main (int argc, char *argv[]){
-  autoware_msgs::CANPacket candat;
+  autoware_can_msgs::CANPacket candat;
 
   ros::init(argc, argv, "can_draw");
   ros::NodeHandle n;
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\can\packages\kvaser\nodes\can_listener\can_listener.cpp" new_path="ros\src\sensing\drivers\can\packages\kvaser\nodes\can_listener\can_listener.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -62,7 +62,7 @@
 #include &lt;unistd.h&gt;
 #include &lt;time.h&gt;
 #include &lt;ros/ros.h&gt;
-#include "autoware_msgs/CANPacket.h"
+#include "autoware_can_msgs/CANPacket.h"
 
 int i = 0;
 unsigned char willExit = 0;
@@ -94,12 +94,12 @@ int main (int argc, char *argv[])
   int channel = 0;
   int bitrate = BAUD_500K;
   int j;
-	autoware_msgs::CANPacket candat;
+	autoware_can_msgs::CANPacket candat;
 
   ros::init(argc, argv, "can_listener");
   ros::NodeHandle n;
  
-  ros::Publisher can_pub = n.advertise&lt;autoware_msgs::CANPacket&gt;("can_raw", 10);
+  ros::Publisher can_pub = n.advertise&lt;autoware_can_msgs::CANPacket&gt;("can_raw", 10);
 
   errno = 0;
   if (argc != 2 || (channel = atoi(argv[1]), errno) != 0) {
</diff>
			</file>
			<file old_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_sender\mqtt_sender.cpp" new_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_sender\mqtt_sender.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -43,7 +43,7 @@
 #include &lt;yaml-cpp/yaml.h&gt;
 using namespace std;
 #include "mqtt_socket/mqtt_setting.hpp"
-#include "autoware_msgs/CanInfo.h"
+#include "autoware_can_msgs/CANInfo.h"
 #include &lt;tablet_socket_msgs/mode_info.h&gt;
 
 class MqttSender
@@ -51,7 +51,7 @@ class MqttSender
 public:
   MqttSender();
   ~MqttSender();
-  void canInfoCallback(const autoware_msgs::CanInfoConstPtr &amp;msg);
+  void canInfoCallback(const autoware_can_msgs::CANInfoConstPtr &amp;msg);
   static void on_connect(struct mosquitto *mosq, void *obj, int result);
   static void on_disconnect(struct mosquitto *mosq, void *obj, int rc);
   static void on_publish(struct mosquitto *mosq, void *userdata, int mid);
@@ -272,7 +272,7 @@ void MqttSender::modeInfoCallback(const tablet_socket_msgs::mode_info&amp; msg)
   }
 }
 
-void MqttSender::canInfoCallback(const autoware_msgs::CanInfoConstPtr &amp;msg)
+void MqttSender::canInfoCallback(const autoware_can_msgs::CANInfoConstPtr &amp;msg)
 {
 
   if(can_info_callback_counter_ &gt; caninfo_downsample * 100) {
</diff>
			</file>
			<file old_path="ros\src\socket\packages\tablet_socket\nodes\tablet_sender\tablet_sender.cpp" new_path="ros\src\socket\packages\tablet_socket\nodes\tablet_sender\tablet_sender.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -39,7 +39,7 @@
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;tablet_socket_msgs/error_info.h&gt;
 #include &lt;tablet_socket_msgs/mode_info.h&gt;
-#include "autoware_msgs/CanInfo.h"
+#include "autoware_can_msgs/CANInfo.h"
 #include "autoware_msgs/NDTStat.h"
 
 static constexpr int DEFAULT_PORT = 5777;
@@ -71,7 +71,7 @@ struct can_request {
 	int32_t type;
 	int32_t driveshift;
 
-	can_request(const autoware_msgs::CanInfo&amp; msg)
+	can_request(const autoware_can_msgs::CANInfo&amp; msg)
 	: type(CAN_INFO_TYPE), driveshift(msg.driveshift) {
 	}
 };
@@ -148,7 +148,7 @@ static void subscribe_error_info(const tablet_socket_msgs::error_info&amp; msg)
 	}
 }
 
-static void subscribe_can_info(const autoware_msgs::CanInfo&amp; msg)
+static void subscribe_can_info(const autoware_can_msgs::CANInfo&amp; msg)
 {
 	can_request request(msg);
 	int response;
</diff>
			</file>
			<file old_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_receiver\vehicle_receiver.cpp" new_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_receiver\vehicle_receiver.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -30,7 +30,7 @@
 
 #include &lt;ros/ros.h&gt;
 #include &lt;tablet_socket_msgs/mode_info.h&gt;
-#include "autoware_msgs/CanInfo.h"
+#include "autoware_can_msgs/CANInfo.h"
 
 #include &lt;netinet/in.h&gt;
 #include &lt;pthread.h&gt;
@@ -58,7 +58,7 @@ static ros::Publisher can_pub;
 static ros::Publisher mode_pub;
 static int mode;
 
-static bool parseCanValue(const std::string &amp;can_data, autoware_msgs::CanInfo &amp;msg)
+static bool parseCanValue(const std::string &amp;can_data, autoware_can_msgs::CANInfo &amp;msg)
 {
   std::istringstream ss(can_data);
   std::vector&lt;std::string&gt; columns;
@@ -167,7 +167,7 @@ static void *getCanValue(void *arg)
   if (can_data.empty())
     return nullptr;
 
-  autoware_msgs::CanInfo can_msg;
+  autoware_can_msgs::CANInfo can_msg;
   bool ret = parseCanValue(can_data, can_msg);
   if (!ret)
     return nullptr;
@@ -261,7 +261,7 @@ int main(int argc, char **argv)
 
   std::cout &lt;&lt; "vehicle receiver" &lt;&lt; std::endl;
 
-  can_pub = nh.advertise&lt;autoware_msgs::CanInfo&gt;("can_info", 100);
+  can_pub = nh.advertise&lt;autoware_can_msgs::CANInfo&gt;("can_info", 100);
   mode_pub = nh.advertise&lt;tablet_socket_msgs::mode_info&gt;("mode_info", 100);
 
   pthread_t th;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="119cc43278392461e377d8f83b7d5f474691e571" author="Kenji Funaoka">
		<msg>Fix compile error (vision_darknet_detect.h:52:37: fatal error: autoware_msgs/ConfigSsd.h: No such file or directory)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.h" added_lines="1" deleted_lines="1">
				<diff>@@ -49,7 +49,7 @@
 
 #include &lt;cv_bridge/cv_bridge.h&gt;
 
-#include &lt;autoware_msgs/ConfigSsd.h&gt;
+#include &lt;autoware_config_msgs/ConfigSsd.h&gt;
 #include &lt;autoware_msgs/DetectedObject.h&gt;
 #include &lt;autoware_msgs/DetectedObjectArray.h&gt;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="31d4f6a802276a736e91caf5e286618aec594e90" author="Esteve Fernandez">
		<msg>Use stubs for the CUDA libraries. Ignore undefined symbols errors in autoware_driveworks_interface. Support Docker volumes for CUDA, Driveworks and TensorRT.</msg>
		<modified_files>
			<file old_path="ros\cross_toolchain_driveworks.cmake" new_path="ros\cross_toolchain_driveworks.cmake" added_lines="9" deleted_lines="9">
				<diff>@@ -37,16 +37,16 @@ set(CUDA_TOOLKIT_TARGET_DIR_INTERNAL "${CUDA_TOOLKIT_TARGET_DIR}" CACHE STRING "
 set(CUDA_TOOLKIT_INCLUDE "${CUDA_TOOLKIT_TARGET_DIR}/include/" CACHE STRING "" FORCE)
 
 set(CUDA_CUDA_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/stubs/libcuda.so" CACHE STRING "" FORCE)
-set(CUDA_CUDART_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/libcudart.so" CACHE STRING "" FORCE)
+set(CUDA_CUDART_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/stubs/libcudart.so" CACHE STRING "" FORCE)
 set(CUDA_cudart_static_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/libcudart_static.a" CACHE STRING "" FORCE)
-set(CUDA_cublas_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/libcublas.so" CACHE STRING "" FORCE)
-set(CUDA_cublasemu_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/libcublasemu.so" CACHE STRING "" FORCE)
-set(CUDA_cufft_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/libcufft.so" CACHE STRING "" FORCE)
-set(CUDA_cufftemu_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/libcufftemu.so" CACHE STRING "" FORCE)
-set(CUDA_cupti_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/libcupti.so" CACHE STRING "" FORCE)
-set(CUDA_curand_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/libcurand.so" CACHE STRING "" FORCE)
-set(CUDA_cusolver_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/libcusolver.so" CACHE STRING "" FORCE)
-set(CUDA_cusparse_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/libcusparse.so" CACHE STRING "" FORCE)
+set(CUDA_cublas_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/stubs/libcublas.so" CACHE STRING "" FORCE)
+set(CUDA_cublasemu_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/stubs/libcublasemu.so" CACHE STRING "" FORCE)
+set(CUDA_cufft_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/stubs/libcufft.so" CACHE STRING "" FORCE)
+set(CUDA_cufftemu_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/stubs/libcufftemu.so" CACHE STRING "" FORCE)
+set(CUDA_cupti_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/stubs/libcupti.so" CACHE STRING "" FORCE)
+set(CUDA_curand_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/stubs/libcurand.so" CACHE STRING "" FORCE)
+set(CUDA_cusolver_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/stubs/libcusolver.so" CACHE STRING "" FORCE)
+set(CUDA_cusparse_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/stubs/libcusparse.so" CACHE STRING "" FORCE)
 set(CUDA_npp_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/libnpp.so" CACHE STRING "" FORCE)
 set(CUDA_nppc_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/libnppc.so" CACHE STRING "" FORCE)
 set(CUDA_nppi_LIBRARY "${CUDA_TOOLKIT_TARGET_DIR}/lib/libnppi.so" CACHE STRING "" FORCE)
</diff>
			</file>
		</modified_files>
	</commit>
</Root>
