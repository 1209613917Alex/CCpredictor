<?xml version="1.0" encoding="utf-8"?>
<Root>
	<commit hash="330f0157708d3eef4981da0ababae41a60dcf28a" author="Abraham Monrroy">
		<msg>-Added support fot VMap colouring to Left Traffic signals (#988)

-Added Lane number on tlr_superimpose</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" added_lines="3" deleted_lines="1">
				<diff>@@ -92,7 +92,7 @@ static void putResult_inText(cv::Mat *image, const std::vector&lt;Context&gt; &amp;context
 {
 	std::string label;
 	const int fontFace = cv::FONT_HERSHEY_COMPLEX_SMALL;
-	const float fontScale = 1.0f;
+	const float fontScale = 0.8f;
 	const int fontThickness = 1;
 	int baseline = 0;
 	CvPoint textOrg;
@@ -130,6 +130,8 @@ static void putResult_inText(cv::Mat *image, const std::vector&lt;Context&gt; &amp;context
 		{
 			label += " RIGHT";
 		}
+		//add lane # text
+		label +=" " + std::to_string(ctx.closestLaneId);
 
 		cv::getTextSize(label,
 		                fontFace,
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.cpp" added_lines="12" deleted_lines="1">
				<diff>@@ -409,7 +409,7 @@ void RegionTlrSsdRosNode::PublishImage(std::vector&lt;Context&gt; contexts) {
   // Define information for written label
   std::string  label;
   const int    kFontFace      = cv::FONT_HERSHEY_COMPLEX_SMALL;
-  const double kFontScale     = 1.0;
+  const double kFontScale     = 0.8;
   int          font_baseline  = 0;
   CvScalar     label_color;
 
@@ -438,6 +438,17 @@ void RegionTlrSsdRosNode::PublishImage(std::vector&lt;Context&gt; contexts) {
       label_color = CV_RGB(0, 0, 0);
     }
 
+    if (ctx.leftTurnSignal)
+    {
+      label += " LEFT";
+    }
+    if (ctx.rightTurnSignal)
+    {
+      label += " RIGHT";
+    }
+    //add lane # text
+    label +=" " + std::to_string(ctx.closestLaneId);
+
     cv::Point label_origin = cv::Point(ctx.topLeft.x, ctx.botRight.y + font_baseline);
 
     cv::putText(result_image, label, label_origin, kFontFace, kFontScale, label_color);
</diff>
			</file>
			<file old_path="ros\src\data\packages\map_file\nodes\vector_map_loader\vector_map_loader.cpp" new_path="ros\src\data\packages\map_file\nodes\vector_map_loader\vector_map_loader.cpp" added_lines="10" deleted_lines="1">
				<diff>@@ -537,12 +537,21 @@ visualization_msgs::MarkerArray createSignalMarkerArray(const VectorMap&amp; vmap, C
     case Signal::YELLOW:
       vector_marker = createVectorMarker("signal", id++, yellow_color, vmap, vector);
       break;
+    case Signal::RED_LEFT:
+      vector_marker = createVectorMarker("signal", id++, Color::LIGHT_RED, vmap, vector);
+          break;
+    case Signal::BLUE_LEFT:
+      vector_marker = createVectorMarker("signal", id++, Color::LIGHT_GREEN, vmap, vector);
+          break;
+    case Signal::YELLOW_LEFT:
+      vector_marker = createVectorMarker("signal", id++, Color::LIGHT_YELLOW, vmap, vector);
+          break;
     case Signal::OTHER:
       vector_marker = createVectorMarker("signal", id++, other_color, vmap, vector);
       break;
     default:
       ROS_WARN_STREAM("[createSignalMarkerArray] unknown signal.type: " &lt;&lt; signal.type &lt;&lt; " Creating Marker as OTHER.");
-      vector_marker = createVectorMarker("signal", id++, other_color, vmap, vector);
+      vector_marker = createVectorMarker("signal", id++, Color::GRAY, vmap, vector);
       break;
     }
     if (isValidMarker(vector_marker))
</diff>
			</file>
			<file old_path="ros\src\data\packages\vector_map_server\nodes\vector_map_client\vector_map_client.cpp" new_path="ros\src\data\packages\vector_map_server\nodes\vector_map_client\vector_map_client.cpp" added_lines="10" deleted_lines="1">
				<diff>@@ -233,11 +233,20 @@ int main(int argc, char **argv)
         case Signal::YELLOW:
           vector_marker = createVectorMarker("signal", id++, Color::YELLOW, vmap, vector);
           break;
+        case Signal::RED_LEFT:
+          vector_marker = createVectorMarker("signal", id++, Color::LIGHT_RED, vmap, vector);
+          break;
+        case Signal::BLUE_LEFT:
+          vector_marker = createVectorMarker("signal", id++, Color::LIGHT_GREEN, vmap, vector);
+          break;
+        case Signal::YELLOW_LEFT:
+          vector_marker = createVectorMarker("signal", id++, Color::LIGHT_YELLOW, vmap, vector);
+          break;
         case Signal::OTHER:
           vector_marker = createVectorMarker("signal", id++, Color::CYAN, vmap, vector);
           break;
         default:
-          vector_marker = createVectorMarker("signal", id++, Color::CYAN, vmap, vector);
+          vector_marker = createVectorMarker("signal", id++, Color::GRAY, vmap, vector);
           break;
         }
         if (isValidMarker(vector_marker))
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="734817d97e9078045c7b4ae3bda49db239b283dc" author="Yamato ANDO">
		<msg>even though the ID of the ADAS map does not start with #1, it has been modified to work properly</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -309,9 +309,9 @@ void echoSignals2(ros::Publisher &amp;pub, bool useOpenGLCoord = false)
 		}
 	}
 
-	for (unsigned int i = 1; i &lt;= vmap.signals.size(); i++)
+	for (const auto&amp; signal_map : vmap.signals)
 	{
-		Signal signal = vmap.signals[i];
+		const Signal signal = signal_map.second;
 		int pid = vmap.vectors[signal.vid].pid;
 
 		Point3 signalcenter = vmap.getPoint(pid);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7ba39b273ce889ac5b2a8113028c3af4f95efa85" author="Yamato ANDO">
		<msg>fix previous_gnss_pose does not set when first initial pose (#983)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="5" deleted_lines="2">
				<diff>@@ -105,8 +105,7 @@ struct pose
 };
 
 static pose initial_pose, predict_pose, predict_pose_imu, predict_pose_odom, predict_pose_imu_odom, previous_pose,
-    ndt_pose, current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, localizer_pose,
-    previous_gnss_pose, current_gnss_pose;
+    ndt_pose, current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, localizer_pose;
 
 static double offset_x, offset_y, offset_z, offset_yaw;  // current_pos - previous_pose
 static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
@@ -534,11 +533,15 @@ static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
   tf::Quaternion gnss_q(input-&gt;pose.orientation.x, input-&gt;pose.orientation.y, input-&gt;pose.orientation.z,
                         input-&gt;pose.orientation.w);
   tf::Matrix3x3 gnss_m(gnss_q);
+
+  pose current_gnss_pose;
   current_gnss_pose.x = input-&gt;pose.position.x;
   current_gnss_pose.y = input-&gt;pose.position.y;
   current_gnss_pose.z = input-&gt;pose.position.z;
   gnss_m.getRPY(current_gnss_pose.roll, current_gnss_pose.pitch, current_gnss_pose.yaw);
 
+  static pose previous_gnss_pose = current_gnss_pose;
+
   if ((_use_gnss == 1 &amp;&amp; init_pos_set == 0) || fitness_score &gt;= 500.0)
   {
     previous_pose.x = previous_gnss_pose.x;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a00083276448ed57a7d5b742558e0836ddf4fc6b" author="Yamato ANDO">
		<msg>refactor code</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="39" deleted_lines="44">
				<diff>@@ -272,20 +272,19 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
       gpu_ndt_ptr-&gt;setResolution(ndt_res);
     }
     else
-    {
 #endif
-		if (_use_fast_pcl)
-		{
-          cpu_ndt.setResolution(ndt_res);
-		}
-		else
-		{
-          ndt.setResolution(ndt_res);
-		}
-#ifdef CUDA_FOUND
+    {
+	  if (_use_fast_pcl)
+	  {
+        cpu_ndt.setResolution(ndt_res);
+	  }
+	  else
+	  {
+        ndt.setResolution(ndt_res);
+	  }
     }
-#endif
   }
+
   if (input-&gt;step_size != step_size)
   {
     step_size = input-&gt;step_size;
@@ -295,20 +294,19 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
       gpu_ndt_ptr-&gt;setStepSize(step_size);
     }
     else
-    {
 #endif
-		if (_use_fast_pcl)
-		{
-          cpu_ndt.setStepSize(step_size);
-		}
-		else
-		{
-          ndt.setStepSize(step_size);
-		}
-#ifdef CUDA_FOUND
+    {
+	  if (_use_fast_pcl)
+	  {
+        cpu_ndt.setStepSize(step_size);
+	  }
+	  else
+	  {
+        ndt.setStepSize(step_size);
+	  }
     }
-#endif
   }
+
   if (input-&gt;trans_epsilon != trans_eps)
   {
     trans_eps = input-&gt;trans_epsilon;
@@ -318,20 +316,19 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
       gpu_ndt_ptr-&gt;setTransformationEpsilon(trans_eps);
     }
     else
-    {
 #endif
-		if (_use_fast_pcl)
-		{
-          cpu_ndt.setTransformationEpsilon(trans_eps);
-		}
-		else
-		{
-          ndt.setTransformationEpsilon(trans_eps);
-		}
-#ifdef CUDA_FOUND
+    {
+	  if (_use_fast_pcl)
+	  {
+        cpu_ndt.setTransformationEpsilon(trans_eps);
+	  }
+	  else
+	  {
+        ndt.setTransformationEpsilon(trans_eps);
+	  }
     }
-#endif
   }
+
   if (input-&gt;max_iterations != max_iter)
   {
     max_iter = input-&gt;max_iterations;
@@ -341,19 +338,17 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
       gpu_ndt_ptr-&gt;setMaximumIterations(max_iter);
     }
     else
-    {
 #endif
-		if (_use_fast_pcl)
-		{
-          cpu_ndt.setMaximumIterations(max_iter);
-		}
-		else
-		{
-          ndt.setMaximumIterations(max_iter);
-		}
-#ifdef CUDA_FOUND
+    {
+	  if (_use_fast_pcl)
+	  {
+        cpu_ndt.setMaximumIterations(max_iter);
+	  }
+	  else
+	  {
+        ndt.setMaximumIterations(max_iter);
+	  }
     }
-#endif
   }
 
   if (_use_gnss == 0 &amp;&amp; init_pos_set == 0)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3278199c45450f889bda695612b9daecab4c0b79" author="yukikitsukawa">
		<msg>add new param to change the scan number in tf_mapping.launch</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\tf_mapping\tf_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\tf_mapping\tf_mapping.cpp" added_lines="4" deleted_lines="1">
				<diff>@@ -23,6 +23,7 @@
 static std::string PARENT_FRAME;
 static std::string CHILD_FRAME;
 static std::string POINTS_TOPIC;
+static int SCAN_NUM;
 static std::string OUTPUT_DIR;
 
 static pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; map;
@@ -138,7 +139,7 @@ void points_callback(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr &amp;input)
     }
     std::cout &lt;&lt; "Wrote " &lt;&lt; pcl_out.size() &lt;&lt; " points to " &lt;&lt; filename &lt;&lt; "." &lt;&lt; std::endl;
     added_scan_num++;
-    if(added_scan_num == 300)
+    if(added_scan_num == SCAN_NUM)
     {
       added_scan_num = 0;
       map_id++;
@@ -155,11 +156,13 @@ int main(int argc, char **argv)
   private_nh.getParam("parent_frame", PARENT_FRAME);
   private_nh.getParam("child_frame", CHILD_FRAME);
   private_nh.getParam("points_topic", POINTS_TOPIC);
+  private_nh.getParam("scan_num", SCAN_NUM);
   private_nh.getParam("output_dir", OUTPUT_DIR);
 
   std::cout &lt;&lt; "parent_frame: " &lt;&lt; PARENT_FRAME &lt;&lt; std::endl;
   std::cout &lt;&lt; "child_frame: " &lt;&lt; CHILD_FRAME &lt;&lt; std::endl;
   std::cout &lt;&lt; "points_topic: " &lt;&lt; POINTS_TOPIC &lt;&lt; std::endl;
+  std::cout &lt;&lt; "scan_num: " &lt;&lt; SCAN_NUM &lt;&lt; std::endl;
   std::cout &lt;&lt; "output_dir: " &lt;&lt; OUTPUT_DIR &lt;&lt; std::endl;
 
   tf_listener = new tf::TransformListener();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2237ff544e2d90235d795360b9dadeba389aca75" author="anhnv3991">
		<msg>Fix crash on NDt mapping gpu</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" added_lines="7" deleted_lines="7">
				<diff>@@ -529,7 +529,7 @@ __global__ void computeHessianListS0(float *trans_x, float *trans_y, float *tran
 													double *icov00, double *icov01, double *icov02,
 													double *icov10, double *icov11, double *icov12,
 													double *icov20, double *icov21, double *icov22,
-													double *point_gradients0, double *point_gradients1, double *point_gradients2,
+													double *point_gradients,
 													double *tmp_hessian,
 													int valid_voxel_num)
 {
@@ -538,12 +538,12 @@ __global__ void computeHessianListS0(float *trans_x, float *trans_y, float *tran
 	int col = blockIdx.y;
 
 	if (col &lt; 6) {
-		double *tmp_pg0 = point_gradients0 + col * valid_points_num;
-		double *tmp_pg1 = point_gradients1 + 6 * valid_points_num;
-		double *tmp_pg2 = point_gradients2 + 6 * valid_points_num;
+		double *tmp_pg0 = point_gradients + col * valid_points_num;
+		double *tmp_pg1 = tmp_pg0 + 6 * valid_points_num;
+		double *tmp_pg2 = tmp_pg1 + 6 * valid_points_num;
 		double *tmp_h = tmp_hessian + col * valid_voxel_num;
 
-		for (int i = id; i &lt; valid_points_num &amp;&amp; col &lt; 6; i += stride) {
+		for (int i = id; i &lt; valid_points_num; i += stride) {
 			int pid = valid_points[i];
 			double d_x = static_cast&lt;double&gt;(trans_x[pid]);
 			double d_y = static_cast&lt;double&gt;(trans_y[pid]);
@@ -876,7 +876,7 @@ double GNormalDistributionsTransform::computeDerivatives(Eigen::Matrix&lt;double, 6
 												inverse_covariance, inverse_covariance + voxel_num, inverse_covariance + 2 * voxel_num,
 												inverse_covariance + 3 * voxel_num, inverse_covariance + 4 * voxel_num, inverse_covariance + 5 * voxel_num,
 												inverse_covariance + 6 * voxel_num, inverse_covariance + 7 * voxel_num, inverse_covariance + 8 * voxel_num,
-												point_gradients, point_gradients + 6 * valid_points_num, point_gradients + 12 * valid_points_num,
+												point_gradients,
 												tmp_hessian, valid_voxel_num);
 		checkCudaErrors(cudaGetLastError());
 		grid.z = 6;
@@ -1495,7 +1495,7 @@ void GNormalDistributionsTransform::computeHessian(Eigen::Matrix&lt;double, 6, 6&gt; &amp;
 												inverse_covariance, inverse_covariance + voxel_num, inverse_covariance + 2 * voxel_num,
 												inverse_covariance + 3 * voxel_num, inverse_covariance + 4 * voxel_num, inverse_covariance + 5 * voxel_num,
 												inverse_covariance + 6 * voxel_num, inverse_covariance + 7 * voxel_num, inverse_covariance + 8 * voxel_num,
-												point_gradients, point_gradients + 6 * valid_points_num, point_gradients + 12 * valid_points_num,
+												point_gradients,
 												tmp_hessian, valid_voxel_num);
 	checkCudaErrors(cudaGetLastError());
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9e76a8a8b4d211557c493a713c6e6ed8eac0104d" author="anhnv3991">
		<msg>Reduce the number of register used in the computePointGradients kernel, which may cause crash when running on old GPU.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" added_lines="76" deleted_lines="13">
				<diff>@@ -140,6 +140,30 @@ void GNormalDistributionsTransform::setInputTarget(pcl::PointCloud&lt;pcl::PointXYZ
 	}
 }
 
+void GNormalDistributionsTransform::setInputTarget(pcl::PointXYZI *input, int size)
+{
+	// Copy input map data from the host memory to the GPU memory
+	GRegistration::setInputTarget(input, size);
+
+	// Build the voxel grid
+	if (target_points_number_ != 0) {
+		voxel_grid_.setLeafSize(resolution_, resolution_, resolution_);
+		voxel_grid_.setInput(target_x_, target_y_, target_z_, target_points_number_);
+	}
+}
+
+void GNormalDistributionsTransform::setInputTarget(pcl::PointXYZ *input, int size)
+{
+	// Copy input map data from the host memory to the GPU memory
+	GRegistration::setInputTarget(input, size);
+
+	// Build the voxel grid
+	if (target_points_number_ != 0) {
+		voxel_grid_.setLeafSize(resolution_, resolution_, resolution_);
+		voxel_grid_.setInput(target_x_, target_y_, target_z_, target_points_number_);
+	}
+}
+
 void GNormalDistributionsTransform::computeTransformation(const Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess)
 {
 
@@ -220,19 +244,18 @@ void GNormalDistributionsTransform::computeTransformation(const Eigen::Matrix&lt;fl
 }
 
 /* First step of computing point gradients */
-__global__ void computePointGradients(float *x, float *y, float *z, int points_num,
+__global__ void computePointGradients0(float *x, float *y, float *z, int points_num,
 													int *valid_points, int valid_points_num,
 													double *dj_ang,
 													double *pg00, double *pg11, double *pg22,
-													double *pg13, double *pg23, double *pg04, double *pg14,
-													double *pg24, double *pg05, double *pg15, double *pg25)
+													double *pg13, double *pg23, double *pg04, double *pg14)
 {
 	int id = threadIdx.x + blockIdx.x * blockDim.x;
 	int stride = blockDim.x * gridDim.x;
-	__shared__ double j_ang[24];
+	__shared__ double j_ang[12];
 
 
-	if (threadIdx.x &lt; 24) {
+	if (threadIdx.x &lt; 12) {
 		j_ang[threadIdx.x] = dj_ang[threadIdx.x];
 	}
 
@@ -256,11 +279,40 @@ __global__ void computePointGradients(float *x, float *y, float *z, int points_n
 		pg23[i] = o_x * j_ang[3] + o_y * j_ang[4] + o_z * j_ang[5];
 		pg04[i] = o_x * j_ang[6] + o_y * j_ang[7] + o_z * j_ang[8];
 		pg14[i] = o_x * j_ang[9] + o_y * j_ang[10] + o_z * j_ang[11];
+	}
+}
 
-		pg24[i] = o_x * j_ang[12] + o_y * j_ang[13] + o_z * j_ang[14];
-		pg05[i] = o_x * j_ang[15] + o_y * j_ang[16] + o_z * j_ang[17];
-		pg15[i] = o_x * j_ang[18] + o_y * j_ang[19] + o_z * j_ang[20];
-		pg25[i] = o_x * j_ang[21] + o_y * j_ang[22] + o_z * j_ang[23];
+/* Second step of computing point gradients */
+__global__ void computePointGradients1(float *x, float *y, float *z, int points_num,
+													int *valid_points, int valid_points_num,
+													double *dj_ang,
+													double *pg24, double *pg05, double *pg15, double *pg25)
+{
+	int id = threadIdx.x + blockIdx.x * blockDim.x;
+	int stride = blockDim.x * gridDim.x;
+	__shared__ double j_ang[12];
+
+
+	if (threadIdx.x &lt; 12) {
+		j_ang[threadIdx.x] = dj_ang[threadIdx.x + 12];
+	}
+
+	__syncthreads();
+
+	for (int i = id; i &lt; valid_points_num; i += stride) {
+		int pid = valid_points[i];
+
+		//Orignal coordinates
+		double o_x = static_cast&lt;double&gt;(x[pid]);
+		double o_y = static_cast&lt;double&gt;(y[pid]);
+		double o_z = static_cast&lt;double&gt;(z[pid]);
+
+		//Compute point derivatives
+
+		pg24[i] = o_x * j_ang[0] + o_y * j_ang[1] + o_z * j_ang[2];
+		pg05[i] = o_x * j_ang[3] + o_y * j_ang[4] + o_z * j_ang[5];
+		pg15[i] = o_x * j_ang[6] + o_y * j_ang[7] + o_z * j_ang[8];
+		pg25[i] = o_x * j_ang[9] + o_y * j_ang[10] + o_z * j_ang[11];
 	}
 }
 
@@ -763,7 +815,7 @@ double GNormalDistributionsTransform::computeDerivatives(Eigen::Matrix&lt;double, 6
 
 	dim3 grid;
 
-	computePointGradients&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
+	computePointGradients0&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
 												valid_points, valid_points_num,
 												dj_ang_.buffer(),
 												point_gradients,
@@ -772,7 +824,12 @@ double GNormalDistributionsTransform::computeDerivatives(Eigen::Matrix&lt;double, 6
 												point_gradients + valid_points_num * 9,
 												point_gradients + valid_points_num * 15,
 												point_gradients + valid_points_num * 4,
-												point_gradients + valid_points_num * 10,
+												point_gradients + valid_points_num * 10);
+	checkCudaErrors(cudaGetLastError());
+
+	computePointGradients1&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
+												valid_points, valid_points_num,
+												dj_ang_.buffer(),
 												point_gradients + valid_points_num * 16,
 												point_gradients + valid_points_num * 5,
 												point_gradients + valid_points_num * 11,
@@ -1406,7 +1463,7 @@ void GNormalDistributionsTransform::computeHessian(Eigen::Matrix&lt;double, 6, 6&gt; &amp;
 	int grid_x = (valid_points_num - 1) / block_x + 1;
 	dim3 grid;
 
-	computePointGradients&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
+	computePointGradients0&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
 												valid_points, valid_points_num,
 												dj_ang_.buffer(),
 												point_gradients,
@@ -1415,7 +1472,12 @@ void GNormalDistributionsTransform::computeHessian(Eigen::Matrix&lt;double, 6, 6&gt; &amp;
 												point_gradients + valid_points_num * 9,
 												point_gradients + valid_points_num * 15,
 												point_gradients + valid_points_num * 4,
-												point_gradients + valid_points_num * 10,
+												point_gradients + valid_points_num * 10);
+	checkCudaErrors(cudaGetLastError());
+
+	computePointGradients1&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
+												valid_points, valid_points_num,
+												dj_ang_.buffer(),
 												point_gradients + valid_points_num * 16,
 												point_gradients + valid_points_num * 5,
 												point_gradients + valid_points_num * 11,
@@ -1588,6 +1650,7 @@ __global__ void gpuSum(T *input, int size, int half_size)
 
 double GNormalDistributionsTransform::getFitnessScore(double max_range)
 {
+	printf("TESTTTTTTTTTTTTTTTTTTT");
 	double fitness_score = 0.0;
 
 	float *trans_x, *trans_y, *trans_z;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ccbd4ad2c48f29c335845c67d4835e3f847e41d8" author="anhnv3991">
		<msg>Re-up</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" added_lines="0" deleted_lines="24">
				<diff>@@ -140,30 +140,6 @@ void GNormalDistributionsTransform::setInputTarget(pcl::PointCloud&lt;pcl::PointXYZ
 	}
 }
 
-void GNormalDistributionsTransform::setInputTarget(pcl::PointXYZI *input, int size)
-{
-	// Copy input map data from the host memory to the GPU memory
-	GRegistration::setInputTarget(input, size);
-
-	// Build the voxel grid
-	if (target_points_number_ != 0) {
-		voxel_grid_.setLeafSize(resolution_, resolution_, resolution_);
-		voxel_grid_.setInput(target_x_, target_y_, target_z_, target_points_number_);
-	}
-}
-
-void GNormalDistributionsTransform::setInputTarget(pcl::PointXYZ *input, int size)
-{
-	// Copy input map data from the host memory to the GPU memory
-	GRegistration::setInputTarget(input, size);
-
-	// Build the voxel grid
-	if (target_points_number_ != 0) {
-		voxel_grid_.setLeafSize(resolution_, resolution_, resolution_);
-		voxel_grid_.setInput(target_x_, target_y_, target_z_, target_points_number_);
-	}
-}
-
 void GNormalDistributionsTransform::computeTransformation(const Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess)
 {
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9b08473d31c00d1a446578ffda5737bdfc3f69f7" author="anhnv3991">
		<msg>Re-up</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" added_lines="0" deleted_lines="1">
				<diff>@@ -1626,7 +1626,6 @@ __global__ void gpuSum(T *input, int size, int half_size)
 
 double GNormalDistributionsTransform::getFitnessScore(double max_range)
 {
-	printf("TESTTTTTTTTTTTTTTTTTTT");
 	double fitness_score = 0.0;
 
 	float *trans_x, *trans_y, *trans_z;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7363357bf27a6986609814638b85c70e92a398af" author="andoh104">
		<msg>fix Cuda9 Build error CPFL#1009</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\common.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\common.h" added_lines="6" deleted_lines="0">
				<diff>@@ -15,3 +15,9 @@
 
 #define SHARED_MEM_SIZE 3072
 #endif
+
+//  This is the temploary patch for CUDA9 build problem 
+#if ( __CUDACC_VER_MAJOR__ &gt;=9 )
+#undef  __CUDACC_VER__
+#define __CUDACC_VER__ 90000 
+#endif
\ No newline at end of file
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e4a3efb85fd106bf50ee9ff247676d4175928c89" author="Yusuke FUJII">
		<msg>fix a importing vectormap</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -249,7 +249,7 @@ private:
   friend class State&lt;DriveBehaviorAcceptLanechangeState&gt;;
   DriveBehaviorAcceptLanechangeState(void)
   {
-    StateName = "AcceptLaneChange";
+    StateName = "AcceptLane-Change";
     StateNum = DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE;
     StateKind = BEHAVIOR_STATE;
   }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" added_lines="5" deleted_lines="2">
				<diff>@@ -51,6 +51,9 @@ std::vector&lt;geometry_msgs::Point&gt; convhull(const CrossRoadArea *_TargetArea)
 {
   std::vector&lt;int&gt; enablePoints;
 
+  if(_TargetArea-&gt;points.size() &lt; 3)
+	  return {};
+
   // Jarvis's March algorithm
   size_t l = 0;
   for (auto i = begin(_TargetArea-&gt;points); i != end(_TargetArea-&gt;points); i++)
@@ -72,12 +75,12 @@ std::vector&lt;geometry_msgs::Point&gt; convhull(const CrossRoadArea *_TargetArea)
       geometry_msgs::Point pp = _TargetArea-&gt;points.at(p);
       geometry_msgs::Point pi = _TargetArea-&gt;points.at(i);
       geometry_msgs::Point pq = _TargetArea-&gt;points.at(q);
-      if ((pi.y - pp.y) * (pq.x - pi.x) - (pi.x - pp.x) * (pq.y - pi.y) &lt; 0)
+      if (((pi.y - pp.y) * (pq.x - pi.x) - (pi.x - pp.x) * (pq.y - pi.y)) &lt; 0)
       {
         q = i;
       }
     }
-    enablePoints.push_back(p);
+    enablePoints.push_back(q);
     p = q;
   } while (p != l);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="3" deleted_lines="4">
				<diff>@@ -126,13 +126,14 @@ void DecisionMakerNode::initVectorMap(void)
   std::vector&lt;CrossRoad&gt; crossroads = g_vmap.findByFilter([](const CrossRoad &amp;crossroad) { return true; });
   if (crossroads.empty())
   {
-    ROS_INFO("crossroad have not found\n");
+    ROS_INFO("crossroads have not found\n");
     return;
   }
 
   vector_map_init = true;  // loaded flag
   for (const auto &amp;cross_road : crossroads)
   {
+    geometry_msgs::Point _prev_point;
     Area area = g_vmap.findByKey(Key&lt;Area&gt;(cross_road.aid));
     CrossRoadArea carea;
     carea.id = _index++;
@@ -147,9 +148,8 @@ void DecisionMakerNode::initVectorMap(void)
         g_vmap.findByFilter([&amp;area](const Line &amp;line) { return area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid; });
     for (const auto &amp;line : lines)
     {
-      geometry_msgs::Point _prev_point;
       std::vector&lt;Point&gt; points =
-          g_vmap.findByFilter([&amp;line](const Point &amp;point) { return line.bpid == point.pid || point.pid == line.fpid; });
+          g_vmap.findByFilter([&amp;line](const Point &amp;point) { return line.bpid == point.pid;});
       for (const auto &amp;point : points)
       {
         geometry_msgs::Point _point;
@@ -172,7 +172,6 @@ void DecisionMakerNode::initVectorMap(void)
         y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
         y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
         z = _point.z;
-
       }  // points iter
     }    // line iter
     carea.bbox.pose.position.x = x_avg / (double)points_count;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="96e068f468174d9ca5612bf899453eca459b463b" author="Yusuke FUJII">
		<msg>change a exploring way for lamp</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="32" deleted_lines="22">
				<diff>@@ -279,29 +279,39 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
   }
   // cached
   current_finalwaypoints_ = msg;
-
-  size_t idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_stopline_target_waypoint_ ?
-                   param_stopline_target_waypoint_ :
-                   current_finalwaypoints_.waypoints.size() - 1;
+  if(current_finalwaypoints_.waypoints.size()){
+
+    size_t idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_stopline_target_waypoint_ ?
+                     param_stopline_target_waypoint_ :
+                     current_finalwaypoints_.waypoints.size() - 1;
+    
+    if (current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
+  	  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
+    // steering
+    idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_target_waypoint_ ?
+              param_target_waypoint_ :
+              current_finalwaypoints_.waypoints.size() - 1;
   
-  if (current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
-	  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
-  // steering
-  idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_target_waypoint_ ?
-            param_target_waypoint_ :
-            current_finalwaypoints_.waypoints.size() - 1;
-  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE))
-  {
-	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
-  }
-  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE))
-  {
-	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
-  }
-  else
-  {
-	  ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
-  }
+    if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE))
+    {
+  	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
+    }
+    if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE))
+    {
+  	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
+    }
+    else
+    {
+	  state_machine::StateFlags _TargetStateFlag;
+  	  for(size_t i = idx; i&gt;0; i--){
+		  _TargetStateFlag = getStateFlags(current_finalwaypoints_.waypoints.at(i).wpstate.steering_state);
+		  if(_TargetStateFlag != state_machine::DRIVE_STR_STRAIGHT_STATE){
+			 break;
+		  }
+ 	  }
+  	  ctx-&gt;setCurrentState(_TargetStateFlag);
+    }
+}
 
   // for publish plan of velocity
   publishToVelocityArray();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2d509eb9c110aefdfaa258402a17d13eaa26b1bd" author="Yusuke FUJII">
		<msg>fix a lane_change loop</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="3" deleted_lines="1">
				<diff>@@ -174,7 +174,7 @@ private:
   void changeShiftLane(void);
   void removeShiftLane(void);
 
-
+  // state callback
   void setAllStoplineStop(void);
   void StoplinePlanIn(int status);
   void StoplinePlanOut(int status);
@@ -188,7 +188,9 @@ private:
   void callbackInStateAcc(int status);
   void callbackInStateDec(int status);
   void callbackInStateKeep(int status);
+  void callbackOutStateLaneChange(int status);
   void setupStateCallback(void);
+  
   // callback by topic subscribing
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
   void callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -70,7 +70,7 @@ void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
 
 void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
 {
-  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT) &amp;&amp; ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE))
+  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT) &amp;&amp; (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE)))
   {
     ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
     ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="14" deleted_lines="0">
				<diff>@@ -50,6 +50,12 @@ void DecisionMakerNode::setupStateCallback(void)
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));
 
+  // LaneChange
+  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE,
+                          std::bind(&amp;DecisionMakerNode::callbackOutStateLaneChange, this, 1));
+  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE,
+                          std::bind(&amp;DecisionMakerNode::callbackOutStateLaneChange, this, 1));
+
   // obstacle avoidance
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                              std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
@@ -81,6 +87,14 @@ void DecisionMakerNode::setupStateCallback(void)
 
 }
 
+void DecisionMakerNode::callbackOutStateLaneChange(int status)
+{
+  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE))
+  {
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE);
+  }
+}
+
 void DecisionMakerNode::publishLightColor(int status)
 {
   autoware_msgs::traffic_light msg;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d2ae00017b5bad04b2655f33cb783ec4e47fbe37" author="Yusuke FUJII">
		<msg>fix a merging miss</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="0" deleted_lines="3">
				<diff>@@ -131,8 +131,6 @@ private:
 
   bool isManualLight;
 
-  bool isManualLight;
-
   // Param
   bool enableDisplayMarker;
   bool enableForceStateChange;
@@ -205,7 +203,6 @@ private:
 
 
   // callback by state context
-  void setAllStoplineStop(void);
   void StoplinePlanIn(int status);
   void StoplinePlanOut(int status);
   void publishLightColor(int status);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a0e9ba7bfcbf7d79c42bdcbc58466464c1f4b6f6" author="AMC">
		<msg>Fix Clustering performance when wayarea is not available or no vector map is available.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" added_lines="14" deleted_lines="9">
				<diff>@@ -194,9 +194,10 @@ bool checkPointInGrid(const grid_map::GridMap&amp; in_grid_map, const cv::Mat&amp; in_gr
 	double cv_y = (in_grid_map.getLength().x() - origin_x_offset - in_point.x) / in_grid_map.getResolution();
 
 	//check coords are inside the gridmap
-	if(cv_x &lt; 0 || cv_x &gt; in_grid_image.cols
-			|| cv_y &lt; 0 || cv_y &gt; in_grid_image.rows)
-	{	return false;}
+	if(cv_x &lt; 0 || cv_x &gt; in_grid_image.cols || cv_y &lt; 0 || cv_y &gt; in_grid_image.rows)
+	{
+		return false;
+	}
 
 	//Scalar(0) if road
 	if(0 == in_grid_image.at&lt;uchar&gt;(cv_y, cv_x))
@@ -213,7 +214,7 @@ void convertPointsToImage(grid_map::GridMap&amp; out_grid_map, const std::vector&lt;std
 	{
 		out_grid_map.add("wayarea");
 	}
-	out_grid_map["wayarea"].setConstant(100);
+	out_grid_map["wayarea"].setConstant(100);//fill with gray color
 
 	cv::Mat original_image;
 	grid_map::GridMapCvConverter::toImage&lt;unsigned char, 1&gt;(out_grid_map, "wayarea", CV_8UC1, 0, 100, original_image);
@@ -1235,13 +1236,16 @@ int main (int argc, char** argv)
 
 	// Create a ROS subscriber for the input point cloud
 	ros::Subscriber sub = h.subscribe (points_topic, 1, velodyne_callback);
-	//ros::Subscriber sub_vectormap = h.subscribe ("vector_map", 1, vectormap_callback);
-	//_vectormap_server = h.serviceClient&lt;vector_map_server::PositionState&gt;("vector_map_server/is_way_area");
 
-	ROS_INFO("[euclidean_cluster]: Creating GridMap for Wayarea...");
+
 	vector_map::VectorMap vector_map;
-	vector_map.subscribe(private_nh, vector_map::Category::POINT | vector_map::Category::LINE |
-			vector_map::Category::AREA | vector_map::Category::WAY_AREA);
+
+	ROS_INFO("[euclidean_cluster]: Creating GridMap for Wayarea...");
+	vector_map.subscribe(private_nh,
+	                     vector_map::Category::POINT | vector_map::Category::LINE |
+	                     vector_map::Category::AREA | vector_map::Category::WAY_AREA,
+	                     10
+	);
 
 	// all true -&gt; all data
 	std::vector&lt;vector_map_msgs::WayArea&gt; way_areas = vector_map.findByFilter([](const vector_map_msgs::WayArea&amp; way_area){return true;});
@@ -1254,6 +1258,7 @@ int main (int argc, char** argv)
 	if (way_areas.empty())
 	{
 		ROS_WARN_STREAM("[euclidean_cluster]: The VectorMap is not being published or does not contain WAYAREA, not performing filtering.");
+		_wayarea_gridmap = NULL;
 	} else
 	{
 		ROS_INFO("[euclidean_cluster]: Found %lu wayareas.", way_areas.size());
</diff>
			</file>
			<file old_path="ros\src\data\packages\vector_map\include\vector_map\vector_map.h" new_path="ros\src\data\packages\vector_map\include\vector_map\vector_map.h" added_lines="1" deleted_lines="0">
				<diff>@@ -403,6 +403,7 @@ public:
 
   void subscribe(ros::NodeHandle&amp; nh, category_t category);
   void subscribe(ros::NodeHandle&amp; nh, category_t category, const ros::Duration&amp; timeout);
+  void subscribe(ros::NodeHandle&amp; nh, category_t category, const size_t max_retries);
 
   Point findByKey(const Key&lt;Point&gt;&amp; key) const;
   Vector findByKey(const Key&lt;Vector&gt;&amp; key) const;
</diff>
			</file>
			<file old_path="ros\src\data\packages\vector_map\lib\vector_map\vector_map.cpp" new_path="ros\src\data\packages\vector_map\lib\vector_map\vector_map.cpp" added_lines="12" deleted_lines="0">
				<diff>@@ -744,6 +744,18 @@ void VectorMap::subscribe(ros::NodeHandle&amp; nh, category_t category, const ros::D
   }
 }
 
+void VectorMap::subscribe(ros::NodeHandle&amp; nh, category_t category, const size_t max_retries)
+{
+  size_t tries = 0;
+  registerSubscriber(nh, category);
+  ros::Rate rate(1);
+  while (ros::ok() &amp;&amp; !hasSubscribed(category) &amp;&amp; tries++ &lt; max_retries)
+  {
+    ros::spinOnce();
+    rate.sleep();
+  }
+}
+
 Point VectorMap::findByKey(const Key&lt;Point&gt;&amp; key) const
 {
   return point_.findByKey(key);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="edd9bf96b359d34046db3525db0c41e37cfc6698" author="AMC">
		<msg>Added comment</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1244,7 +1244,7 @@ int main (int argc, char** argv)
 	vector_map.subscribe(private_nh,
 	                     vector_map::Category::POINT | vector_map::Category::LINE |
 	                     vector_map::Category::AREA | vector_map::Category::WAY_AREA,
-	                     10
+	                     10 //abort after 10 times, either vector map or wayarea not available
 	);
 
 	// all true -&gt; all data
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="814e9e64b7127c78aa79b2cb551d77430c5da974" author="Yuma">
		<msg>Add current_velocity and twist_command line graph</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" added_lines="119" deleted_lines="25">
				<diff>@@ -58,13 +58,23 @@ std_msgs::ColorRGBA g_local_color;
 const double g_global_alpha = 0.2;
 const double g_local_alpha = 1.0;
 int _closest_waypoint = -1;
+
+bool g_current_pose_subscribed = false;
+bool g_current_vel_subscribed = false;
+bool g_command_vel_subscribed = false;
+geometry_msgs::PoseStamped g_current_pose;
+geometry_msgs::TwistStamped g_current_vel, g_command_vel;
+autoware_msgs::lane g_current_vel_array, g_command_vel_array;
+
 visualization_msgs::MarkerArray g_global_marker_array;
 visualization_msgs::MarkerArray g_local_waypoints_marker_array;
 
 bool g_config_manual_detection = true;
 bool g_use_velocity_visualizer;
 double g_graph_height_ratio;
-std::vector&lt;double&gt; g_graph_color = { 0.0, 1.0, 0.0, 0.5 };
+std::vector&lt;double&gt; g_local_vel_graph_color = { 0.0, 1.0, 0.0, 0.5 };
+std::vector&lt;double&gt; g_current_vel_graph_color = { 1.0, 0.0, 0.0, 0.5 };
+std::vector&lt;double&gt; g_command_vel_graph_color = { 0.0, 0.0, 1.0, 0.5 };
 
 enum class ChangeFlag : int32_t
 {
@@ -105,7 +115,7 @@ void createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray&amp; lane_wa
   // display by markers the velocity of each waypoint.
   visualization_msgs::Marker velocity_marker;
   velocity_marker.header.frame_id = "map";
-  velocity_marker.header.stamp = ros::Time();
+  velocity_marker.header.stamp = ros::Time::now();
   velocity_marker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
   velocity_marker.action = visualization_msgs::Marker::ADD;
   velocity_marker.scale.z = 0.4;
@@ -146,7 +156,7 @@ void createGlobalLaneArrayChangeFlagMarker(const autoware_msgs::LaneArray&amp; lane_
   // display by markers the velocity of each waypoint.
   visualization_msgs::Marker marker;
   marker.header.frame_id = "map";
-  marker.header.stamp = ros::Time();
+  marker.header.stamp = ros::Time::now();
   marker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
   marker.action = visualization_msgs::Marker::ADD;
   marker.scale.z = 0.4;
@@ -204,7 +214,7 @@ void createLocalWaypointVelocityMarker(std_msgs::ColorRGBA color, int closest_wa
   // display by markers the velocity of each waypoint.
   visualization_msgs::Marker velocity;
   velocity.header.frame_id = "map";
-  velocity.header.stamp = ros::Time();
+  velocity.header.stamp = ros::Time::now();
   velocity.ns = "local_waypoint_velocity";
   velocity.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
   velocity.action = visualization_msgs::Marker::ADD;
@@ -233,7 +243,7 @@ void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const autoware_msgs:
 {
   visualization_msgs::Marker lane_waypoint_marker;
   lane_waypoint_marker.header.frame_id = "map";
-  lane_waypoint_marker.header.stamp = ros::Time();
+  lane_waypoint_marker.header.stamp = ros::Time::now();
   lane_waypoint_marker.ns = "global_lane_array_marker";
   lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
   lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
@@ -258,20 +268,20 @@ void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const autoware_msgs:
   }
 }
 
-void createLocalVelocityBarGraphMarker(const autoware_msgs::lane&amp; lane_waypoint)
+void createVelocityBarGraphMarker(const autoware_msgs::lane&amp; lane_waypoint, const std::string str_name_space, const std::vector&lt;double&gt;&amp; flat_color)
 {
   visualization_msgs::Marker velocity_bar_graph_marker;
   velocity_bar_graph_marker.header.frame_id = "map";
-  velocity_bar_graph_marker.header.stamp = ros::Time();
-  velocity_bar_graph_marker.ns = "local_velocity_bar_graph_marker";
+  velocity_bar_graph_marker.header.stamp = ros::Time::now();
+  velocity_bar_graph_marker.ns = str_name_space + "_velocity_bar_graph_marker";
   velocity_bar_graph_marker.type = visualization_msgs::Marker::CYLINDER;
   velocity_bar_graph_marker.action = visualization_msgs::Marker::ADD;
   velocity_bar_graph_marker.scale.x = 0.2;
   velocity_bar_graph_marker.scale.y = 0.2;
-  velocity_bar_graph_marker.color.r = g_graph_color[0];
-  velocity_bar_graph_marker.color.g = g_graph_color[1];
-  velocity_bar_graph_marker.color.b = g_graph_color[2];
-  velocity_bar_graph_marker.color.a = g_graph_color[3];
+  velocity_bar_graph_marker.color.r = flat_color[0];
+  velocity_bar_graph_marker.color.g = flat_color[1];
+  velocity_bar_graph_marker.color.b = flat_color[2];
+  velocity_bar_graph_marker.color.a = flat_color[3];
   velocity_bar_graph_marker.frame_locked = true;
 
   unsigned int count = 0;
@@ -287,19 +297,19 @@ void createLocalVelocityBarGraphMarker(const autoware_msgs::lane&amp; lane_waypoint)
   }
 }
 
-void createLocalVelocityLineGraphMarker(const autoware_msgs::lane&amp; lane_waypoint)
+void createVelocityLineGraphMarker(const autoware_msgs::lane&amp; lane_waypoint, const std::string str_name_space, const std::vector&lt;double&gt;&amp; flat_color)
 {
   visualization_msgs::Marker velocity_line_graph_marker;
   velocity_line_graph_marker.header.frame_id = "map";
-  velocity_line_graph_marker.header.stamp = ros::Time();
-  velocity_line_graph_marker.ns = "local_velocity_line_graph_marker";
+  velocity_line_graph_marker.header.stamp = ros::Time::now();
+  velocity_line_graph_marker.ns = str_name_space + "_velocity_line_graph_marker";
   velocity_line_graph_marker.type = visualization_msgs::Marker::LINE_STRIP;
   velocity_line_graph_marker.action = visualization_msgs::Marker::ADD;
   velocity_line_graph_marker.scale.x = 0.25;
-  velocity_line_graph_marker.color.r = g_graph_color[0];
-  velocity_line_graph_marker.color.g = g_graph_color[1];
-  velocity_line_graph_marker.color.b = g_graph_color[2];
-  velocity_line_graph_marker.color.a = g_graph_color[3];
+  velocity_line_graph_marker.color.r = flat_color[0];
+  velocity_line_graph_marker.color.g = flat_color[1];
+  velocity_line_graph_marker.color.b = flat_color[2];
+  velocity_line_graph_marker.color.a = flat_color[3];
   velocity_line_graph_marker.frame_locked = true;
 
   for (auto el : lane_waypoint.waypoints)
@@ -316,7 +326,7 @@ void createGlobalLaneArrayOrientationMarker(const autoware_msgs::LaneArray&amp; lane
   visualization_msgs::MarkerArray tmp_marker_array;
   visualization_msgs::Marker lane_waypoint_marker;
   lane_waypoint_marker.header.frame_id = "map";
-  lane_waypoint_marker.header.stamp = ros::Time();
+  lane_waypoint_marker.header.stamp = ros::Time::now();
   lane_waypoint_marker.type = visualization_msgs::Marker::ARROW;
   lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
   lane_waypoint_marker.scale.x = 0.25;
@@ -348,7 +358,7 @@ void createLocalPathMarker(std_msgs::ColorRGBA color, const autoware_msgs::lane&amp;
 {
   visualization_msgs::Marker lane_waypoint_marker;
   lane_waypoint_marker.header.frame_id = "map";
-  lane_waypoint_marker.header.stamp = ros::Time();
+  lane_waypoint_marker.header.stamp = ros::Time::now();
   lane_waypoint_marker.ns = "local_path_marker";
   lane_waypoint_marker.id = 0;
   lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
@@ -370,7 +380,7 @@ void createLocalPointMarker(const autoware_msgs::lane&amp; lane_waypoint)
 {
   visualization_msgs::Marker lane_waypoint_marker;
   lane_waypoint_marker.header.frame_id = "map";
-  lane_waypoint_marker.header.stamp = ros::Time();
+  lane_waypoint_marker.header.stamp = ros::Time::now();
   lane_waypoint_marker.ns = "local_point_marker";
   lane_waypoint_marker.id = 0;
   lane_waypoint_marker.type = visualization_msgs::Marker::CUBE_LIST;
@@ -462,12 +472,87 @@ void finalCallback(const autoware_msgs::laneConstPtr&amp; msg)
   createLocalPointMarker(*msg);
   if (g_use_velocity_visualizer)
   {
-    createLocalVelocityBarGraphMarker(*msg);
-    createLocalVelocityLineGraphMarker(*msg);
+    createVelocityBarGraphMarker(*msg, "local", g_local_vel_graph_color);
+    createVelocityLineGraphMarker(*msg, "local", g_local_vel_graph_color);
+
+    createVelocityBarGraphMarker(g_current_vel_array, "current", g_current_vel_graph_color);
+    createVelocityLineGraphMarker(g_current_vel_array, "current", g_current_vel_graph_color);
+
+    createVelocityBarGraphMarker(g_command_vel_array, "command", g_command_vel_graph_color);
+    createVelocityLineGraphMarker(g_command_vel_array, "command", g_command_vel_graph_color);
   }
   publishLocalMarker();
 }
 
+const bool isSyncTimeOn10Hz()
+{
+  ros::Duration duration_diff[3];
+  ros::Time cpose_stamp = g_current_pose.header.stamp;
+  ros::Time cvel_stamp = g_current_vel.header.stamp;
+  ros::Time pvel_stamp = g_command_vel.header.stamp;
+  duration_diff[0] = cpose_stamp - cvel_stamp;
+  duration_diff[1] = cpose_stamp - pvel_stamp;
+  duration_diff[2] = cvel_stamp - pvel_stamp;
+  for(int i=0;i&lt;3;i++)
+  {
+    double diff_sec = fabs(1e-9 * duration_diff[i].nsec + duration_diff[i].sec);
+    if(diff_sec &gt;= 0.2)return false;//rejecting over 0.2sec delay
+  }
+  return true;
+}
+
+void pushVelocityArray()
+{
+  const unsigned int pose_and_velocity_array_limits = 100;
+  std::vector&lt;autoware_msgs::waypoint&gt;&amp; cwp_array = g_current_vel_array.waypoints;
+  std::vector&lt;autoware_msgs::waypoint&gt;&amp; pwp_array = g_command_vel_array.waypoints;
+
+  autoware_msgs::waypoint current_wp, command_wp;
+  current_wp.pose = command_wp.pose = g_current_pose;
+  current_wp.twist = g_current_vel;
+  command_wp.twist = g_command_vel;
+  cwp_array.push_back(current_wp);
+  pwp_array.push_back(command_wp);
+  if(cwp_array.size() &gt; pose_and_velocity_array_limits)cwp_array.erase(cwp_array.begin());
+  if(pwp_array.size() &gt; pose_and_velocity_array_limits)pwp_array.erase(pwp_array.begin());
+}
+
+void currentPoseCallback(const geometry_msgs::PoseStamped&amp; pose)
+{
+  g_current_pose = pose;
+  g_current_pose_subscribed = true;
+
+  bool is_sync_pose_and_velocity = (g_current_pose_subscribed &amp;&amp; g_current_vel_subscribed &amp;&amp; g_command_vel_subscribed);
+  if(!is_sync_pose_and_velocity)return;
+  if(!isSyncTimeOn10Hz())return;
+  pushVelocityArray();
+  g_current_pose_subscribed = g_current_vel_subscribed = g_command_vel_subscribed =false;
+}
+
+void currentVelocityCallback(const geometry_msgs::TwistStamped&amp; vel)
+{
+  g_current_vel = vel;
+  g_current_vel_subscribed = true;
+
+  bool is_sync_pose_and_velocity = (g_current_pose_subscribed &amp;&amp; g_current_vel_subscribed &amp;&amp; g_command_vel_subscribed);
+  if(!is_sync_pose_and_velocity)return;
+  if(!isSyncTimeOn10Hz())return;
+  pushVelocityArray();
+  g_current_pose_subscribed = g_current_vel_subscribed = g_command_vel_subscribed =false;
+}
+
+void commandVelocityCallback(const geometry_msgs::TwistStamped&amp; vel)
+{
+  g_command_vel = vel;
+  g_command_vel_subscribed = true;
+
+  bool is_sync_pose_and_velocity = (g_current_pose_subscribed &amp;&amp; g_current_vel_subscribed &amp;&amp; g_command_vel_subscribed);
+  if(!is_sync_pose_and_velocity)return;
+  if(!isSyncTimeOn10Hz())return;
+  pushVelocityArray();
+  g_current_pose_subscribed = g_current_vel_subscribed = g_command_vel_subscribed =false;
+}
+
 void closestCallback(const std_msgs::Int32ConstPtr&amp; msg)
 {
   _closest_waypoint = msg-&gt;data;
@@ -482,7 +567,9 @@ int main(int argc, char** argv)
 
   private_nh.param&lt;bool&gt;("use_velocity_visualizer", g_use_velocity_visualizer, false);
   private_nh.param&lt;double&gt;("graph_height_ratio", g_graph_height_ratio, 1.0);
-  private_nh.param&lt;std::vector&lt;double&gt; &gt;("velocity_bar_graph_color", g_graph_color, g_graph_color);
+  private_nh.param&lt;std::vector&lt;double&gt; &gt;("local_velocity_graph_color", g_local_vel_graph_color, g_local_vel_graph_color);
+  private_nh.param&lt;std::vector&lt;double&gt; &gt;("current_velocity_graph_color", g_current_vel_graph_color, g_current_vel_graph_color);
+  private_nh.param&lt;std::vector&lt;double&gt; &gt;("command_velocity_graph_color", g_command_vel_graph_color, g_command_vel_graph_color);
 
   // subscribe traffic light
   ros::Subscriber light_sub = nh.subscribe("light_color", 10, receiveAutoDetection);
@@ -496,6 +583,13 @@ int main(int argc, char** argv)
   ros::Subscriber final_sub = nh.subscribe("final_waypoints", 10, finalCallback);
   ros::Subscriber closest_sub = nh.subscribe("closest_waypoint", 10, closestCallback);
 
+  // subscribe current pose &amp; velocity
+  ros::Subscriber current_pose_sub = nh.subscribe("current_pose", 10, currentPoseCallback);
+  ros::Subscriber current_vel_sub = nh.subscribe("current_velocity", 10, currentVelocityCallback);
+
+  // subscribe velocity command
+  ros::Subscriber command_vel_sub = nh.subscribe("twist_cmd", 10, commandVelocityCallback);
+
   // subscribe config
   ros::Subscriber config_sub = nh.subscribe("config/lane_stop", 10, configParameter);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9eceab073cd5c60c9e9f27957ebe9159b1e1fdf2" author="Akihito Ohsato">
		<msg>Separate speed vizualizer -&gt; waypoint_marker/waypoint_velocity_vizualizer</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" added_lines="0" deleted_lines="158">
				<diff>@@ -59,22 +59,10 @@ const double g_global_alpha = 0.2;
 const double g_local_alpha = 1.0;
 int _closest_waypoint = -1;
 
-bool g_current_pose_subscribed = false;
-bool g_current_vel_subscribed = false;
-bool g_command_vel_subscribed = false;
-geometry_msgs::PoseStamped g_current_pose;
-geometry_msgs::TwistStamped g_current_vel, g_command_vel;
-autoware_msgs::lane g_current_vel_array, g_command_vel_array;
-
 visualization_msgs::MarkerArray g_global_marker_array;
 visualization_msgs::MarkerArray g_local_waypoints_marker_array;
 
 bool g_config_manual_detection = true;
-bool g_use_velocity_visualizer;
-double g_graph_height_ratio;
-std::vector&lt;double&gt; g_local_vel_graph_color = { 0.0, 1.0, 0.0, 0.5 };
-std::vector&lt;double&gt; g_current_vel_graph_color = { 1.0, 0.0, 0.0, 0.5 };
-std::vector&lt;double&gt; g_command_vel_graph_color = { 0.0, 0.0, 1.0, 0.5 };
 
 enum class ChangeFlag : int32_t
 {
@@ -268,59 +256,6 @@ void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const autoware_msgs:
   }
 }
 
-void createVelocityBarGraphMarker(const autoware_msgs::lane&amp; lane_waypoint, const std::string str_name_space, const std::vector&lt;double&gt;&amp; flat_color)
-{
-  visualization_msgs::Marker velocity_bar_graph_marker;
-  velocity_bar_graph_marker.header.frame_id = "map";
-  velocity_bar_graph_marker.header.stamp = ros::Time::now();
-  velocity_bar_graph_marker.ns = str_name_space + "_velocity_bar_graph_marker";
-  velocity_bar_graph_marker.type = visualization_msgs::Marker::CYLINDER;
-  velocity_bar_graph_marker.action = visualization_msgs::Marker::ADD;
-  velocity_bar_graph_marker.scale.x = 0.2;
-  velocity_bar_graph_marker.scale.y = 0.2;
-  velocity_bar_graph_marker.color.r = flat_color[0];
-  velocity_bar_graph_marker.color.g = flat_color[1];
-  velocity_bar_graph_marker.color.b = flat_color[2];
-  velocity_bar_graph_marker.color.a = flat_color[3];
-  velocity_bar_graph_marker.frame_locked = true;
-
-  unsigned int count = 0;
-  for (auto el : lane_waypoint.waypoints)
-  {
-    double bar_graph_height = g_graph_height_ratio * el.twist.twist.linear.x;
-    velocity_bar_graph_marker.id = count++;
-    velocity_bar_graph_marker.pose = el.pose.pose;
-    velocity_bar_graph_marker.pose.position.z += bar_graph_height / 2.0;
-    // When the the cylinder height is 0 or less, a warning occurs in RViz.
-    velocity_bar_graph_marker.scale.z = fabs(bar_graph_height) + 1e-6;
-    g_local_waypoints_marker_array.markers.push_back(velocity_bar_graph_marker);
-  }
-}
-
-void createVelocityLineGraphMarker(const autoware_msgs::lane&amp; lane_waypoint, const std::string str_name_space, const std::vector&lt;double&gt;&amp; flat_color)
-{
-  visualization_msgs::Marker velocity_line_graph_marker;
-  velocity_line_graph_marker.header.frame_id = "map";
-  velocity_line_graph_marker.header.stamp = ros::Time::now();
-  velocity_line_graph_marker.ns = str_name_space + "_velocity_line_graph_marker";
-  velocity_line_graph_marker.type = visualization_msgs::Marker::LINE_STRIP;
-  velocity_line_graph_marker.action = visualization_msgs::Marker::ADD;
-  velocity_line_graph_marker.scale.x = 0.25;
-  velocity_line_graph_marker.color.r = flat_color[0];
-  velocity_line_graph_marker.color.g = flat_color[1];
-  velocity_line_graph_marker.color.b = flat_color[2];
-  velocity_line_graph_marker.color.a = flat_color[3];
-  velocity_line_graph_marker.frame_locked = true;
-
-  for (auto el : lane_waypoint.waypoints)
-  {
-    geometry_msgs::Point point = el.pose.pose.position;
-    point.z += g_graph_height_ratio * el.twist.twist.linear.x;
-    velocity_line_graph_marker.points.push_back(point);
-  }
-  g_local_waypoints_marker_array.markers.push_back(velocity_line_graph_marker);
-}
-
 void createGlobalLaneArrayOrientationMarker(const autoware_msgs::LaneArray&amp; lane_waypoints_array)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
@@ -470,89 +405,9 @@ void finalCallback(const autoware_msgs::laneConstPtr&amp; msg)
     createLocalWaypointVelocityMarker(g_local_color, _closest_waypoint, *msg);
   createLocalPathMarker(g_local_color, *msg);
   createLocalPointMarker(*msg);
-  if (g_use_velocity_visualizer)
-  {
-    createVelocityBarGraphMarker(*msg, "local", g_local_vel_graph_color);
-    createVelocityLineGraphMarker(*msg, "local", g_local_vel_graph_color);
-
-    createVelocityBarGraphMarker(g_current_vel_array, "current", g_current_vel_graph_color);
-    createVelocityLineGraphMarker(g_current_vel_array, "current", g_current_vel_graph_color);
-
-    createVelocityBarGraphMarker(g_command_vel_array, "command", g_command_vel_graph_color);
-    createVelocityLineGraphMarker(g_command_vel_array, "command", g_command_vel_graph_color);
-  }
   publishLocalMarker();
 }
 
-const bool isSyncTimeOn10Hz()
-{
-  ros::Duration duration_diff[3];
-  ros::Time cpose_stamp = g_current_pose.header.stamp;
-  ros::Time cvel_stamp = g_current_vel.header.stamp;
-  ros::Time pvel_stamp = g_command_vel.header.stamp;
-  duration_diff[0] = cpose_stamp - cvel_stamp;
-  duration_diff[1] = cpose_stamp - pvel_stamp;
-  duration_diff[2] = cvel_stamp - pvel_stamp;
-  for(int i=0;i&lt;3;i++)
-  {
-    double diff_sec = fabs(1e-9 * duration_diff[i].nsec + duration_diff[i].sec);
-    if(diff_sec &gt;= 0.2)return false;//rejecting over 0.2sec delay
-  }
-  return true;
-}
-
-void pushVelocityArray()
-{
-  const unsigned int pose_and_velocity_array_limits = 100;
-  std::vector&lt;autoware_msgs::waypoint&gt;&amp; cwp_array = g_current_vel_array.waypoints;
-  std::vector&lt;autoware_msgs::waypoint&gt;&amp; pwp_array = g_command_vel_array.waypoints;
-
-  autoware_msgs::waypoint current_wp, command_wp;
-  current_wp.pose = command_wp.pose = g_current_pose;
-  current_wp.twist = g_current_vel;
-  command_wp.twist = g_command_vel;
-  cwp_array.push_back(current_wp);
-  pwp_array.push_back(command_wp);
-  if(cwp_array.size() &gt; pose_and_velocity_array_limits)cwp_array.erase(cwp_array.begin());
-  if(pwp_array.size() &gt; pose_and_velocity_array_limits)pwp_array.erase(pwp_array.begin());
-}
-
-void currentPoseCallback(const geometry_msgs::PoseStamped&amp; pose)
-{
-  g_current_pose = pose;
-  g_current_pose_subscribed = true;
-
-  bool is_sync_pose_and_velocity = (g_current_pose_subscribed &amp;&amp; g_current_vel_subscribed &amp;&amp; g_command_vel_subscribed);
-  if(!is_sync_pose_and_velocity)return;
-  if(!isSyncTimeOn10Hz())return;
-  pushVelocityArray();
-  g_current_pose_subscribed = g_current_vel_subscribed = g_command_vel_subscribed =false;
-}
-
-void currentVelocityCallback(const geometry_msgs::TwistStamped&amp; vel)
-{
-  g_current_vel = vel;
-  g_current_vel_subscribed = true;
-
-  bool is_sync_pose_and_velocity = (g_current_pose_subscribed &amp;&amp; g_current_vel_subscribed &amp;&amp; g_command_vel_subscribed);
-  if(!is_sync_pose_and_velocity)return;
-  if(!isSyncTimeOn10Hz())return;
-  pushVelocityArray();
-  g_current_pose_subscribed = g_current_vel_subscribed = g_command_vel_subscribed =false;
-}
-
-void commandVelocityCallback(const geometry_msgs::TwistStamped&amp; vel)
-{
-  g_command_vel = vel;
-  g_command_vel_subscribed = true;
-
-  bool is_sync_pose_and_velocity = (g_current_pose_subscribed &amp;&amp; g_current_vel_subscribed &amp;&amp; g_command_vel_subscribed);
-  if(!is_sync_pose_and_velocity)return;
-  if(!isSyncTimeOn10Hz())return;
-  pushVelocityArray();
-  g_current_pose_subscribed = g_current_vel_subscribed = g_command_vel_subscribed =false;
-}
-
 void closestCallback(const std_msgs::Int32ConstPtr&amp; msg)
 {
   _closest_waypoint = msg-&gt;data;
@@ -565,12 +420,6 @@ int main(int argc, char** argv)
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
 
-  private_nh.param&lt;bool&gt;("use_velocity_visualizer", g_use_velocity_visualizer, false);
-  private_nh.param&lt;double&gt;("graph_height_ratio", g_graph_height_ratio, 1.0);
-  private_nh.param&lt;std::vector&lt;double&gt; &gt;("local_velocity_graph_color", g_local_vel_graph_color, g_local_vel_graph_color);
-  private_nh.param&lt;std::vector&lt;double&gt; &gt;("current_velocity_graph_color", g_current_vel_graph_color, g_current_vel_graph_color);
-  private_nh.param&lt;std::vector&lt;double&gt; &gt;("command_velocity_graph_color", g_command_vel_graph_color, g_command_vel_graph_color);
-
   // subscribe traffic light
   ros::Subscriber light_sub = nh.subscribe("light_color", 10, receiveAutoDetection);
   ros::Subscriber light_managed_sub = nh.subscribe("light_color_managed", 10, receiveManualDetection);
@@ -583,13 +432,6 @@ int main(int argc, char** argv)
   ros::Subscriber final_sub = nh.subscribe("final_waypoints", 10, finalCallback);
   ros::Subscriber closest_sub = nh.subscribe("closest_waypoint", 10, closestCallback);
 
-  // subscribe current pose &amp; velocity
-  ros::Subscriber current_pose_sub = nh.subscribe("current_pose", 10, currentPoseCallback);
-  ros::Subscriber current_vel_sub = nh.subscribe("current_velocity", 10, currentVelocityCallback);
-
-  // subscribe velocity command
-  ros::Subscriber command_vel_sub = nh.subscribe("twist_cmd", 10, commandVelocityCallback);
-
   // subscribe config
   ros::Subscriber config_sub = nh.subscribe("config/lane_stop", 10, configParameter);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="caf15457b8bb058bd6e142355da3dc04a78388a2" author="Akihito Ohsato">
		<msg>Refactor using boost::circular_buffer, ApproximateTimeSyncPolicy, and so on</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_vizualizer\waypoint_velocity_vizualizer.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_vizualizer\waypoint_velocity_vizualizer.cpp" added_lines="197" deleted_lines="249">
				<diff>@@ -32,308 +32,256 @@
 #include &lt;ros/console.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
+#include &lt;std_msgs/ColorRGBA.h&gt;
+#include &lt;geometry_msgs/PoseStamped.h&gt;
+#include &lt;geometry_msgs/TwistStamped.h&gt;
+#include &lt;nav_msgs/Odometry.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
+#include &lt;message_filters/subscriber.h&gt;
+#include &lt;message_filters/synchronizer.h&gt;
+#include &lt;message_filters/sync_policies/approximate_time.h&gt;
 
 #include &lt;iostream&gt;
 #include &lt;vector&gt;
 #include &lt;string&gt;
 
+#include &lt;boost/circular_buffer.hpp&gt;
+
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "autoware_msgs/LaneArray.h"
 #include "autoware_msgs/ConfigLaneStop.h"
 #include "autoware_msgs/traffic_light.h"
 
-namespace
+class WaypointVelocityVizualizer
 {
-ros::Publisher g_local_mark_pub;
-ros::Publisher g_global_mark_pub;
-
-
-std_msgs::ColorRGBA _initial_color;
-std_msgs::ColorRGBA _global_color;
-std_msgs::ColorRGBA g_local_color;
-const double g_global_alpha = 0.2;
-const double g_local_alpha = 1.0;
-int _closest_waypoint = -1;
-
-bool g_current_pose_subscribed = false;
-bool g_current_vel_subscribed = false;
-bool g_command_vel_subscribed = false;
-geometry_msgs::PoseStamped g_current_pose;
-geometry_msgs::TwistStamped g_current_vel, g_command_vel;
-autoware_msgs::lane g_current_vel_array, g_command_vel_array;
-
-visualization_msgs::MarkerArray g_global_marker_array;
-visualization_msgs::MarkerArray g_local_waypoints_marker_array;
-
-bool g_config_manual_detection = true;
-bool g_use_velocity_visualizer;
-double g_graph_height_ratio;
-std::vector&lt;double&gt; g_local_vel_graph_color = { 0.0, 1.0, 0.0, 0.5 };
-std::vector&lt;double&gt; g_current_vel_graph_color = { 1.0, 0.0, 0.0, 0.5 };
-std::vector&lt;double&gt; g_command_vel_graph_color = { 0.0, 0.0, 1.0, 0.5 };
-
-void publishLocalMarker()
+public:
+  WaypointVelocityVizualizer();
+  ~WaypointVelocityVizualizer();
+
+private:
+  typedef message_filters::sync_policies::ApproximateTime&lt;geometry_msgs::PoseStamped, geometry_msgs::TwistStamped, geometry_msgs::TwistStamped&gt; ControlSyncPolicy;
+
+  ros::NodeHandle node_handle_;
+  ros::NodeHandle private_node_handle_;
+
+  ros::Subscriber base_waypoints_sub_;
+  ros::Subscriber final_waypoints_sub_;
+  ros::Subscriber closest_waypoint_sub_;
+  message_filters::Subscriber&lt;geometry_msgs::PoseStamped&gt; *current_pose_sub_;
+  message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt; *current_twist_sub_;
+  message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt; *command_twist_sub_;
+  message_filters::Synchronizer&lt;ControlSyncPolicy&gt; *control_sync_;
+
+  ros::Publisher velocity_marker_pub_;
+
+  visualization_msgs::MarkerArray velocity_marker_array_;
+  visualization_msgs::MarkerArray base_waypoints_marker_array_;
+  visualization_msgs::MarkerArray final_waypoints_marker_array_;
+  visualization_msgs::MarkerArray current_twist_marker_array_;
+  visualization_msgs::MarkerArray command_twist_marker_array_;
+
+  int control_buffer_size_ = 100;
+  double plot_height_ratio_ = 1.0;
+  std::vector&lt;double&gt; base_waypoints_rgba_ = { 1.0, 1.0, 1.0, 0.5 };
+  std::vector&lt;double&gt; final_waypoints_rgba_ = { 0.0, 1.0, 0.0, 0.5 };
+  std::vector&lt;double&gt; current_twist_rgba_ = { 1.0, 0.0, 0.0, 0.5 };
+  std::vector&lt;double&gt; command_twist_rgba_ = { 0.0, 0.0, 1.0, 0.5 };
+
+  std_msgs::ColorRGBA base_waypoints_color_;
+  std_msgs::ColorRGBA final_waypoints_color_;
+  std_msgs::ColorRGBA current_twist_color_;
+  std_msgs::ColorRGBA command_twist_color_;
+
+  int closest_waypoint_ = -1;
+  boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt; current_pose_buf_;
+  boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt; current_twist_buf_;
+  boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt; command_twist_buf_;
+
+  std_msgs::ColorRGBA vector2color(const std::vector&lt;double&gt;&amp; v);
+
+  void baseWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg);
+  void finalWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg);
+  void closestWaypointCallback(const std_msgs::Int32::ConstPtr&amp; msg);
+  void controlCallback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; current_twist_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; command_twist_msg);
+
+  void publishVelocityMarker();
+
+  void createVelocityMarker(const std::vector&lt;nav_msgs::Odometry&gt; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
+  void createVelocityMarker(const autoware_msgs::lane&amp; lane, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
+  void createVelocityMarker(const boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt;&amp; poses, const boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt;&amp; twists, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
+
+  void createVelocityBarMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
+  void createVelocityLineMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
+};
+
+WaypointVelocityVizualizer::WaypointVelocityVizualizer() : node_handle_(), private_node_handle_("~")
 {
-  visualization_msgs::MarkerArray marker_array;
-
-  // insert local marker
-  marker_array.markers.insert(marker_array.markers.end(), g_local_waypoints_marker_array.markers.begin(),
-                              g_local_waypoints_marker_array.markers.end());
-
-  g_local_mark_pub.publish(marker_array);
+  private_node_handle_.param&lt;int&gt;("control_buffer_size", control_buffer_size_, control_buffer_size_);
+  private_node_handle_.param&lt;double&gt;("plot_height_ratio", plot_height_ratio_, plot_height_ratio_);
+  private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("base_waypoints_rgba", base_waypoints_rgba_, base_waypoints_rgba_);
+  private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("final_waypoints_rgba", final_waypoints_rgba_, final_waypoints_rgba_);
+  private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("current_twist_rgba", current_twist_rgba_, current_twist_rgba_);
+  private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("command_twist_rgba", command_twist_rgba_, command_twist_rgba_);
+
+  base_waypoints_color_ = vector2color(base_waypoints_rgba_);
+  final_waypoints_color_ = vector2color(final_waypoints_rgba_);
+  current_twist_color_ = vector2color(current_twist_rgba_);
+  command_twist_color_ = vector2color(command_twist_rgba_);
+
+  current_pose_buf_.resize(control_buffer_size_);
+  current_twist_buf_.resize(control_buffer_size_);
+  command_twist_buf_.resize(control_buffer_size_);
+
+  base_waypoints_sub_ = node_handle_.subscribe("base_waypoints", 1, &amp;WaypointVelocityVizualizer::baseWaypointsCallback, this);
+  final_waypoints_sub_ = node_handle_.subscribe("final_waypoints", 1, &amp;WaypointVelocityVizualizer::finalWaypointsCallback, this);
+  closest_waypoint_sub_ = node_handle_.subscribe("closest_waypoint", 1, &amp;WaypointVelocityVizualizer::closestWaypointCallback, this);
+
+  current_pose_sub_ = new message_filters::Subscriber&lt;geometry_msgs::PoseStamped&gt;(node_handle_, "current_pose", 1);
+  current_twist_sub_ = new message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt;(node_handle_, "current_velocity", 1);
+  command_twist_sub_ = new message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt;(node_handle_, "twist_cmd", 1);
+  control_sync_ = new message_filters::Synchronizer&lt;ControlSyncPolicy&gt;(ControlSyncPolicy(100), *current_pose_sub_, *current_twist_sub_, *command_twist_sub_);
+  control_sync_-&gt;registerCallback(boost::bind(&amp;WaypointVelocityVizualizer::controlCallback, this, _1, _2, _3));
+
+  velocity_marker_pub_ = node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;("waypoints_velocity", 10, true);
 }
 
-void createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray&amp; lane_waypoints_array)
+WaypointVelocityVizualizer::~WaypointVelocityVizualizer()
 {
-  visualization_msgs::MarkerArray tmp_marker_array;
-  // display by markers the velocity of each waypoint.
-  visualization_msgs::Marker velocity_marker;
-  velocity_marker.header.frame_id = "map";
-  velocity_marker.header.stamp = ros::Time::now();
-  velocity_marker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
-  velocity_marker.action = visualization_msgs::Marker::ADD;
-  velocity_marker.scale.z = 0.4;
-  velocity_marker.color.r = 1;
-  velocity_marker.color.g = 1;
-  velocity_marker.color.b = 1;
-  velocity_marker.color.a = 1.0;
-  velocity_marker.frame_locked = true;
-
-  int count = 1;
-  for (auto lane : lane_waypoints_array.lanes)
-  {
-    velocity_marker.ns = "global_velocity_lane_" + std::to_string(count);
-    for (int i = 0; i &lt; static_cast&lt;int&gt;(lane.waypoints.size()); i++)
-    {
-      velocity_marker.id = i;
-      geometry_msgs::Point relative_p;
-      relative_p.y = 0.5;
-      velocity_marker.pose.position = calcAbsoluteCoordinate(relative_p, lane.waypoints[i].pose.pose);
-      velocity_marker.pose.position.z += 0.2;
-
-      // double to string
-      std::string vel = std::to_string(mps2kmph(lane.waypoints[i].twist.twist.linear.x));
-      velocity_marker.text = vel.erase(vel.find_first_of(".") + 2);
-
-      tmp_marker_array.markers.push_back(velocity_marker);
-    }
-    count++;
-  }
 
-  g_global_marker_array.markers.insert(g_global_marker_array.markers.end(), tmp_marker_array.markers.begin(),
-                                       tmp_marker_array.markers.end());
 }
 
-void createLocalWaypointVelocityMarker(std_msgs::ColorRGBA color, int closest_waypoint,
-                                       const autoware_msgs::lane&amp; lane_waypoint)
+std_msgs::ColorRGBA WaypointVelocityVizualizer::vector2color(const std::vector&lt;double&gt;&amp; v)
 {
-  // display by markers the velocity of each waypoint.
-  visualization_msgs::Marker velocity;
-  velocity.header.frame_id = "map";
-  velocity.header.stamp = ros::Time::now();
-  velocity.ns = "local_waypoint_velocity";
-  velocity.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
-  velocity.action = visualization_msgs::Marker::ADD;
-  velocity.scale.z = 0.4;
-  velocity.color = color;
-  velocity.frame_locked = true;
-
-  for (int i = 0; i &lt; static_cast&lt;int&gt;(lane_waypoint.waypoints.size()); i++)
-  {
-    velocity.id = i;
-    geometry_msgs::Point relative_p;
-    relative_p.y = -0.65;
-    velocity.pose.position = calcAbsoluteCoordinate(relative_p, lane_waypoint.waypoints[i].pose.pose);
-    velocity.pose.position.z += 0.2;
-
-    // double to string
-    std::ostringstream oss;
-    oss &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; mps2kmph(lane_waypoint.waypoints[i].twist.twist.linear.x);
-    velocity.text = oss.str();
-
-    g_local_waypoints_marker_array.markers.push_back(velocity);
-  }
+  std_msgs::ColorRGBA c;
+  c.r = v[0]; c.g = v[1]; c.b = v[2]; c.a = v[3];
+  return c;
 }
 
-void createVelocityBarGraphMarker(const autoware_msgs::lane&amp; lane_waypoint, const std::string str_name_space, const std::vector&lt;double&gt;&amp; flat_color)
+void WaypointVelocityVizualizer::baseWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg)
 {
-  visualization_msgs::Marker velocity_bar_graph_marker;
-  velocity_bar_graph_marker.header.frame_id = "map";
-  velocity_bar_graph_marker.header.stamp = ros::Time::now();
-  velocity_bar_graph_marker.ns = str_name_space + "_velocity_bar_graph_marker";
-  velocity_bar_graph_marker.type = visualization_msgs::Marker::CYLINDER;
-  velocity_bar_graph_marker.action = visualization_msgs::Marker::ADD;
-  velocity_bar_graph_marker.scale.x = 0.2;
-  velocity_bar_graph_marker.scale.y = 0.2;
-  velocity_bar_graph_marker.color.r = flat_color[0];
-  velocity_bar_graph_marker.color.g = flat_color[1];
-  velocity_bar_graph_marker.color.b = flat_color[2];
-  velocity_bar_graph_marker.color.a = flat_color[3];
-  velocity_bar_graph_marker.frame_locked = true;
-
-  unsigned int count = 0;
-  for (auto el : lane_waypoint.waypoints)
-  {
-    double bar_graph_height = g_graph_height_ratio * el.twist.twist.linear.x;
-    velocity_bar_graph_marker.id = count++;
-    velocity_bar_graph_marker.pose = el.pose.pose;
-    velocity_bar_graph_marker.pose.position.z += bar_graph_height / 2.0;
-    // When the the cylinder height is 0 or less, a warning occurs in RViz.
-    velocity_bar_graph_marker.scale.z = fabs(bar_graph_height) + 1e-6;
-    g_local_waypoints_marker_array.markers.push_back(velocity_bar_graph_marker);
-  }
+  base_waypoints_marker_array_.markers.clear();
+  createVelocityMarker(*msg, "base_waypoints", base_waypoints_color_, base_waypoints_marker_array_);
+  publishVelocityMarker();
 }
 
-void createVelocityLineGraphMarker(const autoware_msgs::lane&amp; lane_waypoint, const std::string str_name_space, const std::vector&lt;double&gt;&amp; flat_color)
+void WaypointVelocityVizualizer::finalWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg)
 {
-  visualization_msgs::Marker velocity_line_graph_marker;
-  velocity_line_graph_marker.header.frame_id = "map";
-  velocity_line_graph_marker.header.stamp = ros::Time::now();
-  velocity_line_graph_marker.ns = str_name_space + "_velocity_line_graph_marker";
-  velocity_line_graph_marker.type = visualization_msgs::Marker::LINE_STRIP;
-  velocity_line_graph_marker.action = visualization_msgs::Marker::ADD;
-  velocity_line_graph_marker.scale.x = 0.25;
-  velocity_line_graph_marker.color.r = flat_color[0];
-  velocity_line_graph_marker.color.g = flat_color[1];
-  velocity_line_graph_marker.color.b = flat_color[2];
-  velocity_line_graph_marker.color.a = flat_color[3];
-  velocity_line_graph_marker.frame_locked = true;
-
-  for (auto el : lane_waypoint.waypoints)
-  {
-    geometry_msgs::Point point = el.pose.pose.position;
-    point.z += g_graph_height_ratio * el.twist.twist.linear.x;
-    velocity_line_graph_marker.points.push_back(point);
-  }
-  g_local_waypoints_marker_array.markers.push_back(velocity_line_graph_marker);
+  final_waypoints_marker_array_.markers.clear();
+  createVelocityMarker(*msg, "final_waypoints", final_waypoints_color_, final_waypoints_marker_array_);
+  publishVelocityMarker();
 }
 
-void laneArrayCallback(const autoware_msgs::LaneArrayConstPtr&amp; msg)
+void WaypointVelocityVizualizer::closestWaypointCallback(const std_msgs::Int32::ConstPtr&amp; msg)
 {
-  g_global_marker_array.markers.clear();
+  closest_waypoint_ = msg-&gt;data;
 }
 
-void finalCallback(const autoware_msgs::laneConstPtr&amp; msg)
+void WaypointVelocityVizualizer::controlCallback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; current_twist_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; command_twist_msg)
 {
-  g_local_waypoints_marker_array.markers.clear();
-  createVelocityBarGraphMarker(*msg, "local", g_local_vel_graph_color);
-  createVelocityLineGraphMarker(*msg, "local", g_local_vel_graph_color);
-  createVelocityBarGraphMarker(g_current_vel_array, "current", g_current_vel_graph_color);
-  createVelocityLineGraphMarker(g_current_vel_array, "current", g_current_vel_graph_color);
-  createVelocityBarGraphMarker(g_command_vel_array, "command", g_command_vel_graph_color);
-  createVelocityLineGraphMarker(g_command_vel_array, "command", g_command_vel_graph_color);
-  publishLocalMarker();
+  current_pose_buf_.push_back(*current_pose_msg);
+  current_twist_buf_.push_back(*current_twist_msg);
+  command_twist_buf_.push_back(*command_twist_msg);
+  current_twist_marker_array_.markers.clear();
+  command_twist_marker_array_.markers.clear();
+  createVelocityMarker(current_pose_buf_, current_twist_buf_, "current_velocity", current_twist_color_, current_twist_marker_array_);
+  createVelocityMarker(current_pose_buf_, command_twist_buf_, "twist_cmd", command_twist_color_, command_twist_marker_array_);
+  publishVelocityMarker();
 }
 
-const bool isSyncTimeOn10Hz()
+void WaypointVelocityVizualizer::publishVelocityMarker()
 {
-  ros::Duration duration_diff[3];
-  ros::Time cpose_stamp = g_current_pose.header.stamp;
-  ros::Time cvel_stamp = g_current_vel.header.stamp;
-  ros::Time pvel_stamp = g_command_vel.header.stamp;
-  duration_diff[0] = cpose_stamp - cvel_stamp;
-  duration_diff[1] = cpose_stamp - pvel_stamp;
-  duration_diff[2] = cvel_stamp - pvel_stamp;
-  for(int i=0;i&lt;3;i++)
-  {
-    double diff_sec = fabs(1e-9 * duration_diff[i].nsec + duration_diff[i].sec);
-    if(diff_sec &gt;= 0.2)return false;//rejecting over 0.2sec delay
-  }
-  return true;
+  velocity_marker_array_.markers.clear();
+  velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(), base_waypoints_marker_array_.markers.begin(), base_waypoints_marker_array_.markers.end());
+  velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(), final_waypoints_marker_array_.markers.begin(), final_waypoints_marker_array_.markers.end());
+  velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(), current_twist_marker_array_.markers.begin(), current_twist_marker_array_.markers.end());
+  velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(), command_twist_marker_array_.markers.begin(), command_twist_marker_array_.markers.end());
+  velocity_marker_pub_.publish(velocity_marker_array_);
 }
 
-void pushVelocityArray()
+void WaypointVelocityVizualizer::createVelocityMarker(const std::vector&lt;nav_msgs::Odometry&gt; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
 {
-  const unsigned int pose_and_velocity_array_limits = 100;
-  std::vector&lt;autoware_msgs::waypoint&gt;&amp; cwp_array = g_current_vel_array.waypoints;
-  std::vector&lt;autoware_msgs::waypoint&gt;&amp; pwp_array = g_command_vel_array.waypoints;
-
-  autoware_msgs::waypoint current_wp, command_wp;
-  current_wp.pose = command_wp.pose = g_current_pose;
-  current_wp.twist = g_current_vel;
-  command_wp.twist = g_command_vel;
-  cwp_array.push_back(current_wp);
-  pwp_array.push_back(command_wp);
-  if(cwp_array.size() &gt; pose_and_velocity_array_limits)cwp_array.erase(cwp_array.begin());
-  if(pwp_array.size() &gt; pose_and_velocity_array_limits)pwp_array.erase(pwp_array.begin());
+  createVelocityBarMarker(waypoints, ns, color, markers);
+  createVelocityLineMarker(waypoints, ns, color, markers);
 }
 
-void currentPoseCallback(const geometry_msgs::PoseStamped&amp; pose)
+void WaypointVelocityVizualizer::createVelocityMarker(const autoware_msgs::lane&amp; lane, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
 {
-  g_current_pose = pose;
-  g_current_pose_subscribed = true;
-
-  bool is_sync_pose_and_velocity = (g_current_pose_subscribed &amp;&amp; g_current_vel_subscribed &amp;&amp; g_command_vel_subscribed);
-  if(!is_sync_pose_and_velocity)return;
-  if(!isSyncTimeOn10Hz())return;
-  pushVelocityArray();
-  g_current_pose_subscribed = g_current_vel_subscribed = g_command_vel_subscribed =false;
+  std::vector&lt;nav_msgs::Odometry&gt; waypoints;
+  for (auto wp : lane.waypoints)
+  {
+    nav_msgs::Odometry odom;
+    odom.pose.pose = wp.pose.pose;
+    odom.twist.twist = wp.twist.twist;
+    waypoints.push_back(odom);
+  }
+  createVelocityMarker(waypoints, ns, color, markers);
 }
 
-void currentVelocityCallback(const geometry_msgs::TwistStamped&amp; vel)
+void WaypointVelocityVizualizer::createVelocityMarker(const boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt;&amp; poses, const boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt;&amp; twists, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
 {
-  g_current_vel = vel;
-  g_current_vel_subscribed = true;
-
-  bool is_sync_pose_and_velocity = (g_current_pose_subscribed &amp;&amp; g_current_vel_subscribed &amp;&amp; g_command_vel_subscribed);
-  if(!is_sync_pose_and_velocity)return;
-  if(!isSyncTimeOn10Hz())return;
-  pushVelocityArray();
-  g_current_pose_subscribed = g_current_vel_subscribed = g_command_vel_subscribed =false;
+  assert(poses.size() == twists.size());
+  std::vector&lt;nav_msgs::Odometry&gt; waypoints;
+  for (unsigned int i = 0; i &lt; poses.size(); ++i)
+  {
+    nav_msgs::Odometry odom;
+    odom.pose.pose = poses[i].pose;
+    odom.twist.twist = twists[i].twist;
+    waypoints.push_back(odom);
+  }
+  createVelocityMarker(waypoints, ns, color, markers);
 }
 
-void commandVelocityCallback(const geometry_msgs::TwistStamped&amp; vel)
+void WaypointVelocityVizualizer::createVelocityBarMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
 {
-  g_command_vel = vel;
-  g_command_vel_subscribed = true;
-
-  bool is_sync_pose_and_velocity = (g_current_pose_subscribed &amp;&amp; g_current_vel_subscribed &amp;&amp; g_command_vel_subscribed);
-  if(!is_sync_pose_and_velocity)return;
-  if(!isSyncTimeOn10Hz())return;
-  pushVelocityArray();
-  g_current_pose_subscribed = g_current_vel_subscribed = g_command_vel_subscribed =false;
+  visualization_msgs::Marker marker;
+  marker.header.frame_id = "map";
+  marker.header.stamp = ros::Time::now();
+  marker.ns = ns + "/bar";
+  marker.type = visualization_msgs::Marker::CYLINDER;
+  marker.action = visualization_msgs::Marker::ADD;
+  marker.scale.x = 0.1;
+  marker.scale.y = 0.1;
+  marker.color = color;
+  marker.frame_locked = true;
+
+  unsigned int count = 0;
+  for (auto wp : waypoints)
+  {
+    double h =  plot_height_ratio_ * wp.twist.twist.linear.x;
+    marker.id = count++;
+    marker.pose = wp.pose.pose;
+    marker.pose.position.z += h / 2.0;
+    // When the the cylinder height is 0 or less, a warning occurs in RViz.
+    marker.scale.z = fabs(h) + 1e-6;
+    markers.markers.push_back(marker);
+  }
 }
 
-void closestCallback(const std_msgs::Int32ConstPtr&amp; msg)
+void WaypointVelocityVizualizer::createVelocityLineMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
 {
-  _closest_waypoint = msg-&gt;data;
-}
+  visualization_msgs::Marker marker;
+  marker.header.frame_id = "map";
+  marker.header.stamp = ros::Time::now();
+  marker.ns = ns + "/line";
+  marker.type = visualization_msgs::Marker::LINE_STRIP;
+  marker.action = visualization_msgs::Marker::ADD;
+  marker.scale.x = 0.1;
+  marker.color = color;
+  marker.frame_locked = true;
+
+  for (auto wp : waypoints)
+  {
+    geometry_msgs::Point p = wp.pose.pose.position;
+    p.z += plot_height_ratio_ * wp.twist.twist.linear.x;
+    marker.points.push_back(p);
+  }
+  markers.markers.push_back(marker);
 }
 
 int main(int argc, char** argv)
 {
-  ros::init(argc, argv, "waypoints_marker_publisher");
-  ros::NodeHandle nh;
-  ros::NodeHandle private_nh("~");
-
-  private_nh.param&lt;bool&gt;("use_velocity_visualizer", g_use_velocity_visualizer, false);
-  private_nh.param&lt;double&gt;("graph_height_ratio", g_graph_height_ratio, 1.0);
-  private_nh.param&lt;std::vector&lt;double&gt; &gt;("local_velocity_graph_color", g_local_vel_graph_color, g_local_vel_graph_color);
-  private_nh.param&lt;std::vector&lt;double&gt; &gt;("current_velocity_graph_color", g_current_vel_graph_color, g_current_vel_graph_color);
-  private_nh.param&lt;std::vector&lt;double&gt; &gt;("command_velocity_graph_color", g_command_vel_graph_color, g_command_vel_graph_color);
-
-  // subscribe local waypoints
-  ros::Subscriber final_sub = nh.subscribe("final_waypoints", 10, finalCallback);
-  ros::Subscriber closest_sub = nh.subscribe("closest_waypoint", 10, closestCallback);
-
-  // subscribe current pose &amp; velocity
-  ros::Subscriber current_pose_sub = nh.subscribe("current_pose", 10, currentPoseCallback);
-  ros::Subscriber current_vel_sub = nh.subscribe("current_velocity", 10, currentVelocityCallback);
-
-  // subscribe velocity command
-  ros::Subscriber command_vel_sub = nh.subscribe("twist_cmd", 10, commandVelocityCallback);
-
-  g_local_mark_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("local_waypoints_velocity", 10, true);
-  g_global_mark_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("global_waypoints_velocity", 10, true);
-
-  // initialize path color
-  _initial_color.g = 0.7;
-  _initial_color.b = 1.0;
-  _global_color = _initial_color;
-  _global_color.a = g_global_alpha;
-  g_local_color = _initial_color;
-  g_local_color.a = g_local_alpha;
-
+  ros::init(argc, argv, "waypoint_velocity_vizualizer");
+  WaypointVelocityVizualizer node;
   ros::spin();
+  return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="baf5760c0ebcc029d1393006381f298203b4fbd2" author="Akihito Ohsato">
		<msg>Fix circular buffer initialization</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_vizualizer\waypoint_velocity_vizualizer.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_vizualizer\waypoint_velocity_vizualizer.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -128,9 +128,9 @@ WaypointVelocityVizualizer::WaypointVelocityVizualizer() : node_handle_(), priva
   current_twist_color_ = vector2color(current_twist_rgba_);
   command_twist_color_ = vector2color(command_twist_rgba_);
 
-  current_pose_buf_.resize(control_buffer_size_);
-  current_twist_buf_.resize(control_buffer_size_);
-  command_twist_buf_.resize(control_buffer_size_);
+  current_pose_buf_.set_capacity(control_buffer_size_);
+  current_twist_buf_.set_capacity(control_buffer_size_);
+  command_twist_buf_.set_capacity(control_buffer_size_);
 
   base_waypoints_sub_ = node_handle_.subscribe("base_waypoints", 1, &amp;WaypointVelocityVizualizer::baseWaypointsCallback, this);
   final_waypoints_sub_ = node_handle_.subscribe("final_waypoints", 1, &amp;WaypointVelocityVizualizer::finalWaypointsCallback, this);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="551fb9fd8e80ec6d6eaac079d4c90f2a0a202537" author="Akihito Ohsato">
		<msg>Add velocity visualize as facing text</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_vizualizer\waypoint_velocity_vizualizer.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_vizualizer\waypoint_velocity_vizualizer.cpp" added_lines="30" deleted_lines="1">
				<diff>@@ -82,6 +82,7 @@ private:
 
   int control_buffer_size_ = 100;
   double plot_height_ratio_ = 1.0;
+  double plot_height_shift_ = 0.2;
   std::vector&lt;double&gt; base_waypoints_rgba_ = { 1.0, 1.0, 1.0, 0.5 };
   std::vector&lt;double&gt; final_waypoints_rgba_ = { 0.0, 1.0, 0.0, 0.5 };
   std::vector&lt;double&gt; current_twist_rgba_ = { 1.0, 0.0, 0.0, 0.5 };
@@ -112,6 +113,7 @@ private:
 
   void createVelocityBarMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
   void createVelocityLineMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
+  void createVelocityTextMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
 };
 
 WaypointVelocityVizualizer::WaypointVelocityVizualizer() : node_handle_(), private_node_handle_("~")
@@ -139,7 +141,7 @@ WaypointVelocityVizualizer::WaypointVelocityVizualizer() : node_handle_(), priva
   current_pose_sub_ = new message_filters::Subscriber&lt;geometry_msgs::PoseStamped&gt;(node_handle_, "current_pose", 1);
   current_twist_sub_ = new message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt;(node_handle_, "current_velocity", 1);
   command_twist_sub_ = new message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt;(node_handle_, "twist_cmd", 1);
-  control_sync_ = new message_filters::Synchronizer&lt;ControlSyncPolicy&gt;(ControlSyncPolicy(100), *current_pose_sub_, *current_twist_sub_, *command_twist_sub_);
+  control_sync_ = new message_filters::Synchronizer&lt;ControlSyncPolicy&gt;(ControlSyncPolicy(10), *current_pose_sub_, *current_twist_sub_, *command_twist_sub_);
   control_sync_-&gt;registerCallback(boost::bind(&amp;WaypointVelocityVizualizer::controlCallback, this, _1, _2, _3));
 
   velocity_marker_pub_ = node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;("waypoints_velocity", 10, true);
@@ -202,6 +204,7 @@ void WaypointVelocityVizualizer::createVelocityMarker(const std::vector&lt;nav_msgs
 {
   createVelocityBarMarker(waypoints, ns, color, markers);
   createVelocityLineMarker(waypoints, ns, color, markers);
+  createVelocityTextMarker(waypoints, ns, color, markers);
 }
 
 void WaypointVelocityVizualizer::createVelocityMarker(const autoware_msgs::lane&amp; lane, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
@@ -278,6 +281,32 @@ void WaypointVelocityVizualizer::createVelocityLineMarker(const std::vector&lt;nav_
   markers.markers.push_back(marker);
 }
 
+void WaypointVelocityVizualizer::createVelocityTextMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
+{
+  visualization_msgs::Marker marker;
+  marker.header.frame_id = "map";
+  marker.header.stamp = ros::Time::now();
+  marker.ns = ns + "/text";
+  marker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
+  marker.action = visualization_msgs::Marker::ADD;
+  marker.scale.z = 0.2;
+  marker.color = color;
+  marker.frame_locked = true;
+
+  unsigned int count = 0;
+  for (auto wp : waypoints)
+  {
+    marker.id = count++;
+    geometry_msgs::Point p = wp.pose.pose.position;
+    p.z += plot_height_ratio_ * wp.twist.twist.linear.x + plot_height_shift_;
+    marker.pose.position = p;
+    std::ostringstream oss;
+    oss &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; mps2kmph(wp.twist.twist.linear.x);
+    marker.text = oss.str();
+    markers.markers.push_back(marker);
+  }
+}
+
 int main(int argc, char** argv)
 {
   ros::init(argc, argv, "waypoint_velocity_vizualizer");
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="685fd86227e6ca6f9cfff4fa7d8301c3769c3355" author="Akihito Ohsato">
		<msg>Add some rosparam and fix launch file</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_vizualizer\waypoint_velocity_vizualizer.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_vizualizer\waypoint_velocity_vizualizer.cpp" added_lines="12" deleted_lines="5">
				<diff>@@ -80,13 +80,16 @@ private:
   visualization_msgs::MarkerArray current_twist_marker_array_;
   visualization_msgs::MarkerArray command_twist_marker_array_;
 
+  bool use_bar_plot_ = false;
+  bool use_line_plot_ = true;
+  bool use_text_plot_ = true;
   int control_buffer_size_ = 100;
   double plot_height_ratio_ = 1.0;
   double plot_height_shift_ = 0.2;
   std::vector&lt;double&gt; base_waypoints_rgba_ = { 1.0, 1.0, 1.0, 0.5 };
   std::vector&lt;double&gt; final_waypoints_rgba_ = { 0.0, 1.0, 0.0, 0.5 };
-  std::vector&lt;double&gt; current_twist_rgba_ = { 1.0, 0.0, 0.0, 0.5 };
-  std::vector&lt;double&gt; command_twist_rgba_ = { 0.0, 0.0, 1.0, 0.5 };
+  std::vector&lt;double&gt; current_twist_rgba_ = { 0.0, 0.0, 1.0, 0.5 };
+  std::vector&lt;double&gt; command_twist_rgba_ = { 1.0, 0.0, 0.0, 0.5 };
 
   std_msgs::ColorRGBA base_waypoints_color_;
   std_msgs::ColorRGBA final_waypoints_color_;
@@ -118,8 +121,12 @@ private:
 
 WaypointVelocityVizualizer::WaypointVelocityVizualizer() : node_handle_(), private_node_handle_("~")
 {
+  private_node_handle_.param&lt;bool&gt;("use_bar_plot", use_bar_plot_, use_bar_plot_);
+  private_node_handle_.param&lt;bool&gt;("use_line_plot", use_line_plot_, use_line_plot_);
+  private_node_handle_.param&lt;bool&gt;("use_text_plot", use_text_plot_, use_text_plot_);
   private_node_handle_.param&lt;int&gt;("control_buffer_size", control_buffer_size_, control_buffer_size_);
   private_node_handle_.param&lt;double&gt;("plot_height_ratio", plot_height_ratio_, plot_height_ratio_);
+  private_node_handle_.param&lt;double&gt;("plot_height_shift", plot_height_shift_, plot_height_shift_);
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("base_waypoints_rgba", base_waypoints_rgba_, base_waypoints_rgba_);
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("final_waypoints_rgba", final_waypoints_rgba_, final_waypoints_rgba_);
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("current_twist_rgba", current_twist_rgba_, current_twist_rgba_);
@@ -202,9 +209,9 @@ void WaypointVelocityVizualizer::publishVelocityMarker()
 
 void WaypointVelocityVizualizer::createVelocityMarker(const std::vector&lt;nav_msgs::Odometry&gt; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
 {
-  createVelocityBarMarker(waypoints, ns, color, markers);
-  createVelocityLineMarker(waypoints, ns, color, markers);
-  createVelocityTextMarker(waypoints, ns, color, markers);
+  if (use_bar_plot_) createVelocityBarMarker(waypoints, ns, color, markers);
+  if (use_line_plot_) createVelocityLineMarker(waypoints, ns, color, markers);
+  if (use_text_plot_) createVelocityTextMarker(waypoints, ns, color, markers);
 }
 
 void WaypointVelocityVizualizer::createVelocityMarker(const autoware_msgs::lane&amp; lane, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d12bb0a2ee2c25f284d0d45f118ad20a8cc2be3c" author="Akihito Ohsato">
		<msg>Modify plotting of controller response by metric interval</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_vizualizer\waypoint_velocity_vizualizer.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_vizualizer\waypoint_velocity_vizualizer.cpp" added_lines="10" deleted_lines="0">
				<diff>@@ -86,6 +86,7 @@ private:
   int control_buffer_size_ = 100;
   double plot_height_ratio_ = 1.0;
   double plot_height_shift_ = 0.2;
+  double plot_metric_interval_ = 1.0;
   std::vector&lt;double&gt; base_waypoints_rgba_ = { 1.0, 1.0, 1.0, 0.5 };
   std::vector&lt;double&gt; final_waypoints_rgba_ = { 0.0, 1.0, 0.0, 0.5 };
   std::vector&lt;double&gt; current_twist_rgba_ = { 0.0, 0.0, 1.0, 0.5 };
@@ -127,6 +128,7 @@ WaypointVelocityVizualizer::WaypointVelocityVizualizer() : node_handle_(), priva
   private_node_handle_.param&lt;int&gt;("control_buffer_size", control_buffer_size_, control_buffer_size_);
   private_node_handle_.param&lt;double&gt;("plot_height_ratio", plot_height_ratio_, plot_height_ratio_);
   private_node_handle_.param&lt;double&gt;("plot_height_shift", plot_height_shift_, plot_height_shift_);
+  private_node_handle_.param&lt;double&gt;("plot_metric_interval", plot_metric_interval_, plot_metric_interval_);
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("base_waypoints_rgba", base_waypoints_rgba_, base_waypoints_rgba_);
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("final_waypoints_rgba", final_waypoints_rgba_, final_waypoints_rgba_);
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("current_twist_rgba", current_twist_rgba_, current_twist_rgba_);
@@ -187,6 +189,14 @@ void WaypointVelocityVizualizer::closestWaypointCallback(const std_msgs::Int32::
 
 void WaypointVelocityVizualizer::controlCallback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; current_twist_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; command_twist_msg)
 {
+  if (plot_metric_interval_ &gt; 0 &amp;&amp; current_pose_buf_.size() &gt; 0)
+  {
+    tf::Vector3 p1, p2;
+    tf::pointMsgToTF(current_pose_buf_.back().pose.position, p1);
+    tf::pointMsgToTF(current_pose_msg-&gt;pose.position, p2);
+    if (!(p1.distance(p2) &gt; plot_metric_interval_)) return; // skipping plot
+  }
+  // if plot_metric_interval &lt;= 0, velocity is plotted by each callback.
   current_pose_buf_.push_back(*current_pose_msg);
   current_twist_buf_.push_back(*current_twist_msg);
   command_twist_buf_.push_back(*command_twist_msg);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c97b0c4bb42e1bd3c574cb334da66765fc6d0893" author="Akihito Ohsato">
		<msg>Fix typo</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_vizualizer\waypoint_velocity_vizualizer.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" added_lines="23" deleted_lines="30">
				<diff>@@ -52,11 +52,11 @@
 #include "autoware_msgs/ConfigLaneStop.h"
 #include "autoware_msgs/traffic_light.h"
 
-class WaypointVelocityVizualizer
+class WaypointVelocityVisualizer
 {
 public:
-  WaypointVelocityVizualizer();
-  ~WaypointVelocityVizualizer();
+  WaypointVelocityVisualizer();
+  ~WaypointVelocityVisualizer();
 
 private:
   typedef message_filters::sync_policies::ApproximateTime&lt;geometry_msgs::PoseStamped, geometry_msgs::TwistStamped, geometry_msgs::TwistStamped&gt; ControlSyncPolicy;
@@ -66,7 +66,6 @@ private:
 
   ros::Subscriber base_waypoints_sub_;
   ros::Subscriber final_waypoints_sub_;
-  ros::Subscriber closest_waypoint_sub_;
   message_filters::Subscriber&lt;geometry_msgs::PoseStamped&gt; *current_pose_sub_;
   message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt; *current_twist_sub_;
   message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt; *command_twist_sub_;
@@ -97,7 +96,6 @@ private:
   std_msgs::ColorRGBA current_twist_color_;
   std_msgs::ColorRGBA command_twist_color_;
 
-  int closest_waypoint_ = -1;
   boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt; current_pose_buf_;
   boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt; current_twist_buf_;
   boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt; command_twist_buf_;
@@ -106,7 +104,6 @@ private:
 
   void baseWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg);
   void finalWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg);
-  void closestWaypointCallback(const std_msgs::Int32::ConstPtr&amp; msg);
   void controlCallback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; current_twist_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; command_twist_msg);
 
   void publishVelocityMarker();
@@ -120,15 +117,17 @@ private:
   void createVelocityTextMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
 };
 
-WaypointVelocityVizualizer::WaypointVelocityVizualizer() : node_handle_(), private_node_handle_("~")
+WaypointVelocityVisualizer::WaypointVelocityVisualizer() : node_handle_(), private_node_handle_("~")
 {
   private_node_handle_.param&lt;bool&gt;("use_bar_plot", use_bar_plot_, use_bar_plot_);
   private_node_handle_.param&lt;bool&gt;("use_line_plot", use_line_plot_, use_line_plot_);
   private_node_handle_.param&lt;bool&gt;("use_text_plot", use_text_plot_, use_text_plot_);
+
   private_node_handle_.param&lt;int&gt;("control_buffer_size", control_buffer_size_, control_buffer_size_);
   private_node_handle_.param&lt;double&gt;("plot_height_ratio", plot_height_ratio_, plot_height_ratio_);
   private_node_handle_.param&lt;double&gt;("plot_height_shift", plot_height_shift_, plot_height_shift_);
   private_node_handle_.param&lt;double&gt;("plot_metric_interval", plot_metric_interval_, plot_metric_interval_);
+
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("base_waypoints_rgba", base_waypoints_rgba_, base_waypoints_rgba_);
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("final_waypoints_rgba", final_waypoints_rgba_, final_waypoints_rgba_);
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("current_twist_rgba", current_twist_rgba_, current_twist_rgba_);
@@ -143,51 +142,45 @@ WaypointVelocityVizualizer::WaypointVelocityVizualizer() : node_handle_(), priva
   current_twist_buf_.set_capacity(control_buffer_size_);
   command_twist_buf_.set_capacity(control_buffer_size_);
 
-  base_waypoints_sub_ = node_handle_.subscribe("base_waypoints", 1, &amp;WaypointVelocityVizualizer::baseWaypointsCallback, this);
-  final_waypoints_sub_ = node_handle_.subscribe("final_waypoints", 1, &amp;WaypointVelocityVizualizer::finalWaypointsCallback, this);
-  closest_waypoint_sub_ = node_handle_.subscribe("closest_waypoint", 1, &amp;WaypointVelocityVizualizer::closestWaypointCallback, this);
+  base_waypoints_sub_ = node_handle_.subscribe("base_waypoints", 1, &amp;WaypointVelocityVisualizer::baseWaypointsCallback, this);
+  final_waypoints_sub_ = node_handle_.subscribe("final_waypoints", 1, &amp;WaypointVelocityVisualizer::finalWaypointsCallback, this);
 
   current_pose_sub_ = new message_filters::Subscriber&lt;geometry_msgs::PoseStamped&gt;(node_handle_, "current_pose", 1);
   current_twist_sub_ = new message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt;(node_handle_, "current_velocity", 1);
   command_twist_sub_ = new message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt;(node_handle_, "twist_cmd", 1);
   control_sync_ = new message_filters::Synchronizer&lt;ControlSyncPolicy&gt;(ControlSyncPolicy(10), *current_pose_sub_, *current_twist_sub_, *command_twist_sub_);
-  control_sync_-&gt;registerCallback(boost::bind(&amp;WaypointVelocityVizualizer::controlCallback, this, _1, _2, _3));
+  control_sync_-&gt;registerCallback(boost::bind(&amp;WaypointVelocityVisualizer::controlCallback, this, _1, _2, _3));
 
   velocity_marker_pub_ = node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;("waypoints_velocity", 10, true);
 }
 
-WaypointVelocityVizualizer::~WaypointVelocityVizualizer()
+WaypointVelocityVisualizer::~WaypointVelocityVisualizer()
 {
 
 }
 
-std_msgs::ColorRGBA WaypointVelocityVizualizer::vector2color(const std::vector&lt;double&gt;&amp; v)
+std_msgs::ColorRGBA WaypointVelocityVisualizer::vector2color(const std::vector&lt;double&gt;&amp; v)
 {
   std_msgs::ColorRGBA c;
   c.r = v[0]; c.g = v[1]; c.b = v[2]; c.a = v[3];
   return c;
 }
 
-void WaypointVelocityVizualizer::baseWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg)
+void WaypointVelocityVisualizer::baseWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg)
 {
   base_waypoints_marker_array_.markers.clear();
   createVelocityMarker(*msg, "base_waypoints", base_waypoints_color_, base_waypoints_marker_array_);
   publishVelocityMarker();
 }
 
-void WaypointVelocityVizualizer::finalWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg)
+void WaypointVelocityVisualizer::finalWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg)
 {
   final_waypoints_marker_array_.markers.clear();
   createVelocityMarker(*msg, "final_waypoints", final_waypoints_color_, final_waypoints_marker_array_);
   publishVelocityMarker();
 }
 
-void WaypointVelocityVizualizer::closestWaypointCallback(const std_msgs::Int32::ConstPtr&amp; msg)
-{
-  closest_waypoint_ = msg-&gt;data;
-}
-
-void WaypointVelocityVizualizer::controlCallback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; current_twist_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; command_twist_msg)
+void WaypointVelocityVisualizer::controlCallback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; current_twist_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; command_twist_msg)
 {
   if (plot_metric_interval_ &gt; 0 &amp;&amp; current_pose_buf_.size() &gt; 0)
   {
@@ -207,7 +200,7 @@ void WaypointVelocityVizualizer::controlCallback(const geometry_msgs::PoseStampe
   publishVelocityMarker();
 }
 
-void WaypointVelocityVizualizer::publishVelocityMarker()
+void WaypointVelocityVisualizer::publishVelocityMarker()
 {
   velocity_marker_array_.markers.clear();
   velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(), base_waypoints_marker_array_.markers.begin(), base_waypoints_marker_array_.markers.end());
@@ -217,14 +210,14 @@ void WaypointVelocityVizualizer::publishVelocityMarker()
   velocity_marker_pub_.publish(velocity_marker_array_);
 }
 
-void WaypointVelocityVizualizer::createVelocityMarker(const std::vector&lt;nav_msgs::Odometry&gt; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
+void WaypointVelocityVisualizer::createVelocityMarker(const std::vector&lt;nav_msgs::Odometry&gt; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
 {
   if (use_bar_plot_) createVelocityBarMarker(waypoints, ns, color, markers);
   if (use_line_plot_) createVelocityLineMarker(waypoints, ns, color, markers);
   if (use_text_plot_) createVelocityTextMarker(waypoints, ns, color, markers);
 }
 
-void WaypointVelocityVizualizer::createVelocityMarker(const autoware_msgs::lane&amp; lane, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
+void WaypointVelocityVisualizer::createVelocityMarker(const autoware_msgs::lane&amp; lane, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
 {
   std::vector&lt;nav_msgs::Odometry&gt; waypoints;
   for (auto wp : lane.waypoints)
@@ -237,7 +230,7 @@ void WaypointVelocityVizualizer::createVelocityMarker(const autoware_msgs::lane&amp;
   createVelocityMarker(waypoints, ns, color, markers);
 }
 
-void WaypointVelocityVizualizer::createVelocityMarker(const boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt;&amp; poses, const boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt;&amp; twists, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
+void WaypointVelocityVisualizer::createVelocityMarker(const boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt;&amp; poses, const boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt;&amp; twists, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
 {
   assert(poses.size() == twists.size());
   std::vector&lt;nav_msgs::Odometry&gt; waypoints;
@@ -251,7 +244,7 @@ void WaypointVelocityVizualizer::createVelocityMarker(const boost::circular_buff
   createVelocityMarker(waypoints, ns, color, markers);
 }
 
-void WaypointVelocityVizualizer::createVelocityBarMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
+void WaypointVelocityVisualizer::createVelocityBarMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
 {
   visualization_msgs::Marker marker;
   marker.header.frame_id = "map";
@@ -277,7 +270,7 @@ void WaypointVelocityVizualizer::createVelocityBarMarker(const std::vector&lt;nav_m
   }
 }
 
-void WaypointVelocityVizualizer::createVelocityLineMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
+void WaypointVelocityVisualizer::createVelocityLineMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
 {
   visualization_msgs::Marker marker;
   marker.header.frame_id = "map";
@@ -298,7 +291,7 @@ void WaypointVelocityVizualizer::createVelocityLineMarker(const std::vector&lt;nav_
   markers.markers.push_back(marker);
 }
 
-void WaypointVelocityVizualizer::createVelocityTextMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
+void WaypointVelocityVisualizer::createVelocityTextMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
 {
   visualization_msgs::Marker marker;
   marker.header.frame_id = "map";
@@ -326,8 +319,8 @@ void WaypointVelocityVizualizer::createVelocityTextMarker(const std::vector&lt;nav_
 
 int main(int argc, char** argv)
 {
-  ros::init(argc, argv, "waypoint_velocity_vizualizer");
-  WaypointVelocityVizualizer node;
+  ros::init(argc, argv, "waypoint_velocity_visualizer");
+  WaypointVelocityVisualizer node;
   ros::spin();
   return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a498f6e08ed3e6f12c858338c88d5ce01530ffda" author="Akihito Ohsato">
		<msg>Apply clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" added_lines="85" deleted_lines="38">
				<diff>@@ -59,17 +59,19 @@ public:
   ~WaypointVelocityVisualizer();
 
 private:
-  typedef message_filters::sync_policies::ApproximateTime&lt;geometry_msgs::PoseStamped, geometry_msgs::TwistStamped, geometry_msgs::TwistStamped&gt; ControlSyncPolicy;
+  typedef message_filters::sync_policies::ApproximateTime&lt;geometry_msgs::PoseStamped, geometry_msgs::TwistStamped,
+                                                          geometry_msgs::TwistStamped&gt;
+      ControlSyncPolicy;
 
   ros::NodeHandle node_handle_;
   ros::NodeHandle private_node_handle_;
 
   ros::Subscriber base_waypoints_sub_;
   ros::Subscriber final_waypoints_sub_;
-  message_filters::Subscriber&lt;geometry_msgs::PoseStamped&gt; *current_pose_sub_;
-  message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt; *current_twist_sub_;
-  message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt; *command_twist_sub_;
-  message_filters::Synchronizer&lt;ControlSyncPolicy&gt; *control_sync_;
+  message_filters::Subscriber&lt;geometry_msgs::PoseStamped&gt;* current_pose_sub_;
+  message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt;* current_twist_sub_;
+  message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt;* command_twist_sub_;
+  message_filters::Synchronizer&lt;ControlSyncPolicy&gt;* control_sync_;
 
   ros::Publisher velocity_marker_pub_;
 
@@ -104,17 +106,26 @@ private:
 
   void baseWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg);
   void finalWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg);
-  void controlCallback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; current_twist_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; command_twist_msg);
+  void controlCallback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg,
+                       const geometry_msgs::TwistStamped::ConstPtr&amp; current_twist_msg,
+                       const geometry_msgs::TwistStamped::ConstPtr&amp; command_twist_msg);
 
   void publishVelocityMarker();
 
-  void createVelocityMarker(const std::vector&lt;nav_msgs::Odometry&gt; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
-  void createVelocityMarker(const autoware_msgs::lane&amp; lane, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
-  void createVelocityMarker(const boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt;&amp; poses, const boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt;&amp; twists, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
-
-  void createVelocityBarMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
-  void createVelocityLineMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
-  void createVelocityTextMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
+  void createVelocityMarker(const std::vector&lt;nav_msgs::Odometry&gt; waypoints, const std::string&amp; ns,
+                            const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
+  void createVelocityMarker(const autoware_msgs::lane&amp; lane, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color,
+                            visualization_msgs::MarkerArray&amp; markers);
+  void createVelocityMarker(const boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt;&amp; poses,
+                            const boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt;&amp; twists, const std::string&amp; ns,
+                            const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
+
+  void createVelocityBarMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns,
+                               const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
+  void createVelocityLineMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns,
+                                const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
+  void createVelocityTextMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns,
+                                const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers);
 };
 
 WaypointVelocityVisualizer::WaypointVelocityVisualizer() : node_handle_(), private_node_handle_("~")
@@ -129,7 +140,8 @@ WaypointVelocityVisualizer::WaypointVelocityVisualizer() : node_handle_(), priva
   private_node_handle_.param&lt;double&gt;("plot_metric_interval", plot_metric_interval_, plot_metric_interval_);
 
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("base_waypoints_rgba", base_waypoints_rgba_, base_waypoints_rgba_);
-  private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("final_waypoints_rgba", final_waypoints_rgba_, final_waypoints_rgba_);
+  private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("final_waypoints_rgba", final_waypoints_rgba_,
+                                                   final_waypoints_rgba_);
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("current_twist_rgba", current_twist_rgba_, current_twist_rgba_);
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("command_twist_rgba", command_twist_rgba_, command_twist_rgba_);
 
@@ -142,13 +154,17 @@ WaypointVelocityVisualizer::WaypointVelocityVisualizer() : node_handle_(), priva
   current_twist_buf_.set_capacity(control_buffer_size_);
   command_twist_buf_.set_capacity(control_buffer_size_);
 
-  base_waypoints_sub_ = node_handle_.subscribe("base_waypoints", 1, &amp;WaypointVelocityVisualizer::baseWaypointsCallback, this);
-  final_waypoints_sub_ = node_handle_.subscribe("final_waypoints", 1, &amp;WaypointVelocityVisualizer::finalWaypointsCallback, this);
+  base_waypoints_sub_ =
+      node_handle_.subscribe("base_waypoints", 1, &amp;WaypointVelocityVisualizer::baseWaypointsCallback, this);
+  final_waypoints_sub_ =
+      node_handle_.subscribe("final_waypoints", 1, &amp;WaypointVelocityVisualizer::finalWaypointsCallback, this);
 
   current_pose_sub_ = new message_filters::Subscriber&lt;geometry_msgs::PoseStamped&gt;(node_handle_, "current_pose", 1);
-  current_twist_sub_ = new message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt;(node_handle_, "current_velocity", 1);
+  current_twist_sub_ =
+      new message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt;(node_handle_, "current_velocity", 1);
   command_twist_sub_ = new message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt;(node_handle_, "twist_cmd", 1);
-  control_sync_ = new message_filters::Synchronizer&lt;ControlSyncPolicy&gt;(ControlSyncPolicy(10), *current_pose_sub_, *current_twist_sub_, *command_twist_sub_);
+  control_sync_ = new message_filters::Synchronizer&lt;ControlSyncPolicy&gt;(ControlSyncPolicy(10), *current_pose_sub_,
+                                                                       *current_twist_sub_, *command_twist_sub_);
   control_sync_-&gt;registerCallback(boost::bind(&amp;WaypointVelocityVisualizer::controlCallback, this, _1, _2, _3));
 
   velocity_marker_pub_ = node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;("waypoints_velocity", 10, true);
@@ -156,13 +172,15 @@ WaypointVelocityVisualizer::WaypointVelocityVisualizer() : node_handle_(), priva
 
 WaypointVelocityVisualizer::~WaypointVelocityVisualizer()
 {
-
 }
 
 std_msgs::ColorRGBA WaypointVelocityVisualizer::vector2color(const std::vector&lt;double&gt;&amp; v)
 {
   std_msgs::ColorRGBA c;
-  c.r = v[0]; c.g = v[1]; c.b = v[2]; c.a = v[3];
+  c.r = v[0];
+  c.g = v[1];
+  c.b = v[2];
+  c.a = v[3];
   return c;
 }
 
@@ -180,14 +198,17 @@ void WaypointVelocityVisualizer::finalWaypointsCallback(const autoware_msgs::lan
   publishVelocityMarker();
 }
 
-void WaypointVelocityVisualizer::controlCallback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; current_twist_msg, const geometry_msgs::TwistStamped::ConstPtr&amp; command_twist_msg)
+void WaypointVelocityVisualizer::controlCallback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg,
+                                                 const geometry_msgs::TwistStamped::ConstPtr&amp; current_twist_msg,
+                                                 const geometry_msgs::TwistStamped::ConstPtr&amp; command_twist_msg)
 {
   if (plot_metric_interval_ &gt; 0 &amp;&amp; current_pose_buf_.size() &gt; 0)
   {
     tf::Vector3 p1, p2;
     tf::pointMsgToTF(current_pose_buf_.back().pose.position, p1);
     tf::pointMsgToTF(current_pose_msg-&gt;pose.position, p2);
-    if (!(p1.distance(p2) &gt; plot_metric_interval_)) return; // skipping plot
+    if (!(p1.distance(p2) &gt; plot_metric_interval_))
+      return;  // skipping plot
   }
   // if plot_metric_interval &lt;= 0, velocity is plotted by each callback.
   current_pose_buf_.push_back(*current_pose_msg);
@@ -195,29 +216,46 @@ void WaypointVelocityVisualizer::controlCallback(const geometry_msgs::PoseStampe
   command_twist_buf_.push_back(*command_twist_msg);
   current_twist_marker_array_.markers.clear();
   command_twist_marker_array_.markers.clear();
-  createVelocityMarker(current_pose_buf_, current_twist_buf_, "current_velocity", current_twist_color_, current_twist_marker_array_);
-  createVelocityMarker(current_pose_buf_, command_twist_buf_, "twist_cmd", command_twist_color_, command_twist_marker_array_);
+  createVelocityMarker(current_pose_buf_, current_twist_buf_, "current_velocity", current_twist_color_,
+                       current_twist_marker_array_);
+  createVelocityMarker(current_pose_buf_, command_twist_buf_, "twist_cmd", command_twist_color_,
+                       command_twist_marker_array_);
   publishVelocityMarker();
 }
 
 void WaypointVelocityVisualizer::publishVelocityMarker()
 {
   velocity_marker_array_.markers.clear();
-  velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(), base_waypoints_marker_array_.markers.begin(), base_waypoints_marker_array_.markers.end());
-  velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(), final_waypoints_marker_array_.markers.begin(), final_waypoints_marker_array_.markers.end());
-  velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(), current_twist_marker_array_.markers.begin(), current_twist_marker_array_.markers.end());
-  velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(), command_twist_marker_array_.markers.begin(), command_twist_marker_array_.markers.end());
+  velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(),
+                                        base_waypoints_marker_array_.markers.begin(),
+                                        base_waypoints_marker_array_.markers.end());
+  velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(),
+                                        final_waypoints_marker_array_.markers.begin(),
+                                        final_waypoints_marker_array_.markers.end());
+  velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(),
+                                        current_twist_marker_array_.markers.begin(),
+                                        current_twist_marker_array_.markers.end());
+  velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(),
+                                        command_twist_marker_array_.markers.begin(),
+                                        command_twist_marker_array_.markers.end());
   velocity_marker_pub_.publish(velocity_marker_array_);
 }
 
-void WaypointVelocityVisualizer::createVelocityMarker(const std::vector&lt;nav_msgs::Odometry&gt; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
+void WaypointVelocityVisualizer::createVelocityMarker(const std::vector&lt;nav_msgs::Odometry&gt; waypoints,
+                                                      const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color,
+                                                      visualization_msgs::MarkerArray&amp; markers)
 {
-  if (use_bar_plot_) createVelocityBarMarker(waypoints, ns, color, markers);
-  if (use_line_plot_) createVelocityLineMarker(waypoints, ns, color, markers);
-  if (use_text_plot_) createVelocityTextMarker(waypoints, ns, color, markers);
+  if (use_bar_plot_)
+    createVelocityBarMarker(waypoints, ns, color, markers);
+  if (use_line_plot_)
+    createVelocityLineMarker(waypoints, ns, color, markers);
+  if (use_text_plot_)
+    createVelocityTextMarker(waypoints, ns, color, markers);
 }
 
-void WaypointVelocityVisualizer::createVelocityMarker(const autoware_msgs::lane&amp; lane, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
+void WaypointVelocityVisualizer::createVelocityMarker(const autoware_msgs::lane&amp; lane, const std::string&amp; ns,
+                                                      const std_msgs::ColorRGBA&amp; color,
+                                                      visualization_msgs::MarkerArray&amp; markers)
 {
   std::vector&lt;nav_msgs::Odometry&gt; waypoints;
   for (auto wp : lane.waypoints)
@@ -230,7 +268,10 @@ void WaypointVelocityVisualizer::createVelocityMarker(const autoware_msgs::lane&amp;
   createVelocityMarker(waypoints, ns, color, markers);
 }
 
-void WaypointVelocityVisualizer::createVelocityMarker(const boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt;&amp; poses, const boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt;&amp; twists, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
+void WaypointVelocityVisualizer::createVelocityMarker(const boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt;&amp; poses,
+                                                      const boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt;&amp; twists,
+                                                      const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color,
+                                                      visualization_msgs::MarkerArray&amp; markers)
 {
   assert(poses.size() == twists.size());
   std::vector&lt;nav_msgs::Odometry&gt; waypoints;
@@ -244,7 +285,9 @@ void WaypointVelocityVisualizer::createVelocityMarker(const boost::circular_buff
   createVelocityMarker(waypoints, ns, color, markers);
 }
 
-void WaypointVelocityVisualizer::createVelocityBarMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
+void WaypointVelocityVisualizer::createVelocityBarMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints,
+                                                         const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color,
+                                                         visualization_msgs::MarkerArray&amp; markers)
 {
   visualization_msgs::Marker marker;
   marker.header.frame_id = "map";
@@ -260,7 +303,7 @@ void WaypointVelocityVisualizer::createVelocityBarMarker(const std::vector&lt;nav_m
   unsigned int count = 0;
   for (auto wp : waypoints)
   {
-    double h =  plot_height_ratio_ * wp.twist.twist.linear.x;
+    double h = plot_height_ratio_ * wp.twist.twist.linear.x;
     marker.id = count++;
     marker.pose = wp.pose.pose;
     marker.pose.position.z += h / 2.0;
@@ -270,7 +313,9 @@ void WaypointVelocityVisualizer::createVelocityBarMarker(const std::vector&lt;nav_m
   }
 }
 
-void WaypointVelocityVisualizer::createVelocityLineMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
+void WaypointVelocityVisualizer::createVelocityLineMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints,
+                                                          const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color,
+                                                          visualization_msgs::MarkerArray&amp; markers)
 {
   visualization_msgs::Marker marker;
   marker.header.frame_id = "map";
@@ -291,7 +336,9 @@ void WaypointVelocityVisualizer::createVelocityLineMarker(const std::vector&lt;nav_
   markers.markers.push_back(marker);
 }
 
-void WaypointVelocityVisualizer::createVelocityTextMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints, const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color, visualization_msgs::MarkerArray&amp; markers)
+void WaypointVelocityVisualizer::createVelocityTextMarker(const std::vector&lt;nav_msgs::Odometry&gt;&amp; waypoints,
+                                                          const std::string&amp; ns, const std_msgs::ColorRGBA&amp; color,
+                                                          visualization_msgs::MarkerArray&amp; markers)
 {
   visualization_msgs::Marker marker;
   marker.header.frame_id = "map";
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="dcbbc968627b49e6c3fe4169e0a36a55c7ab66e9" author="Yuki Iida">
		<msg>add current_pose topic to mqtt msg</msg>
		<modified_files>
			<file old_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_sender\mqtt_sender.cpp" new_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_sender\mqtt_sender.cpp" added_lines="30" deleted_lines="0">
				<diff>@@ -33,6 +33,7 @@
 #include &lt;std_msgs/String.h&gt;
 #include &lt;std_msgs/Float64MultiArray.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
+#include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;unordered_map&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
@@ -59,6 +60,7 @@ private:
   void targetVelocityArrayCallback(const std_msgs::Float64MultiArray &amp;msg);
   void twistCmdCallback(const geometry_msgs::TwistStamped &amp;msg);
   void stateCallback(const std_msgs::String &amp;msg);
+  void currentPoseCallback(const geometry_msgs::PoseStamped&amp; msg);
   unordered_map&lt;string, ros::Subscriber&gt; Subs;
   ros::NodeHandle node_handle_;
 
@@ -67,6 +69,7 @@ private:
   string mqtt_topic_state_;
   string mqtt_topic_target_velocity_;
   string mqtt_topic_current_target_velocity_;
+  string mqtt_topic_current_pose_;
 
   // current behavior/status
   std_msgs::Float64MultiArray current_target_velocity_array_; //kmph
@@ -90,6 +93,7 @@ MqttSender::MqttSender() :
   Subs["target_velocity_array"] = node_handle_.subscribe("/target_velocity_array", 1, &amp;MqttSender::targetVelocityArrayCallback, this);
   Subs["twist_cmd"] = node_handle_.subscribe("/twist_cmd", 1, &amp;MqttSender::twistCmdCallback, this);
   Subs["state"] = node_handle_.subscribe("/state", 1, &amp;MqttSender::stateCallback, this);
+  Subs["current_pose"] = node_handle_.subscribe("/current_pose", 1, &amp;MqttSender::currentPoseCallback, this);
 
   // MQTT PARAMS
   mosquitto_lib_init();
@@ -101,6 +105,7 @@ MqttSender::MqttSender() :
   mqtt_topic_state_ = "vehicle/" + to_string(vehicle_id) + "/state";
   mqtt_topic_target_velocity_ = "vehicle/" + to_string(vehicle_id) + "/target_velocity";
   mqtt_topic_current_target_velocity_ = "vehicle/" + to_string(vehicle_id) + "/current_velocity";
+  mqtt_topic_current_pose_ = "vehicle/" + to_string(vehicle_id) + "/current_pose";
 
   mqtt_client = mosquitto_new(mqtt_client_id.c_str(), true, NULL);
   mosquitto_connect_callback_set(mqtt_client, &amp;MqttSender::on_connect);
@@ -145,6 +150,7 @@ static void MqttSender::load_config()
   caninfo_downsample = config["mqtt"]["CANINFO_DOWNSAMPLE"].as&lt;float&gt;();
   gear_d = config["mqtt"]["GEAR_D"].as&lt;int&gt;();
   gear_n = config["mqtt"]["GEAR_N"].as&lt;int&gt;();
+  unordered_map&lt;string, ros::Subscriber&gt; Subs;
   gear_r = config["mqtt"]["GEAR_R"].as&lt;int&gt;();
   gear_p = config["mqtt"]["GEAR_P"].as&lt;int&gt;();
 
@@ -212,6 +218,30 @@ void MqttSender::stateCallback(const std_msgs::String &amp;msg)
   );
 }
 
+void MqttSender::currentPoseCallback(const geometry_msgs::PoseStamped&amp; msg)
+{
+  ostringstream publish_msg;
+
+  publish_msg &lt;&lt; to_string(msg.pose.position.x) &lt;&lt; ",";
+  publish_msg &lt;&lt; to_string(msg.pose.position.y) &lt;&lt; ",";
+  publish_msg &lt;&lt; to_string(msg.pose.position.z) &lt;&lt; ",";
+  publish_msg &lt;&lt; to_string(msg.pose.orientation.x) &lt;&lt; ",";
+  publish_msg &lt;&lt; to_string(msg.pose.orientation.y) &lt;&lt; ",";
+  publish_msg &lt;&lt; to_string(msg.pose.orientation.z) &lt;&lt; ",";
+  publish_msg &lt;&lt; to_string(msg.pose.orientation.w) &lt;&lt; ",";
+
+  string publish_msg_str = publish_msg.str();
+  int ret = mosquitto_publish(
+    mqtt_client,
+    NULL,
+    mqtt_topic_current_pose_.c_str(),
+    strlen(publish_msg_str.c_str()),
+    publish_msg_str.c_str(),
+    mqtt_qos,
+    false
+  );
+}
+
 void MqttSender::canInfoCallback(const autoware_msgs::CanInfoConstPtr &amp;msg)
 {
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e7b99def98f04bff0779472b986d557cebf8951d" author="Akihito Ohsato">
		<msg>Add deleting marker/buffers for replaying rosbag, and some fix</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" added_lines="40" deleted_lines="12">
				<diff>@@ -98,11 +98,14 @@ private:
   std_msgs::ColorRGBA current_twist_color_;
   std_msgs::ColorRGBA command_twist_color_;
 
+  ros::Time previous_time_;
   boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt; current_pose_buf_;
   boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt; current_twist_buf_;
   boost::circular_buffer&lt;geometry_msgs::TwistStamped&gt; command_twist_buf_;
 
   std_msgs::ColorRGBA vector2color(const std::vector&lt;double&gt;&amp; v);
+  void deleteMarkers();
+  void resetBuffers();
 
   void baseWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg);
   void finalWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg);
@@ -150,6 +153,8 @@ WaypointVelocityVisualizer::WaypointVelocityVisualizer() : node_handle_(), priva
   current_twist_color_ = vector2color(current_twist_rgba_);
   command_twist_color_ = vector2color(command_twist_rgba_);
 
+  previous_time_ = ros::Time::now();
+
   current_pose_buf_.set_capacity(control_buffer_size_);
   current_twist_buf_.set_capacity(control_buffer_size_);
   command_twist_buf_.set_capacity(control_buffer_size_);
@@ -167,7 +172,7 @@ WaypointVelocityVisualizer::WaypointVelocityVisualizer() : node_handle_(), priva
                                                                        *current_twist_sub_, *command_twist_sub_);
   control_sync_-&gt;registerCallback(boost::bind(&amp;WaypointVelocityVisualizer::controlCallback, this, _1, _2, _3));
 
-  velocity_marker_pub_ = node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;("waypoints_velocity", 10, true);
+  velocity_marker_pub_ = node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;("waypoints_velocity", 10);
 }
 
 WaypointVelocityVisualizer::~WaypointVelocityVisualizer()
@@ -184,6 +189,22 @@ std_msgs::ColorRGBA WaypointVelocityVisualizer::vector2color(const std::vector&lt;d
   return c;
 }
 
+void WaypointVelocityVisualizer::deleteMarkers()
+{
+  velocity_marker_array_.markers.clear();
+  visualization_msgs::Marker marker;
+  marker.action = visualization_msgs::Marker::DELETEALL;
+  velocity_marker_array_.markers.push_back(marker);
+  velocity_marker_pub_.publish(velocity_marker_array_);
+}
+
+void WaypointVelocityVisualizer::resetBuffers()
+{
+  current_pose_buf_.clear();
+  current_twist_buf_.clear();
+  command_twist_buf_.clear();
+}
+
 void WaypointVelocityVisualizer::baseWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg)
 {
   base_waypoints_marker_array_.markers.clear();
@@ -202,6 +223,17 @@ void WaypointVelocityVisualizer::controlCallback(const geometry_msgs::PoseStampe
                                                  const geometry_msgs::TwistStamped::ConstPtr&amp; current_twist_msg,
                                                  const geometry_msgs::TwistStamped::ConstPtr&amp; command_twist_msg)
 {
+  // buffers are reset when time goes back, e.g. playback rosbag
+  ros::Time current_time = ros::Time::now();
+  if (previous_time_ &gt; current_time)
+  {
+    ROS_WARN("Detected jump back in time of %.3fs. Clearing markers and buffers.",
+             (previous_time_ - current_time).toSec());
+    deleteMarkers();  // call 'DELETEALL'
+    resetBuffers();   // clear circular buffers
+  }
+  previous_time_ = current_time;
+  // if plot_metric_interval &lt;= 0, velocity is plotted by each callback.
   if (plot_metric_interval_ &gt; 0 &amp;&amp; current_pose_buf_.size() &gt; 0)
   {
     tf::Vector3 p1, p2;
@@ -210,7 +242,6 @@ void WaypointVelocityVisualizer::controlCallback(const geometry_msgs::PoseStampe
     if (!(p1.distance(p2) &gt; plot_metric_interval_))
       return;  // skipping plot
   }
-  // if plot_metric_interval &lt;= 0, velocity is plotted by each callback.
   current_pose_buf_.push_back(*current_pose_msg);
   current_twist_buf_.push_back(*current_twist_msg);
   command_twist_buf_.push_back(*command_twist_msg);
@@ -258,7 +289,7 @@ void WaypointVelocityVisualizer::createVelocityMarker(const autoware_msgs::lane&amp;
                                                       visualization_msgs::MarkerArray&amp; markers)
 {
   std::vector&lt;nav_msgs::Odometry&gt; waypoints;
-  for (auto wp : lane.waypoints)
+  for (const auto&amp; wp : lane.waypoints)
   {
     nav_msgs::Odometry odom;
     odom.pose.pose = wp.pose.pose;
@@ -291,17 +322,16 @@ void WaypointVelocityVisualizer::createVelocityBarMarker(const std::vector&lt;nav_m
 {
   visualization_msgs::Marker marker;
   marker.header.frame_id = "map";
-  marker.header.stamp = ros::Time::now();
+  marker.header.stamp = ros::Time();
   marker.ns = ns + "/bar";
   marker.type = visualization_msgs::Marker::CYLINDER;
   marker.action = visualization_msgs::Marker::ADD;
   marker.scale.x = 0.1;
   marker.scale.y = 0.1;
   marker.color = color;
-  marker.frame_locked = true;
 
   unsigned int count = 0;
-  for (auto wp : waypoints)
+  for (const auto&amp; wp : waypoints)
   {
     double h = plot_height_ratio_ * wp.twist.twist.linear.x;
     marker.id = count++;
@@ -319,15 +349,14 @@ void WaypointVelocityVisualizer::createVelocityLineMarker(const std::vector&lt;nav_
 {
   visualization_msgs::Marker marker;
   marker.header.frame_id = "map";
-  marker.header.stamp = ros::Time::now();
+  marker.header.stamp = ros::Time();
   marker.ns = ns + "/line";
   marker.type = visualization_msgs::Marker::LINE_STRIP;
   marker.action = visualization_msgs::Marker::ADD;
   marker.scale.x = 0.1;
   marker.color = color;
-  marker.frame_locked = true;
 
-  for (auto wp : waypoints)
+  for (const auto&amp; wp : waypoints)
   {
     geometry_msgs::Point p = wp.pose.pose.position;
     p.z += plot_height_ratio_ * wp.twist.twist.linear.x;
@@ -342,16 +371,15 @@ void WaypointVelocityVisualizer::createVelocityTextMarker(const std::vector&lt;nav_
 {
   visualization_msgs::Marker marker;
   marker.header.frame_id = "map";
-  marker.header.stamp = ros::Time::now();
+  marker.header.stamp = ros::Time();
   marker.ns = ns + "/text";
   marker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
   marker.action = visualization_msgs::Marker::ADD;
   marker.scale.z = 0.2;
   marker.color = color;
-  marker.frame_locked = true;
 
   unsigned int count = 0;
-  for (auto wp : waypoints)
+  for (const auto&amp; wp : waypoints)
   {
     marker.id = count++;
     geometry_msgs::Point p = wp.pose.pose.position;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fd1d102bc2d0cadc7452be447235851f33308760" author="AMC">
		<msg>Fixing #1064 and #1065</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" added_lines="4" deleted_lines="0">
				<diff>@@ -193,7 +193,11 @@ void WaypointVelocityVisualizer::deleteMarkers()
 {
   velocity_marker_array_.markers.clear();
   visualization_msgs::Marker marker;
+#ifndef ROS_KINETIC
+  marker.action = visualization_msgs::Marker::DELETE;
+#else
   marker.action = visualization_msgs::Marker::DELETEALL;
+#endif
   velocity_marker_array_.markers.push_back(marker);
   velocity_marker_pub_.publish(velocity_marker_array_);
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b70257905a1c15bccc1c0f7a4c41756e54df4a1c" author="anhnv3991">
		<msg>Use the incremental update for ndt_mapping.
When new points are added to the current map, instead of rebuilding the whole map, only
update centroids and covariance matrixes of voxels that contain new points. Other voxels
remain untouch.
Remove octree since updating it is too slow.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\NormalDistributionsTransform.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\NormalDistributionsTransform.h" added_lines="2" deleted_lines="0">
				<diff>@@ -36,6 +36,8 @@ public:
 	/* Compute and get fitness score */
 	double getFitnessScore(double max_range = DBL_MAX);
 
+	void update(typename pcl::PointCloud&lt;PointTargetType&gt;::Ptr new_cloud);
+
 protected:
 	void computeTransformation(const Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess);
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\Registration.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\Registration.h" added_lines="2" deleted_lines="0">
				<diff>@@ -40,6 +40,8 @@ public:
 
 	bool hasConverged() const;
 
+	void updateInputTarget(typename pcl::PointCloud&lt;PointTargetType&gt;::Ptr new_cloud);
+
 	virtual ~Registration();
 
 protected:
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\VoxelGrid.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\VoxelGrid.h" added_lines="37" deleted_lines="29">
				<diff>@@ -54,7 +54,7 @@ public:
 
 	/* Searching for the nearest point of each input query point.
 	 * Return the distance between the query point and its nearest neighbor.
-	 * If the distance is larger than max_range, then return 0. */
+	 * If the distance is larger than max_range, then return DBL_MAX. */
 	double nearestNeighborDistance(PointSourceType query_point, float max_range);
 
 
@@ -62,6 +62,8 @@ public:
 	Eigen::Matrix3d getCovariance(int voxel_id) const;
 	Eigen::Matrix3d getInverseCovariance(int voxel_id) const;
 
+	void update(typename pcl::PointCloud&lt;PointSourceType&gt;::Ptr new_cloud);
+
 private:
 
 	/* Construct the voxel grid and the build the octree. */
@@ -78,25 +80,28 @@ private:
 	 * measured in number of leaf size */
 	void findBoundaries();
 
-	/* Size of the octree in each level,
-	 * measured in number of tree nodes. */
-	typedef struct _OctreeGridSize {
-		int size_x;
-		int size_y;
-		int size_z;
-	} OctreeGridSize;
-
-	/* Build octrees for nearest neighbor search.
-	 * Only used for searching one nearest neighbor point.
-	 * Cannot used for searching multiple nearest neighbors. */
-	void buildOctree();
+	void findBoundaries(typename pcl::PointCloud&lt;PointSourceType&gt;::Ptr input_cloud,
+							float &amp;max_x, float &amp;max_y, float &amp;max_z,
+							float &amp;min_x, float &amp;min_y, float &amp;min_z);
 
 	int voxelId(PointSourceType p);
 
-	void buildParent(std::vector&lt;Eigen::Vector3d&gt; &amp;child_centroids, std::vector&lt;int&gt; &amp;points_per_child, OctreeGridSize child_size,
-						std::vector&lt;Eigen::Vector3d&gt; &amp;parent_centroids, std::vector&lt;int&gt; &amp;points_per_parent, OctreeGridSize parent_size);
+	int voxelId(PointSourceType p,
+				float voxel_x, float voxel_y, float voxel_z,
+				int min_b_x, int min_b_y, int min_b_z,
+				int vgrid_x, int vgrid_y, int vgrid_z);
+
+	int voxelId(int idx, int idy, int idz,
+				int min_b_x, int min_b_y, int min_b_z,
+				int size_x, int size_y, int size_z);
+
+	/* Private methods for merging new point cloud to the current point cloud */
+	void updateBoundaries(float max_x, float max_y, float max_z,
+							float min_x, float min_y, float min_z);
+
+	void updateVoxelContent(typename pcl::PointCloud&lt;PointSourceType&gt;::Ptr new_cloud);
+
 
-	void nearestOctreeNodeSearch(PointSourceType q, Eigen::Vector3d &amp;node_id, int tree_level);
 
 	//Coordinate of input points
 	typename pcl::PointCloud&lt;PointSourceType&gt;::Ptr source_cloud_;
@@ -109,19 +114,22 @@ private:
 	int max_b_x_, max_b_y_, max_b_z_;	// Upper bounds of the grid, measured in number of voxels
 	int min_b_x_, min_b_y_, min_b_z_;	// Lower bounds of the grid, measured in number of voxels
 	int vgrid_x_, vgrid_y_, vgrid_z_;	// Size of the voxel grid, measured in number of voxels
-	int min_points_per_voxel_;
-
-	std::vector&lt;Eigen::Vector3d&gt; centroid_;
-	std::vector&lt;Eigen::Matrix3d&gt; covariance_;
-	std::vector&lt;Eigen::Matrix3d&gt; icovariance_;
-	std::vector&lt;std::vector&lt;int&gt; &gt; points_id_;
-	std::vector&lt;int&gt; points_per_voxel_;
-
-	/* Octree
-	 * Each element stores centroids of all voxels in the level */
-	std::vector&lt;std::vector&lt;Eigen::Vector3d&gt; &gt; octree_centroids_;
-	std::vector&lt;std::vector&lt;int&gt; &gt; points_per_node_;
-	std::vector&lt;OctreeGridSize&gt; octree_size_of_level_;
+	int min_points_per_voxel_;			// Minimum number of points per voxel. If the number of points
+										// per voxel is less than this number, then the voxel is ignored
+										// during computation (treated like it contains no point)
+
+	std::vector&lt;Eigen::Vector3d&gt; centroid_;			// 3x1 Centroid vectors of voxels
+	std::vector&lt;Eigen::Matrix3d&gt; covariance_;		// 3x3 Covariance matrixes of voxels
+	std::vector&lt;Eigen::Matrix3d&gt; icovariance_;		// Inverse covariance matrixes of voxel
+	std::vector&lt;std::vector&lt;int&gt; &gt; points_id_;		// Indexes of points belong to each voxel
+	std::vector&lt;int&gt; points_per_voxel_;				// Number of points belong to each voxel
+													// (may differ from size of each vector in points_id_
+													// because of changes made during computing covariances
+	std::vector&lt;Eigen::Vector3d&gt; tmp_centroid_;
+	std::vector&lt;Eigen::Matrix3d&gt; tmp_cov_;
+
+	int real_max_bx_, real_max_by_, real_max_bz_;
+	int real_min_bx_, real_min_by_, real_min_bz_;
 };
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\NormalDistributionsTransform.cpp" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\NormalDistributionsTransform.cpp" added_lines="9" deleted_lines="2">
				<diff>@@ -719,13 +719,12 @@ double NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::getFitnes
 	double distance;
 	int nr = 0;
 
-
 	for (int i = 0; i &lt; trans_cloud.points.size(); i++) {
 		PointSourceType q = trans_cloud.points[i];
 
 		distance = voxel_grid_.nearestNeighborDistance(q, max_range);
 
-		if (distance &lt;= max_range) {
+		if (distance &lt; max_range) {
 			fitness_score += distance;
 			nr++;
 		}
@@ -737,6 +736,14 @@ double NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::getFitnes
 	return DBL_MAX;
 }
 
+
+template &lt;typename PointSourceType, typename PointTargetType&gt;
+void NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::update(typename pcl::PointCloud&lt;PointTargetType&gt;::Ptr new_cloud)
+{
+	// Update voxel grid
+	voxel_grid_.update(new_cloud);
+}
+
 template class NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt;;
 template class NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt;;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" added_lines="512" deleted_lines="204">
				<diff>@@ -13,6 +13,12 @@
 #include "fast_pcl/ndt_cpu/SymmetricEigenSolver.h"
 
 namespace cpu {
+
+#define MAX_BX_ (128)
+#define MAX_BY_ (128)
+#define MAX_BZ_ (32)
+
+
 template &lt;typename PointSourceType&gt;
 VoxelGrid&lt;PointSourceType&gt;::VoxelGrid():
 	voxel_num_(0),
@@ -41,23 +47,56 @@ VoxelGrid&lt;PointSourceType&gt;::VoxelGrid():
 	icovariance_.clear();
 	points_id_.clear();
 	points_per_voxel_.clear();
-	octree_centroids_.clear();
-	points_per_node_.clear();
+	tmp_centroid_.clear();
+	tmp_cov_.clear();
 };
 
 template &lt;typename PointSourceType&gt;
 void VoxelGrid&lt;PointSourceType&gt;::initialize()
 {
+#define timeDiff(start, end) ((end.tv_sec - start.tv_sec) * 1000000 + end.tv_usec - start.tv_usec)
+
+	struct timeval start, end;
+
+	gettimeofday(&amp;start, NULL);
 	centroid_.resize(voxel_num_);
+	gettimeofday(&amp;end, NULL);
+
+	std::cout &lt;&lt; "Resize centroid = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
+	gettimeofday(&amp;start, NULL);
 	covariance_.resize(voxel_num_);
+	gettimeofday(&amp;end, NULL);
+
+	std::cout &lt;&lt; "Resize covariance = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
+	gettimeofday(&amp;start, NULL);
 	icovariance_.resize(voxel_num_);
+	gettimeofday(&amp;end, NULL);
 
+	std::cout &lt;&lt; "Resize icovariance = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
+
+	gettimeofday(&amp;start, NULL);
 	points_id_.resize(voxel_num_);
+	gettimeofday(&amp;end, NULL);
+
+	std::cout &lt;&lt; "Resize points id = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
+	gettimeofday(&amp;start, NULL);
 	points_per_voxel_.resize(voxel_num_);
+	gettimeofday(&amp;end, NULL);
 
+	std::cout &lt;&lt; "Resize points per voxel = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
+
+	gettimeofday(&amp;start, NULL);
+	// Reset the number of points in all voxels to zero
+	std::fill(points_per_voxel_.begin(), points_per_voxel_.end(), 0);
+	gettimeofday(&amp;end, NULL);
+
+	std::cout &lt;&lt; "Filling points per voxel = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
+
+	tmp_centroid_.resize(voxel_num_);
+	tmp_cov_.resize(voxel_num_);
 }
 
 template &lt;typename PointSourceType&gt;
@@ -203,75 +242,123 @@ void VoxelGrid&lt;PointSourceType&gt;::setLeafSize(float voxel_x, float voxel_y, float
 template &lt;typename PointSourceType&gt;
 int VoxelGrid&lt;PointSourceType&gt;::voxelId(PointSourceType p)
 {
-	int idx = static_cast&lt;int&gt;(floor(p.x / voxel_x_) - static_cast&lt;float&gt;(min_b_x_));
-	int idy = static_cast&lt;int&gt;(floor(p.y / voxel_y_) - static_cast&lt;float&gt;(min_b_y_));
-	int idz = static_cast&lt;int&gt;(floor(p.z / voxel_z_) - static_cast&lt;float&gt;(min_b_z_));
+	int idx = static_cast&lt;int&gt;(floor(p.x / voxel_x_)) - min_b_x_;
+	int idy = static_cast&lt;int&gt;(floor(p.y / voxel_y_)) - min_b_y_;
+	int idz = static_cast&lt;int&gt;(floor(p.z / voxel_z_)) - min_b_z_;
 
 	return (idx + idy * vgrid_x_ + idz * vgrid_x_ * vgrid_y_);
 }
 
+template &lt;typename PointSourceType&gt;
+int VoxelGrid&lt;PointSourceType&gt;::voxelId(PointSourceType p,
+											float voxel_x, float voxel_y, float voxel_z,
+											int min_b_x, int min_b_y, int min_b_z,
+											int vgrid_x, int vgrid_y, int vgrid_z)
+{
+	int idx = static_cast&lt;int&gt;(floor(p.x / voxel_x)) - min_b_x;
+	int idy = static_cast&lt;int&gt;(floor(p.y / voxel_y)) - min_b_y;
+	int idz = static_cast&lt;int&gt;(floor(p.z / voxel_z)) - min_b_z;
+
+	return (idx + idy * vgrid_x + idz * vgrid_x * vgrid_y);
+}
+
+template &lt;typename PointSourceType&gt;
+int VoxelGrid&lt;PointSourceType&gt;::voxelId(int idx, int idy, int idz,
+										int min_b_x, int min_b_y, int min_b_z,
+										int size_x, int size_y, int size_z)
+{
+	return (idx - min_b_x) + (idy - min_b_y) * size_x + (idz - min_b_z) * size_x * size_y;
+}
 
 template &lt;typename PointSourceType&gt;
 void VoxelGrid&lt;PointSourceType&gt;::computeCentroidAndCovariance()
 {
-	for (int i = 0; i &lt; voxel_num_; i++) {
-		int ipoint_num = points_id_[i].size();
-		double point_num = static_cast&lt;double&gt;(ipoint_num);
-		Eigen::Vector3d pt_sum = centroid_[i];
+	for (int idx = real_min_bx_; idx &lt;= real_max_bx_; idx++)
+		for (int idy = real_min_by_; idy &lt;= real_max_by_; idy++)
+			for (int idz = real_min_bz_; idz &lt;= real_max_bz_; idz++) {
+				int i = voxelId(idx, idy, idz, min_b_x_, min_b_y_, min_b_z_, vgrid_x_, vgrid_y_, vgrid_z_);
+				int ipoint_num = points_id_[i].size();
+				double point_num = static_cast&lt;double&gt;(ipoint_num);
+				Eigen::Vector3d pt_sum = tmp_centroid_[i];
 
-		if (ipoint_num &gt; 0) {
-			centroid_[i] /= point_num;
-		}
+				if (ipoint_num &gt; 0) {
+					centroid_[i] = pt_sum / point_num;
+				}
 
-		if (ipoint_num &gt;= min_points_per_voxel_) {
 
-			covariance_[i] = (covariance_[i] - 2 * (pt_sum * centroid_[i].transpose())) / point_num + centroid_[i] * centroid_[i].transpose();
-			covariance_[i] *= (point_num - 1.0) / point_num;
+				if (ipoint_num &gt;= min_points_per_voxel_) {
+					covariance_[i] = (tmp_cov_[i] - 2.0 * (pt_sum * centroid_[i].transpose())) / point_num + centroid_[i] * centroid_[i].transpose();
+					covariance_[i] *= (point_num - 1.0) / point_num;
 
-			SymmetricEigensolver3x3 sv(covariance_[i]);
+					SymmetricEigensolver3x3 sv(covariance_[i]);
 
-			sv.compute();
-			Eigen::Matrix3d evecs = sv.eigenvectors();
-			Eigen::Matrix3d evals = sv.eigenvalues().asDiagonal();
+					sv.compute();
+					Eigen::Matrix3d evecs = sv.eigenvectors();
+					Eigen::Matrix3d evals = sv.eigenvalues().asDiagonal();
 
-			if (evals(0, 0) &lt; 0 || evals(1, 1) &lt; 0 || evals(2, 2) &lt;= 0) {
-				points_per_voxel_[i] = -1;
-				continue;
-			}
+					if (evals(0, 0) &lt; 0 || evals(1, 1) &lt; 0 || evals(2, 2) &lt;= 0) {
+						points_per_voxel_[i] = -1;
+						continue;
+					}
 
-			double min_cov_eigvalue = evals(2, 2) * 0.01;
+					double min_cov_eigvalue = evals(2, 2) * 0.01;
 
-			if (evals(0, 0) &lt; min_cov_eigvalue) {
-				evals(0, 0) = min_cov_eigvalue;
+					if (evals(0, 0) &lt; min_cov_eigvalue) {
+						evals(0, 0) = min_cov_eigvalue;
 
-				if (evals(1, 1) &lt; min_cov_eigvalue) {
-					evals(1, 1) = min_cov_eigvalue;
-				}
+						if (evals(1, 1) &lt; min_cov_eigvalue) {
+							evals(1, 1) = min_cov_eigvalue;
+						}
 
-				covariance_[i] = evecs * evals * evecs.inverse();
-			}
+						covariance_[i] = evecs * evals * evecs.inverse();
+					}
 
-			icovariance_[i] = covariance_[i].inverse();
-		}
-	}
+					icovariance_[i] = covariance_[i].inverse();
+				}
+			}
 }
 
 //Input are supposed to be in device memory
 template &lt;typename PointSourceType&gt;
 void VoxelGrid&lt;PointSourceType&gt;::setInput(typename pcl::PointCloud&lt;PointSourceType&gt;::Ptr input_cloud)
 {
-	if (input_cloud-&gt;points.size() &gt; 0) {
+	if (voxel_num_ &gt; 0) {
+		/* If a voxel grid has already existed,
+		 * only set the source_cloud_ pointer to
+		 * point to new input cloud
+		 */
 		source_cloud_ = input_cloud;
+	} else if (input_cloud-&gt;points.size() &gt; 0) {
+		/* If no voxel grid was created, then
+		 * build the initial voxel grid and octree
+		 */
+		source_cloud_ = input_cloud;
+
+#define timeDiff(start, end) ((end.tv_sec - start.tv_sec) * 1000000 + end.tv_usec - start.tv_usec)
 
+		struct timeval start, end;
+
+		gettimeofday(&amp;start, NULL);
 		findBoundaries();
+		gettimeofday(&amp;end, NULL);
+
+		std::cout &lt;&lt; "Find boundaries = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
+		gettimeofday(&amp;start, NULL);
 		initialize();
+		gettimeofday(&amp;end, NULL);
+
+		std::cout &lt;&lt; "Initialize = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
+		gettimeofday(&amp;start, NULL);
 		scatterPointsToVoxelGrid();
+		gettimeofday(&amp;end, NULL);
 
-		computeCentroidAndCovariance();
+		std::cout &lt;&lt; "Scatter points = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
-		buildOctree();
+		gettimeofday(&amp;start, NULL);
+		computeCentroidAndCovariance();
+		gettimeofday(&amp;end, NULL);
 	}
 }
 
@@ -279,40 +366,65 @@ template &lt;typename PointSourceType&gt;
 void VoxelGrid&lt;PointSourceType&gt;::findBoundaries()
 {
 
-	for (int i = 0; i &lt; source_cloud_-&gt;points.size(); i++) {
-		float x = source_cloud_-&gt;points[i].x;
-		float y = source_cloud_-&gt;points[i].y;
-		float z = source_cloud_-&gt;points[i].z;
+	findBoundaries(source_cloud_, max_x_, max_y_, max_z_, min_x_, min_y_, min_z_);
 
-		if (i == 0) {
-			max_x_ = min_x_ = x;
-			max_y_ = min_y_ = y;
-			max_z_ = min_z_ = z;
-		} else {
+	real_max_bx_ = max_b_x_ = static_cast&lt;int&gt; (floor(max_x_ / voxel_x_));
+	real_max_by_ = max_b_y_ = static_cast&lt;int&gt; (floor(max_y_ / voxel_y_));
+	real_max_bz_ = max_b_z_ = static_cast&lt;int&gt; (floor(max_z_ / voxel_z_));
 
-			max_x_ = (max_x_ &gt; x) ? max_x_ : x;
-			max_y_ = (max_y_ &gt; y) ? max_y_ : y;
-			max_z_ = (max_z_ &gt; z) ? max_z_ : z;
+	real_min_bx_ = min_b_x_ = static_cast&lt;int&gt; (floor(min_x_ / voxel_x_));
+	real_min_by_ = min_b_y_ = static_cast&lt;int&gt; (floor(min_y_ / voxel_y_));
+	real_min_bz_ = min_b_z_ = static_cast&lt;int&gt; (floor(min_z_ / voxel_z_));
 
-			min_x_ = (min_x_ &lt; x) ? min_x_ : x;
-			min_y_ = (min_y_ &lt; y) ? min_y_ : y;
-			min_z_ = (min_z_ &lt; z) ? min_z_ : z;
-		}
-	}
-
-	max_b_x_ = static_cast&lt;int&gt; (floor(max_x_ / voxel_x_));
-	max_b_y_ = static_cast&lt;int&gt; (floor(max_y_ / voxel_y_));
-	max_b_z_ = static_cast&lt;int&gt; (floor(max_z_ / voxel_z_));
+	/* Allocate a poll of memory that is larger than the requested memory so
+	 * we do not have to reallocate buffers when the target cloud is set
+	 */
+	/* Max bounds round toward plus infinity */
+	max_b_x_ = (max_b_x_ &lt; 0) ? (-(- max_b_x_) / MAX_BX_) * MAX_BX_ : ((max_b_x_ - 1) / MAX_BX_ + 1) * MAX_BX_;
+	max_b_y_ = (max_b_y_ &lt; 0) ? (-(- max_b_y_) / MAX_BY_) * MAX_BY_ : ((max_b_y_ - 1) / MAX_BY_ + 1) * MAX_BY_;
+	max_b_z_ = (max_b_z_ &lt; 0) ? (-(- max_b_z_) / MAX_BZ_) * MAX_BZ_ : ((max_b_z_ - 1) / MAX_BZ_ + 1) * MAX_BZ_;
 
-	min_b_x_ = static_cast&lt;int&gt; (floor(min_x_ / voxel_x_));
-	min_b_y_ = static_cast&lt;int&gt; (floor(min_y_ / voxel_y_));
-	min_b_z_ = static_cast&lt;int&gt; (floor(min_z_ / voxel_z_));
+	/* Min bounds round toward minus infinity */
+	min_b_x_ = (min_b_x_ &lt; 0) ? (-((- min_b_x_ - 1) / MAX_BX_ + 1)) * MAX_BX_ : (min_b_x_ / MAX_BX_) * MAX_BX_;
+	min_b_y_ = (min_b_y_ &lt; 0) ? (-((- min_b_y_ - 1) / MAX_BY_ + 1)) * MAX_BY_ : (min_b_y_ / MAX_BY_) * MAX_BY_;
+	min_b_z_ = (min_b_z_ &lt; 0) ? (-((- min_b_z_ - 1) / MAX_BZ_ + 1)) * MAX_BZ_ : (min_b_z_ / MAX_BZ_) * MAX_BZ_;
 
 	vgrid_x_ = max_b_x_ - min_b_x_ + 1;
 	vgrid_y_ = max_b_y_ - min_b_y_ + 1;
 	vgrid_z_ = max_b_z_ - min_b_z_ + 1;
 
-	voxel_num_ = vgrid_x_ * vgrid_y_ * vgrid_z_;
+	if (vgrid_x_ &gt; 0 &amp;&amp; vgrid_y_ &gt; 0 &amp;&amp; vgrid_z_ &gt; 0)
+		voxel_num_ = vgrid_x_ * vgrid_y_ * vgrid_z_;
+	else
+		voxel_num_ = 0;
+}
+
+template &lt;typename PointSourceType&gt;
+void VoxelGrid&lt;PointSourceType&gt;::findBoundaries(typename pcl::PointCloud&lt;PointSourceType&gt;::Ptr input_cloud,
+													float &amp;max_x, float &amp;max_y, float &amp;max_z,
+													float &amp;min_x, float &amp;min_y, float &amp;min_z)
+{
+
+	for (int i = 0; i &lt; input_cloud-&gt;points.size(); i++) {
+		float x = input_cloud-&gt;points[i].x;
+		float y = input_cloud-&gt;points[i].y;
+		float z = input_cloud-&gt;points[i].z;
+
+		if (i == 0) {
+			max_x = min_x = x;
+			max_y = min_y = y;
+			max_z = min_z = z;
+		} else {
+
+			max_x = (max_x &gt; x) ? max_x : x;
+			max_y = (max_y &gt; y) ? max_y : y;
+			max_z = (max_z &gt; z) ? max_z : z;
+
+			min_x = (min_x &lt; x) ? min_x : x;
+			min_y = (min_y &lt; y) ? min_y : y;
+			min_z = (min_z &lt; z) ? min_z : z;
+		}
+	}
 }
 
 template &lt;typename PointSourceType&gt;
@@ -333,20 +445,21 @@ void VoxelGrid&lt;PointSourceType&gt;::radiusSearch(PointSourceType p, float radius, s
 	/* Find intersection of the cube containing
 	 * the NN sphere of the point and the voxel grid
 	 */
-	max_id_x = (max_id_x &gt; max_b_x_) ? max_b_x_ - min_b_x_ : max_id_x - min_b_x_;
-	max_id_y = (max_id_y &gt; max_b_y_) ? max_b_y_ - min_b_y_ : max_id_y - min_b_y_;
-	max_id_z = (max_id_z &gt; max_b_z_) ? max_b_z_ - min_b_z_ : max_id_z - min_b_z_;
-
-	min_id_x = (min_id_x &lt; min_b_x_) ? 0 : min_id_x - min_b_x_;
-	min_id_y = (min_id_y &lt; min_b_y_) ? 0 : min_id_y - min_b_y_;
-	min_id_z = (min_id_z &lt; min_b_z_) ? 0 : min_id_z - min_b_z_;
+	max_id_x = (max_id_x &gt; real_max_bx_) ? real_max_bx_ : max_id_x;
+	max_id_y = (max_id_y &gt; real_max_by_) ? real_max_by_ : max_id_y;
+	max_id_z = (max_id_z &gt; real_max_bz_) ? real_max_bz_ : max_id_z;
 
+	min_id_x = (min_id_x &lt; real_min_bx_) ? real_min_bx_ : min_id_x;
+	min_id_y = (min_id_y &lt; real_min_by_) ? real_min_by_ : min_id_y;
+	min_id_z = (min_id_z &lt; real_min_bz_) ? real_min_bz_ : min_id_z;
 	int nn = 0;
 
 	for (int idx = min_id_x; idx &lt;= max_id_x &amp;&amp; nn &lt; max_nn; idx++) {
 		for (int idy = min_id_y; idy &lt;= max_id_y &amp;&amp; nn &lt; max_nn; idy++) {
 			for (int idz = min_id_z; idz &lt;= max_id_z &amp;&amp; nn &lt; max_nn; idz++) {
-				int vid = idx + idy * vgrid_x_ + idz * vgrid_x_ * vgrid_y_;
+				int vid = voxelId(idx, idy, idz,
+									min_b_x_, min_b_y_, min_b_z_,
+									vgrid_x_, vgrid_y_, vgrid_z_);
 
 				if (points_per_voxel_[vid] &gt;= min_points_per_voxel_) {
 					double cx = centroid_[vid](0) - static_cast&lt;double&gt;(t_x);
@@ -377,211 +490,406 @@ void VoxelGrid&lt;PointSourceType&gt;::scatterPointsToVoxelGrid()
 
 		if (points_id_[vid].size() == 0) {
 			centroid_[vid].setZero();
-			covariance_[vid].setIdentity();
-			icovariance_[vid].setZero();
 			points_per_voxel_[vid] = 0;
+			tmp_centroid_[vid].setZero();
+			tmp_cov_[vid].setIdentity();
 		}
 
-		centroid_[vid] += p3d;
-		covariance_[vid] += p3d * p3d.transpose();
+		tmp_centroid_[vid] += p3d;
+		tmp_cov_[vid] += p3d * p3d.transpose();
 		points_id_[vid].push_back(pid);
 		points_per_voxel_[vid]++;
 	}
 }
 
-/* Build parent nodes from child nodes of the octree */
 template &lt;typename PointSourceType&gt;
-void VoxelGrid&lt;PointSourceType&gt;::buildParent(std::vector&lt;Eigen::Vector3d&gt; &amp;child_centroids, std::vector&lt;int&gt; &amp;points_per_child, OctreeGridSize child_size,
-												std::vector&lt;Eigen::Vector3d&gt; &amp;parent_centroids, std::vector&lt;int&gt; &amp;points_per_parent, OctreeGridSize parent_size)
+double VoxelGrid&lt;PointSourceType&gt;::nearestNeighborDistance(PointSourceType query_point, float max_range)
 {
+	// Index of the origin of the circle (query point)
+	float qx = query_point.x;
+	float qy = query_point.y;
+	float qz = query_point.z;
 
-	for (int px = 0; px &lt; parent_size.size_x; px++) {
-		for (int py = 0; py &lt; parent_size.size_y; py++) {
-			for (int pz = 0; pz &lt; parent_size.size_z; pz++) {
-				int pid = px + py * parent_size.size_x + pz * parent_size.size_x * parent_size.size_y;
-				int ppoints_num = 0;
+	int ovx = static_cast&lt;int&gt;(floor(qx / voxel_x_));
+	int ovy = static_cast&lt;int&gt;(floor(qy / voxel_y_));
+	int ovz = static_cast&lt;int&gt;(floor(qz / voxel_z_));
+
+	// Now find index of the nearest voxel (may be empty or not)
+	int nvx, nvy, nvz, fvx, fvy, fvz;
+
+	if (ovx &gt; real_max_bx_) {
+		nvx = real_max_bx_;
+		fvx = real_min_bx_;
+	} else if (ovx &lt; real_min_bx_) {
+		nvx = real_min_bx_;
+		fvx = real_max_bx_;
+	} else {
+		nvx = ovx;
+		fvx = (real_max_bx_ - ovx &gt; ovx - real_min_bx_) ? real_max_bx_ : real_min_bx_;
+	}
 
-				parent_centroids[pid].setZero();
+	if (ovy &gt; real_max_by_) {
+		nvy = real_max_by_;
+		fvy = real_min_by_;
+	} else if (ovy &lt; real_min_by_) {
+		nvy = real_min_by_;
+		fvy = real_max_by_;
+	} else {
+		nvy = ovy;
+		fvy = (real_max_by_ - ovy &gt; ovy - real_min_by_) ? real_max_by_ : real_min_by_;
+	}
 
-				for (int cx = px * 2; cx &lt; px * 2 + 2 &amp;&amp; cx &lt; child_size.size_x; cx++) {
-					for (int cy = py * 2; cy &lt; py * 2 + 2 &amp;&amp; cy &lt; child_size.size_y; cy++) {
-						for (int cz = pz * 2; cz &lt; pz * 2 + 2 &amp;&amp; cz &lt; child_size.size_z; cz++) {
-							int cid = cx + cy * child_size.size_x + cz * child_size.size_x * child_size.size_y;
-							int cpoints_num = points_per_child[cid];
+	if (ovz &gt; real_max_bz_) {
+		nvz = real_max_bz_;
+		fvz = real_min_bz_;
+	} else if (ovz &lt; real_min_bz_) {
+		nvz = real_min_bz_;
+		fvz = real_max_bz_;
+	} else {
+		nvz = ovz;
+		fvz = (real_max_bz_ - ovz &gt; ovz - real_min_bz_) ? real_max_bz_ : real_min_bz_;
+	}
 
-							if (cpoints_num &gt; 0) {
-								//std::cout &lt;&lt; "Child centroid = " &lt;&lt; child_centroids[cid] &lt;&lt; std::endl;
-								parent_centroids[pid] += static_cast&lt;double&gt;(cpoints_num) * child_centroids[cid];
-								ppoints_num += cpoints_num;
-							}
-						}
+	// Now find index of the furthest voxel
+
+	int min_radius = static_cast&lt;int&gt;(sqrt((nvx - ovx) * (nvx - ovx) + (nvy - ovy) * (nvy - ovy) + (nvz - ovz) * (nvz - ovz)));
+	int max_radius = static_cast&lt;int&gt;(sqrt((nvx - ovx) * (nvx - ovx) + (nvy - ovy) * (nvy - ovy) + (nvz - ovz) * (nvz - ovz)));
+
+	/* Check all voxels laying on the circle. If a voxel is
+	 * not empty, then break immediately.
+	 * If those voxels are all empty, then increase the radius
+	 * and repeat the process. */
+	bool found_nn = false;
+	int nn_vid;
+
+	for (int radius = min_radius; radius &lt;= max_radius &amp;&amp; !found_nn; radius++) {
+		// Find the intersection of the circle with the voxel grid
+		int lower_bx, upper_bx, lower_by, upper_by, lower_bz, upper_bz;
+
+		lower_bx = (ovx - radius &gt; real_min_bx_) ? ovx - radius : real_min_bx_;
+		upper_bx = (ovx + radius &gt; real_max_bx_) ? real_max_bx_ : ovx + radius;
+
+		lower_by = (ovy - radius &gt; real_min_by_) ? ovy - radius : real_min_by_;
+		upper_by = (ovy + radius &gt; real_max_by_) ? real_max_by_ : ovy + radius;
+
+		lower_bz = (ovz - radius &gt; real_min_bz_) ? ovz - radius : real_min_bz_;
+		upper_bz = (ovz + radius &gt; real_max_bz_) ? real_max_bz_ : ovz + radius;
+
+		for (int i = lower_bx; i &lt;= upper_bx &amp;&amp; !found_nn; i++) {
+			for (int j = lower_by; j &lt;= upper_by &amp;&amp; !found_nn; j++) {
+				int kz = static_cast&lt;int&gt;(sqrt(radius * radius - (ovx - i) * (ovx - i) - (ovy - j) * (ovy - j)));
+				int k;
+				int vid;
+
+				k = ovz + kz;
+				if (k &gt;= lower_bz &amp;&amp; k &lt;= upper_bz) {
+					vid = voxelId(i, j, k, min_b_x_, min_b_y_, min_b_z_, vgrid_x_, vgrid_y_, vgrid_z_);
+
+					if (points_id_[vid].size() &gt; 0) {
+						found_nn = true;
+						nn_vid = vid;
+						break;
 					}
 				}
 
-				if (ppoints_num &gt; 0) {
-					parent_centroids[pid] /= static_cast&lt;double&gt;(ppoints_num);
-				}
+				k = ovz - kz;
 
-				points_per_parent[pid] = ppoints_num;
+				if (k &gt;= lower_bz &amp;&amp; k &lt;= upper_bz) {
+					vid = voxelId(i, j, k, min_b_x_, min_b_y_, min_b_z_, vgrid_x_, vgrid_y_, vgrid_z_);
+
+					if (points_id_[vid].size() &gt; 0) {
+						found_nn = true;
+						nn_vid = vid;
+						break;
+					}
+				}
 			}
 		}
 	}
-}
 
+//	std::vector&lt;int&gt; &amp;tmp_pid = points_id_[nn_vid];
+//
+//	float min_dist = DBL_MAX;
+//
+//
+//	for (int i = 0; i &lt; tmp_pid.size(); i++) {
+//		PointSourceType p = source_cloud_-&gt;points[tmp_pid[i]];
+//		float distance = sqrt((p.x - qx) * (p.x - qx) + (p.y - qy) * (p.y - qy) + (p.z - qz) * (p.z - qz));
+//
+//		if (distance &lt; min_dist) {
+//			min_dist = distance;
+//		}
+//	}
+
+	Eigen::Vector3d c = centroid_[nn_vid];
+	double min_dist = sqrt((qx - c(0)) * (qx - c(0)) + (qy - c(1)) * (qy - c(1)) + (qz - c(2)) * (qz - c(2)));
+
+	if (min_dist &gt;= max_range)
+		return DBL_MAX;
+
+	return static_cast&lt;double&gt;(min_dist);
+}
 
 template &lt;typename PointSourceType&gt;
-void VoxelGrid&lt;PointSourceType&gt;::buildOctree()
+void VoxelGrid&lt;PointSourceType&gt;::updateBoundaries(float max_x, float max_y, float max_z,
+													float min_x, float min_y, float min_z)
 {
-	octree_centroids_.clear();
-	points_per_node_.clear();
-	octree_size_of_level_.clear();
 
-	//Push leafs to the bottom of the tree
-	octree_centroids_.push_back(centroid_);
+	float new_max_x, new_max_y, new_max_z;
+	float new_min_x, new_min_y, new_min_z;
 
-	std::vector&lt;int&gt; points_per_octree_node(points_id_.size());
+	new_max_x = (max_x_ &gt;= max_x) ? max_x_ : max_x;
+	new_max_y = (max_y_ &gt;= max_y) ? max_y_ : max_y;
+	new_max_z = (max_z_ &gt;= max_z) ? max_z_ : max_z;
 
-	for (int i = 0; i &lt; points_id_.size(); i++) {
-		points_per_octree_node[i] = points_id_[i].size();
-	}
+	new_min_x = (min_x_ &lt;= min_x) ? min_x_ : min_x;
+	new_min_y = (min_y_ &lt;= min_y) ? min_y_ : min_y;
+	new_min_z = (min_z_ &lt;= min_z) ? min_z_ : min_z;
+
+	/* If the boundaries change, then we need to extend the
+	 * list of voxels as well as the octree
+	 */
+	if (new_max_x &gt; max_x_ || new_max_y &gt; max_y_ || new_max_z &gt; max_z_ ||
+			new_min_x &lt; min_x_ || new_min_y &lt; min_y_ || new_min_z &lt; min_z_) {
+
+		int max_b_x = static_cast&lt;int&gt; (floor(new_max_x / voxel_x_));
+		int max_b_y = static_cast&lt;int&gt; (floor(new_max_y / voxel_y_));
+		int max_b_z = static_cast&lt;int&gt; (floor(new_max_z / voxel_z_));
+
+		int min_b_x = static_cast&lt;int&gt; (floor(new_min_x / voxel_x_));
+		int min_b_y = static_cast&lt;int&gt; (floor(new_min_y / voxel_y_));
+		int min_b_z = static_cast&lt;int&gt; (floor(new_min_z / voxel_z_));
+
+		int real_max_bx = max_b_x;
+		int real_max_by = max_b_y;
+		int real_max_bz = max_b_z;
+
+		int real_min_bx = min_b_x;
+		int real_min_by = min_b_y;
+		int real_min_bz = min_b_z;
+
+		/* Max bounds round toward plus infinity */
+		max_b_x = (max_b_x &lt; 0) ? (-(- max_b_x) / MAX_BX_) * MAX_BX_ : ((max_b_x - 1) / MAX_BX_ + 1) * MAX_BX_;
+		max_b_y = (max_b_y &lt; 0) ? (-(- max_b_y) / MAX_BY_) * MAX_BY_ : ((max_b_y - 1) / MAX_BY_ + 1) * MAX_BY_;
+		max_b_z = (max_b_z &lt; 0) ? (-(- max_b_z) / MAX_BZ_) * MAX_BZ_ : ((max_b_z - 1) / MAX_BZ_ + 1) * MAX_BZ_;
+
+		/* Min bounds round toward minus infinity */
+		min_b_x = (min_b_x &lt; 0) ? (-((- min_b_x - 1) / MAX_BX_ + 1)) * MAX_BX_ : (min_b_x / MAX_BX_) * MAX_BX_;
+		min_b_y = (min_b_y &lt; 0) ? (-((- min_b_y - 1) / MAX_BY_ + 1)) * MAX_BY_ : (min_b_y / MAX_BY_) * MAX_BY_;
+		min_b_z = (min_b_z &lt; 0) ? (-((- min_b_z - 1) / MAX_BZ_ + 1)) * MAX_BZ_ : (min_b_z / MAX_BZ_) * MAX_BZ_;
+
+		if (max_b_x &gt; max_b_x_ || max_b_y &gt; max_b_y_ || max_b_z &gt; max_b_z_ ||
+				min_b_x &lt; min_b_x_ || min_b_y &lt; min_b_y_ || min_b_z &lt; min_b_z_) {
+			int vgrid_x = max_b_x - min_b_x + 1;
+			int vgrid_y = max_b_y - min_b_y + 1;
+			int vgrid_z = max_b_z - min_b_z + 1;
+
+			int voxel_num = vgrid_x * vgrid_y * vgrid_z;
+
+			std::vector&lt;Eigen::Vector3d&gt; new_centroid(voxel_num);
+			std::vector&lt;Eigen::Matrix3d&gt; new_covariance(voxel_num);
+			std::vector&lt;Eigen::Matrix3d&gt; new_icovariance(voxel_num);
+			std::vector&lt;std::vector&lt;int&gt; &gt; points_id(voxel_num);
+			std::vector&lt;int&gt; points_per_voxel(voxel_num, 0);
+
+			std::vector&lt;Eigen::Vector3d&gt; new_tmp_centroid(voxel_num);
+			std::vector&lt;Eigen::Matrix3d&gt; new_tmp_cov(voxel_num);
+
+			// Move the old non-empty voxels to the new list of voxels
+
+			int idx, idy, idz;
+			int old_id, new_id;
+
+			for (int idx = real_min_bx_; idx &lt;= real_max_bx_; idx++) {
+				for (int idy = real_min_by_; idy &lt;= real_max_by_; idy++) {
+					for (int idz = real_min_bz_; idz &lt;= real_max_bz_; idz++) {
+						old_id = voxelId(idx, idy, idz,
+											min_b_x_, min_b_y_, min_b_z_,
+											vgrid_x_, vgrid_y_, vgrid_z_);
+						new_id = voxelId(idx, idy, idz,
+											min_b_x, min_b_y, min_b_z,
+											vgrid_x, vgrid_y, vgrid_z);
+
+						if (points_id_[old_id].size() &gt; 0) {
+							points_per_voxel[new_id] = points_per_voxel_[old_id];
+							new_centroid[new_id] = centroid_[old_id];
+							new_covariance[new_id] = covariance_[old_id];
+							new_icovariance[new_id] = icovariance_[old_id];
+							points_id[new_id] = points_id_[old_id];
+
+							new_tmp_centroid[new_id] = tmp_centroid_[old_id];
+							new_tmp_cov[new_id] = tmp_cov_[old_id];
+						}
+					}
+				}
+			}
 
-	points_per_node_.push_back(points_per_octree_node);
-	OctreeGridSize grid_size;
+			centroid_.clear();
+			covariance_.clear();
+			icovariance_.clear();
+			points_id_.clear();
+			points_per_voxel_.clear();
+			tmp_centroid_.clear();
+			tmp_cov_.clear();
 
-	grid_size.size_x = vgrid_x_;
-	grid_size.size_y = vgrid_y_;
-	grid_size.size_z = vgrid_z_;
+			centroid_ = new_centroid;
+			covariance_ = new_covariance;
+			icovariance_ = new_icovariance;
+			points_id_ = points_id;
+			points_per_voxel_ = points_per_voxel;
+			tmp_centroid_ = new_tmp_centroid;
+			tmp_cov_ = new_tmp_cov;
 
-	octree_size_of_level_.push_back(grid_size);
 
-	int node_number = voxel_num_;
-	OctreeGridSize child_size, parent_size;
+			// Update boundaries of voxels
+			max_b_x_ = max_b_x;
+			max_b_y_ = max_b_y;
+			max_b_z_ = max_b_z;
 
-	int i = 0;
+			min_b_x_ = min_b_x;
+			min_b_y_ = min_b_y;
+			min_b_z_ = min_b_z;
 
-	while (node_number &gt; 8) {
-		child_size = octree_size_of_level_[i];
-		parent_size.size_x = (child_size.size_x - 1) / 2 + 1;
-		parent_size.size_y = (child_size.size_y - 1) / 2 + 1;
-		parent_size.size_z = (child_size.size_z - 1) / 2 + 1;
+			vgrid_x_ = vgrid_x;
+			vgrid_y_ = vgrid_y;
+			vgrid_z_ = vgrid_z;
 
-		node_number = parent_size.size_x * parent_size.size_y * parent_size.size_z;
+			voxel_num_ = voxel_num;
 
-		std::vector&lt;Eigen::Vector3d&gt; parent_centroids(node_number);
-		std::vector&lt;int&gt; points_per_parent(node_number);
+		}
+		// Update actual voxel boundaries
+		real_min_bx_ = real_min_bx;
+		real_min_by_ = real_min_by;
+		real_min_bz_ = real_min_bz;
 
-		std::vector&lt;Eigen::Vector3d&gt; &amp;child_centroids = octree_centroids_[i];
-		std::vector&lt;int&gt; &amp;points_per_child = points_per_node_[i];
+		real_max_bx_ = real_max_bx;
+		real_max_by_ = real_max_by;
+		real_max_bz_ = real_max_bz;
 
-		buildParent(child_centroids, points_per_child, child_size, parent_centroids, points_per_parent, parent_size);
 
-		octree_centroids_.push_back(parent_centroids);
-		points_per_node_.push_back(points_per_parent);
+		//Update boundaries of points
+		max_x_ = new_max_x;
+		max_y_ = new_max_y;
+		max_z_ = new_max_z;
 
-		octree_size_of_level_.push_back(parent_size);
+		min_x_ = new_min_x;
+		min_y_ = new_min_y;
+		min_z_ = new_min_z;
 
-		i++;
 	}
 }
 
-/* Search for the nearest octree node */
 template &lt;typename PointSourceType&gt;
-void VoxelGrid&lt;PointSourceType&gt;::nearestOctreeNodeSearch(PointSourceType p, Eigen::Vector3d &amp;node_id, int tree_level)
+void VoxelGrid&lt;PointSourceType&gt;::update(typename pcl::PointCloud&lt;PointSourceType&gt;::Ptr new_cloud)
 {
-	struct timeval start, end;
-
-	int vx = node_id(0);
-	int vy = node_id(1);
-	int vz = node_id(2);
-	double min_dist = DBL_MAX;
-	double t_x = static_cast&lt;double&gt;(p.x);
-	double t_y = static_cast&lt;double&gt;(p.y);
-	double t_z = static_cast&lt;double&gt;(p.z);
-	double cur_dist;
-
+	if (new_cloud-&gt;points.size() &lt;= 0)
+		return;
 
-	int vgrid_x = octree_size_of_level_[tree_level].size_x;
-	int vgrid_y = octree_size_of_level_[tree_level].size_y;
-	int vgrid_z = octree_size_of_level_[tree_level].size_z;
+	float new_max_x, new_max_y, new_max_z;
+	float new_min_x, new_min_y, new_min_z;
+	int shift_x, shift_y, shift_z;
 
-	std::vector&lt;Eigen::Vector3d&gt; &amp;current_centroids = octree_centroids_[tree_level];
+#define timeDiff(start, end) ((end.tv_sec - start.tv_sec) * 1000000 + end.tv_usec - start.tv_usec)
 
-	int out_x, out_y, out_z;
+	struct timeval start, end;
 
-	double tmp_x, tmp_y, tmp_z;
+	gettimeofday(&amp;start, NULL);
+	// Find boundaries of the new point cloud
+	findBoundaries(new_cloud, new_max_x, new_max_y, new_max_z, new_min_x, new_min_y, new_min_z);
+	gettimeofday(&amp;end, NULL);
 
-	std::vector&lt;int&gt; &amp;current_level_points_per_node = points_per_node_[tree_level];
+	std::cout &lt;&lt; "Find boundaries = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
-	for (int j = vx * 2; j &lt; vx * 2 + 2 &amp;&amp; j &lt; vgrid_x; j++) {
-		for (int k = vy * 2; k &lt; vy * 2 + 2 &amp;&amp; k &lt; vgrid_y; k++) {
-			for (int l = vz * 2; l &lt; vz * 2 + 2 &amp;&amp; l &lt; vgrid_z; l++) {
-				int nid = j + k * vgrid_x + l * vgrid_x * vgrid_y;
-				int points = current_level_points_per_node[nid];
-				Eigen::Vector3d node_centr = current_centroids[nid];
+	gettimeofday(&amp;start, NULL);
 
-				if (points &gt; 0) {
-					tmp_x = node_centr(0) - t_x;
-					tmp_y = node_centr(1) - t_y;
-					tmp_z = node_centr(2) - t_z;
+	/* Update current boundaries of the voxel grid
+	 * Also allocate buffer for new voxel grid and
+	 * octree and move the current voxel grid and
+	 * octree to the new buffer if necessary
+	 */
+	updateBoundaries(new_max_x, new_max_y, new_max_z, new_min_x, new_min_y, new_min_z);
 
-					cur_dist = sqrt(tmp_x * tmp_x + tmp_y * tmp_y + tmp_z * tmp_z);
+	gettimeofday(&amp;end, NULL);
 
-					if (cur_dist &lt; min_dist) {
-						out_x = j;
-						out_y = k;
-						out_z = l;
+	std::cout &lt;&lt; "Update boundaries = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
-						min_dist = cur_dist;
-					}
-				}
-			}
-		}
-	}
+	gettimeofday(&amp;start, NULL);
+	/* Update changed voxels (voxels that contains new points).
+	 * Update centroids of voxels and their covariance matrixes
+	 * as well as inverse covariance matrixes */
+	updateVoxelContent(new_cloud);
+	gettimeofday(&amp;end, NULL);
 
-	node_id(0) = out_x;
-	node_id(1) = out_y;
-	node_id(2) = out_z;
+	std::cout &lt;&lt; "Update voxel content = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 }
 
 template &lt;typename PointSourceType&gt;
-double VoxelGrid&lt;PointSourceType&gt;::nearestNeighborDistance(PointSourceType query_point, float max_range)
+void VoxelGrid&lt;PointSourceType&gt;::updateVoxelContent(typename pcl::PointCloud&lt;PointSourceType&gt;::Ptr new_cloud)
 {
-	Eigen::Vector3d node_id;
+	int total_points_num = source_cloud_-&gt;points.size();
 
-	node_id.setZero();
+	for (int i = 0; i &lt; new_cloud-&gt;points.size(); i++) {
+		PointSourceType p = new_cloud-&gt;points[i];
+		Eigen::Vector3d p3d(p.x, p.y, p.z);
+		int vx = static_cast&lt;int&gt;(floor(p.x / voxel_x_));
+		int vy = static_cast&lt;int&gt;(floor(p.y / voxel_y_));
+		int vz = static_cast&lt;int&gt;(floor(p.z / voxel_z_));
+		int vid = voxelId(vx, vy, vz, min_b_x_, min_b_y_, min_b_z_, vgrid_x_, vgrid_y_, vgrid_z_);
+		std::vector&lt;int&gt; &amp;tmp_pid = points_id_[vid];
 
-	// Go through top of the octree to the bottom
-	for (int i = octree_centroids_.size() - 1; i &gt;= 0; i--) {
-		nearestOctreeNodeSearch(query_point, node_id, i);
-	}
+		if (tmp_pid.size() == 0) {
+			centroid_[vid].setZero();
+			tmp_cov_[vid].setIdentity();
+			tmp_centroid_[vid].setZero();
+		}
 
-	int voxel_id = node_id(0) + node_id(1) * vgrid_x_ + node_id(2) * vgrid_x_ * vgrid_y_;
+		tmp_centroid_[vid] += p3d;
+		tmp_cov_[vid] += p3d * p3d.transpose();
+		points_id_[vid].push_back(total_points_num + i);
 
-	std::vector&lt;int&gt; &amp;pid_list = points_id_[voxel_id];
+		// Update centroids
+		int ipoint_num = points_id_[vid].size();
+		centroid_[vid] = tmp_centroid_[vid] / static_cast&lt;double&gt;(ipoint_num);
+		points_per_voxel_[vid] = ipoint_num;
 
-	float min_dist = FLT_MAX;
-	float qx = query_point.x;
-	float qy = query_point.y;
-	float qz = query_point.z;
 
-	//std::cout &lt;&lt; "Voxel id = " &lt;&lt; voxel_id &lt;&lt; std::endl;
-	//std::cout &lt;&lt; "PID LIST SIZE = " &lt;&lt; pid_list.size() &lt;&lt; std::endl;
+		// Update covariance
+		double point_num = static_cast&lt;double&gt;(ipoint_num);
+		Eigen::Vector3d pt_sum = tmp_centroid_[vid];
 
-	for (int i = 0; i &lt; pid_list.size(); i++) {
-		float tx = source_cloud_-&gt;points[pid_list[i]].x - qx;
-		float ty = source_cloud_-&gt;points[pid_list[i]].y - qy;
-		float tz = source_cloud_-&gt;points[pid_list[i]].z - qz;
-		float cur_dist = sqrt(tx * tx + ty * ty + tz * tz);
+		// Update  centroids
+		centroid_[vid] = tmp_centroid_[vid] / point_num;
 
-		if (cur_dist &lt; min_dist) {
-			min_dist = cur_dist;
-		}
-	}
+		if (ipoint_num &gt;= min_points_per_voxel_) {
+			covariance_[vid] = (tmp_cov_[vid] - 2.0 * (pt_sum * centroid_[vid].transpose())) / point_num + centroid_[vid] * centroid_[vid].transpose();
+			covariance_[vid] *= (point_num - 1.0) / point_num;
 
-	if (min_dist &gt; max_range)
-		min_dist = DBL_MAX;
+			SymmetricEigensolver3x3 sv(covariance_[vid]);
 
-	return static_cast&lt;double&gt;(min_dist);
+			sv.compute();
+			Eigen::Matrix3d evecs = sv.eigenvectors();
+			Eigen::Matrix3d evals = sv.eigenvalues().asDiagonal();
+
+			if (evals(0, 0) &lt; 0 || evals(1, 1) &lt; 0 || evals(2, 2) &lt;= 0) {
+				points_per_voxel_[vid] = -1;
+				continue;
+			}
+
+			double min_cov_eigvalue = evals(2, 2) * 0.01;
+
+			if (evals(0, 0) &lt; min_cov_eigvalue) {
+				evals(0, 0) = min_cov_eigvalue;
+
+				if (evals(1, 1) &lt; min_cov_eigvalue) {
+					evals(1, 1) = min_cov_eigvalue;
+				}
+
+				covariance_[vid] = evecs * evals * evecs.inverse();
+			}
+
+			icovariance_[vid] = covariance_[vid].inverse();
+		}
+	}
 }
 
 template class VoxelGrid&lt;pcl::PointXYZI&gt;;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="43" deleted_lines="0">
				<diff>@@ -506,6 +506,10 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     initial_scan_loaded = 1;
   }
 
+#define timeDiff(start, end) ((end.tv_sec - start.tv_sec) * 1000000 + end.tv_usec - start.tv_usec)
+
+  struct timeval start, end;
+
   // Apply voxelgrid filter
   pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
   voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
@@ -514,6 +518,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
 
+  gettimeofday(&amp;start, NULL);
   #ifdef CUDA_FOUND
     if (_use_gpu == true)
     {
@@ -543,7 +548,11 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 		ndt.setInputSource(filtered_scan_ptr);
 	  }
   }
+    gettimeofday(&amp;end, NULL);
 
+    std::cout &lt;&lt; "Set input cloud = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
+
+    gettimeofday(&amp;start, NULL);
   if (isMapUpdate == true)
   {
 #ifdef CUDA_FOUND
@@ -566,6 +575,8 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
     isMapUpdate = false;
   }
+  gettimeofday(&amp;end, NULL);
+  std::cout &lt;&lt; "Set input target = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
   guess_pose.x = previous_pose.x + diff_x;
   guess_pose.y = previous_pose.y + diff_y;
@@ -620,10 +631,19 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   #endif
     if (_use_fast_pcl)
     {
+    	gettimeofday(&amp;start, NULL);
       cpu_ndt.align(init_guess);
+      gettimeofday(&amp;end, NULL);
+
+      std::cout &lt;&lt; "Align = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
       t_localizer = cpu_ndt.getFinalTransformation();
       has_converged = cpu_ndt.hasConverged();
+      gettimeofday(&amp;start, NULL);
       fitness_score = cpu_ndt.getFitnessScore();
+
+      gettimeofday(&amp;end, NULL);
+
+      std::cout &lt;&lt; "Get fitness score = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
       final_num_iteration = cpu_ndt.getFinalNumIteration();
     }
     else
@@ -632,8 +652,14 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
         ndt.omp_align(*output_cloud, init_guess);
         fitness_score = ndt.omp_getFitnessScore();
       #else
+        gettimeofday(&amp;start, NULL);
         ndt.align(*output_cloud, init_guess);
+        gettimeofday(&amp;end, NULL);
+        std::cout &lt;&lt; "Align = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
+        gettimeofday(&amp;start, NULL);
         fitness_score = ndt.getFitnessScore();
+        gettimeofday(&amp;end, NULL);
+        std::cout &lt;&lt; "Get fitness score = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
       #endif
       t_localizer = ndt.getFinalTransformation();
       has_converged = ndt.hasConverged();
@@ -760,6 +786,20 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   double shift = sqrt(pow(current_pose.x - added_pose.x, 2.0) + pow(current_pose.y - added_pose.y, 2.0));
   if (shift &gt;= min_add_scan_shift)
   {
+	  gettimeofday(&amp;start, NULL);
+	  // Update the current ndt structure
+	if (_use_fast_pcl &amp;&amp; !_use_gpu)
+	{
+	std::cout &lt;&lt; "UPDATE VOXEL GRID" &lt;&lt; std::endl;
+	  cpu_ndt.update(transformed_scan_ptr);
+	}
+
+	gettimeofday(&amp;end, NULL);
+
+	  std::cout &lt;&lt; "Update = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
+
+
+
     map += *transformed_scan_ptr;
     added_pose.x = current_pose.x;
     added_pose.y = current_pose.y;
@@ -770,10 +810,13 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     isMapUpdate = true;
   }
 
+
   sensor_msgs::PointCloud2::Ptr map_msg_ptr(new sensor_msgs::PointCloud2);
   pcl::toROSMsg(*map_ptr, *map_msg_ptr);
   ndt_map_pub.publish(*map_msg_ptr);
 
+
+
   q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
   current_pose_msg.header.frame_id = "map";
   current_pose_msg.header.stamp = current_scan_time;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a130e239354c67c20dd03cc2d20dd89c7a75d0d1" author="anhnv3991">
		<msg>Add a macro to switch between incremental and non-incremental update method in ndt mapping</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" added_lines="5" deleted_lines="1">
				<diff>@@ -18,6 +18,7 @@ namespace cpu {
 #define MAX_BY_ (128)
 #define MAX_BZ_ (32)
 
+#define INCREMENTAL_UPDATE_ 1
 
 template &lt;typename PointSourceType&gt;
 VoxelGrid&lt;PointSourceType&gt;::VoxelGrid():
@@ -322,13 +323,16 @@ void VoxelGrid&lt;PointSourceType&gt;::computeCentroidAndCovariance()
 template &lt;typename PointSourceType&gt;
 void VoxelGrid&lt;PointSourceType&gt;::setInput(typename pcl::PointCloud&lt;PointSourceType&gt;::Ptr input_cloud)
 {
+#ifdef INCREMENTAL_UPDATE_
 	if (voxel_num_ &gt; 0) {
 		/* If a voxel grid has already existed,
 		 * only set the source_cloud_ pointer to
 		 * point to new input cloud
 		 */
 		source_cloud_ = input_cloud;
-	} else if (input_cloud-&gt;points.size() &gt; 0) {
+	} else
+#endif
+		if (input_cloud-&gt;points.size() &gt; 0) {
 		/* If no voxel grid was created, then
 		 * build the initial voxel grid and octree
 		 */
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="036f1c96c14842619eb17807b2270f7b3d6bcb98" author="TomohitoAndo">
		<msg>Feature/occupancygrid filter (#1002)

* Add grid map filter node

* Add wayarea2grid node

* Replace dist_transform with grid_map_filter

* Add Runtime Manager UI for grid_map_filter node

* Add UI for wayarea2grid node

* Add instruction videos

* Fix videos

* Both node handles were private

* Added Comments Documentation
Code refactoring to follow standards
Added libraries
Separation of Vectormap Processing inside Clustering

* Added documentation

* Changed variable name

* Added Road Occupancy Processor package

* Added extra documentation
Added commands to RunTimeManager</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\launch\euclidean_cluster.config" new_path="" added_lines="0" deleted_lines="8">
				<diff>@@ -1,8 +0,0 @@
-grid_map_topic: /grid_map_wayarea
-grid_map_visualizations:
-  - name: cluster_wayarea
-    type: occupancy_grid
-    params:
-     layer: wayarea
-     data_min: 0
-     data_max: 100
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" added_lines="135" deleted_lines="217">
				<diff>@@ -83,73 +83,72 @@
 
 using namespace cv;
 
-std::vector&lt;cv::Scalar&gt; _colors;
-ros::Publisher _pub_cluster_cloud;
-ros::Publisher _pub_ground_cloud;
-ros::Publisher _centroid_pub;
-ros::Publisher _marker_pub;
-ros::Publisher _pub_clusters_message;
-ros::Publisher _pub_text_pictogram;
-visualization_msgs::Marker _visualization_marker;
-
-ros::Publisher _pub_points_lanes_cloud;
-ros::Publisher _pub_jsk_boundingboxes;
-ros::Publisher _pub_jsk_hulls;
+ros::Publisher      _pub_cluster_cloud;
+ros::Publisher      _pub_ground_cloud;
+ros::Publisher      _centroid_pub;
+ros::Publisher      _marker_pub;
+ros::Publisher      _pub_clusters_message;
+ros::Publisher      _pub_text_pictogram;
 
-ros::Publisher _pub_grid_map;
+ros::Publisher      _pub_points_lanes_cloud;
+ros::Publisher      _pub_jsk_boundingboxes;
+ros::Publisher      _pub_jsk_hulls;
 
-ros::ServiceClient _vectormap_server;
+ros::Publisher      _pub_grid_map;
 
-std_msgs::Header _velodyne_header;
-
-pcl::PointCloud&lt;pcl::PointXYZ&gt; _sensor_cloud;
+ros::ServiceClient  _vectormap_server;
 
-std::vector&lt;double&gt; _clustering_thresholds;
-std::vector&lt;double&gt; _clustering_distances;
+std_msgs::Header    _velodyne_header;
 
-tf::StampedTransform* _transform;
-tf::StampedTransform* _velodyne_output_transform;
-tf::TransformListener* _transform_listener;
-tf::TransformListener* _vectormap_transform_listener;
+std::string         _output_frame;
+std::string         _vectormap_frame;
+std::string         _gridmap_layer;
 
-std::string _output_frame;
-std::string _vectormap_frame;
+grid_map::GridMap   _wayarea_gridmap;
 
-grid_map::GridMap* _wayarea_gridmap;
+const int           _grid_min_value = 0;
+const int           _grid_max_value = 255;
+static int          _gridmap_no_road_value;
 
-static bool _velodyne_transform_available;
-static bool _downsample_cloud;
-static bool _pose_estimation;
-static double _leaf_size;
-static int _cluster_size_min;
-static int _cluster_size_max;
+static bool         _velodyne_transform_available;
+static bool         _downsample_cloud;
+static bool         _pose_estimation;
+static double       _leaf_size;
+static int          _cluster_size_min;
+static int          _cluster_size_max;
 
-static bool _remove_ground;	//only ground
+static bool         _remove_ground;	//only ground
 
-static bool _using_sensor_cloud;
-static bool _use_diffnormals;
-static bool _use_vector_map;
+static bool         _using_sensor_cloud;
+static bool         _use_diffnormals;
+static bool         _use_vector_map;
 
-static double _clip_min_height;
-static double _clip_max_height;
+static double       _clip_min_height;
+static double       _clip_max_height;
 
-static bool _keep_lanes;
-static double _keep_lane_left_distance;
-static double _keep_lane_right_distance;
+static bool         _keep_lanes;
+static double       _keep_lane_left_distance;
+static double       _keep_lane_right_distance;
 
-static double _max_boundingbox_side;
-static double _remove_points_upto;
-static double _cluster_merge_threshold;
+static double       _max_boundingbox_side;
+static double       _remove_points_upto;
+static double       _cluster_merge_threshold;
 
-static double _vectormap_grid_width;
-static double _vectormap_grid_height;
-static double _vectormap_grid_resolution;
-static double _vectormap_grid_behind;
+static bool         _use_gpu;
+static std::chrono::system_clock::time_point _start, _end;
 
 std::vector&lt;std::vector&lt;geometry_msgs::Point&gt;&gt; _way_area_points;
+std::vector&lt;cv::Scalar&gt; _colors;
+pcl::PointCloud&lt;pcl::PointXYZ&gt; _sensor_cloud;
+visualization_msgs::Marker _visualization_marker;
 
-static bool _use_gpu;
-static std::chrono::system_clock::time_point _start, _end;
+std::vector&lt;double&gt; _clustering_thresholds;
+std::vector&lt;double&gt; _clustering_distances;
+
+tf::StampedTransform* _transform;
+tf::StampedTransform* _velodyne_output_transform;
+tf::TransformListener* _transform_listener;
+tf::TransformListener* _vectormap_transform_listener;
 
 tf::StampedTransform findTransform(const std::string&amp; in_target_frame, const std::string&amp; in_source_frame)
 {
@@ -184,7 +183,6 @@ geometry_msgs::Point transformPoint(const geometry_msgs::Point &amp;point, const tf:
 
 bool checkPointInGrid(const grid_map::GridMap&amp; in_grid_map, const cv::Mat&amp; in_grid_image, const geometry_msgs::Point&amp; in_point)
 {
-
 	// calculate out_grid_map position
 	grid_map::Position map_pos = in_grid_map.getPosition();
 	double origin_x_offset = in_grid_map.getLength().x() / 2.0 - map_pos.x();
@@ -199,8 +197,8 @@ bool checkPointInGrid(const grid_map::GridMap&amp; in_grid_map, const cv::Mat&amp; in_gr
 		return false;
 	}
 
-	//Scalar(0) if road
-	if(0 == in_grid_image.at&lt;uchar&gt;(cv_y, cv_x))
+	//_gridmap_no_road_value if road
+	if(in_grid_image.at&lt;uchar&gt;(cv_y, cv_x) != _gridmap_no_road_value)
 	{
 		return true;
 	}
@@ -208,89 +206,6 @@ bool checkPointInGrid(const grid_map::GridMap&amp; in_grid_map, const cv::Mat&amp; in_gr
 	return false;
 }
 
-void convertPointsToImage(grid_map::GridMap&amp; out_grid_map, const std::vector&lt;std::vector&lt;geometry_msgs::Point&gt;&gt;&amp; in_wayarea_points)
-{
-	if(!out_grid_map.exists("wayarea"))
-	{
-		out_grid_map.add("wayarea");
-	}
-	out_grid_map["wayarea"].setConstant(100);//fill with gray color
-
-	cv::Mat original_image;
-	grid_map::GridMapCvConverter::toImage&lt;unsigned char, 1&gt;(out_grid_map, "wayarea", CV_8UC1, 0, 100, original_image);
-
-	cv::Mat filled_image = original_image.clone();
-	tf::StampedTransform tf = findTransform(_velodyne_header.frame_id, _vectormap_frame);
-
-	// calculate out_grid_map position
-	grid_map::Position map_pos = out_grid_map.getPosition();
-	double origin_x_offset = out_grid_map.getLength().x() / 2.0 - map_pos.x();
-	double origin_y_offset = out_grid_map.getLength().y() / 2.0 - map_pos.y();
-
-	for (const auto&amp; points : in_wayarea_points)
-	{
-		std::vector&lt;cv::Point&gt; cv_points;
-
-		for (const auto&amp; p : points)
-		{
-			geometry_msgs::Point tf_point = transformPoint(p, tf);
-			// coordinate conversion for cv image
-			double cv_x = (out_grid_map.getLength().y() - origin_y_offset - tf_point.y) / out_grid_map.getResolution();
-			double cv_y = (out_grid_map.getLength().x() - origin_x_offset - tf_point.x) / out_grid_map.getResolution();
-			cv_points.emplace_back(cv::Point(cv_x, cv_y));
-		}
-		cv::fillConvexPoly(filled_image, cv_points.data(), cv_points.size(), cv::Scalar(0));
-	}
-
-	// convert to ROS msg
-	grid_map::GridMapCvConverter::addLayerFromImage&lt;unsigned char, 1&gt;(filled_image, "wayarea", out_grid_map, 0, 100);
-}
-
-void getWayAreaPointsFromMap(const vector_map::Area&amp; in_vmap_area, const vector_map::VectorMap&amp; in_vectormap)
-{
-	std::vector&lt;geometry_msgs::Point&gt; area_points;
-
-	if (in_vmap_area.aid == 0)
-		return;
-
-	vector_map::Line line = in_vectormap.findByKey(vector_map::Key&lt;vector_map::Line&gt;(in_vmap_area.slid));
-	// must set beginning line
-	if (line.lid == 0 || line.blid != 0)
-		return;
-
-	// Search all lines in in_vmap_area
-	while (line.flid != 0)
-	{
-		vector_map::Point bp = in_vectormap.findByKey(vector_map::Key&lt;vector_map::Point&gt;(line.bpid));
-		if (bp.pid == 0)
-			return;
-
-		vector_map::Point fp = in_vectormap.findByKey(vector_map::Key&lt;vector_map::Point&gt;(line.fpid));
-		if (fp.pid == 0)
-			return;
-
-		// 2 points of line
-		area_points.push_back(vector_map::convertPointToGeomPoint(bp));
-		area_points.push_back(vector_map::convertPointToGeomPoint(fp));
-
-		line = in_vectormap.findByKey(vector_map::Key&lt;vector_map::Line&gt;(line.flid));
-		if (line.lid == 0)
-			return;
-	}
-
-	vector_map::Point bp = in_vectormap.findByKey(vector_map::Key&lt;vector_map::Point&gt;(line.bpid));
-	vector_map::Point fp = in_vectormap.findByKey(vector_map::Key&lt;vector_map::Point&gt;(line.fpid));
-	if (bp.pid == 0 || fp.pid == 0)
-		return;
-
-	area_points.push_back(vector_map::convertPointToGeomPoint(bp));
-	area_points.push_back(vector_map::convertPointToGeomPoint(fp));
-
-	_way_area_points.push_back(area_points);
-
-	return;
-}
-
 void transformBoundingBox(const jsk_recognition_msgs::BoundingBox&amp; in_boundingbox, jsk_recognition_msgs::BoundingBox&amp; out_boundingbox, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
 {
 	geometry_msgs::PoseStamped pose_in, pose_out;
@@ -721,40 +636,48 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 	tf::StampedTransform vectormap_transform;
 	if (_use_vector_map)
 	{
-		//cv::TickMeter timer;
-
-		if (_wayarea_gridmap!=NULL &amp;&amp; _wayarea_gridmap-&gt;exists("wayarea"))
+		if (_wayarea_gridmap.exists(_gridmap_layer))
 		{
-			_wayarea_gridmap-&gt;setFrameId(_velodyne_header.frame_id);
-			convertPointsToImage(*_wayarea_gridmap, _way_area_points);
-
-			grid_map_msgs::GridMap message;
-			grid_map::GridMapRosConverter::toMessage(*_wayarea_gridmap, message);
-			_pub_grid_map.publish(message);
-			//timer.start();
 			//check if centroids are inside the drivable area
 			cv::Mat grid_image;
-			grid_map::GridMapCvConverter::toImage&lt;unsigned char, 1&gt;(*_wayarea_gridmap, "wayarea", CV_8UC1, 0, 100, grid_image);
-
-
-			#pragma omp for
-			for(unsigned int i=0; i&lt;final_clusters.size(); i++)
+			grid_map::GridMapCvConverter::toImage&lt;unsigned char, 1&gt;(_wayarea_gridmap,
+			                                                        _gridmap_layer,
+			                                                        CV_8UC1,
+			                                                        _grid_min_value,
+			                                                        _grid_max_value,
+			                                                        grid_image);
+
+#pragma omp for
+			for (unsigned int i = 0; i &lt; final_clusters.size(); i++)
 			{
 				pcl::PointXYZ pcl_centroid = final_clusters[i]-&gt;GetCentroid();
-				geometry_msgs::Point centroid_point;
-				centroid_point.x = pcl_centroid.x;
-				centroid_point.y = pcl_centroid.y;
-				centroid_point.z = pcl_centroid.z;
-				//no need to transform point since points from the sensor are the same as the recently created grid
-
-				bool point_in_grid = checkPointInGrid(*_wayarea_gridmap, grid_image, centroid_point);
 
+				geometry_msgs::Point original_centroid_point, final_centroid_point;
+				original_centroid_point.x = pcl_centroid.x;
+				original_centroid_point.y = pcl_centroid.y;
+				original_centroid_point.z = pcl_centroid.z;
+
+				if (_wayarea_gridmap.getFrameId() != _velodyne_header.frame_id)
+				{
+					tf::StampedTransform grid_sensor_tf = findTransform(_wayarea_gridmap.getFrameId(), _velodyne_header.frame_id);
+					final_centroid_point = transformPoint(original_centroid_point, grid_sensor_tf);
+				}
+				else
+				{
+					final_centroid_point = original_centroid_point;
+				}
+
+				bool point_in_grid = checkPointInGrid(_wayarea_gridmap, grid_image, final_centroid_point);
 				final_clusters[i]-&gt;SetValidity(point_in_grid);
-
 			}
 			//timer.stop();
 			//std::cout &lt;&lt; "vectormap filtering took " &lt;&lt; timer.getTimeMilli() &lt;&lt; " ms to check " &lt;&lt; final_clusters.size() &lt;&lt; std::endl;
 		}
+		else
+		{
+			ROS_INFO("%s layer not contained in the OccupancyGrid", _gridmap_layer.c_str());
+		}
+
 	}
 	//Get final PointCloud to be published
 	in_out_polygon_array.header = _velodyne_header;
@@ -970,7 +893,7 @@ void removePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pc
 
 void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
 {
-	_start = std::chrono::system_clock::now(); // 計測開始時間
+	//_start = std::chrono::system_clock::now();
 
 	if (!_using_sensor_cloud)
 	{
@@ -1053,9 +976,9 @@ void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
 
 		_using_sensor_cloud = false;
 	}
-	_end = std::chrono::system_clock::now();  // 計測終了時間
-  double elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(_end-_start).count(); //処理に要した時間をミリ秒に変換
-  //ROS_INFO("Euclidean Clustering : %f", elapsed);
+	//_end = std::chrono::system_clock::now();
+	//double elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(_end-_start).count();
+	//ROS_INFO("Euclidean Clustering : %f", elapsed);
 }
 
 /*
@@ -1133,6 +1056,11 @@ void vectormap_callback(const visualization_msgs::MarkerArray::Ptr in_vectormap_
 	cv::waitKey(0);
 }*/
 
+void wayarea_gridmap_callback(const grid_map_msgs::GridMap&amp; message)
+{
+	grid_map::GridMapRosConverter::fromMessage(message, _wayarea_gridmap);
+}
+
 int main (int argc, char** argv)
 {
 	// Initialize ROS
@@ -1168,7 +1096,7 @@ int main (int argc, char** argv)
 
 	_pub_grid_map = h.advertise&lt;grid_map_msgs::GridMap&gt;("grid_map_wayarea", 1, true);
 
-	std::string points_topic;
+	std::string points_topic, gridmap_topic;
 
 	_using_sensor_cloud = false;
 
@@ -1192,33 +1120,47 @@ int main (int argc, char** argv)
 	}
 
 	/* Initialize tuning parameter */
-	private_nh.param("downsample_cloud", _downsample_cloud, false);	ROS_INFO("downsample_cloud: %d", _downsample_cloud);
-	private_nh.param("remove_ground", _remove_ground, true);		ROS_INFO("remove_ground: %d", _remove_ground);
-	private_nh.param("leaf_size", _leaf_size, 0.1);					ROS_INFO("leaf_size: %f", _leaf_size);
-	private_nh.param("cluster_size_min", _cluster_size_min, 20);	ROS_INFO("cluster_size_min %d", _cluster_size_min);
-	private_nh.param("cluster_size_max", _cluster_size_max, 100000);ROS_INFO("cluster_size_max: %d", _cluster_size_max);
-	private_nh.param("pose_estimation", _pose_estimation, false);	ROS_INFO("pose_estimation: %d", _pose_estimation);
-	private_nh.param("clip_min_height", _clip_min_height, -1.3);	ROS_INFO("clip_min_height: %f", _clip_min_height);
-	private_nh.param("clip_max_height", _clip_max_height, 0.5);		ROS_INFO("clip_max_height: %f", _clip_max_height);
-	private_nh.param("keep_lanes", _keep_lanes, false);				ROS_INFO("keep_lanes: %d", _keep_lanes);
-	private_nh.param("keep_lane_left_distance", _keep_lane_left_distance, 5.0);		ROS_INFO("keep_lane_left_distance: %f", _keep_lane_left_distance);
-	private_nh.param("keep_lane_right_distance", _keep_lane_right_distance, 5.0);	ROS_INFO("keep_lane_right_distance: %f", _keep_lane_right_distance);
+	private_nh.param("downsample_cloud", _downsample_cloud, false);
+	ROS_INFO("downsample_cloud: %d", _downsample_cloud);
+	private_nh.param("remove_ground", _remove_ground, true);
+	ROS_INFO("remove_ground: %d", _remove_ground);
+	private_nh.param("leaf_size", _leaf_size, 0.1);
+	ROS_INFO("leaf_size: %f", _leaf_size);
+	private_nh.param("cluster_size_min", _cluster_size_min, 20);
+	ROS_INFO("cluster_size_min %d", _cluster_size_min);
+	private_nh.param("cluster_size_max", _cluster_size_max, 100000);
+	ROS_INFO("cluster_size_max: %d", _cluster_size_max);
+	private_nh.param("pose_estimation", _pose_estimation, false);
+	ROS_INFO("pose_estimation: %d", _pose_estimation);
+	private_nh.param("clip_min_height", _clip_min_height, -1.3);
+	ROS_INFO("clip_min_height: %f", _clip_min_height);
+	private_nh.param("clip_max_height", _clip_max_height, 0.5);
+	ROS_INFO("clip_max_height: %f", _clip_max_height);
+	private_nh.param("keep_lanes", _keep_lanes, false);
+	ROS_INFO("keep_lanes: %d", _keep_lanes);
+	private_nh.param("keep_lane_left_distance", _keep_lane_left_distance, 5.0);
+	ROS_INFO("keep_lane_left_distance: %f", _keep_lane_left_distance);
+	private_nh.param("keep_lane_right_distance", _keep_lane_right_distance, 5.0);
+	ROS_INFO("keep_lane_right_distance: %f", _keep_lane_right_distance);
 	private_nh.param("clustering_thresholds", _clustering_thresholds);
 	private_nh.param("clustering_distances", _clustering_distances);
-	private_nh.param("max_boundingbox_side", _max_boundingbox_side, 10.0);		ROS_INFO("max_boundingbox_side: %f", _max_boundingbox_side);
-	private_nh.param("cluster_merge_threshold", _cluster_merge_threshold, 1.5);	ROS_INFO("cluster_merge_threshold: %f", _cluster_merge_threshold);
-	private_nh.param&lt;std::string&gt;("output_frame", _output_frame, "velodyne");	ROS_INFO("output_frame: %s", _output_frame.c_str());
+	private_nh.param("max_boundingbox_side", _max_boundingbox_side, 10.0);
+	ROS_INFO("max_boundingbox_side: %f", _max_boundingbox_side);
+	private_nh.param("cluster_merge_threshold", _cluster_merge_threshold, 1.5);
+	ROS_INFO("cluster_merge_threshold: %f", _cluster_merge_threshold);
+	private_nh.param&lt;std::string&gt;("output_frame", _output_frame, "velodyne");
+	ROS_INFO("output_frame: %s", _output_frame.c_str());
 
-	private_nh.param("use_vector_map", _use_vector_map, false);					ROS_INFO("use_vector_map: %d", _use_vector_map);
-	private_nh.param&lt;std::string&gt;("vectormap_frame", _vectormap_frame, "map");	ROS_INFO("vectormap_frame: %s", _vectormap_frame.c_str());
-	private_nh.param("vectormap_grid_width", _vectormap_grid_width, 30.0);	    ROS_INFO("vectormap_grid_width: %f", _vectormap_grid_width);
-	private_nh.param("vectormap_grid_height", _vectormap_grid_height, 70.0);	ROS_INFO("vectormap_grid_height: %f", _vectormap_grid_height);
-	private_nh.param("vectormap_grid_resolution", _vectormap_grid_resolution, 0.3);	ROS_INFO("vectormap_grid_resolution: %f", _vectormap_grid_resolution);
-	private_nh.param("vectormap_grid_behind", _vectormap_grid_behind, 20.0);	ROS_INFO("vectormap_grid_resolution: %f", _vectormap_grid_behind);
+	private_nh.param("use_vector_map", _use_vector_map, false);
+	ROS_INFO("use_vector_map: %d", _use_vector_map);
+	private_nh.param&lt;std::string&gt;("vectormap_frame", _vectormap_frame, "map");
+	ROS_INFO("vectormap_frame: %s", _vectormap_frame.c_str());
 
-	private_nh.param("remove_points_upto", _remove_points_upto, 0.0);		ROS_INFO("remove_points_upto: %f", _remove_points_upto);
+	private_nh.param("remove_points_upto", _remove_points_upto, 0.0);
+	ROS_INFO("remove_points_upto: %f", _remove_points_upto);
 
-	private_nh.param("use_gpu", _use_gpu, false);				ROS_INFO("use_gpu: %d", _use_gpu);
+	private_nh.param("use_gpu", _use_gpu, false);
+	ROS_INFO("use_gpu: %d", _use_gpu);
 
 	_velodyne_transform_available = false;
 
@@ -1237,38 +1179,14 @@ int main (int argc, char** argv)
 	// Create a ROS subscriber for the input point cloud
 	ros::Subscriber sub = h.subscribe (points_topic, 1, velodyne_callback);
 
+	private_nh.param&lt;std::string&gt;("wayarea_gridmap_topic", gridmap_topic, "grid_map_wayarea");
+	ROS_INFO("wayarea_gridmap_topic: %s", gridmap_topic.c_str());
+	private_nh.param&lt;std::string&gt;("wayarea_gridmap_layer", _gridmap_layer, "wayarea");
+	ROS_INFO("wayarea_gridmap_layer: %s", _gridmap_layer.c_str());
+	private_nh.param&lt;int&gt;("wayarea_no_road_value", _gridmap_no_road_value, _grid_max_value);
+	ROS_INFO("wayarea_no_road_value: %ds", _gridmap_no_road_value);
+	ros::Subscriber wayarea_sub = h.subscribe (gridmap_topic, 1, wayarea_gridmap_callback);
 
-	vector_map::VectorMap vector_map;
-
-	ROS_INFO("[euclidean_cluster]: Creating GridMap for Wayarea...");
-	vector_map.subscribe(private_nh,
-	                     vector_map::Category::POINT | vector_map::Category::LINE |
-	                     vector_map::Category::AREA | vector_map::Category::WAY_AREA,
-	                     10 //abort after 10 times, either vector map or wayarea not available
-	);
-
-	// all true -&gt; all data
-	std::vector&lt;vector_map_msgs::WayArea&gt; way_areas = vector_map.findByFilter([](const vector_map_msgs::WayArea&amp; way_area){return true;});
-
-	grid_map::GridMap gridmap({"wayarea"});
-	_wayarea_gridmap = &amp;gridmap;
-	_wayarea_gridmap-&gt;setGeometry(grid_map::Length(_vectormap_grid_height, _vectormap_grid_width), _vectormap_grid_resolution);
-	_wayarea_gridmap-&gt;setPosition(grid_map::Position(_vectormap_grid_behind,0));
-
-	if (way_areas.empty())
-	{
-		ROS_WARN_STREAM("[euclidean_cluster]: The VectorMap is not being published or does not contain WAYAREA, not performing filtering.");
-		_wayarea_gridmap = NULL;
-	} else
-	{
-		ROS_INFO("[euclidean_cluster]: Found %lu wayareas.", way_areas.size());
-		for (const auto &amp;way_area : way_areas)
-		{
-			vector_map::Area area = vector_map.findByKey(vector_map::Key&lt;vector_map::Area&gt;(way_area.aid));
-			getWayAreaPointsFromMap(area, vector_map);
-		}
-		ROS_INFO("[euclidean_cluster]: WayAreaPoints complete ");
-	}
 
 	_visualization_marker.header.frame_id = "velodyne";
 	_visualization_marker.header.stamp = ros::Time();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\dist_transform\dist_transform.cpp" new_path="" added_lines="0" deleted_lines="161">
				<diff>@@ -1,161 +0,0 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include &lt;ros/ros.h&gt;
-#include &lt;grid_map_ros/grid_map_ros.hpp&gt;
-#include &lt;grid_map_msgs/GridMap.h&gt;
-#include &lt;grid_map_cv/grid_map_cv.hpp&gt;
-#include &lt;cv_bridge/cv_bridge.h&gt;
-#include &lt;opencv2/highgui/highgui.hpp&gt;
-#include &lt;chrono&gt;
-
-namespace
-{
-
-double g_max_distance;
-
-void distanceTransform(grid_map::GridMap&amp; map)
-{
-  cv::Mat original_image;
-  grid_map::GridMapCvConverter::toImage&lt;unsigned char, 1&gt;(map, "original", CV_8UC1, original_image);
-
-  // binalize
-  cv::Mat binary_image;
-  cv::threshold(original_image, binary_image, 20, 100, cv::THRESH_BINARY_INV);
-
-  // distance transform
-  // 3 fast
-  // 5 slow but accurate
-  cv::Mat dt_image;
-  cv::distanceTransform(binary_image, dt_image, CV_DIST_L2, 5);
-
-  // Convert to int...
-  cv::Mat dt_int_image(dt_image.size(), CV_8UC1);
-  cv::Mat dt_int_inv_image(dt_image.size(), CV_8UC1);
-
-  // max distance for cost propagation
-  double max_dist = g_max_distance; // meter
-  double resolution = map.getResolution();
-
-  for (int y = 0; y &lt; dt_image.rows; y++) {
-    for (int x = 0; x &lt; dt_image.cols; x++) {
-      // actual distance [meter]
-      double dist = dt_image.at&lt;float&gt;(y, x) * resolution;
-      if (dist &gt; max_dist)
-        dist = max_dist;
-
-      // Make value range 0 ~ 255
-      int round_dist = dist / max_dist * 255;
-      int inv_round_dist = 255 - round_dist;
-
-      dt_int_image.at&lt;unsigned char&gt;(y, x)     = round_dist;
-      dt_int_inv_image.at&lt;unsigned char&gt;(y, x) = inv_round_dist;
-    }
-  }
-
-  // visualize the image
-  /*
-  cv::namedWindow("Original", 0);
-  cv::namedWindow("Binary", 0);
-  cv::namedWindow("Distance", 0);
-  cv::namedWindow("DistanceInt", 0);
-  cv::namedWindow("DistanceInv", 0);
-
-  cv::imshow("Original", original_image);
-  cv::imshow("Binary", binary_image);
-  cv::imshow("Distance", dt_image);
-  cv::imshow("DistanceInt", dt_int_image);
-  cv::imshow("DistanceInv", dt_int_inv_image);
-  cv::waitKey(40);
-  */
-
-  // convert to ROS msg
-  grid_map::GridMapCvConverter::addLayerFromImage&lt;unsigned char, 1&gt;(dt_int_inv_image, "distance_transform", map, 0, 100);
-  grid_map::GridMapCvConverter::addLayerFromImage&lt;unsigned char, 1&gt;(dt_int_inv_image, "dist_elevation", map, 0, 1.5);
-}
-
-void convertOccupancyGrid(const nav_msgs::OccupancyGridConstPtr&amp; msg, const ros::Publisher&amp; pub)
-{
-  // timer start
-  auto start = std::chrono::system_clock::now();
-
-  ROS_INFO("Subscribed Occupancy Grid Map");
-
-  // convert ROS OccupancyGrid to GridMap
-  grid_map::GridMap map({"original", "distance_transform", "elevation", "dist_elevation"});
-  grid_map::GridMapRosConverter::fromOccupancyGrid(*msg, "original", map);
-
-  //map.setFrameId("occupancy_grid");
-
-  ROS_INFO("Created map with size %f x %f m (%i x %i cells).",
-           map.getLength().x(), map.getLength().y(),
-           map.getSize()(0), map.getSize()(1));
-
-  // Create elevation points
-  for (grid_map::GridMapIterator it(map); !it.isPastEnd(); ++it)
-  {
-    map.at("elevation", *it) = map.at("original", *it) / 100.0;
-  }
-
-  // Process for distance transform
-  distanceTransform(map);
-
-  grid_map_msgs::GridMap message;
-  grid_map::GridMapRosConverter::toMessage(map, message);
-  pub.publish(message);
-  ROS_INFO_THROTTLE(1.0, "Grid map (timestamp %f) published.", message.info.header.stamp.toSec());
-
-  // timer end
-  auto end = std::chrono::system_clock::now();
-  auto usec = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count();
-  std::cout &lt;&lt; "time: " &lt;&lt; usec / 1000.0 &lt;&lt; " [msec]" &lt;&lt; std::endl;
-}
-
-} // namespace
-
-int main(int argc, char** argv)
-{
-  // Initialize node and publisher.
-  ros::init(argc, argv, "dist_transform");
-  ros::NodeHandle nh("~");
-  ros::NodeHandle private_nh("~");
-
-  std::string map_topic;
-  private_nh.param&lt;std::string&gt;("map_topic", map_topic, "/realtime_cost_map");
-  private_nh.param&lt;double&gt;("max_distance", g_max_distance, 3.0);
-
-  ros::Publisher grid_map_pub = nh.advertise&lt;grid_map_msgs::GridMap&gt;("grid_map", 1, true);
-
-  ros::Subscriber ogm_sub = nh.subscribe&lt;nav_msgs::OccupancyGrid&gt;(map_topic, 1, std::bind(convertOccupancyGrid, std::placeholders::_1, grid_map_pub));
-
-  ros::spin();
-
-  return 0;
-}
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5cedfd6973f28b0422848bc65d0cbc881b3fb073" author="Yamato ANDO">
		<msg>remove time measurement</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" added_lines="1" deleted_lines="64">
				<diff>@@ -55,48 +55,21 @@ VoxelGrid&lt;PointSourceType&gt;::VoxelGrid():
 template &lt;typename PointSourceType&gt;
 void VoxelGrid&lt;PointSourceType&gt;::initialize()
 {
-#define timeDiff(start, end) ((end.tv_sec - start.tv_sec) * 1000000 + end.tv_usec - start.tv_usec)
-
-	struct timeval start, end;
-
-	gettimeofday(&amp;start, NULL);
 	centroid_.resize(voxel_num_);
-	gettimeofday(&amp;end, NULL);
-
-	std::cout &lt;&lt; "Resize centroid = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
-	gettimeofday(&amp;start, NULL);
 	covariance_.resize(voxel_num_);
-	gettimeofday(&amp;end, NULL);
 
-	std::cout &lt;&lt; "Resize covariance = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
-
-	gettimeofday(&amp;start, NULL);
 	icovariance_.resize(voxel_num_);
-	gettimeofday(&amp;end, NULL);
-
-	std::cout &lt;&lt; "Resize icovariance = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
-	gettimeofday(&amp;start, NULL);
 	points_id_.resize(voxel_num_);
-	gettimeofday(&amp;end, NULL);
-
-	std::cout &lt;&lt; "Resize points id = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
-	gettimeofday(&amp;start, NULL);
 	points_per_voxel_.resize(voxel_num_);
-	gettimeofday(&amp;end, NULL);
 
-	std::cout &lt;&lt; "Resize points per voxel = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
-
-	gettimeofday(&amp;start, NULL);
 	// Reset the number of points in all voxels to zero
 	std::fill(points_per_voxel_.begin(), points_per_voxel_.end(), 0);
-	gettimeofday(&amp;end, NULL);
-
-	std::cout &lt;&lt; "Filling points per voxel = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
 	tmp_centroid_.resize(voxel_num_);
+
 	tmp_cov_.resize(voxel_num_);
 }
 
@@ -338,31 +311,13 @@ void VoxelGrid&lt;PointSourceType&gt;::setInput(typename pcl::PointCloud&lt;PointSourceTy
 		 */
 		source_cloud_ = input_cloud;
 
-#define timeDiff(start, end) ((end.tv_sec - start.tv_sec) * 1000000 + end.tv_usec - start.tv_usec)
-
-		struct timeval start, end;
-
-		gettimeofday(&amp;start, NULL);
 		findBoundaries();
-		gettimeofday(&amp;end, NULL);
 
-		std::cout &lt;&lt; "Find boundaries = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
-
-		gettimeofday(&amp;start, NULL);
 		initialize();
-		gettimeofday(&amp;end, NULL);
-
-		std::cout &lt;&lt; "Initialize = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
-		gettimeofday(&amp;start, NULL);
 		scatterPointsToVoxelGrid();
-		gettimeofday(&amp;end, NULL);
-
-		std::cout &lt;&lt; "Scatter points = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
-		gettimeofday(&amp;start, NULL);
 		computeCentroidAndCovariance();
-		gettimeofday(&amp;end, NULL);
 	}
 }
 
@@ -793,18 +748,8 @@ void VoxelGrid&lt;PointSourceType&gt;::update(typename pcl::PointCloud&lt;PointSourceType
 	float new_min_x, new_min_y, new_min_z;
 	int shift_x, shift_y, shift_z;
 
-#define timeDiff(start, end) ((end.tv_sec - start.tv_sec) * 1000000 + end.tv_usec - start.tv_usec)
-
-	struct timeval start, end;
-
-	gettimeofday(&amp;start, NULL);
 	// Find boundaries of the new point cloud
 	findBoundaries(new_cloud, new_max_x, new_max_y, new_max_z, new_min_x, new_min_y, new_min_z);
-	gettimeofday(&amp;end, NULL);
-
-	std::cout &lt;&lt; "Find boundaries = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
-
-	gettimeofday(&amp;start, NULL);
 
 	/* Update current boundaries of the voxel grid
 	 * Also allocate buffer for new voxel grid and
@@ -813,18 +758,10 @@ void VoxelGrid&lt;PointSourceType&gt;::update(typename pcl::PointCloud&lt;PointSourceType
 	 */
 	updateBoundaries(new_max_x, new_max_y, new_max_z, new_min_x, new_min_y, new_min_z);
 
-	gettimeofday(&amp;end, NULL);
-
-	std::cout &lt;&lt; "Update boundaries = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
-
-	gettimeofday(&amp;start, NULL);
 	/* Update changed voxels (voxels that contains new points).
 	 * Update centroids of voxels and their covariance matrixes
 	 * as well as inverse covariance matrixes */
 	updateVoxelContent(new_cloud);
-	gettimeofday(&amp;end, NULL);
-
-	std::cout &lt;&lt; "Update voxel content = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 }
 
 template &lt;typename PointSourceType&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="1" deleted_lines="33">
				<diff>@@ -506,10 +506,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     initial_scan_loaded = 1;
   }
 
-#define timeDiff(start, end) ((end.tv_sec - start.tv_sec) * 1000000 + end.tv_usec - start.tv_usec)
-
-  struct timeval start, end;
-
   // Apply voxelgrid filter
   pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
   voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
@@ -518,7 +514,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
 
-  gettimeofday(&amp;start, NULL);
   #ifdef CUDA_FOUND
     if (_use_gpu == true)
     {
@@ -548,11 +543,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 		ndt.setInputSource(filtered_scan_ptr);
 	  }
   }
-    gettimeofday(&amp;end, NULL);
 
-    std::cout &lt;&lt; "Set input cloud = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
-
-    gettimeofday(&amp;start, NULL);
   if (isMapUpdate == true)
   {
 #ifdef CUDA_FOUND
@@ -575,8 +566,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
     isMapUpdate = false;
   }
-  gettimeofday(&amp;end, NULL);
-  std::cout &lt;&lt; "Set input target = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
 
   guess_pose.x = previous_pose.x + diff_x;
   guess_pose.y = previous_pose.y + diff_y;
@@ -631,19 +620,12 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   #endif
     if (_use_fast_pcl)
     {
-    	gettimeofday(&amp;start, NULL);
       cpu_ndt.align(init_guess);
-      gettimeofday(&amp;end, NULL);
 
-      std::cout &lt;&lt; "Align = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
       t_localizer = cpu_ndt.getFinalTransformation();
       has_converged = cpu_ndt.hasConverged();
-      gettimeofday(&amp;start, NULL);
       fitness_score = cpu_ndt.getFitnessScore();
 
-      gettimeofday(&amp;end, NULL);
-
-      std::cout &lt;&lt; "Get fitness score = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
       final_num_iteration = cpu_ndt.getFinalNumIteration();
     }
     else
@@ -652,14 +634,8 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
         ndt.omp_align(*output_cloud, init_guess);
         fitness_score = ndt.omp_getFitnessScore();
       #else
-        gettimeofday(&amp;start, NULL);
         ndt.align(*output_cloud, init_guess);
-        gettimeofday(&amp;end, NULL);
-        std::cout &lt;&lt; "Align = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
-        gettimeofday(&amp;start, NULL);
         fitness_score = ndt.getFitnessScore();
-        gettimeofday(&amp;end, NULL);
-        std::cout &lt;&lt; "Get fitness score = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
       #endif
       t_localizer = ndt.getFinalTransformation();
       has_converged = ndt.hasConverged();
@@ -786,20 +762,12 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   double shift = sqrt(pow(current_pose.x - added_pose.x, 2.0) + pow(current_pose.y - added_pose.y, 2.0));
   if (shift &gt;= min_add_scan_shift)
   {
-	  gettimeofday(&amp;start, NULL);
-	  // Update the current ndt structure
+	// Update the current ndt structure
 	if (_use_fast_pcl &amp;&amp; !_use_gpu)
 	{
-	std::cout &lt;&lt; "UPDATE VOXEL GRID" &lt;&lt; std::endl;
 	  cpu_ndt.update(transformed_scan_ptr);
 	}
 
-	gettimeofday(&amp;end, NULL);
-
-	  std::cout &lt;&lt; "Update = " &lt;&lt; timeDiff(start, end) &lt;&lt; std::endl;
-
-
-
     map += *transformed_scan_ptr;
     added_pose.x = current_pose.x;
     added_pose.y = current_pose.y;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b5a5b0f70d4d9a3db4779cc1eef57bc89a80333e" author="yukikitsukawa">
		<msg>fix typo</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -892,7 +892,7 @@ int main(int argc, char** argv)
   std::cout &lt;&lt; "use_imu: " &lt;&lt; _use_imu &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_gpu: " &lt;&lt; _use_gpu &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_openmp: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
-  std::cout &lt;&lt; "use_fast_pcl: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
+  std::cout &lt;&lt; "use_fast_pcl: " &lt;&lt; _use_fast_pcl &lt;&lt; std::endl;
   std::cout &lt;&lt; "imu_upside_down: " &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_odom: " &lt;&lt; _use_odom &lt;&lt; std::endl;
   std::cout &lt;&lt; "imu_topic: " &lt;&lt; _imu_topic &lt;&lt; std::endl;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e98c02972d05fc66fdddea8e8b65a1254baddedf" author="Yamato ANDO">
		<msg>add incremental_voxel_update flag</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\NormalDistributionsTransform.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\NormalDistributionsTransform.h" added_lines="1" deleted_lines="1">
				<diff>@@ -36,7 +36,7 @@ public:
 	/* Compute and get fitness score */
 	double getFitnessScore(double max_range = DBL_MAX);
 
-	void update(typename pcl::PointCloud&lt;PointTargetType&gt;::Ptr new_cloud);
+	void updateVoxelGrid(typename pcl::PointCloud&lt;PointTargetType&gt;::Ptr new_cloud);
 
 protected:
 	void computeTransformation(const Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\NormalDistributionsTransform.cpp" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\NormalDistributionsTransform.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -738,7 +738,7 @@ double NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::getFitnes
 
 
 template &lt;typename PointSourceType, typename PointTargetType&gt;
-void NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::update(typename pcl::PointCloud&lt;PointTargetType&gt;::Ptr new_cloud)
+void NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::updateVoxelGrid(typename pcl::PointCloud&lt;PointTargetType&gt;::Ptr new_cloud)
 {
 	// Update voxel grid
 	voxel_grid_.update(new_cloud);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" added_lines="3" deleted_lines="12">
				<diff>@@ -18,8 +18,6 @@ namespace cpu {
 #define MAX_BY_ (128)
 #define MAX_BZ_ (32)
 
-#define INCREMENTAL_UPDATE_ 1
-
 template &lt;typename PointSourceType&gt;
 VoxelGrid&lt;PointSourceType&gt;::VoxelGrid():
 	voxel_num_(0),
@@ -296,16 +294,7 @@ void VoxelGrid&lt;PointSourceType&gt;::computeCentroidAndCovariance()
 template &lt;typename PointSourceType&gt;
 void VoxelGrid&lt;PointSourceType&gt;::setInput(typename pcl::PointCloud&lt;PointSourceType&gt;::Ptr input_cloud)
 {
-#ifdef INCREMENTAL_UPDATE_
-	if (voxel_num_ &gt; 0) {
-		/* If a voxel grid has already existed,
-		 * only set the source_cloud_ pointer to
-		 * point to new input cloud
-		 */
-		source_cloud_ = input_cloud;
-	} else
-#endif
-		if (input_cloud-&gt;points.size() &gt; 0) {
+	if (input_cloud-&gt;points.size() &gt; 0) {
 		/* If no voxel grid was created, then
 		 * build the initial voxel grid and octree
 		 */
@@ -762,6 +751,8 @@ void VoxelGrid&lt;PointSourceType&gt;::update(typename pcl::PointCloud&lt;PointSourceType
 	 * Update centroids of voxels and their covariance matrixes
 	 * as well as inverse covariance matrixes */
 	updateVoxelContent(new_cloud);
+
+	*source_cloud_ += *new_cloud;
 }
 
 template &lt;typename PointSourceType&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="29" deleted_lines="14">
				<diff>@@ -156,12 +156,11 @@ static double min_add_scan_shift = 1.0;
 static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
 static Eigen::Matrix4f tf_btol, tf_ltob;
 
-static bool isMapUpdate = true;
-
 static bool _use_openmp = false;
 static bool _use_gpu = false;
 
 static bool _use_fast_pcl = false;
+static bool _incremental_voxel_update = false;
 
 static bool _use_imu = false;
 static bool _use_odom = false;
@@ -544,7 +543,8 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 	  }
   }
 
-  if (isMapUpdate == true)
+  static bool is_first_map = true;
+  if (is_first_map == true)
   {
 #ifdef CUDA_FOUND
     if (_use_gpu == true)
@@ -554,17 +554,16 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     else
 #endif
     {
-    	if (_use_fast_pcl)
+    	if (_use_fast_pcl == true)
     	{
-          cpu_ndt.setInputTarget(map_ptr);
+            cpu_ndt.setInputTarget(map_ptr);
     	}
 		else
 		{
           ndt.setInputTarget(map_ptr);
 		}
     }
-
-    isMapUpdate = false;
+    is_first_map = false;
   }
 
   guess_pose.x = previous_pose.x + diff_x;
@@ -762,12 +761,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   double shift = sqrt(pow(current_pose.x - added_pose.x, 2.0) + pow(current_pose.y - added_pose.y, 2.0));
   if (shift &gt;= min_add_scan_shift)
   {
-	// Update the current ndt structure
-	if (_use_fast_pcl &amp;&amp; !_use_gpu)
-	{
-	  cpu_ndt.update(transformed_scan_ptr);
-	}
-
     map += *transformed_scan_ptr;
     added_pose.x = current_pose.x;
     added_pose.y = current_pose.y;
@@ -775,7 +768,27 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     added_pose.roll = current_pose.roll;
     added_pose.pitch = current_pose.pitch;
     added_pose.yaw = current_pose.yaw;
-    isMapUpdate = true;
+
+    #ifdef CUDA_FOUND
+        if (_use_gpu == true)
+        {
+          gpu_ndt.setInputTarget(map_ptr);
+        }
+        else
+    #endif
+        {
+        	if (_use_fast_pcl == true)
+        	{
+              if(_incremental_voxel_update == true)
+                cpu_ndt.updateVoxelGrid(transformed_scan_ptr);
+              else
+                cpu_ndt.setInputTarget(map_ptr);
+        	}
+    		else
+    		{
+              ndt.setInputTarget(map_ptr);
+    		}
+        }
   }
 
 
@@ -899,6 +912,7 @@ int main(int argc, char** argv)
   private_nh.getParam("use_odom", _use_odom);
   private_nh.getParam("imu_upside_down", _imu_upside_down);
   private_nh.getParam("imu_topic", _imu_topic);
+  private_nh.getParam("incremental_voxel_update", _incremental_voxel_update);
 
   std::cout &lt;&lt; "use_imu: " &lt;&lt; _use_imu &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_gpu: " &lt;&lt; _use_gpu &lt;&lt; std::endl;
@@ -907,6 +921,7 @@ int main(int argc, char** argv)
   std::cout &lt;&lt; "imu_upside_down: " &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_odom: " &lt;&lt; _use_odom &lt;&lt; std::endl;
   std::cout &lt;&lt; "imu_topic: " &lt;&lt; _imu_topic &lt;&lt; std::endl;
+  std::cout &lt;&lt; "incremental_voxel_update: " &lt;&lt; _incremental_voxel_update &lt;&lt; std::endl;
 
   if (nh.getParam("tf_x", _tf_x) == false)
   {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9f4c10e4f6b715266efeede2a1b558c1c0afbf50" author="Yamato ANDO">
		<msg>improve config gui of NDT</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="26" deleted_lines="33">
				<diff>@@ -58,7 +58,7 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#ifdef USE_FAST_PCL
+#ifdef USE_PCL_OPENMP
   #include &lt;fast_pcl/filters/voxel_grid.h&gt;
   #include &lt;fast_pcl/registration/ndt.h&gt;
 #else
@@ -89,6 +89,15 @@ struct pose
   double yaw;
 };
 
+enum class MethodType
+{
+    PCL_GENERIC = 0,
+    PCL_ANH = 1,
+    PCL_ANH_GPU = 2,
+    PCL_OPENMP = 3,
+};
+static MethodType _method_type = MethodType::PCL_GENERIC;
+
 // global variables
 static pose previous_pose, guess_pose, guess_pose_imu, guess_pose_odom, guess_pose_imu_odom, current_pose,
     current_pose_imu, current_pose_odom, current_pose_imu_odom, ndt_pose, added_pose, localizer_pose;
@@ -156,16 +165,12 @@ static double min_add_scan_shift = 1.0;
 static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
 static Eigen::Matrix4f tf_btol, tf_ltob;
 
-static bool _use_openmp = false;
-static bool _use_gpu = false;
-
-static bool _use_fast_pcl = false;
-static bool _incremental_voxel_update = false;
-
 static bool _use_imu = false;
 static bool _use_odom = false;
 static bool _imu_upside_down = false;
 
+static bool _incremental_voxel_update = false;
+
 static std::string _imu_topic = "/imu_raw";
 
 static double fitness_score;
@@ -514,7 +519,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
 
   #ifdef CUDA_FOUND
-    if (_use_gpu == true)
+    if (_method_type == MethodType::PCL_ANH_GPU)
     {
       gpu_ndt.setTransformationEpsilon(trans_eps);
       gpu_ndt.setStepSize(step_size);
@@ -525,7 +530,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     else
   #endif
   {
-	  if (_use_fast_pcl)
+	  if (_method_type == MethodType::PCL_ANH)
 	  {
         cpu_ndt.setTransformationEpsilon(trans_eps);
   		cpu_ndt.setStepSize(step_size);
@@ -547,14 +552,14 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   if (is_first_map == true)
   {
 #ifdef CUDA_FOUND
-    if (_use_gpu == true)
+    if (_method_type == MethodType::PCL_ANH_GPU)
     {
       gpu_ndt.setInputTarget(map_ptr);
     }
     else
 #endif
     {
-    	if (_use_fast_pcl == true)
+    	if (_method_type == MethodType::PCL_ANH)
     	{
             cpu_ndt.setInputTarget(map_ptr);
     	}
@@ -607,7 +612,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
 
   #ifdef CUDA_FOUND
-    if (_use_gpu == true)
+    if (_method_type == MethodType::PCL_ANH_GPU)
     {
       gpu_ndt.align(init_guess);
       t_localizer = gpu_ndt.getFinalTransformation();
@@ -617,7 +622,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     }
     else
   #endif
-    if (_use_fast_pcl)
+    if (_method_type == MethodType::PCL_ANH)
     {
       cpu_ndt.align(init_guess);
 
@@ -629,7 +634,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     }
     else
     {
-      #ifdef USE_FAST_PCL
+      #ifdef USE_PCL_OPENMP
         ndt.omp_align(*output_cloud, init_guess);
         fitness_score = ndt.omp_getFitnessScore();
       #else
@@ -770,14 +775,14 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     added_pose.yaw = current_pose.yaw;
 
     #ifdef CUDA_FOUND
-        if (_use_gpu == true)
+        if (_method_type == MethodType::PCL_ANH_GPU)
         {
           gpu_ndt.setInputTarget(map_ptr);
         }
         else
     #endif
         {
-        	if (_use_fast_pcl == true)
+        	if (_method_type == MethodType::PCL_ANH)
         	{
               if(_incremental_voxel_update == true)
                 cpu_ndt.updateVoxelGrid(transformed_scan_ptr);
@@ -905,21 +910,17 @@ int main(int argc, char** argv)
   ros::NodeHandle private_nh("~");
 
 // setting parameters
-  private_nh.getParam("use_gpu", _use_gpu);
-  private_nh.getParam("use_openmp", _use_openmp);
-  private_nh.getParam("use_fast_pcl", _use_fast_pcl);
-  private_nh.getParam("use_imu", _use_imu);
-  private_nh.getParam("use_odom", _use_odom);
+  int method_type_tmp = 0;
+  private_nh.getParam("method_type", method_type_tmp);
+  _method_type = static_cast&lt;MethodType&gt;(method_type_tmp);
   private_nh.getParam("imu_upside_down", _imu_upside_down);
   private_nh.getParam("imu_topic", _imu_topic);
   private_nh.getParam("incremental_voxel_update", _incremental_voxel_update);
 
+  std::cout &lt;&lt; "method_type: " &lt;&lt; static_cast&lt;int&gt;(_method_type) &lt;&lt; std::endl;
+  std::cout &lt;&lt; "use_odom: " &lt;&lt; _use_odom &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_imu: " &lt;&lt; _use_imu &lt;&lt; std::endl;
-  std::cout &lt;&lt; "use_gpu: " &lt;&lt; _use_gpu &lt;&lt; std::endl;
-  std::cout &lt;&lt; "use_openmp: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
-  std::cout &lt;&lt; "use_fast_pcl: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
   std::cout &lt;&lt; "imu_upside_down: " &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
-  std::cout &lt;&lt; "use_odom: " &lt;&lt; _use_odom &lt;&lt; std::endl;
   std::cout &lt;&lt; "imu_topic: " &lt;&lt; _imu_topic &lt;&lt; std::endl;
   std::cout &lt;&lt; "incremental_voxel_update: " &lt;&lt; _incremental_voxel_update &lt;&lt; std::endl;
 
@@ -954,14 +955,6 @@ int main(int argc, char** argv)
     return 1;
   }
 
-#if defined(CUDA_FOUND) &amp;&amp; defined(USE_FAST_PCL)
-  if (_use_gpu == true &amp;&amp; _use_openmp == true)
-  {
-    std::cout &lt;&lt; "use_gpu and use_openmp are exclusive. Set use_gpu true and use_openmp false." &lt;&lt; std::endl;
-    _use_openmp = false;
-  }
-#endif
-
   std::cout &lt;&lt; "(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (" &lt;&lt; _tf_x &lt;&lt; ", " &lt;&lt; _tf_y &lt;&lt; ", " &lt;&lt; _tf_z &lt;&lt; ", "
             &lt;&lt; _tf_roll &lt;&lt; ", " &lt;&lt; _tf_pitch &lt;&lt; ", " &lt;&lt; _tf_yaw &lt;&lt; ")" &lt;&lt; std::endl;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="33" deleted_lines="39">
				<diff>@@ -65,7 +65,7 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#ifdef USE_FAST_PCL
+#ifdef USE_PCL_OPENMP
   #include &lt;fast_pcl/registration/ndt.h&gt;
 #else
   #include &lt;pcl/registration/ndt.h&gt;
@@ -104,6 +104,15 @@ struct pose
   double yaw;
 };
 
+enum class MethodType
+{
+    PCL_GENERIC = 0,
+    PCL_ANH = 1,
+    PCL_ANH_GPU = 2,
+    PCL_OPENMP = 3,
+};
+static MethodType _method_type = MethodType::PCL_GENERIC;
+
 static pose initial_pose, predict_pose, predict_pose_imu, predict_pose_odom, predict_pose_imu_odom, previous_pose,
     ndt_pose, current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, localizer_pose,
     previous_gnss_pose, current_gnss_pose;
@@ -222,11 +231,6 @@ static std::string _offset = "linear";  // linear, zero, quadratic
 static ros::Publisher ndt_reliability_pub;
 static std_msgs::Float32 ndt_reliability;
 
-static bool _use_gpu = false;
-static bool _use_openmp = false;
-
-static bool _use_fast_pcl = false;
-
 static bool _get_height = false;
 static bool _use_local_transform = false;
 static bool _use_imu = false;
@@ -268,14 +272,14 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
   {
     ndt_res = input-&gt;resolution;
 #ifdef CUDA_FOUND
-    if (_use_gpu == true)
+    if (_method_type == MethodType::PCL_ANH_GPU)
     {
       gpu_ndt_ptr-&gt;setResolution(ndt_res);
     }
     else
     {
 #endif
-		if (_use_fast_pcl)
+		if (_method_type == MethodType::PCL_ANH)
 		{
           cpu_ndt.setResolution(ndt_res);
 		}
@@ -291,14 +295,14 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
   {
     step_size = input-&gt;step_size;
 #ifdef CUDA_FOUND
-    if (_use_gpu == true)
+    if (_method_type == MethodType::PCL_ANH_GPU)
     {
       gpu_ndt_ptr-&gt;setStepSize(step_size);
     }
     else
     {
 #endif
-		if (_use_fast_pcl)
+		if (_method_type == MethodType::PCL_ANH)
 		{
           cpu_ndt.setStepSize(step_size);
 		}
@@ -314,14 +318,14 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
   {
     trans_eps = input-&gt;trans_epsilon;
 #ifdef CUDA_FOUND
-    if (_use_gpu == true)
+    if (_method_type == MethodType::PCL_ANH_GPU)
     {
       gpu_ndt_ptr-&gt;setTransformationEpsilon(trans_eps);
     }
     else
     {
 #endif
-		if (_use_fast_pcl)
+		if (_method_type == MethodType::PCL_ANH)
 		{
           cpu_ndt.setTransformationEpsilon(trans_eps);
 		}
@@ -337,14 +341,14 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
   {
     max_iter = input-&gt;max_iterations;
 #ifdef CUDA_FOUND
-    if (_use_gpu == true)
+    if (_method_type == MethodType::PCL_ANH_GPU)
     {
       gpu_ndt_ptr-&gt;setMaximumIterations(max_iter);
     }
     else
     {
 #endif
-		if (_use_fast_pcl)
+		if (_method_type == MethodType::PCL_ANH)
 		{
           cpu_ndt.setMaximumIterations(max_iter);
 		}
@@ -463,7 +467,7 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
 // Setting point cloud to be aligned to.
 #ifdef CUDA_FOUND
-    if (_use_gpu == true)
+    if (_method_type == MethodType::PCL_ANH_GPU)
     {
       std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; new_gpu_ndt_ptr = std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
       new_gpu_ndt_ptr-&gt;setResolution(ndt_res);
@@ -485,7 +489,7 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     }
     else
 #endif
-    if (_use_fast_pcl)
+    if (_method_type == MethodType::PCL_ANH)
     {
       cpu::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_cpu_ndt;
       new_cpu_ndt.setResolution(ndt_res);
@@ -514,7 +518,7 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       new_ndt.setMaximumIterations(max_iter);
       new_ndt.setStepSize(step_size);
       new_ndt.setTransformationEpsilon(trans_eps);
-      #ifdef USE_FAST_PCL
+      #ifdef USE_PCL_OPENMP
         new_ndt.omp_align(*output_cloud, Eigen::Matrix4f::Identity());
       #else
         new_ndt.align(*output_cloud, Eigen::Matrix4f::Identity());
@@ -907,14 +911,14 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
     pthread_mutex_lock(&amp;mutex);
 #ifdef CUDA_FOUND
-    if (_use_gpu == true)
+    if (_method_type == MethodType::PCL_ANH_GPU)
     {
       gpu_ndt_ptr-&gt;setInputSource(filtered_scan_ptr);
     }
     else
     {
 #endif
-		if (_use_fast_pcl)
+		if (_method_type == MethodType::PCL_ANH)
 		{
           cpu_ndt.setInputSource(filtered_scan_ptr);
 		}
@@ -961,7 +965,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
 
     #ifdef CUDA_FOUND
-      if (_use_gpu == true)
+      if (_method_type == MethodType::PCL_ANH_GPU)
       {
         align_start = std::chrono::system_clock::now();
         gpu_ndt_ptr-&gt;align(init_guess);
@@ -980,7 +984,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       }
       else
     #endif
-      if (_use_fast_pcl)
+      if (_method_type == MethodType::PCL_ANH)
       {
         align_start = std::chrono::system_clock::now();
         cpu_ndt.align(init_guess);
@@ -1000,7 +1004,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       else
       {
         align_start = std::chrono::system_clock::now();
-        #ifdef USE_FAST_PCL
+        #ifdef USE_PCL_OPENMP
           ndt.omp_align(*output_cloud, init_guess);
         #else
           ndt.align(*output_cloud, init_guess);
@@ -1013,7 +1017,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
         iteration = ndt.getFinalNumIteration();
 
         getFitnessScore_start = std::chrono::system_clock::now();
-        #ifdef USE_FAST_PCL
+        #ifdef USE_PCL_OPENMP
           fitness_score = ndt.omp_getFitnessScore();
         #else
           fitness_score = ndt.getFitnessScore();
@@ -1480,12 +1484,12 @@ int main(int argc, char** argv)
   ofs.open(filename.c_str(), std::ios::app);
 
   // Geting parameters
+  int method_type_tmp = 0;
+  private_nh.getParam("method_type", method_type_tmp);
+  _method_type = static_cast&lt;MethodType&gt;(method_type_tmp);
   private_nh.getParam("use_gnss", _use_gnss);
   private_nh.getParam("queue_size", _queue_size);
   private_nh.getParam("offset", _offset);
-  private_nh.getParam("use_openmp", _use_openmp);
-  private_nh.getParam("use_gpu", _use_gpu);
-  private_nh.getParam("use_fast_pcl", _use_fast_pcl);
   private_nh.getParam("get_height", _get_height);
   private_nh.getParam("use_local_transform", _use_local_transform);
   private_nh.getParam("use_imu", _use_imu);
@@ -1493,14 +1497,6 @@ int main(int argc, char** argv)
   private_nh.getParam("imu_upside_down", _imu_upside_down);
   private_nh.getParam("imu_topic", _imu_topic);
 
-#if defined(CUDA_FOUND) &amp;&amp; defined(USE_FAST_PCL)
-  if (_use_gpu == true &amp;&amp; _use_openmp == true)
-  {
-    std::cout &lt;&lt; "use_gpu and use_openmp are exclusive. Set use_gpu true and use_openmp false." &lt;&lt; std::endl;
-    _use_openmp = false;
-  }
-#endif
-
   if (nh.getParam("localizer", _localizer) == false)
   {
     std::cout &lt;&lt; "localizer is not set." &lt;&lt; std::endl;
@@ -1539,19 +1535,17 @@ int main(int argc, char** argv)
 
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
   std::cout &lt;&lt; "Log file: " &lt;&lt; filename &lt;&lt; std::endl;
+  std::cout &lt;&lt; "method_type: " &lt;&lt; static_cast&lt;int&gt;(_method_type) &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_gnss: " &lt;&lt; _use_gnss &lt;&lt; std::endl;
   std::cout &lt;&lt; "queue_size: " &lt;&lt; _queue_size &lt;&lt; std::endl;
   std::cout &lt;&lt; "offset: " &lt;&lt; _offset &lt;&lt; std::endl;
-  std::cout &lt;&lt; "use_gpu: " &lt;&lt; _use_gpu &lt;&lt; std::endl;
-  std::cout &lt;&lt; "use_openmp: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
-  std::cout &lt;&lt; "use_fast_pcl: " &lt;&lt; _use_fast_pcl &lt;&lt; std::endl;
   std::cout &lt;&lt; "get_height: " &lt;&lt; _get_height &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_local_transform: " &lt;&lt; _use_local_transform &lt;&lt; std::endl;
-  std::cout &lt;&lt; "use_imu: " &lt;&lt; _use_imu &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_odom: " &lt;&lt; _use_odom &lt;&lt; std::endl;
+  std::cout &lt;&lt; "use_imu: " &lt;&lt; _use_imu &lt;&lt; std::endl;
   std::cout &lt;&lt; "imu_upside_down: " &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
-  std::cout &lt;&lt; "localizer: " &lt;&lt; _localizer &lt;&lt; std::endl;
   std::cout &lt;&lt; "imu_topic: " &lt;&lt; _imu_topic &lt;&lt; std::endl;
+  std::cout &lt;&lt; "localizer: " &lt;&lt; _localizer &lt;&lt; std::endl;
   std::cout &lt;&lt; "(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (" &lt;&lt; _tf_x &lt;&lt; ", " &lt;&lt; _tf_y &lt;&lt; ", " &lt;&lt; _tf_z &lt;&lt; ", "
             &lt;&lt; _tf_roll &lt;&lt; ", " &lt;&lt; _tf_pitch &lt;&lt; ", " &lt;&lt; _tf_yaw &lt;&lt; ")" &lt;&lt; std::endl;
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="674fce8bea3844089fd036faa4497e8d6f481a5c" author="Yamato ANDO">
		<msg>refactor code, remove ndt_mapping_omp and ndt_matching_omp</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\filters\include\fast_pcl\filters\boost.h" new_path="" added_lines="0" deleted_lines="61">
				<diff>@@ -1,61 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id: io.h 5850 2012-06-06 14:04:59Z stfox88 $
- *
- */
-
-#ifndef FAST_PCL_FILTERS_BOOST_H_
-#define FAST_PCL_FILTERS_BOOST_H_
-
-#ifdef __GNUC__
-#pragma GCC system_header 
-#endif
-
-// Marking all Boost headers as system headers to remove warnings
-#include &lt;boost/random.hpp&gt;
-#include &lt;boost/random/normal_distribution.hpp&gt;
-#include &lt;boost/shared_ptr.hpp&gt;
-#include &lt;boost/make_shared.hpp&gt;
-#include &lt;boost/dynamic_bitset.hpp&gt;
-#include &lt;boost/mpl/size.hpp&gt;
-#include &lt;boost/unordered_map.hpp&gt;
-#include &lt;boost/fusion/sequence/intrinsic/at_key.hpp&gt;
-#include &lt;boost/bind.hpp&gt;
-#include &lt;boost/function.hpp&gt;
-#include &lt;boost/optional.hpp&gt;
-
-#endif    // FAST_PCL_FILTERS_BOOST_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\filters\include\fast_pcl\filters\filter.h" new_path="" added_lines="0" deleted_lines="276">
				<diff>@@ -1,276 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#ifndef FAST_PCL_FILTER_H_
-#define FAST_PCL_FILTER_H_
-
-#include &lt;pcl/pcl_base.h&gt;
-#include &lt;pcl/common/io.h&gt;
-#include &lt;pcl/conversions.h&gt;
-//#include &lt;pcl/filters/boost.h&gt;
-#include "fast_pcl/filters/boost.h"
-
-#include &lt;cfloat&gt;
-#include &lt;pcl/PointIndices.h&gt;
-
-namespace pcl
-{
-  /** \brief Removes points with x, y, or z equal to NaN
-    * \param[in] cloud_in the input point cloud
-    * \param[out] cloud_out the input point cloud
-    * \param[out] index the mapping (ordered): cloud_out.points[i] = cloud_in.points[index[i]]
-    * \note The density of the point cloud is lost.
-    * \note Can be called with cloud_in == cloud_out
-    * \ingroup filters
-    */
-  template&lt;typename PointT&gt; void
-  removeNaNFromPointCloud (const pcl::PointCloud&lt;PointT&gt; &amp;cloud_in, 
-                           pcl::PointCloud&lt;PointT&gt; &amp;cloud_out, 
-                           std::vector&lt;int&gt; &amp;index);
-
-  /** \brief Removes points that have their normals invalid (i.e., equal to NaN)
-    * \param[in] cloud_in the input point cloud
-    * \param[out] cloud_out the input point cloud
-    * \param[out] index the mapping (ordered): cloud_out.points[i] = cloud_in.points[index[i]]
-    * \note The density of the point cloud is lost.
-    * \note Can be called with cloud_in == cloud_out
-    * \ingroup filters
-    */
-  template&lt;typename PointT&gt; void
-  removeNaNNormalsFromPointCloud (const pcl::PointCloud&lt;PointT&gt; &amp;cloud_in, 
-                                  pcl::PointCloud&lt;PointT&gt; &amp;cloud_out, 
-                                  std::vector&lt;int&gt; &amp;index);
-
-  ////////////////////////////////////////////////////////////////////////////////////////////
-  /** \brief Filter represents the base filter class. All filters must inherit from this interface.
-    * \author Radu B. Rusu
-    * \ingroup filters
-    */
-  template&lt;typename PointT&gt;
-  class Filter : public PCLBase&lt;PointT&gt;
-  {
-    public:
-      using PCLBase&lt;PointT&gt;::indices_;
-      using PCLBase&lt;PointT&gt;::input_;
-
-      typedef boost::shared_ptr&lt; Filter&lt;PointT&gt; &gt; Ptr;
-      typedef boost::shared_ptr&lt; const Filter&lt;PointT&gt; &gt; ConstPtr;
-
-
-      typedef pcl::PointCloud&lt;PointT&gt; PointCloud;
-      typedef typename PointCloud::Ptr PointCloudPtr;
-      typedef typename PointCloud::ConstPtr PointCloudConstPtr;
-
-      /** \brief Empty constructor.
-        * \param[in] extract_removed_indices set to true if the filtered data indices should be saved in a 
-        * separate list. Default: false.
-        */
-      Filter (bool extract_removed_indices = false) : 
-        removed_indices_ (new std::vector&lt;int&gt;),
-        filter_name_ (),
-        extract_removed_indices_ (extract_removed_indices)
-      {
-      }
-
-      /** \brief Empty destructor */
-      virtual ~Filter () {}
-
-      /** \brief Get the point indices being removed */
-      inline IndicesConstPtr const
-      getRemovedIndices ()
-      {
-        return (removed_indices_);
-      }
-
-      /** \brief Get the point indices being removed 
-        * \param[out] pi the resultant point indices that have been removed
-        */
-      inline void
-      getRemovedIndices (PointIndices &amp;pi)
-      {
-        pi.indices = *removed_indices_;
-      }
-
-      /** \brief Calls the filtering method and returns the filtered dataset in output.
-        * \param[out] output the resultant filtered point cloud dataset
-        */
-      inline void
-      filter (PointCloud &amp;output)
-      {
-        if (!initCompute ())
-          return;
-
-        if (input_.get () == &amp;output)  // cloud_in = cloud_out
-        {
-          PointCloud output_temp;
-          applyFilter (output_temp);
-          output_temp.header = input_-&gt;header;
-          output_temp.sensor_origin_ = input_-&gt;sensor_origin_;
-          output_temp.sensor_orientation_ = input_-&gt;sensor_orientation_;
-          pcl::copyPointCloud (output_temp, output);
-        }
-        else
-        {
-          output.header = input_-&gt;header;
-          output.sensor_origin_ = input_-&gt;sensor_origin_;
-          output.sensor_orientation_ = input_-&gt;sensor_orientation_;
-          applyFilter (output);
-        }
-
-        deinitCompute ();
-      }
-
-    protected:
-
-      using PCLBase&lt;PointT&gt;::initCompute;
-      using PCLBase&lt;PointT&gt;::deinitCompute;
-
-      /** \brief Indices of the points that are removed */
-      IndicesPtr removed_indices_;
-
-      /** \brief The filter name. */
-      std::string filter_name_;
-
-      /** \brief Set to true if we want to return the indices of the removed points. */
-      bool extract_removed_indices_;
-
-      /** \brief Abstract filter method. 
-        *
-        * The implementation needs to set output.{points, width, height, is_dense}.
-        *
-        * \param[out] output the resultant filtered point cloud
-        */
-      virtual void
-      applyFilter (PointCloud &amp;output) = 0;
-
-      /** \brief Get a string representation of the name of this class. */
-      inline const std::string&amp;
-      getClassName () const
-      {
-        return (filter_name_);
-      }
-  };
-
-  ////////////////////////////////////////////////////////////////////////////////////////////
-  /** \brief Filter represents the base filter class. All filters must inherit from this interface.
-    * \author Radu B. Rusu
-    * \ingroup filters
-    */
-  template&lt;&gt;
-  class PCL_EXPORTS Filter&lt;pcl::PCLPointCloud2&gt; : public PCLBase&lt;pcl::PCLPointCloud2&gt;
-  {
-    public:
-      typedef boost::shared_ptr&lt; Filter&lt;pcl::PCLPointCloud2&gt; &gt; Ptr;
-      typedef boost::shared_ptr&lt; const Filter&lt;pcl::PCLPointCloud2&gt; &gt; ConstPtr;
-
-      typedef pcl::PCLPointCloud2 PCLPointCloud2;
-      typedef PCLPointCloud2::Ptr PCLPointCloud2Ptr;
-      typedef PCLPointCloud2::ConstPtr PCLPointCloud2ConstPtr;
-
-      /** \brief Empty constructor. 
-        * \param[in] extract_removed_indices set to true if the filtered data indices should be saved in a 
-        * separate list. Default: false.
-        */
-      Filter (bool extract_removed_indices = false) : 
-        removed_indices_ (new std::vector&lt;int&gt;),
-        extract_removed_indices_ (extract_removed_indices),
-        filter_name_ ()
-      {
-      }
-      
-      /** \brief Empty destructor */
-      virtual ~Filter () {}
-
-      /** \brief Get the point indices being removed */
-      inline IndicesConstPtr const
-      getRemovedIndices ()
-      {
-        return (removed_indices_);
-      }
-
-      /** \brief Get the point indices being removed 
-        * \param[out] pi the resultant point indices that have been removed
-        */
-      inline void
-      getRemovedIndices (PointIndices &amp;pi)
-      {
-        pi.indices = *removed_indices_;
-      }
-
-      /** \brief Calls the filtering method and returns the filtered dataset in output.
-        * \param[out] output the resultant filtered point cloud dataset
-        */
-      void
-      filter (PCLPointCloud2 &amp;output);
-
-    protected:
-
-      /** \brief Indices of the points that are removed */
-      IndicesPtr removed_indices_;
-
-      /** \brief Set to true if we want to return the indices of the removed points. */
-      bool extract_removed_indices_;
-
-      /** \brief The filter name. */
-      std::string filter_name_;
-
-      /** \brief Abstract filter method.
-        *
-        * The implementation needs to set output.{data, row_step, point_step, width, height, is_dense}.
-        *
-        * \param[out] output the resultant filtered point cloud
-        */
-      virtual void
-      applyFilter (PCLPointCloud2 &amp;output) = 0;
-
-      /** \brief Get a string representation of the name of this class. */
-      inline const std::string&amp;
-      getClassName () const
-      {
-        return (filter_name_);
-      }
-  };
-}
-
-#ifdef PCL_NO_PRECOMPILE
-    //#include &lt;pcl/filters/impl/filter.hpp&gt;
-#include "fast_pcl/filters/impl/filter.hpp"
-#endif
-
-#endif  //#ifndef FAST_PCL_FILTER_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\filters\include\fast_pcl\filters\impl\filter.hpp" new_path="" added_lines="0" deleted_lines="137">
				<diff>@@ -1,137 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2009, Willow Garage, Inc.
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#ifndef FAST_PCL_FILTERS_IMPL_FILTER_H_
-#define FAST_PCL_FILTERS_IMPL_FILTER_H_
-
-#include &lt;pcl/pcl_macros.h&gt;
-//#include &lt;pcl/filters/filter.h&gt;
-#include "fast_pcl/filters/filter.h"
-
-//////////////////////////////////////////////////////////////////////////
-template &lt;typename PointT&gt; void
-pcl::removeNaNFromPointCloud (const pcl::PointCloud&lt;PointT&gt; &amp;cloud_in, 
-                              pcl::PointCloud&lt;PointT&gt; &amp;cloud_out,
-                              std::vector&lt;int&gt; &amp;index)
-{
-  // If the clouds are not the same, prepare the output
-  if (&amp;cloud_in != &amp;cloud_out)
-  {
-    cloud_out.header = cloud_in.header;
-    cloud_out.points.resize (cloud_in.points.size ());
-  }
-  // Reserve enough space for the indices
-  index.resize (cloud_in.points.size ());
-  size_t j = 0;
-
-  // If the data is dense, we don't need to check for NaN
-  if (cloud_in.is_dense)
-  {
-    // Simply copy the data
-    cloud_out = cloud_in;
-    for (j = 0; j &lt; cloud_out.points.size (); ++j)
-      index[j] = static_cast&lt;int&gt;(j);
-  }
-  else
-  {
-    for (size_t i = 0; i &lt; cloud_in.points.size (); ++i)
-    {
-      if (!pcl_isfinite (cloud_in.points[i].x) || 
-          !pcl_isfinite (cloud_in.points[i].y) || 
-          !pcl_isfinite (cloud_in.points[i].z))
-        continue;
-      cloud_out.points[j] = cloud_in.points[i];
-      index[j] = static_cast&lt;int&gt;(i);
-      j++;
-    }
-    if (j != cloud_in.points.size ())
-    {
-      // Resize to the correct size
-      cloud_out.points.resize (j);
-      index.resize (j);
-    }
-
-    cloud_out.height = 1;
-    cloud_out.width  = static_cast&lt;uint32_t&gt;(j);
-
-    // Removing bad points =&gt; dense (note: 'dense' doesn't mean 'organized')
-    cloud_out.is_dense = true;
-  }
-}
-
-//////////////////////////////////////////////////////////////////////////
-template &lt;typename PointT&gt; void
-pcl::removeNaNNormalsFromPointCloud (const pcl::PointCloud&lt;PointT&gt; &amp;cloud_in, 
-                                     pcl::PointCloud&lt;PointT&gt; &amp;cloud_out,
-                                     std::vector&lt;int&gt; &amp;index)
-{
-  // If the clouds are not the same, prepare the output
-  if (&amp;cloud_in != &amp;cloud_out)
-  {
-    cloud_out.header = cloud_in.header;
-    cloud_out.points.resize (cloud_in.points.size ());
-  }
-  // Reserve enough space for the indices
-  index.resize (cloud_in.points.size ());
-  size_t j = 0;
-
-  for (size_t i = 0; i &lt; cloud_in.points.size (); ++i)
-  {
-    if (!pcl_isfinite (cloud_in.points[i].normal_x) || 
-        !pcl_isfinite (cloud_in.points[i].normal_y) || 
-        !pcl_isfinite (cloud_in.points[i].normal_z))
-      continue;
-    cloud_out.points[j] = cloud_in.points[i];
-    index[j] = static_cast&lt;int&gt;(i);
-    j++;
-  }
-  if (j != cloud_in.points.size ())
-  {
-    // Resize to the correct size
-    cloud_out.points.resize (j);
-    index.resize (j);
-  }
-
-  cloud_out.height = 1;
-  cloud_out.width  = static_cast&lt;uint32_t&gt;(j);
-}
-
-
-#define PCL_INSTANTIATE_removeNaNFromPointCloud(T) template PCL_EXPORTS void pcl::removeNaNFromPointCloud&lt;T&gt;(const pcl::PointCloud&lt;T&gt;&amp;, pcl::PointCloud&lt;T&gt;&amp;, std::vector&lt;int&gt;&amp;);
-#define PCL_INSTANTIATE_removeNaNNormalsFromPointCloud(T) template PCL_EXPORTS void pcl::removeNaNNormalsFromPointCloud&lt;T&gt;(const pcl::PointCloud&lt;T&gt;&amp;, pcl::PointCloud&lt;T&gt;&amp;, std::vector&lt;int&gt;&amp;);
-
-#endif    // FAST_PCL_FILTERS_IMPL_FILTER_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\filters\include\fast_pcl\filters\impl\voxel_grid.hpp" new_path="" added_lines="0" deleted_lines="500">
				<diff>@@ -1,500 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2009, Willow Garage, Inc.
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#ifndef FAST_PCL_FILTERS_IMPL_VOXEL_GRID_H_
-#define FAST_PCL_FILTERS_IMPL_VOXEL_GRID_H_
-
-#include &lt;pcl/common/common.h&gt;
-#include &lt;pcl/common/io.h&gt;
-//#include &lt;pcl/filters/voxel_grid.h&gt;
-#include "fast_pcl/filters/voxel_grid.h"
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointT&gt; void
-pcl::getMinMax3D (const typename pcl::PointCloud&lt;PointT&gt;::ConstPtr &amp;cloud,
-                  const std::string &amp;distance_field_name, float min_distance, float max_distance,
-                  Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt, bool limit_negative)
-{
-  Eigen::Array4f min_p, max_p;
-  min_p.setConstant (FLT_MAX);
-  max_p.setConstant (-FLT_MAX);
-
-  // Get the fields list and the distance field index
-  std::vector&lt;pcl::PCLPointField&gt; fields;
-  int distance_idx = pcl::getFieldIndex (*cloud, distance_field_name, fields);
-
-  float distance_value;
-  // If dense, no need to check for NaNs
-  if (cloud-&gt;is_dense)
-  {
-    for (size_t i = 0; i &lt; cloud-&gt;points.size (); ++i)
-    {
-      // Get the distance value
-      const uint8_t* pt_data = reinterpret_cast&lt;const uint8_t*&gt; (&amp;cloud-&gt;points[i]);
-      memcpy (&amp;distance_value, pt_data + fields[distance_idx].offset, sizeof (float));
-
-      if (limit_negative)
-      {
-        // Use a threshold for cutting out points which inside the interval
-        if ((distance_value &lt; max_distance) &amp;&amp; (distance_value &gt; min_distance))
-          continue;
-      }
-      else
-      {
-        // Use a threshold for cutting out points which are too close/far away
-        if ((distance_value &gt; max_distance) || (distance_value &lt; min_distance))
-          continue;
-      }
-      // Create the point structure and get the min/max
-      pcl::Array4fMapConst pt = cloud-&gt;points[i].getArray4fMap ();
-      min_p = min_p.min (pt);
-      max_p = max_p.max (pt);
-    }
-  }
-  else
-  {
-    for (size_t i = 0; i &lt; cloud-&gt;points.size (); ++i)
-    {
-      // Get the distance value
-      const uint8_t* pt_data = reinterpret_cast&lt;const uint8_t*&gt; (&amp;cloud-&gt;points[i]);
-      memcpy (&amp;distance_value, pt_data + fields[distance_idx].offset, sizeof (float));
-
-      if (limit_negative)
-      {
-        // Use a threshold for cutting out points which inside the interval
-        if ((distance_value &lt; max_distance) &amp;&amp; (distance_value &gt; min_distance))
-          continue;
-      }
-      else
-      {
-        // Use a threshold for cutting out points which are too close/far away
-        if ((distance_value &gt; max_distance) || (distance_value &lt; min_distance))
-          continue;
-      }
-
-      // Check if the point is invalid
-      if (!pcl_isfinite (cloud-&gt;points[i].x) || 
-          !pcl_isfinite (cloud-&gt;points[i].y) || 
-          !pcl_isfinite (cloud-&gt;points[i].z))
-        continue;
-      // Create the point structure and get the min/max
-      pcl::Array4fMapConst pt = cloud-&gt;points[i].getArray4fMap ();
-      min_p = min_p.min (pt);
-      max_p = max_p.max (pt);
-    }
-  }
-  min_pt = min_p;
-  max_pt = max_p;
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointT&gt; void
-pcl::getMinMax3D (const typename pcl::PointCloud&lt;PointT&gt;::ConstPtr &amp;cloud,
-                  const std::vector&lt;int&gt; &amp;indices,
-                  const std::string &amp;distance_field_name, float min_distance, float max_distance,
-                  Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt, bool limit_negative)
-{
-  Eigen::Array4f min_p, max_p;
-  min_p.setConstant (FLT_MAX);
-  max_p.setConstant (-FLT_MAX);
-
-  // Get the fields list and the distance field index
-  std::vector&lt;pcl::PCLPointField&gt; fields;
-  int distance_idx = pcl::getFieldIndex (*cloud, distance_field_name, fields);
-
-  float distance_value;
-  // If dense, no need to check for NaNs
-  if (cloud-&gt;is_dense)
-  {
-    for (std::vector&lt;int&gt;::const_iterator it = indices.begin (); it != indices.end (); ++it)
-    {
-      // Get the distance value
-      const uint8_t* pt_data = reinterpret_cast&lt;const uint8_t*&gt; (&amp;cloud-&gt;points[*it]);
-      memcpy (&amp;distance_value, pt_data + fields[distance_idx].offset, sizeof (float));
-
-      if (limit_negative)
-      {
-        // Use a threshold for cutting out points which inside the interval
-        if ((distance_value &lt; max_distance) &amp;&amp; (distance_value &gt; min_distance))
-          continue;
-      }
-      else
-      {
-        // Use a threshold for cutting out points which are too close/far away
-        if ((distance_value &gt; max_distance) || (distance_value &lt; min_distance))
-          continue;
-      }
-      // Create the point structure and get the min/max
-      pcl::Array4fMapConst pt = cloud-&gt;points[*it].getArray4fMap ();
-      min_p = min_p.min (pt);
-      max_p = max_p.max (pt);
-    }
-  }
-  else
-  {
-    for (std::vector&lt;int&gt;::const_iterator it = indices.begin (); it != indices.end (); ++it)
-    {
-      // Get the distance value
-      const uint8_t* pt_data = reinterpret_cast&lt;const uint8_t*&gt; (&amp;cloud-&gt;points[*it]);
-      memcpy (&amp;distance_value, pt_data + fields[distance_idx].offset, sizeof (float));
-
-      if (limit_negative)
-      {
-        // Use a threshold for cutting out points which inside the interval
-        if ((distance_value &lt; max_distance) &amp;&amp; (distance_value &gt; min_distance))
-          continue;
-      }
-      else
-      {
-        // Use a threshold for cutting out points which are too close/far away
-        if ((distance_value &gt; max_distance) || (distance_value &lt; min_distance))
-          continue;
-      }
-
-      // Check if the point is invalid
-      if (!pcl_isfinite (cloud-&gt;points[*it].x) || 
-          !pcl_isfinite (cloud-&gt;points[*it].y) || 
-          !pcl_isfinite (cloud-&gt;points[*it].z))
-        continue;
-      // Create the point structure and get the min/max
-      pcl::Array4fMapConst pt = cloud-&gt;points[*it].getArray4fMap ();
-      min_p = min_p.min (pt);
-      max_p = max_p.max (pt);
-    }
-  }
-  min_pt = min_p;
-  max_pt = max_p;
-}
-
-struct cloud_point_index_idx 
-{
-  unsigned int idx;
-  unsigned int cloud_point_index;
-
-  cloud_point_index_idx (unsigned int idx_, unsigned int cloud_point_index_) : idx (idx_), cloud_point_index (cloud_point_index_) {}
-  bool operator &lt; (const cloud_point_index_idx &amp;p) const { return (idx &lt; p.idx); }
-};
-
-//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointT&gt; void
-pcl::VoxelGrid&lt;PointT&gt;::applyFilter (PointCloud &amp;output)
-{
-  // Has the input dataset been set already?
-  if (!input_)
-  {
-    PCL_WARN ("[pcl::%s::applyFilter] No input dataset given!\n", getClassName ().c_str ());
-    output.width = output.height = 0;
-    output.points.clear ();
-    return;
-  }
-
-  // Copy the header (and thus the frame_id) + allocate enough space for points
-  output.height       = 1;                    // downsampling breaks the organized structure
-  output.is_dense     = true;                 // we filter out invalid points
-
-  Eigen::Vector4f min_p, max_p;
-  // Get the minimum and maximum dimensions
-  if (!filter_field_name_.empty ()) // If we don't want to process the entire cloud...
-    getMinMax3D&lt;PointT&gt; (input_, *indices_, filter_field_name_, static_cast&lt;float&gt; (filter_limit_min_), static_cast&lt;float&gt; (filter_limit_max_), min_p, max_p, filter_limit_negative_);
-  else
-    getMinMax3D&lt;PointT&gt; (*input_, *indices_, min_p, max_p);
-
-  // Check that the leaf size is not too small, given the size of the data
-  int64_t dx = static_cast&lt;int64_t&gt;((max_p[0] - min_p[0]) * inverse_leaf_size_[0])+1;
-  int64_t dy = static_cast&lt;int64_t&gt;((max_p[1] - min_p[1]) * inverse_leaf_size_[1])+1;
-  int64_t dz = static_cast&lt;int64_t&gt;((max_p[2] - min_p[2]) * inverse_leaf_size_[2])+1;
-
-  if ((dx*dy*dz) &gt; static_cast&lt;int64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()))
-  {
-    PCL_WARN("[pcl::%s::applyFilter] Leaf size is too small for the input dataset. Integer indices would overflow.", getClassName().c_str());
-    output = *input_;
-    return;
-  }
-
-  // Compute the minimum and maximum bounding box values
-  min_b_[0] = static_cast&lt;int&gt; (floor (min_p[0] * inverse_leaf_size_[0]));
-  max_b_[0] = static_cast&lt;int&gt; (floor (max_p[0] * inverse_leaf_size_[0]));
-  min_b_[1] = static_cast&lt;int&gt; (floor (min_p[1] * inverse_leaf_size_[1]));
-  max_b_[1] = static_cast&lt;int&gt; (floor (max_p[1] * inverse_leaf_size_[1]));
-  min_b_[2] = static_cast&lt;int&gt; (floor (min_p[2] * inverse_leaf_size_[2]));
-  max_b_[2] = static_cast&lt;int&gt; (floor (max_p[2] * inverse_leaf_size_[2]));
-
-  // Compute the number of divisions needed along all axis
-  div_b_ = max_b_ - min_b_ + Eigen::Vector4i::Ones ();
-  div_b_[3] = 0;
-
-  // Set up the division multiplier
-  divb_mul_ = Eigen::Vector4i (1, div_b_[0], div_b_[0] * div_b_[1], 0);
-
-  int centroid_size = 4;
-  if (downsample_all_data_)
-    centroid_size = boost::mpl::size&lt;FieldList&gt;::value;
-
-  // ---[ RGB special case
-  std::vector&lt;pcl::PCLPointField&gt; fields;
-  int rgba_index = -1;
-  rgba_index = pcl::getFieldIndex (*input_, "rgb", fields);
-  if (rgba_index == -1)
-    rgba_index = pcl::getFieldIndex (*input_, "rgba", fields);
-  if (rgba_index &gt;= 0)
-  {
-    rgba_index = fields[rgba_index].offset;
-    centroid_size += 3;
-  }
-
-  std::vector&lt;cloud_point_index_idx&gt; index_vector;
-  index_vector.reserve (indices_-&gt;size ());
-
-  // If we don't want to process the entire cloud, but rather filter points far away from the viewpoint first...
-  if (!filter_field_name_.empty ())
-  {
-    // Get the distance field index
-    std::vector&lt;pcl::PCLPointField&gt; fields;
-    int distance_idx = pcl::getFieldIndex (*input_, filter_field_name_, fields);
-    if (distance_idx == -1)
-      PCL_WARN ("[pcl::%s::applyFilter] Invalid filter field name. Index is %d.\n", getClassName ().c_str (), distance_idx);
-
-    // First pass: go over all points and insert them into the index_vector vector
-    // with calculated idx. Points with the same idx value will contribute to the
-    // same point of resulting CloudPoint
-    for (std::vector&lt;int&gt;::const_iterator it = indices_-&gt;begin (); it != indices_-&gt;end (); ++it)
-    {
-      if (!input_-&gt;is_dense)
-        // Check if the point is invalid
-        if (!pcl_isfinite (input_-&gt;points[*it].x) || 
-            !pcl_isfinite (input_-&gt;points[*it].y) || 
-            !pcl_isfinite (input_-&gt;points[*it].z))
-          continue;
-
-      // Get the distance value
-      const uint8_t* pt_data = reinterpret_cast&lt;const uint8_t*&gt; (&amp;input_-&gt;points[*it]);
-      float distance_value = 0;
-      memcpy (&amp;distance_value, pt_data + fields[distance_idx].offset, sizeof (float));
-
-      if (filter_limit_negative_)
-      {
-        // Use a threshold for cutting out points which inside the interval
-        if ((distance_value &lt; filter_limit_max_) &amp;&amp; (distance_value &gt; filter_limit_min_))
-          continue;
-      }
-      else
-      {
-        // Use a threshold for cutting out points which are too close/far away
-        if ((distance_value &gt; filter_limit_max_) || (distance_value &lt; filter_limit_min_))
-          continue;
-      }
-      
-      int ijk0 = static_cast&lt;int&gt; (floor (input_-&gt;points[*it].x * inverse_leaf_size_[0]) - static_cast&lt;float&gt; (min_b_[0]));
-      int ijk1 = static_cast&lt;int&gt; (floor (input_-&gt;points[*it].y * inverse_leaf_size_[1]) - static_cast&lt;float&gt; (min_b_[1]));
-      int ijk2 = static_cast&lt;int&gt; (floor (input_-&gt;points[*it].z * inverse_leaf_size_[2]) - static_cast&lt;float&gt; (min_b_[2]));
-
-      // Compute the centroid leaf index
-      int idx = ijk0 * divb_mul_[0] + ijk1 * divb_mul_[1] + ijk2 * divb_mul_[2];
-      index_vector.push_back (cloud_point_index_idx (static_cast&lt;unsigned int&gt; (idx), *it));
-    }
-  }
-  // No distance filtering, process all data
-  else
-  {
-    // First pass: go over all points and insert them into the index_vector vector
-    // with calculated idx. Points with the same idx value will contribute to the
-    // same point of resulting CloudPoint
-    for (std::vector&lt;int&gt;::const_iterator it = indices_-&gt;begin (); it != indices_-&gt;end (); ++it)
-    {
-      if (!input_-&gt;is_dense)
-        // Check if the point is invalid
-        if (!pcl_isfinite (input_-&gt;points[*it].x) || 
-            !pcl_isfinite (input_-&gt;points[*it].y) || 
-            !pcl_isfinite (input_-&gt;points[*it].z))
-          continue;
-
-      int ijk0 = static_cast&lt;int&gt; (floor (input_-&gt;points[*it].x * inverse_leaf_size_[0]) - static_cast&lt;float&gt; (min_b_[0]));
-      int ijk1 = static_cast&lt;int&gt; (floor (input_-&gt;points[*it].y * inverse_leaf_size_[1]) - static_cast&lt;float&gt; (min_b_[1]));
-      int ijk2 = static_cast&lt;int&gt; (floor (input_-&gt;points[*it].z * inverse_leaf_size_[2]) - static_cast&lt;float&gt; (min_b_[2]));
-
-      // Compute the centroid leaf index
-      int idx = ijk0 * divb_mul_[0] + ijk1 * divb_mul_[1] + ijk2 * divb_mul_[2];
-      index_vector.push_back (cloud_point_index_idx (static_cast&lt;unsigned int&gt; (idx), *it));
-    }
-  }
-
-  // Second pass: sort the index_vector vector using value representing target cell as index
-  // in effect all points belonging to the same output cell will be next to each other
-  std::sort (index_vector.begin (), index_vector.end (), std::less&lt;cloud_point_index_idx&gt; ());
-
-  // Third pass: count output cells
-  // we need to skip all the same, adjacenent idx values
-  unsigned int total = 0;
-  unsigned int index = 0;
-  // first_and_last_indices_vector[i] represents the index in index_vector of the first point in
-  // index_vector belonging to the voxel which corresponds to the i-th output point,
-  // and of the first point not belonging to.
-  std::vector&lt;std::pair&lt;unsigned int, unsigned int&gt; &gt; first_and_last_indices_vector;
-  // Worst case size
-  first_and_last_indices_vector.reserve (index_vector.size ());
-  while (index &lt; index_vector.size ()) 
-  {
-    unsigned int i = index + 1;
-    while (i &lt; index_vector.size () &amp;&amp; index_vector[i].idx == index_vector[index].idx) 
-      ++i;
-    if (i - index &gt;= min_points_per_voxel_)
-    {
-      ++total;
-      first_and_last_indices_vector.push_back (std::pair&lt;unsigned int, unsigned int&gt; (index, i));
-    }
-    index = i;
-  }
-
-  // Fourth pass: compute centroids, insert them into their final position
-  output.points.resize (total);
-  if (save_leaf_layout_)
-  {
-    try
-    { 
-      // Resizing won't reset old elements to -1.  If leaf_layout_ has been used previously, it needs to be re-initialized to -1
-      uint32_t new_layout_size = div_b_[0]*div_b_[1]*div_b_[2];
-      //This is the number of elements that need to be re-initialized to -1
-      uint32_t reinit_size = std::min (static_cast&lt;unsigned int&gt; (new_layout_size), static_cast&lt;unsigned int&gt; (leaf_layout_.size()));
-      for (uint32_t i = 0; i &lt; reinit_size; i++)
-      {
-        leaf_layout_[i] = -1;
-      }        
-      leaf_layout_.resize (new_layout_size, -1);           
-    }
-    catch (std::bad_alloc&amp;)
-    {
-      throw PCLException("VoxelGrid bin size is too low; impossible to allocate memory for layout", 
-        "voxel_grid.hpp", "applyFilter");	
-    }
-    catch (std::length_error&amp;)
-    {
-      throw PCLException("VoxelGrid bin size is too low; impossible to allocate memory for layout", 
-        "voxel_grid.hpp", "applyFilter");	
-    }
-  }
-  
-  index = 0;
-  Eigen::VectorXf centroid = Eigen::VectorXf::Zero (centroid_size);
-  Eigen::VectorXf temporary = Eigen::VectorXf::Zero (centroid_size);
-
-  for (unsigned int cp = 0; cp &lt; first_and_last_indices_vector.size (); ++cp)
-  {
-    // calculate centroid - sum values from all input points, that have the same idx value in index_vector array
-	unsigned int first_index = first_and_last_indices_vector[cp].first;
-	unsigned int last_index = first_and_last_indices_vector[cp].second;
-    if (!downsample_all_data_) 
-    {
-      centroid[0] = input_-&gt;points[index_vector[first_index].cloud_point_index].x;
-      centroid[1] = input_-&gt;points[index_vector[first_index].cloud_point_index].y;
-      centroid[2] = input_-&gt;points[index_vector[first_index].cloud_point_index].z;
-    }
-    else 
-    {
-      // ---[ RGB special case
-      if (rgba_index &gt;= 0)
-      {
-        // Fill r/g/b data, assuming that the order is BGRA
-        pcl::RGB rgb;
-        memcpy (&amp;rgb, reinterpret_cast&lt;const char*&gt; (&amp;input_-&gt;points[index_vector[first_index].cloud_point_index]) + rgba_index, sizeof (RGB));
-        centroid[centroid_size-3] = rgb.r;
-        centroid[centroid_size-2] = rgb.g;
-        centroid[centroid_size-1] = rgb.b;
-      }
-      pcl::for_each_type &lt;FieldList&gt; (NdCopyPointEigenFunctor &lt;PointT&gt; (input_-&gt;points[index_vector[first_index].cloud_point_index], centroid));
-    }
-
-    for (unsigned int i = first_index + 1; i &lt; last_index; ++i) 
-    {
-      if (!downsample_all_data_) 
-      {
-        centroid[0] += input_-&gt;points[index_vector[i].cloud_point_index].x;
-        centroid[1] += input_-&gt;points[index_vector[i].cloud_point_index].y;
-        centroid[2] += input_-&gt;points[index_vector[i].cloud_point_index].z;
-      }
-      else 
-      {
-        // ---[ RGB special case
-        if (rgba_index &gt;= 0)
-        {
-          // Fill r/g/b data, assuming that the order is BGRA
-          pcl::RGB rgb;
-          memcpy (&amp;rgb, reinterpret_cast&lt;const char*&gt; (&amp;input_-&gt;points[index_vector[i].cloud_point_index]) + rgba_index, sizeof (RGB));
-          temporary[centroid_size-3] = rgb.r;
-          temporary[centroid_size-2] = rgb.g;
-          temporary[centroid_size-1] = rgb.b;
-        }
-        pcl::for_each_type &lt;FieldList&gt; (NdCopyPointEigenFunctor &lt;PointT&gt; (input_-&gt;points[index_vector[i].cloud_point_index], temporary));
-        centroid += temporary;
-      }
-    }
-
-    // index is centroid final position in resulting PointCloud
-    if (save_leaf_layout_)
-      leaf_layout_[index_vector[first_index].idx] = index;
-
-    centroid /= static_cast&lt;float&gt; (last_index - first_index);
-
-    // store centroid
-    // Do we need to process all the fields?
-    if (!downsample_all_data_) 
-    {
-      output.points[index].x = centroid[0];
-      output.points[index].y = centroid[1];
-      output.points[index].z = centroid[2];
-    }
-    else 
-    {
-      pcl::for_each_type&lt;FieldList&gt; (pcl::NdCopyEigenPointFunctor &lt;PointT&gt; (centroid, output.points[index]));
-      // ---[ RGB special case
-      if (rgba_index &gt;= 0) 
-      {
-        // pack r/g/b into rgb
-        float r = centroid[centroid_size-3], g = centroid[centroid_size-2], b = centroid[centroid_size-1];
-        int rgb = (static_cast&lt;int&gt; (r) &lt;&lt; 16) | (static_cast&lt;int&gt; (g) &lt;&lt; 8) | static_cast&lt;int&gt; (b);
-        memcpy (reinterpret_cast&lt;char*&gt; (&amp;output.points[index]) + rgba_index, &amp;rgb, sizeof (float));
-      }
-    }
-    ++index;
-  }
-  output.width = static_cast&lt;uint32_t&gt; (output.points.size ());
-}
-
-#define PCL_INSTANTIATE_VoxelGrid(T) template class PCL_EXPORTS pcl::VoxelGrid&lt;T&gt;;
-#define PCL_INSTANTIATE_getMinMax3D(T) template PCL_EXPORTS void pcl::getMinMax3D&lt;T&gt; (const pcl::PointCloud&lt;T&gt;::ConstPtr &amp;, const std::string &amp;, float, float, Eigen::Vector4f &amp;, Eigen::Vector4f &amp;, bool);
-
-#endif    // FAST_PCL_FILTERS_IMPL_VOXEL_GRID_H_
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\filters\include\fast_pcl\filters\impl\voxel_grid_covariance.hpp" new_path="" added_lines="0" deleted_lines="449">
				<diff>@@ -1,449 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef FAST_PCL_VOXEL_GRID_COVARIANCE_IMPL_H_
-#define FAST_PCL_VOXEL_GRID_COVARIANCE_IMPL_H_
-
-#include &lt;pcl/common/common.h&gt;
-//#include &lt;pcl/filters/boost.h&gt;
-//#include &lt;pcl/filters/voxel_grid_covariance.h&gt;
-#include "fast_pcl/filters/boost.h"
-#include "fast_pcl/filters/voxel_grid_covariance.h"
-#include &lt;Eigen/Dense&gt;
-#include &lt;Eigen/Cholesky&gt;
-
-//////////////////////////////////////////////////////////////////////////////////////////
-template&lt;typename PointT&gt; void
-pcl::VoxelGridCovariance&lt;PointT&gt;::applyFilter (PointCloud &amp;output)
-{
-  voxel_centroids_leaf_indices_.clear ();
-
-  // Has the input dataset been set already?
-  if (!input_)
-  {
-    PCL_WARN ("[pcl::%s::applyFilter] No input dataset given!\n", getClassName ().c_str ());
-    output.width = output.height = 0;
-    output.points.clear ();
-    return;
-  }
-
-  // Copy the header (and thus the frame_id) + allocate enough space for points
-  output.height = 1;                          // downsampling breaks the organized structure
-  output.is_dense = true;                     // we filter out invalid points
-  output.points.clear ();
-
-  Eigen::Vector4f min_p, max_p;
-  // Get the minimum and maximum dimensions
-  if (!filter_field_name_.empty ()) // If we don't want to process the entire cloud...
-    getMinMax3D&lt;PointT&gt; (input_, filter_field_name_, static_cast&lt;float&gt; (filter_limit_min_), static_cast&lt;float&gt; (filter_limit_max_), min_p, max_p, filter_limit_negative_);
-  else
-    getMinMax3D&lt;PointT&gt; (*input_, min_p, max_p);
-
-  // Check that the leaf size is not too small, given the size of the data
-  int64_t dx = static_cast&lt;int64_t&gt;((max_p[0] - min_p[0]) * inverse_leaf_size_[0])+1;
-  int64_t dy = static_cast&lt;int64_t&gt;((max_p[1] - min_p[1]) * inverse_leaf_size_[1])+1;
-  int64_t dz = static_cast&lt;int64_t&gt;((max_p[2] - min_p[2]) * inverse_leaf_size_[2])+1;
-
-  if((dx*dy*dz) &gt; std::numeric_limits&lt;int32_t&gt;::max())
-  {
-    PCL_WARN("[pcl::%s::applyFilter] Leaf size is too small for the input dataset. Integer indices would overflow.", getClassName().c_str());
-    output.clear();
-    return;
-  }
-
-  // Compute the minimum and maximum bounding box values
-  min_b_[0] = static_cast&lt;int&gt; (floor (min_p[0] * inverse_leaf_size_[0]));
-  max_b_[0] = static_cast&lt;int&gt; (floor (max_p[0] * inverse_leaf_size_[0]));
-  min_b_[1] = static_cast&lt;int&gt; (floor (min_p[1] * inverse_leaf_size_[1]));
-  max_b_[1] = static_cast&lt;int&gt; (floor (max_p[1] * inverse_leaf_size_[1]));
-  min_b_[2] = static_cast&lt;int&gt; (floor (min_p[2] * inverse_leaf_size_[2]));
-  max_b_[2] = static_cast&lt;int&gt; (floor (max_p[2] * inverse_leaf_size_[2]));
-
-  // Compute the number of divisions needed along all axis
-  div_b_ = max_b_ - min_b_ + Eigen::Vector4i::Ones ();
-  div_b_[3] = 0;
-
-  // Clear the leaves
-  leaves_.clear ();
-
-  // Set up the division multiplier
-  divb_mul_ = Eigen::Vector4i (1, div_b_[0], div_b_[0] * div_b_[1], 0);
-
-  int centroid_size = 4;
-
-  if (downsample_all_data_)
-    centroid_size = boost::mpl::size&lt;FieldList&gt;::value;
-
-  // ---[ RGB special case
-  std::vector&lt;pcl::PCLPointField&gt; fields;
-  int rgba_index = -1;
-  rgba_index = pcl::getFieldIndex (*input_, "rgb", fields);
-  if (rgba_index == -1)
-    rgba_index = pcl::getFieldIndex (*input_, "rgba", fields);
-  if (rgba_index &gt;= 0)
-  {
-    rgba_index = fields[rgba_index].offset;
-    centroid_size += 3;
-  }
-
-  // If we don't want to process the entire cloud, but rather filter points far away from the viewpoint first...
-  if (!filter_field_name_.empty ())
-  {
-    // Get the distance field index
-    std::vector&lt;pcl::PCLPointField&gt; fields;
-    int distance_idx = pcl::getFieldIndex (*input_, filter_field_name_, fields);
-    if (distance_idx == -1)
-      PCL_WARN ("[pcl::%s::applyFilter] Invalid filter field name. Index is %d.\n", getClassName ().c_str (), distance_idx);
-
-    // First pass: go over all points and insert them into the right leaf
-    for (size_t cp = 0; cp &lt; input_-&gt;points.size (); ++cp)
-    {
-      if (!input_-&gt;is_dense)
-        // Check if the point is invalid
-        if (!pcl_isfinite (input_-&gt;points[cp].x) ||
-            !pcl_isfinite (input_-&gt;points[cp].y) ||
-            !pcl_isfinite (input_-&gt;points[cp].z))
-          continue;
-
-      // Get the distance value
-      const uint8_t* pt_data = reinterpret_cast&lt;const uint8_t*&gt; (&amp;input_-&gt;points[cp]);
-      float distance_value = 0;
-      memcpy (&amp;distance_value, pt_data + fields[distance_idx].offset, sizeof (float));
-
-      if (filter_limit_negative_)
-      {
-        // Use a threshold for cutting out points which inside the interval
-        if ((distance_value &lt; filter_limit_max_) &amp;&amp; (distance_value &gt; filter_limit_min_))
-          continue;
-      }
-      else
-      {
-        // Use a threshold for cutting out points which are too close/far away
-        if ((distance_value &gt; filter_limit_max_) || (distance_value &lt; filter_limit_min_))
-          continue;
-      }
-
-      int ijk0 = static_cast&lt;int&gt; (floor (input_-&gt;points[cp].x * inverse_leaf_size_[0]) - static_cast&lt;float&gt; (min_b_[0]));
-      int ijk1 = static_cast&lt;int&gt; (floor (input_-&gt;points[cp].y * inverse_leaf_size_[1]) - static_cast&lt;float&gt; (min_b_[1]));
-      int ijk2 = static_cast&lt;int&gt; (floor (input_-&gt;points[cp].z * inverse_leaf_size_[2]) - static_cast&lt;float&gt; (min_b_[2]));
-
-      // Compute the centroid leaf index
-      int idx = ijk0 * divb_mul_[0] + ijk1 * divb_mul_[1] + ijk2 * divb_mul_[2];
-
-      Leaf&amp; leaf = leaves_[idx];
-      if (leaf.nr_points == 0)
-      {
-        leaf.centroid.resize (centroid_size);
-        leaf.centroid.setZero ();
-      }
-
-      Eigen::Vector3d pt3d (input_-&gt;points[cp].x, input_-&gt;points[cp].y, input_-&gt;points[cp].z);
-      // Accumulate point sum for centroid calculation
-      leaf.mean_ += pt3d;
-      // Accumulate x*xT for single pass covariance calculation
-      leaf.cov_ += pt3d * pt3d.transpose ();
-
-      // Do we need to process all the fields?
-      if (!downsample_all_data_)
-      {
-        Eigen::Vector4f pt (input_-&gt;points[cp].x, input_-&gt;points[cp].y, input_-&gt;points[cp].z, 0);
-        leaf.centroid.template head&lt;4&gt; () += pt;
-      }
-      else
-      {
-        // Copy all the fields
-        Eigen::VectorXf centroid = Eigen::VectorXf::Zero (centroid_size);
-        // ---[ RGB special case
-        if (rgba_index &gt;= 0)
-        {
-          // fill r/g/b data
-          int rgb;
-          memcpy (&amp;rgb, reinterpret_cast&lt;const char*&gt; (&amp;input_-&gt;points[cp]) + rgba_index, sizeof (int));
-          centroid[centroid_size - 3] = static_cast&lt;float&gt; ((rgb &gt;&gt; 16) &amp; 0x0000ff);
-          centroid[centroid_size - 2] = static_cast&lt;float&gt; ((rgb &gt;&gt; 8) &amp; 0x0000ff);
-          centroid[centroid_size - 1] = static_cast&lt;float&gt; ((rgb) &amp; 0x0000ff);
-        }
-        pcl::for_each_type&lt;FieldList&gt; (NdCopyPointEigenFunctor&lt;PointT&gt; (input_-&gt;points[cp], centroid));
-        leaf.centroid += centroid;
-      }
-      ++leaf.nr_points;
-    }
-  }
-  // No distance filtering, process all data
-  else
-  {
-    // First pass: go over all points and insert them into the right leaf
-    for (size_t cp = 0; cp &lt; input_-&gt;points.size (); ++cp)
-    {
-      if (!input_-&gt;is_dense)
-        // Check if the point is invalid
-        if (!pcl_isfinite (input_-&gt;points[cp].x) ||
-            !pcl_isfinite (input_-&gt;points[cp].y) ||
-            !pcl_isfinite (input_-&gt;points[cp].z))
-          continue;
-
-      int ijk0 = static_cast&lt;int&gt; (floor (input_-&gt;points[cp].x * inverse_leaf_size_[0]) - static_cast&lt;float&gt; (min_b_[0]));
-      int ijk1 = static_cast&lt;int&gt; (floor (input_-&gt;points[cp].y * inverse_leaf_size_[1]) - static_cast&lt;float&gt; (min_b_[1]));
-      int ijk2 = static_cast&lt;int&gt; (floor (input_-&gt;points[cp].z * inverse_leaf_size_[2]) - static_cast&lt;float&gt; (min_b_[2]));
-
-      // Compute the centroid leaf index
-      int idx = ijk0 * divb_mul_[0] + ijk1 * divb_mul_[1] + ijk2 * divb_mul_[2];
-
-      //int idx = (((input_-&gt;points[cp].getArray4fmap () * inverse_leaf_size_).template cast&lt;int&gt; ()).matrix () - min_b_).dot (divb_mul_);
-      Leaf&amp; leaf = leaves_[idx];
-      if (leaf.nr_points == 0)
-      {
-        leaf.centroid.resize (centroid_size);
-        leaf.centroid.setZero ();
-      }
-
-      Eigen::Vector3d pt3d (input_-&gt;points[cp].x, input_-&gt;points[cp].y, input_-&gt;points[cp].z);
-      // Accumulate point sum for centroid calculation
-      leaf.mean_ += pt3d;
-      // Accumulate x*xT for single pass covariance calculation
-      leaf.cov_ += pt3d * pt3d.transpose ();
-
-      // Do we need to process all the fields?
-      if (!downsample_all_data_)
-      {
-        Eigen::Vector4f pt (input_-&gt;points[cp].x, input_-&gt;points[cp].y, input_-&gt;points[cp].z, 0);
-        leaf.centroid.template head&lt;4&gt; () += pt;
-      }
-      else
-      {
-        // Copy all the fields
-        Eigen::VectorXf centroid = Eigen::VectorXf::Zero (centroid_size);
-        // ---[ RGB special case
-        if (rgba_index &gt;= 0)
-        {
-          // Fill r/g/b data, assuming that the order is BGRA
-          int rgb;
-          memcpy (&amp;rgb, reinterpret_cast&lt;const char*&gt; (&amp;input_-&gt;points[cp]) + rgba_index, sizeof (int));
-          centroid[centroid_size - 3] = static_cast&lt;float&gt; ((rgb &gt;&gt; 16) &amp; 0x0000ff);
-          centroid[centroid_size - 2] = static_cast&lt;float&gt; ((rgb &gt;&gt; 8) &amp; 0x0000ff);
-          centroid[centroid_size - 1] = static_cast&lt;float&gt; ((rgb) &amp; 0x0000ff);
-        }
-        pcl::for_each_type&lt;FieldList&gt; (NdCopyPointEigenFunctor&lt;PointT&gt; (input_-&gt;points[cp], centroid));
-        leaf.centroid += centroid;
-      }
-      ++leaf.nr_points;
-    }
-  }
-
-  // Second pass: go over all leaves and compute centroids and covariance matrices
-  output.points.reserve (leaves_.size ());
-  if (searchable_)
-    voxel_centroids_leaf_indices_.reserve (leaves_.size ());
-  int cp = 0;
-  if (save_leaf_layout_)
-    leaf_layout_.resize (div_b_[0] * div_b_[1] * div_b_[2], -1);
-
-  // Eigen values and vectors calculated to prevent near singluar matrices
-  Eigen::SelfAdjointEigenSolver&lt;Eigen::Matrix3d&gt; eigensolver;
-  Eigen::Matrix3d eigen_val;
-  Eigen::Vector3d pt_sum;
-
-  // Eigen values less than a threshold of max eigen value are inflated to a set fraction of the max eigen value.
-  double min_covar_eigvalue;
-
-  for (typename std::map&lt;size_t, Leaf&gt;::iterator it = leaves_.begin (); it != leaves_.end (); ++it)
-  {
-
-    // Normalize the centroid
-    Leaf&amp; leaf = it-&gt;second;
-
-    // Normalize the centroid
-    leaf.centroid /= static_cast&lt;float&gt; (leaf.nr_points);
-    // Point sum used for single pass covariance calculation
-    pt_sum = leaf.mean_;
-    // Normalize mean
-    leaf.mean_ /= leaf.nr_points;
-
-    // If the voxel contains sufficient points, its covariance is calculated and is added to the voxel centroids and output clouds.
-    // Points with less than the minimum points will have a can not be accuratly approximated using a normal distribution.
-    if (leaf.nr_points &gt;= min_points_per_voxel_)
-    {
-      if (save_leaf_layout_)
-        leaf_layout_[it-&gt;first] = cp++;
-
-      output.push_back (PointT ());
-
-      // Do we need to process all the fields?
-      if (!downsample_all_data_)
-      {
-        output.points.back ().x = leaf.centroid[0];
-        output.points.back ().y = leaf.centroid[1];
-        output.points.back ().z = leaf.centroid[2];
-      }
-      else
-      {
-        pcl::for_each_type&lt;FieldList&gt; (pcl::NdCopyEigenPointFunctor&lt;PointT&gt; (leaf.centroid, output.back ()));
-        // ---[ RGB special case
-        if (rgba_index &gt;= 0)
-        {
-          // pack r/g/b into rgb
-          float r = leaf.centroid[centroid_size - 3], g = leaf.centroid[centroid_size - 2], b = leaf.centroid[centroid_size - 1];
-          int rgb = (static_cast&lt;int&gt; (r)) &lt;&lt; 16 | (static_cast&lt;int&gt; (g)) &lt;&lt; 8 | (static_cast&lt;int&gt; (b));
-          memcpy (reinterpret_cast&lt;char*&gt; (&amp;output.points.back ()) + rgba_index, &amp;rgb, sizeof (float));
-        }
-      }
-
-      // Stores the voxel indice for fast access searching
-      if (searchable_)
-        voxel_centroids_leaf_indices_.push_back (static_cast&lt;int&gt; (it-&gt;first));
-
-      // Single pass covariance calculation
-      leaf.cov_ = (leaf.cov_ - 2 * (pt_sum * leaf.mean_.transpose ())) / leaf.nr_points + leaf.mean_ * leaf.mean_.transpose ();
-      leaf.cov_ *= (leaf.nr_points - 1.0) / leaf.nr_points;
-
-      //Normalize Eigen Val such that max no more than 100x min.
-      eigensolver.compute (leaf.cov_);
-      eigen_val = eigensolver.eigenvalues ().asDiagonal ();
-      leaf.evecs_ = eigensolver.eigenvectors ();
-
-      if (eigen_val (0, 0) &lt; 0 || eigen_val (1, 1) &lt; 0 || eigen_val (2, 2) &lt;= 0)
-      {
-        leaf.nr_points = -1;
-        continue;
-      }
-
-      // Avoids matrices near singularities (eq 6.11)[Magnusson 2009]
-
-      min_covar_eigvalue = min_covar_eigvalue_mult_ * eigen_val (2, 2);
-      if (eigen_val (0, 0) &lt; min_covar_eigvalue)
-      {
-        eigen_val (0, 0) = min_covar_eigvalue;
-
-        if (eigen_val (1, 1) &lt; min_covar_eigvalue)
-        {
-          eigen_val (1, 1) = min_covar_eigvalue;
-        }
-
-        leaf.cov_ = leaf.evecs_ * eigen_val * leaf.evecs_.inverse ();
-      }
-      leaf.evals_ = eigen_val.diagonal ();
-
-      leaf.icov_ = leaf.cov_.inverse ();
-      if (leaf.icov_.maxCoeff () == std::numeric_limits&lt;float&gt;::infinity ( )
-          || leaf.icov_.minCoeff () == -std::numeric_limits&lt;float&gt;::infinity ( ) )
-      {
-        leaf.nr_points = -1;
-      }
-
-    }
-  }
-
-  output.width = static_cast&lt;uint32_t&gt; (output.points.size ());
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////
-template&lt;typename PointT&gt; int
-pcl::VoxelGridCovariance&lt;PointT&gt;::getNeighborhoodAtPoint (const PointT&amp; reference_point, std::vector&lt;LeafConstPtr&gt; &amp;neighbors)
-{
-  neighbors.clear ();
-
-  // Find displacement coordinates
-  Eigen::MatrixXi relative_coordinates = pcl::getAllNeighborCellIndices ();
-  Eigen::Vector4i ijk (static_cast&lt;int&gt; (floor (reference_point.x / leaf_size_[0])), 
-                       static_cast&lt;int&gt; (floor (reference_point.y / leaf_size_[1])), 
-                       static_cast&lt;int&gt; (floor (reference_point.z / leaf_size_[2])), 0);
-  Eigen::Array4i diff2min = min_b_ - ijk;
-  Eigen::Array4i diff2max = max_b_ - ijk;
-  neighbors.reserve (relative_coordinates.cols ());
-
-  // Check each neighbor to see if it is occupied and contains sufficient points
-  // Slower than radius search because needs to check 26 indices
-  for (int ni = 0; ni &lt; relative_coordinates.cols (); ni++)
-  {
-    Eigen::Vector4i displacement = (Eigen::Vector4i () &lt;&lt; relative_coordinates.col (ni), 0).finished ();
-    // Checking if the specified cell is in the grid
-    if ((diff2min &lt;= displacement.array ()).all () &amp;&amp; (diff2max &gt;= displacement.array ()).all ())
-    {
-      typename std::map&lt;size_t, Leaf&gt;::iterator leaf_iter = leaves_.find (((ijk + displacement - min_b_).dot (divb_mul_)));
-      if (leaf_iter != leaves_.end () &amp;&amp; leaf_iter-&gt;second.nr_points &gt;= min_points_per_voxel_)
-      {
-        LeafConstPtr leaf = &amp;(leaf_iter-&gt;second);
-        neighbors.push_back (leaf);
-      }
-    }
-  }
-
-  return (static_cast&lt;int&gt; (neighbors.size ()));
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////
-template&lt;typename PointT&gt; void
-pcl::VoxelGridCovariance&lt;PointT&gt;::getDisplayCloud (pcl::PointCloud&lt;PointXYZ&gt;&amp; cell_cloud)
-{
-  cell_cloud.clear ();
-
-  int pnt_per_cell = 1000;
-  boost::mt19937 rng;
-  boost::normal_distribution&lt;&gt; nd (0.0, leaf_size_.head (3).norm ());
-  boost::variate_generator&lt;boost::mt19937&amp;, boost::normal_distribution&lt;&gt; &gt; var_nor (rng, nd);
-
-  Eigen::LLT&lt;Eigen::Matrix3d&gt; llt_of_cov;
-  Eigen::Matrix3d cholesky_decomp;
-  Eigen::Vector3d cell_mean;
-  Eigen::Vector3d rand_point;
-  Eigen::Vector3d dist_point;
-
-  // Generate points for each occupied voxel with sufficient points.
-  for (typename std::map&lt;size_t, Leaf&gt;::iterator it = leaves_.begin (); it != leaves_.end (); ++it)
-  {
-    Leaf&amp; leaf = it-&gt;second;
-
-    if (leaf.nr_points &gt;= min_points_per_voxel_)
-    {
-      cell_mean = leaf.mean_;
-      llt_of_cov.compute (leaf.cov_);
-      cholesky_decomp = llt_of_cov.matrixL ();
-
-      // Random points generated by sampling the normal distribution given by voxel mean and covariance matrix
-      for (int i = 0; i &lt; pnt_per_cell; i++)
-      {
-        rand_point = Eigen::Vector3d (var_nor (), var_nor (), var_nor ());
-        dist_point = cell_mean + cholesky_decomp * rand_point;
-        cell_cloud.push_back (PointXYZ (static_cast&lt;float&gt; (dist_point (0)), static_cast&lt;float&gt; (dist_point (1)), static_cast&lt;float&gt; (dist_point (2))));
-      }
-    }
-  }
-}
-
-#define PCL_INSTANTIATE_VoxelGridCovariance(T) template class PCL_EXPORTS pcl::VoxelGridCovariance&lt;T&gt;;
-
-#endif    // FAST_PCL_VOXEL_GRID_COVARIANCE_IMPL_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\filters\include\fast_pcl\filters\voxel_grid.h" new_path="" added_lines="0" deleted_lines="859">
				<diff>@@ -1,859 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#ifndef FAST_PCL_FILTERS_VOXEL_GRID_MAP_H_
-#define FAST_PCL_FILTERS_VOXEL_GRID_MAP_H_
-
-//#include &lt;pcl/filters/boost.h&gt;
-//#include &lt;pcl/filters/filter.h&gt;
-#include "fast_pcl/filters/boost.h"
-#include "fast_pcl/filters/filter.h"
-#include &lt;map&gt;
-
-namespace pcl
-{
-  /** \brief Obtain the maximum and minimum points in 3D from a given point cloud.
-    * \param[in] cloud the pointer to a pcl::PCLPointCloud2 dataset
-    * \param[in] x_idx the index of the X channel
-    * \param[in] y_idx the index of the Y channel
-    * \param[in] z_idx the index of the Z channel
-    * \param[out] min_pt the minimum data point 
-    * \param[out] max_pt the maximum data point
-    */
-  PCL_EXPORTS void 
-  getMinMax3D (const pcl::PCLPointCloud2ConstPtr &amp;cloud, int x_idx, int y_idx, int z_idx,
-               Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt);
-
-  /** \brief Obtain the maximum and minimum points in 3D from a given point cloud. 
-    * \note Performs internal data filtering as well.
-    * \param[in] cloud the pointer to a pcl::PCLPointCloud2 dataset
-    * \param[in] x_idx the index of the X channel
-    * \param[in] y_idx the index of the Y channel
-    * \param[in] z_idx the index of the Z channel
-    * \param[in] distance_field_name the name of the dimension to filter data along to
-    * \param[in] min_distance the minimum acceptable value in \a distance_field_name data
-    * \param[in] max_distance the maximum acceptable value in \a distance_field_name data
-    * \param[out] min_pt the minimum data point 
-    * \param[out] max_pt the maximum data point
-    * \param[in] limit_negative \b false if data \b inside of the [min_distance; max_distance] interval should be
-    * considered, \b true otherwise.
-    */
-  PCL_EXPORTS void 
-  getMinMax3D (const pcl::PCLPointCloud2ConstPtr &amp;cloud, int x_idx, int y_idx, int z_idx,
-               const std::string &amp;distance_field_name, float min_distance, float max_distance, 
-               Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt, bool limit_negative = false);
-
-  /** \brief Get the relative cell indices of the "upper half" 13 neighbors.
-    * \note Useful in combination with getNeighborCentroidIndices() from \ref VoxelGrid
-    * \ingroup filters
-    */
-  inline Eigen::MatrixXi
-  getHalfNeighborCellIndices ()
-  {
-    Eigen::MatrixXi relative_coordinates (3, 13);
-    int idx = 0;
-
-    // 0 - 8
-    for (int i = -1; i &lt; 2; i++) 
-    {
-      for (int j = -1; j &lt; 2; j++) 
-      {
-        relative_coordinates (0, idx) = i;
-        relative_coordinates (1, idx) = j;
-        relative_coordinates (2, idx) = -1;
-        idx++;
-      }
-    }
-    // 9 - 11
-    for (int i = -1; i &lt; 2; i++) 
-    {
-      relative_coordinates (0, idx) = i;
-      relative_coordinates (1, idx) = -1;
-      relative_coordinates (2, idx) = 0;
-      idx++;
-    }
-    // 12
-    relative_coordinates (0, idx) = -1;
-    relative_coordinates (1, idx) = 0;
-    relative_coordinates (2, idx) = 0;
-
-    return (relative_coordinates);
-  }
-
-  /** \brief Get the relative cell indices of all the 26 neighbors.
-    * \note Useful in combination with getNeighborCentroidIndices() from \ref VoxelGrid
-    * \ingroup filters
-    */
-  inline Eigen::MatrixXi
-  getAllNeighborCellIndices ()
-  {
-    Eigen::MatrixXi relative_coordinates = getHalfNeighborCellIndices ();
-    Eigen::MatrixXi relative_coordinates_all( 3, 26);
-    relative_coordinates_all.block&lt;3, 13&gt; (0, 0) = relative_coordinates;
-    relative_coordinates_all.block&lt;3, 13&gt; (0, 13) = -relative_coordinates;
-    return (relative_coordinates_all);
-  }
-
-  /** \brief Get the minimum and maximum values on each of the 3 (x-y-z) dimensions
-    * in a given pointcloud, without considering points outside of a distance threshold from the laser origin
-    * \param[in] cloud the point cloud data message
-    * \param[in] distance_field_name the field name that contains the distance values
-    * \param[in] min_distance the minimum distance a point will be considered from
-    * \param[in] max_distance the maximum distance a point will be considered to
-    * \param[out] min_pt the resultant minimum bounds
-    * \param[out] max_pt the resultant maximum bounds
-    * \param[in] limit_negative if set to true, then all points outside of the interval (min_distance;max_distace) are considered
-    * \ingroup filters
-    */
-  template &lt;typename PointT&gt; void 
-  getMinMax3D (const typename pcl::PointCloud&lt;PointT&gt;::ConstPtr &amp;cloud, 
-               const std::string &amp;distance_field_name, float min_distance, float max_distance,
-               Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt, bool limit_negative = false);
-
-  /** \brief Get the minimum and maximum values on each of the 3 (x-y-z) dimensions
-    * in a given pointcloud, without considering points outside of a distance threshold from the laser origin
-    * \param[in] cloud the point cloud data message
-    * \param[in] indices the vector of indices to use
-    * \param[in] distance_field_name the field name that contains the distance values
-    * \param[in] min_distance the minimum distance a point will be considered from
-    * \param[in] max_distance the maximum distance a point will be considered to
-    * \param[out] min_pt the resultant minimum bounds
-    * \param[out] max_pt the resultant maximum bounds
-    * \param[in] limit_negative if set to true, then all points outside of the interval (min_distance;max_distace) are considered
-    * \ingroup filters
-    */
-  template &lt;typename PointT&gt; void 
-  getMinMax3D (const typename pcl::PointCloud&lt;PointT&gt;::ConstPtr &amp;cloud, 
-               const std::vector&lt;int&gt; &amp;indices,
-               const std::string &amp;distance_field_name, float min_distance, float max_distance,
-               Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt, bool limit_negative = false);
-
-  /** \brief VoxelGrid assembles a local 3D grid over a given PointCloud, and downsamples + filters the data.
-    *
-    * The VoxelGrid class creates a *3D voxel grid* (think about a voxel
-    * grid as a set of tiny 3D boxes in space) over the input point cloud data.
-    * Then, in each *voxel* (i.e., 3D box), all the points present will be
-    * approximated (i.e., *downsampled*) with their centroid. This approach is
-    * a bit slower than approximating them with the center of the voxel, but it
-    * represents the underlying surface more accurately.
-    *
-    * \author Radu B. Rusu, Bastian Steder
-    * \ingroup filters
-    */
-  template &lt;typename PointT&gt;
-  class VoxelGrid: public Filter&lt;PointT&gt;
-  {
-    protected:
-      using Filter&lt;PointT&gt;::filter_name_;
-      using Filter&lt;PointT&gt;::getClassName;
-      using Filter&lt;PointT&gt;::input_;
-      using Filter&lt;PointT&gt;::indices_;
-
-      typedef typename Filter&lt;PointT&gt;::PointCloud PointCloud;
-      typedef typename PointCloud::Ptr PointCloudPtr;
-      typedef typename PointCloud::ConstPtr PointCloudConstPtr;
-      typedef boost::shared_ptr&lt; VoxelGrid&lt;PointT&gt; &gt; Ptr;
-      typedef boost::shared_ptr&lt; const VoxelGrid&lt;PointT&gt; &gt; ConstPtr;
- 
-
-    public:
-      /** \brief Empty constructor. */
-      VoxelGrid () : 
-        leaf_size_ (Eigen::Vector4f::Zero ()),
-        inverse_leaf_size_ (Eigen::Array4f::Zero ()),
-        downsample_all_data_ (true), 
-        save_leaf_layout_ (false),
-        leaf_layout_ (),
-        min_b_ (Eigen::Vector4i::Zero ()),
-        max_b_ (Eigen::Vector4i::Zero ()),
-        div_b_ (Eigen::Vector4i::Zero ()),
-        divb_mul_ (Eigen::Vector4i::Zero ()),
-        filter_field_name_ (""), 
-        filter_limit_min_ (-FLT_MAX), 
-        filter_limit_max_ (FLT_MAX),
-        filter_limit_negative_ (false),
-        min_points_per_voxel_ (0)
-      {
-        filter_name_ = "VoxelGrid";
-      }
-
-      /** \brief Destructor. */
-      virtual ~VoxelGrid ()
-      {
-      }
-
-      /** \brief Set the voxel grid leaf size.
-        * \param[in] leaf_size the voxel grid leaf size
-        */
-      inline void 
-      setLeafSize (const Eigen::Vector4f &amp;leaf_size) 
-      { 
-        leaf_size_ = leaf_size; 
-        // Avoid division errors
-        if (leaf_size_[3] == 0)
-          leaf_size_[3] = 1;
-        // Use multiplications instead of divisions
-        inverse_leaf_size_ = Eigen::Array4f::Ones () / leaf_size_.array ();
-      }
-
-      /** \brief Set the voxel grid leaf size.
-        * \param[in] lx the leaf size for X
-        * \param[in] ly the leaf size for Y
-        * \param[in] lz the leaf size for Z
-        */
-      inline void
-      setLeafSize (float lx, float ly, float lz)
-      {
-        leaf_size_[0] = lx; leaf_size_[1] = ly; leaf_size_[2] = lz;
-        // Avoid division errors
-        if (leaf_size_[3] == 0)
-          leaf_size_[3] = 1;
-        // Use multiplications instead of divisions
-        inverse_leaf_size_ = Eigen::Array4f::Ones () / leaf_size_.array ();
-      }
-
-      /** \brief Get the voxel grid leaf size. */
-      inline Eigen::Vector3f 
-      getLeafSize () { return (leaf_size_.head&lt;3&gt; ()); }
-
-      /** \brief Set to true if all fields need to be downsampled, or false if just XYZ.
-        * \param[in] downsample the new value (true/false)
-        */
-      inline void 
-      setDownsampleAllData (bool downsample) { downsample_all_data_ = downsample; }
-
-      /** \brief Get the state of the internal downsampling parameter (true if
-        * all fields need to be downsampled, false if just XYZ). 
-        */
-      inline bool 
-      getDownsampleAllData () { return (downsample_all_data_); }
-
-      /** \brief Set the minimum number of points required for a voxel to be used.
-        * \param[in] min_points_per_voxel the minimum number of points for required for a voxel to be used
-        */
-      inline void 
-      setMinimumPointsNumberPerVoxel (unsigned int min_points_per_voxel) { min_points_per_voxel_ = min_points_per_voxel; }
-
-      /** \brief Return the minimum number of points required for a voxel to be used.
-       */
-      inline unsigned int
-      getMinimumPointsNumberPerVoxel () { return min_points_per_voxel_; }
-
-      /** \brief Set to true if leaf layout information needs to be saved for later access.
-        * \param[in] save_leaf_layout the new value (true/false)
-        */
-      inline void 
-      setSaveLeafLayout (bool save_leaf_layout) { save_leaf_layout_ = save_leaf_layout; }
-
-      /** \brief Returns true if leaf layout information will to be saved for later access. */
-      inline bool 
-      getSaveLeafLayout () { return (save_leaf_layout_); }
-
-      /** \brief Get the minimum coordinates of the bounding box (after
-        * filtering is performed). 
-        */
-      inline Eigen::Vector3i 
-      getMinBoxCoordinates () { return (min_b_.head&lt;3&gt; ()); }
-
-      /** \brief Get the minimum coordinates of the bounding box (after
-        * filtering is performed). 
-        */
-      inline Eigen::Vector3i 
-      getMaxBoxCoordinates () { return (max_b_.head&lt;3&gt; ()); }
-
-      /** \brief Get the number of divisions along all 3 axes (after filtering
-        * is performed). 
-        */
-      inline Eigen::Vector3i 
-      getNrDivisions () { return (div_b_.head&lt;3&gt; ()); }
-
-      /** \brief Get the multipliers to be applied to the grid coordinates in
-        * order to find the centroid index (after filtering is performed). 
-        */
-      inline Eigen::Vector3i 
-      getDivisionMultiplier () { return (divb_mul_.head&lt;3&gt; ()); }
-
-      /** \brief Returns the index in the resulting downsampled cloud of the specified point.
-        *
-        * \note for efficiency, user must make sure that the saving of the leaf layout is enabled and filtering 
-        * performed, and that the point is inside the grid, to avoid invalid access (or use
-        * getGridCoordinates+getCentroidIndexAt)
-        *
-        * \param[in] p the point to get the index at
-        */
-      inline int 
-      getCentroidIndex (const PointT &amp;p)
-      {
-        return (leaf_layout_.at ((Eigen::Vector4i (static_cast&lt;int&gt; (floor (p.x * inverse_leaf_size_[0])), 
-                                                   static_cast&lt;int&gt; (floor (p.y * inverse_leaf_size_[1])), 
-                                                   static_cast&lt;int&gt; (floor (p.z * inverse_leaf_size_[2])), 0) - min_b_).dot (divb_mul_)));
-      }
-
-      /** \brief Returns the indices in the resulting downsampled cloud of the points at the specified grid coordinates,
-        * relative to the grid coordinates of the specified point (or -1 if the cell was empty/out of bounds).
-        * \param[in] reference_point the coordinates of the reference point (corresponding cell is allowed to be empty/out of bounds)
-        * \param[in] relative_coordinates matrix with the columns being the coordinates of the requested cells, relative to the reference point's cell
-        * \note for efficiency, user must make sure that the saving of the leaf layout is enabled and filtering performed
-        */
-      inline std::vector&lt;int&gt; 
-      getNeighborCentroidIndices (const PointT &amp;reference_point, const Eigen::MatrixXi &amp;relative_coordinates)
-      {
-        Eigen::Vector4i ijk (static_cast&lt;int&gt; (floor (reference_point.x * inverse_leaf_size_[0])), 
-                             static_cast&lt;int&gt; (floor (reference_point.y * inverse_leaf_size_[1])), 
-                             static_cast&lt;int&gt; (floor (reference_point.z * inverse_leaf_size_[2])), 0);
-        Eigen::Array4i diff2min = min_b_ - ijk;
-        Eigen::Array4i diff2max = max_b_ - ijk;
-        std::vector&lt;int&gt; neighbors (relative_coordinates.cols());
-        for (int ni = 0; ni &lt; relative_coordinates.cols (); ni++)
-        {
-          Eigen::Vector4i displacement = (Eigen::Vector4i() &lt;&lt; relative_coordinates.col(ni), 0).finished();
-          // checking if the specified cell is in the grid
-          if ((diff2min &lt;= displacement.array()).all() &amp;&amp; (diff2max &gt;= displacement.array()).all())
-            neighbors[ni] = leaf_layout_[((ijk + displacement - min_b_).dot (divb_mul_))]; // .at() can be omitted
-          else
-            neighbors[ni] = -1; // cell is out of bounds, consider it empty
-        }
-        return (neighbors);
-      }
-
-      /** \brief Returns the layout of the leafs for fast access to cells relative to current position.
-        * \note position at (i-min_x) + (j-min_y)*div_x + (k-min_z)*div_x*div_y holds the index of the element at coordinates (i,j,k) in the grid (-1 if empty)
-        */
-      inline std::vector&lt;int&gt; 
-      getLeafLayout () { return (leaf_layout_); }
-
-      /** \brief Returns the corresponding (i,j,k) coordinates in the grid of point (x,y,z). 
-        * \param[in] x the X point coordinate to get the (i, j, k) index at
-        * \param[in] y the Y point coordinate to get the (i, j, k) index at
-        * \param[in] z the Z point coordinate to get the (i, j, k) index at
-        */
-      inline Eigen::Vector3i 
-      getGridCoordinates (float x, float y, float z) 
-      { 
-        return (Eigen::Vector3i (static_cast&lt;int&gt; (floor (x * inverse_leaf_size_[0])), 
-                                 static_cast&lt;int&gt; (floor (y * inverse_leaf_size_[1])), 
-                                 static_cast&lt;int&gt; (floor (z * inverse_leaf_size_[2])))); 
-      }
-
-      /** \brief Returns the index in the downsampled cloud corresponding to a given set of coordinates.
-        * \param[in] ijk the coordinates (i,j,k) in the grid (-1 if empty)
-        */
-      inline int 
-      getCentroidIndexAt (const Eigen::Vector3i &amp;ijk)
-      {
-        int idx = ((Eigen::Vector4i() &lt;&lt; ijk, 0).finished() - min_b_).dot (divb_mul_);
-        if (idx &lt; 0 || idx &gt;= static_cast&lt;int&gt; (leaf_layout_.size ())) // this checks also if leaf_layout_.size () == 0 i.e. everything was computed as needed
-        {
-          //if (verbose)
-          //  PCL_ERROR ("[pcl::%s::getCentroidIndexAt] Specified coordinate is outside grid bounds, or leaf layout is not saved, make sure to call setSaveLeafLayout(true) and filter(output) first!\n", getClassName ().c_str ());
-          return (-1);
-        }
-        return (leaf_layout_[idx]);
-      }
-
-      /** \brief Provide the name of the field to be used for filtering data. In conjunction with  \a setFilterLimits,
-        * points having values outside this interval will be discarded.
-        * \param[in] field_name the name of the field that contains values used for filtering
-        */
-      inline void
-      setFilterFieldName (const std::string &amp;field_name)
-      {
-        filter_field_name_ = field_name;
-      }
-
-      /** \brief Get the name of the field used for filtering. */
-      inline std::string const
-      getFilterFieldName ()
-      {
-        return (filter_field_name_);
-      }
-
-      /** \brief Set the field filter limits. All points having field values outside this interval will be discarded.
-        * \param[in] limit_min the minimum allowed field value
-        * \param[in] limit_max the maximum allowed field value
-        */
-      inline void
-      setFilterLimits (const double &amp;limit_min, const double &amp;limit_max)
-      {
-        filter_limit_min_ = limit_min;
-        filter_limit_max_ = limit_max;
-      }
-
-      /** \brief Get the field filter limits (min/max) set by the user. The default values are -FLT_MAX, FLT_MAX. 
-        * \param[out] limit_min the minimum allowed field value
-        * \param[out] limit_max the maximum allowed field value
-        */
-      inline void
-      getFilterLimits (double &amp;limit_min, double &amp;limit_max)
-      {
-        limit_min = filter_limit_min_;
-        limit_max = filter_limit_max_;
-      }
-
-      /** \brief Set to true if we want to return the data outside the interval specified by setFilterLimits (min, max).
-        * Default: false.
-        * \param[in] limit_negative return data inside the interval (false) or outside (true)
-        */
-      inline void
-      setFilterLimitsNegative (const bool limit_negative)
-      {
-        filter_limit_negative_ = limit_negative;
-      }
-
-      /** \brief Get whether the data outside the interval (min/max) is to be returned (true) or inside (false). 
-        * \param[out] limit_negative true if data \b outside the interval [min; max] is to be returned, false otherwise
-        */
-      inline void
-      getFilterLimitsNegative (bool &amp;limit_negative)
-      {
-        limit_negative = filter_limit_negative_;
-      }
-
-      /** \brief Get whether the data outside the interval (min/max) is to be returned (true) or inside (false). 
-        * \return true if data \b outside the interval [min; max] is to be returned, false otherwise
-        */
-      inline bool
-      getFilterLimitsNegative ()
-      {
-        return (filter_limit_negative_);
-      }
-
-    protected:
-      /** \brief The size of a leaf. */
-      Eigen::Vector4f leaf_size_;
-
-      /** \brief Internal leaf sizes stored as 1/leaf_size_ for efficiency reasons. */ 
-      Eigen::Array4f inverse_leaf_size_;
-
-      /** \brief Set to true if all fields need to be downsampled, or false if just XYZ. */
-      bool downsample_all_data_;
-
-      /** \brief Set to true if leaf layout information needs to be saved in \a leaf_layout_. */
-      bool save_leaf_layout_;
-
-      /** \brief The leaf layout information for fast access to cells relative to current position **/
-      std::vector&lt;int&gt; leaf_layout_;
-
-      /** \brief The minimum and maximum bin coordinates, the number of divisions, and the division multiplier. */
-      Eigen::Vector4i min_b_, max_b_, div_b_, divb_mul_;
-
-      /** \brief The desired user filter field name. */
-      std::string filter_field_name_;
-
-      /** \brief The minimum allowed filter value a point will be considered from. */
-      double filter_limit_min_;
-
-      /** \brief The maximum allowed filter value a point will be considered from. */
-      double filter_limit_max_;
-
-      /** \brief Set to true if we want to return the data outside (\a filter_limit_min_;\a filter_limit_max_). Default: false. */
-      bool filter_limit_negative_;
-
-      /** \brief Minimum number of points per voxel for the centroid to be computed */
-      unsigned int min_points_per_voxel_;
-
-      typedef typename pcl::traits::fieldList&lt;PointT&gt;::type FieldList;
-
-      /** \brief Downsample a Point Cloud using a voxelized grid approach
-        * \param[out] output the resultant point cloud message
-        */
-      void 
-      applyFilter (PointCloud &amp;output);
-  };
-
-  /** \brief VoxelGrid assembles a local 3D grid over a given PointCloud, and downsamples + filters the data.
-    *
-    * The VoxelGrid class creates a *3D voxel grid* (think about a voxel
-    * grid as a set of tiny 3D boxes in space) over the input point cloud data.
-    * Then, in each *voxel* (i.e., 3D box), all the points present will be
-    * approximated (i.e., *downsampled*) with their centroid. This approach is
-    * a bit slower than approximating them with the center of the voxel, but it
-    * represents the underlying surface more accurately.
-    *
-    * \author Radu B. Rusu, Bastian Steder, Radoslaw Cybulski
-    * \ingroup filters
-    */
-  template &lt;&gt;
-  class PCL_EXPORTS VoxelGrid&lt;pcl::PCLPointCloud2&gt; : public Filter&lt;pcl::PCLPointCloud2&gt;
-  {
-    using Filter&lt;pcl::PCLPointCloud2&gt;::filter_name_;
-    using Filter&lt;pcl::PCLPointCloud2&gt;::getClassName;
-
-    typedef pcl::PCLPointCloud2 PCLPointCloud2;
-    typedef PCLPointCloud2::Ptr PCLPointCloud2Ptr;
-    typedef PCLPointCloud2::ConstPtr PCLPointCloud2ConstPtr;
-
-    public:
-      /** \brief Empty constructor. */
-      VoxelGrid () : 
-        leaf_size_ (Eigen::Vector4f::Zero ()),
-        inverse_leaf_size_ (Eigen::Array4f::Zero ()),
-        downsample_all_data_ (true), 
-        save_leaf_layout_ (false),
-        leaf_layout_ (),
-        min_b_ (Eigen::Vector4i::Zero ()),
-        max_b_ (Eigen::Vector4i::Zero ()),
-        div_b_ (Eigen::Vector4i::Zero ()),
-        divb_mul_ (Eigen::Vector4i::Zero ()),
-        filter_field_name_ (""), 
-        filter_limit_min_ (-FLT_MAX), 
-        filter_limit_max_ (FLT_MAX),
-        filter_limit_negative_ (false),
-        min_points_per_voxel_ (0)
-      {
-        filter_name_ = "VoxelGrid";
-      }
-
-      /** \brief Destructor. */
-      virtual ~VoxelGrid ()
-      {
-      }
-
-      /** \brief Set the voxel grid leaf size.
-        * \param[in] leaf_size the voxel grid leaf size
-        */
-      inline void 
-      setLeafSize (const Eigen::Vector4f &amp;leaf_size) 
-      { 
-        leaf_size_ = leaf_size; 
-        // Avoid division errors
-        if (leaf_size_[3] == 0)
-          leaf_size_[3] = 1;
-        // Use multiplications instead of divisions
-        inverse_leaf_size_ = Eigen::Array4f::Ones () / leaf_size_.array ();
-      }
-
-      /** \brief Set the voxel grid leaf size.
-        * \param[in] lx the leaf size for X
-        * \param[in] ly the leaf size for Y
-        * \param[in] lz the leaf size for Z
-        */
-      inline void
-      setLeafSize (float lx, float ly, float lz)
-      {
-        leaf_size_[0] = lx; leaf_size_[1] = ly; leaf_size_[2] = lz;
-        // Avoid division errors
-        if (leaf_size_[3] == 0)
-          leaf_size_[3] = 1;
-        // Use multiplications instead of divisions
-        inverse_leaf_size_ = Eigen::Array4f::Ones () / leaf_size_.array ();
-      }
-
-      /** \brief Get the voxel grid leaf size. */
-      inline Eigen::Vector3f 
-      getLeafSize () { return (leaf_size_.head&lt;3&gt; ()); }
-
-      /** \brief Set to true if all fields need to be downsampled, or false if just XYZ.
-        * \param[in] downsample the new value (true/false)
-        */
-      inline void 
-      setDownsampleAllData (bool downsample) { downsample_all_data_ = downsample; }
-
-      /** \brief Get the state of the internal downsampling parameter (true if
-        * all fields need to be downsampled, false if just XYZ). 
-        */
-      inline bool 
-      getDownsampleAllData () { return (downsample_all_data_); }
-
-      /** \brief Set the minimum number of points required for a voxel to be used.
-        * \param[in] min_points_per_voxel the minimum number of points for required for a voxel to be used
-        */
-      inline void 
-      setMinimumPointsNumberPerVoxel (unsigned int min_points_per_voxel) { min_points_per_voxel_ = min_points_per_voxel; }
-
-	  /** \brief Return the minimum number of points required for a voxel to be used.
-       */
-	  inline unsigned int
-	  getMinimumPointsNumberPerVoxel () { return min_points_per_voxel_; }
-
-      /** \brief Set to true if leaf layout information needs to be saved for later access.
-        * \param[in] save_leaf_layout the new value (true/false)
-        */
-      inline void 
-      setSaveLeafLayout (bool save_leaf_layout) { save_leaf_layout_ = save_leaf_layout; }
-
-      /** \brief Returns true if leaf layout information will to be saved for later access. */
-      inline bool 
-      getSaveLeafLayout () { return (save_leaf_layout_); }
-
-      /** \brief Get the minimum coordinates of the bounding box (after
-        * filtering is performed). 
-        */
-      inline Eigen::Vector3i 
-      getMinBoxCoordinates () { return (min_b_.head&lt;3&gt; ()); }
-
-      /** \brief Get the minimum coordinates of the bounding box (after
-        * filtering is performed). 
-        */
-      inline Eigen::Vector3i 
-      getMaxBoxCoordinates () { return (max_b_.head&lt;3&gt; ()); }
-
-      /** \brief Get the number of divisions along all 3 axes (after filtering
-        * is performed). 
-        */
-      inline Eigen::Vector3i 
-      getNrDivisions () { return (div_b_.head&lt;3&gt; ()); }
-
-      /** \brief Get the multipliers to be applied to the grid coordinates in
-        * order to find the centroid index (after filtering is performed). 
-        */
-      inline Eigen::Vector3i 
-      getDivisionMultiplier () { return (divb_mul_.head&lt;3&gt; ()); }
-
-      /** \brief Returns the index in the resulting downsampled cloud of the specified point.
-        * \note for efficiency, user must make sure that the saving of the leaf layout is enabled and filtering performed,
-        * and that the point is inside the grid, to avoid invalid access (or use getGridCoordinates+getCentroidIndexAt)
-        * \param[in] x the X point coordinate to get the index at
-        * \param[in] y the Y point coordinate to get the index at
-        * \param[in] z the Z point coordinate to get the index at
-        */
-      inline int 
-      getCentroidIndex (float x, float y, float z)
-      {
-        return (leaf_layout_.at ((Eigen::Vector4i (static_cast&lt;int&gt; (floor (x * inverse_leaf_size_[0])), 
-                                                   static_cast&lt;int&gt; (floor (y * inverse_leaf_size_[1])), 
-                                                   static_cast&lt;int&gt; (floor (z * inverse_leaf_size_[2])), 
-                                                   0) 
-                - min_b_).dot (divb_mul_)));
-      }
-
-      /** \brief Returns the indices in the resulting downsampled cloud of the points at the specified grid coordinates,
-        * relative to the grid coordinates of the specified point (or -1 if the cell was empty/out of bounds).
-        * \param[in] x the X coordinate of the reference point (corresponding cell is allowed to be empty/out of bounds)
-        * \param[in] y the Y coordinate of the reference point (corresponding cell is allowed to be empty/out of bounds)
-        * \param[in] z the Z coordinate of the reference point (corresponding cell is allowed to be empty/out of bounds)
-        * \param[out] relative_coordinates matrix with the columns being the coordinates of the requested cells, relative to the reference point's cell
-        * \note for efficiency, user must make sure that the saving of the leaf layout is enabled and filtering performed
-        */
-      inline std::vector&lt;int&gt; 
-      getNeighborCentroidIndices (float x, float y, float z, const Eigen::MatrixXi &amp;relative_coordinates)
-      {
-        Eigen::Vector4i ijk (static_cast&lt;int&gt; (floor (x * inverse_leaf_size_[0])), 
-                             static_cast&lt;int&gt; (floor (y * inverse_leaf_size_[1])), 
-                             static_cast&lt;int&gt; (floor (z * inverse_leaf_size_[2])), 0);
-        Eigen::Array4i diff2min = min_b_ - ijk;
-        Eigen::Array4i diff2max = max_b_ - ijk;
-        std::vector&lt;int&gt; neighbors (relative_coordinates.cols());
-        for (int ni = 0; ni &lt; relative_coordinates.cols (); ni++)
-        {
-          Eigen::Vector4i displacement = (Eigen::Vector4i() &lt;&lt; relative_coordinates.col(ni), 0).finished();
-          // checking if the specified cell is in the grid
-          if ((diff2min &lt;= displacement.array()).all() &amp;&amp; (diff2max &gt;= displacement.array()).all())
-            neighbors[ni] = leaf_layout_[((ijk + displacement - min_b_).dot (divb_mul_))]; // .at() can be omitted
-          else
-            neighbors[ni] = -1; // cell is out of bounds, consider it empty
-        }
-        return (neighbors);
-      }
-      
-      /** \brief Returns the indices in the resulting downsampled cloud of the points at the specified grid coordinates,
-        * relative to the grid coordinates of the specified point (or -1 if the cell was empty/out of bounds).
-        * \param[in] x the X coordinate of the reference point (corresponding cell is allowed to be empty/out of bounds)
-        * \param[in] y the Y coordinate of the reference point (corresponding cell is allowed to be empty/out of bounds)
-        * \param[in] z the Z coordinate of the reference point (corresponding cell is allowed to be empty/out of bounds)
-        * \param[out] relative_coordinates vector with the elements being the coordinates of the requested cells, relative to the reference point's cell
-        * \note for efficiency, user must make sure that the saving of the leaf layout is enabled and filtering performed
-        */
-      inline std::vector&lt;int&gt; 
-      getNeighborCentroidIndices (float x, float y, float z, const std::vector&lt;Eigen::Vector3i, Eigen::aligned_allocator&lt;Eigen::Vector3i&gt; &gt; &amp;relative_coordinates)
-      {
-        Eigen::Vector4i ijk (static_cast&lt;int&gt; (floorf (x * inverse_leaf_size_[0])), static_cast&lt;int&gt; (floorf (y * inverse_leaf_size_[1])), static_cast&lt;int&gt; (floorf (z * inverse_leaf_size_[2])), 0);
-        std::vector&lt;int&gt; neighbors;
-        neighbors.reserve (relative_coordinates.size ());
-        for (std::vector&lt;Eigen::Vector3i, Eigen::aligned_allocator&lt;Eigen::Vector3i&gt; &gt;::const_iterator it = relative_coordinates.begin (); it != relative_coordinates.end (); it++)
-          neighbors.push_back (leaf_layout_[(ijk + (Eigen::Vector4i() &lt;&lt; *it, 0).finished() - min_b_).dot (divb_mul_)]);
-        return (neighbors);
-      }
-
-      /** \brief Returns the layout of the leafs for fast access to cells relative to current position.
-        * \note position at (i-min_x) + (j-min_y)*div_x + (k-min_z)*div_x*div_y holds the index of the element at coordinates (i,j,k) in the grid (-1 if empty)
-        */
-      inline std::vector&lt;int&gt; 
-      getLeafLayout () { return (leaf_layout_); }
-
-      /** \brief Returns the corresponding (i,j,k) coordinates in the grid of point (x,y,z).
-        * \param[in] x the X point coordinate to get the (i, j, k) index at
-        * \param[in] y the Y point coordinate to get the (i, j, k) index at
-        * \param[in] z the Z point coordinate to get the (i, j, k) index at
-        */
-      inline Eigen::Vector3i 
-      getGridCoordinates (float x, float y, float z) 
-      { 
-        return (Eigen::Vector3i (static_cast&lt;int&gt; (floor (x * inverse_leaf_size_[0])), 
-                                 static_cast&lt;int&gt; (floor (y * inverse_leaf_size_[1])), 
-                                 static_cast&lt;int&gt; (floor (z * inverse_leaf_size_[2])))); 
-      }
-
-      /** \brief Returns the index in the downsampled cloud corresponding to a given set of coordinates.
-        * \param[in] ijk the coordinates (i,j,k) in the grid (-1 if empty)
-        */
-      inline int 
-      getCentroidIndexAt (const Eigen::Vector3i &amp;ijk)
-      {
-        int idx = ((Eigen::Vector4i() &lt;&lt; ijk, 0).finished() - min_b_).dot (divb_mul_);
-        if (idx &lt; 0 || idx &gt;= static_cast&lt;int&gt; (leaf_layout_.size ())) // this checks also if leaf_layout_.size () == 0 i.e. everything was computed as needed
-        {
-          //if (verbose)
-          //  PCL_ERROR ("[pcl::%s::getCentroidIndexAt] Specified coordinate is outside grid bounds, or leaf layout is not saved, make sure to call setSaveLeafLayout(true) and filter(output) first!\n", getClassName ().c_str ());
-          return (-1);
-        }
-        return (leaf_layout_[idx]);
-      }
-
-      /** \brief Provide the name of the field to be used for filtering data. In conjunction with  \a setFilterLimits,
-        * points having values outside this interval will be discarded.
-        * \param[in] field_name the name of the field that contains values used for filtering
-        */
-      inline void
-      setFilterFieldName (const std::string &amp;field_name)
-      {
-        filter_field_name_ = field_name;
-      }
-
-      /** \brief Get the name of the field used for filtering. */
-      inline std::string const
-      getFilterFieldName ()
-      {
-        return (filter_field_name_);
-      }
-
-      /** \brief Set the field filter limits. All points having field values outside this interval will be discarded.
-        * \param[in] limit_min the minimum allowed field value
-        * \param[in] limit_max the maximum allowed field value
-        */
-      inline void
-      setFilterLimits (const double &amp;limit_min, const double &amp;limit_max)
-      {
-        filter_limit_min_ = limit_min;
-        filter_limit_max_ = limit_max;
-      }
-
-      /** \brief Get the field filter limits (min/max) set by the user. The default values are -FLT_MAX, FLT_MAX. 
-        * \param[out] limit_min the minimum allowed field value
-        * \param[out] limit_max the maximum allowed field value
-        */
-      inline void
-      getFilterLimits (double &amp;limit_min, double &amp;limit_max)
-      {
-        limit_min = filter_limit_min_;
-        limit_max = filter_limit_max_;
-      }
-
-      /** \brief Set to true if we want to return the data outside the interval specified by setFilterLimits (min, max).
-        * Default: false.
-        * \param[in] limit_negative return data inside the interval (false) or outside (true)
-        */
-      inline void
-      setFilterLimitsNegative (const bool limit_negative)
-      {
-        filter_limit_negative_ = limit_negative;
-      }
-
-      /** \brief Get whether the data outside the interval (min/max) is to be returned (true) or inside (false). 
-        * \param[out] limit_negative true if data \b outside the interval [min; max] is to be returned, false otherwise
-        */
-      inline void
-      getFilterLimitsNegative (bool &amp;limit_negative)
-      {
-        limit_negative = filter_limit_negative_;
-      }
-
-      /** \brief Get whether the data outside the interval (min/max) is to be returned (true) or inside (false). 
-        * \return true if data \b outside the interval [min; max] is to be returned, false otherwise
-        */
-      inline bool
-      getFilterLimitsNegative ()
-      {
-        return (filter_limit_negative_);
-      }
-
-    protected:
-      /** \brief The size of a leaf. */
-      Eigen::Vector4f leaf_size_;
-
-      /** \brief Internal leaf sizes stored as 1/leaf_size_ for efficiency reasons. */ 
-      Eigen::Array4f inverse_leaf_size_;
-
-      /** \brief Set to true if all fields need to be downsampled, or false if just XYZ. */
-      bool downsample_all_data_;
-
-      /** \brief Set to true if leaf layout information needs to be saved in \a
-        * leaf_layout. 
-        */
-      bool save_leaf_layout_;
-
-      /** \brief The leaf layout information for fast access to cells relative
-        * to current position 
-        */
-      std::vector&lt;int&gt; leaf_layout_;
-
-      /** \brief The minimum and maximum bin coordinates, the number of
-        * divisions, and the division multiplier. 
-        */
-      Eigen::Vector4i min_b_, max_b_, div_b_, divb_mul_;
-
-      /** \brief The desired user filter field name. */
-      std::string filter_field_name_;
-
-      /** \brief The minimum allowed filter value a point will be considered from. */
-      double filter_limit_min_;
-
-      /** \brief The maximum allowed filter value a point will be considered from. */
-      double filter_limit_max_;
-
-      /** \brief Set to true if we want to return the data outside (\a filter_limit_min_;\a filter_limit_max_). Default: false. */
-      bool filter_limit_negative_;
-
-      /** \brief Minimum number of points per voxel for the centroid to be computed */
-      unsigned int min_points_per_voxel_;
-
-      /** \brief Downsample a Point Cloud using a voxelized grid approach
-        * \param[out] output the resultant point cloud
-        */
-      void 
-      applyFilter (PCLPointCloud2 &amp;output);
-  };
-}
-
-#ifdef PCL_NO_PRECOMPILE
-    //#include &lt;pcl/filters/impl/voxel_grid.hpp&gt;
-#include "fast_pcl/filters/impl/voxel_grid.hpp"
-#endif
-
-#endif  //#ifndef FAST_PCL_FILTERS_VOXEL_GRID_MAP_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\filters\include\fast_pcl\filters\voxel_grid_covariance.h" new_path="" added_lines="0" deleted_lines="551">
				<diff>@@ -1,551 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef FAST_PCL_VOXEL_GRID_COVARIANCE_H_
-#define FAST_PCL_VOXEL_GRID_COVARIANCE_H_
-
-//#include &lt;pcl/filters/boost.h&gt;
-//#include &lt;pcl/filters/voxel_grid.h&gt;
-#include "fast_pcl/filters/boost.h"
-#include "fast_pcl/filters/voxel_grid.h"
-
-#include &lt;map&gt;
-#include &lt;pcl/point_types.h&gt;
-#include &lt;pcl/kdtree/kdtree_flann.h&gt;
-
-namespace pcl
-{
-  /** \brief A searchable voxel strucure containing the mean and covariance of the data.
-    * \note For more information please see
-    * &lt;b&gt;Magnusson, M. (2009). The Three-Dimensional Normal-Distributions Transform —
-    * an Efﬁcient Representation for Registration, Surface Analysis, and Loop Detection.
-    * PhD thesis, Orebro University. Orebro Studies in Technology 36&lt;/b&gt;
-    * \author Brian Okorn (Space and Naval Warfare Systems Center Pacific)
-    */
-  template&lt;typename PointT&gt;
-  class VoxelGridCovariance : public VoxelGrid&lt;PointT&gt;
-  {
-    protected:
-      using VoxelGrid&lt;PointT&gt;::filter_name_;
-      using VoxelGrid&lt;PointT&gt;::getClassName;
-      using VoxelGrid&lt;PointT&gt;::input_;
-      using VoxelGrid&lt;PointT&gt;::indices_;
-      using VoxelGrid&lt;PointT&gt;::filter_limit_negative_;
-      using VoxelGrid&lt;PointT&gt;::filter_limit_min_;
-      using VoxelGrid&lt;PointT&gt;::filter_limit_max_;
-      using VoxelGrid&lt;PointT&gt;::filter_field_name_;
-
-      using VoxelGrid&lt;PointT&gt;::downsample_all_data_;
-      using VoxelGrid&lt;PointT&gt;::leaf_layout_;
-      using VoxelGrid&lt;PointT&gt;::save_leaf_layout_;
-      using VoxelGrid&lt;PointT&gt;::leaf_size_;
-      using VoxelGrid&lt;PointT&gt;::min_b_;
-      using VoxelGrid&lt;PointT&gt;::max_b_;
-      using VoxelGrid&lt;PointT&gt;::inverse_leaf_size_;
-      using VoxelGrid&lt;PointT&gt;::div_b_;
-      using VoxelGrid&lt;PointT&gt;::divb_mul_;
-
-
-      typedef typename pcl::traits::fieldList&lt;PointT&gt;::type FieldList;
-      typedef typename Filter&lt;PointT&gt;::PointCloud PointCloud;
-      typedef typename PointCloud::Ptr PointCloudPtr;
-      typedef typename PointCloud::ConstPtr PointCloudConstPtr;
-
-    public:
-
-      typedef boost::shared_ptr&lt; VoxelGrid&lt;PointT&gt; &gt; Ptr;
-      typedef boost::shared_ptr&lt; const VoxelGrid&lt;PointT&gt; &gt; ConstPtr;
-
-
-      /** \brief Simple structure to hold a centroid, covarince and the number of points in a leaf.
-        * Inverse covariance, eigen vectors and engen values are precomputed. */
-      struct Leaf
-      {
-        /** \brief Constructor.
-         * Sets \ref nr_points, \ref icov_, \ref mean_ and \ref evals_ to 0 and \ref cov_ and \ref evecs_ to the identity matrix
-         */
-        Leaf () :
-          nr_points (0),
-          mean_ (Eigen::Vector3d::Zero ()),
-          centroid (),
-          cov_ (Eigen::Matrix3d::Identity ()),
-          icov_ (Eigen::Matrix3d::Zero ()),
-          evecs_ (Eigen::Matrix3d::Identity ()),
-          evals_ (Eigen::Vector3d::Zero ())
-        {
-        }
-
-        /** \brief Get the voxel covariance.
-          * \return covariance matrix
-          */
-        Eigen::Matrix3d
-        getCov () const
-        {
-          return (cov_);
-        }
-
-        /** \brief Get the inverse of the voxel covariance.
-          * \return inverse covariance matrix
-          */
-        Eigen::Matrix3d
-        getInverseCov () const
-        {
-          return (icov_);
-        }
-
-        /** \brief Get the voxel centroid.
-          * \return centroid
-          */
-        Eigen::Vector3d
-        getMean () const
-        {
-          return (mean_);
-        }
-
-        /** \brief Get the eigen vectors of the voxel covariance.
-          * \note Order corresponds with \ref getEvals
-          * \return matrix whose columns contain eigen vectors
-          */
-        Eigen::Matrix3d
-        getEvecs () const
-        {
-          return (evecs_);
-        }
-
-        /** \brief Get the eigen values of the voxel covariance.
-          * \note Order corresponds with \ref getEvecs
-          * \return vector of eigen values
-          */
-        Eigen::Vector3d
-        getEvals () const
-        {
-          return (evals_);
-        }
-
-        /** \brief Get the number of points contained by this voxel.
-          * \return number of points
-          */
-        int
-        getPointCount () const
-        {
-          return (nr_points);
-        }
-
-        /** \brief Number of points contained by voxel */
-        int nr_points;
-
-        /** \brief 3D voxel centroid */
-        Eigen::Vector3d mean_;
-
-        /** \brief Nd voxel centroid
-         * \note Differs from \ref mean_ when color data is used
-         */
-        Eigen::VectorXf centroid;
-
-        /** \brief Voxel covariance matrix */
-        Eigen::Matrix3d cov_;
-
-        /** \brief Inverse of voxel covariance matrix */
-        Eigen::Matrix3d icov_;
-
-        /** \brief Eigen vectors of voxel covariance matrix */
-        Eigen::Matrix3d evecs_;
-
-        /** \brief Eigen values of voxel covariance matrix */
-        Eigen::Vector3d evals_;
-
-      };
-
-      /** \brief Pointer to VoxelGridCovariance leaf structure */
-      typedef Leaf* LeafPtr;
-
-      /** \brief Const pointer to VoxelGridCovariance leaf structure */
-      typedef const Leaf* LeafConstPtr;
-
-    public:
-
-      /** \brief Constructor.
-       * Sets \ref leaf_size_ to 0 and \ref searchable_ to false.
-       */
-      VoxelGridCovariance () :
-        searchable_ (true),
-        min_points_per_voxel_ (6),
-        min_covar_eigvalue_mult_ (0.01),
-        leaves_ (),
-        voxel_centroids_ (),
-        voxel_centroids_leaf_indices_ (),
-        kdtree_ ()
-      {
-        downsample_all_data_ = false;
-        save_leaf_layout_ = false;
-        leaf_size_.setZero ();
-        min_b_.setZero ();
-        max_b_.setZero ();
-        filter_name_ = "VoxelGridCovariance";
-      }
-
-      /** \brief Set the minimum number of points required for a cell to be used (must be 3 or greater for covariance calculation).
-        * \param[in] min_points_per_voxel the minimum number of points for required for a voxel to be used
-        */
-      inline void
-      setMinPointPerVoxel (int min_points_per_voxel)
-      {
-        if(min_points_per_voxel &gt; 2)
-        {
-          min_points_per_voxel_ = min_points_per_voxel;
-        }
-        else
-        {
-          PCL_WARN ("%s: Covariance calculation requires at least 3 points, setting Min Point per Voxel to 3 ", this-&gt;getClassName ().c_str ());
-          min_points_per_voxel_ = 3;
-        }
-      }
-
-      /** \brief Get the minimum number of points required for a cell to be used.
-        * \return the minimum number of points for required for a voxel to be used
-        */
-      inline int
-      getMinPointPerVoxel ()
-      {
-        return min_points_per_voxel_;
-      }
-
-      /** \brief Set the minimum allowable ratio between eigenvalues to prevent singular covariance matrices.
-        * \param[in] min_covar_eigvalue_mult the minimum allowable ratio between eigenvalues
-        */
-      inline void
-      setCovEigValueInflationRatio (double min_covar_eigvalue_mult)
-      {
-        min_covar_eigvalue_mult_ = min_covar_eigvalue_mult;
-      }
-
-      /** \brief Get the minimum allowable ratio between eigenvalues to prevent singular covariance matrices.
-        * \return the minimum allowable ratio between eigenvalues
-        */
-      inline double
-      getCovEigValueInflationRatio ()
-      {
-        return min_covar_eigvalue_mult_;
-      }
-
-      /** \brief Filter cloud and initializes voxel structure.
-       * \param[out] output cloud containing centroids of voxels containing a sufficient number of points
-       * \param[in] searchable flag if voxel structure is searchable, if true then kdtree is built
-       */
-      inline void
-      filter (PointCloud &amp;output, bool searchable = false)
-      {
-        searchable_ = searchable;
-        applyFilter (output);
-
-        voxel_centroids_ = PointCloudPtr (new PointCloud (output));
-
-        if (searchable_ &amp;&amp; voxel_centroids_-&gt;size() &gt; 0)
-        {
-          // Initiates kdtree of the centroids of voxels containing a sufficient number of points
-          kdtree_.setInputCloud (voxel_centroids_);
-        }
-      }
-
-      /** \brief Initializes voxel structure.
-       * \param[in] searchable flag if voxel structure is searchable, if true then kdtree is built
-       */
-      inline void
-      filter (bool searchable = false)
-      {
-        searchable_ = searchable;
-        voxel_centroids_ = PointCloudPtr (new PointCloud);
-        applyFilter (*voxel_centroids_);
-
-        if (searchable_ &amp;&amp; voxel_centroids_-&gt;size() &gt; 0)
-        {
-          // Initiates kdtree of the centroids of voxels containing a sufficient number of points
-          kdtree_.setInputCloud (voxel_centroids_);
-        }
-      }
-
-      /** \brief Get the voxel containing point p.
-       * \param[in] index the index of the leaf structure node
-       * \return const pointer to leaf structure
-       */
-      inline LeafConstPtr
-      getLeaf (int index)
-      {
-        typename std::map&lt;size_t, Leaf&gt;::iterator leaf_iter = leaves_.find (index);
-        if (leaf_iter != leaves_.end ())
-        {
-          LeafConstPtr ret (&amp;(leaf_iter-&gt;second));
-          return ret;
-        }
-        else
-          return NULL;
-      }
-
-      /** \brief Get the voxel containing point p.
-       * \param[in] p the point to get the leaf structure at
-       * \return const pointer to leaf structure
-       */
-      inline LeafConstPtr
-      getLeaf (PointT &amp;p)
-      {
-        // Generate index associated with p
-        int ijk0 = static_cast&lt;int&gt; (floor (p.x * inverse_leaf_size_[0]) - min_b_[0]);
-        int ijk1 = static_cast&lt;int&gt; (floor (p.y * inverse_leaf_size_[1]) - min_b_[1]);
-        int ijk2 = static_cast&lt;int&gt; (floor (p.z * inverse_leaf_size_[2]) - min_b_[2]);
-
-        // Compute the centroid leaf index
-        int idx = ijk0 * divb_mul_[0] + ijk1 * divb_mul_[1] + ijk2 * divb_mul_[2];
-
-        // Find leaf associated with index
-        typename std::map&lt;size_t, Leaf&gt;::iterator leaf_iter = leaves_.find (idx);
-        if (leaf_iter != leaves_.end ())
-        {
-          // If such a leaf exists return the pointer to the leaf structure
-          LeafConstPtr ret (&amp;(leaf_iter-&gt;second));
-          return ret;
-        }
-        else
-          return NULL;
-      }
-
-      /** \brief Get the voxel containing point p.
-       * \param[in] p the point to get the leaf structure at
-       * \return const pointer to leaf structure
-       */
-      inline LeafConstPtr
-      getLeaf (Eigen::Vector3f &amp;p)
-      {
-        // Generate index associated with p
-        int ijk0 = static_cast&lt;int&gt; (floor (p[0] * inverse_leaf_size_[0]) - min_b_[0]);
-        int ijk1 = static_cast&lt;int&gt; (floor (p[1] * inverse_leaf_size_[1]) - min_b_[1]);
-        int ijk2 = static_cast&lt;int&gt; (floor (p[2] * inverse_leaf_size_[2]) - min_b_[2]);
-
-        // Compute the centroid leaf index
-        int idx = ijk0 * divb_mul_[0] + ijk1 * divb_mul_[1] + ijk2 * divb_mul_[2];
-
-        // Find leaf associated with index
-        typename std::map&lt;size_t, Leaf&gt;::iterator leaf_iter = leaves_.find (idx);
-        if (leaf_iter != leaves_.end ())
-        {
-          // If such a leaf exists return the pointer to the leaf structure
-          LeafConstPtr ret (&amp;(leaf_iter-&gt;second));
-          return ret;
-        }
-        else
-          return NULL;
-
-      }
-
-      /** \brief Get the voxels surrounding point p, not including the voxel contating point p.
-       * \note Only voxels containing a sufficient number of points are used (slower than radius search in practice).
-       * \param[in] reference_point the point to get the leaf structure at
-       * \param[out] neighbors
-       * \return number of neighbors found
-       */
-      int
-      getNeighborhoodAtPoint (const PointT&amp; reference_point, std::vector&lt;LeafConstPtr&gt; &amp;neighbors);
-
-      /** \brief Get the leaf structure map
-       * \return a map contataining all leaves
-       */
-      inline const std::map&lt;size_t, Leaf&gt;&amp;
-      getLeaves ()
-      {
-        return leaves_;
-      }
-
-      /** \brief Get a pointcloud containing the voxel centroids
-       * \note Only voxels containing a sufficient number of points are used.
-       * \return a map contataining all leaves
-       */
-      inline PointCloudPtr
-      getCentroids ()
-      {
-        return voxel_centroids_;
-      }
-
-
-      /** \brief Get a cloud to visualize each voxels normal distribution.
-       * \param[out] cell_cloud a cloud created by sampling the normal distributions of each voxel
-       */
-      void
-      getDisplayCloud (pcl::PointCloud&lt;PointXYZ&gt;&amp; cell_cloud);
-
-      /** \brief Search for the k-nearest occupied voxels for the given query point.
-       * \note Only voxels containing a sufficient number of points are used.
-       * \param[in] point the given query point
-       * \param[in] k the number of neighbors to search for
-       * \param[out] k_leaves the resultant leaves of the neighboring points
-       * \param[out] k_sqr_distances the resultant squared distances to the neighboring points
-       * \return number of neighbors found
-       */
-      int
-      nearestKSearch (const PointT &amp;point, int k,
-                      std::vector&lt;LeafConstPtr&gt; &amp;k_leaves, std::vector&lt;float&gt; &amp;k_sqr_distances)
-      {
-        k_leaves.clear ();
-
-        // Check if kdtree has been built
-        if (!searchable_)
-        {
-          PCL_WARN ("%s: Not Searchable", this-&gt;getClassName ().c_str ());
-          return 0;
-        }
-
-        // Find k-nearest neighbors in the occupied voxel centroid cloud
-        std::vector&lt;int&gt; k_indices;
-        k = kdtree_.nearestKSearch (point, k, k_indices, k_sqr_distances);
-
-        // Find leaves corresponding to neighbors
-        k_leaves.reserve (k);
-        for (std::vector&lt;int&gt;::iterator iter = k_indices.begin (); iter != k_indices.end (); iter++)
-        {
-          k_leaves.push_back (&amp;leaves_[voxel_centroids_leaf_indices_[*iter]]);
-        }
-        return k;
-      }
-
-      /** \brief Search for the k-nearest occupied voxels for the given query point.
-       * \note Only voxels containing a sufficient number of points are used.
-       * \param[in] cloud the given query point
-       * \param[in] index the index
-       * \param[in] k the number of neighbors to search for
-       * \param[out] k_leaves the resultant leaves of the neighboring points
-       * \param[out] k_sqr_distances the resultant squared distances to the neighboring points
-       * \return number of neighbors found
-       */
-      inline int
-      nearestKSearch (const PointCloud &amp;cloud, int index, int k,
-                      std::vector&lt;LeafConstPtr&gt; &amp;k_leaves, std::vector&lt;float&gt; &amp;k_sqr_distances)
-      {
-        if (index &gt;= static_cast&lt;int&gt; (cloud.points.size ()) || index &lt; 0)
-          return (0);
-        return (nearestKSearch (cloud.points[index], k, k_leaves, k_sqr_distances));
-      }
-
-
-      /** \brief Search for all the nearest occupied voxels of the query point in a given radius.
-       * \note Only voxels containing a sufficient number of points are used.
-       * \param[in] point the given query point
-       * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
-       * \param[out] k_leaves the resultant leaves of the neighboring points
-       * \param[out] k_sqr_distances the resultant squared distances to the neighboring points
-       * \param[in] max_nn
-       * \return number of neighbors found
-       */
-      int
-      radiusSearch (const PointT &amp;point, double radius, std::vector&lt;LeafConstPtr&gt; &amp;k_leaves,
-                    std::vector&lt;float&gt; &amp;k_sqr_distances, unsigned int max_nn = 0)
-      {
-        k_leaves.clear ();
-
-        // Check if kdtree has been built
-        if (!searchable_)
-        {
-          PCL_WARN ("%s: Not Searchable", this-&gt;getClassName ().c_str ());
-          return 0;
-        }
-
-        // Find neighbors within radius in the occupied voxel centroid cloud
-        std::vector&lt;int&gt; k_indices;
-        int k = kdtree_.radiusSearch (point, radius, k_indices, k_sqr_distances, max_nn);
-
-        // Find leaves corresponding to neighbors
-        k_leaves.reserve (k);
-        for (std::vector&lt;int&gt;::iterator iter = k_indices.begin (); iter != k_indices.end (); iter++)
-        {
-          k_leaves.push_back (&amp;leaves_[voxel_centroids_leaf_indices_[*iter]]);
-        }
-        return k;
-      }
-
-      /** \brief Search for all the nearest occupied voxels of the query point in a given radius.
-       * \note Only voxels containing a sufficient number of points are used.
-       * \param[in] cloud the given query point
-       * \param[in] index a valid index in cloud representing a valid (i.e., finite) query point
-       * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
-       * \param[out] k_leaves the resultant leaves of the neighboring points
-       * \param[out] k_sqr_distances the resultant squared distances to the neighboring points
-       * \param[in] max_nn
-       * \return number of neighbors found
-       */
-      inline int
-      radiusSearch (const PointCloud &amp;cloud, int index, double radius,
-                    std::vector&lt;LeafConstPtr&gt; &amp;k_leaves, std::vector&lt;float&gt; &amp;k_sqr_distances,
-                    unsigned int max_nn = 0)
-      {
-        if (index &gt;= static_cast&lt;int&gt; (cloud.points.size ()) || index &lt; 0)
-          return (0);
-        return (radiusSearch (cloud.points[index], radius, k_leaves, k_sqr_distances, max_nn));
-      }
-
-    protected:
-
-      /** \brief Filter cloud and initializes voxel structure.
-       * \param[out] output cloud containing centroids of voxels containing a sufficient number of points
-       */
-      void applyFilter (PointCloud &amp;output);
-
-      /** \brief Flag to determine if voxel structure is searchable. */
-      bool searchable_;
-
-      /** \brief Minimum points contained with in a voxel to allow it to be useable. */
-      int min_points_per_voxel_;
-
-      /** \brief Minimum allowable ratio between eigenvalues to prevent singular covariance matrices. */
-      double min_covar_eigvalue_mult_;
-
-      /** \brief Voxel structure containing all leaf nodes (includes voxels with less than a sufficient number of points). */
-      std::map&lt;size_t, Leaf&gt; leaves_;
-
-      /** \brief Point cloud containing centroids of voxels containing atleast minimum number of points. */
-      PointCloudPtr voxel_centroids_;
-
-      /** \brief Indices of leaf structurs associated with each point in \ref voxel_centroids_ (used for searching). */
-      std::vector&lt;int&gt; voxel_centroids_leaf_indices_;
-
-      /** \brief KdTree generated using \ref voxel_centroids_ (used for searching). */
-      KdTreeFLANN&lt;PointT&gt; kdtree_;
-  };
-}
-
-#ifdef PCL_NO_PRECOMPILE
-//#include &lt;pcl/filters/impl/voxel_grid_covariance.hpp&gt;
-#include "fast_pcl/filters/impl/voxel_grid_covariance.hpp"
-#endif
-
-#endif  //#ifndef FAST_PCL_VOXEL_GRID_COVARIANCE_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\filters\src\filter.cpp" new_path="" added_lines="0" deleted_lines="86">
				<diff>@@ -1,86 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2009, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-// #include &lt;pcl/filters/impl/filter.hpp&gt;
-#include "fast_pcl/filters/impl/filter.hpp"
-#include &lt;pcl/PCLPointCloud2.h&gt;
-
-///////////////////////////////////////////////////////////////////////////////////////////
-/** \brief Base method for feature estimation for all points given in &lt;setInputCloud (), setIndices ()&gt; using
- * the surface in setSearchSurface () and the spatial locator in setSearchMethod ()
- * \param output the resultant filtered point cloud dataset
- */
-void
-pcl::Filter&lt;pcl::PCLPointCloud2&gt;::filter (PCLPointCloud2 &amp;output)
-{
-  if (!initCompute ())
-    return;
-
-  if (input_.get () == &amp;output)  // cloud_in = cloud_out
-  {
-    pcl::PCLPointCloud2 output_temp;
-    applyFilter (output_temp);
-    output_temp.fields = input_-&gt;fields;
-    output_temp.header = input_-&gt;header;
-    pcl::copyPointCloud (output_temp, output);
-  }
-  else
-  {
-    output.fields = input_-&gt;fields;
-    output.header = input_-&gt;header;
-    applyFilter (output);
-  }
-
-  // Apply the actual filter
-  applyFilter (output);
-
-  deinitCompute ();
-}
-
-#ifndef PCL_NO_PRECOMPILE
-#include &lt;pcl/impl/instantiate.hpp&gt;
-#include &lt;pcl/point_types.h&gt;
-
-// Instantiations of specific point types
-PCL_INSTANTIATE(removeNaNFromPointCloud, PCL_XYZ_POINT_TYPES)
-PCL_INSTANTIATE(removeNaNNormalsFromPointCloud, PCL_NORMAL_POINT_TYPES)
-
-#endif    // PCL_NO_PRECOMPILE
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\filters\src\voxel_grid.cpp" new_path="" added_lines="0" deleted_lines="549">
				<diff>@@ -1,549 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2009, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#include &lt;iostream&gt;
-#include &lt;pcl/common/io.h&gt;
-//#include &lt;pcl/filters/impl/voxel_grid.hpp&gt;
-#include "fast_pcl/filters/impl/voxel_grid.hpp"
-
-typedef Eigen::Array&lt;size_t, 4, 1&gt; Array4size_t;
-
-///////////////////////////////////////////////////////////////////////////////////////////
-void
-pcl::getMinMax3D (const pcl::PCLPointCloud2ConstPtr &amp;cloud, int x_idx, int y_idx, int z_idx,
-                  Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt)
-{
-  // @todo fix this
-  if (cloud-&gt;fields[x_idx].datatype != pcl::PCLPointField::FLOAT32 ||
-      cloud-&gt;fields[y_idx].datatype != pcl::PCLPointField::FLOAT32 ||
-      cloud-&gt;fields[z_idx].datatype != pcl::PCLPointField::FLOAT32)
-  {
-    PCL_ERROR ("[pcl::getMinMax3D] XYZ dimensions are not float type!\n");
-    return;
-  }
-
-  Eigen::Array4f min_p, max_p;
-  min_p.setConstant (FLT_MAX);
-  max_p.setConstant (-FLT_MAX);
-
-  size_t nr_points = cloud-&gt;width * cloud-&gt;height;
-
-  Eigen::Array4f pt = Eigen::Array4f::Zero ();
-  Array4size_t xyz_offset (cloud-&gt;fields[x_idx].offset, cloud-&gt;fields[y_idx].offset, cloud-&gt;fields[z_idx].offset, 0);
-
-  for (size_t cp = 0; cp &lt; nr_points; ++cp)
-  {
-    // Unoptimized memcpys: assume fields x, y, z are in random order
-    memcpy (&amp;pt[0], &amp;cloud-&gt;data[xyz_offset[0]], sizeof (float));
-    memcpy (&amp;pt[1], &amp;cloud-&gt;data[xyz_offset[1]], sizeof (float));
-    memcpy (&amp;pt[2], &amp;cloud-&gt;data[xyz_offset[2]], sizeof (float));
-    // Check if the point is invalid
-    if (!pcl_isfinite (pt[0]) || 
-        !pcl_isfinite (pt[1]) || 
-        !pcl_isfinite (pt[2]))
-    {
-      xyz_offset += cloud-&gt;point_step;
-      continue;
-    }
-    xyz_offset += cloud-&gt;point_step;
-    min_p = (min_p.min) (pt);
-    max_p = (max_p.max) (pt);
-  }
-  min_pt = min_p;
-  max_pt = max_p;
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-void
-pcl::getMinMax3D (const pcl::PCLPointCloud2ConstPtr &amp;cloud, int x_idx, int y_idx, int z_idx,
-                  const std::string &amp;distance_field_name, float min_distance, float max_distance,
-                  Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt, bool limit_negative)
-{
-  // @todo fix this
-  if (cloud-&gt;fields[x_idx].datatype != pcl::PCLPointField::FLOAT32 ||
-      cloud-&gt;fields[y_idx].datatype != pcl::PCLPointField::FLOAT32 ||
-      cloud-&gt;fields[z_idx].datatype != pcl::PCLPointField::FLOAT32)
-  {
-    PCL_ERROR ("[pcl::getMinMax3D] XYZ dimensions are not float type!\n");
-    return;
-  }
-
-  Eigen::Array4f min_p, max_p;
-  min_p.setConstant (FLT_MAX);
-  max_p.setConstant (-FLT_MAX);
-
-  // Get the distance field index
-  int distance_idx = pcl::getFieldIndex (*cloud, distance_field_name);
-
-  // @todo fix this
-  if (cloud-&gt;fields[distance_idx].datatype != pcl::PCLPointField::FLOAT32)
-  {
-    PCL_ERROR ("[pcl::getMinMax3D] Filtering dimensions is not float type!\n");
-    return;
-  }
-
-  size_t nr_points = cloud-&gt;width * cloud-&gt;height;
-
-  Eigen::Array4f pt = Eigen::Array4f::Zero ();
-  Array4size_t xyz_offset (cloud-&gt;fields[x_idx].offset,
-                           cloud-&gt;fields[y_idx].offset,
-                           cloud-&gt;fields[z_idx].offset,
-                           0);
-  float distance_value = 0;
-  for (size_t cp = 0; cp &lt; nr_points; ++cp)
-  {
-    size_t point_offset = cp * cloud-&gt;point_step;
-
-    // Get the distance value
-    memcpy (&amp;distance_value, &amp;cloud-&gt;data[point_offset + cloud-&gt;fields[distance_idx].offset], sizeof (float));
-
-    if (limit_negative)
-    {
-      // Use a threshold for cutting out points which inside the interval
-      if ((distance_value &lt; max_distance) &amp;&amp; (distance_value &gt; min_distance))
-      {
-        xyz_offset += cloud-&gt;point_step;
-        continue;
-      }
-    }
-    else
-    {
-      // Use a threshold for cutting out points which are too close/far away
-      if ((distance_value &gt; max_distance) || (distance_value &lt; min_distance))
-      {
-        xyz_offset += cloud-&gt;point_step;
-        continue;
-      }
-    }
-
-    // Unoptimized memcpys: assume fields x, y, z are in random order
-    memcpy (&amp;pt[0], &amp;cloud-&gt;data[xyz_offset[0]], sizeof (float));
-    memcpy (&amp;pt[1], &amp;cloud-&gt;data[xyz_offset[1]], sizeof (float));
-    memcpy (&amp;pt[2], &amp;cloud-&gt;data[xyz_offset[2]], sizeof (float));
-    // Check if the point is invalid
-    if (!pcl_isfinite (pt[0]) || 
-        !pcl_isfinite (pt[1]) || 
-        !pcl_isfinite (pt[2]))
-    {
-      xyz_offset += cloud-&gt;point_step;
-      continue;
-    }
-    xyz_offset += cloud-&gt;point_step;
-    min_p = (min_p.min) (pt);
-    max_p = (max_p.max) (pt);
-  }
-  min_pt = min_p;
-  max_pt = max_p;
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-void
-pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt;::applyFilter (PCLPointCloud2 &amp;output)
-{
-  // If fields x/y/z are not present, we cannot downsample
-  if (x_idx_ == -1 || y_idx_ == -1 || z_idx_ == -1)
-  {
-    PCL_ERROR ("[pcl::%s::applyFilter] Input dataset doesn't have x-y-z coordinates!\n", getClassName ().c_str ());
-    output.width = output.height = 0;
-    output.data.clear ();
-    return;
-  }
-  size_t nr_points  = input_-&gt;width * input_-&gt;height;
-
-  // Copy the header (and thus the frame_id) + allocate enough space for points
-  output.height         = 1;                    // downsampling breaks the organized structure
-  if (downsample_all_data_)
-  {
-    output.fields       = input_-&gt;fields;
-    output.point_step   = input_-&gt;point_step;
-  }
-  else
-  {
-    output.fields.resize (4);
-
-    output.fields[0] = input_-&gt;fields[x_idx_];
-    output.fields[0].offset = 0;
-
-    output.fields[1] = input_-&gt;fields[y_idx_];
-    output.fields[1].offset = 4;
-
-    output.fields[2] = input_-&gt;fields[z_idx_];
-    output.fields[2].offset = 8;
-
-    output.point_step = 12;
-  }
-  output.is_bigendian = input_-&gt;is_bigendian;
-  output.row_step     = input_-&gt;row_step;
-  output.is_dense     = true;                 // we filter out invalid points
-
-  Eigen::Vector4f min_p, max_p;
-  // Get the minimum and maximum dimensions
-  if (!filter_field_name_.empty ()) // If we don't want to process the entire cloud...
-    getMinMax3D (input_, x_idx_, y_idx_, z_idx_, filter_field_name_, 
-                 static_cast&lt;float&gt; (filter_limit_min_), 
-                 static_cast&lt;float&gt; (filter_limit_max_), min_p, max_p, filter_limit_negative_);
-  else
-    getMinMax3D (input_, x_idx_, y_idx_, z_idx_, min_p, max_p);
-
-  // Check that the leaf size is not too small, given the size of the data
-  int64_t dx = static_cast&lt;int64_t&gt;((max_p[0] - min_p[0]) * inverse_leaf_size_[0])+1;
-  int64_t dy = static_cast&lt;int64_t&gt;((max_p[1] - min_p[1]) * inverse_leaf_size_[1])+1;
-  int64_t dz = static_cast&lt;int64_t&gt;((max_p[2] - min_p[2]) * inverse_leaf_size_[2])+1;
-
-  if( (dx*dy*dz) &gt; static_cast&lt;int64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()) )
-  {
-    PCL_WARN("[pcl::%s::applyFilter] Leaf size is too small for the input dataset. Integer indices would overflow.", getClassName().c_str());
-    //output.width = output.height = 0;
-    //output.data.clear();
-    //return;
-  }
-
-  // Compute the minimum and maximum bounding box values
-  min_b_[0] = static_cast&lt;int&gt; (floor (min_p[0] * inverse_leaf_size_[0]));
-  max_b_[0] = static_cast&lt;int&gt; (floor (max_p[0] * inverse_leaf_size_[0]));
-  min_b_[1] = static_cast&lt;int&gt; (floor (min_p[1] * inverse_leaf_size_[1]));
-  max_b_[1] = static_cast&lt;int&gt; (floor (max_p[1] * inverse_leaf_size_[1]));
-  min_b_[2] = static_cast&lt;int&gt; (floor (min_p[2] * inverse_leaf_size_[2]));
-  max_b_[2] = static_cast&lt;int&gt; (floor (max_p[2] * inverse_leaf_size_[2]));
-
-  // Compute the number of divisions needed along all axis
-  div_b_ = max_b_ - min_b_ + Eigen::Vector4i::Ones ();
-  div_b_[3] = 0;
-
-  std::vector&lt;cloud_point_index_idx&gt; index_vector;
-  index_vector.reserve (nr_points);
-
-  // Create the first xyz_offset, and set up the division multiplier
-  Array4size_t xyz_offset (input_-&gt;fields[x_idx_].offset,
-                           input_-&gt;fields[y_idx_].offset,
-                           input_-&gt;fields[z_idx_].offset,
-                           0);
-  divb_mul_ = Eigen::Vector4i (1, div_b_[0], div_b_[0] * div_b_[1], 0);
-  Eigen::Vector4f pt  = Eigen::Vector4f::Zero ();
-
-  int centroid_size = 4;
-  if (downsample_all_data_)
-    centroid_size = static_cast&lt;int&gt; (input_-&gt;fields.size ());
-
-  int rgba_index = -1;
-
-  // ---[ RGB special case
-  // if the data contains "rgba" or "rgb", add an extra field for r/g/b in centroid
-  for (int d = 0; d &lt; centroid_size; ++d)
-  {
-    if (input_-&gt;fields[d].name == std::string ("rgba") || input_-&gt;fields[d].name == std::string ("rgb"))
-    {
-      rgba_index = d;
-      centroid_size += 3;
-      break;
-    }
-  }
-
-  // If we don't want to process the entire cloud, but rather filter points far away from the viewpoint first...
-  if (!filter_field_name_.empty ())
-  {
-    // Get the distance field index
-    int distance_idx = pcl::getFieldIndex (*input_, filter_field_name_);
-
-    // @todo fixme
-    if (input_-&gt;fields[distance_idx].datatype != pcl::PCLPointField::FLOAT32)
-    {
-      PCL_ERROR ("[pcl::%s::applyFilter] Distance filtering requested, but distances are not float/double in the dataset! Only FLOAT32/FLOAT64 distances are supported right now.\n", getClassName ().c_str ());
-      output.width = output.height = 0;
-      output.data.clear ();
-      return;
-    }
-
-    // First pass: go over all points and insert them into the index_vector vector
-    // with calculated idx. Points with the same idx value will contribute to the
-    // same point of resulting CloudPoint
-    float distance_value = 0;
-    for (size_t cp = 0; cp &lt; nr_points; ++cp)
-    {
-      size_t point_offset = cp * input_-&gt;point_step;
-      // Get the distance value
-      memcpy (&amp;distance_value, &amp;input_-&gt;data[point_offset + input_-&gt;fields[distance_idx].offset], sizeof (float));
-
-      if (filter_limit_negative_)
-      {
-        // Use a threshold for cutting out points which inside the interval
-        if (distance_value &lt; filter_limit_max_ &amp;&amp; distance_value &gt; filter_limit_min_)
-        {
-          xyz_offset += input_-&gt;point_step;
-          continue;
-        }
-      }
-      else
-      {
-        // Use a threshold for cutting out points which are too close/far away
-        if (distance_value &gt; filter_limit_max_ || distance_value &lt; filter_limit_min_)
-        {
-          xyz_offset += input_-&gt;point_step;
-          continue;
-        }
-      }
-
-      // Unoptimized memcpys: assume fields x, y, z are in random order
-      memcpy (&amp;pt[0], &amp;input_-&gt;data[xyz_offset[0]], sizeof (float));
-      memcpy (&amp;pt[1], &amp;input_-&gt;data[xyz_offset[1]], sizeof (float));
-      memcpy (&amp;pt[2], &amp;input_-&gt;data[xyz_offset[2]], sizeof (float));
-
-      // Check if the point is invalid
-      if (!pcl_isfinite (pt[0]) || 
-          !pcl_isfinite (pt[1]) || 
-          !pcl_isfinite (pt[2]))
-      {
-        xyz_offset += input_-&gt;point_step;
-        continue;
-      }
-
-      int ijk0 = static_cast&lt;int&gt; (floor (pt[0] * inverse_leaf_size_[0]) - min_b_[0]);
-      int ijk1 = static_cast&lt;int&gt; (floor (pt[1] * inverse_leaf_size_[1]) - min_b_[1]);
-      int ijk2 = static_cast&lt;int&gt; (floor (pt[2] * inverse_leaf_size_[2]) - min_b_[2]);
-      // Compute the centroid leaf index
-      int idx = ijk0 * divb_mul_[0] + ijk1 * divb_mul_[1] + ijk2 * divb_mul_[2];
-      index_vector.push_back (cloud_point_index_idx (idx, static_cast&lt;unsigned int&gt; (cp)));
-
-      xyz_offset += input_-&gt;point_step;
-    }
-  }
-  // No distance filtering, process all data
-  else
-  {
-    // First pass: go over all points and insert them into the right leaf
-    for (size_t cp = 0; cp &lt; nr_points; ++cp)
-    {
-      // Unoptimized memcpys: assume fields x, y, z are in random order
-      memcpy (&amp;pt[0], &amp;input_-&gt;data[xyz_offset[0]], sizeof (float));
-      memcpy (&amp;pt[1], &amp;input_-&gt;data[xyz_offset[1]], sizeof (float));
-      memcpy (&amp;pt[2], &amp;input_-&gt;data[xyz_offset[2]], sizeof (float));
-
-      // Check if the point is invalid
-      if (!pcl_isfinite (pt[0]) || 
-          !pcl_isfinite (pt[1]) || 
-          !pcl_isfinite (pt[2]))
-      {
-        xyz_offset += input_-&gt;point_step;
-        continue;
-      }
-
-      int ijk0 = static_cast&lt;int&gt; (floor (pt[0] * inverse_leaf_size_[0]) - min_b_[0]);
-      int ijk1 = static_cast&lt;int&gt; (floor (pt[1] * inverse_leaf_size_[1]) - min_b_[1]);
-      int ijk2 = static_cast&lt;int&gt; (floor (pt[2] * inverse_leaf_size_[2]) - min_b_[2]);
-      // Compute the centroid leaf index
-      int idx = ijk0 * divb_mul_[0] + ijk1 * divb_mul_[1] + ijk2 * divb_mul_[2];
-      index_vector.push_back (cloud_point_index_idx (idx, static_cast&lt;unsigned int&gt; (cp)));
-      xyz_offset += input_-&gt;point_step;
-    }
-  }
-
-  // Second pass: sort the index_vector vector using value representing target cell as index
-  // in effect all points belonging to the same output cell will be next to each other
-  std::sort (index_vector.begin (), index_vector.end (), std::less&lt;cloud_point_index_idx&gt; ());
-
-  // Third pass: count output cells
-  // we need to skip all the same, adjacenent idx values
-  size_t total = 0;
-  size_t index = 0;
-  while (index &lt; index_vector.size ()) 
-  {
-    size_t i = index + 1;
-    while (i &lt; index_vector.size () &amp;&amp; index_vector[i].idx == index_vector[index].idx) 
-      ++i;
-    ++total;
-    index = i;
-  }
-
-  // Fourth pass: compute centroids, insert them into their final position
-  output.width = uint32_t (total);
-  output.row_step = output.point_step * output.width;
-  output.data.resize (output.width * output.point_step);
-
-  if (save_leaf_layout_) 
-  {
-    try
-    {
-      // Resizing won't reset old elements to -1.  If leaf_layout_ has been used previously, it needs to be re-initialized to -1
-      uint32_t new_layout_size = div_b_[0]*div_b_[1]*div_b_[2];
-      //This is the number of elements that need to be re-initialized to -1
-      uint32_t reinit_size = std::min (static_cast&lt;unsigned int&gt; (new_layout_size), static_cast&lt;unsigned int&gt; (leaf_layout_.size()));
-      for (uint32_t i = 0; i &lt; reinit_size; i++)
-      {
-        leaf_layout_[i] = -1;
-      }        
-      leaf_layout_.resize (new_layout_size, -1);           
-    }
-    catch (std::bad_alloc&amp;)
-    {
-      throw PCLException("VoxelGrid bin size is too low; impossible to allocate memory for layout", 
-        "voxel_grid.cpp", "applyFilter");	
-    }
-    catch (std::length_error&amp;)
-    {
-      throw PCLException("VoxelGrid bin size is too low; impossible to allocate memory for layout", 
-        "voxel_grid.cpp", "applyFilter");	
-    }
-  }
-  
-  // If we downsample each field, the {x,y,z}_idx_ offsets should correspond in input_ and output
-  if (downsample_all_data_)
-    xyz_offset = Array4size_t (output.fields[x_idx_].offset,
-                               output.fields[y_idx_].offset,
-                               output.fields[z_idx_].offset,
-                               0);
-  else
-    // If not, we must have created a new xyzw cloud
-    xyz_offset = Array4size_t (0, 4, 8, 12);
-
-  index=0;
-  Eigen::VectorXf centroid = Eigen::VectorXf::Zero (centroid_size);
-  Eigen::VectorXf temporary = Eigen::VectorXf::Zero (centroid_size);
-
-  for (size_t cp = 0; cp &lt; index_vector.size ();)
-  {
-    size_t point_offset = index_vector[cp].cloud_point_index * input_-&gt;point_step;
-    // Do we need to process all the fields?
-    if (!downsample_all_data_) 
-    {
-      memcpy (&amp;pt[0], &amp;input_-&gt;data[point_offset+input_-&gt;fields[x_idx_].offset], sizeof (float));
-      memcpy (&amp;pt[1], &amp;input_-&gt;data[point_offset+input_-&gt;fields[y_idx_].offset], sizeof (float));
-      memcpy (&amp;pt[2], &amp;input_-&gt;data[point_offset+input_-&gt;fields[z_idx_].offset], sizeof (float));
-      centroid[0] = pt[0];
-      centroid[1] = pt[1];
-      centroid[2] = pt[2];
-      centroid[3] = 0;
-    }
-    else
-    {
-      // ---[ RGB special case
-      // fill extra r/g/b centroid field
-      if (rgba_index &gt;= 0)
-      {
-        pcl::RGB rgb;
-        memcpy (&amp;rgb, &amp;input_-&gt;data[point_offset + input_-&gt;fields[rgba_index].offset], sizeof (RGB));
-        centroid[centroid_size-3] = rgb.r;
-        centroid[centroid_size-2] = rgb.g;
-        centroid[centroid_size-1] = rgb.b;
-      }
-      // Copy all the fields
-      for (size_t d = 0; d &lt; input_-&gt;fields.size (); ++d)
-        memcpy (&amp;centroid[d], &amp;input_-&gt;data[point_offset + input_-&gt;fields[d].offset], field_sizes_[d]);
-    }
-
-    size_t i = cp + 1;
-    while (i &lt; index_vector.size () &amp;&amp; index_vector[i].idx == index_vector[cp].idx) 
-    {
-      size_t point_offset = index_vector[i].cloud_point_index * input_-&gt;point_step;
-      if (!downsample_all_data_) 
-      {
-        memcpy (&amp;pt[0], &amp;input_-&gt;data[point_offset+input_-&gt;fields[x_idx_].offset], sizeof (float));
-        memcpy (&amp;pt[1], &amp;input_-&gt;data[point_offset+input_-&gt;fields[y_idx_].offset], sizeof (float));
-        memcpy (&amp;pt[2], &amp;input_-&gt;data[point_offset+input_-&gt;fields[z_idx_].offset], sizeof (float));
-        centroid[0] += pt[0];
-        centroid[1] += pt[1];
-        centroid[2] += pt[2];
-      }
-      else
-      {
-        // ---[ RGB special case
-        // fill extra r/g/b centroid field
-        if (rgba_index &gt;= 0)
-        {
-          pcl::RGB rgb;
-          memcpy (&amp;rgb, &amp;input_-&gt;data[point_offset + input_-&gt;fields[rgba_index].offset], sizeof (RGB));
-          temporary[centroid_size-3] = rgb.r;
-          temporary[centroid_size-2] = rgb.g;
-          temporary[centroid_size-1] = rgb.b;
-        }
-        // Copy all the fields
-        for (size_t d = 0; d &lt; input_-&gt;fields.size (); ++d)
-          memcpy (&amp;temporary[d], &amp;input_-&gt;data[point_offset + input_-&gt;fields[d].offset], field_sizes_[d]);
-        centroid += temporary;
-      }
-      ++i;
-    }
-
-	  // Save leaf layout information for fast access to cells relative to current position
-    if (save_leaf_layout_)
-      leaf_layout_[index_vector[cp].idx] = static_cast&lt;int&gt; (index);
-
-    // Normalize the centroid
-    centroid /= static_cast&lt;float&gt; (i - cp);
-
-    // Do we need to process all the fields?
-    if (!downsample_all_data_)
-    {
-      // Copy the data
-      memcpy (&amp;output.data[xyz_offset[0]], &amp;centroid[0], sizeof (float));
-      memcpy (&amp;output.data[xyz_offset[1]], &amp;centroid[1], sizeof (float));
-      memcpy (&amp;output.data[xyz_offset[2]], &amp;centroid[2], sizeof (float));
-      xyz_offset += output.point_step;
-    }
-    else
-    {
-      size_t point_offset = index * output.point_step;
-      // Copy all the fields
-      for (size_t d = 0; d &lt; output.fields.size (); ++d)
-        memcpy (&amp;output.data[point_offset + output.fields[d].offset], &amp;centroid[d], field_sizes_[d]);
-
-      // ---[ RGB special case
-      // full extra r/g/b centroid field
-      if (rgba_index &gt;= 0) 
-      {
-        float r = centroid[centroid_size-3], g = centroid[centroid_size-2], b = centroid[centroid_size-1];
-        int rgb = (static_cast&lt;int&gt; (r) &lt;&lt; 16) | (static_cast&lt;int&gt; (g) &lt;&lt; 8) | static_cast&lt;int&gt; (b);
-        memcpy (&amp;output.data[point_offset + output.fields[rgba_index].offset], &amp;rgb, sizeof (float));
-      }
-    }
-    cp = i;
-    ++index;
-  }
-}
-
-#ifndef PCL_NO_PRECOMPILE
-#include &lt;pcl/impl/instantiate.hpp&gt;
-#include &lt;pcl/point_types.h&gt;
-
-// Instantiations of specific point types
-PCL_INSTANTIATE(getMinMax3D, PCL_XYZ_POINT_TYPES)
-PCL_INSTANTIATE(VoxelGrid, PCL_XYZ_POINT_TYPES)
-
-#endif    // PCL_NO_PRECOMPILE
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\filters\src\voxel_grid_covariance.cpp" new_path="" added_lines="0" deleted_lines="52">
				<diff>@@ -1,52 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-//#include &lt;pcl/filters/impl/voxel_grid_covariance.hpp&gt;
-#include "fast_pcl/filters/impl/voxel_grid_covariance.hpp"
-//#include &lt;pcl/filters/impl/voxel_grid.hpp&gt;
-#include "fast_pcl/filters/impl/voxel_grid.hpp"
-
-#ifndef PCL_NO_PRECOMPILE
-#include &lt;pcl/point_types.h&gt;
-#include &lt;pcl/impl/instantiate.hpp&gt;
-
-// Instantiations of specific point types
-PCL_INSTANTIATE (VoxelGridCovariance, PCL_XYZ_POINT_TYPES)
-
-#endif    // PCL_NO_PRECOMPILE
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\boost.h" new_path="" added_lines="0" deleted_lines="58">
				<diff>@@ -1,58 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#ifndef FAST_PCL_REGISTRATION_BOOST_H_
-#define FAST_PCL_REGISTRATION_BOOST_H_
-
-#if defined __GNUC__
-#  pragma GCC system_header 
-#endif
-
-//#include &lt;boost/graph/adjacency_list.hpp&gt;
-#include &lt;boost/graph/graph_traits.hpp&gt;
-#include &lt;boost/graph/dijkstra_shortest_paths.hpp&gt;
-#include &lt;boost/property_map/property_map.hpp&gt;
-
-#include &lt;boost/unordered_map.hpp&gt;
-#include &lt;boost/noncopyable.hpp&gt;
-#include &lt;boost/make_shared.hpp&gt;
-#include &lt;boost/function.hpp&gt;
-#include &lt;boost/bind.hpp&gt;
-
-#endif    // FAST_PCL_REGISTRATION_BOOST_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\convergence_criteria.h" new_path="" added_lines="0" deleted_lines="90">
				<diff>@@ -1,90 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#ifndef FAST_PCL_REGISTRATION_CONVERGENCE_CRIERIA_H_
-#define FAST_PCL_REGISTRATION_CONVERGENCE_CRIERIA_H_
-
-#include &lt;pcl/pcl_macros.h&gt;
-
-namespace pcl
-{
-  namespace registration
-  {
-    /** \brief @b ConvergenceCriteria represents an abstract base class for
-      * different convergence criteria used in registration loops.
-      *
-      * This should be used as part of an Iterative Closest Point (ICP)-like
-      * method, to verify if the algorithm has reached convergence.
-      *
-      * Typical convergence criteria that could inherit from this include:
-      * 
-      *  * a maximum number of iterations has been reached
-      *  * the transformation (R, t) cannot be further updated (the difference between current and previous is smaller than a threshold)
-      *  * the Mean Squared Error (MSE) between the current set of correspondences and the previous one is smaller than some threshold
-      *
-      * \author Radu B. Rusu
-      * \ingroup registration
-      */
-    class PCL_EXPORTS ConvergenceCriteria
-    {
-      public:
-        typedef boost::shared_ptr&lt;ConvergenceCriteria&gt; Ptr;
-        typedef boost::shared_ptr&lt;const ConvergenceCriteria&gt; ConstPtr;
-
-        /** \brief Empty constructor. */
-        ConvergenceCriteria () {}
-
-        /** \brief Empty destructor. */
-        virtual ~ConvergenceCriteria () {}
-
-        /** \brief Check if convergence has been reached. Pure virtual. */
-        virtual bool
-        hasConverged () = 0;
-
-        /** \brief Bool operator. */
-        operator bool ()
-        {
-          return (hasConverged ());
-        }
-     };
-  }
-}
-
-#endif    // FAST_PCL_REGISTRATION_CONVERGENCE_CRIERIA_H_
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\correspondence_estimation.h" new_path="" added_lines="0" deleted_lines="456">
				<diff>@@ -1,456 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#ifndef FAST_PCL_REGISTRATION_CORRESPONDENCE_ESTIMATION_H_
-#define FAST_PCL_REGISTRATION_CORRESPONDENCE_ESTIMATION_H_
-
-#include &lt;string&gt;
-
-#include &lt;pcl/pcl_base.h&gt;
-#include &lt;pcl/common/transforms.h&gt;
-#include &lt;pcl/search/kdtree.h&gt;
-#include &lt;pcl/pcl_macros.h&gt;
-
-//#include &lt;pcl/registration/correspondence_types.h&gt;
-#include "fast_pcl/registration/correspondence_types.h"
-
-namespace pcl
-{
-  namespace registration
-  {
-    /** \brief Abstract @b CorrespondenceEstimationBase class. 
-      * All correspondence estimation methods should inherit from this.
-      * \author Radu B. Rusu
-      * \ingroup registration
-      */
-    template &lt;typename PointSource, typename PointTarget, typename Scalar = float&gt;
-      class CorrespondenceEstimationBase: public PCLBase&lt;PointSource&gt;
-    {
-      public:
-        typedef boost::shared_ptr&lt;CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt; &gt; Ptr;
-        typedef boost::shared_ptr&lt;const CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt; &gt; ConstPtr;
-
-        // using PCLBase&lt;PointSource&gt;::initCompute;
-        using PCLBase&lt;PointSource&gt;::deinitCompute;
-        using PCLBase&lt;PointSource&gt;::input_;
-        using PCLBase&lt;PointSource&gt;::indices_;
-        using PCLBase&lt;PointSource&gt;::setIndices;
-
-        typedef pcl::search::KdTree&lt;PointTarget&gt; KdTree;
-        typedef typename KdTree::Ptr KdTreePtr;
-
-        typedef pcl::search::KdTree&lt;PointSource&gt; KdTreeReciprocal;
-        typedef typename KdTree::Ptr KdTreeReciprocalPtr;
-
-        typedef pcl::PointCloud&lt;PointSource&gt; PointCloudSource;
-        typedef typename PointCloudSource::Ptr PointCloudSourcePtr;
-        typedef typename PointCloudSource::ConstPtr PointCloudSourceConstPtr;
-
-        typedef pcl::PointCloud&lt;PointTarget&gt; PointCloudTarget;
-        typedef typename PointCloudTarget::Ptr PointCloudTargetPtr;
-        typedef typename PointCloudTarget::ConstPtr PointCloudTargetConstPtr;
-
-        typedef typename KdTree::PointRepresentationConstPtr PointRepresentationConstPtr;
-
-        /** \brief Empty constructor. */
-        CorrespondenceEstimationBase () 
-          : corr_name_ ("CorrespondenceEstimationBase")
-          , tree_ (new pcl::search::KdTree&lt;PointTarget&gt;)
-          , tree_reciprocal_ (new pcl::search::KdTree&lt;PointSource&gt;)
-          , target_ ()
-          , target_indices_ ()
-          , point_representation_ ()
-          , input_transformed_ ()
-          , input_fields_ ()
-          , target_cloud_updated_ (true)
-          , source_cloud_updated_ (true)
-          , force_no_recompute_ (false)
-          , force_no_recompute_reciprocal_ (false)
-        {
-        }
-      
-        /** \brief Empty destructor */
-        virtual ~CorrespondenceEstimationBase () {}
-
-        /** \brief Provide a pointer to the input source 
-          * (e.g., the point cloud that we want to align to the target)
-          *
-          * \param[in] cloud the input point cloud source
-          */
-        PCL_DEPRECATED ("[pcl::registration::CorrespondenceEstimationBase::setInputCloud] setInputCloud is deprecated. Please use setInputSource instead.")
-        void
-        setInputCloud (const PointCloudSourceConstPtr &amp;cloud);
-
-        /** \brief Get a pointer to the input point cloud dataset target. */
-        PCL_DEPRECATED ("[pcl::registration::CorrespondenceEstimationBase::getInputCloud] getInputCloud is deprecated. Please use getInputSource instead.")
-        PointCloudSourceConstPtr const
-        getInputCloud ();
-
-        /** \brief Provide a pointer to the input source 
-          * (e.g., the point cloud that we want to align to the target)
-          *
-          * \param[in] cloud the input point cloud source
-          */
-        inline void 
-        setInputSource (const PointCloudSourceConstPtr &amp;cloud)
-        {
-          source_cloud_updated_ = true;
-          PCLBase&lt;PointSource&gt;::setInputCloud (cloud);
-          pcl::getFields (*cloud, input_fields_);
-        }
-
-        /** \brief Get a pointer to the input point cloud dataset target. */
-        inline PointCloudSourceConstPtr const 
-        getInputSource () 
-        { 
-          return (input_ ); 
-        }
-
-        /** \brief Provide a pointer to the input target 
-          * (e.g., the point cloud that we want to align the input source to)
-          * \param[in] cloud the input point cloud target
-          */
-        inline void 
-        setInputTarget (const PointCloudTargetConstPtr &amp;cloud);
-
-        /** \brief Get a pointer to the input point cloud dataset target. */
-        inline PointCloudTargetConstPtr const 
-        getInputTarget () { return (target_ ); }
-
-
-        /** \brief See if this rejector requires source normals */
-        virtual bool
-        requiresSourceNormals () const
-        { return (false); }
-
-        /** \brief Abstract method for setting the source normals */
-        virtual void
-        setSourceNormals (pcl::PCLPointCloud2::ConstPtr /*cloud2*/)
-        {
-          PCL_WARN ("[pcl::registration::%s::setSourceNormals] This class does not require input source normals", getClassName ().c_str ());
-        }
-        
-        /** \brief See if this rejector requires target normals */
-        virtual bool
-        requiresTargetNormals () const
-        { return (false); }
-
-        /** \brief Abstract method for setting the target normals */
-        virtual void
-        setTargetNormals (pcl::PCLPointCloud2::ConstPtr /*cloud2*/)
-        {
-          PCL_WARN ("[pcl::registration::%s::setTargetNormals] This class does not require input target normals", getClassName ().c_str ());
-        }
-
-        /** \brief Provide a pointer to the vector of indices that represent the 
-          * input source point cloud.
-          * \param[in] indices a pointer to the vector of indices 
-          */
-        inline void
-        setIndicesSource (const IndicesPtr &amp;indices)
-        {
-          setIndices (indices);
-        }
-
-        /** \brief Get a pointer to the vector of indices used for the source dataset. */
-        inline IndicesPtr const 
-        getIndicesSource () { return (indices_); }
-
-        /** \brief Provide a pointer to the vector of indices that represent the input target point cloud.
-          * \param[in] indices a pointer to the vector of indices 
-          */
-        inline void
-        setIndicesTarget (const IndicesPtr &amp;indices)
-        {
-          target_cloud_updated_ = true;
-          target_indices_ = indices;
-        }
-
-        /** \brief Get a pointer to the vector of indices used for the target dataset. */
-        inline IndicesPtr const 
-        getIndicesTarget () { return (target_indices_); }
-
-        /** \brief Provide a pointer to the search object used to find correspondences in
-          * the target cloud.
-          * \param[in] tree a pointer to the spatial search object.
-          * \param[in] force_no_recompute If set to true, this tree will NEVER be 
-          * recomputed, regardless of calls to setInputTarget. Only use if you are 
-          * confident that the tree will be set correctly.
-          */
-        inline void
-        setSearchMethodTarget (const KdTreePtr &amp;tree, 
-                               bool force_no_recompute = false) 
-        { 
-          tree_ = tree; 
-          if (force_no_recompute)
-          {
-            force_no_recompute_ = true;
-          }
-          // Since we just set a new tree, we need to check for updates
-          target_cloud_updated_ = true;
-        }
-
-        /** \brief Get a pointer to the search method used to find correspondences in the
-          * target cloud. */
-        inline KdTreePtr
-        getSearchMethodTarget () const
-        {
-          return (tree_);
-        }
-
-        /** \brief Provide a pointer to the search object used to find correspondences in
-          * the source cloud (usually used by reciprocal correspondence finding).
-          * \param[in] tree a pointer to the spatial search object.
-          * \param[in] force_no_recompute If set to true, this tree will NEVER be 
-          * recomputed, regardless of calls to setInputSource. Only use if you are 
-          * extremely confident that the tree will be set correctly.
-          */
-        inline void
-        setSearchMethodSource (const KdTreeReciprocalPtr &amp;tree, 
-                               bool force_no_recompute = false) 
-        { 
-          tree_reciprocal_ = tree; 
-          if ( force_no_recompute )
-          {
-            force_no_recompute_reciprocal_ = true;
-          }
-          // Since we just set a new tree, we need to check for updates
-          source_cloud_updated_ = true;
-        }
-
-        /** \brief Get a pointer to the search method used to find correspondences in the
-          * source cloud. */
-        inline KdTreeReciprocalPtr
-        getSearchMethodSource () const
-        {
-          return (tree_reciprocal_);
-        }
-
-        /** \brief Determine the correspondences between input and target cloud.
-          * \param[out] correspondences the found correspondences (index of query point, index of target point, distance)
-          * \param[in] max_distance maximum allowed distance between correspondences
-          */
-        virtual void 
-        determineCorrespondences (pcl::Correspondences &amp;correspondences,
-                                  double max_distance = std::numeric_limits&lt;double&gt;::max ()) = 0;
-
-        /** \brief Determine the reciprocal correspondences between input and target cloud.
-          * A correspondence is considered reciprocal if both Src_i has Tgt_i as a 
-          * correspondence, and Tgt_i has Src_i as one.
-          *
-          * \param[out] correspondences the found correspondences (index of query and target point, distance)
-          * \param[in] max_distance maximum allowed distance between correspondences
-          */
-        virtual void 
-        determineReciprocalCorrespondences (pcl::Correspondences &amp;correspondences,
-                                            double max_distance = std::numeric_limits&lt;double&gt;::max ()) = 0;
-
-        /** \brief Provide a boost shared pointer to the PointRepresentation to be used 
-          * when searching for nearest neighbors.
-          *
-          * \param[in] point_representation the PointRepresentation to be used by the 
-          * k-D tree for nearest neighbor search
-          */
-        inline void
-        setPointRepresentation (const PointRepresentationConstPtr &amp;point_representation)
-        {
-          point_representation_ = point_representation;
-        }
-
-        /** \brief Clone and cast to CorrespondenceEstimationBase */
-        virtual boost::shared_ptr&lt; CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt; &gt; clone () const = 0;
-
-      protected:
-        /** \brief The correspondence estimation method name. */
-        std::string corr_name_;
-
-        /** \brief A pointer to the spatial search object used for the target dataset. */
-        KdTreePtr tree_;
-
-        /** \brief A pointer to the spatial search object used for the source dataset. */
-        KdTreeReciprocalPtr tree_reciprocal_;
-
-
-        
-        /** \brief The input point cloud dataset target. */
-        PointCloudTargetConstPtr target_;
-
-        /** \brief The target point cloud dataset indices. */
-        IndicesPtr target_indices_;
-
-        /** \brief The point representation used (internal). */
-        PointRepresentationConstPtr point_representation_;
-
-        /** \brief The transformed input source point cloud dataset. */
-        PointCloudTargetPtr input_transformed_;
-
-        /** \brief The types of input point fields available. */
-        std::vector&lt;pcl::PCLPointField&gt; input_fields_;
-
-        /** \brief Abstract class get name method. */
-        inline const std::string&amp; 
-        getClassName () const { return (corr_name_); }
-
-        /** \brief Internal computation initalization. */
-        bool
-        initCompute ();
-        
-        /** \brief Internal computation initalization for reciprocal correspondences. */
-        bool
-        initComputeReciprocal ();
-
-        /** \brief Variable that stores whether we have a new target cloud, meaning we need to pre-process it again.
-         * This way, we avoid rebuilding the kd-tree for the target cloud every time the determineCorrespondences () method
-         * is called. */
-        bool target_cloud_updated_;
-        /** \brief Variable that stores whether we have a new source cloud, meaning we need to pre-process it again.
-         * This way, we avoid rebuilding the reciprocal kd-tree for the source cloud every time the determineCorrespondences () method
-         * is called. */
-        bool source_cloud_updated_;
-        /** \brief A flag which, if set, means the tree operating on the target cloud 
-         * will never be recomputed*/
-        bool force_no_recompute_;
-        
-        /** \brief A flag which, if set, means the tree operating on the source cloud 
-         * will never be recomputed*/
-        bool force_no_recompute_reciprocal_;
-
-     };
-
-    /** \brief @b CorrespondenceEstimation represents the base class for
-      * determining correspondences between target and query point
-      * sets/features.
-      *
-      * Code example:
-      *
-      * \code
-      * pcl::PointCloud&lt;pcl::PointXYZRGBA&gt;::Ptr source, target;
-      * // ... read or fill in source and target
-      * pcl::CorrespondenceEstimation&lt;pcl::PointXYZ, pcl::PointXYZ&gt; est;
-      * est.setInputSource (source);
-      * est.setInputTarget (target);
-      *
-      * pcl::Correspondences all_correspondences;
-      * // Determine all reciprocal correspondences
-      * est.determineReciprocalCorrespondences (all_correspondences);
-      * \endcode
-      *
-      * \author Radu B. Rusu, Michael Dixon, Dirk Holz
-      * \ingroup registration
-      */
-    template &lt;typename PointSource, typename PointTarget, typename Scalar = float&gt;
-    class CorrespondenceEstimation : public CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;
-    {
-      public:
-        typedef boost::shared_ptr&lt;CorrespondenceEstimation&lt;PointSource, PointTarget, Scalar&gt; &gt; Ptr;
-        typedef boost::shared_ptr&lt;const CorrespondenceEstimation&lt;PointSource, PointTarget, Scalar&gt; &gt; ConstPtr;
-
-        using CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::point_representation_;
-        using CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::input_transformed_;
-        using CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::tree_;
-        using CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::tree_reciprocal_;
-        using CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::target_;
-        using CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::corr_name_;
-        using CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::target_indices_;
-        using CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::getClassName;
-        using CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::initCompute;
-        using CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::initComputeReciprocal;
-        using CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::input_;
-        using CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::indices_;
-        using CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::input_fields_;
-        using PCLBase&lt;PointSource&gt;::deinitCompute;
-
-        typedef pcl::search::KdTree&lt;PointTarget&gt; KdTree;
-        typedef typename pcl::search::KdTree&lt;PointTarget&gt;::Ptr KdTreePtr;
-
-        typedef pcl::PointCloud&lt;PointSource&gt; PointCloudSource;
-        typedef typename PointCloudSource::Ptr PointCloudSourcePtr;
-        typedef typename PointCloudSource::ConstPtr PointCloudSourceConstPtr;
-
-        typedef pcl::PointCloud&lt;PointTarget&gt; PointCloudTarget;
-        typedef typename PointCloudTarget::Ptr PointCloudTargetPtr;
-        typedef typename PointCloudTarget::ConstPtr PointCloudTargetConstPtr;
-
-        typedef typename KdTree::PointRepresentationConstPtr PointRepresentationConstPtr;
-
-        /** \brief Empty constructor. */
-        CorrespondenceEstimation () 
-        {
-          corr_name_  = "CorrespondenceEstimation";
-        }
-      
-        /** \brief Empty destructor */
-        virtual ~CorrespondenceEstimation () {}
-
-        /** \brief Determine the correspondences between input and target cloud.
-          * \param[out] correspondences the found correspondences (index of query point, index of target point, distance)
-          * \param[in] max_distance maximum allowed distance between correspondences
-          */
-        virtual void 
-        determineCorrespondences (pcl::Correspondences &amp;correspondences,
-                                  double max_distance = std::numeric_limits&lt;double&gt;::max ());
-
-        /** \brief Determine the reciprocal correspondences between input and target cloud.
-          * A correspondence is considered reciprocal if both Src_i has Tgt_i as a 
-          * correspondence, and Tgt_i has Src_i as one.
-          *
-          * \param[out] correspondences the found correspondences (index of query and target point, distance)
-          * \param[in] max_distance maximum allowed distance between correspondences
-          */
-        virtual void 
-        determineReciprocalCorrespondences (pcl::Correspondences &amp;correspondences,
-                                            double max_distance = std::numeric_limits&lt;double&gt;::max ());
-
-        
-        /** \brief Clone and cast to CorrespondenceEstimationBase */
-        virtual boost::shared_ptr&lt; CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt; &gt; 
-        clone () const
-        {
-          Ptr copy (new CorrespondenceEstimation&lt;PointSource, PointTarget, Scalar&gt; (*this));
-          return (copy);
-        }
-     };
-  }
-}
-
-//#include &lt;pcl/registration/impl/correspondence_estimation.hpp&gt;
-#include "fast_pcl/registration/impl/correspondence_estimation.hpp"
-
-#endif /* FAST_PCL_REGISTRATION_CORRESPONDENCE_ESTIMATION_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\correspondence_rejection.h" new_path="" added_lines="0" deleted_lines="426">
				<diff>@@ -1,426 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#ifndef FAST_PCL_REGISTRATION_CORRESPONDENCE_REJECTION_H_
-#define FAST_PCL_REGISTRATION_CORRESPONDENCE_REJECTION_H_
-
-//#include &lt;pcl/registration/correspondence_types.h&gt;
-//#include &lt;pcl/registration/correspondence_sorting.h&gt;
-#include "fast_pcl/registration/correspondence_types.h"
-#include "fast_pcl/registration/correspondence_sorting.h"
-#include &lt;pcl/console/print.h&gt;
-#include &lt;pcl/common/transforms.h&gt;
-#include &lt;pcl/point_cloud.h&gt;
-#include &lt;pcl/search/kdtree.h&gt;
-
-namespace pcl
-{
-  namespace registration
-  {
-    /** @b CorrespondenceRejector represents the base class for correspondence rejection methods
-      * \author Dirk Holz
-      * \ingroup registration
-      */
-    class CorrespondenceRejector
-    {
-      public:
-        typedef boost::shared_ptr&lt;CorrespondenceRejector&gt; Ptr;
-        typedef boost::shared_ptr&lt;const CorrespondenceRejector&gt; ConstPtr;
-
-        /** \brief Empty constructor. */
-        CorrespondenceRejector () 
-          : rejection_name_ ()
-          , input_correspondences_ () 
-        {}
-
-        /** \brief Empty destructor. */
-        virtual ~CorrespondenceRejector () {}
-
-        /** \brief Provide a pointer to the vector of the input correspondences.
-          * \param[in] correspondences the const boost shared pointer to a correspondence vector
-          */
-        virtual inline void 
-        setInputCorrespondences (const CorrespondencesConstPtr &amp;correspondences) 
-        { 
-          input_correspondences_ = correspondences; 
-        };
-
-        /** \brief Get a pointer to the vector of the input correspondences.
-          * \return correspondences the const boost shared pointer to a correspondence vector
-          */
-        inline CorrespondencesConstPtr 
-        getInputCorrespondences () { return input_correspondences_; };
-
-        /** \brief Run correspondence rejection
-          * \param[out] correspondences Vector of correspondences that have not been rejected.
-          */
-        inline void 
-        getCorrespondences (pcl::Correspondences &amp;correspondences)
-        {
-          if (!input_correspondences_ || (input_correspondences_-&gt;empty ()))
-            return;
-
-          applyRejection (correspondences);
-        }
-
-        /** \brief Get a list of valid correspondences after rejection from the original set of correspondences.
-          * Pure virtual. Compared to \a getCorrespondences this function is
-          * stateless, i.e., input correspondences do not need to be provided beforehand,
-          * but are directly provided in the function call.
-          * \param[in] original_correspondences the set of initial correspondences given
-          * \param[out] remaining_correspondences the resultant filtered set of remaining correspondences
-          */
-        virtual inline void 
-        getRemainingCorrespondences (const pcl::Correspondences&amp; original_correspondences, 
-                                     pcl::Correspondences&amp; remaining_correspondences) = 0;
-
-        /** \brief Determine the indices of query points of
-          * correspondences that have been rejected, i.e., the difference
-          * between the input correspondences (set via \a setInputCorrespondences)
-          * and the given correspondence vector.
-          * \param[in] correspondences Vector of correspondences after rejection
-          * \param[out] indices Vector of query point indices of those correspondences
-          * that have been rejected.
-          */
-        inline void 
-        getRejectedQueryIndices (const pcl::Correspondences &amp;correspondences, 
-                                 std::vector&lt;int&gt;&amp; indices)
-        {
-          if (!input_correspondences_ || input_correspondences_-&gt;empty ())
-          {
-            PCL_WARN ("[pcl::registration::%s::getRejectedQueryIndices] Input correspondences not set (lookup of rejected correspondences _not_ possible).\n", getClassName ().c_str ());
-            return;
-          }
-
-          pcl::getRejectedQueryIndices(*input_correspondences_, correspondences, indices);
-        }
-
-        /** \brief Get a string representation of the name of this class. */
-        inline const std::string&amp; 
-        getClassName () const { return (rejection_name_); }
-
-
-        /** \brief See if this rejector requires source points */
-        virtual bool
-        requiresSourcePoints () const
-        { return (false); }
-
-        /** \brief Abstract method for setting the source cloud */
-        virtual void
-        setSourcePoints (pcl::PCLPointCloud2::ConstPtr /*cloud2*/)
-        {
-          PCL_WARN ("[pcl::registration::%s::setSourcePoints] This class does not require an input source cloud", getClassName ().c_str ());
-        }
-        
-        /** \brief See if this rejector requires source normals */
-        virtual bool
-        requiresSourceNormals () const
-        { return (false); }
-
-        /** \brief Abstract method for setting the source normals */
-        virtual void
-        setSourceNormals (pcl::PCLPointCloud2::ConstPtr /*cloud2*/)
-        { 
-          PCL_WARN ("[pcl::registration::%s::setSourceNormals] This class does not require input source normals", getClassName ().c_str ());
-        }
-        /** \brief See if this rejector requires a target cloud */
-        virtual bool
-        requiresTargetPoints () const
-        { return (false); }
-
-        /** \brief Abstract method for setting the target cloud */
-        virtual void
-        setTargetPoints (pcl::PCLPointCloud2::ConstPtr /*cloud2*/)
-        {
-          PCL_WARN ("[pcl::registration::%s::setTargetPoints] This class does not require an input target cloud", getClassName ().c_str ());
-        }
-        
-        /** \brief See if this rejector requires target normals */
-        virtual bool
-        requiresTargetNormals () const
-        { return (false); }
-
-        /** \brief Abstract method for setting the target normals */
-        virtual void
-        setTargetNormals (pcl::PCLPointCloud2::ConstPtr /*cloud2*/)
-        {
-          PCL_WARN ("[pcl::registration::%s::setTargetNormals] This class does not require input target normals", getClassName ().c_str ());
-        }
-
-      protected:
-
-        /** \brief The name of the rejection method. */
-        std::string rejection_name_;
-
-        /** \brief The input correspondences. */
-        CorrespondencesConstPtr input_correspondences_;
-
-        /** \brief Abstract rejection method. */
-        virtual void 
-        applyRejection (Correspondences &amp;correspondences) = 0;
-    };
-
-    /** @b DataContainerInterface provides a generic interface for computing correspondence scores between correspondent
-      * points in the input and target clouds
-      * \ingroup registration
-      */
-    class DataContainerInterface
-    {
-      public:
-        virtual ~DataContainerInterface () {}
-        virtual double getCorrespondenceScore (int index) = 0;
-        virtual double getCorrespondenceScore (const pcl::Correspondence &amp;) = 0;
-     };
-
-    /** @b DataContainer is a container for the input and target point clouds and implements the interface 
-      * to compute correspondence scores between correspondent points in the input and target clouds
-      * \ingroup registration
-      */
-    template &lt;typename PointT, typename NormalT = pcl::PointNormal&gt;
-    class DataContainer : public DataContainerInterface
-    {
-      typedef pcl::PointCloud&lt;PointT&gt; PointCloud;
-      typedef typename PointCloud::Ptr PointCloudPtr;
-      typedef typename PointCloud::ConstPtr PointCloudConstPtr;
-
-      typedef typename pcl::search::KdTree&lt;PointT&gt;::Ptr KdTreePtr;
-      
-      typedef pcl::PointCloud&lt;NormalT&gt; Normals;
-      typedef typename Normals::Ptr NormalsPtr;
-      typedef typename Normals::ConstPtr NormalsConstPtr;
-
-      public:
-
-        /** \brief Empty constructor. */
-        DataContainer (bool needs_normals = false) 
-          : input_ ()
-          , input_transformed_ ()
-          , target_ ()
-          , input_normals_ ()
-          , input_normals_transformed_ ()
-          , target_normals_ ()
-          , tree_ (new pcl::search::KdTree&lt;PointT&gt;)
-          , class_name_ ("DataContainer")
-          , needs_normals_ (needs_normals)
-          , target_cloud_updated_ (true)
-          , force_no_recompute_ (false)
-        {
-        }
-      
-        /** \brief Empty destructor */
-        virtual ~DataContainer () {}
-
-        /** \brief Provide a source point cloud dataset (must contain XYZ
-          * data!), used to compute the correspondence distance.  
-          * \param[in] cloud a cloud containing XYZ data
-          */
-        PCL_DEPRECATED ("[pcl::registration::DataContainer::setInputCloud] setInputCloud is deprecated. Please use setInputSource instead.")
-        void
-        setInputCloud (const PointCloudConstPtr &amp;cloud);
-
-        /** \brief Get a pointer to the input point cloud dataset target. */
-        PCL_DEPRECATED ("[pcl::registration::DataContainer::getInputCloud] getInputCloud is deprecated. Please use getInputSource instead.")
-        PointCloudConstPtr const
-        getInputCloud ();
-
-        /** \brief Provide a source point cloud dataset (must contain XYZ
-          * data!), used to compute the correspondence distance.  
-          * \param[in] cloud a cloud containing XYZ data
-          */
-        inline void 
-        setInputSource (const PointCloudConstPtr &amp;cloud)
-        {
-          input_ = cloud;
-        }
-
-        /** \brief Get a pointer to the input point cloud dataset target. */
-        inline PointCloudConstPtr const 
-        getInputSource () { return (input_); }
-
-        /** \brief Provide a target point cloud dataset (must contain XYZ
-          * data!), used to compute the correspondence distance.  
-          * \param[in] target a cloud containing XYZ data
-          */
-        inline void 
-        setInputTarget (const PointCloudConstPtr &amp;target)
-        {
-          target_ = target;
-          target_cloud_updated_ = true;
-        }
-
-        /** \brief Get a pointer to the input point cloud dataset target. */
-        inline PointCloudConstPtr const 
-        getInputTarget () { return (target_); }
-        
-        /** \brief Provide a pointer to the search object used to find correspondences in
-          * the target cloud.
-          * \param[in] tree a pointer to the spatial search object.
-          * \param[in] force_no_recompute If set to true, this tree will NEVER be 
-          * recomputed, regardless of calls to setInputTarget. Only use if you are 
-          * confident that the tree will be set correctly.
-          */
-        inline void
-        setSearchMethodTarget (const KdTreePtr &amp;tree, 
-                               bool force_no_recompute = false) 
-        { 
-          tree_ = tree; 
-          if (force_no_recompute)
-          {
-            force_no_recompute_ = true;
-          }
-          target_cloud_updated_ = true;
-        }
-
-        /** \brief Set the normals computed on the input point cloud
-          * \param[in] normals the normals computed for the input cloud
-          */
-        inline void
-        setInputNormals (const NormalsConstPtr &amp;normals) { input_normals_ = normals; }
-
-        /** \brief Get the normals computed on the input point cloud */
-        inline NormalsConstPtr
-        getInputNormals () { return (input_normals_); }
-
-        /** \brief Set the normals computed on the target point cloud
-          * \param[in] normals the normals computed for the input cloud
-          */
-        inline void
-        setTargetNormals (const NormalsConstPtr &amp;normals) { target_normals_ = normals; }
-        
-        /** \brief Get the normals computed on the target point cloud */
-        inline NormalsConstPtr
-        getTargetNormals () { return (target_normals_); }
-
-        /** \brief Get the correspondence score for a point in the input cloud
-          * \param[in] index index of the point in the input cloud
-          */
-        inline double 
-        getCorrespondenceScore (int index)
-        {
-          if ( target_cloud_updated_ &amp;&amp; !force_no_recompute_ )
-          {
-            tree_-&gt;setInputCloud (target_);
-          }
-          std::vector&lt;int&gt; indices (1);
-          std::vector&lt;float&gt; distances (1);
-          if (tree_-&gt;nearestKSearch (input_-&gt;points[index], 1, indices, distances))
-            return (distances[0]);
-          else
-            return (std::numeric_limits&lt;double&gt;::max ());
-        }
-
-        /** \brief Get the correspondence score for a given pair of correspondent points
-          * \param[in] corr Correspondent points
-          */
-        inline double 
-        getCorrespondenceScore (const pcl::Correspondence &amp;corr)
-        {
-          // Get the source and the target feature from the list
-          const PointT &amp;src = input_-&gt;points[corr.index_query];
-          const PointT &amp;tgt = target_-&gt;points[corr.index_match];
-
-          return ((src.getVector4fMap () - tgt.getVector4fMap ()).squaredNorm ());
-        }
-        
-        /** \brief Get the correspondence score for a given pair of correspondent points based on 
-          * the angle betweeen the normals. The normmals for the in put and target clouds must be 
-          * set before using this function
-          * \param[in] corr Correspondent points
-          */
-        inline double
-        getCorrespondenceScoreFromNormals (const pcl::Correspondence &amp;corr)
-        {
-          //assert ( (input_normals_-&gt;points.size () != 0) &amp;&amp; (target_normals_-&gt;points.size () != 0) &amp;&amp; "Normals are not set for the input and target point clouds");
-          assert (input_normals_ &amp;&amp; target_normals_ &amp;&amp; "Normals are not set for the input and target point clouds");
-          const NormalT &amp;src = input_normals_-&gt;points[corr.index_query];
-          const NormalT &amp;tgt = target_normals_-&gt;points[corr.index_match];
-          return (double ((src.normal[0] * tgt.normal[0]) + (src.normal[1] * tgt.normal[1]) + (src.normal[2] * tgt.normal[2])));
-        }
-
-     private:
-        /** \brief The input point cloud dataset */
-        PointCloudConstPtr input_;
-
-        /** \brief The input transformed point cloud dataset */
-        PointCloudPtr input_transformed_;
-
-        /** \brief The target point cloud datase. */
-        PointCloudConstPtr target_;
-
-        /** \brief Normals to the input point cloud */
-        NormalsConstPtr input_normals_;
-
-        /** \brief Normals to the input point cloud */
-        NormalsPtr input_normals_transformed_;
-
-        /** \brief Normals to the target point cloud */
-        NormalsConstPtr target_normals_;
-
-        /** \brief A pointer to the spatial search object. */
-        KdTreePtr tree_;
-
-        /** \brief The name of the rejection method. */
-        std::string class_name_;
-
-        /** \brief Should the current data container use normals? */
-        bool needs_normals_;
-
-        /** \brief Variable that stores whether we have a new target cloud, meaning we need to pre-process it again.
-         * This way, we avoid rebuilding the kd-tree */
-        bool target_cloud_updated_;
-
-        /** \brief A flag which, if set, means the tree operating on the target cloud 
-         * will never be recomputed*/
-        bool force_no_recompute_;
-
-
-
-        /** \brief Get a string representation of the name of this class. */
-        inline const std::string&amp; 
-        getClassName () const { return (class_name_); }
-    };
-  }
-}
-
-      //#include &lt;pcl/registration/impl/correspondence_rejection.hpp&gt;
-#include "fast_pcl/registration/impl/correspondence_rejection.hpp"
-
-#endif /* FAST_PCL_REGISTRATION_CORRESPONDENCE_REJECTION_H_ */
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\correspondence_sorting.h" new_path="" added_lines="0" deleted_lines="129">
				<diff>@@ -1,129 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-#ifndef FAST_PCL_REGISTRATION_CORRESPONDENCE_SORTING_H_
-#define FAST_PCL_REGISTRATION_CORRESPONDENCE_SORTING_H_
-
-#if defined __GNUC__
-#  pragma GCC system_header
-#endif
-
-#include "fast_pcl/registration/correspondence_types.h"
-
-namespace pcl
-{
-  namespace registration
-  {
-    /** @b sortCorrespondencesByQueryIndex : a functor for sorting correspondences by query index
-      * \author Dirk Holz
-      * \ingroup registration
-      */
-    struct sortCorrespondencesByQueryIndex : public std::binary_function&lt;pcl::Correspondence, pcl::Correspondence, bool&gt;
-    {
-      bool
-      operator()( pcl::Correspondence a, pcl::Correspondence b)
-      {
-        return (a.index_query &lt; b.index_query);
-      }
-    };
-
-    /** @b sortCorrespondencesByMatchIndex : a functor for sorting correspondences by match index
-      * \author Dirk Holz
-      * \ingroup registration
-      */
-    struct sortCorrespondencesByMatchIndex : public std::binary_function&lt;pcl::Correspondence, pcl::Correspondence, bool&gt;
-    {
-      bool 
-      operator()( pcl::Correspondence a, pcl::Correspondence b)
-      {
-        return (a.index_match &lt; b.index_match);
-      }
-    };
-
-    /** @b sortCorrespondencesByDistance : a functor for sorting correspondences by distance
-      * \author Dirk Holz
-      * \ingroup registration
-      */
-    struct sortCorrespondencesByDistance : public std::binary_function&lt;pcl::Correspondence, pcl::Correspondence, bool&gt;
-    {
-      bool 
-      operator()( pcl::Correspondence a, pcl::Correspondence b)
-      {
-        return (a.distance &lt; b.distance);
-      }
-    };
-
-    /** @b sortCorrespondencesByQueryIndexAndDistance : a functor for sorting correspondences by query index _and_ distance
-      * \author Dirk Holz
-      * \ingroup registration
-      */
-    struct sortCorrespondencesByQueryIndexAndDistance : public std::binary_function&lt;pcl::Correspondence, pcl::Correspondence, bool&gt;
-    {
-      inline bool 
-      operator()( pcl::Correspondence a, pcl::Correspondence b)
-      {
-        if (a.index_query &lt; b.index_query)
-          return (true);
-        else if ( (a.index_query == b.index_query) &amp;&amp; (a.distance &lt; b.distance) )
-          return (true);
-        return (false);
-      }
-    };
-
-    /** @b sortCorrespondencesByMatchIndexAndDistance : a functor for sorting correspondences by match index _and_ distance
-      * \author Dirk Holz
-      * \ingroup registration
-      */
-    struct sortCorrespondencesByMatchIndexAndDistance : public std::binary_function&lt;pcl::Correspondence, pcl::Correspondence, bool&gt;
-    {
-      inline bool 
-      operator()( pcl::Correspondence a, pcl::Correspondence b)
-      {
-        if (a.index_match &lt; b.index_match)
-          return (true);
-        else if ( (a.index_match == b.index_match) &amp;&amp; (a.distance &lt; b.distance) )
-          return (true);
-        return (false);
-      }
-    };
-
-  }
-}
-
-#endif /* FAST_PCL_REGISTRATION_CORRESPONDENCE_SORTING_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\correspondence_types.h" new_path="" added_lines="0" deleted_lines="80">
				<diff>@@ -1,80 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-#ifndef FAST_PCL_REGISTRATION_CORRESPONDENCE_TYPES_H_
-#define FAST_PCL_REGISTRATION_CORRESPONDENCE_TYPES_H_
-
-#include &lt;pcl/correspondence.h&gt;
-
-namespace pcl
-{
-  namespace registration
-  {
-    /** \brief calculates the mean and standard deviation of descriptor distances from correspondences
-      * \param[in] correspondences list of correspondences
-      * \param[out] mean the mean descriptor distance of correspondences
-      * \param[out] stddev the standard deviation of descriptor distances.
-      * \note The sample varaiance is used to determine the standard deviation
-      */
-    inline void 
-    getCorDistMeanStd (const pcl::Correspondences&amp; correspondences, double &amp;mean, double &amp;stddev);
-
-    /** \brief extracts the query indices
-      * \param[in] correspondences list of correspondences
-      * \param[out] indices array of extracted indices.
-      * \note order of indices corresponds to input list of descriptor correspondences
-      */
-    inline void 
-    getQueryIndices (const pcl::Correspondences&amp; correspondences, std::vector&lt;int&gt;&amp; indices);
-
-    /** \brief extracts the match indices
-      * \param[in] correspondences list of correspondences
-      * \param[out] indices array of extracted indices.
-      * \note order of indices corresponds to input list of descriptor correspondences
-      */
-    inline void 
-    getMatchIndices (const pcl::Correspondences&amp; correspondences, std::vector&lt;int&gt;&amp; indices);
-
-  }
-}
-
-//#include &lt;pcl/registration/impl/correspondence_types.hpp&gt;
-#include "fast_pcl/registration/impl/correspondence_types.hpp"
-
-#endif /* FAST_PCL_REGISTRATION_CORRESPONDENCE_TYPES_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\default_convergence_criteria.h" new_path="" added_lines="0" deleted_lines="284">
				<diff>@@ -1,284 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#ifndef FAST_PCL_REGISTRATION_DEFAULT_CONVERGENCE_CRITERIA_H_
-#define FAST_PCL_REGISTRATION_DEFAULT_CONVERGENCE_CRITERIA_H_
-
-//#include &lt;pcl/registration/eigen.h&gt;
-#include "fast_pcl/registration/eigen.h"
-#include &lt;pcl/correspondence.h&gt;
-//#include &lt;pcl/registration/convergence_criteria.h&gt;
-#include "fast_pcl/registration/convergence_criteria.h"
-
-namespace pcl
-{
-  namespace registration
-  {
-    /** \brief @b DefaultConvergenceCriteria represents an instantiation of
-      * ConvergenceCriteria, and implements the following criteria for registration loop
-      * evaluation:
-      *
-      *  * a maximum number of iterations has been reached
-      *  * the transformation (R, t) cannot be further updated (the difference between current and previous is smaller than a threshold)
-      *  * the Mean Squared Error (MSE) between the current set of correspondences and the previous one is smaller than some threshold (both relative and absolute tests)
-      *
-      * \note Convergence is considered reached if ANY of the above criteria are met.
-      *
-      * \author Radu B. Rusu
-      * \ingroup registration
-      */
-    template &lt;typename Scalar = float&gt;
-    class DefaultConvergenceCriteria : public ConvergenceCriteria
-    {
-      public:
-        typedef boost::shared_ptr&lt;DefaultConvergenceCriteria&lt;Scalar&gt; &gt; Ptr;
-        typedef boost::shared_ptr&lt;const DefaultConvergenceCriteria&lt;Scalar&gt; &gt; ConstPtr;
-
-        typedef Eigen::Matrix&lt;Scalar, 4, 4&gt; Matrix4;
-
-        enum ConvergenceState
-        {
-          CONVERGENCE_CRITERIA_NOT_CONVERGED,
-          CONVERGENCE_CRITERIA_ITERATIONS,
-          CONVERGENCE_CRITERIA_TRANSFORM,
-          CONVERGENCE_CRITERIA_ABS_MSE,
-          CONVERGENCE_CRITERIA_REL_MSE,
-          CONVERGENCE_CRITERIA_NO_CORRESPONDENCES
-        };
-
-        /** \brief Empty constructor.
-          * Sets:
-          *  * the maximum number of iterations to 1000
-          *  * the rotation threshold to 0.256 degrees (0.99999)
-          *  * the translation threshold to 0.0003 meters (3e-4^2)
-          *  * the MSE relative / absolute thresholds to 0.001% and 1e-12
-          *
-          * \param[in] iterations a reference to the number of iterations the loop has ran so far
-          * \param[in] transform a reference to the current transformation obtained by the transformation evaluation
-          * \param[in] correspondences a reference to the current set of point correspondences between source and target
-          */
-        DefaultConvergenceCriteria (const int &amp;iterations, const Matrix4 &amp;transform, const pcl::Correspondences &amp;correspondences)
-          : iterations_ (iterations)
-          , transformation_ (transform)
-          , correspondences_ (correspondences)
-          , correspondences_prev_mse_ (std::numeric_limits&lt;double&gt;::max ())
-          , correspondences_cur_mse_ (std::numeric_limits&lt;double&gt;::max ())
-          , max_iterations_ (100)                 // 100 iterations
-          , failure_after_max_iter_ (false)
-          , rotation_threshold_ (0.99999)         // 0.256 degrees
-          , translation_threshold_ (3e-4 * 3e-4)  // 0.0003 meters
-          , mse_threshold_relative_ (0.00001)     // 0.001% of the previous MSE (relative error)
-          , mse_threshold_absolute_ (1e-12)       // MSE (absolute error)
-          , iterations_similar_transforms_ (0)
-          , max_iterations_similar_transforms_ (0)
-          , convergence_state_ (CONVERGENCE_CRITERIA_NOT_CONVERGED)
-        {
-        }
-      
-        /** \brief Empty destructor */
-        virtual ~DefaultConvergenceCriteria () {}
-
-        /** \brief Set the maximum number of iterations that the internal rotation, 
-          * translation, and MSE differences are allowed to be similar. 
-          * \param[in] nr_iterations the maximum number of iterations 
-          */
-        inline void
-        setMaximumIterationsSimilarTransforms (const int nr_iterations) { max_iterations_similar_transforms_ = nr_iterations; }
-
-        /** \brief Get the maximum number of iterations that the internal rotation, 
-          * translation, and MSE differences are allowed to be similar, as set by the user.
-          */
-        inline int
-        getMaximumIterationsSimilarTransforms () const { return (max_iterations_similar_transforms_); }
-
-        /** \brief Set the maximum number of iterations the internal optimization should run for.
-          * \param[in] nr_iterations the maximum number of iterations the internal optimization should run for
-          */
-        inline void
-        setMaximumIterations (const int nr_iterations) { max_iterations_ = nr_iterations; }
-
-        /** \brief Get the maximum number of iterations the internal optimization should run for, as set by the user. */
-        inline int
-        getMaximumIterations () const { return (max_iterations_); }
-
-        /** \brief Specifies if the registration fails or converges when the maximum number of iterations is reached.
-          * \param[in] failure_after_max_iter If true, the registration fails. If false, the registration is assumed to have converged.
-          */
-        inline void
-        setFailureAfterMaximumIterations (const bool failure_after_max_iter) { failure_after_max_iter_ = failure_after_max_iter; }
-
-        /** \brief Get whether the registration will fail or converge when the maximum number of iterations is reached. */
-        inline bool
-        getFailureAfterMaximumIterations () const { return (failure_after_max_iter_); }
-
-        /** \brief Set the rotation threshold cosine angle (maximum allowable difference between two consecutive transformations) in order for an optimization to be considered as having converged to the final solution.
-          * \param[in] threshold the rotation threshold in order for an optimization to be considered as having converged to the final solution.
-          */
-        inline void
-        setRotationThreshold (const double threshold) { rotation_threshold_ = threshold; }
-
-        /** \brief Get the rotation threshold cosine angle (maximum allowable difference between two consecutive transformations) as set by the user.
-          */
-        inline double
-        getRotationThreshold () const { return (rotation_threshold_); }
-
-        /** \brief Set the translation threshold (maximum allowable difference between two consecutive transformations) in order for an optimization to be considered as having converged to the final solution.
-          * \param[in] threshold the translation threshold in order for an optimization to be considered as having converged to the final solution.
-          */
-        inline void
-        setTranslationThreshold (const double threshold) { translation_threshold_ = threshold; }
-
-        /** \brief Get the rotation threshold cosine angle (maximum allowable difference between two consecutive transformations) as set by the user.
-          */
-        inline double
-        getTranslationThreshold () const { return (translation_threshold_); }
-
-        /** \brief Set the relative MSE between two consecutive sets of correspondences.
-          * \param[in] mse_relative the relative MSE threshold
-          */
-        inline void
-        setRelativeMSE (const double mse_relative) { mse_threshold_relative_ = mse_relative; }
-
-        /** \brief Get the relative MSE between two consecutive sets of correspondences. */
-        inline double
-        getRelativeMSE () const { return (mse_threshold_relative_); }
-
-        /** \brief Set the absolute MSE between two consecutive sets of correspondences.
-          * \param[in] mse_absolute the relative MSE threshold
-          */
-        inline void
-        setAbsoluteMSE (const double mse_absolute) { mse_threshold_absolute_ = mse_absolute; }
-
-        /** \brief Get the absolute MSE between two consecutive sets of correspondences. */
-        inline double
-        getAbsoluteMSE () const { return (mse_threshold_absolute_); }
-
-
-        /** \brief Check if convergence has been reached. */
-        virtual bool
-        hasConverged ();
-
-        /** \brief Return the convergence state after hasConverged () */
-        ConvergenceState
-        getConvergenceState ()
-        {
-          return (convergence_state_);
-        }
-
-        /** \brief Sets the convergence state externally (for example, when ICP does not find
-         * enough correspondences to estimate a transformation, the function is called setting
-         * the convergence state to ConvergenceState::CONVERGENCE_CRITERIA_NO_CORRESPONDENCES)
-         * \param[in] c the convergence state
-         */
-        inline void
-        setConvergenceState(ConvergenceState c)
-        {
-          convergence_state_ = c;
-        }
-
-      protected:
-
-        /** \brief Calculate the mean squared error (MSE) of the distance for a given set of correspondences.
-          * \param[in] correspondences the given set of correspondences
-          */
-        inline double
-        calculateMSE (const pcl::Correspondences &amp;correspondences) const
-        {
-          double mse = 0;
-          for (size_t i = 0; i &lt; correspondences.size (); ++i)
-            mse += correspondences[i].distance;
-          mse /= double (correspondences.size ());
-          return (mse);
-        }
-
-        /** \brief The number of iterations done by the registration loop so far. */
-        const int &amp;iterations_;
-
-        /** \brief The current transformation obtained by the transformation estimation method. */
-        const Matrix4 &amp;transformation_;
-
-        /** \brief The current set of point correspondences between the source and the target. */
-        const pcl::Correspondences &amp;correspondences_;
-
-        /** \brief The MSE for the previous set of correspondences. */
-        double correspondences_prev_mse_;
-
-        /** \brief The MSE for the current set of correspondences. */
-        double correspondences_cur_mse_;
-
-        /** \brief The maximum nuyyGmber of iterations that the registration loop is to be executed. */
-        int max_iterations_;
-
-        /** \brief Specifys if the registration fails or converges when the maximum number of iterations is reached. */
-        bool failure_after_max_iter_;
-
-        /** \brief The rotation threshold is the relative rotation between two iterations (as angle cosine). */
-        double rotation_threshold_;
-
-        /** \brief The translation threshold is the relative translation between two iterations (0 if no translation). */
-        double translation_threshold_;
-
-        /** \brief The relative change from the previous MSE for the current set of correspondences, e.g. .1 means 10% change. */
-        double mse_threshold_relative_;
-
-        /** \brief The absolute change from the previous MSE for the current set of correspondences. */
-        double mse_threshold_absolute_;
-
-        /** \brief Internal counter for the number of iterations that the internal 
-          * rotation, translation, and MSE differences are allowed to be similar. */
-        int iterations_similar_transforms_;
-
-        /** \brief The maximum number of iterations that the internal rotation, 
-          * translation, and MSE differences are allowed to be similar. */
-        int max_iterations_similar_transforms_;
-
-        /** \brief The state of the convergence (e.g., why did the registration converge). */
-        ConvergenceState convergence_state_;
-
-      public:
-        EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-     };
-  }
-}
-
-//#include &lt;pcl/registration/impl/default_convergence_criteria.hpp&gt;
-#include "fast_pcl/registration/impl/default_convergence_criteria.hpp"
-
-#endif    // FAST_PCL_REGISTRATION_DEFAULT_CONVERGENCE_CRITERIA_H_
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\distances.h" new_path="" added_lines="0" deleted_lines="146">
				<diff>@@ -1,146 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-#ifndef FAST_PCL_REGISTRATION_DISTANCES_H
-#define FAST_PCL_REGISTRATION_DISTANCES_H
-
-//#include &lt;pcl/registration/eigen.h&gt;
-#include "fast_pcl/registration/eigen.h"
-#include &lt;vector&gt;
-
-namespace pcl
-{
-  namespace distances
-  {
-
-    /** \brief Compute the median value from a set of doubles
-      * \param[in] fvec the set of doubles
-      * \param[in] m the number of doubles in the set
-      */
-    inline double 
-    computeMedian (double *fvec, int m)
-    {
-      // Copy the values to vectors for faster sorting
-      std::vector&lt;double&gt; data (m);
-      memcpy (&amp;data[0], fvec, sizeof (double) * m);
-      
-      std::nth_element(data.begin(), data.begin() + (data.size () &gt;&gt; 1), data.end());
-      return (data[data.size () &gt;&gt; 1]);
-    }
-
-    /** \brief Use a Huber kernel to estimate the distance between two vectors
-      * \param[in] p_src the first eigen vector
-      * \param[in] p_tgt the second eigen vector
-      * \param[in] sigma the sigma value
-      */
-    inline double
-    huber (const Eigen::Vector4f &amp;p_src, const Eigen::Vector4f &amp;p_tgt, double sigma) 
-    {
-      Eigen::Array4f diff = (p_tgt.array () - p_src.array ()).abs ();
-      double norm = 0.0;
-      for (int i = 0; i &lt; 3; ++i)
-      {
-        if (diff[i] &lt; sigma)
-          norm += diff[i] * diff[i];
-        else
-          norm += 2.0 * sigma * diff[i] - sigma * sigma;
-      }
-      return (norm);
-    }
-
-    /** \brief Use a Huber kernel to estimate the distance between two vectors
-      * \param[in] diff the norm difference between two vectors
-      * \param[in] sigma the sigma value
-      */
-    inline double
-    huber (double diff, double sigma) 
-    {
-      double norm = 0.0;
-      if (diff &lt; sigma)
-        norm += diff * diff;
-      else
-        norm += 2.0 * sigma * diff - sigma * sigma;
-      return (norm);
-    }
-
-    /** \brief Use a Gedikli kernel to estimate the distance between two vectors
-      * (for more information, see 
-      * \param[in] val the norm difference between two vectors
-      * \param[in] clipping the clipping value
-      * \param[in] slope the slope. Default: 4
-      */
-    inline double
-    gedikli (double val, double clipping, double slope = 4) 
-    {
-      return (1.0 / (1.0 + pow (fabs(val) / clipping, slope)));
-    }
-
-    /** \brief Compute the Manhattan distance between two eigen vectors.
-      * \param[in] p_src the first eigen vector
-      * \param[in] p_tgt the second eigen vector
-      */
-    inline double
-    l1 (const Eigen::Vector4f &amp;p_src, const Eigen::Vector4f &amp;p_tgt) 
-    {
-      return ((p_src.array () - p_tgt.array ()).abs ().sum ());
-    }
-
-    /** \brief Compute the Euclidean distance between two eigen vectors.
-      * \param[in] p_src the first eigen vector
-      * \param[in] p_tgt the second eigen vector
-      */
-    inline double
-    l2 (const Eigen::Vector4f &amp;p_src, const Eigen::Vector4f &amp;p_tgt) 
-    {
-      return ((p_src - p_tgt).norm ());
-    }
-
-    /** \brief Compute the squared Euclidean distance between two eigen vectors.
-      * \param[in] p_src the first eigen vector
-      * \param[in] p_tgt the second eigen vector
-      */
-    inline double
-    l2Sqr (const Eigen::Vector4f &amp;p_src, const Eigen::Vector4f &amp;p_tgt) 
-    {
-      return ((p_src - p_tgt).squaredNorm ());
-    }
-  }
-}
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\eigen.h" new_path="" added_lines="0" deleted_lines="52">
				<diff>@@ -1,52 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id: lmeds.h 1370 2011-06-19 01:06:01Z jspricke $
- *
- */
-
-#ifndef FAST_PCL_REGISTRATION_EIGEN_H_
-#define FAST_PCL_REGISTRATION_EIGEN_H_
-
-#if defined __GNUC__
-#  pragma GCC system_header 
-#endif
-
-#include &lt;Eigen/Core&gt;
-#include &lt;Eigen/Geometry&gt;
-#include &lt;unsupported/Eigen/Polynomials&gt;
-#include &lt;Eigen/Dense&gt;
-
-#endif    // FAST_PCL_REGISTRATION_EIGEN_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\icp.h" new_path="" added_lines="0" deleted_lines="345">
				<diff>@@ -1,345 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#ifndef FAST_PCL_ICP_H_
-#define FAST_PCL_ICP_H_
-
-// PCL includes
-#include &lt;pcl/sample_consensus/ransac.h&gt;
-#include &lt;pcl/sample_consensus/sac_model_registration.h&gt;
-//#include &lt;pcl/registration/registration.h&gt;
-//#include &lt;pcl/registration/transformation_estimation_svd.h&gt;
-//#include &lt;pcl/registration/transformation_estimation_point_to_plane_lls.h&gt;
-//#include &lt;pcl/registration/correspondence_estimation.h&gt;
-//#include &lt;pcl/registration/default_convergence_criteria.h&gt;
-#include "fast_pcl/registration/registration.h"
-#include "fast_pcl/registration/transformation_estimation_svd.h"
-#include "fast_pcl/registration/transformation_estimation_point_to_plane_lls.h"
-#include "fast_pcl/registration/correspondence_estimation.h"
-#include "fast_pcl/registration/default_convergence_criteria.h"
-
-
-namespace pcl
-{
-  /** \brief @b IterativeClosestPoint provides a base implementation of the Iterative Closest Point algorithm. 
-    * The transformation is estimated based on Singular Value Decomposition (SVD).
-    *
-    * The algorithm has several termination criteria:
-    *
-    * &lt;ol&gt;
-    * &lt;li&gt;Number of iterations has reached the maximum user imposed number of iterations (via \ref setMaximumIterations)&lt;/li&gt;
-    * &lt;li&gt;The epsilon (difference) between the previous transformation and the current estimated transformation is smaller than an user imposed value (via \ref setTransformationEpsilon)&lt;/li&gt;
-    * &lt;li&gt;The sum of Euclidean squared errors is smaller than a user defined threshold (via \ref setEuclideanFitnessEpsilon)&lt;/li&gt;
-    * &lt;/ol&gt;
-    *
-    *
-    * Usage example:
-    * \code
-    * IterativeClosestPoint&lt;PointXYZ, PointXYZ&gt; icp;
-    * // Set the input source and target
-    * icp.setInputCloud (cloud_source);
-    * icp.setInputTarget (cloud_target);
-    *
-    * // Set the max correspondence distance to 5cm (e.g., correspondences with higher distances will be ignored)
-    * icp.setMaxCorrespondenceDistance (0.05);
-    * // Set the maximum number of iterations (criterion 1)
-    * icp.setMaximumIterations (50);
-    * // Set the transformation epsilon (criterion 2)
-    * icp.setTransformationEpsilon (1e-8);
-    * // Set the euclidean distance difference epsilon (criterion 3)
-    * icp.setEuclideanFitnessEpsilon (1);
-    *
-    * // Perform the alignment
-    * icp.align (cloud_source_registered);
-    *
-    * // Obtain the transformation that aligned cloud_source to cloud_source_registered
-    * Eigen::Matrix4f transformation = icp.getFinalTransformation ();
-    * \endcode
-    *
-    * \author Radu B. Rusu, Michael Dixon
-    * \ingroup registration
-    */
-  template &lt;typename PointSource, typename PointTarget, typename Scalar = float&gt;
-  class IterativeClosestPoint : public Registration&lt;PointSource, PointTarget, Scalar&gt;
-  {
-    public:
-      typedef typename Registration&lt;PointSource, PointTarget, Scalar&gt;::PointCloudSource PointCloudSource;
-      typedef typename PointCloudSource::Ptr PointCloudSourcePtr;
-      typedef typename PointCloudSource::ConstPtr PointCloudSourceConstPtr;
-
-      typedef typename Registration&lt;PointSource, PointTarget, Scalar&gt;::PointCloudTarget PointCloudTarget;
-      typedef typename PointCloudTarget::Ptr PointCloudTargetPtr;
-      typedef typename PointCloudTarget::ConstPtr PointCloudTargetConstPtr;
-
-      typedef PointIndices::Ptr PointIndicesPtr;
-      typedef PointIndices::ConstPtr PointIndicesConstPtr;
-
-      typedef boost::shared_ptr&lt;IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt; &gt; Ptr;
-      typedef boost::shared_ptr&lt;const IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt; &gt; ConstPtr;
-
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::reg_name_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::getClassName;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::input_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::indices_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::target_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::nr_iterations_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::max_iterations_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::previous_transformation_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::final_transformation_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::transformation_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::transformation_epsilon_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::converged_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::corr_dist_threshold_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::inlier_threshold_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::min_number_correspondences_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::update_visualizer_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::euclidean_fitness_epsilon_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::correspondences_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::transformation_estimation_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::correspondence_estimation_;
-      using Registration&lt;PointSource, PointTarget, Scalar&gt;::correspondence_rejectors_;
-
-      typename pcl::registration::DefaultConvergenceCriteria&lt;Scalar&gt;::Ptr convergence_criteria_;
-      typedef typename Registration&lt;PointSource, PointTarget, Scalar&gt;::Matrix4 Matrix4;
-
-      /** \brief Empty constructor. */
-      IterativeClosestPoint () 
-        : x_idx_offset_ (0)
-        , y_idx_offset_ (0)
-        , z_idx_offset_ (0)
-        , nx_idx_offset_ (0)
-        , ny_idx_offset_ (0)
-        , nz_idx_offset_ (0)
-        , use_reciprocal_correspondence_ (false)
-        , source_has_normals_ (false)
-        , target_has_normals_ (false)
-      {
-        reg_name_ = "IterativeClosestPoint";
-        transformation_estimation_.reset (new pcl::registration::TransformationEstimationSVD&lt;PointSource, PointTarget, Scalar&gt; ());
-        correspondence_estimation_.reset (new pcl::registration::CorrespondenceEstimation&lt;PointSource, PointTarget, Scalar&gt;);
-        convergence_criteria_.reset(new pcl::registration::DefaultConvergenceCriteria&lt;Scalar&gt; (nr_iterations_, transformation_, *correspondences_));
-      };
-
-      /** \brief Empty destructor */
-      virtual ~IterativeClosestPoint () {}
-
-      /** \brief Returns a pointer to the DefaultConvergenceCriteria used by the IterativeClosestPoint class.
-        * This allows to check the convergence state after the align() method as well as to configure
-        * DefaultConvergenceCriteria's parameters not available through the ICP API before the align()
-        * method is called. Please note that the align method sets max_iterations_,
-        * euclidean_fitness_epsilon_ and transformation_epsilon_ and therefore overrides the default / set
-        * values of the DefaultConvergenceCriteria instance.
-        * \return Pointer to the IterativeClosestPoint's DefaultConvergenceCriteria.
-        */
-      inline typename pcl::registration::DefaultConvergenceCriteria&lt;Scalar&gt;::Ptr
-      getConvergeCriteria ()
-      {
-        return convergence_criteria_;
-      }
-
-      /** \brief Provide a pointer to the input source 
-        * (e.g., the point cloud that we want to align to the target)
-        *
-        * \param[in] cloud the input point cloud source
-        */
-      virtual void
-      setInputSource (const PointCloudSourceConstPtr &amp;cloud)
-      {
-        Registration&lt;PointSource, PointTarget, Scalar&gt;::setInputSource (cloud);
-        std::vector&lt;pcl::PCLPointField&gt; fields;
-        pcl::getFields (*cloud, fields);
-        source_has_normals_ = false;
-        for (size_t i = 0; i &lt; fields.size (); ++i)
-        {
-          if      (fields[i].name == "x") x_idx_offset_ = fields[i].offset;
-          else if (fields[i].name == "y") y_idx_offset_ = fields[i].offset;
-          else if (fields[i].name == "z") z_idx_offset_ = fields[i].offset;
-          else if (fields[i].name == "normal_x") 
-          {
-            source_has_normals_ = true;
-            nx_idx_offset_ = fields[i].offset;
-          }
-          else if (fields[i].name == "normal_y") 
-          {
-            source_has_normals_ = true;
-            ny_idx_offset_ = fields[i].offset;
-          }
-          else if (fields[i].name == "normal_z") 
-          {
-            source_has_normals_ = true;
-            nz_idx_offset_ = fields[i].offset;
-          }
-        }
-      }
-      
-      /** \brief Provide a pointer to the input target 
-        * (e.g., the point cloud that we want to align to the target)
-        *
-        * \param[in] cloud the input point cloud target
-        */
-      virtual void
-      setInputTarget (const PointCloudTargetConstPtr &amp;cloud)
-      {
-        Registration&lt;PointSource, PointTarget, Scalar&gt;::setInputTarget (cloud);
-        std::vector&lt;pcl::PCLPointField&gt; fields;
-        pcl::getFields (*cloud, fields);
-        target_has_normals_ = false;
-        for (size_t i = 0; i &lt; fields.size (); ++i)
-        {
-          if (fields[i].name == "normal_x" || fields[i].name == "normal_y" || fields[i].name == "normal_z") 
-          {
-            target_has_normals_ = true;
-            break;
-          }
-        }
-      }
-
-      /** \brief Set whether to use reciprocal correspondence or not
-        *
-        * \param[in] use_reciprocal_correspondence whether to use reciprocal correspondence or not
-        */
-      inline void
-      setUseReciprocalCorrespondences (bool use_reciprocal_correspondence)
-      {
-        use_reciprocal_correspondence_ = use_reciprocal_correspondence;
-      }
-
-      /** \brief Obtain whether reciprocal correspondence are used or not */
-      inline bool
-      getUseReciprocalCorrespondences () const
-      {
-        return (use_reciprocal_correspondence_);
-      }
-
-    protected:
-
-      /** \brief Apply a rigid transform to a given dataset. Here we check whether whether
-        * the dataset has surface normals in addition to XYZ, and rotate normals as well.
-        * \param[in] input the input point cloud
-        * \param[out] output the resultant output point cloud
-        * \param[in] transform a 4x4 rigid transformation
-        * \note Can be used with cloud_in equal to cloud_out
-        */
-      virtual void 
-      transformCloud (const PointCloudSource &amp;input, 
-                      PointCloudSource &amp;output, 
-                      const Matrix4 &amp;transform);
-
-      /** \brief Rigid transformation computation method  with initial guess.
-        * \param output the transformed input point cloud dataset using the rigid transformation found
-        * \param guess the initial guess of the transformation to compute
-        */
-      virtual void 
-      computeTransformation (PointCloudSource &amp;output, const Matrix4 &amp;guess);
-
-      /** \brief Looks at the Estimators and Rejectors and determines whether their blob-setter methods need to be called */
-      virtual void
-      determineRequiredBlobData ();
-
-      /** \brief XYZ fields offset. */
-      size_t x_idx_offset_, y_idx_offset_, z_idx_offset_;
-
-      /** \brief Normal fields offset. */
-      size_t nx_idx_offset_, ny_idx_offset_, nz_idx_offset_;
-
-      /** \brief The correspondence type used for correspondence estimation. */
-      bool use_reciprocal_correspondence_;
-
-      /** \brief Internal check whether source dataset has normals or not. */
-      bool source_has_normals_;
-      /** \brief Internal check whether target dataset has normals or not. */
-      bool target_has_normals_;
-
-      /** \brief Checks for whether estimators and rejectors need various data */
-      bool need_source_blob_, need_target_blob_;
-  };
-
-  /** \brief @b IterativeClosestPointWithNormals is a special case of
-    * IterativeClosestPoint, that uses a transformation estimated based on
-    * Point to Plane distances by default.
-    *
-    * \author Radu B. Rusu
-    * \ingroup registration
-    */
-  template &lt;typename PointSource, typename PointTarget, typename Scalar = float&gt;
-  class IterativeClosestPointWithNormals : public IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;
-  {
-    public:
-      typedef typename IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;::PointCloudSource PointCloudSource;
-      typedef typename IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;::PointCloudTarget PointCloudTarget;
-      typedef typename IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;::Matrix4 Matrix4;
-
-      using IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;::reg_name_;
-      using IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;::transformation_estimation_;
-      using IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;::correspondence_rejectors_;
-
-      typedef boost::shared_ptr&lt;IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt; &gt; Ptr;
-      typedef boost::shared_ptr&lt;const IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt; &gt; ConstPtr;
-
-      /** \brief Empty constructor. */
-      IterativeClosestPointWithNormals () 
-      {
-        reg_name_ = "IterativeClosestPointWithNormals";
-        transformation_estimation_.reset (new pcl::registration::TransformationEstimationPointToPlaneLLS&lt;PointSource, PointTarget, Scalar&gt; ());
-        //correspondence_rejectors_.add
-      };
-      
-      /** \brief Empty destructor */
-      virtual ~IterativeClosestPointWithNormals () {}
-
-    protected:
-
-      /** \brief Apply a rigid transform to a given dataset
-        * \param[in] input the input point cloud
-        * \param[out] output the resultant output point cloud
-        * \param[in] transform a 4x4 rigid transformation
-        * \note Can be used with cloud_in equal to cloud_out
-        */
-      virtual void 
-      transformCloud (const PointCloudSource &amp;input, 
-                      PointCloudSource &amp;output, 
-                      const Matrix4 &amp;transform);
-  };
-}
-
-//#include &lt;pcl/registration/impl/icp.hpp&gt;
-#include "fast_pcl/registration/impl/icp.hpp"
-
-#endif  //#ifndef FAST_PCL_ICP_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\icp_nl.h" new_path="" added_lines="0" deleted_lines="95">
				<diff>@@ -1,95 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#ifndef FAST_PCL_ICP_NL_H_
-#define FAST_PCL_ICP_NL_H_
-
-// PCL includes
-//#include &lt;pcl/registration/icp.h&gt;
-//#include &lt;pcl/registration/transformation_estimation_lm.h&gt;
-#include "fast_pcl/registration/icp.h"
-#include "fast_pcl/registration/transformation_estimation_lm.h"
-
-namespace pcl
-{
-  /** \brief @b IterativeClosestPointNonLinear is an ICP variant that uses Levenberg-Marquardt optimization 
-    * backend. The resultant transformation is optimized as a quaternion.
-    *
-    * The algorithm has several termination criteria:
-    *
-    * &lt;ol&gt;
-    * &lt;li&gt;Number of iterations has reached the maximum user imposed number of iterations 
-    *     (via \ref setMaximumIterations)&lt;/li&gt;
-    * &lt;li&gt;The epsilon (difference) between the previous transformation and the current estimated transformation is 
-    *     smaller than an user imposed value (via \ref setTransformationEpsilon)&lt;/li&gt;
-    * &lt;li&gt;The sum of Euclidean squared errors is smaller than a user defined threshold 
-    *     (via \ref setEuclideanFitnessEpsilon)&lt;/li&gt;
-    * &lt;/ol&gt;
-    *
-    * \author Radu B. Rusu, Michael Dixon
-    * \ingroup registration
-    */
-  template &lt;typename PointSource, typename PointTarget, typename Scalar = float&gt;
-  class IterativeClosestPointNonLinear : public IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;
-  {
-    using IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;::min_number_correspondences_;
-    using IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;::reg_name_;
-    using IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;::transformation_estimation_;
-    using IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;::computeTransformation;
-
-    public:
-
-      typedef boost::shared_ptr&lt; IterativeClosestPointNonLinear&lt;PointSource, PointTarget, Scalar&gt; &gt; Ptr;
-      typedef boost::shared_ptr&lt; const IterativeClosestPointNonLinear&lt;PointSource, PointTarget, Scalar&gt; &gt; ConstPtr;
-
-      typedef typename Registration&lt;PointSource, PointTarget, Scalar&gt;::Matrix4 Matrix4;
-
-      /** \brief Empty constructor. */
-      IterativeClosestPointNonLinear ()
-      {
-        min_number_correspondences_ = 4;
-        reg_name_ = "IterativeClosestPointNonLinear";
-
-        transformation_estimation_.reset (new pcl::registration::TransformationEstimationLM&lt;PointSource, PointTarget, Scalar&gt;);
-      }
-  };
-}
-
-#endif  //#ifndef FAST_PCL_ICP_NL_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\impl\correspondence_estimation.hpp" new_path="" added_lines="0" deleted_lines="265">
				<diff>@@ -1,265 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-#ifndef FAST_PCL_REGISTRATION_IMPL_CORRESPONDENCE_ESTIMATION_H_
-#define FAST_PCL_REGISTRATION_IMPL_CORRESPONDENCE_ESTIMATION_H_
-
-#include &lt;pcl/common/io.h&gt;
-#include &lt;pcl/common/copy_point.h&gt;
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; void
-pcl::registration::CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::setInputCloud (const typename pcl::registration::CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::PointCloudSourceConstPtr &amp;cloud)
-{
-  setInputSource (cloud); 
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; typename pcl::registration::CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::PointCloudSourceConstPtr const
-pcl::registration::CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::getInputCloud ()
-{
-  return (getInputSource ()); 
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; void
-pcl::registration::CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::setInputTarget (
-    const PointCloudTargetConstPtr &amp;cloud)
-{
-  if (cloud-&gt;points.empty ())
-  {
-    PCL_ERROR ("[pcl::registration::%s::setInputTarget] Invalid or empty point cloud dataset given!\n", getClassName ().c_str ());
-    return;
-  }
-  target_ = cloud;
-
-  // Set the internal point representation of choice
-  if (point_representation_)
-    tree_-&gt;setPointRepresentation (point_representation_);
-
-  target_cloud_updated_ = true;
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; bool
-pcl::registration::CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::initCompute ()
-{
-  if (!target_)
-  {
-    PCL_ERROR ("[pcl::registration::%s::compute] No input target dataset was given!\n", getClassName ().c_str ());
-    return (false);
-  }
-
-  // Only update target kd-tree if a new target cloud was set
-  if (target_cloud_updated_ &amp;&amp; !force_no_recompute_)
-  {
-    // If the target indices have been given via setIndicesTarget
-    if (target_indices_)
-      tree_-&gt;setInputCloud (target_, target_indices_);
-    else
-      tree_-&gt;setInputCloud (target_);
-
-    target_cloud_updated_ = false;
-  }
-
-  return (PCLBase&lt;PointSource&gt;::initCompute ());
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; bool
-pcl::registration::CorrespondenceEstimationBase&lt;PointSource, PointTarget, Scalar&gt;::initComputeReciprocal ()
-{
-  // Only update source kd-tree if a new target cloud was set
-  if (source_cloud_updated_ &amp;&amp; !force_no_recompute_reciprocal_)
-  {
-    if (point_representation_)
-      tree_reciprocal_-&gt;setPointRepresentation (point_representation_);
-    // If the target indices have been given via setIndicesTarget
-    if (indices_)
-      tree_reciprocal_-&gt;setInputCloud (getInputSource(), getIndicesSource());
-    else
-      tree_reciprocal_-&gt;setInputCloud (getInputSource());
-
-    source_cloud_updated_ = false;
-  }
-
-  return (true);
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; void
-pcl::registration::CorrespondenceEstimation&lt;PointSource, PointTarget, Scalar&gt;::determineCorrespondences (
-    pcl::Correspondences &amp;correspondences, double max_distance)
-{
-  if (!initCompute ())
-    return;
-
-  double max_dist_sqr = max_distance * max_distance;
-
-  correspondences.resize (indices_-&gt;size ());
-
-  std::vector&lt;int&gt; index (1);
-  std::vector&lt;float&gt; distance (1);
-  pcl::Correspondence corr;
-  unsigned int nr_valid_correspondences = 0;
-  
-  // Check if the template types are the same. If true, avoid a copy.
-  // Both point types MUST be registered using the POINT_CLOUD_REGISTER_POINT_STRUCT macro!
-  if (isSamePointType&lt;PointSource, PointTarget&gt; ())
-  {
-    // Iterate over the input set of source indices
-    for (std::vector&lt;int&gt;::const_iterator idx = indices_-&gt;begin (); idx != indices_-&gt;end (); ++idx)
-    {
-      tree_-&gt;nearestKSearch (input_-&gt;points[*idx], 1, index, distance);
-      if (distance[0] &gt; max_dist_sqr)
-        continue;
-
-      corr.index_query = *idx;
-      corr.index_match = index[0];
-      corr.distance = distance[0];
-      correspondences[nr_valid_correspondences++] = corr;
-    }
-  }
-  else
-  {
-    PointTarget pt;
-    
-    // Iterate over the input set of source indices
-    for (std::vector&lt;int&gt;::const_iterator idx = indices_-&gt;begin (); idx != indices_-&gt;end (); ++idx)
-    {
-      // Copy the source data to a target PointTarget format so we can search in the tree
-      copyPoint (input_-&gt;points[*idx], pt);
-
-      tree_-&gt;nearestKSearch (pt, 1, index, distance);
-      if (distance[0] &gt; max_dist_sqr)
-        continue;
-
-      corr.index_query = *idx;
-      corr.index_match = index[0];
-      corr.distance = distance[0];
-      correspondences[nr_valid_correspondences++] = corr;
-    }
-  }
-  correspondences.resize (nr_valid_correspondences);
-  deinitCompute ();
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; void
-pcl::registration::CorrespondenceEstimation&lt;PointSource, PointTarget, Scalar&gt;::determineReciprocalCorrespondences (
-    pcl::Correspondences &amp;correspondences, double max_distance)
-{
-  if (!initCompute ())
-    return;
-
-  // setup tree for reciprocal search
-  // Set the internal point representation of choice
-  if (!initComputeReciprocal())
-    return;
-  double max_dist_sqr = max_distance * max_distance;
-
-  correspondences.resize (indices_-&gt;size());
-  std::vector&lt;int&gt; index (1);
-  std::vector&lt;float&gt; distance (1);
-  std::vector&lt;int&gt; index_reciprocal (1);
-  std::vector&lt;float&gt; distance_reciprocal (1);
-  pcl::Correspondence corr;
-  unsigned int nr_valid_correspondences = 0;
-  int target_idx = 0;
-
-  // Check if the template types are the same. If true, avoid a copy.
-  // Both point types MUST be registered using the POINT_CLOUD_REGISTER_POINT_STRUCT macro!
-  if (isSamePointType&lt;PointSource, PointTarget&gt; ())
-  {
-    // Iterate over the input set of source indices
-    for (std::vector&lt;int&gt;::const_iterator idx = indices_-&gt;begin (); idx != indices_-&gt;end (); ++idx)
-    {
-      tree_-&gt;nearestKSearch (input_-&gt;points[*idx], 1, index, distance);
-      if (distance[0] &gt; max_dist_sqr)
-        continue;
-
-      target_idx = index[0];
-
-      tree_reciprocal_-&gt;nearestKSearch (target_-&gt;points[target_idx], 1, index_reciprocal, distance_reciprocal);
-      if (distance_reciprocal[0] &gt; max_dist_sqr || *idx != index_reciprocal[0])
-        continue;
-
-      corr.index_query = *idx;
-      corr.index_match = index[0];
-      corr.distance = distance[0];
-      correspondences[nr_valid_correspondences++] = corr;
-    }
-  }
-  else
-  {
-    PointTarget pt_src;
-    PointSource pt_tgt;
-   
-    // Iterate over the input set of source indices
-    for (std::vector&lt;int&gt;::const_iterator idx = indices_-&gt;begin (); idx != indices_-&gt;end (); ++idx)
-    {
-      // Copy the source data to a target PointTarget format so we can search in the tree
-      copyPoint (input_-&gt;points[*idx], pt_src);
-
-      tree_-&gt;nearestKSearch (pt_src, 1, index, distance);
-      if (distance[0] &gt; max_dist_sqr)
-        continue;
-
-      target_idx = index[0];
-
-      // Copy the target data to a target PointSource format so we can search in the tree_reciprocal
-      copyPoint (target_-&gt;points[target_idx], pt_tgt);
-
-      tree_reciprocal_-&gt;nearestKSearch (pt_tgt, 1, index_reciprocal, distance_reciprocal);
-      if (distance_reciprocal[0] &gt; max_dist_sqr || *idx != index_reciprocal[0])
-        continue;
-
-      corr.index_query = *idx;
-      corr.index_match = index[0];
-      corr.distance = distance[0];
-      correspondences[nr_valid_correspondences++] = corr;
-    }
-  }
-  correspondences.resize (nr_valid_correspondences);
-  deinitCompute ();
-}
-
-//#define PCL_INSTANTIATE_CorrespondenceEstimation(T,U) template class PCL_EXPORTS pcl::registration::CorrespondenceEstimation&lt;T,U&gt;;
-
-#endif /* FAST_PCL_REGISTRATION_IMPL_CORRESPONDENCE_ESTIMATION_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\impl\correspondence_rejection.hpp" new_path="" added_lines="0" deleted_lines="58">
				<diff>@@ -1,58 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef FAST_PCL_REGISTRATION_CORRESPONDENCE_REJECTION_IMPL_HPP_
-#define FAST_PCL_REGISTRATION_CORRESPONDENCE_REJECTION_IMPL_HPP_
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointT, typename NormalT&gt; void
-pcl::registration::DataContainer&lt;PointT, NormalT&gt;::setInputCloud (const typename pcl::registration::DataContainer&lt;PointT, NormalT&gt;::PointCloudConstPtr &amp;cloud)
-{
-  //input_ = cloud;
-  setInputSource (cloud);
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointT, typename NormalT&gt; typename pcl::registration::DataContainer&lt;PointT, NormalT&gt;::PointCloudConstPtr const
-pcl::registration::DataContainer&lt;PointT, NormalT&gt;::getInputCloud ()
-{
-  return (getInputSource ()); 
-  //return (input_); 
-}
-
-#endif    // FAST_PCL_REGISTRATION_CORRESPONDENCE_REJECTION_IMPL_HPP_
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\impl\correspondence_types.hpp" new_path="" added_lines="0" deleted_lines="87">
				<diff>@@ -1,87 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-#ifndef FAST_PCL_REGISTRATION_IMPL_CORRESPONDENCE_TYPES_H_
-#define FAST_PCL_REGISTRATION_IMPL_CORRESPONDENCE_TYPES_H_
-
-#include &lt;limits&gt;
-//#include &lt;pcl/registration/eigen.h&gt;
-#include "fast_pcl/registration/eigen.h"
-
-//////////////////////////////////////////////////////////////////////////////////////////
-inline void
-//pcl::registration::getCorDistMeanStd (const pcl::Correspondences &amp;correspondences, double &amp;mean, double &amp;stddev)
-pcl::registration::getCorDistMeanStd (const pcl::Correspondences &amp;correspondences, double &amp;mean, double &amp;stddev)
-{
-  if (correspondences.empty ())
-    return;
-
-  double sum = 0, sq_sum = 0;
-
-  for (size_t i = 0; i &lt; correspondences.size (); ++i)
-  {
-    sum += correspondences[i].distance;
-    sq_sum += correspondences[i].distance * correspondences[i].distance;
-  }
-  mean = sum / static_cast&lt;double&gt; (correspondences.size ());
-  double variance = (sq_sum - sum * sum / static_cast&lt;double&gt; (correspondences.size ())) / static_cast&lt;double&gt; (correspondences.size () - 1);
-  stddev = sqrt (variance);
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////
-inline void
-//pcl::registration::getQueryIndices (const pcl::Correspondences&amp; correspondences, std::vector&lt;int&gt;&amp; indices)
-pcl::registration::getQueryIndices (const pcl::Correspondences&amp; correspondences, std::vector&lt;int&gt;&amp; indices)
-{
-  indices.resize (correspondences.size ());
-  for (size_t i = 0; i &lt; correspondences.size (); ++i)
-    indices[i] = correspondences[i].index_query;
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////
-inline void
-//pcl::registration::getMatchIndices (const pcl::Correspondences&amp; correspondences, std::vector&lt;int&gt;&amp; indices)
-pcl::registration::getMatchIndices (const pcl::Correspondences&amp; correspondences, std::vector&lt;int&gt;&amp; indices)
-{
-  indices.resize (correspondences.size ());
-  for (size_t i = 0; i &lt; correspondences.size (); ++i)
-    indices[i] = correspondences[i].index_match;
-}
-
-#endif /* FAST_PCL_REGISTRATION_IMPL_CORRESPONDENCE_TYPES_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\impl\default_convergence_criteria.hpp" new_path="" added_lines="0" deleted_lines="131">
				<diff>@@ -1,131 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#ifndef FAST_PCL_REGISTRATION_DEFAULT_CONVERGENCE_CRITERIA_HPP_
-#define FAST_PCL_REGISTRATION_DEFAULT_CONVERGENCE_CRITERIA_HPP_
-
-#include &lt;pcl/console/print.h&gt;
-
-//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename Scalar&gt; bool
-pcl::registration::DefaultConvergenceCriteria&lt;Scalar&gt;::hasConverged ()
-{
-  convergence_state_ = CONVERGENCE_CRITERIA_NOT_CONVERGED;
-
-  PCL_DEBUG ("[pcl::DefaultConvergenceCriteria::hasConverged] Iteration %d out of %d.\n", iterations_, max_iterations_);
-  // 1. Number of iterations has reached the maximum user imposed number of iterations
-  if (iterations_ &gt;= max_iterations_)
-  {
-    if (failure_after_max_iter_)
-      return (false);
-    else
-    {
-      convergence_state_ = CONVERGENCE_CRITERIA_ITERATIONS;
-      return (true);
-    }
-    return (failure_after_max_iter_ ? false : true);
-  }
-
-  // 2. The epsilon (difference) between the previous transformation and the current estimated transformation
-  double cos_angle = 0.5 * (transformation_.coeff (0, 0) + transformation_.coeff (1, 1) + transformation_.coeff (2, 2) - 1);
-  double translation_sqr = transformation_.coeff (0, 3) * transformation_.coeff (0, 3) +
-                           transformation_.coeff (1, 3) * transformation_.coeff (1, 3) +
-                           transformation_.coeff (2, 3) * transformation_.coeff (2, 3);
-  PCL_DEBUG ("[pcl::DefaultConvergenceCriteria::hasConverged] Current transformation gave %f rotation (cosine) and %f translation.\n", cos_angle, translation_sqr);
-
-  if (cos_angle &gt;= rotation_threshold_ &amp;&amp; translation_sqr &lt;= translation_threshold_)
-  {
-    if (iterations_similar_transforms_ &lt; max_iterations_similar_transforms_)
-    {
-      // Increment the number of transforms that the thresholds are allowed to be similar
-      ++iterations_similar_transforms_;
-      return (false);
-    }
-    else
-    {
-      iterations_similar_transforms_ = 0;
-      convergence_state_ = CONVERGENCE_CRITERIA_TRANSFORM;
-      return (true);
-    }
-  }
-
-  correspondences_cur_mse_ = calculateMSE (correspondences_);
-  PCL_DEBUG ("[pcl::DefaultConvergenceCriteria::hasConverged] Previous / Current MSE for correspondences distances is: %f / %f.\n", correspondences_prev_mse_, correspondences_cur_mse_);
-
-  // 3. The relative sum of Euclidean squared errors is smaller than a user defined threshold
-  // Absolute
-  if (fabs (correspondences_cur_mse_ - correspondences_prev_mse_) &lt; mse_threshold_absolute_)
-  {
-    if (iterations_similar_transforms_ &lt; max_iterations_similar_transforms_)
-    {
-      // Increment the number of transforms that the thresholds are allowed to be similar
-      ++iterations_similar_transforms_;
-      return (false);
-    }
-    else
-    {
-      iterations_similar_transforms_ = 0;
-      convergence_state_ = CONVERGENCE_CRITERIA_ABS_MSE;
-      return (true);
-    }
-  }
-  
-  // Relative
-  if (fabs (correspondences_cur_mse_ - correspondences_prev_mse_) / correspondences_prev_mse_ &lt; mse_threshold_relative_)
-  {
-    if (iterations_similar_transforms_ &lt; max_iterations_similar_transforms_)
-    {
-      // Increment the number of transforms that the thresholds are allowed to be similar
-      ++iterations_similar_transforms_;
-      return (false);
-    }
-    else
-    {
-      iterations_similar_transforms_ = 0;
-      convergence_state_ = CONVERGENCE_CRITERIA_REL_MSE;
-      return (true);
-    }
-  }
-
-  correspondences_prev_mse_ = correspondences_cur_mse_;
-
-  return (false);
-}
-
-#endif    // FAST_PCL_REGISTRATION_DEFAULT_CONVERGENCE_CRITERIA_HPP_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\impl\icp.hpp" new_path="" added_lines="0" deleted_lines="298">
				<diff>@@ -1,298 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#ifndef FAST_PCL_REGISTRATION_IMPL_ICP_HPP_
-#define FAST_PCL_REGISTRATION_IMPL_ICP_HPP_
-
-//#include &lt;pcl/registration/boost.h&gt;
-#include "fast_pcl/registration/boost.h"
-#include &lt;pcl/correspondence.h&gt;
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; void
-pcl::IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;::transformCloud (
-    const PointCloudSource &amp;input, 
-    PointCloudSource &amp;output, 
-    const Matrix4 &amp;transform)
-{
-  Eigen::Vector4f pt (0.0f, 0.0f, 0.0f, 1.0f), pt_t;
-  Eigen::Matrix4f tr = transform.template cast&lt;float&gt; ();
-
-  // XYZ is ALWAYS present due to the templatization, so we only have to check for normals
-  if (source_has_normals_)
-  {
-    Eigen::Vector3f nt, nt_t;
-    Eigen::Matrix3f rot = tr.block&lt;3, 3&gt; (0, 0);
-
-    for (size_t i = 0; i &lt; input.size (); ++i)
-    {
-      const uint8_t* data_in = reinterpret_cast&lt;const uint8_t*&gt; (&amp;input[i]);
-      uint8_t* data_out = reinterpret_cast&lt;uint8_t*&gt; (&amp;output[i]);
-      memcpy (&amp;pt[0], data_in + x_idx_offset_, sizeof (float));
-      memcpy (&amp;pt[1], data_in + y_idx_offset_, sizeof (float));
-      memcpy (&amp;pt[2], data_in + z_idx_offset_, sizeof (float));
-
-      if (!pcl_isfinite (pt[0]) || !pcl_isfinite (pt[1]) || !pcl_isfinite (pt[2])) 
-        continue;
-
-      pt_t = tr * pt;
-
-      memcpy (data_out + x_idx_offset_, &amp;pt_t[0], sizeof (float));
-      memcpy (data_out + y_idx_offset_, &amp;pt_t[1], sizeof (float));
-      memcpy (data_out + z_idx_offset_, &amp;pt_t[2], sizeof (float));
-
-      memcpy (&amp;nt[0], data_in + nx_idx_offset_, sizeof (float));
-      memcpy (&amp;nt[1], data_in + ny_idx_offset_, sizeof (float));
-      memcpy (&amp;nt[2], data_in + nz_idx_offset_, sizeof (float));
-
-      if (!pcl_isfinite (nt[0]) || !pcl_isfinite (nt[1]) || !pcl_isfinite (nt[2])) 
-        continue;
-
-      nt_t = rot * nt;
-
-      memcpy (data_out + nx_idx_offset_, &amp;nt_t[0], sizeof (float));
-      memcpy (data_out + ny_idx_offset_, &amp;nt_t[1], sizeof (float));
-      memcpy (data_out + nz_idx_offset_, &amp;nt_t[2], sizeof (float));
-    }
-  }
-  else
-  {
-    for (size_t i = 0; i &lt; input.size (); ++i)
-    {
-      const uint8_t* data_in = reinterpret_cast&lt;const uint8_t*&gt; (&amp;input[i]);
-      uint8_t* data_out = reinterpret_cast&lt;uint8_t*&gt; (&amp;output[i]);
-      memcpy (&amp;pt[0], data_in + x_idx_offset_, sizeof (float));
-      memcpy (&amp;pt[1], data_in + y_idx_offset_, sizeof (float));
-      memcpy (&amp;pt[2], data_in + z_idx_offset_, sizeof (float));
-
-      if (!pcl_isfinite (pt[0]) || !pcl_isfinite (pt[1]) || !pcl_isfinite (pt[2])) 
-        continue;
-
-      pt_t = tr * pt;
-
-      memcpy (data_out + x_idx_offset_, &amp;pt_t[0], sizeof (float));
-      memcpy (data_out + y_idx_offset_, &amp;pt_t[1], sizeof (float));
-      memcpy (data_out + z_idx_offset_, &amp;pt_t[2], sizeof (float));
-    }
-  }
-  
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; void
-pcl::IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;::computeTransformation (
-    PointCloudSource &amp;output, const Matrix4 &amp;guess)
-{
-  // Point cloud containing the correspondences of each point in &lt;input, indices&gt;
-  PointCloudSourcePtr input_transformed (new PointCloudSource);
-
-  nr_iterations_ = 0;
-  converged_ = false;
-
-  // Initialise final transformation to the guessed one
-  final_transformation_ = guess;
-
-  // If the guessed transformation is non identity
-  if (guess != Matrix4::Identity ())
-  {
-    input_transformed-&gt;resize (input_-&gt;size ());
-     // Apply guessed transformation prior to search for neighbours
-    transformCloud (*input_, *input_transformed, guess);
-  }
-  else
-    *input_transformed = *input_;
- 
-  transformation_ = Matrix4::Identity ();
-
-  // Make blobs if necessary
-  determineRequiredBlobData ();
-  PCLPointCloud2::Ptr target_blob (new PCLPointCloud2);
-  if (need_target_blob_)
-    pcl::toPCLPointCloud2 (*target_, *target_blob);
-
-  // Pass in the default target for the Correspondence Estimation/Rejection code
-  correspondence_estimation_-&gt;setInputTarget (target_);
-  if (correspondence_estimation_-&gt;requiresTargetNormals ())
-    correspondence_estimation_-&gt;setTargetNormals (target_blob);
-  // Correspondence Rejectors need a binary blob
-  for (size_t i = 0; i &lt; correspondence_rejectors_.size (); ++i)
-  {
-    registration::CorrespondenceRejector::Ptr&amp; rej = correspondence_rejectors_[i];
-    if (rej-&gt;requiresTargetPoints ())
-      rej-&gt;setTargetPoints (target_blob);
-    if (rej-&gt;requiresTargetNormals () &amp;&amp; target_has_normals_)
-      rej-&gt;setTargetNormals (target_blob);
-  }
-
-  convergence_criteria_-&gt;setMaximumIterations (max_iterations_);
-  convergence_criteria_-&gt;setRelativeMSE (euclidean_fitness_epsilon_);
-  convergence_criteria_-&gt;setTranslationThreshold (transformation_epsilon_);
-  convergence_criteria_-&gt;setRotationThreshold (1.0 - transformation_epsilon_);
-
-  // Repeat until convergence
-  do
-  {
-    // Get blob data if needed
-    PCLPointCloud2::Ptr input_transformed_blob;
-    if (need_source_blob_)
-    {
-      input_transformed_blob.reset (new PCLPointCloud2);
-      toPCLPointCloud2 (*input_transformed, *input_transformed_blob);
-    }
-    // Save the previously estimated transformation
-    previous_transformation_ = transformation_;
-
-    // Set the source each iteration, to ensure the dirty flag is updated
-    correspondence_estimation_-&gt;setInputSource (input_transformed);
-    if (correspondence_estimation_-&gt;requiresSourceNormals ())
-      correspondence_estimation_-&gt;setSourceNormals (input_transformed_blob);
-    // Estimate correspondences
-    if (use_reciprocal_correspondence_)
-      correspondence_estimation_-&gt;determineReciprocalCorrespondences (*correspondences_, corr_dist_threshold_);
-    else
-      correspondence_estimation_-&gt;determineCorrespondences (*correspondences_, corr_dist_threshold_);
-
-    //if (correspondence_rejectors_.empty ())
-    CorrespondencesPtr temp_correspondences (new Correspondences (*correspondences_));
-    for (size_t i = 0; i &lt; correspondence_rejectors_.size (); ++i)
-    {
-      registration::CorrespondenceRejector::Ptr&amp; rej = correspondence_rejectors_[i];
-      PCL_DEBUG ("Applying a correspondence rejector method: %s.\n", rej-&gt;getClassName ().c_str ());
-      if (rej-&gt;requiresSourcePoints ())
-        rej-&gt;setSourcePoints (input_transformed_blob);
-      if (rej-&gt;requiresSourceNormals () &amp;&amp; source_has_normals_)
-        rej-&gt;setSourceNormals (input_transformed_blob);
-      rej-&gt;setInputCorrespondences (temp_correspondences);
-      rej-&gt;getCorrespondences (*correspondences_);
-      // Modify input for the next iteration
-      if (i &lt; correspondence_rejectors_.size () - 1)
-        *temp_correspondences = *correspondences_;
-    }
-
-    size_t cnt = correspondences_-&gt;size ();
-    // Check whether we have enough correspondences
-    if (static_cast&lt;int&gt; (cnt) &lt; min_number_correspondences_)
-    {
-      PCL_ERROR ("[pcl::%s::computeTransformation] Not enough correspondences found. Relax your threshold parameters.\n", getClassName ().c_str ());
-      convergence_criteria_-&gt;setConvergenceState(pcl::registration::DefaultConvergenceCriteria&lt;Scalar&gt;::CONVERGENCE_CRITERIA_NO_CORRESPONDENCES);
-      converged_ = false;
-      break;
-    }
-
-    // Estimate the transform
-    transformation_estimation_-&gt;estimateRigidTransformation (*input_transformed, *target_, *correspondences_, transformation_);
-
-    // Tranform the data
-    transformCloud (*input_transformed, *input_transformed, transformation_);
-
-    // Obtain the final transformation    
-    final_transformation_ = transformation_ * final_transformation_;
-
-    ++nr_iterations_;
-
-    // Update the vizualization of icp convergence
-    //if (update_visualizer_ != 0)
-    //  update_visualizer_(output, source_indices_good, *target_, target_indices_good );
-
-    converged_ = static_cast&lt;bool&gt; ((*convergence_criteria_));
-  }
-  while (!converged_);
-
-  // Transform the input cloud using the final transformation
-  PCL_DEBUG ("Transformation is:\n\t%5f\t%5f\t%5f\t%5f\n\t%5f\t%5f\t%5f\t%5f\n\t%5f\t%5f\t%5f\t%5f\n\t%5f\t%5f\t%5f\t%5f\n", 
-      final_transformation_ (0, 0), final_transformation_ (0, 1), final_transformation_ (0, 2), final_transformation_ (0, 3),
-      final_transformation_ (1, 0), final_transformation_ (1, 1), final_transformation_ (1, 2), final_transformation_ (1, 3),
-      final_transformation_ (2, 0), final_transformation_ (2, 1), final_transformation_ (2, 2), final_transformation_ (2, 3),
-      final_transformation_ (3, 0), final_transformation_ (3, 1), final_transformation_ (3, 2), final_transformation_ (3, 3));
-
-  // Copy all the values
-  output = *input_;
-  // Transform the XYZ + normals
-  transformCloud (*input_, output, final_transformation_);
-}
-
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; void
-pcl::IterativeClosestPoint&lt;PointSource, PointTarget, Scalar&gt;::determineRequiredBlobData ()
-{
-  need_source_blob_ = false;
-  need_target_blob_ = false;
-  // Check estimator
-  need_source_blob_ |= correspondence_estimation_-&gt;requiresSourceNormals ();
-  need_target_blob_ |= correspondence_estimation_-&gt;requiresTargetNormals ();
-  // Add warnings if necessary
-  if (correspondence_estimation_-&gt;requiresSourceNormals () &amp;&amp; !source_has_normals_)
-  {
-      PCL_WARN("[pcl::%s::determineRequiredBlobData] Estimator expects source normals, but we can't provide them.\n", getClassName ().c_str ());
-  }
-  if (correspondence_estimation_-&gt;requiresTargetNormals () &amp;&amp; !target_has_normals_)
-  {
-      PCL_WARN("[pcl::%s::determineRequiredBlobData] Estimator expects target normals, but we can't provide them.\n", getClassName ().c_str ());
-  }
-  // Check rejectors
-  for (size_t i = 0; i &lt; correspondence_rejectors_.size (); i++)
-  {
-    registration::CorrespondenceRejector::Ptr&amp; rej = correspondence_rejectors_[i];
-    need_source_blob_ |= rej-&gt;requiresSourcePoints ();
-    need_source_blob_ |= rej-&gt;requiresSourceNormals ();
-    need_target_blob_ |= rej-&gt;requiresTargetPoints ();
-    need_target_blob_ |= rej-&gt;requiresTargetNormals ();
-    if (rej-&gt;requiresSourceNormals () &amp;&amp; !source_has_normals_)
-    {
-      PCL_WARN("[pcl::%s::determineRequiredBlobData] Rejector %s expects source normals, but we can't provide them.\n", getClassName ().c_str (), rej-&gt;getClassName ().c_str ());
-    }
-    if (rej-&gt;requiresTargetNormals () &amp;&amp; !target_has_normals_)
-    {
-      PCL_WARN("[pcl::%s::determineRequiredBlobData] Rejector %s expects target normals, but we can't provide them.\n", getClassName ().c_str (), rej-&gt;getClassName ().c_str ());
-    }
-  }
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; void
-pcl::IterativeClosestPointWithNormals&lt;PointSource, PointTarget, Scalar&gt;::transformCloud (
-    const PointCloudSource &amp;input, 
-    PointCloudSource &amp;output, 
-    const Matrix4 &amp;transform)
-{
-  pcl::transformPointCloudWithNormals (input, output, transform);
-}
-      
-
-#endif /* FAST_PCL_REGISTRATION_IMPL_ICP_HPP_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\impl\icp_nl.hpp" new_path="" added_lines="0" deleted_lines="44">
				<diff>@@ -1,44 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-#ifndef FAST_PCL_REGISTRATION_ICP_NL_HPP_
-#define FAST_PCL_REGISTRATION_ICP_NL_HPP_
-
-#endif /* PCL_REGISTRATION_ICP_NL_HPP_ */
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\impl\transformation_estimation_lm.hpp" new_path="" added_lines="0" deleted_lines="276">
				<diff>@@ -1,276 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-#ifndef FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_LM_HPP_
-#define FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_LM_HPP_
-
-//#include &lt;pcl/registration/warp_point_rigid.h&gt;
-//#include &lt;pcl/registration/warp_point_rigid_6d.h&gt;
-//#include &lt;pcl/registration/distances.h&gt;
-#include "fast_pcl/registration/warp_point_rigid.h"
-#include "fast_pcl/registration/warp_point_rigid_6d.h"
-#include "fast_pcl/registration/distances.h"
-#include &lt;unsupported/Eigen/NonLinearOptimization&gt;
-
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename MatScalar&gt;
-pcl::registration::TransformationEstimationLM&lt;PointSource, PointTarget, MatScalar&gt;::TransformationEstimationLM ()
-  : tmp_src_ ()
-  , tmp_tgt_ ()
-  , tmp_idx_src_ ()
-  , tmp_idx_tgt_ ()
-  , warp_point_ (new WarpPointRigid6D&lt;PointSource, PointTarget, MatScalar&gt;)
-{
-};
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename MatScalar&gt; void
-pcl::registration::TransformationEstimationLM&lt;PointSource, PointTarget, MatScalar&gt;::estimateRigidTransformation (
-    const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-    const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-    Matrix4 &amp;transformation_matrix) const
-{
-
-  // &lt;cloud_src,cloud_src&gt; is the source dataset
-  if (cloud_src.points.size () != cloud_tgt.points.size ())
-  {
-    PCL_ERROR ("[pcl::registration::TransformationEstimationLM::estimateRigidTransformation] ");
-    PCL_ERROR ("Number or points in source (%lu) differs than target (%lu)!\n", 
-               cloud_src.points.size (), cloud_tgt.points.size ());
-    return;
-  }
-  if (cloud_src.points.size () &lt; 4)     // need at least 4 samples
-  {
-    PCL_ERROR ("[pcl::registration::TransformationEstimationLM::estimateRigidTransformation] ");
-    PCL_ERROR ("Need at least 4 points to estimate a transform! Source and target have %lu points!\n", 
-               cloud_src.points.size ());
-    return;
-  }
-
-  int n_unknowns = warp_point_-&gt;getDimension ();
-  VectorX x (n_unknowns);
-  x.setZero ();
-  
-  // Set temporary pointers
-  tmp_src_ = &amp;cloud_src;
-  tmp_tgt_ = &amp;cloud_tgt;
-
-  OptimizationFunctor functor (static_cast&lt;int&gt; (cloud_src.points.size ()), this);
-  Eigen::NumericalDiff&lt;OptimizationFunctor&gt; num_diff (functor);
-  //Eigen::LevenbergMarquardt&lt;Eigen::NumericalDiff&lt;OptimizationFunctor&gt;, double&gt; lm (num_diff);
-  Eigen::LevenbergMarquardt&lt;Eigen::NumericalDiff&lt;OptimizationFunctor&gt;, MatScalar&gt; lm (num_diff);
-  int info = lm.minimize (x);
-
-  // Compute the norm of the residuals
-  PCL_DEBUG ("[pcl::registration::TransformationEstimationLM::estimateRigidTransformation]");
-  PCL_DEBUG ("LM solver finished with exit code %i, having a residual norm of %g. \n", info, lm.fvec.norm ());
-  PCL_DEBUG ("Final solution: [%f", x[0]);
-  for (int i = 1; i &lt; n_unknowns; ++i) 
-    PCL_DEBUG (" %f", x[i]);
-  PCL_DEBUG ("]\n");
-
-  // Return the correct transformation
-  warp_point_-&gt;setParam (x);
-  transformation_matrix = warp_point_-&gt;getTransform ();
-
-  tmp_src_ = NULL;
-  tmp_tgt_ = NULL;
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename MatScalar&gt; void
-pcl::registration::TransformationEstimationLM&lt;PointSource, PointTarget, MatScalar&gt;::estimateRigidTransformation (
-    const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-    const std::vector&lt;int&gt; &amp;indices_src,
-    const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-    Matrix4 &amp;transformation_matrix) const
-{
-  if (indices_src.size () != cloud_tgt.points.size ())
-  {
-    PCL_ERROR ("[pcl::registration::TransformationEstimationLM::estimateRigidTransformation] Number or points in source (%lu) differs than target (%lu)!\n", indices_src.size (), cloud_tgt.points.size ());
-    return;
-  }
-
-  // &lt;cloud_src,cloud_src&gt; is the source dataset
-  transformation_matrix.setIdentity ();
-
-  const int nr_correspondences = static_cast&lt;const int&gt; (cloud_tgt.points.size ());
-  std::vector&lt;int&gt; indices_tgt;
-  indices_tgt.resize(nr_correspondences);
-  for (int i = 0; i &lt; nr_correspondences; ++i)
-    indices_tgt[i] = i;
-
-  estimateRigidTransformation(cloud_src, indices_src, cloud_tgt, indices_tgt, transformation_matrix);
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename MatScalar&gt; inline void
-pcl::registration::TransformationEstimationLM&lt;PointSource, PointTarget, MatScalar&gt;::estimateRigidTransformation (
-    const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-    const std::vector&lt;int&gt; &amp;indices_src,
-    const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-    const std::vector&lt;int&gt; &amp;indices_tgt,
-    Matrix4 &amp;transformation_matrix) const
-{
-  if (indices_src.size () != indices_tgt.size ())
-  {
-    PCL_ERROR ("[pcl::registration::TransformationEstimationLM::estimateRigidTransformation] Number or points in source (%lu) differs than target (%lu)!\n", indices_src.size (), indices_tgt.size ());
-    return;
-  }
-
-  if (indices_src.size () &lt; 4)     // need at least 4 samples
-  {
-    PCL_ERROR ("[pcl::IterativeClosestPointNonLinear::estimateRigidTransformationLM] ");
-    PCL_ERROR ("Need at least 4 points to estimate a transform! Source and target have %lu points!",
-               indices_src.size ());
-    return;
-  }
-
-  int n_unknowns = warp_point_-&gt;getDimension ();  // get dimension of unknown space
-  VectorX x (n_unknowns);
-  x.setConstant (n_unknowns, 0);
-
-  // Set temporary pointers
-  tmp_src_ = &amp;cloud_src;
-  tmp_tgt_ = &amp;cloud_tgt;
-  tmp_idx_src_ = &amp;indices_src;
-  tmp_idx_tgt_ = &amp;indices_tgt;
-
-  OptimizationFunctorWithIndices functor (static_cast&lt;int&gt; (indices_src.size ()), this);
-  Eigen::NumericalDiff&lt;OptimizationFunctorWithIndices&gt; num_diff (functor);
-  //Eigen::LevenbergMarquardt&lt;Eigen::NumericalDiff&lt;OptimizationFunctorWithIndices&gt; &gt; lm (num_diff);
-  Eigen::LevenbergMarquardt&lt;Eigen::NumericalDiff&lt;OptimizationFunctorWithIndices&gt;, MatScalar&gt; lm (num_diff);
-  int info = lm.minimize (x);
-
-  // Compute the norm of the residuals
-  PCL_DEBUG ("[pcl::registration::TransformationEstimationLM::estimateRigidTransformation] LM solver finished with exit code %i, having a residual norm of %g. \n", info, lm.fvec.norm ());
-  PCL_DEBUG ("Final solution: [%f", x[0]);
-  for (int i = 1; i &lt; n_unknowns; ++i) 
-    PCL_DEBUG (" %f", x[i]);
-  PCL_DEBUG ("]\n");
-
-  // Return the correct transformation
-  warp_point_-&gt;setParam (x);
-  transformation_matrix = warp_point_-&gt;getTransform ();
-
-  tmp_src_ = NULL;
-  tmp_tgt_ = NULL;
-  tmp_idx_src_ = tmp_idx_tgt_ = NULL;
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename MatScalar&gt; inline void
-pcl::registration::TransformationEstimationLM&lt;PointSource, PointTarget, MatScalar&gt;::estimateRigidTransformation (
-    const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-    const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-    const pcl::Correspondences &amp;correspondences,
-    Matrix4 &amp;transformation_matrix) const
-{
-  const int nr_correspondences = static_cast&lt;const int&gt; (correspondences.size ());
-  std::vector&lt;int&gt; indices_src (nr_correspondences);
-  std::vector&lt;int&gt; indices_tgt (nr_correspondences);
-  for (int i = 0; i &lt; nr_correspondences; ++i)
-  {
-    indices_src[i] = correspondences[i].index_query;
-    indices_tgt[i] = correspondences[i].index_match;
-  }
-
-  estimateRigidTransformation (cloud_src, indices_src, cloud_tgt, indices_tgt, transformation_matrix);
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename MatScalar&gt; int 
-pcl::registration::TransformationEstimationLM&lt;PointSource, PointTarget, MatScalar&gt;::OptimizationFunctor::operator () (
-    const VectorX &amp;x, VectorX &amp;fvec) const
-{
-  const PointCloud&lt;PointSource&gt; &amp; src_points = *estimator_-&gt;tmp_src_;
-  const PointCloud&lt;PointTarget&gt; &amp; tgt_points = *estimator_-&gt;tmp_tgt_;
-
-  // Initialize the warp function with the given parameters
-  estimator_-&gt;warp_point_-&gt;setParam (x);
-
-  // Transform each source point and compute its distance to the corresponding target point
-  for (int i = 0; i &lt; values (); ++i)
-  {
-    const PointSource &amp; p_src = src_points.points[i];
-    const PointTarget &amp; p_tgt = tgt_points.points[i];
-
-    // Transform the source point based on the current warp parameters
-    Vector4 p_src_warped;
-    estimator_-&gt;warp_point_-&gt;warpPoint (p_src, p_src_warped);
-
-    // Estimate the distance (cost function)
-    fvec[i] = estimator_-&gt;computeDistance (p_src_warped, p_tgt);
-  }
-  return (0);
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename MatScalar&gt; int
-pcl::registration::TransformationEstimationLM&lt;PointSource, PointTarget, MatScalar&gt;::OptimizationFunctorWithIndices::operator() (
-    const VectorX &amp;x, VectorX &amp;fvec) const
-{
-  const PointCloud&lt;PointSource&gt; &amp; src_points = *estimator_-&gt;tmp_src_;
-  const PointCloud&lt;PointTarget&gt; &amp; tgt_points = *estimator_-&gt;tmp_tgt_;
-  const std::vector&lt;int&gt; &amp; src_indices = *estimator_-&gt;tmp_idx_src_;
-  const std::vector&lt;int&gt; &amp; tgt_indices = *estimator_-&gt;tmp_idx_tgt_;
-
-  // Initialize the warp function with the given parameters
-  estimator_-&gt;warp_point_-&gt;setParam (x);
-
-  // Transform each source point and compute its distance to the corresponding target point
-  for (int i = 0; i &lt; values (); ++i)
-  {
-    const PointSource &amp; p_src = src_points.points[src_indices[i]];
-    const PointTarget &amp; p_tgt = tgt_points.points[tgt_indices[i]];
-
-    // Transform the source point based on the current warp parameters
-    Vector4 p_src_warped;
-    estimator_-&gt;warp_point_-&gt;warpPoint (p_src, p_src_warped);
-    
-    // Estimate the distance (cost function)
-    fvec[i] = estimator_-&gt;computeDistance (p_src_warped, p_tgt);
-  }
-  return (0);
-}
-
-//#define PCL_INSTANTIATE_TransformationEstimationLM(T,U) template class PCL_EXPORTS pcl::registration::TransformationEstimationLM&lt;T,U&gt;;
-
-#endif /* FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_LM_HPP_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\impl\transformation_estimation_point_to_plane_lls.hpp" new_path="" added_lines="0" deleted_lines="250">
				<diff>@@ -1,250 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-#ifndef FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_POINT_TO_PLANE_LLS_HPP_
-#define FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_POINT_TO_PLANE_LLS_HPP_
-#include &lt;pcl/cloud_iterator.h&gt;
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline void
-pcl::registration::TransformationEstimationPointToPlaneLLS&lt;PointSource, PointTarget, Scalar&gt;::
-estimateRigidTransformation (const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-                             const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-                             Matrix4 &amp;transformation_matrix) const
-{
-  size_t nr_points = cloud_src.points.size ();
-  if (cloud_tgt.points.size () != nr_points)
-  {
-    PCL_ERROR ("[pcl::TransformationEstimationPointToPlaneLLS::estimateRigidTransformation] Number or points in source (%lu) differs than target (%lu)!\n", nr_points, cloud_tgt.points.size ());
-    return;
-  }
-
-  ConstCloudIterator&lt;PointSource&gt; source_it (cloud_src);
-  ConstCloudIterator&lt;PointTarget&gt; target_it (cloud_tgt);
-  estimateRigidTransformation (source_it, target_it, transformation_matrix);  
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; void
-pcl::registration::TransformationEstimationPointToPlaneLLS&lt;PointSource, PointTarget, Scalar&gt;::
-estimateRigidTransformation (const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-                             const std::vector&lt;int&gt; &amp;indices_src,
-                             const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-                             Matrix4 &amp;transformation_matrix) const
-{
-  size_t nr_points = indices_src.size ();
-  if (cloud_tgt.points.size () != nr_points)
-  {
-    PCL_ERROR ("[pcl::TransformationEstimationPointToPlaneLLS::estimateRigidTransformation] Number or points in source (%lu) differs than target (%lu)!\n", indices_src.size (), cloud_tgt.points.size ());
-    return;
-  }
-
-  ConstCloudIterator&lt;PointSource&gt; source_it (cloud_src, indices_src);
-  ConstCloudIterator&lt;PointTarget&gt; target_it (cloud_tgt);
-  estimateRigidTransformation (source_it, target_it, transformation_matrix);  
-}
-
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline void
-pcl::registration::TransformationEstimationPointToPlaneLLS&lt;PointSource, PointTarget, Scalar&gt;::
-estimateRigidTransformation (const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-                             const std::vector&lt;int&gt; &amp;indices_src,
-                             const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-                             const std::vector&lt;int&gt; &amp;indices_tgt,
-                             Matrix4 &amp;transformation_matrix) const
-{
-  size_t nr_points = indices_src.size ();
-  if (indices_tgt.size () != nr_points)
-  {
-    PCL_ERROR ("[pcl::TransformationEstimationPointToPlaneLLS::estimateRigidTransformation] Number or points in source (%lu) differs than target (%lu)!\n", indices_src.size (), indices_tgt.size ());
-    return;
-  }
-
-  ConstCloudIterator&lt;PointSource&gt; source_it (cloud_src, indices_src);
-  ConstCloudIterator&lt;PointTarget&gt; target_it (cloud_tgt, indices_tgt);
-  estimateRigidTransformation (source_it, target_it, transformation_matrix);  
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline void
-pcl::registration::TransformationEstimationPointToPlaneLLS&lt;PointSource, PointTarget, Scalar&gt;::
-estimateRigidTransformation (const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-                             const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-                             const pcl::Correspondences &amp;correspondences,
-                             Matrix4 &amp;transformation_matrix) const
-{
-  ConstCloudIterator&lt;PointSource&gt; source_it (cloud_src, correspondences, true);
-  ConstCloudIterator&lt;PointTarget&gt; target_it (cloud_tgt, correspondences, false);
-  estimateRigidTransformation (source_it, target_it, transformation_matrix);
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline void
-pcl::registration::TransformationEstimationPointToPlaneLLS&lt;PointSource, PointTarget, Scalar&gt;::
-constructTransformationMatrix (const double &amp; alpha, const double &amp; beta, const double &amp; gamma,
-                               const double &amp; tx,    const double &amp; ty,   const double &amp; tz,
-                               Matrix4 &amp;transformation_matrix) const
-{
-  // Construct the transformation matrix from rotation and translation 
-  transformation_matrix = Eigen::Matrix&lt;Scalar, 4, 4&gt;::Zero ();
-  transformation_matrix (0, 0) = static_cast&lt;Scalar&gt; ( cos (gamma) * cos (beta));
-  transformation_matrix (0, 1) = static_cast&lt;Scalar&gt; (-sin (gamma) * cos (alpha) + cos (gamma) * sin (beta) * sin (alpha));
-  transformation_matrix (0, 2) = static_cast&lt;Scalar&gt; ( sin (gamma) * sin (alpha) + cos (gamma) * sin (beta) * cos (alpha));
-  transformation_matrix (1, 0) = static_cast&lt;Scalar&gt; ( sin (gamma) * cos (beta));
-  transformation_matrix (1, 1) = static_cast&lt;Scalar&gt; ( cos (gamma) * cos (alpha) + sin (gamma) * sin (beta) * sin (alpha));
-  transformation_matrix (1, 2) = static_cast&lt;Scalar&gt; (-cos (gamma) * sin (alpha) + sin (gamma) * sin (beta) * cos (alpha));
-  transformation_matrix (2, 0) = static_cast&lt;Scalar&gt; (-sin (beta));
-  transformation_matrix (2, 1) = static_cast&lt;Scalar&gt; ( cos (beta) * sin (alpha));
-  transformation_matrix (2, 2) = static_cast&lt;Scalar&gt; ( cos (beta) * cos (alpha));
-
-  transformation_matrix (0, 3) = static_cast&lt;Scalar&gt; (tx);
-  transformation_matrix (1, 3) = static_cast&lt;Scalar&gt; (ty);
-  transformation_matrix (2, 3) = static_cast&lt;Scalar&gt; (tz);
-  transformation_matrix (3, 3) = static_cast&lt;Scalar&gt; (1);
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline void
-pcl::registration::TransformationEstimationPointToPlaneLLS&lt;PointSource, PointTarget, Scalar&gt;::
-estimateRigidTransformation (ConstCloudIterator&lt;PointSource&gt;&amp; source_it, ConstCloudIterator&lt;PointTarget&gt;&amp; target_it, Matrix4 &amp;transformation_matrix) const
-{
-  typedef Eigen::Matrix&lt;double, 6, 1&gt; Vector6d;
-  typedef Eigen::Matrix&lt;double, 6, 6&gt; Matrix6d;
-
-  Matrix6d ATA;
-  Vector6d ATb;
-  ATA.setZero ();
-  ATb.setZero ();
-
-  // Approximate as a linear least squares problem
-  while (source_it.isValid () &amp;&amp; target_it.isValid ())
-  {
-    if (!pcl_isfinite (source_it-&gt;x) ||
-        !pcl_isfinite (source_it-&gt;y) ||
-        !pcl_isfinite (source_it-&gt;z) ||
-        !pcl_isfinite (target_it-&gt;x) ||
-        !pcl_isfinite (target_it-&gt;y) ||
-        !pcl_isfinite (target_it-&gt;z) ||
-        !pcl_isfinite (target_it-&gt;normal_x) ||
-        !pcl_isfinite (target_it-&gt;normal_y) ||
-        !pcl_isfinite (target_it-&gt;normal_z))
-    {
-      ++target_it;
-      ++source_it;    
-      continue;
-    }
-
-    const float &amp; sx = source_it-&gt;x;
-    const float &amp; sy = source_it-&gt;y;
-    const float &amp; sz = source_it-&gt;z;
-    const float &amp; dx = target_it-&gt;x;
-    const float &amp; dy = target_it-&gt;y;
-    const float &amp; dz = target_it-&gt;z;
-    const float &amp; nx = target_it-&gt;normal[0];
-    const float &amp; ny = target_it-&gt;normal[1];
-    const float &amp; nz = target_it-&gt;normal[2];
-
-    double a = nz*sy - ny*sz;
-    double b = nx*sz - nz*sx; 
-    double c = ny*sx - nx*sy;
-   
-    //    0  1  2  3  4  5
-    //    6  7  8  9 10 11
-    //   12 13 14 15 16 17
-    //   18 19 20 21 22 23
-    //   24 25 26 27 28 29
-    //   30 31 32 33 34 35
-   
-    ATA.coeffRef (0) += a * a;
-    ATA.coeffRef (1) += a * b;
-    ATA.coeffRef (2) += a * c;
-    ATA.coeffRef (3) += a * nx;
-    ATA.coeffRef (4) += a * ny;
-    ATA.coeffRef (5) += a * nz;
-    ATA.coeffRef (7) += b * b;
-    ATA.coeffRef (8) += b * c;
-    ATA.coeffRef (9) += b * nx;
-    ATA.coeffRef (10) += b * ny;
-    ATA.coeffRef (11) += b * nz;
-    ATA.coeffRef (14) += c * c;
-    ATA.coeffRef (15) += c * nx;
-    ATA.coeffRef (16) += c * ny;
-    ATA.coeffRef (17) += c * nz;
-    ATA.coeffRef (21) += nx * nx;
-    ATA.coeffRef (22) += nx * ny;
-    ATA.coeffRef (23) += nx * nz;
-    ATA.coeffRef (28) += ny * ny;
-    ATA.coeffRef (29) += ny * nz;
-    ATA.coeffRef (35) += nz * nz;
-
-    double d = nx*dx + ny*dy + nz*dz - nx*sx - ny*sy - nz*sz;
-    ATb.coeffRef (0) += a * d;
-    ATb.coeffRef (1) += b * d;
-    ATb.coeffRef (2) += c * d;
-    ATb.coeffRef (3) += nx * d;
-    ATb.coeffRef (4) += ny * d;
-    ATb.coeffRef (5) += nz * d;
-
-    ++target_it;
-    ++source_it;    
-  }
-  ATA.coeffRef (6) = ATA.coeff (1);
-  ATA.coeffRef (12) = ATA.coeff (2);
-  ATA.coeffRef (13) = ATA.coeff (8);
-  ATA.coeffRef (18) = ATA.coeff (3);
-  ATA.coeffRef (19) = ATA.coeff (9);
-  ATA.coeffRef (20) = ATA.coeff (15);
-  ATA.coeffRef (24) = ATA.coeff (4);
-  ATA.coeffRef (25) = ATA.coeff (10);
-  ATA.coeffRef (26) = ATA.coeff (16);
-  ATA.coeffRef (27) = ATA.coeff (22);
-  ATA.coeffRef (30) = ATA.coeff (5);
-  ATA.coeffRef (31) = ATA.coeff (11);
-  ATA.coeffRef (32) = ATA.coeff (17);
-  ATA.coeffRef (33) = ATA.coeff (23);
-  ATA.coeffRef (34) = ATA.coeff (29);
-
-  // Solve A*x = b
-  Vector6d x = static_cast&lt;Vector6d&gt; (ATA.inverse () * ATb);
-  
-  // Construct the transformation matrix from x
-  constructTransformationMatrix (x (0), x (1), x (2), x (3), x (4), x (5), transformation_matrix);
-}
-#endif /* FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_POINT_TO_PLANE_LLS_HPP_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\impl\transformation_estimation_svd.hpp" new_path="" added_lines="0" deleted_lines="206">
				<diff>@@ -1,206 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-#ifndef FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_SVD_HPP_
-#define FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_SVD_HPP_
-
-#include &lt;pcl/common/eigen.h&gt;
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline void
-pcl::registration::TransformationEstimationSVD&lt;PointSource, PointTarget, Scalar&gt;::estimateRigidTransformation (
-    const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-    const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-    Matrix4 &amp;transformation_matrix) const
-{
-  size_t nr_points = cloud_src.points.size ();
-  if (cloud_tgt.points.size () != nr_points)
-  {
-    PCL_ERROR ("[pcl::TransformationEstimationSVD::estimateRigidTransformation] Number or points in source (%lu) differs than target (%lu)!\n", nr_points, cloud_tgt.points.size ());
-    return;
-  }
-
-  ConstCloudIterator&lt;PointSource&gt; source_it (cloud_src);
-  ConstCloudIterator&lt;PointTarget&gt; target_it (cloud_tgt);
-  estimateRigidTransformation (source_it, target_it, transformation_matrix);
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; void
-pcl::registration::TransformationEstimationSVD&lt;PointSource, PointTarget, Scalar&gt;::estimateRigidTransformation (
-    const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-    const std::vector&lt;int&gt; &amp;indices_src,
-    const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-    Matrix4 &amp;transformation_matrix) const
-{
-  if (indices_src.size () != cloud_tgt.points.size ())
-  {
-    PCL_ERROR ("[pcl::TransformationSVD::estimateRigidTransformation] Number or points in source (%lu) differs than target (%lu)!\n", indices_src.size (), cloud_tgt.points.size ());
-    return;
-  }
-
-  ConstCloudIterator&lt;PointSource&gt; source_it (cloud_src, indices_src);
-  ConstCloudIterator&lt;PointTarget&gt; target_it (cloud_tgt);
-  estimateRigidTransformation (source_it, target_it, transformation_matrix);
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline void
-pcl::registration::TransformationEstimationSVD&lt;PointSource, PointTarget, Scalar&gt;::estimateRigidTransformation (
-    const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-    const std::vector&lt;int&gt; &amp;indices_src,
-    const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-    const std::vector&lt;int&gt; &amp;indices_tgt,
-    Matrix4 &amp;transformation_matrix) const
-{
-  if (indices_src.size () != indices_tgt.size ())
-  {
-    PCL_ERROR ("[pcl::TransformationEstimationSVD::estimateRigidTransformation] Number or points in source (%lu) differs than target (%lu)!\n", indices_src.size (), indices_tgt.size ());
-    return;
-  }
-
-  ConstCloudIterator&lt;PointSource&gt; source_it (cloud_src, indices_src);
-  ConstCloudIterator&lt;PointTarget&gt; target_it (cloud_tgt, indices_tgt);
-  estimateRigidTransformation (source_it, target_it, transformation_matrix);
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; void
-pcl::registration::TransformationEstimationSVD&lt;PointSource, PointTarget, Scalar&gt;::estimateRigidTransformation (
-    const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-    const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-    const pcl::Correspondences &amp;correspondences,
-    Matrix4 &amp;transformation_matrix) const
-{
-  ConstCloudIterator&lt;PointSource&gt; source_it (cloud_src, correspondences, true);
-  ConstCloudIterator&lt;PointTarget&gt; target_it (cloud_tgt, correspondences, false);
-  estimateRigidTransformation (source_it, target_it, transformation_matrix);
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline void
-pcl::registration::TransformationEstimationSVD&lt;PointSource, PointTarget, Scalar&gt;::estimateRigidTransformation (
-    ConstCloudIterator&lt;PointSource&gt;&amp; source_it,
-    ConstCloudIterator&lt;PointTarget&gt;&amp; target_it,
-    Matrix4 &amp;transformation_matrix) const
-{
-  // Convert to Eigen format
-  const int npts = static_cast &lt;int&gt; (source_it.size ());
-
-
-
-  if (use_umeyama_)
-  {
-    Eigen::Matrix&lt;Scalar, 3, Eigen::Dynamic&gt; cloud_src (3, npts);
-    Eigen::Matrix&lt;Scalar, 3, Eigen::Dynamic&gt; cloud_tgt (3, npts);
-
-    for (int i = 0; i &lt; npts; ++i)
-    {
-      cloud_src (0, i) = source_it-&gt;x;
-      cloud_src (1, i) = source_it-&gt;y;
-      cloud_src (2, i) = source_it-&gt;z;
-      ++source_it;
-
-      cloud_tgt (0, i) = target_it-&gt;x;
-      cloud_tgt (1, i) = target_it-&gt;y;
-      cloud_tgt (2, i) = target_it-&gt;z;
-      ++target_it;
-    }
-    
-    // Call Umeyama directly from Eigen (PCL patched version until Eigen is released)
-    transformation_matrix = pcl::umeyama (cloud_src, cloud_tgt, false);
-  }
-  else
-  {
-    source_it.reset (); target_it.reset ();
-    // &lt;cloud_src,cloud_src&gt; is the source dataset
-    transformation_matrix.setIdentity ();
-
-    Eigen::Matrix&lt;Scalar, 4, 1&gt; centroid_src, centroid_tgt;
-    // Estimate the centroids of source, target
-    compute3DCentroid (source_it, centroid_src);
-    compute3DCentroid (target_it, centroid_tgt);
-    source_it.reset (); target_it.reset ();
-
-    // Subtract the centroids from source, target
-    Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt; cloud_src_demean, cloud_tgt_demean;
-    demeanPointCloud (source_it, centroid_src, cloud_src_demean);
-    demeanPointCloud (target_it, centroid_tgt, cloud_tgt_demean);
-
-    getTransformationFromCorrelation (cloud_src_demean, centroid_src, cloud_tgt_demean, centroid_tgt, transformation_matrix);
-  }
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; void
-pcl::registration::TransformationEstimationSVD&lt;PointSource, PointTarget, Scalar&gt;::getTransformationFromCorrelation (
-    const Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt; &amp;cloud_src_demean,
-    const Eigen::Matrix&lt;Scalar, 4, 1&gt; &amp;centroid_src,
-    const Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt; &amp;cloud_tgt_demean,
-    const Eigen::Matrix&lt;Scalar, 4, 1&gt; &amp;centroid_tgt,
-    Matrix4 &amp;transformation_matrix) const
-{
-  transformation_matrix.setIdentity ();
-
-  // Assemble the correlation matrix H = source * target'
-  Eigen::Matrix&lt;Scalar, 3, 3&gt; H = (cloud_src_demean * cloud_tgt_demean.transpose ()).topLeftCorner (3, 3);
-
-  // Compute the Singular Value Decomposition
-  Eigen::JacobiSVD&lt;Eigen::Matrix&lt;Scalar, 3, 3&gt; &gt; svd (H, Eigen::ComputeFullU | Eigen::ComputeFullV);
-  Eigen::Matrix&lt;Scalar, 3, 3&gt; u = svd.matrixU ();
-  Eigen::Matrix&lt;Scalar, 3, 3&gt; v = svd.matrixV ();
-
-  // Compute R = V * U'
-  if (u.determinant () * v.determinant () &lt; 0)
-  {
-    for (int x = 0; x &lt; 3; ++x)
-      v (x, 2) *= -1;
-  }
-
-  Eigen::Matrix&lt;Scalar, 3, 3&gt; R = v * u.transpose ();
-
-  // Return the correct transformation
-  transformation_matrix.topLeftCorner (3, 3) = R;
-  const Eigen::Matrix&lt;Scalar, 3, 1&gt; Rc (R * centroid_src.head (3));
-  transformation_matrix.block (0, 3, 3, 1) = centroid_tgt.head (3) - Rc;
-}
-
-//#define PCL_INSTANTIATE_TransformationEstimationSVD(T,U) template class PCL_EXPORTS pcl::registration::TransformationEstimationSVD&lt;T,U&gt;;
-
-#endif /* FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_SVD_HPP_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\transformation_estimation.h" new_path="" added_lines="0" deleted_lines="130">
				<diff>@@ -1,130 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-#ifndef FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_H_
-#define FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_H_
-
-#include &lt;pcl/correspondence.h&gt;
-#include &lt;pcl/common/transforms.h&gt;
-//#include &lt;pcl/registration/correspondence_types.h&gt;
-#include "fast_pcl/registration/correspondence_types.h"
-
-namespace pcl
-{
-  namespace registration
-  {
-    /** \brief TransformationEstimation represents the base class for methods for transformation estimation based on:
-      *   - correspondence vectors
-      *   - two point clouds (source and target) of the same size
-      *   - a point cloud with a set of indices (source), and another point cloud (target)
-      *   - two point clouds with two sets of indices (source and target) of the same size
-      *
-      * \note The class is templated on the source and target point types as well as on the output scalar of the transformation matrix (i.e., float or double). Default: float.
-      * \author Dirk Holz, Radu B. Rusu
-      * \ingroup registration
-      */
-    template &lt;typename PointSource, typename PointTarget, typename Scalar = float&gt;
-    class TransformationEstimation
-    {
-      public:
-        typedef Eigen::Matrix&lt;Scalar, 4, 4&gt; Matrix4;
-
-        TransformationEstimation () {};
-        virtual ~TransformationEstimation () {};
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        virtual void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            Matrix4 &amp;transformation_matrix) const = 0;
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] indices_src the vector of indices describing the points of interest in \a cloud_src
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        virtual void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const std::vector&lt;int&gt; &amp;indices_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            Matrix4 &amp;transformation_matrix) const = 0;
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] indices_src the vector of indices describing the points of interest in \a cloud_src
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[in] indices_tgt the vector of indices describing the correspondences of the interst points from \a indices_src
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        virtual void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const std::vector&lt;int&gt; &amp;indices_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            const std::vector&lt;int&gt; &amp;indices_tgt,
-            Matrix4 &amp;transformation_matrix) const = 0;
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[in] correspondences the vector of correspondences between source and target point cloud
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        virtual void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            const pcl::Correspondences &amp;correspondences,
-            Matrix4 &amp;transformation_matrix) const = 0;
-
-
-        typedef boost::shared_ptr&lt;TransformationEstimation&lt;PointSource, PointTarget, Scalar&gt; &gt; Ptr;
-        typedef boost::shared_ptr&lt;const TransformationEstimation&lt;PointSource, PointTarget, Scalar&gt; &gt; ConstPtr;
-    };
-  }
-}
-
-#endif /* FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\transformation_estimation_lm.h" new_path="" added_lines="0" deleted_lines="360">
				<diff>@@ -1,360 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-#ifndef FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_LM_H_
-#define FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_LM_H_
-
-//#include &lt;pcl/registration/transformation_estimation.h&gt;
-//#include &lt;pcl/registration/warp_point_rigid.h&gt;
-//#include &lt;pcl/registration/distances.h&gt;
-#include "fast_pcl/registration/transformation_estimation.h"
-#include "fast_pcl/registration/warp_point_rigid.h"
-#include "fast_pcl/registration/distances.h"
-
-namespace pcl
-{
-  namespace registration
-  {
-    /** @b TransformationEstimationLM implements Levenberg Marquardt-based
-      * estimation of the transformation aligning the given correspondences.
-      *
-      * \note The class is templated on the source and target point types as well as on the output scalar of the transformation matrix (i.e., float or double). Default: float.
-      * \author Radu B. Rusu
-      * \ingroup registration
-      */
-    template &lt;typename PointSource, typename PointTarget, typename MatScalar = float&gt;
-    class TransformationEstimationLM : public TransformationEstimation&lt;PointSource, PointTarget, MatScalar&gt;
-    {
-      typedef pcl::PointCloud&lt;PointSource&gt; PointCloudSource;
-      typedef typename PointCloudSource::Ptr PointCloudSourcePtr;
-      typedef typename PointCloudSource::ConstPtr PointCloudSourceConstPtr;
-
-      typedef pcl::PointCloud&lt;PointTarget&gt; PointCloudTarget;
-
-      typedef PointIndices::Ptr PointIndicesPtr;
-      typedef PointIndices::ConstPtr PointIndicesConstPtr;
-
-      public:
-        typedef boost::shared_ptr&lt;TransformationEstimationLM&lt;PointSource, PointTarget, MatScalar&gt; &gt; Ptr;
-        typedef boost::shared_ptr&lt;const TransformationEstimationLM&lt;PointSource, PointTarget, MatScalar&gt; &gt; ConstPtr;
-
-        typedef Eigen::Matrix&lt;MatScalar, Eigen::Dynamic, 1&gt; VectorX;
-        typedef Eigen::Matrix&lt;MatScalar, 4, 1&gt; Vector4;
-        typedef typename TransformationEstimation&lt;PointSource, PointTarget, MatScalar&gt;::Matrix4 Matrix4;
-        
-        /** \brief Constructor. */
-        TransformationEstimationLM ();
-
-        /** \brief Copy constructor. 
-          * \param[in] src the TransformationEstimationLM object to copy into this 
-          */
-        TransformationEstimationLM (const TransformationEstimationLM &amp;src) : 
-          tmp_src_ (src.tmp_src_), 
-          tmp_tgt_ (src.tmp_tgt_), 
-          tmp_idx_src_ (src.tmp_idx_src_), 
-          tmp_idx_tgt_ (src.tmp_idx_tgt_), 
-          warp_point_ (src.warp_point_)
-        {};
-
-        /** \brief Copy operator. 
-          * \param[in] src the TransformationEstimationLM object to copy into this 
-          */
-        TransformationEstimationLM&amp;
-        operator = (const TransformationEstimationLM &amp;src)
-        {
-          tmp_src_ = src.tmp_src_; 
-          tmp_tgt_ = src.tmp_tgt_; 
-          tmp_idx_src_ = src.tmp_idx_src_;
-          tmp_idx_tgt_ = src.tmp_idx_tgt_; 
-          warp_point_ = src.warp_point_;
-        }
-
-         /** \brief Destructor. */
-        virtual ~TransformationEstimationLM () {};
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud using LM.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        inline void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            Matrix4 &amp;transformation_matrix) const;
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud using LM.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] indices_src the vector of indices describing the points of interest in \a cloud_src
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        inline void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const std::vector&lt;int&gt; &amp;indices_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            Matrix4 &amp;transformation_matrix) const;
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud using LM.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] indices_src the vector of indices describing the points of interest in \a cloud_src
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[in] indices_tgt the vector of indices describing the correspondences of the interst points from 
-          * \a indices_src
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        inline void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const std::vector&lt;int&gt; &amp;indices_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            const std::vector&lt;int&gt; &amp;indices_tgt,
-            Matrix4 &amp;transformation_matrix) const;
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud using LM.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[in] correspondences the vector of correspondences between source and target point cloud
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        inline void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            const pcl::Correspondences &amp;correspondences,
-            Matrix4 &amp;transformation_matrix) const;
-
-        /** \brief Set the function we use to warp points. Defaults to rigid 6D warp.
-          * \param[in] warp_fcn a shared pointer to an object that warps points
-          */
-        void
-        setWarpFunction (const boost::shared_ptr&lt;WarpPointRigid&lt;PointSource, PointTarget, MatScalar&gt; &gt; &amp;warp_fcn)
-        {
-          warp_point_ = warp_fcn;
-        }
-
-      protected:
-        /** \brief Compute the distance between a source point and its corresponding target point
-          * \param[in] p_src The source point
-          * \param[in] p_tgt The target point
-          * \return The distance between \a p_src and \a p_tgt
-          *
-          * \note Older versions of PCL used this method internally for calculating the
-          * optimization gradient. Since PCL 1.7, a switch has been made to the 
-          * computeDistance method using Vector4 types instead. This method is only 
-          * kept for API compatibility reasons.
-          */
-        virtual MatScalar
-        computeDistance (const PointSource &amp;p_src, const PointTarget &amp;p_tgt) const
-        {
-          Vector4 s (p_src.x, p_src.y, p_src.z, 0);
-          Vector4 t (p_tgt.x, p_tgt.y, p_tgt.z, 0);
-          return ((s - t).norm ());
-        }
-
-        /** \brief Compute the distance between a source point and its corresponding target point
-          * \param[in] p_src The source point
-          * \param[in] p_tgt The target point
-          * \return The distance between \a p_src and \a p_tgt
-          *
-          * \note A different distance function can be defined by creating a subclass of 
-          * TransformationEstimationLM and overriding this method. 
-          * (See \a TransformationEstimationPointToPlane)
-          */
-        virtual MatScalar
-        computeDistance (const Vector4 &amp;p_src, const PointTarget &amp;p_tgt) const
-        {
-          Vector4 t (p_tgt.x, p_tgt.y, p_tgt.z, 0);
-          return ((p_src - t).norm ());
-        }
-
-        /** \brief Temporary pointer to the source dataset. */
-        mutable const PointCloudSource *tmp_src_;
-
-        /** \brief Temporary pointer to the target dataset. */
-        mutable const PointCloudTarget  *tmp_tgt_;
-
-        /** \brief Temporary pointer to the source dataset indices. */
-        mutable const std::vector&lt;int&gt; *tmp_idx_src_;
-
-        /** \brief Temporary pointer to the target dataset indices. */
-        mutable const std::vector&lt;int&gt; *tmp_idx_tgt_;
-
-        /** \brief The parameterized function used to warp the source to the target. */
-        boost::shared_ptr&lt;pcl::registration::WarpPointRigid&lt;PointSource, PointTarget, MatScalar&gt; &gt; warp_point_;
-        
-        /** Base functor all the models that need non linear optimization must
-          * define their own one and implement operator() (const Eigen::VectorXd&amp; x, Eigen::VectorXd&amp; fvec)
-          * or operator() (const Eigen::VectorXf&amp; x, Eigen::VectorXf&amp; fvec) dependening on the choosen _Scalar
-          */
-        template&lt;typename _Scalar, int NX=Eigen::Dynamic, int NY=Eigen::Dynamic&gt;
-        struct Functor
-        {
-          typedef _Scalar Scalar;
-          enum 
-          {
-            InputsAtCompileTime = NX,
-            ValuesAtCompileTime = NY
-          };
-          typedef Eigen::Matrix&lt;_Scalar,InputsAtCompileTime,1&gt; InputType;
-          typedef Eigen::Matrix&lt;_Scalar,ValuesAtCompileTime,1&gt; ValueType;
-          typedef Eigen::Matrix&lt;_Scalar,ValuesAtCompileTime,InputsAtCompileTime&gt; JacobianType;
-
-          /** \brief Empty Construtor. */
-          Functor () : m_data_points_ (ValuesAtCompileTime) {}
-
-          /** \brief Constructor
-            * \param[in] m_data_points number of data points to evaluate.
-            */
-          Functor (int m_data_points) : m_data_points_ (m_data_points) {}
-        
-          /** \brief Destructor. */
-          virtual ~Functor () {}
-
-          /** \brief Get the number of values. */ 
-          int
-          values () const { return (m_data_points_); }
-
-          protected:
-            int m_data_points_;
-        };
-
-        struct OptimizationFunctor : public Functor&lt;MatScalar&gt;
-        {
-          using Functor&lt;MatScalar&gt;::values;
-
-          /** Functor constructor
-            * \param[in] m_data_points the number of data points to evaluate
-            * \param[in,out] estimator pointer to the estimator object
-            */
-          OptimizationFunctor (int m_data_points, 
-                               const TransformationEstimationLM *estimator) 
-            :  Functor&lt;MatScalar&gt; (m_data_points), estimator_ (estimator) 
-          {}
-
-          /** Copy constructor
-            * \param[in] src the optimization functor to copy into this
-            */
-          inline OptimizationFunctor (const OptimizationFunctor &amp;src) : 
-            Functor&lt;MatScalar&gt; (src.m_data_points_), estimator_ ()
-          {
-            *this = src;
-          }
-
-          /** Copy operator
-            * \param[in] src the optimization functor to copy into this
-            */
-          inline OptimizationFunctor&amp; 
-          operator = (const OptimizationFunctor &amp;src) 
-          { 
-            Functor&lt;MatScalar&gt;::operator=(src);
-            estimator_ = src.estimator_; 
-            return (*this); 
-          }
-
-          /** \brief Destructor. */
-          virtual ~OptimizationFunctor () {}
-
-          /** Fill fvec from x. For the current state vector x fill the f values
-            * \param[in] x state vector
-            * \param[out] fvec f values vector
-            */
-          int 
-          operator () (const VectorX &amp;x, VectorX &amp;fvec) const;
-
-          const TransformationEstimationLM&lt;PointSource, PointTarget, MatScalar&gt; *estimator_;
-        };
-
-        struct OptimizationFunctorWithIndices : public Functor&lt;MatScalar&gt;
-        {
-          using Functor&lt;MatScalar&gt;::values;
-
-          /** Functor constructor
-            * \param[in] m_data_points the number of data points to evaluate
-            * \param[in,out] estimator pointer to the estimator object
-            */
-          OptimizationFunctorWithIndices (int m_data_points, 
-                                          const TransformationEstimationLM *estimator) 
-            : Functor&lt;MatScalar&gt; (m_data_points), estimator_ (estimator) 
-          {}
-
-          /** Copy constructor
-            * \param[in] src the optimization functor to copy into this
-            */
-          inline OptimizationFunctorWithIndices (const OptimizationFunctorWithIndices &amp;src)
-            : Functor&lt;MatScalar&gt; (src.m_data_points_), estimator_ ()
-          {
-            *this = src;
-          }
-
-          /** Copy operator
-            * \param[in] src the optimization functor to copy into this
-            */
-          inline OptimizationFunctorWithIndices&amp; 
-          operator = (const OptimizationFunctorWithIndices &amp;src) 
-          { 
-            Functor&lt;MatScalar&gt;::operator=(src);
-            estimator_ = src.estimator_; 
-            return (*this); 
-          }
-
-          /** \brief Destructor. */
-          virtual ~OptimizationFunctorWithIndices () {}
-
-          /** Fill fvec from x. For the current state vector x fill the f values
-            * \param[in] x state vector
-            * \param[out] fvec f values vector
-            */
-          int 
-          operator () (const VectorX &amp;x, VectorX &amp;fvec) const;
-
-          const TransformationEstimationLM&lt;PointSource, PointTarget, MatScalar&gt; *estimator_;
-        };
-      public:
-        EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-    };
-  }
-}
-
-//#include &lt;pcl/registration/impl/transformation_estimation_lm.hpp&gt;
-#include "fast_pcl/registration/impl/transformation_estimation_lm.hpp"
-
-#endif /* FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_LM_H_ */
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\transformation_estimation_point_to_plane_lls.h" new_path="" added_lines="0" deleted_lines="161">
				<diff>@@ -1,161 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-#ifndef FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_POINT_TO_PLANE_LLS_H_ 
-#define FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_POINT_TO_PLANE_LLS_H_
-
-//#include &lt;pcl/registration/transformation_estimation.h&gt;
-//#include &lt;pcl/registration/warp_point_rigid.h&gt;
-#include "fast_pcl/registration/transformation_estimation.h"
-#include "fast_pcl/registration/warp_point_rigid.h"
-#include &lt;pcl/cloud_iterator.h&gt;
-
-namespace pcl
-{
-  namespace registration
-  {
-    /** \brief @b TransformationEstimationPointToPlaneLLS implements a Linear Least Squares (LLS) approximation
-      * for minimizing the point-to-plane distance between two clouds of corresponding points with normals.
-      *
-      * For additional details, see 
-      *   "Linear Least-Squares Optimization for Point-to-Plane ICP Surface Registration", Kok-Lim Low, 2004
-      *
-      * \note The class is templated on the source and target point types as well as on the output scalar of the
-      * transformation matrix (i.e., float or double). Default: float.
-      * \author Michael Dixon
-      * \ingroup registration
-      */
-    template &lt;typename PointSource, typename PointTarget, typename Scalar = float&gt;
-    class TransformationEstimationPointToPlaneLLS : public TransformationEstimation&lt;PointSource, PointTarget, Scalar&gt;
-    {
-      public:
-        typedef boost::shared_ptr&lt;TransformationEstimationPointToPlaneLLS&lt;PointSource, PointTarget, Scalar&gt; &gt; Ptr;
-        typedef boost::shared_ptr&lt;const TransformationEstimationPointToPlaneLLS&lt;PointSource, PointTarget, Scalar&gt; &gt; ConstPtr;
-
-        typedef typename TransformationEstimation&lt;PointSource, PointTarget, Scalar&gt;::Matrix4 Matrix4;
-        
-        TransformationEstimationPointToPlaneLLS () {};
-        virtual ~TransformationEstimationPointToPlaneLLS () {};
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud using SVD.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        inline void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            Matrix4 &amp;transformation_matrix) const;
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud using SVD.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] indices_src the vector of indices describing the points of interest in \a cloud_src
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        inline void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const std::vector&lt;int&gt; &amp;indices_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            Matrix4 &amp;transformation_matrix) const;
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud using SVD.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] indices_src the vector of indices describing the points of interest in \a cloud_src
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[in] indices_tgt the vector of indices describing the correspondences of the interst points from \a indices_src
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        inline void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const std::vector&lt;int&gt; &amp;indices_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            const std::vector&lt;int&gt; &amp;indices_tgt,
-            Matrix4 &amp;transformation_matrix) const;
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud using SVD.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[in] correspondences the vector of correspondences between source and target point cloud
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        inline void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            const pcl::Correspondences &amp;correspondences,
-            Matrix4 &amp;transformation_matrix) const;
-
-      protected:
-        
-        /** \brief Estimate a rigid rotation transformation between a source and a target
-          * \param[in] source_it an iterator over the source point cloud dataset
-          * \param[in] target_it an iterator over the target point cloud dataset
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        void 
-        estimateRigidTransformation (ConstCloudIterator&lt;PointSource&gt;&amp; source_it, 
-                                     ConstCloudIterator&lt;PointTarget&gt;&amp; target_it, 
-                                     Matrix4 &amp;transformation_matrix) const;
-
-        /** \brief Construct a 4 by 4 tranformation matrix from the provided rotation and translation.
-          * \param[in] alpha the rotation about the x-axis
-          * \param[in] beta the rotation about the y-axis
-          * \param[in] gamma the rotation about the z-axis
-          * \param[in] tx the x translation
-          * \param[in] ty the y translation
-          * \param[in] tz the z translation
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        inline void
-        constructTransformationMatrix (const double &amp; alpha, const double &amp; beta, const double &amp; gamma,
-                                       const double &amp; tx,    const double &amp; ty,   const double &amp; tz,
-                                       Matrix4 &amp;transformation_matrix) const;
-
-    };
-  }
-}
-
-//#include &lt;pcl/registration/impl/transformation_estimation_point_to_plane_lls.hpp&gt;
-#include "fast_pcl/registration/impl/transformation_estimation_point_to_plane_lls.hpp"
-
-#endif /* PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_POINT_TO_PLANE_H_LLS_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\transformation_estimation_svd.h" new_path="" added_lines="0" deleted_lines="163">
				<diff>@@ -1,163 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-#ifndef FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_SVD_H_
-#define FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_SVD_H_
-
-//#include &lt;pcl/registration/transformation_estimation.h&gt;
-#include "fast_pcl/registration/transformation_estimation.h"
-#include &lt;pcl/cloud_iterator.h&gt;
-
-namespace pcl
-{
-  namespace registration
-  {
-    /** @b TransformationEstimationSVD implements SVD-based estimation of
-      * the transformation aligning the given correspondences.
-      *
-      * \note The class is templated on the source and target point types as well as on the output scalar of the transformation matrix (i.e., float or double). Default: float.
-      * \author Dirk Holz, Radu B. Rusu
-      * \ingroup registration
-      */
-    template &lt;typename PointSource, typename PointTarget, typename Scalar = float&gt;
-    class TransformationEstimationSVD : public TransformationEstimation&lt;PointSource, PointTarget, Scalar&gt;
-    {
-      public:
-        typedef boost::shared_ptr&lt;TransformationEstimationSVD&lt;PointSource, PointTarget, Scalar&gt; &gt; Ptr;
-        typedef boost::shared_ptr&lt;const TransformationEstimationSVD&lt;PointSource, PointTarget, Scalar&gt; &gt; ConstPtr;
-
-        typedef typename TransformationEstimation&lt;PointSource, PointTarget, Scalar&gt;::Matrix4 Matrix4;
-
-        /** \brief Constructor
-          * \param[in] use_umeyama Toggles whether or not to use 3rd party software*/
-        TransformationEstimationSVD (bool use_umeyama=true):
-          use_umeyama_ (use_umeyama)
-        {}
-
-        virtual ~TransformationEstimationSVD () {};
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud using SVD.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        inline void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            Matrix4 &amp;transformation_matrix) const;
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud using SVD.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] indices_src the vector of indices describing the points of interest in \a cloud_src
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        inline void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const std::vector&lt;int&gt; &amp;indices_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            Matrix4 &amp;transformation_matrix) const;
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud using SVD.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] indices_src the vector of indices describing the points of interest in \a cloud_src
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[in] indices_tgt the vector of indices describing the correspondences of the interst points from \a indices_src
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        inline void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const std::vector&lt;int&gt; &amp;indices_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            const std::vector&lt;int&gt; &amp;indices_tgt,
-            Matrix4 &amp;transformation_matrix) const;
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target point cloud using SVD.
-          * \param[in] cloud_src the source point cloud dataset
-          * \param[in] cloud_tgt the target point cloud dataset
-          * \param[in] correspondences the vector of correspondences between source and target point cloud
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        void
-        estimateRigidTransformation (
-            const pcl::PointCloud&lt;PointSource&gt; &amp;cloud_src,
-            const pcl::PointCloud&lt;PointTarget&gt; &amp;cloud_tgt,
-            const pcl::Correspondences &amp;correspondences,
-            Matrix4 &amp;transformation_matrix) const;
-
-      protected:
-
-        /** \brief Estimate a rigid rotation transformation between a source and a target
-          * \param[in] source_it an iterator over the source point cloud dataset
-          * \param[in] target_it an iterator over the target point cloud dataset
-          * \param[out] transformation_matrix the resultant transformation matrix
-          */
-        void
-        estimateRigidTransformation (ConstCloudIterator&lt;PointSource&gt;&amp; source_it,
-                                     ConstCloudIterator&lt;PointTarget&gt;&amp; target_it,
-                                     Matrix4 &amp;transformation_matrix) const;
-
-        /** \brief Obtain a 4x4 rigid transformation matrix from a correlation matrix H = src * tgt'
-          * \param[in] cloud_src_demean the input source cloud, demeaned, in Eigen format
-          * \param[in] centroid_src the input source centroid, in Eigen format
-          * \param[in] cloud_tgt_demean the input target cloud, demeaned, in Eigen format
-          * \param[in] centroid_tgt the input target cloud, in Eigen format
-          * \param[out] transformation_matrix the resultant 4x4 rigid transformation matrix
-          */
-        virtual void
-        getTransformationFromCorrelation (
-            const Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt; &amp;cloud_src_demean,
-            const Eigen::Matrix&lt;Scalar, 4, 1&gt; &amp;centroid_src,
-            const Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt; &amp;cloud_tgt_demean,
-            const Eigen::Matrix&lt;Scalar, 4, 1&gt; &amp;centroid_tgt,
-            Matrix4 &amp;transformation_matrix) const;
-
-        bool use_umeyama_;
-     };
-
-  }
-}
-
-      //#include &lt;pcl/registration/impl/transformation_estimation_svd.hpp&gt;
-#include "fast_pcl/registration/impl/transformation_estimation_svd.hpp"
-
-#endif /* FAST_PCL_REGISTRATION_TRANSFORMATION_ESTIMATION_SVD_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\warp_point_rigid.h" new_path="" added_lines="0" deleted_lines="134">
				<diff>@@ -1,134 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#ifndef FAST_PCL_WARP_POINT_RIGID_H_
-#define FAST_PCL_WARP_POINT_RIGID_H_
-
-//#include &lt;pcl/registration/eigen.h&gt;
-#include "fast_pcl/registration/eigen.h"
-
-namespace pcl
-{
-  namespace registration
-  {
-    /** \brief Base warp point class. 
-      * 
-      * \note The class is templated on the source and target point types as well as on the output scalar of the transformation matrix (i.e., float or double). Default: float.
-      * \author Radu B. Rusu
-      * \ingroup registration
-      */
-    template &lt;typename PointSourceT, typename PointTargetT, typename Scalar = float&gt;
-    class WarpPointRigid
-    {
-      public:
-        typedef Eigen::Matrix&lt;Scalar, 4, 4&gt; Matrix4;
-        typedef Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt; VectorX;
-        typedef Eigen::Matrix&lt;Scalar, 4, 1&gt; Vector4;
-
-        typedef boost::shared_ptr&lt;WarpPointRigid&lt;PointSourceT, PointTargetT, Scalar&gt; &gt; Ptr;
-        typedef boost::shared_ptr&lt;const WarpPointRigid&lt;PointSourceT, PointTargetT, Scalar&gt; &gt; ConstPtr;
-
-        /** \brief Constructor
-          * \param[in] nr_dim the number of dimensions
-          */
-        WarpPointRigid (int nr_dim)
-          : nr_dim_ (nr_dim)
-          , transform_matrix_ (Matrix4::Zero ())
-        {
-          transform_matrix_ (3, 3) = 1.0;
-        };
-
-        /** \brief Destructor. */
-        virtual ~WarpPointRigid () {};
-
-        /** \brief Set warp parameters. Pure virtual.
-          * \param[in] p warp parameters 
-          */
-        virtual void 
-        setParam (const VectorX&amp; p) = 0;
-
-        /** \brief Warp a point given a transformation matrix
-          * \param[in] pnt_in the point to warp (transform)
-          * \param[out] pnt_out the warped (transformed) point
-          */
-        inline void 
-        warpPoint (const PointSourceT&amp; pnt_in, PointSourceT&amp; pnt_out) const
-        {
-          pnt_out.x = static_cast&lt;float&gt; (transform_matrix_ (0, 0) * pnt_in.x + transform_matrix_ (0, 1) * pnt_in.y + transform_matrix_ (0, 2) * pnt_in.z + transform_matrix_ (0, 3));
-          pnt_out.y = static_cast&lt;float&gt; (transform_matrix_ (1, 0) * pnt_in.x + transform_matrix_ (1, 1) * pnt_in.y + transform_matrix_ (1, 2) * pnt_in.z + transform_matrix_ (1, 3));
-          pnt_out.z = static_cast&lt;float&gt; (transform_matrix_ (2, 0) * pnt_in.x + transform_matrix_ (2, 1) * pnt_in.y + transform_matrix_ (2, 2) * pnt_in.z + transform_matrix_ (2, 3));
-          //pnt_out.getVector3fMap () = transform_matrix_.topLeftCorner (3, 3) * 
-          //                            pnt_in.getVector3fMap () + 
-          //                            transform_matrix_.block (0, 3, 3, 1);
-          //pnt_out.data[3] = pnt_in.data[3];
-        }
-
-        /** \brief Warp a point given a transformation matrix
-          * \param[in] pnt_in the point to warp (transform)
-          * \param[out] pnt_out the warped (transformed) point
-          */
-        inline void 
-        warpPoint (const PointSourceT&amp; pnt_in, Vector4&amp; pnt_out) const
-        {
-          pnt_out[0] = static_cast&lt;Scalar&gt; (transform_matrix_ (0, 0) * pnt_in.x + transform_matrix_ (0, 1) * pnt_in.y + transform_matrix_ (0, 2) * pnt_in.z + transform_matrix_ (0, 3));
-          pnt_out[1] = static_cast&lt;Scalar&gt; (transform_matrix_ (1, 0) * pnt_in.x + transform_matrix_ (1, 1) * pnt_in.y + transform_matrix_ (1, 2) * pnt_in.z + transform_matrix_ (1, 3));
-          pnt_out[2] = static_cast&lt;Scalar&gt; (transform_matrix_ (2, 0) * pnt_in.x + transform_matrix_ (2, 1) * pnt_in.y + transform_matrix_ (2, 2) * pnt_in.z + transform_matrix_ (2, 3));
-          pnt_out[3] = 0.0;
-        }
-
-        /** \brief Get the number of dimensions. */
-        inline int 
-        getDimension () const { return (nr_dim_); }
-
-        /** \brief Get the Transform used. */
-        inline const Matrix4&amp; 
-        getTransform () const { return (transform_matrix_); }
-        
-      public:
-        EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
-      protected:
-        int nr_dim_;
-        Matrix4 transform_matrix_;
-    };
-  } // namespace registration
-} // namespace pcl
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\warp_point_rigid_6d.h" new_path="" added_lines="0" deleted_lines="103">
				<diff>@@ -1,103 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010, Willow Garage, Inc.
- *  Copyright (c) 2012-, Open Perception, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-
-#ifndef FAST_PCL_WARP_POINT_RIGID_6D_H_
-#define FAST_PCL_WARP_POINT_RIGID_6D_H_
-
-//#include &lt;pcl/registration/warp_point_rigid.h&gt;
-#include "fast_pcl/registration/warp_point_rigid.h"
-
-namespace pcl
-{
-  namespace registration
-  {
-    /** \brief @b WarpPointRigid3D enables 6D (3D rotation + 3D translation) 
-      * transformations for points.
-      * 
-      * \note The class is templated on the source and target point types as well as on the output scalar of the transformation matrix (i.e., float or double). Default: float.
-      * \author Radu B. Rusu
-      * \ingroup registration
-      */
-    template &lt;typename PointSourceT, typename PointTargetT, typename Scalar = float&gt;
-    class WarpPointRigid6D : public WarpPointRigid&lt;PointSourceT, PointTargetT, Scalar&gt;
-    {
-      public:
-        using WarpPointRigid&lt;PointSourceT, PointTargetT, Scalar&gt;::transform_matrix_;
-
-        typedef typename WarpPointRigid&lt;PointSourceT, PointTargetT, Scalar&gt;::Matrix4 Matrix4;
-        typedef typename WarpPointRigid&lt;PointSourceT, PointTargetT, Scalar&gt;::VectorX VectorX;
-
-        typedef boost::shared_ptr&lt;WarpPointRigid6D&lt;PointSourceT, PointTargetT, Scalar&gt; &gt; Ptr;
-        typedef boost::shared_ptr&lt;const WarpPointRigid6D&lt;PointSourceT, PointTargetT, Scalar&gt; &gt; ConstPtr;
-
-        WarpPointRigid6D () : WarpPointRigid&lt;PointSourceT, PointTargetT, Scalar&gt; (6) {}
-      
-        /** \brief Empty destructor */
-        virtual ~WarpPointRigid6D () {}
-
-        /** \brief Set warp parameters. 
-          * \note Assumes the quaternion parameters are normalized. 
-          * \param[in] p warp parameters (tx ty tz qx qy qz)
-          */
-        virtual void 
-        setParam (const VectorX&amp; p)
-        {
-          assert (p.rows () == this-&gt;getDimension ());
-
-          // Copy the rotation and translation components
-          transform_matrix_.setZero ();
-          transform_matrix_ (0, 3) = p[0];
-          transform_matrix_ (1, 3) = p[1];
-          transform_matrix_ (2, 3) = p[2];
-          transform_matrix_ (3, 3) = 1;
-          
-          // Compute w from the unit quaternion
-          Eigen::Quaternion&lt;Scalar&gt; q (0, p[3], p[4], p[5]);
-          q.w () = static_cast&lt;Scalar&gt; (sqrt (1 - q.dot (q)));
-          q.normalize ();
-          transform_matrix_.topLeftCorner (3, 3) = q.toRotationMatrix ();
-        }
-    };
-  }
-}
-
-#endif
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\src\correspondence_estimation.cpp" new_path="" added_lines="0" deleted_lines="41">
				<diff>@@ -1,41 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of the copyright holder(s) nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-//#include &lt;pcl/registration/correspondence_estimation.h&gt;
-#include "fast_pcl/registration/correspondence_estimation.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\src\correspondence_types.cpp" new_path="" added_lines="0" deleted_lines="41">
				<diff>@@ -1,41 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Willow Garage, Inc. nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-//#include &lt;pcl/registration/correspondence_types.h&gt;
-#include "fast_pcl/registration/correspondence_types.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\src\icp.cpp" new_path="" added_lines="0" deleted_lines="41">
				<diff>@@ -1,41 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Willow Garage, Inc. nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-//#include &lt;pcl/registration/icp.h&gt;
-#include "fast_pcl/registration/icp.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\src\icp_nl.cpp" new_path="" added_lines="0" deleted_lines="41">
				<diff>@@ -1,41 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Willow Garage, Inc. nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-//#include &lt;pcl/registration/icp_nl.h&gt;
-#include "fast_pcl/registration/icp_nl.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\src\registration.cpp" new_path="" added_lines="0" deleted_lines="60">
				<diff>@@ -1,60 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Point Cloud Library (PCL) - www.pointclouds.org
- *  Copyright (c) 2010-2011, Willow Garage, Inc.
- *
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Willow Garage, Inc. nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#include &lt;pcl/point_types.h&gt;
-//#include &lt;pcl/registration/registration.h&gt;
-//#include &lt;pcl/registration/icp.h&gt;
-//#include &lt;pcl/registration/icp_nl.h&gt;
-#include "fast_pcl/registration/registration.h"
-#include "fast_pcl/registration/icp.h"
-#include "fast_pcl/registration/icp_nl.h"
-/*#include &lt;pcl/registration/correspondence_estimation.h&gt;
-#include &lt;pcl/registration/correspondence_rejection.h&gt;
-#include &lt;pcl/registration/correspondence_rejection_distance.h&gt;
-#include &lt;pcl/registration/correspondence_rejection_one_to_one.h&gt;
-#include &lt;pcl/registration/correspondence_rejection_sample_consensus.h&gt;
-#include &lt;pcl/registration/correspondence_rejection_trimmed.h&gt;
-#include &lt;pcl/registration/correspondence_sorting.h&gt;
-*/
-
-typedef pcl::IterativeClosestPoint&lt;pcl::PointXYZ,pcl::PointXYZ&gt; IterativeClosestPoint;
-typedef pcl::IterativeClosestPointNonLinear&lt;pcl::PointXYZ,pcl::PointXYZ&gt; IterativeClosestPointNonLinear;
-//PLUGINLIB_DECLARE_CLASS (pcl, IterativeClosestPoint, IterativeClosestPoint, nodelet::Nodelet);
-//PLUGINLIB_DECLARE_CLASS (pcl, IterativeClosestPointNonLinear, IterativeClosestPointNonLinear, nodelet::Nodelet);
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\src\transformation_estimation_lm.cpp" new_path="" added_lines="0" deleted_lines="39">
				<diff>@@ -1,39 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011, Alexandru-Eugen Ichim
- *                      Willow Garage, Inc
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Willow Garage, Inc. nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-#include "fast_pcl/registration/transformation_estimation_lm.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\src\transformation_estimation_point_to_plane_lls.cpp" new_path="" added_lines="0" deleted_lines="40">
				<diff>@@ -1,40 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011, Alexandru-Eugen Ichim
- *                      Willow Garage, Inc
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Willow Garage, Inc. nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-//#include &lt;pcl/registration/transformation_estimation_point_to_plane_lls.h&gt;
-#include "fast_pcl/registration/transformation_estimation_point_to_plane_lls.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\src\transformation_estimation_svd.cpp" new_path="" added_lines="0" deleted_lines="40">
				<diff>@@ -1,40 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011, Alexandru-Eugen Ichim
- *                      Willow Garage, Inc
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Willow Garage, Inc. nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id$
- *
- */
-
-//#include &lt;pcl/registration/transformation_estimation_svd.h&gt;
-#include "fast_pcl/registration/transformation_estimation_svd.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\impl\ndt.hpp" new_path="ros\src\computing\perception\localization\lib\pcl_omp\registration\include\pcl_omp\registration\impl\ndt.hpp" added_lines="17" deleted_lines="172">
				<diff>@@ -38,12 +38,12 @@
  *
  */
 
-#ifndef FAST_PCL_REGISTRATION_NDT_IMPL_H_
-#define FAST_PCL_REGISTRATION_NDT_IMPL_H_
+#ifndef PCL_OMP_REGISTRATION_NDT_IMPL_H_
+#define PCL_OMP_REGISTRATION_NDT_IMPL_H_
 
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 template&lt;typename PointSource, typename PointTarget&gt;
-pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::NormalDistributionsTransform ()
+pcl_omp::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::NormalDistributionsTransform ()
   : target_cells_ ()
   , resolution_ (1.0f)
   , step_size_ (0.1)
@@ -72,108 +72,10 @@ pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::NormalDistributions
   max_iterations_ = 35;
 }
 
-//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-template&lt;typename PointSource, typename PointTarget&gt; void
-pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeTransformation (PointCloudSource &amp;output, const Eigen::Matrix4f &amp;guess)
-{
-  nr_iterations_ = 0;
-  converged_ = false;
-
-  double gauss_c1, gauss_c2, gauss_d3;
-
-  // Initializes the guassian fitting parameters (eq. 6.8) [Magnusson 2009]
-  gauss_c1 = 10 * (1 - outlier_ratio_);
-  gauss_c2 = outlier_ratio_ / pow (resolution_, 3);
-  gauss_d3 = -log (gauss_c2);
-  gauss_d1_ = -log ( gauss_c1 + gauss_c2 ) - gauss_d3;
-  gauss_d2_ = -2 * log ((-log ( gauss_c1 * exp ( -0.5 ) + gauss_c2 ) - gauss_d3) / gauss_d1_);
-
-  if (guess != Eigen::Matrix4f::Identity ())
-  {
-    // Initialise final transformation to the guessed one
-    final_transformation_ = guess;
-    // Apply guessed transformation prior to search for neighbours
-    transformPointCloud (output, output, guess);
-  }
-
-  // Initialize Point Gradient and Hessian
-  point_gradient_.setZero ();
-  point_gradient_.block&lt;3, 3&gt;(0, 0).setIdentity ();
-  point_hessian_.setZero ();
-
-  Eigen::Transform&lt;float, 3, Eigen::Affine, Eigen::ColMajor&gt; eig_transformation;
-  eig_transformation.matrix () = final_transformation_;
-
-  // Convert initial guess matrix to 6 element transformation vector
-  Eigen::Matrix&lt;double, 6, 1&gt; p, delta_p, score_gradient;
-  Eigen::Vector3f init_translation = eig_transformation.translation ();
-  Eigen::Vector3f init_rotation = eig_transformation.rotation ().eulerAngles (0, 1, 2);
-  p &lt;&lt; init_translation (0), init_translation (1), init_translation (2),
-  init_rotation (0), init_rotation (1), init_rotation (2);
-
-  Eigen::Matrix&lt;double, 6, 6&gt; hessian;
-
-  double score = 0;
-  double delta_p_norm;
-
-  // Calculate derivates of initial transform vector, subsequent derivative calculations are done in the step length determination.
-  score = computeDerivatives (score_gradient, hessian, output, p);
-
-  while (!converged_)
-  {
-    // Store previous transformation
-    previous_transformation_ = transformation_;
-
-    // Solve for decent direction using newton method, line 23 in Algorithm 2 [Magnusson 2009]
-    Eigen::JacobiSVD&lt;Eigen::Matrix&lt;double, 6, 6&gt; &gt; sv (hessian, Eigen::ComputeFullU | Eigen::ComputeFullV);
-    // Negative for maximization as opposed to minimization
-    delta_p = sv.solve (-score_gradient);
-
-    //Calculate step length with guarnteed sufficient decrease [More, Thuente 1994]
-    delta_p_norm = delta_p.norm ();
-
-    if (delta_p_norm == 0 || delta_p_norm != delta_p_norm)
-    {
-      trans_probability_ = score / static_cast&lt;double&gt; (input_-&gt;points.size ());
-      converged_ = delta_p_norm == delta_p_norm;
-      return;
-    }
-
-    delta_p.normalize ();
-    delta_p_norm = computeStepLengthMT (p, delta_p, delta_p_norm, step_size_, transformation_epsilon_ / 2, score, score_gradient, hessian, output);
-    delta_p *= delta_p_norm;
-
-
-    transformation_ = (Eigen::Translation&lt;float, 3&gt; (static_cast&lt;float&gt; (delta_p (0)), static_cast&lt;float&gt; (delta_p (1)), static_cast&lt;float&gt; (delta_p (2))) *
-                       Eigen::AngleAxis&lt;float&gt; (static_cast&lt;float&gt; (delta_p (3)), Eigen::Vector3f::UnitX ()) *
-                       Eigen::AngleAxis&lt;float&gt; (static_cast&lt;float&gt; (delta_p (4)), Eigen::Vector3f::UnitY ()) *
-                       Eigen::AngleAxis&lt;float&gt; (static_cast&lt;float&gt; (delta_p (5)), Eigen::Vector3f::UnitZ ())).matrix ();
-
-
-    p = p + delta_p;
-
-    // Update Visualizer (untested)
-    if (update_visualizer_ != 0)
-      update_visualizer_ (output, std::vector&lt;int&gt;(), *target_, std::vector&lt;int&gt;() );
-
-    if (nr_iterations_ &gt; max_iterations_ ||
-        (nr_iterations_ &amp;&amp; (std::fabs (delta_p_norm) &lt; transformation_epsilon_)))
-    {
-      converged_ = true;
-    }
-
-    nr_iterations_++;
-
-  }
-
-  // Store transformation probability.  The realtive differences within each scan registration are accurate
-  // but the normalization constants need to be modified for it to be globally accurate
-  trans_probability_ = score / static_cast&lt;double&gt; (input_-&gt;points.size ());
-}
 
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 template&lt;typename PointSource, typename PointTarget&gt; void
-pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::omp_computeTransformation (PointCloudSource &amp;output, const Eigen::Matrix4f &amp;guess)
+pcl_omp::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeTransformation (PointCloudSource &amp;output, const Eigen::Matrix4f &amp;guess)
 {
   nr_iterations_ = 0;
   converged_ = false;
@@ -216,7 +118,7 @@ pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::omp_computeTransfor
   double delta_p_norm;
 
   // Calculate derivates of initial transform vector, subsequent derivative calculations are done in the step length determination.
-  score = omp_computeDerivatives (score_gradient, hessian, output, p);
+  score = computeDerivatives (score_gradient, hessian, output, p);
 
   while (!converged_)
   {
@@ -270,67 +172,10 @@ pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::omp_computeTransfor
   trans_probability_ = score / static_cast&lt;double&gt; (input_-&gt;points.size ());
 }
 
-//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-template&lt;typename PointSource, typename PointTarget&gt; double
-pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeDerivatives (Eigen::Matrix&lt;double, 6, 1&gt; &amp;score_gradient,
-                                                                                 Eigen::Matrix&lt;double, 6, 6&gt; &amp;hessian,
-                                                                                 PointCloudSource &amp;trans_cloud,
-                                                                                 Eigen::Matrix&lt;double, 6, 1&gt; &amp;p,
-                                                                                 bool compute_hessian)
-{
-  // Original Point and Transformed Point
-  PointSource x_pt, x_trans_pt;
-  // Original Point and Transformed Point (for math)
-  Eigen::Vector3d x, x_trans;
-  // Occupied Voxel
-  TargetGridLeafConstPtr cell;
-  // Inverse Covariance of Occupied Voxel
-  Eigen::Matrix3d c_inv;
-
-  score_gradient.setZero ();
-  hessian.setZero ();
-  double score = 0;
-
-  // Precompute Angular Derivatives (eq. 6.19 and 6.21)[Magnusson 2009]
-  computeAngleDerivatives (p);
-
-  // Update gradient and hessian for each point, line 17 in Algorithm 2 [Magnusson 2009]
-  for (size_t idx = 0; idx &lt; input_-&gt;points.size (); idx++)
-  {
-    x_trans_pt = trans_cloud.points[idx];
-
-    // Find nieghbors (Radius search has been experimentally faster than direct neighbor checking.
-    std::vector&lt;TargetGridLeafConstPtr&gt; neighborhood;
-    std::vector&lt;float&gt; distances;
-    target_cells_.radiusSearch (x_trans_pt, resolution_, neighborhood, distances);
-
-    for (typename std::vector&lt;TargetGridLeafConstPtr&gt;::iterator neighborhood_it = neighborhood.begin (); neighborhood_it != neighborhood.end (); neighborhood_it++)
-    {
-      cell = *neighborhood_it;
-      x_pt = input_-&gt;points[idx];
-      x = Eigen::Vector3d (x_pt.x, x_pt.y, x_pt.z);
-
-      x_trans = Eigen::Vector3d (x_trans_pt.x, x_trans_pt.y, x_trans_pt.z);
-
-      // Denorm point, x_k' in Equations 6.12 and 6.13 [Magnusson 2009]
-      x_trans -= cell-&gt;getMean ();
-      // Uses precomputed covariance for speed.
-      c_inv = cell-&gt;getInverseCov ();
-
-      // Compute derivative of transform function w.r.t. transform vector, J_E and H_E in Equations 6.18 and 6.20 [Magnusson 2009]
-      computePointDerivatives (x);
-      // Update score, gradient and hessian, lines 19-21 in Algorithm 2, according to Equations 6.10, 6.12 and 6.13, respectively [Magnusson 2009]
-      score += updateDerivatives (score_gradient, hessian, x_trans, c_inv, compute_hessian);
-
-    }
-  }
-  return (score);
-}
-
 
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 template&lt;typename PointSource, typename PointTarget&gt; double
-pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::omp_computeDerivatives (Eigen::Matrix&lt;double, 6, 1&gt; &amp;score_gradient,
+pcl_omp::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeDerivatives (Eigen::Matrix&lt;double, 6, 1&gt; &amp;score_gradient,
                                                                                  Eigen::Matrix&lt;double, 6, 6&gt; &amp;hessian,
                                                                                  PointCloudSource &amp;trans_cloud,
                                                                                  Eigen::Matrix&lt;double, 6, 1&gt; &amp;p,
@@ -455,7 +300,7 @@ pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::omp_computeDerivati
 
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 template&lt;typename PointSource, typename PointTarget&gt; void
-pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeAngleDerivatives (Eigen::Matrix&lt;double, 6, 1&gt; &amp;p, bool compute_hessian)
+pcl_omp::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeAngleDerivatives (Eigen::Matrix&lt;double, 6, 1&gt; &amp;p, bool compute_hessian)
 {
   // Simplified math for near 0 angles
   double cx, cy, cz, sx, sy, sz;
@@ -532,7 +377,7 @@ pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeAngleDerivat
 
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 template&lt;typename PointSource, typename PointTarget&gt; void
-pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computePointDerivatives (Eigen::Vector3d &amp;x, bool compute_hessian)
+pcl_omp::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computePointDerivatives (Eigen::Vector3d &amp;x, bool compute_hessian)
 {
   // Calculate first derivative of Transformation Equation 6.17 w.r.t. transform vector p.
   // Derivative w.r.t. ith element of transform vector corresponds to column i, Equation 6.18 and 6.19 [Magnusson 2009]
@@ -573,7 +418,7 @@ pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computePointDerivat
 
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 template&lt;typename PointSource, typename PointTarget&gt; double
-pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::updateDerivatives (Eigen::Matrix&lt;double, 6, 1&gt; &amp;score_gradient,
+pcl_omp::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::updateDerivatives (Eigen::Matrix&lt;double, 6, 1&gt; &amp;score_gradient,
                                                                                 Eigen::Matrix&lt;double, 6, 6&gt; &amp;hessian,
                                                                                 Eigen::Vector3d &amp;x_trans, Eigen::Matrix3d &amp;c_inv,
                                                                                 bool compute_hessian)
@@ -619,7 +464,7 @@ pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::updateDerivatives (
 
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 template&lt;typename PointSource, typename PointTarget&gt; void
-pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeHessian (Eigen::Matrix&lt;double, 6, 6&gt; &amp;hessian,
+pcl_omp::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeHessian (Eigen::Matrix&lt;double, 6, 6&gt; &amp;hessian,
                                                                              PointCloudSource &amp;trans_cloud, Eigen::Matrix&lt;double, 6, 1&gt; &amp;)
 {
   // Original Point and Transformed Point
@@ -671,7 +516,7 @@ pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeHessian (Eig
 
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 template&lt;typename PointSource, typename PointTarget&gt; void
-pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::updateHessian (Eigen::Matrix&lt;double, 6, 6&gt; &amp;hessian, Eigen::Vector3d &amp;x_trans, Eigen::Matrix3d &amp;c_inv)
+pcl_omp::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::updateHessian (Eigen::Matrix&lt;double, 6, 6&gt; &amp;hessian, Eigen::Vector3d &amp;x_trans, Eigen::Matrix3d &amp;c_inv)
 {
   Eigen::Vector3d cov_dxd_pi;
   // e^(-d_2/2 * (x_k - mu_k)^T Sigma_k^-1 (x_k - mu_k)) Equation 6.9 [Magnusson 2009]
@@ -702,7 +547,7 @@ pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::updateHessian (Eige
 
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 template&lt;typename PointSource, typename PointTarget&gt; bool
-pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::updateIntervalMT (double &amp;a_l, double &amp;f_l, double &amp;g_l,
+pcl_omp::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::updateIntervalMT (double &amp;a_l, double &amp;f_l, double &amp;g_l,
                                                                                double &amp;a_u, double &amp;f_u, double &amp;g_u,
                                                                                double a_t, double f_t, double g_t)
 {
@@ -743,7 +588,7 @@ pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::updateIntervalMT (d
 
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 template&lt;typename PointSource, typename PointTarget&gt; double
-pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::trialValueSelectionMT (double a_l, double f_l, double g_l,
+pcl_omp::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::trialValueSelectionMT (double a_l, double f_l, double g_l,
                                                                                     double a_u, double f_u, double g_u,
                                                                                     double a_t, double f_t, double g_t)
 {
@@ -826,7 +671,7 @@ pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::trialValueSelection
 
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 template&lt;typename PointSource, typename PointTarget&gt; double
-pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeStepLengthMT (const Eigen::Matrix&lt;double, 6, 1&gt; &amp;x, Eigen::Matrix&lt;double, 6, 1&gt; &amp;step_dir, double step_init, double step_max,
+pcl_omp::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeStepLengthMT (const Eigen::Matrix&lt;double, 6, 1&gt; &amp;x, Eigen::Matrix&lt;double, 6, 1&gt; &amp;step_dir, double step_init, double step_max,
                                                                                   double step_min, double &amp;score, Eigen::Matrix&lt;double, 6, 1&gt; &amp;score_gradient, Eigen::Matrix&lt;double, 6, 6&gt; &amp;hessian,
                                                                                   PointCloudSource &amp;trans_cloud)
 {
@@ -890,7 +735,7 @@ pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeStepLengthMT
 
   // Updates score, gradient and hessian.  Hessian calculation is unessisary but testing showed that most step calculations use the
   // initial step suggestion and recalculation the reusable portions of the hessian would intail more computation time.
-  score = omp_computeDerivatives (score_gradient, hessian, trans_cloud, x_t, true);
+  score = computeDerivatives (score_gradient, hessian, trans_cloud, x_t, true);
 
   // Calculate phi(alpha_t)
   double phi_t = -score;
@@ -934,7 +779,7 @@ pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeStepLengthMT
     transformPointCloud (*input_, trans_cloud, final_transformation_);
 
     // Updates score, gradient. Values stored to prevent wasted computation.
-    score = omp_computeDerivatives (score_gradient, hessian, trans_cloud, x_t, false);
+    score = computeDerivatives (score_gradient, hessian, trans_cloud, x_t, false);
 
     // Calculate phi(alpha_t+)
     phi_t = -score;
@@ -987,4 +832,4 @@ pcl::NormalDistributionsTransform&lt;PointSource, PointTarget&gt;::computeStepLengthMT
   return (a_t);
 }
 
-#endif // PCL_REGISTRATION_NDT_IMPL_H_
+#endif // PCL_OMP_REGISTRATION_NDT_IMPL_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\impl\registration.hpp" new_path="ros\src\computing\perception\localization\lib\pcl_omp\registration\include\pcl_omp\registration\impl\registration.hpp" added_lines="12" deleted_lines="96">
				<diff>@@ -40,22 +40,22 @@
 
 ///////////////////////////////////////////////////////////////////////////////////////////
 template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; void
-pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::setInputCloud (
-    const typename pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::PointCloudSourceConstPtr &amp;cloud)
+pcl_omp::Registration&lt;PointSource, PointTarget, Scalar&gt;::setInputCloud (
+    const typename pcl_omp::Registration&lt;PointSource, PointTarget, Scalar&gt;::PointCloudSourceConstPtr &amp;cloud)
 {
   setInputSource (cloud);
 }
 
 ///////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; typename pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::PointCloudSourceConstPtr const
-pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::getInputCloud ()
+template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; typename pcl_omp::Registration&lt;PointSource, PointTarget, Scalar&gt;::PointCloudSourceConstPtr const
+pcl_omp::Registration&lt;PointSource, PointTarget, Scalar&gt;::getInputCloud ()
 {
   return (getInputSource ());
 }
 
 ///////////////////////////////////////////////////////////////////////////////////////////
 template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline void
-pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::setInputTarget (const PointCloudTargetConstPtr &amp;cloud)
+pcl_omp::Registration&lt;PointSource, PointTarget, Scalar&gt;::setInputTarget (const PointCloudTargetConstPtr &amp;cloud)
 {
   if (cloud-&gt;points.empty ())
   {
@@ -68,7 +68,7 @@ pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::setInputTarget (const Point
 
 ///////////////////////////////////////////////////////////////////////////////////////////
 template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; bool
-pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::initCompute ()
+pcl_omp::Registration&lt;PointSource, PointTarget, Scalar&gt;::initCompute ()
 {
   if (!target_)
   {
@@ -94,12 +94,12 @@ pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::initCompute ()
   // Note: we /cannot/ update the search method on all correspondence rejectors, because we know
   // nothing about them. If they should be cached, they must be cached individually.
 
-  return (PCLBase&lt;PointSource&gt;::initCompute ());
+  return (pcl::PCLBase&lt;PointSource&gt;::initCompute ());
 }
 
 ///////////////////////////////////////////////////////////////////////////////////////////
 template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; bool
-pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::initComputeReciprocal ()
+pcl_omp::Registration&lt;PointSource, PointTarget, Scalar&gt;::initComputeReciprocal ()
 {
   if (!input_)
   {
@@ -117,7 +117,7 @@ pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::initComputeReciprocal ()
 
 //////////////////////////////////////////////////////////////////////////////////////////////
 template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline double
-pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::getFitnessScore (
+pcl_omp::Registration&lt;PointSource, PointTarget, Scalar&gt;::getFitnessScore (
     const std::vector&lt;float&gt; &amp;distances_a,
     const std::vector&lt;float&gt; &amp;distances_b)
 {
@@ -129,44 +129,7 @@ pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::getFitnessScore (
 
 //////////////////////////////////////////////////////////////////////////////////////////////
 template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline double
-pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::getFitnessScore (double max_range)
-{
-
-  double fitness_score = 0.0;
-
-  // Transform the input dataset using the final transformation
-  PointCloudSource input_transformed;
-  transformPointCloud (*input_, input_transformed, final_transformation_);
-
-  std::vector&lt;int&gt; nn_indices (1);
-  std::vector&lt;float&gt; nn_dists (1);
-
-  // For each point in the source dataset
-  int nr = 0;
-  for (size_t i = 0; i &lt; input_transformed.points.size (); ++i)
-  {
-    // Find its nearest neighbor in the target
-    tree_-&gt;nearestKSearch (input_transformed.points[i], 1, nn_indices, nn_dists);
-
-    // Deal with occlusions (incomplete targets)
-    if (nn_dists[0] &lt;= max_range)
-    {
-      // Add to the fitness score
-      fitness_score += nn_dists[0];
-      nr++;
-    }
-  }
-
-  if (nr &gt; 0)
-    return (fitness_score / nr);
-  else
-    return (std::numeric_limits&lt;double&gt;::max ());
-
-}
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline double
-pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::omp_getFitnessScore (double max_range)
+pcl_omp::Registration&lt;PointSource, PointTarget, Scalar&gt;::getFitnessScore (double max_range)
 {
 
   double fitness_score = 0.0;
@@ -227,14 +190,14 @@ pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::omp_getFitnessScore (double
 
 //////////////////////////////////////////////////////////////////////////////////////////////
 template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline void
-pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::align (PointCloudSource &amp;output)
+pcl_omp::Registration&lt;PointSource, PointTarget, Scalar&gt;::align (PointCloudSource &amp;output)
 {
   align (output, Matrix4::Identity ());
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////////
 template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline void
-pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::align (PointCloudSource &amp;output, const Matrix4&amp; guess)
+pcl_omp::Registration&lt;PointSource, PointTarget, Scalar&gt;::align (PointCloudSource &amp;output, const Matrix4&amp; guess)
 {
   if (!initCompute ())
     return;
@@ -278,50 +241,3 @@ pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::align (PointCloudSource &amp;ou
 
   deinitCompute ();
 }
-
-//////////////////////////////////////////////////////////////////////////////////////////////
-template &lt;typename PointSource, typename PointTarget, typename Scalar&gt; inline void
-pcl::Registration&lt;PointSource, PointTarget, Scalar&gt;::omp_align (PointCloudSource &amp;output, const Matrix4&amp; guess)
-{
-  if (!initCompute ())
-    return;
-
-  // Resize the output dataset
-  if (output.points.size () != indices_-&gt;size ())
-    output.points.resize (indices_-&gt;size ());
-  // Copy the header
-  output.header   = input_-&gt;header;
-  // Check if the output will be computed for all points or only a subset
-  if (indices_-&gt;size () != input_-&gt;points.size ())
-  {
-    output.width    = static_cast&lt;uint32_t&gt; (indices_-&gt;size ());
-    output.height   = 1;
-  }
-  else
-  {
-    output.width    = static_cast&lt;uint32_t&gt; (input_-&gt;width);
-    output.height   = input_-&gt;height;
-  }
-  output.is_dense = input_-&gt;is_dense;
-
-  // Copy the point data to output
-  for (size_t i = 0; i &lt; indices_-&gt;size (); ++i)
-    output.points[i] = input_-&gt;points[(*indices_)[i]];
-
-  // Set the internal point representation of choice unless otherwise noted
-  if (point_representation_ &amp;&amp; !force_no_recompute_)
-    tree_-&gt;setPointRepresentation (point_representation_);
-
-  // Perform the actual transformation computation
-  converged_ = false;
-  final_transformation_ = transformation_ = previous_transformation_ = Matrix4::Identity ();
-
-  // Right before we estimate the transformation, we set all the point.data[3] values to 1 to aid the rigid
-  // transformation
-  for (size_t i = 0; i &lt; indices_-&gt;size (); ++i)
-    output.points[i].data[3] = 1.0;
-
-  omp_computeTransformation (output, guess);
-
-  deinitCompute ();
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\ndt.h" new_path="ros\src\computing\perception\localization\lib\pcl_omp\registration\include\pcl_omp\registration\ndt.h" added_lines="13" deleted_lines="23">
				<diff>@@ -38,17 +38,17 @@
  *
  */
 
-#ifndef FAST_PCL_REGISTRATION_NDT_H_
-#define FAST_PCL_REGISTRATION_NDT_H_
+#ifndef PCL_OMP_REGISTRATION_NDT_H_
+#define PCL_OMP_REGISTRATION_NDT_H_
 
 //#include &lt;pcl/registration/registration.h&gt;
-#include "fast_pcl/registration/registration.h"
+#include "pcl_omp/registration/registration.h"
 //#include &lt;pcl/filters/voxel_grid_covariance.h&gt;
-#include "fast_pcl/filters/voxel_grid_covariance.h"
+#include &lt;pcl/filters/voxel_grid_covariance.h&gt;
 
 #include &lt;unsupported/Eigen/NonLinearOptimization&gt;
 
-namespace pcl
+namespace pcl_omp
 {
   /** \brief A 3D Normal Distribution Transform registration implementation for point cloud data.
     * \note For more information please see
@@ -74,11 +74,11 @@ namespace pcl
       typedef typename PointCloudTarget::Ptr PointCloudTargetPtr;
       typedef typename PointCloudTarget::ConstPtr PointCloudTargetConstPtr;
 
-      typedef PointIndices::Ptr PointIndicesPtr;
-      typedef PointIndices::ConstPtr PointIndicesConstPtr;
+      typedef pcl::PointIndices::Ptr PointIndicesPtr;
+      typedef pcl::PointIndices::ConstPtr PointIndicesConstPtr;
 
       /** \brief Typename of searchable voxel grid containing mean and covariance. */
-      typedef VoxelGridCovariance&lt;PointTarget&gt; TargetGrid;
+      typedef pcl::VoxelGridCovariance&lt;PointTarget&gt; TargetGrid;
       /** \brief Typename of pointer to searchable voxel grid. */
       typedef TargetGrid* TargetGridPtr;
       /** \brief Typename of const pointer to searchable voxel grid. */
@@ -97,7 +97,7 @@ namespace pcl
         * Sets \ref outlier_ratio_ to 0.35, \ref step_size_ to 0.05 and \ref resolution_ to 1.0
         */
       NormalDistributionsTransform ();
-      
+
       /** \brief Empty destructor */
       virtual ~NormalDistributionsTransform () {}
 
@@ -249,9 +249,6 @@ namespace pcl
       virtual void
       computeTransformation (PointCloudSource &amp;output, const Eigen::Matrix4f &amp;guess);
 
-      virtual void
-      omp_computeTransformation (PointCloudSource &amp;output, const Eigen::Matrix4f &amp;guess);
-
       /** \brief Initiate covariance voxel structure. */
       void inline
       init ()
@@ -277,13 +274,6 @@ namespace pcl
                           Eigen::Matrix&lt;double, 6, 1&gt; &amp;p,
                           bool compute_hessian = true);
 
-      double
-      omp_computeDerivatives (Eigen::Matrix&lt;double, 6, 1&gt; &amp;score_gradient,
-                          Eigen::Matrix&lt;double, 6, 6&gt; &amp;hessian,
-                          PointCloudSource &amp;trans_cloud,
-                          Eigen::Matrix&lt;double, 6, 1&gt; &amp;p,
-                          bool compute_hessian = true);
-
       /** \brief Compute individual point contirbutions to derivatives of probability function w.r.t. the transformation vector.
         * \note Equation 6.10, 6.12 and 6.13 [Magnusson 2009].
         * \param[in,out] score_gradient the gradient vector of the probability function w.r.t. the transformation vector
@@ -448,7 +438,7 @@ namespace pcl
 
       /** \brief Precomputed Angular Gradient
         *
-        * The precomputed angular derivatives for the jacobian of a transformation vector, Equation 6.19 [Magnusson 2009]. 
+        * The precomputed angular derivatives for the jacobian of a transformation vector, Equation 6.19 [Magnusson 2009].
         */
       Eigen::Vector3d j_ang_a_, j_ang_b_, j_ang_c_, j_ang_d_, j_ang_e_, j_ang_f_, j_ang_g_, j_ang_h_;
 
@@ -476,7 +466,7 @@ namespace pcl
 
 }
 
-    //#include &lt;pcl/registration/impl/ndt.hpp&gt;
-#include "fast_pcl/registration/impl/ndt.hpp"
+//#include &lt;pcl/registration/impl/ndt.hpp&gt;
+#include "pcl_omp/registration/impl/ndt.hpp"
 
-#endif // FAST_PCL_REGISTRATION_NDT_H_
+#endif // PCL_OMP_REGISTRATION_NDT_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\include\fast_pcl\registration\registration.h" new_path="ros\src\computing\perception\localization\lib\pcl_omp\registration\include\pcl_omp\registration\registration.h" added_lines="90" deleted_lines="102">
				<diff>@@ -38,8 +38,8 @@
  *
  */
 
-#ifndef FAST_PCL_REGISTRATION_H_
-#define FAST_PCL_REGISTRATION_H_
+#ifndef PCL_OMP_REGISTRATION_H_
+#define PCL_OMP_REGISTRATION_H_
 
 // PCL includes
 #include &lt;pcl/pcl_base.h&gt;
@@ -47,31 +47,27 @@
 #include &lt;pcl/pcl_macros.h&gt;
 #include &lt;pcl/search/kdtree.h&gt;
 #include &lt;pcl/kdtree/kdtree_flann.h&gt;
-//#include &lt;pcl/registration/boost.h&gt;
-//#include &lt;pcl/registration/transformation_estimation.h&gt;
-//#include &lt;pcl/registration/correspondence_estimation.h&gt;
-//#include &lt;pcl/registration/correspondence_rejection.h&gt;
-#include "fast_pcl/registration/boost.h"
-#include "fast_pcl/registration/transformation_estimation.h"
-#include "fast_pcl/registration/correspondence_estimation.h"
-#include "fast_pcl/registration/correspondence_rejection.h"
-
-namespace pcl
+#include &lt;pcl/registration/boost.h&gt;
+#include &lt;pcl/registration/transformation_estimation.h&gt;
+#include &lt;pcl/registration/correspondence_estimation.h&gt;
+#include &lt;pcl/registration/correspondence_rejection.h&gt;
+
+namespace pcl_omp
 {
   /** \brief @b Registration represents the base registration class for general purpose, ICP-like methods.
     * \author Radu B. Rusu, Michael Dixon
     * \ingroup registration
     */
   template &lt;typename PointSource, typename PointTarget, typename Scalar = float&gt;
-  class Registration : public PCLBase&lt;PointSource&gt;
+  class Registration : public pcl::PCLBase&lt;PointSource&gt;
   {
     public:
       typedef Eigen::Matrix&lt;Scalar, 4, 4&gt; Matrix4;
 
-      // using PCLBase&lt;PointSource&gt;::initCompute;
-      using PCLBase&lt;PointSource&gt;::deinitCompute;
-      using PCLBase&lt;PointSource&gt;::input_;
-      using PCLBase&lt;PointSource&gt;::indices_;
+      // using pcl::PCLBase&lt;PointSource&gt;::initCompute;
+      using pcl::PCLBase&lt;PointSource&gt;::deinitCompute;
+      using pcl::PCLBase&lt;PointSource&gt;::input_;
+      using pcl::PCLBase&lt;PointSource&gt;::indices_;
 
       typedef boost::shared_ptr&lt; Registration&lt;PointSource, PointTarget, Scalar&gt; &gt; Ptr;
       typedef boost::shared_ptr&lt; const Registration&lt;PointSource, PointTarget, Scalar&gt; &gt; ConstPtr;
@@ -82,7 +78,7 @@ namespace pcl
 
       typedef pcl::search::KdTree&lt;PointSource&gt; KdTreeReciprocal;
       typedef typename KdTreeReciprocal::Ptr KdTreeReciprocalPtr;
-     
+
       typedef pcl::PointCloud&lt;PointSource&gt; PointCloudSource;
       typedef typename PointCloudSource::Ptr PointCloudSourcePtr;
       typedef typename PointCloudSource::ConstPtr PointCloudSourceConstPtr;
@@ -92,7 +88,7 @@ namespace pcl
       typedef typename PointCloudTarget::ConstPtr PointCloudTargetConstPtr;
 
       typedef typename KdTree::PointRepresentationConstPtr PointRepresentationConstPtr;
-      
+
       typedef typename pcl::registration::TransformationEstimation&lt;PointSource, PointTarget, Scalar&gt; TransformationEstimation;
       typedef typename TransformationEstimation::Ptr TransformationEstimationPtr;
       typedef typename TransformationEstimation::ConstPtr TransformationEstimationConstPtr;
@@ -102,7 +98,7 @@ namespace pcl
       typedef typename CorrespondenceEstimation::ConstPtr CorrespondenceEstimationConstPtr;
 
       /** \brief Empty constructor. */
-      Registration () 
+      Registration ()
         : reg_name_ ()
         , tree_ (new KdTree)
         , tree_reciprocal_ (new KdTreeReciprocal)
@@ -119,7 +115,7 @@ namespace pcl
         , inlier_threshold_ (0.05)
         , converged_ (false)
         , min_number_correspondences_ (3)
-        , correspondences_ (new Correspondences)
+        , correspondences_ (new pcl::Correspondences)
         , transformation_estimation_ ()
         , correspondence_estimation_ ()
         , correspondence_rejectors_ ()
@@ -136,8 +132,8 @@ namespace pcl
       virtual ~Registration () {}
 
       /** \brief Provide a pointer to the transformation estimation object.
-        * (e.g., SVD, point to plane etc.) 
-        * 
+        * (e.g., SVD, point to plane etc.)
+        *
         * \param[in] te is the pointer to the corresponding transformation estimation object
         *
         * Code example:
@@ -154,8 +150,8 @@ namespace pcl
       setTransformationEstimation (const TransformationEstimationPtr &amp;te) { transformation_estimation_ = te; }
 
       /** \brief Provide a pointer to the correspondence estimation object.
-        * (e.g., regular, reciprocal, normal shooting etc.) 
-        * 
+        * (e.g., regular, reciprocal, normal shooting etc.)
+        *
         * \param[in] ce is the pointer to the corresponding correspondence estimation object
         *
         * Code example:
@@ -177,7 +173,7 @@ namespace pcl
       void
       setCorrespondenceEstimation (const CorrespondenceEstimationPtr &amp;ce) { correspondence_estimation_ = ce; }
 
-      /** \brief Provide a pointer to the input source 
+      /** \brief Provide a pointer to the input source
         * (e.g., the point cloud that we want to align to the target)
         *
         * \param[in] cloud the input point cloud source
@@ -191,7 +187,7 @@ namespace pcl
       PointCloudSourceConstPtr const
       getInputCloud ();
 
-      /** \brief Provide a pointer to the input source 
+      /** \brief Provide a pointer to the input source
         * (e.g., the point cloud that we want to align to the target)
         *
         * \param[in] cloud the input point cloud source
@@ -200,7 +196,7 @@ namespace pcl
       setInputSource (const PointCloudSourceConstPtr &amp;cloud)
       {
         source_cloud_updated_ = true;
-        PCLBase&lt;PointSource&gt;::setInputCloud (cloud);
+        pcl::PCLBase&lt;PointSource&gt;::setInputCloud (cloud);
       }
 
       /** \brief Get a pointer to the input point cloud dataset target. */
@@ -210,26 +206,26 @@ namespace pcl
       /** \brief Provide a pointer to the input target (e.g., the point cloud that we want to align the input source to)
         * \param[in] cloud the input point cloud target
         */
-      virtual inline void 
-      setInputTarget (const PointCloudTargetConstPtr &amp;cloud); 
+      virtual inline void
+      setInputTarget (const PointCloudTargetConstPtr &amp;cloud);
 
       /** \brief Get a pointer to the input point cloud dataset target. */
-      inline PointCloudTargetConstPtr const 
+      inline PointCloudTargetConstPtr const
       getInputTarget () { return (target_ ); }
 
 
       /** \brief Provide a pointer to the search object used to find correspondences in
         * the target cloud.
         * \param[in] tree a pointer to the spatial search object.
-        * \param[in] force_no_recompute If set to true, this tree will NEVER be 
-        * recomputed, regardless of calls to setInputTarget. Only use if you are 
+        * \param[in] force_no_recompute If set to true, this tree will NEVER be
+        * recomputed, regardless of calls to setInputTarget. Only use if you are
         * confident that the tree will be set correctly.
         */
       inline void
-      setSearchMethodTarget (const KdTreePtr &amp;tree, 
-                             bool force_no_recompute = false) 
-      { 
-        tree_ = tree; 
+      setSearchMethodTarget (const KdTreePtr &amp;tree,
+                             bool force_no_recompute = false)
+      {
+        tree_ = tree;
         if (force_no_recompute)
         {
           force_no_recompute_ = true;
@@ -249,15 +245,15 @@ namespace pcl
       /** \brief Provide a pointer to the search object used to find correspondences in
         * the source cloud (usually used by reciprocal correspondence finding).
         * \param[in] tree a pointer to the spatial search object.
-        * \param[in] force_no_recompute If set to true, this tree will NEVER be 
-        * recomputed, regardless of calls to setInputSource. Only use if you are 
+        * \param[in] force_no_recompute If set to true, this tree will NEVER be
+        * recomputed, regardless of calls to setInputSource. Only use if you are
         * extremely confident that the tree will be set correctly.
         */
       inline void
-      setSearchMethodSource (const KdTreeReciprocalPtr &amp;tree, 
-                             bool force_no_recompute = false) 
-      { 
-        tree_reciprocal_ = tree; 
+      setSearchMethodSource (const KdTreeReciprocalPtr &amp;tree,
+                             bool force_no_recompute = false)
+      {
+        tree_reciprocal_ = tree;
         if ( force_no_recompute )
         {
           force_no_recompute_reciprocal_ = true;
@@ -285,81 +281,81 @@ namespace pcl
       /** \brief Set the maximum number of iterations the internal optimization should run for.
         * \param[in] nr_iterations the maximum number of iterations the internal optimization should run for
         */
-      inline void 
+      inline void
       setMaximumIterations (int nr_iterations) { max_iterations_ = nr_iterations; }
 
       /** \brief Get the maximum number of iterations the internal optimization should run for, as set by the user. */
-      inline int 
+      inline int
       getMaximumIterations () { return (max_iterations_); }
 
       /** \brief Set the number of iterations RANSAC should run for.
         * \param[in] ransac_iterations is the number of iterations RANSAC should run for
         */
-      inline void 
+      inline void
       setRANSACIterations (int ransac_iterations) { ransac_iterations_ = ransac_iterations; }
 
       /** \brief Get the number of iterations RANSAC should run for, as set by the user. */
-      inline double 
+      inline double
       getRANSACIterations () { return (ransac_iterations_); }
 
       /** \brief Set the inlier distance threshold for the internal RANSAC outlier rejection loop.
-        * 
-        * The method considers a point to be an inlier, if the distance between the target data index and the transformed 
-        * source index is smaller than the given inlier distance threshold. 
+        *
+        * The method considers a point to be an inlier, if the distance between the target data index and the transformed
+        * source index is smaller than the given inlier distance threshold.
         * The value is set by default to 0.05m.
         * \param[in] inlier_threshold the inlier distance threshold for the internal RANSAC outlier rejection loop
         */
-      inline void 
+      inline void
       setRANSACOutlierRejectionThreshold (double inlier_threshold) { inlier_threshold_ = inlier_threshold; }
 
       /** \brief Get the inlier distance threshold for the internal outlier rejection loop as set by the user. */
-      inline double 
+      inline double
       getRANSACOutlierRejectionThreshold () { return (inlier_threshold_); }
 
-      /** \brief Set the maximum distance threshold between two correspondent points in source &lt;-&gt; target. If the 
+      /** \brief Set the maximum distance threshold between two correspondent points in source &lt;-&gt; target. If the
         * distance is larger than this threshold, the points will be ignored in the alignment process.
-        * \param[in] distance_threshold the maximum distance threshold between a point and its nearest neighbor 
+        * \param[in] distance_threshold the maximum distance threshold between a point and its nearest neighbor
         * correspondent in order to be considered in the alignment process
         */
-      inline void 
+      inline void
       setMaxCorrespondenceDistance (double distance_threshold) { corr_dist_threshold_ = distance_threshold; }
 
-      /** \brief Get the maximum distance threshold between two correspondent points in source &lt;-&gt; target. If the 
+      /** \brief Get the maximum distance threshold between two correspondent points in source &lt;-&gt; target. If the
         * distance is larger than this threshold, the points will be ignored in the alignment process.
         */
-      inline double 
+      inline double
       getMaxCorrespondenceDistance () { return (corr_dist_threshold_); }
 
-      /** \brief Set the transformation epsilon (maximum allowable difference between two consecutive 
-        * transformations) in order for an optimization to be considered as having converged to the final 
+      /** \brief Set the transformation epsilon (maximum allowable difference between two consecutive
+        * transformations) in order for an optimization to be considered as having converged to the final
         * solution.
-        * \param[in] epsilon the transformation epsilon in order for an optimization to be considered as having 
+        * \param[in] epsilon the transformation epsilon in order for an optimization to be considered as having
         * converged to the final solution.
         */
-      inline void 
+      inline void
       setTransformationEpsilon (double epsilon) { transformation_epsilon_ = epsilon; }
 
-      /** \brief Get the transformation epsilon (maximum allowable difference between two consecutive 
+      /** \brief Get the transformation epsilon (maximum allowable difference between two consecutive
         * transformations) as set by the user.
         */
-      inline double 
+      inline double
       getTransformationEpsilon () { return (transformation_epsilon_); }
 
-      /** \brief Set the maximum allowed Euclidean error between two consecutive steps in the ICP loop, before 
-        * the algorithm is considered to have converged. 
-        * The error is estimated as the sum of the differences between correspondences in an Euclidean sense, 
+      /** \brief Set the maximum allowed Euclidean error between two consecutive steps in the ICP loop, before
+        * the algorithm is considered to have converged.
+        * The error is estimated as the sum of the differences between correspondences in an Euclidean sense,
         * divided by the number of correspondences.
         * \param[in] epsilon the maximum allowed distance error before the algorithm will be considered to have
         * converged
         */
 
-      inline void 
+      inline void
       setEuclideanFitnessEpsilon (double epsilon) { euclidean_fitness_epsilon_ = epsilon; }
 
       /** \brief Get the maximum allowed distance error before the algorithm will be considered to have converged,
         * as set by the user. See \ref setEuclideanFitnessEpsilon
         */
-      inline double 
+      inline double
       getEuclideanFitnessEpsilon () { return (euclidean_fitness_epsilon_); }
 
       /** \brief Provide a boost shared pointer to the PointRepresentation to be used when comparing points
@@ -388,49 +384,44 @@ namespace pcl
       }
 
       /** \brief Obtain the Euclidean fitness score (e.g., sum of squared distances from the source to the target)
-        * \param[in] max_range maximum allowable distance between a point and its correspondence in the target 
+        * \param[in] max_range maximum allowable distance between a point and its correspondence in the target
         * (default: double::max)
         */
-      inline double 
+      inline double
       getFitnessScore (double max_range = std::numeric_limits&lt;double&gt;::max ());
 
-      inline double
-	  omp_getFitnessScore (double max_range = std::numeric_limits&lt;double&gt;::max ());
 
       /** \brief Obtain the Euclidean fitness score (e.g., sum of squared distances from the source to the target)
         * from two sets of correspondence distances (distances between source and target points)
         * \param[in] distances_a the first set of distances between correspondences
         * \param[in] distances_b the second set of distances between correspondences
         */
-      inline double 
+      inline double
       getFitnessScore (const std::vector&lt;float&gt; &amp;distances_a, const std::vector&lt;float&gt; &amp;distances_b);
 
       /** \brief Return the state of convergence after the last align run */
-      inline bool 
+      inline bool
       hasConverged () { return (converged_); }
 
-      /** \brief Call the registration algorithm which estimates the transformation and returns the transformed source 
+      /** \brief Call the registration algorithm which estimates the transformation and returns the transformed source
         * (input) as \a output.
         * \param[out] output the resultant input transfomed point cloud dataset
         */
       inline void
       align (PointCloudSource &amp;output);
 
-      /** \brief Call the registration algorithm which estimates the transformation and returns the transformed source 
+      /** \brief Call the registration algorithm which estimates the transformation and returns the transformed source
         * (input) as \a output.
         * \param[out] output the resultant input transfomed point cloud dataset
         * \param[in] guess the initial gross estimation of the transformation
         */
-      inline void 
-      align (PointCloudSource &amp;output, const Matrix4&amp; guess);
-
       inline void
-      omp_align (PointCloudSource &amp;output, const Matrix4&amp; guess);
+      align (PointCloudSource &amp;output, const Matrix4&amp; guess);
 
       /** \brief Abstract class get name method. */
       inline const std::string&amp;
       getClassName () const { return (reg_name_); }
-        
+
       /** \brief Internal computation initalization. */
       bool
       initCompute ();
@@ -450,7 +441,7 @@ namespace pcl
         * rej.setInputTarget&lt;PointXYZ&gt; (keypoints_tgt);
         * rej.setMaximumDistance (1);
         * rej.setInputCorrespondences (all_correspondences);
-        * 
+        *
         * // or...
         *
         * \endcode
@@ -493,7 +484,7 @@ namespace pcl
 
       /** \brief A pointer to the spatial search object. */
       KdTreePtr tree_;
-      
+
       /** \brief A pointer to the spatial search object of the source. */
       KdTreeReciprocalPtr tree_reciprocal_;
 
@@ -520,38 +511,38 @@ namespace pcl
       /** \brief The previous transformation matrix estimated by the registration method (used internally). */
       Matrix4 previous_transformation_;
 
-      /** \brief The maximum difference between two consecutive transformations in order to consider convergence 
-        * (user defined). 
+      /** \brief The maximum difference between two consecutive transformations in order to consider convergence
+        * (user defined).
         */
       double transformation_epsilon_;
 
-      /** \brief The maximum allowed Euclidean error between two consecutive steps in the ICP loop, before the 
-        * algorithm is considered to have converged. The error is estimated as the sum of the differences between 
+      /** \brief The maximum allowed Euclidean error between two consecutive steps in the ICP loop, before the
+        * algorithm is considered to have converged. The error is estimated as the sum of the differences between
         * correspondences in an Euclidean sense, divided by the number of correspondences.
         */
       double euclidean_fitness_epsilon_;
 
-      /** \brief The maximum distance threshold between two correspondent points in source &lt;-&gt; target. If the 
+      /** \brief The maximum distance threshold between two correspondent points in source &lt;-&gt; target. If the
         * distance is larger than this threshold, the points will be ignored in the alignement process.
         */
       double corr_dist_threshold_;
 
       /** \brief The inlier distance threshold for the internal RANSAC outlier rejection loop.
-        * The method considers a point to be an inlier, if the distance between the target data index and the transformed 
-        * source index is smaller than the given inlier distance threshold. The default value is 0.05. 
+        * The method considers a point to be an inlier, if the distance between the target data index and the transformed
+        * source index is smaller than the given inlier distance threshold. The default value is 0.05.
         */
       double inlier_threshold_;
 
       /** \brief Holds internal convergence state, given user parameters. */
       bool converged_;
 
-      /** \brief The minimum number of correspondences that the algorithm needs before attempting to estimate the 
+      /** \brief The minimum number of correspondences that the algorithm needs before attempting to estimate the
         * transformation. The default value is 3.
         */
       int min_number_correspondences_;
 
       /** \brief The set of correspondences determined at this ICP step. */
-      CorrespondencesPtr correspondences_;
+      pcl::CorrespondencesPtr correspondences_;
 
       /** \brief A TransformationEstimation object, used to calculate the 4x4 rigid transformation. */
       TransformationEstimationPtr transformation_estimation_;
@@ -570,11 +561,11 @@ namespace pcl
        * This way, we avoid rebuilding the reciprocal kd-tree for the source cloud every time the determineCorrespondences () method
        * is called. */
       bool source_cloud_updated_;
-      /** \brief A flag which, if set, means the tree operating on the target cloud 
+      /** \brief A flag which, if set, means the tree operating on the target cloud
        * will never be recomputed*/
       bool force_no_recompute_;
-      
-      /** \brief A flag which, if set, means the tree operating on the source cloud 
+
+      /** \brief A flag which, if set, means the tree operating on the source cloud
        * will never be recomputed*/
       bool force_no_recompute_reciprocal_;
 
@@ -593,7 +584,7 @@ namespace pcl
         * \param distances the resultant distances from the query point to the k-nearest neighbors
         */
       inline bool
-      searchForNeighbors (const PointCloudSource &amp;cloud, int index, 
+      searchForNeighbors (const PointCloudSource &amp;cloud, int index,
                           std::vector&lt;int&gt; &amp;indices, std::vector&lt;float&gt; &amp;distances)
       {
         int k = tree_-&gt;nearestKSearch (cloud, index, 1, indices, distances);
@@ -603,11 +594,8 @@ namespace pcl
       }
 
       /** \brief Abstract transformation computation method with initial guess */
-      virtual void 
-      computeTransformation (PointCloudSource &amp;output, const Matrix4&amp; guess) = 0;
-
       virtual void
-      omp_computeTransformation (PointCloudSource &amp;output, const Matrix4&amp; guess) = 0;
+      computeTransformation (PointCloudSource &amp;output, const Matrix4&amp; guess) = 0;
 
     private:
       /** \brief The point representation used (internal). */
@@ -617,6 +605,6 @@ namespace pcl
    };
 }
 
-#include "fast_pcl/registration/impl/registration.hpp"
+#include "pcl_omp/registration/impl/registration.hpp"
 
-#endif  //#ifndef FAST_PCL_REGISTRATION_H_
+#endif  //#ifndef PCL_OMP_REGISTRATION_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\registration\src\ndt.cpp" new_path="ros\src\computing\perception\localization\lib\pcl_omp\registration\src\ndt.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -43,9 +43,9 @@
 
 //#include &lt;pcl/registration/ndt.h&gt;
 //#include &lt;pcl/registration/impl/ndt.hpp&gt;
-#include "fast_pcl/registration/ndt.h"
-#include "fast_pcl/registration/impl/ndt.hpp"
+#include "pcl_omp/registration/ndt.h"
+#include "pcl_omp/registration/impl/ndt.hpp"
 
-template class PCL_EXPORTS pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt;;
-template class PCL_EXPORTS pcl::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt;;
-template class PCL_EXPORTS pcl::NormalDistributionsTransform&lt;pcl::PointXYZRGB, pcl::PointXYZRGB&gt;;
+template class PCL_EXPORTS pcl_omp::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt;;
+template class PCL_EXPORTS pcl_omp::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt;;
+template class PCL_EXPORTS pcl_omp::NormalDistributionsTransform&lt;pcl::PointXYZRGB, pcl::PointXYZRGB&gt;;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="128" deleted_lines="114">
				<diff>@@ -58,20 +58,14 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#ifdef USE_PCL_OPENMP
-  #include &lt;fast_pcl/filters/voxel_grid.h&gt;
-  #include &lt;fast_pcl/registration/ndt.h&gt;
-#else
-  #include &lt;pcl/filters/voxel_grid.h&gt;
-  #include &lt;pcl/registration/ndt.h&gt;
-#endif
-
-
+#include &lt;pcl/registration/ndt.h&gt;
+#include &lt;fast_pcl/ndt_cpu/NormalDistributionsTransform.h&gt;
 #ifdef CUDA_FOUND
   #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
 #endif
-
-#include &lt;fast_pcl/ndt_cpu/NormalDistributionsTransform.h&gt;
+#ifdef USE_PCL_OPENMP
+  #include &lt;pcl_omp/registration/ndt.h&gt;
+#endif
 
 #include &lt;autoware_msgs/ConfigNdtMapping.h&gt;
 #include &lt;autoware_msgs/ConfigNdtMappingOutput.h&gt;
@@ -123,16 +117,16 @@ static double current_velocity_imu_z = 0.0;
 
 static pcl::PointCloud&lt;pcl::PointXYZI&gt; map;
 
-// Added for GPU ndt
+static pcl::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; ndt;
+static cpu::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; anh_ndt;
 #ifdef CUDA_FOUND
-static gpu::GNormalDistributionsTransform gpu_ndt;
+static gpu::GNormalDistributionsTransform anh_gpu_ndt;
+#endif
+#ifdef USE_PCL_OPENMP
+static pcl_omp::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; omp_ndt;
 #endif
 
-// Added for CPU ndt testing version
-static cpu::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; cpu_ndt;
 
-static pcl::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; ndt;
-// end of adding
 
 // Default values
 static int max_iter = 30;        // Maximum iterations
@@ -518,56 +512,59 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
 
-  #ifdef CUDA_FOUND
-    if (_method_type == MethodType::PCL_ANH_GPU)
-    {
-      gpu_ndt.setTransformationEpsilon(trans_eps);
-      gpu_ndt.setStepSize(step_size);
-      gpu_ndt.setResolution(ndt_res);
-      gpu_ndt.setMaximumIterations(max_iter);
-      gpu_ndt.setInputSource(filtered_scan_ptr);
-    }
-    else
-  #endif
+  if (_method_type == MethodType::PCL_GENERIC)
+  {
+    ndt.setTransformationEpsilon(trans_eps);
+    ndt.setStepSize(step_size);
+    ndt.setResolution(ndt_res);
+    ndt.setMaximumIterations(max_iter);
+    ndt.setInputSource(filtered_scan_ptr);
+  }
+  else if (_method_type == MethodType::PCL_ANH)
   {
-	  if (_method_type == MethodType::PCL_ANH)
-	  {
-        cpu_ndt.setTransformationEpsilon(trans_eps);
-  		cpu_ndt.setStepSize(step_size);
-  		cpu_ndt.setResolution(ndt_res);
-  		cpu_ndt.setMaximumIterations(max_iter);
-  		cpu_ndt.setInputSource(filtered_scan_ptr);
-	  }
-	  else
-	  {
-        ndt.setTransformationEpsilon(trans_eps);
-		ndt.setStepSize(step_size);
-		ndt.setResolution(ndt_res);
-		ndt.setMaximumIterations(max_iter);
-		ndt.setInputSource(filtered_scan_ptr);
-	  }
+    anh_ndt.setTransformationEpsilon(trans_eps);
+    anh_ndt.setStepSize(step_size);
+    anh_ndt.setResolution(ndt_res);
+    anh_ndt.setMaximumIterations(max_iter);
+    anh_ndt.setInputSource(filtered_scan_ptr);
   }
+#ifdef CUDA_FOUND
+  else if (_method_type == MethodType::PCL_ANH_GPU)
+  {
+    anh_gpu_ndt.setTransformationEpsilon(trans_eps);
+    anh_gpu_ndt.setStepSize(step_size);
+    anh_gpu_ndt.setResolution(ndt_res);
+    anh_gpu_ndt.setMaximumIterations(max_iter);
+    anh_gpu_ndt.setInputSource(filtered_scan_ptr);
+  }
+#endif
+#ifdef USE_PCL_OPENMP
+  else if (_method_type == MethodType::PCL_OPENMP)
+  {
+    omp_ndt.setTransformationEpsilon(trans_eps);
+    omp_ndt.setStepSize(step_size);
+    omp_ndt.setResolution(ndt_res);
+    omp_ndt.setMaximumIterations(max_iter);
+    omp_ndt.setInputSource(filtered_scan_ptr);
+  }
+#endif
+
 
   static bool is_first_map = true;
   if (is_first_map == true)
   {
+    if (_method_type == MethodType::PCL_GENERIC)
+      ndt.setInputTarget(map_ptr);
+    else if (_method_type == MethodType::PCL_ANH)
+      anh_ndt.setInputTarget(map_ptr);
 #ifdef CUDA_FOUND
-    if (_method_type == MethodType::PCL_ANH_GPU)
-    {
-      gpu_ndt.setInputTarget(map_ptr);
-    }
-    else
+    else if (_method_type == MethodType::PCL_ANH_GPU)
+      anh_gpu_ndt.setInputTarget(map_ptr);
+#endif
+#ifdef USE_PCL_OPENMP
+    else if (_method_type == MethodType::PCL_OPENMP)
+      omp_ndt.setInputTarget(map_ptr);
 #endif
-    {
-    	if (_method_type == MethodType::PCL_ANH)
-    	{
-            cpu_ndt.setInputTarget(map_ptr);
-    	}
-		else
-		{
-          ndt.setInputTarget(map_ptr);
-		}
-    }
     is_first_map = false;
   }
 
@@ -611,42 +608,43 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
 
-  #ifdef CUDA_FOUND
-    if (_method_type == MethodType::PCL_ANH_GPU)
-    {
-      gpu_ndt.align(init_guess);
-      t_localizer = gpu_ndt.getFinalTransformation();
-      has_converged = gpu_ndt.hasConverged();
-      fitness_score = gpu_ndt.getFitnessScore();
-      final_num_iteration = ndt.getFinalNumIteration();
-    }
-    else
-  #endif
-    if (_method_type == MethodType::PCL_ANH)
-    {
-      cpu_ndt.align(init_guess);
-
-      t_localizer = cpu_ndt.getFinalTransformation();
-      has_converged = cpu_ndt.hasConverged();
-      fitness_score = cpu_ndt.getFitnessScore();
-
-      final_num_iteration = cpu_ndt.getFinalNumIteration();
-    }
-    else
-    {
-      #ifdef USE_PCL_OPENMP
-        ndt.omp_align(*output_cloud, init_guess);
-        fitness_score = ndt.omp_getFitnessScore();
-      #else
-        ndt.align(*output_cloud, init_guess);
-        fitness_score = ndt.getFitnessScore();
-      #endif
-      t_localizer = ndt.getFinalTransformation();
-      has_converged = ndt.hasConverged();
-      final_num_iteration = ndt.getFinalNumIteration();
-    }
-
 
+  if (_method_type == MethodType::PCL_GENERIC)
+  {
+    ndt.align(*output_cloud, init_guess);
+    fitness_score = ndt.getFitnessScore();
+    t_localizer = ndt.getFinalTransformation();
+    has_converged = ndt.hasConverged();
+    final_num_iteration = ndt.getFinalNumIteration();
+  }
+  else if (_method_type == MethodType::PCL_ANH)
+  {
+    anh_ndt.align(init_guess);
+    fitness_score = anh_ndt.getFitnessScore();
+    t_localizer = anh_ndt.getFinalTransformation();
+    has_converged = anh_ndt.hasConverged();
+    final_num_iteration = anh_ndt.getFinalNumIteration();
+  }
+#ifdef CUDA_FOUND
+  else if (_method_type == MethodType::PCL_ANH_GPU)
+  {
+    anh_gpu_ndt.align(init_guess);
+    fitness_score = anh_gpu_ndt.getFitnessScore();
+    t_localizer = anh_gpu_ndt.getFinalTransformation();
+    has_converged = anh_gpu_ndt.hasConverged();
+    final_num_iteration = anh_gpu_ndt.getFinalNumIteration();
+  }
+#endif
+#ifdef USE_PCL_OPENMP
+  else if (_method_type == MethodType::PCL_OPENMP)
+  {
+    omp_ndt.align(*output_cloud, init_guess);
+    fitness_score = omp_ndt.getFitnessScore();
+    t_localizer = omp_ndt.getFinalTransformation();
+    has_converged = omp_ndt.hasConverged();
+    final_num_iteration = omp_ndt.getFinalNumIteration();
+  }
+#endif
 
   t_base_link = t_localizer * tf_ltob;
 
@@ -774,26 +772,23 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     added_pose.pitch = current_pose.pitch;
     added_pose.yaw = current_pose.yaw;
 
-    #ifdef CUDA_FOUND
-        if (_method_type == MethodType::PCL_ANH_GPU)
-        {
-          gpu_ndt.setInputTarget(map_ptr);
-        }
-        else
-    #endif
-        {
-        	if (_method_type == MethodType::PCL_ANH)
-        	{
-              if(_incremental_voxel_update == true)
-                cpu_ndt.updateVoxelGrid(transformed_scan_ptr);
-              else
-                cpu_ndt.setInputTarget(map_ptr);
-        	}
-    		else
-    		{
-              ndt.setInputTarget(map_ptr);
-    		}
-        }
+    if (_method_type == MethodType::PCL_GENERIC)
+      ndt.setInputTarget(map_ptr);
+    else if (_method_type == MethodType::PCL_ANH)
+    {
+      if(_incremental_voxel_update == true)
+        anh_ndt.updateVoxelGrid(transformed_scan_ptr);
+      else
+        anh_ndt.setInputTarget(map_ptr);
+    }
+#ifdef CUDA_FOUND
+    else if (_method_type == MethodType::PCL_ANH_GPU)
+      anh_gpu_ndt.setInputTarget(map_ptr);
+#endif
+#ifdef USE_PCL_OPENMP
+    else if (_method_type == MethodType::PCL_OPENMP)
+      omp_ndt.setInputTarget(map_ptr);
+#endif
   }
 
 
@@ -958,6 +953,25 @@ int main(int argc, char** argv)
   std::cout &lt;&lt; "(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (" &lt;&lt; _tf_x &lt;&lt; ", " &lt;&lt; _tf_y &lt;&lt; ", " &lt;&lt; _tf_z &lt;&lt; ", "
             &lt;&lt; _tf_roll &lt;&lt; ", " &lt;&lt; _tf_pitch &lt;&lt; ", " &lt;&lt; _tf_yaw &lt;&lt; ")" &lt;&lt; std::endl;
 
+#ifndef CUDA_FOUND
+  if(_method_type == MethodType::PCL_ANH_GPU)
+  {
+    std::cerr &lt;&lt; "**************************************************************" &lt;&lt; std::endl;
+    std::cerr &lt;&lt; "[ERROR]PCL_ANH_GPU is not built. Please use other method type." &lt;&lt; std::endl;
+    std::cerr &lt;&lt; "**************************************************************" &lt;&lt; std::endl;
+    exit(1);
+  }
+#endif
+#ifndef USE_PCL_OPENMP
+  if(_method_type == MethodType::PCL_OPENMP)
+  {
+    std::cerr &lt;&lt; "**************************************************************" &lt;&lt; std::endl;
+    std::cerr &lt;&lt; "[ERROR]PCL_OPENMP is not built. Please use other method type." &lt;&lt; std::endl;
+    std::cerr &lt;&lt; "**************************************************************" &lt;&lt; std::endl;
+    exit(1);
+  }
+#endif
+
   Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);                 // tl: translation
   Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
   Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="200" deleted_lines="183">
				<diff>@@ -65,17 +65,15 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#ifdef USE_PCL_OPENMP
-  #include &lt;fast_pcl/registration/ndt.h&gt;
-#else
-  #include &lt;pcl/registration/ndt.h&gt;
-#endif
-
+#include &lt;pcl/registration/ndt.h&gt;
+#include &lt;fast_pcl/ndt_cpu/NormalDistributionsTransform.h&gt;
 #ifdef CUDA_FOUND
   #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
 #endif
+#ifdef USE_PCL_OPENMP
+  #include &lt;pcl_omp/registration/ndt.h&gt;
+#endif
 
-//End of adding
 
 #include &lt;pcl_ros/point_cloud.h&gt;
 #include &lt;pcl_ros/transforms.h&gt;
@@ -84,10 +82,6 @@
 
 #include &lt;autoware_msgs/ndt_stat.h&gt;
 
-//Added for testing on cpu
-#include &lt;fast_pcl/ndt_cpu/NormalDistributionsTransform.h&gt;
-//End of adding
-
 #define PREDICT_POSE_THRESHOLD 0.5
 
 #define Wa 0.4
@@ -130,15 +124,17 @@ static int map_loaded = 0;
 static int _use_gnss = 1;
 static int init_pos_set = 0;
 
+
+static pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;
+static cpu::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; anh_ndt;
 #ifdef CUDA_FOUND
-static std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; gpu_ndt_ptr = std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
+static std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; anh_gpu_ndt_ptr = std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
+#endif
+#ifdef USE_PCL_OPENMP
+static pcl_omp::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; omp_ndt;
 #endif
 
 
-static cpu::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; cpu_ndt;
-
-static pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;
-
 // Default values
 static int max_iter = 30;        // Maximum iterations
 static float ndt_res = 1.0;      // Resolution
@@ -270,89 +266,74 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
   if (input-&gt;resolution != ndt_res)
   {
     ndt_res = input-&gt;resolution;
+
+    if (_method_type == MethodType::PCL_GENERIC)
+      ndt.setResolution(ndt_res);
+    else if (_method_type == MethodType::PCL_ANH)
+      anh_ndt.setResolution(ndt_res);
 #ifdef CUDA_FOUND
-    if (_method_type == MethodType::PCL_ANH_GPU)
-    {
-      gpu_ndt_ptr-&gt;setResolution(ndt_res);
-    }
-    else
+    else if (_method_type == MethodType::PCL_ANH_GPU)
+      anh_gpu_ndt_ptr-&gt;setResolution(ndt_res);
+#endif
+#ifdef USE_PCL_OPENMP
+    else if (_method_type == MethodType::PCL_OPENMP)
+      omp_ndt.setResolution(ndt_res);
 #endif
-    {
-	  if (_method_type == MethodType::PCL_ANH)
-	  {
-        cpu_ndt.setResolution(ndt_res);
-	  }
-	  else
-	  {
-        ndt.setResolution(ndt_res);
-	  }
-    }
   }
 
   if (input-&gt;step_size != step_size)
   {
     step_size = input-&gt;step_size;
+
+    if (_method_type == MethodType::PCL_GENERIC)
+      ndt.setStepSize(step_size);
+    else if (_method_type == MethodType::PCL_ANH)
+      anh_ndt.setStepSize(step_size);
 #ifdef CUDA_FOUND
-    if (_method_type == MethodType::PCL_ANH_GPU)
-    {
-      gpu_ndt_ptr-&gt;setStepSize(step_size);
-    }
-    else
+    else if (_method_type == MethodType::PCL_ANH_GPU)
+      anh_gpu_ndt_ptr-&gt;setStepSize(step_size);
+#endif
+#ifdef USE_PCL_OPENMP
+    else if (_method_type == MethodType::PCL_OPENMP)
+      omp_ndt.setStepSize(ndt_res);
 #endif
-    {
-	  if (_method_type == MethodType::PCL_ANH)
-	  {
-        cpu_ndt.setStepSize(step_size);
-	  }
-	  else
-	  {
-        ndt.setStepSize(step_size);
-	  }
-    }
   }
 
   if (input-&gt;trans_epsilon != trans_eps)
   {
     trans_eps = input-&gt;trans_epsilon;
+
+    if (_method_type == MethodType::PCL_GENERIC)
+      ndt.setTransformationEpsilon(trans_eps);
+    else if (_method_type == MethodType::PCL_ANH)
+      anh_ndt.setTransformationEpsilon(trans_eps);
 #ifdef CUDA_FOUND
-    if (_method_type == MethodType::PCL_ANH_GPU)
-    {
-      gpu_ndt_ptr-&gt;setTransformationEpsilon(trans_eps);
-    }
-    else
+    else if (_method_type == MethodType::PCL_ANH_GPU)
+      anh_gpu_ndt_ptr-&gt;setTransformationEpsilon(trans_eps);
 #endif
-    {
-	  if (_method_type == MethodType::PCL_ANH)
-	  {
-        cpu_ndt.setTransformationEpsilon(trans_eps);
-	  }
-	  else
-	  {
-        ndt.setTransformationEpsilon(trans_eps);
-	  }
-    }
+#ifdef USE_PCL_OPENMP
+    else if (_method_type == MethodType::PCL_OPENMP)
+      omp_ndt.setTransformationEpsilon(ndt_res);
+#endif
+
   }
 
   if (input-&gt;max_iterations != max_iter)
   {
     max_iter = input-&gt;max_iterations;
+
+    if (_method_type == MethodType::PCL_GENERIC)
+      ndt.setMaximumIterations(max_iter);
+    else if (_method_type == MethodType::PCL_ANH)
+      anh_ndt.setMaximumIterations(max_iter);
 #ifdef CUDA_FOUND
-    if (_method_type == MethodType::PCL_ANH_GPU)
-    {
-      gpu_ndt_ptr-&gt;setMaximumIterations(max_iter);
-    }
-    else
+    else if (_method_type == MethodType::PCL_ANH_GPU)
+      anh_gpu_ndt_ptr-&gt;setMaximumIterations(max_iter);
+#endif
+#ifdef USE_PCL_OPENMP
+    else if (_method_type == MethodType::PCL_OPENMP)
+      omp_ndt.setMaximumIterations(ndt_res);
 #endif
-    {
-	  if (_method_type == MethodType::PCL_ANH)
-	  {
-        cpu_ndt.setMaximumIterations(max_iter);
-	  }
-	  else
-	  {
-        ndt.setMaximumIterations(max_iter);
-	  }
-    }
   }
 
   if (_use_gnss == 0 &amp;&amp; init_pos_set == 0)
@@ -460,69 +441,82 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
 
 // Setting point cloud to be aligned to.
-#ifdef CUDA_FOUND
-    if (_method_type == MethodType::PCL_ANH_GPU)
+    if (_method_type == MethodType::PCL_GENERIC)
+    {
+      pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_ndt;
+      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+      new_ndt.setResolution(ndt_res);
+      new_ndt.setInputTarget(map_ptr);
+      new_ndt.setMaximumIterations(max_iter);
+      new_ndt.setStepSize(step_size);
+      new_ndt.setTransformationEpsilon(trans_eps);
+
+      new_ndt.align(*output_cloud, Eigen::Matrix4f::Identity());
+
+      pthread_mutex_lock(&amp;mutex);
+      ndt = new_ndt;
+      pthread_mutex_unlock(&amp;mutex);
+    }
+    else if (_method_type == MethodType::PCL_ANH)
     {
-      std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; new_gpu_ndt_ptr = std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
-      new_gpu_ndt_ptr-&gt;setResolution(ndt_res);
-      new_gpu_ndt_ptr-&gt;setInputTarget(map_ptr);
-      new_gpu_ndt_ptr-&gt;setMaximumIterations(max_iter);
-      new_gpu_ndt_ptr-&gt;setStepSize(step_size);
-      new_gpu_ndt_ptr-&gt;setTransformationEpsilon(trans_eps);
+      cpu::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_anh_ndt;
+      new_anh_ndt.setResolution(ndt_res);
+      new_anh_ndt.setInputTarget(map_ptr);
+      new_anh_ndt.setMaximumIterations(max_iter);
+      new_anh_ndt.setStepSize(step_size);
+      new_anh_ndt.setTransformationEpsilon(trans_eps);
 
       pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr dummy_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;());
       pcl::PointXYZ dummy_point;
       dummy_scan_ptr-&gt;push_back(dummy_point);
-      new_gpu_ndt_ptr-&gt;setInputSource(dummy_scan_ptr);
+      new_anh_ndt.setInputSource(dummy_scan_ptr);
 
-      new_gpu_ndt_ptr-&gt;align(Eigen::Matrix4f::Identity());
+      new_anh_ndt.align(Eigen::Matrix4f::Identity());
 
       pthread_mutex_lock(&amp;mutex);
-      gpu_ndt_ptr = new_gpu_ndt_ptr;
+      anh_ndt = new_anh_ndt;
       pthread_mutex_unlock(&amp;mutex);
     }
-    else
-#endif
-    if (_method_type == MethodType::PCL_ANH)
+#ifdef CUDA_FOUND
+    else if (_method_type == MethodType::PCL_ANH_GPU)
     {
-      cpu::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_cpu_ndt;
-      new_cpu_ndt.setResolution(ndt_res);
-      new_cpu_ndt.setInputTarget(map_ptr);
-      new_cpu_ndt.setMaximumIterations(max_iter);
-      new_cpu_ndt.setStepSize(step_size);
-      new_cpu_ndt.setTransformationEpsilon(trans_eps);
+      std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; new_anh_gpu_ndt_ptr = std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
+      new_anh_gpu_ndt_ptr-&gt;setResolution(ndt_res);
+      new_anh_gpu_ndt_ptr-&gt;setInputTarget(map_ptr);
+      new_anh_gpu_ndt_ptr-&gt;setMaximumIterations(max_iter);
+      new_anh_gpu_ndt_ptr-&gt;setStepSize(step_size);
+      new_anh_gpu_ndt_ptr-&gt;setTransformationEpsilon(trans_eps);
 
       pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr dummy_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;());
       pcl::PointXYZ dummy_point;
       dummy_scan_ptr-&gt;push_back(dummy_point);
-      new_cpu_ndt.setInputSource(dummy_scan_ptr);
+      new_anh_gpu_ndt_ptr-&gt;setInputSource(dummy_scan_ptr);
 
-      new_cpu_ndt.align(Eigen::Matrix4f::Identity());
+      new_anh_gpu_ndt_ptr-&gt;align(Eigen::Matrix4f::Identity());
 
       pthread_mutex_lock(&amp;mutex);
-      cpu_ndt = new_cpu_ndt;
+      anh_gpu_ndt_ptr = new_anh_gpu_ndt_ptr;
       pthread_mutex_unlock(&amp;mutex);
     }
-    else
+#endif
+#ifdef USE_PCL_OPENMP
+    else if (_method_type == MethodType::PCL_OPENMP)
     {
-      pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_ndt;
+      pcl_omp::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_omp_ndt;
       pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-      new_ndt.setResolution(ndt_res);
-      new_ndt.setInputTarget(map_ptr);
-      new_ndt.setMaximumIterations(max_iter);
-      new_ndt.setStepSize(step_size);
-      new_ndt.setTransformationEpsilon(trans_eps);
-      #ifdef USE_PCL_OPENMP
-        new_ndt.omp_align(*output_cloud, Eigen::Matrix4f::Identity());
-      #else
-        new_ndt.align(*output_cloud, Eigen::Matrix4f::Identity());
-      #endif
+      new_omp_ndt.setResolution(ndt_res);
+      new_omp_ndt.setInputTarget(map_ptr);
+      new_omp_ndt.setMaximumIterations(max_iter);
+      new_omp_ndt.setStepSize(step_size);
+      new_omp_ndt.setTransformationEpsilon(trans_eps);
+
+      new_omp_ndt.align(*output_cloud, Eigen::Matrix4f::Identity());
 
       pthread_mutex_lock(&amp;mutex);
-      ndt = new_ndt;
+      omp_ndt = new_omp_ndt;
       pthread_mutex_unlock(&amp;mutex);
     }
-
+#endif
     map_loaded = 1;
   }
 }
@@ -908,24 +902,18 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     static double align_time, getFitnessScore_time = 0.0;
 
     pthread_mutex_lock(&amp;mutex);
+
+    if (_method_type == MethodType::PCL_GENERIC)
+      ndt.setInputSource(filtered_scan_ptr);
+    else if (_method_type == MethodType::PCL_ANH)
+      anh_ndt.setInputSource(filtered_scan_ptr);
 #ifdef CUDA_FOUND
-    if (_method_type == MethodType::PCL_ANH_GPU)
-    {
-      gpu_ndt_ptr-&gt;setInputSource(filtered_scan_ptr);
-    }
-    else
-    {
+    else if (_method_type == MethodType::PCL_ANH_GPU)
+        anh_gpu_ndt_ptr-&gt;setInputSource(filtered_scan_ptr);
 #endif
-		if (_method_type == MethodType::PCL_ANH)
-		{
-          cpu_ndt.setInputSource(filtered_scan_ptr);
-		}
-		else
-		{
-          ndt.setInputSource(filtered_scan_ptr);
-		}
-#ifdef CUDA_FOUND
-    }
+#ifdef USE_PCL_OPENMP
+    else if (_method_type == MethodType::PCL_OPENMP)
+        omp_ndt.setInputSource(filtered_scan_ptr);
 #endif
 
     // Guess the initial gross estimation of the transformation
@@ -962,69 +950,78 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
 
 
-    #ifdef CUDA_FOUND
-      if (_method_type == MethodType::PCL_ANH_GPU)
-      {
-        align_start = std::chrono::system_clock::now();
-        gpu_ndt_ptr-&gt;align(init_guess);
-        align_end = std::chrono::system_clock::now();
+    if (_method_type == MethodType::PCL_GENERIC)
+    {
+      align_start = std::chrono::system_clock::now();
+      ndt.align(*output_cloud, init_guess);
+      align_end = std::chrono::system_clock::now();
 
-        has_converged = gpu_ndt_ptr-&gt;hasConverged();
+      has_converged = ndt.hasConverged();
 
-        t = gpu_ndt_ptr-&gt;getFinalTransformation();
-        iteration = gpu_ndt_ptr-&gt;getFinalNumIteration();
+      t = ndt.getFinalTransformation();
+      iteration = ndt.getFinalNumIteration();
 
-        getFitnessScore_start = std::chrono::system_clock::now();
-        fitness_score = gpu_ndt_ptr-&gt;getFitnessScore();
-        getFitnessScore_end = std::chrono::system_clock::now();
+      getFitnessScore_start = std::chrono::system_clock::now();
+      fitness_score = ndt.getFitnessScore();
+      getFitnessScore_end = std::chrono::system_clock::now();
 
-        trans_probability = gpu_ndt_ptr-&gt;getTransformationProbability();
-      }
-      else
-    #endif
-      if (_method_type == MethodType::PCL_ANH)
-      {
-        align_start = std::chrono::system_clock::now();
-        cpu_ndt.align(init_guess);
-        align_end = std::chrono::system_clock::now();
+      trans_probability = ndt.getTransformationProbability();
+    }
+    else if (_method_type == MethodType::PCL_ANH)
+    {
+      align_start = std::chrono::system_clock::now();
+      anh_ndt.align(init_guess);
+      align_end = std::chrono::system_clock::now();
 
-        has_converged = cpu_ndt.hasConverged();
+      has_converged = anh_ndt.hasConverged();
 
-        t = cpu_ndt.getFinalTransformation();
-        iteration = cpu_ndt.getFinalNumIteration();
+      t = anh_ndt.getFinalTransformation();
+      iteration = anh_ndt.getFinalNumIteration();
 
-        getFitnessScore_start = std::chrono::system_clock::now();
-        fitness_score = cpu_ndt.getFitnessScore();
-        getFitnessScore_end = std::chrono::system_clock::now();
+      getFitnessScore_start = std::chrono::system_clock::now();
+      fitness_score = anh_ndt.getFitnessScore();
+      getFitnessScore_end = std::chrono::system_clock::now();
 
-        trans_probability = cpu_ndt.getTransformationProbability();
-      }
-      else
-      {
-        align_start = std::chrono::system_clock::now();
-        #ifdef USE_PCL_OPENMP
-          ndt.omp_align(*output_cloud, init_guess);
-        #else
-          ndt.align(*output_cloud, init_guess);
-        #endif
-        align_end = std::chrono::system_clock::now();
-
-        has_converged = ndt.hasConverged();
-
-        t = ndt.getFinalTransformation();
-        iteration = ndt.getFinalNumIteration();
-
-        getFitnessScore_start = std::chrono::system_clock::now();
-        #ifdef USE_PCL_OPENMP
-          fitness_score = ndt.omp_getFitnessScore();
-        #else
-          fitness_score = ndt.getFitnessScore();
-        #endif
-        getFitnessScore_end = std::chrono::system_clock::now();
-
-        trans_probability = ndt.getTransformationProbability();
-      }
+      trans_probability = anh_ndt.getTransformationProbability();
+    }
+#ifdef CUDA_FOUND
+    else if (_method_type == MethodType::PCL_ANH_GPU)
+    {
+      align_start = std::chrono::system_clock::now();
+      anh_gpu_ndt_ptr-&gt;align(init_guess);
+      align_end = std::chrono::system_clock::now();
+
+      has_converged = anh_gpu_ndt_ptr-&gt;hasConverged();
+
+      t = anh_gpu_ndt_ptr-&gt;getFinalTransformation();
+      iteration = anh_gpu_ndt_ptr-&gt;getFinalNumIteration();
+
+      getFitnessScore_start = std::chrono::system_clock::now();
+      fitness_score = anh_gpu_ndt_ptr-&gt;getFitnessScore();
+      getFitnessScore_end = std::chrono::system_clock::now();
+
+      trans_probability = anh_gpu_ndt_ptr-&gt;getTransformationProbability();
+    }
+#endif
+#ifdef USE_PCL_OPENMP
+    else if (_method_type == MethodType::PCL_OPENMP)
+    {
+      align_start = std::chrono::system_clock::now();
+      omp_ndt.align(*output_cloud, init_guess);
+      align_end = std::chrono::system_clock::now();
+
+      has_converged = omp_ndt.hasConverged();
+
+      t = omp_ndt.getFinalTransformation();
+      iteration = omp_ndt.getFinalNumIteration();
 
+      getFitnessScore_start = std::chrono::system_clock::now();
+      fitness_score = omp_ndt.getFitnessScore();
+      getFitnessScore_end = std::chrono::system_clock::now();
+
+      trans_probability = omp_ndt.getTransformationProbability();
+    }
+#endif
     align_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(align_end - align_start).count() / 1000.0;
 
     t2 = t * tf_btol.inverse();
@@ -1548,6 +1545,26 @@ int main(int argc, char** argv)
             &lt;&lt; _tf_roll &lt;&lt; ", " &lt;&lt; _tf_pitch &lt;&lt; ", " &lt;&lt; _tf_yaw &lt;&lt; ")" &lt;&lt; std::endl;
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
 
+
+#ifndef CUDA_FOUND
+  if(_method_type == MethodType::PCL_ANH_GPU)
+  {
+    std::cerr &lt;&lt; "**************************************************************" &lt;&lt; std::endl;
+    std::cerr &lt;&lt; "[ERROR]PCL_ANH_GPU is not built. Please use other method type." &lt;&lt; std::endl;
+    std::cerr &lt;&lt; "**************************************************************" &lt;&lt; std::endl;
+    exit(1);
+  }
+#endif
+#ifndef USE_PCL_OPENMP
+  if(_method_type == MethodType::PCL_OPENMP)
+  {
+    std::cerr &lt;&lt; "**************************************************************" &lt;&lt; std::endl;
+    std::cerr &lt;&lt; "[ERROR]PCL_OPENMP is not built. Please use other method type." &lt;&lt; std::endl;
+    std::cerr &lt;&lt; "**************************************************************" &lt;&lt; std::endl;
+    exit(1);
+  }
+#endif
+
   Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);                 // tl: translation
   Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
   Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="409d4d255f0d325df3642d3961f08e0902f89b4b" author="AMC">
		<msg>Removed flawed subtree</msg>
		<modified_files>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_compression\src\compress2png.cpp" new_path="" added_lines="0" deleted_lines="171">
				<diff>@@ -1,171 +0,0 @@
-#include "ros/ros.h"
-#include &lt;ros/time.h&gt;
-#include "velodyne_pointcloud/rawdata.h"
-#include "ros/package.h"
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;iostream&gt;
-#include &lt;string&gt;  
-#include &lt;fstream&gt;  
-#include &lt;iostream&gt;  
-#include &lt;opencv2/opencv.hpp&gt;
-#include &lt;cv_bridge/cv_bridge.h&gt;
-#include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;opencv2/highgui/highgui.hpp&gt;
-#include &lt;image_transport/image_transport.h&gt;
-#include "std_msgs/UInt16MultiArray.h"
-#include &lt;velodyne_compression/CompressedPacket.h&gt;
-#include &lt;cmath&gt;
-
-
-
-#include &lt;vector&gt;
-#include &lt;sstream&gt;
-
-using namespace std;
-using namespace velodyne_rawdata;
-using namespace cv;
-
-velodyne_compression::CompressedPacket CompressedData;
-ros::Publisher *pubp;
-
-int i=1;
-int row_type;
-void velodyneCallback(const velodyne_msgs::VelodyneScan::ConstPtr &amp;msg)
-{
-static int count=0;
-count++;
-
-if (msg-&gt;packets.size()==348) //64ES2
-{
-
-  cout&lt;&lt;"Senor version:HDL64ES2/HDL64ES2.1"&lt;&lt;endl;
-  CompressedData.scan_row=64;
-  CompressedData.scan_column=2088;
-}
-else if (msg-&gt;packets.size()==580)//64ES3
-{
-  CompressedData.scan_row=64;
-  CompressedData.scan_column=6*580;;
-  cout&lt;&lt;"Senor version:HDL64ES3"&lt;&lt;endl;
-}
-else if (msg-&gt;packets.size()==260)//64E 260
-{
-  CompressedData.scan_row=64;
-  CompressedData.scan_column=6*260;
-  cout&lt;&lt;"Senor version:HDL64E"&lt;&lt;endl;
-}
-else if (msg-&gt;packets.size()==181)//32E 181
-{
-  CompressedData.scan_row=32;
-  CompressedData.scan_column=12*181;;
-  cout&lt;&lt;"Senor version:HDL32E"&lt;&lt;endl;
-}
-
-else if (msg-&gt;packets.size()==79)//VLP16
-{
-  CompressedData.scan_row=32;
-  CompressedData.scan_column=12*79;;
-  cout&lt;&lt;"Senor version:VLP16"&lt;&lt;endl;
-}
-else
-{
-   cout&lt;&lt;"Unknown device"&lt;&lt;endl;
-}
-Mat img(CompressedData.scan_row, CompressedData.scan_column, CV_16U);
-Mat img2(CompressedData.scan_row, CompressedData.scan_column, CV_8U);
-
-
-vector&lt;int&gt;compression_params;
-compression_params.push_back(CV_IMWRITE_PNG_COMPRESSION);
-compression_params.push_back(9);
-CompressedData.rotation.clear();
-  
- 
-for (int next=0; next&lt;msg-&gt;packets.size();++next)
-{
- const raw_packet_t *raw=(const raw_packet_t *) &amp;msg-&gt;packets[next].data[0];
-
-for (int i = 0; i &lt; BLOCKS_PER_PACKET; i++) {
-
-      // upper bank lasers are numbered [0..31]
-      // NOTE: this is a change from the old velodyne_common implementation
-      int bank_origin = 0;
-      if (raw-&gt;blocks[i].header == LOWER_BANK) {
-        // lower bank lasers are [32..63]
-        bank_origin = 32;
-      }
-for (int j = 0, k = 0; j &lt; SCANS_PER_BLOCK; j++, k += RAW_SCAN_SIZE) {
-        
-        uint8_t laser_number;       ///&lt; hardware laser number
-
-        laser_number=j+bank_origin;
-        union two_bytes tmp;
-        tmp.bytes[0] = raw-&gt;blocks[i].data[k];
-        tmp.bytes[1] = raw-&gt;blocks[i].data[k+1];
-        float distance = tmp.uint*DISTANCE_RESOLUTION;
-        int d=distance*100.0;
-        //printf("get %d\n",d);
-        int col;
-        if (CompressedData.scan_row==32)
-        {col=next*12+i;}
-        else
-        {col=floor(next*6+i/2);}
-
-        img.at&lt;ushort&gt;(laser_number, col) = d;
-        img2.at&lt;uchar&gt;(laser_number, col) = raw-&gt;blocks[i].data[k+2];
-
-        if (j==0)
-        {  
-          if (CompressedData.scan_row==32)
-          {
-            CompressedData.rotation.push_back(raw-&gt;blocks[i].rotation);
-          }
-          else
-            if (i%2==0)
-            {
-               CompressedData.rotation.push_back(raw-&gt;blocks[i].rotation);
-            }
-        }
-
-}
-}
-
-} 
-
-
-CompressedData.header=msg-&gt;header;
-if (cv::imencode(".png", img, CompressedData.distance, compression_params))
-{
-
-    cv::imencode(".png", img2, CompressedData.intensity, compression_params);
-    cout&lt;&lt;"Frame "&lt;&lt;i&lt;&lt;" is Compressing"&lt;&lt;endl;
-    i++;
-}
-
-pubp-&gt;publish(CompressedData);
-
-}
-
-int main(int argc, char **argv)
-{
-  printf("Compression start \n");
-
-
-  ros::init(argc, argv, "velodyne_compression");
-
-  ros::NodeHandle n;
-  ros::NodeHandle nh;
-  ros::Publisher pub=nh.advertise&lt;velodyne_compression::CompressedPacket&gt;("velodyne_packets_compressed",1000);
-
-
-  pubp=&amp;pub;
-
-  ros::Subscriber sub = n.subscribe("/velodyne_packets", 500000, velodyneCallback);
-
-  ros::spin();
-
-  return 0;
-}
-
-
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_compression\src\driver.h" new_path="" added_lines="0" deleted_lines="63">
				<diff>@@ -1,63 +0,0 @@
-/* -*- mode: C++ -*- */
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- * 
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
- *
- *  ROS driver interface for the Velodyne 3D LIDARs
- */
-
-#ifndef _VELODYNE_DRIVER_H_
-#define _VELODYNE_DRIVER_H_ 1
-
-#include &lt;string&gt;
-#include &lt;ros/ros.h&gt;
-#include &lt;diagnostic_updater/diagnostic_updater.h&gt;
-#include &lt;diagnostic_updater/publisher.h&gt;
-#include &lt;opencv2/opencv.hpp&gt;
-
-#include &lt;velodyne_driver/input.h&gt;
-
-namespace velodyne_driver
-{
-
-class VelodyneDriver
-{
-public:
-
-  VelodyneDriver(ros::NodeHandle node,
-                 ros::NodeHandle private_nh);
-  ~VelodyneDriver() {}
-
-  //bool poll(void);
-  bool poll(cv::Mat img_distance,cv::Mat img_inten);
-
-private:
-
-  // configuration parameters
-  struct
-  {
-    std::string frame_id;            ///&lt; tf frame ID
-    std::string model;               ///&lt; device model name
-    int    npackets;                 ///&lt; number of packets to collect
-    double rpm;                      ///&lt; device rotation rate (RPMs)
-  } config_;
-
-  boost::shared_ptr&lt;Input&gt; input_;
-  ros::Publisher output_;
-
-  /** diagnostics updater */
-  diagnostic_updater::Updater diagnostics_;
-  double diag_min_freq_;
-  double diag_max_freq_;
-  boost::shared_ptr&lt;diagnostic_updater::TopicDiagnostic&gt; diag_topic_;
-};
-
-} // namespace velodyne_driver
-
-#endif // _VELODYNE_DRIVER_H_
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_compression\src\recon2packet.cpp" new_path="" added_lines="0" deleted_lines="351">
				<diff>@@ -1,351 +0,0 @@
-#include &lt;ros/ros.h&gt;
-#include "velodyne_pointcloud/rawdata.h"
-#include "ros/package.h"
-#include "driver.h"
-#include &lt;string&gt;
-#include &lt;cmath&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;iostream&gt;
-#include &lt;vector&gt;  
-#include &lt;string&gt;  
-#include &lt;fstream&gt;  
-#include &lt;iostream&gt;  
-#include &lt;opencv2/opencv.hpp&gt;
-#include &lt;tf/transform_listener.h&gt;
-#include "velodyne_msgs/VelodyneScan.h"
-#include &lt;unistd.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;ros/ros.h&gt;
-#include "driver.h"
-#include "std_msgs/UInt16MultiArray.h"
-#include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;vector&gt;
-#include "std_msgs/MultiArrayDimension.h"
-#include "std_msgs/MultiArrayLayout.h"
-#include &lt;velodyne_compression/CompressedPacket.h&gt;
-#include &lt;cv_bridge/cv_bridge.h&gt;
-#include &lt;opencv2/highgui/highgui.hpp&gt;
-
-
-using namespace std;
-using namespace velodyne_rawdata;
-using namespace cv;
-
-typedef unsigned short uint16;
-
-int recon_frame;
-int rec=0;
-uint16* rota;
-uint16 row;
-ros::Publisher *pubp;
-uint16 column;
-
-
-namespace velodyne_driver
-{
-
-VelodyneDriver::VelodyneDriver(ros::NodeHandle node,
-                               ros::NodeHandle private_nh)
-{
-  // use private node handle to get parameters
-  private_nh.param("frame_id", config_.frame_id, std::string("velodyne"));
-  std::string tf_prefix = tf::getPrefixParam(private_nh);
-  ROS_DEBUG_STREAM("tf_prefix: " &lt;&lt; tf_prefix);
-  config_.frame_id = tf::resolve(tf_prefix, config_.frame_id);
-
-  // get model name, validate string, determine packet rate
-  if (column==2088)
-  {
-  private_nh.param("model", config_.model, std::string("64E_S2"));
-  }
-  else if (column==6*260)
-    {
-    private_nh.param("model", config_.model, std::string("64E"));
-    }
-  else if (column==12*181)
-    {
-    private_nh.param("model", config_.model, std::string("32E"));
-    }
-  else if (column==6*580)
-    {
-    private_nh.param("model", config_.model, std::string("64E_S3"));
-    }
-  else if (column==12*79)
-    {
-    private_nh.param("model", config_.model, std::string("VLP16"));
-    }
-
-
-  double packet_rate;                   // packet frequency (Hz)
-   std::string model_full_name;
-   if ((config_.model == "64E_S2") ||
-       (config_.model == "64E_S2.1"))    // generates 1333312 points per second
-     {                                   // 1 packet holds 384 points
-       packet_rate = 3472.17;            // 1333312 / 384
-       model_full_name = std::string("HDL-") + config_.model;
-     }
-   else if (config_.model == "64E_S3")
-     {
-       packet_rate = 5800.0; // experimental
-       model_full_name = std::string("HDL-") + config_.model;
-     }
-   else if (config_.model == "64E")
-     {
-       packet_rate = 2600.0;
-       model_full_name = std::string("HDL-") + config_.model;
-     }
-   else if (config_.model == "32E")
-     {
-       packet_rate = 1808.0;
-       model_full_name = std::string("HDL-") + config_.model;
-     }
-   else if (config_.model == "VLP16")
-     {
-       packet_rate = 781.25;             // 300000 / 384
-       model_full_name = "VLP-16";
-     }
-   else
-     {
-       ROS_ERROR_STREAM("unknown Velodyne LIDAR model: " &lt;&lt; config_.model);
-       packet_rate = 2600.0;
- }
-  std::string deviceName("Velodyne HDL-" + config_.model);
-
-  private_nh.param("rpm", config_.rpm, 600.0);
-  ROS_INFO_STREAM(deviceName &lt;&lt; " rotating at " &lt;&lt; config_.rpm &lt;&lt; " RPM");
-  double frequency = (config_.rpm / 60.0);     // expected Hz rate
-
-  // default number of packets for each scan is a single revolution
-  // (fractions rounded up)
-  config_.npackets = (int) ceil(packet_rate / frequency);
-  private_nh.getParam("npackets", config_.npackets);
-  ROS_INFO_STREAM("publishing " &lt;&lt; config_.npackets &lt;&lt; " packets per scan");
-
-  std::string dump_file;
-  private_nh.param("pcap", dump_file, std::string(""));
-
-  // initialize diagnostics
-  diagnostics_.setHardwareID(deviceName);
-  const double diag_freq = packet_rate/config_.npackets;
-  diag_max_freq_ = diag_freq;
-  diag_min_freq_ = diag_freq;
-  ROS_INFO("expected frequency: %.3f (Hz)", diag_freq);
-
-  using namespace diagnostic_updater;
-  diag_topic_.reset(new TopicDiagnostic("velodyne_packets", diagnostics_,
-                                        FrequencyStatusParam(&amp;diag_min_freq_,
-                                                             &amp;diag_max_freq_,
-                                                             0.1, 10),
-                                        TimeStampStatusParam()));
-
-  // open Velodyne input device or file
-  // raw data output topic
-  output_ = node.advertise&lt;velodyne_msgs::VelodyneScan&gt;("velodyne_packets", 10);
-}
-
-
-
-
-
-/** poll the device
- *
- *  @returns true unless end of file reached
- */
-bool VelodyneDriver::poll(Mat img_distance,Mat img_inten)
-{
-  uint16_t rot_angle;
-  long i, j, ID_block,ID_packet;
-  union two_bytes tmp;
-  float dis;
-  int intensity;
-  uint8_t packet[1206];
-  uint8_t head_p[6] = { 30, 30, 30, 30, 30, 30 };
-  
-  recon_frame++;
-  //cout &lt;&lt; config_.npackets;
-  // Allocate a new shared pointer for zero-copy sharing with other nodelets.
-  velodyne_msgs::VelodyneScanPtr scan(new velodyne_msgs::VelodyneScan);
-  scan-&gt;packets.resize(config_.npackets);
-
-
-	cout &lt;&lt; "Frame " &lt;&lt; recon_frame &lt;&lt; " is reconstructing"&lt;&lt;endl;
-
-
-  if (row==64)
-  {
-
-  ID_block = 0;
-  ID_packet=0;
-  for (i = 0; i &lt; column; i++)
-  {
-  rot_angle=*(rota+i);
-	tmp.uint = uint16_t(0xeeff);
-	packet[ID_block * 100] = tmp.bytes[0];
-	packet[ID_block * 100 + 1] = tmp.bytes[1];
-
-	tmp.uint = rot_angle;
-	packet[ID_block * 100 + 2] = tmp.bytes[0];
-	packet[ID_block * 100 + 3] = tmp.bytes[1];
-
-	for (j = 0; j &lt; 32; j++)
-	{
-
-  intensity=img_inten.at&lt;uchar&gt;(j,i);  
-  dis= img_distance.at&lt;ushort&gt;(j, i);
-  dis = (dis+0.5) / 100.0 / 0.002f;
-	tmp.uint = dis;
-	int loca = ID_block * 100 + 4 + j * 3;
-	packet[loca] = tmp.bytes[0];
-	packet[loca + 1] = tmp.bytes[1];
-  packet[loca + 2] = intensity;  //intensity
-	}
-
-	ID_block++;
-
-	tmp.uint = uint16_t(0xddff);
-	packet[ID_block * 100] = tmp.bytes[0];
-	packet[ID_block * 100 + 1] = tmp.bytes[1];
-
-	tmp.uint = rot_angle;
-	packet[ID_block * 100 + 2] = tmp.bytes[0];
-	packet[ID_block * 100 + 3] = tmp.bytes[1];
-
-	for (j = 32; j &lt; 64; j++)
-	{
-    dis = img_distance.at&lt;ushort&gt;(j, i);
-    intensity=img_inten.at&lt;uchar&gt;(j,i);
-		dis = (dis+0.5) / 100.0 / 0.002f;
-		tmp.uint = dis;
-		int loca = ID_block * 100 + 4 + (j-32) * 3;
-		packet[loca] = tmp.bytes[0];
-		packet[loca + 1] = tmp.bytes[1];
-    packet[loca + 2] = intensity;  //intensity
-	}
-
-	ID_block++;
-
-
-
-
-
-
-	if (ID_block == 12) 
-        { 
-        
-        memcpy(packet+1200, head_p, 6); 
-        velodyne_msgs::VelodynePacket *pkt=&amp;scan-&gt;packets[ID_packet];
-        memcpy(&amp;pkt-&gt;data[0],packet,1206);
-        pkt-&gt;stamp=ros::Time::now();
-        ID_block = 0; 
-        ID_packet++;
-        } //status	
-  }
-  }
-
-
-
-
-  if (row==32)
-  {
-    ID_block = 0;
-    ID_packet=0;
-    for (i = 0; i &lt; column; i++)
-    {
-    rot_angle=*(rota+i);
-    tmp.uint = uint16_t(0xeeff);
-    packet[ID_block * 100] = tmp.bytes[0];
-    packet[ID_block * 100 + 1] = tmp.bytes[1];
-
-    tmp.uint = rot_angle;
-    packet[ID_block * 100 + 2] = tmp.bytes[0];
-    packet[ID_block * 100 + 3] = tmp.bytes[1];
-    for (j = 0; j &lt; 32; j++)
-    {
-    dis= img_distance.at&lt;ushort&gt;(j, i);
-    intensity=img_inten.at&lt;uchar&gt;(j,i);
-    dis = (dis+0.5) / 100.0 / 0.002f;
-    tmp.uint = dis;
-    int loca = ID_block * 100 + 4 + j * 3;
-    packet[loca] = tmp.bytes[0];
-    packet[loca + 1] = tmp.bytes[1];
-    packet[loca + 2] = intensity;  //intensity
-    }
-    ID_block++;
-    if (ID_block == 12)
-          {
-
-          memcpy(packet+1200, head_p, 6);
-          velodyne_msgs::VelodynePacket *pkt=&amp;scan-&gt;packets[ID_packet];
-          memcpy(&amp;pkt-&gt;data[0],packet,1206);
-          pkt-&gt;stamp=ros::Time::now();
-          ID_block = 0;
-          ID_packet++;
-          }
-
-  }
-
-
-}
-
-  ROS_DEBUG("Publishing a full Velodyne scan.");
-  scan-&gt;header.stamp = ros::Time(scan-&gt;packets[config_.npackets - 1].stamp);
-  scan-&gt;header.frame_id = config_.frame_id;
-  pubp-&gt;publish(scan);
-
-  diag_topic_-&gt;tick(scan-&gt;header.stamp);
-  diagnostics_.update();
-  cout &lt;&lt;rec&lt;&lt;endl;
-  rec=0;
-  delete[] rota;
-  return true;
-}
-
-} // namespace velodyne_driver
-
-
-void CompressedPacketCallback(const velodyne_compression::CompressedPacket::ConstPtr&amp; CompressedData)
- {
-   row=CompressedData-&gt;scan_row;
-   column=CompressedData-&gt;scan_column;
-
-
-   rota=new uint16[column];
-   Mat img_distance(row, column, CV_16U);
-   Mat img_inten(row, column, CV_8U);
-
-    for(int i=0; i&lt;column;i++ )
-    {
-        *(rota+i)=CompressedData-&gt;rotation[i];
-    }
-
-    rec=1;
-
-
-    img_distance=cv::imdecode(CompressedData-&gt;distance, CV_LOAD_IMAGE_UNCHANGED);
-    img_inten=cv::imdecode(CompressedData-&gt;intensity, CV_LOAD_IMAGE_UNCHANGED);
-
-    ros::NodeHandle node2;
-    ros::NodeHandle private_nh("~");
-    velodyne_driver::VelodyneDriver dvr(node2, private_nh);
-    dvr.poll(img_distance,img_inten);
-
-    return;
- }
-
-
-
-int main(int argc, char** argv)
-{
-  ros::init(argc, argv, "velodyne_decompression");
-  ros::NodeHandle node;
-  ros::NodeHandle np;
-  printf("start\n");
-  recon_frame=0;
-  ros::Publisher pub=np.advertise&lt;velodyne_msgs::VelodyneScan&gt;("velodyne_packets", 10);
-  pubp=&amp;pub;
-  ros::Subscriber sub = node.subscribe("velodyne_packets_compressed", 1000, CompressedPacketCallback);
-
-  ros::spin();
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\include\velodyne_driver\input.h" new_path="" added_lines="0" deleted_lines="124">
				<diff>@@ -1,124 +0,0 @@
-/* -*- mode: C++ -*-
- *
- *  Copyright (C) 2007 Austin Robot Technology, Yaxin Liu, Patrick Beeson
- *  Copyright (C) 2009, 2010 Austin Robot Technology, Jack O'Quin
- *
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
- *
- *  Velodyne 3D LIDAR data input classes
- *
- *    These classes provide raw Velodyne LIDAR input packets from
- *    either a live socket interface or a previously-saved PCAP dump
- *    file.
- *
- *  Classes:
- *
- *     velodyne::Input -- pure virtual base class to access the data
- *                      independently of its source
- *
- *     velodyne::InputSocket -- derived class reads live data from the
- *                      device via a UDP socket
- *
- *     velodyne::InputPCAP -- derived class provides a similar interface
- *                      from a PCAP dump file
- */
-
-#ifndef __VELODYNE_INPUT_H
-#define __VELODYNE_INPUT_H
-
-#include &lt;unistd.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;pcap.h&gt;
-#include &lt;netinet/in.h&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;velodyne_msgs/VelodynePacket.h&gt;
-
-namespace velodyne_driver
-{
-  static uint16_t UDP_PORT_NUMBER = 2368;
-
-  /** @brief Pure virtual Velodyne input base class */
-  class Input
-  {
-  public:
-    Input() {}
-
-    /** @brief Read one Velodyne packet.
-     *
-     * @param pkt points to VelodynePacket message
-     *
-     * @returns 0 if successful,
-     *          -1 if end of file
-     *          &gt; 0 if incomplete packet (is this possible?)
-     */
-    virtual int getPacket(velodyne_msgs::VelodynePacket *pkt) = 0;
-
-
-    /** @brief Set source IP, from where packets are accepted
-     *
-     * @param ip IP of a Velodyne LIDAR e.g. 192.168.51.70
-     */
-    virtual void setDeviceIP( const std::string&amp; ip ) { devip_str_ = ip; }
-  protected:
-    std::string devip_str_;
-  };
-
-  /** @brief Live Velodyne input from socket. */
-  class InputSocket: public Input
-  {
-  public:
-    InputSocket(ros::NodeHandle private_nh,
-                uint16_t udp_port = UDP_PORT_NUMBER);
-    ~InputSocket();
-
-    virtual int getPacket(velodyne_msgs::VelodynePacket *pkt);
-    void setDeviceIP( const std::string&amp; ip );
-  private:
-
-    int sockfd_;
-    in_addr devip_;
-  };
-
-
-  /** @brief Velodyne input from PCAP dump file.
-   *
-   * Dump files can be grabbed by libpcap, Velodyne's DSR software,
-   * ethereal, wireshark, tcpdump, or the \ref vdump_command.
-   */
-  class InputPCAP: public Input
-  {
-  public:
-    InputPCAP(ros::NodeHandle private_nh,
-              double packet_rate,
-              std::string filename="",
-              bool read_once=false,
-              bool read_fast=false,
-              double repeat_delay=0.0);
-    ~InputPCAP();
-
-    virtual int getPacket(velodyne_msgs::VelodynePacket *pkt);
-    void setDeviceIP( const std::string&amp; ip );
-
-  private:
-
-    std::string filename_;
-    FILE *fp_;
-    pcap_t *pcap_;
-    char errbuf_[PCAP_ERRBUF_SIZE];
-    bool empty_;
-    bool read_once_;
-    bool read_fast_;
-    double repeat_delay_;
-    ros::Rate packet_rate_;
-    bpf_program velodyne_pointdata_filter_;
-  };
-
-} // velodyne_driver namespace
-
-#endif // __VELODYNE_INPUT_H
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\include\velodyne_driver\ring_sequence.h" new_path="" added_lines="0" deleted_lines="54">
				<diff>@@ -1,54 +0,0 @@
-/* -*- mode: C++ -*-
- *
- *  Copyright (C) 2010 Austin Robot Technology, Jack O'Quin
- *
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
- *
- *  Velodyne HDL-64E 3D LIDAR laser ring sequence.
- *
- *  \author Jack O'Quin
- */
-
-
-#ifndef __VELODYNE_RING_SEQUENCE_H
-#define __VELODYNE_RING_SEQUENCE_H
-
-namespace velodyne
-{
-  /// number of lasers
-  const int N_LASERS = 64;
-
-  /// ring sequence for device laser numbers
-  const int LASER_SEQUENCE[N_LASERS] =
-    {
-      6,  7, 10, 11,  0,  1,  4,  5,
-      8,  9, 14, 15, 18, 19, 22, 23,
-     12, 13, 16, 17, 20, 21, 26, 27,
-     30, 31,  2,  3, 24, 25, 28, 29,
-     38, 39, 42, 43, 32, 33, 36, 37,
-     40, 41, 46, 47, 50, 51, 54, 55,
-     44, 45, 48, 49, 52, 53, 58, 59,
-     62, 63, 34, 35, 56, 57, 60, 61
-    };
-
-  /// convert laser number to ring sequence (inverse of LASER_SEQUENCE)
-  const int LASER_RING[N_LASERS] =
-    {
-       4,  5, 26, 27,  6,  7,  0,  1,
-       8,  9,  2,  3, 16, 17, 10, 11,
-      18, 19, 12, 13, 20, 21, 14, 15,
-      28, 29, 22, 23, 30, 31, 24, 25,
-      36, 37, 58, 59, 38, 39, 32, 33,
-      40, 41, 34, 35, 48, 49, 42, 43,
-      50, 51, 44, 45, 52, 53, 46, 47,
-      60, 61, 54, 55, 62, 63, 56, 57
-    };
-
-} // velodyne namespace
-
-#endif // __VELODYNE_RING_SEQUENCE_H
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\src\driver\driver.cc" new_path="" added_lines="0" deleted_lines="162">
				<diff>@@ -1,162 +0,0 @@
-/*
- *  Copyright (C) 2007 Austin Robot Technology, Patrick Beeson
- *  Copyright (C) 2009-2012 Austin Robot Technology, Jack O'Quin
- * 
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
- *
- *  ROS driver implementation for the Velodyne 3D LIDARs
- */
-
-#include &lt;string&gt;
-#include &lt;cmath&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-#include &lt;velodyne_msgs/VelodyneScan.h&gt;
-
-#include "driver.h"
-
-namespace velodyne_driver
-{
-
-VelodyneDriver::VelodyneDriver(ros::NodeHandle node,
-                               ros::NodeHandle private_nh)
-{
-  // use private node handle to get parameters
-  private_nh.param("frame_id", config_.frame_id, std::string("velodyne"));
-  std::string tf_prefix = tf::getPrefixParam(private_nh);
-  ROS_DEBUG_STREAM("tf_prefix: " &lt;&lt; tf_prefix);
-  config_.frame_id = tf::resolve(tf_prefix, config_.frame_id);
-
-  // get model name, validate string, determine packet rate
-  private_nh.param("model", config_.model, std::string("64E"));
-  double packet_rate;                   // packet frequency (Hz)
-  std::string model_full_name;
-  if ((config_.model == "64E_S2") || 
-      (config_.model == "64E_S2.1"))    // generates 1333312 points per second
-    {                                   // 1 packet holds 384 points
-      packet_rate = 3472.17;            // 1333312 / 384
-      model_full_name = std::string("HDL-") + config_.model;
-    }
-  else if (config_.model == "64E_S3")
-    {
-      packet_rate = 5800.0; // experimental
-      model_full_name = std::string("HDL-") + config_.model;
-    }
-  else if (config_.model == "64E")
-    {
-      packet_rate = 2600.0;
-      model_full_name = std::string("HDL-") + config_.model;
-    }
-  else if (config_.model == "32E")
-    {
-      packet_rate = 1808.0;
-      model_full_name = std::string("HDL-") + config_.model;
-    }
-  else if (config_.model == "VLP16")
-    {
-      packet_rate = 781.25;             // 300000 / 384
-      model_full_name = "VLP-16";
-    }
-  else
-    {
-      ROS_ERROR_STREAM("unknown Velodyne LIDAR model: " &lt;&lt; config_.model);
-      packet_rate = 2600.0;
-    }
-  std::string deviceName(std::string("Velodyne ") + model_full_name);
-
-  private_nh.param("rpm", config_.rpm, 600.0);
-  ROS_INFO_STREAM(deviceName &lt;&lt; " rotating at " &lt;&lt; config_.rpm &lt;&lt; " RPM");
-  double frequency = (config_.rpm / 60.0);     // expected Hz rate
-
-  // default number of packets for each scan is a single revolution
-  // (fractions rounded up)
-  config_.npackets = (int) ceil(packet_rate / frequency);
-  private_nh.getParam("npackets", config_.npackets);
-  ROS_INFO_STREAM("publishing " &lt;&lt; config_.npackets &lt;&lt; " packets per scan");
-
-  std::string dump_file;
-  private_nh.param("pcap", dump_file, std::string(""));
-
-  int udp_port;
-  private_nh.param("port", udp_port, (int)UDP_PORT_NUMBER);
-
-  // initialize diagnostics
-  diagnostics_.setHardwareID(deviceName);
-  const double diag_freq = packet_rate/config_.npackets;
-  diag_max_freq_ = diag_freq;
-  diag_min_freq_ = diag_freq;
-  ROS_INFO("expected frequency: %.3f (Hz)", diag_freq);
-
-  using namespace diagnostic_updater;
-  diag_topic_.reset(new TopicDiagnostic("velodyne_packets", diagnostics_,
-                                        FrequencyStatusParam(&amp;diag_min_freq_,
-                                                             &amp;diag_max_freq_,
-                                                             0.1, 10),
-                                        TimeStampStatusParam()));
-
-  // open Velodyne input device or file
-  if (dump_file != "")
-    {
-      input_.reset(new velodyne_driver::InputPCAP(private_nh,
-                                                  packet_rate,
-                                                  dump_file));
-    }
-  else
-    {
-      input_.reset(new velodyne_driver::InputSocket(private_nh, udp_port));
-    }
-
-  std::string devip;
-  private_nh.param("device_ip", devip, std::string(""));
-  if(!devip.empty())
-    ROS_INFO_STREAM("Set device ip to " &lt;&lt; devip &lt;&lt; ", only accepting packets from this address." );
-  input_-&gt;setDeviceIP(devip);
-
-  // raw data output topic
-  output_ = node.advertise&lt;velodyne_msgs::VelodyneScan&gt;("velodyne_packets", 10);
-}
-
-/** poll the device
- *
- *  @returns true unless end of file reached
- */
-bool VelodyneDriver::poll(void)
-{
-  // Allocate a new shared pointer for zero-copy sharing with other nodelets.
-  velodyne_msgs::VelodyneScanPtr scan(new velodyne_msgs::VelodyneScan);
-  scan-&gt;packets.resize(config_.npackets);
-
-  // Since the velodyne delivers data at a very high rate, keep
-  // reading and publishing scans as fast as possible.
-  for (int i = 0; i &lt; config_.npackets; ++i)
-    {
-      while (true)
-        {
-          // keep reading until full packet received
-          int rc = input_-&gt;getPacket(&amp;scan-&gt;packets[i]);
-          if (rc == 0) break;       // got a full packet?
-          if (rc &lt; 0) return false; // end of file reached?
-        }
-    }
-
-  // publish message using time of last packet read
-  ROS_DEBUG("Publishing a full Velodyne scan.");
-  scan-&gt;header.stamp = ros::Time(scan-&gt;packets[config_.npackets - 1].stamp);
-  scan-&gt;header.frame_id = config_.frame_id;
-  output_.publish(scan);
-
-  // notify diagnostics that a message has been published, updating
-  // its status
-  diag_topic_-&gt;tick(scan-&gt;header.stamp);
-  diagnostics_.update();
-
-  return true;
-}
-
-} // namespace velodyne_driver
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\src\driver\driver.h" new_path="" added_lines="0" deleted_lines="61">
				<diff>@@ -1,61 +0,0 @@
-/* -*- mode: C++ -*- */
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- * 
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
- *
- *  ROS driver interface for the Velodyne 3D LIDARs
- */
-
-#ifndef _VELODYNE_DRIVER_H_
-#define _VELODYNE_DRIVER_H_ 1
-
-#include &lt;string&gt;
-#include &lt;ros/ros.h&gt;
-#include &lt;diagnostic_updater/diagnostic_updater.h&gt;
-#include &lt;diagnostic_updater/publisher.h&gt;
-
-#include &lt;velodyne_driver/input.h&gt;
-
-namespace velodyne_driver
-{
-
-class VelodyneDriver
-{
-public:
-
-  VelodyneDriver(ros::NodeHandle node,
-                 ros::NodeHandle private_nh);
-  ~VelodyneDriver() {}
-
-  bool poll(void);
-
-private:
-
-  // configuration parameters
-  struct
-  {
-    std::string frame_id;            ///&lt; tf frame ID
-    std::string model;               ///&lt; device model name
-    int    npackets;                 ///&lt; number of packets to collect
-    double rpm;                      ///&lt; device rotation rate (RPMs)
-  } config_;
-
-  boost::shared_ptr&lt;Input&gt; input_;
-  ros::Publisher output_;
-
-  /** diagnostics updater */
-  diagnostic_updater::Updater diagnostics_;
-  double diag_min_freq_;
-  double diag_max_freq_;
-  boost::shared_ptr&lt;diagnostic_updater::TopicDiagnostic&gt; diag_topic_;
-};
-
-} // namespace velodyne_driver
-
-#endif // _VELODYNE_DRIVER_H_
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\src\driver\nodelet.cc" new_path="" added_lines="0" deleted_lines="86">
				<diff>@@ -1,86 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- * 
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
- *
- *  ROS driver nodelet for the Velodyne 3D LIDARs
- */
-
-#include &lt;string&gt;
-#include &lt;boost/thread.hpp&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;pluginlib/class_list_macros.h&gt;
-#include &lt;nodelet/nodelet.h&gt;
-
-#include "driver.h"
-
-namespace velodyne_driver
-{
-
-class DriverNodelet: public nodelet::Nodelet
-{
-public:
-
-  DriverNodelet():
-    running_(false)
-  {}
-
-  ~DriverNodelet()
-  {
-    if (running_)
-      {
-        NODELET_INFO("shutting down driver thread");
-        running_ = false;
-        deviceThread_-&gt;join();
-        NODELET_INFO("driver thread stopped");
-      }
-  }
-
-private:
-
-  virtual void onInit(void);
-  virtual void devicePoll(void);
-
-  volatile bool running_;               ///&lt; device thread is running
-  boost::shared_ptr&lt;boost::thread&gt; deviceThread_;
-
-  boost::shared_ptr&lt;VelodyneDriver&gt; dvr_; ///&lt; driver implementation class
-};
-
-void DriverNodelet::onInit()
-{
-  // start the driver
-  dvr_.reset(new VelodyneDriver(getNodeHandle(), getPrivateNodeHandle()));
-
-  // spawn device poll thread
-  running_ = true;
-  deviceThread_ = boost::shared_ptr&lt; boost::thread &gt;
-    (new boost::thread(boost::bind(&amp;DriverNodelet::devicePoll, this)));
-}
-
-/** @brief Device poll thread main loop. */
-void DriverNodelet::devicePoll()
-{
-  while(ros::ok())
-    {
-      // poll device until end of file
-      running_ = dvr_-&gt;poll();
-      if (!running_)
-        break;
-    }
-  running_ = false;
-}
-
-} // namespace velodyne_driver
-
-// Register this plugin with pluginlib.  Names must match nodelet_velodyne.xml.
-//
-// parameters are: package, class name, class type, base class type
-PLUGINLIB_DECLARE_CLASS(velodyne_driver, DriverNodelet,
-                        velodyne_driver::DriverNodelet, nodelet::Nodelet);
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\src\driver\velodyne_node.cc" new_path="" added_lines="0" deleted_lines="33">
				<diff>@@ -1,33 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- * 
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
- *
- *  ROS driver node for the Velodyne 3D LIDARs.
- */
-
-#include &lt;ros/ros.h&gt;
-#include "driver.h"
-
-int main(int argc, char** argv)
-{
-  ros::init(argc, argv, "velodyne_node");
-  ros::NodeHandle node;
-  ros::NodeHandle private_nh("~");
-
-  // start the driver
-  velodyne_driver::VelodyneDriver dvr(node, private_nh);
-
-  // loop until shut down or end of file
-  while(ros::ok() &amp;&amp; dvr.poll())
-    {
-      ros::spinOnce();
-    }
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\src\lib\input.cc" new_path="" added_lines="0" deleted_lines="306">
				<diff>@@ -1,306 +0,0 @@
-/*
- *  Copyright (C) 2007 Austin Robot Technology, Patrick Beeson
- *  Copyright (C) 2009, 2010 Austin Robot Technology, Jack O'Quin
- *
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
- *
- *  Input classes for the Velodyne HDL-64E 3D LIDAR:
- *
- *     Input -- virtual base class than can be used to access the data
- *              independently of its source
- *
- *     InputSocket -- derived class reads live data from the device
- *              via a UDP socket
- *
- *     InputPCAP -- derived class provides a similar interface from a
- *              PCAP dump
- */
-
-#include &lt;unistd.h&gt;
-#include &lt;sys/socket.h&gt;
-#include &lt;arpa/inet.h&gt;
-#include &lt;poll.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;sys/file.h&gt;
-#include &lt;velodyne_driver/input.h&gt;
-
-namespace velodyne_driver
-{
-  static const size_t packet_size = sizeof(velodyne_msgs::VelodynePacket().data);
-
-  ////////////////////////////////////////////////////////////////////////
-  // InputSocket class implementation
-  ////////////////////////////////////////////////////////////////////////
-
-  /** @brief constructor
-   *
-   *  @param private_nh private node handle for driver
-   *  @param udp_port UDP port number to connect
-   */
-  InputSocket::InputSocket(ros::NodeHandle private_nh, uint16_t udp_port):
-    Input()
-  {
-    sockfd_ = -1;
-
-    // connect to Velodyne UDP port
-    ROS_INFO_STREAM("Opening UDP socket: port " &lt;&lt; udp_port);
-    sockfd_ = socket(PF_INET, SOCK_DGRAM, 0);
-    if (sockfd_ == -1)
-      {
-        perror("socket");               // TODO: ROS_ERROR errno
-        return;
-      }
-  
-    sockaddr_in my_addr;                     // my address information
-    memset(&amp;my_addr, 0, sizeof(my_addr));    // initialize to zeros
-    my_addr.sin_family = AF_INET;            // host byte order
-    my_addr.sin_port = htons(udp_port);      // short, in network byte order
-    my_addr.sin_addr.s_addr = INADDR_ANY;    // automatically fill in my IP
-  
-    if (bind(sockfd_, (sockaddr *)&amp;my_addr, sizeof(sockaddr)) == -1)
-      {
-        perror("bind");                 // TODO: ROS_ERROR errno
-        return;
-      }
-  
-    if (fcntl(sockfd_,F_SETFL, O_NONBLOCK|FASYNC) &lt; 0)
-      {
-        perror("non-block");
-        return;
-      }
-
-    ROS_DEBUG("Velodyne socket fd is %d\n", sockfd_);
-  }
-
-  /** @brief destructor */
-  InputSocket::~InputSocket(void)
-  {
-    (void) close(sockfd_);
-  }
-
-  void InputSocket::setDeviceIP(const std::string &amp;ip)
-  {
-    devip_str_ = ip;
-    inet_aton(ip.c_str(),&amp;devip_);
-  }
-
-  /** @brief Get one velodyne packet. */
-  int InputSocket::getPacket(velodyne_msgs::VelodynePacket *pkt)
-  {
-    double time1 = ros::Time::now().toSec();
-
-    struct pollfd fds[1];
-    fds[0].fd = sockfd_;
-    fds[0].events = POLLIN;
-    static const int POLL_TIMEOUT = 1000; // one second (in msec)
-
-    sockaddr_in sender_address;
-    socklen_t sender_address_len = sizeof(sender_address);
-
-    while (true)
-      {
-        // Unfortunately, the Linux kernel recvfrom() implementation
-        // uses a non-interruptible sleep() when waiting for data,
-        // which would cause this method to hang if the device is not
-        // providing data.  We poll() the device first to make sure
-        // the recvfrom() will not block.
-        //
-        // Note, however, that there is a known Linux kernel bug:
-        //
-        //   Under Linux, select() may report a socket file descriptor
-        //   as "ready for reading", while nevertheless a subsequent
-        //   read blocks.  This could for example happen when data has
-        //   arrived but upon examination has wrong checksum and is
-        //   discarded.  There may be other circumstances in which a
-        //   file descriptor is spuriously reported as ready.  Thus it
-        //   may be safer to use O_NONBLOCK on sockets that should not
-        //   block.
-
-        // poll() until input available
-        do
-          {
-            int retval = poll(fds, 1, POLL_TIMEOUT);
-            if (retval &lt; 0)             // poll() error?
-              {
-                if (errno != EINTR)
-                  ROS_ERROR("poll() error: %s", strerror(errno));
-                return 1;
-              }
-            if (retval == 0)            // poll() timeout?
-              {
-                ROS_WARN("Velodyne poll() timeout");
-                return 1;
-              }
-            if ((fds[0].revents &amp; POLLERR)
-                || (fds[0].revents &amp; POLLHUP)
-                || (fds[0].revents &amp; POLLNVAL)) // device error?
-              {
-                ROS_ERROR("poll() reports Velodyne error");
-                return 1;
-              }
-          } while ((fds[0].revents &amp; POLLIN) == 0);
-
-        // Receive packets that should now be available from the
-        // socket using a blocking read.
-        ssize_t nbytes = recvfrom(sockfd_, &amp;pkt-&gt;data[0],
-                                  packet_size,  0,
-                                  (sockaddr*) &amp;sender_address, &amp;sender_address_len);
-
-        if (nbytes &lt; 0)
-          {
-            if (errno != EWOULDBLOCK)
-              {
-                perror("recvfail");
-                ROS_INFO("recvfail");
-                return 1;
-              }
-          }
-        else if ((size_t) nbytes == packet_size)
-          {
-            // read successful,
-            // if packet is not from the lidar scanner we selected by IP,
-            // continue otherwise we are done
-            if( devip_str_ != "" &amp;&amp; sender_address.sin_addr.s_addr != devip_.s_addr )
-              continue;
-            else
-              break; //done
-          }
-
-        ROS_DEBUG_STREAM("incomplete Velodyne packet read: "
-                         &lt;&lt; nbytes &lt;&lt; " bytes");
-      }
-
-    // Average the times at which we begin and end reading.  Use that to
-    // estimate when the scan occurred.
-    double time2 = ros::Time::now().toSec();
-    pkt-&gt;stamp = ros::Time((time2 + time1) / 2.0);
-
-    return 0;
-  }
-
-  ////////////////////////////////////////////////////////////////////////
-  // InputPCAP class implementation
-  ////////////////////////////////////////////////////////////////////////
-
-  /** @brief constructor
-   *
-   *  @param private_nh private node handle for driver
-   *  @param packet_rate expected device packet frequency (Hz)
-   *  @param filename PCAP dump file name
-   *  @param read_once read PCAP in a loop, unless false
-   *  @param read_fast read PCAP at device rate, unless false
-   *  @param repeat_delay time to wait before repeating PCAP data
-   */
-  InputPCAP::InputPCAP(ros::NodeHandle private_nh,
-                       double packet_rate,
-                       std::string filename,
-                       bool read_once,
-                       bool read_fast,
-                       double repeat_delay):
-    Input(),
-    packet_rate_(packet_rate)
-  {
-    filename_ = filename;
-    fp_ = NULL;  
-    pcap_ = NULL;  
-    empty_ = true;
-
-    // get parameters using private node handle
-    private_nh.param("read_once", read_once_, read_once);
-    private_nh.param("read_fast", read_fast_, read_fast);
-    private_nh.param("repeat_delay", repeat_delay_, repeat_delay);
-
-    if (read_once_)
-      ROS_INFO("Read input file only once.");
-    if (read_fast_)
-      ROS_INFO("Read input file as quickly as possible.");
-    if (repeat_delay_ &gt; 0.0)
-      ROS_INFO("Delay %.3f seconds before repeating input file.",
-               repeat_delay_);
-
-    // Open the PCAP dump file
-    ROS_INFO("Opening PCAP file \"%s\"", filename_.c_str());
-    if ((pcap_ = pcap_open_offline(filename_.c_str(), errbuf_) ) == NULL)
-      {
-        ROS_FATAL("Error opening Velodyne socket dump file.");
-        return;
-      }
-  }
-
-
-  /** destructor */
-  InputPCAP::~InputPCAP(void)
-  {
-    pcap_close(pcap_);
-  }
-
-  void InputPCAP::setDeviceIP(const std::string &amp;ip)
-  {
-      std::string filter_str = "src host " + devip_str_ + " &amp;&amp; udp src port 2368 &amp;&amp; udp dst port 2368";
-      if( devip_str_ != "" )
-        pcap_compile(pcap_, &amp;velodyne_pointdata_filter_, filter_str.c_str(), 1, PCAP_NETMASK_UNKNOWN);
-  }
-
-  /** @brief Get one velodyne packet. */
-  int InputPCAP::getPacket(velodyne_msgs::VelodynePacket *pkt)
-  {
-    struct pcap_pkthdr *header;
-    const u_char *pkt_data;
-
-    while (true)
-      {
-        int res;
-        if ((res = pcap_next_ex(pcap_, &amp;header, &amp;pkt_data)) &gt;= 0)
-          {
-            // if packet is not from the lidar scanner we selected by IP, continue
-            if( !devip_str_.empty() &amp;&amp; (pcap_offline_filter( &amp;velodyne_pointdata_filter_, header, pkt_data ) == 0) )
-              continue;
-
-            // Keep the reader from blowing through the file.
-            if (read_fast_ == false)
-              packet_rate_.sleep();
-            
-            memcpy(&amp;pkt-&gt;data[0], pkt_data+42, packet_size);
-            pkt-&gt;stamp = ros::Time::now();
-            empty_ = false;
-            return 0;                   // success
-          }
-
-        if (empty_)                 // no data in file?
-          {
-            ROS_WARN("Error %d reading Velodyne packet: %s", 
-                     res, pcap_geterr(pcap_));
-            return -1;
-          }
-
-        if (read_once_)
-          {
-            ROS_INFO("end of file reached -- done reading.");
-            return -1;
-          }
-        
-        if (repeat_delay_ &gt; 0.0)
-          {
-            ROS_INFO("end of file reached -- delaying %.3f seconds.",
-                     repeat_delay_);
-            usleep(rint(repeat_delay_ * 1000000.0));
-          }
-
-        ROS_DEBUG("replaying Velodyne dump file");
-
-        // I can't figure out how to rewind the file, because it
-        // starts with some kind of header.  So, close the file
-        // and reopen it with pcap.
-        pcap_close(pcap_);
-        pcap_ = pcap_open_offline(filename_.c_str(), errbuf_);
-        empty_ = true;              // maybe the file disappeared?
-      } // loop back and try again
-  }
-
-} // velodyne namespace
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\cfg\VelodyneConfig.cfg" new_path="" added_lines="0" deleted_lines="16">
				<diff>@@ -1,16 +0,0 @@
-#!/usr/bin/env python
-PACKAGE = "velodyne_pointcloud"
-
-from math import pi
-from dynamic_reconfigure.parameter_generator_catkin import *
-
-gen = ParameterGenerator()
-
-gen.add("min_range", double_t, 0, "min range to publish", 0.9, 0.1, 10.0)
-gen.add("max_range", double_t, 0, "max range to publish", 130, 0.1, 200)
-gen.add("view_direction", double_t, 0, "angle defining the center of view",
-        0.0, -pi, pi)
-gen.add("view_width", double_t, 0, "angle defining the view width",
-        2*pi, 0.0, 2*pi)
-
-exit(gen.generate(PACKAGE, "velodyne_pointcloud", "VelodyneConfig"))
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\include\velodyne_pointcloud\calibration.h" new_path="" added_lines="0" deleted_lines="76">
				<diff>@@ -1,76 +0,0 @@
-/**
- * \file  calibration.h 
- *
- * \author  Piyush Khandelwal (piyushk@cs.utexas.edu)
- * Copyright (C) 2012, Austin Robot Technology, University of Texas at Austin
- *
- * License: Modified BSD License
- *
- * $ Id: 02/14/2012 11:25:34 AM piyushk $
- */
-
-#ifndef __VELODYNE_CALIBRATION_H
-#define __VELODYNE_CALIBRATION_H
-
-#include &lt;map&gt;
-#include &lt;string&gt;
-
-namespace velodyne_pointcloud {
-
-  /** \brief correction values for a single laser
-   *
-   * Correction values for a single laser (as provided by db.xml from veleodyne)
-   * Includes parameters for Velodyne HDL-64E S2.1 calibration.
-   * http://velodynelidar.com/lidar/products/manual/63-HDL64E%20S2%20Manual_Rev%20D_2011_web.pdf
-   **/
-  struct LaserCorrection {
-
-    /** parameters in db.xml */
-    float rot_correction;
-    float vert_correction;
-    float dist_correction;
-    bool two_pt_correction_available;
-    float dist_correction_x;
-    float dist_correction_y;
-    float vert_offset_correction;
-    float horiz_offset_correction;
-    int max_intensity;
-    int min_intensity;
-    float focal_distance;
-    float focal_slope;
-
-    /** cached values calculated when the calibration file is read */
-    float cos_rot_correction;              ///&lt; cached cosine of rot_correction
-    float sin_rot_correction;              ///&lt; cached sine of rot_correction
-    float cos_vert_correction;             ///&lt; cached cosine of vert_correction
-    float sin_vert_correction;             ///&lt; cached sine of vert_correction
-
-    int laser_ring;                        ///&lt; ring number for this laser
-  };
-
-  /** \brief Calibration class storing entire configuration for the Velodyne */
-  class Calibration {
-
-  public:
-
-    std::map&lt;int, LaserCorrection&gt; laser_corrections;
-    int num_lasers;
-    bool initialized;
-
-  public:
-
-    Calibration() : initialized(false) {}
-    Calibration(const std::string&amp; calibration_file) {
-      read(calibration_file);
-    }
-
-    void read(const std::string&amp; calibration_file);
-    void write(const std::string&amp; calibration_file);
-  };
-  
-} /* velodyne_pointcloud */
-
-
-#endif /* end of include guard: __VELODYNE_CALIBRATION_H */
-
-
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\include\velodyne_pointcloud\point_types.h" new_path="" added_lines="0" deleted_lines="46">
				<diff>@@ -1,46 +0,0 @@
-/* -*- mode: C++ -*-
- *
- *  Copyright (C) 2011, 2012 Austin Robot Technology
- *
- *  License: Modified BSD Software License Agreement
- *
- *  $Id: data_base.h 1554 2011-06-14 22:11:17Z jack.oquin $
- */
-
-/** \file
- *
- *  Point Cloud Library point structures for Velodyne data.
- *
- *  @author Jesse Vera
- *  @author Jack O'Quin
- *  @author Piyush Khandelwal
- */
-
-#ifndef __VELODYNE_POINTCLOUD_POINT_TYPES_H
-#define __VELODYNE_POINTCLOUD_POINT_TYPES_H
-
-#include &lt;pcl/point_types.h&gt;
-
-namespace velodyne_pointcloud
-{
-  /** Euclidean Velodyne coordinate, including intensity and ring number. */
-  struct PointXYZIR
-  {
-    PCL_ADD_POINT4D;                    // quad-word XYZ
-    float    intensity;                 ///&lt; laser intensity reading
-    uint16_t ring;                      ///&lt; laser ring number
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW     // ensure proper alignment
-  } EIGEN_ALIGN16;
-
-}; // namespace velodyne_pointcloud
-
-
-POINT_CLOUD_REGISTER_POINT_STRUCT(velodyne_pointcloud::PointXYZIR,
-                                  (float, x, x)
-                                  (float, y, y)
-                                  (float, z, z)
-                                  (float, intensity, intensity)
-                                  (uint16_t, ring, ring))
-
-#endif // __VELODYNE_POINTCLOUD_POINT_TYPES_H
-
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\include\velodyne_pointcloud\rawdata.h" new_path="" added_lines="0" deleted_lines="180">
				<diff>@@ -1,180 +0,0 @@
-/* -*- mode: C++ -*-
- *
- *  Copyright (C) 2007 Austin Robot Technology, Yaxin Liu, Patrick Beeson
- *  Copyright (C) 2009, 2010, 2012 Austin Robot Technology, Jack O'Quin
- *
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
- *
- *  @brief Interfaces for interpreting raw packets from the Velodyne 3D LIDAR.
- *
- *  @author Yaxin Liu
- *  @author Patrick Beeson
- *  @author Jack O'Quin
- */
-
-#ifndef __VELODYNE_RAWDATA_H
-#define __VELODYNE_RAWDATA_H
-
-#include &lt;errno.h&gt;
-#include &lt;stdint.h&gt;
-#include &lt;string&gt;
-#include &lt;boost/format.hpp&gt;
-#include &lt;math.h&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;pcl_ros/point_cloud.h&gt;
-#include &lt;velodyne_msgs/VelodyneScan.h&gt;
-#include &lt;velodyne_pointcloud/point_types.h&gt;
-#include &lt;velodyne_pointcloud/calibration.h&gt;
-
-namespace velodyne_rawdata
-{
-  // Shorthand typedefs for point cloud representations
-  typedef velodyne_pointcloud::PointXYZIR VPoint;
-  typedef pcl::PointCloud&lt;VPoint&gt; VPointCloud;
-
-  /**
-   * Raw Velodyne packet constants and structures.
-   */
-  static const int SIZE_BLOCK = 100;
-  static const int RAW_SCAN_SIZE = 3;
-  static const int SCANS_PER_BLOCK = 32;
-  static const int BLOCK_DATA_SIZE = (SCANS_PER_BLOCK * RAW_SCAN_SIZE);
-
-  static const float ROTATION_RESOLUTION = 0.01f; /**&lt; degrees */
-  static const uint16_t ROTATION_MAX_UNITS = 36000; /**&lt; hundredths of degrees */
-
-  /** According to Bruce Hall DISTANCE_MAX is 65.0, but we noticed
-   *  valid packets with readings up to 130.0. */
-  static const float DISTANCE_MAX = 130.0f;        /**&lt; meters */
-  static const float DISTANCE_RESOLUTION = 0.002f; /**&lt; meters */
-  static const float DISTANCE_MAX_UNITS = (DISTANCE_MAX
-                                           / DISTANCE_RESOLUTION + 1.0);
-  static const uint16_t UPPER_BANK = 0xeeff;
-  static const uint16_t LOWER_BANK = 0xddff;
-  
-  
-  /** Special Defines for VLP16 support **/
-  static const int VLP16_FIRINGS_PER_BLOCK = 2;
-  static const int VLP16_SCANS_PER_FIRING = 16;
-  static const int VLP16_BLOCK_TDURATION = 110.592;
-  static const int VLP16_DSR_TOFFSET = 2.304;
-  static const int VLP16_FIRING_TOFFSET = 55.296;
-  
-
-  /** \brief Raw Velodyne data block.
-   *
-   *  Each block contains data from either the upper or lower laser
-   *  bank.  The device returns three times as many upper bank blocks.
-   *
-   *  use stdint.h types, so things work with both 64 and 32-bit machines
-   */
-  typedef struct raw_block
-  {
-    uint16_t header;        ///&lt; UPPER_BANK or LOWER_BANK
-    uint16_t rotation;      ///&lt; 0-35999, divide by 100 to get degrees
-    uint8_t  data[BLOCK_DATA_SIZE];
-  } raw_block_t;
-
-  /** used for unpacking the first two data bytes in a block
-   *
-   *  They are packed into the actual data stream misaligned.  I doubt
-   *  this works on big endian machines.
-   */
-  union two_bytes
-  {
-    uint16_t uint;
-    uint8_t  bytes[2];
-  };
-
-  static const int PACKET_SIZE = 1206;
-  static const int BLOCKS_PER_PACKET = 12;
-  static const int PACKET_STATUS_SIZE = 4;
-  static const int SCANS_PER_PACKET = (SCANS_PER_BLOCK * BLOCKS_PER_PACKET);
-
-  /** \brief Raw Velodyne packet.
-   *
-   *  revolution is described in the device manual as incrementing
-   *    (mod 65536) for each physical turn of the device.  Our device
-   *    seems to alternate between two different values every third
-   *    packet.  One value increases, the other decreases.
-   *
-   *  \todo figure out if revolution is only present for one of the
-   *  two types of status fields
-   *
-   *  status has either a temperature encoding or the microcode level
-   */
-  typedef struct raw_packet
-  {
-    raw_block_t blocks[BLOCKS_PER_PACKET];
-    uint16_t revolution;
-    uint8_t status[PACKET_STATUS_SIZE]; 
-  } raw_packet_t;
-
-  /** \brief Velodyne data conversion class */
-  class RawData
-  {
-  public:
-
-    RawData();
-    ~RawData() {}
-
-    /** \brief Set up for data processing.
-     *
-     *  Perform initializations needed before data processing can
-     *  begin:
-     *
-     *    - read device-specific angles calibration
-     *
-     *  @param private_nh private node handle for ROS parameters
-     *  @returns 0 if successful;
-     *           errno value for failure
-     */
-    int setup(ros::NodeHandle private_nh);
-
-    void unpack(const velodyne_msgs::VelodynePacket &amp;pkt, VPointCloud &amp;pc);
-    
-    void setParameters(double min_range, double max_range, double view_direction,
-                       double view_width);
-
-  private:
-
-    /** configuration parameters */
-    typedef struct {
-      std::string calibrationFile;     ///&lt; calibration file name
-      double max_range;                ///&lt; maximum range to publish
-      double min_range;                ///&lt; minimum range to publish
-      int min_angle;                   ///&lt; minimum angle to publish
-      int max_angle;                   ///&lt; maximum angle to publish
-      
-      double tmp_min_angle;
-      double tmp_max_angle;
-    } Config;
-    Config config_;
-
-    /** 
-     * Calibration file
-     */
-    velodyne_pointcloud::Calibration calibration_;
-    float sin_rot_table_[ROTATION_MAX_UNITS];
-    float cos_rot_table_[ROTATION_MAX_UNITS];
-    
-    /** add private function to handle the VLP16 **/ 
-    void unpack_vlp16(const velodyne_msgs::VelodynePacket &amp;pkt, VPointCloud &amp;pc);
-
-    /** in-line test whether a point is in range */
-    bool pointInRange(float range)
-    {
-      return (range &gt;= config_.min_range
-              &amp;&amp; range &lt;= config_.max_range);
-    }
-  };
-
-} // namespace velodyne_rawdata
-
-#endif // __VELODYNE_RAWDATA_H
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\cloud_node.cc" new_path="" added_lines="0" deleted_lines="31">
				<diff>@@ -1,31 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
-
-    This ROS node converts raw Velodyne LIDAR packets to PointCloud2.
-
-*/
-
-#include &lt;ros/ros.h&gt;
-#include "convert.h"
-
-/** Main node entry point. */
-int main(int argc, char **argv)
-{
-  ros::init(argc, argv, "cloud_node");
-  ros::NodeHandle node;
-  ros::NodeHandle priv_nh("~");
-
-  // create conversion class, which subscribes to raw data
-  velodyne_pointcloud::Convert conv(node, priv_nh);
-
-  // handle callbacks until shut down
-  ros::spin();
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\cloud_nodelet.cc" new_path="" added_lines="0" deleted_lines="49">
				<diff>@@ -1,49 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This ROS nodelet converts raw Velodyne 3D LIDAR packets to a
-    PointCloud2.
-
-*/
-
-#include &lt;ros/ros.h&gt;
-#include &lt;pluginlib/class_list_macros.h&gt;
-#include &lt;nodelet/nodelet.h&gt;
-
-#include "convert.h"
-
-namespace velodyne_pointcloud
-{
-  class CloudNodelet: public nodelet::Nodelet
-  {
-  public:
-
-    CloudNodelet() {}
-    ~CloudNodelet() {}
-
-  private:
-
-    virtual void onInit();
-    boost::shared_ptr&lt;Convert&gt; conv_;
-  };
-
-  /** @brief Nodelet initialization. */
-  void CloudNodelet::onInit()
-  {
-    conv_.reset(new Convert(getNodeHandle(), getPrivateNodeHandle()));
-  }
-
-} // namespace velodyne_pointcloud
-
-
-// Register this plugin with pluginlib.  Names must match nodelet_velodyne.xml.
-//
-// parameters: package, class name, class type, base class type
-PLUGINLIB_DECLARE_CLASS(velodyne_pointcloud, CloudNodelet,
-                        velodyne_pointcloud::CloudNodelet, nodelet::Nodelet);
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\colors.cc" new_path="" added_lines="0" deleted_lines="93">
				<diff>@@ -1,93 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    Implementation for converting a Velodyne 3D LIDAR PointXYZIR cloud
-    to PointXYZRGB, assigning colors for visualization of the laser
-    rings.
-
-    @author Jack O'Quin
-*/
-
-#include "colors.h"
-#include &lt;velodyne_pointcloud/point_types.h&gt;
-
-/// @todo make sure these includes are really necessary
-#include &lt;pcl/io/pcd_io.h&gt;
-#include &lt;pcl/point_cloud.h&gt;
-
-namespace
-{
-  // RGB color values
-  const int color_red =       0xff0000;
-  const int color_orange =    0xff8800;
-  const int color_yellow =    0xffff00;
-  const int color_green =     0x00ff00;
-  const int color_blue =      0x0000ff;
-  const int color_violet =    0xff00ff;
-
-  const int N_COLORS = 6;
-  int rainbow[N_COLORS] = {color_red, color_orange, color_yellow,
-                           color_green, color_blue, color_violet};
-}
-
-namespace velodyne_pointcloud
-{
-
-  /** types of output point and cloud */
-  typedef pcl::PointXYZRGB RGBPoint;
-  typedef pcl::PointCloud&lt;RGBPoint&gt; RGBPointCloud;
-
-  /** @brief Constructor. */
-  RingColors::RingColors(ros::NodeHandle node, ros::NodeHandle private_nh)
-  {
-    // advertise output point cloud (before subscribing to input data)
-    output_ =
-      node.advertise&lt;sensor_msgs::PointCloud2&gt;("velodyne_rings", 10);
-
-    // subscribe to VelodyneScan packets
-    input_ =
-      node.subscribe("velodyne_points", 10,
-                     &amp;RingColors::convertPoints, this,
-                     ros::TransportHints().tcpNoDelay(true));
-  }
-
-
-  /** @brief Callback for Velodyne PointXYZRI messages. */
-  void
-    RingColors::convertPoints(const VPointCloud::ConstPtr &amp;inMsg)
-  {
-    if (output_.getNumSubscribers() == 0)         // no one listening?
-      return;                                     // do nothing
-
-    // allocate an PointXYZRGB message with same time and frame ID as
-    // input data
-    RGBPointCloud::Ptr outMsg(new RGBPointCloud());
-    outMsg-&gt;header.stamp = inMsg-&gt;header.stamp;
-    outMsg-&gt;header.frame_id = inMsg-&gt;header.frame_id;
-    outMsg-&gt;height = 1;
-
-    for (size_t i = 0; i &lt; inMsg-&gt;points.size(); ++i)
-      {
-        RGBPoint p;
-        p.x = inMsg-&gt;points[i].x;
-        p.y = inMsg-&gt;points[i].y;
-        p.z = inMsg-&gt;points[i].z;
-
-        // color lasers with the rainbow array
-        int color = inMsg-&gt;points[i].ring % N_COLORS;
-        p.rgb = *reinterpret_cast&lt;float*&gt;(&amp;rainbow[color]);
-
-        outMsg-&gt;points.push_back(p);
-        ++outMsg-&gt;width;
-      }
-
-    output_.publish(outMsg);
-  }
-
-} // namespace velodyne_pcl
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\colors.h" new_path="" added_lines="0" deleted_lines="49">
				<diff>@@ -1,49 +0,0 @@
-/* -*- mode: C++ -*- */
-/*
- *  Copyright (C) 2012 Austin Robot Technology
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    Interface for converting a Velodyne 3D LIDAR PointXYZIR cloud to
-    PointXYZRGB, assigning colors for visualization of the laser
-    rings.
-
-    @author Jack O'Quin
-*/
-
-#ifndef _VELODYNE_POINTCLOUD_COLORS_H_
-#define _VELODYNE_POINTCLOUD_COLORS_H_
-
-#include &lt;ros/ros.h&gt;
-#include &lt;pcl_ros/point_cloud.h&gt;
-#include &lt;pcl/point_types.h&gt;
-#include &lt;velodyne_pointcloud/point_types.h&gt;
-
-namespace velodyne_pointcloud
-{
-  // shorter names for point cloud types in this namespace
-  typedef velodyne_pointcloud::PointXYZIR VPoint;
-  typedef pcl::PointCloud&lt;VPoint&gt; VPointCloud;
-
-  class RingColors
-  {
-  public:
-
-    RingColors(ros::NodeHandle node, ros::NodeHandle private_nh);
-    ~RingColors() {}
-
-  private:
-
-    void convertPoints(const VPointCloud::ConstPtr &amp;inMsg);
-
-    ros::Subscriber input_;
-    ros::Publisher output_;
-  };
-
-} // namespace velodyne_pointcloud
-
-#endif // _VELODYNE_POINTCLOUD_COLORS_H_
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\convert.cc" new_path="" added_lines="0" deleted_lines="81">
				<diff>@@ -1,81 +0,0 @@
-/*
- *  Copyright (C) 2009, 2010 Austin Robot Technology, Jack O'Quin
- *  Copyright (C) 2011 Jesse Vera
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This class converts raw Velodyne 3D LIDAR packets to PointCloud2.
-
-*/
-
-#include "convert.h"
-
-#include &lt;pcl_conversions/pcl_conversions.h&gt;
-
-namespace velodyne_pointcloud
-{
-  /** @brief Constructor. */
-  Convert::Convert(ros::NodeHandle node, ros::NodeHandle private_nh):
-    data_(new velodyne_rawdata::RawData())
-  {
-    data_-&gt;setup(private_nh);
-
-
-    // advertise output point cloud (before subscribing to input data)
-    output_ =
-      node.advertise&lt;sensor_msgs::PointCloud2&gt;("velodyne_points", 10);
-      
-    srv_ = boost::make_shared &lt;dynamic_reconfigure::Server&lt;velodyne_pointcloud::
-      VelodyneConfigConfig&gt; &gt; (private_nh);
-    dynamic_reconfigure::Server&lt;velodyne_pointcloud::VelodyneConfigConfig&gt;::
-      CallbackType f;
-    f = boost::bind (&amp;Convert::callback, this, _1, _2);
-    srv_-&gt;setCallback (f);
-
-    // subscribe to VelodyneScan packets
-    velodyne_scan_ =
-      node.subscribe("velodyne_packets", 10,
-                     &amp;Convert::processScan, (Convert *) this,
-                     ros::TransportHints().tcpNoDelay(true));
-  }
-  
-  void Convert::callback(velodyne_pointcloud::VelodyneConfigConfig &amp;config,
-                uint32_t level)
-  {
-  ROS_INFO("Reconfigure Request");
-  data_-&gt;setParameters(config.min_range, config.max_range, config.view_direction,
-                       config.view_width);
-  }
-
-  /** @brief Callback for raw scan messages. */
-  void Convert::processScan(const velodyne_msgs::VelodyneScan::ConstPtr &amp;scanMsg)
-  {
-    if (output_.getNumSubscribers() == 0)         // no one listening?
-      return;                                     // avoid much work
-
-    // allocate a point cloud with same time and frame ID as raw data
-    velodyne_rawdata::VPointCloud::Ptr
-      outMsg(new velodyne_rawdata::VPointCloud());
-    // outMsg's header is a pcl::PCLHeader, convert it before stamp assignment
-    outMsg-&gt;header.stamp = pcl_conversions::toPCL(scanMsg-&gt;header).stamp;
-    outMsg-&gt;header.frame_id = scanMsg-&gt;header.frame_id;
-    outMsg-&gt;height = 1;
-
-    // process each packet provided by the driver
-    for (size_t i = 0; i &lt; scanMsg-&gt;packets.size(); ++i)
-      {
-        data_-&gt;unpack(scanMsg-&gt;packets[i], *outMsg);
-      }
-
-    // publish the accumulated cloud message
-    ROS_DEBUG_STREAM("Publishing " &lt;&lt; outMsg-&gt;height * outMsg-&gt;width
-                     &lt;&lt; " Velodyne points, time: " &lt;&lt; outMsg-&gt;header.stamp);
-    output_.publish(outMsg);
-  }
-
-} // namespace velodyne_pointcloud
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\convert.h" new_path="" added_lines="0" deleted_lines="60">
				<diff>@@ -1,60 +0,0 @@
-/* -*- mode: C++ -*- */
-/*
- *  Copyright (C) 2009, 2010 Austin Robot Technology, Jack O'Quin
- *  Copyright (C) 2011 Jesse Vera
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This class converts raw Velodyne 3D LIDAR packets to PointCloud2.
-
-*/
-
-#ifndef _VELODYNE_POINTCLOUD_CONVERT_H_
-#define _VELODYNE_POINTCLOUD_CONVERT_H_ 1
-
-#include &lt;ros/ros.h&gt;
-
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-#include &lt;velodyne_pointcloud/rawdata.h&gt;
-
-#include &lt;dynamic_reconfigure/server.h&gt;
-#include &lt;velodyne_pointcloud/VelodyneConfigConfig.h&gt;
-
-namespace velodyne_pointcloud
-{
-  class Convert
-  {
-  public:
-
-    Convert(ros::NodeHandle node, ros::NodeHandle private_nh);
-    ~Convert() {}
-
-  private:
-    
-    void callback(velodyne_pointcloud::VelodyneConfigConfig &amp;config,
-                uint32_t level);
-    void processScan(const velodyne_msgs::VelodyneScan::ConstPtr &amp;scanMsg);
-
-    ///Pointer to dynamic reconfigure service srv_
-    boost::shared_ptr&lt;dynamic_reconfigure::Server&lt;velodyne_pointcloud::
-      VelodyneConfigConfig&gt; &gt; srv_;
-    
-    boost::shared_ptr&lt;velodyne_rawdata::RawData&gt; data_;
-    ros::Subscriber velodyne_scan_;
-    ros::Publisher output_;
-
-    /// configuration parameters
-    typedef struct {
-      int npackets;                    ///&lt; number of packets to combine
-    } Config;
-    Config config_;
-  };
-
-} // namespace velodyne_pointcloud
-
-#endif // _VELODYNE_POINTCLOUD_CONVERT_H_
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\ringcolors_node.cc" new_path="" added_lines="0" deleted_lines="33">
				<diff>@@ -1,33 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This ROS node converts a Velodyne 3D LIDAR PointXYZIR cloud to
-    PointXYZRGB, assigning colors for visualization of the laser
-    rings.
-
-*/
-
-#include &lt;ros/ros.h&gt;
-#include "colors.h"
-
-/** Main node entry point. */
-int main(int argc, char **argv)
-{
-  ros::init(argc, argv, "colors_node");
-  ros::NodeHandle node;
-  ros::NodeHandle priv_nh("~");
-
-  // create conversion class, which subscribes to input messages
-  velodyne_pointcloud::RingColors colors(node, priv_nh);
-
-  // handle callbacks until shut down
-  ros::spin();
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\ringcolors_nodelet.cc" new_path="" added_lines="0" deleted_lines="50">
				<diff>@@ -1,50 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This ROS nodelet converts a Velodyne 3D LIDAR PointXYZIR cloud to
-    PointXYZRGB, assigning colors for visualization of the laser
-    rings.
-
-*/
-
-#include &lt;ros/ros.h&gt;
-#include &lt;pluginlib/class_list_macros.h&gt;
-#include &lt;nodelet/nodelet.h&gt;
-
-#include "colors.h"
-
-namespace velodyne_pointcloud
-{
-  class RingColorsNodelet: public nodelet::Nodelet
-  {
-  public:
-
-    RingColorsNodelet() {}
-    ~RingColorsNodelet() {}
-
-  private:
-
-    virtual void onInit();
-    boost::shared_ptr&lt;RingColors&gt; colors_;
-  };
-
-  /** @brief Nodelet initialization. */
-  void RingColorsNodelet::onInit()
-  {
-    colors_.reset(new RingColors(getNodeHandle(), getPrivateNodeHandle()));
-  }
-
-} // namespace velodyne_pointcloud
-
-
-// Register this plugin with pluginlib.  Names must match nodelet_velodyne.xml.
-//
-// parameters: package, class name, class type, base class type
-PLUGINLIB_DECLARE_CLASS(velodyne_pointcloud, RingColorsNodelet,
-                        velodyne_pointcloud::RingColorsNodelet, nodelet::Nodelet);
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\transform.cc" new_path="" added_lines="0" deleted_lines="124">
				<diff>@@ -1,124 +0,0 @@
-/*
- *  Copyright (C) 2009, 2010 Austin Robot Technology, Jack O'Quin
- *  Copyright (C) 2011 Jesse Vera
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This class transforms raw Velodyne 3D LIDAR packets to PointCloud2
-    in the /odom frame of reference.
-
-    @author Jack O'Quin
-    @author Jesse Vera
-
-*/
-
-#include "transform.h"
-
-#include &lt;pcl_conversions/pcl_conversions.h&gt;
-
-namespace velodyne_pointcloud
-{
-  /** @brief Constructor. */
-  Transform::Transform(ros::NodeHandle node, ros::NodeHandle private_nh):
-    data_(new velodyne_rawdata::RawData())
-  {
-    private_nh.param("frame_id", config_.frame_id, std::string("odom"));
-    std::string tf_prefix = tf::getPrefixParam(private_nh);
-    config_.frame_id = tf::resolve(tf_prefix, config_.frame_id);
-    ROS_INFO_STREAM("target frame ID: " &lt;&lt; config_.frame_id);
-
-    data_-&gt;setup(private_nh);
-
-    // advertise output point cloud (before subscribing to input data)
-    output_ =
-      node.advertise&lt;sensor_msgs::PointCloud2&gt;("velodyne_points", 10);
-
-    // subscribe to VelodyneScan packets using transform filter
-    velodyne_scan_.subscribe(node, "velodyne_packets", 10);
-    tf_filter_ =
-      new tf::MessageFilter&lt;velodyne_msgs::VelodyneScan&gt;(velodyne_scan_,
-                                                         listener_,
-                                                         config_.frame_id, 10);
-    tf_filter_-&gt;registerCallback(boost::bind(&amp;Transform::processScan, this, _1));
-  }
-
-  /** @brief Callback for raw scan messages.
-   *
-   *  @pre TF message filter has already waited until the transform to
-   *       the configured @c frame_id can succeed.
-   */
-  void
-    Transform::processScan(const velodyne_msgs::VelodyneScan::ConstPtr &amp;scanMsg)
-  {
-    if (output_.getNumSubscribers() == 0)         // no one listening?
-      return;                                     // avoid much work
-
-    // allocate an output point cloud with same time as raw data
-    VPointCloud::Ptr outMsg(new VPointCloud());
-    outMsg-&gt;header.stamp = pcl_conversions::toPCL(scanMsg-&gt;header).stamp;
-    outMsg-&gt;header.frame_id = config_.frame_id;
-    outMsg-&gt;height = 1;
-
-    // process each packet provided by the driver
-    for (size_t next = 0; next &lt; scanMsg-&gt;packets.size(); ++next)
-      {
-        // clear input point cloud to handle this packet
-        inPc_.points.clear();
-        inPc_.width = 0;
-        inPc_.height = 1;
-        std_msgs::Header header;
-        header.stamp = scanMsg-&gt;packets[next].stamp;
-        header.frame_id = scanMsg-&gt;header.frame_id;
-        pcl_conversions::toPCL(header, inPc_.header);
-
-        // unpack the raw data
-        data_-&gt;unpack(scanMsg-&gt;packets[next], inPc_);
-
-        // clear transform point cloud for this packet
-        tfPc_.points.clear();           // is this needed?
-        tfPc_.width = 0;
-        tfPc_.height = 1;
-        header.stamp = scanMsg-&gt;packets[next].stamp;
-        pcl_conversions::toPCL(header, tfPc_.header);
-        tfPc_.header.frame_id = config_.frame_id;
-
-        // transform the packet point cloud into the target frame
-        try
-          {
-            ROS_DEBUG_STREAM("transforming from" &lt;&lt; inPc_.header.frame_id
-                             &lt;&lt; " to " &lt;&lt; config_.frame_id);
-            pcl_ros::transformPointCloud(config_.frame_id, inPc_, tfPc_,
-                                         listener_);
-#if 0       // use the latest transform available, should usually work fine
-            pcl_ros::transformPointCloud(inPc_.header.frame_id,
-                                         ros::Time(0), inPc_,
-                                         config_.frame_id,
-                                         tfPc_, listener_);
-#endif
-          }
-        catch (tf::TransformException &amp;ex)
-          {
-            // only log tf error once every 100 times
-            ROS_WARN_THROTTLE(100, "%s", ex.what());
-            continue;                   // skip this packet
-          }
-
-        // append transformed packet data to end of output message
-        outMsg-&gt;points.insert(outMsg-&gt;points.end(),
-                             tfPc_.points.begin(),
-                             tfPc_.points.end());
-        outMsg-&gt;width += tfPc_.points.size();
-      }
-
-    // publish the accumulated cloud message
-    ROS_DEBUG_STREAM("Publishing " &lt;&lt; outMsg-&gt;height * outMsg-&gt;width
-                     &lt;&lt; " Velodyne points, time: " &lt;&lt; outMsg-&gt;header.stamp);
-    output_.publish(outMsg);
-  }
-
-} // namespace velodyne_pointcloud
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\transform.h" new_path="" added_lines="0" deleted_lines="77">
				<diff>@@ -1,77 +0,0 @@
-/* -*- mode: C++ -*- */
-/*
- *  Copyright (C) 2009, 2010 Austin Robot Technology, Jack O'Quin
- *  Copyright (C) 2011 Jesse Vera
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This class transforms raw Velodyne 3D LIDAR packets to PointCloud2
-    in the /odom frame of reference.
-
-*/
-
-#ifndef _VELODYNE_POINTCLOUD_TRANSFORM_H_
-#define _VELODYNE_POINTCLOUD_TRANSFORM_H_ 1
-
-#include &lt;ros/ros.h&gt;
-#include "tf/message_filter.h"
-#include "message_filters/subscriber.h"
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-
-#include &lt;velodyne_pointcloud/rawdata.h&gt;
-#include &lt;velodyne_pointcloud/point_types.h&gt;
-
-// include template implementations to transform a custom point cloud
-#include &lt;pcl_ros/impl/transforms.hpp&gt;
-
-/** types of point and cloud to work with */
-typedef velodyne_rawdata::VPoint VPoint;
-typedef velodyne_rawdata::VPointCloud VPointCloud;
-
-// instantiate template for transforming a VPointCloud
-template bool
-  pcl_ros::transformPointCloud&lt;VPoint&gt;(const std::string &amp;,
-                                       const VPointCloud &amp;,
-                                       VPointCloud &amp;,
-                                       const tf::TransformListener &amp;);
-
-namespace velodyne_pointcloud
-{
-  class Transform
-  {
-  public:
-
-    Transform(ros::NodeHandle node, ros::NodeHandle private_nh);
-    ~Transform() {}
-
-  private:
-
-    void processScan(const velodyne_msgs::VelodyneScan::ConstPtr &amp;scanMsg);
-
-    boost::shared_ptr&lt;velodyne_rawdata::RawData&gt; data_;
-    message_filters::Subscriber&lt;velodyne_msgs::VelodyneScan&gt; velodyne_scan_;
-    tf::MessageFilter&lt;velodyne_msgs::VelodyneScan&gt; *tf_filter_;
-    ros::Publisher output_;
-    tf::TransformListener listener_;
-
-    /// configuration parameters
-    typedef struct {
-      std::string frame_id;          ///&lt; target frame ID
-    } Config;
-    Config config_;
-
-    // Point cloud buffers for collecting points within a packet.  The
-    // inPc_ and tfPc_ are class members only to avoid reallocation on
-    // every message.
-    VPointCloud inPc_;              ///&lt; input packet point cloud
-    VPointCloud tfPc_;              ///&lt; transformed packet point cloud
-  };
-
-} // namespace velodyne_pointcloud
-
-#endif // _VELODYNE_POINTCLOUD_TRANSFORM_H_
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\transform_node.cc" new_path="" added_lines="0" deleted_lines="31">
				<diff>@@ -1,31 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
-
-    This ROS node transforms raw Velodyne LIDAR packets to PointCloud2
-    in the /odom frame of reference.
-
-*/
-
-#include &lt;ros/ros.h&gt;
-#include "transform.h"
-
-/** Main node entry point. */
-int main(int argc, char **argv)
-{
-  ros::init(argc, argv, "transform_node");
-
-  // create conversion class, which subscribes to raw data
-  velodyne_pointcloud::Transform transform(ros::NodeHandle(),
-                                           ros::NodeHandle("~"));
-
-  // handle callbacks until shut down
-  ros::spin();
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\transform_nodelet.cc" new_path="" added_lines="0" deleted_lines="50">
				<diff>@@ -1,50 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This ROS nodelet transforms raw Velodyne 3D LIDAR packets to a
-    PointCloud2 in the /odom frame.
-
-*/
-
-#include &lt;ros/ros.h&gt;
-#include &lt;pluginlib/class_list_macros.h&gt;
-#include &lt;nodelet/nodelet.h&gt;
-
-#include "transform.h"
-
-namespace velodyne_pointcloud
-{
-  class TransformNodelet: public nodelet::Nodelet
-  {
-  public:
-
-    TransformNodelet() {}
-    ~TransformNodelet() {}
-
-  private:
-
-    virtual void onInit();
-    boost::shared_ptr&lt;Transform&gt; tf_;
-  };
-
-  /** @brief Nodelet initialization. */
-  void TransformNodelet::onInit()
-  {
-    tf_.reset(new Transform(getNodeHandle(), getPrivateNodeHandle()));
-  }
-
-} // namespace velodyne_pointcloud
-
-
-// Register this plugin with pluginlib.  Names must match nodelet_velodyne.xml.
-//
-// parameters: package, class name, class type, base class type
-PLUGINLIB_DECLARE_CLASS(velodyne_pointcloud, TransformNodelet,
-                        velodyne_pointcloud::TransformNodelet,
-                        nodelet::Nodelet);
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\lib\calibration.cc" new_path="" added_lines="0" deleted_lines="237">
				<diff>@@ -1,237 +0,0 @@
-/**
- * \file  calibration.cc
- * \brief  
- *
- * \author  Piyush Khandelwal (piyushk@cs.utexas.edu)
- * Copyright (C) 2012, Austin Robot Technology,
- *                     The University of Texas at Austin
- *
- * License: Modified BSD License
- *
- * $ Id: 02/14/2012 11:36:36 AM piyushk $
- */
-
-#include &lt;iostream&gt;
-#include &lt;fstream&gt;
-#include &lt;string&gt;
-#include &lt;cmath&gt;
-#include &lt;limits&gt;
-#include &lt;yaml-cpp/yaml.h&gt;
-
-#ifdef HAVE_NEW_YAMLCPP
-namespace YAML {
-
-  // The &gt;&gt; operator disappeared in yaml-cpp 0.5, so this function is
-  // added to provide support for code written under the yaml-cpp 0.3 API.
-  template&lt;typename T&gt;
-  void operator &gt;&gt; (const YAML::Node&amp; node, T&amp; i) {
-    i = node.as&lt;T&gt;();
-  }
-} /* YAML */
-#endif // HAVE_NEW_YAMLCPP
-
-#include &lt;ros/ros.h&gt;
-#include &lt;velodyne_pointcloud/calibration.h&gt;
-
-namespace velodyne_pointcloud 
-{
-
-  const std::string NUM_LASERS = "num_lasers";
-  const std::string LASERS = "lasers";
-  const std::string LASER_ID = "laser_id";
-  const std::string ROT_CORRECTION = "rot_correction";
-  const std::string VERT_CORRECTION = "vert_correction";
-   const std::string DIST_CORRECTION = "dist_correction";
-  const std::string TWO_PT_CORRECTION_AVAILABLE =
-    "two_pt_correction_available";
-  const std::string DIST_CORRECTION_X = "dist_correction_x";
-  const std::string DIST_CORRECTION_Y = "dist_correction_y";
-  const std::string VERT_OFFSET_CORRECTION = "vert_offset_correction";
-  const std::string HORIZ_OFFSET_CORRECTION = "horiz_offset_correction";
-  const std::string MAX_INTENSITY = "max_intensity";
-  const std::string MIN_INTENSITY = "min_intensity";
-  const std::string FOCAL_DISTANCE = "focal_distance";
-  const std::string FOCAL_SLOPE = "focal_slope";
-
-  void operator &gt;&gt; (const YAML::Node&amp; node,
-                    std::pair&lt;int, LaserCorrection&gt;&amp; correction)
-  {
-    node[LASER_ID] &gt;&gt; correction.first;
-    node[ROT_CORRECTION] &gt;&gt; correction.second.rot_correction;
-    node[VERT_CORRECTION] &gt;&gt; correction.second.vert_correction;
-    node[DIST_CORRECTION] &gt;&gt; correction.second.dist_correction;
-#ifdef HAVE_NEW_YAMLCPP
-    if (node[TWO_PT_CORRECTION_AVAILABLE])
-      node[TWO_PT_CORRECTION_AVAILABLE] &gt;&gt;
-        correction.second.two_pt_correction_available;
-#else
-    if (const YAML::Node *pName = node.FindValue(TWO_PT_CORRECTION_AVAILABLE))
-      *pName &gt;&gt; correction.second.two_pt_correction_available;
-#endif
-    else
-      correction.second.two_pt_correction_available = false;
-    node[DIST_CORRECTION_X] &gt;&gt; correction.second.dist_correction_x;
-    node[DIST_CORRECTION_Y] &gt;&gt; correction.second.dist_correction_y;
-    node[VERT_OFFSET_CORRECTION] &gt;&gt; correction.second.vert_offset_correction;
-    node[HORIZ_OFFSET_CORRECTION] &gt;&gt; correction.second.horiz_offset_correction;
-#ifdef HAVE_NEW_YAMLCPP
-    if (node[MAX_INTENSITY])
-      node[MAX_INTENSITY] &gt;&gt; correction.second.max_intensity;
-#else
-    if (const YAML::Node *pName = node.FindValue(MAX_INTENSITY))
-      *pName &gt;&gt; correction.second.max_intensity;
-#endif
-    else
-      correction.second.max_intensity = 255;
-#ifdef HAVE_NEW_YAMLCPP
-    if (node[MIN_INTENSITY])
-      node[MIN_INTENSITY] &gt;&gt; correction.second.min_intensity;
-#else
-    if (const YAML::Node *pName = node.FindValue(MIN_INTENSITY))
-      *pName &gt;&gt; correction.second.min_intensity;
-#endif
-    else
-      correction.second.min_intensity = 0;
-    node[FOCAL_DISTANCE] &gt;&gt; correction.second.focal_distance;
-    node[FOCAL_SLOPE] &gt;&gt; correction.second.focal_slope;
-
-    // Calculate cached values
-    correction.second.cos_rot_correction =
-      cosf(correction.second.rot_correction);
-    correction.second.sin_rot_correction =
-      sinf(correction.second.rot_correction);
-    correction.second.cos_vert_correction =
-      cosf(correction.second.vert_correction);
-    correction.second.sin_vert_correction =
-      sinf(correction.second.vert_correction);
-
-    correction.second.laser_ring = 0;   // clear initially (set later)
-  }
-
-  void operator &gt;&gt; (const YAML::Node&amp; node, Calibration&amp; calibration) 
-  {
-    int num_lasers;
-    node[NUM_LASERS] &gt;&gt; num_lasers;
-    const YAML::Node&amp; lasers = node[LASERS];
-    calibration.laser_corrections.clear();
-    calibration.num_lasers = num_lasers;
-    for (int i = 0; i &lt; num_lasers; i++) {
-      std::pair&lt;int, LaserCorrection&gt; correction;
-      lasers[i] &gt;&gt; correction;
-      calibration.laser_corrections.insert(correction);
-    }
-
-    // For each laser ring, find the next-smallest vertical angle.
-    //
-    // This implementation is simple, but not efficient.  That is OK,
-    // since it only runs while starting up.
-    double next_angle = -std::numeric_limits&lt;double&gt;::infinity();
-    for (int ring = 0; ring &lt; num_lasers; ++ring) {
-
-      // find minimum remaining vertical offset correction
-      double min_seen = std::numeric_limits&lt;double&gt;::infinity();
-      int next_index = num_lasers;
-      for (int j = 0; j &lt; num_lasers; ++j) {
-
-        double angle = calibration.laser_corrections[j].vert_correction;
-        if (next_angle &lt; angle &amp;&amp; angle &lt; min_seen) {
-          min_seen = angle;
-          next_index = j;
-        }
-      }
-
-      if (next_index &lt; num_lasers) {    // anything found in this ring?
-
-        // store this ring number with its corresponding laser number
-        calibration.laser_corrections[next_index].laser_ring = ring;
-        next_angle = min_seen;
-        ROS_INFO_STREAM("laser_ring[" &lt;&lt; next_index &lt;&lt; "] = " &lt;&lt; ring
-                         &lt;&lt; ", angle = " &lt;&lt; next_angle);
-      }
-    }
-  }
-
-  YAML::Emitter&amp; operator &lt;&lt; (YAML::Emitter&amp; out,
-                              const std::pair&lt;int, LaserCorrection&gt; correction)
-  {
-    out &lt;&lt; YAML::BeginMap;
-    out &lt;&lt; YAML::Key &lt;&lt; LASER_ID &lt;&lt; YAML::Value &lt;&lt; correction.first;
-    out &lt;&lt; YAML::Key &lt;&lt; ROT_CORRECTION &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.rot_correction;
-    out &lt;&lt; YAML::Key &lt;&lt; VERT_CORRECTION &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.vert_correction;
-    out &lt;&lt; YAML::Key &lt;&lt; DIST_CORRECTION &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.dist_correction;
-    out &lt;&lt; YAML::Key &lt;&lt; TWO_PT_CORRECTION_AVAILABLE &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.two_pt_correction_available;
-    out &lt;&lt; YAML::Key &lt;&lt; DIST_CORRECTION_X &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.dist_correction_x;
-    out &lt;&lt; YAML::Key &lt;&lt; DIST_CORRECTION_Y &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.dist_correction_y;
-    out &lt;&lt; YAML::Key &lt;&lt; VERT_OFFSET_CORRECTION &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.vert_offset_correction;
-    out &lt;&lt; YAML::Key &lt;&lt; HORIZ_OFFSET_CORRECTION &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.horiz_offset_correction;
-    out &lt;&lt; YAML::Key &lt;&lt; MAX_INTENSITY &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.max_intensity;
-    out &lt;&lt; YAML::Key &lt;&lt; MIN_INTENSITY &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.min_intensity;
-    out &lt;&lt; YAML::Key &lt;&lt; FOCAL_DISTANCE &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.focal_distance;
-    out &lt;&lt; YAML::Key &lt;&lt; FOCAL_SLOPE &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.focal_slope;
-    out &lt;&lt; YAML::EndMap;
-    return out;
-  }
-
-  YAML::Emitter&amp; operator &lt;&lt;
-  (YAML::Emitter&amp; out, const Calibration&amp; calibration)
-  {
-    out &lt;&lt; YAML::BeginMap;
-    out &lt;&lt; YAML::Key &lt;&lt; NUM_LASERS &lt;&lt;
-      YAML::Value &lt;&lt; calibration.laser_corrections.size();
-    out &lt;&lt; YAML::Key &lt;&lt; LASERS &lt;&lt; YAML::Value &lt;&lt; YAML::BeginSeq;
-    for (std::map&lt;int, LaserCorrection&gt;::const_iterator
-           it = calibration.laser_corrections.begin();
-         it != calibration.laser_corrections.end(); it++)
-      {
-        out &lt;&lt; *it; 
-      }
-    out &lt;&lt; YAML::EndSeq;
-    out &lt;&lt; YAML::EndMap;
-    return out;
-  }
-
-  void Calibration::read(const std::string&amp; calibration_file) {
-    std::ifstream fin(calibration_file.c_str());
-    if (!fin.is_open()) {
-      initialized = false;
-      return;
-    }
-    initialized = true;
-    try {
-      YAML::Node doc;
-#ifdef HAVE_NEW_YAMLCPP
-      fin.close();
-      doc = YAML::LoadFile(calibration_file);
-#else
-      YAML::Parser parser(fin);
-      parser.GetNextDocument(doc);
-#endif
-      doc &gt;&gt; *this;
-    } catch (YAML::Exception &amp;e) {
-      std::cerr &lt;&lt; "YAML Exception: " &lt;&lt; e.what() &lt;&lt; std::endl;
-      initialized = false;
-    }
-    fin.close();
-  }
-
-  void Calibration::write(const std::string&amp; calibration_file) {
-    std::ofstream fout(calibration_file.c_str());
-    YAML::Emitter out;
-    out &lt;&lt; *this;
-    fout &lt;&lt; out.c_str();
-    fout.close();
-  }
-  
-} /* velodyne_pointcloud */
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\lib\rawdata.cc" new_path="" added_lines="0" deleted_lines="447">
				<diff>@@ -1,447 +0,0 @@
-/*
- *  Copyright (C) 2007 Austin Robot Technology, Patrick Beeson
- *  Copyright (C) 2009, 2010, 2012 Austin Robot Technology, Jack O'Quin
- *
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/**
- *  @file
- *
- *  Velodyne 3D LIDAR data accessor class implementation.
- *
- *  Class for unpacking raw Velodyne LIDAR packets into useful
- *  formats.
- *
- *  Derived classes accept raw Velodyne data for either single packets
- *  or entire rotations, and provide it in various formats for either
- *  on-line or off-line processing.
- *
- *  @author Patrick Beeson
- *  @author Jack O'Quin
- *
- *  HDL-64E S2 calibration support provided by Nick Hillier
- */
-
-#include &lt;fstream&gt;
-#include &lt;math.h&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;ros/package.h&gt;
-#include &lt;angles/angles.h&gt;
-
-#include &lt;velodyne_pointcloud/rawdata.h&gt;
-
-namespace velodyne_rawdata
-{
-  ////////////////////////////////////////////////////////////////////////
-  //
-  // RawData base class implementation
-  //
-  ////////////////////////////////////////////////////////////////////////
-
-  RawData::RawData() {}
-  
-  /** Uppdate parameters: conversions and update */
-  void RawData::setParameters(double min_range,
-                              double max_range,
-                              double view_direction,
-                              double view_width)
-  {
-    config_.min_range = min_range;
-    config_.max_range = max_range;
-
-    //converting angle parameters into the velodyne reference (rad)
-    config_.tmp_min_angle = view_direction + view_width/2;
-    config_.tmp_max_angle = view_direction - view_width/2;
-    
-    //computing positive modulo to keep theses angles into [0;2*M_PI]
-    config_.tmp_min_angle = fmod(fmod(config_.tmp_min_angle,2*M_PI) + 2*M_PI,2*M_PI);
-    config_.tmp_max_angle = fmod(fmod(config_.tmp_max_angle,2*M_PI) + 2*M_PI,2*M_PI);
-    
-    //converting into the hardware velodyne ref (negative yaml and degrees)
-    //adding 0.5 perfomrs a centered double to int conversion 
-    config_.min_angle = 100 * (2*M_PI - config_.tmp_min_angle) * 180 / M_PI + 0.5;
-    config_.max_angle = 100 * (2*M_PI - config_.tmp_max_angle) * 180 / M_PI + 0.5;
-    if (config_.min_angle == config_.max_angle)
-    {
-      //avoid returning empty cloud if min_angle = max_angle
-      config_.min_angle = 0;
-      config_.max_angle = 36000;
-    }
-  }
-
-  /** Set up for on-line operation. */
-  int RawData::setup(ros::NodeHandle private_nh)
-  {
-    // get path to angles.config file for this device
-    if (!private_nh.getParam("calibration", config_.calibrationFile))
-      {
-        ROS_ERROR_STREAM("No calibration angles specified! Using test values!");
-
-        // have to use something: grab unit test version as a default
-        std::string pkgPath = ros::package::getPath("velodyne_pointcloud");
-        config_.calibrationFile = pkgPath + "/params/64e_utexas.yaml";
-      }
-
-    ROS_INFO_STREAM("correction angles: " &lt;&lt; config_.calibrationFile);
-
-    calibration_.read(config_.calibrationFile);
-    if (!calibration_.initialized) {
-      ROS_ERROR_STREAM("Unable to open calibration file: " &lt;&lt; 
-          config_.calibrationFile);
-      return -1;
-    }
-    
-    ROS_INFO_STREAM("Data will be processed as a VLP-16...num_lasers: " &lt;&lt; calibration_.num_lasers);
-    
-    // Set up cached values for sin and cos of all the possible headings
-    for (uint16_t rot_index = 0; rot_index &lt; ROTATION_MAX_UNITS; ++rot_index) {
-      float rotation = angles::from_degrees(ROTATION_RESOLUTION * rot_index);
-      cos_rot_table_[rot_index] = cosf(rotation);
-      sin_rot_table_[rot_index] = sinf(rotation);
-    }
-   return 0;
-  }
-
-  /** @brief convert raw packet to point cloud
-   *
-   *  @param pkt raw packet to unpack
-   *  @param pc shared pointer to point cloud (points are appended)
-   */
-  void RawData::unpack(const velodyne_msgs::VelodynePacket &amp;pkt,
-                       VPointCloud &amp;pc)
-  {
-    ROS_DEBUG_STREAM("Received packet, time: " &lt;&lt; pkt.stamp);
-    
-    /** special parsing for the VLP16 **/
-    if (calibration_.num_lasers == 16)
-    {
-      unpack_vlp16(pkt, pc);
-      return;
-    }
-    
-    const raw_packet_t *raw = (const raw_packet_t *) &amp;pkt.data[0];
-
-    for (int i = 0; i &lt; BLOCKS_PER_PACKET; i++) {
-
-      // upper bank lasers are numbered [0..31]
-      // NOTE: this is a change from the old velodyne_common implementation
-      int bank_origin = 0;
-      if (raw-&gt;blocks[i].header == LOWER_BANK) {
-        // lower bank lasers are [32..63]
-        bank_origin = 32;
-      }
-
-      for (int j = 0, k = 0; j &lt; SCANS_PER_BLOCK; j++, k += RAW_SCAN_SIZE) {
-        
-        float x, y, z;
-        float intensity;
-        uint8_t laser_number;       ///&lt; hardware laser number
-
-        laser_number = j + bank_origin;
-        velodyne_pointcloud::LaserCorrection &amp;corrections = 
-          calibration_.laser_corrections[laser_number];
-
-        /** Position Calculation */
-
-        union two_bytes tmp;
-        tmp.bytes[0] = raw-&gt;blocks[i].data[k];
-        tmp.bytes[1] = raw-&gt;blocks[i].data[k+1];
-        /*condition added to avoid calculating points which are not
-          in the interesting defined area (min_angle &lt; area &lt; max_angle)*/
-        if ((raw-&gt;blocks[i].rotation &gt;= config_.min_angle 
-             &amp;&amp; raw-&gt;blocks[i].rotation &lt;= config_.max_angle 
-             &amp;&amp; config_.min_angle &lt; config_.max_angle)
-             ||(config_.min_angle &gt; config_.max_angle 
-             &amp;&amp; (raw-&gt;blocks[i].rotation &lt;= config_.max_angle 
-             || raw-&gt;blocks[i].rotation &gt;= config_.min_angle))){
-          float distance = tmp.uint * DISTANCE_RESOLUTION;
-          distance += corrections.dist_correction;
-  
-          float cos_vert_angle = corrections.cos_vert_correction;
-          float sin_vert_angle = corrections.sin_vert_correction;
-          float cos_rot_correction = corrections.cos_rot_correction;
-          float sin_rot_correction = corrections.sin_rot_correction;
-  
-          // cos(a-b) = cos(a)*cos(b) + sin(a)*sin(b)
-          // sin(a-b) = sin(a)*cos(b) - cos(a)*sin(b)
-          float cos_rot_angle = 
-            cos_rot_table_[raw-&gt;blocks[i].rotation] * cos_rot_correction + 
-            sin_rot_table_[raw-&gt;blocks[i].rotation] * sin_rot_correction;
-          float sin_rot_angle = 
-            sin_rot_table_[raw-&gt;blocks[i].rotation] * cos_rot_correction - 
-            cos_rot_table_[raw-&gt;blocks[i].rotation] * sin_rot_correction;
-  
-          float horiz_offset = corrections.horiz_offset_correction;
-          float vert_offset = corrections.vert_offset_correction;
-  
-          // Compute the distance in the xy plane (w/o accounting for rotation)
-          /**the new term of 'vert_offset * sin_vert_angle'
-           * was added to the expression due to the mathemathical
-           * model we used.
-           */
-          float xy_distance = distance * cos_vert_angle + vert_offset * sin_vert_angle;
-  
-          // Calculate temporal X, use absolute value.
-          float xx = xy_distance * sin_rot_angle - horiz_offset * cos_rot_angle;
-          // Calculate temporal Y, use absolute value
-          float yy = xy_distance * cos_rot_angle + horiz_offset * sin_rot_angle;
-          if (xx &lt; 0) xx=-xx;
-          if (yy &lt; 0) yy=-yy;
-    
-          // Get 2points calibration values,Linear interpolation to get distance
-          // correction for X and Y, that means distance correction use
-          // different value at different distance
-          float distance_corr_x = 0;
-          float distance_corr_y = 0;
-          if (corrections.two_pt_correction_available) {
-            distance_corr_x = 
-              (corrections.dist_correction - corrections.dist_correction_x)
-                * (xx - 2.4) / (25.04 - 2.4) 
-              + corrections.dist_correction_x;
-            distance_corr_x -= corrections.dist_correction;
-            distance_corr_y = 
-              (corrections.dist_correction - corrections.dist_correction_y)
-                * (yy - 1.93) / (25.04 - 1.93)
-              + corrections.dist_correction_y;
-            distance_corr_y -= corrections.dist_correction;
-          }
-  
-          float distance_x = distance + distance_corr_x;
-          /**the new term of 'vert_offset * sin_vert_angle'
-           * was added to the expression due to the mathemathical
-           * model we used.
-           */
-          xy_distance = distance_x * cos_vert_angle + vert_offset * sin_vert_angle ;
-          ///the expression wiht '-' is proved to be better than the one with '+'
-          x = xy_distance * sin_rot_angle - horiz_offset * cos_rot_angle;
-  
-          float distance_y = distance + distance_corr_y;
-          xy_distance = distance_y * cos_vert_angle + vert_offset * sin_vert_angle ;
-          /**the new term of 'vert_offset * sin_vert_angle'
-           * was added to the expression due to the mathemathical
-           * model we used.
-           */
-          y = xy_distance * cos_rot_angle + horiz_offset * sin_rot_angle;
-  
-          // Using distance_y is not symmetric, but the velodyne manual
-          // does this.
-          /**the new term of 'vert_offset * cos_vert_angle'
-           * was added to the expression due to the mathemathical
-           * model we used.
-           */
-          z = distance_y * sin_vert_angle + vert_offset*cos_vert_angle;
-  
-          /** Use standard ROS coordinate system (right-hand rule) */
-          float x_coord = y;
-          float y_coord = -x;
-          float z_coord = z;
-  
-          /** Intensity Calculation */
-  
-          float min_intensity = corrections.min_intensity;
-          float max_intensity = corrections.max_intensity;
-  
-          intensity = raw-&gt;blocks[i].data[k+2];
-  
-          float focal_offset = 256 
-                             * (1 - corrections.focal_distance / 13100) 
-                             * (1 - corrections.focal_distance / 13100);
-          float focal_slope = corrections.focal_slope;
-          intensity += focal_slope * (abs(focal_offset - 256 * 
-            (1 - static_cast&lt;float&gt;(tmp.uint)/65535)*(1 - static_cast&lt;float&gt;(tmp.uint)/65535)));
-          intensity = (intensity &lt; min_intensity) ? min_intensity : intensity;
-          intensity = (intensity &gt; max_intensity) ? max_intensity : intensity;
-  
-          if (pointInRange(distance)) {
-  
-            // convert polar coordinates to Euclidean XYZ
-            VPoint point;
-            point.ring = corrections.laser_ring;
-            point.x = x_coord;
-            point.y = y_coord;
-            point.z = z_coord;
-            point.intensity = (uint8_t) intensity;
-  
-            // append this point to the cloud
-            pc.points.push_back(point);
-            ++pc.width;
-          }
-        }
-      }
-    }
-  }
-  
-  /** @brief convert raw VLP16 packet to point cloud
-   *
-   *  @param pkt raw packet to unpack
-   *  @param pc shared pointer to point cloud (points are appended)
-   */
-  void RawData::unpack_vlp16(const velodyne_msgs::VelodynePacket &amp;pkt,
-                             VPointCloud &amp;pc)
-  {
-    float azimuth;
-    float azimuth_diff;
-    float last_azimuth_diff;
-    float azimuth_corrected_f;
-    int azimuth_corrected;
-    float x, y, z;
-    float intensity;
-    uint8_t dsr;
-    
-    const raw_packet_t *raw = (const raw_packet_t *) &amp;pkt.data[0];
-
-    for (int block = 0; block &lt; BLOCKS_PER_PACKET; block++) {
-      assert(0xEEFF == raw-&gt;blocks[block].header);
-      azimuth = (float)(raw-&gt;blocks[block].rotation);
-      if (block &lt; (BLOCKS_PER_PACKET-1)){
-        azimuth_diff = (float)((36000 + raw-&gt;blocks[block+1].rotation - raw-&gt;blocks[block].rotation)%36000);
-        last_azimuth_diff = azimuth_diff;
-      }else{
-        azimuth_diff = last_azimuth_diff;
-      }
-
-      for (int firing=0, k=0; firing &lt; VLP16_FIRINGS_PER_BLOCK; firing++){
-        for (int dsr=0; dsr &lt; VLP16_SCANS_PER_FIRING; dsr++, k+=RAW_SCAN_SIZE){
-          velodyne_pointcloud::LaserCorrection &amp;corrections = 
-            calibration_.laser_corrections[dsr];
-
-          /** Position Calculation */
-          union two_bytes tmp;
-          tmp.bytes[0] = raw-&gt;blocks[block].data[k];
-          tmp.bytes[1] = raw-&gt;blocks[block].data[k+1];
-          
-          /** correct for the laser rotation as a function of timing during the firings **/
-          azimuth_corrected_f = azimuth + (azimuth_diff * ((dsr*VLP16_DSR_TOFFSET) + (firing*VLP16_FIRING_TOFFSET)) / VLP16_BLOCK_TDURATION);
-          azimuth_corrected = ((int)round(azimuth_corrected_f)) % 36000;
-          
-          /*condition added to avoid calculating points which are not
-            in the interesting defined area (min_angle &lt; area &lt; max_angle)*/
-          if ((azimuth_corrected &gt;= config_.min_angle 
-               &amp;&amp; azimuth_corrected &lt;= config_.max_angle 
-               &amp;&amp; config_.min_angle &lt; config_.max_angle)
-               ||(config_.min_angle &gt; config_.max_angle 
-               &amp;&amp; (azimuth_corrected &lt;= config_.max_angle 
-               || azimuth_corrected &gt;= config_.min_angle))){
-            float distance = tmp.uint * DISTANCE_RESOLUTION;
-            distance += corrections.dist_correction;
-            
-            float cos_vert_angle = corrections.cos_vert_correction;
-            float sin_vert_angle = corrections.sin_vert_correction;
-            float cos_rot_correction = corrections.cos_rot_correction;
-            float sin_rot_correction = corrections.sin_rot_correction;
-    
-            // cos(a-b) = cos(a)*cos(b) + sin(a)*sin(b)
-            // sin(a-b) = sin(a)*cos(b) - cos(a)*sin(b)
-            float cos_rot_angle = 
-              cos_rot_table_[azimuth_corrected] * cos_rot_correction + 
-              sin_rot_table_[azimuth_corrected] * sin_rot_correction;
-            float sin_rot_angle = 
-              sin_rot_table_[azimuth_corrected] * cos_rot_correction - 
-              cos_rot_table_[azimuth_corrected] * sin_rot_correction;
-    
-            float horiz_offset = corrections.horiz_offset_correction;
-            float vert_offset = corrections.vert_offset_correction;
-    
-            // Compute the distance in the xy plane (w/o accounting for rotation)
-            /**the new term of 'vert_offset * sin_vert_angle'
-             * was added to the expression due to the mathemathical
-             * model we used.
-             */
-            float xy_distance = distance * cos_vert_angle + vert_offset * sin_vert_angle;
-    
-            // Calculate temporal X, use absolute value.
-            float xx = xy_distance * sin_rot_angle - horiz_offset * cos_rot_angle;
-            // Calculate temporal Y, use absolute value
-            float yy = xy_distance * cos_rot_angle + horiz_offset * sin_rot_angle;
-            if (xx &lt; 0) xx=-xx;
-            if (yy &lt; 0) yy=-yy;
-      
-            // Get 2points calibration values,Linear interpolation to get distance
-            // correction for X and Y, that means distance correction use
-            // different value at different distance
-            float distance_corr_x = 0;
-            float distance_corr_y = 0;
-            if (corrections.two_pt_correction_available) {
-              distance_corr_x = 
-                (corrections.dist_correction - corrections.dist_correction_x)
-                  * (xx - 2.4) / (25.04 - 2.4) 
-                + corrections.dist_correction_x;
-              distance_corr_x -= corrections.dist_correction;
-              distance_corr_y = 
-                (corrections.dist_correction - corrections.dist_correction_y)
-                  * (yy - 1.93) / (25.04 - 1.93)
-                + corrections.dist_correction_y;
-              distance_corr_y -= corrections.dist_correction;
-            }
-    
-            float distance_x = distance + distance_corr_x;
-            /**the new term of 'vert_offset * sin_vert_angle'
-             * was added to the expression due to the mathemathical
-             * model we used.
-             */
-            xy_distance = distance_x * cos_vert_angle + vert_offset * sin_vert_angle ;
-            x = xy_distance * sin_rot_angle - horiz_offset * cos_rot_angle;
-    
-            float distance_y = distance + distance_corr_y;
-            /**the new term of 'vert_offset * sin_vert_angle'
-             * was added to the expression due to the mathemathical
-             * model we used.
-             */
-            xy_distance = distance_y * cos_vert_angle + vert_offset * sin_vert_angle ;
-            y = xy_distance * cos_rot_angle + horiz_offset * sin_rot_angle;
-    
-            // Using distance_y is not symmetric, but the velodyne manual
-            // does this.
-            /**the new term of 'vert_offset * cos_vert_angle'
-             * was added to the expression due to the mathemathical
-             * model we used.
-             */
-            z = distance_y * sin_vert_angle + vert_offset*cos_vert_angle;
-  
-    
-            /** Use standard ROS coordinate system (right-hand rule) */
-            float x_coord = y;
-            float y_coord = -x;
-            float z_coord = z;
-    
-            /** Intensity Calculation */
-    
-            float min_intensity = corrections.min_intensity;
-            float max_intensity = corrections.max_intensity;
-    
-            intensity = raw-&gt;blocks[block].data[k+2];
-    
-            float focal_offset = 256 
-                               * (1 - corrections.focal_distance / 13100) 
-                               * (1 - corrections.focal_distance / 13100);
-            float focal_slope = corrections.focal_slope;
-            intensity += focal_slope * (abs(focal_offset - 256 * 
-              (1 - tmp.uint/65535)*(1 - tmp.uint/65535)));
-            intensity = (intensity &lt; min_intensity) ? min_intensity : intensity;
-            intensity = (intensity &gt; max_intensity) ? max_intensity : intensity;
-    
-            if (pointInRange(distance)) {
-    
-              // convert polar coordinates to Euclidean XYZ
-              VPoint point;
-              point.ring = corrections.laser_ring;
-              point.x = x_coord;
-              point.y = y_coord;
-              point.z = z_coord;
-              point.intensity = (uint8_t) intensity;
-    
-              // append this point to the cloud
-              pc.points.push_back(point);
-              ++pc.width;
-            }
-          }
-        }
-      }
-    }
-  }  
-
-} // namespace velodyne_rawdata
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\image_processor\nodes\image_rectifier\image_rectifier_node.cpp" new_path="ros\src\sensing\filters\packages\image_processor\nodes\image_rectifier\image_rectifier_node.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -111,8 +111,6 @@ public:
 		node_handle.param&lt;std::string&gt;("image_src", image_raw_topic_str, "/image_raw");
 
 		node_handle.param&lt;std::string&gt;("camera_info_src", camera_info_topic_str, "/camera_info");
-		ROS_INFO("[%s] camera_info_src: %s", _NODE_NAME_, camera_info_topic_str.c_str());
-
 
 		if (name_space_str != "/") {
 			if (name_space_str.substr(0, 2) == "//") {
@@ -126,6 +124,7 @@ public:
 		}
 
 		ROS_INFO("[%s] image_src: %s", _NODE_NAME_, image_raw_topic_str.c_str());
+		ROS_INFO("[%s] camera_info_src: %s", _NODE_NAME_, camera_info_topic_str.c_str());
 
 		ROS_INFO("[%s] Subscribing to... %s", _NODE_NAME_, image_raw_topic_str.c_str());
 		subscriber_image_raw_ = node_handle.subscribe(image_raw_topic_str, 1, &amp;RosImageRectifierApp::ImageCallback, this);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d5ec9318faca4df4978d6a4181962593632b7bcc" author="anhnv3991">
		<msg>Update nearest neighbor search algorithm using Octree.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\VoxelGrid.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\VoxelGrid.h" added_lines="26" deleted_lines="8">
				<diff>@@ -8,6 +8,9 @@
 #include &lt;vector&gt;
 #include &lt;eigen3/Eigen/Dense&gt;
 #include &lt;eigen3/Eigen/Geometry&gt;
+#include "Octree.h"
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;boost/make_shared.hpp&gt;
 
 namespace cpu {
 
@@ -55,8 +58,8 @@ public:
 	/* Searching for the nearest point of each input query point.
 	 * Return the distance between the query point and its nearest neighbor.
 	 * If the distance is larger than max_range, then return DBL_MAX. */
-	double nearestNeighborDistance(PointSourceType query_point, float max_range);
 
+	double nearestNeighborDistance(PointSourceType query_point, float max_range);
 
 	Eigen::Vector3d getCentroid(int voxel_id) const;
 	Eigen::Matrix3d getCovariance(int voxel_id) const;
@@ -66,6 +69,10 @@ public:
 
 private:
 
+	typedef struct {
+		int x, y, z;
+	} OctreeDim;
+
 	/* Construct the voxel grid and the build the octree. */
 	void initialize();
 
@@ -101,7 +108,13 @@ private:
 
 	void updateVoxelContent(typename pcl::PointCloud&lt;PointSourceType&gt;::Ptr new_cloud);
 
+	int nearestVoxel(PointSourceType query_point, Eigen::Matrix&lt;float, 6, 1&gt; boundaries, float max_range);
+
+	int roundUp(int input, int factor);
 
+	int roundDown(int input, int factor);
+
+	int div(int input, int divisor);
 
 	//Coordinate of input points
 	typename pcl::PointCloud&lt;PointSourceType&gt;::Ptr source_cloud_;
@@ -118,18 +131,23 @@ private:
 										// per voxel is less than this number, then the voxel is ignored
 										// during computation (treated like it contains no point)
 
-	std::vector&lt;Eigen::Vector3d&gt; centroid_;			// 3x1 Centroid vectors of voxels
-	std::vector&lt;Eigen::Matrix3d&gt; covariance_;		// 3x3 Covariance matrixes of voxels
-	std::vector&lt;Eigen::Matrix3d&gt; icovariance_;		// Inverse covariance matrixes of voxel
-	std::vector&lt;std::vector&lt;int&gt; &gt; points_id_;		// Indexes of points belong to each voxel
-	std::vector&lt;int&gt; points_per_voxel_;				// Number of points belong to each voxel
+	boost::shared_ptr&lt;std::vector&lt;Eigen::Vector3d&gt; &gt; centroid_;			// 3x1 Centroid vectors of voxels
+	boost::shared_ptr&lt;std::vector&lt;Eigen::Matrix3d&gt; &gt; icovariance_;		// Inverse covariance matrixes of voxel
+	boost::shared_ptr&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; points_id_;		// Indexes of points belong to each voxel
+	boost::shared_ptr&lt;std::vector&lt;int&gt; &gt; points_per_voxel_;				// Number of points belong to each voxel
 													// (may differ from size of each vector in points_id_
 													// because of changes made during computing covariances
-	std::vector&lt;Eigen::Vector3d&gt; tmp_centroid_;
-	std::vector&lt;Eigen::Matrix3d&gt; tmp_cov_;
+	boost::shared_ptr&lt;std::vector&lt;Eigen::Vector3d&gt; &gt; tmp_centroid_;
+	boost::shared_ptr&lt;std::vector&lt;Eigen::Matrix3d&gt; &gt; tmp_cov_;
 
 	int real_max_bx_, real_max_by_, real_max_bz_;
 	int real_min_bx_, real_min_by_, real_min_bz_;
+
+	Octree&lt;PointSourceType&gt; octree_;
+
+	static const int MAX_BX_ = 16;
+	static const int MAX_BY_ = 16;
+	static const int MAX_BZ_ = 8;
 };
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" added_lines="193" deleted_lines="236">
				<diff>@@ -14,10 +14,6 @@
 
 namespace cpu {
 
-#define MAX_BX_ (128)
-#define MAX_BY_ (128)
-#define MAX_BZ_ (32)
-
 template &lt;typename PointSourceType&gt;
 VoxelGrid&lt;PointSourceType&gt;::VoxelGrid():
 	voxel_num_(0),
@@ -39,36 +35,60 @@ VoxelGrid&lt;PointSourceType&gt;::VoxelGrid():
 	vgrid_x_(0),
 	vgrid_y_(0),
 	vgrid_z_(0),
-	min_points_per_voxel_(6)
-{
-	centroid_.clear();
-	covariance_.clear();
-	icovariance_.clear();
-	points_id_.clear();
-	points_per_voxel_.clear();
-	tmp_centroid_.clear();
-	tmp_cov_.clear();
+	min_points_per_voxel_(6),
+	real_max_bx_(INT_MIN),
+	real_max_by_(INT_MIN),
+	real_max_bz_(INT_MIN),
+	real_min_bx_(INT_MAX),
+	real_min_by_(INT_MAX),
+	real_min_bz_(INT_MAX)
+{
+	centroid_.reset();
+	icovariance_.reset();
+	points_id_.reset();
+	points_per_voxel_.reset();
+	tmp_centroid_.reset();
+	tmp_cov_.reset();
 };
 
 template &lt;typename PointSourceType&gt;
-void VoxelGrid&lt;PointSourceType&gt;::initialize()
+int VoxelGrid&lt;PointSourceType&gt;::roundUp(int input, int factor)
+{
+	return (input &lt; 0) ? -((-input) / factor) * factor : ((input + factor - 1) / factor) * factor;
+}
+
+template &lt;typename PointSourceType&gt;
+int VoxelGrid&lt;PointSourceType&gt;::roundDown(int input, int factor)
 {
-	centroid_.resize(voxel_num_);
+	return (input &lt; 0) ? -((-input + factor - 1) / factor) * factor : (input / factor) * factor;
+}
 
-	covariance_.resize(voxel_num_);
+template &lt;typename PointSourceType&gt;
+int VoxelGrid&lt;PointSourceType&gt;::div(int input, int divisor)
+{
+	return (input &lt; 0) ? -((-input + divisor - 1) / divisor) : input / divisor;
+}
 
-	icovariance_.resize(voxel_num_);
+template &lt;typename PointSourceType&gt;
+void VoxelGrid&lt;PointSourceType&gt;::initialize()
+{
+	centroid_.reset();
+	centroid_ = boost::make_shared&lt;std::vector&lt;Eigen::Vector3d&gt; &gt;(voxel_num_);
 
-	points_id_.resize(voxel_num_);
+	icovariance_.reset();
+	icovariance_ = boost::make_shared&lt;std::vector&lt;Eigen::Matrix3d&gt; &gt;(voxel_num_);
 
-	points_per_voxel_.resize(voxel_num_);
+	points_id_.reset();
+	points_id_ = boost::make_shared&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt;(voxel_num_);
 
-	// Reset the number of points in all voxels to zero
-	std::fill(points_per_voxel_.begin(), points_per_voxel_.end(), 0);
+	points_per_voxel_.reset();
+	points_per_voxel_ = boost::make_shared&lt;std::vector&lt;int&gt; &gt;(voxel_num_, 0);
 
-	tmp_centroid_.resize(voxel_num_);
+	tmp_centroid_.reset();
+	tmp_centroid_ = boost::make_shared&lt;std::vector&lt;Eigen::Vector3d&gt; &gt;(voxel_num_);
 
-	tmp_cov_.resize(voxel_num_);
+	tmp_cov_.reset();
+	tmp_cov_ = boost::make_shared&lt;std::vector&lt;Eigen::Matrix3d&gt; &gt;(voxel_num_);
 }
 
 template &lt;typename PointSourceType&gt;
@@ -188,19 +208,13 @@ int VoxelGrid&lt;PointSourceType&gt;::getVgridZ() const
 template &lt;typename PointSourceType&gt;
 Eigen::Vector3d VoxelGrid&lt;PointSourceType&gt;::getCentroid(int voxel_id) const
 {
-	return centroid_[voxel_id];
-}
-
-template &lt;typename PointSourceType&gt;
-Eigen::Matrix3d VoxelGrid&lt;PointSourceType&gt;::getCovariance(int voxel_id) const
-{
-	return covariance_[voxel_id];
+	return (*centroid_)[voxel_id];
 }
 
 template &lt;typename PointSourceType&gt;
 Eigen::Matrix3d VoxelGrid&lt;PointSourceType&gt;::getInverseCovariance(int voxel_id) const
 {
-	return icovariance_[voxel_id];
+	return (*icovariance_)[voxel_id];
 }
 
 template &lt;typename PointSourceType&gt;
@@ -249,27 +263,27 @@ void VoxelGrid&lt;PointSourceType&gt;::computeCentroidAndCovariance()
 		for (int idy = real_min_by_; idy &lt;= real_max_by_; idy++)
 			for (int idz = real_min_bz_; idz &lt;= real_max_bz_; idz++) {
 				int i = voxelId(idx, idy, idz, min_b_x_, min_b_y_, min_b_z_, vgrid_x_, vgrid_y_, vgrid_z_);
-				int ipoint_num = points_id_[i].size();
+				int ipoint_num = (*points_id_)[i].size();
 				double point_num = static_cast&lt;double&gt;(ipoint_num);
-				Eigen::Vector3d pt_sum = tmp_centroid_[i];
+				Eigen::Vector3d pt_sum = (*tmp_centroid_)[i];
 
 				if (ipoint_num &gt; 0) {
-					centroid_[i] = pt_sum / point_num;
+					(*centroid_)[i] = pt_sum / point_num;
 				}
-
+				Eigen::Matrix3d covariance;
 
 				if (ipoint_num &gt;= min_points_per_voxel_) {
-					covariance_[i] = (tmp_cov_[i] - 2.0 * (pt_sum * centroid_[i].transpose())) / point_num + centroid_[i] * centroid_[i].transpose();
-					covariance_[i] *= (point_num - 1.0) / point_num;
+					covariance = ((*tmp_cov_)[i] - 2.0 * (pt_sum * (*centroid_)[i].transpose())) / point_num + (*centroid_)[i] * (*centroid_)[i].transpose();
+					covariance *= (point_num - 1.0) / point_num;
 
-					SymmetricEigensolver3x3 sv(covariance_[i]);
+					SymmetricEigensolver3x3 sv(covariance);
 
 					sv.compute();
 					Eigen::Matrix3d evecs = sv.eigenvectors();
 					Eigen::Matrix3d evals = sv.eigenvalues().asDiagonal();
 
 					if (evals(0, 0) &lt; 0 || evals(1, 1) &lt; 0 || evals(2, 2) &lt;= 0) {
-						points_per_voxel_[i] = -1;
+						(*points_per_voxel_)[i] = -1;
 						continue;
 					}
 
@@ -282,10 +296,10 @@ void VoxelGrid&lt;PointSourceType&gt;::computeCentroidAndCovariance()
 							evals(1, 1) = min_cov_eigvalue;
 						}
 
-						covariance_[i] = evecs * evals * evecs.inverse();
+						covariance = evecs * evals * evecs.inverse();
 					}
 
-					icovariance_[i] = covariance_[i].inverse();
+					(*icovariance_)[i] = covariance.inverse();
 				}
 			}
 }
@@ -302,6 +316,21 @@ void VoxelGrid&lt;PointSourceType&gt;::setInput(typename pcl::PointCloud&lt;PointSourceTy
 
 		findBoundaries();
 
+		std::vector&lt;Eigen::Vector3i&gt; voxel_ids(input_cloud-&gt;points.size());
+
+		for (int i = 0; i &lt; input_cloud-&gt;points.size(); i++) {
+			Eigen::Vector3i &amp;vid = voxel_ids[i];
+			PointSourceType p = input_cloud-&gt;points[i];
+
+			vid(0) = static_cast&lt;int&gt;(floor(p.x / voxel_x_));
+			vid(1) = static_cast&lt;int&gt;(floor(p.y / voxel_y_));
+			vid(2) = static_cast&lt;int&gt;(floor(p.z / voxel_z_));
+		}
+
+		octree_.setInput(voxel_ids, input_cloud);
+
+		voxel_ids.clear();
+
 		initialize();
 
 		scatterPointsToVoxelGrid();
@@ -328,14 +357,14 @@ void VoxelGrid&lt;PointSourceType&gt;::findBoundaries()
 	 * we do not have to reallocate buffers when the target cloud is set
 	 */
 	/* Max bounds round toward plus infinity */
-	max_b_x_ = (max_b_x_ &lt; 0) ? (-(- max_b_x_) / MAX_BX_) * MAX_BX_ : ((max_b_x_ - 1) / MAX_BX_ + 1) * MAX_BX_;
-	max_b_y_ = (max_b_y_ &lt; 0) ? (-(- max_b_y_) / MAX_BY_) * MAX_BY_ : ((max_b_y_ - 1) / MAX_BY_ + 1) * MAX_BY_;
-	max_b_z_ = (max_b_z_ &lt; 0) ? (-(- max_b_z_) / MAX_BZ_) * MAX_BZ_ : ((max_b_z_ - 1) / MAX_BZ_ + 1) * MAX_BZ_;
+	max_b_x_ = roundUp(max_b_x_, MAX_BX_);
+	max_b_y_ = roundUp(max_b_y_, MAX_BY_);
+	max_b_z_ = roundUp(max_b_z_, MAX_BZ_);
 
 	/* Min bounds round toward minus infinity */
-	min_b_x_ = (min_b_x_ &lt; 0) ? (-((- min_b_x_ - 1) / MAX_BX_ + 1)) * MAX_BX_ : (min_b_x_ / MAX_BX_) * MAX_BX_;
-	min_b_y_ = (min_b_y_ &lt; 0) ? (-((- min_b_y_ - 1) / MAX_BY_ + 1)) * MAX_BY_ : (min_b_y_ / MAX_BY_) * MAX_BY_;
-	min_b_z_ = (min_b_z_ &lt; 0) ? (-((- min_b_z_ - 1) / MAX_BZ_ + 1)) * MAX_BZ_ : (min_b_z_ / MAX_BZ_) * MAX_BZ_;
+	min_b_x_ = roundDown(min_b_x_, MAX_BX_);
+	min_b_y_ = roundDown(min_b_y_, MAX_BY_);
+	min_b_z_ = roundDown(min_b_z_, MAX_BZ_);
 
 	vgrid_x_ = max_b_x_ - min_b_x_ + 1;
 	vgrid_y_ = max_b_y_ - min_b_y_ + 1;
@@ -353,25 +382,21 @@ void VoxelGrid&lt;PointSourceType&gt;::findBoundaries(typename pcl::PointCloud&lt;PointSo
 													float &amp;min_x, float &amp;min_y, float &amp;min_z)
 {
 
+	max_x = max_y = max_z = -FLT_MAX;
+	min_x = min_y = min_z = FLT_MAX;
+
 	for (int i = 0; i &lt; input_cloud-&gt;points.size(); i++) {
 		float x = input_cloud-&gt;points[i].x;
 		float y = input_cloud-&gt;points[i].y;
 		float z = input_cloud-&gt;points[i].z;
 
-		if (i == 0) {
-			max_x = min_x = x;
-			max_y = min_y = y;
-			max_z = min_z = z;
-		} else {
-
-			max_x = (max_x &gt; x) ? max_x : x;
-			max_y = (max_y &gt; y) ? max_y : y;
-			max_z = (max_z &gt; z) ? max_z : z;
+		max_x = (max_x &gt; x) ? max_x : x;
+		max_y = (max_y &gt; y) ? max_y : y;
+		max_z = (max_z &gt; z) ? max_z : z;
 
-			min_x = (min_x &lt; x) ? min_x : x;
-			min_y = (min_y &lt; y) ? min_y : y;
-			min_z = (min_z &lt; z) ? min_z : z;
-		}
+		min_x = (min_x &lt; x) ? min_x : x;
+		min_y = (min_y &lt; y) ? min_y : y;
+		min_z = (min_z &lt; z) ? min_z : z;
 	}
 }
 
@@ -409,10 +434,10 @@ void VoxelGrid&lt;PointSourceType&gt;::radiusSearch(PointSourceType p, float radius, s
 									min_b_x_, min_b_y_, min_b_z_,
 									vgrid_x_, vgrid_y_, vgrid_z_);
 
-				if (points_per_voxel_[vid] &gt;= min_points_per_voxel_) {
-					double cx = centroid_[vid](0) - static_cast&lt;double&gt;(t_x);
-					double cy = centroid_[vid](1) - static_cast&lt;double&gt;(t_y);
-					double cz = centroid_[vid](2) - static_cast&lt;double&gt;(t_z);
+				if ((*points_per_voxel_)[vid] &gt;= min_points_per_voxel_) {
+					double cx = (*centroid_)[vid](0) - static_cast&lt;double&gt;(t_x);
+					double cy = (*centroid_)[vid](1) - static_cast&lt;double&gt;(t_y);
+					double cz = (*centroid_)[vid](2) - static_cast&lt;double&gt;(t_z);
 
 					double distance = sqrt(cx * cx + cy * cy + cz * cz);
 
@@ -436,146 +461,77 @@ void VoxelGrid&lt;PointSourceType&gt;::scatterPointsToVoxelGrid()
 
 		Eigen::Vector3d p3d(p.x, p.y, p.z);
 
-		if (points_id_[vid].size() == 0) {
-			centroid_[vid].setZero();
-			points_per_voxel_[vid] = 0;
-			tmp_centroid_[vid].setZero();
-			tmp_cov_[vid].setIdentity();
+		if ((*points_id_)[vid].size() == 0) {
+			(*centroid_)[vid].setZero();
+			(*points_per_voxel_)[vid] = 0;
+			(*tmp_centroid_)[vid].setZero();
+			(*tmp_cov_)[vid].setIdentity();
 		}
 
-		tmp_centroid_[vid] += p3d;
-		tmp_cov_[vid] += p3d * p3d.transpose();
-		points_id_[vid].push_back(pid);
-		points_per_voxel_[vid]++;
+		(*tmp_centroid_)[vid] += p3d;
+		(*tmp_cov_)[vid] += p3d * p3d.transpose();
+		(*points_id_)[vid].push_back(pid);
+		(*points_per_voxel_)[vid]++;
 	}
 }
 
 template &lt;typename PointSourceType&gt;
-double VoxelGrid&lt;PointSourceType&gt;::nearestNeighborDistance(PointSourceType query_point, float max_range)
+int VoxelGrid&lt;PointSourceType&gt;::nearestVoxel(PointSourceType query_point, Eigen::Matrix&lt;float, 6, 1&gt; boundaries, float max_range)
 {
 	// Index of the origin of the circle (query point)
 	float qx = query_point.x;
 	float qy = query_point.y;
 	float qz = query_point.z;
 
-	int ovx = static_cast&lt;int&gt;(floor(qx / voxel_x_));
-	int ovy = static_cast&lt;int&gt;(floor(qy / voxel_y_));
-	int ovz = static_cast&lt;int&gt;(floor(qz / voxel_z_));
-
-	// Now find index of the nearest voxel (may be empty or not)
-	int nvx, nvy, nvz, fvx, fvy, fvz;
-
-	if (ovx &gt; real_max_bx_) {
-		nvx = real_max_bx_;
-		fvx = real_min_bx_;
-	} else if (ovx &lt; real_min_bx_) {
-		nvx = real_min_bx_;
-		fvx = real_max_bx_;
-	} else {
-		nvx = ovx;
-		fvx = (real_max_bx_ - ovx &gt; ovx - real_min_bx_) ? real_max_bx_ : real_min_bx_;
-	}
-
-	if (ovy &gt; real_max_by_) {
-		nvy = real_max_by_;
-		fvy = real_min_by_;
-	} else if (ovy &lt; real_min_by_) {
-		nvy = real_min_by_;
-		fvy = real_max_by_;
-	} else {
-		nvy = ovy;
-		fvy = (real_max_by_ - ovy &gt; ovy - real_min_by_) ? real_max_by_ : real_min_by_;
-	}
-
-	if (ovz &gt; real_max_bz_) {
-		nvz = real_max_bz_;
-		fvz = real_min_bz_;
-	} else if (ovz &lt; real_min_bz_) {
-		nvz = real_min_bz_;
-		fvz = real_max_bz_;
-	} else {
-		nvz = ovz;
-		fvz = (real_max_bz_ - ovz &gt; ovz - real_min_bz_) ? real_max_bz_ : real_min_bz_;
-	}
-
-	// Now find index of the furthest voxel
-
-	int min_radius = static_cast&lt;int&gt;(sqrt((nvx - ovx) * (nvx - ovx) + (nvy - ovy) * (nvy - ovy) + (nvz - ovz) * (nvz - ovz)));
-	int max_radius = static_cast&lt;int&gt;(sqrt((nvx - ovx) * (nvx - ovx) + (nvy - ovy) * (nvy - ovy) + (nvz - ovz) * (nvz - ovz)));
-
-	/* Check all voxels laying on the circle. If a voxel is
-	 * not empty, then break immediately.
-	 * If those voxels are all empty, then increase the radius
-	 * and repeat the process. */
-	bool found_nn = false;
-	int nn_vid;
-
-	for (int radius = min_radius; radius &lt;= max_radius &amp;&amp; !found_nn; radius++) {
-		// Find the intersection of the circle with the voxel grid
-		int lower_bx, upper_bx, lower_by, upper_by, lower_bz, upper_bz;
-
-		lower_bx = (ovx - radius &gt; real_min_bx_) ? ovx - radius : real_min_bx_;
-		upper_bx = (ovx + radius &gt; real_max_bx_) ? real_max_bx_ : ovx + radius;
-
-		lower_by = (ovy - radius &gt; real_min_by_) ? ovy - radius : real_min_by_;
-		upper_by = (ovy + radius &gt; real_max_by_) ? real_max_by_ : ovy + radius;
-
-		lower_bz = (ovz - radius &gt; real_min_bz_) ? ovz - radius : real_min_bz_;
-		upper_bz = (ovz + radius &gt; real_max_bz_) ? real_max_bz_ : ovz + radius;
-
-		for (int i = lower_bx; i &lt;= upper_bx &amp;&amp; !found_nn; i++) {
-			for (int j = lower_by; j &lt;= upper_by &amp;&amp; !found_nn; j++) {
-				int kz = static_cast&lt;int&gt;(sqrt(radius * radius - (ovx - i) * (ovx - i) - (ovy - j) * (ovy - j)));
-				int k;
-				int vid;
+	int lower_x = static_cast&lt;int&gt;(floor(boundaries(0) / voxel_x_));
+	int lower_y = static_cast&lt;int&gt;(floor(boundaries(1) / voxel_y_));
+	int lower_z = static_cast&lt;int&gt;(floor(boundaries(2) / voxel_z_));
 
-				k = ovz + kz;
-				if (k &gt;= lower_bz &amp;&amp; k &lt;= upper_bz) {
-					vid = voxelId(i, j, k, min_b_x_, min_b_y_, min_b_z_, vgrid_x_, vgrid_y_, vgrid_z_);
+	int upper_x = static_cast&lt;int&gt;(floor(boundaries(3) / voxel_x_));
+	int upper_y = static_cast&lt;int&gt;(floor(boundaries(4) / voxel_y_));
+	int upper_z = static_cast&lt;int&gt;(floor(boundaries(5) / voxel_z_));
 
-					if (points_id_[vid].size() &gt; 0) {
-						found_nn = true;
-						nn_vid = vid;
-						break;
-					}
-				}
+	double min_dist = DBL_MAX;
+	int nn_vid = -1;
 
-				k = ovz - kz;
+	for (int i = lower_x; i &lt;= upper_x; i++) {
+		for (int j = lower_y; j &lt;= upper_y; j++) {
+			for (int k = lower_z; k &lt;= upper_z; k++) {
+				int vid = voxelId(i, j, k, min_b_x_, min_b_y_, min_b_z_, vgrid_x_, vgrid_y_, vgrid_z_);
+				Eigen::Vector3d c = (*centroid_)[vid];
 
-				if (k &gt;= lower_bz &amp;&amp; k &lt;= upper_bz) {
-					vid = voxelId(i, j, k, min_b_x_, min_b_y_, min_b_z_, vgrid_x_, vgrid_y_, vgrid_z_);
+				if ((*points_id_)[vid].size() &gt; 0) {
+					double cur_dist = sqrt((qx - c(0)) * (qx - c(0)) + (qy - c(1)) * (qy - c(1)) + (qz - c(2)) * (qz - c(2)));
 
-					if (points_id_[vid].size() &gt; 0) {
-						found_nn = true;
+					if (cur_dist &lt; min_dist) {
+						min_dist = cur_dist;
 						nn_vid = vid;
-						break;
 					}
 				}
 			}
 		}
 	}
 
-//	std::vector&lt;int&gt; &amp;tmp_pid = points_id_[nn_vid];
-//
-//	float min_dist = DBL_MAX;
-//
-//
-//	for (int i = 0; i &lt; tmp_pid.size(); i++) {
-//		PointSourceType p = source_cloud_-&gt;points[tmp_pid[i]];
-//		float distance = sqrt((p.x - qx) * (p.x - qx) + (p.y - qy) * (p.y - qy) + (p.z - qz) * (p.z - qz));
-//
-//		if (distance &lt; min_dist) {
-//			min_dist = distance;
-//		}
-//	}
-
-	Eigen::Vector3d c = centroid_[nn_vid];
-	double min_dist = sqrt((qx - c(0)) * (qx - c(0)) + (qy - c(1)) * (qy - c(1)) + (qz - c(2)) * (qz - c(2)));
+	return nn_vid;
+}
+
+template &lt;typename PointSourceType&gt;
+double VoxelGrid&lt;PointSourceType&gt;::nearestNeighborDistance(PointSourceType q, float max_range)
+{
+	Eigen::Matrix&lt;float, 6, 1&gt; nn_node_bounds;
+
+	nn_node_bounds = octree_.nearestOctreeNode(q);
+
+	int nn_vid = nearestVoxel(q, nn_node_bounds, max_range);
+
+	Eigen::Vector3d c = (*centroid_)[nn_vid];
+	double min_dist = sqrt((q.x - c(0)) * (q.x - c(0)) + (q.y - c(1)) * (q.y - c(1)) + (q.z - c(2)) * (q.z - c(2)));
 
 	if (min_dist &gt;= max_range)
 		return DBL_MAX;
 
-	return static_cast&lt;double&gt;(min_dist);
+	return min_dist;
+
 }
 
 template &lt;typename PointSourceType&gt;
@@ -594,9 +550,7 @@ void VoxelGrid&lt;PointSourceType&gt;::updateBoundaries(float max_x, float max_y, floa
 	new_min_y = (min_y_ &lt;= min_y) ? min_y_ : min_y;
 	new_min_z = (min_z_ &lt;= min_z) ? min_z_ : min_z;
 
-	/* If the boundaries change, then we need to extend the
-	 * list of voxels as well as the octree
-	 */
+	/* If the boundaries change, then we need to extend the list of voxels */
 	if (new_max_x &gt; max_x_ || new_max_y &gt; max_y_ || new_max_z &gt; max_z_ ||
 			new_min_x &lt; min_x_ || new_min_y &lt; min_y_ || new_min_z &lt; min_z_) {
 
@@ -617,14 +571,14 @@ void VoxelGrid&lt;PointSourceType&gt;::updateBoundaries(float max_x, float max_y, floa
 		int real_min_bz = min_b_z;
 
 		/* Max bounds round toward plus infinity */
-		max_b_x = (max_b_x &lt; 0) ? (-(- max_b_x) / MAX_BX_) * MAX_BX_ : ((max_b_x - 1) / MAX_BX_ + 1) * MAX_BX_;
-		max_b_y = (max_b_y &lt; 0) ? (-(- max_b_y) / MAX_BY_) * MAX_BY_ : ((max_b_y - 1) / MAX_BY_ + 1) * MAX_BY_;
-		max_b_z = (max_b_z &lt; 0) ? (-(- max_b_z) / MAX_BZ_) * MAX_BZ_ : ((max_b_z - 1) / MAX_BZ_ + 1) * MAX_BZ_;
+		max_b_x = roundUp(max_b_x, MAX_BX_);
+		max_b_y = roundUp(max_b_y, MAX_BY_);
+		max_b_z = roundUp(max_b_z, MAX_BZ_);
 
 		/* Min bounds round toward minus infinity */
-		min_b_x = (min_b_x &lt; 0) ? (-((- min_b_x - 1) / MAX_BX_ + 1)) * MAX_BX_ : (min_b_x / MAX_BX_) * MAX_BX_;
-		min_b_y = (min_b_y &lt; 0) ? (-((- min_b_y - 1) / MAX_BY_ + 1)) * MAX_BY_ : (min_b_y / MAX_BY_) * MAX_BY_;
-		min_b_z = (min_b_z &lt; 0) ? (-((- min_b_z - 1) / MAX_BZ_ + 1)) * MAX_BZ_ : (min_b_z / MAX_BZ_) * MAX_BZ_;
+		min_b_x = roundDown(min_b_x, MAX_BX_);
+		min_b_y = roundDown(min_b_y, MAX_BY_);
+		min_b_z = roundDown(min_b_z, MAX_BZ_);
 
 		if (max_b_x &gt; max_b_x_ || max_b_y &gt; max_b_y_ || max_b_z &gt; max_b_z_ ||
 				min_b_x &lt; min_b_x_ || min_b_y &lt; min_b_y_ || min_b_z &lt; min_b_z_) {
@@ -634,14 +588,20 @@ void VoxelGrid&lt;PointSourceType&gt;::updateBoundaries(float max_x, float max_y, floa
 
 			int voxel_num = vgrid_x * vgrid_y * vgrid_z;
 
-			std::vector&lt;Eigen::Vector3d&gt; new_centroid(voxel_num);
-			std::vector&lt;Eigen::Matrix3d&gt; new_covariance(voxel_num);
-			std::vector&lt;Eigen::Matrix3d&gt; new_icovariance(voxel_num);
-			std::vector&lt;std::vector&lt;int&gt; &gt; points_id(voxel_num);
-			std::vector&lt;int&gt; points_per_voxel(voxel_num, 0);
+			boost::shared_ptr&lt;std::vector&lt;Eigen::Vector3d&gt; &gt; old_centroid = centroid_;
+			boost::shared_ptr&lt;std::vector&lt;Eigen::Matrix3d&gt; &gt; old_icovariance = icovariance_;
+			boost::shared_ptr&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; old_points_id = points_id_;
+			boost::shared_ptr&lt;std::vector&lt;int&gt; &gt; old_points_per_voxel = points_per_voxel_;
 
-			std::vector&lt;Eigen::Vector3d&gt; new_tmp_centroid(voxel_num);
-			std::vector&lt;Eigen::Matrix3d&gt; new_tmp_cov(voxel_num);
+			boost::shared_ptr&lt;std::vector&lt;Eigen::Vector3d&gt; &gt; old_tmp_centroid = tmp_centroid_;
+			boost::shared_ptr&lt;std::vector&lt;Eigen::Matrix3d&gt; &gt; old_tmp_cov = tmp_cov_;
+
+			centroid_ = boost::make_shared&lt;std::vector&lt;Eigen::Vector3d&gt; &gt;(voxel_num);
+			icovariance_ = boost::make_shared&lt;std::vector&lt;Eigen::Matrix3d&gt; &gt;(voxel_num);
+			points_id_ = boost::make_shared&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt;(voxel_num);
+			points_per_voxel_ = boost::make_shared&lt;std::vector&lt;int&gt; &gt;(voxel_num, 0);
+			tmp_centroid_ = boost::make_shared&lt;std::vector&lt;Eigen::Vector3d&gt; &gt;(voxel_num);
+			tmp_cov_ = boost::make_shared&lt;std::vector&lt;Eigen::Matrix3d&gt; &gt;(voxel_num);
 
 			// Move the old non-empty voxels to the new list of voxels
 
@@ -658,37 +618,19 @@ void VoxelGrid&lt;PointSourceType&gt;::updateBoundaries(float max_x, float max_y, floa
 											min_b_x, min_b_y, min_b_z,
 											vgrid_x, vgrid_y, vgrid_z);
 
-						if (points_id_[old_id].size() &gt; 0) {
-							points_per_voxel[new_id] = points_per_voxel_[old_id];
-							new_centroid[new_id] = centroid_[old_id];
-							new_covariance[new_id] = covariance_[old_id];
-							new_icovariance[new_id] = icovariance_[old_id];
-							points_id[new_id] = points_id_[old_id];
+						if ((*old_points_id)[old_id].size() &gt; 0) {
+							(*points_per_voxel_)[new_id] = (*old_points_per_voxel)[old_id];
+							(*centroid_)[new_id] = (*old_centroid)[old_id];
+							(*icovariance_)[new_id] = (*old_icovariance)[old_id];
+							(*points_id_)[new_id] = (*old_points_id)[old_id];
 
-							new_tmp_centroid[new_id] = tmp_centroid_[old_id];
-							new_tmp_cov[new_id] = tmp_cov_[old_id];
+							(*tmp_centroid_)[new_id] = (*old_tmp_centroid)[old_id];
+							(*tmp_cov_)[new_id] = (*old_tmp_cov)[old_id];
 						}
 					}
 				}
 			}
 
-			centroid_.clear();
-			covariance_.clear();
-			icovariance_.clear();
-			points_id_.clear();
-			points_per_voxel_.clear();
-			tmp_centroid_.clear();
-			tmp_cov_.clear();
-
-			centroid_ = new_centroid;
-			covariance_ = new_covariance;
-			icovariance_ = new_icovariance;
-			points_id_ = points_id;
-			points_per_voxel_ = points_per_voxel;
-			tmp_centroid_ = new_tmp_centroid;
-			tmp_cov_ = new_tmp_cov;
-
-
 			// Update boundaries of voxels
 			max_b_x_ = max_b_x;
 			max_b_y_ = max_b_y;
@@ -727,6 +669,7 @@ void VoxelGrid&lt;PointSourceType&gt;::updateBoundaries(float max_x, float max_y, floa
 	}
 }
 
+
 template &lt;typename PointSourceType&gt;
 void VoxelGrid&lt;PointSourceType&gt;::update(typename pcl::PointCloud&lt;PointSourceType&gt;::Ptr new_cloud)
 {
@@ -735,7 +678,6 @@ void VoxelGrid&lt;PointSourceType&gt;::update(typename pcl::PointCloud&lt;PointSourceType
 
 	float new_max_x, new_max_y, new_max_z;
 	float new_min_x, new_min_y, new_min_z;
-	int shift_x, shift_y, shift_z;
 
 	// Find boundaries of the new point cloud
 	findBoundaries(new_cloud, new_max_x, new_max_y, new_max_z, new_min_x, new_min_y, new_min_z);
@@ -752,6 +694,20 @@ void VoxelGrid&lt;PointSourceType&gt;::update(typename pcl::PointCloud&lt;PointSourceType
 	 * as well as inverse covariance matrixes */
 	updateVoxelContent(new_cloud);
 
+	/* Update octree */
+	std::vector&lt;Eigen::Vector3i&gt; new_voxel_id(new_cloud-&gt;points.size());
+
+	for (int i = 0; i &lt; new_cloud-&gt;points.size(); i++) {
+		Eigen::Vector3i &amp;vid = new_voxel_id[i];
+		PointSourceType p = new_cloud-&gt;points[i];
+
+		vid(0) = static_cast&lt;int&gt;(floor(p.x / voxel_x_));
+		vid(1) = static_cast&lt;int&gt;(floor(p.y / voxel_y_));
+		vid(2) = static_cast&lt;int&gt;(floor(p.z / voxel_z_));
+	}
+
+	octree_.update(new_voxel_id, new_cloud);
+
 	*source_cloud_ += *new_cloud;
 }
 
@@ -767,43 +723,44 @@ void VoxelGrid&lt;PointSourceType&gt;::updateVoxelContent(typename pcl::PointCloud&lt;Poi
 		int vy = static_cast&lt;int&gt;(floor(p.y / voxel_y_));
 		int vz = static_cast&lt;int&gt;(floor(p.z / voxel_z_));
 		int vid = voxelId(vx, vy, vz, min_b_x_, min_b_y_, min_b_z_, vgrid_x_, vgrid_y_, vgrid_z_);
-		std::vector&lt;int&gt; &amp;tmp_pid = points_id_[vid];
+		std::vector&lt;int&gt; &amp;tmp_pid = (*points_id_)[vid];
 
 		if (tmp_pid.size() == 0) {
-			centroid_[vid].setZero();
-			tmp_cov_[vid].setIdentity();
-			tmp_centroid_[vid].setZero();
+			(*centroid_)[vid].setZero();
+			(*tmp_cov_)[vid].setIdentity();
+			(*tmp_centroid_)[vid].setZero();
 		}
 
-		tmp_centroid_[vid] += p3d;
-		tmp_cov_[vid] += p3d * p3d.transpose();
-		points_id_[vid].push_back(total_points_num + i);
+		(*tmp_centroid_)[vid] += p3d;
+		(*tmp_cov_)[vid] += p3d * p3d.transpose();
+		(*points_id_)[vid].push_back(total_points_num + i);
 
 		// Update centroids
-		int ipoint_num = points_id_[vid].size();
-		centroid_[vid] = tmp_centroid_[vid] / static_cast&lt;double&gt;(ipoint_num);
-		points_per_voxel_[vid] = ipoint_num;
+		int ipoint_num = (*points_id_)[vid].size();
+		(*centroid_)[vid] = (*tmp_centroid_)[vid] / static_cast&lt;double&gt;(ipoint_num);
+		(*points_per_voxel_)[vid] = ipoint_num;
 
 
 		// Update covariance
 		double point_num = static_cast&lt;double&gt;(ipoint_num);
-		Eigen::Vector3d pt_sum = tmp_centroid_[vid];
+		Eigen::Vector3d pt_sum = (*tmp_centroid_)[vid];
 
 		// Update  centroids
-		centroid_[vid] = tmp_centroid_[vid] / point_num;
+		(*centroid_)[vid] = (*tmp_centroid_)[vid] / point_num;
 
 		if (ipoint_num &gt;= min_points_per_voxel_) {
-			covariance_[vid] = (tmp_cov_[vid] - 2.0 * (pt_sum * centroid_[vid].transpose())) / point_num + centroid_[vid] * centroid_[vid].transpose();
-			covariance_[vid] *= (point_num - 1.0) / point_num;
+			Eigen::Matrix3d covariance;
+			covariance = ((*tmp_cov_)[vid] - 2.0 * (pt_sum * (*centroid_)[vid].transpose())) / point_num + (*centroid_)[vid] * (*centroid_)[vid].transpose();
+			covariance *= (point_num - 1.0) / point_num;
 
-			SymmetricEigensolver3x3 sv(covariance_[vid]);
+			SymmetricEigensolver3x3 sv(covariance);
 
 			sv.compute();
 			Eigen::Matrix3d evecs = sv.eigenvectors();
 			Eigen::Matrix3d evals = sv.eigenvalues().asDiagonal();
 
 			if (evals(0, 0) &lt; 0 || evals(1, 1) &lt; 0 || evals(2, 2) &lt;= 0) {
-				points_per_voxel_[vid] = -1;
+				(*points_per_voxel_)[vid] = -1;
 				continue;
 			}
 
@@ -816,10 +773,10 @@ void VoxelGrid&lt;PointSourceType&gt;::updateVoxelContent(typename pcl::PointCloud&lt;Poi
 					evals(1, 1) = min_cov_eigvalue;
 				}
 
-				covariance_[vid] = evecs * evals * evecs.inverse();
+				covariance = evecs * evals * evecs.inverse();
 			}
 
-			icovariance_[vid] = covariance_[vid].inverse();
+			(*icovariance_)[vid] = covariance.inverse();
 		}
 	}
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f5aa715b39eb9fd45968088805a09666d85afda0" author="AMC">
		<msg>Added Autoexposure, documentation to the Baumer camera node</msg>
		<modified_files>
			<file old_path="ros\src\sensing\drivers\camera\packages\baumer\nodes\vlg22\src\bgapi_init.cpp" new_path="ros\src\sensing\drivers\camera\packages\baumer\nodes\vlg22\src\bgapi_init.cpp" added_lines="59" deleted_lines="18">
				<diff>@@ -1,9 +1,8 @@
+#include &lt;bgapidef.hpp&gt;
 #include "bgapi.hpp"
 #include "bgapi_init.h"
 
-using namespace std;
-
-int init_systems(int * system_count, vector&lt;BGAPI::System*&gt; * externppSystem)
+int init_systems(int * system_count, std::vector&lt;BGAPI::System*&gt; * externppSystem)
 {
 	BGAPI_RESULT res = BGAPI_RESULT_FAIL;
 	int i = 0;
@@ -88,9 +87,6 @@ bool setup_cameras(std::vector&lt;BGAPI::Camera*&gt; &amp; cameraObjects, std::string came
 		}
 		ROS_INFO( "Flip ok.\n" );
 
-	//PIXEL FORMAT
-	// --------
-
 		BGAPI_FeatureState state;
 		state.cbSize = sizeof( BGAPI_FeatureState );
 
@@ -157,9 +153,8 @@ bool setup_cameras(std::vector&lt;BGAPI::Camera*&gt; &amp; cameraObjects, std::string came
 			}
 			ROS_INFO("setPixelFormat =&gt; (ID %x:%s | %d)\n" , pformat.iPixelFormat, (char*)pformat.sName, pformat.iPixelBits);
 
-
 			// check result
-			res = cameraObjects[i] -&gt; getPixelFormat(formatlist.current, &amp;state ,&amp;pixellist) ;
+			res = cameraObjects[i]-&gt; getPixelFormat(formatlist.current, &amp;state ,&amp;pixellist) ;
 			if(res != BGAPI_RESULT_OK)
 			{
 				ROS_INFO("BGAPI::Camera::getPixelFormat2 error:%d\n" ,res) ;
@@ -173,22 +168,68 @@ bool setup_cameras(std::vector&lt;BGAPI::Camera*&gt; &amp; cameraObjects, std::string came
 				return false;
 			}
 		}
-	//PIXEL FORMAT
+
+		res = cameraObjects[i]-&gt;setHDREnable( true );
+		if (res != BGAPI_RESULT_OK)
+		{
+			ROS_INFO("Camera-&gt;setHDREnable errorcode: %d\n", res);
+		}
+		else
+		{
+			ROS_INFO("HDR Mode enabled");
+		}
+
+		BGAPIX_TypeRangeINT rangedint;
+		rangedint.cbSize = sizeof( BGAPIX_TypeRangeINT );
+		res = cameraObjects[i]-&gt;getExposure( &amp;state, &amp;rangedint );
+		if( res != BGAPI_RESULT_OK )
+		{
+			ROS_INFO("BGAPI::Camera::getExposure Errorcode: %d", res);
+		}
+		else
+		{
+			ROS_INFO("Current Exposure: %d\n", rangedint.current);
+			ROS_INFO("Possible value range: %d to %d\n", rangedint.minimum, rangedint.maximum);
+		}
+
+		int exposurevalue = VLG22_DEFAULT_EXPOSURE;
+		res = cameraObjects[i]-&gt;setExposure( exposurevalue );
+		if( res != BGAPI_RESULT_OK )
+		{
+			ROS_INFO("BGAPI::Camera::setExposure errorcode %d\n", res);
+
+		}
+
+		BGAPIX_TypeRangeFLOAT gainrange;
+		gainrange.cbSize = sizeof( BGAPIX_TypeRangeFLOAT );
+		res = cameraObjects[i]-&gt;getGain( &amp;state, &amp;gainrange );
+		if( res != BGAPI_RESULT_OK )
+		{
+			ROS_INFO("BGAPI::Camera::getGain Errorcode: %d\n", res);
+		}
+
+		ROS_INFO("Current Gain: %g max:%g min:%g\n", gainrange.current, gainrange.maximum, gainrange.minimum);
+
+		res = cameraObjects[i]-&gt;setGain( gainrange.maximum/4 );
+		if( res != BGAPI_RESULT_OK )
+		{
+			printf("BGAPI::Camera::setGain Errorcode: %d\n", res);
+		}
+
 	}
 	return true;
 }
 
-int init_cameras( int system_count, vector&lt;BGAPI::System*&gt; * externppSystem, int * pCurrSystem, int&amp; camera_count, std::vector&lt;BGAPI::Camera*&gt;&amp; cameraObjects)
+int init_cameras( int system_count, std::vector&lt;BGAPI::System*&gt; * externppSystem, int * pCurrSystem, int&amp; camera_count, std::vector&lt;BGAPI::Camera*&gt;&amp; cameraObjects)
 {
 	BGAPI_RESULT res = BGAPI_RESULT_FAIL;
 	int cam = 0;
 	camera_count = 0;
-	vector&lt;int&gt; cameras;
-	vector&lt;int&gt;::iterator camIter;
+	std::vector&lt;int&gt; cameras;
+	std::vector&lt;int&gt;::iterator camIter;
 	BGAPI_FeatureState state;
 	BGAPIX_CameraInfo cameradeviceinfo;
-	int inputVal = 0;
-	vector&lt;BGAPI::System*&gt;::iterator systemIter;
+	std::vector&lt;BGAPI::System*&gt;::iterator systemIter;
 	ROS_INFO( "START COUNTING\n" );
 	
 	for( systemIter = externppSystem-&gt;begin(); systemIter != externppSystem-&gt;end(); systemIter++ )
@@ -266,10 +307,10 @@ int init_cameras( int system_count, vector&lt;BGAPI::System*&gt; * externppSystem, int
 	return res;
 }
 
-int release_systems( vector&lt;BGAPI::System*&gt; * externppSystem )
+int release_systems( std::vector&lt;BGAPI::System*&gt; * externppSystem )
 {
 	BGAPI_RESULT res = BGAPI_RESULT_FAIL;
-	vector&lt;BGAPI::System*&gt;::iterator systemIter;
+	std::vector&lt;BGAPI::System*&gt;::iterator systemIter;
 
 	for( systemIter = externppSystem-&gt;begin(); systemIter != externppSystem-&gt;end(); systemIter++ )
 	{
@@ -282,10 +323,10 @@ int release_systems( vector&lt;BGAPI::System*&gt; * externppSystem )
 	externppSystem-&gt;clear();
 	return res;
 }
-int release_images( vector&lt;BGAPI::Image*&gt; * ppImage )
+int release_images( std::vector&lt;BGAPI::Image*&gt; * ppImage )
 {
 	BGAPI_RESULT res = BGAPI_RESULT_FAIL;
-	vector&lt;BGAPI::Image*&gt;::iterator imageIter;
+	std::vector&lt;BGAPI::Image*&gt;::iterator imageIter;
 	bool tmpExtern = false;
 	unsigned char* tmpBuffer = NULL;
 	
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\camera\packages\baumer\nodes\vlg22\src\bgapi_init.h" new_path="ros\src\sensing\drivers\camera\packages\baumer\nodes\vlg22\src\bgapi_init.h" added_lines="6" deleted_lines="3">
				<diff>@@ -7,6 +7,7 @@
 
 #include &lt;stdlib.h&gt;
 #include &lt;stdio.h&gt;
+#include &lt;string&gt;
 
 // OpenCV includes
 #include &lt;cv.h&gt;
@@ -23,10 +24,12 @@
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 
-using namespace std;
+#define VLG22_DEFAULT_EXPOSURE 20000
+#define VLG22_MAX_EXPOSURE 150000
+#define VLG22_MIN_EXPOSURE 5000
 
-int init_systems(int * system_count, vector&lt;BGAPI::System*&gt; * externppSystem);
-int init_cameras( int system_count, vector&lt;BGAPI::System*&gt; * externppSystem, int * pCurrSystem, int&amp; numCameras, std::vector&lt;BGAPI::Camera*&gt;&amp; cameraObjects);
+int init_systems(int* system_count, std::vector&lt;BGAPI::System*&gt; * externppSystem);
+int init_cameras(int system_count, std::vector&lt;BGAPI::System*&gt; * externppSystem, int * pCurrSystem, int&amp; numCameras, std::vector&lt;BGAPI::Camera*&gt;&amp; cameraObjects);
 int release_systems( std::vector&lt;BGAPI::System*&gt; * ppSystem );
 int release_images( std::vector&lt;BGAPI::Image*&gt; * ppImage );
 bool setup_cameras(std::vector&lt;BGAPI::Camera*&gt; &amp; cameraObjects, std::string camera_pixel_format_str);
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\camera\packages\baumer\nodes\vlg22\src\vlg22_main.cpp" new_path="ros\src\sensing\drivers\camera\packages\baumer\nodes\vlg22\src\vlg22_main.cpp" added_lines="273" deleted_lines="74">
				<diff>@@ -1,34 +1,22 @@
+#include &lt;bgapidef.hpp&gt;
 #include "bgapi.hpp"
 #include "bgapi_init.h"
 
-int main(int argc, char **argv)
+/*
+ * Initialize cameras
+ * @return Returns True if the camera systems and at least one camera was correctly initialized
+ */
+bool baumer_startup(std::vector&lt;BGAPI::System*&gt;&amp; ppSystem,
+                    std::vector&lt;BGAPI::System*&gt;::iterator&amp; systemIter,
+                    BGAPI_RESULT&amp; res,
+                    std::vector&lt;BGAPI::Camera*&gt;&amp; cameraPointers,
+                    std::vector&lt;BGAPI::Image*&gt;&amp; imagePointers,
+                    int&amp; camera_num,
+                    int&amp; system_count,
+                    BGAPI::Image* pImage)
 {
-	ros::init(argc, argv, "baumer_vlg22");
-	ros::NodeHandle n;
-	ros::NodeHandle private_nh("~");
-	ros::Publisher camera_info_pub;
-
-	int system_count = 0;
 	int currSystem = 0;
 	int i = 0;
-	int camera_num = 0;
-
-	vector&lt;BGAPI::System*&gt; ppSystem;
-	vector&lt;BGAPI::System*&gt;::iterator systemIter;
-
-	BGAPI_RESULT res = BGAPI_RESULT_FAIL;
-	std::vector&lt;BGAPI::Camera*&gt; cameraPointers;
-	std::vector&lt;BGAPI::Image*&gt; imagePointers;
-
-	double fps;
-	if (private_nh.getParam("fps", fps))
-	{
-		ROS_INFO("fps set to %.2f", fps);
-	} else {
-		fps = 15.0;
-		ROS_INFO("No param received, defaulting to %.2f", fps);
-	}
-
 	//try to initialize baumer system
 	res = init_systems( &amp;system_count, &amp;ppSystem );
 	if( res != BGAPI_RESULT_OK )
@@ -42,6 +30,7 @@ int main(int argc, char **argv)
 	if( res != BGAPI_RESULT_OK )
 	{
 		ROS_INFO("init_camera Errorcode: %d\n", res);
+		return false;
 	}
 
 	if (camera_num &gt; 0)
@@ -51,17 +40,16 @@ int main(int argc, char **argv)
 	else
 	{
 		ROS_INFO("No cameras detected, finalizing...");
-		return -1;
+		return false;
 	}
 
 	//set all cameras to BayerRGB8 to save ethernet bandwidth
 	if(!setup_cameras(cameraPointers,  "BayerRG8"))
 	{
 		ROS_INFO("Could not setup cameras for capture. Finalizing...");
-		return -1;
+		return false;
 	}
 
-	BGAPI::Image* pImage = NULL;
 	//create an image
 	res = BGAPI::createImage( &amp;pImage );
 	if( res != BGAPI_RESULT_OK )
@@ -78,26 +66,257 @@ int main(int argc, char **argv)
 	if (!start_cameras(cameraPointers))
 	{
 		ROS_INFO("Could not create images for capture. Finalizing...");
-		return -1;
+		return false;
 	}
+	return true;
+}
 
-	//create ros camera publishers
-	ros::Publisher pub[camera_num];
+/*!
+ * brightness in this program is defined as the ratio between the pixels with higher values over the lowest ones.
+ * Ratio is calculated splitting the histogram in half, and dividing the number of pixels in the seconf (higher) part
+ * of the histogram (brightness higher than 128) over the total number of pixels.
+ * @param in_image
+ * @return
+ */
+float get_image_brightness_percent(cv::Mat&amp; in_image)
+{
+	cv::Mat histogram;
+	int histSize = 16;
+	float range[] = { 0, 16 } ;
+	const float* histRange = { range };
+	bool uniform = true; bool accumulate = false;
+
+	cv::calcHist( &amp;in_image, 1, 0, cv::Mat(), histogram, 1, &amp;histSize, &amp;histRange, uniform, accumulate );
 
-	for (int i = 0; i &lt; camera_num; i++)
+	float high_half_samples = 0;
+	float total_samples = 0;
+
+	for (int k =0; k &lt;= histSize; k++)
 	{
-		std::ostringstream topic;
-		topic &lt;&lt; "image_raw";
-		if (camera_num &gt; 1)
+		if (k &gt;= histSize/2)
+			high_half_samples+=histogram.at&lt;float&gt;(k);
+
+		total_samples+=histogram.at&lt;float&gt;(k);
+	}
+
+	float brightness;
+	if(high_half_samples == 0)
+		brightness = 0.0;
+	else
+		brightness = high_half_samples/total_samples;
+
+#ifdef VLG22_DEBUG
+	int hist_w = 512; int hist_h = 400;
+	int bin_w = cvRound( (double) hist_w/histSize );
+	cv::Mat histImage( hist_h, hist_w, CV_8UC3, cv::Scalar( 0,0,0) );
+	/// Normalize the result to [ 0, histImage.rows ]
+	cv::normalize(histogram, histogram, 0, histImage.rows, cv::NORM_MINMAX, -1, cv::Mat() );
+	for( int j = 1; j &lt; histSize; j++ )
+	{
+		total_samples+=histogram.at&lt;float&gt;(j);
+		cv::line( histImage, cv::Point( bin_w*(j-1), hist_h - cvRound(histogram.at&lt;float&gt;(j-1)) ),
+		          cv::Point( bin_w*(j), hist_h - cvRound(histogram.at&lt;float&gt;(j)) ),
+		          cv::Scalar( 255, 255, 255), 2, 8, 0  );
+	}
+
+	std::cout &lt;&lt; high_half_samples &lt;&lt; "/" &lt;&lt; total_samples &lt;&lt; "==&gt;" &lt;&lt; brightness &lt;&lt; std::endl;
+	/// Display
+	cv::imshow("Histogram", histImage );
+	cv::waitKey(1);
+#endif
+
+	return brightness;
+
+}
+
+
+/*!
+ * Changes, if possible, the camera time exposure.
+ * @param camera_pointer Valid pointer of the camera to change.
+ * @param exposure New exposure
+ */
+void baumer_change_exposure(BGAPI::Camera* camera_pointer, int exposure)
+{
+	if (camera_pointer == NULL)
+		return;
+
+	BGAPI_FeatureState state;
+	state.cbSize = sizeof( BGAPI_FeatureState );
+
+	BGAPI_RESULT res = BGAPI_RESULT_FAIL;
+	BGAPIX_TypeRangeINT rangedint;
+
+	rangedint.cbSize = sizeof( BGAPIX_TypeRangeINT );
+	res = camera_pointer-&gt;getExposure( &amp;state, &amp;rangedint );
+	if( res != BGAPI_RESULT_OK )
+	{
+		ROS_INFO("BGAPI::Camera::getExposure Errorcode: %d", res);
+	}
+
+	if (exposure &gt; rangedint.maximum)
+		exposure = rangedint.maximum;
+
+	if (exposure &lt; rangedint.minimum)
+		exposure = rangedint.minimum;
+
+	res = camera_pointer-&gt;setExposure( exposure );
+	if( res != BGAPI_RESULT_OK )
+	{
+		ROS_INFO("BGAPI::Camera::setExposure Errorcode: %d", res);
+	}
+
+	/*res = camera_pointer-&gt;setGain( 2.0 );
+	if( res != BGAPI_RESULT_OK )
+	{
+		printf("BGAPI::Camera::setGain Errorcode: %d\n", res);
+	}*/
+}
+
+void get_ros_params(ros::NodeHandle&amp; node_handle, int&amp; fps, double&amp; scale, double&amp; brightness)
+{
+	if (node_handle.getParam("fps", fps))
+	{
+		ROS_INFO("fps set to %d", fps);
+	}
+	else
+	{
+		fps = 20;
+		ROS_INFO("No param received, defaulting fps to %df", fps);
+	}
+
+	if (node_handle.getParam("scale", scale))
+	{
+		if (scale &gt; 1.0 || scale &lt; 0.01)
 		{
-			topic &lt;&lt; i;
+			scale = 1.0;
 		}
-		pub[i] = n.advertise&lt;sensor_msgs::Image&gt;(topic.str(), 100);
+		ROS_INFO("scale set to %.2f", scale);
+	}
+	else
+	{
+		scale = 0.5;
+		ROS_INFO("No param received, defaulting scale to %.2f", scale);
+	}
+
+	if (node_handle.getParam("brightness", brightness))
+	{
+		if (brightness &gt; 1.0 || brightness &lt; 0.01)
+		{
+			brightness = 0.7;
+		}
+		ROS_INFO("brightness set to %.2f", brightness);
+	}
+	else
+	{
+		brightness = 0.7;
+		ROS_INFO("No param received, defaulting brightness to %.2f", brightness);
+	}
+}
+
+void ros_init_publishers(ros::NodeHandle node_handle, ros::Publisher publishers[], int camera_num)
+{
+	for (int i = 0; i &lt; camera_num; i++) {
+		std::string topic(std::string("image_raw"));
+
+		if (camera_num &gt; 1) {
+			topic = "camera" + std::to_string(i) + "/" + topic;
+		}
+		publishers[i] = node_handle.advertise&lt;sensor_msgs::Image&gt;(topic, 100);
+		ROS_INFO("Publishing.. %s", topic.c_str());
+	}
+}
+
+sensor_msgs::Image ros_prepare_image(int count, cv::Mat image)
+{
+	//ROS publish*******************
+	sensor_msgs::Image msg;
+
+	msg.header.seq = count;
+	msg.header.frame_id = "camera";
+	msg.header.stamp.sec = ros::Time::now().sec;
+	msg.header.stamp.nsec = ros::Time::now().nsec;
+	msg.height = image.size().height;
+	msg.width = image.size().width;
+	msg.encoding = "rgb8";
+	msg.step = image.cols * image.elemSize();
+
+	size_t image_size = image.rows * image.cols * image.elemSize();
+
+	msg.data.resize(image_size);
+	memcpy(msg.data.data(), image.data, image_size);
+
+	return msg;
+}
+
+void adjust_exposure(BGAPI::Camera* camera_pointer,
+                     cv::Mat&amp; bayer_image,
+                     float&amp; current_brightness,
+                     float threshold_brightness,
+                     int&amp; prev_exposure,
+                     int&amp; exposure,
+                     int exposure_delta)
+{
+	current_brightness = get_image_brightness_percent(bayer_image);
+
+	if (current_brightness &lt; threshold_brightness)
+	{
+		ROS_INFO("increasing exposure");
+		exposure = prev_exposure + exposure_delta;
+		if (exposure &gt;= VLG22_MAX_EXPOSURE)
+			exposure = VLG22_MAX_EXPOSURE;
+		baumer_change_exposure(camera_pointer, exposure);
 	}
 
+	if (current_brightness == 1.0)
+	{
+		ROS_INFO("reducing exposure");
+		exposure = prev_exposure - exposure_delta;
+		if (exposure &lt;= VLG22_MIN_EXPOSURE)
+			exposure = VLG22_MIN_EXPOSURE;
+		baumer_change_exposure(camera_pointer, exposure);
+	}
+	prev_exposure = exposure;
+}
+
+int main(int argc, char **argv)
+{
+	ros::init(argc, argv, "baumer_vlg22");
+	ros::NodeHandle n;
+	ros::NodeHandle private_nh("~");
+	ros::Publisher camera_info_pub;
+
+	int system_count = 0;
+	int camera_num = 0;
+
+	int fps;
+	double brightness;
+	double scale;
+
+	get_ros_params(private_nh, fps, scale, brightness);
+
+	std::vector&lt;BGAPI::System*&gt; ppSystem;
+	std::vector&lt;BGAPI::System*&gt;::iterator systemIter;
+
+	BGAPI_RESULT res = BGAPI_RESULT_FAIL;
+	std::vector&lt;BGAPI::Camera*&gt; cameraPointers;
+	std::vector&lt;BGAPI::Image*&gt; imagePointers;
+	BGAPI::Image* pImage = NULL;
+
+	if(!baumer_startup(ppSystem, systemIter, res, cameraPointers, imagePointers, camera_num, system_count, pImage))
+	{
+		return -1;
+	}
+
+	//create ros camera publishers
+	ros::Publisher pub[camera_num];
+	ros_init_publishers(n, pub, camera_num);
+
 	int receiveTimeout = 1000;
 	int count = 0;
 	ros::Rate loop_rate(fps); // Hz
+	float current_brightness = 0.0;
+	int prev_exposure = VLG22_DEFAULT_EXPOSURE;
+	const int exposure_delta = 1000;
 	while (ros::ok())
 	{
 		unsigned char* imagebuffer = NULL;
@@ -106,9 +325,9 @@ int main(int argc, char **argv)
 		int width = 0;
 		int height = 0;
 
+		int exposure = VLG22_DEFAULT_EXPOSURE;
 		for (unsigned int i = 0; i &lt; cameraPointers.size(); i++)
 		{
-
 			res = cameraPointers[i]-&gt;getImage( &amp;pImage, receiveTimeout );
 			if( res != BGAPI_RESULT_OK )
 			{
@@ -116,7 +335,7 @@ int main(int argc, char **argv)
 			}
 			else
 			{
-			        free(imagebuffer);
+				free(imagebuffer);
 				(pImage)-&gt;get( &amp;imagebuffer );
 				(pImage)-&gt;getNumber( &amp;swc, &amp;hwc );
 
@@ -126,41 +345,21 @@ int main(int argc, char **argv)
 					ROS_INFO("BGAPI::Image::getSize Errorcode: %d", res);
 				}
 
-				//receive Bayer Image, convert to Color 3 channels
-				cv::Mat mat(cv::Size(width, height), CV_8UC1, imagebuffer);
-				//cv::flip(mat, mat, -1);
-				cv::Mat dest(cv::Size(width, height), CV_8UC3);
-				cv::cvtColor(mat, dest, CV_BayerBG2RGB);
-				//to fix aspect ratio and to avoid stretching we crop the image
-				//after conversion of the bayer grid
-				//to mantain ratio of 1.33 we need to remove 2*297 from the wide
-				//image, so we use a roi to crop the 2048x1084 image
-				cv::Rect roi(297,0,1445,1084);//for [4:3] aspect ratio. 297 half of the width to remove
-				//cv::Rect roi(56,0,1927,1084);//for [16:9] aspect ratio. 56 half of the width to remove
-				cv::Mat tmp = dest(roi);
-				cv::Mat cropped = tmp.clone();
-				int w = 800;//fixed
-				int h = 600;//fixed 
-				cv::resize(cropped, cropped, cv::Size(w, h));
-
-				//cv::imshow("window", dest);
-				//cv::waitKey(2);
-				//ROS publish*******************
-				sensor_msgs::Image msg;
-
-				msg.header.seq = count;
-				msg.header.frame_id = "camera";
-				msg.header.stamp.sec = ros::Time::now().sec;
-				msg.header.stamp.nsec = ros::Time::now().nsec;
-				msg.height = cropped.size().height;
-				msg.width = cropped.size().width;
-				msg.encoding = "rgb8";
-				msg.step = cropped.cols * cropped.elemSize();
-
-				size_t image_size = cropped.rows * cropped.cols * cropped.elemSize();
-
-				msg.data.resize(image_size);
-				memcpy(msg.data.data(), cropped.data, image_size);
+				cv::Mat bayer_image(cv::Size(width, height), CV_8UC1, imagebuffer);
+				cv::Mat color_image(cv::Size(width, height), CV_8UC3);
+				cv::cvtColor(bayer_image, color_image, CV_BayerBG2RGB);
+				cv::Mat resized_color_image;
+				cv::resize(color_image, resized_color_image, cv::Size(), scale, scale);
+
+				adjust_exposure(cameraPointers[i],
+				                bayer_image,
+				                current_brightness,
+				                brightness,
+				                prev_exposure,
+				                exposure,
+				                exposure_delta);
+
+				sensor_msgs::Image msg = ros_prepare_image(count, resized_color_image);
 
 				pub[i].publish(msg);
 				res = cameraPointers[i]-&gt;setImage( pImage );
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cd928df6105b0afde4447958217fc14f047f29fc" author="Yamato ANDO">
		<msg>predict moving distance using pointcloud timestamp</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="13" deleted_lines="15">
				<diff>@@ -367,6 +367,15 @@ static double wrapToPmPi(double a_angle_rad)
   return wrapToPm(a_angle_rad, M_PI);
 }
 
+static double calcDiffForRadian(const double lhs_rad, const double rhs_rad)
+{
+  double diff_rad = lhs_rad - rhs_rad;
+  if(diff_rad &gt;= M_PI)
+     diff_rad = diff_rad - 2*M_PI;
+  else if(diff_rad &lt; -M_PI)
+     diff_rad = diff_rad + 2*M_PI;
+  return diff_rad;
+}
 static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
 {
   // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
@@ -419,20 +428,9 @@ static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
   imu_yaw = wrapToPmPi(imu_yaw);
 
   static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
-  const double diff_imu_roll = imu_roll - previous_imu_roll;
-
-  const double diff_imu_pitch = imu_pitch - previous_imu_pitch;
-
-  double diff_imu_yaw;
-  if (fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
-  {
-    if (imu_yaw &gt; 0)
-      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI * 2;
-    else
-      diff_imu_yaw = -M_PI * 2 - (imu_yaw - previous_imu_yaw);
-  }
-  else
-    diff_imu_yaw = imu_yaw - previous_imu_yaw;
+  const double diff_imu_roll = calcDiffForRadian(imu_roll, previous_imu_roll);
+  const double diff_imu_pitch = calcDiffForRadian(imu_pitch, previous_imu_pitch);
+  const double diff_imu_yaw = calcDiffForRadian(imu_yaw, previous_imu_yaw);
 
   imu.header = input-&gt;header;
   imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
@@ -696,7 +694,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   diff_x = current_pose.x - previous_pose.x;
   diff_y = current_pose.y - previous_pose.y;
   diff_z = current_pose.z - previous_pose.z;
-  diff_yaw = current_pose.yaw - previous_pose.yaw;
+  diff_yaw = calcDiffForRadian(current_pose.yaw, previous_pose.yaw);
   diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);
 
   current_velocity_x = diff_x / secs;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="85" deleted_lines="60">
				<diff>@@ -168,8 +168,6 @@ static geometry_msgs::PoseStamped localizer_pose_msg;
 static ros::Publisher estimate_twist_pub;
 static geometry_msgs::TwistStamped estimate_twist_msg;
 
-static ros::Time current_scan_time;
-static ros::Time previous_scan_time;
 static ros::Duration scan_duration;
 
 static double exe_time = 0.0;
@@ -534,6 +532,8 @@ static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
   gnss_m.getRPY(current_gnss_pose.roll, current_gnss_pose.pitch, current_gnss_pose.yaw);
 
   static pose previous_gnss_pose = current_gnss_pose;
+  ros::Time current_gnss_time = input-&gt;header.stamp;
+  static ros::Time previous_gnss_time = current_gnss_time;
 
   if ((_use_gnss == 1 &amp;&amp; init_pos_set == 0) || fitness_score &gt;= 500.0)
   {
@@ -553,10 +553,23 @@ static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
 
     current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;
 
-    offset_x = current_pose.x - previous_pose.x;
-    offset_y = current_pose.y - previous_pose.y;
-    offset_z = current_pose.z - previous_pose.z;
-    offset_yaw = current_pose.yaw - previous_pose.yaw;
+    diff_x = current_pose.x - previous_pose.x;
+    diff_y = current_pose.y - previous_pose.y;
+    diff_z = current_pose.z - previous_pose.z;
+    diff_yaw = current_pose.yaw - previous_pose.yaw;
+    diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);
+
+    const double diff_time = (current_gnss_time - previous_gnss_time).toSec();
+    current_velocity   = (diff_time &gt; 0) ? (diff / diff_time) : 0;
+    current_velocity_x = (diff_time &gt; 0) ? (diff_x / diff_time) : 0;
+    current_velocity_y = (diff_time &gt; 0) ? (diff_y / diff_time) : 0;
+    current_velocity_z = (diff_time &gt; 0) ? (diff_z / diff_time) : 0;
+    angular_velocity   = (diff_time &gt; 0) ? (diff_yaw / diff_time) : 0;
+
+    current_accel   = 0.0;
+    current_accel_x = 0.0;
+    current_accel_y = 0.0;
+    current_accel_z = 0.0;
 
     init_pos_set = 1;
   }
@@ -567,6 +580,7 @@ static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
   previous_gnss_pose.roll = current_gnss_pose.roll;
   previous_gnss_pose.pitch = current_gnss_pose.pitch;
   previous_gnss_pose.yaw = current_gnss_pose.yaw;
+  previous_gnss_time = current_gnss_time;
 }
 
 static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input)
@@ -626,6 +640,17 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
   previous_pose.pitch = current_pose.pitch;
   previous_pose.yaw = current_pose.yaw;
 
+  current_velocity   = 0.0;
+  current_velocity_x = 0.0;
+  current_velocity_y = 0.0;
+  current_velocity_z = 0.0;
+  angular_velocity   = 0.0;
+
+  current_accel   = 0.0;
+  current_accel_x = 0.0;
+  current_accel_y = 0.0;
+  current_accel_z = 0.0;
+
   offset_x = 0.0;
   offset_y = 0.0;
   offset_z = 0.0;
@@ -651,6 +676,8 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
   offset_imu_odom_roll = 0.0;
   offset_imu_odom_pitch = 0.0;
   offset_imu_odom_yaw = 0.0;
+
+  init_pos_set = 1;
 }
 
 static void imu_odom_calc(ros::Time current_time)
@@ -766,7 +793,7 @@ static void imu_calc(ros::Time current_time)
   previous_time = current_time;
 }
 
-static const double wrapToPm(double a_num, const double a_max)
+static double wrapToPm(double a_num, const double a_max)
 {
   if (a_num &gt;= a_max)
   {
@@ -775,11 +802,21 @@ static const double wrapToPm(double a_num, const double a_max)
   return a_num;
 }
 
-static const double wrapToPmPi(double a_angle_rad)
+static double wrapToPmPi(const double a_angle_rad)
 {
   return wrapToPm(a_angle_rad, M_PI);
 }
 
+static double calcDiffForRadian(const double lhs_rad, const double rhs_rad)
+{
+  double diff_rad = lhs_rad - rhs_rad;
+  if(diff_rad &gt;= M_PI)
+     diff_rad = diff_rad - 2*M_PI;
+  else if(diff_rad &lt; -M_PI)
+     diff_rad = diff_rad + 2*M_PI;
+  return diff_rad;
+}
+
 static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
 {
   // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
@@ -832,20 +869,9 @@ static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
   imu_yaw = wrapToPmPi(imu_yaw);
 
   static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
-  const double diff_imu_roll = imu_roll - previous_imu_roll;
-
-  const double diff_imu_pitch = imu_pitch - previous_imu_pitch;
-
-  double diff_imu_yaw;
-  if (fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
-  {
-    if (imu_yaw &gt; 0)
-      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI * 2;
-    else
-      diff_imu_yaw = -M_PI * 2 - (imu_yaw - previous_imu_yaw);
-  }
-  else
-    diff_imu_yaw = imu_yaw - previous_imu_yaw;
+  const double diff_imu_roll = calcDiffForRadian(imu_roll, previous_imu_roll);
+  const double diff_imu_pitch = calcDiffForRadian(imu_pitch, previous_imu_pitch);
+  const double diff_imu_yaw = calcDiffForRadian(imu_yaw, previous_imu_yaw);
 
   imu.header = input-&gt;header;
   imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
@@ -888,7 +914,8 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     pcl::PointXYZ p;
     pcl::PointCloud&lt;pcl::PointXYZ&gt; filtered_scan;
 
-    current_scan_time = input-&gt;header.stamp;
+    ros::Time current_scan_time = input-&gt;header.stamp;
+    static ros::Time previous_scan_time = current_scan_time;
 
     pcl::fromROSMsg(*input, filtered_scan);
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(filtered_scan));
@@ -917,6 +944,30 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 #endif
 
     // Guess the initial gross estimation of the transformation
+    double diff_time = (current_scan_time - previous_scan_time).toSec();
+
+    if (_offset == "linear")
+    {
+      offset_x = current_velocity_x * diff_time;
+      offset_y = current_velocity_y * diff_time;
+      offset_z = current_velocity_z * diff_time;
+      offset_yaw = angular_velocity * diff_time;
+    }
+    else if (_offset == "quadratic")
+    {
+      offset_x = (current_velocity_x + current_accel_x * diff_time) * diff_time;
+      offset_y = (current_velocity_y + current_accel_y * diff_time) * diff_time;
+      offset_z = current_velocity_z * diff_time;
+      offset_yaw = angular_velocity * diff_time;
+    }
+    else if (_offset == "zero")
+    {
+      offset_x = 0.0;
+      offset_y = 0.0;
+      offset_z = 0.0;
+      offset_yaw = 0.0;
+    }
+
     predict_pose.x = previous_pose.x + offset_x;
     predict_pose.y = previous_pose.y + offset_y;
     predict_pose.z = previous_pose.z + offset_z;
@@ -1089,19 +1140,17 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     }
 
     // Compute the velocity and acceleration
-    scan_duration = current_scan_time - previous_scan_time;
-    double secs = scan_duration.toSec();
     diff_x = current_pose.x - previous_pose.x;
     diff_y = current_pose.y - previous_pose.y;
     diff_z = current_pose.z - previous_pose.z;
-    diff_yaw = current_pose.yaw - previous_pose.yaw;
+    diff_yaw = calcDiffForRadian(current_pose.yaw, previous_pose.yaw);
     diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);
 
-    current_velocity = diff / secs;
-    current_velocity_x = diff_x / secs;
-    current_velocity_y = diff_y / secs;
-    current_velocity_z = diff_z / secs;
-    angular_velocity = diff_yaw / secs;
+    current_velocity   = (diff_time &gt; 0) ? (diff / diff_time) : 0;
+    current_velocity_x = (diff_time &gt; 0) ? (diff_x / diff_time) : 0;
+    current_velocity_y = (diff_time &gt; 0) ? (diff_y / diff_time) : 0;
+    current_velocity_z = (diff_time &gt; 0) ? (diff_z / diff_time) : 0;
+    angular_velocity   = (diff_time &gt; 0) ? (diff_yaw / diff_time) : 0;
 
     current_pose_imu.x = current_pose.x;
     current_pose_imu.y = current_pose.y;
@@ -1134,10 +1183,10 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       current_velocity_smooth = 0.0;
     }
 
-    current_accel = (current_velocity - previous_velocity) / secs;
-    current_accel_x = (current_velocity_x - previous_velocity_x) / secs;
-    current_accel_y = (current_velocity_y - previous_velocity_y) / secs;
-    current_accel_z = (current_velocity_z - previous_velocity_z) / secs;
+    current_accel   = (diff_time &gt; 0) ? ((current_velocity - previous_velocity) / diff_time) : 0;
+    current_accel_x = (diff_time &gt; 0) ? ((current_velocity_x - previous_velocity_x) / diff_time) : 0;
+    current_accel_y = (diff_time &gt; 0) ? ((current_velocity_y - previous_velocity_y) / diff_time) : 0;
+    current_accel_z = (diff_time &gt; 0) ? ((current_velocity_z - previous_velocity_z) / diff_time) : 0;
 
     estimated_vel_mps.data = current_velocity;
     estimated_vel_kmph.data = current_velocity * 3.6;
@@ -1381,29 +1430,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     std::cout &lt;&lt; "Get fitness score time: " &lt;&lt; getFitnessScore_time &lt;&lt; std::endl;
     std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
 
-    // Update offset
-    if (_offset == "linear")
-    {
-      offset_x = diff_x;
-      offset_y = diff_y;
-      offset_z = diff_z;
-      offset_yaw = diff_yaw;
-    }
-    else if (_offset == "quadratic")
-    {
-      offset_x = (current_velocity_x + current_accel_x * secs) * secs;
-      offset_y = (current_velocity_y + current_accel_y * secs) * secs;
-      offset_z = diff_z;
-      offset_yaw = diff_yaw;
-    }
-    else if (_offset == "zero")
-    {
-      offset_x = 0.0;
-      offset_y = 0.0;
-      offset_z = 0.0;
-      offset_yaw = 0.0;
-    }
-
     offset_imu_x = 0.0;
     offset_imu_y = 0.0;
     offset_imu_z = 0.0;
@@ -1433,8 +1459,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     previous_pose.pitch = current_pose.pitch;
     previous_pose.yaw = current_pose.yaw;
 
-    previous_scan_time.sec = current_scan_time.sec;
-    previous_scan_time.nsec = current_scan_time.nsec;
+    previous_scan_time = current_scan_time;
 
     previous_previous_velocity = previous_velocity;
     previous_velocity = current_velocity;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="82c044a28a23dc3d077168a5764a62042844caf3" author="Yamato ANDO">
		<msg>fixed warning message of complie</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="3" deleted_lines="1">
				<diff>@@ -241,7 +241,7 @@ static nav_msgs::Odometry odom;
 // static tf::TransformListener local_transform_listener;
 static tf::StampedTransform local_transform;
 
-static int points_map_num = 0;
+static unsigned int points_map_num = 0;
 
 pthread_mutex_t mutex;
 
@@ -1485,6 +1485,8 @@ void* thread_func(void* args)
     map_callback_queue.callAvailable(ros::WallDuration());
     ros_rate.sleep();
   }
+  
+  return nullptr;
 }
 
 int main(int argc, char** argv)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f97c7f722c40af9ed3da45d3f15c44bbd6510da2" author="Abraham Monrroy">
		<msg>[feature] Grasshopper3 node modified to set the mode and pixel format (#1105)

* Grasshopper3 node modified to set the mode and pixel format
* Baumer Type Readme
* Baumer Auto Exposure Algorithm improvement
* Added Documentation to the package
* Added runtime manager param controls for both Ladybug and Grasshopper nodes</msg>
		<modified_files>
			<file old_path="ros\src\sensing\drivers\camera\packages\baumer\nodes\vlg22\src\vlg22_main.cpp" new_path="ros\src\sensing\drivers\camera\packages\baumer\nodes\vlg22\src\vlg22_main.cpp" added_lines="13" deleted_lines="11">
				<diff>@@ -260,20 +260,22 @@ void adjust_exposure(BGAPI::Camera* camera_pointer,
 
 	if (current_brightness &lt; threshold_brightness)
 	{
-		ROS_INFO("increasing exposure");
-		exposure = prev_exposure + exposure_delta;
-		if (exposure &gt;= VLG22_MAX_EXPOSURE)
-			exposure = VLG22_MAX_EXPOSURE;
-		baumer_change_exposure(camera_pointer, exposure);
+		if (exposure &lt;= VLG22_MAX_EXPOSURE)
+		{
+			exposure = prev_exposure + exposure_delta;
+			ROS_INFO("Increasing exposure");
+			baumer_change_exposure(camera_pointer, exposure);
+		}
 	}
 
 	if (current_brightness == 1.0)
 	{
-		ROS_INFO("reducing exposure");
-		exposure = prev_exposure - exposure_delta;
-		if (exposure &lt;= VLG22_MIN_EXPOSURE)
-			exposure = VLG22_MIN_EXPOSURE;
-		baumer_change_exposure(camera_pointer, exposure);
+		if (exposure &gt;= VLG22_MIN_EXPOSURE)
+		{
+			exposure = prev_exposure - exposure_delta;
+			ROS_INFO("Reducing exposure");
+			baumer_change_exposure(camera_pointer, exposure);
+		}
 	}
 	prev_exposure = exposure;
 }
@@ -386,4 +388,4 @@ int main(int argc, char **argv)
 	//release image memory
 	release_images(&amp;imagePointers);
 	return 0;
-}
+}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\grasshopper3\grasshopper3.cpp" new_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\grasshopper3\grasshopper3.cpp" added_lines="192" deleted_lines="34">
				<diff>@@ -53,16 +53,16 @@
 
 static volatile int running = 1;
 
-static void signalHandler(int)
+static void signal_handler(int)
 {
 	running = 0;
 	ros::shutdown();
 }
 
-void parseCameraInfo(const cv::Mat  &amp;camMat,
-                       const cv::Mat  &amp;disCoeff,
-                       const cv::Size &amp;imgSize,
-                       sensor_msgs::CameraInfo &amp;msg)
+void parse_camera_info(const cv::Mat&amp; camMat,
+                       const cv::Mat&amp; disCoeff,
+                       const cv::Size&amp; imgSize,
+                       sensor_msgs::CameraInfo&amp; msg)
 {
 	msg.header.frame_id = "camera";
 	//  msg.header.stamp    = ros::Time::now();
@@ -102,7 +102,7 @@ void parseCameraInfo(const cv::Mat  &amp;camMat,
 }
 
 
-static void print_camera_info(FlyCapture2::CameraInfo* info)
+void print_camera_info(FlyCapture2::CameraInfo* info)
 {
 	std::cout &lt;&lt; "\n*** CAMERA INFORMATION ***\n"
 		  &lt;&lt; "\tSerial number       - " &lt;&lt; info-&gt;serialNumber &lt;&lt; "\n"
@@ -115,13 +115,41 @@ static void print_camera_info(FlyCapture2::CameraInfo* info)
 		  &lt;&lt; std::endl;
 }
 
-static std::vector&lt;FlyCapture2::Camera*&gt;
-initializeCameras(FlyCapture2::BusManager *bus_manger, int camera_num)
+void print_image_settings(
+		const FlyCapture2::Format7ImageSettings&amp; image_settings,
+		const unsigned int&amp; packet_size,
+		const float&amp; percentage
+	)
+{
+	std::cout &lt;&lt; "Image settings: " &lt;&lt; std::endl;
+	std::cout &lt;&lt; "\tMode: " &lt;&lt; image_settings.mode &lt;&lt; std::endl;
+	std::cout &lt;&lt; "\tPixel Format: 0x" &lt;&lt; std::hex &lt;&lt; image_settings.pixelFormat &lt;&lt; std::dec &lt;&lt; std::endl;
+	std::cout &lt;&lt; "\tOffset X: " &lt;&lt; image_settings.offsetX &lt;&lt; std::endl;
+	std::cout &lt;&lt; "\tOffset Y: " &lt;&lt; image_settings.offsetY &lt;&lt; std::endl;
+	std::cout &lt;&lt; "\tWidth: " &lt;&lt; image_settings.width &lt;&lt; std::endl;
+	std::cout &lt;&lt; "\tHeight: " &lt;&lt; image_settings.height &lt;&lt; std::endl;
+	std::cout &lt;&lt; "Packet size: " &lt;&lt; packet_size &lt;&lt; " (" &lt;&lt; percentage &lt;&lt; "%)" &lt;&lt; std::endl;
+}
+
+void print_format7_info(const FlyCapture2::Format7Info&amp; info, bool supported)
+{
+	std::cout &lt;&lt; "supported: " &lt;&lt; supported &lt;&lt; std::endl;
+	std::cout &lt;&lt; "mode: " &lt;&lt; info.mode &lt;&lt; std::endl;
+	std::cout &lt;&lt; "maxWidth: " &lt;&lt; info.maxWidth &lt;&lt; std::endl;
+	std::cout &lt;&lt; "maxHeight: " &lt;&lt; info.maxHeight &lt;&lt; std::endl;
+	std::cout &lt;&lt; "packetSize: " &lt;&lt; info.packetSize &lt;&lt; std::endl;
+	std::cout &lt;&lt; "percentage: " &lt;&lt; info.percentage &lt;&lt; std::endl;
+	std::cout &lt;&lt; "pixelFormatBitField: " &lt;&lt; info.pixelFormatBitField &lt;&lt; std::endl;
+}
+
+void initialize_cameras(std::vector&lt;FlyCapture2::Camera *&gt; &amp;cameras,
+                        FlyCapture2::BusManager *bus_manger,
+                        int camera_num,
+                        FlyCapture2::Mode desired_mode,
+                        FlyCapture2::PixelFormat desired_pixel_format)
 {
 	// Connect to all detected cameras and attempt to set them to
 	// a common video mode and frame rate
-
-	std::vector&lt;FlyCapture2::Camera*&gt; cameras;
 	for (int i = 0; i &lt; camera_num; i++)
 	{
 		FlyCapture2::Camera *camera = new FlyCapture2::Camera();
@@ -149,7 +177,7 @@ initializeCameras(FlyCapture2::BusManager *bus_manger, int camera_num)
 			std::exit(-1);
 		}
 
-		image_info.timestamp.onOff = true;
+		image_info.timestamp.onOff = false;
 		error = camera-&gt;SetEmbeddedImageInfo(&amp;image_info);
 		if (error != FlyCapture2::PGRERROR_OK)
 		{
@@ -166,14 +194,92 @@ initializeCameras(FlyCapture2::BusManager *bus_manger, int camera_num)
 			std::exit(-1);
 		}
 
+		//obtain working settings
+		FlyCapture2::VideoMode default_video_mode;
+		FlyCapture2::FrameRate default_frame_rate;
+
+		error = camera-&gt;GetVideoModeAndFrameRate(&amp;default_video_mode, &amp;default_frame_rate);
+		if (error != FlyCapture2::PGRERROR_OK)
+		{
+			error.PrintErrorTrace();
+			std::exit(-1);
+		}
+
+		//try to set Format7, according to the desired mode and pixel format.
+		FlyCapture2::Format7ImageSettings image_settings;
+		bool supported = false;
+		unsigned int packet_size;
+		float percentage;
+
+		FlyCapture2::Format7Info format7_info;
+		format7_info.mode = desired_mode;
+
+		error = camera-&gt;GetFormat7Info(&amp;format7_info, &amp;supported);
+		if (error != FlyCapture2::PGRERROR_OK)
+		{
+			error.PrintErrorTrace();
+			std::exit(-1);
+		}
+
+		print_format7_info(format7_info, supported);
+
+		if (supported)
+		{
+			error = camera-&gt;GetFormat7Configuration(&amp;image_settings, &amp;packet_size, &amp;percentage);
+			if (error != FlyCapture2::PGRERROR_OK)
+			{
+				error.PrintErrorTrace();
+				std::exit(-1);
+			}
+
+			image_settings.mode = desired_mode;
+			image_settings.pixelFormat = desired_pixel_format;
+			image_settings.offsetX = 0;
+			image_settings.offsetY = 0;
+			image_settings.width = format7_info.maxWidth;
+			image_settings.height = format7_info.maxHeight;
+
+			FlyCapture2::Format7PacketInfo packet_info;
+			bool valid_settings = false;
+			error = camera-&gt;ValidateFormat7Settings(&amp;image_settings, &amp;valid_settings, &amp;packet_info);
+			if (error != FlyCapture2::PGRERROR_OK)
+			{
+				error.PrintErrorTrace();
+				std::exit(-1);
+			}
+			packet_size = packet_info.recommendedBytesPerPacket;
+			error = camera-&gt;SetFormat7Configuration(&amp;image_settings, packet_size);
+			if (error != FlyCapture2::PGRERROR_OK)
+			{
+				error.PrintErrorTrace();
+				std::exit(-1);
+			}
+
+			error = camera-&gt;GetFormat7Configuration(&amp;image_settings, &amp;packet_size, &amp;percentage);
+			if (error != FlyCapture2::PGRERROR_OK)
+			{
+				error.PrintErrorTrace();
+				std::exit(-1);
+			}
+
+			print_image_settings(image_settings, packet_size, percentage);
+		}
+		else
+		{
+			ROS_ERROR("Selected Mode not supported, using last working mode.");
+		}
+
 		print_camera_info(&amp;camera_info);
 		cameras.push_back(camera);
 	}
-
-	return cameras;
 }
 
-static int getNumCameras(FlyCapture2::BusManager *bus_manager)
+/*!
+ * Get the number of cameras connected to the system
+ * @param bus_manager Valid pointer to the BusManager
+ * @return The number of detected cameras
+ */
+unsigned int get_num_cameras(FlyCapture2::BusManager* bus_manager)
 {
 	unsigned int cameras;
 	FlyCapture2::Error error = bus_manager-&gt;GetNumOfCameras(&amp;cameras);
@@ -190,11 +296,14 @@ static int getNumCameras(FlyCapture2::BusManager *bus_manager)
 		std::cerr &lt;&lt; "Error: This program requires at least 1 camera." &lt;&lt; std::endl;
 		std::exit(-1);
 	}
-
-	return static_cast&lt;int&gt;(cameras);
+	return cameras;
 }
 
-static void startCapture(std::vector&lt;FlyCapture2::Camera*&gt;&amp; cameras)
+/*!
+ * Initialize the capture on all the cameras
+ * @param cameras An array of valid pointers to the camera objects
+ */
+void start_capture(std::vector&lt;FlyCapture2::Camera *&gt;&amp; cameras)
 {
 	for (auto *camera : cameras)
 	{
@@ -205,11 +314,14 @@ static void startCapture(std::vector&lt;FlyCapture2::Camera*&gt;&amp; cameras)
 			return;
 		}
 	}
-
-	return;
 }
 
-void getMatricesFromFile(ros::NodeHandle nh, sensor_msgs::CameraInfo &amp;camerainfo_msg)
+/*!
+ * Reads and parses the Autoware calibration file format
+ * @param nh ros node handle
+ * @param camerainfo_msg CameraInfo message to fill
+ */
+void getMatricesFromFile(const ros::NodeHandle&amp; nh, sensor_msgs::CameraInfo &amp;camerainfo_msg)
 {
 	//////////////////CAMERA INFO/////////////////////////////////////////
 	cv::Mat  cameraExtrinsicMat;
@@ -241,7 +353,42 @@ void getMatricesFromFile(ros::NodeHandle nh, sensor_msgs::CameraInfo &amp;camerainfo
 		fs["DistCoeff"] &gt;&gt; distCoeff;
 		fs["ImageSize"] &gt;&gt; imageSize;
 	}
-	parseCameraInfo(cameraMat, distCoeff, imageSize, camerainfo_msg);
+	parse_camera_info(cameraMat, distCoeff, imageSize, camerainfo_msg);
+}
+
+/*!
+ * Reads the params from the console
+ * @param private_nh[in] Private Ros node handle
+ * @param fps[out] Read value from the console
+ * @param mode[out] Read value from the console
+ * @param format[out] Read value from the console
+ */
+void ros_get_params(const ros::NodeHandle&amp; private_nh, int&amp; fps, int&amp; mode, std::string&amp; format)
+{
+	if (private_nh.getParam("fps", fps))
+	{
+		ROS_INFO("fps set to %d", fps);
+	} else {
+		fps = 20;
+		ROS_INFO("No param received, defaulting fps to %d", fps);
+	}
+
+	if (private_nh.getParam("mode", mode))
+	{
+		ROS_INFO("mode set to %d", mode);
+	} else {
+		mode = 0;
+		ROS_INFO("No param received, defaulting mode to %d", mode);
+	}
+
+	if (private_nh.getParam("format", format))
+	{
+		ROS_INFO("format set to %s", format.c_str());
+	} else {
+		format = "raw";
+		ROS_INFO("No param received, defaulting format to %s", format.c_str());
+	}
+
 }
 
 int main(int argc, char **argv)
@@ -249,24 +396,37 @@ int main(int argc, char **argv)
 	////////////////POINT GREY CAMERA /////////////////////////////
 	FlyCapture2::BusManager busMgr;
 
-	int camera_num = getNumCameras(&amp;busMgr);
-	std::vector&lt;FlyCapture2::Camera*&gt; cameras = initializeCameras(&amp;busMgr, camera_num);
-
 	////ROS STUFF////
 	ros::init(argc, argv, "grasshopper3");
 	ros::NodeHandle n;
 	ros::NodeHandle private_nh("~");
 
-	signal(SIGTERM, signalHandler);//detect closing
+	signal(SIGTERM, signal_handler);//detect closing
 
-	double fps;
-	if (private_nh.getParam("fps", fps))
+	int fps, camera_mode;
+	std::string pixel_format;
+
+	ros_get_params(private_nh, fps, camera_mode, pixel_format);
+
+	//
+	FlyCapture2::Mode desired_mode;
+	FlyCapture2::PixelFormat desired_pixel_format;
+
+	desired_mode = (FlyCapture2::Mode)camera_mode;
+
+	if(pixel_format == "rgb")
 	{
-		ROS_INFO("fps set to %.2f", fps);
-	} else {
-		fps = 15.0;
-		ROS_INFO("No param received, defaulting to %.2f", fps);
+		desired_pixel_format = FlyCapture2::PIXEL_FORMAT_RGB8;
 	}
+	else
+	{
+		desired_pixel_format = FlyCapture2::PIXEL_FORMAT_RAW8;
+	}
+
+	//init cameras
+	int camera_num = get_num_cameras(&amp;busMgr);
+	std::vector&lt;FlyCapture2::Camera*&gt; cameras;
+	initialize_cameras(cameras, &amp;busMgr, camera_num, desired_mode, desired_pixel_format);
 
 	///////calibration data
 	sensor_msgs::CameraInfo camerainfo_msg;
@@ -287,7 +447,7 @@ int main(int argc, char **argv)
 		ROS_INFO("Publishing.. %s", topic.c_str());
 	}
 
-	startCapture(cameras);
+	start_capture(cameras);
 
 	std::cout &lt;&lt; "Capturing by " &lt;&lt; camera_num &lt;&lt; " cameras..." &lt;&lt; std::endl;
 
@@ -341,8 +501,6 @@ int main(int argc, char **argv)
 			msg.data.resize(image_size);
 			memcpy(msg.data.data(), image.GetData(), image_size);
 
-
-
 			pub[i].publish(msg);
 			i++;
 		}
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5792c4e09bd641ac06b86944cd16999993d1a90d" author="Yuma">
		<msg>Add waypoint_filter functions</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="45" deleted_lines="48">
				<diff>@@ -48,7 +48,7 @@ WaypointLoaderNode::~WaypointLoaderNode()
 void WaypointLoaderNode::initPublisher()
 {
   // setup publisher
-  if(disableDecisionMaker_){
+  if(disable_decision_maker_){
 	  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/lane_waypoints_array", 10, true);
   }else{
 	  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/based/lane_waypoints_array", 10, true);
@@ -58,10 +58,8 @@ void WaypointLoaderNode::initPublisher()
 void WaypointLoaderNode::initParameter()
 {
   // parameter settings
-  private_nh_.param&lt;double&gt;("decelerate", decelerate_, double(0));
-  private_nh_.param&lt;bool&gt;("disableDecisionMaker", disableDecisionMaker_, true);
-  private_nh_.param&lt;bool&gt;("disableVelocitySmoothing", disableVelocitySmoothing_, false);
-  ROS_INFO_STREAM("decelerate :" &lt;&lt; decelerate_);
+  private_nh_.param&lt;bool&gt;("disable_decision_maker", disable_decision_maker_, true);
+  private_nh_.param&lt;bool&gt;("disable_filtering", disable_filtering_, false);
   private_nh_.param&lt;std::string&gt;("multi_lane_csv", multi_lane_csv_, MULTI_LANE_CSV);
 }
 
@@ -73,19 +71,60 @@ void WaypointLoaderNode::publishLaneArray()
   autoware_msgs::LaneArray lane_array;
   createLaneArray(multi_file_path, &amp;lane_array);
   lane_pub_.publish(lane_array);
+  if(!disable_filtering_)
+  {
+    std::vector&lt;std::string&gt; dst_multi_file_path = multi_file_path;
+    for(auto&amp; el : dst_multi_file_path)
+      el = addFileSuffix(el, "_filtered");
+    saveLaneArray(dst_multi_file_path, lane_array);
+  }
+}
+
+const std::string addFileSuffix(std::string file_path, std::string suffix)
+{
+  std::string output_file_path, tmp;
+  std::string directory_path, filename, extension;
+
+  tmp = file_path;
+  const std::string::size_type idx_slash = tmp.find_last_of("/");
+  if(idx_slash != std::string::npos)tmp.erase(0, idx_slash);
+  const std::string::size_type idx_dot = tmp.find_last_of(".");
+  const std::string::size_type idx_dot_allpath = file_path.find_last_of(".");
+  if(idx_dot != std::string::npos &amp;&amp; idx_dot != tmp.size() - 1)
+    file_path.erase(idx_dot_allpath, file_path.size() - 1);
+  file_path += suffix + ".csv";
+  return file_path;
 }
 
 void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt; &amp;paths,
                                          autoware_msgs::LaneArray *lane_array)
 {
-  for (auto el : paths)
+  for (const auto&amp; el : paths)
   {
     autoware_msgs::lane lane;
     createLaneWaypoint(el, &amp;lane);
+    if(!disable_filtering_)
+      filter_.filterLaneWaypoint(&amp;lane);
     lane_array-&gt;lanes.push_back(lane);
   }
 }
 
+void WaypointLoaderNode::saveLaneArray(const std::vector&lt;std::string&gt; &amp;paths, const autoware_msgs::LaneArray &amp;lane_array)
+{
+  unsigned long idx = 0;
+  for (const auto&amp; file_path : paths)
+  {
+    std::ofstream ofs(file_path.c_str(), std::ios::app);
+    ofs &lt;&lt; "x,y,z,yaw,velocity,change_flag" &lt;&lt; std::endl;
+    for(const auto&amp; el : lane_array.lanes[idx].waypoints)
+    {
+      ofs &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; el.pose.pose.position.x &lt;&lt; "," &lt;&lt; el.pose.pose.position.y &lt;&lt; ","
+          &lt;&lt; el.pose.pose.position.z &lt;&lt; "," &lt;&lt; tf::getYaw(el.pose.pose.orientation) &lt;&lt; "," &lt;&lt; mps2kmph(el.twist.twist.linear.x) &lt;&lt; ",0" &lt;&lt; std::endl;
+    }
+    idx++;
+  }
+}
+
 void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, autoware_msgs::lane *lane)
 {
   if (!verifyFileConsistency(file_path.c_str()))
@@ -103,7 +142,6 @@ void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, autowa
     loadWaypointsForVer2(file_path.c_str(), &amp;wps);
   else
     loadWaypoints(file_path.c_str(), &amp;wps);
-
   lane-&gt;header.frame_id = "/map";
   lane-&gt;header.stamp = ros::Time(0);
   lane-&gt;waypoints = wps;
@@ -139,9 +177,6 @@ void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;
     {
       wps-&gt;at(i).pose.pose.orientation = wps-&gt;at(i - 1).pose.pose.orientation;
     }
-
-    wps-&gt;at(i).twist.twist.linear.x = decelerate(
-        wps-&gt;at(i).pose.pose.position, wps-&gt;at(wps-&gt;size() - 1).pose.pose.position, wps-&gt;at(i).twist.twist.linear.x);
   }
 }
 
@@ -172,7 +207,6 @@ void WaypointLoaderNode::loadWaypointsForVer2(const char *filename, std::vector&lt;
     parseWaypointForVer2(line, &amp;wp);
     wps-&gt;push_back(wp);
   }
-  planningVelocity(&amp;*wps);
 }
 
 void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line, autoware_msgs::waypoint *wp)
@@ -206,7 +240,6 @@ void WaypointLoaderNode::loadWaypoints(const char *filename, std::vector&lt;autowar
     parseWaypoint(line, contents, &amp;wp);
     wps-&gt;push_back(wp);
   }
-  planningVelocity(&amp;*wps);
 }
 
 void WaypointLoaderNode::parseWaypoint(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
@@ -261,42 +294,6 @@ FileFormat WaypointLoaderNode::checkFileFormat(const char *filename)
           );
 }
 
-void WaypointLoaderNode::planningVelocity(std::vector&lt;autoware_msgs::waypoint&gt; *wps)
-{
-
-  for (size_t i = 0; i &lt; wps-&gt;size(); ++i)
-  {
-    wps-&gt;at(i).twist.twist.linear.x = decelerate(
-      wps-&gt;at(i).pose.pose.position, wps-&gt;at(wps-&gt;size() - 1).pose.pose.position, wps-&gt;at(i).twist.twist.linear.x);
-  }
-
-  if(!disableVelocitySmoothing_){
-	  std::vector&lt;autoware_msgs::waypoint&gt; temp = *wps;
-	  if(temp.size() &gt; 3){
-		  for (size_t i = 1; i&lt; wps-&gt;size()-1; ++i){
-			  wps-&gt;at(i).twist.twist.linear.x = 
-				  (temp.at(i-1).twist.twist.linear.x + 
-				   temp.at(i-1).twist.twist.linear.x + 
-				   temp.at(i-1).twist.twist.linear.x) / 3;
-		  }
-	  }
-  }
-}
-
-double WaypointLoaderNode::decelerate(geometry_msgs::Point p1, geometry_msgs::Point p2, double original_velocity_mps)
-{
-  double distance = sqrt(pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2) + pow(p2.z - p1.z, 2));
-  double vel = sqrt(2 * decelerate_ * distance);  // km/h
-
-  if (mps2kmph(vel) &lt; 1.0)
-    vel = 0;
-
-  if (vel &gt; original_velocity_mps)
-    vel = original_velocity_mps;
-
-  return vel;
-}
-
 bool WaypointLoaderNode::verifyFileConsistency(const char *filename)
 {
   ROS_INFO("verify...");
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="6" deleted_lines="6">
				<diff>@@ -42,6 +42,7 @@
 #include &lt;unordered_map&gt;
 
 #include "autoware_msgs/LaneArray.h"
+#include "waypoint_filter.h"
 
 namespace waypoint_maker
 {
@@ -88,9 +89,9 @@ private:
 
   // variables
   std::string multi_lane_csv_;
-  double decelerate_;
-  bool disableDecisionMaker_;
-  bool disableVelocitySmoothing_;
+  bool disable_decision_maker_;
+  bool disable_filtering_;
+  WaypointFilter filter_;
 
   // initializer
   void initPublisher();
@@ -100,6 +101,7 @@ private:
 
   void createLaneWaypoint(const std::string &amp;file_path, autoware_msgs::lane *lane);
   void createLaneArray(const std::vector&lt;std::string&gt; &amp;paths, autoware_msgs::LaneArray *lane_array);
+  void saveLaneArray(const std::vector&lt;std::string&gt; &amp;paths, const autoware_msgs::LaneArray &amp;lane_array);
 
   FileFormat checkFileFormat(const char *filename);
   bool verifyFileConsistency(const char *filename);
@@ -110,11 +112,9 @@ private:
   void loadWaypoints(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
   void parseWaypoint(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
                             autoware_msgs::waypoint *wp);
-  void planningVelocity(std::vector&lt;autoware_msgs::waypoint&gt; *wps);
-  double decelerate(geometry_msgs::Point p1, geometry_msgs::Point p2, double original_velocity_mps);
-
 };
 
+const std::string addFileSuffix(std::string file_path, std::string suffix);
 void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns);
 size_t countColumns(const std::string&amp; line);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0bd2c91f3a10f0be215f61d827ad63bdf3ab2152" author="Tomoya-Sato">
		<msg>delete ndt code</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\icp_localizer\nodes\icp_matching\icp_matching.cpp" new_path="ros\src\computing\perception\localization\packages\icp_localizer\nodes\icp_matching\icp_matching.cpp" added_lines="3" deleted_lines="23">
				<diff>@@ -60,7 +60,6 @@
 #include &lt;pcl/io/pcd_io.h&gt;
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
-#include &lt;pcl/registration/ndt.h&gt;
 #include &lt;pcl/registration/icp.h&gt;
 #include &lt;pcl/filters/voxel_grid.h&gt;
 
@@ -96,7 +95,6 @@ static int map_loaded = 0;
 static int _use_gnss = 1;
 static int init_pos_set = 0;
 
-static pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;
 static pcl::IterativeClosestPoint&lt;pcl::PointXYZ, pcl::PointXYZ&gt; icp;
 
 // Default values for ICP
@@ -237,17 +235,9 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(map));
     // Setting point cloud to be aligned to.
-//    ndt.setInputTarget(map_ptr);
     icp.setInputTarget(map_ptr);
     std::cout &lt;&lt; "setInputTarget finished." &lt;&lt; std::endl;
 
-    // Setting NDT parameters to default values
-    /*
-    ndt.setMaximumIterations(iter);
-    ndt.setResolution(ndt_res);
-    ndt.setStepSize(step_size);
-    ndt.setTransformationEpsilon(trans_eps);
-*/
     map_loaded = 1;
   }
 }
@@ -356,7 +346,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     static double align_time, getFitnessScore_time = 0.0;
 
     // Setting point cloud to be aligned.
-//    ndt.setInputSource(filtered_scan_ptr);
     icp.setInputSource(filtered_scan_ptr);
 
     // Guess the initial gross estimation of the transformation
@@ -374,7 +363,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;
 
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-//    ndt.align(*output_cloud, init_guess);
 
     icp.setMaximumIterations(maximum_iterations);
     icp.setTransformationEpsilon(transformation_epsilon);
@@ -387,20 +375,14 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     align_end = std::chrono::system_clock::now();
     align_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(align_end - align_start).count() / 1000.0;
 
-//    t = ndt.getFinalTransformation();  // localizer
     t = icp.getFinalTransformation();  // localizer
     t2 = t * tf_ltob;                  // base_link
 
-//    iteration = ndt.getFinalNumIteration();
-//    score = ndt.getFitnessScore();
-
     getFitnessScore_start = std::chrono::system_clock::now();
     fitness_score = icp.getFitnessScore();
     getFitnessScore_end = std::chrono::system_clock::now();
     getFitnessScore_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(getFitnessScore_end - getFitnessScore_start).count() / 1000.0;
 
-//    trans_probability = ndt.getTransformationProbability();
-
     tf::Matrix3x3 mat_l;  // localizer
     mat_l.setValue(static_cast&lt;double&gt;(t(0, 0)), static_cast&lt;double&gt;(t(0, 1)), static_cast&lt;double&gt;(t(0, 2)),
                    static_cast&lt;double&gt;(t(1, 0)), static_cast&lt;double&gt;(t(1, 1)), static_cast&lt;double&gt;(t(1, 2)),
@@ -417,13 +399,13 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
                    static_cast&lt;double&gt;(t2(1, 0)), static_cast&lt;double&gt;(t2(1, 1)), static_cast&lt;double&gt;(t2(1, 2)),
                    static_cast&lt;double&gt;(t2(2, 0)), static_cast&lt;double&gt;(t2(2, 1)), static_cast&lt;double&gt;(t2(2, 2)));
 
-    // Update ndt_pose
+    // Update icp_pose
     icp_pose.x = t2(0, 3);
     icp_pose.y = t2(1, 3);
     icp_pose.z = t2(2, 3);
     mat_b.getRPY(icp_pose.roll, icp_pose.pitch, icp_pose.yaw, 1);
 
-    // Calculate the difference between ndt_pose and predict_pose
+    // Calculate the difference between icp_pose and predict_pose
     predict_pose_error = sqrt((icp_pose.x - predict_pose.x) * (icp_pose.x - predict_pose.x) +
                               (icp_pose.y - predict_pose.y) * (icp_pose.y - predict_pose.y) +
                               (icp_pose.z - predict_pose.z) * (icp_pose.z - predict_pose.z));
@@ -600,10 +582,8 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     std::cout &lt;&lt; "Number of Filtered Scan Points: " &lt;&lt; scan_points_num &lt;&lt; " points." &lt;&lt; std::endl;
     std::cout &lt;&lt; "ICP has converged: " &lt;&lt; icp.hasConverged() &lt;&lt; std::endl;
     std::cout &lt;&lt; "Fitness Score: " &lt;&lt; fitness_score &lt;&lt; std::endl;
-//    std::cout &lt;&lt; "Transformation Probability: " &lt;&lt; ndt.getTransformationProbability() &lt;&lt; std::endl;
+
     std::cout &lt;&lt; "Execution Time: " &lt;&lt; exe_time &lt;&lt; " ms." &lt;&lt; std::endl;
-//    std::cout &lt;&lt; "Number of Iterations: " &lt;&lt; ndt.getFinalNumIteration() &lt;&lt; std::endl;
-//    std::cout &lt;&lt; "NDT Reliability: " &lt;&lt; ndt_reliability.data &lt;&lt; std::endl;
     std::cout &lt;&lt; "(x,y,z,roll,pitch,yaw): " &lt;&lt; std::endl;
     std::cout &lt;&lt; "(" &lt;&lt; current_pose.x &lt;&lt; ", " &lt;&lt; current_pose.y &lt;&lt; ", " &lt;&lt; current_pose.z &lt;&lt; ", " &lt;&lt; current_pose.roll
               &lt;&lt; ", " &lt;&lt; current_pose.pitch &lt;&lt; ", " &lt;&lt; current_pose.yaw &lt;&lt; ")" &lt;&lt; std::endl;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bed10b65216f1c2dad373cd4cec67e80e12ebe9c" author="Manato Hirabayashi">
		<msg>Suppress compile error

I encounterd compile error like following:
```
Autoware/ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_decision.cpp:86:28: error: ‘accumulate’ is not a member of ‘std’
```

And this can be avoided by this modification.</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -1,4 +1,5 @@
 #include &lt;stdio.h&gt;
+#include &lt;numeric&gt;
 
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;jsk_rviz_plugins/OverlayText.h&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9f2ce1988195b4b51f8f5a23d22c0e061b9a4aa0" author="anhnv3991">
		<msg>Add curly brackets to if commands.
Remove "#include&lt;velodyne_pointcloud/point_types.h&gt;".</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\Octree.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\Octree.h" added_lines="0" deleted_lines="1">
				<diff>@@ -1,7 +1,6 @@
 #ifndef OCTREE_H_
 #define OCTREE_H_
 
-#include &lt;velodyne_pointcloud/point_types.h&gt;
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl/point_cloud.h&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\Registration.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\Registration.h" added_lines="0" deleted_lines="1">
				<diff>@@ -3,7 +3,6 @@
 
 #include &lt;eigen3/Eigen/Dense&gt;
 #include &lt;eigen3/Eigen/Geometry&gt;
-#include &lt;velodyne_pointcloud/point_types.h&gt;
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl/point_cloud.h&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\VoxelGrid.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\VoxelGrid.h" added_lines="0" deleted_lines="1">
				<diff>@@ -1,7 +1,6 @@
 #ifndef CPU_VGRID_H_
 #define CPU_VGRID_H_
 
-#include &lt;velodyne_pointcloud/point_types.h&gt;
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl/point_cloud.h&gt;
 #include &lt;float.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\NormalDistributionsTransform.cpp" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\NormalDistributionsTransform.cpp" added_lines="26" deleted_lines="16">
				<diff>@@ -169,14 +169,16 @@ void NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::computeTran
 
 		//Not update visualizer
 
-		if (nr_iterations_ &gt; max_iterations_ || (nr_iterations_ &amp;&amp; (std::fabs(delta_p_norm) &lt; transformation_epsilon_)))
+		if (nr_iterations_ &gt; max_iterations_ || (nr_iterations_ &amp;&amp; (std::fabs(delta_p_norm) &lt; transformation_epsilon_))) {
 			converged_ = true;
+		}
 
 		nr_iterations_++;
 	}
 
-	if (source_cloud_-&gt;points.size() &gt; 0)
+	if (source_cloud_-&gt;points.size() &gt; 0) {
 		trans_probability_ = score / static_cast&lt;double&gt;(source_cloud_-&gt;points.size());
+	}
 }
 
 template &lt;typename PointSourceType, typename PointTargetType&gt;
@@ -274,8 +276,9 @@ double NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::updateDer
 
 	e_x_cov_x = gauss_d2_ * e_x_cov_x;
 
-	if (e_x_cov_x &gt; 1 || e_x_cov_x &lt; 0 || e_x_cov_x != e_x_cov_x)
+	if (e_x_cov_x &gt; 1 || e_x_cov_x &lt; 0 || e_x_cov_x != e_x_cov_x) {
 		return 0.0;
+	}
 
 	e_x_cov_x *= gauss_d1_;
 
@@ -435,9 +438,9 @@ double NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::computeSt
 	Eigen::Matrix&lt;double, 6, 1&gt; x_t;
 
 	if (d_phi_0 &gt;= 0) {
-		if (d_phi_0 == 0)
+		if (d_phi_0 == 0) {
 			return 0;
-		else {
+		} else {
 			d_phi_0 *= -1;
 			step_dir *= -1;
 		}
@@ -551,10 +554,11 @@ double NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::trialValu
 		// Equation 2.4.2 [Sun, Yuan 2006]
 		double a_q = a_l - 0.5 * (a_l - a_t) * g_l / (g_l - (f_l - f_t) / (a_l - a_t));
 
-		if (std::fabs (a_c - a_l) &lt; std::fabs (a_q - a_l))
+		if (std::fabs (a_c - a_l) &lt; std::fabs (a_q - a_l)) {
 		  return (a_c);
-		else
+		} else {
 		  return (0.5 * (a_q + a_c));
+		}
 	}
 	// Case 2 in Trial Value Selection [More, Thuente 1994]
 	else if (g_t * g_l &lt; 0) {
@@ -569,10 +573,11 @@ double NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::trialValu
 		// Equation 2.4.5 [Sun, Yuan 2006]
 		double a_s = a_l - (a_l - a_t) / (g_l - g_t) * g_l;
 
-		if (std::fabs (a_c - a_t) &gt;= std::fabs (a_s - a_t))
+		if (std::fabs (a_c - a_t) &gt;= std::fabs (a_s - a_t)) {
 		  return (a_c);
-		else
+		} else {
 		  return (a_s);
+		}
 	}
 	// Case 3 in Trial Value Selection [More, Thuente 1994]
 	else if (std::fabs (g_t) &lt;= std::fabs (g_l)) {
@@ -588,15 +593,17 @@ double NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::trialValu
 
 		double a_t_next;
 
-		if (std::fabs (a_c - a_t) &lt; std::fabs (a_s - a_t))
+		if (std::fabs (a_c - a_t) &lt; std::fabs (a_s - a_t)) {
 		  a_t_next = a_c;
-		else
+		} else {
 		  a_t_next = a_s;
+		}
 
-		if (a_t &gt; a_l)
+		if (a_t &gt; a_l) {
 		  return (std::min (a_t + 0.66 * (a_u - a_t), a_t_next));
-		else
+		} else {
 		  return (std::max (a_t + 0.66 * (a_u - a_t), a_t_next));
+		}
 	}
 	// Case 4 in Trial Value Selection [More, Thuente 1994]
 	else {
@@ -641,8 +648,9 @@ double NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::updateInt
 		return (false);
 	}
 	// Interval Converged
-	else
+	else {
 		return (true);
+	}
 }
 
 template &lt;typename PointSourceType, typename PointTargetType&gt;
@@ -653,8 +661,9 @@ void NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::updateHessi
 	Eigen::Vector3d cov_dxd_pi;
 	double e_x_cov_x = gauss_d2_ * exp(-gauss_d2_ * x_trans.dot(c_inv * x_trans) / 2);
 
-	if (e_x_cov_x &gt; 1 || e_x_cov_x &lt; 0 || e_x_cov_x != e_x_cov_x)
+	if (e_x_cov_x &gt; 1 || e_x_cov_x &lt; 0 || e_x_cov_x != e_x_cov_x) {
 		return;
+	}
 
 	e_x_cov_x *= gauss_d1_;
 
@@ -730,8 +739,9 @@ double NormalDistributionsTransform&lt;PointSourceType, PointTargetType&gt;::getFitnes
 		}
 	}
 
-	if (nr &gt; 0)
+	if (nr &gt; 0) {
 		return (fitness_score / nr);
+	}
 
 	return DBL_MAX;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\Octree.cpp" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\Octree.cpp" added_lines="88" deleted_lines="47">
				<diff>@@ -69,23 +69,29 @@ void Octree&lt;PointSourceType&gt;::setInput(std::vector&lt;Eigen::Vector3i&gt; occupied_vox
 	for (int i = 0; i &lt; occupied_voxels.size(); i++) {
 		Eigen::Vector3i vid = occupied_voxels[i];
 
-		if (min_b_x &gt; vid(0))
+		if (min_b_x &gt; vid(0)) {
 			min_b_x = vid(0);
+		}
 
-		if (max_b_x &lt; vid(0))
+		if (max_b_x &lt; vid(0)) {
 			max_b_x = vid(0);
+		}
 
-		if (min_b_y &gt; vid(1))
+		if (min_b_y &gt; vid(1)) {
 			min_b_y = vid(1);
+		}
 
-		if (max_b_y &lt; vid(1))
+		if (max_b_y &lt; vid(1)) {
 			max_b_y = vid(1);
+		}
 
-		if (min_b_z &gt; vid(2))
+		if (min_b_z &gt; vid(2)) {
 			min_b_z = vid(2);
+		}
 
-		if (max_b_z &lt; vid(2))
+		if (max_b_z &lt; vid(2)) {
 			max_b_z = vid(2);
+		}
 	}
 
 	OctreeLevelBoundaries level;
@@ -180,23 +186,29 @@ void Octree&lt;PointSourceType&gt;::setInput(std::vector&lt;Eigen::Vector3i&gt; occupied_vox
 
 		} else {
 			/* Otherwise, update boundaries inside the node */
-			if (p.x &lt; current_node.lx)
+			if (p.x &lt; current_node.lx) {
 				current_node.lx = p.x;
+			}
 
-			if (p.y &lt; current_node.ly)
+			if (p.y &lt; current_node.ly) {
 				current_node.ly = p.y;
+			}
 
-			if (p.z &lt; current_node.lz)
+			if (p.z &lt; current_node.lz) {
 				current_node.lz = p.z;
+			}
 
-			if (p.x &gt; current_node.ux)
+			if (p.x &gt; current_node.ux) {
 				current_node.ux = p.x;
+			}
 
-			if (p.y &gt; current_node.uy)
+			if (p.y &gt; current_node.uy) {
 				current_node.uy = p.y;
+			}
 
-			if (p.z &gt; current_node.uz)
+			if (p.z &gt; current_node.uz) {
 				current_node.uz = p.z;
+			}
 
 			Eigen::Vector3d new_node(p.x, p.y, p.z);
 
@@ -279,23 +291,29 @@ void Octree&lt;PointSourceType&gt;::buildLevel(int level)
 
 				if (isOccupied(cid, level - 1)) {
 					if (isOccupied(pid, level)) {
-						if (pnode.lx &gt; cnode.lx)
+						if (pnode.lx &gt; cnode.lx) {
 							pnode.lx = cnode.lx;
+						}
 
-						if (pnode.ly &gt; cnode.ly)
+						if (pnode.ly &gt; cnode.ly) {
 							pnode.ly = cnode.ly;
+						}
 
-						if (pnode.lz &gt; cnode.lz)
+						if (pnode.lz &gt; cnode.lz) {
 							pnode.lz = cnode.lz;
+						}
 
-						if (pnode.ux &lt; cnode.ux)
+						if (pnode.ux &lt; cnode.ux) {
 							pnode.ux = cnode.ux;
+						}
 
-						if (pnode.uy &lt; cnode.uy)
+						if (pnode.uy &lt; cnode.uy) {
 							pnode.uy = cnode.uy;
+						}
 
-						if (pnode.uz &lt; cnode.uz)
+						if (pnode.uz &lt; cnode.uz) {
 							pnode.uz = cnode.uz;
+						}
 
 						// If the parent node is already occupied, update its centroid
 						pnode.centroid = pnode.centroid * pnode.point_num + cnode.centroid * cnode.point_num;
@@ -334,23 +352,29 @@ void Octree&lt;PointSourceType&gt;::updateBoundaries(std::vector&lt;Eigen::Vector3i&gt; new_
 	for (int i = 0; i &lt; new_voxels.size(); i++) {
 		Eigen::Vector3i vid = new_voxels[i];
 
-		if (new_min_bx &gt; vid(0))
+		if (new_min_bx &gt; vid(0)) {
 			new_min_bx = vid(0);
+		}
 
-		if (new_max_bx &lt; vid(0))
+		if (new_max_bx &lt; vid(0)) {
 			new_max_bx = vid(0);
+		}
 
-		if (new_min_by &gt; vid(1))
+		if (new_min_by &gt; vid(1)) {
 			new_min_by = vid(1);
+		}
 
-		if (new_max_by &lt; vid(1))
+		if (new_max_by &lt; vid(1)) {
 			new_max_by = vid(1);
+		}
 
-		if (new_min_bz &gt; vid(2))
+		if (new_min_bz &gt; vid(2)) {
 			new_min_bz = vid(2);
+		}
 
-		if (new_max_bz &lt; vid(2))
+		if (new_max_bz &lt; vid(2)) {
 			new_max_bz = vid(2);
+		}
 	}
 
 	OctreeLevelBoundaries dst_bounds;
@@ -371,23 +395,29 @@ void Octree&lt;PointSourceType&gt;::updateBoundaries(std::vector&lt;Eigen::Vector3i&gt; new_
 	if (dst_bounds.lower_x &lt; src_bounds.lower_x || dst_bounds.lower_y &lt; src_bounds.lower_y || dst_bounds.lower_z &lt; src_bounds.lower_z ||
 			dst_bounds.upper_x &gt; src_bounds.upper_x || dst_bounds.upper_y &gt; src_bounds.upper_y || dst_bounds.upper_z &gt; src_bounds.upper_z) {
 		// If the base voxel grid expanded, then we need expand the octree as well
-		if (dst_bounds.lower_x &gt; src_bounds.lower_x)
+		if (dst_bounds.lower_x &gt; src_bounds.lower_x) {
 			dst_bounds.lower_x = src_bounds.lower_x;
+		}
 
-		if (dst_bounds.lower_y &gt; src_bounds.lower_y)
+		if (dst_bounds.lower_y &gt; src_bounds.lower_y) {
 			dst_bounds.lower_y = src_bounds.lower_y;
+		}
 
-		if (dst_bounds.lower_z &gt; src_bounds.lower_z)
+		if (dst_bounds.lower_z &gt; src_bounds.lower_z) {
 			dst_bounds.lower_z = src_bounds.lower_z;
+		}
 
-		if (dst_bounds.upper_x &lt; src_bounds.upper_x)
+		if (dst_bounds.upper_x &lt; src_bounds.upper_x) {
 			dst_bounds.upper_x = src_bounds.upper_x;
+		}
 
-		if (dst_bounds.upper_y &lt; src_bounds.upper_y)
+		if (dst_bounds.upper_y &lt; src_bounds.upper_y) {
 			dst_bounds.upper_y = src_bounds.upper_y;
+		}
 
-		if (dst_bounds.upper_z &lt; src_bounds.upper_z)
+		if (dst_bounds.upper_z &lt; src_bounds.upper_z) {
 			dst_bounds.upper_z = src_bounds.upper_z;
+		}
 
 		OctreeLevelDim dst_dim;
 
@@ -556,23 +586,29 @@ void Octree&lt;PointSourceType&gt;::updateOctreeContent(std::vector&lt;Eigen::Vector3i&gt; n
 
 			if (isOccupied(nid, level)) {
 				// If the node is occupied, update the current content
-				if (p.x &lt; node.lx)
+				if (p.x &lt; node.lx) {
 					node.lx = p.x;
+				}
 
-				if (p.y &lt; node.ly)
+				if (p.y &lt; node.ly) {
 					node.ly = p.y;
+				}
 
-				if (p.z &lt; node.lz)
+				if (p.z &lt; node.lz) {
 					node.lz = p.z;
+				}
 
-				if (p.x &gt; node.ux)
+				if (p.x &gt; node.ux) {
 					node.ux = p.x;
+				}
 
-				if (p.y &gt; node.uy)
+				if (p.y &gt; node.uy) {
 					node.uy = p.y;
+				}
 
-				if (p.z &gt; node.uz)
+				if (p.z &gt; node.uz) {
 					node.uz = p.z;
+				}
 
 
 				node.centroid = node.centroid * node.point_num + point;
@@ -636,26 +672,29 @@ double Octree&lt;PointSourceType&gt;::dist(OctreeNode node, PointSourceType p)
 	double dx, dy, dz;
 
 
-	if (p.x &lt; node.lx)
+	if (p.x &lt; node.lx) {
 		dx = node.lx - p.x;
-	else if (p.x &gt; node.ux)
+	} else if (p.x &gt; node.ux) {
 		dx = p.x - node.ux;
-	else
+	} else {
 		dx = 0;
+	}
 
-	if (p.y &lt; node.ly)
+	if (p.y &lt; node.ly) {
 		dy = node.ly - p.y;
-	else if (p.y &gt; node.uy)
+	} else if (p.y &gt; node.uy) {
 		dy = p.y - node.uy;
-	else
+	} else {
 		dy = 0;
+	}
 
-	if (p.z &lt; node.lz)
+	if (p.z &lt; node.lz) {
 		dz = node.lz - p.z;
-	else if (p.z &gt; node.uz)
+	} else if (p.z &gt; node.uz) {
 		dz = p.z - node.uz;
-	else
+	} else {
 		dz = 0;
+	}
 
 	return sqrt(dx * dx + dy * dy + dz * dz);
 }
@@ -773,8 +812,9 @@ void Octree&lt;PointSourceType&gt;::goDown(Eigen::Matrix&lt;int, 4, 1&gt; node, PointSourceT
 {
 	int id = index2id(node(0), node(1), node(2), node(3));
 
-	if (!isOccupied(id, node(3)))
+	if (!isOccupied(id, node(3))) {
 		return;
+	}
 
 	std::vector&lt;OctreeNode&gt; &amp;cur_level = (*octree_)[node(3)];
 	OctreeNode cur_node = cur_level[id];
@@ -791,8 +831,9 @@ void Octree&lt;PointSourceType&gt;::goDown(Eigen::Matrix&lt;int, 4, 1&gt; node, PointSourceT
 
 	double cur_dist = dist(cur_node, q);
 
-	if (cur_dist &gt; min_range)
+	if (cur_dist &gt; min_range) {
 		return;
+	}
 
 	// Check children
 	int level = node(3) - 1;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" added_lines="8" deleted_lines="4">
				<diff>@@ -270,6 +270,7 @@ void VoxelGrid&lt;PointSourceType&gt;::computeCentroidAndCovariance()
 				if (ipoint_num &gt; 0) {
 					(*centroid_)[i] = pt_sum / point_num;
 				}
+
 				Eigen::Matrix3d covariance;
 
 				if (ipoint_num &gt;= min_points_per_voxel_) {
@@ -370,10 +371,11 @@ void VoxelGrid&lt;PointSourceType&gt;::findBoundaries()
 	vgrid_y_ = max_b_y_ - min_b_y_ + 1;
 	vgrid_z_ = max_b_z_ - min_b_z_ + 1;
 
-	if (vgrid_x_ &gt; 0 &amp;&amp; vgrid_y_ &gt; 0 &amp;&amp; vgrid_z_ &gt; 0)
+	if (vgrid_x_ &gt; 0 &amp;&amp; vgrid_y_ &gt; 0 &amp;&amp; vgrid_z_ &gt; 0) {
 		voxel_num_ = vgrid_x_ * vgrid_y_ * vgrid_z_;
-	else
+	} else {
 		voxel_num_ = 0;
+	}
 }
 
 template &lt;typename PointSourceType&gt;
@@ -527,8 +529,9 @@ double VoxelGrid&lt;PointSourceType&gt;::nearestNeighborDistance(PointSourceType q, fl
 	Eigen::Vector3d c = (*centroid_)[nn_vid];
 	double min_dist = sqrt((q.x - c(0)) * (q.x - c(0)) + (q.y - c(1)) * (q.y - c(1)) + (q.z - c(2)) * (q.z - c(2)));
 
-	if (min_dist &gt;= max_range)
+	if (min_dist &gt;= max_range) {
 		return DBL_MAX;
+	}
 
 	return min_dist;
 
@@ -673,8 +676,9 @@ void VoxelGrid&lt;PointSourceType&gt;::updateBoundaries(float max_x, float max_y, floa
 template &lt;typename PointSourceType&gt;
 void VoxelGrid&lt;PointSourceType&gt;::update(typename pcl::PointCloud&lt;PointSourceType&gt;::Ptr new_cloud)
 {
-	if (new_cloud-&gt;points.size() &lt;= 0)
+	if (new_cloud-&gt;points.size() &lt;= 0) {
 		return;
+	}
 
 	float new_max_x, new_max_y, new_max_z;
 	float new_min_x, new_min_y, new_min_z;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="800c531b359286f626efc49f06c870f8af40b914" author="Akihito OHSATO">
		<msg>Fix queue sizes of pubs/subs for ensuring real-time</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -1571,26 +1571,26 @@ int main(int argc, char** argv)
   initial_pose.yaw = 0.0;
 
   // Publishers
-  predict_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose", 1000);
-  predict_pose_imu_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose_imu", 1000);
-  predict_pose_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose_odom", 1000);
-  predict_pose_imu_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose_imu_odom", 1000);
-  ndt_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/ndt_pose", 1000);
-  // current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/current_pose", 1000);
-  localizer_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/localizer_pose", 1000);
-  estimate_twist_pub = nh.advertise&lt;geometry_msgs::TwistStamped&gt;("/estimate_twist", 1000);
-  estimated_vel_mps_pub = nh.advertise&lt;std_msgs::Float32&gt;("/estimated_vel_mps", 1000);
-  estimated_vel_kmph_pub = nh.advertise&lt;std_msgs::Float32&gt;("/estimated_vel_kmph", 1000);
-  estimated_vel_pub = nh.advertise&lt;geometry_msgs::Vector3Stamped&gt;("/estimated_vel", 1000);
-  time_ndt_matching_pub = nh.advertise&lt;std_msgs::Float32&gt;("/time_ndt_matching", 1000);
-  ndt_stat_pub = nh.advertise&lt;autoware_msgs::ndt_stat&gt;("/ndt_stat", 1000);
-  ndt_reliability_pub = nh.advertise&lt;std_msgs::Float32&gt;("/ndt_reliability", 1000);
+  predict_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose", 10);
+  predict_pose_imu_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose_imu", 10);
+  predict_pose_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose_odom", 10);
+  predict_pose_imu_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose_imu_odom", 10);
+  ndt_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/ndt_pose", 10);
+  // current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/current_pose", 10);
+  localizer_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/localizer_pose", 10);
+  estimate_twist_pub = nh.advertise&lt;geometry_msgs::TwistStamped&gt;("/estimate_twist", 10);
+  estimated_vel_mps_pub = nh.advertise&lt;std_msgs::Float32&gt;("/estimated_vel_mps", 10);
+  estimated_vel_kmph_pub = nh.advertise&lt;std_msgs::Float32&gt;("/estimated_vel_kmph", 10);
+  estimated_vel_pub = nh.advertise&lt;geometry_msgs::Vector3Stamped&gt;("/estimated_vel", 10);
+  time_ndt_matching_pub = nh.advertise&lt;std_msgs::Float32&gt;("/time_ndt_matching", 10);
+  ndt_stat_pub = nh.advertise&lt;autoware_msgs::ndt_stat&gt;("/ndt_stat", 10);
+  ndt_reliability_pub = nh.advertise&lt;std_msgs::Float32&gt;("/ndt_reliability", 10);
 
   // Subscribers
   ros::Subscriber param_sub = nh.subscribe("config/ndt", 10, param_callback);
   ros::Subscriber gnss_sub = nh.subscribe("gnss_pose", 10, gnss_callback);
-  //  ros::Subscriber map_sub = nh.subscribe("points_map", 10, map_callback);
-  ros::Subscriber initialpose_sub = nh.subscribe("initialpose", 1000, initialpose_callback);
+  //  ros::Subscriber map_sub = nh.subscribe("points_map", 1, map_callback);
+  ros::Subscriber initialpose_sub = nh.subscribe("initialpose", 10, initialpose_callback);
   ros::Subscriber points_sub = nh.subscribe("filtered_points", _queue_size, points_callback);
   ros::Subscriber odom_sub = nh.subscribe("/odom_pose", _queue_size * 10, odom_callback);
   ros::Subscriber imu_sub = nh.subscribe(_imu_topic.c_str(), _queue_size * 10, imu_callback);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1edc87397d0b318c21741caaa656ee47287c3fcb" author="anhnv3991">
		<msg>Disable cudaHostRegister on arm64 systems.
Need to test on drivePx2.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\Registration.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\Registration.h" added_lines="0" deleted_lines="1">
				<diff>@@ -9,7 +9,6 @@
 #include "common.h"
 #include &lt;eigen3/Eigen/Dense&gt;
 #include &lt;eigen3/Eigen/Geometry&gt;
-#include &lt;velodyne_pointcloud/point_types.h&gt;
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl/point_cloud.h&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\Registration.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\Registration.cu" added_lines="16" deleted_lines="0">
				<diff>@@ -170,7 +170,9 @@ void GRegistration::setInputSource(pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr input)
 		pcl::PointXYZI *host_tmp = input-&gt;points.data();
 
 		// Pin the host buffer for accelerating the memory copy
+#ifndef __aarch64__
 		checkCudaErrors(cudaHostRegister(host_tmp, sizeof(pcl::PointXYZI) * points_number_, cudaHostRegisterDefault));
+#endif
 
 		checkCudaErrors(cudaMemcpy(tmp, host_tmp, sizeof(pcl::PointXYZI) * points_number_, cudaMemcpyHostToDevice));
 
@@ -228,7 +230,9 @@ void GRegistration::setInputSource(pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr input)
 		checkCudaErrors(cudaFree(tmp));
 
 		// Unpin host buffer
+#ifndef __aarch64__
 		checkCudaErrors(cudaHostUnregister(host_tmp));
+#endif
 	}
 }
 
@@ -245,7 +249,9 @@ void GRegistration::setInputSource(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr input)
 		pcl::PointXYZ *host_tmp = input-&gt;points.data();
 
 		// Pin the host buffer for accelerating the memory copy
+#ifndef __aarch64__
 		checkCudaErrors(cudaHostRegister(host_tmp, sizeof(pcl::PointXYZ) * points_number_, cudaHostRegisterDefault));
+#endif
 
 		checkCudaErrors(cudaMemcpy(tmp, host_tmp, sizeof(pcl::PointXYZ) * points_number_, cudaMemcpyHostToDevice));
 
@@ -299,7 +305,9 @@ void GRegistration::setInputSource(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr input)
 		checkCudaErrors(cudaMemcpy(trans_z_, z_, sizeof(float) * points_number_, cudaMemcpyDeviceToDevice));
 
 		checkCudaErrors(cudaFree(tmp));
+#ifndef __aarch64__
 		checkCudaErrors(cudaHostUnregister(host_tmp));
+#endif
 	}
 }
 
@@ -317,7 +325,9 @@ void GRegistration::setInputTarget(pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr input)
 
 		pcl::PointXYZI *host_tmp = input-&gt;points.data();
 
+#ifndef __aarch64__
 		checkCudaErrors(cudaHostRegister(host_tmp, sizeof(pcl::PointXYZI) * target_points_number_, cudaHostRegisterDefault));
+#endif
 
 		checkCudaErrors(cudaMemcpy(tmp, host_tmp, sizeof(pcl::PointXYZI) * target_points_number_, cudaMemcpyHostToDevice));
 
@@ -347,7 +357,9 @@ void GRegistration::setInputTarget(pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr input)
 		checkCudaErrors(cudaGetLastError());
 		checkCudaErrors(cudaDeviceSynchronize());
 
+#ifndef __aarch64__
 		checkCudaErrors(cudaHostUnregister(host_tmp));
+#endif
 		checkCudaErrors(cudaFree(tmp));
 	}
 }
@@ -363,7 +375,9 @@ void GRegistration::setInputTarget(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr input)
 
 		pcl::PointXYZ *host_tmp = input-&gt;points.data();
 
+#ifndef __aarch64__
 		checkCudaErrors(cudaHostRegister(host_tmp, sizeof(pcl::PointXYZ) * target_points_number_, cudaHostRegisterDefault));
+#endif
 
 		checkCudaErrors(cudaMemcpy(tmp, host_tmp, sizeof(pcl::PointXYZ) * target_points_number_, cudaMemcpyHostToDevice));
 
@@ -394,7 +408,9 @@ void GRegistration::setInputTarget(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr input)
 		checkCudaErrors(cudaDeviceSynchronize());
 
 		checkCudaErrors(cudaFree(tmp));
+#ifndef __aarch64__
 		checkCudaErrors(cudaHostUnregister(host_tmp));
+#endif
 	}
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d82963496edb870812dd6c3cc03e4e65aa01b500" author="Abraham Monrroy">
		<msg>[feature] Add timeout to the grasshopper camera node. (#1154)

* Added timeout to the grasshopper camera node.

* Added timeout to the launch file</msg>
		<modified_files>
			<file old_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\grasshopper3\grasshopper3.cpp" new_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\grasshopper3\grasshopper3.cpp" added_lines="39" deleted_lines="9">
				<diff>@@ -146,7 +146,8 @@ void initialize_cameras(std::vector&lt;FlyCapture2::Camera *&gt; &amp;cameras,
                         FlyCapture2::BusManager *bus_manger,
                         int camera_num,
                         FlyCapture2::Mode desired_mode,
-                        FlyCapture2::PixelFormat desired_pixel_format)
+                        FlyCapture2::PixelFormat desired_pixel_format,
+                        int timeout_ms)
 {
 	// Connect to all detected cameras and attempt to set them to
 	// a common video mode and frame rate
@@ -269,6 +270,26 @@ void initialize_cameras(std::vector&lt;FlyCapture2::Camera *&gt; &amp;cameras,
 			ROS_ERROR("Selected Mode not supported, using last working mode.");
 		}
 
+		FlyCapture2::FC2Config camera_config;
+		error = camera-&gt;GetConfiguration(&amp;camera_config);
+		if (error != FlyCapture2::PGRERROR_OK)
+		{
+			error.PrintErrorTrace();
+			ROS_INFO("Could not read configuration from Camera");
+		}
+		else
+		{
+			if (timeout_ms &gt; 0)
+				camera_config.grabTimeout = timeout_ms;
+
+			error = camera-&gt;SetConfiguration(&amp;camera_config);
+			if (error != FlyCapture2::PGRERROR_OK)
+			{
+				error.PrintErrorTrace();
+				ROS_INFO("Could not set configuration on Camera");
+			}
+		}
+
 		print_camera_info(&amp;camera_info);
 		cameras.push_back(camera);
 	}
@@ -359,11 +380,12 @@ void getMatricesFromFile(const ros::NodeHandle&amp; nh, sensor_msgs::CameraInfo &amp;cam
 /*!
  * Reads the params from the console
  * @param private_nh[in] Private Ros node handle
- * @param fps[out] Read value from the console
- * @param mode[out] Read value from the console
- * @param format[out] Read value from the console
+ * @param fps[out] Read value from the console double
+ * @param mode[out] Read value from the console integer
+ * @param format[out] Read value from the console raw or rgb
+ * @param timeout[out] Read value from the console timeout in ms
  */
-void ros_get_params(const ros::NodeHandle&amp; private_nh, int&amp; fps, int&amp; mode, std::string&amp; format)
+void ros_get_params(const ros::NodeHandle&amp; private_nh, int&amp; fps, int&amp; mode, std::string&amp; format, int&amp; timeout)
 {
 	if (private_nh.getParam("fps", fps))
 	{
@@ -389,6 +411,14 @@ void ros_get_params(const ros::NodeHandle&amp; private_nh, int&amp; fps, int&amp; mode, std:
 		ROS_INFO("No param received, defaulting format to %s", format.c_str());
 	}
 
+	if (private_nh.getParam("timeout", timeout))
+	{
+		ROS_INFO("timeout set to %d ms", timeout);
+	} else {
+		timeout = 1000;
+		ROS_INFO("No param received, defaulting timeout to %d ms", timeout);
+	}
+
 }
 
 int main(int argc, char **argv)
@@ -403,10 +433,10 @@ int main(int argc, char **argv)
 
 	signal(SIGTERM, signal_handler);//detect closing
 
-	int fps, camera_mode;
+	int fps, camera_mode, timeout;
 	std::string pixel_format;
 
-	ros_get_params(private_nh, fps, camera_mode, pixel_format);
+	ros_get_params(private_nh, fps, camera_mode, pixel_format, timeout);
 
 	//
 	FlyCapture2::Mode desired_mode;
@@ -426,7 +456,7 @@ int main(int argc, char **argv)
 	//init cameras
 	int camera_num = get_num_cameras(&amp;busMgr);
 	std::vector&lt;FlyCapture2::Camera*&gt; cameras;
-	initialize_cameras(cameras, &amp;busMgr, camera_num, desired_mode, desired_pixel_format);
+	initialize_cameras(cameras, &amp;busMgr, camera_num, desired_mode, desired_pixel_format, timeout);
 
 	///////calibration data
 	sensor_msgs::CameraInfo camerainfo_msg;
@@ -463,7 +493,7 @@ int main(int argc, char **argv)
 			if (error != FlyCapture2::PGRERROR_OK)
 			{
 				error.PrintErrorTrace();
-				std::exit(-1);
+				continue;
 			}
 
 			// check encoding pattern
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="deacca616d8b2cffbd636ba3300d85bcc0fcdb0c" author="Abraham Monrroy">
		<msg>[feature] vlc32c driver, velodyne drivers updated (#1166)

* Squashed 'ros/src/sensing/drivers/lidar/packages/velodyne/' changes from 776a358..1a70413

1a70413 Merge branch 'master' into Autoware
7976d12 support vlp32c now
273520e Added hdl32c, fixed naming
e21b522 Merge pull request #146 from stsundermann/patch-2
0e5a200 Merge pull request #150 from ros-drivers/mikaelarguedas-patch-1
db6b5ee update to use non deprecated pluginlib macro
560fe12 Use std::abs instead of fabsf

git-subtree-dir: ros/src/sensing/drivers/lidar/packages/velodyne
git-subtree-split: 1a704135c529c5d2995cd2c1972ca4f59d5ae1ad

* Squashed 'ros/src/sensing/drivers/lidar/packages/velodyne/' changes from 1a70413..52c0a0d

52c0a0d README format

git-subtree-dir: ros/src/sensing/drivers/lidar/packages/velodyne
git-subtree-split: 52c0a0d63594ee71a156755954d240d24966829e

* Squashed 'ros/src/sensing/drivers/lidar/packages/velodyne/' changes from 52c0a0d..a1d6f18

a1d6f18 Update and rename README.rst to README.md

git-subtree-dir: ros/src/sensing/drivers/lidar/packages/velodyne
git-subtree-split: a1d6f186d3340f3ce5059e234ed7e3dcb828d09d</msg>
		<modified_files>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\src\driver\driver.cc" new_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\src\driver\driver.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -60,7 +60,7 @@ VelodyneDriver::VelodyneDriver(ros::NodeHandle node,
     }
     else if (config_.model == "32C")
     {
-      packet_rate = 1808.0;
+      packet_rate = 1507.0;
       model_full_name = std::string("VLP-") + config_.model;
     }
   else if (config_.model == "VLP16")
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_laserscan\src\VelodyneLaserScan.cpp" new_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_laserscan\src\VelodyneLaserScan.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -96,7 +96,7 @@ void VelodyneLaserScan::recvCallback(const sensor_msgs::PointCloud2ConstPtr&amp; msg
 
   // Construct LaserScan message
   if ((offset_x &gt;= 0) &amp;&amp; (offset_y &gt;= 0) &amp;&amp; (offset_r &gt;= 0)) {
-    const float RESOLUTION = fabsf(cfg_.resolution);
+    const float RESOLUTION = std::abs(cfg_.resolution);
     const size_t SIZE = 2.0 * M_PI / RESOLUTION;
     sensor_msgs::LaserScanPtr scan(new sensor_msgs::LaserScan());
     scan-&gt;header = msg-&gt;header;
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_laserscan\src\nodelet.cpp" new_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_laserscan\src\nodelet.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -21,4 +21,4 @@ private:
 
 }
 
-PLUGINLIB_DECLARE_CLASS(velodyne_laserscan, LaserScanNodelet, velodyne_laserscan::LaserScanNodelet, nodelet::Nodelet);
+PLUGINLIB_EXPORT_CLASS(velodyne_laserscan::LaserScanNodelet, nodelet::Nodelet);
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\include\velodyne_pointcloud\rawdata.h" new_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\include\velodyne_pointcloud\rawdata.h" added_lines="1" deleted_lines="1">
				<diff>@@ -146,7 +146,7 @@ namespace velodyne_rawdata
      */
     int setupOffline(std::string calibration_file, double max_range_, double min_range_);
 
-    void unpack(const velodyne_msgs::VelodynePacket &amp;pkt, VPointCloud &amp;pc);
+    void unpack(const velodyne_msgs::VelodynePacket &amp;pkt, VPointCloud &amp;pc, int packets_num);
     
     void setParameters(double min_range, double max_range, double view_direction,
                        double view_width);
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\convert.cc" new_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\convert.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -69,7 +69,7 @@ namespace velodyne_pointcloud
     // process each packet provided by the driver
     for (size_t i = 0; i &lt; scanMsg-&gt;packets.size(); ++i)
       {
-        data_-&gt;unpack(scanMsg-&gt;packets[i], *outMsg);
+        data_-&gt;unpack(scanMsg-&gt;packets[i], *outMsg, scanMsg-&gt;packets.size());
       }
 
     // publish the accumulated cloud message
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\transform.cc" new_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\transform.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -91,7 +91,7 @@ namespace velodyne_pointcloud
         pcl_conversions::toPCL(header, inPc_.header);
 
         // unpack the raw data
-        data_-&gt;unpack(scanMsg-&gt;packets[next], inPc_);
+        data_-&gt;unpack(scanMsg-&gt;packets[next], inPc_, scanMsg-&gt;packets.size());
 
         // clear transform point cloud for this packet
         tfPc_.points.clear();           // is this needed?
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\lib\rawdata.cc" new_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\lib\rawdata.cc" added_lines="8" deleted_lines="2">
				<diff>@@ -144,7 +144,7 @@ namespace velodyne_rawdata
    *  @param pc shared pointer to point cloud (points are appended)
    */
   void RawData::unpack(const velodyne_msgs::VelodynePacket &amp;pkt,
-                       VPointCloud &amp;pc)
+                       VPointCloud &amp;pc, int packets_num)
   {
     ROS_DEBUG_STREAM("Received packet, time: " &lt;&lt; pkt.stamp);
     
@@ -190,7 +190,13 @@ namespace velodyne_rawdata
              ||(config_.min_angle &gt; config_.max_angle 
              &amp;&amp; (raw-&gt;blocks[i].rotation &lt;= config_.max_angle 
              || raw-&gt;blocks[i].rotation &gt;= config_.min_angle))){
-          float distance = tmp.uint * DISTANCE_RESOLUTION;
+
+          float distance;
+          if (packets_num==(int) ceil(1507.0 / 10))
+            distance = tmp.uint * DISTANCE_RESOLUTION * 2;
+          else
+            distance = tmp.uint * DISTANCE_RESOLUTION;
+
           distance += corrections.dist_correction;
   
           float cos_vert_angle = corrections.cos_vert_correction;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="67cf8a90ea2d2f3c829b92fc146088868f9e239e" author="Yuma">
		<msg>Add velocity plan offset for system delay</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" added_lines="3" deleted_lines="2">
				<diff>@@ -54,6 +54,7 @@ namespace waypoint_maker
     private_nh_.param&lt;double&gt;("radius_min", r_min_, 6.0);
     private_nh_.param&lt;int&gt;("lookup_curve_width", lkup_crv_width_, 5);
     private_nh_.param&lt;double&gt;("resample_interval", resample_interval_, 1.0);
+    private_nh_.param&lt;int&gt;("delay_offset", delay_offset_, 6);
     r_inf_ = 10 * r_max_;
   }
 
@@ -78,8 +79,8 @@ namespace waypoint_maker
     //set curve_velocity on curve begining
     for(const auto&amp; el : curve_list)
     {
-      const unsigned long start_idx = el.first;
-      const unsigned long end_idx = el.second.first;
+      const unsigned long start_idx = (el.first &gt; delay_offset_) ? (el.first - delay_offset_) : 0;
+      const unsigned long end_idx = (el.second.first &gt; delay_offset_) ? (el.second.first - delay_offset_) : 0;
       const double radius = el.second.second;
       const double vmax = velocity_max_;
       const double vmin = vel_param[0] * radius + vel_param[1];
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" added_lines="1" deleted_lines="0">
				<diff>@@ -48,6 +48,7 @@ private:
   int lkup_crv_width_;
   double velocity_max_, velocity_min_;
   double accel_limit_, decel_limit_, resample_interval_;
+  int delay_offset_;
 public:
   WaypointFilter();
   ~WaypointFilter();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d51e4e85e833a7489bb4197f810255ed4e6ffa13" author="Yuki Iida">
		<msg>add button of hev program status</msg>
		<modified_files>
			<file old_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_sender\mqtt_sender.cpp" new_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_sender\mqtt_sender.cpp" added_lines="34" deleted_lines="4">
				<diff>@@ -44,6 +44,7 @@
 using namespace std;
 #include "mqtt_socket/mqtt_setting.hpp"
 #include "autoware_msgs/CanInfo.h"
+#include &lt;tablet_socket_msgs/mode_info.h&gt;
 
 class MqttSender
 {
@@ -61,6 +62,7 @@ private:
   void twistCmdCallback(const geometry_msgs::TwistStamped &amp;msg);
   void stateCallback(const std_msgs::String &amp;msg);
   void currentPoseCallback(const geometry_msgs::PoseStamped&amp; msg);
+  void modeInfoCallback(const tablet_socket_msgs::mode_info&amp; msg);
   unordered_map&lt;string, ros::Subscriber&gt; Subs;
   ros::NodeHandle node_handle_;
 
@@ -70,6 +72,7 @@ private:
   string mqtt_topic_target_velocity_;
   string mqtt_topic_current_target_velocity_;
   string mqtt_topic_current_pose_;
+  string mqtt_topic_drive_mode_;
 
   // current behavior/status
   std_msgs::Float64MultiArray current_target_velocity_array_; //kmph
@@ -77,7 +80,8 @@ private:
   double current_target_velocity_; // mps2kmph(current_twist_cmd_.twist.twist.linear.x);
   std_msgs::String current_state_;
 
-  int callback_counter_ = 0;
+  int can_info_callback_counter_ = 0;
+  int mode_info_callback_counter_ = 0;
 };
 
 inline double mps2kmph(double _mpsval)
@@ -93,6 +97,7 @@ MqttSender::MqttSender() :
   Subs["target_velocity_array"] = node_handle_.subscribe("/target_velocity_array", 1, &amp;MqttSender::targetVelocityArrayCallback, this);
   Subs["twist_cmd"] = node_handle_.subscribe("/twist_cmd", 1, &amp;MqttSender::twistCmdCallback, this);
   Subs["state"] = node_handle_.subscribe("/state", 1, &amp;MqttSender::stateCallback, this);
+  Subs["drive_mode"] = node_handle_.subscribe("/mode_info", 1, &amp;MqttSender::modeInfoCallback, this);
   Subs["current_pose"] = node_handle_.subscribe("/current_pose", 1, &amp;MqttSender::currentPoseCallback, this);
 
   // MQTT PARAMS
@@ -106,6 +111,7 @@ MqttSender::MqttSender() :
   mqtt_topic_target_velocity_ = "vehicle/" + to_string(vehicle_id) + "/target_velocity";
   mqtt_topic_current_target_velocity_ = "vehicle/" + to_string(vehicle_id) + "/current_velocity";
   mqtt_topic_current_pose_ = "vehicle/" + to_string(vehicle_id) + "/current_pose";
+  mqtt_topic_drive_mode_ = "vehicle/" + to_string(vehicle_id) + "/drive_mode";
 
   mqtt_client = mosquitto_new(mqtt_client_id.c_str(), true, NULL);
   mosquitto_connect_callback_set(mqtt_client, &amp;MqttSender::on_connect);
@@ -242,10 +248,34 @@ void MqttSender::currentPoseCallback(const geometry_msgs::PoseStamped&amp; msg)
   );
 }
 
+void MqttSender::modeInfoCallback(const tablet_socket_msgs::mode_info&amp; msg)
+{
+  if(mode_info_callback_counter_ &gt; caninfo_downsample * 100) {
+    ostringstream publish_msg;
+    publish_msg &lt;&lt; to_string(msg.mode);
+    string publish_msg_str = publish_msg.str();
+    ROS_INFO("Drive Mode: %s\n", publish_msg_str.c_str());
+
+    int ret = mosquitto_publish(
+      mqtt_client,
+      NULL,
+      mqtt_topic_drive_mode_.c_str(),
+      strlen(publish_msg_str.c_str()),
+      publish_msg_str.c_str(),
+      mqtt_qos,
+      false
+    );
+    mode_info_callback_counter_ = 0;
+  }
+  else {
+    mode_info_callback_counter_++;
+  }
+}
+
 void MqttSender::canInfoCallback(const autoware_msgs::CanInfoConstPtr &amp;msg)
 {
 
-  if(callback_counter_ &gt; caninfo_downsample * 100) {
+  if(can_info_callback_counter_ &gt; caninfo_downsample * 100) {
     ostringstream publish_msg;
 
     publish_msg &lt;&lt; msg-&gt;tm &lt;&lt; ",";
@@ -322,10 +352,10 @@ void MqttSender::canInfoCallback(const autoware_msgs::CanInfoConstPtr &amp;msg)
       false
     );
 
-    callback_counter_ = 0;
+    can_info_callback_counter_ = 0;
   }
   else {
-    callback_counter_++;
+    can_info_callback_counter_++;
   }
 }
 
</diff>
			</file>
			<file old_path="ui\web\remote_monitor\public\css\button.css" new_path="ui\web\remote_monitor\public\css\button.css" added_lines="44" deleted_lines="0">
				<diff>@@ -385,6 +385,50 @@ a.bt-emergency:active{
   box-shadow: none;
 }
 
+a.bt-drive-mode {
+  display: block;
+  height: 40px;
+  width: 90%;
+  margin: 5px;
+  padding:1px;
+  text-decoration: none;
+  line-height: 40px;
+  color: #fff;
+  font-size:16px;
+  text-shadow: 0px -1px 0px #af6d01;
+  background: #fff;
+  border: 1px solid #fff;
+  border-radius: 20px;
+  -webkit-box-shadow: 1px 1px 2px #ccc;
+  -moz-box-shadow: 1px 1px 2px #ccc;
+  box-shadow: 1px 1px 2px #ccc;
+  -webkit-transition: 0.3s;
+  -moz-transition: 0.3s;
+  -o-transition: 0.3s;
+  -ms-transition: 0.3s;
+  transition: 0.3s;
+}
+a.bt-drive-mode span{
+  display: block;
+  height: 100%;
+  width: 100%;
+  text-align: center;
+  background: #00a3e0;
+  background: -moz-linear-gradient(top,  #00a3e0,  #00a3e0);
+  background: -o-linear-gradient(top,  #00a3e0,  #00a3e0);
+  background: -ms-linear-gradient(top,  #00a3e0,  #00a3e0);
+  background: linear-gradient(top,  #00a3e0,  #00a3e0);
+  border-radius: 20px;
+}
+a.bt-drive-mode:hover{
+  opacity: 0.5;
+}
+a.bt-drive-mode:active{
+  -ms-transform: translateY(2px);
+  -webkit-transform: translateY(2px);
+  transform: translateY(2px);
+  box-shadow: none;
+}
 
 a.bt-controlmode {
   display: block;
</diff>
			</file>
			<file old_path="ui\web\remote_monitor\template\operator_window.html" new_path="ui\web\remote_monitor\template\operator_window.html" added_lines="1" deleted_lines="0">
				<diff>@@ -175,6 +175,7 @@
       &lt;div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"&gt;
         &lt;center&gt;
           &lt;a href="#" class="bt-emergency" onclick="select_emergency_button();"&gt;&lt;span id="emergency_button"&gt;EMEGENCY&lt;/span&gt;&lt;/a&gt;
+          &lt;a href="#" class="bt-drive-mode" onclick="select_drive_mode_button(2);"&gt;&lt;span id="drive_mode_button"&gt;MANUAL&lt;/span&gt;&lt;/a&gt;
           &lt;a href="#" class="bt-controlmode" onclick="select_mode_button();"&gt;&lt;span id="control_mode_button"&gt;AUTO&lt;/span&gt;&lt;/a&gt;
         &lt;/center&gt;
 
</diff>
			</file>
			<file old_path="ui\web\remote_monitor\template\vehicle_window.html" new_path="ui\web\remote_monitor\template\vehicle_window.html" added_lines="4" deleted_lines="13">
				<diff>@@ -183,19 +183,10 @@
       &lt;/div&gt;
 
       &lt;div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"&gt;
-        &lt;div class="onoffswitch"&gt;
-            &lt;input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="emergencyswitch" checked onchange="select_emergency_button();"&gt;
-            &lt;label class="onoffswitch-label" for="emergencyswitch"&gt;
-                &lt;span class="emergencyswitch-inner"&gt;&lt;/span&gt;
-            &lt;/label&gt;
-        &lt;/div&gt;
-
-        &lt;div class="onoffswitch"&gt;
-          &lt;input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="modeswitch" checked onchange="select_mode_button();"&gt;
-          &lt;label class="onoffswitch-label" for="modeswitch"&gt;
-              &lt;span class="modeswitch-inner"&gt;&lt;/span&gt;
-          &lt;/label&gt;
-        &lt;/div&gt;
+        &lt;center&gt;
+          &lt;a href="#" class="bt-drive-mode"&gt;&lt;span id="drive_mode_button"&gt;MANUAL&lt;/span&gt;&lt;/a&gt;
+          &lt;a href="#" class="bt-controlmode"&gt;&lt;span id="control_mode_button"&gt;AUTO&lt;/span&gt;&lt;/a&gt;
+        &lt;/center&gt;
       &lt;/div&gt;
     &lt;/div&gt;
   &lt;/div&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="96b8a05567c500c8b0bc1eb6b5a30800c7cdc039" author="Yuma">
		<msg>Add config_callback for online waypoint tuning</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" added_lines="14" deleted_lines="12">
				<diff>@@ -44,22 +44,24 @@ namespace waypoint_maker
 
   WaypointFilter::WaypointFilter():private_nh_("~")
   {
-    private_nh_.param&lt;double&gt;("velocity_max", velocity_max_, 40.0);
-    velocity_max_ = kmph2mps(velocity_max_);
-    private_nh_.param&lt;double&gt;("velocity_min", velocity_min_, 4.0);
-    velocity_min_ = kmph2mps(velocity_min_);
-    private_nh_.param&lt;double&gt;("accel_limit", accel_limit_, 0.15 * 9.8);
-    private_nh_.param&lt;double&gt;("decel_limit", decel_limit_, 0.15 * 9.8);
-    private_nh_.param&lt;double&gt;("radius_max", r_max_, 20.0);
-    private_nh_.param&lt;double&gt;("radius_min", r_min_, 6.0);
-    private_nh_.param&lt;int&gt;("lookup_curve_width", lkup_crv_width_, 5);
-    private_nh_.param&lt;double&gt;("resample_interval", resample_interval_, 1.0);
-    private_nh_.param&lt;int&gt;("delay_offset", delay_offset_, 6);
-    r_inf_ = 10 * r_max_;
   }
 
   WaypointFilter::~WaypointFilter(){}
 
+  void WaypointFilter::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
+  {
+    velocity_max_ = kmph2mps(conf-&gt;velocity_max);
+    velocity_min_ = kmph2mps(conf-&gt;velocity_min);
+    accel_limit_ = conf-&gt;accel_limit;
+    decel_limit_ = conf-&gt;decel_limit;
+    r_max_ = conf-&gt;radius_max;
+    r_min_ = conf-&gt;radius_min;
+    lkup_crv_width_ = 5;
+    resample_interval_ = conf-&gt;resample_interval;
+    delay_offset_ = conf-&gt;delay_offset;
+    r_inf_ = 10 * r_max_;
+  }
+
   void WaypointFilter::filterLaneWaypoint(autoware_msgs::lane *lane)
   {
     std::vector&lt;double&gt; curve_radius;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" added_lines="2" deleted_lines="0">
				<diff>@@ -33,6 +33,7 @@
 
 #include &lt;ros/ros.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
+#include &lt;autoware_msgs/ConfigWaypointLoader.h&gt;
 #include &lt;fstream&gt;
 #include &lt;unordered_map&gt;
 #include "autoware_msgs/lane.h"
@@ -52,6 +53,7 @@ private:
 public:
   WaypointFilter();
   ~WaypointFilter();
+  void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
   void filterLaneWaypoint(autoware_msgs::lane *lane);
 protected:
   void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane *lane, std::vector&lt;double&gt; *curve_radius);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="23" deleted_lines="19">
				<diff>@@ -36,8 +36,7 @@ namespace waypoint_maker
 // Constructor
 WaypointLoaderNode::WaypointLoaderNode() : private_nh_("~")
 {
-  initParameter();
-  initPublisher();
+  initPubSub();
 }
 
 // Destructor
@@ -45,7 +44,7 @@ WaypointLoaderNode::~WaypointLoaderNode()
 {
 }
 
-void WaypointLoaderNode::initPublisher()
+void WaypointLoaderNode::initPubSub()
 {
   // setup publisher
   if(disable_decision_maker_){
@@ -53,31 +52,36 @@ void WaypointLoaderNode::initPublisher()
   }else{
 	  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/based/lane_waypoints_array", 10, true);
   }
+  config_sub_ = nh_.subscribe("/config/waypoint_loader", 1, &amp;WaypointLoaderNode::configCallback, this);
+  output_cmd_sub_ = nh_.subscribe("/config/waypoint_loader_output", 1, &amp;WaypointLoaderNode::outputCommandCallback, this);
 }
 
-void WaypointLoaderNode::initParameter()
+void WaypointLoaderNode::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
 {
   // parameter settings
-  private_nh_.param&lt;bool&gt;("disable_decision_maker", disable_decision_maker_, true);
-  private_nh_.param&lt;bool&gt;("disable_filtering", disable_filtering_, false);
-  private_nh_.param&lt;std::string&gt;("multi_lane_csv", multi_lane_csv_, MULTI_LANE_CSV);
+  disable_decision_maker_ = conf-&gt;disable_decision_maker;
+  disable_filtering_ = conf-&gt;disable_filtering;
+  multi_lane_csv_ = conf-&gt;multi_lane_csv;
 }
 
-void WaypointLoaderNode::publishLaneArray()
+void WaypointLoaderNode::configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
 {
-  // extract file paths
-  std::vector&lt;std::string&gt; multi_file_path;
-  parseColumns(multi_lane_csv_, &amp;multi_file_path);
+  filter_.initParameter(conf);
+  initParameter(conf);
+
+  parseColumns(multi_lane_csv_, &amp;multi_file_path_);
   autoware_msgs::LaneArray lane_array;
-  createLaneArray(multi_file_path, &amp;lane_array);
+  createLaneArray(multi_file_path_, &amp;lane_array);
   lane_pub_.publish(lane_array);
-  if(!disable_filtering_)
-  {
-    std::vector&lt;std::string&gt; dst_multi_file_path = multi_file_path;
-    for(auto&amp; el : dst_multi_file_path)
-      el = addFileSuffix(el, "_filtered");
-    saveLaneArray(dst_multi_file_path, lane_array);
-  }
+  output_lane_array_ = lane_array;
+}
+
+void WaypointLoaderNode::outputCommandCallback(const std_msgs::Bool::ConstPtr&amp; output_cmd)
+{
+  std::vector&lt;std::string&gt; dst_multi_file_path = multi_file_path_;
+  for(auto&amp; el : dst_multi_file_path)
+    el = addFileSuffix(el, "_filtered");
+  saveLaneArray(dst_multi_file_path, output_lane_array_);
 }
 
 const std::string addFileSuffix(std::string file_path, std::string suffix)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="10" deleted_lines="6">
				<diff>@@ -38,6 +38,7 @@
 #include &lt;iostream&gt;
 #include &lt;fstream&gt;
 #include &lt;vector&gt;
+#include &lt;std_msgs/Bool.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
 #include &lt;unordered_map&gt;
 
@@ -76,29 +77,32 @@ public:
   WaypointLoaderNode();
   ~WaypointLoaderNode();
 
-  void publishLaneArray();
-
 private:
 
   // handle
   ros::NodeHandle nh_;
   ros::NodeHandle private_nh_;
 
-  // publisher
+  // publisher &amp; subscriber
   ros::Publisher lane_pub_;
+  ros::Subscriber config_sub_;
+  ros::Subscriber output_cmd_sub_;
 
   // variables
   std::string multi_lane_csv_;
   bool disable_decision_maker_;
   bool disable_filtering_;
   WaypointFilter filter_;
+  std::vector&lt;std::string&gt; multi_file_path_;
+  autoware_msgs::LaneArray output_lane_array_;
 
   // initializer
-  void initPublisher();
-  void initParameter();
+  void initPubSub();
+  void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
 
   // functions
-
+  void configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
+  void outputCommandCallback(const std_msgs::Bool::ConstPtr&amp; output_cmd);
   void createLaneWaypoint(const std::string &amp;file_path, autoware_msgs::lane *lane);
   void createLaneArray(const std::vector&lt;std::string&gt; &amp;paths, autoware_msgs::LaneArray *lane_array);
   void saveLaneArray(const std::vector&lt;std::string&gt; &amp;paths, const autoware_msgs::LaneArray &amp;lane_array);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_node.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_node.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -37,7 +37,6 @@ int main(int argc, char **argv)
 {
   ros::init(argc, argv, "waypoint_loader");
   waypoint_maker::WaypointLoaderNode wln;
-  wln.publishLaneArray();
   ros::spin();
 
   return 0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5efccf2513ffcd5676cdfa3c26c5f330c2cd6e17" author="Yuma">
		<msg>fix runtime_manager layout and description</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -54,12 +54,12 @@ namespace waypoint_maker
     velocity_min_ = kmph2mps(conf-&gt;velocity_min);
     accel_limit_ = conf-&gt;accel_limit;
     decel_limit_ = conf-&gt;decel_limit;
-    r_max_ = conf-&gt;radius_max;
+    r_th_ = conf-&gt;radius_thresh;
     r_min_ = conf-&gt;radius_min;
     lkup_crv_width_ = 5;
     resample_interval_ = conf-&gt;resample_interval;
-    delay_offset_ = conf-&gt;delay_offset;
-    r_inf_ = 10 * r_max_;
+    velocity_offset_ = conf-&gt;velocity_offset;
+    r_inf_ = 10 * r_th_;
   }
 
   void WaypointFilter::filterLaneWaypoint(autoware_msgs::lane *lane)
@@ -81,8 +81,8 @@ namespace waypoint_maker
     //set curve_velocity on curve begining
     for(const auto&amp; el : curve_list)
     {
-      const unsigned long start_idx = (el.first &gt; delay_offset_) ? (el.first - delay_offset_) : 0;
-      const unsigned long end_idx = (el.second.first &gt; delay_offset_) ? (el.second.first - delay_offset_) : 0;
+      const unsigned long start_idx = (el.first &gt; velocity_offset_) ? (el.first - velocity_offset_) : 0;
+      const unsigned long end_idx = (el.second.first &gt; velocity_offset_) ? (el.second.first - velocity_offset_) : 0;
       const double radius = el.second.second;
       const double vmax = velocity_max_;
       const double vmin = vel_param[0] * radius + vel_param[1];
@@ -183,8 +183,8 @@ namespace waypoint_maker
   const std::vector&lt;double&gt; WaypointFilter::calcVelParamFromVmax(const double vmax)const
   {
     std::vector&lt;double&gt; param(2, 0.0);
-    param[0] = (vmax - velocity_min_) / (r_max_ - r_min_);//bias
-    param[1] = vmax - param[0] * r_max_;//vel_intersept
+    param[0] = (vmax - velocity_min_) / (r_th_ - r_min_);//bias
+    param[1] = vmax - param[0] * r_th_;//vel_intersept
     return param;
   }
 
@@ -195,12 +195,12 @@ namespace waypoint_maker
     double radius_localmin = DBL_MAX;
     for(unsigned long i = 1; i &lt; curve_radius.size(); i++)
     {
-      if(!on_curve &amp;&amp; curve_radius[i] &lt;= r_max_ &amp;&amp; curve_radius[i -1] &gt; r_max_)
+      if(!on_curve &amp;&amp; curve_radius[i] &lt;= r_th_ &amp;&amp; curve_radius[i -1] &gt; r_th_)
       {
         index = i;
         on_curve = true;
       }
-      else if(on_curve &amp;&amp; curve_radius[i - 1] &lt;= r_max_ &amp;&amp; curve_radius[i] &gt; r_max_)
+      else if(on_curve &amp;&amp; curve_radius[i - 1] &lt;= r_th_ &amp;&amp; curve_radius[i] &gt; r_th_)
       {
         on_curve = false;
         if(radius_localmin &lt; r_min_)radius_localmin = r_min_;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" added_lines="2" deleted_lines="2">
				<diff>@@ -45,11 +45,11 @@ class WaypointFilter
 {
 private:
   ros::NodeHandle private_nh_;
-  double r_max_, r_min_, r_inf_;
+  double r_th_, r_min_, r_inf_;
   int lkup_crv_width_;
   double velocity_max_, velocity_min_;
   double accel_limit_, decel_limit_, resample_interval_;
-  int delay_offset_;
+  int velocity_offset_;
 public:
   WaypointFilter();
   ~WaypointFilter();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="81924354cbf01599cc672eeba80cbd58644cf2f7" author="eratostennis">
		<msg>Initial Working Version with region_tlr #1184</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLight.h" new_path="" added_lines="0" deleted_lines="52">
				<diff>@@ -1,52 +0,0 @@
-#ifndef TRAFFIC_LIGHT_H
-#define TRAFFIC_LIGHT_H
-
-/* External includes */
-#include &lt;cmath&gt;
-
-/* Internal includes */
-#include "TrafficLightDetector.h"
-
-/* Extra includes */
-#include "autoware_msgs/Signals.h"
-
-#define MAIN_WINDOW_NAME "Main"
-#define SETTINGS_WINDOW_NAME "Settings"
-
-#define TLR_GREEN_SIGNAL_STR "green signal"
-#define TLR_RED_SIGNAL_STR "red signal"
-#define TLR_UNKNOWN_SIGNAL_STR ""
-
-/* Functions declarations */
-void setContexts(TrafficLightDetector &amp;detector, const autoware_msgs::Signals::ConstPtr&amp; extractedPos);
-
-#define MINIMAM_RADIUS 3
-#define ROI_MARGINE 25
-
-static inline bool IsNearlyZero(double x)
-{
-  double abs_x = fabs(x);
-  int scale = 100;
-  return(abs_x &lt; DBL_MIN*scale);
-}
-
-struct valueSet {
-    double upper;
-    double lower;
-};
-
-struct hsvSet {
-    valueSet Hue;
-    valueSet Sat;
-    valueSet Val;
-};
-
-struct thresholdSet {
-    hsvSet Red;
-    hsvSet Yellow;
-    hsvSet Green;
-};
-
-//#define SHOW_DEBUG_INFO
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLightDetector.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLightDetector.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -1,4 +1,5 @@
 #include "TrafficLight.h"
+#include "RegionTLR.h"
 #include "TrafficLightDetector.h"
 
 #define BLACK CV_RGB(0, 0, 0)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -19,6 +19,7 @@
 #include &lt;autoware_msgs/TrafficLightResult.h&gt;
 
 #include "TrafficLight.h"
+#include "RegionTLR.h"
 
 thresholdSet thSet;
 
@@ -213,9 +214,6 @@ static void extractedPos_cb(const autoware_msgs::Signals::ConstPtr &amp;extractedPos
 	tlr_result_array_msg.header = extractedPos-&gt;header;
 
 	std_msgs::String state_string_msg;
-	const int32_t TRAFFIC_LIGHT_RED = 0;
-	const int32_t TRAFFIC_LIGHT_GREEN = 1;
-	const int32_t TRAFFIC_LIGHT_UNKNOWN = 2;
 	static int32_t prev_state = TRAFFIC_LIGHT_UNKNOWN;
 	state_msg.traffic_light = TRAFFIC_LIGHT_UNKNOWN;
 
@@ -488,14 +486,16 @@ int main(int argc, char *argv[])
 	ros::NodeHandle n;
 	ros::NodeHandle private_nh("~");
 	std::string image_topic_name;
+	std::string camera_light_color_topic_name;
 	private_nh.param&lt;std::string&gt;("image_raw_topic", image_topic_name, "/image_raw");
+	private_nh.param&lt;std::string&gt;("camera_light_color_topic", camera_light_color_topic_name, "/camera_light_color");
 
 	ros::Subscriber image_sub = n.subscribe(image_topic_name, 1, image_raw_cb);
 	ros::Subscriber position_sub = n.subscribe("/roi_signal", 1, extractedPos_cb);
 	ros::Subscriber tunedResult_sub = n.subscribe("/tuned_result", 1, tunedResult_cb);
 	ros::Subscriber superimpose_sub = n.subscribe("/config/superimpose", 1, superimpose_cb);
 
-	signalState_pub = n.advertise&lt;autoware_msgs::traffic_light&gt;("/light_color", ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
+	signalState_pub = n.advertise&lt;autoware_msgs::traffic_light&gt;(camera_light_color_topic_name, ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
 	signalStateString_pub = n.advertise&lt;std_msgs::String&gt;("/sound_player", ADVERTISE_QUEUE_SIZE);
 	marker_pub = n.advertise&lt;visualization_msgs::MarkerArray&gt;("tlr_result", ADVERTISE_QUEUE_SIZE);
 	superimpose_image_pub = n.advertise&lt;sensor_msgs::Image&gt;("tlr_superimpose_image", ADVERTISE_QUEUE_SIZE);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="30320de6e9ec827dbb2f26542b13332af1920299" author="anhnv3991">
		<msg>Fix the error that causes new allocated voxel grid corrupted.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" added_lines="2" deleted_lines="1">
				<diff>@@ -54,6 +54,7 @@ void VoxelGrid&lt;PointSourceType&gt;::initialize()
 
 	icovariance_.resize(voxel_num_);
 
+	points_id_.clear();
 	points_id_.resize(voxel_num_);
 
 	points_per_voxel_.resize(voxel_num_);
@@ -225,7 +226,7 @@ void VoxelGrid&lt;PointSourceType&gt;::computeCentroidAndCovariance()
 
 		if (ipoint_num &gt;= min_points_per_voxel_) {
 
-			covariance_[i] = (covariance_[i] - 2 * (pt_sum * centroid_[i].transpose())) / point_num + centroid_[i] * centroid_[i].transpose();
+			covariance_[i] = (covariance_[i] - 2.0 * (pt_sum * centroid_[i].transpose())) / point_num + centroid_[i] * centroid_[i].transpose();
 			covariance_[i] *= (point_num - 1.0) / point_num;
 
 			SymmetricEigensolver3x3 sv(covariance_[i]);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="48f1c71d085c6635e42841f63fe5ec1fd1a9b2f5" author="Yuma">
		<msg>Correspond to new version of waypoint_csv(for decision_maker)</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" added_lines="51" deleted_lines="7">
				<diff>@@ -56,7 +56,8 @@ namespace waypoint_maker
     decel_limit_ = conf-&gt;decel_limit;
     r_th_ = conf-&gt;radius_thresh;
     r_min_ = conf-&gt;radius_min;
-    lkup_crv_width_ = 5;
+    lookup_crv_width_ = 5;
+    resample_mode_ = conf-&gt;resample_mode;
     resample_interval_ = conf-&gt;resample_interval;
     velocity_offset_ = conf-&gt;velocity_offset;
     r_inf_ = 10 * r_th_;
@@ -67,7 +68,10 @@ namespace waypoint_maker
     std::vector&lt;double&gt; curve_radius;
     std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt; curve_list;
 
-    resampleLaneWaypoint(resample_interval_, lane, &amp;curve_radius);
+    if(resample_mode_)
+      resampleLaneWaypoint(resample_interval_, lane, &amp;curve_radius);
+    else
+      getCurveAll(*lane, &amp;curve_radius);
     const std::vector&lt;double&gt; vel_param = calcVelParamFromVmax(velocity_max_);
     createCurveList(curve_radius, &amp;curve_list);
     if(vel_param.size() &lt; 2)
@@ -99,7 +103,7 @@ namespace waypoint_maker
     {
       const unsigned long idx = end_id[i];
       const double vmax = velocity_max_;
-      const double vmin = 0.0;
+      const double vmin = (i == 0) ? velocity_min_ : 0.0;
       if(lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)continue;
       lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
       limitAccelDecel(vmax, vmin, idx, lane);
@@ -119,8 +123,8 @@ namespace waypoint_maker
     lane-&gt;waypoints.reserve(waypoints_size);
     curve_radius-&gt;reserve(waypoints_size);
 
-    const unsigned int n = (lkup_crv_width_ - 1) / 2;
-    for(unsigned long i = 1; i &lt; original_lane.waypoints.size() - 1; i++)
+    const unsigned int n = (lookup_crv_width_ - 1) / 2;
+    for(unsigned long i = 1; i &lt; original_lane.waypoints.size(); i++)
     {
       std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
       curve_point[0] = (lane-&gt;waypoints.size() &lt; n) ? lane-&gt;waypoints[0].pose.pose.position
@@ -136,9 +140,10 @@ namespace waypoint_maker
         autoware_msgs::waypoint wp;
         wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
         wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(atan2(vec[1], vec[0]));
+        wp.change_flag = lane-&gt;waypoints.back().change_flag;
         const std::vector&lt;double&gt; nvec = {curve_point[1].x - wp.pose.pose.position.x, curve_point[1].y - wp.pose.pose.position.y};
         double dist = sqrt(calcSquareSum(nvec[0], nvec[1]));
-        const tf::Vector3 resample_vec(resample_interval_ * vec[0] / dist, resample_interval_ * vec[1] / dist, 0.0);
+        const tf::Vector3 resample_vec(resample_interval_ * nvec[0] / dist, resample_interval_ * nvec[1] / dist, 0.0);
         for(; dist &gt; resample_interval_; dist -= resample_interval_)
         {
           if(lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())break;
@@ -163,10 +168,12 @@ namespace waypoint_maker
         else if(theta &lt; -M_PI)theta += 2 * M_PI;
         //interport
         double t = atan2(p0.y - cy, p0.x - cx);
+        autoware_msgs::waypoint wp;
+        wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
+        wp.change_flag = lane-&gt;waypoints.back().change_flag;
         for(double dist = radius * fabs(theta); dist &gt; resample_interval_; dist -= resample_interval_)
         {
           if(lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())break;
-          autoware_msgs::waypoint wp = lane-&gt;waypoints[0];
           const int sign = (theta &gt; 0.0) ? (1) : (-1);
           t += sign * resample_interval_ / radius;
           const double yaw = fmod(t + sign * M_PI / 2.0, 2 * M_PI);
@@ -177,6 +184,42 @@ namespace waypoint_maker
           curve_radius-&gt;push_back(threshold_radius);
         }
       }
+      lane-&gt;waypoints.back().wpstate = original_lane.waypoints[i].wpstate;
+      lane-&gt;waypoints.back().change_flag = original_lane.waypoints[i].change_flag;
+    }
+    lane-&gt;waypoints.back().wpstate = original_lane.waypoints.back().wpstate;
+    lane-&gt;waypoints.back().change_flag = original_lane.waypoints.back().change_flag;
+  }
+
+
+
+  void WaypointFilter::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt; *curve_radius)
+  {
+    if(lane.waypoints.empty())return;
+    curve_radius-&gt;resize(lane.waypoints.size());
+    curve_radius-&gt;at(0) = curve_radius-&gt;back() = r_inf_;
+
+    const unsigned int n = (lookup_crv_width_ - 1) / 2;
+    for(unsigned long i = 1; i &lt; lane.waypoints.size() - 1; i++)
+    {
+      std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
+      curve_point[0] = (i &lt; n) ? lane.waypoints[0].pose.pose.position
+                                : lane.waypoints[i - n].pose.pose.position;
+      curve_point[1] = lane.waypoints[i].pose.pose.position;
+      curve_point[2] = (i &gt;= lane.waypoints.size() - n) ? lane.waypoints.back().pose.pose.position
+                                                          : lane.waypoints[i + n].pose.pose.position;
+      const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
+      //if going straight
+      if(curve_param.empty())
+      {
+        curve_radius-&gt;at(i) = r_inf_;
+      }
+      //else if turnning curve
+      else
+      {
+        const double&amp; radius = curve_param[2];
+        curve_radius-&gt;at(i) = (radius &gt; r_inf_) ? r_inf_ : radius;
+      }
     }
   }
 
@@ -247,6 +290,7 @@ namespace waypoint_maker
       pt_m[i].x = (p0.x + p1.x) / 2.0;
       pt_m[i].y = (p0.y + p1.y) / 2.0;
       vec[i] = tf::Vector3(p1.x - p0.x, p1.y - p0.y, 0.0);
+      if(fabs(vec[i].x()) &lt; 1e-8 &amp;&amp; fabs(vec[i].y()) &lt; 1e-8)return std::vector&lt;double&gt;();
       tan_pt_m[i] = tan(atan2(vec[i].y(), vec[i].x()) + M_PI / 2.0);
     }
     if(fabs(tan_pt_m[1] - tan_pt_m[0]) &lt; 1e-9)return std::vector&lt;double&gt;();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" added_lines="3" deleted_lines="1">
				<diff>@@ -46,10 +46,11 @@ class WaypointFilter
 private:
   ros::NodeHandle private_nh_;
   double r_th_, r_min_, r_inf_;
-  int lkup_crv_width_;
+  int lookup_crv_width_;
   double velocity_max_, velocity_min_;
   double accel_limit_, decel_limit_, resample_interval_;
   int velocity_offset_;
+  bool resample_mode_;
 public:
   WaypointFilter();
   ~WaypointFilter();
@@ -57,6 +58,7 @@ public:
   void filterLaneWaypoint(autoware_msgs::lane *lane);
 protected:
   void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane *lane, std::vector&lt;double&gt; *curve_radius);
+  void getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt; *curve_radius);
   const std::vector&lt;double&gt; calcVelParamFromVmax(const double vmax)const;
   void createCurveList(const std::vector&lt;double&gt;&amp; curve_radius, std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list);
   void limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx, autoware_msgs::lane *lane);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="16" deleted_lines="10">
				<diff>@@ -60,7 +60,7 @@ void WaypointLoaderNode::initParameter(const autoware_msgs::ConfigWaypointLoader
 {
   // parameter settings
   disable_decision_maker_ = conf-&gt;disable_decision_maker;
-  disable_filtering_ = conf-&gt;disable_filtering;
+  filtering_mode_ = conf-&gt;filtering_mode;
   multi_lane_csv_ = conf-&gt;multi_lane_csv;
 }
 
@@ -107,7 +107,7 @@ void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt; &amp;paths,
   {
     autoware_msgs::lane lane;
     createLaneWaypoint(el, &amp;lane);
-    if(!disable_filtering_)
+    if(filtering_mode_)
       filter_.filterLaneWaypoint(&amp;lane);
     lane_array-&gt;lanes.push_back(lane);
   }
@@ -118,12 +118,14 @@ void WaypointLoaderNode::saveLaneArray(const std::vector&lt;std::string&gt; &amp;paths, co
   unsigned long idx = 0;
   for (const auto&amp; file_path : paths)
   {
-    std::ofstream ofs(file_path.c_str(), std::ios::app);
-    ofs &lt;&lt; "x,y,z,yaw,velocity,change_flag" &lt;&lt; std::endl;
+    std::ofstream ofs(file_path.c_str());
+    ofs &lt;&lt; "x,y,z,yaw,velocity,change_flag,steering_flag,accel_flag,stop_flag,event_flag" &lt;&lt; std::endl;
     for(const auto&amp; el : lane_array.lanes[idx].waypoints)
     {
       ofs &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; el.pose.pose.position.x &lt;&lt; "," &lt;&lt; el.pose.pose.position.y &lt;&lt; ","
-          &lt;&lt; el.pose.pose.position.z &lt;&lt; "," &lt;&lt; tf::getYaw(el.pose.pose.orientation) &lt;&lt; "," &lt;&lt; mps2kmph(el.twist.twist.linear.x) &lt;&lt; ",0" &lt;&lt; std::endl;
+          &lt;&lt; el.pose.pose.position.z &lt;&lt; "," &lt;&lt; tf::getYaw(el.pose.pose.orientation) &lt;&lt; "," &lt;&lt; mps2kmph(el.twist.twist.linear.x) &lt;&lt; ","
+          &lt;&lt; (int)el.change_flag &lt;&lt; "," &lt;&lt; (int)el.wpstate.steering_state &lt;&lt; "," &lt;&lt; (int)el.wpstate.accel_state &lt;&lt; ","
+          &lt;&lt; (int)el.wpstate.stopline_state &lt;&lt; "," &lt;&lt; (int)el.wpstate.event_state &lt;&lt; std::endl;
     }
     idx++;
   }
@@ -145,7 +147,7 @@ void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, autowa
   else if (format == FileFormat::ver2)
     loadWaypointsForVer2(file_path.c_str(), &amp;wps);
   else
-    loadWaypoints(file_path.c_str(), &amp;wps);
+    loadWaypointsForVer3(file_path.c_str(), &amp;wps);
   lane-&gt;header.frame_id = "/map";
   lane-&gt;header.stamp = ros::Time(0);
   lane-&gt;waypoints = wps;
@@ -225,7 +227,7 @@ void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line, autoware_
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(columns[4]));
 }
 
-void WaypointLoaderNode::loadWaypoints(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps)
+void WaypointLoaderNode::loadWaypointsForVer3(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps)
 {
   std::ifstream ifs(filename);
 
@@ -237,16 +239,16 @@ void WaypointLoaderNode::loadWaypoints(const char *filename, std::vector&lt;autowar
   std::vector&lt;std::string&gt; contents;
   parseColumns(line, &amp;contents);
 
-  std::getline(ifs, line);  // remove second line
+  //std::getline(ifs, line);  // remove second line
   while (std::getline(ifs, line))
   {
     autoware_msgs::waypoint wp;
-    parseWaypoint(line, contents, &amp;wp);
+    parseWaypointForVer3(line, contents, &amp;wp);
     wps-&gt;push_back(wp);
   }
 }
 
-void WaypointLoaderNode::parseWaypoint(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
+void WaypointLoaderNode::parseWaypointForVer3(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
                                        autoware_msgs::waypoint *wp)
 {
   std::vector&lt;std::string&gt; columns;
@@ -263,6 +265,10 @@ void WaypointLoaderNode::parseWaypoint(const std::string &amp;line, const std::vecto
   wp-&gt;pose.pose.orientation = tf::createQuaternionMsgFromYaw(std::stod(map["yaw"]));
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(map["velocity"]));
   wp-&gt;change_flag = std::stoi(map["change_flag"]);
+  wp-&gt;wpstate.steering_state = (map.find("steering_flag") != map.end()) ? std::stoi(map["steering_flag"]) : 0;
+  wp-&gt;wpstate.accel_state = (map.find("accel_flag") != map.end()) ? std::stoi(map["accel_flag"]) : 0;
+  wp-&gt;wpstate.stopline_state = (map.find("stop_flag") != map.end()) ? std::stoi(map["stop_flag"]) : 0;
+  wp-&gt;wpstate.event_state = (map.find("event_flag") != map.end()) ? std::stoi(map["event_flag"]) : 0;
 }
 
 FileFormat WaypointLoaderNode::checkFileFormat(const char *filename)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="3" deleted_lines="3">
				<diff>@@ -91,7 +91,7 @@ private:
   // variables
   std::string multi_lane_csv_;
   bool disable_decision_maker_;
-  bool disable_filtering_;
+  bool filtering_mode_;
   WaypointFilter filter_;
   std::vector&lt;std::string&gt; multi_file_path_;
   autoware_msgs::LaneArray output_lane_array_;
@@ -113,8 +113,8 @@ private:
   void parseWaypointForVer1(const std::string &amp;line, autoware_msgs::waypoint *wp);
   void loadWaypointsForVer2(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
   void parseWaypointForVer2(const std::string &amp;line, autoware_msgs::waypoint *wp);
-  void loadWaypoints(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
-  void parseWaypoint(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
+  void loadWaypointsForVer3(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
+  void parseWaypointForVer3(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
                             autoware_msgs::waypoint *wp);
 };
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="98b5aa1df76d7516ca62b8dce8153a1d79f53000" author="Abraham Monrroy">
		<msg>[Feature] region tlr mxnet (#1048)

* Initial commit of MxNet TLR based recognizer

* Added result interpretation

* Added
-Score threshold,
-latch-like trap to avoid sudden state changes,
-latch threshold to set minimum number of instances before changing state

* added mxnet to runtime manager

* Fix the settings of runtime manager from apex version

* Add launch file for region_tlr_mxnet

* added path dialogue boxes to load model and params for mxnet

* Add the settings of region_tlr_mxnet on runtime manager dialogue</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\include\Context.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\include\Context.h" added_lines="1" deleted_lines="0">
				<diff>@@ -36,6 +36,7 @@ public:
 	cv::Point   topLeft;
 	cv::Point   botRight;
 	LightState  lightState;
+	LightState  newCandidateLightState;
 	int         signalID;
 	int         stateJudgeCount;
 	bool        leftTurnSignal;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\lib\Context.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\lib\Context.cpp" added_lines="3" deleted_lines="0">
				<diff>@@ -12,6 +12,8 @@ Context::Context(cv::Point aRedCenter, cv::Point aYellowCenter, cv::Point aGreen
 	leftTurnSignal = false;
 	rightTurnSignal = false;
 	closestLaneId = -1;
+	newCandidateLightState = UNDEFINED;
+	lightState = UNDEFINED;
 }
 
 /*
@@ -153,6 +155,7 @@ void Context::SetContexts(std::vector&lt;Context&gt; &amp;out_signal_contexts,
 				final_signal_contexts.push_back(current_signal_context);
 				final_signal_contexts.back().lightState = out_signal_contexts.at(i).lightState;
 				final_signal_contexts.back().stateJudgeCount = out_signal_contexts.at(i).stateJudgeCount;
+				final_signal_contexts.back().newCandidateLightState = out_signal_contexts.at(i).newCandidateLightState;
 				isInserted = true;
 				break;
 			}
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fb284523027c0df1ec513b09c6426c9d235c9f12" author="Yuma">
		<msg>Clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" added_lines="280" deleted_lines="263">
				<diff>@@ -6,7 +6,8 @@
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions are met:
  *
- *  * Redistributions of source code must retain the above copyright notice, this
+ *  * Redistributions of source code must retain the above copyright notice,
+ this
  *    list of conditions and the following disclaimer.
  *
  *  * Redistributions in binary form must reproduce the above copyright notice,
@@ -19,308 +20,324 @@
  *
  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ ARE
  *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #include "waypoint_filter.h"
 
-namespace waypoint_maker
-{
+namespace waypoint_maker {
 
-  inline double kmph2mps(double velocity_kmph)
-  {
-    return (velocity_kmph * 1000) / (60 * 60);
-  }
-  inline double mps2kmph(double velocity_mps)
-  {
-    return (velocity_mps * 60 * 60) / 1000;
-  }
+inline double kmph2mps(double velocity_kmph) {
+  return (velocity_kmph * 1000) / (60 * 60);
+}
+inline double mps2kmph(double velocity_mps) {
+  return (velocity_mps * 60 * 60) / 1000;
+}
 
-  WaypointFilter::WaypointFilter():private_nh_("~")
-  {
-  }
+WaypointFilter::WaypointFilter() : private_nh_("~") {}
 
-  WaypointFilter::~WaypointFilter(){}
+WaypointFilter::~WaypointFilter() {}
 
-  void WaypointFilter::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
-  {
-    velocity_max_ = kmph2mps(conf-&gt;velocity_max);
-    velocity_min_ = kmph2mps(conf-&gt;velocity_min);
-    accel_limit_ = conf-&gt;accel_limit;
-    decel_limit_ = conf-&gt;decel_limit;
-    r_th_ = conf-&gt;radius_thresh;
-    r_min_ = conf-&gt;radius_min;
-    lookup_crv_width_ = 5;
-    resample_mode_ = conf-&gt;resample_mode;
-    resample_interval_ = conf-&gt;resample_interval;
-    velocity_offset_ = conf-&gt;velocity_offset;
-    r_inf_ = 10 * r_th_;
-  }
+void WaypointFilter::initParameter(
+    const autoware_msgs::ConfigWaypointLoader::ConstPtr &amp;conf) {
+  velocity_max_ = kmph2mps(conf-&gt;velocity_max);
+  velocity_min_ = kmph2mps(conf-&gt;velocity_min);
+  accel_limit_ = conf-&gt;accel_limit;
+  decel_limit_ = conf-&gt;decel_limit;
+  r_th_ = conf-&gt;radius_thresh;
+  r_min_ = conf-&gt;radius_min;
+  lookup_crv_width_ = 5;
+  resample_mode_ = conf-&gt;resample_mode;
+  resample_interval_ = conf-&gt;resample_interval;
+  velocity_offset_ = conf-&gt;velocity_offset;
+  r_inf_ = 10 * r_th_;
+}
 
-  void WaypointFilter::filterLaneWaypoint(autoware_msgs::lane *lane)
-  {
-    std::vector&lt;double&gt; curve_radius;
-    std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt; curve_list;
+void WaypointFilter::filterLaneWaypoint(autoware_msgs::lane *lane) {
+  std::vector&lt;double&gt; curve_radius;
+  std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt;&gt;
+      curve_list;
 
-    if(resample_mode_)
-      resampleLaneWaypoint(resample_interval_, lane, &amp;curve_radius);
-    else
-      getCurveAll(*lane, &amp;curve_radius);
-    const std::vector&lt;double&gt; vel_param = calcVelParamFromVmax(velocity_max_);
-    createCurveList(curve_radius, &amp;curve_list);
-    if(vel_param.size() &lt; 2)
-    {
-      ROS_ERROR("velocity parameter is invalid");
-      return;
-    }
-    //set velocity_max for all_point
-    for(auto&amp; el : lane-&gt;waypoints)
-      el.twist.twist.linear.x = velocity_max_;
-    //set curve_velocity on curve begining
-    for(const auto&amp; el : curve_list)
-    {
-      const unsigned long start_idx = (el.first &gt; velocity_offset_) ? (el.first - velocity_offset_) : 0;
-      const unsigned long end_idx = (el.second.first &gt; velocity_offset_) ? (el.second.first - velocity_offset_) : 0;
-      const double radius = el.second.second;
-      const double vmax = velocity_max_;
-      const double vmin = vel_param[0] * radius + vel_param[1];
-      for(unsigned long idx = start_idx; idx &lt;= end_idx ; idx++)
-      {
-        if(lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)continue;
-        lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
-      }
-      limitAccelDecel(vmax, vmin, start_idx, lane);
-      limitAccelDecel(vmax, vmin, end_idx, lane);
-    }
-    unsigned long end_id[2] = {0, lane-&gt;waypoints.size() - 1};
-    for(int i = 0; i &lt; 2; i++)
-    {
-      const unsigned long idx = end_id[i];
-      const double vmax = velocity_max_;
-      const double vmin = (i == 0) ? velocity_min_ : 0.0;
-      if(lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)continue;
+  if (resample_mode_)
+    resampleLaneWaypoint(resample_interval_, lane, &amp;curve_radius);
+  else
+    getCurveAll(*lane, &amp;curve_radius);
+  const std::vector&lt;double&gt; vel_param = calcVelParamFromVmax(velocity_max_);
+  createCurveList(curve_radius, &amp;curve_list);
+  if (vel_param.size() &lt; 2) {
+    ROS_ERROR("velocity parameter is invalid");
+    return;
+  }
+  // set velocity_max for all_point
+  for (auto &amp;el : lane-&gt;waypoints)
+    el.twist.twist.linear.x = velocity_max_;
+  // set curve_velocity on curve begining
+  for (const auto &amp;el : curve_list) {
+    const unsigned long start_idx =
+        (el.first &gt; velocity_offset_) ? (el.first - velocity_offset_) : 0;
+    const unsigned long end_idx = (el.second.first &gt; velocity_offset_)
+                                      ? (el.second.first - velocity_offset_)
+                                      : 0;
+    const double radius = el.second.second;
+    const double vmax = velocity_max_;
+    const double vmin = vel_param[0] * radius + vel_param[1];
+    for (unsigned long idx = start_idx; idx &lt;= end_idx; idx++) {
+      if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
+        continue;
       lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
-      limitAccelDecel(vmax, vmin, idx, lane);
     }
+    limitAccelDecel(vmax, vmin, start_idx, lane);
+    limitAccelDecel(vmax, vmin, end_idx, lane);
   }
+  unsigned long end_id[2] = {0, lane-&gt;waypoints.size() - 1};
+  for (int i = 0; i &lt; 2; i++) {
+    const unsigned long idx = end_id[i];
+    const double vmax = velocity_max_;
+    const double vmin = (i == 0) ? velocity_min_ : 0.0;
+    if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
+      continue;
+    lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
+    limitAccelDecel(vmax, vmin, idx, lane);
+  }
+}
 
-  void WaypointFilter::resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane *lane, std::vector&lt;double&gt; *curve_radius)
-  {
-    if(lane-&gt;waypoints.empty())return;
-    autoware_msgs::lane original_lane = *lane;
-    lane-&gt;waypoints.clear();
-    lane-&gt;waypoints.push_back(original_lane.waypoints[0]);
-    curve_radius-&gt;clear();
-    curve_radius-&gt;push_back(r_inf_);
-    double original_len = calcPathLength(original_lane);
-    unsigned long waypoints_size = ceil(1.5 * original_len / resample_interval_);
-    lane-&gt;waypoints.reserve(waypoints_size);
-    curve_radius-&gt;reserve(waypoints_size);
+void WaypointFilter::resampleLaneWaypoint(const double resample_interval,
+                                          autoware_msgs::lane *lane,
+                                          std::vector&lt;double&gt; *curve_radius) {
+  if (lane-&gt;waypoints.empty())
+    return;
+  autoware_msgs::lane original_lane = *lane;
+  lane-&gt;waypoints.clear();
+  lane-&gt;waypoints.push_back(original_lane.waypoints[0]);
+  curve_radius-&gt;clear();
+  curve_radius-&gt;push_back(r_inf_);
+  double original_len = calcPathLength(original_lane);
+  unsigned long waypoints_size = ceil(1.5 * original_len / resample_interval_);
+  lane-&gt;waypoints.reserve(waypoints_size);
+  curve_radius-&gt;reserve(waypoints_size);
 
-    const unsigned int n = (lookup_crv_width_ - 1) / 2;
-    for(unsigned long i = 1; i &lt; original_lane.waypoints.size(); i++)
-    {
-      std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
-      curve_point[0] = (lane-&gt;waypoints.size() &lt; n) ? lane-&gt;waypoints[0].pose.pose.position
-                                                    : lane-&gt;waypoints[lane-&gt;waypoints.size() - n].pose.pose.position;
-      curve_point[1] = original_lane.waypoints[i].pose.pose.position;
-      curve_point[2] = (i &gt;= original_lane.waypoints.size() - n) ? original_lane.waypoints.back().pose.pose.position
-                                                                : original_lane.waypoints[i + n].pose.pose.position;
-      const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
-      //if going straight
-      if(curve_param.empty())
-      {
-        const std::vector&lt;double&gt; vec = {curve_point[2].x - curve_point[0].x, curve_point[2].y - curve_point[0].y};
-        autoware_msgs::waypoint wp;
-        wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
-        wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(atan2(vec[1], vec[0]));
-        wp.change_flag = lane-&gt;waypoints.back().change_flag;
-        const std::vector&lt;double&gt; nvec = {curve_point[1].x - wp.pose.pose.position.x, curve_point[1].y - wp.pose.pose.position.y};
-        double dist = sqrt(calcSquareSum(nvec[0], nvec[1]));
-        const tf::Vector3 resample_vec(resample_interval_ * nvec[0] / dist, resample_interval_ * nvec[1] / dist, 0.0);
-        for(; dist &gt; resample_interval_; dist -= resample_interval_)
-        {
-          if(lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())break;
-          wp.pose.pose.position.x += resample_vec.x();
-          wp.pose.pose.position.y += resample_vec.y();
-          lane-&gt;waypoints.push_back(wp);
-          curve_radius-&gt;push_back(r_inf_);
-        }
+  const unsigned int n = (lookup_crv_width_ - 1) / 2;
+  for (unsigned long i = 1; i &lt; original_lane.waypoints.size(); i++) {
+    std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
+    curve_point[0] =
+        (lane-&gt;waypoints.size() &lt; n)
+            ? lane-&gt;waypoints[0].pose.pose.position
+            : lane-&gt;waypoints[lane-&gt;waypoints.size() - n].pose.pose.position;
+    curve_point[1] = original_lane.waypoints[i].pose.pose.position;
+    curve_point[2] = (i &gt;= original_lane.waypoints.size() - n)
+                         ? original_lane.waypoints.back().pose.pose.position
+                         : original_lane.waypoints[i + n].pose.pose.position;
+    const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
+    // if going straight
+    if (curve_param.empty()) {
+      const std::vector&lt;double&gt; vec = {curve_point[2].x - curve_point[0].x,
+                                       curve_point[2].y - curve_point[0].y};
+      autoware_msgs::waypoint wp;
+      wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
+      wp.pose.pose.orientation =
+          tf::createQuaternionMsgFromYaw(atan2(vec[1], vec[0]));
+      wp.change_flag = lane-&gt;waypoints.back().change_flag;
+      const std::vector&lt;double&gt; nvec = {
+          curve_point[1].x - wp.pose.pose.position.x,
+          curve_point[1].y - wp.pose.pose.position.y};
+      double dist = sqrt(calcSquareSum(nvec[0], nvec[1]));
+      const tf::Vector3 resample_vec(resample_interval_ * nvec[0] / dist,
+                                     resample_interval_ * nvec[1] / dist, 0.0);
+      for (; dist &gt; resample_interval_; dist -= resample_interval_) {
+        if (lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())
+          break;
+        wp.pose.pose.position.x += resample_vec.x();
+        wp.pose.pose.position.y += resample_vec.y();
+        lane-&gt;waypoints.push_back(wp);
+        curve_radius-&gt;push_back(r_inf_);
       }
-      //else if turnning curve
-      else
-      {
-        const double&amp; cx = curve_param[0];
-        const double&amp; cy = curve_param[1];
-        const double&amp; radius = curve_param[2];
-        const double threshold_radius = (radius &gt; r_inf_) ? r_inf_ : radius;
+    }
+    // else if turnning curve
+    else {
+      const double &amp;cx = curve_param[0];
+      const double &amp;cy = curve_param[1];
+      const double &amp;radius = curve_param[2];
+      const double threshold_radius = (radius &gt; r_inf_) ? r_inf_ : radius;
 
-        const geometry_msgs::Point&amp; p0 = lane-&gt;waypoints.back().pose.pose.position;
-        const geometry_msgs::Point&amp; p1 = curve_point[1];
-        double theta = fmod(atan2(p1.y - cy, p1.x - cx) - atan2(p0.y - cy, p0.x - cx), 2 * M_PI);
-        if(theta &gt; M_PI)theta -= 2 * M_PI;
-        else if(theta &lt; -M_PI)theta += 2 * M_PI;
-        //interport
-        double t = atan2(p0.y - cy, p0.x - cx);
-        autoware_msgs::waypoint wp;
-        wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
-        wp.change_flag = lane-&gt;waypoints.back().change_flag;
-        for(double dist = radius * fabs(theta); dist &gt; resample_interval_; dist -= resample_interval_)
-        {
-          if(lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())break;
-          const int sign = (theta &gt; 0.0) ? (1) : (-1);
-          t += sign * resample_interval_ / radius;
-          const double yaw = fmod(t + sign * M_PI / 2.0, 2 * M_PI);
-          wp.pose.pose.position.x = cx + radius * cos(t);
-          wp.pose.pose.position.y = cy + radius * sin(t);
-          wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
-          lane-&gt;waypoints.push_back(wp);
-          curve_radius-&gt;push_back(threshold_radius);
-        }
+      const geometry_msgs::Point &amp;p0 =
+          lane-&gt;waypoints.back().pose.pose.position;
+      const geometry_msgs::Point &amp;p1 = curve_point[1];
+      double theta = fmod(
+          atan2(p1.y - cy, p1.x - cx) - atan2(p0.y - cy, p0.x - cx), 2 * M_PI);
+      if (theta &gt; M_PI)
+        theta -= 2 * M_PI;
+      else if (theta &lt; -M_PI)
+        theta += 2 * M_PI;
+      // interport
+      double t = atan2(p0.y - cy, p0.x - cx);
+      autoware_msgs::waypoint wp;
+      wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
+      wp.change_flag = lane-&gt;waypoints.back().change_flag;
+      for (double dist = radius * fabs(theta); dist &gt; resample_interval_;
+           dist -= resample_interval_) {
+        if (lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())
+          break;
+        const int sign = (theta &gt; 0.0) ? (1) : (-1);
+        t += sign * resample_interval_ / radius;
+        const double yaw = fmod(t + sign * M_PI / 2.0, 2 * M_PI);
+        wp.pose.pose.position.x = cx + radius * cos(t);
+        wp.pose.pose.position.y = cy + radius * sin(t);
+        wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
+        lane-&gt;waypoints.push_back(wp);
+        curve_radius-&gt;push_back(threshold_radius);
       }
-      lane-&gt;waypoints.back().wpstate = original_lane.waypoints[i].wpstate;
-      lane-&gt;waypoints.back().change_flag = original_lane.waypoints[i].change_flag;
     }
-    lane-&gt;waypoints.back().wpstate = original_lane.waypoints.back().wpstate;
-    lane-&gt;waypoints.back().change_flag = original_lane.waypoints.back().change_flag;
+    lane-&gt;waypoints.back().wpstate = original_lane.waypoints[i].wpstate;
+    lane-&gt;waypoints.back().change_flag = original_lane.waypoints[i].change_flag;
   }
+  lane-&gt;waypoints.back().wpstate = original_lane.waypoints.back().wpstate;
+  lane-&gt;waypoints.back().change_flag =
+      original_lane.waypoints.back().change_flag;
+}
 
+void WaypointFilter::getCurveAll(const autoware_msgs::lane &amp;lane,
+                                 std::vector&lt;double&gt; *curve_radius) {
+  if (lane.waypoints.empty())
+    return;
+  curve_radius-&gt;resize(lane.waypoints.size());
+  curve_radius-&gt;at(0) = curve_radius-&gt;back() = r_inf_;
 
-
-  void WaypointFilter::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt; *curve_radius)
-  {
-    if(lane.waypoints.empty())return;
-    curve_radius-&gt;resize(lane.waypoints.size());
-    curve_radius-&gt;at(0) = curve_radius-&gt;back() = r_inf_;
-
-    const unsigned int n = (lookup_crv_width_ - 1) / 2;
-    for(unsigned long i = 1; i &lt; lane.waypoints.size() - 1; i++)
-    {
-      std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
-      curve_point[0] = (i &lt; n) ? lane.waypoints[0].pose.pose.position
-                                : lane.waypoints[i - n].pose.pose.position;
-      curve_point[1] = lane.waypoints[i].pose.pose.position;
-      curve_point[2] = (i &gt;= lane.waypoints.size() - n) ? lane.waypoints.back().pose.pose.position
-                                                          : lane.waypoints[i + n].pose.pose.position;
-      const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
-      //if going straight
-      if(curve_param.empty())
-      {
-        curve_radius-&gt;at(i) = r_inf_;
-      }
-      //else if turnning curve
-      else
-      {
-        const double&amp; radius = curve_param[2];
-        curve_radius-&gt;at(i) = (radius &gt; r_inf_) ? r_inf_ : radius;
-      }
+  const unsigned int n = (lookup_crv_width_ - 1) / 2;
+  for (unsigned long i = 1; i &lt; lane.waypoints.size() - 1; i++) {
+    std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
+    curve_point[0] = (i &lt; n) ? lane.waypoints[0].pose.pose.position
+                             : lane.waypoints[i - n].pose.pose.position;
+    curve_point[1] = lane.waypoints[i].pose.pose.position;
+    curve_point[2] = (i &gt;= lane.waypoints.size() - n)
+                         ? lane.waypoints.back().pose.pose.position
+                         : lane.waypoints[i + n].pose.pose.position;
+    const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
+    // if going straight
+    if (curve_param.empty()) {
+      curve_radius-&gt;at(i) = r_inf_;
+    }
+    // else if turnning curve
+    else {
+      const double &amp;radius = curve_param[2];
+      curve_radius-&gt;at(i) = (radius &gt; r_inf_) ? r_inf_ : radius;
     }
   }
+}
 
-  const std::vector&lt;double&gt; WaypointFilter::calcVelParamFromVmax(const double vmax)const
-  {
-    std::vector&lt;double&gt; param(2, 0.0);
-    param[0] = (vmax - velocity_min_) / (r_th_ - r_min_);//bias
-    param[1] = vmax - param[0] * r_th_;//vel_intersept
-    return param;
-  }
+const std::vector&lt;double&gt;
+WaypointFilter::calcVelParamFromVmax(const double vmax) const {
+  std::vector&lt;double&gt; param(2, 0.0);
+  param[0] = (vmax - velocity_min_) / (r_th_ - r_min_); // bias
+  param[1] = vmax - param[0] * r_th_;                   // vel_intersept
+  return param;
+}
 
-  void WaypointFilter::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius, std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list)
-  {
-    unsigned long index = 0;
-    bool on_curve = false;
-    double radius_localmin = DBL_MAX;
-    for(unsigned long i = 1; i &lt; curve_radius.size(); i++)
-    {
-      if(!on_curve &amp;&amp; curve_radius[i] &lt;= r_th_ &amp;&amp; curve_radius[i -1] &gt; r_th_)
-      {
-        index = i;
-        on_curve = true;
-      }
-      else if(on_curve &amp;&amp; curve_radius[i - 1] &lt;= r_th_ &amp;&amp; curve_radius[i] &gt; r_th_)
-      {
-        on_curve = false;
-        if(radius_localmin &lt; r_min_)radius_localmin = r_min_;
-        (*curve_list)[index] = std::make_pair(i, radius_localmin);
-        radius_localmin = DBL_MAX;
-      }
-      if(!on_curve)continue;
-      if(radius_localmin &gt; curve_radius[i])radius_localmin = curve_radius[i];
+void WaypointFilter::createCurveList(
+    const std::vector&lt;double&gt; &amp;curve_radius,
+    std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt;&gt;
+        *curve_list) {
+  unsigned long index = 0;
+  bool on_curve = false;
+  double radius_localmin = DBL_MAX;
+  for (unsigned long i = 1; i &lt; curve_radius.size(); i++) {
+    if (!on_curve &amp;&amp; curve_radius[i] &lt;= r_th_ &amp;&amp; curve_radius[i - 1] &gt; r_th_) {
+      index = i;
+      on_curve = true;
+    } else if (on_curve &amp;&amp; curve_radius[i - 1] &lt;= r_th_ &amp;&amp;
+               curve_radius[i] &gt; r_th_) {
+      on_curve = false;
+      if (radius_localmin &lt; r_min_)
+        radius_localmin = r_min_;
+      (*curve_list)[index] = std::make_pair(i, radius_localmin);
+      radius_localmin = DBL_MAX;
     }
+    if (!on_curve)
+      continue;
+    if (radius_localmin &gt; curve_radius[i])
+      radius_localmin = curve_radius[i];
   }
+}
 
-  void WaypointFilter::limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx, autoware_msgs::lane *lane)
-  {
-    double v = vmin_local;
-    for(unsigned long i = 1; ; i++)
-    {
-      v = sqrt(2 * accel_limit_ * resample_interval_ + v * v);
-      if(i &gt; lane-&gt;waypoints.size() - idx - 1 || v &gt; vmax)break;
-      if(lane-&gt;waypoints[idx + i].twist.twist.linear.x &lt; v)break;
-      lane-&gt;waypoints[idx + i].twist.twist.linear.x = v;
-    }
-
-    v = vmin_local;
-    for(unsigned long i = 1; ; i++)
-    {
-      v = sqrt(2 * decel_limit_ * resample_interval_ + v * v);
-      if(i &gt; idx || v &gt; vmax)break;
-      if(lane-&gt;waypoints[idx - i].twist.twist.linear.x &lt; v)break;
-      lane-&gt;waypoints[idx - i].twist.twist.linear.x = v;
-    }
+void WaypointFilter::limitAccelDecel(const double vmax, const double vmin_local,
+                                     const unsigned long idx,
+                                     autoware_msgs::lane *lane) {
+  double v = vmin_local;
+  for (unsigned long i = 1;; i++) {
+    v = sqrt(2 * accel_limit_ * resample_interval_ + v * v);
+    if (i &gt; lane-&gt;waypoints.size() - idx - 1 || v &gt; vmax)
+      break;
+    if (lane-&gt;waypoints[idx + i].twist.twist.linear.x &lt; v)
+      break;
+    lane-&gt;waypoints[idx + i].twist.twist.linear.x = v;
   }
 
-  //get 3 parameter of curve, [center_x, center_y, radius]
-  const std::vector&lt;double&gt; WaypointFilter::getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point)const
-  {
-    std::vector&lt;double&gt; curve_param(3, 0.0);
-    tf::Vector3 vec[2];
-    geometry_msgs::Point pt_m[2];
-    double tan_pt_m[2];
-    for(unsigned int i = 0; i &lt; 2; i++)
-    {
-      const geometry_msgs::Point&amp; p0 = point[i];
-      const geometry_msgs::Point&amp; p1 = point[i + 1];
-      pt_m[i].x = (p0.x + p1.x) / 2.0;
-      pt_m[i].y = (p0.y + p1.y) / 2.0;
-      vec[i] = tf::Vector3(p1.x - p0.x, p1.y - p0.y, 0.0);
-      if(fabs(vec[i].x()) &lt; 1e-8 &amp;&amp; fabs(vec[i].y()) &lt; 1e-8)return std::vector&lt;double&gt;();
-      tan_pt_m[i] = tan(atan2(vec[i].y(), vec[i].x()) + M_PI / 2.0);
-    }
-    if(fabs(tan_pt_m[1] - tan_pt_m[0]) &lt; 1e-9)return std::vector&lt;double&gt;();
+  v = vmin_local;
+  for (unsigned long i = 1;; i++) {
+    v = sqrt(2 * decel_limit_ * resample_interval_ + v * v);
+    if (i &gt; idx || v &gt; vmax)
+      break;
+    if (lane-&gt;waypoints[idx - i].twist.twist.linear.x &lt; v)
+      break;
+    lane-&gt;waypoints[idx - i].twist.twist.linear.x = v;
+  }
+}
 
-    {
-      const geometry_msgs::Point&amp; p0 = point[0];
-      curve_param[0] = pt_m[0].y - pt_m[0].x * tan_pt_m[0] - pt_m[1].y + pt_m[1].x * tan_pt_m[1];
-      curve_param[0] /= tan_pt_m[1] - tan_pt_m[0];
-      curve_param[1] = pt_m[0].y - (pt_m[0].x - curve_param[0]) * tan_pt_m[0];
-      curve_param[2] = sqrt(calcSquareSum(p0.x - curve_param[0], p0.y - curve_param[1]));
-    }
-    return curve_param;
+// get 3 parameter of curve, [center_x, center_y, radius]
+const std::vector&lt;double&gt; WaypointFilter::getCurveOnce(
+    const std::vector&lt;geometry_msgs::Point&gt; &amp;point) const {
+  std::vector&lt;double&gt; curve_param(3, 0.0);
+  tf::Vector3 vec[2];
+  geometry_msgs::Point pt_m[2];
+  double tan_pt_m[2];
+  for (unsigned int i = 0; i &lt; 2; i++) {
+    const geometry_msgs::Point &amp;p0 = point[i];
+    const geometry_msgs::Point &amp;p1 = point[i + 1];
+    pt_m[i].x = (p0.x + p1.x) / 2.0;
+    pt_m[i].y = (p0.y + p1.y) / 2.0;
+    vec[i] = tf::Vector3(p1.x - p0.x, p1.y - p0.y, 0.0);
+    if (fabs(vec[i].x()) &lt; 1e-8 &amp;&amp; fabs(vec[i].y()) &lt; 1e-8)
+      return std::vector&lt;double&gt;();
+    tan_pt_m[i] = tan(atan2(vec[i].y(), vec[i].x()) + M_PI / 2.0);
   }
+  if (fabs(tan_pt_m[1] - tan_pt_m[0]) &lt; 1e-9)
+    return std::vector&lt;double&gt;();
 
-  const double WaypointFilter::calcSquareSum(const double x, const double y)const
   {
-    return (x * x + y * y);
+    const geometry_msgs::Point &amp;p0 = point[0];
+    curve_param[0] = pt_m[0].y - pt_m[0].x * tan_pt_m[0] - pt_m[1].y +
+                     pt_m[1].x * tan_pt_m[1];
+    curve_param[0] /= tan_pt_m[1] - tan_pt_m[0];
+    curve_param[1] = pt_m[0].y - (pt_m[0].x - curve_param[0]) * tan_pt_m[0];
+    curve_param[2] =
+        sqrt(calcSquareSum(p0.x - curve_param[0], p0.y - curve_param[1]));
   }
+  return curve_param;
+}
 
-  const double WaypointFilter::calcPathLength(const autoware_msgs::lane&amp; lane)const
-  {
-    double distance = 0.0;
-    for(unsigned long i = 1; i &lt; lane.waypoints.size(); i++)
-    {
-      const geometry_msgs::Point&amp; p0 = lane.waypoints[i - 1].pose.pose.position;
-      const geometry_msgs::Point&amp; p1 = lane.waypoints[i].pose.pose.position;
-      tf::Vector3 tf0(p0.x, p0.y, 0.0);
-      tf::Vector3 tf1(p1.x, p1.y, 0.0);
-      distance += tf::tfDistance(tf0, tf1);
-    }
-    return distance;
+const double WaypointFilter::calcSquareSum(const double x,
+                                           const double y) const {
+  return (x * x + y * y);
+}
+
+const double
+WaypointFilter::calcPathLength(const autoware_msgs::lane &amp;lane) const {
+  double distance = 0.0;
+  for (unsigned long i = 1; i &lt; lane.waypoints.size(); i++) {
+    const geometry_msgs::Point &amp;p0 = lane.waypoints[i - 1].pose.pose.position;
+    const geometry_msgs::Point &amp;p1 = lane.waypoints[i].pose.pose.position;
+    tf::Vector3 tf0(p0.x, p0.y, 0.0);
+    tf::Vector3 tf1(p1.x, p1.y, 0.0);
+    distance += tf::tfDistance(tf0, tf1);
   }
+  return distance;
+}
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" added_lines="32" deleted_lines="20">
				<diff>@@ -6,7 +6,8 @@
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions are met:
  *
- *  * Redistributions of source code must retain the above copyright notice, this
+ *  * Redistributions of source code must retain the above copyright notice,
+ this
  *    list of conditions and the following disclaimer.
  *
  *  * Redistributions in binary form must reproduce the above copyright notice,
@@ -19,30 +20,31 @@
  *
  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ ARE
  *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #ifndef __WAYPOINT_FILTER_H__
 #define __WAYPOINT_FILTER_H__
 
-#include &lt;ros/ros.h&gt;
-#include &lt;tf/transform_datatypes.h&gt;
+#include "autoware_msgs/lane.h"
 #include &lt;autoware_msgs/ConfigWaypointLoader.h&gt;
 #include &lt;fstream&gt;
+#include &lt;ros/ros.h&gt;
+#include &lt;tf/transform_datatypes.h&gt;
 #include &lt;unordered_map&gt;
-#include "autoware_msgs/lane.h"
 
-namespace waypoint_maker
-{
+namespace waypoint_maker {
 
-class WaypointFilter
-{
+class WaypointFilter {
 private:
   ros::NodeHandle private_nh_;
   double r_th_, r_min_, r_inf_;
@@ -51,20 +53,30 @@ private:
   double accel_limit_, decel_limit_, resample_interval_;
   int velocity_offset_;
   bool resample_mode_;
+
 public:
   WaypointFilter();
   ~WaypointFilter();
-  void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
+  void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr &amp;conf);
   void filterLaneWaypoint(autoware_msgs::lane *lane);
+
 protected:
-  void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane *lane, std::vector&lt;double&gt; *curve_radius);
-  void getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt; *curve_radius);
-  const std::vector&lt;double&gt; calcVelParamFromVmax(const double vmax)const;
-  void createCurveList(const std::vector&lt;double&gt;&amp; curve_radius, std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list);
-  void limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx, autoware_msgs::lane *lane);
-  const std::vector&lt;double&gt; getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point)const;
-  const double calcSquareSum(const double x, const double y)const;
-  const double calcPathLength(const autoware_msgs::lane&amp; lane)const;
+  void resampleLaneWaypoint(const double resample_interval,
+                            autoware_msgs::lane *lane,
+                            std::vector&lt;double&gt; *curve_radius);
+  void getCurveAll(const autoware_msgs::lane &amp;lane,
+                   std::vector&lt;double&gt; *curve_radius);
+  const std::vector&lt;double&gt; calcVelParamFromVmax(const double vmax) const;
+  void createCurveList(
+      const std::vector&lt;double&gt; &amp;curve_radius,
+      std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt;&gt;
+          *curve_list);
+  void limitAccelDecel(const double vmax, const double vmin_local,
+                       const unsigned long idx, autoware_msgs::lane *lane);
+  const std::vector&lt;double&gt;
+  getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt; &amp;point) const;
+  const double calcSquareSum(const double x, const double y) const;
+  const double calcPathLength(const autoware_msgs::lane &amp;lane) const;
 };
 }
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="119" deleted_lines="120">
				<diff>@@ -6,7 +6,8 @@
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions are met:
  *
- *  * Redistributions of source code must retain the above copyright notice, this
+ *  * Redistributions of source code must retain the above copyright notice,
+ this
  *    list of conditions and the following disclaimer.
  *
  *  * Redistributions in binary form must reproduce the above copyright notice,
@@ -19,53 +20,54 @@
  *
  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ ARE
  *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
 #include "waypoint_loader_core.h"
 
-namespace waypoint_maker
-{
+namespace waypoint_maker {
 // Constructor
-WaypointLoaderNode::WaypointLoaderNode() : private_nh_("~")
-{
-  initPubSub();
-}
+WaypointLoaderNode::WaypointLoaderNode() : private_nh_("~") { initPubSub(); }
 
 // Destructor
-WaypointLoaderNode::~WaypointLoaderNode()
-{
-}
+WaypointLoaderNode::~WaypointLoaderNode() {}
 
-void WaypointLoaderNode::initPubSub()
-{
+void WaypointLoaderNode::initPubSub() {
   // setup publisher
-  if(disable_decision_maker_){
-	  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/lane_waypoints_array", 10, true);
-  }else{
-	  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/based/lane_waypoints_array", 10, true);
+  if (disable_decision_maker_) {
+    lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/lane_waypoints_array",
+                                                        10, true);
+  } else {
+    lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(
+        "/based/lane_waypoints_array", 10, true);
   }
-  config_sub_ = nh_.subscribe("/config/waypoint_loader", 1, &amp;WaypointLoaderNode::configCallback, this);
-  output_cmd_sub_ = nh_.subscribe("/config/waypoint_loader_output", 1, &amp;WaypointLoaderNode::outputCommandCallback, this);
+  config_sub_ = nh_.subscribe("/config/waypoint_loader", 1,
+                              &amp;WaypointLoaderNode::configCallback, this);
+  output_cmd_sub_ =
+      nh_.subscribe("/config/waypoint_loader_output", 1,
+                    &amp;WaypointLoaderNode::outputCommandCallback, this);
 }
 
-void WaypointLoaderNode::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
-{
+void WaypointLoaderNode::initParameter(
+    const autoware_msgs::ConfigWaypointLoader::ConstPtr &amp;conf) {
   // parameter settings
   disable_decision_maker_ = conf-&gt;disable_decision_maker;
   filtering_mode_ = conf-&gt;filtering_mode;
   multi_lane_csv_ = conf-&gt;multi_lane_csv;
 }
 
-void WaypointLoaderNode::configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
-{
+void WaypointLoaderNode::configCallback(
+    const autoware_msgs::ConfigWaypointLoader::ConstPtr &amp;conf) {
   filter_.initParameter(conf);
   initParameter(conf);
 
@@ -76,65 +78,67 @@ void WaypointLoaderNode::configCallback(const autoware_msgs::ConfigWaypointLoade
   output_lane_array_ = lane_array;
 }
 
-void WaypointLoaderNode::outputCommandCallback(const std_msgs::Bool::ConstPtr&amp; output_cmd)
-{
+void WaypointLoaderNode::outputCommandCallback(
+    const std_msgs::Bool::ConstPtr &amp;output_cmd) {
   std::vector&lt;std::string&gt; dst_multi_file_path = multi_file_path_;
-  for(auto&amp; el : dst_multi_file_path)
+  for (auto &amp;el : dst_multi_file_path)
     el = addFileSuffix(el, "_filtered");
   saveLaneArray(dst_multi_file_path, output_lane_array_);
 }
 
-const std::string addFileSuffix(std::string file_path, std::string suffix)
-{
+const std::string addFileSuffix(std::string file_path, std::string suffix) {
   std::string output_file_path, tmp;
   std::string directory_path, filename, extension;
 
   tmp = file_path;
   const std::string::size_type idx_slash = tmp.find_last_of("/");
-  if(idx_slash != std::string::npos)tmp.erase(0, idx_slash);
+  if (idx_slash != std::string::npos)
+    tmp.erase(0, idx_slash);
   const std::string::size_type idx_dot = tmp.find_last_of(".");
   const std::string::size_type idx_dot_allpath = file_path.find_last_of(".");
-  if(idx_dot != std::string::npos &amp;&amp; idx_dot != tmp.size() - 1)
+  if (idx_dot != std::string::npos &amp;&amp; idx_dot != tmp.size() - 1)
     file_path.erase(idx_dot_allpath, file_path.size() - 1);
   file_path += suffix + ".csv";
   return file_path;
 }
 
 void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt; &amp;paths,
-                                         autoware_msgs::LaneArray *lane_array)
-{
-  for (const auto&amp; el : paths)
-  {
+                                         autoware_msgs::LaneArray *lane_array) {
+  for (const auto &amp;el : paths) {
     autoware_msgs::lane lane;
     createLaneWaypoint(el, &amp;lane);
-    if(filtering_mode_)
+    if (filtering_mode_)
       filter_.filterLaneWaypoint(&amp;lane);
     lane_array-&gt;lanes.push_back(lane);
   }
 }
 
-void WaypointLoaderNode::saveLaneArray(const std::vector&lt;std::string&gt; &amp;paths, const autoware_msgs::LaneArray &amp;lane_array)
-{
+void WaypointLoaderNode::saveLaneArray(
+    const std::vector&lt;std::string&gt; &amp;paths,
+    const autoware_msgs::LaneArray &amp;lane_array) {
   unsigned long idx = 0;
-  for (const auto&amp; file_path : paths)
-  {
+  for (const auto &amp;file_path : paths) {
     std::ofstream ofs(file_path.c_str());
-    ofs &lt;&lt; "x,y,z,yaw,velocity,change_flag,steering_flag,accel_flag,stop_flag,event_flag" &lt;&lt; std::endl;
-    for(const auto&amp; el : lane_array.lanes[idx].waypoints)
-    {
-      ofs &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; el.pose.pose.position.x &lt;&lt; "," &lt;&lt; el.pose.pose.position.y &lt;&lt; ","
-          &lt;&lt; el.pose.pose.position.z &lt;&lt; "," &lt;&lt; tf::getYaw(el.pose.pose.orientation) &lt;&lt; "," &lt;&lt; mps2kmph(el.twist.twist.linear.x) &lt;&lt; ","
-          &lt;&lt; (int)el.change_flag &lt;&lt; "," &lt;&lt; (int)el.wpstate.steering_state &lt;&lt; "," &lt;&lt; (int)el.wpstate.accel_state &lt;&lt; ","
-          &lt;&lt; (int)el.wpstate.stopline_state &lt;&lt; "," &lt;&lt; (int)el.wpstate.event_state &lt;&lt; std::endl;
+    ofs &lt;&lt; "x,y,z,yaw,velocity,change_flag,steering_flag,accel_flag,stop_flag,"
+           "event_flag"
+        &lt;&lt; std::endl;
+    for (const auto &amp;el : lane_array.lanes[idx].waypoints) {
+      ofs &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; el.pose.pose.position.x
+          &lt;&lt; "," &lt;&lt; el.pose.pose.position.y &lt;&lt; "," &lt;&lt; el.pose.pose.position.z
+          &lt;&lt; "," &lt;&lt; tf::getYaw(el.pose.pose.orientation) &lt;&lt; ","
+          &lt;&lt; mps2kmph(el.twist.twist.linear.x) &lt;&lt; "," &lt;&lt; (int)el.change_flag
+          &lt;&lt; "," &lt;&lt; (int)el.wpstate.steering_state &lt;&lt; ","
+          &lt;&lt; (int)el.wpstate.accel_state &lt;&lt; ","
+          &lt;&lt; (int)el.wpstate.stopline_state &lt;&lt; ","
+          &lt;&lt; (int)el.wpstate.event_state &lt;&lt; std::endl;
     }
     idx++;
   }
 }
 
-void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, autoware_msgs::lane *lane)
-{
-  if (!verifyFileConsistency(file_path.c_str()))
-  {
+void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path,
+                                            autoware_msgs::lane *lane) {
+  if (!verifyFileConsistency(file_path.c_str())) {
     ROS_ERROR("lane data is something wrong...");
     return;
   }
@@ -153,41 +157,38 @@ void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, autowa
   lane-&gt;waypoints = wps;
 }
 
-void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps)
-{
+void WaypointLoaderNode::loadWaypointsForVer1(
+    const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps) {
   std::ifstream ifs(filename);
 
   if (!ifs)
     return;
 
   std::string line;
-  std::getline(ifs, line);  // Remove first line
+  std::getline(ifs, line); // Remove first line
 
-  while (std::getline(ifs, line))
-  {
+  while (std::getline(ifs, line)) {
     autoware_msgs::waypoint wp;
     parseWaypointForVer1(line, &amp;wp);
     wps-&gt;push_back(wp);
   }
 
   size_t last = wps-&gt;size() - 1;
-  for (size_t i = 0; i &lt; wps-&gt;size(); ++i)
-  {
-    if (i != last)
-    {
-      double yaw = atan2(wps-&gt;at(i + 1).pose.pose.position.y - wps-&gt;at(i).pose.pose.position.y,
-                         wps-&gt;at(i + 1).pose.pose.position.x - wps-&gt;at(i).pose.pose.position.x);
+  for (size_t i = 0; i &lt; wps-&gt;size(); ++i) {
+    if (i != last) {
+      double yaw = atan2(wps-&gt;at(i + 1).pose.pose.position.y -
+                             wps-&gt;at(i).pose.pose.position.y,
+                         wps-&gt;at(i + 1).pose.pose.position.x -
+                             wps-&gt;at(i).pose.pose.position.x);
       wps-&gt;at(i).pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
-    }
-    else
-    {
+    } else {
       wps-&gt;at(i).pose.pose.orientation = wps-&gt;at(i - 1).pose.pose.orientation;
     }
   }
 }
 
-void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line, autoware_msgs::waypoint *wp)
-{
+void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line,
+                                              autoware_msgs::waypoint *wp) {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
 
@@ -197,86 +198,88 @@ void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line, autoware_
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(columns[3]));
 }
 
-void WaypointLoaderNode::loadWaypointsForVer2(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps)
-{
+void WaypointLoaderNode::loadWaypointsForVer2(
+    const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps) {
   std::ifstream ifs(filename);
 
   if (!ifs)
     return;
 
   std::string line;
-  std::getline(ifs, line);  // Remove first line
+  std::getline(ifs, line); // Remove first line
 
-  while (std::getline(ifs, line))
-  {
+  while (std::getline(ifs, line)) {
     autoware_msgs::waypoint wp;
     parseWaypointForVer2(line, &amp;wp);
     wps-&gt;push_back(wp);
   }
 }
 
-void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line, autoware_msgs::waypoint *wp)
-{
+void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line,
+                                              autoware_msgs::waypoint *wp) {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
 
   wp-&gt;pose.pose.position.x = std::stod(columns[0]);
   wp-&gt;pose.pose.position.y = std::stod(columns[1]);
   wp-&gt;pose.pose.position.z = std::stod(columns[2]);
-  wp-&gt;pose.pose.orientation = tf::createQuaternionMsgFromYaw(std::stod(columns[3]));
+  wp-&gt;pose.pose.orientation =
+      tf::createQuaternionMsgFromYaw(std::stod(columns[3]));
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(columns[4]));
 }
 
-void WaypointLoaderNode::loadWaypointsForVer3(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps)
-{
+void WaypointLoaderNode::loadWaypointsForVer3(
+    const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps) {
   std::ifstream ifs(filename);
 
   if (!ifs)
     return;
 
   std::string line;
-  std::getline(ifs, line);  // get first line
+  std::getline(ifs, line); // get first line
   std::vector&lt;std::string&gt; contents;
   parseColumns(line, &amp;contents);
 
-  //std::getline(ifs, line);  // remove second line
-  while (std::getline(ifs, line))
-  {
+  // std::getline(ifs, line);  // remove second line
+  while (std::getline(ifs, line)) {
     autoware_msgs::waypoint wp;
     parseWaypointForVer3(line, contents, &amp;wp);
     wps-&gt;push_back(wp);
   }
 }
 
-void WaypointLoaderNode::parseWaypointForVer3(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
-                                       autoware_msgs::waypoint *wp)
-{
+void WaypointLoaderNode::parseWaypointForVer3(
+    const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
+    autoware_msgs::waypoint *wp) {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
   std::unordered_map&lt;std::string, std::string&gt; map;
-  for (size_t i = 0; i &lt; contents.size(); i++)
-  {
+  for (size_t i = 0; i &lt; contents.size(); i++) {
     map[contents.at(i)] = columns.at(i);
   }
 
   wp-&gt;pose.pose.position.x = std::stod(map["x"]);
   wp-&gt;pose.pose.position.y = std::stod(map["y"]);
   wp-&gt;pose.pose.position.z = std::stod(map["z"]);
-  wp-&gt;pose.pose.orientation = tf::createQuaternionMsgFromYaw(std::stod(map["yaw"]));
+  wp-&gt;pose.pose.orientation =
+      tf::createQuaternionMsgFromYaw(std::stod(map["yaw"]));
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(map["velocity"]));
   wp-&gt;change_flag = std::stoi(map["change_flag"]);
-  wp-&gt;wpstate.steering_state = (map.find("steering_flag") != map.end()) ? std::stoi(map["steering_flag"]) : 0;
-  wp-&gt;wpstate.accel_state = (map.find("accel_flag") != map.end()) ? std::stoi(map["accel_flag"]) : 0;
-  wp-&gt;wpstate.stopline_state = (map.find("stop_flag") != map.end()) ? std::stoi(map["stop_flag"]) : 0;
-  wp-&gt;wpstate.event_state = (map.find("event_flag") != map.end()) ? std::stoi(map["event_flag"]) : 0;
+  wp-&gt;wpstate.steering_state = (map.find("steering_flag") != map.end())
+                                   ? std::stoi(map["steering_flag"])
+                                   : 0;
+  wp-&gt;wpstate.accel_state =
+      (map.find("accel_flag") != map.end()) ? std::stoi(map["accel_flag"]) : 0;
+  wp-&gt;wpstate.stopline_state =
+      (map.find("stop_flag") != map.end()) ? std::stoi(map["stop_flag"]) : 0;
+  wp-&gt;wpstate.event_state =
+      (map.find("event_flag") != map.end()) ? std::stoi(map["event_flag"]) : 0;
 }
 
-FileFormat WaypointLoaderNode::checkFileFormat(const char *filename)
-{
+FileFormat WaypointLoaderNode::checkFileFormat(const char *filename) {
   std::ifstream ifs(filename);
 
-  if (!ifs)
-  {
+  if (!ifs) {
     return FileFormat::unknown;
   }
 
@@ -289,8 +292,8 @@ FileFormat WaypointLoaderNode::checkFileFormat(const char *filename)
   parseColumns(line, &amp;parsed_columns);
 
   // check if first element in the first column does not include digit
-  if (!std::any_of(parsed_columns.at(0).cbegin(), parsed_columns.at(0).cend(), isdigit))
-  {
+  if (!std::any_of(parsed_columns.at(0).cbegin(), parsed_columns.at(0).cend(),
+                   isdigit)) {
     return FileFormat::ver3;
   }
 
@@ -298,14 +301,14 @@ FileFormat WaypointLoaderNode::checkFileFormat(const char *filename)
   int num_of_columns = countColumns(line);
   ROS_INFO("columns size: %d", num_of_columns);
 
-  return ( num_of_columns == 3 ? FileFormat::ver1  // if data consists "x y z (velocity)"
-         : num_of_columns == 4 ? FileFormat::ver2  // if data consists "x y z yaw (velocity)
-                               : FileFormat::unknown
-          );
+  return (num_of_columns == 3
+              ? FileFormat::ver1 // if data consists "x y z (velocity)"
+              : num_of_columns == 4
+                    ? FileFormat::ver2 // if data consists "x y z yaw (velocity)
+                    : FileFormat::unknown);
 }
 
-bool WaypointLoaderNode::verifyFileConsistency(const char *filename)
-{
+bool WaypointLoaderNode::verifyFileConsistency(const char *filename) {
   ROS_INFO("verify...");
   std::ifstream ifs(filename);
 
@@ -314,20 +317,20 @@ bool WaypointLoaderNode::verifyFileConsistency(const char *filename)
 
   FileFormat format = checkFileFormat(filename);
   ROS_INFO("format: %d", static_cast&lt;FileFormat&gt;(format));
-  if (format == FileFormat::unknown)
-  {
+  if (format == FileFormat::unknown) {
     ROS_ERROR("unknown file format");
     return false;
   }
 
   std::string line;
-  std::getline(ifs, line);  // remove first line
+  std::getline(ifs, line); // remove first line
 
-  size_t ncol = format == FileFormat::ver1 ? 4 //x,y,z,velocity
-              : format == FileFormat::ver2 ? 5 //x,y,z,yaw,velocity
-              : countColumns(line);
+  size_t ncol = format == FileFormat::ver1
+                    ? 4                              // x,y,z,velocity
+                    : format == FileFormat::ver2 ? 5 // x,y,z,yaw,velocity
+                                                 : countColumns(line);
 
-  while (std::getline(ifs, line))  // search from second line
+  while (std::getline(ifs, line)) // search from second line
   {
     if (countColumns(line) != ncol)
       return false;
@@ -335,28 +338,24 @@ bool WaypointLoaderNode::verifyFileConsistency(const char *filename)
   return true;
 }
 
-void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns)
-{
+void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns) {
   std::istringstream ss(line);
   std::string column;
-  while (std::getline(ss, column, ','))
-  {
+  while (std::getline(ss, column, ',')) {
     columns-&gt;push_back(column);
   }
 }
 
-size_t countColumns(const std::string &amp;line)
-{
+size_t countColumns(const std::string &amp;line) {
   std::istringstream ss(line);
   size_t ncol = 0;
 
   std::string column;
-  while (std::getline(ss, column, ','))
-  {
+  while (std::getline(ss, column, ',')) {
     ++ncol;
   }
 
   return ncol;
 }
 
-}  // waypoint_maker
+} // waypoint_maker
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="42" deleted_lines="36">
				<diff>@@ -5,7 +5,8 @@
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions are met:
  *
- *  * Redistributions of source code must retain the above copyright notice, this
+ *  * Redistributions of source code must retain the above copyright notice,
+this
  *    list of conditions and the following disclaimer.
  *
  *  * Redistributions in binary form must reproduce the above copyright notice,
@@ -18,13 +19,16 @@
  *
  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE
  *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
@@ -35,50 +39,43 @@
 #include &lt;ros/ros.h&gt;
 
 // C++ includes
-#include &lt;iostream&gt;
 #include &lt;fstream&gt;
-#include &lt;vector&gt;
+#include &lt;iostream&gt;
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
 #include &lt;unordered_map&gt;
+#include &lt;vector&gt;
 
 #include "autoware_msgs/LaneArray.h"
 #include "waypoint_filter.h"
 
-namespace waypoint_maker
-{
+namespace waypoint_maker {
 
 const std::string MULTI_LANE_CSV = "/tmp/driving_lane.csv";
 
-enum class FileFormat : int32_t
-{
-  ver1,  //x,y,z,(velocity)
-  ver2,  //x,y,z,yaw,(velocity)
-  ver3,  //first line consists on explanation of values
+enum class FileFormat : int32_t {
+  ver1, // x,y,z,(velocity)
+  ver2, // x,y,z,yaw,(velocity)
+  ver3, // first line consists on explanation of values
 
   unknown = -1,
 };
 
 typedef std::underlying_type&lt;FileFormat&gt;::type FileFormatInteger;
 
-inline double kmph2mps(double velocity_kmph)
-{
+inline double kmph2mps(double velocity_kmph) {
   return (velocity_kmph * 1000) / (60 * 60);
 }
-inline double mps2kmph(double velocity_mps)
-{
+inline double mps2kmph(double velocity_mps) {
   return (velocity_mps * 60 * 60) / 1000;
 }
 
-class WaypointLoaderNode
-{
+class WaypointLoaderNode {
 public:
-
   WaypointLoaderNode();
   ~WaypointLoaderNode();
 
 private:
-
   // handle
   ros::NodeHandle nh_;
   ros::NodeHandle private_nh_;
@@ -98,29 +95,38 @@ private:
 
   // initializer
   void initPubSub();
-  void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
+  void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr &amp;conf);
 
   // functions
-  void configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
-  void outputCommandCallback(const std_msgs::Bool::ConstPtr&amp; output_cmd);
-  void createLaneWaypoint(const std::string &amp;file_path, autoware_msgs::lane *lane);
-  void createLaneArray(const std::vector&lt;std::string&gt; &amp;paths, autoware_msgs::LaneArray *lane_array);
-  void saveLaneArray(const std::vector&lt;std::string&gt; &amp;paths, const autoware_msgs::LaneArray &amp;lane_array);
+  void
+  configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr &amp;conf);
+  void outputCommandCallback(const std_msgs::Bool::ConstPtr &amp;output_cmd);
+  void createLaneWaypoint(const std::string &amp;file_path,
+                          autoware_msgs::lane *lane);
+  void createLaneArray(const std::vector&lt;std::string&gt; &amp;paths,
+                       autoware_msgs::LaneArray *lane_array);
+  void saveLaneArray(const std::vector&lt;std::string&gt; &amp;paths,
+                     const autoware_msgs::LaneArray &amp;lane_array);
 
   FileFormat checkFileFormat(const char *filename);
   bool verifyFileConsistency(const char *filename);
-  void loadWaypointsForVer1(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
-  void parseWaypointForVer1(const std::string &amp;line, autoware_msgs::waypoint *wp);
-  void loadWaypointsForVer2(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
-  void parseWaypointForVer2(const std::string &amp;line, autoware_msgs::waypoint *wp);
-  void loadWaypointsForVer3(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
-  void parseWaypointForVer3(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
+  void loadWaypointsForVer1(const char *filename,
+                            std::vector&lt;autoware_msgs::waypoint&gt; *wps);
+  void parseWaypointForVer1(const std::string &amp;line,
+                            autoware_msgs::waypoint *wp);
+  void loadWaypointsForVer2(const char *filename,
+                            std::vector&lt;autoware_msgs::waypoint&gt; *wps);
+  void parseWaypointForVer2(const std::string &amp;line,
+                            autoware_msgs::waypoint *wp);
+  void loadWaypointsForVer3(const char *filename,
+                            std::vector&lt;autoware_msgs::waypoint&gt; *wps);
+  void parseWaypointForVer3(const std::string &amp;line,
+                            const std::vector&lt;std::string&gt; &amp;contents,
                             autoware_msgs::waypoint *wp);
 };
 
 const std::string addFileSuffix(std::string file_path, std::string suffix);
 void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns);
-size_t countColumns(const std::string&amp; line);
-
+size_t countColumns(const std::string &amp;line);
 }
-#endif  // WAYPOINT_LOADER_CORE_H
+#endif // WAYPOINT_LOADER_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_node.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_node.cpp" added_lines="9" deleted_lines="6">
				<diff>@@ -5,7 +5,8 @@
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions are met:
  *
- *  * Redistributions of source code must retain the above copyright notice, this
+ *  * Redistributions of source code must retain the above copyright notice,
+ * this
  *    list of conditions and the following disclaimer.
  *
  *  * Redistributions in binary form must reproduce the above copyright notice,
@@ -18,13 +19,16 @@
  *
  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE
  *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
@@ -33,8 +37,7 @@
 
 #include "waypoint_loader_core.h"
 
-int main(int argc, char **argv)
-{
+int main(int argc, char **argv) {
   ros::init(argc, argv, "waypoint_loader");
   waypoint_maker::WaypointLoaderNode wln;
   ros::spin();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="962dd475a2d24b20772c9cd2ca5bb030c38bde58" author="Abraham Monrroy">
		<msg>[feature] Initial release of Yolo v3 node (#1202)

* Initial release of Yolo v3 node

* Added extra documentation

* * Missing header include</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -191,7 +191,7 @@ class Yolo2DetectorNode
 	void image_callback(const sensor_msgs::ImageConstPtr&amp; in_image_message)
 	{
 		std::vector&lt; RectClassScore&lt;float&gt; &gt; detections;
-		//darknet_image = yolo_detector_.convert_image(in_image_message);
+		//darknet_image_ = yolo_detector_.convert_image(in_image_message);
 
 		darknet_image = convert_ipl_to_image(in_image_message);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6e4b15917c096f071fb867cd3aa56e91af808ade" author="Yamato ANDO">
		<msg>add ctrl_cmd/cmd/linear_acceletion</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" added_lines="4" deleted_lines="0">
				<diff>@@ -83,6 +83,10 @@ public:
   {
     return current_pose_;
   }
+  std::vector&lt;autoware_msgs::waypoint&gt; getCurrentWaypoints() const
+  {
+    return current_waypoints_;
+  }
   double getLookaheadDistance() const
   {
     return lookahead_distance_;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="26" deleted_lines="0">
				<diff>@@ -82,6 +82,7 @@ void PurePursuitNode::initForROS()
   pub13_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("search_circle_mark", 0);
   pub14_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("line_point_mark", 0);  // debug tool
   pub15_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("trajectory_circle_mark", 0);
+  pub16_ = nh_.advertise&lt;std_msgs::Float32&gt;("angular_gravity", 0);
   // pub7_ = nh.advertise&lt;std_msgs::Bool&gt;("wf_stat", 0);
 }
 
@@ -112,10 +113,14 @@ void PurePursuitNode::run()
     pub12_.publish(displayNextTarget(pp_.getPoseOfNextTarget()));
     pub15_.publish(displayTrajectoryCircle(
         waypoint_follower::generateTrajectoryCircle(pp_.getPoseOfNextTarget(), pp_.getCurrentPose())));
+    std_msgs::Float32 angular_gravity_msg;
+    angular_gravity_msg.data = computeAngularGravity(computeCommandVelocity(), kappa);
+    pub16_.publish(angular_gravity_msg);
 
     is_pose_set_ = false;
     is_velocity_set_ = false;
     is_waypoint_set_ = false;
+
     loop_rate.sleep();
   }
 }
@@ -137,6 +142,7 @@ void PurePursuitNode::publishControlCommandStamped(const bool &amp;can_get_curvature
   autoware_msgs::ControlCommandStamped ccs;
   ccs.header.stamp = ros::Time::now();
   ccs.cmd.linear_velocity = can_get_curvature ? computeCommandVelocity() : 0;
+  ccs.cmd.linear_acceleration = can_get_curvature ? computeCommandAccel() : 0;
   ccs.cmd.steering_angle = can_get_curvature ? convertCurvatureToSteeringAngle(wheel_base_, kappa) : 0;
 
   pub2_.publish(ccs);
@@ -163,6 +169,26 @@ double PurePursuitNode::computeCommandVelocity() const
   return command_linear_velocity_;
 }
 
+double PurePursuitNode::computeCommandAccel() const
+{
+  const geometry_msgs::Pose current_pose = pp_.getCurrentPose();
+  const geometry_msgs::Pose target_pose = pp_.getCurrentWaypoints().at(1).pose.pose;
+
+  // v^2 - v0^2 = 2ax
+  const double x =  std::hypot(current_pose.position.x-target_pose.position.x, current_pose.position.y-target_pose.position.y);
+  const double v0 = current_linear_velocity_;
+  const double v = computeCommandVelocity();
+  const double a = (v*v - v0*v0) / (2*x);
+  return a;
+}
+
+double PurePursuitNode::computeAngularGravity(double velocity, double kappa) const
+{
+  const double gravity = 9.80665;
+  std::cout &lt;&lt; "kappa:" &lt;&lt; 1.0/kappa &lt;&lt; std::endl;
+  return (velocity*velocity) / (1.0/kappa*gravity);
+}
+
 void PurePursuitNode::callbackFromConfig(const autoware_msgs::ConfigWaypointFollowerConstPtr &amp;config)
 {
   param_flag_ = config-&gt;param_flag;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" added_lines="4" deleted_lines="1">
				<diff>@@ -33,6 +33,7 @@
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
+#include &lt;std_msgs/Float32.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
@@ -77,7 +78,7 @@ private:
   PurePursuit pp_;
 
   // publisher
-  ros::Publisher pub1_, pub2_, pub11_, pub12_, pub13_, pub14_, pub15_;
+  ros::Publisher pub1_, pub2_, pub11_, pub12_, pub13_, pub14_, pub15_, pub16_;
 
   // subscriber
   ros::Subscriber sub1_, sub2_, sub3_, sub4_;
@@ -112,6 +113,8 @@ private:
 
   double computeLookaheadDistance() const;
   double computeCommandVelocity() const;
+  double computeCommandAccel() const;
+  double computeAngularGravity(double velocity, double kappa) const;
 };
 
 double convertCurvatureToSteeringAngle(const double &amp;wheel_base, const double &amp;kappa);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" added_lines="31" deleted_lines="1">
				<diff>@@ -40,6 +40,7 @@
 #include &lt;random&gt;
 
 #include "waypoint_follower/libwaypoint_follower.h"
+#include "autoware_msgs/ControlCommandStamped.h"
 
 namespace
 {
@@ -52,6 +53,7 @@ geometry_msgs::Pose _initial_pose;
 bool _initial_set = false;
 bool _pose_set = false;
 bool _waypoint_set = false;
+bool _use_ctrl_cmd = false;
 bool g_is_closest_waypoint_subscribed = false;
 WayPoints _current_waypoints;
 ros::Publisher g_odometry_publisher;
@@ -59,11 +61,16 @@ ros::Publisher g_velocity_publisher;
 int32_t g_closest_waypoint = -1;
 double g_position_error;
 double g_angle_error;
+double g_linear_acceleration = 0;
+double g_steering_angle = 0;
+double g_wheel_base_m = 2.7;
 
 constexpr int LOOP_RATE = 50; // 50Hz
 
 void CmdCallBack(const geometry_msgs::TwistStampedConstPtr &amp;msg, double accel_rate)
 {
+  if(_use_ctrl_cmd == true)
+    return;
 
   static double previous_linear_velocity = 0;
 
@@ -94,6 +101,15 @@ void CmdCallBack(const geometry_msgs::TwistStampedConstPtr &amp;msg, double accel_ra
   //_current_velocity = msg-&gt;twist;
 }
 
+void controlCmdCallBack(const autoware_msgs::ControlCommandStampedConstPtr &amp;msg)
+{
+  if(_use_ctrl_cmd == false)
+    return;
+
+  g_linear_acceleration = msg-&gt;cmd.linear_acceleration;
+  g_steering_angle = msg-&gt;cmd.steering_angle;
+}
+
 void getTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
 {
   static tf::TransformListener listener;
@@ -147,6 +163,16 @@ void callbackFromClosestWaypoint(const std_msgs::Int32ConstPtr &amp;msg)
   g_is_closest_waypoint_subscribed = true;
 }
 
+
+void updateVelocity()
+{
+  if(_use_ctrl_cmd == false)
+    return;
+
+  _current_velocity.linear.x  += g_linear_acceleration / (double)LOOP_RATE;
+  _current_velocity.angular.z = _current_velocity.linear.x * std::sin(g_steering_angle) / g_wheel_base_m;
+}
+
 void publishOdometry()
 {
   static ros::Time current_time = ros::Time::now();
@@ -177,7 +203,6 @@ void publishOdometry()
   }
 */if(_waypoint_set &amp;&amp; g_is_closest_waypoint_subscribed)
     pose.position.z = _current_waypoints.getWaypointPosition(g_closest_waypoint).z;
-
   double vx = _current_velocity.linear.x;
   double vth = _current_velocity.angular.z;
   current_time = ros::Time::now();
@@ -259,12 +284,16 @@ int main(int argc, char **argv)
 
   private_nh.param("position_error", g_position_error, double(0.0));
   private_nh.param("angle_error", g_angle_error, double(0.0));
+  private_nh.param("vehicle_info/wheel_base", g_wheel_base_m, double(2.7));
+
+  private_nh.param("use_ctrl_cmd", _use_ctrl_cmd, false);
   // publish topic
   g_odometry_publisher = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("sim_pose", 10);
   g_velocity_publisher = nh.advertise&lt;geometry_msgs::TwistStamped&gt;("sim_velocity", 10);
 
   // subscribe topic
   ros::Subscriber cmd_subscriber = nh.subscribe&lt;geometry_msgs::TwistStamped&gt;("twist_cmd", 10, boost::bind(CmdCallBack, _1, accel_rate));
+  ros::Subscriber control_cmd_subscriber = nh.subscribe("ctrl_cmd", 10, controlCmdCallBack);
   ros::Subscriber waypoint_subcscriber = nh.subscribe("base_waypoints", 10, waypointCallback);
   ros::Subscriber closest_sub = nh.subscribe("closest_waypoint", 10, callbackFromClosestWaypoint);
   ros::Subscriber initialpose_subscriber;
@@ -303,6 +332,7 @@ int main(int argc, char **argv)
       continue;
     }
 
+    updateVelocity();
     publishOdometry();
 
     loop_rate.sleep();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8362f76ed3fe030c832364e3eea9b3cf378fc326" author="Yamato ANDO">
		<msg>delete unnecessary line</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -185,7 +185,6 @@ double PurePursuitNode::computeCommandAccel() const
 double PurePursuitNode::computeAngularGravity(double velocity, double kappa) const
 {
   const double gravity = 9.80665;
-  std::cout &lt;&lt; "kappa:" &lt;&lt; 1.0/kappa &lt;&lt; std::endl;
   return (velocity*velocity) / (1.0/kappa*gravity);
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fb857eb09e8e97180c0cfa76f60708b6f4597884" author="Yuki Iida">
		<msg>add publish function of stop state</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" added_lines="16" deleted_lines="1">
				<diff>@@ -34,6 +34,7 @@
 #include &lt;map&gt;
 
 #include &lt;ros/ros.h&gt;
+#include &lt;std_msgs/Int32.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;std_msgs/String.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
@@ -74,6 +75,7 @@ class TwistGate
     ros::Publisher emergency_stop_pub_;
     ros::Publisher control_command_pub_;
     ros::Publisher vehicle_cmd_pub_;
+    ros::Publisher state_cmd_pub_;
     ros::Subscriber remote_cmd_sub_;
     std::map&lt;std::string , ros::Subscriber&gt; auto_cmd_sub_stdmap_;
 
@@ -85,6 +87,9 @@ class TwistGate
     std::thread watchdog_timer_thread_;
     enum class CommandMode{AUTO=1, REMOTE=2} command_mode_, previous_command_mode_;
     std_msgs::String command_mode_topic_;
+
+    // still send is true
+    bool send_emergency_cmd = false;
 };
 
 TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_nh) :
@@ -97,6 +102,7 @@ TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_n
   emergency_stop_pub_ = nh_.advertise&lt;std_msgs::Bool&gt;("/emergency_stop", 1, true);
   control_command_pub_ = nh_.advertise&lt;std_msgs::String&gt;("/ctrl_mode", 1);
   vehicle_cmd_pub_ = nh_.advertise&lt;vehicle_cmd_msg_t&gt;("/vehicle_cmd", 1, true);
+  state_cmd_pub_ = nh_.advertise&lt;std_msgs::Int32&gt;("/state_cmd", 1, true);
 
   remote_cmd_sub_ = nh_.subscribe("/remote_cmd", 1, &amp;TwistGate::remote_cmd_callback, this);
 
@@ -110,8 +116,8 @@ TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_n
   auto_cmd_sub_stdmap_["ctrl_cmd"] = nh_.subscribe("/ctrl_cmd", 1, &amp;TwistGate::ctrl_cmd_callback, this);
 
   twist_gate_msg_.header.seq = 0;
-
   emergency_stop_msg_.data = false;
+  send_emergency_cmd = false;
 
   remote_cmd_time_ = ros::Time::now();
   watchdog_timer_thread_ = std::thread(&amp;TwistGate::watchdog_timer, this);
@@ -175,7 +181,16 @@ void TwistGate::watchdog_timer()
 
     // Emergency
     if(emergency_flag) {
+      // Change Auto Mode
       command_mode_ = CommandMode::AUTO;
+      if(send_emergency_cmd == false) {
+        // Change State to Stop
+        std_msgs::Int32 state_cmd;
+        state_cmd.data = 14;
+        state_cmd_pub_.publish(state_cmd);
+        send_emergency_cmd = true;
+      }
+      // Set Emergency Stop
       emergency_stop_msg_.data = true;
       emergency_stop_pub_.publish(emergency_stop_msg_);
       ROS_WARN("Emergency Stop!");
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3fb286903fd4ff80120514ac22c11e16bc477c0e" author="cirpue49">
		<msg>add ros style enum</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" added_lines="2" deleted_lines="0">
				<diff>@@ -49,6 +49,8 @@ private:
 	double bb_yaw_change_thres_;//0.2; 
 	// double bb_area_change_thres_;//0.5;
 
+	double dist_from_init_thres_;
+
 	// std::vector&lt;UKF&gt; targets_;
 	// std::vector&lt;int&gt; trackNumVec_;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="59" deleted_lines="29">
				<diff>@@ -21,6 +21,31 @@
 using std::cout;
 using std::endl;
 
+namespace States
+{
+  enum TrackingState: int
+  {
+     Die = 0,
+     Init = 1,
+     Stable = 4,
+     Lost = 10,
+
+  };
+}
+typedef States::TrackingState TrackingState;
+
+namespace Matches
+{
+  enum IsMatch: int
+  {
+     False = 0,
+     True = 1,
+  };
+}
+typedef Matches::IsMatch IsMatch;
+
+
+
 int g_count = 0;
 
 ImmUkfPda::ImmUkfPda()
@@ -44,6 +69,9 @@ ImmUkfPda::ImmUkfPda()
     //bbox update params
     bb_yaw_change_thres_  = 0.3;
 
+    //static callsification param
+    dist_from_init_thres_ = 3.0;
+
 
     tf::TransformListener *lr (new  tf::TransformListener);
     tran_=lr;
@@ -162,7 +190,7 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
         if(nis &lt; gamma_g_)
         { // x^2 99% range
             count ++;
-            if(matching_vec[i] == 0) target.lifetime_ ++;
+            if(matching_vec[i] == IsMatch::False) target.lifetime_ ++;
 
             // pick one meas with smallest nis
             if(second_init)
@@ -172,7 +200,7 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
                 smallest_nis = nis;
                 smallest_meas_cluster = input.clusters[i];
                 // measVec.push_back(meas);
-                matching_vec[i] = 1;
+                matching_vec[i] = IsMatch::True;
                 second_init_done = true;
                 }
             }
@@ -180,7 +208,7 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
             {
                 // cout &lt;&lt; "check cp "&lt;&lt;input.clusters[i].bounding_box.pose.position.x &lt;&lt; " "&lt;&lt; input.clusters[i].bounding_box.pose.position.y &lt;&lt; endl;
                 cluster_vec.push_back(input.clusters[i]);
-                matching_vec[i] = 1;
+                matching_vec[i] = IsMatch::True;
             }
         }
     }
@@ -371,7 +399,7 @@ void ImmUkfPda::associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; clust
         return;
     }
     // cout &lt;&lt; target.tracking_num_ &lt;&lt; " "&lt;&lt; target.lifetime_ &lt;&lt; endl;
-    if(target.tracking_num_ == 5 &amp;&amp; target.lifetime_ &gt;= life_time_thres_)
+    if(target.tracking_num_ == TrackingState::Stable &amp;&amp; target.lifetime_ &gt;= life_time_thres_)
     {
         // cout &lt;&lt; "--------------" &lt;&lt; endl;
         autoware_msgs::CloudCluster nearest_cluster;
@@ -546,15 +574,15 @@ void ImmUkfPda::updateLabel(UKF target, autoware_msgs::CloudCluster&amp; cc)
     {
         cc.label = "Static";
     }
-    else if(tracking_num &gt; 0 &amp;&amp; tracking_num &lt;= 3)
+    else if(tracking_num &gt; TrackingState::Die &amp;&amp; tracking_num &lt; TrackingState::Stable)
     {
         cc.label = "Initialized";
     }
-    else if(tracking_num == 5)
+    else if(tracking_num == TrackingState::Stable)
     {
         cc.label = "Stable";
     }
-    else if(tracking_num &gt; 5 &amp;&amp; tracking_num &lt;= 10)
+    else if(tracking_num &gt; TrackingState::Stable &amp;&amp; tracking_num &lt;= TrackingState::Lost)
     {
         cc.label = "Lost";
     }
@@ -611,11 +639,11 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
         targets_[i].is_vis_bb_ = false;
 
     	//todo: modify here. This skips irregular measurement and nan
-    	if(targets_[i].tracking_num_ == 0) continue;
+        if(targets_[i].tracking_num_ == TrackingState::Die) continue;
         // prevent ukf not to explode
         if(targets_[i].p_merge_.determinant() &gt; 10 || targets_[i].p_merge_(4,4) &gt; 1000)
         {
-            targets_[i].tracking_num_ = 0;
+            targets_[i].tracking_num_ = TrackingState::Die;
             continue;
         }
         // immukf prediction step
@@ -636,12 +664,12 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
         // prevent ukf not to explode
         if(std::isnan(det_s)|| det_s &gt; 10)
         {
-            targets_[i].tracking_num_ = 0;
+            targets_[i].tracking_num_ = TrackingState::Die;
             continue;
         }
 
         bool second_init;
-        if(targets_[i].tracking_num_ == 1)
+        if(targets_[i].tracking_num_ == TrackingState::Init)
         {
             second_init = true;
         }
@@ -668,7 +696,7 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
         {
             if(cluster_vec.size() == 0)
             {
-                targets_[i].tracking_num_ = 0;
+                targets_[i].tracking_num_ = TrackingState::Die;
                 continue;
             }
 
@@ -701,38 +729,38 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
     	// update tracking number
     	if(cluster_vec.size() &gt; 0)
         {
-    		if(targets_[i].tracking_num_ &lt; 3)
+            if(targets_[i].tracking_num_ &lt; TrackingState::Stable)
             {
     			targets_[i].tracking_num_++;
     		}
-    		else if(targets_[i].tracking_num_ == 3)
+            else if(targets_[i].tracking_num_ == TrackingState::Stable)
             {
-    			targets_[i].tracking_num_ = 5;
+                targets_[i].tracking_num_ = TrackingState::Stable;
     		}
-    		else if(targets_[i].tracking_num_ &gt;= 5 &amp;&amp; targets_[i].tracking_num_ &lt; 10)
+            else if(targets_[i].tracking_num_ &gt;= TrackingState::Stable &amp;&amp; targets_[i].tracking_num_ &lt; TrackingState::Lost)
             {
-    			targets_[i].tracking_num_ = 5;
+                targets_[i].tracking_num_ = TrackingState::Stable;
     		}
-            else if(targets_[i].tracking_num_ == 10)
+            else if(targets_[i].tracking_num_ == TrackingState::Lost)
             {
-                targets_[i].tracking_num_ = 0;
+                targets_[i].tracking_num_ = TrackingState::Die;
             }
     	}else{
-            if(targets_[i].tracking_num_ &lt; 5)
+            if(targets_[i].tracking_num_ &lt; TrackingState::Stable)
             {
-                targets_[i].tracking_num_ = 0;
+                targets_[i].tracking_num_ = TrackingState::Die;
             }
-    		else if(targets_[i].tracking_num_ &gt;= 5 &amp;&amp; targets_[i].tracking_num_ &lt; 10)
+            else if(targets_[i].tracking_num_ &gt;= TrackingState::Stable &amp;&amp; targets_[i].tracking_num_ &lt; TrackingState::Lost)
             {
     			targets_[i].tracking_num_++;
     		}
-    		else if(targets_[i].tracking_num_ == 10)
+            else if(targets_[i].tracking_num_ == TrackingState::Lost)
             {
-    			targets_[i].tracking_num_ = 0;
+                targets_[i].tracking_num_ = TrackingState::Die;
     		}
     	}
 
-        if(targets_[i].tracking_num_ == 0) continue;
+        if(targets_[i].tracking_num_ == TrackingState::Die) continue;
 
 
 	    filterPDA(targets_[i], cluster_vec, lambda_vec);
@@ -752,7 +780,7 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
 
     for(size_t i = 0; i &lt; matching_vec.size(); i ++)
     {
-        if(matching_vec[i] == 0)
+        if(matching_vec[i] == IsMatch::False)
         {
             double px = input.clusters[i].bounding_box.pose.position.x;
             double py = input.clusters[i].bounding_box.pose.position.y;
@@ -772,10 +800,12 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
     // static dynamic classification
     for (size_t i = 0; i &lt; targets_.size(); i++)
     {
-        if(!targets_[i].is_static_ &amp;&amp; targets_[i].tracking_num_ == 5 &amp;&amp; targets_[i].lifetime_ &gt; 8 )
+        if(!targets_[i].is_static_ &amp;&amp;
+         targets_[i].tracking_num_ == TrackingState::Stable &amp;&amp;
+         targets_[i].lifetime_ &gt; life_time_thres_ )
         {
-            double dist_thres = 3.0;
-            if((targets_[i].dist_from_init_ &lt; dist_thres)&amp;&amp;
+            // double dist_thres = 3.0;
+            if((targets_[i].dist_from_init_ &lt; dist_from_init_thres_)&amp;&amp;
                     (targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_cv_ ||
                      targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_ctrv_ ))
             {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4997ee2a80f49ed97f75d14b2d9f6527cff28f4e" author="cirpue49">
		<msg>modify getNearestEuclidCluster argument</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" added_lines="1" deleted_lines="1">
				<diff>@@ -70,7 +70,7 @@ private:
 							   std::vector&lt;int&gt;&amp; matching_vec);
 	void filterPDA(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, std::vector&lt;double&gt;&amp; lambda_vec);
 	void getNearestEuclidCluster(const UKF target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, 
-							  autoware_msgs::CloudCluster&amp; cluster, int&amp; min_dist);
+							  autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist);
 	void getRightAngleBBox(const std::vector&lt;double&gt; nearest_bbox, std::vector&lt;double&gt;&amp; rightAngle_bbox);
 	void associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
                      UKF&amp; target);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -368,7 +368,7 @@ void ImmUkfPda::filterPDA(UKF&amp; target,
 
 void ImmUkfPda::getNearestEuclidCluster(const UKF target,
                                         const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
-                                        autoware_msgs::CloudCluster&amp; cluster, int&amp; min_dist){
+                                        autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist){
     int min_ind = 0;
     double px = target.x_merge_(0);
     double py = target.x_merge_(1);
@@ -403,7 +403,7 @@ void ImmUkfPda::associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; clust
     {
         // cout &lt;&lt; "--------------" &lt;&lt; endl;
         autoware_msgs::CloudCluster nearest_cluster;
-        int min_dist = 999;
+        double min_dist = 999;
         getNearestEuclidCluster(target, cluster_vec, nearest_cluster, min_dist);
         // cout &lt;&lt; "minDist "&lt;&lt; minDist &lt;&lt; endl;
         if(min_dist &lt; distance_thres_)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4f532eae866a50673f0d922e71847d310f640570" author="cirpue49">
		<msg>Add run-time manager script</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" added_lines="15" deleted_lines="10">
				<diff>@@ -46,30 +46,35 @@ private:
 	double distance_thres_;//0.25;
 	int life_time_thres_;//8;
 	//bbox update params
-	double bb_yaw_change_thres_;//0.2; 
+	double bb_yaw_change_thres_;//0.2;
 	// double bb_area_change_thres_;//0.5;
 
 	double dist_from_init_thres_;
 
+	double init_yaw_;
+
+	std::string input_topic_;
+	std::string output_topic_;
+
 	// std::vector&lt;UKF&gt; targets_;
 	// std::vector&lt;int&gt; trackNumVec_;
 
 	tf::TransformListener* tran_;
 
 	ros::NodeHandle node_handle_;
-    ros::Subscriber sub_cloud_array_;
-    ros::Publisher pub_cloud_array_;
+  ros::Subscriber sub_cloud_array_;
+  ros::Publisher pub_cloud_array_;
 
-    void callBack(autoware_msgs::CloudClusterArray input);
-    void transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input);
-    void transformPoseToLocal(autoware_msgs::CloudClusterArray&amp; input);
+  void callBack(autoware_msgs::CloudClusterArray input);
+  void transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input);
+  void transformPoseToLocal(autoware_msgs::CloudClusterArray&amp; input);
 	void findMaxZandS(const UKF target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s);
-	void measurementValidation(const autoware_msgs::CloudClusterArray input, UKF&amp; target, const bool second_init, 
-							   const Eigen::VectorXd max_det_z, const Eigen::MatrixXd max_det_s, 
-							   std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, 
+	void measurementValidation(const autoware_msgs::CloudClusterArray input, UKF&amp; target, const bool second_init,
+							   const Eigen::VectorXd max_det_z, const Eigen::MatrixXd max_det_s,
+							   std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
 							   std::vector&lt;int&gt;&amp; matching_vec);
 	void filterPDA(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, std::vector&lt;double&gt;&amp; lambda_vec);
-	void getNearestEuclidCluster(const UKF target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, 
+	void getNearestEuclidCluster(const UKF target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
 							  autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist);
 	void getRightAngleBBox(const std::vector&lt;double&gt; nearest_bbox, std::vector&lt;double&gt;&amp; rightAngle_bbox);
 	void associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="43" deleted_lines="50">
				<diff>@@ -10,6 +10,8 @@
 #include &lt;cmath&gt;
 #include &lt;math.h&gt;
 
+#include &lt;limits.h&gt;
+
 #include &lt;tf/tf.h&gt;
 #include &lt;tf/transform_listener.h&gt;
 #include &lt;tf2/LinearMath/Quaternion.h&gt;
@@ -45,42 +47,31 @@ namespace Matches
 typedef Matches::IsMatch IsMatch;
 
 
-
+//for print out iteration
 int g_count = 0;
 
 ImmUkfPda::ImmUkfPda()
 {
-    //dynamic
-    init_ = false;
-
-
-    //params--------------------
-    // probabilistic data association params
-    gamma_g_ = 9.22; // 99%
-    p_g_ = 0.99;
-    // const double gammaG_ = 5.99; // 99%
-    // const double pG_ = 0.95;
-    // const double gammaG_ = 15.22; // 99%
-    p_d_ = 0.9;
 
-    //bbox association param
-    distance_thres_ = 0.25;
-    life_time_thres_ = 8;
-    //bbox update params
-    bb_yaw_change_thres_  = 0.3;
 
-    //static callsification param
-    dist_from_init_thres_ = 3.0;
+  ros::NodeHandle private_nh_("~");
+  private_nh_.param&lt;bool&gt;("init_", init_, false);
+  private_nh_.param&lt;double&gt;("gamma_g_", gamma_g_, 9.22);
+  private_nh_.param&lt;double&gt;("p_g_", p_g_, 0.99);
+  private_nh_.param&lt;double&gt;("p_d_", p_d_, 0.9);
+  private_nh_.param&lt;double&gt;("distance_thres_", distance_thres_, 99);
+  private_nh_.param&lt;int&gt;("life_time_thres_", life_time_thres_, 8);
+  private_nh_.param&lt;double&gt;("bb_yaw_change_thres_", bb_yaw_change_thres_, 0.3);
+  private_nh_.param&lt;double&gt;("dist_from_init_thres_", dist_from_init_thres_, 3.0);
+  private_nh_.param&lt;double&gt;("init_yaw_", init_yaw_, 100);
+  private_nh_.param&lt;std::string&gt;("input_topic_", input_topic_, "/cloud_clusters");
+  private_nh_.param&lt;std::string&gt;("output_topic_", output_topic_, "/tracking_cluster_array");
 
+  tf::TransformListener *lr (new  tf::TransformListener);
+  tran_=lr;
 
-    tf::TransformListener *lr (new  tf::TransformListener);
-    tran_=lr;
-
-    //subscribe topic diretly from clustering algorithm
-    sub_cloud_array_   = node_handle_.subscribe ("/cloud_clusters", 1, &amp;ImmUkfPda::callBack, this);
-    //subscribe topic from cluster filter
-    // sub_cloud_array_   = node_handle_.subscribe ("/bbox_cluster_array", 1, &amp;ImmUkfPda::callBack, this);
-    pub_cloud_array_  = node_handle_.advertise&lt;autoware_msgs::CloudClusterArray&gt; ("/tracking_cluster_array", 1);
+  sub_cloud_array_   = node_handle_.subscribe (input_topic_, 1, &amp;ImmUkfPda::callBack, this);
+  pub_cloud_array_  = node_handle_.advertise&lt;autoware_msgs::CloudClusterArray&gt; (output_topic_, 1);
 
 }
 
@@ -175,7 +166,8 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
 
     int count = 0;
     bool second_init_done = false;
-    double smallest_nis = 999;
+    // double smallest_nis = 999;
+    double smallest_nis = std::numeric_limits&lt;double&gt;::max();
     autoware_msgs::CloudCluster smallest_meas_cluster;
     for(size_t i = 0; i &lt; input.clusters.size(); i++)
     {
@@ -403,9 +395,10 @@ void ImmUkfPda::associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; clust
     {
         // cout &lt;&lt; "--------------" &lt;&lt; endl;
         autoware_msgs::CloudCluster nearest_cluster;
-        double min_dist = 999;
+        // double min_dist = 999;
+        double min_dist = std::numeric_limits&lt;double&gt;::max();
         getNearestEuclidCluster(target, cluster_vec, nearest_cluster, min_dist);
-        // cout &lt;&lt; "minDist "&lt;&lt; minDist &lt;&lt; endl;
+        // std::cout &lt;&lt; "minDist "&lt;&lt; min_dist &lt;&lt; std::endl;
         if(min_dist &lt; distance_thres_)
         {
             target.is_vis_bb_ = true;
@@ -466,29 +459,26 @@ void ImmUkfPda::updateBB(UKF&amp; target)
     // skip the rest of process if it is first bbox associaiton
     // todo: wanna check if bestJskBBox is empty or not, there should be better method
     // if(target.bestBBox_.empty()){
-    if(target.best_yaw_ == 100)
+    if(target.best_yaw_ == init_yaw_)
     {
         target.best_jsk_bb_ = target.jsk_bb_;
         target.best_yaw_   = yaw;
         return;
     }
 
+    // restricting yaw movement
+    // double diff_yaw = yaw - target.best_yaw_;
 
-    double diff_yaw = yaw - target.best_yaw_;
-
-    cout &lt;&lt; yaw &lt;&lt; " " &lt;&lt; target.best_yaw_&lt;&lt; endl;
-    cout &lt;&lt; "diff yae "&lt;&lt; diff_yaw &lt;&lt; endl;
-
-    // diffYaw is within the threshold, apply the diffYaw chamge
-    if(abs(diff_yaw) &lt; bb_yaw_change_thres_)
-    {
-        target.best_jsk_bb_.pose.orientation = target.jsk_bb_.pose.orientation;
-        target.best_yaw_ = yaw;
-    }
-    else
-    {
-        target.jsk_bb_.pose.orientation = target.best_jsk_bb_.pose.orientation;
-    }
+    // // diffYaw is within the threshold, apply the diffYaw chamge
+    // if(abs(diff_yaw) &lt; bb_yaw_change_thres_)
+    // {
+    //     target.best_jsk_bb_.pose.orientation = target.jsk_bb_.pose.orientation;
+    //     target.best_yaw_ = yaw;
+    // }
+    // else
+    // {
+    //     target.jsk_bb_.pose.orientation = target.best_jsk_bb_.pose.orientation;
+    // }
 
     // // bbox area
     double area     = getJskBBoxArea(target.jsk_bb_);
@@ -599,6 +589,9 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
     int in_num_cluster = input.clusters.size();
     double timestamp = input.header.stamp.toSec();
 
+    double det_explode_param = 10;
+    double cov_explode_param = 1000;
+
     if(!init_)
     {
     	for(int i = 0; i &lt; in_num_cluster; i++)
@@ -641,7 +634,7 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
     	//todo: modify here. This skips irregular measurement and nan
         if(targets_[i].tracking_num_ == TrackingState::Die) continue;
         // prevent ukf not to explode
-        if(targets_[i].p_merge_.determinant() &gt; 10 || targets_[i].p_merge_(4,4) &gt; 1000)
+        if(targets_[i].p_merge_.determinant() &gt; det_explode_param || targets_[i].p_merge_(4,4) &gt; cov_explode_param)
         {
             targets_[i].tracking_num_ = TrackingState::Die;
             continue;
@@ -662,7 +655,7 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
         double det_s = max_det_s.determinant();
 
         // prevent ukf not to explode
-        if(std::isnan(det_s)|| det_s &gt; 10)
+        if(std::isnan(det_s)|| det_s &gt; det_explode_param)
         {
             targets_[i].tracking_num_ = TrackingState::Die;
             continue;
@@ -687,7 +680,7 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
         associateBB(cluster_vec, targets_[i]);
 
         // bounding box validation
-        updateBB(targets_[i]);
+        // updateBB(targets_[i]);
 
         // cout &lt;&lt; "validated meas "&lt;&lt;measVec[0][0]&lt;&lt;" "&lt;&lt;measVec[0][1]&lt;&lt;endl;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" added_lines="5" deleted_lines="3">
				<diff>@@ -22,10 +22,12 @@ using namespace Eigen;
 class VisualizeCloudCluster
 {
 private:
+	std::string input_topic_;
+	
 	ros::NodeHandle node_handle_;
-    ros::Subscriber sub_cloud_array_;
-    ros::Publisher  pub_jsk_bb_;
-    ros::Publisher  pub_arrow_;
+  ros::Subscriber sub_cloud_array_;
+  ros::Publisher  pub_jsk_bb_;
+  ros::Publisher  pub_arrow_;
 
 	void getJskBB(autoware_msgs::CloudClusterArray input,
 				  jsk_recognition_msgs::BoundingBoxArray&amp; jskBBs);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" added_lines="7" deleted_lines="5">
				<diff>@@ -20,10 +20,12 @@ using namespace Eigen;
 
 VisualizeCloudCluster::VisualizeCloudCluster()
 {
+	ros::NodeHandle private_nh_("~");
+	private_nh_.param&lt;std::string&gt;("input_topic_", input_topic_, "/tracking_cluster_array");
 	// sub_cloud_array_  = node_handle_.subscribe ("/bbox_cluster_array", 1, &amp;VisualizeCloudCluster::callBack, this);
-	sub_cloud_array_  = node_handle_.subscribe ("/tracking_cluster_array", 1, &amp;VisualizeCloudCluster::callBack, this);
-    pub_jsk_bb_       = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt; ("/tracking_cluster_array/jsk_bb", 1);
-    pub_arrow_        = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/tracking_cluster_array/velocity_arrow", 1);
+	sub_cloud_array_  = node_handle_.subscribe (input_topic_, 1, &amp;VisualizeCloudCluster::callBack, this);
+	pub_jsk_bb_       = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt; ("/tracking_cluster_array/jsk_bb", 1);
+	pub_arrow_        = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/tracking_cluster_array/velocity_arrow", 1);
 }
 
 void VisualizeCloudCluster::callBack(autoware_msgs::CloudClusterArray input)
@@ -33,7 +35,7 @@ void VisualizeCloudCluster::callBack(autoware_msgs::CloudClusterArray input)
 	getJskBB(input, jsk_bbs);
 	pub_jsk_bb_.publish(jsk_bbs);
 	visArrows(input);
-	cout &lt;&lt; "receive jsk call back" &lt;&lt; endl;
+	// cout &lt;&lt; "receive jsk call back" &lt;&lt; endl;
 }
 
 void VisualizeCloudCluster::getJskBB(autoware_msgs::CloudClusterArray input,
@@ -47,7 +49,7 @@ void VisualizeCloudCluster::getJskBB(autoware_msgs::CloudClusterArray input,
 		bb = input.clusters[i].bounding_box;
 		bb.header = input.header;
 		string label = input.clusters[i].label;
-		cout &lt;&lt; label &lt;&lt; endl;
+		// cout &lt;&lt; label &lt;&lt; endl;
 		// bb.label = label;
 		// ? jsk bb, how to find appropriate color
 		if(label == "Stable")
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="feb2885a623a8549c86a0b183d6da31df64736f4" author="cirpue49">
		<msg>Comment out unnecessary header file</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="10" deleted_lines="10">
				<diff>@@ -2,19 +2,19 @@
 // Created by kosuke on 12/23/17.
 //
 
-#include &lt;ros/ros.h&gt;
+// #include &lt;ros/ros.h&gt;
 
-#include &lt;iostream&gt;
-#include &lt;fstream&gt;
-#include &lt;vector&gt;
-#include &lt;cmath&gt;
-#include &lt;math.h&gt;
+// #include &lt;iostream&gt;
+// #include &lt;fstream&gt;
+// #include &lt;vector&gt;
+// #include &lt;cmath&gt;
+// #include &lt;math.h&gt;
 
-#include &lt;limits.h&gt;
+// #include &lt;limits.h&gt;
 
-#include &lt;tf/tf.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-#include &lt;tf2/LinearMath/Quaternion.h&gt;
+// #include &lt;tf/tf.h&gt;
+// #include &lt;tf/transform_listener.h&gt;
+// #include &lt;tf2/LinearMath/Quaternion.h&gt;
 
 #include "ukf.h"
 #include "imm_ukf_pda_tracker.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker_main.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker_main.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -1,8 +1,8 @@
-#include &lt;ros/ros.h&gt;
-#include &lt;iostream&gt;
+// #include &lt;ros/ros.h&gt;
+// #include &lt;iostream&gt;
 
-#include "autoware_msgs/CloudCluster.h"
-#include "autoware_msgs/CloudClusterArray.h"
+// #include "autoware_msgs/CloudCluster.h"
+// #include "autoware_msgs/CloudClusterArray.h"
 
 #include "imm_ukf_pda_tracker.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -1,17 +1,17 @@
 #include "visualize_cloud_cluster.h"
 
-#include &lt;ros/ros.h&gt;
-#include &lt;std_msgs/Header.h&gt;
+// #include &lt;ros/ros.h&gt;
+// #include &lt;std_msgs/Header.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
 
 
-#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
-#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
+// #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
+// #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 
-#include &lt;pcl/io/io.h&gt;
+// #include &lt;pcl/io/io.h&gt;
 
-#include &lt;vector&gt;
+// #include &lt;vector&gt;
 
 
 using namespace std;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster_main.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster_main.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -1,9 +1,9 @@
-#include &lt;ros/ros.h&gt;
-#include &lt;iostream&gt;
+// #include &lt;ros/ros.h&gt;
+// #include &lt;iostream&gt;
 #include "visualize_cloud_cluster.h"
 
-#include "autoware_msgs/CloudCluster.h"
-#include "autoware_msgs/CloudClusterArray.h"
+// #include "autoware_msgs/CloudCluster.h"
+// #include "autoware_msgs/CloudClusterArray.h"
 
 int main(int argc, char **argv)
 {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="873a2626967fd9c85847cf3aec00ec5fb4444728" author="cirpue49">
		<msg>Remove 'using namespace'</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" added_lines="3" deleted_lines="3">
				<diff>@@ -15,9 +15,9 @@
 #include "autoware_msgs/CloudClusterArray.h"
 
 
-using namespace std;
-using namespace pcl;
-using namespace Eigen;
+// using namespace std;
+// using namespace pcl;
+// using namespace Eigen;
 
 class VisualizeCloudCluster
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" added_lines="6" deleted_lines="5">
				<diff>@@ -5,6 +5,7 @@
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
 
+// #include &lt;string&gt;
 
 // #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 // #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
@@ -14,9 +15,9 @@
 // #include &lt;vector&gt;
 
 
-using namespace std;
-using namespace pcl;
-using namespace Eigen;
+// using namespace std;
+// using namespace pcl;
+// using namespace Eigen;
 
 VisualizeCloudCluster::VisualizeCloudCluster()
 {
@@ -48,7 +49,7 @@ void VisualizeCloudCluster::getJskBB(autoware_msgs::CloudClusterArray input,
 		jsk_recognition_msgs::BoundingBox bb;
 		bb = input.clusters[i].bounding_box;
 		bb.header = input.header;
-		string label = input.clusters[i].label;
+		std::string label = input.clusters[i].label;
 		// cout &lt;&lt; label &lt;&lt; endl;
 		// bb.label = label;
 		// ? jsk bb, how to find appropriate color
@@ -73,7 +74,7 @@ void VisualizeCloudCluster::visArrows(autoware_msgs::CloudClusterArray input)
 	{
 		visualization_msgs::Marker arrows;
 		arrows.lifetime = ros::Duration(0.1);
-		string label = input.clusters[i].label;
+		std::string label = input.clusters[i].label;
 
 		if(label == "None" || label == "Initialized" || label == "Lost" || label == "Static") 
 		{
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="14287588e0d6624d654f16bb55ec157969e20eec" author="Yuma">
		<msg>Fix velocity planning at end of waypoint</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" added_lines="13" deleted_lines="2">
				<diff>@@ -40,6 +40,7 @@ PurePursuit::PurePursuit()
   , next_waypoint_number_(-1)
   , lookahead_distance_(0)
   , current_linear_velocity_(0)
+  , minimum_lookahead_distance_(6)
 {
 }
 
@@ -239,7 +240,17 @@ bool PurePursuit::canGetCurvature(double *output_kappa)
     ROS_INFO("lost next waypoint");
     return false;
   }
-
+  // check whether curvature is valid or not
+  bool is_valid_curve = false;
+  for(const auto&amp; el : current_waypoints_)
+  {
+    if(getPlaneDistance(el.pose.pose.position, current_pose_.position) &gt; minimum_lookahead_distance_)
+    {
+      is_valid_curve = true;
+      break;
+    }
+  }
+  if(!is_valid_curve)return false;
   // if is_linear_interpolation_ is false or next waypoint is first or last
   if (!is_linear_interpolation_ || next_waypoint_number_ == 0 ||
       next_waypoint_number_ == (static_cast&lt;int&gt;(current_waypoints_.size() - 1)))
@@ -264,4 +275,4 @@ bool PurePursuit::canGetCurvature(double *output_kappa)
   return true;
 }
 
-}  // waypoint_follower
\ No newline at end of file
+}  // waypoint_follower
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" added_lines="9" deleted_lines="0">
				<diff>@@ -53,6 +53,10 @@ public:
   {
     lookahead_distance_ = ld;
   }
+  void setMinimumLookaheadDistance(const double &amp;minld)
+  {
+    minimum_lookahead_distance_ = minld;
+  }
   void setCurrentVelocity(const double &amp;cur_vel)
   {
     current_linear_velocity_ = cur_vel;
@@ -87,6 +91,10 @@ public:
   {
     return lookahead_distance_;
   }
+  double getMinimumLookaheadDistance() const
+  {
+    return minimum_lookahead_distance_;
+  }
   // processing
   bool canGetCurvature(double *output_kappa);
 
@@ -100,6 +108,7 @@ private:
   int next_waypoint_number_;
   geometry_msgs::Point next_target_position_;
   double lookahead_distance_;
+  double minimum_lookahead_distance_;
   geometry_msgs::Pose current_pose_;
   double current_linear_velocity_;
   std::vector&lt;autoware_msgs::waypoint&gt; current_waypoints_;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -100,6 +100,7 @@ void PurePursuitNode::run()
     }
 
     pp_.setLookaheadDistance(computeLookaheadDistance());
+    pp_.setMinimumLookaheadDistance(minimum_lookahead_distance_);
 
     double kappa = 0;
     bool can_get_curvature = pp_.canGetCurvature(&amp;kappa);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1aec712931474ced1e558c81bba553a843b7dd40" author="Abraham Monrroy">
		<msg>Fix/cmake cleanup (#1156)

* Initial Cleanup

* fixed also for indigo

* kf cjeck

* Fix road wizard

* Added travis ci

* Trigger CI

* Fixes to cv_tracker and lidar_tracker cmake

* Fix kitti player dependencies

* Removed unnecessary dependencies

* messages fixing for can

* Update build script travis

* Travis Path

* Travis Paths fix

* Travis test

* Eigen checks

* removed unnecessary dependencies

* Eigen Detection

* Job number reduced

* Eigen3 more fixes

* More Eigen3

* Even more Eigen

* find package cmake modules included

* More fixes to cmake modules

* Removed non ros dependency

* Enable industrial_ci for indidog and kinetic

* Wrong install command

* fix rviz_plugin install

* FastVirtualScan fix

* Fix Qt5 Fastvirtualscan

* Fixed qt5 system dependencies for rosdep

* NDT TKU Fix catkin not pacakged

* Fixes from industrial_ci</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lib\image\kf\src\kf.cpp" new_path="ros\src\computing\perception\detection\lib\image\kf\src\kf_lib.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -958,7 +958,7 @@ void init_params()
 
 int kf_main(int argc, char* argv[])
 {
-	ros::init(argc, argv, "kf");
+	ros::init(argc, argv, "kf_lib");
 	ros::NodeHandle n;
 	ros::NodeHandle private_nh("~");
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\cmake\FindTinyXML.cmake" new_path="" added_lines="0" deleted_lines="74">
				<diff>@@ -1,74 +0,0 @@
-##################################################################################################
-# 
-# CMake script for finding TinyXML.
-# 
-# Input variables:
-# 
-# - TinyXML_ROOT_DIR (optional): When specified, header files and libraries will be searched for in
-#     ${TinyXML_ROOT_DIR}/include
-#     ${TinyXML_ROOT_DIR}/libs
-#   respectively, and the default CMake search order will be ignored. When unspecified, the default
-#   CMake search order is used.
-#   This variable can be specified either as a CMake or environment variable. If both are set,
-#   preference is given to the CMake variable.
-#   Use this variable for finding packages installed in a nonstandard location, or for enforcing
-#   that one of multiple package installations is picked up.
-# 
-# 
-# Cache variables (not intended to be used in CMakeLists.txt files)
-# 
-# - TinyXML_INCLUDE_DIR: Absolute path to package headers.
-# - TinyXML_LIBRARY: Absolute path to library.
-# 
-# 
-# Output variables:
-# 
-# - TinyXML_FOUND: Boolean that indicates if the package was found
-# - TinyXML_INCLUDE_DIRS: Paths to the necessary header files
-# - TinyXML_LIBRARIES: Package libraries
-# 
-# 
-# Example usage:
-# 
-#  find_package(TinyXML)
-#  if(NOT TinyXML_FOUND)
-#    # Error handling
-#  endif()
-#  ...
-#  include_directories(${TinyXML_INCLUDE_DIRS} ...)
-#  ...
-#  target_link_libraries(my_target ${TinyXML_LIBRARIES})
-# 
-##################################################################################################
-
-# Get package location hint from environment variable (if any)
-if(NOT TinyXML_ROOT_DIR AND DEFINED ENV{TinyXML_ROOT_DIR})
-  set(TinyXML_ROOT_DIR "$ENV{TinyXML_ROOT_DIR}" CACHE PATH
-      "TinyXML base directory location (optional, used for nonstandard installation paths)")
-endif()
-
-# Search path for nonstandard package locations
-if(TinyXML_ROOT_DIR)
-  set(TinyXML_INCLUDE_PATH PATHS "${TinyXML_ROOT_DIR}/include" NO_DEFAULT_PATH)
-  set(TinyXML_LIBRARY_PATH PATHS "${TinyXML_ROOT_DIR}/lib"     NO_DEFAULT_PATH)
-endif()
-
-# Find headers and libraries
-find_path(TinyXML_INCLUDE_DIR NAMES tinyxml.h PATH_SUFFIXES "tinyxml" ${TinyXML_INCLUDE_PATH})
-find_library(TinyXML_LIBRARY  NAMES tinyxml   PATH_SUFFIXES "tinyxml" ${TinyXML_LIBRARY_PATH})
-
-mark_as_advanced(TinyXML_INCLUDE_DIR
-                 TinyXML_LIBRARY)
-
-# Output variables generation
-include(FindPackageHandleStandardArgs)
-find_package_handle_standard_args(TinyXML DEFAULT_MSG TinyXML_LIBRARY
-                                                      TinyXML_INCLUDE_DIR)
-
-set(TinyXML_FOUND ${TINYXML_FOUND}) # Enforce case-correctness: Set appropriately cased variable...
-unset(TINYXML_FOUND) # ...and unset uppercase variable generated by find_package_handle_standard_args
-
-if(TinyXML_FOUND)
-  set(TinyXML_INCLUDE_DIRS ${TinyXML_INCLUDE_DIR})
-  set(TinyXML_LIBRARIES ${TinyXML_LIBRARY})
-endif()
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\can\packages\kvaser\nodes\can_converter\can_converter.cpp" new_path="ros\src\sensing\drivers\can\packages\kvaser\nodes\can_converter\can_converter.cpp" added_lines="3" deleted_lines="4">
				<diff>@@ -1,9 +1,8 @@
 #include &lt;ros/ros.h&gt;
-#include "kvaser/CANPacket.h"
+#include "autoware_msgs/CANPacket.h"
 
 
-
-void chatterCallback(const kvaser::CANPacket::ConstPtr&amp; msg)
+void chatterCallback(const autoware_msgs::CANPacket::ConstPtr&amp; msg)
 {
   unsigned short w;
   static int enc_sum;
@@ -82,7 +81,7 @@ void chatterCallback(const kvaser::CANPacket::ConstPtr&amp; msg)
 
 
 int main (int argc, char *argv[]){
-  kvaser::CANPacket candat;
+  autoware_msgs::CANPacket candat;
 
   ros::init(argc, argv, "can_converter");
   ros::NodeHandle n;
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\can\packages\kvaser\nodes\can_draw\can_draw.cpp" new_path="ros\src\sensing\drivers\can\packages\kvaser\nodes\can_draw\can_draw.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -1,5 +1,5 @@
 #include &lt;ros/ros.h&gt;
-#include "kvaser/CANPacket.h"
+#include "autoware_msgs/CANPacket.h"
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
@@ -7,7 +7,7 @@
 ros::Publisher pub;
 double g_steer,g_speed;
 
-void chatterCallback(const kvaser::CANPacket::ConstPtr&amp; msg)
+void chatterCallback(const autoware_msgs::CANPacket::ConstPtr&amp; msg)
 {
   unsigned short w;
   static int enc_sum;
@@ -85,7 +85,7 @@ void chatterCallback(const kvaser::CANPacket::ConstPtr&amp; msg)
 
 
 int main (int argc, char *argv[]){
-  kvaser::CANPacket candat;
+  autoware_msgs::CANPacket candat;
 
   ros::init(argc, argv, "can_draw");
   ros::NodeHandle n;
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\can\packages\kvaser\nodes\can_listener\can_listener.cpp" new_path="ros\src\sensing\drivers\can\packages\kvaser\nodes\can_listener\can_listener.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -1,5 +1,5 @@
 /*
-**                Copyright 2012 by Kvaser AB, Mlndal, Sweden
+**                Copyright 2012 by Kvaser AB, M�lndal, Sweden
 **                        http://www.kvaser.com
 **
 ** This software is dual licensed under the following two licenses:
@@ -62,7 +62,7 @@
 #include &lt;unistd.h&gt;
 #include &lt;time.h&gt;
 #include &lt;ros/ros.h&gt;
-#include "kvaser/CANPacket.h"
+#include "autoware_msgs/CANPacket.h"
 
 int i = 0;
 unsigned char willExit = 0;
@@ -94,12 +94,12 @@ int main (int argc, char *argv[])
   int channel = 0;
   int bitrate = BAUD_500K;
   int j;
-  kvaser::CANPacket candat;
+	autoware_msgs::CANPacket candat;
 
   ros::init(argc, argv, "can_listener");
   ros::NodeHandle n;
  
-  ros::Publisher can_pub = n.advertise&lt;kvaser::CANPacket&gt;("can_raw", 10);
+  ros::Publisher can_pub = n.advertise&lt;autoware_msgs::CANPacket&gt;("can_raw", 10);
 
   errno = 0;
   if (argc != 2 || (channel = atoi(argv[1]), errno) != 0) {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d2244676f106df6137814a65149470c9cd30e21b" author="Yuma">
		<msg>Reflect waypoints height updown</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" added_lines="11" deleted_lines="4">
				<diff>@@ -148,15 +148,18 @@ void WaypointFilter::resampleLaneWaypoint(const double resample_interval,
       wp.change_flag = lane-&gt;waypoints.back().change_flag;
       const std::vector&lt;double&gt; nvec = {
           curve_point[1].x - wp.pose.pose.position.x,
-          curve_point[1].y - wp.pose.pose.position.y};
+          curve_point[1].y - wp.pose.pose.position.y,
+          curve_point[1].z - wp.pose.pose.position.z};
       double dist = sqrt(calcSquareSum(nvec[0], nvec[1]));
       const tf::Vector3 resample_vec(resample_interval_ * nvec[0] / dist,
-                                     resample_interval_ * nvec[1] / dist, 0.0);
+                                     resample_interval_ * nvec[1] / dist,
+                                     resample_interval_ * nvec[2] / dist);
       for (; dist &gt; resample_interval_; dist -= resample_interval_) {
         if (lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())
           break;
         wp.pose.pose.position.x += resample_vec.x();
         wp.pose.pose.position.y += resample_vec.y();
+        wp.pose.pose.position.z += resample_vec.z();
         lane-&gt;waypoints.push_back(wp);
         curve_radius-&gt;push_back(r_inf_);
       }
@@ -182,8 +185,11 @@ void WaypointFilter::resampleLaneWaypoint(const double resample_interval,
       autoware_msgs::waypoint wp;
       wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
       wp.change_flag = lane-&gt;waypoints.back().change_flag;
-      for (double dist = radius * fabs(theta); dist &gt; resample_interval_;
-           dist -= resample_interval_) {
+      double dist = radius * fabs(theta);
+      double dz_nextpt =
+          curve_point[1].z -lane-&gt;waypoints.back().pose.pose.position.z;
+      const double resample_dz = resample_interval_ * dz_nextpt / dist;
+      for (; dist &gt; resample_interval_; dist -= resample_interval_) {
         if (lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())
           break;
         const int sign = (theta &gt; 0.0) ? (1) : (-1);
@@ -191,6 +197,7 @@ void WaypointFilter::resampleLaneWaypoint(const double resample_interval,
         const double yaw = fmod(t + sign * M_PI / 2.0, 2 * M_PI);
         wp.pose.pose.position.x = cx + radius * cos(t);
         wp.pose.pose.position.y = cy + radius * sin(t);
+        wp.pose.pose.position.z += resample_dz;
         wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
         lane-&gt;waypoints.push_back(wp);
         curve_radius-&gt;push_back(threshold_radius);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="64c61e2df09e2c30ac798ab236957527b45de122" author="Yuma">
		<msg>Ignore space character of waypoints.csv</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="8" deleted_lines="1">
				<diff>@@ -342,7 +342,14 @@ void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns) {
   std::istringstream ss(line);
   std::string column;
   while (std::getline(ss, column, ',')) {
-    columns-&gt;push_back(column);
+    while (1) {
+      auto res = std::find(column.begin(), column.end(), ' ');
+      if (res == column.end())
+        break;
+      column.erase(res);
+    }
+    if (!column.empty())
+      columns-&gt;push_back(column);
   }
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a6b0654feb2d2cd67f721821ea592a5e492e91e2" author="Yuma">
		<msg>Revert "Clang-format"

This reverts commit fb284523027c0df1ec513b09c6426c9d235c9f12.</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" added_lines="268" deleted_lines="287">
				<diff>@@ -6,8 +6,7 @@
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions are met:
  *
- *  * Redistributions of source code must retain the above copyright notice,
- this
+ *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
  *
  *  * Redistributions in binary form must reproduce the above copyright notice,
@@ -20,331 +19,313 @@
  *
  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- ARE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- USE
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #include "waypoint_filter.h"
 
-namespace waypoint_maker {
+namespace waypoint_maker
+{
 
-inline double kmph2mps(double velocity_kmph) {
-  return (velocity_kmph * 1000) / (60 * 60);
-}
-inline double mps2kmph(double velocity_mps) {
-  return (velocity_mps * 60 * 60) / 1000;
-}
+  inline double kmph2mps(double velocity_kmph)
+  {
+    return (velocity_kmph * 1000) / (60 * 60);
+  }
+  inline double mps2kmph(double velocity_mps)
+  {
+    return (velocity_mps * 60 * 60) / 1000;
+  }
 
-WaypointFilter::WaypointFilter() : private_nh_("~") {}
+  WaypointFilter::WaypointFilter():private_nh_("~")
+  {
+  }
 
-WaypointFilter::~WaypointFilter() {}
+  WaypointFilter::~WaypointFilter(){}
 
-void WaypointFilter::initParameter(
-    const autoware_msgs::ConfigWaypointLoader::ConstPtr &amp;conf) {
-  velocity_max_ = kmph2mps(conf-&gt;velocity_max);
-  velocity_min_ = kmph2mps(conf-&gt;velocity_min);
-  accel_limit_ = conf-&gt;accel_limit;
-  decel_limit_ = conf-&gt;decel_limit;
-  r_th_ = conf-&gt;radius_thresh;
-  r_min_ = conf-&gt;radius_min;
-  lookup_crv_width_ = 5;
-  resample_mode_ = conf-&gt;resample_mode;
-  resample_interval_ = conf-&gt;resample_interval;
-  velocity_offset_ = conf-&gt;velocity_offset;
-  r_inf_ = 10 * r_th_;
-}
+  void WaypointFilter::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
+  {
+    velocity_max_ = kmph2mps(conf-&gt;velocity_max);
+    velocity_min_ = kmph2mps(conf-&gt;velocity_min);
+    accel_limit_ = conf-&gt;accel_limit;
+    decel_limit_ = conf-&gt;decel_limit;
+    r_th_ = conf-&gt;radius_thresh;
+    r_min_ = conf-&gt;radius_min;
+    lookup_crv_width_ = 5;
+    resample_mode_ = conf-&gt;resample_mode;
+    resample_interval_ = conf-&gt;resample_interval;
+    velocity_offset_ = conf-&gt;velocity_offset;
+    r_inf_ = 10 * r_th_;
+  }
 
-void WaypointFilter::filterLaneWaypoint(autoware_msgs::lane *lane) {
-  std::vector&lt;double&gt; curve_radius;
-  std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt;&gt;
-      curve_list;
+  void WaypointFilter::filterLaneWaypoint(autoware_msgs::lane *lane)
+  {
+    std::vector&lt;double&gt; curve_radius;
+    std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt; curve_list;
 
-  if (resample_mode_)
-    resampleLaneWaypoint(resample_interval_, lane, &amp;curve_radius);
-  else
-    getCurveAll(*lane, &amp;curve_radius);
-  const std::vector&lt;double&gt; vel_param = calcVelParamFromVmax(velocity_max_);
-  createCurveList(curve_radius, &amp;curve_list);
-  if (vel_param.size() &lt; 2) {
-    ROS_ERROR("velocity parameter is invalid");
-    return;
-  }
-  // set velocity_max for all_point
-  for (auto &amp;el : lane-&gt;waypoints)
-    el.twist.twist.linear.x = velocity_max_;
-  // set curve_velocity on curve begining
-  for (const auto &amp;el : curve_list) {
-    const unsigned long start_idx =
-        (el.first &gt; velocity_offset_) ? (el.first - velocity_offset_) : 0;
-    const unsigned long end_idx = (el.second.first &gt; velocity_offset_)
-                                      ? (el.second.first - velocity_offset_)
-                                      : 0;
-    const double radius = el.second.second;
-    const double vmax = velocity_max_;
-    const double vmin = vel_param[0] * radius + vel_param[1];
-    for (unsigned long idx = start_idx; idx &lt;= end_idx; idx++) {
-      if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
-        continue;
+    if(resample_mode_)
+      resampleLaneWaypoint(resample_interval_, lane, &amp;curve_radius);
+    else
+      getCurveAll(*lane, &amp;curve_radius);
+    const std::vector&lt;double&gt; vel_param = calcVelParamFromVmax(velocity_max_);
+    createCurveList(curve_radius, &amp;curve_list);
+    if(vel_param.size() &lt; 2)
+    {
+      ROS_ERROR("velocity parameter is invalid");
+      return;
+    }
+    //set velocity_max for all_point
+    for(auto&amp; el : lane-&gt;waypoints)
+      el.twist.twist.linear.x = velocity_max_;
+    //set curve_velocity on curve begining
+    for(const auto&amp; el : curve_list)
+    {
+      const unsigned long start_idx = (el.first &gt; velocity_offset_) ? (el.first - velocity_offset_) : 0;
+      const unsigned long end_idx = (el.second.first &gt; velocity_offset_) ? (el.second.first - velocity_offset_) : 0;
+      const double radius = el.second.second;
+      const double vmax = velocity_max_;
+      const double vmin = vel_param[0] * radius + vel_param[1];
+      for(unsigned long idx = start_idx; idx &lt;= end_idx ; idx++)
+      {
+        if(lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)continue;
+        lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
+      }
+      limitAccelDecel(vmax, vmin, start_idx, lane);
+      limitAccelDecel(vmax, vmin, end_idx, lane);
+    }
+    unsigned long end_id[2] = {0, lane-&gt;waypoints.size() - 1};
+    for(int i = 0; i &lt; 2; i++)
+    {
+      const unsigned long idx = end_id[i];
+      const double vmax = velocity_max_;
+      const double vmin = (i == 0) ? velocity_min_ : 0.0;
+      if(lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)continue;
       lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
+      limitAccelDecel(vmax, vmin, idx, lane);
     }
-    limitAccelDecel(vmax, vmin, start_idx, lane);
-    limitAccelDecel(vmax, vmin, end_idx, lane);
   }
-  unsigned long end_id[2] = {0, lane-&gt;waypoints.size() - 1};
-  for (int i = 0; i &lt; 2; i++) {
-    const unsigned long idx = end_id[i];
-    const double vmax = velocity_max_;
-    const double vmin = (i == 0) ? velocity_min_ : 0.0;
-    if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
-      continue;
-    lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
-    limitAccelDecel(vmax, vmin, idx, lane);
-  }
-}
 
-void WaypointFilter::resampleLaneWaypoint(const double resample_interval,
-                                          autoware_msgs::lane *lane,
-                                          std::vector&lt;double&gt; *curve_radius) {
-  if (lane-&gt;waypoints.empty())
-    return;
-  autoware_msgs::lane original_lane = *lane;
-  lane-&gt;waypoints.clear();
-  lane-&gt;waypoints.push_back(original_lane.waypoints[0]);
-  curve_radius-&gt;clear();
-  curve_radius-&gt;push_back(r_inf_);
-  double original_len = calcPathLength(original_lane);
-  unsigned long waypoints_size = ceil(1.5 * original_len / resample_interval_);
-  lane-&gt;waypoints.reserve(waypoints_size);
-  curve_radius-&gt;reserve(waypoints_size);
+  void WaypointFilter::resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane *lane, std::vector&lt;double&gt; *curve_radius)
+  {
+    if(lane-&gt;waypoints.empty())return;
+    autoware_msgs::lane original_lane = *lane;
+    lane-&gt;waypoints.clear();
+    lane-&gt;waypoints.push_back(original_lane.waypoints[0]);
+    curve_radius-&gt;clear();
+    curve_radius-&gt;push_back(r_inf_);
+    double original_len = calcPathLength(original_lane);
+    unsigned long waypoints_size = ceil(1.5 * original_len / resample_interval_);
+    lane-&gt;waypoints.reserve(waypoints_size);
+    curve_radius-&gt;reserve(waypoints_size);
 
-  const unsigned int n = (lookup_crv_width_ - 1) / 2;
-  for (unsigned long i = 1; i &lt; original_lane.waypoints.size(); i++) {
-    std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
-    curve_point[0] =
-        (lane-&gt;waypoints.size() &lt; n)
-            ? lane-&gt;waypoints[0].pose.pose.position
-            : lane-&gt;waypoints[lane-&gt;waypoints.size() - n].pose.pose.position;
-    curve_point[1] = original_lane.waypoints[i].pose.pose.position;
-    curve_point[2] = (i &gt;= original_lane.waypoints.size() - n)
-                         ? original_lane.waypoints.back().pose.pose.position
-                         : original_lane.waypoints[i + n].pose.pose.position;
-    const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
-    // if going straight
-    if (curve_param.empty()) {
-      const std::vector&lt;double&gt; vec = {curve_point[2].x - curve_point[0].x,
-                                       curve_point[2].y - curve_point[0].y};
-      autoware_msgs::waypoint wp;
-      wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
-      wp.pose.pose.orientation =
-          tf::createQuaternionMsgFromYaw(atan2(vec[1], vec[0]));
-      wp.change_flag = lane-&gt;waypoints.back().change_flag;
-      const std::vector&lt;double&gt; nvec = {
-          curve_point[1].x - wp.pose.pose.position.x,
-          curve_point[1].y - wp.pose.pose.position.y,
-          curve_point[1].z - wp.pose.pose.position.z};
-      double dist = sqrt(calcSquareSum(nvec[0], nvec[1]));
-      const tf::Vector3 resample_vec(resample_interval_ * nvec[0] / dist,
-                                     resample_interval_ * nvec[1] / dist,
-                                     resample_interval_ * nvec[2] / dist);
-      for (; dist &gt; resample_interval_; dist -= resample_interval_) {
-        if (lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())
-          break;
-        wp.pose.pose.position.x += resample_vec.x();
-        wp.pose.pose.position.y += resample_vec.y();
-        wp.pose.pose.position.z += resample_vec.z();
-        lane-&gt;waypoints.push_back(wp);
-        curve_radius-&gt;push_back(r_inf_);
+    const unsigned int n = (lookup_crv_width_ - 1) / 2;
+    for(unsigned long i = 1; i &lt; original_lane.waypoints.size(); i++)
+    {
+      std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
+      curve_point[0] = (lane-&gt;waypoints.size() &lt; n) ? lane-&gt;waypoints[0].pose.pose.position
+                                                    : lane-&gt;waypoints[lane-&gt;waypoints.size() - n].pose.pose.position;
+      curve_point[1] = original_lane.waypoints[i].pose.pose.position;
+      curve_point[2] = (i &gt;= original_lane.waypoints.size() - n) ? original_lane.waypoints.back().pose.pose.position
+                                                                : original_lane.waypoints[i + n].pose.pose.position;
+      const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
+      //if going straight
+      if(curve_param.empty())
+      {
+        const std::vector&lt;double&gt; vec = {curve_point[2].x - curve_point[0].x, curve_point[2].y - curve_point[0].y};
+        autoware_msgs::waypoint wp;
+        wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
+        wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(atan2(vec[1], vec[0]));
+        wp.change_flag = lane-&gt;waypoints.back().change_flag;
+        const std::vector&lt;double&gt; nvec = {curve_point[1].x - wp.pose.pose.position.x, curve_point[1].y - wp.pose.pose.position.y, curve_point[1].z - wp.pose.pose.position.z};
+        double dist = sqrt(calcSquareSum(nvec[0], nvec[1]));
+        const tf::Vector3 resample_vec(resample_interval_ * nvec[0] / dist, resample_interval_ * nvec[1] / dist, resample_interval_ * nvec[2] / dist);
+        for(; dist &gt; resample_interval_; dist -= resample_interval_)
+        {
+          if(lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())break;
+          wp.pose.pose.position.x += resample_vec.x();
+          wp.pose.pose.position.y += resample_vec.y();
+          wp.pose.pose.position.z += resample_vec.z();
+          lane-&gt;waypoints.push_back(wp);
+          curve_radius-&gt;push_back(r_inf_);
+        }
       }
-    }
-    // else if turnning curve
-    else {
-      const double &amp;cx = curve_param[0];
-      const double &amp;cy = curve_param[1];
-      const double &amp;radius = curve_param[2];
-      const double threshold_radius = (radius &gt; r_inf_) ? r_inf_ : radius;
+      //else if turnning curve
+      else
+      {
+        const double&amp; cx = curve_param[0];
+        const double&amp; cy = curve_param[1];
+        const double&amp; radius = curve_param[2];
+        const double threshold_radius = (radius &gt; r_inf_) ? r_inf_ : radius;
 
-      const geometry_msgs::Point &amp;p0 =
-          lane-&gt;waypoints.back().pose.pose.position;
-      const geometry_msgs::Point &amp;p1 = curve_point[1];
-      double theta = fmod(
-          atan2(p1.y - cy, p1.x - cx) - atan2(p0.y - cy, p0.x - cx), 2 * M_PI);
-      if (theta &gt; M_PI)
-        theta -= 2 * M_PI;
-      else if (theta &lt; -M_PI)
-        theta += 2 * M_PI;
-      // interport
-      double t = atan2(p0.y - cy, p0.x - cx);
-      autoware_msgs::waypoint wp;
-      wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
-      wp.change_flag = lane-&gt;waypoints.back().change_flag;
-      double dist = radius * fabs(theta);
-      double dz_nextpt =
-          curve_point[1].z -lane-&gt;waypoints.back().pose.pose.position.z;
-      const double resample_dz = resample_interval_ * dz_nextpt / dist;
-      for (; dist &gt; resample_interval_; dist -= resample_interval_) {
-        if (lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())
-          break;
-        const int sign = (theta &gt; 0.0) ? (1) : (-1);
-        t += sign * resample_interval_ / radius;
-        const double yaw = fmod(t + sign * M_PI / 2.0, 2 * M_PI);
-        wp.pose.pose.position.x = cx + radius * cos(t);
-        wp.pose.pose.position.y = cy + radius * sin(t);
-        wp.pose.pose.position.z += resample_dz;
-        wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
-        lane-&gt;waypoints.push_back(wp);
-        curve_radius-&gt;push_back(threshold_radius);
+        const geometry_msgs::Point&amp; p0 = lane-&gt;waypoints.back().pose.pose.position;
+        const geometry_msgs::Point&amp; p1 = curve_point[1];
+        double theta = fmod(atan2(p1.y - cy, p1.x - cx) - atan2(p0.y - cy, p0.x - cx), 2 * M_PI);
+        if(theta &gt; M_PI)theta -= 2 * M_PI;
+        else if(theta &lt; -M_PI)theta += 2 * M_PI;
+        //interport
+        double t = atan2(p0.y - cy, p0.x - cx);
+        autoware_msgs::waypoint wp;
+        wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
+        wp.change_flag = lane-&gt;waypoints.back().change_flag;
+        double dist = radius * fabs(theta);
+        double dz_nextpt = curve_point[1].z - lane-&gt;waypoints.back().pose.pose.position.z;
+        const double resample_dz = resample_interval_ * dz_nextpt / dist;
+        for(; dist &gt; resample_interval_; dist -= resample_interval_)
+        {
+          if(lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())break;
+          const int sign = (theta &gt; 0.0) ? (1) : (-1);
+          t += sign * resample_interval_ / radius;
+          const double yaw = fmod(t + sign * M_PI / 2.0, 2 * M_PI);
+          wp.pose.pose.position.x = cx + radius * cos(t);
+          wp.pose.pose.position.y = cy + radius * sin(t);
+          wp.pose.pose.position.z += resample_dz;
+          wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
+          lane-&gt;waypoints.push_back(wp);
+          curve_radius-&gt;push_back(threshold_radius);
+        }
       }
+      lane-&gt;waypoints.back().wpstate = original_lane.waypoints[i].wpstate;
+      lane-&gt;waypoints.back().change_flag = original_lane.waypoints[i].change_flag;
     }
-    lane-&gt;waypoints.back().wpstate = original_lane.waypoints[i].wpstate;
-    lane-&gt;waypoints.back().change_flag = original_lane.waypoints[i].change_flag;
+    lane-&gt;waypoints.back().wpstate = original_lane.waypoints.back().wpstate;
+    lane-&gt;waypoints.back().change_flag = original_lane.waypoints.back().change_flag;
   }
-  lane-&gt;waypoints.back().wpstate = original_lane.waypoints.back().wpstate;
-  lane-&gt;waypoints.back().change_flag =
-      original_lane.waypoints.back().change_flag;
-}
 
-void WaypointFilter::getCurveAll(const autoware_msgs::lane &amp;lane,
-                                 std::vector&lt;double&gt; *curve_radius) {
-  if (lane.waypoints.empty())
-    return;
-  curve_radius-&gt;resize(lane.waypoints.size());
-  curve_radius-&gt;at(0) = curve_radius-&gt;back() = r_inf_;
 
-  const unsigned int n = (lookup_crv_width_ - 1) / 2;
-  for (unsigned long i = 1; i &lt; lane.waypoints.size() - 1; i++) {
-    std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
-    curve_point[0] = (i &lt; n) ? lane.waypoints[0].pose.pose.position
-                             : lane.waypoints[i - n].pose.pose.position;
-    curve_point[1] = lane.waypoints[i].pose.pose.position;
-    curve_point[2] = (i &gt;= lane.waypoints.size() - n)
-                         ? lane.waypoints.back().pose.pose.position
-                         : lane.waypoints[i + n].pose.pose.position;
-    const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
-    // if going straight
-    if (curve_param.empty()) {
-      curve_radius-&gt;at(i) = r_inf_;
-    }
-    // else if turnning curve
-    else {
-      const double &amp;radius = curve_param[2];
-      curve_radius-&gt;at(i) = (radius &gt; r_inf_) ? r_inf_ : radius;
-    }
-  }
-}
 
-const std::vector&lt;double&gt;
-WaypointFilter::calcVelParamFromVmax(const double vmax) const {
-  std::vector&lt;double&gt; param(2, 0.0);
-  param[0] = (vmax - velocity_min_) / (r_th_ - r_min_); // bias
-  param[1] = vmax - param[0] * r_th_;                   // vel_intersept
-  return param;
-}
+  void WaypointFilter::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt; *curve_radius)
+  {
+    if(lane.waypoints.empty())return;
+    curve_radius-&gt;resize(lane.waypoints.size());
+    curve_radius-&gt;at(0) = curve_radius-&gt;back() = r_inf_;
 
-void WaypointFilter::createCurveList(
-    const std::vector&lt;double&gt; &amp;curve_radius,
-    std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt;&gt;
-        *curve_list) {
-  unsigned long index = 0;
-  bool on_curve = false;
-  double radius_localmin = DBL_MAX;
-  for (unsigned long i = 1; i &lt; curve_radius.size(); i++) {
-    if (!on_curve &amp;&amp; curve_radius[i] &lt;= r_th_ &amp;&amp; curve_radius[i - 1] &gt; r_th_) {
-      index = i;
-      on_curve = true;
-    } else if (on_curve &amp;&amp; curve_radius[i - 1] &lt;= r_th_ &amp;&amp;
-               curve_radius[i] &gt; r_th_) {
-      on_curve = false;
-      if (radius_localmin &lt; r_min_)
-        radius_localmin = r_min_;
-      (*curve_list)[index] = std::make_pair(i, radius_localmin);
-      radius_localmin = DBL_MAX;
+    const unsigned int n = (lookup_crv_width_ - 1) / 2;
+    for(unsigned long i = 1; i &lt; lane.waypoints.size() - 1; i++)
+    {
+      std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
+      curve_point[0] = (i &lt; n) ? lane.waypoints[0].pose.pose.position
+                                : lane.waypoints[i - n].pose.pose.position;
+      curve_point[1] = lane.waypoints[i].pose.pose.position;
+      curve_point[2] = (i &gt;= lane.waypoints.size() - n) ? lane.waypoints.back().pose.pose.position
+                                                          : lane.waypoints[i + n].pose.pose.position;
+      const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
+      //if going straight
+      if(curve_param.empty())
+      {
+        curve_radius-&gt;at(i) = r_inf_;
+      }
+      //else if turnning curve
+      else
+      {
+        const double&amp; radius = curve_param[2];
+        curve_radius-&gt;at(i) = (radius &gt; r_inf_) ? r_inf_ : radius;
+      }
     }
-    if (!on_curve)
-      continue;
-    if (radius_localmin &gt; curve_radius[i])
-      radius_localmin = curve_radius[i];
   }
-}
 
-void WaypointFilter::limitAccelDecel(const double vmax, const double vmin_local,
-                                     const unsigned long idx,
-                                     autoware_msgs::lane *lane) {
-  double v = vmin_local;
-  for (unsigned long i = 1;; i++) {
-    v = sqrt(2 * accel_limit_ * resample_interval_ + v * v);
-    if (i &gt; lane-&gt;waypoints.size() - idx - 1 || v &gt; vmax)
-      break;
-    if (lane-&gt;waypoints[idx + i].twist.twist.linear.x &lt; v)
-      break;
-    lane-&gt;waypoints[idx + i].twist.twist.linear.x = v;
+  const std::vector&lt;double&gt; WaypointFilter::calcVelParamFromVmax(const double vmax)const
+  {
+    std::vector&lt;double&gt; param(2, 0.0);
+    param[0] = (vmax - velocity_min_) / (r_th_ - r_min_);//bias
+    param[1] = vmax - param[0] * r_th_;//vel_intersept
+    return param;
   }
 
-  v = vmin_local;
-  for (unsigned long i = 1;; i++) {
-    v = sqrt(2 * decel_limit_ * resample_interval_ + v * v);
-    if (i &gt; idx || v &gt; vmax)
-      break;
-    if (lane-&gt;waypoints[idx - i].twist.twist.linear.x &lt; v)
-      break;
-    lane-&gt;waypoints[idx - i].twist.twist.linear.x = v;
+  void WaypointFilter::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius, std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list)
+  {
+    unsigned long index = 0;
+    bool on_curve = false;
+    double radius_localmin = DBL_MAX;
+    for(unsigned long i = 1; i &lt; curve_radius.size(); i++)
+    {
+      if(!on_curve &amp;&amp; curve_radius[i] &lt;= r_th_ &amp;&amp; curve_radius[i -1] &gt; r_th_)
+      {
+        index = i;
+        on_curve = true;
+      }
+      else if(on_curve &amp;&amp; curve_radius[i - 1] &lt;= r_th_ &amp;&amp; curve_radius[i] &gt; r_th_)
+      {
+        on_curve = false;
+        if(radius_localmin &lt; r_min_)radius_localmin = r_min_;
+        (*curve_list)[index] = std::make_pair(i, radius_localmin);
+        radius_localmin = DBL_MAX;
+      }
+      if(!on_curve)continue;
+      if(radius_localmin &gt; curve_radius[i])radius_localmin = curve_radius[i];
+    }
   }
-}
 
-// get 3 parameter of curve, [center_x, center_y, radius]
-const std::vector&lt;double&gt; WaypointFilter::getCurveOnce(
-    const std::vector&lt;geometry_msgs::Point&gt; &amp;point) const {
-  std::vector&lt;double&gt; curve_param(3, 0.0);
-  tf::Vector3 vec[2];
-  geometry_msgs::Point pt_m[2];
-  double tan_pt_m[2];
-  for (unsigned int i = 0; i &lt; 2; i++) {
-    const geometry_msgs::Point &amp;p0 = point[i];
-    const geometry_msgs::Point &amp;p1 = point[i + 1];
-    pt_m[i].x = (p0.x + p1.x) / 2.0;
-    pt_m[i].y = (p0.y + p1.y) / 2.0;
-    vec[i] = tf::Vector3(p1.x - p0.x, p1.y - p0.y, 0.0);
-    if (fabs(vec[i].x()) &lt; 1e-8 &amp;&amp; fabs(vec[i].y()) &lt; 1e-8)
-      return std::vector&lt;double&gt;();
-    tan_pt_m[i] = tan(atan2(vec[i].y(), vec[i].x()) + M_PI / 2.0);
+  void WaypointFilter::limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx, autoware_msgs::lane *lane)
+  {
+    double v = vmin_local;
+    for(unsigned long i = 1; ; i++)
+    {
+      v = sqrt(2 * accel_limit_ * resample_interval_ + v * v);
+      if(i &gt; lane-&gt;waypoints.size() - idx - 1 || v &gt; vmax)break;
+      if(lane-&gt;waypoints[idx + i].twist.twist.linear.x &lt; v)break;
+      lane-&gt;waypoints[idx + i].twist.twist.linear.x = v;
+    }
+
+    v = vmin_local;
+    for(unsigned long i = 1; ; i++)
+    {
+      v = sqrt(2 * decel_limit_ * resample_interval_ + v * v);
+      if(i &gt; idx || v &gt; vmax)break;
+      if(lane-&gt;waypoints[idx - i].twist.twist.linear.x &lt; v)break;
+      lane-&gt;waypoints[idx - i].twist.twist.linear.x = v;
+    }
   }
-  if (fabs(tan_pt_m[1] - tan_pt_m[0]) &lt; 1e-9)
-    return std::vector&lt;double&gt;();
 
+  //get 3 parameter of curve, [center_x, center_y, radius]
+  const std::vector&lt;double&gt; WaypointFilter::getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point)const
   {
-    const geometry_msgs::Point &amp;p0 = point[0];
-    curve_param[0] = pt_m[0].y - pt_m[0].x * tan_pt_m[0] - pt_m[1].y +
-                     pt_m[1].x * tan_pt_m[1];
-    curve_param[0] /= tan_pt_m[1] - tan_pt_m[0];
-    curve_param[1] = pt_m[0].y - (pt_m[0].x - curve_param[0]) * tan_pt_m[0];
-    curve_param[2] =
-        sqrt(calcSquareSum(p0.x - curve_param[0], p0.y - curve_param[1]));
+    std::vector&lt;double&gt; curve_param(3, 0.0);
+    tf::Vector3 vec[2];
+    geometry_msgs::Point pt_m[2];
+    double tan_pt_m[2];
+    for(unsigned int i = 0; i &lt; 2; i++)
+    {
+      const geometry_msgs::Point&amp; p0 = point[i];
+      const geometry_msgs::Point&amp; p1 = point[i + 1];
+      pt_m[i].x = (p0.x + p1.x) / 2.0;
+      pt_m[i].y = (p0.y + p1.y) / 2.0;
+      vec[i] = tf::Vector3(p1.x - p0.x, p1.y - p0.y, 0.0);
+      if(fabs(vec[i].x()) &lt; 1e-8 &amp;&amp; fabs(vec[i].y()) &lt; 1e-8)return std::vector&lt;double&gt;();
+      tan_pt_m[i] = tan(atan2(vec[i].y(), vec[i].x()) + M_PI / 2.0);
+    }
+    if(fabs(tan_pt_m[1] - tan_pt_m[0]) &lt; 1e-9)return std::vector&lt;double&gt;();
+
+    {
+      const geometry_msgs::Point&amp; p0 = point[0];
+      curve_param[0] = pt_m[0].y - pt_m[0].x * tan_pt_m[0] - pt_m[1].y + pt_m[1].x * tan_pt_m[1];
+      curve_param[0] /= tan_pt_m[1] - tan_pt_m[0];
+      curve_param[1] = pt_m[0].y - (pt_m[0].x - curve_param[0]) * tan_pt_m[0];
+      curve_param[2] = sqrt(calcSquareSum(p0.x - curve_param[0], p0.y - curve_param[1]));
+    }
+    return curve_param;
   }
-  return curve_param;
-}
 
-const double WaypointFilter::calcSquareSum(const double x,
-                                           const double y) const {
-  return (x * x + y * y);
-}
+  const double WaypointFilter::calcSquareSum(const double x, const double y)const
+  {
+    return (x * x + y * y);
+  }
 
-const double
-WaypointFilter::calcPathLength(const autoware_msgs::lane &amp;lane) const {
-  double distance = 0.0;
-  for (unsigned long i = 1; i &lt; lane.waypoints.size(); i++) {
-    const geometry_msgs::Point &amp;p0 = lane.waypoints[i - 1].pose.pose.position;
-    const geometry_msgs::Point &amp;p1 = lane.waypoints[i].pose.pose.position;
-    tf::Vector3 tf0(p0.x, p0.y, 0.0);
-    tf::Vector3 tf1(p1.x, p1.y, 0.0);
-    distance += tf::tfDistance(tf0, tf1);
+  const double WaypointFilter::calcPathLength(const autoware_msgs::lane&amp; lane)const
+  {
+    double distance = 0.0;
+    for(unsigned long i = 1; i &lt; lane.waypoints.size(); i++)
+    {
+      const geometry_msgs::Point&amp; p0 = lane.waypoints[i - 1].pose.pose.position;
+      const geometry_msgs::Point&amp; p1 = lane.waypoints[i].pose.pose.position;
+      tf::Vector3 tf0(p0.x, p0.y, 0.0);
+      tf::Vector3 tf1(p1.x, p1.y, 0.0);
+      distance += tf::tfDistance(tf0, tf1);
+    }
+    return distance;
   }
-  return distance;
-}
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" added_lines="20" deleted_lines="32">
				<diff>@@ -6,8 +6,7 @@
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions are met:
  *
- *  * Redistributions of source code must retain the above copyright notice,
- this
+ *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
  *
  *  * Redistributions in binary form must reproduce the above copyright notice,
@@ -20,31 +19,30 @@
  *
  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- ARE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- USE
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #ifndef __WAYPOINT_FILTER_H__
 #define __WAYPOINT_FILTER_H__
 
-#include "autoware_msgs/lane.h"
-#include &lt;autoware_msgs/ConfigWaypointLoader.h&gt;
-#include &lt;fstream&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
+#include &lt;autoware_msgs/ConfigWaypointLoader.h&gt;
+#include &lt;fstream&gt;
 #include &lt;unordered_map&gt;
+#include "autoware_msgs/lane.h"
 
-namespace waypoint_maker {
+namespace waypoint_maker
+{
 
-class WaypointFilter {
+class WaypointFilter
+{
 private:
   ros::NodeHandle private_nh_;
   double r_th_, r_min_, r_inf_;
@@ -53,30 +51,20 @@ private:
   double accel_limit_, decel_limit_, resample_interval_;
   int velocity_offset_;
   bool resample_mode_;
-
 public:
   WaypointFilter();
   ~WaypointFilter();
-  void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr &amp;conf);
+  void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
   void filterLaneWaypoint(autoware_msgs::lane *lane);
-
 protected:
-  void resampleLaneWaypoint(const double resample_interval,
-                            autoware_msgs::lane *lane,
-                            std::vector&lt;double&gt; *curve_radius);
-  void getCurveAll(const autoware_msgs::lane &amp;lane,
-                   std::vector&lt;double&gt; *curve_radius);
-  const std::vector&lt;double&gt; calcVelParamFromVmax(const double vmax) const;
-  void createCurveList(
-      const std::vector&lt;double&gt; &amp;curve_radius,
-      std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt;&gt;
-          *curve_list);
-  void limitAccelDecel(const double vmax, const double vmin_local,
-                       const unsigned long idx, autoware_msgs::lane *lane);
-  const std::vector&lt;double&gt;
-  getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt; &amp;point) const;
-  const double calcSquareSum(const double x, const double y) const;
-  const double calcPathLength(const autoware_msgs::lane &amp;lane) const;
+  void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane *lane, std::vector&lt;double&gt; *curve_radius);
+  void getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt; *curve_radius);
+  const std::vector&lt;double&gt; calcVelParamFromVmax(const double vmax)const;
+  void createCurveList(const std::vector&lt;double&gt;&amp; curve_radius, std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list);
+  void limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx, autoware_msgs::lane *lane);
+  const std::vector&lt;double&gt; getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point)const;
+  const double calcSquareSum(const double x, const double y)const;
+  const double calcPathLength(const autoware_msgs::lane&amp; lane)const;
 };
 }
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="118" deleted_lines="118">
				<diff>@@ -6,8 +6,7 @@
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions are met:
  *
- *  * Redistributions of source code must retain the above copyright notice,
- this
+ *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
  *
  *  * Redistributions in binary form must reproduce the above copyright notice,
@@ -20,54 +19,53 @@
  *
  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- ARE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- USE
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
 #include "waypoint_loader_core.h"
 
-namespace waypoint_maker {
+namespace waypoint_maker
+{
 // Constructor
-WaypointLoaderNode::WaypointLoaderNode() : private_nh_("~") { initPubSub(); }
+WaypointLoaderNode::WaypointLoaderNode() : private_nh_("~")
+{
+  initPubSub();
+}
 
 // Destructor
-WaypointLoaderNode::~WaypointLoaderNode() {}
+WaypointLoaderNode::~WaypointLoaderNode()
+{
+}
 
-void WaypointLoaderNode::initPubSub() {
+void WaypointLoaderNode::initPubSub()
+{
   // setup publisher
-  if (disable_decision_maker_) {
-    lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/lane_waypoints_array",
-                                                        10, true);
-  } else {
-    lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(
-        "/based/lane_waypoints_array", 10, true);
+  if(disable_decision_maker_){
+	  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/lane_waypoints_array", 10, true);
+  }else{
+	  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/based/lane_waypoints_array", 10, true);
   }
-  config_sub_ = nh_.subscribe("/config/waypoint_loader", 1,
-                              &amp;WaypointLoaderNode::configCallback, this);
-  output_cmd_sub_ =
-      nh_.subscribe("/config/waypoint_loader_output", 1,
-                    &amp;WaypointLoaderNode::outputCommandCallback, this);
+  config_sub_ = nh_.subscribe("/config/waypoint_loader", 1, &amp;WaypointLoaderNode::configCallback, this);
+  output_cmd_sub_ = nh_.subscribe("/config/waypoint_loader_output", 1, &amp;WaypointLoaderNode::outputCommandCallback, this);
 }
 
-void WaypointLoaderNode::initParameter(
-    const autoware_msgs::ConfigWaypointLoader::ConstPtr &amp;conf) {
+void WaypointLoaderNode::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
+{
   // parameter settings
   disable_decision_maker_ = conf-&gt;disable_decision_maker;
   filtering_mode_ = conf-&gt;filtering_mode;
   multi_lane_csv_ = conf-&gt;multi_lane_csv;
 }
 
-void WaypointLoaderNode::configCallback(
-    const autoware_msgs::ConfigWaypointLoader::ConstPtr &amp;conf) {
+void WaypointLoaderNode::configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
+{
   filter_.initParameter(conf);
   initParameter(conf);
 
@@ -78,67 +76,65 @@ void WaypointLoaderNode::configCallback(
   output_lane_array_ = lane_array;
 }
 
-void WaypointLoaderNode::outputCommandCallback(
-    const std_msgs::Bool::ConstPtr &amp;output_cmd) {
+void WaypointLoaderNode::outputCommandCallback(const std_msgs::Bool::ConstPtr&amp; output_cmd)
+{
   std::vector&lt;std::string&gt; dst_multi_file_path = multi_file_path_;
-  for (auto &amp;el : dst_multi_file_path)
+  for(auto&amp; el : dst_multi_file_path)
     el = addFileSuffix(el, "_filtered");
   saveLaneArray(dst_multi_file_path, output_lane_array_);
 }
 
-const std::string addFileSuffix(std::string file_path, std::string suffix) {
+const std::string addFileSuffix(std::string file_path, std::string suffix)
+{
   std::string output_file_path, tmp;
   std::string directory_path, filename, extension;
 
   tmp = file_path;
   const std::string::size_type idx_slash = tmp.find_last_of("/");
-  if (idx_slash != std::string::npos)
-    tmp.erase(0, idx_slash);
+  if(idx_slash != std::string::npos)tmp.erase(0, idx_slash);
   const std::string::size_type idx_dot = tmp.find_last_of(".");
   const std::string::size_type idx_dot_allpath = file_path.find_last_of(".");
-  if (idx_dot != std::string::npos &amp;&amp; idx_dot != tmp.size() - 1)
+  if(idx_dot != std::string::npos &amp;&amp; idx_dot != tmp.size() - 1)
     file_path.erase(idx_dot_allpath, file_path.size() - 1);
   file_path += suffix + ".csv";
   return file_path;
 }
 
 void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt; &amp;paths,
-                                         autoware_msgs::LaneArray *lane_array) {
-  for (const auto &amp;el : paths) {
+                                         autoware_msgs::LaneArray *lane_array)
+{
+  for (const auto&amp; el : paths)
+  {
     autoware_msgs::lane lane;
     createLaneWaypoint(el, &amp;lane);
-    if (filtering_mode_)
+    if(filtering_mode_)
       filter_.filterLaneWaypoint(&amp;lane);
     lane_array-&gt;lanes.push_back(lane);
   }
 }
 
-void WaypointLoaderNode::saveLaneArray(
-    const std::vector&lt;std::string&gt; &amp;paths,
-    const autoware_msgs::LaneArray &amp;lane_array) {
+void WaypointLoaderNode::saveLaneArray(const std::vector&lt;std::string&gt; &amp;paths, const autoware_msgs::LaneArray &amp;lane_array)
+{
   unsigned long idx = 0;
-  for (const auto &amp;file_path : paths) {
+  for (const auto&amp; file_path : paths)
+  {
     std::ofstream ofs(file_path.c_str());
-    ofs &lt;&lt; "x,y,z,yaw,velocity,change_flag,steering_flag,accel_flag,stop_flag,"
-           "event_flag"
-        &lt;&lt; std::endl;
-    for (const auto &amp;el : lane_array.lanes[idx].waypoints) {
-      ofs &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; el.pose.pose.position.x
-          &lt;&lt; "," &lt;&lt; el.pose.pose.position.y &lt;&lt; "," &lt;&lt; el.pose.pose.position.z
-          &lt;&lt; "," &lt;&lt; tf::getYaw(el.pose.pose.orientation) &lt;&lt; ","
-          &lt;&lt; mps2kmph(el.twist.twist.linear.x) &lt;&lt; "," &lt;&lt; (int)el.change_flag
-          &lt;&lt; "," &lt;&lt; (int)el.wpstate.steering_state &lt;&lt; ","
-          &lt;&lt; (int)el.wpstate.accel_state &lt;&lt; ","
-          &lt;&lt; (int)el.wpstate.stopline_state &lt;&lt; ","
-          &lt;&lt; (int)el.wpstate.event_state &lt;&lt; std::endl;
+    ofs &lt;&lt; "x,y,z,yaw,velocity,change_flag,steering_flag,accel_flag,stop_flag,event_flag" &lt;&lt; std::endl;
+    for(const auto&amp; el : lane_array.lanes[idx].waypoints)
+    {
+      ofs &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; el.pose.pose.position.x &lt;&lt; "," &lt;&lt; el.pose.pose.position.y &lt;&lt; ","
+          &lt;&lt; el.pose.pose.position.z &lt;&lt; "," &lt;&lt; tf::getYaw(el.pose.pose.orientation) &lt;&lt; "," &lt;&lt; mps2kmph(el.twist.twist.linear.x) &lt;&lt; ","
+          &lt;&lt; (int)el.change_flag &lt;&lt; "," &lt;&lt; (int)el.wpstate.steering_state &lt;&lt; "," &lt;&lt; (int)el.wpstate.accel_state &lt;&lt; ","
+          &lt;&lt; (int)el.wpstate.stopline_state &lt;&lt; "," &lt;&lt; (int)el.wpstate.event_state &lt;&lt; std::endl;
     }
     idx++;
   }
 }
 
-void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path,
-                                            autoware_msgs::lane *lane) {
-  if (!verifyFileConsistency(file_path.c_str())) {
+void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, autoware_msgs::lane *lane)
+{
+  if (!verifyFileConsistency(file_path.c_str()))
+  {
     ROS_ERROR("lane data is something wrong...");
     return;
   }
@@ -157,38 +153,41 @@ void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path,
   lane-&gt;waypoints = wps;
 }
 
-void WaypointLoaderNode::loadWaypointsForVer1(
-    const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps) {
+void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps)
+{
   std::ifstream ifs(filename);
 
   if (!ifs)
     return;
 
   std::string line;
-  std::getline(ifs, line); // Remove first line
+  std::getline(ifs, line);  // Remove first line
 
-  while (std::getline(ifs, line)) {
+  while (std::getline(ifs, line))
+  {
     autoware_msgs::waypoint wp;
     parseWaypointForVer1(line, &amp;wp);
     wps-&gt;push_back(wp);
   }
 
   size_t last = wps-&gt;size() - 1;
-  for (size_t i = 0; i &lt; wps-&gt;size(); ++i) {
-    if (i != last) {
-      double yaw = atan2(wps-&gt;at(i + 1).pose.pose.position.y -
-                             wps-&gt;at(i).pose.pose.position.y,
-                         wps-&gt;at(i + 1).pose.pose.position.x -
-                             wps-&gt;at(i).pose.pose.position.x);
+  for (size_t i = 0; i &lt; wps-&gt;size(); ++i)
+  {
+    if (i != last)
+    {
+      double yaw = atan2(wps-&gt;at(i + 1).pose.pose.position.y - wps-&gt;at(i).pose.pose.position.y,
+                         wps-&gt;at(i + 1).pose.pose.position.x - wps-&gt;at(i).pose.pose.position.x);
       wps-&gt;at(i).pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
-    } else {
+    }
+    else
+    {
       wps-&gt;at(i).pose.pose.orientation = wps-&gt;at(i - 1).pose.pose.orientation;
     }
   }
 }
 
-void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line,
-                                              autoware_msgs::waypoint *wp) {
+void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line, autoware_msgs::waypoint *wp)
+{
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
 
@@ -198,88 +197,86 @@ void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line,
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(columns[3]));
 }
 
-void WaypointLoaderNode::loadWaypointsForVer2(
-    const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps) {
+void WaypointLoaderNode::loadWaypointsForVer2(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps)
+{
   std::ifstream ifs(filename);
 
   if (!ifs)
     return;
 
   std::string line;
-  std::getline(ifs, line); // Remove first line
+  std::getline(ifs, line);  // Remove first line
 
-  while (std::getline(ifs, line)) {
+  while (std::getline(ifs, line))
+  {
     autoware_msgs::waypoint wp;
     parseWaypointForVer2(line, &amp;wp);
     wps-&gt;push_back(wp);
   }
 }
 
-void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line,
-                                              autoware_msgs::waypoint *wp) {
+void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line, autoware_msgs::waypoint *wp)
+{
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
 
   wp-&gt;pose.pose.position.x = std::stod(columns[0]);
   wp-&gt;pose.pose.position.y = std::stod(columns[1]);
   wp-&gt;pose.pose.position.z = std::stod(columns[2]);
-  wp-&gt;pose.pose.orientation =
-      tf::createQuaternionMsgFromYaw(std::stod(columns[3]));
+  wp-&gt;pose.pose.orientation = tf::createQuaternionMsgFromYaw(std::stod(columns[3]));
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(columns[4]));
 }
 
-void WaypointLoaderNode::loadWaypointsForVer3(
-    const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps) {
+void WaypointLoaderNode::loadWaypointsForVer3(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps)
+{
   std::ifstream ifs(filename);
 
   if (!ifs)
     return;
 
   std::string line;
-  std::getline(ifs, line); // get first line
+  std::getline(ifs, line);  // get first line
   std::vector&lt;std::string&gt; contents;
   parseColumns(line, &amp;contents);
 
-  // std::getline(ifs, line);  // remove second line
-  while (std::getline(ifs, line)) {
+  //std::getline(ifs, line);  // remove second line
+  while (std::getline(ifs, line))
+  {
     autoware_msgs::waypoint wp;
     parseWaypointForVer3(line, contents, &amp;wp);
     wps-&gt;push_back(wp);
   }
 }
 
-void WaypointLoaderNode::parseWaypointForVer3(
-    const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
-    autoware_msgs::waypoint *wp) {
+void WaypointLoaderNode::parseWaypointForVer3(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
+                                       autoware_msgs::waypoint *wp)
+{
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
   std::unordered_map&lt;std::string, std::string&gt; map;
-  for (size_t i = 0; i &lt; contents.size(); i++) {
+  for (size_t i = 0; i &lt; contents.size(); i++)
+  {
     map[contents.at(i)] = columns.at(i);
   }
 
   wp-&gt;pose.pose.position.x = std::stod(map["x"]);
   wp-&gt;pose.pose.position.y = std::stod(map["y"]);
   wp-&gt;pose.pose.position.z = std::stod(map["z"]);
-  wp-&gt;pose.pose.orientation =
-      tf::createQuaternionMsgFromYaw(std::stod(map["yaw"]));
+  wp-&gt;pose.pose.orientation = tf::createQuaternionMsgFromYaw(std::stod(map["yaw"]));
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(map["velocity"]));
   wp-&gt;change_flag = std::stoi(map["change_flag"]);
-  wp-&gt;wpstate.steering_state = (map.find("steering_flag") != map.end())
-                                   ? std::stoi(map["steering_flag"])
-                                   : 0;
-  wp-&gt;wpstate.accel_state =
-      (map.find("accel_flag") != map.end()) ? std::stoi(map["accel_flag"]) : 0;
-  wp-&gt;wpstate.stopline_state =
-      (map.find("stop_flag") != map.end()) ? std::stoi(map["stop_flag"]) : 0;
-  wp-&gt;wpstate.event_state =
-      (map.find("event_flag") != map.end()) ? std::stoi(map["event_flag"]) : 0;
+  wp-&gt;wpstate.steering_state = (map.find("steering_flag") != map.end()) ? std::stoi(map["steering_flag"]) : 0;
+  wp-&gt;wpstate.accel_state = (map.find("accel_flag") != map.end()) ? std::stoi(map["accel_flag"]) : 0;
+  wp-&gt;wpstate.stopline_state = (map.find("stop_flag") != map.end()) ? std::stoi(map["stop_flag"]) : 0;
+  wp-&gt;wpstate.event_state = (map.find("event_flag") != map.end()) ? std::stoi(map["event_flag"]) : 0;
 }
 
-FileFormat WaypointLoaderNode::checkFileFormat(const char *filename) {
+FileFormat WaypointLoaderNode::checkFileFormat(const char *filename)
+{
   std::ifstream ifs(filename);
 
-  if (!ifs) {
+  if (!ifs)
+  {
     return FileFormat::unknown;
   }
 
@@ -292,8 +289,8 @@ FileFormat WaypointLoaderNode::checkFileFormat(const char *filename) {
   parseColumns(line, &amp;parsed_columns);
 
   // check if first element in the first column does not include digit
-  if (!std::any_of(parsed_columns.at(0).cbegin(), parsed_columns.at(0).cend(),
-                   isdigit)) {
+  if (!std::any_of(parsed_columns.at(0).cbegin(), parsed_columns.at(0).cend(), isdigit))
+  {
     return FileFormat::ver3;
   }
 
@@ -301,14 +298,14 @@ FileFormat WaypointLoaderNode::checkFileFormat(const char *filename) {
   int num_of_columns = countColumns(line);
   ROS_INFO("columns size: %d", num_of_columns);
 
-  return (num_of_columns == 3
-              ? FileFormat::ver1 // if data consists "x y z (velocity)"
-              : num_of_columns == 4
-                    ? FileFormat::ver2 // if data consists "x y z yaw (velocity)
-                    : FileFormat::unknown);
+  return ( num_of_columns == 3 ? FileFormat::ver1  // if data consists "x y z (velocity)"
+         : num_of_columns == 4 ? FileFormat::ver2  // if data consists "x y z yaw (velocity)
+                               : FileFormat::unknown
+          );
 }
 
-bool WaypointLoaderNode::verifyFileConsistency(const char *filename) {
+bool WaypointLoaderNode::verifyFileConsistency(const char *filename)
+{
   ROS_INFO("verify...");
   std::ifstream ifs(filename);
 
@@ -317,20 +314,20 @@ bool WaypointLoaderNode::verifyFileConsistency(const char *filename) {
 
   FileFormat format = checkFileFormat(filename);
   ROS_INFO("format: %d", static_cast&lt;FileFormat&gt;(format));
-  if (format == FileFormat::unknown) {
+  if (format == FileFormat::unknown)
+  {
     ROS_ERROR("unknown file format");
     return false;
   }
 
   std::string line;
-  std::getline(ifs, line); // remove first line
+  std::getline(ifs, line);  // remove first line
 
-  size_t ncol = format == FileFormat::ver1
-                    ? 4                              // x,y,z,velocity
-                    : format == FileFormat::ver2 ? 5 // x,y,z,yaw,velocity
-                                                 : countColumns(line);
+  size_t ncol = format == FileFormat::ver1 ? 4 //x,y,z,velocity
+              : format == FileFormat::ver2 ? 5 //x,y,z,yaw,velocity
+              : countColumns(line);
 
-  while (std::getline(ifs, line)) // search from second line
+  while (std::getline(ifs, line))  // search from second line
   {
     if (countColumns(line) != ncol)
       return false;
@@ -338,7 +335,8 @@ bool WaypointLoaderNode::verifyFileConsistency(const char *filename) {
   return true;
 }
 
-void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns) {
+void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns)
+{
   std::istringstream ss(line);
   std::string column;
   while (std::getline(ss, column, ',')) {
@@ -353,16 +351,18 @@ void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns) {
   }
 }
 
-size_t countColumns(const std::string &amp;line) {
+size_t countColumns(const std::string &amp;line)
+{
   std::istringstream ss(line);
   size_t ncol = 0;
 
   std::string column;
-  while (std::getline(ss, column, ',')) {
+  while (std::getline(ss, column, ','))
+  {
     ++ncol;
   }
 
   return ncol;
 }
 
-} // waypoint_maker
+}  // waypoint_maker
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="36" deleted_lines="42">
				<diff>@@ -5,8 +5,7 @@
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions are met:
  *
- *  * Redistributions of source code must retain the above copyright notice,
-this
+ *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
  *
  *  * Redistributions in binary form must reproduce the above copyright notice,
@@ -19,16 +18,13 @@ this
  *
  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
-USE
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
@@ -39,43 +35,50 @@ USE
 #include &lt;ros/ros.h&gt;
 
 // C++ includes
-#include &lt;fstream&gt;
 #include &lt;iostream&gt;
+#include &lt;fstream&gt;
+#include &lt;vector&gt;
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
 #include &lt;unordered_map&gt;
-#include &lt;vector&gt;
 
 #include "autoware_msgs/LaneArray.h"
 #include "waypoint_filter.h"
 
-namespace waypoint_maker {
+namespace waypoint_maker
+{
 
 const std::string MULTI_LANE_CSV = "/tmp/driving_lane.csv";
 
-enum class FileFormat : int32_t {
-  ver1, // x,y,z,(velocity)
-  ver2, // x,y,z,yaw,(velocity)
-  ver3, // first line consists on explanation of values
+enum class FileFormat : int32_t
+{
+  ver1,  //x,y,z,(velocity)
+  ver2,  //x,y,z,yaw,(velocity)
+  ver3,  //first line consists on explanation of values
 
   unknown = -1,
 };
 
 typedef std::underlying_type&lt;FileFormat&gt;::type FileFormatInteger;
 
-inline double kmph2mps(double velocity_kmph) {
+inline double kmph2mps(double velocity_kmph)
+{
   return (velocity_kmph * 1000) / (60 * 60);
 }
-inline double mps2kmph(double velocity_mps) {
+inline double mps2kmph(double velocity_mps)
+{
   return (velocity_mps * 60 * 60) / 1000;
 }
 
-class WaypointLoaderNode {
+class WaypointLoaderNode
+{
 public:
+
   WaypointLoaderNode();
   ~WaypointLoaderNode();
 
 private:
+
   // handle
   ros::NodeHandle nh_;
   ros::NodeHandle private_nh_;
@@ -95,38 +98,29 @@ private:
 
   // initializer
   void initPubSub();
-  void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr &amp;conf);
+  void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
 
   // functions
-  void
-  configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr &amp;conf);
-  void outputCommandCallback(const std_msgs::Bool::ConstPtr &amp;output_cmd);
-  void createLaneWaypoint(const std::string &amp;file_path,
-                          autoware_msgs::lane *lane);
-  void createLaneArray(const std::vector&lt;std::string&gt; &amp;paths,
-                       autoware_msgs::LaneArray *lane_array);
-  void saveLaneArray(const std::vector&lt;std::string&gt; &amp;paths,
-                     const autoware_msgs::LaneArray &amp;lane_array);
+  void configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
+  void outputCommandCallback(const std_msgs::Bool::ConstPtr&amp; output_cmd);
+  void createLaneWaypoint(const std::string &amp;file_path, autoware_msgs::lane *lane);
+  void createLaneArray(const std::vector&lt;std::string&gt; &amp;paths, autoware_msgs::LaneArray *lane_array);
+  void saveLaneArray(const std::vector&lt;std::string&gt; &amp;paths, const autoware_msgs::LaneArray &amp;lane_array);
 
   FileFormat checkFileFormat(const char *filename);
   bool verifyFileConsistency(const char *filename);
-  void loadWaypointsForVer1(const char *filename,
-                            std::vector&lt;autoware_msgs::waypoint&gt; *wps);
-  void parseWaypointForVer1(const std::string &amp;line,
-                            autoware_msgs::waypoint *wp);
-  void loadWaypointsForVer2(const char *filename,
-                            std::vector&lt;autoware_msgs::waypoint&gt; *wps);
-  void parseWaypointForVer2(const std::string &amp;line,
-                            autoware_msgs::waypoint *wp);
-  void loadWaypointsForVer3(const char *filename,
-                            std::vector&lt;autoware_msgs::waypoint&gt; *wps);
-  void parseWaypointForVer3(const std::string &amp;line,
-                            const std::vector&lt;std::string&gt; &amp;contents,
+  void loadWaypointsForVer1(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
+  void parseWaypointForVer1(const std::string &amp;line, autoware_msgs::waypoint *wp);
+  void loadWaypointsForVer2(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
+  void parseWaypointForVer2(const std::string &amp;line, autoware_msgs::waypoint *wp);
+  void loadWaypointsForVer3(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
+  void parseWaypointForVer3(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
                             autoware_msgs::waypoint *wp);
 };
 
 const std::string addFileSuffix(std::string file_path, std::string suffix);
 void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns);
-size_t countColumns(const std::string &amp;line);
+size_t countColumns(const std::string&amp; line);
+
 }
-#endif // WAYPOINT_LOADER_CORE_H
+#endif  // WAYPOINT_LOADER_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_node.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_node.cpp" added_lines="6" deleted_lines="9">
				<diff>@@ -5,8 +5,7 @@
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions are met:
  *
- *  * Redistributions of source code must retain the above copyright notice,
- * this
+ *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
  *
  *  * Redistributions in binary form must reproduce the above copyright notice,
@@ -19,16 +18,13 @@
  *
  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
@@ -37,7 +33,8 @@
 
 #include "waypoint_loader_core.h"
 
-int main(int argc, char **argv) {
+int main(int argc, char **argv)
+{
   ros::init(argc, argv, "waypoint_loader");
   waypoint_maker::WaypointLoaderNode wln;
   ros::spin();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="025433f018d07f7aa2cbd388ba12ba482a37744e" author="Yuma">
		<msg>retry Clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" added_lines="271" deleted_lines="250">
				<diff>@@ -32,300 +32,321 @@
 
 namespace waypoint_maker
 {
+inline double kmph2mps(double velocity_kmph)
+{
+  return (velocity_kmph * 1000) / (60 * 60);
+}
+inline double mps2kmph(double velocity_mps)
+{
+  return (velocity_mps * 60 * 60) / 1000;
+}
 
-  inline double kmph2mps(double velocity_kmph)
-  {
-    return (velocity_kmph * 1000) / (60 * 60);
-  }
-  inline double mps2kmph(double velocity_mps)
-  {
-    return (velocity_mps * 60 * 60) / 1000;
-  }
+WaypointFilter::WaypointFilter() : private_nh_("~")
+{
+}
 
-  WaypointFilter::WaypointFilter():private_nh_("~")
-  {
-  }
+WaypointFilter::~WaypointFilter()
+{
+}
+
+void WaypointFilter::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
+{
+  velocity_max_ = kmph2mps(conf-&gt;velocity_max);
+  velocity_min_ = kmph2mps(conf-&gt;velocity_min);
+  accel_limit_ = conf-&gt;accel_limit;
+  decel_limit_ = conf-&gt;decel_limit;
+  r_th_ = conf-&gt;radius_thresh;
+  r_min_ = conf-&gt;radius_min;
+  lookup_crv_width_ = 5;
+  resample_mode_ = conf-&gt;resample_mode;
+  resample_interval_ = conf-&gt;resample_interval;
+  velocity_offset_ = conf-&gt;velocity_offset;
+  r_inf_ = 10 * r_th_;
+}
 
-  WaypointFilter::~WaypointFilter(){}
+void WaypointFilter::filterLaneWaypoint(autoware_msgs::lane* lane)
+{
+  std::vector&lt;double&gt; curve_radius;
+  std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt; curve_list;
 
-  void WaypointFilter::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
+  if (resample_mode_)
+    resampleLaneWaypoint(resample_interval_, lane, &amp;curve_radius);
+  else
+    getCurveAll(*lane, &amp;curve_radius);
+  const std::vector&lt;double&gt; vel_param = calcVelParamFromVmax(velocity_max_);
+  createCurveList(curve_radius, &amp;curve_list);
+  if (vel_param.size() &lt; 2)
   {
-    velocity_max_ = kmph2mps(conf-&gt;velocity_max);
-    velocity_min_ = kmph2mps(conf-&gt;velocity_min);
-    accel_limit_ = conf-&gt;accel_limit;
-    decel_limit_ = conf-&gt;decel_limit;
-    r_th_ = conf-&gt;radius_thresh;
-    r_min_ = conf-&gt;radius_min;
-    lookup_crv_width_ = 5;
-    resample_mode_ = conf-&gt;resample_mode;
-    resample_interval_ = conf-&gt;resample_interval;
-    velocity_offset_ = conf-&gt;velocity_offset;
-    r_inf_ = 10 * r_th_;
+    ROS_ERROR("velocity parameter is invalid");
+    return;
   }
-
-  void WaypointFilter::filterLaneWaypoint(autoware_msgs::lane *lane)
+  // set velocity_max for all_point
+  for (auto&amp; el : lane-&gt;waypoints)
+    el.twist.twist.linear.x = velocity_max_;
+  // set curve_velocity on curve begining
+  for (const auto&amp; el : curve_list)
   {
-    std::vector&lt;double&gt; curve_radius;
-    std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt; curve_list;
-
-    if(resample_mode_)
-      resampleLaneWaypoint(resample_interval_, lane, &amp;curve_radius);
-    else
-      getCurveAll(*lane, &amp;curve_radius);
-    const std::vector&lt;double&gt; vel_param = calcVelParamFromVmax(velocity_max_);
-    createCurveList(curve_radius, &amp;curve_list);
-    if(vel_param.size() &lt; 2)
+    const unsigned long start_idx = (el.first &gt; velocity_offset_) ? (el.first - velocity_offset_) : 0;
+    const unsigned long end_idx = (el.second.first &gt; velocity_offset_) ? (el.second.first - velocity_offset_) : 0;
+    const double radius = el.second.second;
+    const double vmax = velocity_max_;
+    const double vmin = vel_param[0] * radius + vel_param[1];
+    for (unsigned long idx = start_idx; idx &lt;= end_idx; idx++)
     {
-      ROS_ERROR("velocity parameter is invalid");
-      return;
-    }
-    //set velocity_max for all_point
-    for(auto&amp; el : lane-&gt;waypoints)
-      el.twist.twist.linear.x = velocity_max_;
-    //set curve_velocity on curve begining
-    for(const auto&amp; el : curve_list)
-    {
-      const unsigned long start_idx = (el.first &gt; velocity_offset_) ? (el.first - velocity_offset_) : 0;
-      const unsigned long end_idx = (el.second.first &gt; velocity_offset_) ? (el.second.first - velocity_offset_) : 0;
-      const double radius = el.second.second;
-      const double vmax = velocity_max_;
-      const double vmin = vel_param[0] * radius + vel_param[1];
-      for(unsigned long idx = start_idx; idx &lt;= end_idx ; idx++)
-      {
-        if(lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)continue;
-        lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
-      }
-      limitAccelDecel(vmax, vmin, start_idx, lane);
-      limitAccelDecel(vmax, vmin, end_idx, lane);
-    }
-    unsigned long end_id[2] = {0, lane-&gt;waypoints.size() - 1};
-    for(int i = 0; i &lt; 2; i++)
-    {
-      const unsigned long idx = end_id[i];
-      const double vmax = velocity_max_;
-      const double vmin = (i == 0) ? velocity_min_ : 0.0;
-      if(lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)continue;
+      if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
+        continue;
       lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
-      limitAccelDecel(vmax, vmin, idx, lane);
     }
+    limitAccelDecel(vmax, vmin, start_idx, lane);
+    limitAccelDecel(vmax, vmin, end_idx, lane);
   }
-
-  void WaypointFilter::resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane *lane, std::vector&lt;double&gt; *curve_radius)
+  unsigned long end_id[2] = { 0, lane-&gt;waypoints.size() - 1 };
+  for (int i = 0; i &lt; 2; i++)
   {
-    if(lane-&gt;waypoints.empty())return;
-    autoware_msgs::lane original_lane = *lane;
-    lane-&gt;waypoints.clear();
-    lane-&gt;waypoints.push_back(original_lane.waypoints[0]);
-    curve_radius-&gt;clear();
-    curve_radius-&gt;push_back(r_inf_);
-    double original_len = calcPathLength(original_lane);
-    unsigned long waypoints_size = ceil(1.5 * original_len / resample_interval_);
-    lane-&gt;waypoints.reserve(waypoints_size);
-    curve_radius-&gt;reserve(waypoints_size);
-
-    const unsigned int n = (lookup_crv_width_ - 1) / 2;
-    for(unsigned long i = 1; i &lt; original_lane.waypoints.size(); i++)
-    {
-      std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
-      curve_point[0] = (lane-&gt;waypoints.size() &lt; n) ? lane-&gt;waypoints[0].pose.pose.position
-                                                    : lane-&gt;waypoints[lane-&gt;waypoints.size() - n].pose.pose.position;
-      curve_point[1] = original_lane.waypoints[i].pose.pose.position;
-      curve_point[2] = (i &gt;= original_lane.waypoints.size() - n) ? original_lane.waypoints.back().pose.pose.position
-                                                                : original_lane.waypoints[i + n].pose.pose.position;
-      const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
-      //if going straight
-      if(curve_param.empty())
-      {
-        const std::vector&lt;double&gt; vec = {curve_point[2].x - curve_point[0].x, curve_point[2].y - curve_point[0].y};
-        autoware_msgs::waypoint wp;
-        wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
-        wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(atan2(vec[1], vec[0]));
-        wp.change_flag = lane-&gt;waypoints.back().change_flag;
-        const std::vector&lt;double&gt; nvec = {curve_point[1].x - wp.pose.pose.position.x, curve_point[1].y - wp.pose.pose.position.y, curve_point[1].z - wp.pose.pose.position.z};
-        double dist = sqrt(calcSquareSum(nvec[0], nvec[1]));
-        const tf::Vector3 resample_vec(resample_interval_ * nvec[0] / dist, resample_interval_ * nvec[1] / dist, resample_interval_ * nvec[2] / dist);
-        for(; dist &gt; resample_interval_; dist -= resample_interval_)
-        {
-          if(lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())break;
-          wp.pose.pose.position.x += resample_vec.x();
-          wp.pose.pose.position.y += resample_vec.y();
-          wp.pose.pose.position.z += resample_vec.z();
-          lane-&gt;waypoints.push_back(wp);
-          curve_radius-&gt;push_back(r_inf_);
-        }
-      }
-      //else if turnning curve
-      else
-      {
-        const double&amp; cx = curve_param[0];
-        const double&amp; cy = curve_param[1];
-        const double&amp; radius = curve_param[2];
-        const double threshold_radius = (radius &gt; r_inf_) ? r_inf_ : radius;
-
-        const geometry_msgs::Point&amp; p0 = lane-&gt;waypoints.back().pose.pose.position;
-        const geometry_msgs::Point&amp; p1 = curve_point[1];
-        double theta = fmod(atan2(p1.y - cy, p1.x - cx) - atan2(p0.y - cy, p0.x - cx), 2 * M_PI);
-        if(theta &gt; M_PI)theta -= 2 * M_PI;
-        else if(theta &lt; -M_PI)theta += 2 * M_PI;
-        //interport
-        double t = atan2(p0.y - cy, p0.x - cx);
-        autoware_msgs::waypoint wp;
-        wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
-        wp.change_flag = lane-&gt;waypoints.back().change_flag;
-        double dist = radius * fabs(theta);
-        double dz_nextpt = curve_point[1].z - lane-&gt;waypoints.back().pose.pose.position.z;
-        const double resample_dz = resample_interval_ * dz_nextpt / dist;
-        for(; dist &gt; resample_interval_; dist -= resample_interval_)
-        {
-          if(lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())break;
-          const int sign = (theta &gt; 0.0) ? (1) : (-1);
-          t += sign * resample_interval_ / radius;
-          const double yaw = fmod(t + sign * M_PI / 2.0, 2 * M_PI);
-          wp.pose.pose.position.x = cx + radius * cos(t);
-          wp.pose.pose.position.y = cy + radius * sin(t);
-          wp.pose.pose.position.z += resample_dz;
-          wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
-          lane-&gt;waypoints.push_back(wp);
-          curve_radius-&gt;push_back(threshold_radius);
-        }
-      }
-      lane-&gt;waypoints.back().wpstate = original_lane.waypoints[i].wpstate;
-      lane-&gt;waypoints.back().change_flag = original_lane.waypoints[i].change_flag;
-    }
-    lane-&gt;waypoints.back().wpstate = original_lane.waypoints.back().wpstate;
-    lane-&gt;waypoints.back().change_flag = original_lane.waypoints.back().change_flag;
+    const unsigned long idx = end_id[i];
+    const double vmax = velocity_max_;
+    const double vmin = (i == 0) ? velocity_min_ : 0.0;
+    if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
+      continue;
+    lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
+    limitAccelDecel(vmax, vmin, idx, lane);
   }
+}
 
+void WaypointFilter::resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane,
+                                          std::vector&lt;double&gt;* curve_radius)
+{
+  if (lane-&gt;waypoints.empty())
+    return;
+  autoware_msgs::lane original_lane = *lane;
+  lane-&gt;waypoints.clear();
+  lane-&gt;waypoints.push_back(original_lane.waypoints[0]);
+  curve_radius-&gt;clear();
+  curve_radius-&gt;push_back(r_inf_);
+  double original_len = calcPathLength(original_lane);
+  unsigned long waypoints_size = ceil(1.5 * original_len / resample_interval_);
+  lane-&gt;waypoints.reserve(waypoints_size);
+  curve_radius-&gt;reserve(waypoints_size);
 
-
-  void WaypointFilter::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt; *curve_radius)
+  const unsigned int n = (lookup_crv_width_ - 1) / 2;
+  for (unsigned long i = 1; i &lt; original_lane.waypoints.size(); i++)
   {
-    if(lane.waypoints.empty())return;
-    curve_radius-&gt;resize(lane.waypoints.size());
-    curve_radius-&gt;at(0) = curve_radius-&gt;back() = r_inf_;
-
-    const unsigned int n = (lookup_crv_width_ - 1) / 2;
-    for(unsigned long i = 1; i &lt; lane.waypoints.size() - 1; i++)
+    std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
+    curve_point[0] = (lane-&gt;waypoints.size() &lt; n) ? lane-&gt;waypoints[0].pose.pose.position :
+                                                    lane-&gt;waypoints[lane-&gt;waypoints.size() - n].pose.pose.position;
+    curve_point[1] = original_lane.waypoints[i].pose.pose.position;
+    curve_point[2] = (i &gt;= original_lane.waypoints.size() - n) ? original_lane.waypoints.back().pose.pose.position :
+                                                                 original_lane.waypoints[i + n].pose.pose.position;
+    const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
+    // if going straight
+    if (curve_param.empty())
     {
-      std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
-      curve_point[0] = (i &lt; n) ? lane.waypoints[0].pose.pose.position
-                                : lane.waypoints[i - n].pose.pose.position;
-      curve_point[1] = lane.waypoints[i].pose.pose.position;
-      curve_point[2] = (i &gt;= lane.waypoints.size() - n) ? lane.waypoints.back().pose.pose.position
-                                                          : lane.waypoints[i + n].pose.pose.position;
-      const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
-      //if going straight
-      if(curve_param.empty())
+      const std::vector&lt;double&gt; vec = { curve_point[2].x - curve_point[0].x, curve_point[2].y - curve_point[0].y };
+      autoware_msgs::waypoint wp;
+      wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
+      wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(atan2(vec[1], vec[0]));
+      wp.change_flag = lane-&gt;waypoints.back().change_flag;
+      const std::vector&lt;double&gt; nvec = { curve_point[1].x - wp.pose.pose.position.x,
+                                         curve_point[1].y - wp.pose.pose.position.y,
+                                         curve_point[1].z - wp.pose.pose.position.z };
+      double dist = sqrt(calcSquareSum(nvec[0], nvec[1]));
+      const tf::Vector3 resample_vec(resample_interval_ * nvec[0] / dist, resample_interval_ * nvec[1] / dist,
+                                     resample_interval_ * nvec[2] / dist);
+      for (; dist &gt; resample_interval_; dist -= resample_interval_)
       {
-        curve_radius-&gt;at(i) = r_inf_;
+        if (lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())
+          break;
+        wp.pose.pose.position.x += resample_vec.x();
+        wp.pose.pose.position.y += resample_vec.y();
+        wp.pose.pose.position.z += resample_vec.z();
+        lane-&gt;waypoints.push_back(wp);
+        curve_radius-&gt;push_back(r_inf_);
       }
-      //else if turnning curve
-      else
+    }
+    // else if turnning curve
+    else
+    {
+      const double&amp; cx = curve_param[0];
+      const double&amp; cy = curve_param[1];
+      const double&amp; radius = curve_param[2];
+      const double threshold_radius = (radius &gt; r_inf_) ? r_inf_ : radius;
+
+      const geometry_msgs::Point&amp; p0 = lane-&gt;waypoints.back().pose.pose.position;
+      const geometry_msgs::Point&amp; p1 = curve_point[1];
+      double theta = fmod(atan2(p1.y - cy, p1.x - cx) - atan2(p0.y - cy, p0.x - cx), 2 * M_PI);
+      if (theta &gt; M_PI)
+        theta -= 2 * M_PI;
+      else if (theta &lt; -M_PI)
+        theta += 2 * M_PI;
+      // interport
+      double t = atan2(p0.y - cy, p0.x - cx);
+      autoware_msgs::waypoint wp;
+      wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
+      wp.change_flag = lane-&gt;waypoints.back().change_flag;
+      double dist = radius * fabs(theta);
+      double dz_nextpt = curve_point[1].z - lane-&gt;waypoints.back().pose.pose.position.z;
+      const double resample_dz = resample_interval_ * dz_nextpt / dist;
+      for (; dist &gt; resample_interval_; dist -= resample_interval_)
       {
-        const double&amp; radius = curve_param[2];
-        curve_radius-&gt;at(i) = (radius &gt; r_inf_) ? r_inf_ : radius;
+        if (lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())
+          break;
+        const int sign = (theta &gt; 0.0) ? (1) : (-1);
+        t += sign * resample_interval_ / radius;
+        const double yaw = fmod(t + sign * M_PI / 2.0, 2 * M_PI);
+        wp.pose.pose.position.x = cx + radius * cos(t);
+        wp.pose.pose.position.y = cy + radius * sin(t);
+        wp.pose.pose.position.z += resample_dz;
+        wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
+        lane-&gt;waypoints.push_back(wp);
+        curve_radius-&gt;push_back(threshold_radius);
       }
     }
+    lane-&gt;waypoints.back().wpstate = original_lane.waypoints[i].wpstate;
+    lane-&gt;waypoints.back().change_flag = original_lane.waypoints[i].change_flag;
   }
+  lane-&gt;waypoints.back().wpstate = original_lane.waypoints.back().wpstate;
+  lane-&gt;waypoints.back().change_flag = original_lane.waypoints.back().change_flag;
+}
 
-  const std::vector&lt;double&gt; WaypointFilter::calcVelParamFromVmax(const double vmax)const
-  {
-    std::vector&lt;double&gt; param(2, 0.0);
-    param[0] = (vmax - velocity_min_) / (r_th_ - r_min_);//bias
-    param[1] = vmax - param[0] * r_th_;//vel_intersept
-    return param;
-  }
+void WaypointFilter::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
+{
+  if (lane.waypoints.empty())
+    return;
+  curve_radius-&gt;resize(lane.waypoints.size());
+  curve_radius-&gt;at(0) = curve_radius-&gt;back() = r_inf_;
 
-  void WaypointFilter::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius, std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list)
+  const unsigned int n = (lookup_crv_width_ - 1) / 2;
+  for (unsigned long i = 1; i &lt; lane.waypoints.size() - 1; i++)
   {
-    unsigned long index = 0;
-    bool on_curve = false;
-    double radius_localmin = DBL_MAX;
-    for(unsigned long i = 1; i &lt; curve_radius.size(); i++)
+    std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
+    curve_point[0] = (i &lt; n) ? lane.waypoints[0].pose.pose.position : lane.waypoints[i - n].pose.pose.position;
+    curve_point[1] = lane.waypoints[i].pose.pose.position;
+    curve_point[2] = (i &gt;= lane.waypoints.size() - n) ? lane.waypoints.back().pose.pose.position :
+                                                        lane.waypoints[i + n].pose.pose.position;
+    const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
+    // if going straight
+    if (curve_param.empty())
     {
-      if(!on_curve &amp;&amp; curve_radius[i] &lt;= r_th_ &amp;&amp; curve_radius[i -1] &gt; r_th_)
-      {
-        index = i;
-        on_curve = true;
-      }
-      else if(on_curve &amp;&amp; curve_radius[i - 1] &lt;= r_th_ &amp;&amp; curve_radius[i] &gt; r_th_)
-      {
-        on_curve = false;
-        if(radius_localmin &lt; r_min_)radius_localmin = r_min_;
-        (*curve_list)[index] = std::make_pair(i, radius_localmin);
-        radius_localmin = DBL_MAX;
-      }
-      if(!on_curve)continue;
-      if(radius_localmin &gt; curve_radius[i])radius_localmin = curve_radius[i];
+      curve_radius-&gt;at(i) = r_inf_;
+    }
+    // else if turnning curve
+    else
+    {
+      const double&amp; radius = curve_param[2];
+      curve_radius-&gt;at(i) = (radius &gt; r_inf_) ? r_inf_ : radius;
     }
   }
+}
+
+const std::vector&lt;double&gt; WaypointFilter::calcVelParamFromVmax(const double vmax) const
+{
+  std::vector&lt;double&gt; param(2, 0.0);
+  param[0] = (vmax - velocity_min_) / (r_th_ - r_min_);  // bias
+  param[1] = vmax - param[0] * r_th_;                    // vel_intersept
+  return param;
+}
 
-  void WaypointFilter::limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx, autoware_msgs::lane *lane)
+void WaypointFilter::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
+                                     std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list)
+{
+  unsigned long index = 0;
+  bool on_curve = false;
+  double radius_localmin = DBL_MAX;
+  for (unsigned long i = 1; i &lt; curve_radius.size(); i++)
   {
-    double v = vmin_local;
-    for(unsigned long i = 1; ; i++)
+    if (!on_curve &amp;&amp; curve_radius[i] &lt;= r_th_ &amp;&amp; curve_radius[i - 1] &gt; r_th_)
     {
-      v = sqrt(2 * accel_limit_ * resample_interval_ + v * v);
-      if(i &gt; lane-&gt;waypoints.size() - idx - 1 || v &gt; vmax)break;
-      if(lane-&gt;waypoints[idx + i].twist.twist.linear.x &lt; v)break;
-      lane-&gt;waypoints[idx + i].twist.twist.linear.x = v;
+      index = i;
+      on_curve = true;
     }
-
-    v = vmin_local;
-    for(unsigned long i = 1; ; i++)
+    else if (on_curve &amp;&amp; curve_radius[i - 1] &lt;= r_th_ &amp;&amp; curve_radius[i] &gt; r_th_)
     {
-      v = sqrt(2 * decel_limit_ * resample_interval_ + v * v);
-      if(i &gt; idx || v &gt; vmax)break;
-      if(lane-&gt;waypoints[idx - i].twist.twist.linear.x &lt; v)break;
-      lane-&gt;waypoints[idx - i].twist.twist.linear.x = v;
+      on_curve = false;
+      if (radius_localmin &lt; r_min_)
+        radius_localmin = r_min_;
+      (*curve_list)[index] = std::make_pair(i, radius_localmin);
+      radius_localmin = DBL_MAX;
     }
+    if (!on_curve)
+      continue;
+    if (radius_localmin &gt; curve_radius[i])
+      radius_localmin = curve_radius[i];
   }
+}
 
-  //get 3 parameter of curve, [center_x, center_y, radius]
-  const std::vector&lt;double&gt; WaypointFilter::getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point)const
+void WaypointFilter::limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx,
+                                     autoware_msgs::lane* lane)
+{
+  double v = vmin_local;
+  for (unsigned long i = 1;; i++)
   {
-    std::vector&lt;double&gt; curve_param(3, 0.0);
-    tf::Vector3 vec[2];
-    geometry_msgs::Point pt_m[2];
-    double tan_pt_m[2];
-    for(unsigned int i = 0; i &lt; 2; i++)
-    {
-      const geometry_msgs::Point&amp; p0 = point[i];
-      const geometry_msgs::Point&amp; p1 = point[i + 1];
-      pt_m[i].x = (p0.x + p1.x) / 2.0;
-      pt_m[i].y = (p0.y + p1.y) / 2.0;
-      vec[i] = tf::Vector3(p1.x - p0.x, p1.y - p0.y, 0.0);
-      if(fabs(vec[i].x()) &lt; 1e-8 &amp;&amp; fabs(vec[i].y()) &lt; 1e-8)return std::vector&lt;double&gt;();
-      tan_pt_m[i] = tan(atan2(vec[i].y(), vec[i].x()) + M_PI / 2.0);
-    }
-    if(fabs(tan_pt_m[1] - tan_pt_m[0]) &lt; 1e-9)return std::vector&lt;double&gt;();
+    v = sqrt(2 * accel_limit_ * resample_interval_ + v * v);
+    if (i &gt; lane-&gt;waypoints.size() - idx - 1 || v &gt; vmax)
+      break;
+    if (lane-&gt;waypoints[idx + i].twist.twist.linear.x &lt; v)
+      break;
+    lane-&gt;waypoints[idx + i].twist.twist.linear.x = v;
+  }
 
-    {
-      const geometry_msgs::Point&amp; p0 = point[0];
-      curve_param[0] = pt_m[0].y - pt_m[0].x * tan_pt_m[0] - pt_m[1].y + pt_m[1].x * tan_pt_m[1];
-      curve_param[0] /= tan_pt_m[1] - tan_pt_m[0];
-      curve_param[1] = pt_m[0].y - (pt_m[0].x - curve_param[0]) * tan_pt_m[0];
-      curve_param[2] = sqrt(calcSquareSum(p0.x - curve_param[0], p0.y - curve_param[1]));
-    }
-    return curve_param;
+  v = vmin_local;
+  for (unsigned long i = 1;; i++)
+  {
+    v = sqrt(2 * decel_limit_ * resample_interval_ + v * v);
+    if (i &gt; idx || v &gt; vmax)
+      break;
+    if (lane-&gt;waypoints[idx - i].twist.twist.linear.x &lt; v)
+      break;
+    lane-&gt;waypoints[idx - i].twist.twist.linear.x = v;
   }
+}
 
-  const double WaypointFilter::calcSquareSum(const double x, const double y)const
+// get 3 parameter of curve, [center_x, center_y, radius]
+const std::vector&lt;double&gt; WaypointFilter::getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point) const
+{
+  std::vector&lt;double&gt; curve_param(3, 0.0);
+  tf::Vector3 vec[2];
+  geometry_msgs::Point pt_m[2];
+  double tan_pt_m[2];
+  for (unsigned int i = 0; i &lt; 2; i++)
   {
-    return (x * x + y * y);
+    const geometry_msgs::Point&amp; p0 = point[i];
+    const geometry_msgs::Point&amp; p1 = point[i + 1];
+    pt_m[i].x = (p0.x + p1.x) / 2.0;
+    pt_m[i].y = (p0.y + p1.y) / 2.0;
+    vec[i] = tf::Vector3(p1.x - p0.x, p1.y - p0.y, 0.0);
+    if (fabs(vec[i].x()) &lt; 1e-8 &amp;&amp; fabs(vec[i].y()) &lt; 1e-8)
+      return std::vector&lt;double&gt;();
+    tan_pt_m[i] = tan(atan2(vec[i].y(), vec[i].x()) + M_PI / 2.0);
   }
+  if (fabs(tan_pt_m[1] - tan_pt_m[0]) &lt; 1e-9)
+    return std::vector&lt;double&gt;();
 
-  const double WaypointFilter::calcPathLength(const autoware_msgs::lane&amp; lane)const
   {
-    double distance = 0.0;
-    for(unsigned long i = 1; i &lt; lane.waypoints.size(); i++)
-    {
-      const geometry_msgs::Point&amp; p0 = lane.waypoints[i - 1].pose.pose.position;
-      const geometry_msgs::Point&amp; p1 = lane.waypoints[i].pose.pose.position;
-      tf::Vector3 tf0(p0.x, p0.y, 0.0);
-      tf::Vector3 tf1(p1.x, p1.y, 0.0);
-      distance += tf::tfDistance(tf0, tf1);
-    }
-    return distance;
+    const geometry_msgs::Point&amp; p0 = point[0];
+    curve_param[0] = pt_m[0].y - pt_m[0].x * tan_pt_m[0] - pt_m[1].y + pt_m[1].x * tan_pt_m[1];
+    curve_param[0] /= tan_pt_m[1] - tan_pt_m[0];
+    curve_param[1] = pt_m[0].y - (pt_m[0].x - curve_param[0]) * tan_pt_m[0];
+    curve_param[2] = sqrt(calcSquareSum(p0.x - curve_param[0], p0.y - curve_param[1]));
+  }
+  return curve_param;
+}
+
+const double WaypointFilter::calcSquareSum(const double x, const double y) const
+{
+  return (x * x + y * y);
+}
+
+const double WaypointFilter::calcPathLength(const autoware_msgs::lane&amp; lane) const
+{
+  double distance = 0.0;
+  for (unsigned long i = 1; i &lt; lane.waypoints.size(); i++)
+  {
+    const geometry_msgs::Point&amp; p0 = lane.waypoints[i - 1].pose.pose.position;
+    const geometry_msgs::Point&amp; p1 = lane.waypoints[i].pose.pose.position;
+    tf::Vector3 tf0(p0.x, p0.y, 0.0);
+    tf::Vector3 tf1(p1.x, p1.y, 0.0);
+    distance += tf::tfDistance(tf0, tf1);
   }
+  return distance;
+}
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" added_lines="13" deleted_lines="10">
				<diff>@@ -40,7 +40,6 @@
 
 namespace waypoint_maker
 {
-
 class WaypointFilter
 {
 private:
@@ -51,20 +50,24 @@ private:
   double accel_limit_, decel_limit_, resample_interval_;
   int velocity_offset_;
   bool resample_mode_;
+
 public:
   WaypointFilter();
   ~WaypointFilter();
   void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
-  void filterLaneWaypoint(autoware_msgs::lane *lane);
+  void filterLaneWaypoint(autoware_msgs::lane* lane);
+
 protected:
-  void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane *lane, std::vector&lt;double&gt; *curve_radius);
-  void getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt; *curve_radius);
-  const std::vector&lt;double&gt; calcVelParamFromVmax(const double vmax)const;
-  void createCurveList(const std::vector&lt;double&gt;&amp; curve_radius, std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list);
-  void limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx, autoware_msgs::lane *lane);
-  const std::vector&lt;double&gt; getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point)const;
-  const double calcSquareSum(const double x, const double y)const;
-  const double calcPathLength(const autoware_msgs::lane&amp; lane)const;
+  void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane,
+                            std::vector&lt;double&gt;* curve_radius);
+  void getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius);
+  const std::vector&lt;double&gt; calcVelParamFromVmax(const double vmax) const;
+  void createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
+                       std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list);
+  void limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx, autoware_msgs::lane* lane);
+  const std::vector&lt;double&gt; getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point) const;
+  const double calcSquareSum(const double x, const double y) const;
+  const double calcPathLength(const autoware_msgs::lane&amp; lane) const;
 };
 }
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="49" deleted_lines="38">
				<diff>@@ -47,13 +47,17 @@ WaypointLoaderNode::~WaypointLoaderNode()
 void WaypointLoaderNode::initPubSub()
 {
   // setup publisher
-  if(disable_decision_maker_){
-	  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/lane_waypoints_array", 10, true);
-  }else{
-	  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/based/lane_waypoints_array", 10, true);
+  if (disable_decision_maker_)
+  {
+    lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/lane_waypoints_array", 10, true);
+  }
+  else
+  {
+    lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/based/lane_waypoints_array", 10, true);
   }
   config_sub_ = nh_.subscribe("/config/waypoint_loader", 1, &amp;WaypointLoaderNode::configCallback, this);
-  output_cmd_sub_ = nh_.subscribe("/config/waypoint_loader_output", 1, &amp;WaypointLoaderNode::outputCommandCallback, this);
+  output_cmd_sub_ =
+      nh_.subscribe("/config/waypoint_loader_output", 1, &amp;WaypointLoaderNode::outputCommandCallback, this);
 }
 
 void WaypointLoaderNode::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
@@ -79,7 +83,7 @@ void WaypointLoaderNode::configCallback(const autoware_msgs::ConfigWaypointLoade
 void WaypointLoaderNode::outputCommandCallback(const std_msgs::Bool::ConstPtr&amp; output_cmd)
 {
   std::vector&lt;std::string&gt; dst_multi_file_path = multi_file_path_;
-  for(auto&amp; el : dst_multi_file_path)
+  for (auto&amp; el : dst_multi_file_path)
     el = addFileSuffix(el, "_filtered");
   saveLaneArray(dst_multi_file_path, output_lane_array_);
 }
@@ -91,47 +95,49 @@ const std::string addFileSuffix(std::string file_path, std::string suffix)
 
   tmp = file_path;
   const std::string::size_type idx_slash = tmp.find_last_of("/");
-  if(idx_slash != std::string::npos)tmp.erase(0, idx_slash);
+  if (idx_slash != std::string::npos)
+    tmp.erase(0, idx_slash);
   const std::string::size_type idx_dot = tmp.find_last_of(".");
   const std::string::size_type idx_dot_allpath = file_path.find_last_of(".");
-  if(idx_dot != std::string::npos &amp;&amp; idx_dot != tmp.size() - 1)
+  if (idx_dot != std::string::npos &amp;&amp; idx_dot != tmp.size() - 1)
     file_path.erase(idx_dot_allpath, file_path.size() - 1);
   file_path += suffix + ".csv";
   return file_path;
 }
 
-void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt; &amp;paths,
-                                         autoware_msgs::LaneArray *lane_array)
+void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt;&amp; paths, autoware_msgs::LaneArray* lane_array)
 {
   for (const auto&amp; el : paths)
   {
     autoware_msgs::lane lane;
     createLaneWaypoint(el, &amp;lane);
-    if(filtering_mode_)
+    if (filtering_mode_)
       filter_.filterLaneWaypoint(&amp;lane);
     lane_array-&gt;lanes.push_back(lane);
   }
 }
 
-void WaypointLoaderNode::saveLaneArray(const std::vector&lt;std::string&gt; &amp;paths, const autoware_msgs::LaneArray &amp;lane_array)
+void WaypointLoaderNode::saveLaneArray(const std::vector&lt;std::string&gt;&amp; paths,
+                                       const autoware_msgs::LaneArray&amp; lane_array)
 {
   unsigned long idx = 0;
   for (const auto&amp; file_path : paths)
   {
     std::ofstream ofs(file_path.c_str());
     ofs &lt;&lt; "x,y,z,yaw,velocity,change_flag,steering_flag,accel_flag,stop_flag,event_flag" &lt;&lt; std::endl;
-    for(const auto&amp; el : lane_array.lanes[idx].waypoints)
+    for (const auto&amp; el : lane_array.lanes[idx].waypoints)
     {
       ofs &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; el.pose.pose.position.x &lt;&lt; "," &lt;&lt; el.pose.pose.position.y &lt;&lt; ","
-          &lt;&lt; el.pose.pose.position.z &lt;&lt; "," &lt;&lt; tf::getYaw(el.pose.pose.orientation) &lt;&lt; "," &lt;&lt; mps2kmph(el.twist.twist.linear.x) &lt;&lt; ","
-          &lt;&lt; (int)el.change_flag &lt;&lt; "," &lt;&lt; (int)el.wpstate.steering_state &lt;&lt; "," &lt;&lt; (int)el.wpstate.accel_state &lt;&lt; ","
-          &lt;&lt; (int)el.wpstate.stopline_state &lt;&lt; "," &lt;&lt; (int)el.wpstate.event_state &lt;&lt; std::endl;
+          &lt;&lt; el.pose.pose.position.z &lt;&lt; "," &lt;&lt; tf::getYaw(el.pose.pose.orientation) &lt;&lt; ","
+          &lt;&lt; mps2kmph(el.twist.twist.linear.x) &lt;&lt; "," &lt;&lt; (int)el.change_flag &lt;&lt; "," &lt;&lt; (int)el.wpstate.steering_state
+          &lt;&lt; "," &lt;&lt; (int)el.wpstate.accel_state &lt;&lt; "," &lt;&lt; (int)el.wpstate.stopline_state &lt;&lt; ","
+          &lt;&lt; (int)el.wpstate.event_state &lt;&lt; std::endl;
     }
     idx++;
   }
 }
 
-void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, autoware_msgs::lane *lane)
+void WaypointLoaderNode::createLaneWaypoint(const std::string&amp; file_path, autoware_msgs::lane* lane)
 {
   if (!verifyFileConsistency(file_path.c_str()))
   {
@@ -153,7 +159,7 @@ void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, autowa
   lane-&gt;waypoints = wps;
 }
 
-void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps)
+void WaypointLoaderNode::loadWaypointsForVer1(const char* filename, std::vector&lt;autoware_msgs::waypoint&gt;* wps)
 {
   std::ifstream ifs(filename);
 
@@ -186,7 +192,7 @@ void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;
   }
 }
 
-void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line, autoware_msgs::waypoint *wp)
+void WaypointLoaderNode::parseWaypointForVer1(const std::string&amp; line, autoware_msgs::waypoint* wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
@@ -197,7 +203,7 @@ void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line, autoware_
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(columns[3]));
 }
 
-void WaypointLoaderNode::loadWaypointsForVer2(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps)
+void WaypointLoaderNode::loadWaypointsForVer2(const char* filename, std::vector&lt;autoware_msgs::waypoint&gt;* wps)
 {
   std::ifstream ifs(filename);
 
@@ -215,7 +221,7 @@ void WaypointLoaderNode::loadWaypointsForVer2(const char *filename, std::vector&lt;
   }
 }
 
-void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line, autoware_msgs::waypoint *wp)
+void WaypointLoaderNode::parseWaypointForVer2(const std::string&amp; line, autoware_msgs::waypoint* wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
@@ -227,7 +233,7 @@ void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line, autoware_
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(columns[4]));
 }
 
-void WaypointLoaderNode::loadWaypointsForVer3(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps)
+void WaypointLoaderNode::loadWaypointsForVer3(const char* filename, std::vector&lt;autoware_msgs::waypoint&gt;* wps)
 {
   std::ifstream ifs(filename);
 
@@ -239,7 +245,7 @@ void WaypointLoaderNode::loadWaypointsForVer3(const char *filename, std::vector&lt;
   std::vector&lt;std::string&gt; contents;
   parseColumns(line, &amp;contents);
 
-  //std::getline(ifs, line);  // remove second line
+  // std::getline(ifs, line);  // remove second line
   while (std::getline(ifs, line))
   {
     autoware_msgs::waypoint wp;
@@ -248,8 +254,8 @@ void WaypointLoaderNode::loadWaypointsForVer3(const char *filename, std::vector&lt;
   }
 }
 
-void WaypointLoaderNode::parseWaypointForVer3(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
-                                       autoware_msgs::waypoint *wp)
+void WaypointLoaderNode::parseWaypointForVer3(const std::string&amp; line, const std::vector&lt;std::string&gt;&amp; contents,
+                                              autoware_msgs::waypoint* wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
@@ -271,7 +277,7 @@ void WaypointLoaderNode::parseWaypointForVer3(const std::string &amp;line, const std
   wp-&gt;wpstate.event_state = (map.find("event_flag") != map.end()) ? std::stoi(map["event_flag"]) : 0;
 }
 
-FileFormat WaypointLoaderNode::checkFileFormat(const char *filename)
+FileFormat WaypointLoaderNode::checkFileFormat(const char* filename)
 {
   std::ifstream ifs(filename);
 
@@ -298,13 +304,14 @@ FileFormat WaypointLoaderNode::checkFileFormat(const char *filename)
   int num_of_columns = countColumns(line);
   ROS_INFO("columns size: %d", num_of_columns);
 
-  return ( num_of_columns == 3 ? FileFormat::ver1  // if data consists "x y z (velocity)"
-         : num_of_columns == 4 ? FileFormat::ver2  // if data consists "x y z yaw (velocity)
-                               : FileFormat::unknown
-          );
+  return (num_of_columns == 3 ? FileFormat::ver1  // if data consists "x y z (velocity)"
+                                :
+                                num_of_columns == 4 ? FileFormat::ver2  // if data consists "x y z yaw (velocity)
+                                                      :
+                                                      FileFormat::unknown);
 }
 
-bool WaypointLoaderNode::verifyFileConsistency(const char *filename)
+bool WaypointLoaderNode::verifyFileConsistency(const char* filename)
 {
   ROS_INFO("verify...");
   std::ifstream ifs(filename);
@@ -323,9 +330,11 @@ bool WaypointLoaderNode::verifyFileConsistency(const char *filename)
   std::string line;
   std::getline(ifs, line);  // remove first line
 
-  size_t ncol = format == FileFormat::ver1 ? 4 //x,y,z,velocity
-              : format == FileFormat::ver2 ? 5 //x,y,z,yaw,velocity
-              : countColumns(line);
+  size_t ncol = format == FileFormat::ver1 ? 4  // x,y,z,velocity
+                                             :
+                                             format == FileFormat::ver2 ? 5  // x,y,z,yaw,velocity
+                                                                          :
+                                                                          countColumns(line);
 
   while (std::getline(ifs, line))  // search from second line
   {
@@ -335,12 +344,14 @@ bool WaypointLoaderNode::verifyFileConsistency(const char *filename)
   return true;
 }
 
-void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns)
+void parseColumns(const std::string&amp; line, std::vector&lt;std::string&gt;* columns)
 {
   std::istringstream ss(line);
   std::string column;
-  while (std::getline(ss, column, ',')) {
-    while (1) {
+  while (std::getline(ss, column, ','))
+  {
+    while (1)
+    {
       auto res = std::find(column.begin(), column.end(), ' ');
       if (res == column.end())
         break;
@@ -351,7 +362,7 @@ void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns)
   }
 }
 
-size_t countColumns(const std::string &amp;line)
+size_t countColumns(const std::string&amp; line)
 {
   std::istringstream ss(line);
   size_t ncol = 0;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="17" deleted_lines="21">
				<diff>@@ -47,14 +47,13 @@
 
 namespace waypoint_maker
 {
-
 const std::string MULTI_LANE_CSV = "/tmp/driving_lane.csv";
 
 enum class FileFormat : int32_t
 {
-  ver1,  //x,y,z,(velocity)
-  ver2,  //x,y,z,yaw,(velocity)
-  ver3,  //first line consists on explanation of values
+  ver1,  // x,y,z,(velocity)
+  ver2,  // x,y,z,yaw,(velocity)
+  ver3,  // first line consists on explanation of values
 
   unknown = -1,
 };
@@ -73,12 +72,10 @@ inline double mps2kmph(double velocity_mps)
 class WaypointLoaderNode
 {
 public:
-
   WaypointLoaderNode();
   ~WaypointLoaderNode();
 
 private:
-
   // handle
   ros::NodeHandle nh_;
   ros::NodeHandle private_nh_;
@@ -103,24 +100,23 @@ private:
   // functions
   void configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
   void outputCommandCallback(const std_msgs::Bool::ConstPtr&amp; output_cmd);
-  void createLaneWaypoint(const std::string &amp;file_path, autoware_msgs::lane *lane);
-  void createLaneArray(const std::vector&lt;std::string&gt; &amp;paths, autoware_msgs::LaneArray *lane_array);
-  void saveLaneArray(const std::vector&lt;std::string&gt; &amp;paths, const autoware_msgs::LaneArray &amp;lane_array);
-
-  FileFormat checkFileFormat(const char *filename);
-  bool verifyFileConsistency(const char *filename);
-  void loadWaypointsForVer1(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
-  void parseWaypointForVer1(const std::string &amp;line, autoware_msgs::waypoint *wp);
-  void loadWaypointsForVer2(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
-  void parseWaypointForVer2(const std::string &amp;line, autoware_msgs::waypoint *wp);
-  void loadWaypointsForVer3(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
-  void parseWaypointForVer3(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
-                            autoware_msgs::waypoint *wp);
+  void createLaneWaypoint(const std::string&amp; file_path, autoware_msgs::lane* lane);
+  void createLaneArray(const std::vector&lt;std::string&gt;&amp; paths, autoware_msgs::LaneArray* lane_array);
+  void saveLaneArray(const std::vector&lt;std::string&gt;&amp; paths, const autoware_msgs::LaneArray&amp; lane_array);
+
+  FileFormat checkFileFormat(const char* filename);
+  bool verifyFileConsistency(const char* filename);
+  void loadWaypointsForVer1(const char* filename, std::vector&lt;autoware_msgs::waypoint&gt;* wps);
+  void parseWaypointForVer1(const std::string&amp; line, autoware_msgs::waypoint* wp);
+  void loadWaypointsForVer2(const char* filename, std::vector&lt;autoware_msgs::waypoint&gt;* wps);
+  void parseWaypointForVer2(const std::string&amp; line, autoware_msgs::waypoint* wp);
+  void loadWaypointsForVer3(const char* filename, std::vector&lt;autoware_msgs::waypoint&gt;* wps);
+  void parseWaypointForVer3(const std::string&amp; line, const std::vector&lt;std::string&gt;&amp; contents,
+                            autoware_msgs::waypoint* wp);
 };
 
 const std::string addFileSuffix(std::string file_path, std::string suffix);
-void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns);
+void parseColumns(const std::string&amp; line, std::vector&lt;std::string&gt;* columns);
 size_t countColumns(const std::string&amp; line);
-
 }
 #endif  // WAYPOINT_LOADER_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_node.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -33,7 +33,7 @@
 
 #include "waypoint_loader_core.h"
 
-int main(int argc, char **argv)
+int main(int argc, char** argv)
 {
   ros::init(argc, argv, "waypoint_loader");
   waypoint_maker::WaypointLoaderNode wln;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3e3b7a2f2c74f591ec67d5b57103a1c01156b212" author="Yuma">
		<msg>Add end point offset option</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" added_lines="9" deleted_lines="1">
				<diff>@@ -61,6 +61,7 @@ void WaypointFilter::initParameter(const autoware_msgs::ConfigWaypointLoader::Co
   resample_mode_ = conf-&gt;resample_mode;
   resample_interval_ = conf-&gt;resample_interval;
   velocity_offset_ = conf-&gt;velocity_offset;
+  end_point_offset_ = conf-&gt;end_point_offset;
   r_inf_ = 10 * r_th_;
 }
 
@@ -100,7 +101,7 @@ void WaypointFilter::filterLaneWaypoint(autoware_msgs::lane* lane)
     limitAccelDecel(vmax, vmin, start_idx, lane);
     limitAccelDecel(vmax, vmin, end_idx, lane);
   }
-  unsigned long end_id[2] = { 0, lane-&gt;waypoints.size() - 1 };
+  unsigned long end_id[2] = { 0, lane-&gt;waypoints.size() - 1 - end_point_offset_};
   for (int i = 0; i &lt; 2; i++)
   {
     const unsigned long idx = end_id[i];
@@ -109,6 +110,13 @@ void WaypointFilter::filterLaneWaypoint(autoware_msgs::lane* lane)
     if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
       continue;
     lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
+    if (i == 1)
+    {
+      for (int j = 0; j &lt; end_point_offset_; j++)
+      {
+        lane-&gt;waypoints[idx + j + 1].twist.twist.linear.x = vmin;
+      }
+    }
     limitAccelDecel(vmax, vmin, idx, lane);
   }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" added_lines="1" deleted_lines="0">
				<diff>@@ -50,6 +50,7 @@ private:
   double accel_limit_, decel_limit_, resample_interval_;
   int velocity_offset_;
   bool resample_mode_;
+  int end_point_offset_;
 
 public:
   WaypointFilter();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="662538674e72263223f8a653320e41024c614af0" author="Kosuke Murakami">
		<msg>Refactoring codes</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" added_lines="16" deleted_lines="4">
				<diff>@@ -85,11 +85,26 @@ private:
 	double getJskBBoxYaw(const jsk_recognition_msgs::BoundingBox jsk_bb);
 	void updateBB(UKF&amp; target);
 	double getIntersectCoef(const double vec1x, const double vec1y, const double vec2x, const double vec2y,
-                            const double p_x, const double p_y, const double cp_x, const double cp_y);
+													const double p_x, const double p_y, const double cp_x, const double cp_y);
 	void mergeOverSegmentation(const std::vector&lt;UKF&gt; targets);
 
 	void updateLabel(UKF target, autoware_msgs::CloudCluster&amp; cc);
 
+	void initTracker(autoware_msgs::CloudClusterArray input, double timestamp);
+	void secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; clusterVec, UKF &amp;target);
+
+	void updateTrackingNum(std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target);
+
+	void probabilisticDataAssociation(autoware_msgs::CloudClusterArray input,
+																		double dt, double det_explode_param, std::vector&lt;int&gt;&amp; matching_vec,
+																		std::vector&lt;double&gt;&amp; lambda_vec, UKF&amp; target, bool&amp; is_skip_target);
+	void makeNewTargets(double timestamp, autoware_msgs::CloudClusterArray input, std::vector&lt;int&gt; matching_vec);
+
+	void staticClassification();
+
+	void makeOutput(autoware_msgs::CloudClusterArray input,
+									autoware_msgs::CloudClusterArray&amp; output);
+
 	void tracker(autoware_msgs::CloudClusterArray input,
                  autoware_msgs::CloudClusterArray&amp; output);
 
@@ -98,7 +113,4 @@ public:
 	ImmUkfPda();
 };
 
-
-
-
 #endif /* OBJECT_TRACKING_IMM_UKF_JPDAF_H */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" added_lines="158" deleted_lines="158">
				<diff>@@ -20,238 +20,238 @@ class UKF
 {
 public:
 
-    ///* initially set to false, set to true in first call of ProcessMeasurement
-    bool is_initialized_;
+  ///* initially set to false, set to true in first call of ProcessMeasurement
+  bool is_initialized_;
 
-    ///* if this is false, laser measurements will be ignored (except for init)
-    bool use_laser_;
+  ///* if this is false, laser measurements will be ignored (except for init)
+  bool use_laser_;
 
-    ///* if this is false, radar measurements will be ignored (except for init)
-    bool use_radar_;
+  ///* if this is false, radar measurements will be ignored (except for init)
+  bool use_radar_;
 
 //    ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
-    Eigen::MatrixXd x_merge_;
+  Eigen::MatrixXd x_merge_;
 
-    ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
-    Eigen::MatrixXd x_cv_;
+  ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
+  Eigen::MatrixXd x_cv_;
 
-    ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
-    Eigen::MatrixXd x_ctrv_;
+  ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
+  Eigen::MatrixXd x_ctrv_;
 
-    ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
-    Eigen::MatrixXd x_rm_;
+  ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
+  Eigen::MatrixXd x_rm_;
 
 //    ///* state covariance matrix
-    Eigen::MatrixXd p_merge_;
+  Eigen::MatrixXd p_merge_;
 
-    ///* state covariance matrix
-    Eigen::MatrixXd p_cv_;
+  ///* state covariance matrix
+  Eigen::MatrixXd p_cv_;
 
-    ///* state covariance matrix
-    Eigen::MatrixXd p_ctrv_;
+  ///* state covariance matrix
+  Eigen::MatrixXd p_ctrv_;
 
-    ///* state covariance matrix
-    Eigen::MatrixXd p_rm_;
+  ///* state covariance matrix
+  Eigen::MatrixXd p_rm_;
 
 //    ///* predicted sigma points matrix
 //    Eigen::MatrixXd Xsig_pred_;
 
-    ///* predicted sigma points matrix
-    Eigen::MatrixXd x_sig_pred_cv_;
+  ///* predicted sigma points matrix
+  Eigen::MatrixXd x_sig_pred_cv_;
 
-    ///* predicted sigma points matrix
-    Eigen::MatrixXd x_sig_pred_ctrv_;
+  ///* predicted sigma points matrix
+  Eigen::MatrixXd x_sig_pred_ctrv_;
 
-    ///* predicted sigma points matrix
-    Eigen::MatrixXd x_sig_pred_rm_;
+  ///* predicted sigma points matrix
+  Eigen::MatrixXd x_sig_pred_rm_;
 
-    ///* time when the state is true, in us
-    long long time_;
+  ///* time when the state is true, in us
+  long long time_;
 
-    ///* Process noise standard deviation longitudinal acceleration in m/s^2
-    double std_a_cv_;
-    double std_a_ctrv_;
-    double std_a_rm_;
-    ///* Process noise standard deviation yaw acceleration in rad/s^2
+  ///* Process noise standard deviation longitudinal acceleration in m/s^2
+  double std_a_cv_;
+  double std_a_ctrv_;
+  double std_a_rm_;
+  ///* Process noise standard deviation yaw acceleration in rad/s^2
 //    double std_yawdd_;
-    // CTRV
-    double std_ctrv_yawdd_;
-    // CV
-    double std_cv_yawdd_;
+  // CTRV
+  double std_ctrv_yawdd_;
+  // CV
+  double std_cv_yawdd_;
 
-    double std_rm_yawdd_;
+  double std_rm_yawdd_;
 
-    ///* Laser measurement noise standard deviation position1 in m
-    double std_laspx_;
+  ///* Laser measurement noise standard deviation position1 in m
+  double std_laspx_;
 
-    ///* Laser measurement noise standard deviation position2 in m
-    double std_laspy_;
+  ///* Laser measurement noise standard deviation position2 in m
+  double std_laspy_;
 
-    ///* Radar measurement noise standard deviation radius in m
-    double std_radr_;
+  ///* Radar measurement noise standard deviation radius in m
+  double std_radr_;
 
-    ///* Radar measurement noise standard deviation angle in rad
-    double std_radphi_;
+  ///* Radar measurement noise standard deviation angle in rad
+  double std_radphi_;
 
-    ///* Radar measurement noise standard deviation radius change in m/s
-    double std_radrd_ ;
+  ///* Radar measurement noise standard deviation radius change in m/s
+  double std_radrd_ ;
 
-    ///* Weights of sigma points
-    Eigen::VectorXd weights_;
+  ///* Weights of sigma points
+  Eigen::VectorXd weights_;
 
-    ///* State dimension
-    int n_x_;
+  ///* State dimension
+  int n_x_;
 
-    ///* Augmented state dimension
-    int n_aug_;
+  ///* Augmented state dimension
+  int n_aug_;
 
-    ///* Sigma point spreading parameter
-    double lambda_;
+  ///* Sigma point spreading parameter
+  double lambda_;
 
-    ///* Augmented sigma point spreading parameter
-    double lambda_aug_;
+  ///* Augmented sigma point spreading parameter
+  double lambda_aug_;
 
 
-    int count_;
-    int count_empty_;
+  int count_;
+  int count_empty_;
 
-    double mode_match_prob_cv2cv_;
-    double mode_match_prob_ctrv2cv_;
-    double mode_match_prob_rm2cv_ ;
+  double mode_match_prob_cv2cv_;
+  double mode_match_prob_ctrv2cv_;
+  double mode_match_prob_rm2cv_ ;
 
-    double mode_match_prob_cv2ctrv_;
-    double mode_match_prob_ctrv2ctrv_ ;
-    double mode_match_prob_rm2ctrv_ ;
+  double mode_match_prob_cv2ctrv_;
+  double mode_match_prob_ctrv2ctrv_ ;
+  double mode_match_prob_rm2ctrv_ ;
 
-    double mode_match_prob_cv2rm_ ;
-    double mode_match_prob_ctrv2rm_ ;
-    double mode_match_prob_rm2rm_ ;
+  double mode_match_prob_cv2rm_ ;
+  double mode_match_prob_ctrv2rm_ ;
+  double mode_match_prob_rm2rm_ ;
 
-    double mode_match_prob_cv_;
+  double mode_match_prob_cv_;
 
-    double mode_match_prob_ctrv_;
+  double mode_match_prob_ctrv_;
 
-    double mode_match_prob_rm_;
+  double mode_match_prob_rm_;
 
-    double mode_prob_cv_;
-    double mode_prob_ctrv_;
-    double mode_prob_rm_;
+  double mode_prob_cv_;
+  double mode_prob_ctrv_;
+  double mode_prob_rm_;
 
-    std::vector&lt;double&gt; ini_u_;
+  std::vector&lt;double&gt; ini_u_;
 
-    std::vector&lt;double&gt; p1_;
+  std::vector&lt;double&gt; p1_;
 
-    std::vector&lt;double&gt; p2_;
+  std::vector&lt;double&gt; p2_;
 
-    std::vector&lt;double&gt; p3_;
+  std::vector&lt;double&gt; p3_;
 
-    Eigen::VectorXd z_pred_cv_;
-    Eigen::VectorXd z_pred_ctrv_;
-    Eigen::VectorXd z_pred_rm_;
+  Eigen::VectorXd z_pred_cv_;
+  Eigen::VectorXd z_pred_ctrv_;
+  Eigen::VectorXd z_pred_rm_;
 
-    Eigen::MatrixXd s_cv_;
-    Eigen::MatrixXd s_ctrv_;
-    Eigen::MatrixXd s_rm_;
-    // Eigen::MatrixXd rS_cv_;
-    // Eigen::MatrixXd rS_ctrv_;
-    // Eigen::MatrixXd rS_rm_;
+  Eigen::MatrixXd s_cv_;
+  Eigen::MatrixXd s_ctrv_;
+  Eigen::MatrixXd s_rm_;
+  // Eigen::MatrixXd rS_cv_;
+  // Eigen::MatrixXd rS_ctrv_;
+  // Eigen::MatrixXd rS_rm_;
 
-    Eigen::MatrixXd k_cv_;
-    Eigen::MatrixXd k_ctrv_;
-    Eigen::MatrixXd k_rm_;
+  Eigen::MatrixXd k_cv_;
+  Eigen::MatrixXd k_ctrv_;
+  Eigen::MatrixXd k_rm_;
 
-    double gamma_g_;
-    double pd_;
-    double pg_;
+  double gamma_g_;
+  double pd_;
+  double pg_;
 
-    int lifetime_;
-    bool is_static_;
+  int lifetime_;
+  bool is_static_;
 
-    // bounding box params
-    bool is_vis_bb_;
-    // todo: need initialization?
+  // bounding box params
+  bool is_vis_bb_;
+  // todo: need initialization?
 
-    jsk_recognition_msgs::BoundingBox jsk_bb_;
-    jsk_recognition_msgs::BoundingBox best_jsk_bb_;
-    // pcl::PointCloud&lt;pcl::PointXYZ&gt; bbox_;
-    // pcl::PointCloud&lt;pcl::PointXYZ&gt; bestBBox_;
-    double best_yaw_;
-    double bb_yaw_;
-    double bb_area_;
-    std::vector&lt;double&gt; bb_yaw_history_;
-    std::vector&lt;double&gt; bb_vel_history_;
-    std::vector&lt;double&gt; bb_area_history_;
+  jsk_recognition_msgs::BoundingBox jsk_bb_;
+  jsk_recognition_msgs::BoundingBox best_jsk_bb_;
+  // pcl::PointCloud&lt;pcl::PointXYZ&gt; bbox_;
+  // pcl::PointCloud&lt;pcl::PointXYZ&gt; bestBBox_;
+  double best_yaw_;
+  double bb_yaw_;
+  double bb_area_;
+  std::vector&lt;double&gt; bb_yaw_history_;
+  std::vector&lt;double&gt; bb_vel_history_;
+  std::vector&lt;double&gt; bb_area_history_;
 
-    // for env classification
-    Eigen::VectorXd init_meas_;
-    double dist_from_init_;
+  // for env classification
+  Eigen::VectorXd init_meas_;
+  double dist_from_init_;
 
 
-    std::vector&lt;Eigen::VectorXd&gt; local2local_;
-    std::vector&lt;double&gt; local2localYawVec_;
+  std::vector&lt;Eigen::VectorXd&gt; local2local_;
+  std::vector&lt;double&gt; local2localYawVec_;
 
-    double x_merge_yaw_;
+  double x_merge_yaw_;
 
-    int tracking_num_;
+  int tracking_num_;
 
-    /**
-     * Constructor
-     */
-    UKF();
+  /**
+   * Constructor
+   */
+  UKF();
 
-    /**
-     * Destructor
-     */
-    // virtual ~UKF();
+  /**
+   * Destructor
+   */
+  // virtual ~UKF();
 
-    void updateYawWithHighProb();
+  void updateYawWithHighProb();
 
-    void initialize(const Eigen::VectorXd z, const double timestamp);
+  void initialize(const Eigen::VectorXd z, const double timestamp);
 
-    void updateModeProb(const std::vector&lt;double&gt; lambda_vec);
+  void updateModeProb(const std::vector&lt;double&gt; lambda_vec);
 
-    void mergeEstimationAndCovariance();
+  void mergeEstimationAndCovariance();
 
-    void mixingProbability();
+  void mixingProbability();
 
-    void interaction();
+  void interaction();
 
 
-    /**
-     * ProcessMeasurement
-     * @param meas_package The latest measurement data of either radar or laser
-     */
-    void predictionIMMUKF(const double dt);
+  /**
+   * ProcessMeasurement
+   * @param meas_package The latest measurement data of either radar or laser
+   */
+  void predictionIMMUKF(const double dt);
 
-    void postProcessIMMUKF(const std::vector&lt;double&gt; lambda_vec);
+  void updateIMMUKF(const std::vector&lt;double&gt; lambda_vec);
 
 
-    void ctrv(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
-        const double nu_a,const  double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state);
+  void ctrv(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
+      const double nu_a,const  double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state);
 
-    void cv(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
-        const double nu_a,const  double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state);
+  void cv(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
+      const double nu_a,const  double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state);
 
-    void randomMotion(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
-        const double nu_a,const  double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state);
-    /**
-     * Prediction Predicts sigma points, the state, and the state covariance
-     * matrix
-     * @param delta_t Time between k and k+1 in s
-     */
-    void prediction(const double delta_t, const int model_ind);
+  void randomMotion(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
+      const double nu_a,const  double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state);
+  /**
+   * Prediction Predicts sigma points, the state, and the state covariance
+   * matrix
+   * @param delta_t Time between k and k+1 in s
+   */
+  void prediction(const double delta_t, const int model_ind);
 
-    /**
-     * Updates the state and the state covariance matrix using a laser measurement
-     * @param meas_package The measurement at k+1
-     */
-    void updateLidar(const int model_ind);
+  /**
+   * Updates the state and the state covariance matrix using a laser measurement
+   * @param meas_package The measurement at k+1
+   */
+  void updateLidar(const int model_ind);
 
-    /**
-     * Updates the state and the state covariance matrix using a radar measurement
-     * @param meas_package The measurement at k+1
-     */
-    // void UpdateRadar(MeasurementPackage meas_package, int modelInd);
+  /**
+   * Updates the state and the state covariance matrix using a radar measurement
+   * @param meas_package The measurement at k+1
+   */
+  // void UpdateRadar(MeasurementPackage meas_package, int modelInd);
 };
 
 #endif /* UKF_H */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="674" deleted_lines="608">
				<diff>@@ -52,8 +52,6 @@ int g_count = 0;
 
 ImmUkfPda::ImmUkfPda()
 {
-
-
   ros::NodeHandle private_nh_("~");
   private_nh_.param&lt;bool&gt;("init_", init_, false);
   private_nh_.param&lt;double&gt;("gamma_g_", gamma_g_, 9.22);
@@ -77,84 +75,82 @@ ImmUkfPda::ImmUkfPda()
 
 void ImmUkfPda::callBack(autoware_msgs::CloudClusterArray input)
 {
-    autoware_msgs::CloudClusterArray output;
-
-    // only transform pose(clusteArray.clusters.bouding_box.pose)
-    transformPoseToGlobal(input);
-    tracker(input, output);
-    transformPoseToLocal(output);
-    // output = input;
-    pub_cloud_array_.publish(output);
-    g_count ++;
-    // std::cout &lt;&lt; "Frame " &lt;&lt;g_count&lt;&lt; "------------------------------------------------"&lt;&lt;std::endl;
-    // std::cout &lt;&lt; "target size "&lt;&lt;targets_.size() &lt;&lt; std::endl;
+  autoware_msgs::CloudClusterArray output;
+
+  // only transform pose(clusteArray.clusters.bouding_box.pose)
+  transformPoseToGlobal(input);
+  tracker(input, output);
+  transformPoseToLocal(output);
+  // output = input;
+  pub_cloud_array_.publish(output);
+  g_count ++;
+  // std::cout &lt;&lt; "Frame " &lt;&lt;g_count&lt;&lt; "------------------------------------------------"&lt;&lt;std::endl;
+  // std::cout &lt;&lt; "target size "&lt;&lt;targets_.size() &lt;&lt; std::endl;
 }
 
 void ImmUkfPda::transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input)
 {
-    for(size_t i = 0; i &lt; input.clusters.size(); i ++)
-    {
-        geometry_msgs::PoseStamped pose_in, pose_out;
-
-        pose_in.header = input.header;
-        pose_in.pose = input.clusters[i].bounding_box.pose;
-        tran_-&gt;waitForTransform("/velodyne", "/world",input.header.stamp, ros::Duration(3.0));
-        tran_-&gt;transformPose("world", ros::Time(0), pose_in, input.header.frame_id, pose_out);
-        input.clusters[i].bounding_box.pose = pose_out.pose;
-    }
+  for(size_t i = 0; i &lt; input.clusters.size(); i ++)
+  {
+    geometry_msgs::PoseStamped pose_in, pose_out;
+
+    pose_in.header = input.header;
+    pose_in.pose = input.clusters[i].bounding_box.pose;
+    tran_-&gt;waitForTransform("/velodyne", "/world",input.header.stamp, ros::Duration(3.0));
+    tran_-&gt;transformPose("world", ros::Time(0), pose_in, input.header.frame_id, pose_out);
+    input.clusters[i].bounding_box.pose = pose_out.pose;
+  }
 }
 
 void ImmUkfPda::transformPoseToLocal(autoware_msgs::CloudClusterArray&amp; output)
 {
-    for(size_t i = 0; i &lt; output.clusters.size(); i ++)
-    {
-        geometry_msgs::PoseStamped pose_in, pose_out;
+  for(size_t i = 0; i &lt; output.clusters.size(); i ++)
+  {
+    geometry_msgs::PoseStamped pose_in, pose_out;
 
-        pose_in.header = output.header;
-        pose_in.header.frame_id = "world";
-        pose_in.pose = output.clusters[i].bounding_box.pose;
+    pose_in.header = output.header;
+    pose_in.header.frame_id = "world";
+    pose_in.pose = output.clusters[i].bounding_box.pose;
 
-        tran_-&gt;waitForTransform("/world", "/velodyne",ros::Time(0), ros::Duration(3.0));
-        tran_-&gt;transformPose("velodyne", ros::Time(0), pose_in, "world", pose_out);
-        pose_out.header.frame_id = output.header.frame_id = "velodyne";
-        output.clusters[i].bounding_box.pose = pose_out.pose;
-    }
+    tran_-&gt;waitForTransform("/world", "/velodyne",ros::Time(0), ros::Duration(3.0));
+    tran_-&gt;transformPose("velodyne", ros::Time(0), pose_in, "world", pose_out);
+    pose_out.header.frame_id = output.header.frame_id = "velodyne";
+    output.clusters[i].bounding_box.pose = pose_out.pose;
+  }
 }
 
 
 void ImmUkfPda::findMaxZandS(const UKF target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s)
 {
-    double cv_det   = target.s_cv_.determinant();
-    double ctrv_det = target.s_ctrv_.determinant();
-    double rm_det   = target.s_rm_.determinant();
+  double cv_det   = target.s_cv_.determinant();
+  double ctrv_det = target.s_ctrv_.determinant();
+  double rm_det   = target.s_rm_.determinant();
 
-    if(cv_det &gt; ctrv_det)
+  if(cv_det &gt; ctrv_det)
+  {
+    if(cv_det &gt; rm_det)
     {
-        if(cv_det &gt; rm_det)
-        {
-            max_det_z = target.z_pred_cv_;
-            max_det_s = target.s_cv_;
-        }
-        else
-        {
-            max_det_z = target.z_pred_rm_;
-            max_det_s = target.s_rm_;
-        }
+      max_det_z = target.z_pred_cv_;
+      max_det_s = target.s_cv_;
     }
-    else{
-        if(ctrv_det &gt; rm_det)
-        {
-            max_det_z = target.z_pred_ctrv_;
-            max_det_s = target.s_ctrv_;
-        }
-        else
-        {
-            max_det_z = target.z_pred_rm_;
-            max_det_s = target.s_rm_;
-        }
+    else
+    {
+      max_det_z = target.z_pred_rm_;
+      max_det_s = target.s_rm_;
     }
-
-
+  }
+  else{
+    if(ctrv_det &gt; rm_det)
+    {
+      max_det_z = target.z_pred_ctrv_;
+      max_det_s = target.s_ctrv_;
+    }
+    else
+    {
+      max_det_z = target.z_pred_rm_;
+      max_det_s = target.s_rm_;
+    }
+  }
 }
 
 void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray input, UKF&amp; target,
@@ -163,267 +159,264 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
                                      std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
                                      std::vector&lt;int&gt;&amp; matching_vec)
 {
-
-    int count = 0;
-    bool second_init_done = false;
-    // double smallest_nis = 999;
-    double smallest_nis = std::numeric_limits&lt;double&gt;::max();
-    autoware_msgs::CloudCluster smallest_meas_cluster;
-    for(size_t i = 0; i &lt; input.clusters.size(); i++)
-    {
-        double x = input.clusters[i].bounding_box.pose.position.x;
-        double y = input.clusters[i].bounding_box.pose.position.y;
-        Eigen::VectorXd meas = Eigen::VectorXd(2);
-        meas &lt;&lt; x, y;
-
-        Eigen::VectorXd diff = meas - max_det_z;
-        double nis = diff.transpose()*max_det_s.inverse()*diff;
-        // cout &lt;&lt;"nis: " &lt;&lt;nis &lt;&lt; endl;
-        if(nis &lt; gamma_g_)
-        { // x^2 99% range
-            count ++;
-            if(matching_vec[i] == IsMatch::False) target.lifetime_ ++;
-
-            // pick one meas with smallest nis
-            if(second_init)
-            {
-                if(nis &lt; smallest_nis)
-                {
-                smallest_nis = nis;
-                smallest_meas_cluster = input.clusters[i];
-                // measVec.push_back(meas);
-                matching_vec[i] = IsMatch::True;
-                second_init_done = true;
-                }
-            }
-            else
-            {
-                // cout &lt;&lt; "check cp "&lt;&lt;input.clusters[i].bounding_box.pose.position.x &lt;&lt; " "&lt;&lt; input.clusters[i].bounding_box.pose.position.y &lt;&lt; endl;
-                cluster_vec.push_back(input.clusters[i]);
-                matching_vec[i] = IsMatch::True;
-            }
+  int count = 0;
+  bool second_init_done = false;
+  // double smallest_nis = 999;
+  double smallest_nis = std::numeric_limits&lt;double&gt;::max();
+  autoware_msgs::CloudCluster smallest_meas_cluster;
+  for(size_t i = 0; i &lt; input.clusters.size(); i++)
+  {
+    double x = input.clusters[i].bounding_box.pose.position.x;
+    double y = input.clusters[i].bounding_box.pose.position.y;
+    Eigen::VectorXd meas = Eigen::VectorXd(2);
+    meas &lt;&lt; x, y;
+
+    Eigen::VectorXd diff = meas - max_det_z;
+    double nis = diff.transpose()*max_det_s.inverse()*diff;
+    // cout &lt;&lt;"nis: " &lt;&lt;nis &lt;&lt; endl;
+    if(nis &lt; gamma_g_)
+    { // x^2 99% range
+      count ++;
+      if(matching_vec[i] == IsMatch::False) target.lifetime_ ++;
+      // pick one meas with smallest nis
+      if(second_init)
+      {
+        if(nis &lt; smallest_nis)
+        {
+        smallest_nis = nis;
+        smallest_meas_cluster = input.clusters[i];
+        // measVec.push_back(meas);
+        matching_vec[i] = IsMatch::True;
+        second_init_done = true;
         }
+      }
+      else
+      {
+        // cout &lt;&lt; "check cp "&lt;&lt;input.clusters[i].bounding_box.pose.position.x &lt;&lt; " "&lt;&lt; input.clusters[i].bounding_box.pose.position.y &lt;&lt; endl;
+        cluster_vec.push_back(input.clusters[i]);
+        matching_vec[i] = IsMatch::True;
+      }
     }
-    if(second_init_done) cluster_vec.push_back(smallest_meas_cluster);
+  }
+  if(second_init_done) cluster_vec.push_back(smallest_meas_cluster);
 }
 
 void ImmUkfPda::filterPDA(UKF&amp; target,
                           const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
                           std::vector&lt;double&gt;&amp; lambda_vec)
 {
-    // calculating association probability
-    double num_meas = cluster_vec.size();
-    double b = 2*num_meas*(1-p_d_*p_g_)/(gamma_g_*p_d_);
-    double e_cv_sum   = 0;
-    double e_ctrv_sum = 0;
-    double e_rm_sum   = 0;
-
-    std::vector&lt;double&gt; e_cv_vec;
-    std::vector&lt;double&gt; e_ctrv_vec;
-    std::vector&lt;double&gt; e_rm_vec;
-
-    std::vector&lt;Eigen::VectorXd&gt; diff_cv_vec;
-    std::vector&lt;Eigen::VectorXd&gt; diff_ctrv_vec;
-    std::vector&lt;Eigen::VectorXd&gt; diff_rm_vec;
-
-    for(size_t i = 0; i &lt; num_meas; i++)
-    {
-        Eigen::VectorXd meas_vec = Eigen::VectorXd(2);
-        meas_vec(0) = cluster_vec[i].bounding_box.pose.position.x;
-        meas_vec(1) = cluster_vec[i].bounding_box.pose.position.y;
-
-        Eigen::VectorXd diff_cv   = meas_vec - target.z_pred_cv_;
-        Eigen::VectorXd diff_ctrv = meas_vec - target.z_pred_ctrv_;
-        Eigen::VectorXd diff_rm   = meas_vec - target.z_pred_rm_;
-
-        diff_cv_vec.push_back(diff_cv);
-        diff_ctrv_vec.push_back(diff_ctrv);
-        diff_rm_vec.push_back(diff_rm);
-
-        double e_cv   = exp(  -0.5*diff_cv.transpose()*  target.s_cv_.inverse()  *diff_cv);
-        double e_ctrv = exp(-0.5*diff_ctrv.transpose()*  target.s_ctrv_.inverse()*diff_ctrv);
-        double e_rm   = exp(  -0.5*diff_rm.transpose()*  target.s_rm_.inverse()  *diff_rm);
-
-        e_cv_vec.push_back(e_cv);
-        e_ctrv_vec.push_back(e_ctrv);
-        e_rm_vec.push_back(e_rm);
-
-        e_cv_sum   += e_cv;
-        e_ctrv_sum += e_ctrv;
-        e_rm_sum   += e_rm;
-    }
-    double beta_cv_zero   = b/(b+e_cv_sum);
-    double beta_ctrv_zero = b/(b+e_ctrv_sum);
-    double beta_rm_zero   = b/(b+e_rm_sum);
-
-    std::vector&lt;double&gt; beta_cv;
-    std::vector&lt;double&gt; beta_ctrv;
-    std::vector&lt;double&gt; beta_rm;
+  // calculating association probability
+  double num_meas = cluster_vec.size();
+  double b = 2*num_meas*(1-p_d_*p_g_)/(gamma_g_*p_d_);
+  double e_cv_sum   = 0;
+  double e_ctrv_sum = 0;
+  double e_rm_sum   = 0;
+
+  std::vector&lt;double&gt; e_cv_vec;
+  std::vector&lt;double&gt; e_ctrv_vec;
+  std::vector&lt;double&gt; e_rm_vec;
+
+  std::vector&lt;Eigen::VectorXd&gt; diff_cv_vec;
+  std::vector&lt;Eigen::VectorXd&gt; diff_ctrv_vec;
+  std::vector&lt;Eigen::VectorXd&gt; diff_rm_vec;
+
+  for(size_t i = 0; i &lt; num_meas; i++)
+  {
+    Eigen::VectorXd meas_vec = Eigen::VectorXd(2);
+    meas_vec(0) = cluster_vec[i].bounding_box.pose.position.x;
+    meas_vec(1) = cluster_vec[i].bounding_box.pose.position.y;
 
+    Eigen::VectorXd diff_cv   = meas_vec - target.z_pred_cv_;
+    Eigen::VectorXd diff_ctrv = meas_vec - target.z_pred_ctrv_;
+    Eigen::VectorXd diff_rm   = meas_vec - target.z_pred_rm_;
 
-    for(size_t i = 0; i &lt; num_meas; i++)
-    {
-        double temp_cv   = e_cv_vec[i]/(b+e_cv_sum);
-        double temp_ctrv = e_ctrv_vec[i]/(b+e_ctrv_sum);
-        double temp_rm   = e_rm_vec[i]/(b+e_rm_sum);
+    diff_cv_vec.push_back(diff_cv);
+    diff_ctrv_vec.push_back(diff_ctrv);
+    diff_rm_vec.push_back(diff_rm);
 
-        beta_cv.push_back(temp_cv);
-        beta_ctrv.push_back(temp_ctrv);
-        beta_rm.push_back(temp_rm);
-    }
-    Eigen::VectorXd sigma_x_cv;
-    Eigen::VectorXd sigma_x_ctrv;
-    Eigen::VectorXd sigma_x_rm;
-    sigma_x_cv.setZero(2);
-    sigma_x_ctrv.setZero(2);
-    sigma_x_rm.setZero(2);
-
-    for(size_t i = 0; i &lt; num_meas; i++)
-    {
-        sigma_x_cv   += beta_cv[i]*diff_cv_vec[i];
-        sigma_x_ctrv += beta_ctrv[i]*diff_ctrv_vec[i];
-        sigma_x_rm   += beta_rm[i]*diff_rm_vec[i];
-    }
+    double e_cv   = exp(  -0.5*diff_cv.transpose()*  target.s_cv_.inverse()  *diff_cv);
+    double e_ctrv = exp(-0.5*diff_ctrv.transpose()*  target.s_ctrv_.inverse()*diff_ctrv);
+    double e_rm   = exp(  -0.5*diff_rm.transpose()*  target.s_rm_.inverse()  *diff_rm);
 
-    Eigen::MatrixXd sigma_p_cv;
-    Eigen::MatrixXd sigma_p_ctrv;
-    Eigen::MatrixXd sigma_p_rm;
-    sigma_p_cv.setZero(2,2);
-    sigma_p_ctrv.setZero(2,2);
-    sigma_p_rm.setZero(2,2);
-    for(size_t i = 0; i &lt; num_meas; i++)
+    e_cv_vec.push_back(e_cv);
+    e_ctrv_vec.push_back(e_ctrv);
+    e_rm_vec.push_back(e_rm);
 
-    {
-        sigma_p_cv   += (beta_cv[i]  *diff_cv_vec[i]  *diff_cv_vec[i].transpose()     - sigma_x_cv*sigma_x_cv.transpose());
-        sigma_p_ctrv += (beta_ctrv[i]*diff_ctrv_vec[i]*diff_ctrv_vec[i].transpose()   - sigma_x_ctrv*sigma_x_ctrv.transpose());
-        sigma_p_rm   += (beta_rm[i]  *diff_rm_vec[i]  *diff_rm_vec[i].transpose()     - sigma_x_rm*sigma_x_rm.transpose());
-    }
+    e_cv_sum   += e_cv;
+    e_ctrv_sum += e_ctrv;
+    e_rm_sum   += e_rm;
+  }
+  double beta_cv_zero   = b/(b+e_cv_sum);
+  double beta_ctrv_zero = b/(b+e_ctrv_sum);
+  double beta_rm_zero   = b/(b+e_rm_sum);
 
-    // update x and P
-    target.x_cv_   = target.x_cv_   + target.k_cv_*sigma_x_cv;
-    target.x_ctrv_ = target.x_ctrv_ + target.k_ctrv_*sigma_x_ctrv;
-    target.x_rm_   = target.x_rm_   + target.k_rm_*sigma_x_rm;
+  std::vector&lt;double&gt; beta_cv;
+  std::vector&lt;double&gt; beta_ctrv;
+  std::vector&lt;double&gt; beta_rm;
 
-    while (target.x_cv_(3)&gt; M_PI) target.x_cv_(3) -= 2.*M_PI;
-    while (target.x_cv_(3)&lt;-M_PI) target.x_cv_(3) += 2.*M_PI;
-    while (target.x_ctrv_(3)&gt; M_PI) target.x_ctrv_(3) -= 2.*M_PI;
-    while (target.x_ctrv_(3)&lt;-M_PI) target.x_ctrv_(3) += 2.*M_PI;
-    while (target.x_rm_(3)&gt; M_PI) target.x_rm_(3) -= 2.*M_PI;
-    while (target.x_rm_(3)&lt;-M_PI) target.x_rm_(3) += 2.*M_PI;
 
-    if(num_meas != 0)
-    {
-    	target.p_cv_   = beta_cv_zero*target.p_cv_ +
-                  (1-beta_cv_zero)*(target.p_cv_ - target.k_cv_*target.s_cv_*target.k_cv_.transpose()) +
-                  target.k_cv_*sigma_p_cv*target.k_cv_.transpose();
-	    target.p_ctrv_ = beta_ctrv_zero*target.p_ctrv_ +
-	                  (1-beta_ctrv_zero)*(target.p_ctrv_ - target.k_ctrv_*target.s_ctrv_*target.k_ctrv_.transpose()) +
-	                  target.k_ctrv_*sigma_p_ctrv*target.k_ctrv_.transpose();
-	    target.p_rm_   = beta_rm_zero*target.p_rm_ +
-	                  (1-beta_rm_zero)*(target.p_rm_ - target.k_rm_*target.s_rm_*target.k_rm_.transpose()) +
-	                  target.k_rm_*sigma_p_rm*target.k_rm_.transpose();
-    }
-    else
-    {
-    	target.p_cv_   = target.p_cv_   - target.k_cv_  *target.s_cv_  *target.k_cv_.transpose();
-	    target.p_ctrv_ = target.p_ctrv_ - target.k_ctrv_*target.s_ctrv_*target.k_ctrv_.transpose();
-	    target.p_rm_   = target.p_rm_   - target.k_rm_  *target.s_rm_  *target.k_rm_.transpose();
-    }
+  for(size_t i = 0; i &lt; num_meas; i++)
+  {
+    double temp_cv   = e_cv_vec[i]/(b+e_cv_sum);
+    double temp_ctrv = e_ctrv_vec[i]/(b+e_ctrv_sum);
+    double temp_rm   = e_rm_vec[i]/(b+e_rm_sum);
+
+    beta_cv.push_back(temp_cv);
+    beta_ctrv.push_back(temp_ctrv);
+    beta_rm.push_back(temp_rm);
+  }
+  Eigen::VectorXd sigma_x_cv;
+  Eigen::VectorXd sigma_x_ctrv;
+  Eigen::VectorXd sigma_x_rm;
+  sigma_x_cv.setZero(2);
+  sigma_x_ctrv.setZero(2);
+  sigma_x_rm.setZero(2);
+
+  for(size_t i = 0; i &lt; num_meas; i++)
+  {
+    sigma_x_cv   += beta_cv[i]*diff_cv_vec[i];
+    sigma_x_ctrv += beta_ctrv[i]*diff_ctrv_vec[i];
+    sigma_x_rm   += beta_rm[i]*diff_rm_vec[i];
+  }
+
+  Eigen::MatrixXd sigma_p_cv;
+  Eigen::MatrixXd sigma_p_ctrv;
+  Eigen::MatrixXd sigma_p_rm;
+  sigma_p_cv.setZero(2,2);
+  sigma_p_ctrv.setZero(2,2);
+  sigma_p_rm.setZero(2,2);
+  for(size_t i = 0; i &lt; num_meas; i++)
+  {
+    sigma_p_cv   += (beta_cv[i]  *diff_cv_vec[i]  *diff_cv_vec[i].transpose()     - sigma_x_cv*sigma_x_cv.transpose());
+    sigma_p_ctrv += (beta_ctrv[i]*diff_ctrv_vec[i]*diff_ctrv_vec[i].transpose()   - sigma_x_ctrv*sigma_x_ctrv.transpose());
+    sigma_p_rm   += (beta_rm[i]  *diff_rm_vec[i]  *diff_rm_vec[i].transpose()     - sigma_x_rm*sigma_x_rm.transpose());
+  }
+
+  // update x and P
+  target.x_cv_   = target.x_cv_   + target.k_cv_*sigma_x_cv;
+  target.x_ctrv_ = target.x_ctrv_ + target.k_ctrv_*sigma_x_ctrv;
+  target.x_rm_   = target.x_rm_   + target.k_rm_*sigma_x_rm;
+
+  while (target.x_cv_(3)&gt; M_PI) target.x_cv_(3) -= 2.*M_PI;
+  while (target.x_cv_(3)&lt;-M_PI) target.x_cv_(3) += 2.*M_PI;
+  while (target.x_ctrv_(3)&gt; M_PI) target.x_ctrv_(3) -= 2.*M_PI;
+  while (target.x_ctrv_(3)&lt;-M_PI) target.x_ctrv_(3) += 2.*M_PI;
+  while (target.x_rm_(3)&gt; M_PI) target.x_rm_(3) -= 2.*M_PI;
+  while (target.x_rm_(3)&lt;-M_PI) target.x_rm_(3) += 2.*M_PI;
+
+  if(num_meas != 0)
+  {
+    target.p_cv_   = beta_cv_zero*target.p_cv_ +
+                (1-beta_cv_zero)*(target.p_cv_ - target.k_cv_*target.s_cv_*target.k_cv_.transpose()) +
+                target.k_cv_*sigma_p_cv*target.k_cv_.transpose();
+    target.p_ctrv_ = beta_ctrv_zero*target.p_ctrv_ +
+                  (1-beta_ctrv_zero)*(target.p_ctrv_ - target.k_ctrv_*target.s_ctrv_*target.k_ctrv_.transpose()) +
+                  target.k_ctrv_*sigma_p_ctrv*target.k_ctrv_.transpose();
+    target.p_rm_   = beta_rm_zero*target.p_rm_ +
+                  (1-beta_rm_zero)*(target.p_rm_ - target.k_rm_*target.s_rm_*target.k_rm_.transpose()) +
+                  target.k_rm_*sigma_p_rm*target.k_rm_.transpose();
+  }
+  else
+  {
+    target.p_cv_   = target.p_cv_   - target.k_cv_  *target.s_cv_  *target.k_cv_.transpose();
+    target.p_ctrv_ = target.p_ctrv_ - target.k_ctrv_*target.s_ctrv_*target.k_ctrv_.transpose();
+    target.p_rm_   = target.p_rm_   - target.k_rm_  *target.s_rm_  *target.k_rm_.transpose();
+  }
 
-    Eigen::VectorXd max_det_z;
-    Eigen::MatrixXd max_det_s;
+  Eigen::VectorXd max_det_z;
+  Eigen::MatrixXd max_det_s;
 
-    findMaxZandS(target, max_det_z, max_det_s);
-    double Vk =  M_PI *sqrt(gamma_g_ * max_det_s.determinant());
+  findMaxZandS(target, max_det_z, max_det_s);
+  double Vk =  M_PI *sqrt(gamma_g_ * max_det_s.determinant());
 
-    double lambda_cv, lambda_ctrv, lambda_rm;
-    if(num_meas != 0)
-    {
-    	lambda_cv   = (1 - p_g_*p_d_)/pow(Vk, num_meas) +
-	                        p_d_*pow(Vk, 1-num_meas)*e_cv_sum/(num_meas*sqrt(2*M_PI*target.s_cv_.determinant()));
-	    lambda_ctrv = (1 - p_g_*p_d_)/pow(Vk, num_meas) +
-	                        p_d_*pow(Vk, 1-num_meas)*e_ctrv_sum/(num_meas*sqrt(2*M_PI*target.s_ctrv_.determinant()));
-	    lambda_rm   = (1 - p_g_*p_d_)/pow(Vk, num_meas) +
-	                        p_d_*pow(Vk, 1-num_meas)*e_rm_sum/(num_meas*sqrt(2*M_PI*target.s_rm_.determinant()));
-    }
-    else
-    {
-    	lambda_cv   = (1 - p_g_*p_d_)/pow(Vk, num_meas);
-	    lambda_ctrv = (1 - p_g_*p_d_)/pow(Vk, num_meas);
-	    lambda_rm   = (1 - p_g_*p_d_)/pow(Vk, num_meas);
-    }
-    // cout &lt;&lt;endl&lt;&lt; "lambda: "&lt;&lt;endl&lt;&lt;lambdaCV &lt;&lt; " "&lt;&lt; lambdaCTRV&lt;&lt;" "&lt;&lt; lambdaRM &lt;&lt; endl;
-    lambda_vec.push_back(lambda_cv);
-    lambda_vec.push_back(lambda_ctrv);
-    lambda_vec.push_back(lambda_rm);
+  double lambda_cv, lambda_ctrv, lambda_rm;
+  if(num_meas != 0)
+  {
+    lambda_cv   = (1 - p_g_*p_d_)/pow(Vk, num_meas) +
+                        p_d_*pow(Vk, 1-num_meas)*e_cv_sum/(num_meas*sqrt(2*M_PI*target.s_cv_.determinant()));
+    lambda_ctrv = (1 - p_g_*p_d_)/pow(Vk, num_meas) +
+                        p_d_*pow(Vk, 1-num_meas)*e_ctrv_sum/(num_meas*sqrt(2*M_PI*target.s_ctrv_.determinant()));
+    lambda_rm   = (1 - p_g_*p_d_)/pow(Vk, num_meas) +
+                        p_d_*pow(Vk, 1-num_meas)*e_rm_sum/(num_meas*sqrt(2*M_PI*target.s_rm_.determinant()));
+  }
+  else
+  {
+    lambda_cv   = (1 - p_g_*p_d_)/pow(Vk, num_meas);
+    lambda_ctrv = (1 - p_g_*p_d_)/pow(Vk, num_meas);
+    lambda_rm   = (1 - p_g_*p_d_)/pow(Vk, num_meas);
+  }
+  // cout &lt;&lt;endl&lt;&lt; "lambda: "&lt;&lt;endl&lt;&lt;lambdaCV &lt;&lt; " "&lt;&lt; lambdaCTRV&lt;&lt;" "&lt;&lt; lambdaRM &lt;&lt; endl;
+  lambda_vec.push_back(lambda_cv);
+  lambda_vec.push_back(lambda_ctrv);
+  lambda_vec.push_back(lambda_rm);
 }
 
 void ImmUkfPda::getNearestEuclidCluster(const UKF target,
                                         const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
                                         autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist){
-    int min_ind = 0;
-    double px = target.x_merge_(0);
-    double py = target.x_merge_(1);
-    // cout &lt;&lt; "px py"&lt;&lt; px &lt;&lt; " "&lt;&lt; py &lt;&lt; endl;
-    for (size_t i = 0; i &lt; cluster_vec.size(); i++)
+  int min_ind = 0;
+  double px = target.x_merge_(0);
+  double py = target.x_merge_(1);
+  // cout &lt;&lt; "px py"&lt;&lt; px &lt;&lt; " "&lt;&lt; py &lt;&lt; endl;
+  for (size_t i = 0; i &lt; cluster_vec.size(); i++)
+  {
+    double meas_x = cluster_vec[i].bounding_box.pose.position.x;
+    double meas_y = cluster_vec[i].bounding_box.pose.position.y;
+    // cout &lt;&lt; "measx measY "&lt;&lt; measX &lt;&lt; " "&lt;&lt; measY &lt;&lt; endl;
+    double dist = sqrt((px-meas_x)*(px-meas_x)+(py-meas_y)*(py-meas_y));
+    if(dist &lt; min_dist)
     {
-        double meas_x = cluster_vec[i].bounding_box.pose.position.x;
-        double meas_y = cluster_vec[i].bounding_box.pose.position.y;
-        // cout &lt;&lt; "measx measY "&lt;&lt; measX &lt;&lt; " "&lt;&lt; measY &lt;&lt; endl;
-        double dist = sqrt((px-meas_x)*(px-meas_x)+(py-meas_y)*(py-meas_y));
-        if(dist &lt; min_dist)
-        {
-            min_dist = dist;
-            min_ind = i;
-        }
+      min_dist = dist;
+      min_ind = i;
     }
-    // assert(clusterVec[minInd].rows() == 2);
-    cluster = cluster_vec[min_ind];
+  }
+  // assert(clusterVec[minInd].rows() == 2);
+  cluster = cluster_vec[min_ind];
 }
 
 
 void ImmUkfPda::associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
                             UKF&amp; target)
 {
-    //skip if no validated measurement
-    if(cluster_vec.size() == 0)
-    {
-        return;
-    }
-    // cout &lt;&lt; target.tracking_num_ &lt;&lt; " "&lt;&lt; target.lifetime_ &lt;&lt; endl;
-    if(target.tracking_num_ == TrackingState::Stable &amp;&amp; target.lifetime_ &gt;= life_time_thres_)
+  //skip if no validated measurement
+  if(cluster_vec.size() == 0)
+  {
+      return;
+  }
+  // cout &lt;&lt; target.tracking_num_ &lt;&lt; " "&lt;&lt; target.lifetime_ &lt;&lt; endl;
+  if(target.tracking_num_ == TrackingState::Stable &amp;&amp; target.lifetime_ &gt;= life_time_thres_)
+  {
+    // cout &lt;&lt; "--------------" &lt;&lt; endl;
+    autoware_msgs::CloudCluster nearest_cluster;
+    // double min_dist = 999;
+    double min_dist = std::numeric_limits&lt;double&gt;::max();
+    getNearestEuclidCluster(target, cluster_vec, nearest_cluster, min_dist);
+    // std::cout &lt;&lt; "minDist "&lt;&lt; min_dist &lt;&lt; std::endl;
+    if(min_dist &lt; distance_thres_)
     {
-        // cout &lt;&lt; "--------------" &lt;&lt; endl;
-        autoware_msgs::CloudCluster nearest_cluster;
-        // double min_dist = 999;
-        double min_dist = std::numeric_limits&lt;double&gt;::max();
-        getNearestEuclidCluster(target, cluster_vec, nearest_cluster, min_dist);
-        // std::cout &lt;&lt; "minDist "&lt;&lt; min_dist &lt;&lt; std::endl;
-        if(min_dist &lt; distance_thres_)
-        {
-            target.is_vis_bb_ = true;
-            // target.BBox_    = bbox;
-            // cout &lt;&lt;"nearestCluster "&lt;&lt; nearestCluster.bounding_box&lt;&lt;endl;
-            target.jsk_bb_   = nearest_cluster.bounding_box;
-        }
+      target.is_vis_bb_ = true;
+      // target.BBox_    = bbox;
+      // cout &lt;&lt;"nearestCluster "&lt;&lt; nearestCluster.bounding_box&lt;&lt;endl;
+      target.jsk_bb_   = nearest_cluster.bounding_box;
     }
+  }
 }
 
 
 
 double ImmUkfPda::getBboxArea(const pcl::PointCloud&lt;pcl::PointXYZ&gt; bbox)
 {
-    pcl::PointXYZ p1 = bbox[0];
-    pcl::PointXYZ p2 = bbox[1];
-    pcl::PointXYZ p3 = bbox[2];
-    pcl::PointXYZ p4 = bbox[3];
-
-    //S=tri(p1,p2,p3) + tri(p1, p3, p4)
-    //s(triangle) = 1/2*|(x1−x3)(y2−y3)−(x2−x3)(y1−y3)|
-    double tri1 = 0.5*abs((p1.x - p3.x)*(p2.y - p3.y) - (p2.x - p3.x)*(p1.y - p3.y));
-    double tri2 = 0.5*abs((p1.x - p4.x)*(p3.y - p4.y) - (p3.x - p4.x)*(p1.y - p4.y));
-    double S = tri1 + tri2;
-    return S;
+  pcl::PointXYZ p1 = bbox[0];
+  pcl::PointXYZ p2 = bbox[1];
+  pcl::PointXYZ p3 = bbox[2];
+  pcl::PointXYZ p4 = bbox[3];
+
+  //S=tri(p1,p2,p3) + tri(p1, p3, p4)
+  //s(triangle) = 1/2*|(x1−x3)(y2−y3)−(x2−x3)(y1−y3)|
+  double tri1 = 0.5*abs((p1.x - p3.x)*(p2.y - p3.y) - (p2.x - p3.x)*(p1.y - p3.y));
+  double tri2 = 0.5*abs((p1.x - p4.x)*(p3.y - p4.y) - (p3.x - p4.x)*(p1.y - p4.y));
+  double S = tri1 + tri2;
+  return S;
 }
 
 
@@ -446,73 +439,73 @@ double ImmUkfPda::getJskBBoxArea(const jsk_recognition_msgs::BoundingBox jsk_bb)
 
 void ImmUkfPda::updateBB(UKF&amp; target)
 {
-    //to do: initialize target.BBox_ somewhere else
+  //to do: initialize target.BBox_ somewhere else
 
-    // skip to prevent memory leak by accessing empty target.bbox_
-
-    if(!target.is_vis_bb_)
-    {
-        return;
-    }
-    double yaw = getJskBBoxYaw(target.jsk_bb_);
-
-    // skip the rest of process if it is first bbox associaiton
-    // todo: wanna check if bestJskBBox is empty or not, there should be better method
-    // if(target.bestBBox_.empty()){
-    if(target.best_yaw_ == init_yaw_)
-    {
-        target.best_jsk_bb_ = target.jsk_bb_;
-        target.best_yaw_   = yaw;
-        return;
-    }
+  // skip to prevent memory leak by accessing empty target.bbox_
 
-    // restricting yaw movement
-    // double diff_yaw = yaw - target.best_yaw_;
-
-    // // diffYaw is within the threshold, apply the diffYaw chamge
-    // if(abs(diff_yaw) &lt; bb_yaw_change_thres_)
-    // {
-    //     target.best_jsk_bb_.pose.orientation = target.jsk_bb_.pose.orientation;
-    //     target.best_yaw_ = yaw;
-    // }
-    // else
-    // {
-    //     target.jsk_bb_.pose.orientation = target.best_jsk_bb_.pose.orientation;
-    // }
-
-    // // bbox area
-    double area     = getJskBBoxArea(target.jsk_bb_);
-    double best_area = getJskBBoxArea(target.best_jsk_bb_);
-    // double bestArea = getBboxArea(target.bestBBox_);
-
-    // start updating bbox params
-    double delta_area = area - best_area;
-
-    // when the delta area is under 0, keep best area and relocate(slide) it for current cp
-    if( delta_area &lt; 0 )
-    {
-        // updateVisBoxArea(target, dtCP);
-        target.jsk_bb_.dimensions = target.best_jsk_bb_.dimensions;
-        // for  mergeSegmentation, area comparison
-        target.bb_area_ = best_area;
-    }
-    else if(delta_area &gt; 0)
-    {
-        // target.bestBBox_ = target.BBox_;
-        target.best_jsk_bb_.dimensions = target.jsk_bb_.dimensions;
-        // for mergeSegmentation, area comparison
-        target.bb_area_  = area;
-    }
+  if(!target.is_vis_bb_)
+  {
+      return;
+  }
+  double yaw = getJskBBoxYaw(target.jsk_bb_);
+
+  // skip the rest of process if it is first bbox associaiton
+  // todo: wanna check if bestJskBBox is empty or not, there should be better method
+  // if(target.bestBBox_.empty()){
+  if(target.best_yaw_ == init_yaw_)
+  {
+    target.best_jsk_bb_ = target.jsk_bb_;
+    target.best_yaw_   = yaw;
+    return;
+  }
+
+  // restricting yaw movement
+  // double diff_yaw = yaw - target.best_yaw_;
+
+  // // diffYaw is within the threshold, apply the diffYaw chamge
+  // if(abs(diff_yaw) &lt; bb_yaw_change_thres_)
+  // {
+  //     target.best_jsk_bb_.pose.orientation = target.jsk_bb_.pose.orientation;
+  //     target.best_yaw_ = yaw;
+  // }
+  // else
+  // {
+  //     target.jsk_bb_.pose.orientation = target.best_jsk_bb_.pose.orientation;
+  // }
+
+  // // bbox area
+  double area     = getJskBBoxArea(target.jsk_bb_);
+  double best_area = getJskBBoxArea(target.best_jsk_bb_);
+  // double bestArea = getBboxArea(target.bestBBox_);
+
+  // start updating bbox params
+  double delta_area = area - best_area;
+
+  // when the delta area is under 0, keep best area and relocate(slide) it for current cp
+  if( delta_area &lt; 0 )
+  {
+    // updateVisBoxArea(target, dtCP);
+    target.jsk_bb_.dimensions = target.best_jsk_bb_.dimensions;
+    // for  mergeSegmentation, area comparison
+    target.bb_area_ = best_area;
+  }
+  else if(delta_area &gt; 0)
+  {
+    // target.bestBBox_ = target.BBox_;
+    target.best_jsk_bb_.dimensions = target.jsk_bb_.dimensions;
+    // for mergeSegmentation, area comparison
+    target.bb_area_  = area;
+  }
 }
 
-double ImmUkfPda::getIntersectCoef(const double vec1x, const double vec1y, const double vec2x, const double vec2y,
-                                  const double px, const double py, const double cpx, const double cpy)
-{
-    double intersect_coef = (((vec1x-vec2x)*(py - vec1y) + (vec1y - vec2y)*(vec1x - px)) *
-        ((vec1x - vec2x)*(cpy - vec1y) + (vec1y - vec2y)*(vec1x - cpx)));
-    return intersect_coef;
-
-}
+// double ImmUkfPda::getIntersectCoef(const double vec1x, const double vec1y, const double vec2x, const double vec2y,
+//                                   const double px, const double py, const double cpx, const double cpy)
+// {
+//     double intersect_coef = (((vec1x-vec2x)*(py - vec1y) + (vec1y - vec2y)*(vec1x - px)) *
+//         ((vec1x - vec2x)*(cpy - vec1y) + (vec1y - vec2y)*(vec1x - cpx)));
+//     return intersect_coef;
+//
+// }
 
 //naive method
 // void ImmUkfPda::mergeOverSegmentation(const std::vector&lt;UKF&gt; targets){
@@ -558,305 +551,378 @@ double ImmUkfPda::getIntersectCoef(const double vec1x, const double vec1y, const
 
 void ImmUkfPda::updateLabel(UKF target, autoware_msgs::CloudCluster&amp; cc)
 {
-    int tracking_num = target.tracking_num_;
-    // cout &lt;&lt; "trackingnum "&lt;&lt; trackingNum &lt;&lt; endl;
-    if(target.is_static_)
+  int tracking_num = target.tracking_num_;
+  // cout &lt;&lt; "trackingnum "&lt;&lt; trackingNum &lt;&lt; endl;
+  if(target.is_static_)
+  {
+    cc.label = "Static";
+  }
+  else if(tracking_num &gt; TrackingState::Die &amp;&amp; tracking_num &lt; TrackingState::Stable)
+  {
+    cc.label = "Initialized";
+  }
+  else if(tracking_num == TrackingState::Stable)
+  {
+    cc.label = "Stable";
+  }
+  else if(tracking_num &gt; TrackingState::Stable &amp;&amp; tracking_num &lt;= TrackingState::Lost)
+  {
+    cc.label = "Lost";
+  }
+  else
+  {
+    cc.label = "None";
+  }
+}
+
+void ImmUkfPda::initTracker(autoware_msgs::CloudClusterArray input, double timestamp)
+{
+  for(size_t i = 0; i &lt; input.clusters.size(); i++)
+  {
+    double px = input.clusters[i].bounding_box.pose.position.x;
+    double py = input.clusters[i].bounding_box.pose.position.y;
+    Eigen::VectorXd init_meas = Eigen::VectorXd(2);
+    init_meas &lt;&lt; px, py;
+
+    UKF ukf;
+    ukf.initialize(init_meas, timestamp);
+    targets_.push_back(ukf);
+  }
+  timestamp_ = timestamp;
+  // egoPreYaw_ = egoYaw_;
+  init_ = true;
+  return;
+}
+
+void ImmUkfPda::secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target)
+{
+  if(cluster_vec.size() == 0)
+  {
+    target.tracking_num_ = TrackingState::Die;
+    return;
+  }
+
+  // assert(measVec.size() == 1);
+  // record init measurement for env classification
+  target.init_meas_ &lt;&lt; target.x_merge_(0), target.x_merge_(1);
+
+  // abs update
+  double target_x = cluster_vec[0].bounding_box.pose.position.x;
+  double target_y = cluster_vec[0].bounding_box.pose.position.y;
+  double target_diff_x = target_x - target.x_merge_(0);
+  double target_diff_y = target_y - target.x_merge_(1);
+  double target_yaw = atan2(target_diff_y, target_diff_x);
+  double dist      = sqrt(target_diff_x*target_diff_x + target_diff_y* target_diff_y);
+  double target_v   = dist/dt;
+  // double targetV   = 2;
+
+  while (target_yaw&gt; M_PI) target_yaw -= 2.*M_PI;
+  while (target_yaw&lt;-M_PI) target_yaw += 2.*M_PI;
+
+  target.x_merge_(0) = target.x_cv_(0) = target.x_ctrv_(0) = target.x_rm_(0) = target_x;
+  target.x_merge_(1) = target.x_cv_(1) = target.x_ctrv_(1) = target.x_rm_(1) = target_y;
+  target.x_merge_(2) = target.x_cv_(2) = target.x_ctrv_(2) = target.x_rm_(2) = target_v;
+  target.x_merge_(3) = target.x_cv_(3) = target.x_ctrv_(3) = target.x_rm_(3) = target_yaw;
+
+  target.tracking_num_++;
+  return;
+}
+
+void ImmUkfPda::updateTrackingNum(std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target)
+{
+  if(cluster_vec.size() &gt; 0)
+  {
+    if(target.tracking_num_ &lt; TrackingState::Stable)
     {
-        cc.label = "Static";
+      target.tracking_num_++;
     }
-    else if(tracking_num &gt; TrackingState::Die &amp;&amp; tracking_num &lt; TrackingState::Stable)
+    else if(target.tracking_num_ == TrackingState::Stable)
     {
-        cc.label = "Initialized";
+      target.tracking_num_ = TrackingState::Stable;
     }
-    else if(tracking_num == TrackingState::Stable)
+    else if(target.tracking_num_ &gt;= TrackingState::Stable &amp;&amp; target.tracking_num_ &lt; TrackingState::Lost)
     {
-        cc.label = "Stable";
+      target.tracking_num_ = TrackingState::Stable;
     }
-    else if(tracking_num &gt; TrackingState::Stable &amp;&amp; tracking_num &lt;= TrackingState::Lost)
+    else if(target.tracking_num_ == TrackingState::Lost)
     {
-        cc.label = "Lost";
+      target.tracking_num_ = TrackingState::Die;
     }
-    else
+  }
+  else
+  {
+    if(target.tracking_num_ &lt; TrackingState::Stable)
     {
-        cc.label = "None";
+      target.tracking_num_ = TrackingState::Die;
     }
-}
-
-void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
-                        autoware_msgs::CloudClusterArray&amp; output)
-{
-
-    int in_num_cluster = input.clusters.size();
-    double timestamp = input.header.stamp.toSec();
-
-    double det_explode_param = 10;
-    double cov_explode_param = 1000;
-
-    if(!init_)
+    else if(target.tracking_num_ &gt;= TrackingState::Stable &amp;&amp; target.tracking_num_ &lt; TrackingState::Lost)
     {
-    	for(int i = 0; i &lt; in_num_cluster; i++)
-        {
-            double px = input.clusters[i].bounding_box.pose.position.x;
-            double py = input.clusters[i].bounding_box.pose.position.y;
-    		Eigen::VectorXd init_meas = Eigen::VectorXd(2);
-    		init_meas &lt;&lt; px, py;
-
-            UKF ukf;
-            ukf.initialize(init_meas, timestamp);
-            targets_.push_back(ukf);
-
-    	}
-        timestamp_ = timestamp;
-        // egoPreYaw_ = egoYaw_;
-        init_ = true;
-
-        // assert(targets_.size() == trackNumVec_.size());
-        // assert(targets_.size() == targetPoints.size());
-        // assert(targetPoints.size()== targetVandYaw.size());
-        return;
+      target.tracking_num_++;
     }
-
-    // assert (targets_.size() == trackNumVec_.size());
-
-    // // used for making new target with no data association
-    std::vector&lt;int&gt; matching_vec(in_num_cluster); // make 0 vector
-
-    double dt = (timestamp - timestamp_);
-    timestamp_ = timestamp;
-
-
-    // start UKF process
-    for(size_t i = 0; i &lt; targets_.size(); i++)
+    else if(target.tracking_num_ == TrackingState::Lost)
     {
-        //reset is_vis_bb_ to false
-        targets_[i].is_vis_bb_ = false;
-
-    	//todo: modify here. This skips irregular measurement and nan
-        if(targets_[i].tracking_num_ == TrackingState::Die) continue;
-        // prevent ukf not to explode
-        if(targets_[i].p_merge_.determinant() &gt; det_explode_param || targets_[i].p_merge_(4,4) &gt; cov_explode_param)
-        {
-            targets_[i].tracking_num_ = TrackingState::Die;
-            continue;
-        }
-        // immukf prediction step
-        targets_[i].predictionIMMUKF(dt);
-
-
-        Eigen::VectorXd max_det_z;
-        Eigen::MatrixXd max_det_s;
-    	std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec;
-        // std::vector&lt;Eigen::VectorXd&gt; bboxVec;
-    	std::vector&lt;double&gt; lambda_vec;
-        // find maxDetS associated with predZ
-        findMaxZandS(targets_[i], max_det_z, max_det_s);
-        // to do: might modufy here: this code ensures that measurement is incorporated
-        max_det_s = max_det_s*4;
-        double det_s = max_det_s.determinant();
-
-        // prevent ukf not to explode
-        if(std::isnan(det_s)|| det_s &gt; det_explode_param)
-        {
-            targets_[i].tracking_num_ = TrackingState::Die;
-            continue;
-        }
+      target.tracking_num_ = TrackingState::Die;
+    }
+  }
 
-        bool second_init;
-        if(targets_[i].tracking_num_ == TrackingState::Init)
-        {
-            second_init = true;
-        }
-        else
-        {
-            second_init = false;
-        }
+  return;
+}
 
-        // measurement gating, get measVec, bboxVec, matchingVec through reference
-        measurementValidation(input, targets_[i], second_init, max_det_z, max_det_s, cluster_vec,matching_vec);
+void ImmUkfPda::probabilisticDataAssociation(autoware_msgs::CloudClusterArray input,
+                                            double dt, double det_explode_param, std::vector&lt;int&gt;&amp; matching_vec,
+                                            std::vector&lt;double&gt;&amp; lambda_vec, UKF&amp; target, bool&amp; is_skip_target)
+{
+  Eigen::VectorXd max_det_z;
+  Eigen::MatrixXd max_det_s;
+  std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec;
+  is_skip_target = false;
+  // find maxDetS associated with predZ
+  findMaxZandS(target, max_det_z, max_det_s);
+  // to do: might modufy here: this code ensures that measurement is incorporated
+  max_det_s = max_det_s*4;
+  double det_s = max_det_s.determinant();
+
+  // prevent ukf not to explode
+  if(std::isnan(det_s)|| det_s &gt; det_explode_param)
+  {
+      target.tracking_num_ = TrackingState::Die;
+      is_skip_target = true;
+      return;
+  }
 
-        // bounding box association if target is stable :plus, right angle correction if its needed
-        // input: track number, bbox measurements, &amp;target
-        // cout &lt;&lt; "cluster vec size "&lt;&lt;clusterVec.size()&lt;&lt;endl;
-        associateBB(cluster_vec, targets_[i]);
+  bool is_second_init;
+  if(target.tracking_num_ == TrackingState::Init)
+  {
+    is_second_init = true;
+  }
+  else
+  {
+    is_second_init = false;
+  }
 
-        // bounding box validation
-        // updateBB(targets_[i]);
+  // measurement gating, get measVec, bboxVec, matchingVec through reference
+  measurementValidation(input, target, is_second_init, max_det_z, max_det_s, cluster_vec,matching_vec);
 
-        // cout &lt;&lt; "validated meas "&lt;&lt;measVec[0][0]&lt;&lt;" "&lt;&lt;measVec[0][1]&lt;&lt;endl;
+  // bounding box association if target is stable :plus, right angle correction if its needed
+  // input: track number, bbox measurements, &amp;target
+  associateBB(cluster_vec, target);
 
-        // second detection for a target: update v and yaw
-        if(second_init)
-        {
-            if(cluster_vec.size() == 0)
-            {
-                targets_[i].tracking_num_ = TrackingState::Die;
-                continue;
-            }
-
-            // assert(measVec.size() == 1);
-            // record init measurement for env classification
-            targets_[i].init_meas_ &lt;&lt; targets_[i].x_merge_(0), targets_[i].x_merge_(1);
-
-            // abs update
-            double target_x = cluster_vec[0].bounding_box.pose.position.x;
-            double target_y = cluster_vec[0].bounding_box.pose.position.y;
-            double target_diff_x = target_x - targets_[i].x_merge_(0);
-            double target_diff_y = target_y - targets_[i].x_merge_(1);
-            double target_yaw = atan2(target_diff_y, target_diff_x);
-            double dist      = sqrt(target_diff_x*target_diff_x + target_diff_y* target_diff_y);
-            double target_v   = dist/dt;
-            // double targetV   = 2;
-
-            while (target_yaw&gt; M_PI) target_yaw -= 2.*M_PI;
-            while (target_yaw&lt;-M_PI) target_yaw += 2.*M_PI;
-
-            targets_[i].x_merge_(0) = targets_[i].x_cv_(0) = targets_[i].x_ctrv_(0) = targets_[i].x_rm_(0) = target_x;
-            targets_[i].x_merge_(1) = targets_[i].x_cv_(1) = targets_[i].x_ctrv_(1) = targets_[i].x_rm_(1) = target_y;
-            targets_[i].x_merge_(2) = targets_[i].x_cv_(2) = targets_[i].x_ctrv_(2) = targets_[i].x_rm_(2) = target_v;
-            targets_[i].x_merge_(3) = targets_[i].x_cv_(3) = targets_[i].x_ctrv_(3) = targets_[i].x_rm_(3) = target_yaw;
-
-            targets_[i].tracking_num_++;
-            continue;
-        }
+  // second detection for a target: update v and yaw
+  if(is_second_init)
+  {
+    secondInit(dt, cluster_vec, target);
+    is_skip_target = true;
+    return;
+  }
 
-    	// update tracking number
-    	if(cluster_vec.size() &gt; 0)
-        {
-            if(targets_[i].tracking_num_ &lt; TrackingState::Stable)
-            {
-    			targets_[i].tracking_num_++;
-    		}
-            else if(targets_[i].tracking_num_ == TrackingState::Stable)
-            {
-                targets_[i].tracking_num_ = TrackingState::Stable;
-    		}
-            else if(targets_[i].tracking_num_ &gt;= TrackingState::Stable &amp;&amp; targets_[i].tracking_num_ &lt; TrackingState::Lost)
-            {
-                targets_[i].tracking_num_ = TrackingState::Stable;
-    		}
-            else if(targets_[i].tracking_num_ == TrackingState::Lost)
-            {
-                targets_[i].tracking_num_ = TrackingState::Die;
-            }
-    	}else{
-            if(targets_[i].tracking_num_ &lt; TrackingState::Stable)
-            {
-                targets_[i].tracking_num_ = TrackingState::Die;
-            }
-            else if(targets_[i].tracking_num_ &gt;= TrackingState::Stable &amp;&amp; targets_[i].tracking_num_ &lt; TrackingState::Lost)
-            {
-    			targets_[i].tracking_num_++;
-    		}
-            else if(targets_[i].tracking_num_ == TrackingState::Lost)
-            {
-                targets_[i].tracking_num_ = TrackingState::Die;
-    		}
-    	}
-
-        if(targets_[i].tracking_num_ == TrackingState::Die) continue;
-
-
-	    filterPDA(targets_[i], cluster_vec, lambda_vec);
-
-	    targets_[i].postProcessIMMUKF(lambda_vec);
-    }
-    // // end UKF process
+  // update tracking number
+  updateTrackingNum(cluster_vec, target);
 
+  if(target.tracking_num_ == TrackingState::Die)
+  {
+    is_skip_target = true;
+    return;
+  }
+  filterPDA(target, cluster_vec, lambda_vec);
+}
 
-    // // deling with over segmentation, update trackNumVec_
-    // mergeOverSegmentation(targets_);
+void ImmUkfPda::makeNewTargets(double timestamp, autoware_msgs::CloudClusterArray input, std::vector&lt;int&gt; matching_vec)
+{
+  for(size_t i = 0; i &lt; input.clusters.size(); i ++)
+  {
+    if(matching_vec[i] == IsMatch::False)
+    {
+      double px = input.clusters[i].bounding_box.pose.position.x;
+      double py = input.clusters[i].bounding_box.pose.position.y;
 
+      Eigen::VectorXd init_meas = Eigen::VectorXd(2);
+      init_meas &lt;&lt; px, py;
 
-    // making new ukf target for no data association clusters
-    int added_num = 0;
-    // size_t target_num = targets_.size();
+      UKF ukf;
+      ukf.initialize(init_meas, timestamp);
+      targets_.push_back(ukf);
+    }
+  }
+}
 
-    for(size_t i = 0; i &lt; matching_vec.size(); i ++)
+void ImmUkfPda::staticClassification()
+{
+  for (size_t i = 0; i &lt; targets_.size(); i++)
+  {
+    if(!targets_[i].is_static_ &amp;&amp;
+     targets_[i].tracking_num_ == TrackingState::Stable &amp;&amp;
+     targets_[i].lifetime_ &gt; life_time_thres_ )
     {
-        if(matching_vec[i] == IsMatch::False)
-        {
-            double px = input.clusters[i].bounding_box.pose.position.x;
-            double py = input.clusters[i].bounding_box.pose.position.y;
-
-            Eigen::VectorXd init_meas = Eigen::VectorXd(2);
-            init_meas &lt;&lt; px, py;
+      // double dist_thres = 3.0;
+      if((targets_[i].dist_from_init_ &lt; dist_from_init_thres_)&amp;&amp;
+          (targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_cv_ ||
+           targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_ctrv_ ))
+      {
+        targets_[i].is_static_    = true;
+      }
+    }
+  }
+}
 
-            UKF ukf;
-            ukf.initialize(init_meas, timestamp);
-            targets_.push_back(ukf);
+void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
+                           autoware_msgs::CloudClusterArray&amp; output)
+{
+  tf::StampedTransform transform;
+  tran_-&gt;lookupTransform("/world", "/velodyne", ros::Time(0), transform);
 
-            added_num ++;
-        }
-    }
-    // assert(targets_.size() == (added_num + target_num));
+  // get yaw angle from "world" to "velodyne" for direction(arrow) visualization
+  tf::Matrix3x3 m(transform.getRotation());
+  double roll, pitch, yaw;
+  m.getRPY(roll, pitch, yaw);
 
-    // static dynamic classification
-    for (size_t i = 0; i &lt; targets_.size(); i++)
+  output.header = input.header;
+  // int target_num_count = 0;
+  for(size_t i = 0; i &lt; targets_.size(); i++)
+  {
+    if(targets_[i].is_vis_bb_)
     {
-        if(!targets_[i].is_static_ &amp;&amp;
-         targets_[i].tracking_num_ == TrackingState::Stable &amp;&amp;
-         targets_[i].lifetime_ &gt; life_time_thres_ )
-        {
-            // double dist_thres = 3.0;
-            if((targets_[i].dist_from_init_ &lt; dist_from_init_thres_)&amp;&amp;
-                    (targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_cv_ ||
-                     targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_ctrv_ ))
-            {
-                targets_[i].is_static_    = true;
-            }
-        }
+      double tx = targets_[i].x_merge_(0);
+      double ty = targets_[i].x_merge_(1);
+      double mx = targets_[i].init_meas_(0);
+      double my = targets_[i].init_meas_(1);
+
+      //for static classification
+      targets_[i].dist_from_init_ = sqrt((tx - mx)*(tx - mx) + (ty - my)*(ty - my));
+      std::vector&lt;double&gt; cp;
+      cp.push_back(tx);
+      cp.push_back(ty);
+
+      double tv = targets_[i].x_merge_(2);
+      double tyaw = targets_[i].x_merge_(3) - yaw;
+
+      // tyaw += egoPoints_[0][2];
+      while (tyaw&gt; M_PI) tyaw -= 2.*M_PI;
+      while (tyaw&lt;-M_PI) tyaw += 2.*M_PI;
+      // cout &lt;&lt; "testing yaw off "&lt;&lt; tyaw &lt;&lt; endl;
+
+      // cout &lt;&lt; "inside tracker ----------------------------------------------------------------------------------------------"&lt;&lt;targets_[i].jskBB_.pose &lt;&lt; endl;
+
+      autoware_msgs::CloudCluster cc;
+      cc.header = input.header;
+      cc.bounding_box = targets_[i].jsk_bb_;
+      cc.bounding_box.header = input.header;
+      cc.score           = tv;
+      cc.estimated_angle = tyaw;
+      updateLabel(targets_[i], cc);
+      output.clusters.push_back(cc);
     }
+  }
+}
+
+void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
+                        autoware_msgs::CloudClusterArray&amp; output)
+{
+  // int in_num_cluster = input.clusters.size();
+  double timestamp = input.header.stamp.toSec();
 
+  double det_explode_param = 10;
+  double cov_explode_param = 1000;
 
+  if(!init_)
+  {
+    initTracker(input, timestamp);
+    return;
+  }
 
-    // making output(CludClusterArray) for visualization
-    tf::StampedTransform transform;
-    tran_-&gt;lookupTransform("/world", "/velodyne", ros::Time(0), transform);
 
-    // get yaw angle from "world" to "velodyne" for direction(arrow) visualization
-    tf::Matrix3x3 m(transform.getRotation());
-    double roll, pitch, yaw;
-    m.getRPY(roll, pitch, yaw);
+  double dt = (timestamp - timestamp_);
+  timestamp_ = timestamp;
+  // // used for making new target with no data association
+  std::vector&lt;int&gt; matching_vec(input.clusters.size()); // make 0 vector
 
-    output.header = input.header;
-    // int target_num_count = 0;
-    for(size_t i = 0; i &lt; targets_.size(); i++)
-    {
-        if(targets_[i].is_vis_bb_)
-        {
-            double tx = targets_[i].x_merge_(0);
-            double ty = targets_[i].x_merge_(1);
-            double mx = targets_[i].init_meas_(0);
-            double my = targets_[i].init_meas_(1);
-
-            //for static classification
-            targets_[i].dist_from_init_ = sqrt((tx - mx)*(tx - mx) + (ty - my)*(ty - my));
-            std::vector&lt;double&gt; cp;
-            cp.push_back(tx);
-            cp.push_back(ty);
-
-            double tv = targets_[i].x_merge_(2);
-            double tyaw = targets_[i].x_merge_(3) - yaw;
-
-            // tyaw += egoPoints_[0][2];
-            while (tyaw&gt; M_PI) tyaw -= 2.*M_PI;
-            while (tyaw&lt;-M_PI) tyaw += 2.*M_PI;
-            // cout &lt;&lt; "testing yaw off "&lt;&lt; tyaw &lt;&lt; endl;
-
-            // cout &lt;&lt; "inside tracker ----------------------------------------------------------------------------------------------"&lt;&lt;targets_[i].jskBB_.pose &lt;&lt; endl;
-
-            autoware_msgs::CloudCluster cc;
-            cc.header = input.header;
-            cc.bounding_box = targets_[i].jsk_bb_;
-            cc.bounding_box.header = input.header;
-            cc.score           = tv;
-            cc.estimated_angle = tyaw;
-            updateLabel(targets_[i], cc);
-            output.clusters.push_back(cc);
-        }
+  // start UKF process
+  for(size_t i = 0; i &lt; targets_.size(); i++)
+  {
+    //reset is_vis_bb_ to false
+    targets_[i].is_vis_bb_ = false;
 
+    //todo: modify here. This skips irregular measurement and nan
+    if(targets_[i].tracking_num_ == TrackingState::Die) continue;
+    // prevent ukf not to explode
+    if(targets_[i].p_merge_.determinant() &gt; det_explode_param || targets_[i].p_merge_(4,4) &gt; cov_explode_param)
+    {
+        targets_[i].tracking_num_ = TrackingState::Die;
+        continue;
     }
-    // cout &lt;&lt; output.clusters.size()&lt;&lt; endl;
-
-    assert(matching_vec.size() == input.clusters.size());
+    // immukf prediction step
+    targets_[i].predictionIMMUKF(dt);
+
+
+    std::vector&lt;double&gt; lambda_vec;
+    bool is_skip_target;
+    probabilisticDataAssociation(input, dt, det_explode_param, matching_vec, lambda_vec, targets_[i], is_skip_target);
+    if(is_skip_target)
+      continue;
+
+    // immukf update step
+    targets_[i].updateIMMUKF(lambda_vec);
+  }
+  // // end UKF process
+
+  // // deling with over segmentation, update trackNumVec_
+  // mergeOverSegmentation(targets_);
+
+  // making new ukf target for no data association clusters
+  makeNewTargets(timestamp, input, matching_vec);
+
+  // static dynamic classification
+  staticClassification();
+
+  // making output(CludClusterArray) for visualization
+  makeOutput(input, output);
+  // // making output(CludClusterArray) for visualization
+  // tf::StampedTransform transform;
+  // tran_-&gt;lookupTransform("/world", "/velodyne", ros::Time(0), transform);
+  //
+  // // get yaw angle from "world" to "velodyne" for direction(arrow) visualization
+  // tf::Matrix3x3 m(transform.getRotation());
+  // double roll, pitch, yaw;
+  // m.getRPY(roll, pitch, yaw);
+  //
+  // output.header = input.header;
+  // // int target_num_count = 0;
+  // for(size_t i = 0; i &lt; targets_.size(); i++)
+  // {
+  //   if(targets_[i].is_vis_bb_)
+  //   {
+  //     double tx = targets_[i].x_merge_(0);
+  //     double ty = targets_[i].x_merge_(1);
+  //     double mx = targets_[i].init_meas_(0);
+  //     double my = targets_[i].init_meas_(1);
+  //
+  //     //for static classification
+  //     targets_[i].dist_from_init_ = sqrt((tx - mx)*(tx - mx) + (ty - my)*(ty - my));
+  //     std::vector&lt;double&gt; cp;
+  //     cp.push_back(tx);
+  //     cp.push_back(ty);
+  //
+  //     double tv = targets_[i].x_merge_(2);
+  //     double tyaw = targets_[i].x_merge_(3) - yaw;
+  //
+  //     // tyaw += egoPoints_[0][2];
+  //     while (tyaw&gt; M_PI) tyaw -= 2.*M_PI;
+  //     while (tyaw&lt;-M_PI) tyaw += 2.*M_PI;
+  //     // cout &lt;&lt; "testing yaw off "&lt;&lt; tyaw &lt;&lt; endl;
+  //
+  //     // cout &lt;&lt; "inside tracker ----------------------------------------------------------------------------------------------"&lt;&lt;targets_[i].jskBB_.pose &lt;&lt; endl;
+  //
+  //     autoware_msgs::CloudCluster cc;
+  //     cc.header = input.header;
+  //     cc.bounding_box = targets_[i].jsk_bb_;
+  //     cc.bounding_box.header = input.header;
+  //     cc.score           = tv;
+  //     cc.estimated_angle = tyaw;
+  //     updateLabel(targets_[i], cc);
+  //     output.clusters.push_back(cc);
+  //   }
+  //
+  // }
+  // cout &lt;&lt; output.clusters.size()&lt;&lt; endl;
+
+  assert(matching_vec.size() == input.clusters.size());
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" added_lines="586" deleted_lines="591">
				<diff>@@ -17,331 +17,328 @@ using namespace std;
 /**
 * Initializes Unscented Kalman filter
 */
-UKF::UKF() 
+UKF::UKF()
 {
-    // if this is false, laser measurements will be ignored (except during init)
-    use_laser_ = true;
+  // if this is false, laser measurements will be ignored (except during init)
+  use_laser_ = true;
 
-    // if this is false, radar measurements will be ignored (except during init)
-    use_radar_ = true;
+  // if this is false, radar measurements will be ignored (except during init)
+  use_radar_ = true;
 
-    // initial state vector
-    x_merge_ = Eigen::MatrixXd(5, 1);
+  // initial state vector
+  x_merge_ = Eigen::MatrixXd(5, 1);
 
-    // initial state vector
-    x_cv_ = Eigen::MatrixXd(5, 1);
+  // initial state vector
+  x_cv_ = Eigen::MatrixXd(5, 1);
 
-    // initial state vector
-    x_ctrv_ = Eigen::MatrixXd(5, 1);
+  // initial state vector
+  x_ctrv_ = Eigen::MatrixXd(5, 1);
 
-    // initial state vector
-    x_rm_ = Eigen::MatrixXd(5, 1);
+  // initial state vector
+  x_rm_ = Eigen::MatrixXd(5, 1);
 
-    // initial covariance matrix
-    p_merge_ = Eigen::MatrixXd(5, 5);
+  // initial covariance matrix
+  p_merge_ = Eigen::MatrixXd(5, 5);
 
-    // initial covariance matrix
-    p_cv_ = Eigen::MatrixXd(5, 5);
+  // initial covariance matrix
+  p_cv_ = Eigen::MatrixXd(5, 5);
 
-    // initial covariance matrix
-    p_ctrv_ = Eigen::MatrixXd(5, 5);
+  // initial covariance matrix
+  p_ctrv_ = Eigen::MatrixXd(5, 5);
 
-    // initial covariance matrix
-    p_rm_ = Eigen::MatrixXd(5, 5);
+  // initial covariance matrix
+  p_rm_ = Eigen::MatrixXd(5, 5);
 
-    // Process noise standard deviation longitudinal acceleration in m/s^2
-    std_a_cv_   = 2;
-    std_a_ctrv_ = 2;
-    std_a_rm_   = 3;
-    std_ctrv_yawdd_ = 2;
-    std_cv_yawdd_   = 2;
-    std_rm_yawdd_ = 3;
+  // Process noise standard deviation longitudinal acceleration in m/s^2
+  std_a_cv_   = 2;
+  std_a_ctrv_ = 2;
+  std_a_rm_   = 3;
+  std_ctrv_yawdd_ = 2;
+  std_cv_yawdd_   = 2;
+  std_rm_yawdd_ = 3;
 
-    //------------------
-    // Laser measurement noise standard deviation position1 in m
-    std_laspx_ = 0.15;
-    // Laser measurement noise standard deviation position2 in m
-    std_laspy_ = 0.15;
-    
+  //------------------
+  // Laser measurement noise standard deviation position1 in m
+  std_laspx_ = 0.15;
+  // Laser measurement noise standard deviation position2 in m
+  std_laspy_ = 0.15;
 
-    // initially set to false, set to true in first call of ProcessMeasurement
-    is_initialized_ = false;
 
-    // time when the state is true, in us
-    time_ = 0.0;
+  // initially set to false, set to true in first call of ProcessMeasurement
+  is_initialized_ = false;
 
-    // state dimension
-    n_x_ = 5;
+  // time when the state is true, in us
+  time_ = 0.0;
 
-    // Augmented state dimension
-    n_aug_ = 7;
+  // state dimension
+  n_x_ = 5;
 
-    // Sigma point spreading parameter
-    lambda_ = 3 - n_x_;
+  // Augmented state dimension
+  n_aug_ = 7;
 
-    // Augmented sigma point spreading parameter
-    lambda_aug_ = 3 - n_aug_;
+  // Sigma point spreading parameter
+  lambda_ = 3 - n_x_;
 
-    // predicted sigma points matrix
-    x_sig_pred_cv_ = Eigen::MatrixXd(n_x_, 2 * n_aug_ + 1);
+  // Augmented sigma point spreading parameter
+  lambda_aug_ = 3 - n_aug_;
 
-    // predicted sigma points matrix
-    x_sig_pred_ctrv_ = Eigen::MatrixXd(n_x_, 2 * n_aug_ + 1);
+  // predicted sigma points matrix
+  x_sig_pred_cv_ = Eigen::MatrixXd(n_x_, 2 * n_aug_ + 1);
 
-    // predicted sigma points matrix
-    x_sig_pred_rm_ = Eigen::MatrixXd(n_x_, 2 * n_aug_ + 1);
+  // predicted sigma points matrix
+  x_sig_pred_ctrv_ = Eigen::MatrixXd(n_x_, 2 * n_aug_ + 1);
 
-    //create vector for weights
-    weights_ = Eigen::VectorXd(2 * n_aug_ + 1);
+  // predicted sigma points matrix
+  x_sig_pred_rm_ = Eigen::MatrixXd(n_x_, 2 * n_aug_ + 1);
 
+  //create vector for weights
+  weights_ = Eigen::VectorXd(2 * n_aug_ + 1);
 
-    count_ = 0;
-    count_empty_ = 0;
 
-    ini_u_.push_back(0.33);
-    ini_u_.push_back(0.33);
-    ini_u_.push_back(0.33);
+  count_ = 0;
+  count_empty_ = 0;
 
-    // different from paper, might be wrong
-    p1_.push_back(0.9);
-    p1_.push_back(0.05);
-    p1_.push_back(0.05);
+  ini_u_.push_back(0.33);
+  ini_u_.push_back(0.33);
+  ini_u_.push_back(0.33);
 
-    p2_.push_back(0.05);
-    p2_.push_back(0.9);
-    p2_.push_back(0.05);
+  // different from paper, might be wrong
+  p1_.push_back(0.9);
+  p1_.push_back(0.05);
+  p1_.push_back(0.05);
 
-    p3_.push_back(0.05);
-    p3_.push_back(0.05);
-    p3_.push_back(0.9);
+  p2_.push_back(0.05);
+  p2_.push_back(0.9);
+  p2_.push_back(0.05);
 
+  p3_.push_back(0.05);
+  p3_.push_back(0.05);
+  p3_.push_back(0.9);
 
-    mode_match_prob_cv2cv_ = 0;
-    mode_match_prob_ctrv2cv_ = 0;
-    mode_match_prob_rm2cv_ = 0;
 
-    mode_match_prob_cv2ctrv_ = 0;
-    mode_match_prob_ctrv2ctrv_ = 0;
-    mode_match_prob_rm2ctrv_ = 0;
+  mode_match_prob_cv2cv_ = 0;
+  mode_match_prob_ctrv2cv_ = 0;
+  mode_match_prob_rm2cv_ = 0;
 
-    mode_match_prob_cv2rm_ = 0;
-    mode_match_prob_ctrv2rm_ = 0;
-    mode_match_prob_rm2rm_ = 0;
+  mode_match_prob_cv2ctrv_ = 0;
+  mode_match_prob_ctrv2ctrv_ = 0;
+  mode_match_prob_rm2ctrv_ = 0;
 
-    mode_prob_cv_ = 0.33;
-    mode_prob_ctrv_ = 0.33;
-    mode_prob_rm_ = 0.33;
+  mode_match_prob_cv2rm_ = 0;
+  mode_match_prob_ctrv2rm_ = 0;
+  mode_match_prob_rm2rm_ = 0;
 
-    z_pred_cv_ = Eigen::VectorXd(2);
-    z_pred_ctrv_ =  Eigen::VectorXd(2);
-    z_pred_rm_ =  Eigen::VectorXd(2);
+  mode_prob_cv_ = 0.33;
+  mode_prob_ctrv_ = 0.33;
+  mode_prob_rm_ = 0.33;
 
+  z_pred_cv_ = Eigen::VectorXd(2);
+  z_pred_ctrv_ =  Eigen::VectorXd(2);
+  z_pred_rm_ =  Eigen::VectorXd(2);
 
-    s_cv_   = Eigen::MatrixXd(2,2);
-    s_ctrv_ = Eigen::MatrixXd(2,2);
-    s_rm_   = Eigen::MatrixXd(2,2);
 
-    k_cv_   = Eigen::MatrixXd(2,2);
-    k_ctrv_ = Eigen::MatrixXd(2,2);
-    k_rm_   = Eigen::MatrixXd(2,2);
+  s_cv_   = Eigen::MatrixXd(2,2);
+  s_ctrv_ = Eigen::MatrixXd(2,2);
+  s_rm_   = Eigen::MatrixXd(2,2);
 
+  k_cv_   = Eigen::MatrixXd(2,2);
+  k_ctrv_ = Eigen::MatrixXd(2,2);
+  k_rm_   = Eigen::MatrixXd(2,2);
 
 
-    gamma_g_ = 9.21;
-    pd_     = 0.9;
-    pg_     = 0.99;
 
-    //track parameter
-    lifetime_ = 0;
-    is_static_ = false;
+  gamma_g_ = 9.21;
+  pd_     = 0.9;
+  pg_     = 0.99;
 
-    //bounding box params
-    is_vis_bb_ = false;
-    best_yaw_ = 100;
-    bb_yaw_  = 0;
-    bb_area_ = 0;
+  //track parameter
+  lifetime_ = 0;
+  is_static_ = false;
 
-    //for env classification
-    init_meas_ = Eigen::VectorXd(2);
-    dist_from_init_ = 0;
+  //bounding box params
+  is_vis_bb_ = false;
+  best_yaw_ = 100;
+  bb_yaw_  = 0;
+  bb_area_ = 0;
 
-    x_merge_yaw_ = 0;
+  //for env classification
+  init_meas_ = Eigen::VectorXd(2);
+  dist_from_init_ = 0;
+
+  x_merge_yaw_ = 0;
 
 }
 
 
 void UKF::initialize(const Eigen::VectorXd z, const double timestamp)
 {
-    // first measurement
-    x_merge_ &lt;&lt; 1, 1, 0, 0, 0.1;
-
-    // init covariance matrix
-    p_merge_ &lt;&lt;   0.5,    0, 0, 0, 0,
-                    0,  0.5, 0, 0, 0,
-                    0,    0, 3, 0, 0,
-                    0,    0, 0,10, 0,
-                    0,    0, 0, 0, 1;
-
-    // set weights
-    double weight_0 = lambda_aug_ / (lambda_aug_ + n_aug_);
-    weights_(0) = weight_0;
-    for (int i = 1; i &lt; 2 * n_aug_ + 1; i++) 
-    {  //2n+1 weights
-        double weight = 0.5 / (n_aug_ + lambda_aug_);
-        weights_(i) = weight;
-    }
+  // first measurement
+  x_merge_ &lt;&lt; 1, 1, 0, 0, 0.1;
+
+  // init covariance matrix
+  p_merge_ &lt;&lt;   0.5,    0, 0, 0, 0,
+                  0,  0.5, 0, 0, 0,
+                  0,    0, 3, 0, 0,
+                  0,    0, 0,10, 0,
+                  0,    0, 0, 0, 1;
 
-    // init timestamp
-    time_ = timestamp;
+  // set weights
+  double weight_0 = lambda_aug_ / (lambda_aug_ + n_aug_);
+  weights_(0) = weight_0;
+  for (int i = 1; i &lt; 2 * n_aug_ + 1; i++)
+  {  //2n+1 weights
+      double weight = 0.5 / (n_aug_ + lambda_aug_);
+      weights_(i) = weight;
+  }
 
-    x_merge_(0) = z(0);
-    x_merge_(1) = z(1);
+  // init timestamp
+  time_ = timestamp;
 
-    z_pred_cv_(0) = z(0);
-    z_pred_cv_(1) = z(1);
+  x_merge_(0) = z(0);
+  x_merge_(1) = z(1);
 
-    z_pred_ctrv_(0) = z(0);
-    z_pred_ctrv_(1) = z(1);
+  z_pred_cv_(0) = z(0);
+  z_pred_cv_(1) = z(1);
 
-    z_pred_rm_(0) = z(0);
-    z_pred_rm_(1) = z(1);
+  z_pred_ctrv_(0) = z(0);
+  z_pred_ctrv_(1) = z(1);
 
+  z_pred_rm_(0) = z(0);
+  z_pred_rm_(1) = z(1);
 
-    x_cv_ = x_ctrv_ = x_rm_ = x_merge_;
-    p_cv_ = p_ctrv_ = p_rm_ = p_merge_;
 
-   
-    s_cv_   &lt;&lt;  1, 0,
-                 0, 1;
-    s_ctrv_ &lt;&lt;  1, 0,
-                 0, 1;
-    s_rm_   &lt;&lt;  1, 0,
-                 0, 1;
+  x_cv_ = x_ctrv_ = x_rm_ = x_merge_;
+  p_cv_ = p_ctrv_ = p_rm_ = p_merge_;
 
-    //init tracking num
-    tracking_num_ = 1;
 
-    //prevent transform pose error, if the condition meets, target_.jskBB_ would be updated
-    jsk_bb_.pose.orientation.x = 1.0;
+  s_cv_   &lt;&lt;  1, 0,
+               0, 1;
+  s_ctrv_ &lt;&lt;  1, 0,
+               0, 1;
+  s_rm_   &lt;&lt;  1, 0,
+               0, 1;
+
+  //init tracking num
+  tracking_num_ = 1;
+
+  //prevent transform pose error, if the condition meets, target_.jskBB_ would be updated
+  jsk_bb_.pose.orientation.x = 1.0;
 
 }
 
 
 void UKF::updateModeProb(const std::vector&lt;double&gt; lambda_vec)
 {
-    double cvGauss   = lambda_vec[0];
-    double ctrvGauss = lambda_vec[1];
-    double rmGauss   = lambda_vec[2];
-    double sumGauss  = cvGauss*mode_prob_cv_ + ctrvGauss*mode_prob_ctrv_ + rmGauss*mode_prob_rm_;
-    mode_prob_cv_   = (cvGauss  *mode_prob_cv_)  /sumGauss;
-    mode_prob_ctrv_ = (ctrvGauss*mode_prob_ctrv_)/sumGauss;
-    mode_prob_rm_   = (rmGauss  *mode_prob_rm_)  /sumGauss;
-    // prevent each prob from becoming 0
-    if(fabs(mode_prob_cv_)   &lt; 0.0001) mode_prob_cv_   = 0.0001;
-    if(fabs(mode_prob_ctrv_) &lt; 0.0001) mode_prob_ctrv_ = 0.0001;
-    if(fabs(mode_prob_rm_)   &lt; 0.0001) mode_prob_rm_   = 0.0001;
-
-    // cout &lt;&lt; endl&lt;&lt;"mode prob"&lt;&lt;endl&lt;&lt;"cv: "&lt;&lt;mode_prob_CV_&lt;&lt;endl&lt;&lt;"ctrv: "&lt;&lt;mode_prob_CTRV_&lt;&lt;endl&lt;&lt;"rm: "&lt;&lt;mode_prob_RM_&lt;&lt;endl;
+  double cvGauss   = lambda_vec[0];
+  double ctrvGauss = lambda_vec[1];
+  double rmGauss   = lambda_vec[2];
+  double sumGauss  = cvGauss*mode_prob_cv_ + ctrvGauss*mode_prob_ctrv_ + rmGauss*mode_prob_rm_;
+  mode_prob_cv_   = (cvGauss  *mode_prob_cv_)  /sumGauss;
+  mode_prob_ctrv_ = (ctrvGauss*mode_prob_ctrv_)/sumGauss;
+  mode_prob_rm_   = (rmGauss  *mode_prob_rm_)  /sumGauss;
+  // prevent each prob from becoming 0
+  if(fabs(mode_prob_cv_)   &lt; 0.0001) mode_prob_cv_   = 0.0001;
+  if(fabs(mode_prob_ctrv_) &lt; 0.0001) mode_prob_ctrv_ = 0.0001;
+  if(fabs(mode_prob_rm_)   &lt; 0.0001) mode_prob_rm_   = 0.0001;
+
+  // cout &lt;&lt; endl&lt;&lt;"mode prob"&lt;&lt;endl&lt;&lt;"cv: "&lt;&lt;mode_prob_CV_&lt;&lt;endl&lt;&lt;"ctrv: "&lt;&lt;mode_prob_CTRV_&lt;&lt;endl&lt;&lt;"rm: "&lt;&lt;mode_prob_RM_&lt;&lt;endl;
 }
 
 void UKF::updateYawWithHighProb()
 {
-    if(mode_prob_cv_ &gt; mode_prob_ctrv_)
+  if(mode_prob_cv_ &gt; mode_prob_ctrv_)
+  {
+    if(mode_prob_cv_ &gt; mode_prob_rm_)
+    {
+      x_merge_yaw_ = x_cv_(3);
+    }
+    else
+    {
+      x_merge_yaw_ = x_rm_(3);
+    }
+  }
+  else
+  {
+    if(mode_prob_ctrv_ &gt; mode_prob_rm_)
     {
-        if(mode_prob_cv_ &gt; mode_prob_rm_)
-        {
-            x_merge_yaw_ = x_cv_(3);
-        }
-        else
-        {
-            x_merge_yaw_ = x_rm_(3);
-        }
+      x_merge_yaw_ = x_ctrv_(3);
     }
     else
     {
-        if(mode_prob_ctrv_ &gt; mode_prob_rm_)
-        {
-            x_merge_yaw_ = x_ctrv_(3);
-        }
-        else
-        {
-            x_merge_yaw_ = x_rm_(3);
-        }
+      x_merge_yaw_ = x_rm_(3);
     }
-    x_merge_(3) = x_merge_yaw_;
+  }
+  x_merge_(3) = x_merge_yaw_;
 }
 
 void UKF::mergeEstimationAndCovariance()
 {
-    x_merge_ = mode_prob_cv_*x_cv_ + mode_prob_ctrv_ *x_ctrv_ + mode_prob_rm_ * x_rm_;
-    while (x_merge_(3)&gt; M_PI) x_merge_(3) -= 2.*M_PI;
-    while (x_merge_(3)&lt;-M_PI) x_merge_(3) += 2.*M_PI;
+  x_merge_ = mode_prob_cv_*x_cv_ + mode_prob_ctrv_ *x_ctrv_ + mode_prob_rm_ * x_rm_;
+  while (x_merge_(3)&gt; M_PI) x_merge_(3) -= 2.*M_PI;
+  while (x_merge_(3)&lt;-M_PI) x_merge_(3) += 2.*M_PI;
 
-    // not interacting yaw(-pi ~ pi)
-    updateYawWithHighProb();
+  // not interacting yaw(-pi ~ pi)
+  updateYawWithHighProb();
 
-    p_merge_ = mode_prob_cv_  *(p_cv_   +(x_cv_   - x_merge_)*(x_cv_   - x_merge_).transpose()) +
-               mode_prob_ctrv_*(p_ctrv_ +(x_ctrv_ - x_merge_)*(x_ctrv_ - x_merge_).transpose())+
-               mode_prob_rm_  *(p_rm_   +(x_rm_   - x_merge_)*(x_rm_   - x_merge_).transpose());
+  p_merge_ = mode_prob_cv_  *(p_cv_   +(x_cv_   - x_merge_)*(x_cv_   - x_merge_).transpose()) +
+             mode_prob_ctrv_*(p_ctrv_ +(x_ctrv_ - x_merge_)*(x_ctrv_ - x_merge_).transpose())+
+             mode_prob_rm_  *(p_rm_   +(x_rm_   - x_merge_)*(x_rm_   - x_merge_).transpose());
 
 }
 
 void UKF::mixingProbability()
 {
-    double sumProb1 = mode_prob_cv_*p1_[0]+mode_prob_ctrv_*p2_[0]+mode_prob_rm_*p3_[0];
-    double sumProb2 = mode_prob_cv_*p1_[1]+mode_prob_ctrv_*p2_[1]+mode_prob_rm_*p3_[1];
-    double sumProb3 = mode_prob_cv_*p1_[2]+mode_prob_ctrv_*p2_[2]+mode_prob_rm_*p3_[2];
-    mode_match_prob_cv2cv_     = mode_prob_cv_  *p1_[0]/sumProb1;
-    mode_match_prob_ctrv2cv_   = mode_prob_ctrv_*p2_[0]/sumProb1;
-    mode_match_prob_rm2cv_     = mode_prob_rm_  *p3_[0]/sumProb1;
-
-    mode_match_prob_cv2ctrv_   = mode_prob_cv_  *p1_[1]/sumProb2;
-    mode_match_prob_ctrv2ctrv_ = mode_prob_ctrv_*p2_[1]/sumProb2;
-    mode_match_prob_rm2ctrv_   = mode_prob_rm_  *p3_[1]/sumProb2;
-
-    mode_match_prob_cv2rm_     = mode_prob_cv_  *p1_[2]/sumProb3;
-    mode_match_prob_ctrv2rm_   = mode_prob_ctrv_*p2_[2]/sumProb3;
-    mode_match_prob_rm2rm_     = mode_prob_rm_  *p3_[2]/sumProb3;
-
+  double sumProb1 = mode_prob_cv_*p1_[0]+mode_prob_ctrv_*p2_[0]+mode_prob_rm_*p3_[0];
+  double sumProb2 = mode_prob_cv_*p1_[1]+mode_prob_ctrv_*p2_[1]+mode_prob_rm_*p3_[1];
+  double sumProb3 = mode_prob_cv_*p1_[2]+mode_prob_ctrv_*p2_[2]+mode_prob_rm_*p3_[2];
+  mode_match_prob_cv2cv_     = mode_prob_cv_  *p1_[0]/sumProb1;
+  mode_match_prob_ctrv2cv_   = mode_prob_ctrv_*p2_[0]/sumProb1;
+  mode_match_prob_rm2cv_     = mode_prob_rm_  *p3_[0]/sumProb1;
+
+  mode_match_prob_cv2ctrv_   = mode_prob_cv_  *p1_[1]/sumProb2;
+  mode_match_prob_ctrv2ctrv_ = mode_prob_ctrv_*p2_[1]/sumProb2;
+  mode_match_prob_rm2ctrv_   = mode_prob_rm_  *p3_[1]/sumProb2;
+
+  mode_match_prob_cv2rm_     = mode_prob_cv_  *p1_[2]/sumProb3;
+  mode_match_prob_ctrv2rm_   = mode_prob_ctrv_*p2_[2]/sumProb3;
+  mode_match_prob_rm2rm_     = mode_prob_rm_  *p3_[2]/sumProb3;
 }
 
 
-void UKF::interaction() 
+void UKF::interaction()
 {
-
-    Eigen::MatrixXd x_pre_cv   = x_cv_;
-    Eigen::MatrixXd x_pre_ctrv = x_ctrv_;
-    Eigen::MatrixXd x_pre_rm   = x_rm_;
-    Eigen::MatrixXd p_pre_cv   = p_cv_;
-    Eigen::MatrixXd p_pre_ctrv = p_ctrv_;
-    Eigen::MatrixXd p_pre_rm   = p_rm_;
-    x_cv_   = mode_match_prob_cv2cv_  *x_pre_cv + mode_match_prob_ctrv2cv_  *x_pre_ctrv + mode_match_prob_rm2cv_  *x_pre_rm;
-    x_ctrv_ = mode_match_prob_cv2ctrv_*x_pre_cv + mode_match_prob_ctrv2ctrv_*x_pre_ctrv + mode_match_prob_rm2ctrv_*x_pre_rm;
-    x_rm_   = mode_match_prob_cv2rm_  *x_pre_cv + mode_match_prob_ctrv2rm_  *x_pre_ctrv + mode_match_prob_rm2rm_*x_pre_rm;
-
-    // not interacting yaw(-pi ~ pi)
-    x_cv_(3)   = x_pre_cv(3);
-    x_ctrv_(3) = x_pre_ctrv(3);
-    x_rm_(3)   = x_pre_rm(3);
-
-    // normalizing angle
-    while (x_cv_(3)  &gt; M_PI) x_cv_(3)   -= 2.*M_PI;
-    while (x_cv_(3)  &lt;-M_PI) x_cv_(3)   += 2.*M_PI;
-    while (x_ctrv_(3)&gt; M_PI) x_ctrv_(3) -= 2.*M_PI;
-    while (x_ctrv_(3)&lt;-M_PI) x_ctrv_(3) += 2.*M_PI;
-    while (x_rm_(3)  &gt; M_PI) x_rm_(3)   -= 2.*M_PI;
-    while (x_rm_(3)  &lt;-M_PI) x_rm_(3)   += 2.*M_PI;
-
-    p_cv_   = mode_match_prob_cv2cv_    *(p_pre_cv  +(x_pre_cv -  x_cv_)*   (x_pre_cv -  x_cv_).transpose()) +
-              mode_match_prob_ctrv2cv_  *(p_pre_ctrv+(x_pre_ctrv -x_cv_)*   (x_pre_ctrv -x_cv_).transpose())+
-              mode_match_prob_rm2cv_    *(p_pre_rm + (x_pre_rm -  x_cv_)*   (x_pre_rm -  x_cv_).transpose());
-    p_ctrv_ = mode_match_prob_cv2ctrv_  *(p_pre_cv+  (x_pre_cv -  x_ctrv_)* (x_pre_cv-   x_ctrv_).transpose()) +
-              mode_match_prob_ctrv2ctrv_*(p_pre_ctrv+(x_pre_ctrv -x_ctrv_)* (x_pre_ctrv -x_ctrv_).transpose())+
-              mode_match_prob_rm2ctrv_  *(p_pre_rm + (x_pre_rm -  x_ctrv_)* (x_pre_rm -  x_ctrv_).transpose());
-    p_rm_   = mode_match_prob_cv2rm_    *(p_pre_cv+  (x_pre_cv -  x_rm_)*   (x_pre_cv -  x_rm_).transpose()) +
-              mode_match_prob_ctrv2rm_  *(p_pre_ctrv+(x_pre_ctrv -x_rm_)*   (x_pre_ctrv -x_rm_).transpose())+
-              mode_match_prob_rm2rm_    *(p_pre_rm + (x_pre_rm -  x_rm_)*   (x_pre_rm -  x_rm_).transpose());
-
+  Eigen::MatrixXd x_pre_cv   = x_cv_;
+  Eigen::MatrixXd x_pre_ctrv = x_ctrv_;
+  Eigen::MatrixXd x_pre_rm   = x_rm_;
+  Eigen::MatrixXd p_pre_cv   = p_cv_;
+  Eigen::MatrixXd p_pre_ctrv = p_ctrv_;
+  Eigen::MatrixXd p_pre_rm   = p_rm_;
+  x_cv_   = mode_match_prob_cv2cv_  *x_pre_cv + mode_match_prob_ctrv2cv_  *x_pre_ctrv + mode_match_prob_rm2cv_  *x_pre_rm;
+  x_ctrv_ = mode_match_prob_cv2ctrv_*x_pre_cv + mode_match_prob_ctrv2ctrv_*x_pre_ctrv + mode_match_prob_rm2ctrv_*x_pre_rm;
+  x_rm_   = mode_match_prob_cv2rm_  *x_pre_cv + mode_match_prob_ctrv2rm_  *x_pre_ctrv + mode_match_prob_rm2rm_*x_pre_rm;
+
+  // not interacting yaw(-pi ~ pi)
+  x_cv_(3)   = x_pre_cv(3);
+  x_ctrv_(3) = x_pre_ctrv(3);
+  x_rm_(3)   = x_pre_rm(3);
+
+  // normalizing angle
+  while (x_cv_(3)  &gt; M_PI) x_cv_(3)   -= 2.*M_PI;
+  while (x_cv_(3)  &lt;-M_PI) x_cv_(3)   += 2.*M_PI;
+  while (x_ctrv_(3)&gt; M_PI) x_ctrv_(3) -= 2.*M_PI;
+  while (x_ctrv_(3)&lt;-M_PI) x_ctrv_(3) += 2.*M_PI;
+  while (x_rm_(3)  &gt; M_PI) x_rm_(3)   -= 2.*M_PI;
+  while (x_rm_(3)  &lt;-M_PI) x_rm_(3)   += 2.*M_PI;
+
+  p_cv_   = mode_match_prob_cv2cv_    *(p_pre_cv  +(x_pre_cv -  x_cv_)*   (x_pre_cv -  x_cv_).transpose()) +
+            mode_match_prob_ctrv2cv_  *(p_pre_ctrv+(x_pre_ctrv -x_cv_)*   (x_pre_ctrv -x_cv_).transpose())+
+            mode_match_prob_rm2cv_    *(p_pre_rm + (x_pre_rm -  x_cv_)*   (x_pre_rm -  x_cv_).transpose());
+  p_ctrv_ = mode_match_prob_cv2ctrv_  *(p_pre_cv+  (x_pre_cv -  x_ctrv_)* (x_pre_cv-   x_ctrv_).transpose()) +
+            mode_match_prob_ctrv2ctrv_*(p_pre_ctrv+(x_pre_ctrv -x_ctrv_)* (x_pre_ctrv -x_ctrv_).transpose())+
+            mode_match_prob_rm2ctrv_  *(p_pre_rm + (x_pre_rm -  x_ctrv_)* (x_pre_rm -  x_ctrv_).transpose());
+  p_rm_   = mode_match_prob_cv2rm_    *(p_pre_cv+  (x_pre_cv -  x_rm_)*   (x_pre_cv -  x_rm_).transpose()) +
+            mode_match_prob_ctrv2rm_  *(p_pre_ctrv+(x_pre_ctrv -x_rm_)*   (x_pre_ctrv -x_rm_).transpose())+
+            mode_match_prob_rm2rm_    *(p_pre_rm + (x_pre_rm -  x_rm_)*   (x_pre_rm -  x_rm_).transpose());
 }
 
 
@@ -349,122 +346,121 @@ void UKF::interaction()
 * @param {MeasurementPackage} meas_package The latest measurement data of
 * either radar or laser.
 */
-void UKF::predictionIMMUKF(const double dt) 
+void UKF::predictionIMMUKF(const double dt)
 {
-    /*****************************************************************************
-    *  IMM Mixing and Interaction
-    ****************************************************************************/
-    mixingProbability();
-    interaction();
-    /*****************************************************************************
-    *  Prediction
-    ****************************************************************************/
-    prediction(dt, 0);
-    prediction(dt, 1);
-    prediction(dt, 2);
-
-    /*****************************************************************************
-    *  Update
-    ****************************************************************************/
-    updateLidar(0);
-    updateLidar(1);
-    updateLidar(2);
+  /*****************************************************************************
+  *  IMM Mixing and Interaction
+  ****************************************************************************/
+  mixingProbability();
+  interaction();
+  /*****************************************************************************
+  *  Prediction
+  ****************************************************************************/
+  prediction(dt, 0);
+  prediction(dt, 1);
+  prediction(dt, 2);
+
+  /*****************************************************************************
+  *  Update
+  ****************************************************************************/
+  updateLidar(0);
+  updateLidar(1);
+  updateLidar(2);
 
 }
 
-void UKF::postProcessIMMUKF(const std::vector&lt;double&gt; lambda_vec) 
+void UKF::updateIMMUKF(const std::vector&lt;double&gt; lambda_vec)
 {
-    /*****************************************************************************
-    *  IMM Merge Step
-    ****************************************************************************/
-    updateModeProb(lambda_vec);
-    mergeEstimationAndCovariance();
+  /*****************************************************************************
+  *  IMM Merge Step
+  ****************************************************************************/
+  updateModeProb(lambda_vec);
+  mergeEstimationAndCovariance();
 }
 
 
 
-void UKF::ctrv(const double p_x, const double p_y, const double v, const double yaw, const double yawd, 
+void UKF::ctrv(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
                const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state)
 {
-    //predicted state values
-    double px_p, py_p;
-
-    //avoid division by zero
-    if (fabs(yawd) &gt; 0.001) 
-    {
-        px_p = p_x + v / yawd * (sin(yaw + yawd * delta_t) - sin(yaw));
-        py_p = p_y + v / yawd * (cos(yaw) - cos(yaw + yawd * delta_t));
-    }
-    else 
-    {
-        px_p = p_x + v * delta_t * cos(yaw);
-        py_p = p_y + v * delta_t * sin(yaw);
-    }
-    double v_p = v;
-    double yaw_p = yaw + yawd * delta_t;
-    double yawd_p = yawd;
-
-    //add noise
-    px_p = px_p + 0.5 * nu_a * delta_t * delta_t * cos(yaw);
-    py_p = py_p + 0.5 * nu_a * delta_t * delta_t * sin(yaw);
-    v_p = v_p + nu_a*delta_t;
-
-    yaw_p = yaw_p + 0.5*nu_yawdd*delta_t*delta_t;
-    yawd_p = yawd_p + nu_yawdd*delta_t;
-
-
-    state[0] = px_p;
-    state[1] = py_p;
-    state[2] = v_p;
-    state[3] = yaw_p;
-    state[4] = yawd_p;
+  //predicted state values
+  double px_p, py_p;
+
+  //avoid division by zero
+  if (fabs(yawd) &gt; 0.001)
+  {
+    px_p = p_x + v / yawd * (sin(yaw + yawd * delta_t) - sin(yaw));
+    py_p = p_y + v / yawd * (cos(yaw) - cos(yaw + yawd * delta_t));
+  }
+  else
+  {
+    px_p = p_x + v * delta_t * cos(yaw);
+    py_p = p_y + v * delta_t * sin(yaw);
+  }
+  double v_p = v;
+  double yaw_p = yaw + yawd * delta_t;
+  double yawd_p = yawd;
+
+  //add noise
+  px_p = px_p + 0.5 * nu_a * delta_t * delta_t * cos(yaw);
+  py_p = py_p + 0.5 * nu_a * delta_t * delta_t * sin(yaw);
+  v_p = v_p + nu_a*delta_t;
+
+  yaw_p = yaw_p + 0.5*nu_yawdd*delta_t*delta_t;
+  yawd_p = yawd_p + nu_yawdd*delta_t;
+
+
+  state[0] = px_p;
+  state[1] = py_p;
+  state[2] = v_p;
+  state[3] = yaw_p;
+  state[4] = yawd_p;
 }
 
-void UKF::cv(const double p_x, const double p_y, const double v, const double yaw, const double yawd, 
-               const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state) 
+void UKF::cv(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
+               const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state)
 {
-    //predicted state values
-    double px_p = p_x + v*cos(yaw)*delta_t;
-    double py_p = p_y + v*sin(yaw)*delta_t;
+  //predicted state values
+  double px_p = p_x + v*cos(yaw)*delta_t;
+  double py_p = p_y + v*sin(yaw)*delta_t;
 
-    double v_p = v;
-    // not sure which one, works better in curve by using yaw
-    double yaw_p = yaw;
+  double v_p = v;
+  // not sure which one, works better in curve by using yaw
+  double yaw_p = yaw;
 //    double yaw_p = 0;
-    double yawd_p = yawd;
-
-    //add noise
-    px_p = px_p + 0.5 * nu_a * delta_t * delta_t * cos(yaw);
-    py_p = py_p + 0.5 * nu_a * delta_t * delta_t * sin(yaw);
-    v_p = v_p + nu_a*delta_t;
+  double yawd_p = yawd;
 
-    yaw_p = yaw_p + 0.5*nu_yawdd*delta_t*delta_t;
-    yawd_p = yawd_p + nu_yawdd*delta_t;
+  //add noise
+  px_p = px_p + 0.5 * nu_a * delta_t * delta_t * cos(yaw);
+  py_p = py_p + 0.5 * nu_a * delta_t * delta_t * sin(yaw);
+  v_p = v_p + nu_a*delta_t;
 
-    state[0] = px_p;
-    state[1] = py_p;
-    state[2] = v_p;
-    state[3] = yaw_p;
-    state[4] = yawd_p;
+  yaw_p = yaw_p + 0.5*nu_yawdd*delta_t*delta_t;
+  yawd_p = yawd_p + nu_yawdd*delta_t;
 
+  state[0] = px_p;
+  state[1] = py_p;
+  state[2] = v_p;
+  state[3] = yaw_p;
+  state[4] = yawd_p;
 }
 
 
-void UKF::randomMotion(const double p_x, const double p_y, const double v, const double yaw, const double yawd, 
-               const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state) 
+void UKF::randomMotion(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
+               const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state)
 {
-    double px_p   = p_x;
-    double py_p   = p_y;
-    double v_p    = v;
-
-    double yaw_p  = yaw;
-    double yawd_p = yawd;
-
-    state[0] = px_p;
-    state[1] = py_p;
-    state[2] = v_p;
-    state[3] = yaw_p;
-    state[4] = yawd_p;
+  double px_p   = p_x;
+  double py_p   = p_y;
+  double v_p    = v;
+
+  double yaw_p  = yaw;
+  double yawd_p = yawd;
+
+  state[0] = px_p;
+  state[1] = py_p;
+  state[2] = v_p;
+  state[3] = yaw_p;
+  state[4] = yawd_p;
 }
 
 /**
@@ -472,274 +468,273 @@ void UKF::randomMotion(const double p_x, const double p_y, const double v, const
 * @param {double} delta_t the change in time (in seconds) between the last
 * measurement and this one.
 */
-void UKF::prediction(const double delta_t, const int model_ind) 
+void UKF::prediction(const double delta_t, const int model_ind)
 {
-    /*****************************************************************************
-   *  Initialize model parameters
-   ****************************************************************************/
-    double std_yawdd, std_a;
-    Eigen::MatrixXd x_(x_cv_.rows(), 1);
-    Eigen::MatrixXd p_(p_cv_.rows(),p_cv_.cols());
-    Eigen::MatrixXd x_sig_pred_(x_sig_pred_cv_.rows(), x_sig_pred_cv_.cols());
-    if(model_ind == 0)
-    {
-        x_ = x_cv_.col(0);
-        p_ = p_cv_;
-        x_sig_pred_ = x_sig_pred_cv_;
-        std_yawdd = std_cv_yawdd_;
-        std_a     = std_a_cv_;
-    }
-    else if(model_ind == 1)
-    {
-        x_ = x_ctrv_.col(0);
-        p_ = p_ctrv_;
-        x_sig_pred_ = x_sig_pred_ctrv_;
-        std_yawdd = std_ctrv_yawdd_;
-        std_a     = std_a_ctrv_;
-    }
-    else
-    {
-        x_ = x_rm_.col(0);
-        p_ = p_rm_;
-        x_sig_pred_ = x_sig_pred_rm_;
-        std_yawdd = std_rm_yawdd_;
-        std_a     = std_a_rm_;
-    }
-
-    /*****************************************************************************
-    *  Augment Sigma Points
-    ****************************************************************************/
-    //create augmented mean vector
-    Eigen::VectorXd x_aug = Eigen::VectorXd(n_aug_);
-
-    //create augmented state covariance
-    Eigen::MatrixXd p_aug = Eigen::MatrixXd(n_aug_, n_aug_);
-
-    //create sigma point matrix
-    Eigen::MatrixXd x_sig_aug = Eigen::MatrixXd(n_aug_, 2 * n_aug_ + 1);
-
-    //create augmented mean state
-    x_aug.head(5) = x_;
-    x_aug(5) = 0;
-    x_aug(6) = 0;
-
-    //create augmented covariance matrix
-    p_aug.fill(0.0);
-    p_aug.topLeftCorner(5, 5) = p_;
-    p_aug(5, 5) = std_a*std_a;
-    p_aug(6, 6) = std_yawdd*std_yawdd;
-
-    //create square root matrix
-    Eigen::MatrixXd L = p_aug.llt().matrixL();
-
-    //create augmented sigma points
-    x_sig_aug.col(0) = x_aug;
-    for (int i = 0; i&lt; n_aug_; i++)
-    {
-        x_sig_aug.col(i + 1) = x_aug + sqrt(lambda_aug_ + n_aug_) * L.col(i);
-        x_sig_aug.col(i + 1 + n_aug_) = x_aug - sqrt(lambda_aug_ + n_aug_) * L.col(i);
-    }
-
-    /*****************************************************************************
-    *  Predict Sigma Points
-    ****************************************************************************/
-    //predict sigma points
-    for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
-    {
-        //extract values for better readability
-        double p_x      = x_sig_aug(0, i);
-        double p_y      = x_sig_aug(1, i);
-        double v        = x_sig_aug(2, i);
-        double yaw      = x_sig_aug(3, i);
-        double yawd     = x_sig_aug(4, i);
-        double nu_a     = x_sig_aug(5, i);
-        double nu_yawdd = x_sig_aug(6, i);
-
-        std::vector&lt;double&gt; state(5);
-        if(model_ind == 0)        cv(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
-        else if(model_ind == 1) ctrv(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
-        else           randomMotion(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
-
-        //write predicted sigma point into right column
-        x_sig_pred_(0, i) = state[0];
-        x_sig_pred_(1, i) = state[1];
-        x_sig_pred_(2, i) = state[2];
-        x_sig_pred_(3, i) = state[3];
-        x_sig_pred_(4, i) = state[4];
-    }
-
-
-    /*****************************************************************************
-    *  Convert Predicted Sigma Points to Mean/Covariance
-    ****************************************************************************/
-    //predicted state mean
-    x_.fill(0.0);
-    for (int i = 0; i &lt; 2 * n_aug_ + 1; i++) 
-    {  //iterate over sigma points
-        x_ = x_ + weights_(i) * x_sig_pred_.col(i);
-    }
-
-    while (x_(3)&gt; M_PI) x_(3) -= 2.*M_PI;
-    while (x_(3)&lt;-M_PI) x_(3) += 2.*M_PI;
-    //predicted state covariance matrix
-    p_.fill(0.0);
-    for (int i = 0; i &lt; 2 * n_aug_ + 1; i++) 
-    {  //iterate over sigma points
-        // state difference
-        Eigen::VectorXd x_diff = x_sig_pred_.col(i) - x_;
-        //angle normalization
-        while (x_diff(3)&gt; M_PI) x_diff(3) -= 2.*M_PI;
-        while (x_diff(3)&lt;-M_PI) x_diff(3) += 2.*M_PI;
-        p_ = p_ + weights_(i) * x_diff * x_diff.transpose();
-    }
-
-    /*****************************************************************************
-    *  Update model parameters
-    ****************************************************************************/
-    if(model_ind == 0)
-    {
-        x_cv_.col(0) = x_;
-        p_cv_ = p_;
-        x_sig_pred_cv_ = x_sig_pred_;
-    }
-    else if(model_ind == 1)
-    {
-        x_ctrv_.col(0) = x_;
-        p_ctrv_ = p_;
-        x_sig_pred_ctrv_ = x_sig_pred_;
-    }
-    else
-    {
-        x_rm_.col(0) = x_;
-        p_rm_ = p_;
-        x_sig_pred_rm_ = x_sig_pred_;
-    }
+  /*****************************************************************************
+ *  Initialize model parameters
+ ****************************************************************************/
+  double std_yawdd, std_a;
+  Eigen::MatrixXd x_(x_cv_.rows(), 1);
+  Eigen::MatrixXd p_(p_cv_.rows(),p_cv_.cols());
+  Eigen::MatrixXd x_sig_pred_(x_sig_pred_cv_.rows(), x_sig_pred_cv_.cols());
+  if(model_ind == 0)
+  {
+    x_ = x_cv_.col(0);
+    p_ = p_cv_;
+    x_sig_pred_ = x_sig_pred_cv_;
+    std_yawdd = std_cv_yawdd_;
+    std_a     = std_a_cv_;
+  }
+  else if(model_ind == 1)
+  {
+    x_ = x_ctrv_.col(0);
+    p_ = p_ctrv_;
+    x_sig_pred_ = x_sig_pred_ctrv_;
+    std_yawdd = std_ctrv_yawdd_;
+    std_a     = std_a_ctrv_;
+  }
+  else
+  {
+    x_ = x_rm_.col(0);
+    p_ = p_rm_;
+    x_sig_pred_ = x_sig_pred_rm_;
+    std_yawdd = std_rm_yawdd_;
+    std_a     = std_a_rm_;
+  }
+
+  /*****************************************************************************
+  *  Augment Sigma Points
+  ****************************************************************************/
+  //create augmented mean vector
+  Eigen::VectorXd x_aug = Eigen::VectorXd(n_aug_);
+
+  //create augmented state covariance
+  Eigen::MatrixXd p_aug = Eigen::MatrixXd(n_aug_, n_aug_);
+
+  //create sigma point matrix
+  Eigen::MatrixXd x_sig_aug = Eigen::MatrixXd(n_aug_, 2 * n_aug_ + 1);
+
+  //create augmented mean state
+  x_aug.head(5) = x_;
+  x_aug(5) = 0;
+  x_aug(6) = 0;
+
+  //create augmented covariance matrix
+  p_aug.fill(0.0);
+  p_aug.topLeftCorner(5, 5) = p_;
+  p_aug(5, 5) = std_a*std_a;
+  p_aug(6, 6) = std_yawdd*std_yawdd;
+
+  //create square root matrix
+  Eigen::MatrixXd L = p_aug.llt().matrixL();
+
+  //create augmented sigma points
+  x_sig_aug.col(0) = x_aug;
+  for (int i = 0; i&lt; n_aug_; i++)
+  {
+    x_sig_aug.col(i + 1) = x_aug + sqrt(lambda_aug_ + n_aug_) * L.col(i);
+    x_sig_aug.col(i + 1 + n_aug_) = x_aug - sqrt(lambda_aug_ + n_aug_) * L.col(i);
+  }
+
+  /*****************************************************************************
+  *  Predict Sigma Points
+  ****************************************************************************/
+  //predict sigma points
+  for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
+  {
+    //extract values for better readability
+    double p_x      = x_sig_aug(0, i);
+    double p_y      = x_sig_aug(1, i);
+    double v        = x_sig_aug(2, i);
+    double yaw      = x_sig_aug(3, i);
+    double yawd     = x_sig_aug(4, i);
+    double nu_a     = x_sig_aug(5, i);
+    double nu_yawdd = x_sig_aug(6, i);
+
+    std::vector&lt;double&gt; state(5);
+    if(model_ind == 0)        cv(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
+    else if(model_ind == 1) ctrv(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
+    else           randomMotion(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
+
+    //write predicted sigma point into right column
+    x_sig_pred_(0, i) = state[0];
+    x_sig_pred_(1, i) = state[1];
+    x_sig_pred_(2, i) = state[2];
+    x_sig_pred_(3, i) = state[3];
+    x_sig_pred_(4, i) = state[4];
+  }
+
+
+  /*****************************************************************************
+  *  Convert Predicted Sigma Points to Mean/Covariance
+  ****************************************************************************/
+  //predicted state mean
+  x_.fill(0.0);
+  for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
+  {  //iterate over sigma points
+    x_ = x_ + weights_(i) * x_sig_pred_.col(i);
+  }
+
+  while (x_(3)&gt; M_PI) x_(3) -= 2.*M_PI;
+  while (x_(3)&lt;-M_PI) x_(3) += 2.*M_PI;
+  //predicted state covariance matrix
+  p_.fill(0.0);
+  for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
+  {  //iterate over sigma points
+    // state difference
+    Eigen::VectorXd x_diff = x_sig_pred_.col(i) - x_;
+    //angle normalization
+    while (x_diff(3)&gt; M_PI) x_diff(3) -= 2.*M_PI;
+    while (x_diff(3)&lt;-M_PI) x_diff(3) += 2.*M_PI;
+    p_ = p_ + weights_(i) * x_diff * x_diff.transpose();
+  }
+
+  /*****************************************************************************
+  *  Update model parameters
+  ****************************************************************************/
+  if(model_ind == 0)
+  {
+    x_cv_.col(0) = x_;
+    p_cv_ = p_;
+    x_sig_pred_cv_ = x_sig_pred_;
+  }
+  else if(model_ind == 1)
+  {
+    x_ctrv_.col(0) = x_;
+    p_ctrv_ = p_;
+    x_sig_pred_ctrv_ = x_sig_pred_;
+  }
+  else
+  {
+    x_rm_.col(0) = x_;
+    p_rm_ = p_;
+    x_sig_pred_rm_ = x_sig_pred_;
+  }
 }
 
 /**
 * Updates the state and the state covariance matrix using a laser measurement.
 * @param {MeasurementPackage} meas_package
 */
-void UKF::updateLidar(const int model_ind) 
+void UKF::updateLidar(const int model_ind)
 {
-    // TODO refactoring
-    /*****************************************************************************
-   *  Initialize model parameters
-   ****************************************************************************/
-    Eigen::VectorXd x(x_cv_.rows());
-    Eigen::MatrixXd P(p_cv_.rows(),p_cv_.cols());
-    Eigen::MatrixXd x_sig_pred(x_sig_pred_cv_.rows(), x_sig_pred_cv_.cols());
-    if(model_ind == 0)
-    {
-        x = x_cv_.col(0);
-        P = p_cv_;
-        x_sig_pred = x_sig_pred_cv_;
-    }
-    else if(model_ind == 1)
-    {
-        x = x_ctrv_.col(0);
-        P = p_ctrv_;
-        x_sig_pred = x_sig_pred_ctrv_;
-    }
-    else
-    {
-        x = x_rm_.col(0);
-        P = p_rm_;
-        x_sig_pred = x_sig_pred_rm_;
-    }
-
-    //set measurement dimension, lidar can measure p_x and p_y
-    int n_z = 2;
-
-    //create matrix for sigma points in measurement space
-    Eigen::MatrixXd z_sig = Eigen::MatrixXd(n_z, 2 * n_aug_ + 1);
-
-    //transform sigma points into measurement space
-    for (int i = 0; i &lt; 2 * n_aug_ + 1; i++) 
-    {  //2n+1 simga points
-
-        // extract values for better readibility
-        double p_x = x_sig_pred(0, i);
-        double p_y = x_sig_pred(1, i);
-
-        // measurement model
-        z_sig(0, i) = p_x;
-        z_sig(1, i) = p_y;
-    }
-
-    //mean predicted measurement
-    Eigen::VectorXd z_pred = Eigen::VectorXd(n_z);
-    z_pred.fill(0.0);
-    for (int i = 0; i &lt; 2 * n_aug_ + 1; i++) 
-    {
-        z_pred = z_pred + weights_(i) * z_sig.col(i);
-    }
-
-    //measurement covariance matrix S
-    Eigen::MatrixXd S = Eigen::MatrixXd(n_z, n_z);
-    S.fill(0.0);
-    for (int i = 0; i &lt; 2 * n_aug_ + 1; i++) 
-    {  //2n+1 simga points
-        //residual
-        Eigen::VectorXd z_diff = z_sig.col(i) - z_pred;
-        S = S + weights_(i) * z_diff * z_diff.transpose();
-    }
-
-    //add measurement noise covariance matrix
-    Eigen::MatrixXd R = Eigen::MatrixXd(n_z, n_z);
-    R &lt;&lt; std_laspx_*std_laspx_, 0,
-            0, std_laspy_*std_laspy_;
-    S = S + R;
-
-    //create matrix for cross correlation Tc
-    Eigen::MatrixXd Tc = Eigen::MatrixXd(n_x_, n_z);
-
-    /*****************************************************************************
-    *  UKF Update for Lidar
-    ****************************************************************************/
-    //calculate cross correlation matrix
-    Tc.fill(0.0);
-    for (int i = 0; i &lt; 2 * n_aug_ + 1; i++) 
-    {  //2n+1 simga points
-        //residual
-        Eigen::VectorXd z_diff = z_sig.col(i) - z_pred;
-        // state difference
-        Eigen::VectorXd x_diff = x_sig_pred.col(i) - x;
-
-        Tc = Tc + weights_(i) * x_diff * z_diff.transpose();
-    }
-
-    //Kalman gain K;
-    Eigen::MatrixXd K = Tc * S.inverse();
-
-    /*****************************************************************************
-    *  Update model parameters
-    ****************************************************************************/
-    if(model_ind == 0)
-    {
-        x_cv_.col(0)  = x;
-        p_cv_         = P;
-        x_sig_pred_cv_ = x_sig_pred;
-        z_pred_cv_     = z_pred;
-        s_cv_        = S;
-        k_cv_         = K;
-    }
-    else if(model_ind == 1)
-    {
-        x_ctrv_.col(0)  = x;
-        p_ctrv_         = P;
-        x_sig_pred_ctrv_ = x_sig_pred;
-        z_pred_ctrv_     = z_pred;
-        s_ctrv_        = S;
-        k_ctrv_         = K;
-    }
-    else
-    {
-        x_rm_.col(0)    = x;
-        p_rm_           = P;
-        x_sig_pred_rm_   = x_sig_pred;
-        z_pred_rm_       = z_pred;
-        s_rm_          = S;
-        k_rm_           = K;
-    }
-}
\ No newline at end of file
+  // TODO refactoring
+  /*****************************************************************************
+ *  Initialize model parameters
+ ****************************************************************************/
+  Eigen::VectorXd x(x_cv_.rows());
+  Eigen::MatrixXd P(p_cv_.rows(),p_cv_.cols());
+  Eigen::MatrixXd x_sig_pred(x_sig_pred_cv_.rows(), x_sig_pred_cv_.cols());
+  if(model_ind == 0)
+  {
+    x = x_cv_.col(0);
+    P = p_cv_;
+    x_sig_pred = x_sig_pred_cv_;
+  }
+  else if(model_ind == 1)
+  {
+    x = x_ctrv_.col(0);
+    P = p_ctrv_;
+    x_sig_pred = x_sig_pred_ctrv_;
+  }
+  else
+  {
+    x = x_rm_.col(0);
+    P = p_rm_;
+    x_sig_pred = x_sig_pred_rm_;
+  }
+
+  //set measurement dimension, lidar can measure p_x and p_y
+  int n_z = 2;
+
+  //create matrix for sigma points in measurement space
+  Eigen::MatrixXd z_sig = Eigen::MatrixXd(n_z, 2 * n_aug_ + 1);
+
+  //transform sigma points into measurement space
+  for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
+  {  //2n+1 simga points
+    // extract values for better readibility
+    double p_x = x_sig_pred(0, i);
+    double p_y = x_sig_pred(1, i);
+
+    // measurement model
+    z_sig(0, i) = p_x;
+    z_sig(1, i) = p_y;
+  }
+
+  //mean predicted measurement
+  Eigen::VectorXd z_pred = Eigen::VectorXd(n_z);
+  z_pred.fill(0.0);
+  for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
+  {
+    z_pred = z_pred + weights_(i) * z_sig.col(i);
+  }
+
+  //measurement covariance matrix S
+  Eigen::MatrixXd S = Eigen::MatrixXd(n_z, n_z);
+  S.fill(0.0);
+  for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
+  {  //2n+1 simga points
+    //residual
+    Eigen::VectorXd z_diff = z_sig.col(i) - z_pred;
+    S = S + weights_(i) * z_diff * z_diff.transpose();
+  }
+
+  //add measurement noise covariance matrix
+  Eigen::MatrixXd R = Eigen::MatrixXd(n_z, n_z);
+  R &lt;&lt; std_laspx_*std_laspx_, 0,
+          0, std_laspy_*std_laspy_;
+  S = S + R;
+
+  //create matrix for cross correlation Tc
+  Eigen::MatrixXd Tc = Eigen::MatrixXd(n_x_, n_z);
+
+  /*****************************************************************************
+  *  UKF Update for Lidar
+  ****************************************************************************/
+  //calculate cross correlation matrix
+  Tc.fill(0.0);
+  for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
+  {  //2n+1 simga points
+    //residual
+    Eigen::VectorXd z_diff = z_sig.col(i) - z_pred;
+    // state difference
+    Eigen::VectorXd x_diff = x_sig_pred.col(i) - x;
+
+    Tc = Tc + weights_(i) * x_diff * z_diff.transpose();
+  }
+
+  //Kalman gain K;
+  Eigen::MatrixXd K = Tc * S.inverse();
+
+  /*****************************************************************************
+  *  Update model parameters
+  ****************************************************************************/
+  if(model_ind == 0)
+  {
+    x_cv_.col(0)  = x;
+    p_cv_         = P;
+    x_sig_pred_cv_ = x_sig_pred;
+    z_pred_cv_     = z_pred;
+    s_cv_        = S;
+    k_cv_         = K;
+  }
+  else if(model_ind == 1)
+  {
+    x_ctrv_.col(0)  = x;
+    p_ctrv_         = P;
+    x_sig_pred_ctrv_ = x_sig_pred;
+    z_pred_ctrv_     = z_pred;
+    s_ctrv_        = S;
+    k_ctrv_         = K;
+  }
+  else
+  {
+    x_rm_.col(0)    = x;
+    p_rm_           = P;
+    x_sig_pred_rm_   = x_sig_pred;
+    z_pred_rm_       = z_pred;
+    s_rm_          = S;
+    k_rm_           = K;
+  }
+}
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="46ea48320904be937b69d84663caf3f5cc0c6901" author="Kosuke Murakami">
		<msg>lidar_tracker/immukfpda refactoring</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="1" deleted_lines="49">
				<diff>@@ -853,8 +853,8 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
     targets_[i].predictionIMMUKF(dt);
 
 
-    std::vector&lt;double&gt; lambda_vec;
     bool is_skip_target;
+    std::vector&lt;double&gt; lambda_vec;
     probabilisticDataAssociation(input, dt, det_explode_param, matching_vec, lambda_vec, targets_[i], is_skip_target);
     if(is_skip_target)
       continue;
@@ -875,54 +875,6 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
 
   // making output(CludClusterArray) for visualization
   makeOutput(input, output);
-  // // making output(CludClusterArray) for visualization
-  // tf::StampedTransform transform;
-  // tran_-&gt;lookupTransform("/world", "/velodyne", ros::Time(0), transform);
-  //
-  // // get yaw angle from "world" to "velodyne" for direction(arrow) visualization
-  // tf::Matrix3x3 m(transform.getRotation());
-  // double roll, pitch, yaw;
-  // m.getRPY(roll, pitch, yaw);
-  //
-  // output.header = input.header;
-  // // int target_num_count = 0;
-  // for(size_t i = 0; i &lt; targets_.size(); i++)
-  // {
-  //   if(targets_[i].is_vis_bb_)
-  //   {
-  //     double tx = targets_[i].x_merge_(0);
-  //     double ty = targets_[i].x_merge_(1);
-  //     double mx = targets_[i].init_meas_(0);
-  //     double my = targets_[i].init_meas_(1);
-  //
-  //     //for static classification
-  //     targets_[i].dist_from_init_ = sqrt((tx - mx)*(tx - mx) + (ty - my)*(ty - my));
-  //     std::vector&lt;double&gt; cp;
-  //     cp.push_back(tx);
-  //     cp.push_back(ty);
-  //
-  //     double tv = targets_[i].x_merge_(2);
-  //     double tyaw = targets_[i].x_merge_(3) - yaw;
-  //
-  //     // tyaw += egoPoints_[0][2];
-  //     while (tyaw&gt; M_PI) tyaw -= 2.*M_PI;
-  //     while (tyaw&lt;-M_PI) tyaw += 2.*M_PI;
-  //     // cout &lt;&lt; "testing yaw off "&lt;&lt; tyaw &lt;&lt; endl;
-  //
-  //     // cout &lt;&lt; "inside tracker ----------------------------------------------------------------------------------------------"&lt;&lt;targets_[i].jskBB_.pose &lt;&lt; endl;
-  //
-  //     autoware_msgs::CloudCluster cc;
-  //     cc.header = input.header;
-  //     cc.bounding_box = targets_[i].jsk_bb_;
-  //     cc.bounding_box.header = input.header;
-  //     cc.score           = tv;
-  //     cc.estimated_angle = tyaw;
-  //     updateLabel(targets_[i], cc);
-  //     output.clusters.push_back(cc);
-  //   }
-  //
-  // }
-  // cout &lt;&lt; output.clusters.size()&lt;&lt; endl;
 
   assert(matching_vec.size() == input.clusters.size());
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0ff8da3fc54a4b2b8139f37ff2b44715c2a46d96" author="Yusuke FUJII">
		<msg>add vehicle_status msg</msg>
		<modified_files>
			<file old_path="ros\src\.config\vehicle_info\prius_nhw20.yaml" new_path="ros\src\.config\vehicle_info\prius_nhw20.yaml" added_lines="5" deleted_lines="0">
				<diff>@@ -2,3 +2,8 @@ vehicle_info:
   maximum_steering_angle: 666.0
   minimum_turning_radius: 5.1
   wheel_base: 2.7
+  gear:
+    D: 16
+    N: 32
+    R: 64
+    P: 128
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ba45dc136ddb5d18ab365a00e7f6239a11786ebf" author="Yusuke FUJII">
		<msg>change can_translator
- Support to vehicle_status(can intermediate layer)
- Separate the can translator and the odometry.
- Support to output vehicle autonomous mode</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_info_translator\can_info_translator_core.cpp" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_core.cpp" added_lines="11" deleted_lines="42">
				<diff>@@ -29,26 +29,26 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include "can_info_translator_core.h"
+#include "can_odometry_core.h"
 
 namespace autoware_connector
 {
 // Constructor
-VelPoseConnectNode::VelPoseConnectNode() : private_nh_("~"), v_info_(), odom_(ros::Time::now())
+CanOdometryNode::CanOdometryNode() : private_nh_("~"), v_info_(), odom_(ros::Time::now())
 {
   initForROS();
 }
 
 // Destructor
-VelPoseConnectNode::~VelPoseConnectNode()
+CanOdometryNode::~CanOdometryNode()
 {
 }
 
-void VelPoseConnectNode::initForROS()
+void CanOdometryNode::initForROS()
 {
   // ros parameter settings
   if (!nh_.hasParam("/vehicle_info/wheel_base") || !nh_.hasParam("/vehicle_info/minimum_turning_radius") ||
-    !nh_.hasParam("/vehicle_info/maximum_steering_angle"))
+      !nh_.hasParam("/vehicle_info/maximum_steering_angle"))
   {
     v_info_.is_stored = false;
     ROS_INFO("vehicle_info is not set");
@@ -68,42 +68,18 @@ void VelPoseConnectNode::initForROS()
   }
 
   // setup subscriber
-  sub1_ = nh_.subscribe("can_info", 100, &amp;VelPoseConnectNode::callbackFromCanInfo, this);
+  sub1_ = nh_.subscribe("vehicle_status", 10, &amp;CanOdometryNode::callbackFromCanInfo, this);
 
   // setup publisher
-  pub1_ = nh_.advertise&lt;geometry_msgs::TwistStamped&gt;("can_velocity",10);
-  pub2_ = nh_.advertise&lt;std_msgs::Float32&gt;("linear_velocity_viz", 10);
-  pub3_ = nh_.advertise&lt;nav_msgs::Odometry&gt;("odom_pose",10);
-
+  pub1_ = nh_.advertise&lt;nav_msgs::Odometry&gt;("odom_pose", 10);
 }
 
-void VelPoseConnectNode::run()
+void CanOdometryNode::run()
 {
   ros::spin();
 }
 
-void VelPoseConnectNode::publishVelocity(const autoware_msgs::CanInfoConstPtr &amp;msg)
-{
-  geometry_msgs::TwistStamped tw;
-  tw.header = msg-&gt;header;
-
-  // linear velocity
-  tw.twist.linear.x = kmph2mps(msg-&gt;speed);  // km/h -&gt; m/s
-
-  // angular velocity
-  tw.twist.angular.z = v_info_.convertSteeringAngleToAngularVelocity(kmph2mps(msg-&gt;speed), msg-&gt;angle);
-
-  pub1_.publish(tw);
-}
-
-void VelPoseConnectNode::publishVelocityViz(const autoware_msgs::CanInfoConstPtr &amp;msg)
-{
-  std_msgs::Float32 fl;
-  fl.data = msg-&gt;speed;
-  pub2_.publish(fl);
-}
-
-void VelPoseConnectNode::publishOdometry(const autoware_msgs::CanInfoConstPtr &amp;msg)
+void CanOdometryNode::publishOdometry(const autoware_msgs::CanInfoConstPtr &amp;msg)
 {
   double vx = kmph2mps(msg-&gt;speed);
   double vth = v_info_.convertSteeringAngleToAngularVelocity(kmph2mps(msg-&gt;speed), msg-&gt;angle);
@@ -146,16 +122,9 @@ void VelPoseConnectNode::publishOdometry(const autoware_msgs::CanInfoConstPtr &amp;m
   pub3_.publish(odom);
 }
 
-void VelPoseConnectNode::callbackFromCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
+void CanOdometryNode::callbackFromCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
 {
-  publishVelocity(msg);
-  publishVelocityViz(msg);
   publishOdometry(msg);
-
-
-
 }
 
-
-
-} // autoware_connector
+}  // autoware_connector
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_info_translator\can_info_translator_core.h" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_core.h" added_lines="43" deleted_lines="56">
				<diff>@@ -28,23 +28,46 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#ifndef CAN_INFO_TRANSLATOR_CORE_H
-#define CAN_INFO_TRANSLATOR_CORE_H
+#ifndef CAN_ODOMETRY_CORE_H
+#define CAN_ODOMETRY_CORE_H
 
 // ROS includes
-#include &lt;ros/ros.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
-#include &lt;std_msgs/Float32.h&gt;
 #include &lt;nav_msgs/Odometry.h&gt;
+#include &lt;ros/ros.h&gt;
+#include &lt;std_msgs/Float32.h&gt;
 #include &lt;tf/transform_broadcaster.h&gt;
 
 // User Defined Includes
 #include "autoware_msgs/CanInfo.h"
+#include "autoware_msgs/VehicleStatus.h"
 
 namespace autoware_connector
 {
+inline double kmph2mps(double velocity_kmph)
+{
+  return (velocity_kmph * 1000) / (60 * 60);
+}
 
-struct VehicleInfo {
+inline double mps2kmph(double velocity_mps)
+{
+  return (velocity_mps * 60 * 60) / 1000;
+}
+
+// convert degree to radian
+inline double deg2rad(double deg)
+{
+  return deg * M_PI / 180;
+}
+
+// convert degree to radian
+inline double rad2deg(double rad)
+{
+  return rad * 180 / M_PI;
+}
+
+struct VehicleInfo
+{
   bool is_stored;
   double wheel_base;
   double minimum_turning_radius;
@@ -57,30 +80,22 @@ struct VehicleInfo {
     minimum_turning_radius = 0.0;
     maximum_steering_angle = 0.0;
   }
-  double convertSteeringAngleToAngularVelocity(const double cur_vel_mps, const double cur_angle_deg) // rad/s
+  double convertSteeringAngleToAngularVelocity(const double cur_vel_mps, const double cur_angle_deg)  // rad/s
   {
     return is_stored ? tan(deg2rad(getCurrentTireAngle(cur_angle_deg))) * cur_vel_mps / wheel_base : 0;
   }
-  double getCurrentTireAngle(const double angle_deg) // steering [degree] -&gt; tire [degree]
+  double getCurrentTireAngle(const double angle_deg)  // steering [degree] -&gt; tire [degree]
   {
-    return is_stored ? angle_deg * getMaximumTireAngle() / maximum_steering_angle: 0;
+    return is_stored ? angle_deg * getMaximumTireAngle() / maximum_steering_angle : 0;
   }
-  double getMaximumTireAngle() // degree
+  double getMaximumTireAngle()  // degree
   {
     return is_stored ? rad2deg(asin(wheel_base / minimum_turning_radius)) : 0;
   }
-  double rad2deg(double rad)
-  {
-    return rad * 180 / M_PI;
-  }
-  // convert degree to radian
-  inline double deg2rad(double deg)
-  {
-    return deg * M_PI / 180;
-  }
 };
 
-struct Odometry {
+struct Odometry
+{
   double x;
   double y;
   double th;
@@ -96,7 +111,7 @@ struct Odometry {
 
   void updateOdometry(const double vx, const double vth, const ros::Time &amp;cur_time)
   {
-    if(stamp.sec == 0 &amp;&amp; stamp.nsec == 0)
+    if (stamp.sec == 0 &amp;&amp; stamp.nsec == 0)
     {
       stamp = cur_time;
     }
@@ -105,45 +120,40 @@ struct Odometry {
     double delta_y = (vx * sin(th)) * dt;
     double delta_th = vth * dt;
 
-    std::cout &lt;&lt; "dt : " &lt;&lt; dt &lt;&lt; "delta (x y th) : (" &lt;&lt; delta_x &lt;&lt; " " &lt;&lt; delta_y &lt;&lt; " " &lt;&lt; delta_th &lt;&lt; ")" &lt;&lt; std::endl;
-
+    ROS_INFO("dt : %f delta (x y th) : (%f %f %f %f)", dt, delta_x, delta_y, delta_th);
 
     x += delta_x;
     y += delta_y;
     th += delta_th;
     stamp = cur_time;
   }
-
 };
 
-class VelPoseConnectNode
+class CanOdometryNode
 {
 public:
-
-  VelPoseConnectNode();
-  ~VelPoseConnectNode();
+  CanOdometryNode();
+  ~CanOdometryNode();
 
   void run();
 
 private:
-
   // handle
   ros::NodeHandle nh_;
   ros::NodeHandle private_nh_;
 
   // publisher
-  ros::Publisher pub1_, pub2_, pub3_;
+  ros::Publisher pub1_;
 
   // subscriber
-  ros::Subscriber sub1_,sub2_;
+  ros::Subscriber sub1_;
 
   // variables
   VehicleInfo v_info_;
   Odometry odom_;
-  // tf::TransformBroadcaster odom_broadcaster_;
 
   // callbacks
-  void callbackFromCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg);
+  void callbackFromVehicleStatus(const autoware_msgs::VehicleStatusConstPtr &amp;msg);
 
   // initializer
   void initForROS();
@@ -153,28 +163,5 @@ private:
   void publishVelocityViz(const autoware_msgs::CanInfoConstPtr &amp;msg);
   void publishOdometry(const autoware_msgs::CanInfoConstPtr &amp;msg);
 };
-
-inline double kmph2mps(double velocity_kmph)
-{
-  return (velocity_kmph * 1000) / (60 * 60);
-}
-
-inline double mps2kmph(double velocity_mps)
-{
-  return (velocity_mps * 60 * 60) / 1000;
-}
-
-// convert degree to radian
-inline double deg2rad(double deg)
-{
-  return deg * M_PI / 180;
-}
-
-// convert degree to radian
-inline double rad2deg(double rad)
-{
-  return rad * 180 / M_PI;
-}
-
 }
-#endif  // CAN_INFO_TRANSLATOR_CORE_H
+#endif  // CAN_ODOMETRY_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_info_translator\can_info_translator_node.cpp" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_node.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -31,13 +31,13 @@
 // ROS includes
 #include &lt;ros/ros.h&gt;
 
-#include "can_info_translator_core.h"
+#include "can_odometry_core.h"
 
 int main(int argc, char **argv)
 {
-  ros::init(argc, argv, "can_info_translator");
-  autoware_connector::VelPoseConnectNode n;
+  ros::init(argc, argv, "can_odometry");
+  autoware_connector::CanOdometryNode n;
   n.run();
- 
+
   return 0;
 }
</diff>
			</file>
			<file old_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_receiver\vehicle_receiver.cpp" new_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_receiver\vehicle_receiver.cpp" added_lines="110" deleted_lines="75">
				<diff>@@ -29,83 +29,103 @@
 */
 
 #include &lt;ros/ros.h&gt;
-#include "autoware_msgs/CanInfo.h"
 #include &lt;tablet_socket_msgs/mode_info.h&gt;
+#include "autoware_msgs/CanInfo.h"
 
-#include &lt;iostream&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;cstdio&gt;
-#include &lt;cstring&gt;
-#include &lt;cstdlib&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/socket.h&gt;
 #include &lt;netinet/in.h&gt;
+#include &lt;pthread.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;sys/types.h&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;unistd.h&gt;
-#include &lt;pthread.h&gt;
+#include &lt;cstdio&gt;
+#include &lt;cstdlib&gt;
+#include &lt;cstring&gt;
+#include &lt;iostream&gt;
+#include &lt;string&gt;
+#include &lt;vector&gt;
 
-#define CAN_KEY_MODE	(0)
-#define CAN_KEY_TIME	(1)
-#define CAN_KEY_VELOC	(2)
-#define CAN_KEY_ANGLE	(3)
-#define CAN_KEY_TORQUE	(4)
-#define CAN_KEY_ACCEL	(5)
-#define CAN_KEY_BRAKE	(6)
-#define CAN_KEY_SHIFT	(7)
+#define CAN_KEY_MODE (0)
+#define CAN_KEY_TIME (1)
+#define CAN_KEY_VELOC (2)
+#define CAN_KEY_ANGLE (3)
+#define CAN_KEY_TORQUE (4)
+#define CAN_KEY_ACCEL (5)
+#define CAN_KEY_BRAKE (6)
+#define CAN_KEY_SHIFT (7)
 
 static ros::Publisher can_pub;
 static ros::Publisher mode_pub;
 static int mode;
 
-static bool parseCanValue(const std::string&amp; can_data, autoware_msgs::CanInfo&amp; msg)
+static bool parseCanValue(const std::string &amp;can_data, autoware_msgs::CanInfo &amp;msg)
 {
   std::istringstream ss(can_data);
   std::vector&lt;std::string&gt; columns;
 
   std::string column;
-  while(std::getline(ss, column, ',')){
+  while (std::getline(ss, column, ','))
+  {
     columns.push_back(column);
   }
 
-  for (std::size_t i = 0; i &lt; columns.size(); i += 2) {
+  for (std::size_t i = 0; i &lt; columns.size(); i += 2)
+  {
     int key = std::stoi(columns[i]);
-    switch (key) {
-    case CAN_KEY_MODE:
-      mode = std::stoi(columns[i+1]);
-      break;
-    case CAN_KEY_TIME:
-      msg.tm = columns[i+1].substr(1, columns[i+1].length() - 2); // skip '
-      break;
-    case CAN_KEY_VELOC:
-      msg.speed = std::stod(columns[i+1]);
-      break;
-    case CAN_KEY_ANGLE:
-      msg.angle = std::stod(columns[i+1]);
-      break;
-    case CAN_KEY_TORQUE:
-      msg.torque = std::stoi(columns[i+1]);
-      break;
-    case CAN_KEY_ACCEL:
-      msg.drivepedal = std::stoi(columns[i+1]);
-      break;
-    case CAN_KEY_BRAKE:
-      msg.brakepedal = std::stoi(columns[i+1]);
-      break;
-    case CAN_KEY_SHIFT:
-      msg.driveshift = std::stoi(columns[i+1]);
-      break;
-    default:
-      std::cout &lt;&lt; "Warning: unknown key : " &lt;&lt; key &lt;&lt; std::endl;
+    switch (key)
+    {
+      case CAN_KEY_MODE:
+        mode = std::stoi(columns[i + 1]);
+        if (mode &amp; 0x1)
+        {
+          msg.devmode = 1;
+        }
+        else
+        {
+          msg.devmode = 0;
+        }
+
+        if (mode &amp; 0x2)
+        {
+          msg.strmode = 1;
+        }
+        else
+        {
+          msg.strmode = 0;
+        }
+        break;
+      case CAN_KEY_TIME:
+        msg.tm = columns[i + 1].substr(1, columns[i + 1].length() - 2);  // skip '
+        break;
+      case CAN_KEY_VELOC:
+        msg.speed = std::stod(columns[i + 1]);
+        break;
+      case CAN_KEY_ANGLE:
+        msg.angle = std::stod(columns[i + 1]);
+        break;
+      case CAN_KEY_TORQUE:
+        msg.torque = std::stoi(columns[i + 1]);
+        break;
+      case CAN_KEY_ACCEL:
+        msg.drivepedal = std::stoi(columns[i + 1]);
+        break;
+      case CAN_KEY_BRAKE:
+        msg.brakepedal = std::stoi(columns[i + 1]);
+        break;
+      case CAN_KEY_SHIFT:
+        msg.driveshift = std::stoi(columns[i + 1]);
+        break;
+      default:
+        std::cout &lt;&lt; "Warning: unknown key : " &lt;&lt; key &lt;&lt; std::endl;
     }
   }
 
   return true;
 }
 
-static void* getCanValue(void *arg)
+static void *getCanValue(void *arg)
 {
-  int *client_sockp = static_cast&lt;int*&gt;(arg);
+  int *client_sockp = static_cast&lt;int *&gt;(arg);
   int sock = *client_sockp;
   delete client_sockp;
 
@@ -113,37 +133,43 @@ static void* getCanValue(void *arg)
   std::string can_data("");
   constexpr int LIMIT = 1024 * 1024;
 
-  while(true){
+  while (true)
+  {
     ssize_t n = recv(sock, recvdata, sizeof(recvdata), 0);
 
-    if(n&lt;0){
+    if (n &lt; 0)
+    {
       std::perror("recv");
       can_data = "";
       break;
-    }else if(n == 0){
+    }
+    else if (n == 0)
+    {
       break;
     }
-    can_data.append(recvdata,n);
+    can_data.append(recvdata, n);
 
-    //recv data is bigger than 1M,return error
-    if(can_data.size() &gt; LIMIT){
+    // recv data is bigger than 1M,return error
+    if (can_data.size() &gt; LIMIT)
+    {
       std::cerr &lt;&lt; "recv data is too big." &lt;&lt; std::endl;
       can_data = "";
       break;
     }
   }
 
-  if(close(sock)&lt;0){
+  if (close(sock) &lt; 0)
+  {
     std::perror("close");
     return nullptr;
   }
 
-  if(can_data.empty())
+  if (can_data.empty())
     return nullptr;
 
   autoware_msgs::CanInfo can_msg;
   bool ret = parseCanValue(can_data, can_msg);
-  if(!ret)
+  if (!ret)
     return nullptr;
 
   can_msg.header.frame_id = "/can";
@@ -159,12 +185,13 @@ static void* getCanValue(void *arg)
   return nullptr;
 }
 
-static void* receiverCaller(void *unused)
+static void *receiverCaller(void *unused)
 {
   constexpr int listen_port = 10000;
 
   int sock = socket(AF_INET, SOCK_STREAM, 0);
-  if(sock == -1){
+  if (sock == -1)
+  {
     std::perror("socket");
     return nullptr;
   }
@@ -177,26 +204,30 @@ static void* receiverCaller(void *unused)
   addr.sin_family = PF_INET;
   addr.sin_port = htons(listen_port);
   addr.sin_addr.s_addr = INADDR_ANY;
-  //make it available immediately to connect
-  //setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const char *)&amp;yes, sizeof(yes));
-  int ret = bind(sock, (sockaddr*)&amp;addr, sizeof(addr));
-  if(ret == -1){
+  // make it available immediately to connect
+  // setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const char *)&amp;yes, sizeof(yes));
+  int ret = bind(sock, (sockaddr *)&amp;addr, sizeof(addr));
+  if (ret == -1)
+  {
     std::perror("bind");
     goto error;
   }
 
   ret = listen(sock, 5);
-  if(ret == -1) {
+  if (ret == -1)
+  {
     std::perror("listen");
     goto error;
   }
 
-  while(true){
-    //get connect to android
+  while (true)
+  {
+    // get connect to android
     std::cout &lt;&lt; "Waiting access..." &lt;&lt; std::endl;
     int *client_sock = new int();
-    *client_sock = accept(sock, reinterpret_cast&lt;sockaddr*&gt;(&amp;client), &amp;len);
-    if(*client_sock == -1){
+    *client_sock = accept(sock, reinterpret_cast&lt;sockaddr *&gt;(&amp;client), &amp;len);
+    if (*client_sock == -1)
+    {
       std::perror("accept");
       break;
     }
@@ -204,13 +235,15 @@ static void* receiverCaller(void *unused)
     std::cout &lt;&lt; "Get connect" &lt;&lt; std::endl;
 
     pthread_t th;
-    if(pthread_create(&amp;th, nullptr, getCanValue, static_cast&lt;void*&gt;(client_sock))){
+    if (pthread_create(&amp;th, nullptr, getCanValue, static_cast&lt;void *&gt;(client_sock)))
+    {
       std::perror("pthread_create");
       break;
     }
 
     ret = pthread_detach(th);
-    if(ret != 0){
+    if (ret != 0)
+    {
       std::perror("pthread_detach");
       break;
     }
@@ -223,7 +256,7 @@ error:
 
 int main(int argc, char **argv)
 {
-  ros::init(argc ,argv, "vehicle_receiver");
+  ros::init(argc, argv, "vehicle_receiver");
   ros::NodeHandle nh;
 
   std::cout &lt;&lt; "vehicle receiver" &lt;&lt; std::endl;
@@ -233,13 +266,15 @@ int main(int argc, char **argv)
 
   pthread_t th;
   int ret = pthread_create(&amp;th, nullptr, receiverCaller, nullptr);
-  if (ret != 0) {
+  if (ret != 0)
+  {
     std::perror("pthread_create");
     std::exit(1);
   }
 
   ret = pthread_detach(th);
-  if(ret != 0){
+  if (ret != 0)
+  {
     std::perror("pthread_detach");
     std::exit(1);
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d2f5d681af0e3833ab3c7fea85061e4ddd03f482" author="Yusuke FUJII">
		<msg>change odometry topic name</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_core.cpp" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -71,7 +71,7 @@ void CanOdometryNode::initForROS()
   sub1_ = nh_.subscribe("vehicle_status", 10, &amp;CanOdometryNode::callbackFromCanInfo, this);
 
   // setup publisher
-  pub1_ = nh_.advertise&lt;nav_msgs::Odometry&gt;("odom_pose", 10);
+  pub1_ = nh_.advertise&lt;nav_msgs::Odometry&gt;("/vehicle/odom", 10);
 }
 
 void CanOdometryNode::run()
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\approximate_ndt_mapping\approximate_ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\approximate_ndt_mapping\approximate_ndt_mapping.cpp" added_lines="99" deleted_lines="106">
				<diff>@@ -36,17 +36,17 @@
 
 #define OUTPUT  // If you want to output "position_log.txt", "#define OUTPUT".
 
+#include &lt;fstream&gt;
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;
-#include &lt;fstream&gt;
 #include &lt;string&gt;
 
-#include &lt;ros/ros.h&gt;
-#include &lt;std_msgs/Bool.h&gt;
-#include &lt;std_msgs/Float32.h&gt;
 #include &lt;nav_msgs/Odometry.h&gt;
+#include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/Imu.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
+#include &lt;std_msgs/Bool.h&gt;
+#include &lt;std_msgs/Float32.h&gt;
 #include &lt;velodyne_pointcloud/point_types.h&gt;
 #include &lt;velodyne_pointcloud/rawdata.h&gt;
 
@@ -59,11 +59,11 @@
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
 #ifdef USE_FAST_PCL
-#include &lt;fast_pcl/registration/ndt.h&gt;
 #include &lt;fast_pcl/filters/voxel_grid.h&gt;
+#include &lt;fast_pcl/registration/ndt.h&gt;
 #else
-#include &lt;pcl/registration/ndt.h&gt;
 #include &lt;pcl/filters/voxel_grid.h&gt;
+#include &lt;pcl/registration/ndt.h&gt;
 #endif
 
 #include &lt;autoware_msgs/ConfigApproximateNdtMapping.h&gt;
@@ -80,17 +80,19 @@ struct pose
 };
 
 // global variables
-static pose previous_pose, guess_pose, guess_pose_imu, guess_pose_odom, guess_pose_imu_odom,current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, ndt_pose, added_pose, localizer_pose;
+static pose previous_pose, guess_pose, guess_pose_imu, guess_pose_odom, guess_pose_imu_odom, current_pose,
+    current_pose_imu, current_pose_odom, current_pose_imu_odom, ndt_pose, added_pose, localizer_pose;
 
 static ros::Time current_scan_time;
 static ros::Time previous_scan_time;
 static ros::Duration scan_duration;
 
 static double diff = 0.0;
-static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw; // current_pose - previous_pose
+static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw;  // current_pose - previous_pose
 static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
 static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
-static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch, offset_imu_odom_yaw;
+static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch,
+    offset_imu_odom_yaw;
 
 static double current_velocity_x = 0.0;
 static double current_velocity_y = 0.0;
@@ -104,7 +106,7 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; map, submap;
 
 static pcl::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; ndt;
 // Default values
-static int max_iter = 30;            // Maximum iterations
+static int max_iter = 30;        // Maximum iterations
 static float ndt_res = 1.0;      // Resolution
 static double step_size = 0.1;   // Step size
 static double trans_eps = 0.01;  // Transformation epsilon
@@ -143,7 +145,6 @@ static bool _imu_upside_down = false;
 
 static std::string _imu_topic = "/imu_raw";
 
-
 static double fitness_score;
 
 static int submap_num = 0;
@@ -154,7 +155,6 @@ static nav_msgs::Odometry odom;
 
 static void param_callback(const autoware_msgs::ConfigApproximateNdtMapping::ConstPtr&amp; input)
 {
-
   ndt_res = input-&gt;resolution;
   step_size = input-&gt;step_size;
   trans_eps = input-&gt;trans_epsilon;
@@ -226,85 +226,83 @@ static void imu_odom_calc(ros::Time current_time)
   static ros::Time previous_time = current_time;
   double diff_time = (current_time - previous_time).toSec();
 
-  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
+  double diff_imu_roll = imu.angular_velocity.x * diff_time;
   double diff_imu_pitch = imu.angular_velocity.y * diff_time;
-  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;
+  double diff_imu_yaw = imu.angular_velocity.z * diff_time;
 
-  current_pose_imu_odom.roll  += diff_imu_roll;
+  current_pose_imu_odom.roll += diff_imu_roll;
   current_pose_imu_odom.pitch += diff_imu_pitch;
-  current_pose_imu_odom.yaw   += diff_imu_yaw;
+  current_pose_imu_odom.yaw += diff_imu_yaw;
 
   double diff_distance = odom.twist.twist.linear.x * diff_time;
-  offset_imu_odom_x += diff_distance*cos(-current_pose_imu_odom.pitch)*cos(current_pose_imu_odom.yaw);
-  offset_imu_odom_y += diff_distance*cos(-current_pose_imu_odom.pitch)*sin(current_pose_imu_odom.yaw);
-  offset_imu_odom_z += diff_distance*sin(-current_pose_imu_odom.pitch);
+  offset_imu_odom_x += diff_distance * cos(-current_pose_imu_odom.pitch) * cos(current_pose_imu_odom.yaw);
+  offset_imu_odom_y += diff_distance * cos(-current_pose_imu_odom.pitch) * sin(current_pose_imu_odom.yaw);
+  offset_imu_odom_z += diff_distance * sin(-current_pose_imu_odom.pitch);
 
-  offset_imu_odom_roll  += diff_imu_roll;
+  offset_imu_odom_roll += diff_imu_roll;
   offset_imu_odom_pitch += diff_imu_pitch;
-  offset_imu_odom_yaw   += diff_imu_yaw;
+  offset_imu_odom_yaw += diff_imu_yaw;
 
-  guess_pose_imu_odom.x     = previous_pose.x     + offset_imu_odom_x;
-  guess_pose_imu_odom.y     = previous_pose.y     + offset_imu_odom_y;
-  guess_pose_imu_odom.z     = previous_pose.z     + offset_imu_odom_z;
-  guess_pose_imu_odom.roll  = previous_pose.roll  + offset_imu_odom_roll;
+  guess_pose_imu_odom.x = previous_pose.x + offset_imu_odom_x;
+  guess_pose_imu_odom.y = previous_pose.y + offset_imu_odom_y;
+  guess_pose_imu_odom.z = previous_pose.z + offset_imu_odom_z;
+  guess_pose_imu_odom.roll = previous_pose.roll + offset_imu_odom_roll;
   guess_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
-  guess_pose_imu_odom.yaw   = previous_pose.yaw   + offset_imu_odom_yaw;
- 
+  guess_pose_imu_odom.yaw = previous_pose.yaw + offset_imu_odom_yaw;
+
   previous_time = current_time;
 }
 
-
 static void odom_calc(ros::Time current_time)
 {
   static ros::Time previous_time = current_time;
   double diff_time = (current_time - previous_time).toSec();
 
-  double diff_odom_roll  = odom.twist.twist.angular.x * diff_time;
+  double diff_odom_roll = odom.twist.twist.angular.x * diff_time;
   double diff_odom_pitch = odom.twist.twist.angular.y * diff_time;
-  double diff_odom_yaw   = odom.twist.twist.angular.z * diff_time;
+  double diff_odom_yaw = odom.twist.twist.angular.z * diff_time;
 
-  current_pose_odom.roll  += diff_odom_roll;
+  current_pose_odom.roll += diff_odom_roll;
   current_pose_odom.pitch += diff_odom_pitch;
-  current_pose_odom.yaw   += diff_odom_yaw;
+  current_pose_odom.yaw += diff_odom_yaw;
 
   double diff_distance = odom.twist.twist.linear.x * diff_time;
-  offset_odom_x += diff_distance*cos(-current_pose_odom.pitch)*cos(current_pose_odom.yaw);
-  offset_odom_y += diff_distance*cos(-current_pose_odom.pitch)*sin(current_pose_odom.yaw);
-  offset_odom_z += diff_distance*sin(-current_pose_odom.pitch);
+  offset_odom_x += diff_distance * cos(-current_pose_odom.pitch) * cos(current_pose_odom.yaw);
+  offset_odom_y += diff_distance * cos(-current_pose_odom.pitch) * sin(current_pose_odom.yaw);
+  offset_odom_z += diff_distance * sin(-current_pose_odom.pitch);
 
-  offset_odom_roll  += diff_odom_roll;
+  offset_odom_roll += diff_odom_roll;
   offset_odom_pitch += diff_odom_pitch;
-  offset_odom_yaw   += diff_odom_yaw;
+  offset_odom_yaw += diff_odom_yaw;
 
-  guess_pose_odom.x     = previous_pose.x     + offset_odom_x;
-  guess_pose_odom.y     = previous_pose.y     + offset_odom_y;
-  guess_pose_odom.z     = previous_pose.z     + offset_odom_z;
-  guess_pose_odom.roll  = previous_pose.roll  + offset_odom_roll;
+  guess_pose_odom.x = previous_pose.x + offset_odom_x;
+  guess_pose_odom.y = previous_pose.y + offset_odom_y;
+  guess_pose_odom.z = previous_pose.z + offset_odom_z;
+  guess_pose_odom.roll = previous_pose.roll + offset_odom_roll;
   guess_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
-  guess_pose_odom.yaw   = previous_pose.yaw   + offset_odom_yaw;
- 
+  guess_pose_odom.yaw = previous_pose.yaw + offset_odom_yaw;
+
   previous_time = current_time;
 }
 
 static void imu_calc(ros::Time current_time)
 {
-
   static ros::Time previous_time = current_time;
   double diff_time = (current_time - previous_time).toSec();
 
-  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
+  double diff_imu_roll = imu.angular_velocity.x * diff_time;
   double diff_imu_pitch = imu.angular_velocity.y * diff_time;
-  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;
+  double diff_imu_yaw = imu.angular_velocity.z * diff_time;
 
   current_pose_imu.roll += diff_imu_roll;
   current_pose_imu.pitch += diff_imu_pitch;
   current_pose_imu.yaw += diff_imu_yaw;
 
   double accX1 = imu.linear_acceleration.x;
-  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y
-                -std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
-  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y
-                +std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;
+  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y -
+                 std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
+  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y +
+                 std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;
 
   double accX2 = std::sin(current_pose_imu.pitch) * accZ1 + std::cos(current_pose_imu.pitch) * accX1;
   double accY2 = accY1;
@@ -322,44 +320,42 @@ static void imu_calc(ros::Time current_time)
   current_velocity_imu_y += accY * diff_time;
   current_velocity_imu_z += accZ * diff_time;
 
-  offset_imu_roll  += diff_imu_roll;
+  offset_imu_roll += diff_imu_roll;
   offset_imu_pitch += diff_imu_pitch;
-  offset_imu_yaw   += diff_imu_yaw;
+  offset_imu_yaw += diff_imu_yaw;
 
-  guess_pose_imu.x     = previous_pose.x     + offset_imu_x;
-  guess_pose_imu.y     = previous_pose.y     + offset_imu_y;
-  guess_pose_imu.z     = previous_pose.z     + offset_imu_z;
-  guess_pose_imu.roll  = previous_pose.roll  + offset_imu_roll;
+  guess_pose_imu.x = previous_pose.x + offset_imu_x;
+  guess_pose_imu.y = previous_pose.y + offset_imu_y;
+  guess_pose_imu.z = previous_pose.z + offset_imu_z;
+  guess_pose_imu.roll = previous_pose.roll + offset_imu_roll;
   guess_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
-  guess_pose_imu.yaw   = previous_pose.yaw   + offset_imu_yaw;  
+  guess_pose_imu.yaw = previous_pose.yaw + offset_imu_yaw;
 
   previous_time = current_time;
 }
 
-
 static double wrapToPm(double a_num, const double a_max)
 {
-    if (a_num &gt;= a_max)
-    {
-        a_num -= 2.0 * a_max;
-    }
-    return a_num;
+  if (a_num &gt;= a_max)
+  {
+    a_num -= 2.0 * a_max;
+  }
+  return a_num;
 }
 
 static double wrapToPmPi(double a_angle_rad)
 {
-    return wrapToPm(a_angle_rad, M_PI);
+  return wrapToPm(a_angle_rad, M_PI);
 }
 
 static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
 {
-  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 
   odom = *input;
   odom_calc(input-&gt;header.stamp);
 }
 
-
 static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
 {
   double input_roll, input_pitch, input_yaw;
@@ -376,24 +372,23 @@ static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
   input-&gt;linear_acceleration.y *= -1;
   input-&gt;linear_acceleration.z *= -1;
 
-  input_roll  *= -1;
+  input_roll *= -1;
   input_pitch *= -1;
-  input_yaw   *= -1;
+  input_yaw *= -1;
 
   input-&gt;orientation = tf::createQuaternionMsgFromRollPitchYaw(input_roll, input_pitch, input_yaw);
 }
 
-
 static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
 {
-  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 
-  if(_imu_upside_down)
+  if (_imu_upside_down)
     imuUpsideDown(input);
 
   const ros::Time current_time = input-&gt;header.stamp;
   static ros::Time previous_time = current_time;
-  const double diff_time =  (current_time - previous_time).toSec();
+  const double diff_time = (current_time - previous_time).toSec();
 
   double imu_roll, imu_pitch, imu_yaw;
   tf::Quaternion imu_orientation;
@@ -405,33 +400,33 @@ static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
   imu_yaw = wrapToPmPi(imu_yaw);
 
   static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
-  const double diff_imu_roll  = imu_roll  - previous_imu_roll;
+  const double diff_imu_roll = imu_roll - previous_imu_roll;
 
   const double diff_imu_pitch = imu_pitch - previous_imu_pitch;
 
   double diff_imu_yaw;
-  if(fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
+  if (fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
   {
-    if(imu_yaw &gt; 0)
-      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI*2;
+    if (imu_yaw &gt; 0)
+      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI * 2;
     else
-      diff_imu_yaw = -M_PI*2 - (imu_yaw - previous_imu_yaw);
+      diff_imu_yaw = -M_PI * 2 - (imu_yaw - previous_imu_yaw);
   }
   else
-  diff_imu_yaw = imu_yaw - previous_imu_yaw;
+    diff_imu_yaw = imu_yaw - previous_imu_yaw;
 
   imu.header = input-&gt;header;
   imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
-  //imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
-  //imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
+  // imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
+  // imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
   imu.linear_acceleration.y = 0;
   imu.linear_acceleration.z = 0;
 
-  if(diff_time != 0)
+  if (diff_time != 0)
   {
-    imu.angular_velocity.x = diff_imu_roll  / diff_time;
+    imu.angular_velocity.x = diff_imu_roll / diff_time;
     imu.angular_velocity.y = diff_imu_pitch / diff_time;
-    imu.angular_velocity.z = diff_imu_yaw   / diff_time;
+    imu.angular_velocity.z = diff_imu_yaw / diff_time;
   }
   else
   {
@@ -443,12 +438,11 @@ static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
   imu_calc(input-&gt;header.stamp);
 
   previous_time = current_time;
-  previous_imu_roll  = imu_roll;
+  previous_imu_roll = imu_roll;
   previous_imu_pitch = imu_pitch;
-  previous_imu_yaw   = imu_yaw;
+  previous_imu_yaw = imu_yaw;
 }
 
-
 static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 {
   double r;
@@ -498,7 +492,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   voxel_grid_filter.filter(*filtered_scan_ptr);
 
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
-  
+
   ndt.setTransformationEpsilon(trans_eps);
   ndt.setStepSize(step_size);
   ndt.setResolution(ndt_res);
@@ -518,7 +512,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   guess_pose.pitch = previous_pose.pitch;
   guess_pose.yaw = previous_pose.yaw + diff_yaw;
 
-
   if (_use_imu == true &amp;&amp; _use_odom == true)
     imu_odom_calc(current_scan_time);
   if (_use_imu == true &amp;&amp; _use_odom == false)
@@ -527,16 +520,15 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     odom_calc(current_scan_time);
 
   pose guess_pose_for_ndt;
-  if(_use_imu == true &amp;&amp; _use_odom == true)
+  if (_use_imu == true &amp;&amp; _use_odom == true)
     guess_pose_for_ndt = guess_pose_imu_odom;
-  else if(_use_imu == true &amp;&amp; _use_odom == false)
+  else if (_use_imu == true &amp;&amp; _use_odom == false)
     guess_pose_for_ndt = guess_pose_imu;
-  else if(_use_imu == false &amp;&amp; _use_odom == true)
+  else if (_use_imu == false &amp;&amp; _use_odom == true)
     guess_pose_for_ndt = guess_pose_odom;
   else
     guess_pose_for_ndt = guess_pose;
 
-
   Eigen::AngleAxisf init_rotation_x(guess_pose_for_ndt.roll, Eigen::Vector3f::UnitX());
   Eigen::AngleAxisf init_rotation_y(guess_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());
   Eigen::AngleAxisf init_rotation_z(guess_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());
@@ -660,7 +652,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   previous_scan_time.sec = current_scan_time.sec;
   previous_scan_time.nsec = current_scan_time.nsec;
-  
 
   offset_imu_x = 0.0;
   offset_imu_y = 0.0;
@@ -682,7 +673,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   offset_imu_odom_roll = 0.0;
   offset_imu_odom_pitch = 0.0;
   offset_imu_odom_yaw = 0.0;
-  
+
   // Calculate the shift between added_pos and current_pos
   double shift = sqrt(pow(current_pose.x - added_pose.x, 2.0) + pow(current_pose.y - added_pose.y, 2.0));
   if (shift &gt;= min_add_scan_shift)
@@ -717,24 +708,26 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   current_pose_pub.publish(current_pose_msg);
 
-  if(submap_size &gt;= max_submap_size){
+  if (submap_size &gt;= max_submap_size)
+  {
     std::string s1 = "submap_";
     std::string s2 = std::to_string(submap_num);
     std::string s3 = ".pcd";
     std::string pcd_filename = s1 + s2 + s3;
 
-    if(submap.size() != 0)
+    if (submap.size() != 0)
     {
-      if(pcl::io::savePCDFileBinary(pcd_filename, submap) == -1){
+      if (pcl::io::savePCDFileBinary(pcd_filename, submap) == -1)
+      {
         std::cout &lt;&lt; "Failed saving " &lt;&lt; pcd_filename &lt;&lt; "." &lt;&lt; std::endl;
-  		}
-  		std::cout &lt;&lt; "Saved " &lt;&lt; pcd_filename &lt;&lt; " (" &lt;&lt; submap.size() &lt;&lt; " points)" &lt;&lt; std::endl;
-
-  		map = submap;
-  		submap.clear();
-  		submap_size = 0.0;
-  	}
-  	submap_num++;
+      }
+      std::cout &lt;&lt; "Saved " &lt;&lt; pcd_filename &lt;&lt; " (" &lt;&lt; submap.size() &lt;&lt; " points)" &lt;&lt; std::endl;
+
+      map = submap;
+      submap.clear();
+      submap_size = 0.0;
+    }
+    submap_num++;
   }
 
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
@@ -898,7 +891,7 @@ int main(int argc, char** argv)
   ros::Subscriber param_sub = nh.subscribe("config/approximate_ndt_mapping", 10, param_callback);
   ros::Subscriber output_sub = nh.subscribe("config/ndt_mapping_output", 10, output_callback);
   ros::Subscriber points_sub = nh.subscribe("points_raw", 100000, points_callback);
-  ros::Subscriber odom_sub = nh.subscribe("/odom_pose", 100000, odom_callback);
+  ros::Subscriber odom_sub = nh.subscribe("/vehicle/odom", 100000, odom_callback);
   ros::Subscriber imu_sub = nh.subscribe(_imu_topic, 100000, imu_callback);
 
   ros::spin();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="16" deleted_lines="24">
				<diff>@@ -58,13 +58,13 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#include &lt;pcl/registration/ndt.h&gt;
 #include &lt;fast_pcl/ndt_cpu/NormalDistributionsTransform.h&gt;
+#include &lt;pcl/registration/ndt.h&gt;
 #ifdef CUDA_FOUND
-  #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
+#include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
 #endif
 #ifdef USE_PCL_OPENMP
-  #include &lt;pcl_omp/registration/ndt.h&gt;
+#include &lt;pcl_omp/registration/ndt.h&gt;
 #endif
 
 #include &lt;autoware_msgs/ConfigNdtMapping.h&gt;
@@ -72,7 +72,6 @@
 
 #include &lt;time.h&gt;
 
-
 struct pose
 {
   double x;
@@ -85,10 +84,10 @@ struct pose
 
 enum class MethodType
 {
-    PCL_GENERIC = 0,
-    PCL_ANH = 1,
-    PCL_ANH_GPU = 2,
-    PCL_OPENMP = 3,
+  PCL_GENERIC = 0,
+  PCL_ANH = 1,
+  PCL_ANH_GPU = 2,
+  PCL_OPENMP = 3,
 };
 static MethodType _method_type = MethodType::PCL_GENERIC;
 
@@ -126,8 +125,6 @@ static gpu::GNormalDistributionsTransform anh_gpu_ndt;
 static pcl_omp::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; omp_ndt;
 #endif
 
-
-
 // Default values
 static int max_iter = 30;        // Maximum iterations
 static float ndt_res = 1.0;      // Resolution
@@ -370,10 +367,10 @@ static double wrapToPmPi(double a_angle_rad)
 static double calcDiffForRadian(const double lhs_rad, const double rhs_rad)
 {
   double diff_rad = lhs_rad - rhs_rad;
-  if(diff_rad &gt;= M_PI)
-     diff_rad = diff_rad - 2*M_PI;
-  else if(diff_rad &lt; -M_PI)
-     diff_rad = diff_rad + 2*M_PI;
+  if (diff_rad &gt;= M_PI)
+    diff_rad = diff_rad - 2 * M_PI;
+  else if (diff_rad &lt; -M_PI)
+    diff_rad = diff_rad + 2 * M_PI;
   return diff_rad;
 }
 static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
@@ -547,7 +544,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   }
 #endif
 
-
   static bool is_first_map = true;
   if (is_first_map == true)
   {
@@ -606,7 +602,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
 
-
   if (_method_type == MethodType::PCL_GENERIC)
   {
     ndt.align(*output_cloud, init_guess);
@@ -774,7 +769,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       ndt.setInputTarget(map_ptr);
     else if (_method_type == MethodType::PCL_ANH)
     {
-      if(_incremental_voxel_update == true)
+      if (_incremental_voxel_update == true)
         anh_ndt.updateVoxelGrid(transformed_scan_ptr);
       else
         anh_ndt.setInputTarget(map_ptr);
@@ -789,13 +784,10 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 #endif
   }
 
-
   sensor_msgs::PointCloud2::Ptr map_msg_ptr(new sensor_msgs::PointCloud2);
   pcl::toROSMsg(*map_ptr, *map_msg_ptr);
   ndt_map_pub.publish(*map_msg_ptr);
 
-
-
   q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
   current_pose_msg.header.frame_id = "map";
   current_pose_msg.header.stamp = current_scan_time;
@@ -902,7 +894,7 @@ int main(int argc, char** argv)
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
 
-// setting parameters
+  // setting parameters
   int method_type_tmp = 0;
   private_nh.getParam("method_type", method_type_tmp);
   _method_type = static_cast&lt;MethodType&gt;(method_type_tmp);
@@ -952,7 +944,7 @@ int main(int argc, char** argv)
             &lt;&lt; _tf_roll &lt;&lt; ", " &lt;&lt; _tf_pitch &lt;&lt; ", " &lt;&lt; _tf_yaw &lt;&lt; ")" &lt;&lt; std::endl;
 
 #ifndef CUDA_FOUND
-  if(_method_type == MethodType::PCL_ANH_GPU)
+  if (_method_type == MethodType::PCL_ANH_GPU)
   {
     std::cerr &lt;&lt; "**************************************************************" &lt;&lt; std::endl;
     std::cerr &lt;&lt; "[ERROR]PCL_ANH_GPU is not built. Please use other method type." &lt;&lt; std::endl;
@@ -961,7 +953,7 @@ int main(int argc, char** argv)
   }
 #endif
 #ifndef USE_PCL_OPENMP
-  if(_method_type == MethodType::PCL_OPENMP)
+  if (_method_type == MethodType::PCL_OPENMP)
   {
     std::cerr &lt;&lt; "**************************************************************" &lt;&lt; std::endl;
     std::cerr &lt;&lt; "[ERROR]PCL_OPENMP is not built. Please use other method type." &lt;&lt; std::endl;
@@ -990,7 +982,7 @@ int main(int argc, char** argv)
   ros::Subscriber param_sub = nh.subscribe("config/ndt_mapping", 10, param_callback);
   ros::Subscriber output_sub = nh.subscribe("config/ndt_mapping_output", 10, output_callback);
   ros::Subscriber points_sub = nh.subscribe("points_raw", 100000, points_callback);
-  ros::Subscriber odom_sub = nh.subscribe("/odom_pose", 100000, odom_callback);
+  ros::Subscriber odom_sub = nh.subscribe("/vehicle/odom", 100000, odom_callback);
   ros::Subscriber imu_sub = nh.subscribe(_imu_topic, 100000, imu_callback);
 
   ros::spin();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="34" deleted_lines="39">
				<diff>@@ -34,18 +34,18 @@
  Yuki KITSUKAWA
  */
 
+#include &lt;pthread.h&gt;
 #include &lt;chrono&gt;
 #include &lt;fstream&gt;
 #include &lt;iostream&gt;
+#include &lt;memory&gt;
 #include &lt;sstream&gt;
 #include &lt;string&gt;
-#include &lt;memory&gt;
-#include &lt;pthread.h&gt;
 
+#include &lt;nav_msgs/Odometry.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/Imu.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
-#include &lt;nav_msgs/Odometry.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;std_msgs/Float32.h&gt;
 #include &lt;std_msgs/String.h&gt;
@@ -65,16 +65,15 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#include &lt;pcl/registration/ndt.h&gt;
 #include &lt;fast_pcl/ndt_cpu/NormalDistributionsTransform.h&gt;
+#include &lt;pcl/registration/ndt.h&gt;
 #ifdef CUDA_FOUND
-  #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
+#include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
 #endif
 #ifdef USE_PCL_OPENMP
-  #include &lt;pcl_omp/registration/ndt.h&gt;
+#include &lt;pcl_omp/registration/ndt.h&gt;
 #endif
 
-
 #include &lt;pcl_ros/point_cloud.h&gt;
 #include &lt;pcl_ros/transforms.h&gt;
 
@@ -100,10 +99,10 @@ struct pose
 
 enum class MethodType
 {
-    PCL_GENERIC = 0,
-    PCL_ANH = 1,
-    PCL_ANH_GPU = 2,
-    PCL_OPENMP = 3,
+  PCL_GENERIC = 0,
+  PCL_ANH = 1,
+  PCL_ANH_GPU = 2,
+  PCL_OPENMP = 3,
 };
 static MethodType _method_type = MethodType::PCL_GENERIC;
 
@@ -124,17 +123,16 @@ static int map_loaded = 0;
 static int _use_gnss = 1;
 static int init_pos_set = 0;
 
-
 static pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;
 static cpu::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; anh_ndt;
 #ifdef CUDA_FOUND
-static std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; anh_gpu_ndt_ptr = std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
+static std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; anh_gpu_ndt_ptr =
+    std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
 #endif
 #ifdef USE_PCL_OPENMP
 static pcl_omp::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; omp_ndt;
 #endif
 
-
 // Default values
 static int max_iter = 30;        // Maximum iterations
 static float ndt_res = 1.0;      // Resolution
@@ -313,7 +311,6 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
     else if (_method_type == MethodType::PCL_OPENMP)
       omp_ndt.setTransformationEpsilon(ndt_res);
 #endif
-
   }
 
   if (input-&gt;max_iterations != max_iter)
@@ -437,8 +434,7 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(map));
 
-
-// Setting point cloud to be aligned to.
+    // Setting point cloud to be aligned to.
     if (_method_type == MethodType::PCL_GENERIC)
     {
       pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_ndt;
@@ -478,7 +474,8 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 #ifdef CUDA_FOUND
     else if (_method_type == MethodType::PCL_ANH_GPU)
     {
-      std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; new_anh_gpu_ndt_ptr = std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
+      std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; new_anh_gpu_ndt_ptr =
+          std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
       new_anh_gpu_ndt_ptr-&gt;setResolution(ndt_res);
       new_anh_gpu_ndt_ptr-&gt;setInputTarget(map_ptr);
       new_anh_gpu_ndt_ptr-&gt;setMaximumIterations(max_iter);
@@ -560,13 +557,13 @@ static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
     diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);
 
     const double diff_time = (current_gnss_time - previous_gnss_time).toSec();
-    current_velocity   = (diff_time &gt; 0) ? (diff / diff_time) : 0;
+    current_velocity = (diff_time &gt; 0) ? (diff / diff_time) : 0;
     current_velocity_x = (diff_time &gt; 0) ? (diff_x / diff_time) : 0;
     current_velocity_y = (diff_time &gt; 0) ? (diff_y / diff_time) : 0;
     current_velocity_z = (diff_time &gt; 0) ? (diff_z / diff_time) : 0;
-    angular_velocity   = (diff_time &gt; 0) ? (diff_yaw / diff_time) : 0;
+    angular_velocity = (diff_time &gt; 0) ? (diff_yaw / diff_time) : 0;
 
-    current_accel   = 0.0;
+    current_accel = 0.0;
     current_accel_x = 0.0;
     current_accel_y = 0.0;
     current_accel_z = 0.0;
@@ -640,13 +637,13 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
   previous_pose.pitch = current_pose.pitch;
   previous_pose.yaw = current_pose.yaw;
 
-  current_velocity   = 0.0;
+  current_velocity = 0.0;
   current_velocity_x = 0.0;
   current_velocity_y = 0.0;
   current_velocity_z = 0.0;
-  angular_velocity   = 0.0;
+  angular_velocity = 0.0;
 
-  current_accel   = 0.0;
+  current_accel = 0.0;
   current_accel_x = 0.0;
   current_accel_y = 0.0;
   current_accel_z = 0.0;
@@ -810,10 +807,10 @@ static double wrapToPmPi(const double a_angle_rad)
 static double calcDiffForRadian(const double lhs_rad, const double rhs_rad)
 {
   double diff_rad = lhs_rad - rhs_rad;
-  if(diff_rad &gt;= M_PI)
-     diff_rad = diff_rad - 2*M_PI;
-  else if(diff_rad &lt; -M_PI)
-     diff_rad = diff_rad + 2*M_PI;
+  if (diff_rad &gt;= M_PI)
+    diff_rad = diff_rad - 2 * M_PI;
+  else if (diff_rad &lt; -M_PI)
+    diff_rad = diff_rad + 2 * M_PI;
   return diff_rad;
 }
 
@@ -936,11 +933,11 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       anh_ndt.setInputSource(filtered_scan_ptr);
 #ifdef CUDA_FOUND
     else if (_method_type == MethodType::PCL_ANH_GPU)
-        anh_gpu_ndt_ptr-&gt;setInputSource(filtered_scan_ptr);
+      anh_gpu_ndt_ptr-&gt;setInputSource(filtered_scan_ptr);
 #endif
 #ifdef USE_PCL_OPENMP
     else if (_method_type == MethodType::PCL_OPENMP)
-        omp_ndt.setInputSource(filtered_scan_ptr);
+      omp_ndt.setInputSource(filtered_scan_ptr);
 #endif
 
     // Guess the initial gross estimation of the transformation
@@ -1000,7 +997,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
 
-
     if (_method_type == MethodType::PCL_GENERIC)
     {
       align_start = std::chrono::system_clock::now();
@@ -1146,11 +1142,11 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     diff_yaw = calcDiffForRadian(current_pose.yaw, previous_pose.yaw);
     diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);
 
-    current_velocity   = (diff_time &gt; 0) ? (diff / diff_time) : 0;
+    current_velocity = (diff_time &gt; 0) ? (diff / diff_time) : 0;
     current_velocity_x = (diff_time &gt; 0) ? (diff_x / diff_time) : 0;
     current_velocity_y = (diff_time &gt; 0) ? (diff_y / diff_time) : 0;
     current_velocity_z = (diff_time &gt; 0) ? (diff_z / diff_time) : 0;
-    angular_velocity   = (diff_time &gt; 0) ? (diff_yaw / diff_time) : 0;
+    angular_velocity = (diff_time &gt; 0) ? (diff_yaw / diff_time) : 0;
 
     current_pose_imu.x = current_pose.x;
     current_pose_imu.y = current_pose.y;
@@ -1183,7 +1179,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       current_velocity_smooth = 0.0;
     }
 
-    current_accel   = (diff_time &gt; 0) ? ((current_velocity - previous_velocity) / diff_time) : 0;
+    current_accel = (diff_time &gt; 0) ? ((current_velocity - previous_velocity) / diff_time) : 0;
     current_accel_x = (diff_time &gt; 0) ? ((current_velocity_x - previous_velocity_x) / diff_time) : 0;
     current_accel_y = (diff_time &gt; 0) ? ((current_velocity_y - previous_velocity_y) / diff_time) : 0;
     current_accel_z = (diff_time &gt; 0) ? ((current_velocity_z - previous_velocity_z) / diff_time) : 0;
@@ -1485,7 +1481,7 @@ void* thread_func(void* args)
     map_callback_queue.callAvailable(ros::WallDuration());
     ros_rate.sleep();
   }
-  
+
   return nullptr;
 }
 
@@ -1572,9 +1568,8 @@ int main(int argc, char** argv)
             &lt;&lt; _tf_roll &lt;&lt; ", " &lt;&lt; _tf_pitch &lt;&lt; ", " &lt;&lt; _tf_yaw &lt;&lt; ")" &lt;&lt; std::endl;
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
 
-
 #ifndef CUDA_FOUND
-  if(_method_type == MethodType::PCL_ANH_GPU)
+  if (_method_type == MethodType::PCL_ANH_GPU)
   {
     std::cerr &lt;&lt; "**************************************************************" &lt;&lt; std::endl;
     std::cerr &lt;&lt; "[ERROR]PCL_ANH_GPU is not built. Please use other method type." &lt;&lt; std::endl;
@@ -1583,7 +1578,7 @@ int main(int argc, char** argv)
   }
 #endif
 #ifndef USE_PCL_OPENMP
-  if(_method_type == MethodType::PCL_OPENMP)
+  if (_method_type == MethodType::PCL_OPENMP)
   {
     std::cerr &lt;&lt; "**************************************************************" &lt;&lt; std::endl;
     std::cerr &lt;&lt; "[ERROR]PCL_OPENMP is not built. Please use other method type." &lt;&lt; std::endl;
@@ -1628,7 +1623,7 @@ int main(int argc, char** argv)
   //  ros::Subscriber map_sub = nh.subscribe("points_map", 1, map_callback);
   ros::Subscriber initialpose_sub = nh.subscribe("initialpose", 10, initialpose_callback);
   ros::Subscriber points_sub = nh.subscribe("filtered_points", _queue_size, points_callback);
-  ros::Subscriber odom_sub = nh.subscribe("/odom_pose", _queue_size * 10, odom_callback);
+  ros::Subscriber odom_sub = nh.subscribe("/vehicle/odom", _queue_size * 10, odom_callback);
   ros::Subscriber imu_sub = nh.subscribe(_imu_topic.c_str(), _queue_size * 10, imu_callback);
 
   pthread_t thread;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c2a0103e42254216061191f52d2179373640657d" author="Yusuke FUJII">
		<msg>fix a build setting</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_core.cpp" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_core.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -68,7 +68,7 @@ void CanOdometryNode::initForROS()
   }
 
   // setup subscriber
-  sub1_ = nh_.subscribe("vehicle_status", 10, &amp;CanOdometryNode::callbackFromCanInfo, this);
+  sub1_ = nh_.subscribe("vehicle_status", 10, &amp;CanOdometryNode::callbackFromVehicleStatus, this);
 
   // setup publisher
   pub1_ = nh_.advertise&lt;nav_msgs::Odometry&gt;("/vehicle/odom", 10);
@@ -79,7 +79,7 @@ void CanOdometryNode::run()
   ros::spin();
 }
 
-void CanOdometryNode::publishOdometry(const autoware_msgs::CanInfoConstPtr &amp;msg)
+void CanOdometryNode::publishOdometry(const autoware_msgs::VehicleStatusConstPtr &amp;msg)
 {
   double vx = kmph2mps(msg-&gt;speed);
   double vth = v_info_.convertSteeringAngleToAngularVelocity(kmph2mps(msg-&gt;speed), msg-&gt;angle);
@@ -119,10 +119,10 @@ void CanOdometryNode::publishOdometry(const autoware_msgs::CanInfoConstPtr &amp;msg)
   odom.twist.twist.angular.z = vth;
 
   // publish the message
-  pub3_.publish(odom);
+  pub1_.publish(odom);
 }
 
-void CanOdometryNode::callbackFromCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
+void CanOdometryNode::callbackFromVehicleStatus(const autoware_msgs::VehicleStatusConstPtr &amp;msg)
 {
   publishOdometry(msg);
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_core.h" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_core.h" added_lines="1" deleted_lines="3">
				<diff>@@ -159,9 +159,7 @@ private:
   void initForROS();
 
   // functions
-  void publishVelocity(const autoware_msgs::CanInfoConstPtr &amp;msg);
-  void publishVelocityViz(const autoware_msgs::CanInfoConstPtr &amp;msg);
-  void publishOdometry(const autoware_msgs::CanInfoConstPtr &amp;msg);
+  void publishOdometry(const autoware_msgs::VehicleStatusConstPtr &amp;msg);
 };
 }
 #endif  // CAN_ODOMETRY_CORE_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6eb83beb79247fcbb98fb0311bb13d916b3f1cd1" author="Kosuke Murakami">
		<msg>Add target_id visualizing</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="2" deleted_lines="0">
				<diff>@@ -804,6 +804,8 @@ void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
 
       autoware_msgs::CloudCluster cc;
       cc.header = input.header;
+      // std::cout &lt;&lt; "id "&lt;&lt; i &lt;&lt; std::endl;
+      cc.id     = i;
       cc.bounding_box = targets_[i].jsk_bb_;
       cc.bounding_box.header = input.header;
       cc.score           = tv;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" added_lines="5" deleted_lines="3">
				<diff>@@ -10,6 +10,7 @@
 #include &lt;pcl/io/io.h&gt;
 
 #include &lt;vector&gt;
+#include &lt;string&gt;
 
 #include "autoware_msgs/CloudCluster.h"
 #include "autoware_msgs/CloudClusterArray.h"
@@ -23,13 +24,14 @@ class VisualizeCloudCluster
 {
 private:
 	std::string input_topic_;
-	
+
 	ros::NodeHandle node_handle_;
   ros::Subscriber sub_cloud_array_;
   ros::Publisher  pub_jsk_bb_;
   ros::Publisher  pub_arrow_;
+	ros::Publisher  pub_id_;
 
-	void getJskBB(autoware_msgs::CloudClusterArray input,
+	void getJskBBs(autoware_msgs::CloudClusterArray input,
 				  jsk_recognition_msgs::BoundingBoxArray&amp; jskBBs);
 	void visArrows(autoware_msgs::CloudClusterArray input);
 	void callBack(autoware_msgs::CloudClusterArray input);
@@ -38,4 +40,4 @@ public:
 	VisualizeCloudCluster();
 };
 
-#endif //OBJECT_TRACKING_VisualizeCloudCluster_H
\ No newline at end of file
+#endif //OBJECT_TRACKING_VisualizeCloudCluster_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" added_lines="61" deleted_lines="39">
				<diff>@@ -1,23 +1,8 @@
 #include "visualize_cloud_cluster.h"
 
-// #include &lt;ros/ros.h&gt;
-// #include &lt;std_msgs/Header.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
 
-// #include &lt;string&gt;
-
-// #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
-// #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-
-// #include &lt;pcl/io/io.h&gt;
-
-// #include &lt;vector&gt;
-
-
-// using namespace std;
-// using namespace pcl;
-// using namespace Eigen;
 
 VisualizeCloudCluster::VisualizeCloudCluster()
 {
@@ -27,23 +12,25 @@ VisualizeCloudCluster::VisualizeCloudCluster()
 	sub_cloud_array_  = node_handle_.subscribe (input_topic_, 1, &amp;VisualizeCloudCluster::callBack, this);
 	pub_jsk_bb_       = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt; ("/tracking_cluster_array/jsk_bb", 1);
 	pub_arrow_        = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/tracking_cluster_array/velocity_arrow", 1);
+	pub_id_           = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/tracking_cluster_array/target_id", 1);
 }
 
 void VisualizeCloudCluster::callBack(autoware_msgs::CloudClusterArray input)
 {
 	jsk_recognition_msgs::BoundingBoxArray jsk_bbs;
 	visualization_msgs::Marker arrows;
-	getJskBB(input, jsk_bbs);
+
+	getJskBBs(input, jsk_bbs);
 	pub_jsk_bb_.publish(jsk_bbs);
 	visArrows(input);
 	// cout &lt;&lt; "receive jsk call back" &lt;&lt; endl;
 }
 
-void VisualizeCloudCluster::getJskBB(autoware_msgs::CloudClusterArray input,
+void VisualizeCloudCluster::getJskBBs(autoware_msgs::CloudClusterArray input,
 							 jsk_recognition_msgs::BoundingBoxArray&amp; jsk_bbs)
 {
 	jsk_bbs.header = input.header;
-	
+
 	for(size_t i = 0; i &lt; input.clusters.size(); i++)
 	{
 		jsk_recognition_msgs::BoundingBox bb;
@@ -63,24 +50,70 @@ void VisualizeCloudCluster::getJskBB(autoware_msgs::CloudClusterArray input,
 		}
 
 		jsk_bbs.boxes.push_back(bb);
-
 	}
-	// cout &lt;&lt;"cluster size " &lt;&lt; jsk_bbs.boxes.size() &lt;&lt; endl; 
+	// cout &lt;&lt;"cluster size " &lt;&lt; jsk_bbs.boxes.size() &lt;&lt; endl;
 }
 
 void VisualizeCloudCluster::visArrows(autoware_msgs::CloudClusterArray input)
 {
 	for(size_t i = 0; i &lt; input.clusters.size(); i++)
 	{
+
+		double tv   = input.clusters[i].score;
+		double tyaw = input.clusters[i].estimated_angle;
+		std::string label = input.clusters[i].label;
+
+		visualization_msgs::Marker ids;
+
+		if(label == "None" || label == "Initialized" || label == "Lost")
+		{
+			continue;
+		}
+		ids.lifetime = ros::Duration(0.15);
+		ids.header.frame_id = "/velodyne";
+		ids.header.stamp = input.header.stamp;
+		ids.ns = "ids";
+		ids.action = visualization_msgs::Marker::ADD;
+		ids.type   = visualization_msgs::Marker::TEXT_VIEW_FACING;
+		// green
+		ids.color.g = 1.0f;
+		ids.color.a = 1.0;
+		ids.id = i;
+
+
+		// Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
+		ids.pose.position.x = input.clusters[i].bounding_box.pose.position.x;
+		ids.pose.position.y = input.clusters[i].bounding_box.pose.position.y;
+		ids.pose.position.z = 1.5;
+
+		// convert from RPY to quartenion
+		tf::Matrix3x3 obs_mat;
+		obs_mat.setEulerYPR(tyaw, 0, 0); // yaw, pitch, roll
+		tf::Quaternion q_tf;
+		obs_mat.getRotation(q_tf);
+		ids.pose.orientation.x = q_tf.getX();
+		ids.pose.orientation.y = q_tf.getY();
+		ids.pose.orientation.z = q_tf.getZ();
+		ids.pose.orientation.w = q_tf.getW();
+
+		// Set the scale of the ids -- 1x1x1 here means 1m on a side
+		// ids.scale.x = tv;
+		// ids.scale.y = 0.1;
+		ids.scale.z = 1.0;
+
+		ids.text = std::to_string(input.clusters[i].id);
+
+		pub_id_.publish(ids);
+
+
 		visualization_msgs::Marker arrows;
 		arrows.lifetime = ros::Duration(0.1);
-		std::string label = input.clusters[i].label;
 
-		if(label == "None" || label == "Initialized" || label == "Lost" || label == "Static") 
+		if(label == "None" || label == "Initialized" || label == "Lost" || label == "Static")
 		{
 			continue;
 		}
-		
+
 		arrows.header.frame_id = "/velodyne";
 		arrows.header.stamp = input.header.stamp;
 		arrows.ns = "arrows";
@@ -88,26 +121,15 @@ void VisualizeCloudCluster::visArrows(autoware_msgs::CloudClusterArray input)
 		arrows.type   = visualization_msgs::Marker::ARROW;
 		// green
 		arrows.color.g = 1.0f;
-		arrows.color.a = 1.0;  
+		arrows.color.a = 1.0;
 		arrows.id = i;
-		geometry_msgs::Point p;
-		// assert(targetPoints[i].size()==4);
-		p.x = input.clusters[i].bounding_box.pose.position.x;
-		p.y = input.clusters[i].bounding_box.pose.position.y;
-		p.z = 0.5;
-		double tv   = input.clusters[i].score;
-		double tyaw = input.clusters[i].estimated_angle;
 
 		// Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
-		arrows.pose.position.x = p.x;
-		arrows.pose.position.y = p.y;
-		arrows.pose.position.z = p.z;
+		arrows.pose.position.x = input.clusters[i].bounding_box.pose.position.x;
+		arrows.pose.position.y = input.clusters[i].bounding_box.pose.position.y;
+		arrows.pose.position.z = 0.5;
+
 
-		// convert from RPY to quartenion
-		tf::Matrix3x3 obs_mat;
-		obs_mat.setEulerYPR(tyaw, 0, 0); // yaw, pitch, roll
-		tf::Quaternion q_tf;
-		obs_mat.getRotation(q_tf);
 		arrows.pose.orientation.x = q_tf.getX();
 		arrows.pose.orientation.y = q_tf.getY();
 		arrows.pose.orientation.z = q_tf.getZ();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9064a24a16d586ab950a3be4428a89189f8c15e4" author="Kosuke Murakami">
		<msg>Refactor codes</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" added_lines="1" deleted_lines="1">
				<diff>@@ -33,7 +33,7 @@ private:
 
 	void getJskBBs(autoware_msgs::CloudClusterArray input,
 				  jsk_recognition_msgs::BoundingBoxArray&amp; jskBBs);
-	void visArrows(autoware_msgs::CloudClusterArray input);
+	void visMarkers(autoware_msgs::CloudClusterArray input);
 	void callBack(autoware_msgs::CloudClusterArray input);
 
 public:
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -22,7 +22,7 @@ void VisualizeCloudCluster::callBack(autoware_msgs::CloudClusterArray input)
 
 	getJskBBs(input, jsk_bbs);
 	pub_jsk_bb_.publish(jsk_bbs);
-	visArrows(input);
+	visMarkers(input);
 	// cout &lt;&lt; "receive jsk call back" &lt;&lt; endl;
 }
 
@@ -54,7 +54,7 @@ void VisualizeCloudCluster::getJskBBs(autoware_msgs::CloudClusterArray input,
 	// cout &lt;&lt;"cluster size " &lt;&lt; jsk_bbs.boxes.size() &lt;&lt; endl;
 }
 
-void VisualizeCloudCluster::visArrows(autoware_msgs::CloudClusterArray input)
+void VisualizeCloudCluster::visMarkers(autoware_msgs::CloudClusterArray input)
 {
 	for(size_t i = 0; i &lt; input.clusters.size(); i++)
 	{
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d694c2da609b7f09633d652cc0fecd5c265f79b0" author="Kosuke Murakami">
		<msg>Change param handling slightly</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="6" deleted_lines="3">
				<diff>@@ -53,17 +53,20 @@ int g_count = 0;
 ImmUkfPda::ImmUkfPda()
 {
   ros::NodeHandle private_nh_("~");
+  // dynamic params
+  private_nh_.param&lt;int&gt;("life_time_thres_", life_time_thres_, 8);
+  private_nh_.param&lt;std::string&gt;("input_topic_", input_topic_, "/cloud_clusters");
+  private_nh_.param&lt;std::string&gt;("output_topic_", output_topic_, "/tracking_cluster_array");
+
+  // static params
   private_nh_.param&lt;bool&gt;("init_", init_, false);
   private_nh_.param&lt;double&gt;("gamma_g_", gamma_g_, 9.22);
   private_nh_.param&lt;double&gt;("p_g_", p_g_, 0.99);
   private_nh_.param&lt;double&gt;("p_d_", p_d_, 0.9);
   private_nh_.param&lt;double&gt;("distance_thres_", distance_thres_, 99);
-  private_nh_.param&lt;int&gt;("life_time_thres_", life_time_thres_, 8);
   private_nh_.param&lt;double&gt;("bb_yaw_change_thres_", bb_yaw_change_thres_, 0.3);
   private_nh_.param&lt;double&gt;("dist_from_init_thres_", dist_from_init_thres_, 3.0);
   private_nh_.param&lt;double&gt;("init_yaw_", init_yaw_, 100);
-  private_nh_.param&lt;std::string&gt;("input_topic_", input_topic_, "/cloud_clusters");
-  private_nh_.param&lt;std::string&gt;("output_topic_", output_topic_, "/tracking_cluster_array");
 
   tf::TransformListener *lr (new  tf::TransformListener);
   tran_=lr;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d065944796da38746346b616d3297a8b785e9e92" author="Kosuke Murakami">
		<msg>Modify roslaunch params</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" added_lines="4" deleted_lines="4">
				<diff>@@ -35,12 +35,12 @@ private:
 	// std::vector&lt;int&gt; trackNumVec_;
 
 	// probabilistic data association params
-	double gamma_g_;//9.22; // 99%
-	double p_g_;//0.99;
+	double gating_thres_;//9.22; // 99%
+	double gate_probability_;//0.99;
 	// extern double gammaG_ = 5.99; // 99%
 	// extern double pG_ = 0.95;
 	// extern double gammaG_ = 15.22; // 99%
-	double p_d_;//0.9;
+	double detection_probability_;//0.9;
 
 	//bbox association param
 	double distance_thres_;//0.25;
@@ -49,7 +49,7 @@ private:
 	double bb_yaw_change_thres_;//0.2;
 	// double bb_area_change_thres_;//0.5;
 
-	double dist_from_init_thres_;
+	double static_distance_thres_;
 
 	double init_yaw_;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" added_lines="3" deleted_lines="1">
				<diff>@@ -160,7 +160,7 @@ public:
   Eigen::MatrixXd k_ctrv_;
   Eigen::MatrixXd k_rm_;
 
-  double gamma_g_;
+  // double gamma_g_;
   double pd_;
   double pg_;
 
@@ -173,6 +173,8 @@ public:
 
   jsk_recognition_msgs::BoundingBox jsk_bb_;
   jsk_recognition_msgs::BoundingBox best_jsk_bb_;
+
+  bool is_best_jsk_bb_empty_;
   // pcl::PointCloud&lt;pcl::PointXYZ&gt; bbox_;
   // pcl::PointCloud&lt;pcl::PointXYZ&gt; bestBBox_;
   double best_yaw_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="23" deleted_lines="42">
				<diff>@@ -1,21 +1,3 @@
-//
-// Created by kosuke on 12/23/17.
-//
-
-// #include &lt;ros/ros.h&gt;
-
-// #include &lt;iostream&gt;
-// #include &lt;fstream&gt;
-// #include &lt;vector&gt;
-// #include &lt;cmath&gt;
-// #include &lt;math.h&gt;
-
-// #include &lt;limits.h&gt;
-
-// #include &lt;tf/tf.h&gt;
-// #include &lt;tf/transform_listener.h&gt;
-// #include &lt;tf2/LinearMath/Quaternion.h&gt;
-
 #include "ukf.h"
 #include "imm_ukf_pda_tracker.h"
 
@@ -53,20 +35,18 @@ int g_count = 0;
 ImmUkfPda::ImmUkfPda()
 {
   ros::NodeHandle private_nh_("~");
-  // dynamic params
   private_nh_.param&lt;int&gt;("life_time_thres_", life_time_thres_, 8);
   private_nh_.param&lt;std::string&gt;("input_topic_", input_topic_, "/cloud_clusters");
   private_nh_.param&lt;std::string&gt;("output_topic_", output_topic_, "/tracking_cluster_array");
-
-  // static params
-  private_nh_.param&lt;bool&gt;("init_", init_, false);
-  private_nh_.param&lt;double&gt;("gamma_g_", gamma_g_, 9.22);
-  private_nh_.param&lt;double&gt;("p_g_", p_g_, 0.99);
-  private_nh_.param&lt;double&gt;("p_d_", p_d_, 0.9);
+  private_nh_.param&lt;double&gt;("gating_thres_", gating_thres_, 9.22);
+  private_nh_.param&lt;double&gt;("gate_probability_", gate_probability_, 0.99);
+  private_nh_.param&lt;double&gt;("detection_probability_", detection_probability_, 0.9);
   private_nh_.param&lt;double&gt;("distance_thres_", distance_thres_, 99);
-  private_nh_.param&lt;double&gt;("bb_yaw_change_thres_", bb_yaw_change_thres_, 0.3);
-  private_nh_.param&lt;double&gt;("dist_from_init_thres_", dist_from_init_thres_, 3.0);
-  private_nh_.param&lt;double&gt;("init_yaw_", init_yaw_, 100);
+  private_nh_.param&lt;double&gt;("static_distance_thres_", static_distance_thres_, 3.0);
+  // private_nh_.param&lt;double&gt;("bb_yaw_change_thres_", bb_yaw_change_thres_, 0.3);
+  // private_nh_.param&lt;double&gt;("init_yaw_", init_yaw_, 100);
+
+  init_ = false;
 
   tf::TransformListener *lr (new  tf::TransformListener);
   tran_=lr;
@@ -177,7 +157,7 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
     Eigen::VectorXd diff = meas - max_det_z;
     double nis = diff.transpose()*max_det_s.inverse()*diff;
     // cout &lt;&lt;"nis: " &lt;&lt;nis &lt;&lt; endl;
-    if(nis &lt; gamma_g_)
+    if(nis &lt; gating_thres_)
     { // x^2 99% range
       count ++;
       if(matching_vec[i] == IsMatch::False) target.lifetime_ ++;
@@ -210,7 +190,7 @@ void ImmUkfPda::filterPDA(UKF&amp; target,
 {
   // calculating association probability
   double num_meas = cluster_vec.size();
-  double b = 2*num_meas*(1-p_d_*p_g_)/(gamma_g_*p_d_);
+  double b = 2*num_meas*(1-detection_probability_*gate_probability_)/(gating_thres_*detection_probability_);
   double e_cv_sum   = 0;
   double e_ctrv_sum = 0;
   double e_rm_sum   = 0;
@@ -330,23 +310,23 @@ void ImmUkfPda::filterPDA(UKF&amp; target,
   Eigen::MatrixXd max_det_s;
 
   findMaxZandS(target, max_det_z, max_det_s);
-  double Vk =  M_PI *sqrt(gamma_g_ * max_det_s.determinant());
+  double Vk =  M_PI *sqrt(gating_thres_ * max_det_s.determinant());
 
   double lambda_cv, lambda_ctrv, lambda_rm;
   if(num_meas != 0)
   {
-    lambda_cv   = (1 - p_g_*p_d_)/pow(Vk, num_meas) +
-                        p_d_*pow(Vk, 1-num_meas)*e_cv_sum/(num_meas*sqrt(2*M_PI*target.s_cv_.determinant()));
-    lambda_ctrv = (1 - p_g_*p_d_)/pow(Vk, num_meas) +
-                        p_d_*pow(Vk, 1-num_meas)*e_ctrv_sum/(num_meas*sqrt(2*M_PI*target.s_ctrv_.determinant()));
-    lambda_rm   = (1 - p_g_*p_d_)/pow(Vk, num_meas) +
-                        p_d_*pow(Vk, 1-num_meas)*e_rm_sum/(num_meas*sqrt(2*M_PI*target.s_rm_.determinant()));
+    lambda_cv   = (1 - gate_probability_*detection_probability_)/pow(Vk, num_meas) +
+                        detection_probability_*pow(Vk, 1-num_meas)*e_cv_sum/(num_meas*sqrt(2*M_PI*target.s_cv_.determinant()));
+    lambda_ctrv = (1 - gate_probability_*detection_probability_)/pow(Vk, num_meas) +
+                        detection_probability_*pow(Vk, 1-num_meas)*e_ctrv_sum/(num_meas*sqrt(2*M_PI*target.s_ctrv_.determinant()));
+    lambda_rm   = (1 - gate_probability_*detection_probability_)/pow(Vk, num_meas) +
+                        detection_probability_*pow(Vk, 1-num_meas)*e_rm_sum/(num_meas*sqrt(2*M_PI*target.s_rm_.determinant()));
   }
   else
   {
-    lambda_cv   = (1 - p_g_*p_d_)/pow(Vk, num_meas);
-    lambda_ctrv = (1 - p_g_*p_d_)/pow(Vk, num_meas);
-    lambda_rm   = (1 - p_g_*p_d_)/pow(Vk, num_meas);
+    lambda_cv   = (1 - gate_probability_*detection_probability_)/pow(Vk, num_meas);
+    lambda_ctrv = (1 - gate_probability_*detection_probability_)/pow(Vk, num_meas);
+    lambda_rm   = (1 - gate_probability_*detection_probability_)/pow(Vk, num_meas);
   }
   // cout &lt;&lt;endl&lt;&lt; "lambda: "&lt;&lt;endl&lt;&lt;lambdaCV &lt;&lt; " "&lt;&lt; lambdaCTRV&lt;&lt;" "&lt;&lt; lambdaRM &lt;&lt; endl;
   lambda_vec.push_back(lambda_cv);
@@ -455,10 +435,11 @@ void ImmUkfPda::updateBB(UKF&amp; target)
   // skip the rest of process if it is first bbox associaiton
   // todo: wanna check if bestJskBBox is empty or not, there should be better method
   // if(target.bestBBox_.empty()){
-  if(target.best_yaw_ == init_yaw_)
+  if(target.is_best_jsk_bb_empty_ == false)
   {
     target.best_jsk_bb_ = target.jsk_bb_;
     target.best_yaw_   = yaw;
+    target.is_best_jsk_bb_empty_ = true;
     return;
   }
 
@@ -757,7 +738,7 @@ void ImmUkfPda::staticClassification()
      targets_[i].lifetime_ &gt; life_time_thres_ )
     {
       // double dist_thres = 3.0;
-      if((targets_[i].dist_from_init_ &lt; dist_from_init_thres_)&amp;&amp;
+      if((targets_[i].dist_from_init_ &lt; static_distance_thres_)&amp;&amp;
           (targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_cv_ ||
            targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_ctrv_ ))
       {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" added_lines="2" deleted_lines="1">
				<diff>@@ -147,7 +147,7 @@ UKF::UKF()
 
 
 
-  gamma_g_ = 9.21;
+  // gamma_g_ = 9.21;
   pd_     = 0.9;
   pg_     = 0.99;
 
@@ -156,6 +156,7 @@ UKF::UKF()
   is_static_ = false;
 
   //bounding box params
+  is_best_jsk_bb_empty_ = false;
   is_vis_bb_ = false;
   best_yaw_ = 100;
   bb_yaw_  = 0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0a48443ebcf3fa9ec735191d8d549d61762ede8c" author="Abraham Monrroy">
		<msg>[fix] Fixes for all packages and dependencies (#1240)

* Initial Cleanup

* fixed also for indigo

* kf cjeck

* Fix road wizard

* Added travis ci

* Trigger CI

* Fixes to cv_tracker and lidar_tracker cmake

* Fix kitti player dependencies

* Removed unnecessary dependencies

* messages fixing for can

* Update build script travis

* Travis Path

* Travis Paths fix

* Travis test

* Eigen checks

* removed unnecessary dependencies

* Eigen Detection

* Job number reduced

* Eigen3 more fixes

* More Eigen3

* Even more Eigen

* find package cmake modules included

* More fixes to cmake modules

* Removed non ros dependency

* Enable industrial_ci for indidog and kinetic

* Wrong install command

* fix rviz_plugin install

* FastVirtualScan fix

* Fix Qt5 Fastvirtualscan

* Fixed qt5 system dependencies for rosdep

* NDT TKU Fix catkin not pacakged

* More in detail dependencies fixes for more packages

* GLEW library for ORB

* Ignore OrbLocalizer

* Ignore Version checker

* Fix for driveworks interface

* driveworks not catkinpackagedd

* Missing catkin for driveworks

* libdpm opencv not catkin packaged

* catkin lib gnss  not included in obj_db

* Points2Polygon fix

* More missing dependencies

* image viewer not packaged

* Fixed SSH2 detection, added viewers for all distros

* Fix gnss localizer incorrect dependency config

* Fixes to multiple packages dependencies

* gnss plib and package

* More fixes to gnss

* gnss dependencies for gnss_loclaizer

* Missing gnss dependency for gnss on localizer

* More fixes for dependencies
Replaced gnss for autoware_gnss_library

* gnss more fixes

* fixes to more dependencies

* header dependency

* Debug message

* more debug messages changed back to gnss

* debud messages

* gnss test

* gnss install command

* Several fixes for OpenPlanner and its lbiraries

* Fixes to ROSInterface

* More fixes to robotsdk and rosinterface

* robotsdk calibration fix

* Fixes to rosinterface robotsdk libraries and its nodes

* Fixes to Qt5 missing dependencies in robotsdk

* glviewer missing dependencies

* Missing qt specific config cmake for robotsdk

* disable cv_tracker

* Fix to open planner un needed dependendecies

* Fixes for libraries indecision maker

* Fixes to libraries decision_maker installation

* Gazebo on Kinetic

* Added Missing library

* * Removed Gazebo and synchonization packages
* Renames vmap in lane_planner
* Added installation commands for missing pakcages

* Fixes to lane_planner

* Added NDT TKU Glut extra dependencies

* ndt localizer/lib fast pcl fixes
re enable cv_tracker

* Fix kf_lib

* Keep industrial_ci

* Fixes for dpm library

* Fusion lib fixed

* dpm and fusion header should match exported project name

* Fixes to dpm_ocv  ndt_localizer and pcl_omp

* no fast_pcl anymore

* fixes to libdpm and its package

* CI test

* test with native travis ci

* missing update for apt

* Fixes to pcl_omp installation and headers

* Final fixes for tests, modified README

* * Fixes to README
* Enable industrial_ci

* re enable native travis tests</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lib\fusion\include\fusion_func.h" new_path="ros\src\computing\perception\detection\lib\fusion\include\fusion\fusion_func.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\fusion\include\search_distance.h" new_path="ros\src\computing\perception\detection\lib\fusion\include\fusion\search_distance.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\fusion\fusion.cpp" new_path="ros\src\computing\perception\detection\lib\fusion\src\fusion.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -32,8 +32,8 @@
 #include &lt;opencv/highgui.h&gt;
 #include &lt;opencv/cxcore.h&gt;
 
-#include "fusion_func.h"
-#include "search_distance.h"
+#include "fusion/fusion_func.h"
+#include "fusion/search_distance.h"
 
 #if _DEBUG //debug
 static const char *window_name = "CAR_TRACK";
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\fusion\search_distance.cpp" new_path="ros\src\computing\perception\detection\lib\fusion\src\search_distance.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,7 +1,7 @@
 #include &lt;algorithm&gt;
 #include &lt;iterator&gt;
 #include &lt;map&gt;
-#include "search_distance.h"
+#include "fusion/search_distance.h"
 
 
 float getShortest(const std::vector&lt;float&gt;&amp; candidates) {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\main.cpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\main.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
 #include &lt;cstdio&gt;
 #include &lt;cstdlib&gt;
 
-#include &lt;dpm_ttic.hpp&gt;
+#include &lt;libdpm_ttic/dpm_ttic.hpp&gt;
 
 #include "MODEL_info.h"
 #include "switch_float.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\obstacle_detection.cpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\obstacle_detection.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -35,7 +35,7 @@
 #include &lt;sys/time.h&gt;
 #include &lt;sys/resource.h&gt;
 
-#include &lt;dpm_ttic.hpp&gt;
+#include &lt;libdpm_ttic/dpm_ttic.hpp&gt;
 
 #include "for_use_GPU.h"
 #include "load_model.hpp"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\include\dpm_ttic\dpm_ttic.hpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\include\libdpm_ttic\dpm_ttic.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\cpu\dpm_ocv_cpu.cpp" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\cpu\dpm_ocv_cpu.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,6 +1,6 @@
 #include &lt;opencv2/opencv.hpp&gt;
 #include &lt;opencv2/core/core.hpp&gt;
-#include &lt;dpm_ocv.hpp&gt;
+#include &lt;libdpm_ocv/dpm_ocv.hpp&gt;
 
 // Macros in OpenCV private header files
 #define VAL_OF_TRUNCATE 0.2f
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\cuda_check.h" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\cuda_check.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\dpm_ocv_gpu.cpp" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\dpm_ocv_gpu.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
 #include "matching_gpu.hpp"
 #include "routine_gpu.hpp"
 
-#include &lt;dpm_ocv.hpp&gt;
+#include &lt;libdpm_ocv/dpm_ocv.hpp&gt;
 
 // OpenCV non public functions
 extern int freeFeatureMapObject(CvLSVMFeatureMap **obj);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\dpm_ocv_gpu.hpp" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\dpm_ocv_gpu.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\drvapi_error_string.h" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\drvapi_error_string.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\featurepyramid_gpu.cpp" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\featurepyramid_gpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\featurepyramid_gpu.hpp" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\featurepyramid_gpu.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\for_use_gpu.h" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\for_use_gpu.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\gpu_function.cu" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\gpu_function.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\gpu_init.cpp" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\gpu_init.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\gpu_matching.h" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\gpu_matching.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\matching_gpu.cpp" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\matching_gpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\matching_gpu.hpp" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\matching_gpu.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\resizeimg_gpu.cpp" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\resizeimg_gpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\resizeimg_gpu.h" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\resizeimg_gpu.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\routine_gpu.cpp" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\routine_gpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\routine_gpu.hpp" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\routine_gpu.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\include\dpm_ocv\dpm_ocv.hpp" new_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\include\libdpm_ocv\dpm_ocv.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ocv\dpm_ocv.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ocv\dpm_ocv.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -9,7 +9,7 @@
 #include "autoware_msgs/image_obj.h"
 #include "autoware_msgs/ConfigCarDpm.h"
 
-#include &lt;dpm_ocv.hpp&gt;
+#include &lt;libdpm_ocv/dpm_ocv.hpp&gt;
 
 #define XSTR(x) #x
 #define STR(x) XSTR(x)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ttic\dpm_ttic.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ttic\dpm_ttic.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -39,7 +39,7 @@
 #include "autoware_msgs/image_obj.h"
 #include "autoware_msgs/ConfigPedestrianDpm.h"
 
-#include &lt;dpm_ttic.hpp&gt;
+#include &lt;libdpm_ttic/dpm_ttic.hpp&gt;
 
 #define XSTR(x) #x
 #define STR(x) XSTR(x)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\CarPositionXYZ.h" new_path="" added_lines="0" deleted_lines="272">
				<diff>@@ -1,272 +0,0 @@
-/* Software License Agreement (BSD License)
- *
- * Copyright (c) 2011, Willow Garage, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above
- *    copyright notice, this list of conditions and the following
- *    disclaimer in the documentation and/or other materials provided
- *    with the distribution.
- *  * Neither the name of Willow Garage, Inc. nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * Auto-generated by genmsg_cpp from file /home/yukky/catkin_ws/src/sensors_fusion/msg/CarPositionXYZ.msg
- *
- */
-
-#ifndef SENSORS_FUSION_MESSAGE_CARPOSITIONXYZ_H
-#define SENSORS_FUSION_MESSAGE_CARPOSITIONXYZ_H
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;map&gt;
-
-#include &lt;ros/types.h&gt;
-#include &lt;ros/serialization.h&gt;
-#include &lt;ros/builtin_message_traits.h&gt;
-#include &lt;ros/message_operations.h&gt;
-
-#include &lt;std_msgs/Header.h&gt;
-
-namespace sensors_fusion
-{
-template &lt;class ContainerAllocator&gt;
-struct CarPositionXYZ_
-{
-  typedef CarPositionXYZ_&lt;ContainerAllocator&gt; Type;
-
-  CarPositionXYZ_()
-    : header()
-    , car_num(0)
-    , car_type()
-    , corner_point()
-    , distance()  {
-    }
-  CarPositionXYZ_(const ContainerAllocator&amp; _alloc)
-    : header(_alloc)
-    , car_num(0)
-    , car_type(_alloc)
-    , corner_point(_alloc)
-    , distance(_alloc)  {
-    }
-
-   typedef  ::std_msgs::Header_&lt;ContainerAllocator&gt;  _header_type;
-  _header_type header;
-
-   typedef uint8_t _car_num_type;
-  _car_num_type car_num;
-
-   typedef std::vector&lt;int32_t, typename ContainerAllocator::template rebind&lt;int32_t&gt;::other &gt;  _car_type_type;
-  _car_type_type car_type;
-
-   typedef std::vector&lt;int32_t, typename ContainerAllocator::template rebind&lt;int32_t&gt;::other &gt;  _corner_point_type;
-  _corner_point_type corner_point;
-
-   typedef std::vector&lt;float, typename ContainerAllocator::template rebind&lt;float&gt;::other &gt;  _distance_type;
-  _distance_type distance;
-
-  typedef boost::shared_ptr&lt; ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; &gt; Ptr;
-  typedef boost::shared_ptr&lt; ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; const&gt; ConstPtr;
-  boost::shared_ptr&lt;std::map&lt;std::string, std::string&gt; &gt; __connection_header;
-
-}; // struct CarPositionXYZ_
-
-typedef ::sensors_fusion::CarPositionXYZ_&lt;std::allocator&lt;void&gt; &gt; CarPositionXYZ;
-
-typedef boost::shared_ptr&lt; ::sensors_fusion::CarPositionXYZ &gt; CarPositionXYZPtr;
-typedef boost::shared_ptr&lt; ::sensors_fusion::CarPositionXYZ const&gt; CarPositionXYZConstPtr;
-
-// constants requiring out of line definition
-
-template&lt;typename ContainerAllocator&gt;
-std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; &amp; v)
-{
-ros::message_operations::Printer&lt; ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; &gt;::stream(s, "", v);
-return s;
-}
-
-} // namespace sensors_fusion
-
-namespace ros
-{
-namespace message_traits
-{
-
-// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
-// {'sensor_msgs': ['/opt/ros/hydro/share/sensor_msgs/cmake/../msg'], 'sensors_fusion': ['/home/yukky/catkin_ws/src/sensors_fusion/msg'], 'std_msgs': ['/opt/ros/hydro/share/std_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/hydro/share/geometry_msgs/cmake/../msg']}
-
-// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']
-
-template &lt;class ContainerAllocator&gt;
-struct IsFixedSize&lt; ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; &gt;
-  : FalseType
-  { };
-
-template &lt;class ContainerAllocator&gt;
-struct IsFixedSize&lt; ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; const&gt;
-  : FalseType
-  { };
-
-template &lt;class ContainerAllocator&gt;
-struct IsMessage&lt; ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; &gt;
-  : TrueType
-  { };
-
-template &lt;class ContainerAllocator&gt;
-struct IsMessage&lt; ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; const&gt;
-  : TrueType
-  { };
-
-template &lt;class ContainerAllocator&gt;
-struct HasHeader&lt; ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; &gt;
-  : TrueType
-  { };
-
-template &lt;class ContainerAllocator&gt;
-struct HasHeader&lt; ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; const&gt;
-  : TrueType
-  { };
-
-
-template&lt;class ContainerAllocator&gt;
-struct MD5Sum&lt; ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; &gt;
-{
-  static const char* value()
-  {
-    return "d68530dc0bde2f64ddc6c99da3384213";
-  }
-
-  static const char* value(const ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt;&amp;) { return value(); }
-  static const uint64_t static_value1 = 0xd68530dc0bde2f64ULL;
-  static const uint64_t static_value2 = 0xddc6c99da3384213ULL;
-};
-
-template&lt;class ContainerAllocator&gt;
-struct DataType&lt; ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; &gt;
-{
-  static const char* value()
-  {
-    return "sensors_fusion/CarPositionXYZ";
-  }
-
-  static const char* value(const ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt;&amp;) { return value(); }
-};
-
-template&lt;class ContainerAllocator&gt;
-struct Definition&lt; ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; &gt;
-{
-  static const char* value()
-  {
-    return "Header header\n\
-uint8 car_num\n\
-int32[] car_type\n\
-int32[] corner_point\n\
-float32[] distance\n\
-================================================================================\n\
-MSG: std_msgs/Header\n\
-# Standard metadata for higher-level stamped data types.\n\
-# This is generally used to communicate timestamped data \n\
-# in a particular coordinate frame.\n\
-# \n\
-# sequence ID: consecutively increasing ID \n\
-uint32 seq\n\
-#Two-integer timestamp that is expressed as:\n\
-# * stamp.secs: seconds (stamp_secs) since epoch\n\
-# * stamp.nsecs: nanoseconds since stamp_secs\n\
-# time-handling sugar is provided by the client library\n\
-time stamp\n\
-#Frame this data is associated with\n\
-# 0: no frame\n\
-# 1: global frame\n\
-string frame_id\n\
-";
-  }
-
-  static const char* value(const ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt;&amp;) { return value(); }
-};
-
-} // namespace message_traits
-} // namespace ros
-
-namespace ros
-{
-namespace serialization
-{
-
-  template&lt;class ContainerAllocator&gt; struct Serializer&lt; ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; &gt;
-  {
-    template&lt;typename Stream, typename T&gt; inline static void allInOne(Stream&amp; stream, T m)
-    {
-      stream.next(m.header);
-      stream.next(m.car_num);
-      stream.next(m.car_type);
-      stream.next(m.corner_point);
-      stream.next(m.distance);
-    }
-
-    ROS_DECLARE_ALLINONE_SERIALIZER;
-  }; // struct CarPositionXYZ_
-
-} // namespace serialization
-} // namespace ros
-
-namespace ros
-{
-namespace message_operations
-{
-
-template&lt;class ContainerAllocator&gt;
-struct Printer&lt; ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt; &gt;
-{
-  template&lt;typename Stream&gt; static void stream(Stream&amp; s, const std::string&amp; indent, const ::sensors_fusion::CarPositionXYZ_&lt;ContainerAllocator&gt;&amp; v)
-  {
-    s &lt;&lt; indent &lt;&lt; "header: ";
-    s &lt;&lt; std::endl;
-    Printer&lt; ::std_msgs::Header_&lt;ContainerAllocator&gt; &gt;::stream(s, indent + "  ", v.header);
-    s &lt;&lt; indent &lt;&lt; "car_num: ";
-    Printer&lt;uint8_t&gt;::stream(s, indent + "  ", v.car_num);
-    s &lt;&lt; indent &lt;&lt; "car_type[]" &lt;&lt; std::endl;
-    for (size_t i = 0; i &lt; v.car_type.size(); ++i)
-    {
-      s &lt;&lt; indent &lt;&lt; "  car_type[" &lt;&lt; i &lt;&lt; "]: ";
-      Printer&lt;int32_t&gt;::stream(s, indent + "  ", v.car_type[i]);
-    }
-    s &lt;&lt; indent &lt;&lt; "corner_point[]" &lt;&lt; std::endl;
-    for (size_t i = 0; i &lt; v.corner_point.size(); ++i)
-    {
-      s &lt;&lt; indent &lt;&lt; "  corner_point[" &lt;&lt; i &lt;&lt; "]: ";
-      Printer&lt;int32_t&gt;::stream(s, indent + "  ", v.corner_point[i]);
-    }
-    s &lt;&lt; indent &lt;&lt; "distance[]" &lt;&lt; std::endl;
-    for (size_t i = 0; i &lt; v.distance.size(); ++i)
-    {
-      s &lt;&lt; indent &lt;&lt; "  distance[" &lt;&lt; i &lt;&lt; "]: ";
-      Printer&lt;float&gt;::stream(s, indent + "  ", v.distance[i]);
-    }
-  }
-};
-
-} // namespace message_operations
-} // namespace ros
-
-#endif // SENSORS_FUSION_MESSAGE_CARPOSITIONXYZ_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\geo_pos_conv.hh" new_path="" added_lines="0" deleted_lines="164">
				<diff>@@ -1,164 +0,0 @@
-#ifndef __GEO_POS_CONV__
-#define __GEO_POS_CONV__
-
-#include &lt;math.h&gt;
-
-class geo_pos_conv{
-private:
-  double m_x;  //m
-  double m_y;  //m
-  double m_z;  //m
-
-  double m_lat;  //latitude
-  double m_lon; //longitude
-  double m_h;
-  
-  double m_PLato;        //plane lat
-  double m_PLo;          //plane lon
-
-public:
-  double x() const {return m_x;}
-  double y() const {return m_y;}
-  double z() const {return m_z;}
-  
-  void set_plane(double lat,   double lon){
-    m_PLato = lat;
-    m_PLo = lon;
-  }
-  
-  void set_plane(int num){
-    if(num==7){
-      m_PLo = 2.39400995732;   //
-      m_PLato=  0.628318530717;  //
-    }else if(num==9){
-      m_PLo =  2.4405520707;    //
-      m_PLato =  0.628318530717;  //
-    }
-  }
-
-  void set_xyz(double cx,   double cy,   double cz){
-    m_x=cx;
-    m_y=cy;
-    m_z=cz;
-    conv_xyz2llh();
-  }
-
-  //set llh in radians
-  void set_llh(double lat, double lon, double h){
-    m_lat = lat*M_PI/180;
-    m_lon = lon*M_PI/180;
-    m_h=h;
-    conv_llh2xyz();
-  }
-
-  //set llh in nmea degrees
-  void set_llh_nmea_degrees(double latd,double lond, double h){
-    double lat,lad,lod,lon;
-    //1234.56 -&gt; 12'34.56 -&gt; 12+ 34.56/60
-
-    lad = floor(latd/100.);
-    lat = latd-lad*100.;
-    lod = floor(lond/100.);
-    lon = lond-lod*100.;
-
-    //Changing Longitude and Latitude to Radians
-    m_lat= (lad+lat/60.0) *M_PI/180;
-    m_lon= (lod+lon/60.0) *M_PI/180;
-    m_h  =  h; 
-
-    conv_llh2xyz();
-  }
-
-  void conv_llh2xyz(void){
-    double PS;           //
-    double PSo;          //
-    double PDL;          //
-    double Pt;           //
-    double PN;           //
-    double PW;           // 
-    
-    double PB1, PB2, PB3, PB4, PB5, PB6, PB7, PB8, PB9;
-    double PA, PB, PC, PD, PE, PF, PG, PH, PI;
-    double Pe;           //
-    double Pet;          //
-    double Pnn;          //  
-    double AW,FW,Pmo;
-
-    Pmo = 0.9999;
-
-    /*WGS84 Parameters*/
-    AW   = 6378137.0; //Semimajor Axis
-    FW   = 1.0/298.257222101; //298.257223563 //Geometrical flattening
-    
-    Pe  = (double) sqrt(2.0*FW - pow(FW,2));
-    Pet = (double) sqrt( pow(Pe,2) / (1.0 - pow(Pe,2)) );
-    
-    PA = (double) 1.0 + 3.0/4.0*pow(Pe,2) + 45.0/64.0* pow(Pe,4) + 175.0/256.0*pow(Pe,6) 
-      + 11025.0/16384.0*pow(Pe,8) + 43659.0/65536.0*pow(Pe,10) + 693693.0/1048576.0*pow(Pe,12)
-      + 19324305.0/29360128.0*pow(Pe,14) + 4927697775.0/7516192768.0*pow(Pe,16);
-    
-    PB = (double) 3.0/4.0*pow(Pe,2) + 15.0/16.0*pow(Pe,4) + 525.0/512.0*pow(Pe,6) + 2205.0/2048.0*pow(Pe,8)
-      + 72765.0/65536.0*pow(Pe,10) + 297297.0/262144.0*pow(Pe,12) + 135270135.0/117440512.0*pow(Pe,14) 
-      + 547521975.0/469762048.0*pow(Pe,16);
-    
-    PC = (double) 15.0/64.0*pow(Pe,4) + 105.0/256.0*pow(Pe,6) + 2205.0/4096.0*pow(Pe,8) + 10395.0/16384.0*pow(Pe,10)
-      + 1486485.0/2097152.0*pow(Pe,12) + 45090045.0/58720256.0*pow(Pe,14)+ 766530765.0/939524096.0*pow(Pe,16);
-    
-    PD = (double) 35.0/512.0*pow(Pe,6) + 315.0/2048.0*pow(Pe,8) + 31185.0/131072.0*pow(Pe,10)
-      + 165165.0/524288.0*pow(Pe,12) + 45090045.0/117440512.0*pow(Pe,14) + 209053845.0/469762048.0*pow(Pe,16);
-    
-    PE = (double) 315.0/16384.0*pow(Pe,8) + 3465.0/65536.0*pow(Pe,10) + 99099.0/1048576.0*pow(Pe,12) + 
-      4099095.0/29360128.0*pow(Pe,14) + 348423075.0/1879048192.0*pow(Pe,16);
-    
-    PF = (double) 693.0/131072.0*pow(Pe,10) + 9009.0/524288.0*pow(Pe,12) +  4099095.0/117440512.0*pow(Pe,14)
-      + 26801775.0/469762048.0*pow(Pe,16);
-    
-    PG = (double) 3003.0/2097152.0*pow(Pe,12) + 315315.0/58720256.0*pow(Pe,14) + 11486475.0/939524096.0*pow(Pe,16);
-    
-    PH = (double) 45045.0/117440512.0*pow(Pe,14) + 765765.0/469762048.0*pow(Pe,16);
-    
-    PI = (double) 765765.0/7516192768.0*pow(Pe,16);
-    
-    PB1 = (double) AW * (1.0 - pow(Pe,2)) * PA;
-    PB2 = (double) AW * (1.0 - pow(Pe,2)) * PB/-2.0;
-    PB3 = (double) AW * (1.0 - pow(Pe,2)) * PC/4.0;
-    PB4 = (double) AW * (1.0 - pow(Pe,2)) * PD/-6.0;
-    PB5 = (double) AW * (1.0 - pow(Pe,2)) * PE/8.0;
-    PB6 = (double) AW * (1.0 - pow(Pe,2)) * PF/-10.0;
-    PB7 = (double) AW * (1.0 - pow(Pe,2)) * PG/12.0;
-    PB8 = (double) AW * (1.0 - pow(Pe,2)) * PH/-14.0;
-    PB9 = (double) AW * (1.0 - pow(Pe,2)) * PI/16.0;
-    
-    
-    PS = (double) PB1*m_lat + PB2*sin(2.0*m_lat) + PB3*sin(4.0*m_lat) + PB4*sin(6.0*m_lat) 
-      + PB5*sin(8.0*m_lat) + PB6*sin(10.0*m_lat) + PB7*sin(12.0*m_lat) + PB8*sin(14.0*m_lat)
-      + PB9*sin(16.0*m_lat);
-    
-    PSo = (double) PB1*m_PLato + PB2*sin(2.0*m_PLato) + PB3*sin(4.0*m_PLato) + PB4*sin(6.0*m_PLato) 
-      + PB5*sin(8.0*m_PLato) + PB6*sin(10.0*m_PLato) + PB7*sin(12.0*m_PLato) + PB8*sin(14.0*m_PLato)
-      + PB9*sin(16.0*m_PLato);
-    
-    PDL = (double) m_lon - m_PLo;
-    Pt  = (double) tan(m_lat);
-    PW  = (double) sqrt(1.0 - pow(Pe,2)*pow(sin(m_lat),2));
-    PN  = (double) AW / PW;
-    Pnn = (double) sqrt( pow(Pet,2) * pow(cos(m_lat),2));
-    
-    m_x = (double) ( (PS - PSo) + (1.0/2.0)*PN*pow(cos(m_lat),2.0)*Pt*pow(PDL,2.0) 
-		       + (1.0/24.0) * PN * pow(cos(m_lat),4) * Pt * (5.0-pow(Pt,2) + 9.0*pow(Pnn,2) + 4.0*pow(Pnn,4))*pow(PDL,4)
-		       - (1.0/720.0) * PN * pow(cos(m_lat),6) * Pt * 
-		       (-61.0 + 58.0*pow(Pt,2) - pow(Pt,4) - 270.0*pow(Pnn,2) + 330.0*pow(Pt,2)*pow(Pnn,2))*pow(PDL,6)
-		       - (1.0/40320.0) * PN * pow(cos(m_lat),8) * Pt * 
-		       (-1385.0 + 3111*pow(Pt,2) - 543*pow(Pt,4) + pow(Pt,6)) * pow(PDL,8) ) * Pmo ; 
-    
-    m_y = (double) ( PN*cos(m_lat)*PDL - 1.0/6.0* PN * pow(cos(m_lat),3) * (-1 + pow(Pt,2) - pow(Pnn,2))*pow(PDL,3)
-		       -1.0/120.0*PN*pow(cos(m_lat),5) * (-5.0+18.0*pow(Pt,2)-pow(Pt,4)-14.0*pow(Pnn,2)+58.0*pow(Pt,2)*pow(Pnn,2))*pow(PDL,5)
-		       -1.0/5040.0*PN*pow(cos(m_lat),7)* (-61.0+479.0*pow(Pt,2)-179.0*pow(Pt,4)+pow(Pt,6))*pow(PDL,7) ) * Pmo;
-    
-   m_z = m_h;
-  }
- 
-  void conv_xyz2llh(void){}// n/a
-};
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\obj_reproj.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\obj_reproj.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -61,7 +61,7 @@
 #include "structure.h"
 #include "calcoordinates.h"
 #include "axialMove.h"
-#include "geo_pos_conv.hh"
+#include &lt;gnss/geo_pos_conv.hpp&gt;
 #include "CalObjLoc.h"
 #include "autoware_msgs/image_obj_tracked.h"
 #include "autoware_msgs/obj_label.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\range_fusion\range_fusion.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\range_fusion\range_fusion.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -30,7 +30,7 @@
 
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Header.h&gt;
-#include &lt;fusion_func.h&gt;
+#include &lt;fusion/fusion_func.h&gt;
 #include "autoware_msgs/image_obj_ranged.h"
 #include "autoware_msgs/ConfigCarFusion.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_contour_tracker\include\kf_contour_tracker_core.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_contour_tracker\include\kf_contour_tracker_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -33,8 +33,8 @@
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
-#include "RoadNetwork.h"
-#include "SimpleTracker.h"
+#include "op_planner/RoadNetwork.h"
+#include "op_simu/SimpleTracker.h"
 
 #include &lt;autoware_msgs/CloudClusterArray.h&gt;
 #include &lt;autoware_msgs/DetectedObjectArray.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_contour_tracker\src\kf_contour_tracker_core.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_contour_tracker\src\kf_contour_tracker_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -27,7 +27,7 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #include "../include/kf_contour_tracker_core.h"
-#include "op_RosHelpers.h"
+#include "op_ros_helpers/op_RosHelpers.h"
 
 
 namespace ContourTrackerNS
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\mainwindow.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\mainwindow.h" added_lines="1" deleted_lines="1">
				<diff>@@ -2,7 +2,7 @@
 #define MAINWINDOW_H
 
 #include&lt;QMainWindow&gt;
-#include&lt;rosinterface.h&gt;
+#include&lt;rosinterface/rosinterface.h&gt;
 #include&lt;sensor_msgs/LaserScan.h&gt;
 #include&lt;sensor_msgs/PointCloud2.h&gt;
 #include&lt;visualization_msgs/MarkerArray.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\gnss\include\gnss\geo_pos_conv.hh" new_path="ros\src\computing\perception\localization\lib\gnss\include\gnss\geo_pos_conv.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\gnss\src\geo_pos_conv.cpp" new_path="ros\src\computing\perception\localization\lib\gnss\src\geo_pos_conv.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -28,7 +28,7 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include &lt;geo_pos_conv.hh&gt;
+#include &lt;gnss/geo_pos_conv.hpp&gt;
 
 double geo_pos_conv::x() const
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\NormalDistributionsTransform.h" new_path="ros\src\computing\perception\localization\lib\ndt_cpu\include\ndt_cpu\NormalDistributionsTransform.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\Octree.h" new_path="ros\src\computing\perception\localization\lib\ndt_cpu\include\ndt_cpu\Octree.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\Registration.h" new_path="ros\src\computing\perception\localization\lib\ndt_cpu\include\ndt_cpu\Registration.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\SymmetricEigenSolver.h" new_path="ros\src\computing\perception\localization\lib\ndt_cpu\include\ndt_cpu\SymmetricEigenSolver.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\VoxelGrid.h" new_path="ros\src\computing\perception\localization\lib\ndt_cpu\include\ndt_cpu\VoxelGrid.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\include\fast_pcl\ndt_cpu\debug.h" new_path="ros\src\computing\perception\localization\lib\ndt_cpu\include\ndt_cpu\debug.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\NormalDistributionsTransform.cpp" new_path="ros\src\computing\perception\localization\lib\ndt_cpu\src\NormalDistributionsTransform.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
-#include "fast_pcl/ndt_cpu/NormalDistributionsTransform.h"
-#include "fast_pcl/ndt_cpu/debug.h"
+#include "ndt_cpu/NormalDistributionsTransform.h"
+#include "ndt_cpu/debug.h"
 #include &lt;cmath&gt;
 #include &lt;iostream&gt;
 #include &lt;pcl/common/transforms.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\Octree.cpp" new_path="ros\src\computing\perception\localization\lib\ndt_cpu\src\Octree.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
-#include "fast_pcl/ndt_cpu/Octree.h"
-#include "fast_pcl/ndt_cpu/debug.h"
+#include "ndt_cpu/Octree.h"
+#include "ndt_cpu/debug.h"
 #include &lt;math.h&gt;
 #include &lt;limits&gt;
 #include &lt;inttypes.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\Registration.cpp" new_path="ros\src\computing\perception\localization\lib\ndt_cpu\src\Registration.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
-#include "fast_pcl/ndt_cpu/Registration.h"
-#include "fast_pcl/ndt_cpu/debug.h"
+#include "ndt_cpu/Registration.h"
+#include "ndt_cpu/debug.h"
 #include &lt;iostream&gt;
 
 namespace cpu {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_cpu\src\VoxelGrid.cpp" new_path="ros\src\computing\perception\localization\lib\ndt_cpu\src\VoxelGrid.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -1,5 +1,5 @@
-#include "fast_pcl/ndt_cpu/VoxelGrid.h"
-#include "fast_pcl/ndt_cpu/debug.h"
+#include "ndt_cpu/VoxelGrid.h"
+#include "ndt_cpu/debug.h"
 #include &lt;math.h&gt;
 #include &lt;limits&gt;
 #include &lt;inttypes.h&gt;
@@ -10,7 +10,7 @@
 #include &lt;stdio.h&gt;
 #include &lt;sys/time.h&gt;
 
-#include "fast_pcl/ndt_cpu/SymmetricEigenSolver.h"
+#include "ndt_cpu/SymmetricEigenSolver.h"
 
 namespace cpu {
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\Matrix.h" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\include\ndt_gpu\Matrix.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\MatrixDevice.h" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\include\ndt_gpu\MatrixDevice.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\MatrixHost.h" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\include\ndt_gpu\MatrixHost.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\NormalDistributionsTransform.h" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\include\ndt_gpu\NormalDistributionsTransform.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\Registration.h" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\include\ndt_gpu\Registration.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\SymmetricEigenSolver.h" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\include\ndt_gpu\SymmetricEigenSolver.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\VoxelGrid.h" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\include\ndt_gpu\VoxelGrid.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\common.h" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\include\ndt_gpu\common.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\debug.h" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\include\ndt_gpu\debug.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\MatrixDevice.cu" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\src\MatrixDevice.cu" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
-#include "fast_pcl/ndt_gpu/MatrixDevice.h"
-#include "fast_pcl/ndt_gpu/debug.h"
+#include "ndt_gpu/MatrixDevice.h"
+#include "ndt_gpu/debug.h"
 
 namespace gpu {
 MatrixDevice::MatrixDevice(int rows, int cols) {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\MatrixHost.cu" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\src\MatrixHost.cu" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
-#include "fast_pcl/ndt_gpu/MatrixHost.h"
-#include "fast_pcl/ndt_gpu/debug.h"
+#include "ndt_gpu/MatrixHost.h"
+#include "ndt_gpu/debug.h"
 #include &lt;iostream&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\src\NormalDistributionsTransform.cu" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
-#include "fast_pcl/ndt_gpu/NormalDistributionsTransform.h"
-#include "fast_pcl/ndt_gpu/debug.h"
+#include "ndt_gpu/NormalDistributionsTransform.h"
+#include "ndt_gpu/debug.h"
 #include &lt;cmath&gt;
 #include &lt;iostream&gt;
 #include &lt;pcl/common/transforms.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\Registration.cu" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\src\Registration.cu" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
-#include "fast_pcl/ndt_gpu/Registration.h"
-#include "fast_pcl/ndt_gpu/debug.h"
+#include "ndt_gpu/Registration.h"
+#include "ndt_gpu/debug.h"
 #include &lt;iostream&gt;
 
 namespace gpu {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\SymmetricEigenSolver.cu" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\src\SymmetricEigenSolver.cu" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
-#include "fast_pcl/ndt_gpu/SymmetricEigenSolver.h"
-#include "fast_pcl/ndt_gpu/debug.h"
+#include "ndt_gpu/SymmetricEigenSolver.h"
+#include "ndt_gpu/debug.h"
 
 namespace gpu {
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\VoxelGrid.cu" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\src\VoxelGrid.cu" added_lines="4" deleted_lines="4">
				<diff>@@ -1,6 +1,6 @@
-#include "fast_pcl/ndt_gpu/VoxelGrid.h"
-#include "fast_pcl/ndt_gpu/debug.h"
-#include "fast_pcl/ndt_gpu/common.h"
+#include "ndt_gpu/VoxelGrid.h"
+#include "ndt_gpu/debug.h"
+#include "ndt_gpu/common.h"
 #include &lt;math.h&gt;
 #include &lt;limits&gt;
 #include &lt;thrust/device_ptr.h&gt;
@@ -16,7 +16,7 @@
 #include &lt;stdio.h&gt;
 #include &lt;sys/time.h&gt;
 
-#include "fast_pcl/ndt_gpu/SymmetricEigenSolver.h"
+#include "ndt_gpu/SymmetricEigenSolver.h"
 
 namespace gpu {
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\pcl_omp\registration\include\pcl_omp\registration\impl\ndt.hpp" new_path="ros\src\computing\perception\localization\lib\pcl_omp_registration\include\pcl_omp_registration\impl\ndt.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\pcl_omp\registration\include\pcl_omp\registration\impl\registration.hpp" new_path="ros\src\computing\perception\localization\lib\pcl_omp_registration\include\pcl_omp_registration\impl\registration.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\pcl_omp\registration\include\pcl_omp\registration\ndt.h" new_path="ros\src\computing\perception\localization\lib\pcl_omp_registration\include\pcl_omp_registration\ndt.h" added_lines="2" deleted_lines="2">
				<diff>@@ -42,7 +42,7 @@
 #define PCL_OMP_REGISTRATION_NDT_H_
 
 //#include &lt;pcl/registration/registration.h&gt;
-#include "pcl_omp/registration/registration.h"
+#include "pcl_omp_registration/registration.h"
 //#include &lt;pcl/filters/voxel_grid_covariance.h&gt;
 #include &lt;pcl/filters/voxel_grid_covariance.h&gt;
 
@@ -467,6 +467,6 @@ namespace pcl_omp
 }
 
 //#include &lt;pcl/registration/impl/ndt.hpp&gt;
-#include "pcl_omp/registration/impl/ndt.hpp"
+#include "pcl_omp_registration/impl/ndt.hpp"
 
 #endif // PCL_OMP_REGISTRATION_NDT_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\pcl_omp\registration\include\pcl_omp\registration\registration.h" new_path="ros\src\computing\perception\localization\lib\pcl_omp_registration\include\pcl_omp_registration\registration.h" added_lines="1" deleted_lines="1">
				<diff>@@ -605,6 +605,6 @@ namespace pcl_omp
    };
 }
 
-#include "pcl_omp/registration/impl/registration.hpp"
+#include "pcl_omp_registration/impl/registration.hpp"
 
 #endif  //#ifndef PCL_OMP_REGISTRATION_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\pcl_omp\registration\src\ndt.cpp" new_path="ros\src\computing\perception\localization\lib\pcl_omp_registration\src\ndt.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -43,8 +43,8 @@
 
 //#include &lt;pcl/registration/ndt.h&gt;
 //#include &lt;pcl/registration/impl/ndt.hpp&gt;
-#include "pcl_omp/registration/ndt.h"
-#include "pcl_omp/registration/impl/ndt.hpp"
+#include "pcl_omp_registration/ndt.h"
+#include "pcl_omp_registration/impl/ndt.hpp"
 
 template class PCL_EXPORTS pcl_omp::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt;;
 template class PCL_EXPORTS pcl_omp::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt;;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\fix2tfpose\fix2tfpose.cpp" new_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\fix2tfpose\fix2tfpose.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -37,8 +37,7 @@
 #include &lt;tf/transform_broadcaster.h&gt;
 
 #include &lt;iostream&gt;
-
-#include "geo_pos_conv.hh"
+#include &lt;gnss/geo_pos_conv.hpp&gt;
 
 static ros::Publisher pose_publisher;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_core.h" new_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_core.h" added_lines="1" deleted_lines="1">
				<diff>@@ -41,7 +41,7 @@
 #include &lt;nmea_msgs/Sentence.h&gt;
 #include &lt;tf/transform_broadcaster.h&gt;
 
-#include "geo_pos_conv.hh"
+#include &lt;gnss/geo_pos_conv.hpp&gt;
 
 namespace gnss_localizer
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -58,13 +58,13 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#include &lt;fast_pcl/ndt_cpu/NormalDistributionsTransform.h&gt;
+#include &lt;ndt_cpu/NormalDistributionsTransform.h&gt;
 #include &lt;pcl/registration/ndt.h&gt;
 #ifdef CUDA_FOUND
-#include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
+#include &lt;ndt_gpu/NormalDistributionsTransform.h&gt;
 #endif
 #ifdef USE_PCL_OPENMP
-#include &lt;pcl_omp/registration/ndt.h&gt;
+#include &lt;pcl_omp_registration/ndt.h&gt;
 #endif
 
 #include &lt;autoware_msgs/ConfigNdtMapping.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -65,13 +65,13 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#include &lt;fast_pcl/ndt_cpu/NormalDistributionsTransform.h&gt;
+#include &lt;ndt_cpu/NormalDistributionsTransform.h&gt;
 #include &lt;pcl/registration/ndt.h&gt;
 #ifdef CUDA_FOUND
-#include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
+#include &lt;ndt_gpu/NormalDistributionsTransform.h&gt;
 #endif
 #ifdef USE_PCL_OPENMP
-#include &lt;pcl_omp/registration/ndt.h&gt;
+#include &lt;pcl_omp_registration/ndt.h&gt;
 #endif
 
 #include &lt;pcl_ros/point_cloud.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\BehaviorStateMachine.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\BehaviorStateMachine.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\LocalPlannerH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\LocalPlannerH.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\MappingHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\MappingHelpers.h" added_lines="2" deleted_lines="2">
				<diff>@@ -10,8 +10,8 @@
 
 #include &lt;math.h&gt;
 #include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "DataRW.h"
+#include "op_utility/UtilityH.h"
+#include "op_utility/DataRW.h"
 #include "tinyxml.h"
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\MatrixOperations.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\MatrixOperations.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\PlannerCommonDef.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlannerCommonDef.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\PlannerH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlannerH.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\PlanningHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\PlanningHelpers.h" added_lines="2" deleted_lines="2">
				<diff>@@ -10,8 +10,8 @@
 
 #include &lt;math.h&gt;
 #include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "DataRW.h"
+#include "op_utility/UtilityH.h"
+#include "op_utility/DataRW.h"
 #include "tinyxml.h"
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\RSPlanner.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\RSPlanner.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\RoadNetwork.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\RoadNetwork.h" added_lines="1" deleted_lines="1">
				<diff>@@ -11,7 +11,7 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 #include &lt;sstream&gt;
-#include "UtilityH.h"
+#include "op_utility/UtilityH.h"
 
 #define OPENPLANNER_ENABLE_LOGS
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\TrajectoryCosts.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\TrajectoryCosts.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\TrajectoryPrediction.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\TrajectoryPrediction.h" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
 #ifndef TRAJECTORYPREDICTION_H_
 #define TRAJECTORYPREDICTION_H_
 
-#include &lt;RoadNetwork.h&gt;
+#include &lt;op_planner/RoadNetwork.h&gt;
 #include "PlannerCommonDef.h"
 #include "PlanningHelpers.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\BehaviorStateMachine.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\BehaviorStateMachine.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -5,8 +5,8 @@
  *      Author: hatem
  */
 
-#include "BehaviorStateMachine.h"
-#include "UtilityH.h"
+#include "op_planner/BehaviorStateMachine.h"
+#include "op_utility/UtilityH.h"
 #include &lt;iostream&gt;
 
 using namespace UtilityHNS;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\LocalPlannerH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\LocalPlannerH.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -5,12 +5,12 @@
  *      Author: hatem
  */
 
-#include "LocalPlannerH.h"
-#include "UtilityH.h"
-#include "PlanningHelpers.h"
-#include "MappingHelpers.h"
-#include "MatrixOperations.h"
-#include "PlannerH.h"
+#include "op_planner/LocalPlannerH.h"
+#include "op_utility/UtilityH.h"
+#include "op_planner/PlanningHelpers.h"
+#include "op_planner/MappingHelpers.h"
+#include "op_planner/MatrixOperations.h"
+#include "op_planner/PlannerH.h"
 
 using namespace UtilityHNS;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -6,9 +6,9 @@
  */
 
 
-#include "MappingHelpers.h"
-#include "MatrixOperations.h"
-#include "PlanningHelpers.h"
+#include "op_planner/MappingHelpers.h"
+#include "op_planner/MatrixOperations.h"
+#include "op_planner/PlanningHelpers.h"
 
 #include "math.h"
 #include &lt;fstream&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MatrixOperations.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MatrixOperations.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -5,7 +5,7 @@
  *      Author: hatem
  */
 
-#include "MatrixOperations.h"
+#include "op_planner/MatrixOperations.h"
 
 namespace PlannerHNS {
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlannerH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlannerH.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -5,9 +5,9 @@
  *      Author: hatem
  */
 
-#include "PlannerH.h"
-#include "PlanningHelpers.h"
-#include "MappingHelpers.h"
+#include "op_planner/PlannerH.h"
+#include "op_planner/PlanningHelpers.h"
+#include "op_planner/MappingHelpers.h"
 #include &lt;iostream&gt;
 
 using namespace std;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -5,8 +5,8 @@
  *      Author: hatem
  */
 
-#include "PlanningHelpers.h"
-#include "MatrixOperations.h"
+#include "op_planner/PlanningHelpers.h"
+#include "op_planner/MatrixOperations.h"
 #include &lt;string&gt;
 //#include "spline.hpp"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\RSPlanner.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\RSPlanner.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -5,7 +5,7 @@
  *      Author: hatem
  */
 
-#include "RSPlanner.h"
+#include "op_planner/RSPlanner.h"
 
 
 using namespace std;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\TrajectoryCosts.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\TrajectoryCosts.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -5,8 +5,8 @@
  *      Author: user
  */
 
-#include "TrajectoryCosts.h"
-#include "MatrixOperations.h"
+#include "op_planner/TrajectoryCosts.h"
+#include "op_planner/MatrixOperations.h"
 
 namespace PlannerHNS
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\TrajectoryPrediction.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\TrajectoryPrediction.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -5,9 +5,9 @@
  *      Author: user
  */
 
-#include "TrajectoryPrediction.h"
-#include "PlannerH.h"
-#include "MappingHelpers.h"
+#include "op_planner/TrajectoryPrediction.h"
+#include "op_planner/PlannerH.h"
+#include "op_planner/MappingHelpers.h"
 
 namespace PlannerHNS
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\PolygonGenerator.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_ros_helpers\PolygonGenerator.h" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
 #ifndef POLYGONGENERATOR_H_
 #define POLYGONGENERATOR_H_
 
-#include "RoadNetwork.h"
+#include "op_planner/RoadNetwork.h"
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_RosHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_ros_helpers\op_RosHelpers.h" added_lines="3" deleted_lines="3">
				<diff>@@ -9,9 +9,9 @@
 #define ROSHELPERS_H_
 
 #include &lt;ros/ros.h&gt;
-#include "RoadNetwork.h"
-#include "PlannerCommonDef.h"
-#include "LocalPlannerH.h"
+#include "op_planner/RoadNetwork.h"
+#include "op_planner/PlannerCommonDef.h"
+#include "op_planner/LocalPlannerH.h"
 
 #include "vector_map_msgs/PointArray.h"
 #include "vector_map_msgs/LaneArray.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\PolygonGenerator.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\PolygonGenerator.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -5,8 +5,8 @@
  *      Author: ai-driver
  */
 
-#include "PolygonGenerator.h"
-#include "PlanningHelpers.h"
+#include "op_ros_helpers/PolygonGenerator.h"
+#include "op_planner/PlanningHelpers.h"
 
 namespace PlannerHNS
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\op_RosHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\op_RosHelpers.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -5,15 +5,15 @@
  *      Author: ai-driver
  */
 
-#include "op_RosHelpers.h"
+#include "op_ros_helpers/op_RosHelpers.h"
 
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;
 #include &lt;fstream&gt;
 #include &lt;math.h&gt;
-#include "PolygonGenerator.h"
-#include "MappingHelpers.h"
-#include "MatrixOperations.h"
+#include "op_ros_helpers/PolygonGenerator.h"
+#include "op_planner/MappingHelpers.h"
+#include "op_planner/MatrixOperations.h"
 
 
 namespace PlannerHNS
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\AlternativeVisualizer.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\AlternativeVisualizer.h" added_lines="1" deleted_lines="1">
				<diff>@@ -9,7 +9,7 @@
 #define AlternativeVisualizer_H_
 #include &lt;iostream&gt;
 #include "DrawObjBase.h"
-#include "RoadNetwork.h"
+#include "op_planner/RoadNetwork.h"
 #include "CarState.h"
 #include "DrawingHelpers.h"
 #include "TrajectoryFollower.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\CarState.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\CarState.h" added_lines="3" deleted_lines="3">
				<diff>@@ -8,9 +8,9 @@
 #ifndef CARSTATE_H_
 #define CARSTATE_H_
 
-#include "BehaviorStateMachine.h"
-#include "PlannerCommonDef.h"
-#include "RoadNetwork.h"
+#include "op_planner/BehaviorStateMachine.h"
+#include "op_planner/PlannerCommonDef.h"
+#include "op_planner/RoadNetwork.h"
 
 namespace SimulationNS
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\DrawObjBase.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\DrawObjBase.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\DrawingHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\DrawingHelpers.h" added_lines="1" deleted_lines="1">
				<diff>@@ -9,7 +9,7 @@
 #define DRAWINGHELPERS_H_
 
 #include "glm.h"
-#include "RoadNetwork.h"
+#include "op_planner/RoadNetwork.h"
 #include "glm.h"
 
 namespace Graphics {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\Graph2dBase.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\Graph2dBase.h" added_lines="1" deleted_lines="1">
				<diff>@@ -9,7 +9,7 @@
 #define GRAPH2DBASE_H_
 
 #include "DrawingHelpers.h"
-#include "RoadNetwork.h"
+#include "op_planner/RoadNetwork.h"
 #include &lt;vector&gt;
 
 namespace Graphics {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\MainWindowWrapper.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\MainWindowWrapper.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\PlannerTestDraw.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\PlannerTestDraw.h" added_lines="2" deleted_lines="2">
				<diff>@@ -9,13 +9,13 @@
 #define PLANNERTESTDRAW_H_
 #include &lt;iostream&gt;
 #include "DrawObjBase.h"
-#include "RoadNetwork.h"
+#include "op_planner/RoadNetwork.h"
 #include "CarState.h"
 #include "DrawingHelpers.h"
 #include "TrajectoryFollower.h"
 #include "SimulatedTrajectoryFollower.h"
 #include "Graph2dBase.h"
-#include "LocalPlannerH.h"
+#include "op_planner/LocalPlannerH.h"
 
 namespace Graphics
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\SimpleTracker.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\SimpleTracker.h" added_lines="3" deleted_lines="3">
				<diff>@@ -8,11 +8,11 @@
 #ifndef SimpleTracker_H_
 #define SimpleTracker_H_
 
-#include "RoadNetwork.h"
-#include "PlanningHelpers.h"
+#include "op_planner/RoadNetwork.h"
+#include "op_planner/PlanningHelpers.h"
 #include "opencv2/video/tracking.hpp"
 #include &lt;vector&gt;
-#include "UtilityH.h"
+#include "op_utility/UtilityH.h"
 #include &lt;math.h&gt;
 #include &lt;iostream&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\SimulatedTrajectoryFollower.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\SimulatedTrajectoryFollower.h" added_lines="3" deleted_lines="3">
				<diff>@@ -7,9 +7,9 @@
 
 #ifndef SimulatedTrajectoryFollower_H_
 #define SimulatedTrajectoryFollower_H_
-#include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "PlannerCommonDef.h"
+#include "op_planner/RoadNetwork.h"
+#include "op_utility/UtilityH.h"
+#include "op_planner/PlannerCommonDef.h"
 
 namespace SimulationNS
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\TrajectoryFollower.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\TrajectoryFollower.h" added_lines="3" deleted_lines="3">
				<diff>@@ -7,9 +7,9 @@
 
 #ifndef TRAJECTORYFOLLOWER_H_
 #define TRAJECTORYFOLLOWER_H_
-#include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "PlannerCommonDef.h"
+#include "op_planner/RoadNetwork.h"
+#include "op_utility/UtilityH.h"
+#include "op_planner/PlannerCommonDef.h"
 
 
 #define MAX_ACCELERATION_2G 5 // meter /sec/sec
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\glm.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\op_simu\glm.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\main.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\main.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -6,9 +6,9 @@
  */
 
 #include &lt;iostream&gt;
-#include "AlternativeVisualizer.h"
-#include "MainWindowWrapper.h"
-#include "PlannerTestDraw.h"
+#include "op_simu/AlternativeVisualizer.h"
+#include "op_simu/MainWindowWrapper.h"
+#include "op_simu/PlannerTestDraw.h"
 
 using namespace  Graphics;
 #define USE_ALT_VISUALIZER 1
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\AlternativeVisualizer.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\AlternativeVisualizer.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -5,14 +5,14 @@
  *      Author: hatem
  */
 
-#include "AlternativeVisualizer.h"
-#include "PlannerH.h"
-#include "PlanningHelpers.h"
-#include "MappingHelpers.h"
+#include "op_simu/AlternativeVisualizer.h"
+#include "op_planner/PlannerH.h"
+#include "op_planner/PlanningHelpers.h"
+#include "op_planner/MappingHelpers.h"
 #include &lt;sstream&gt;
-#include "MatrixOperations.h"
-#include "SimpleTracker.h"
-#include "DataRW.h"
+#include "op_planner/MatrixOperations.h"
+#include "op_simu/SimpleTracker.h"
+#include "op_utility/DataRW.h"
 #include &lt;algorithm&gt;
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\CarState.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\CarState.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -5,13 +5,13 @@
  *      Author: hatem
  */
 
-#include "CarState.h"
-#include "UtilityH.h"
-#include "PlanningHelpers.h"
-#include "MappingHelpers.h"
-#include "MatrixOperations.h"
-#include "PlannerH.h"
-#include "SimulatedTrajectoryFollower.h"
+#include "op_simu/CarState.h"
+#include "op_utility/UtilityH.h"
+#include "op_planner/PlanningHelpers.h"
+#include "op_planner/MappingHelpers.h"
+#include "op_planner/MatrixOperations.h"
+#include "op_planner/PlannerH.h"
+#include "op_simu/SimulatedTrajectoryFollower.h"
 
 
 using namespace PlannerHNS;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\DrawObjBase.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\DrawObjBase.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -5,7 +5,7 @@
  *      Author: hatem
  */
 
-#include "DrawObjBase.h"
+#include "op_simu/DrawObjBase.h"
 
 namespace Graphics {
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\DrawingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\DrawingHelpers.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -5,12 +5,12 @@
  *      Author: hatem
  */
 
-#include "DrawingHelpers.h"
+#include "op_simu/DrawingHelpers.h"
 #include &lt;stdarg.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;cmath&gt;
-#include "UtilityH.h"
-#include "PlanningHelpers.h"
+#include "op_utility/UtilityH.h"
+#include "op_planner/PlanningHelpers.h"
 #include &lt;GL/freeglut.h&gt;
 
 using namespace std;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\Graph2dBase.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\Graph2dBase.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -5,8 +5,8 @@
  *      Author: hatem
  */
 
-#include "Graph2dBase.h"
-#include "UtilityH.h"
+#include "op_simu/Graph2dBase.h"
+#include "op_utility/UtilityH.h"
 
 using namespace PlannerHNS;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\MainWindowWrapper.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\MainWindowWrapper.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -5,16 +5,16 @@
  *      Author: hatem
  */
 
-#include "MainWindowWrapper.h"
-#include "DrawingHelpers.h"
+#include "op_simu/MainWindowWrapper.h"
+#include "op_simu/DrawingHelpers.h"
 #include &lt;iostream&gt;
 #include &lt;cmath&gt;
-#include "UtilityH.h"
+#include "op_utility/UtilityH.h"
 #include "GL/freeglut_ext.h"
 
 using namespace std;
 using namespace UtilityHNS;
-#include "MatrixOperations.h"
+#include "op_planner/MatrixOperations.h"
 
 namespace Graphics {
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\PlannerTestDraw.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\PlannerTestDraw.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -5,15 +5,15 @@
  *      Author: hatem
  */
 
-#include "PlannerTestDraw.h"
-#include "PlannerH.h"
-#include "PlanningHelpers.h"
-#include "MappingHelpers.h"
+#include "op_simu/PlannerTestDraw.h"
+#include "op_planner/PlannerH.h"
+#include "op_planner/PlanningHelpers.h"
+#include "op_planner/MappingHelpers.h"
 #include &lt;sstream&gt;
-#include "MatrixOperations.h"
-#include "SimpleTracker.h"
-#include "DataRW.h"
-#include "PlannerCommonDef.h"
+#include "op_planner/MatrixOperations.h"
+#include "op_simu/SimpleTracker.h"
+#include "op_utility/DataRW.h"
+#include "op_planner/PlannerCommonDef.h"
 //#include &lt;plib/js.h&gt;
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\SimpleTracker.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\SimpleTracker.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -5,9 +5,9 @@
  *      Author: hatem
  */
 
-#include "SimpleTracker.h"
-#include "MatrixOperations.h"
-#include "UtilityH.h"
+#include "op_simu/SimpleTracker.h"
+#include "op_planner/MatrixOperations.h"
+#include "op_utility/UtilityH.h"
 
 #include &lt;iostream&gt;
 #include &lt;vector&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\SimulatedTrajectoryFollower.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\SimulatedTrajectoryFollower.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -5,8 +5,8 @@
  *      Author: hatem
  */
 
-#include "SimulatedTrajectoryFollower.h"
-#include "PlanningHelpers.h"
+#include "op_simu/SimulatedTrajectoryFollower.h"
+#include "op_planner/PlanningHelpers.h"
 #include &lt;cmath&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;iostream&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\TrajectoryFollower.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\TrajectoryFollower.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -5,8 +5,8 @@
  *      Author: hatem
  */
 
-#include "TrajectoryFollower.h"
-#include "PlanningHelpers.h"
+#include "op_simu/TrajectoryFollower.h"
+#include "op_planner/PlanningHelpers.h"
 #include &lt;cmath&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;iostream&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\glm.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\glm.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -17,7 +17,7 @@
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 #include &lt;assert.h&gt;
-#include "glm.h"
+#include "op_simu/glm.h"
 
 namespace Graphics
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\DataRW.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\DataRW.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\UtilityH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\op_utility\UtilityH.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -5,10 +5,10 @@
  *      Author: hatem
  */
 
-#include "DataRW.h"
+#include "op_utility/DataRW.h"
 #include &lt;stdlib.h&gt;
 #include &lt;tinyxml.h&gt;
-#include "UtilityH.h"
+#include "op_utility/UtilityH.h"
 
 using namespace std;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\UtilityH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\UtilityH.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -5,7 +5,7 @@
  *      Author: hatem
  */
 
-#include "UtilityH.h"
+#include "op_utility/UtilityH.h"
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;
 #include &lt;string.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libamathutils\include\amathutils.hpp" new_path="ros\src\computing\planning\decision\libs\amathutils_lib\include\amathutils_lib\amathutils.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libamathutils\src\Amathutils.cpp" new_path="ros\src\computing\planning\decision\libs\amathutils_lib\src\Amathutils.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,4 +1,4 @@
-#include "amathutils.hpp"
+#include "amathutils_lib/amathutils.hpp"
 
 namespace amathutils
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" new_path="ros\src\computing\planning\decision\libs\state_machine_lib\include\state_machine_lib\state.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -4,7 +4,7 @@
 #include &lt;functional&gt;
 #include &lt;iostream&gt;
 #include &lt;memory&gt;
-#include &lt;state_flags.hpp&gt;
+#include &lt;state_machine_lib/state_flags.hpp&gt;
 #include &lt;vector&gt;
 
 namespace state_machine
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_common.hpp" new_path="ros\src\computing\planning\decision\libs\state_machine_lib\include\state_machine_lib\state_common.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\state_machine_lib\include\state_machine_lib\state_context.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" new_path="ros\src\computing\planning\decision\libs\state_machine_lib\include\state_machine_lib\state_drive.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_emg.hpp" new_path="ros\src\computing\planning\decision\libs\state_machine_lib\include\state_machine_lib\state_emg.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" new_path="ros\src\computing\planning\decision\libs\state_machine_lib\include\state_machine_lib\state_flags.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_main.hpp" new_path="ros\src\computing\planning\decision\libs\state_machine_lib\include\state_machine_lib\state_main.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -5,7 +5,7 @@
 #include &lt;memory&gt;
 #include &lt;vector&gt;
 
-#include &lt;state.hpp&gt;
+#include &lt;state_machine_lib/state.hpp&gt;
 
 namespace state_machine
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\state_machine_lib\src\state_context.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -7,10 +7,10 @@
 #include &lt;cassert&gt;
 #include &lt;mutex&gt;
 
-#include &lt;state_context.hpp&gt;
+#include &lt;state_machine_lib/state_context.hpp&gt;
 
-#include &lt;state.hpp&gt;
-#include &lt;state_common.hpp&gt;
+#include &lt;state_machine_lib/state.hpp&gt;
+#include &lt;state_machine_lib/state_common.hpp&gt;
 
 /**
  *
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="3" deleted_lines="3">
				<diff>@@ -31,11 +31,11 @@
 #include &lt;geometry_msgs/Point.h&gt;
 
 // lib
-#include &lt;amathutils.hpp&gt;
+#include &lt;amathutils_lib/amathutils.hpp&gt;
 #include &lt;cross_road_area.hpp&gt;
 #include &lt;decision_maker_param.hpp&gt;
-#include &lt;state.hpp&gt;
-#include &lt;state_context.hpp&gt;
+#include &lt;state_machine_lib/state.hpp&gt;
+#include &lt;state_machine_lib/state_context.hpp&gt;
 
 namespace decision_maker
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\planner_selector.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\planner_selector.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -10,7 +10,7 @@
 #include &lt;thread&gt;
 #include &lt;unordered_map&gt;
 
-#include &lt;amathutils.hpp&gt;
+#include &lt;amathutils_lib/amathutils.hpp&gt;
 
 namespace decision_maker
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,4 +1,4 @@
-#include &lt;amathutils.hpp&gt;
+#include &lt;amathutils_lib/amathutils.hpp&gt;
 #include &lt;cmath&gt;
 #include &lt;cross_road_area.hpp&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -14,8 +14,8 @@
 
 #include &lt;cross_road_area.hpp&gt;
 #include &lt;decision_maker_node.hpp&gt;
-#include &lt;state.hpp&gt;
-#include &lt;state_context.hpp&gt;
+#include &lt;state_machine_lib/state.hpp&gt;
+#include &lt;state_machine_lib/state_context.hpp&gt;
 
 namespace decision_maker
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -6,8 +6,8 @@
 #include &lt;stdio.h&gt;
 
 // lib
-#include &lt;state.hpp&gt;
-#include &lt;state_context.hpp&gt;
+#include &lt;state_machine_lib/state.hpp&gt;
+#include &lt;state_machine_lib/state_context.hpp&gt;
 
 #include &lt;decision_maker_node.hpp&gt;
 //#include &lt;vector_map/vector_map.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -11,8 +11,8 @@
 
 #include &lt;cross_road_area.hpp&gt;
 #include &lt;decision_maker_node.hpp&gt;
-#include &lt;state.hpp&gt;
-#include &lt;state_context.hpp&gt;
+#include &lt;state_machine_lib/state.hpp&gt;
+#include &lt;state_machine_lib/state_context.hpp&gt;
 
 namespace decision_maker
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -9,8 +9,8 @@
 #include &lt;tf/transform_listener.h&gt;
 
 // lib
-#include &lt;state.hpp&gt;
-#include &lt;state_context.hpp&gt;
+#include &lt;state_machine_lib/state.hpp&gt;
+#include &lt;state_machine_lib/state_context.hpp&gt;
 
 #include &lt;decision_maker_node.hpp&gt;
 //#include &lt;vector_map/vector_map.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -7,8 +7,8 @@
 #include &lt;tf/transform_listener.h&gt;
 
 // lib
-#include &lt;state.hpp&gt;
-#include &lt;state_context.hpp&gt;
+#include &lt;state_machine_lib/state.hpp&gt;
+#include &lt;state_machine_lib/state_context.hpp&gt;
 
 #include &lt;decision_maker_node.hpp&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,7 +1,7 @@
 #include &lt;ros/ros.h&gt;
 
-#include &lt;state.hpp&gt;
-#include &lt;state_context.hpp&gt;
+#include &lt;state_machine_lib/state.hpp&gt;
+#include &lt;state_machine_lib/state_context.hpp&gt;
 
 #include &lt;autoware_msgs/lamp_cmd.h&gt;
 #include &lt;decision_maker_node.hpp&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -7,7 +7,7 @@
 #include &lt;thread&gt;
 #include &lt;unordered_map&gt;
 
-#include &lt;amathutils.hpp&gt;
+#include &lt;amathutils_lib/amathutils.hpp&gt;
 #include &lt;planner_selector.hpp&gt;
 
 namespace decision_maker
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\include\lane_planner\vmap.hpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\include\lane_planner\lane_planner_vmap.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\lib\lane_planner\vmap.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\lib\lane_planner\lane_planner_vmap.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -35,8 +35,8 @@
 
 #include &lt;tablet_socket_msgs/Waypoint.h&gt;
 
-#include &lt;geo_pos_conv.hh&gt;
-#include &lt;lane_planner/vmap.hpp&gt;
+#include &lt;gnss/geo_pos_conv.hpp&gt;
+#include &lt;lane_planner/lane_planner_vmap.hpp&gt;
 
 namespace lane_planner {
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_navi\lane_navi.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_navi\lane_navi.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -36,7 +36,7 @@
 #include &lt;vector_map/vector_map.h&gt;
 #include "autoware_msgs/LaneArray.h"
 
-#include "lane_planner/vmap.hpp"
+#include "lane_planner/lane_planner_vmap.hpp"
 
 namespace {
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -40,7 +40,7 @@
 #include "autoware_msgs/ConfigLaneRule.h"
 #include "autoware_msgs/LaneArray.h"
 
-#include &lt;lane_planner/vmap.hpp&gt;
+#include &lt;lane_planner/lane_planner_vmap.hpp&gt;
 
 namespace {
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_stop\lane_stop.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_stop\lane_stop.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -34,7 +34,7 @@
 #include "autoware_msgs/traffic_light.h"
 #include "autoware_msgs/LaneArray.h"
 
-#include &lt;lane_planner/vmap.hpp&gt;
+#include &lt;lane_planner/lane_planner_vmap.hpp&gt;
 
 namespace {
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\RosHelpers.h" new_path="ros\src\computing\planning\mission\packages\way_planner\include\RosHelpers.h" added_lines="1" deleted_lines="1">
				<diff>@@ -35,7 +35,7 @@
 #include &lt;tf/transform_broadcaster.h&gt;
 #include &lt;tf/transform_listener.h&gt;
 #include &lt;tf/tf.h&gt;
-#include "RoadNetwork.h"
+#include "op_planner/RoadNetwork.h"
 
 namespace WayPlannerNS
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\way_planner_core.h" new_path="ros\src\computing\planning\mission\packages\way_planner\include\way_planner_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -63,8 +63,8 @@
 #include "autoware_msgs/CanInfo.h"
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
-#include "MappingHelpers.h"
-#include "PlannerH.h"
+#include "op_planner/MappingHelpers.h"
+#include "op_planner/PlannerH.h"
 #include "RosHelpers.h"
 #include "SocketServer.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\RosHelpers.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\RosHelpers.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -11,7 +11,7 @@
 #include &lt;sstream&gt;
 #include &lt;fstream&gt;
 #include &lt;math.h&gt;
-#include "PlanningHelpers.h"
+#include "op_planner/PlanningHelpers.h"
 
 namespace WayPlannerNS {
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\include\PolygonGenerator.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\PolygonGenerator.h" added_lines="2" deleted_lines="2">
				<diff>@@ -8,8 +8,8 @@
 #ifndef POLYGONGENERATOR_H_
 #define POLYGONGENERATOR_H_
 
-#include "RoadNetwork.h"
-#include "PlanningHelpers.h"
+#include "op_planner/RoadNetwork.h"
+#include "op_planner/PlanningHelpers.h"
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\include\RosHelpers.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\RosHelpers.h" added_lines="3" deleted_lines="3">
				<diff>@@ -9,9 +9,9 @@
 #define ROSHELPERS_H_
 
 #include &lt;ros/ros.h&gt;
-#include "RoadNetwork.h"
-#include "PlannerCommonDef.h"
-#include "LocalPlannerH.h"
+#include "op_planner/RoadNetwork.h"
+#include "op_planner/PlannerCommonDef.h"
+#include "op_planner/LocalPlannerH.h"
 
 #include "vector_map_msgs/PointArray.h"
 #include "vector_map_msgs/LaneArray.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" added_lines="5" deleted_lines="5">
				<diff>@@ -56,13 +56,13 @@
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 
-#include "RoadNetwork.h"
-#include "MappingHelpers.h"
-#include "PlanningHelpers.h"
+#include "op_planner/RoadNetwork.h"
+#include "op_planner/MappingHelpers.h"
+#include "op_planner/PlanningHelpers.h"
 //#include "CarState.h"
-#include "LocalPlannerH.h"
+#include "op_planner/LocalPlannerH.h"
 #include "RosHelpers.h"
-#include "SimpleTracker.h"
+#include "op_simu/SimpleTracker.h"
 
 #include &lt;opencv/cv.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\RosHelpers.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\RosHelpers.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -12,8 +12,8 @@
 #include &lt;fstream&gt;
 #include &lt;math.h&gt;
 #include "PolygonGenerator.h"
-#include "MappingHelpers.h"
-#include "MatrixOperations.h"
+#include "op_planner/MappingHelpers.h"
+#include "op_planner/MatrixOperations.h"
 
 
 namespace PlannerXNS
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -34,8 +34,8 @@
 #include &lt;pcl/io/io.h&gt;
 #include &lt;pcl/io/pcd_io.h&gt;
 #include &lt;pcl/point_types.h&gt;
-#include "UtilityH.h"
-#include "MatrixOperations.h"
+#include "op_utility/UtilityH.h"
+#include "op_planner/MatrixOperations.h"
 
 namespace PlannerXNS
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\ff_waypoint_follower_core.h" new_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\ff_waypoint_follower_core.h" added_lines="4" deleted_lines="4">
				<diff>@@ -46,11 +46,11 @@
 #include &lt;std_msgs/Int8.h&gt;
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "autoware_msgs/LaneArray.h"
-#include "TrajectoryFollower.h"
+#include "op_simu/TrajectoryFollower.h"
 //#include "CarState.h"
-#include "LocalPlannerH.h"
-#include "PlannerH.h"
-#include "MappingHelpers.h"
+#include "op_planner/LocalPlannerH.h"
+#include "op_planner/PlannerH.h"
+#include "op_planner/MappingHelpers.h"
 
 
 #ifdef ENABLE_ZMP_LIBRARY_LINK
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower_core.cpp" new_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -33,7 +33,7 @@
 #include &lt;visualization_msgs/InteractiveMarkerPose.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;std_msgs/Float32.h&gt;
-#include "UtilityH.h"
+#include "op_utility/UtilityH.h"
 #include "math.h"
 
 using namespace std;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_trajectory_generator_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_trajectory_generator_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -33,8 +33,8 @@
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
-#include "PlannerH.h"
-#include "PlannerCommonDef.h"
+#include "op_planner/PlannerH.h"
+#include "op_planner/PlannerCommonDef.h"
 
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -27,7 +27,7 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #include "op_trajectory_generator_core.h"
-#include "op_RosHelpers.h"
+#include "op_ros_helpers/op_RosHelpers.h"
 
 
 namespace TrajectoryGeneratorNS
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\OpenPlannerSimulator_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulator\include\OpenPlannerSimulator_core.h" added_lines="5" deleted_lines="5">
				<diff>@@ -45,10 +45,10 @@
 #include &lt;tf/transform_listener.h&gt;
 #include &lt;tf/tf.h&gt;
 #include &lt;std_msgs/Int8.h&gt;
-#include "TrajectoryFollower.h"
-#include "LocalPlannerH.h"
-#include "PlannerH.h"
-#include "MappingHelpers.h"
+#include "op_simu/TrajectoryFollower.h"
+#include "op_planner/LocalPlannerH.h"
+#include "op_planner/PlannerH.h"
+#include "op_planner/MappingHelpers.h"
 
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;visualization_msgs/InteractiveMarkerPose.h&gt;
@@ -56,7 +56,7 @@
 #include &lt;std_msgs/Float32.h&gt;
 #include "autoware_msgs/CloudCluster.h"
 #include "autoware_msgs/CloudClusterArray.h"
-#include "SimpleTracker.h"
+#include "op_simu/SimpleTracker.h"
 
 namespace OpenPlannerSimulatorNS
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\PolygonGenerator.h" new_path="ros\src\computing\planning\motion\packages\op_simulator\include\PolygonGenerator.h" added_lines="2" deleted_lines="2">
				<diff>@@ -8,8 +8,8 @@
 #ifndef POLYGONGENERATORSIMU_H_
 #define POLYGONGENERATORSIMU_H_
 
-#include "RoadNetwork.h"
-#include "PlanningHelpers.h"
+#include "op_planner/RoadNetwork.h"
+#include "op_planner/PlanningHelpers.h"
 
 
 #include &lt;sensor_msgs/PointCloud2.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\OpenPlannerSimulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\OpenPlannerSimulator_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -30,9 +30,9 @@
 #include "../include/OpenPlannerSimulator_core.h"
 
 
-#include "UtilityH.h"
+#include "op_utility/UtilityH.h"
 #include "math.h"
-#include "MatrixOperations.h"
+#include "op_planner/MatrixOperations.h"
 #include &lt;geometry_msgs/PoseArray.h&gt;
 #include "PolygonGenerator.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\nodes\OpenPlannerSimulatorPerception_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulator_perception\nodes\OpenPlannerSimulatorPerception_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -29,9 +29,9 @@
 */
 #include "../include/OpenPlannerSimulatorPerception_core.h"
 
-#include "UtilityH.h"
+#include "op_utility/UtilityH.h"
 #include "math.h"
-#include "MatrixOperations.h"
+#include "op_planner/MatrixOperations.h"
 
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include &lt;pcl/io/io.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_clicker\waypoint_clicker.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_clicker\waypoint_clicker.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -34,7 +34,7 @@
 
 #include &lt;vector_map/vector_map.h&gt;
 
-#include &lt;lane_planner/vmap.hpp&gt;
+#include &lt;lane_planner/lane_planner_vmap.hpp&gt;
 
 namespace {
 
</diff>
			</file>
			<file old_path="ros\src\data\packages\obj_db\nodes\obj_downloader\obj_downloader.cpp" new_path="ros\src\data\packages\obj_db\nodes\obj_downloader\obj_downloader.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -37,7 +37,7 @@ publish data as ractangular plane
 #include "ros/ros.h"
 #include "std_msgs/String.h"
 #include &lt;visualization_msgs/Marker.h&gt;
-#include &lt;geo_pos_conv.hh&gt;
+#include &lt;gnss/geo_pos_conv.hpp&gt;
 #include &lt;cstdio&gt;
 #include &lt;cstdlib&gt;
 #include &lt;vector&gt;
</diff>
			</file>
			<file old_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" new_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -49,7 +49,7 @@ publish data as ractangular plane
 #endif /* ! CURRENT_CAR_DIRECTLY */
 #include &lt;pthread.h&gt;
 
-#include &lt;geo_pos_conv.hh&gt;
+#include &lt;gnss/geo_pos_conv.hpp&gt;
 #include &lt;pos_db.h&gt;
 
 #include &lt;tf/transform_broadcaster.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\CalibrationToolkit\calibrationtoolkit.h" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\CalibrationToolkit\calibrationtoolkit.h" added_lines="2" deleted_lines="2">
				<diff>@@ -29,8 +29,8 @@
 
 #include&lt;nlopt.hpp&gt;
 
-#include&lt;rosinterface.h&gt;
-#include&lt;glviewer.h&gt;
+#include&lt;rosinterface/rosinterface.h&gt;
+#include&lt;glviewer/glviewer.h&gt;
 
 #include"selectionwidget.h"
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\CalibrationToolkit\selectionwidget.h" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\CalibrationToolkit\selectionwidget.h" added_lines="1" deleted_lines="1">
				<diff>@@ -24,7 +24,7 @@
 #include&lt;sensor_msgs/PointCloud2.h&gt;
 #include&lt;sensor_msgs/LaserScan.h&gt;
 
-#include&lt;glviewer.h&gt;
+#include&lt;glviewer/glviewer.h&gt;
 
 class PlaneExtractor : public GLViewer
 {
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\include\points_image.hpp" new_path="ros\src\sensing\fusion\packages\points2image\include\points_image\points_image.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\lib\points_image\points_image.cpp" new_path="ros\src\sensing\fusion\packages\points2image\lib\points_image\points_image.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -29,7 +29,7 @@
 */
 
 #include &lt;vector&gt;
-#include &lt;points_image.hpp&gt;
+#include &lt;include/points_image/points_image.hpp&gt;
 #include &lt;stdint.h&gt;
 #include &lt;iostream&gt;
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\nodes\points2image\points2image.cpp" new_path="ros\src\sensing\fusion\packages\points2image\nodes\points2image\points2image.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -35,7 +35,7 @@
 #include "autoware_msgs/projection_matrix.h"
 //#include "autoware_msgs/CameraExtrinsic.h"
 
-#include &lt;points_image.hpp&gt;
+#include &lt;include/points_image/points_image.hpp&gt;
 
 #define CAMERAEXTRINSICMAT "CameraExtrinsicMat"
 #define CAMERAMAT "CameraMat"
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\nodes\points2vscan\mainwindow.h" new_path="ros\src\sensing\fusion\packages\points2image\nodes\points2vscan\mainwindow.h" added_lines="9" deleted_lines="8">
				<diff>@@ -1,15 +1,16 @@
 #ifndef MAINWINDOW_H
 #define MAINWINDOW_H
 
+#include &lt;string&gt;
 #include &lt;QMainWindow&gt;
-#include&lt;QPainter&gt;
-#include&lt;QImage&gt;
-#include&lt;QTime&gt;
-
-#include&lt;rosinterface.h&gt;
-#include&lt;fastvirtualscan.h&gt;
-#include&lt;sensor_msgs/LaserScan.h&gt;
-#include&lt;string&gt;
+#include &lt;QPainter&gt;
+#include &lt;QImage&gt;
+#include &lt;QTime&gt;
+
+#include &lt;rosinterface/rosinterface.h&gt;
+#include &lt;fastvirtualscan/fastvirtualscan.h&gt;
+#include &lt;sensor_msgs/LaserScan.h&gt;
+
 
 //#define DEBUG_GUI
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\nodes\vscan2image\vscan2image.cpp" new_path="ros\src\sensing\fusion\packages\points2image\nodes\vscan2image\vscan2image.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -35,7 +35,7 @@
 #include "autoware_msgs/projection_matrix.h"
 //#include "autoware_msgs/CameraExtrinsic.h"
 
-#include &lt;points_image.hpp&gt;
+#include &lt;include/points_image/points_image.hpp&gt;
 
 #define CAMERAEXTRINSICMAT "CameraExtrinsicMat"
 #define CAMERAMAT "CameraMat"
</diff>
			</file>
			<file old_path="ros\src\socket\packages\tablet_socket\nodes\tablet_receiver\tablet_receiver.cpp" new_path="ros\src\socket\packages\tablet_socket\nodes\tablet_receiver\tablet_receiver.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -45,7 +45,7 @@
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
 
-#include &lt;geo_pos_conv.hh&gt;
+#include &lt;gnss/geo_pos_conv.hpp&gt;
 
 #include "ros/ros.h"
 #include "tablet_socket_msgs/gear_cmd.h"
</diff>
			</file>
			<file old_path="ros\src\util\packages\RobotSDK\fastvirtualscan\FastVirtualScan\fastvirtualscan.cpp" new_path="ros\src\util\packages\RobotSDK\fastvirtualscan\FastVirtualScan\fastvirtualscan.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,4 +1,4 @@
-#include "fastvirtualscan.h"
+#include "fastvirtualscan/fastvirtualscan.h"
 
 #define MAXVIRTUALSCAN 1e6
 
</diff>
			</file>
			<file old_path="ros\src\util\packages\RobotSDK\glviewer\GLViewer\glviewer.cpp" new_path="ros\src\util\packages\RobotSDK\glviewer\GLViewer\glviewer.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -28,7 +28,7 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include "glviewer.h"
+#include "glviewer/glviewer.h"
 
 #define GL_PI 3.1415926535897932384626433832795
 
</diff>
			</file>
			<file old_path="ros\src\util\packages\RobotSDK\rosinterface\ROSInterface\rosinterface.cpp" new_path="ros\src\util\packages\RobotSDK\rosinterface\ROSInterface\rosinterface.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -28,7 +28,7 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include "rosinterface.h"
+#include "rosinterface/rosinterface.h"
 
 //using namespace RobotSDK;
 
</diff>
			</file>
			<file old_path="ros\src\util\packages\sample_data\nodes\sample_mobility\sample_mobility.cpp" new_path="ros\src\util\packages\sample_data\nodes\sample_mobility\sample_mobility.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -36,7 +36,7 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;std_msgs/String.h&gt;
-#include &lt;geo_pos_conv.hh&gt;
+#include &lt;gnss/geo_pos_conv.hpp&gt;
 
 static ros::Publisher pub;
 
</diff>
			</file>
			<file old_path="ros\src\util\packages\sample_data\nodes\sample_trajectory\sample_trajectory.cpp" new_path="ros\src\util\packages\sample_data\nodes\sample_trajectory\sample_trajectory.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -31,7 +31,7 @@
 #include &lt;fstream&gt;
 #include "ros/ros.h"
 #include &lt;visualization_msgs/Marker.h&gt;
-#include &lt;geo_pos_conv.hh&gt;
+#include &lt;gnss/geo_pos_conv.hpp&gt;
 
 #define SELF_TRANS	0
 int swap_x_y = 0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="858c1f3405fba15ee6e5c7ce6569bbeb96082e30" author="Yuma">
		<msg>Added parentheses and fixed the layout</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" added_lines="6" deleted_lines="3">
				<diff>@@ -242,15 +242,18 @@ bool PurePursuit::canGetCurvature(double *output_kappa)
   }
   // check whether curvature is valid or not
   bool is_valid_curve = false;
-  for(const auto&amp; el : current_waypoints_)
+  for (const auto&amp; el : current_waypoints_)
   {
-    if(getPlaneDistance(el.pose.pose.position, current_pose_.position) &gt; minimum_lookahead_distance_)
+    if (getPlaneDistance(el.pose.pose.position, current_pose_.position) &gt; minimum_lookahead_distance_)
     {
       is_valid_curve = true;
       break;
     }
   }
-  if(!is_valid_curve)return false;
+  if (!is_valid_curve)
+  {
+    return false;
+  }
   // if is_linear_interpolation_ is false or next waypoint is first or last
   if (!is_linear_interpolation_ || next_waypoint_number_ == 0 ||
       next_waypoint_number_ == (static_cast&lt;int&gt;(current_waypoints_.size() - 1)))
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5764915bf2c6ce8e243712ee6cb85c8085395722" author="anhnv3991">
		<msg>Fix the bug ndt_mapping/matching use GPU resources even when selecting pcl_generic.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\ndt_gpu\include\ndt_gpu\MatrixDevice.h" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\include\ndt_gpu\MatrixDevice.h" added_lines="3" deleted_lines="1">
				<diff>@@ -20,6 +20,8 @@ public:
 
 	CUDAH void setBuffer(double *buffer);
 
+	void memAlloc();
+
 	void memFree();
 
 private:
@@ -44,7 +46,7 @@ CUDAH MatrixDevice::MatrixDevice(int rows, int cols, int offset, double *buffer)
 
 CUDAH bool MatrixDevice::isEmpty()
 {
-	return (rows_ == 0 &amp;&amp; cols_ == 0);
+	return (rows_ == 0 || cols_ == 0 || buffer_ == NULL);
 }
 
 CUDAH MatrixDevice MatrixDevice::col(int index)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\ndt_gpu\src\MatrixDevice.cu" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\src\MatrixDevice.cu" added_lines="13" deleted_lines="2">
				<diff>@@ -7,18 +7,29 @@ MatrixDevice::MatrixDevice(int rows, int cols) {
 	cols_ = cols;
 	offset_ = 1;
 	fr_ = true;
+	buffer_ = NULL;
+}
+
+void MatrixDevice::memAlloc()
+{
+	if (buffer_ != NULL &amp;&amp; fr_) {
+		checkCudaErrors(cudaFree(buffer_));
+		buffer_ = NULL;
+	}
 
 	checkCudaErrors(cudaMalloc(&amp;buffer_, sizeof(double) * rows_ * cols_ * offset_));
 	checkCudaErrors(cudaMemset(buffer_, 0, sizeof(double) * rows_ * cols_ * offset_));
 	checkCudaErrors(cudaDeviceSynchronize());
+	fr_ = true;
 }
 
-
 void MatrixDevice::memFree()
 {
 	if (fr_) {
-		if (buffer_ != NULL)
+		if (buffer_ != NULL) {
 			checkCudaErrors(cudaFree(buffer_));
+			buffer_ = NULL;
+		}
 	}
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\ndt_gpu\src\NormalDistributionsTransform.cu" new_path="ros\src\computing\perception\localization\lib\ndt_gpu\src\NormalDistributionsTransform.cu" added_lines="10" deleted_lines="1">
				<diff>@@ -143,6 +143,14 @@ void GNormalDistributionsTransform::setInputTarget(pcl::PointCloud&lt;pcl::PointXYZ
 void GNormalDistributionsTransform::computeTransformation(const Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess)
 {
 
+	if (dj_ang_.isEmpty()) {
+		dj_ang_.memAlloc();
+	}
+
+	if (dh_ang_.isEmpty()) {
+		dh_ang_.memAlloc();
+	}
+
 	nr_iterations_ = 0;
 	converged_ = false;
 
@@ -1129,7 +1137,6 @@ void GNormalDistributionsTransform::computeAngleDerivatives(MatrixHost pose, boo
 		h_ang_(43) = -cx * sy * sz - sx * cz;
 		h_ang_(44) = 0;
 
-
 		h_ang_.moveToGpu(dh_ang_);
 	}
 
@@ -1165,6 +1172,8 @@ void GNormalDistributionsTransform::transformPointCloud(float *in_x, float *in_y
 	MatrixHost htrans(3, 4);
 	MatrixDevice dtrans(3, 4);
 
+	dtrans.memAlloc();
+
 	for (int i = 0; i &lt; 3; i++) {
 		for (int j = 0; j &lt; 4; j++) {
 			htrans(i, j) = t(i, j);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="30d580d37c1a17af3adde518d6e340c839c08de4" author="Abraham Monrroy">
		<msg>[feature] ndt matching safe monitor (#1181)

* Initial release of ndt_matching_monitor safety node

* Added extra instruction

* * Removed Rviz warnings
* Added GNSS orientation if available

* Added extra documentation

* * Changed param name
* Corrected README subtitle

* * Added Topic for ndt status

* Added published topic to readme

* Integrated matching monitor into ndt_localizer</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\default.rviz" new_path="ros\src\.config\rviz\default.rviz" added_lines="50" deleted_lines="22">
				<diff>@@ -13,7 +13,7 @@ Panels:
         - /Local Rollouts1/Namespaces1
         - /GlobalPathAnimation1/Status1
       Splitter Ratio: 0.695804
-    Tree Height: 640
+    Tree Height: 667
   - Class: rviz/Selection
     Name: Selection
   - Class: rviz/Tool Properties
@@ -61,8 +61,12 @@ Visualization Manager:
         All Enabled: true
         base_link:
           Value: true
+        gps:
+          Value: true
         map:
           Value: true
+        mobility:
+          Value: true
         velodyne:
           Value: true
         world:
@@ -78,6 +82,10 @@ Visualization Manager:
             base_link:
               velodyne:
                 {}
+            gps:
+              {}
+            mobility:
+              {}
       Update Interval: 0
       Value: true
     - Alpha: 0.05
@@ -115,7 +123,19 @@ Visualization Manager:
       Marker Topic: /vector_map
       Name: Vector Map
       Namespaces:
-        {}
+        cross_walk: true
+        curb: true
+        gutter: true
+        road_edge: true
+        road_mark: true
+        road_pole: true
+        road_sign: true
+        signal: true
+        stop_line: true
+        street_light: true
+        utility_pole: true
+        white_line: true
+        zebra_zone: true
       Queue Size: 100
       Value: true
     - Class: rviz/Camera
@@ -139,11 +159,10 @@ Visualization Manager:
         Global Waypoints: true
         GlobalPathAnimation: true
         Grid: true
-        Laserscan Costmap: true
         Local Rollouts: true
         Local Waypoints: true
         Next Waypoint Mark: true
-        Object Pose: true
+        Occupancy Grid Map: true
         PP Trajectory Mark: true
         Points Cluster: true
         Points Map: true
@@ -157,6 +176,7 @@ Visualization Manager:
         Vector Map: true
         Vector Map CenterLines: true
         Vehicle Model: true
+        Velocity (km/h): true
         Vscan Points: true
         Waypoint Guide: true
       Zoom Factor: 1
@@ -255,10 +275,7 @@ Visualization Manager:
       Marker Topic: /detection_range
       Name: Detection Range
       Namespaces:
-        Crosswalk Detection: true
-        Decelerate Detection: true
-        Stop Detection: true
-        Stop Line: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -295,11 +312,6 @@ Visualization Manager:
         Expand Link Details: false
         Expand Tree: false
         Link Tree Style: Links in Alphabetic Order
-        base_link:
-          Alpha: 1
-          Show Axes: false
-          Show Trail: false
-          Value: true
       Name: Vehicle Model
       Robot Description: robot_description
       TF Prefix: ""
@@ -341,9 +353,7 @@ Visualization Manager:
       Marker Topic: /local_waypoints_mark
       Name: Local Waypoints
       Namespaces:
-        local_path_marker: true
-        local_point_marker: true
-        local_waypoint_velocity: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -472,6 +482,24 @@ Visualization Manager:
       top: 30
       update interval: 0.04
       width: 80
+    - Background Alpha: 0.8
+      Background Color: 0; 0; 0
+      Class: jsk_rviz_plugin/OverlayText
+      Enabled: true
+      Foreground Alpha: 0.8
+      Foreground Color: 25; 255; 240
+      Name: OverlayText
+      Overtake Color Properties: false
+      Overtake Position Properties: false
+      Topic: /ndt_monitor/ndt_info_text
+      Value: true
+      font: DejaVu Sans Mono
+      height: 128
+      left: 0
+      line width: 2
+      text size: 12
+      top: 0
+      width: 128
   Enabled: true
   Global Options:
     Background Color: 48; 48; 48
@@ -504,11 +532,11 @@ Visualization Manager:
         Value: false
       Name: Current View
       Near Clip Distance: 0.01
-      Scale: 10
+      Scale: 3.97317
       Target Frame: &lt;Fixed Frame&gt;
       Value: TopDownOrtho (rviz)
-      X: 0
-      Y: 0
+      X: -27.0383
+      Y: 47.1504
     Saved: ~
 Window Geometry:
   Camera:
@@ -518,7 +546,7 @@ Window Geometry:
   Height: 900
   Hide Left Dock: false
   Hide Right Dock: false
-  QMainWindow State: 000000ff00000000fd00000004000000000000016a000002c1fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc00000028000002c1000000dd00fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000c00430061006d0065007200610000000000ffffffff0000006500fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb00000000000000000000000100000163000002c1fc0200000003fb0000000a005600690065007700730100000028000002c1000000b000fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e100000197000000030000066d0000005cfc0100000002fb0000000800540069006d006501000000000000066d000002f600fffffffb0000000800540069006d0065010000000000000450000000000000000000000394000002c100000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  QMainWindow State: 000000ff00000000fd00000004000000000000016a000002dcfc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc00000028000002dc000000dd00fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000c00430061006d0065007200610000000000ffffffff0000006500fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb00000000000000000000000100000163000002dcfc0200000003fb0000000a005600690065007700730100000028000002dc000000b000fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000006400000005cfc0100000002fb0000000800540069006d0065010000000000000640000002f600fffffffb0000000800540069006d0065010000000000000450000000000000000000000367000002dc00000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
@@ -528,5 +556,5 @@ Window Geometry:
   Views:
     collapsed: false
   Width: 1600
-  X: 0
-  Y: 0
+  X: 43
+  Y: 174
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4ab2700f028d14b15e6915e654ebb801ab964bfb" author="Kosuke Murakami">
		<msg>Refactor codes</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" added_lines="66" deleted_lines="68">
				<diff>@@ -25,92 +25,90 @@
 class ImmUkfPda
 {
 private:
-	bool init_;
-	double timestamp_ ;
-	// double ego_velo_;
-	// double egoYaw_;
-	// double egoPreYaw_;
-	// Eigen::VectorXd preMeas_;
-	std::vector&lt;UKF&gt; targets_;
-	// std::vector&lt;int&gt; trackNumVec_;
-
-	// probabilistic data association params
-	double gating_thres_;//9.22; // 99%
-	double gate_probability_;//0.99;
-	// extern double gammaG_ = 5.99; // 99%
-	// extern double pG_ = 0.95;
-	// extern double gammaG_ = 15.22; // 99%
-	double detection_probability_;//0.9;
-
-	//bbox association param
-	double distance_thres_;//0.25;
-	int life_time_thres_;//8;
-	//bbox update params
-	double bb_yaw_change_thres_;//0.2;
-	// double bb_area_change_thres_;//0.5;
-
-	double static_distance_thres_;
-
-	double init_yaw_;
-
-	std::string input_topic_;
-	std::string output_topic_;
-
-	// std::vector&lt;UKF&gt; targets_;
-	// std::vector&lt;int&gt; trackNumVec_;
-
-	tf::TransformListener* tran_;
-
-	ros::NodeHandle node_handle_;
+  bool init_;
+  double timestamp_ ;
+
+  std::vector&lt;UKF&gt; targets_;
+  // std::vector&lt;int&gt; trackNumVec_;
+
+  // probabilistic data association params
+  double gating_thres_;//9.22; // 99%
+  double gate_probability_;//0.99;
+  // extern double gammaG_ = 5.99; // 99%
+  // extern double pG_ = 0.95;
+  // extern double gammaG_ = 15.22; // 99%
+  double detection_probability_;//0.9;
+
+  //bbox association param
+  double distance_thres_;//0.25;
+  int life_time_thres_;//8;
+  //bbox update params
+  double bb_yaw_change_thres_;//0.2;
+  // double bb_area_change_thres_;//0.5;
+
+  double static_distance_thres_;
+
+  double init_yaw_;
+
+  std::string input_topic_;
+  std::string output_topic_;
+
+  std::string pointcloud_frame_;
+  // std::vector&lt;UKF&gt; targets_;
+  // std::vector&lt;int&gt; trackNumVec_;
+
+  tf::TransformListener* tran_;
+
+  ros::NodeHandle node_handle_;
   ros::Subscriber sub_cloud_array_;
   ros::Publisher pub_cloud_array_;
 
   void callBack(autoware_msgs::CloudClusterArray input);
   void transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input);
   void transformPoseToLocal(autoware_msgs::CloudClusterArray&amp; input);
-	void findMaxZandS(const UKF target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s);
-	void measurementValidation(const autoware_msgs::CloudClusterArray input, UKF&amp; target, const bool second_init,
-							   const Eigen::VectorXd max_det_z, const Eigen::MatrixXd max_det_s,
-							   std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
-							   std::vector&lt;int&gt;&amp; matching_vec);
-	void filterPDA(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, std::vector&lt;double&gt;&amp; lambda_vec);
-	void getNearestEuclidCluster(const UKF target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
-							  autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist);
-	void getRightAngleBBox(const std::vector&lt;double&gt; nearest_bbox, std::vector&lt;double&gt;&amp; rightAngle_bbox);
-	void associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
+  void findMaxZandS(const UKF target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s);
+  void measurementValidation(const autoware_msgs::CloudClusterArray input, UKF&amp; target, const bool second_init,
+                 const Eigen::VectorXd max_det_z, const Eigen::MatrixXd max_det_s,
+                 std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
+                 std::vector&lt;int&gt;&amp; matching_vec);
+  void filterPDA(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, std::vector&lt;double&gt;&amp; lambda_vec);
+  void getNearestEuclidCluster(const UKF target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
+                autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist);
+  void getRightAngleBBox(const std::vector&lt;double&gt; nearest_bbox, std::vector&lt;double&gt;&amp; rightAngle_bbox);
+  void associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
                      UKF&amp; target);
-	double getBboxArea(const pcl::PointCloud&lt;pcl::PointXYZ&gt; bbox);
-	double getBBoxYaw(const UKF target);
-	double getJskBBoxArea(const jsk_recognition_msgs::BoundingBox jsk_bb);
-	double getJskBBoxYaw(const jsk_recognition_msgs::BoundingBox jsk_bb);
-	void updateBB(UKF&amp; target);
-	double getIntersectCoef(const double vec1x, const double vec1y, const double vec2x, const double vec2y,
-													const double p_x, const double p_y, const double cp_x, const double cp_y);
-	void mergeOverSegmentation(const std::vector&lt;UKF&gt; targets);
+  double getBboxArea(const pcl::PointCloud&lt;pcl::PointXYZ&gt; bbox);
+  double getBBoxYaw(const UKF target);
+  double getJskBBoxArea(const jsk_recognition_msgs::BoundingBox jsk_bb);
+  double getJskBBoxYaw(const jsk_recognition_msgs::BoundingBox jsk_bb);
+  void updateBB(UKF&amp; target);
+  double getIntersectCoef(const double vec1x, const double vec1y, const double vec2x, const double vec2y,
+                          const double p_x, const double p_y, const double cp_x, const double cp_y);
+  void mergeOverSegmentation(const std::vector&lt;UKF&gt; targets);
 
-	void updateLabel(UKF target, autoware_msgs::CloudCluster&amp; cc);
+  void updateLabel(UKF target, autoware_msgs::CloudCluster&amp; cc);
 
-	void initTracker(autoware_msgs::CloudClusterArray input, double timestamp);
-	void secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; clusterVec, UKF &amp;target);
+  void initTracker(autoware_msgs::CloudClusterArray input, double timestamp);
+  void secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; clusterVec, UKF &amp;target);
 
-	void updateTrackingNum(std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target);
+  void updateTrackingNum(std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target);
 
-	void probabilisticDataAssociation(autoware_msgs::CloudClusterArray input,
-																		double dt, double det_explode_param, std::vector&lt;int&gt;&amp; matching_vec,
-																		std::vector&lt;double&gt;&amp; lambda_vec, UKF&amp; target, bool&amp; is_skip_target);
-	void makeNewTargets(double timestamp, autoware_msgs::CloudClusterArray input, std::vector&lt;int&gt; matching_vec);
+  void probabilisticDataAssociation(autoware_msgs::CloudClusterArray input,
+                                    double dt, double det_explode_param, std::vector&lt;int&gt;&amp; matching_vec,
+                                    std::vector&lt;double&gt;&amp; lambda_vec, UKF&amp; target, bool&amp; is_skip_target);
+  void makeNewTargets(double timestamp, autoware_msgs::CloudClusterArray input, std::vector&lt;int&gt; matching_vec);
 
-	void staticClassification();
+  void staticClassification();
 
-	void makeOutput(autoware_msgs::CloudClusterArray input,
-									autoware_msgs::CloudClusterArray&amp; output);
+  void makeOutput(autoware_msgs::CloudClusterArray input,
+                  autoware_msgs::CloudClusterArray&amp; output);
 
-	void tracker(autoware_msgs::CloudClusterArray input,
+  void tracker(autoware_msgs::CloudClusterArray input,
                  autoware_msgs::CloudClusterArray&amp; output);
 
 
 public:
-	ImmUkfPda();
+  ImmUkfPda();
 };
 
 #endif /* OBJECT_TRACKING_IMM_UKF_JPDAF_H */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="10" deleted_lines="8">
				<diff>@@ -35,9 +35,10 @@ int g_count = 0;
 ImmUkfPda::ImmUkfPda()
 {
   ros::NodeHandle private_nh_("~");
-  private_nh_.param&lt;int&gt;("life_time_thres_", life_time_thres_, 8);
   private_nh_.param&lt;std::string&gt;("input_topic_", input_topic_, "/cloud_clusters");
   private_nh_.param&lt;std::string&gt;("output_topic_", output_topic_, "/tracking_cluster_array");
+  private_nh_.param&lt;std::string&gt;("pointcloud_frame_", pointcloud_frame_, "velodyne");
+  private_nh_.param&lt;int&gt;("life_time_thres_", life_time_thres_, 8);
   private_nh_.param&lt;double&gt;("gating_thres_", gating_thres_, 9.22);
   private_nh_.param&lt;double&gt;("gate_probability_", gate_probability_, 0.99);
   private_nh_.param&lt;double&gt;("detection_probability_", detection_probability_, 0.9);
@@ -59,7 +60,6 @@ ImmUkfPda::ImmUkfPda()
 void ImmUkfPda::callBack(autoware_msgs::CloudClusterArray input)
 {
   autoware_msgs::CloudClusterArray output;
-
   // only transform pose(clusteArray.clusters.bouding_box.pose)
   transformPoseToGlobal(input);
   tracker(input, output);
@@ -68,18 +68,19 @@ void ImmUkfPda::callBack(autoware_msgs::CloudClusterArray input)
   pub_cloud_array_.publish(output);
   g_count ++;
   // std::cout &lt;&lt; "Frame " &lt;&lt;g_count&lt;&lt; "------------------------------------------------"&lt;&lt;std::endl;
-  // std::cout &lt;&lt; "target size "&lt;&lt;targets_.size() &lt;&lt; std::endl;
 }
 
 void ImmUkfPda::transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input)
 {
+  // std::string local_frame = "base_link";
+
   for(size_t i = 0; i &lt; input.clusters.size(); i ++)
   {
     geometry_msgs::PoseStamped pose_in, pose_out;
 
     pose_in.header = input.header;
     pose_in.pose = input.clusters[i].bounding_box.pose;
-    tran_-&gt;waitForTransform("/velodyne", "/world",input.header.stamp, ros::Duration(3.0));
+    tran_-&gt;waitForTransform(pointcloud_frame_, "/world",input.header.stamp, ros::Duration(3.0));
     tran_-&gt;transformPose("world", ros::Time(0), pose_in, input.header.frame_id, pose_out);
     input.clusters[i].bounding_box.pose = pose_out.pose;
   }
@@ -87,6 +88,7 @@ void ImmUkfPda::transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input)
 
 void ImmUkfPda::transformPoseToLocal(autoware_msgs::CloudClusterArray&amp; output)
 {
+  // std::string local_frame = "base_link";
   for(size_t i = 0; i &lt; output.clusters.size(); i ++)
   {
     geometry_msgs::PoseStamped pose_in, pose_out;
@@ -95,9 +97,9 @@ void ImmUkfPda::transformPoseToLocal(autoware_msgs::CloudClusterArray&amp; output)
     pose_in.header.frame_id = "world";
     pose_in.pose = output.clusters[i].bounding_box.pose;
 
-    tran_-&gt;waitForTransform("/world", "/velodyne",ros::Time(0), ros::Duration(3.0));
-    tran_-&gt;transformPose("velodyne", ros::Time(0), pose_in, "world", pose_out);
-    pose_out.header.frame_id = output.header.frame_id = "velodyne";
+    tran_-&gt;waitForTransform("/world", pointcloud_frame_, ros::Time(0), ros::Duration(3.0));
+    tran_-&gt;transformPose(pointcloud_frame_, ros::Time(0), pose_in, "world", pose_out);
+    pose_out.header.frame_id = output.header.frame_id = pointcloud_frame_;
     output.clusters[i].bounding_box.pose = pose_out.pose;
   }
 }
@@ -752,7 +754,7 @@ void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
                            autoware_msgs::CloudClusterArray&amp; output)
 {
   tf::StampedTransform transform;
-  tran_-&gt;lookupTransform("/world", "/velodyne", ros::Time(0), transform);
+  tran_-&gt;lookupTransform("/world", "/base_link", ros::Time(0), transform);
 
   // get yaw angle from "world" to "velodyne" for direction(arrow) visualization
   tf::Matrix3x3 m(transform.getRotation());
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker_main.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker_main.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -9,10 +9,10 @@
 int main(int argc, char **argv)
 {
 
-	// std::cout&lt;&lt; 123&lt;&lt;std::endl;
-	ros::init(argc, argv, "imm_ukf_pda_tracker");
-	ImmUkfPda app;
-	ros::spin();
+  // std::cout&lt;&lt; 123&lt;&lt;std::endl;
+  ros::init(argc, argv, "imm_ukf_pda_tracker");
+  ImmUkfPda app;
+  ros::spin();
 
-	return 0;
+  return 0;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" added_lines="9" deleted_lines="8">
				<diff>@@ -23,21 +23,22 @@
 class VisualizeCloudCluster
 {
 private:
-	std::string input_topic_;
+  std::string input_topic_;
+  std::string pointcloud_frame_;
 
-	ros::NodeHandle node_handle_;
+  ros::NodeHandle node_handle_;
   ros::Subscriber sub_cloud_array_;
   ros::Publisher  pub_jsk_bb_;
   ros::Publisher  pub_arrow_;
-	ros::Publisher  pub_id_;
+  ros::Publisher  pub_id_;
 
-	void getJskBBs(autoware_msgs::CloudClusterArray input,
-				  jsk_recognition_msgs::BoundingBoxArray&amp; jskBBs);
-	void visMarkers(autoware_msgs::CloudClusterArray input);
-	void callBack(autoware_msgs::CloudClusterArray input);
+  void getJskBBs(autoware_msgs::CloudClusterArray input,
+          jsk_recognition_msgs::BoundingBoxArray&amp; jskBBs);
+  void visMarkers(autoware_msgs::CloudClusterArray input);
+  void callBack(autoware_msgs::CloudClusterArray input);
 
 public:
-	VisualizeCloudCluster();
+  VisualizeCloudCluster();
 };
 
 #endif //OBJECT_TRACKING_VisualizeCloudCluster_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" added_lines="124" deleted_lines="123">
				<diff>@@ -6,140 +6,141 @@
 
 VisualizeCloudCluster::VisualizeCloudCluster()
 {
-	ros::NodeHandle private_nh_("~");
-	private_nh_.param&lt;std::string&gt;("input_topic_", input_topic_, "/tracking_cluster_array");
-	// sub_cloud_array_  = node_handle_.subscribe ("/bbox_cluster_array", 1, &amp;VisualizeCloudCluster::callBack, this);
-	sub_cloud_array_  = node_handle_.subscribe (input_topic_, 1, &amp;VisualizeCloudCluster::callBack, this);
-	pub_jsk_bb_       = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt; ("/tracking_cluster_array/jsk_bb", 1);
-	pub_arrow_        = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/tracking_cluster_array/velocity_arrow", 1);
-	pub_id_           = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/tracking_cluster_array/target_id", 1);
+  ros::NodeHandle private_nh_("~");
+  private_nh_.param&lt;std::string&gt;("input_topic_", input_topic_, "/tracking_cluster_array");
+  private_nh_.param&lt;std::string&gt;("pointcloud_frame_", pointcloud_frame_, "velodyne");
+  // sub_cloud_array_  = node_handle_.subscribe ("/bbox_cluster_array", 1, &amp;VisualizeCloudCluster::callBack, this);
+  sub_cloud_array_  = node_handle_.subscribe (input_topic_, 1, &amp;VisualizeCloudCluster::callBack, this);
+  pub_jsk_bb_       = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt; ("/tracking_cluster_array/jsk_bb", 1);
+  pub_arrow_        = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/tracking_cluster_array/velocity_arrow", 1);
+  pub_id_           = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/tracking_cluster_array/target_id", 1);
 }
 
 void VisualizeCloudCluster::callBack(autoware_msgs::CloudClusterArray input)
 {
-	jsk_recognition_msgs::BoundingBoxArray jsk_bbs;
-	visualization_msgs::Marker arrows;
+  jsk_recognition_msgs::BoundingBoxArray jsk_bbs;
+  visualization_msgs::Marker arrows;
 
-	getJskBBs(input, jsk_bbs);
-	pub_jsk_bb_.publish(jsk_bbs);
-	visMarkers(input);
-	// cout &lt;&lt; "receive jsk call back" &lt;&lt; endl;
+  getJskBBs(input, jsk_bbs);
+  pub_jsk_bb_.publish(jsk_bbs);
+  visMarkers(input);
+  // cout &lt;&lt; "receive jsk call back" &lt;&lt; endl;
 }
 
 void VisualizeCloudCluster::getJskBBs(autoware_msgs::CloudClusterArray input,
-							 jsk_recognition_msgs::BoundingBoxArray&amp; jsk_bbs)
+               jsk_recognition_msgs::BoundingBoxArray&amp; jsk_bbs)
 {
-	jsk_bbs.header = input.header;
-
-	for(size_t i = 0; i &lt; input.clusters.size(); i++)
-	{
-		jsk_recognition_msgs::BoundingBox bb;
-		bb = input.clusters[i].bounding_box;
-		bb.header = input.header;
-		std::string label = input.clusters[i].label;
-		// cout &lt;&lt; label &lt;&lt; endl;
-		// bb.label = label;
-		// ? jsk bb, how to find appropriate color
-		if(label == "Stable")
-		{
-			bb.label = 2;
-		}
-		else if(label == "Static")
-		{
-			bb.label = 15;
-		}
-
-		jsk_bbs.boxes.push_back(bb);
-	}
-	// cout &lt;&lt;"cluster size " &lt;&lt; jsk_bbs.boxes.size() &lt;&lt; endl;
+  jsk_bbs.header = input.header;
+
+  for(size_t i = 0; i &lt; input.clusters.size(); i++)
+  {
+    jsk_recognition_msgs::BoundingBox bb;
+    bb = input.clusters[i].bounding_box;
+    bb.header = input.header;
+    std::string label = input.clusters[i].label;
+    // cout &lt;&lt; label &lt;&lt; endl;
+    // bb.label = label;
+    // ? jsk bb, how to find appropriate color
+    if(label == "Stable")
+    {
+      bb.label = 2;
+    }
+    else if(label == "Static")
+    {
+      bb.label = 15;
+    }
+
+    jsk_bbs.boxes.push_back(bb);
+  }
+  // cout &lt;&lt;"cluster size " &lt;&lt; jsk_bbs.boxes.size() &lt;&lt; endl;
 }
 
 void VisualizeCloudCluster::visMarkers(autoware_msgs::CloudClusterArray input)
 {
-	for(size_t i = 0; i &lt; input.clusters.size(); i++)
-	{
-
-		double tv   = input.clusters[i].score;
-		double tyaw = input.clusters[i].estimated_angle;
-		std::string label = input.clusters[i].label;
-
-		visualization_msgs::Marker ids;
-
-		if(label == "None" || label == "Initialized" || label == "Lost")
-		{
-			continue;
-		}
-		ids.lifetime = ros::Duration(0.15);
-		ids.header.frame_id = "/velodyne";
-		ids.header.stamp = input.header.stamp;
-		ids.ns = "ids";
-		ids.action = visualization_msgs::Marker::ADD;
-		ids.type   = visualization_msgs::Marker::TEXT_VIEW_FACING;
-		// green
-		ids.color.g = 1.0f;
-		ids.color.a = 1.0;
-		ids.id = i;
-
-
-		// Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
-		ids.pose.position.x = input.clusters[i].bounding_box.pose.position.x;
-		ids.pose.position.y = input.clusters[i].bounding_box.pose.position.y;
-		ids.pose.position.z = 1.5;
-
-		// convert from RPY to quartenion
-		tf::Matrix3x3 obs_mat;
-		obs_mat.setEulerYPR(tyaw, 0, 0); // yaw, pitch, roll
-		tf::Quaternion q_tf;
-		obs_mat.getRotation(q_tf);
-		ids.pose.orientation.x = q_tf.getX();
-		ids.pose.orientation.y = q_tf.getY();
-		ids.pose.orientation.z = q_tf.getZ();
-		ids.pose.orientation.w = q_tf.getW();
-
-		// Set the scale of the ids -- 1x1x1 here means 1m on a side
-		// ids.scale.x = tv;
-		// ids.scale.y = 0.1;
-		ids.scale.z = 1.0;
-
-		ids.text = std::to_string(input.clusters[i].id);
-
-		pub_id_.publish(ids);
-
-
-		visualization_msgs::Marker arrows;
-		arrows.lifetime = ros::Duration(0.1);
-
-		if(label == "None" || label == "Initialized" || label == "Lost" || label == "Static")
-		{
-			continue;
-		}
-
-		arrows.header.frame_id = "/velodyne";
-		arrows.header.stamp = input.header.stamp;
-		arrows.ns = "arrows";
-		arrows.action = visualization_msgs::Marker::ADD;
-		arrows.type   = visualization_msgs::Marker::ARROW;
-		// green
-		arrows.color.g = 1.0f;
-		arrows.color.a = 1.0;
-		arrows.id = i;
-
-		// Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
-		arrows.pose.position.x = input.clusters[i].bounding_box.pose.position.x;
-		arrows.pose.position.y = input.clusters[i].bounding_box.pose.position.y;
-		arrows.pose.position.z = 0.5;
-
-
-		arrows.pose.orientation.x = q_tf.getX();
-		arrows.pose.orientation.y = q_tf.getY();
-		arrows.pose.orientation.z = q_tf.getZ();
-		arrows.pose.orientation.w = q_tf.getW();
-
-		// Set the scale of the arrows -- 1x1x1 here means 1m on a side
-		arrows.scale.x = tv;
-		arrows.scale.y = 0.1;
-		arrows.scale.z = 0.1;
-
-		pub_arrow_.publish(arrows);
-	}
+  for(size_t i = 0; i &lt; input.clusters.size(); i++)
+  {
+
+    double tv   = input.clusters[i].score;
+    double tyaw = input.clusters[i].estimated_angle;
+    std::string label = input.clusters[i].label;
+
+    visualization_msgs::Marker ids;
+
+    if(label == "None" || label == "Initialized" || label == "Lost")
+    {
+      continue;
+    }
+    ids.lifetime = ros::Duration(0.15);
+    ids.header.frame_id = pointcloud_frame_;
+    ids.header.stamp = input.header.stamp;
+    ids.ns = "ids";
+    ids.action = visualization_msgs::Marker::ADD;
+    ids.type   = visualization_msgs::Marker::TEXT_VIEW_FACING;
+    // green
+    ids.color.g = 1.0f;
+    ids.color.a = 1.0;
+    ids.id = i;
+
+
+    // Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
+    ids.pose.position.x = input.clusters[i].bounding_box.pose.position.x;
+    ids.pose.position.y = input.clusters[i].bounding_box.pose.position.y;
+    ids.pose.position.z = 1.5;
+
+    // convert from RPY to quartenion
+    tf::Matrix3x3 obs_mat;
+    obs_mat.setEulerYPR(tyaw, 0, 0); // yaw, pitch, roll
+    tf::Quaternion q_tf;
+    obs_mat.getRotation(q_tf);
+    ids.pose.orientation.x = q_tf.getX();
+    ids.pose.orientation.y = q_tf.getY();
+    ids.pose.orientation.z = q_tf.getZ();
+    ids.pose.orientation.w = q_tf.getW();
+
+    // Set the scale of the ids -- 1x1x1 here means 1m on a side
+    // ids.scale.x = tv;
+    // ids.scale.y = 0.1;
+    ids.scale.z = 1.0;
+
+    ids.text = std::to_string(input.clusters[i].id);
+
+    pub_id_.publish(ids);
+
+
+    visualization_msgs::Marker arrows;
+    arrows.lifetime = ros::Duration(0.1);
+
+    if(label == "None" || label == "Initialized" || label == "Lost" || label == "Static")
+    {
+      continue;
+    }
+
+    arrows.header.frame_id = pointcloud_frame_;
+    arrows.header.stamp = input.header.stamp;
+    arrows.ns = "arrows";
+    arrows.action = visualization_msgs::Marker::ADD;
+    arrows.type   = visualization_msgs::Marker::ARROW;
+    // green
+    arrows.color.g = 1.0f;
+    arrows.color.a = 1.0;
+    arrows.id = i;
+
+    // Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
+    arrows.pose.position.x = input.clusters[i].bounding_box.pose.position.x;
+    arrows.pose.position.y = input.clusters[i].bounding_box.pose.position.y;
+    arrows.pose.position.z = 0.5;
+
+
+    arrows.pose.orientation.x = q_tf.getX();
+    arrows.pose.orientation.y = q_tf.getY();
+    arrows.pose.orientation.z = q_tf.getZ();
+    arrows.pose.orientation.w = q_tf.getW();
+
+    // Set the scale of the arrows -- 1x1x1 here means 1m on a side
+    arrows.scale.x = tv;
+    arrows.scale.y = 0.1;
+    arrows.scale.z = 0.1;
+
+    pub_arrow_.publish(arrows);
+  }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster_main.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster_main.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -8,10 +8,10 @@
 int main(int argc, char **argv)
 {
 
-	// std::cout&lt;&lt; 122&lt;&lt;std::endl;
-	ros::init(argc, argv, "visualize_cloud_cluster");
-	VisualizeCloudCluster app;
-	ros::spin();
+  // std::cout&lt;&lt; 122&lt;&lt;std::endl;
+  ros::init(argc, argv, "visualize_cloud_cluster");
+  VisualizeCloudCluster app;
+  ros::spin();
 
-	return 0;
-}
\ No newline at end of file
+  return 0;
+}
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="53055b65e8dcce3814f9b4ed1de31a3318eda5a7" author="Akihito Ohsato">
		<msg>Fix bug, increasing path size for each loop</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="2" deleted_lines="1">
				<diff>@@ -70,9 +70,10 @@ void WaypointLoaderNode::initParameter(const autoware_msgs::ConfigWaypointLoader
 
 void WaypointLoaderNode::configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
 {
-  filter_.initParameter(conf);
   initParameter(conf);
+  filter_.initParameter(conf);
 
+  multi_file_path_.clear();
   parseColumns(multi_lane_csv_, &amp;multi_file_path_);
   autoware_msgs::LaneArray lane_array;
   createLaneArray(multi_file_path_, &amp;lane_array);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5e87f3f8b40a16f6aebd16e350677d3aa0c2c669" author="Akihito Ohsato">
		<msg>Fix to deleting marker before re-publishing</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" added_lines="13" deleted_lines="17">
				<diff>@@ -75,26 +75,20 @@ enum class ChangeFlag : int32_t
 
 typedef std::underlying_type&lt;ChangeFlag&gt;::type ChangeFlagInteger;
 
-void publishLocalMarker()
+void publishMarkerArray(const visualization_msgs::MarkerArray&amp; marker_array, const ros::Publisher&amp; publisher, bool delete_markers=false)
 {
-  visualization_msgs::MarkerArray marker_array;
+  visualization_msgs::MarkerArray msg;
 
   // insert local marker
-  marker_array.markers.insert(marker_array.markers.end(), g_local_waypoints_marker_array.markers.begin(),
-                              g_local_waypoints_marker_array.markers.end());
+  msg.markers.insert(msg.markers.end(), marker_array.markers.begin(), marker_array.markers.end());
 
-  g_local_mark_pub.publish(marker_array);
-}
-
-void publishGlobalMarker()
-{
-  visualization_msgs::MarkerArray marker_array;
-
-  // insert global marker
-  marker_array.markers.insert(marker_array.markers.end(), g_global_marker_array.markers.begin(),
-                              g_global_marker_array.markers.end());
+  if (delete_markers)
+  {
+    for (auto&amp; marker : msg.markers)
+      marker.action = visualization_msgs::Marker::DELETE;
+  }
 
-  g_global_mark_pub.publish(marker_array);
+  publisher.publish(msg);
 }
 
 void createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray&amp; lane_waypoints_array)
@@ -391,21 +385,23 @@ void configParameter(const autoware_msgs::ConfigLaneStopConstPtr&amp; msg)
 
 void laneArrayCallback(const autoware_msgs::LaneArrayConstPtr&amp; msg)
 {
+  publishMarkerArray(g_global_marker_array, g_global_mark_pub, true);
   g_global_marker_array.markers.clear();
   createGlobalLaneArrayVelocityMarker(*msg);
   createGlobalLaneArrayOrientationMarker(*msg);
   createGlobalLaneArrayChangeFlagMarker(*msg);
-  publishGlobalMarker();
+  publishMarkerArray(g_global_marker_array, g_global_mark_pub);
 }
 
 void finalCallback(const autoware_msgs::laneConstPtr&amp; msg)
 {
+  publishMarkerArray(g_local_waypoints_marker_array, g_local_mark_pub, true);
   g_local_waypoints_marker_array.markers.clear();
   if (_closest_waypoint != -1)
     createLocalWaypointVelocityMarker(g_local_color, _closest_waypoint, *msg);
   createLocalPathMarker(g_local_color, *msg);
   createLocalPointMarker(*msg);
-  publishLocalMarker();
+  publishMarkerArray(g_local_waypoints_marker_array, g_local_mark_pub);
 }
 
 void closestCallback(const std_msgs::Int32ConstPtr&amp; msg)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d51dd4cde4a4e12f0b8f456c017e0f0a63962cb8" author="Akihito Ohsato">
		<msg>Modify visualized topic, /base_waypoints -&gt; /lane_waypoints_array, mainly for editing waypoints</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" added_lines="18" deleted_lines="14">
				<diff>@@ -66,7 +66,7 @@ private:
   ros::NodeHandle node_handle_;
   ros::NodeHandle private_node_handle_;
 
-  ros::Subscriber base_waypoints_sub_;
+  ros::Subscriber lane_waypoints_array_sub_;
   ros::Subscriber final_waypoints_sub_;
   message_filters::Subscriber&lt;geometry_msgs::PoseStamped&gt;* current_pose_sub_;
   message_filters::Subscriber&lt;geometry_msgs::TwistStamped&gt;* current_twist_sub_;
@@ -76,7 +76,7 @@ private:
   ros::Publisher velocity_marker_pub_;
 
   visualization_msgs::MarkerArray velocity_marker_array_;
-  visualization_msgs::MarkerArray base_waypoints_marker_array_;
+  visualization_msgs::MarkerArray lane_waypoints_array_marker_array_;
   visualization_msgs::MarkerArray final_waypoints_marker_array_;
   visualization_msgs::MarkerArray current_twist_marker_array_;
   visualization_msgs::MarkerArray command_twist_marker_array_;
@@ -88,12 +88,12 @@ private:
   double plot_height_ratio_ = 1.0;
   double plot_height_shift_ = 0.2;
   double plot_metric_interval_ = 1.0;
-  std::vector&lt;double&gt; base_waypoints_rgba_ = { 1.0, 1.0, 1.0, 0.5 };
+  std::vector&lt;double&gt; lane_waypoints_array_rgba_ = { 1.0, 1.0, 1.0, 0.5 };
   std::vector&lt;double&gt; final_waypoints_rgba_ = { 0.0, 1.0, 0.0, 0.5 };
   std::vector&lt;double&gt; current_twist_rgba_ = { 0.0, 0.0, 1.0, 0.5 };
   std::vector&lt;double&gt; command_twist_rgba_ = { 1.0, 0.0, 0.0, 0.5 };
 
-  std_msgs::ColorRGBA base_waypoints_color_;
+  std_msgs::ColorRGBA lane_waypoints_array_color_;
   std_msgs::ColorRGBA final_waypoints_color_;
   std_msgs::ColorRGBA current_twist_color_;
   std_msgs::ColorRGBA command_twist_color_;
@@ -107,7 +107,7 @@ private:
   void deleteMarkers();
   void resetBuffers();
 
-  void baseWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg);
+  void laneWaypointsArrayCallback(const autoware_msgs::LaneArray::ConstPtr&amp; msg);
   void finalWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg);
   void controlCallback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg,
                        const geometry_msgs::TwistStamped::ConstPtr&amp; current_twist_msg,
@@ -142,13 +142,13 @@ WaypointVelocityVisualizer::WaypointVelocityVisualizer() : node_handle_(), priva
   private_node_handle_.param&lt;double&gt;("plot_height_shift", plot_height_shift_, plot_height_shift_);
   private_node_handle_.param&lt;double&gt;("plot_metric_interval", plot_metric_interval_, plot_metric_interval_);
 
-  private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("base_waypoints_rgba", base_waypoints_rgba_, base_waypoints_rgba_);
+  private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("lane_waypoints_array_rgba", lane_waypoints_array_rgba_, lane_waypoints_array_rgba_);
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("final_waypoints_rgba", final_waypoints_rgba_,
                                                    final_waypoints_rgba_);
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("current_twist_rgba", current_twist_rgba_, current_twist_rgba_);
   private_node_handle_.param&lt;std::vector&lt;double&gt; &gt;("command_twist_rgba", command_twist_rgba_, command_twist_rgba_);
 
-  base_waypoints_color_ = vector2color(base_waypoints_rgba_);
+  lane_waypoints_array_color_ = vector2color(lane_waypoints_array_rgba_);
   final_waypoints_color_ = vector2color(final_waypoints_rgba_);
   current_twist_color_ = vector2color(current_twist_rgba_);
   command_twist_color_ = vector2color(command_twist_rgba_);
@@ -159,8 +159,8 @@ WaypointVelocityVisualizer::WaypointVelocityVisualizer() : node_handle_(), priva
   current_twist_buf_.set_capacity(control_buffer_size_);
   command_twist_buf_.set_capacity(control_buffer_size_);
 
-  base_waypoints_sub_ =
-      node_handle_.subscribe("base_waypoints", 1, &amp;WaypointVelocityVisualizer::baseWaypointsCallback, this);
+  lane_waypoints_array_sub_ =
+      node_handle_.subscribe("lane_waypoints_array", 1, &amp;WaypointVelocityVisualizer::laneWaypointsArrayCallback, this);
   final_waypoints_sub_ =
       node_handle_.subscribe("final_waypoints", 1, &amp;WaypointVelocityVisualizer::finalWaypointsCallback, this);
 
@@ -209,10 +209,14 @@ void WaypointVelocityVisualizer::resetBuffers()
   command_twist_buf_.clear();
 }
 
-void WaypointVelocityVisualizer::baseWaypointsCallback(const autoware_msgs::lane::ConstPtr&amp; msg)
+void WaypointVelocityVisualizer::laneWaypointsArrayCallback(const autoware_msgs::LaneArray::ConstPtr&amp; msg)
 {
-  base_waypoints_marker_array_.markers.clear();
-  createVelocityMarker(*msg, "base_waypoints", base_waypoints_color_, base_waypoints_marker_array_);
+  lane_waypoints_array_marker_array_.markers.clear();
+  for (size_t i = 0; i &lt; msg-&gt;lanes.size(); ++i)
+  {
+    std::string ns = "lane_waypoints_" + std::to_string(i);
+    createVelocityMarker(msg-&gt;lanes[i], ns, lane_waypoints_array_color_, lane_waypoints_array_marker_array_);
+  }
   publishVelocityMarker();
 }
 
@@ -262,8 +266,8 @@ void WaypointVelocityVisualizer::publishVelocityMarker()
 {
   velocity_marker_array_.markers.clear();
   velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(),
-                                        base_waypoints_marker_array_.markers.begin(),
-                                        base_waypoints_marker_array_.markers.end());
+                                        lane_waypoints_array_marker_array_.markers.begin(),
+                                        lane_waypoints_array_marker_array_.markers.end());
   velocity_marker_array_.markers.insert(velocity_marker_array_.markers.end(),
                                         final_waypoints_marker_array_.markers.begin(),
                                         final_waypoints_marker_array_.markers.end());
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="306085ee4b7951b5774ffdc0b4de73a4385c9a77" author="Yuma">
		<msg>Fix CalcVelParam func &amp; add comment</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" added_lines="12" deleted_lines="9">
				<diff>@@ -74,11 +74,11 @@ void WaypointFilter::filterLaneWaypoint(autoware_msgs::lane* lane)
     resampleLaneWaypoint(resample_interval_, lane, &amp;curve_radius);
   else
     getCurveAll(*lane, &amp;curve_radius);
-  const std::vector&lt;double&gt; vel_param = calcVelParamFromVmax(velocity_max_);
+  const double vel_param = calcVelParam();
   createCurveList(curve_radius, &amp;curve_list);
-  if (vel_param.size() &lt; 2)
+  if (vel_param == DBL_MAX)
   {
-    ROS_ERROR("velocity parameter is invalid");
+    ROS_ERROR("velocity parameter is invalid: please change Rth or Rmin");
     return;
   }
   // set velocity_max for all_point
@@ -91,7 +91,7 @@ void WaypointFilter::filterLaneWaypoint(autoware_msgs::lane* lane)
     const unsigned long end_idx = (el.second.first &gt; velocity_offset_) ? (el.second.first - velocity_offset_) : 0;
     const double radius = el.second.second;
     const double vmax = velocity_max_;
-    const double vmin = vel_param[0] * radius + vel_param[1];
+    const double vmin = velocity_max_ - vel_param * (r_th_ - radius);
     for (unsigned long idx = start_idx; idx &lt;= end_idx; idx++)
     {
       if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
@@ -226,6 +226,8 @@ void WaypointFilter::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;do
   const unsigned int n = (lookup_crv_width_ - 1) / 2;
   for (unsigned long i = 1; i &lt; lane.waypoints.size() - 1; i++)
   {
+    //Three points used for curve detection (the target point is the center)
+    //[0] = previous point, [1] = target point, [2] = next point
     std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
     curve_point[0] = (i &lt; n) ? lane.waypoints[0].pose.pose.position : lane.waypoints[i - n].pose.pose.position;
     curve_point[1] = lane.waypoints[i].pose.pose.position;
@@ -246,12 +248,13 @@ void WaypointFilter::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;do
   }
 }
 
-const std::vector&lt;double&gt; WaypointFilter::calcVelParamFromVmax(const double vmax) const
+const double WaypointFilter::calcVelParam() const
 {
-  std::vector&lt;double&gt; param(2, 0.0);
-  param[0] = (vmax - velocity_min_) / (r_th_ - r_min_);  // bias
-  param[1] = vmax - param[0] * r_th_;                    // vel_intersept
-  return param;
+  if(fabs(r_th_ - r_min_) &lt; 1e-8)
+  {
+    return DBL_MAX;//error
+  }
+  return (velocity_max_ - velocity_min_) / (r_th_ - r_min_);
 }
 
 void WaypointFilter::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" added_lines="1" deleted_lines="1">
				<diff>@@ -62,7 +62,7 @@ protected:
   void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane,
                             std::vector&lt;double&gt;* curve_radius);
   void getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius);
-  const std::vector&lt;double&gt; calcVelParamFromVmax(const double vmax) const;
+  const double calcVelParam() const;
   void createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
                        std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list);
   void limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx, autoware_msgs::lane* lane);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bc1cdf8c74f26ab1a98731999a2729f7fb25d92f" author="Yuma">
		<msg>Fix claculate radius function</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" added_lines="52" deleted_lines="17">
				<diff>@@ -315,30 +315,65 @@ void WaypointFilter::limitAccelDecel(const double vmax, const double vmin_local,
 const std::vector&lt;double&gt; WaypointFilter::getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point) const
 {
   std::vector&lt;double&gt; curve_param(3, 0.0);
-  tf::Vector3 vec[2];
-  geometry_msgs::Point pt_m[2];
-  double tan_pt_m[2];
-  for (unsigned int i = 0; i &lt; 2; i++)
+  const std::vector&lt;double&gt; dx = {point[0].x - point[1].x, point[1].x - point[2].x, point[2].x - point[0].x};
+  const std::vector&lt;double&gt; dy = {point[0].y - point[1].y, point[1].y - point[2].y, point[2].y - point[0].y};
+  std::vector&lt;double&gt; dist(3);
+  // exclude identical points
+  for (int i = 0; i &lt; 3; i++)
   {
-    const geometry_msgs::Point&amp; p0 = point[i];
-    const geometry_msgs::Point&amp; p1 = point[i + 1];
-    pt_m[i].x = (p0.x + p1.x) / 2.0;
-    pt_m[i].y = (p0.y + p1.y) / 2.0;
-    vec[i] = tf::Vector3(p1.x - p0.x, p1.y - p0.y, 0.0);
-    if (fabs(vec[i].x()) &lt; 1e-8 &amp;&amp; fabs(vec[i].y()) &lt; 1e-8)
+    dist[i] = sqrt(dx[i] * dx[i] + dy[i] * dy[i]);
+    if (dist[i] &lt; 1e-8)
       return std::vector&lt;double&gt;();
-    tan_pt_m[i] = tan(atan2(vec[i].y(), vec[i].x()) + M_PI / 2.0);
   }
-  if (fabs(tan_pt_m[1] - tan_pt_m[0]) &lt; 1e-9)
+
+  // exclude identical x,y
+  int valid_dx_cnt = 0;
+  int valid_dy_cnt = 0;
+  int valid_dx_index, valid_dy_index;
+  for(int i = 0; i &lt; 3; i++)
+  {
+    if(fabs(dx[i]) &gt; 1e-8)
+    {
+      valid_dx_cnt++;
+      valid_dx_index = i;
+    }
+    if(fabs(dy[i]) &gt; 1e-8)
+    {
+      valid_dy_cnt++;
+      valid_dy_index = i;
+    }
+  }
+  if (valid_dx_cnt == 0 || valid_dy_cnt == 0)
     return std::vector&lt;double&gt;();
 
+  // exclude idential line
+  const double cross_prod = dx[0] * dy[1] - dx[1] * dy[0];
+  if (asin(fabs(cross_prod) / (dist[0] * dist[1])) &lt; 1e-8)
+    return std::vector&lt;double&gt;();
+
+  //
+  std::vector&lt;double&gt; sq_diff(3);
+  {
+    std::vector&lt;double&gt; sx = {point[0].x + point[1].x, point[1].x + point[2].x, point[2].x + point[0].x};
+    std::vector&lt;double&gt; sy = {point[0].y + point[1].y, point[1].y + point[2].y, point[2].y + point[0].y};
+    std::transform(sx.begin(), sx.end(), dx.begin(), sx.begin(), std::multiplies&lt;double&gt;());
+    std::transform(sy.begin(), sy.end(), dy.begin(), sy.begin(), std::multiplies&lt;double&gt;());
+    std::transform(sx.begin(), sx.end(), sy.begin(), sq_diff.begin(), std::plus&lt;double&gt;());
+  }
+  if(valid_dx_cnt &lt; valid_dy_cnt)
   {
-    const geometry_msgs::Point&amp; p0 = point[0];
-    curve_param[0] = pt_m[0].y - pt_m[0].x * tan_pt_m[0] - pt_m[1].y + pt_m[1].x * tan_pt_m[1];
-    curve_param[0] /= tan_pt_m[1] - tan_pt_m[0];
-    curve_param[1] = pt_m[0].y - (pt_m[0].x - curve_param[0]) * tan_pt_m[0];
-    curve_param[2] = sqrt(calcSquareSum(p0.x - curve_param[0], p0.y - curve_param[1]));
+    curve_param[0] = - 0.5 / cross_prod * (dy[0] * sq_diff[1] - dy[1] * sq_diff[0]);
+    const int&amp; idx = valid_dy_index;
+    curve_param[1] = 0.5 / dy[idx] * (sq_diff[idx] - 2 * dx[idx] * curve_param[0]);
   }
+  else
+  {
+    curve_param[1] = 0.5 / cross_prod * (dx[0] * sq_diff[1] - dx[1] * sq_diff[0]);
+    const int&amp; idx = valid_dx_index;
+    curve_param[0] = 0.5 / dx[idx] * (sq_diff[idx] - 2 * dy[idx] * curve_param[1]);
+  }
+  curve_param[2] = sqrt(calcSquareSum(point[0].x - curve_param[0], point[0].y - curve_param[1]));
+
   return curve_param;
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" added_lines="1" deleted_lines="0">
				<diff>@@ -36,6 +36,7 @@
 #include &lt;autoware_msgs/ConfigWaypointLoader.h&gt;
 #include &lt;fstream&gt;
 #include &lt;unordered_map&gt;
+#include &lt;algorithm&gt;
 #include "autoware_msgs/lane.h"
 
 namespace waypoint_maker
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0ca17b38eca126f2f0a928e475d4e679767ccaf7" author="Yuma">
		<msg>Rename class and functions filter-&gt;replan</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" added_lines="12" deleted_lines="12">
				<diff>@@ -41,15 +41,15 @@ inline double mps2kmph(double velocity_mps)
   return (velocity_mps * 60 * 60) / 1000;
 }
 
-WaypointFilter::WaypointFilter() : private_nh_("~")
+WaypointReplan::WaypointReplan() : private_nh_("~")
 {
 }
 
-WaypointFilter::~WaypointFilter()
+WaypointReplan::~WaypointReplan()
 {
 }
 
-void WaypointFilter::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
+void WaypointReplan::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
 {
   velocity_max_ = kmph2mps(conf-&gt;velocity_max);
   velocity_min_ = kmph2mps(conf-&gt;velocity_min);
@@ -65,7 +65,7 @@ void WaypointFilter::initParameter(const autoware_msgs::ConfigWaypointLoader::Co
   r_inf_ = 10 * r_th_;
 }
 
-void WaypointFilter::filterLaneWaypoint(autoware_msgs::lane* lane)
+void WaypointReplan::replanLaneWaypoint(autoware_msgs::lane* lane)
 {
   std::vector&lt;double&gt; curve_radius;
   std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt; curve_list;
@@ -121,7 +121,7 @@ void WaypointFilter::filterLaneWaypoint(autoware_msgs::lane* lane)
   }
 }
 
-void WaypointFilter::resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane,
+void WaypointReplan::resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane,
                                           std::vector&lt;double&gt;* curve_radius)
 {
   if (lane-&gt;waypoints.empty())
@@ -216,7 +216,7 @@ void WaypointFilter::resampleLaneWaypoint(const double resample_interval, autowa
   lane-&gt;waypoints.back().change_flag = original_lane.waypoints.back().change_flag;
 }
 
-void WaypointFilter::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
+void WaypointReplan::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
 {
   if (lane.waypoints.empty())
     return;
@@ -248,7 +248,7 @@ void WaypointFilter::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;do
   }
 }
 
-const double WaypointFilter::calcVelParam() const
+const double WaypointReplan::calcVelParam() const
 {
   if(fabs(r_th_ - r_min_) &lt; 1e-8)
   {
@@ -257,7 +257,7 @@ const double WaypointFilter::calcVelParam() const
   return (velocity_max_ - velocity_min_) / (r_th_ - r_min_);
 }
 
-void WaypointFilter::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
+void WaypointReplan::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
                                      std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list)
 {
   unsigned long index = 0;
@@ -285,7 +285,7 @@ void WaypointFilter::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
   }
 }
 
-void WaypointFilter::limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx,
+void WaypointReplan::limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx,
                                      autoware_msgs::lane* lane)
 {
   double v = vmin_local;
@@ -312,7 +312,7 @@ void WaypointFilter::limitAccelDecel(const double vmax, const double vmin_local,
 }
 
 // get 3 parameter of curve, [center_x, center_y, radius]
-const std::vector&lt;double&gt; WaypointFilter::getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point) const
+const std::vector&lt;double&gt; WaypointReplan::getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point) const
 {
   std::vector&lt;double&gt; curve_param(3, 0.0);
   const std::vector&lt;double&gt; dx = {point[0].x - point[1].x, point[1].x - point[2].x, point[2].x - point[0].x};
@@ -377,12 +377,12 @@ const std::vector&lt;double&gt; WaypointFilter::getCurveOnce(const std::vector&lt;geometr
   return curve_param;
 }
 
-const double WaypointFilter::calcSquareSum(const double x, const double y) const
+const double WaypointReplan::calcSquareSum(const double x, const double y) const
 {
   return (x * x + y * y);
 }
 
-const double WaypointFilter::calcPathLength(const autoware_msgs::lane&amp; lane) const
+const double WaypointReplan::calcPathLength(const autoware_msgs::lane&amp; lane) const
 {
   double distance = 0.0;
   for (unsigned long i = 1; i &lt; lane.waypoints.size(); i++)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" added_lines="6" deleted_lines="6">
				<diff>@@ -28,8 +28,8 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#ifndef __WAYPOINT_FILTER_H__
-#define __WAYPOINT_FILTER_H__
+#ifndef __WAYPOINT_REPLAN_H__
+#define __WAYPOINT_REPLAN_H__
 
 #include &lt;ros/ros.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
@@ -41,7 +41,7 @@
 
 namespace waypoint_maker
 {
-class WaypointFilter
+class WaypointReplan
 {
 private:
   ros::NodeHandle private_nh_;
@@ -54,10 +54,10 @@ private:
   int end_point_offset_;
 
 public:
-  WaypointFilter();
-  ~WaypointFilter();
+  WaypointReplan();
+  ~WaypointReplan();
   void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
-  void filterLaneWaypoint(autoware_msgs::lane* lane);
+  void replanLaneWaypoint(autoware_msgs::lane* lane);
 
 protected:
   void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane,
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -64,14 +64,14 @@ void WaypointLoaderNode::initParameter(const autoware_msgs::ConfigWaypointLoader
 {
   // parameter settings
   disable_decision_maker_ = conf-&gt;disable_decision_maker;
-  filtering_mode_ = conf-&gt;filtering_mode;
+  replanning_mode_ = conf-&gt;replanning_mode;
   multi_lane_csv_ = conf-&gt;multi_lane_csv;
 }
 
 void WaypointLoaderNode::configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
 {
   initParameter(conf);
-  filter_.initParameter(conf);
+  replan_.initParameter(conf);
 
   multi_file_path_.clear();
   parseColumns(multi_lane_csv_, &amp;multi_file_path_);
@@ -85,7 +85,7 @@ void WaypointLoaderNode::outputCommandCallback(const std_msgs::Bool::ConstPtr&amp; o
 {
   std::vector&lt;std::string&gt; dst_multi_file_path = multi_file_path_;
   for (auto&amp; el : dst_multi_file_path)
-    el = addFileSuffix(el, "_filtered");
+    el = addFileSuffix(el, "_replanned");
   saveLaneArray(dst_multi_file_path, output_lane_array_);
 }
 
@@ -112,8 +112,8 @@ void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt;&amp; paths,
   {
     autoware_msgs::lane lane;
     createLaneWaypoint(el, &amp;lane);
-    if (filtering_mode_)
-      filter_.filterLaneWaypoint(&amp;lane);
+    if (replanning_mode_)
+      replan_.replanLaneWaypoint(&amp;lane);
     lane_array-&gt;lanes.push_back(lane);
   }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -88,8 +88,8 @@ private:
   // variables
   std::string multi_lane_csv_;
   bool disable_decision_maker_;
-  bool filtering_mode_;
-  WaypointFilter filter_;
+  bool replanning_mode_;
+  WaypointReplan replan_;
   std::vector&lt;std::string&gt; multi_file_path_;
   autoware_msgs::LaneArray output_lane_array_;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="58cf2d05cd19fa836e76b5d141519efe5120a8be" author="Yuma">
		<msg>Rename cpp and header_files filter-&gt;replan</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="1" deleted_lines="1">
				<diff>@@ -43,7 +43,7 @@
 #include &lt;unordered_map&gt;
 
 #include "autoware_msgs/LaneArray.h"
-#include "waypoint_filter.h"
+#include "waypoint_replan.h"
 
 namespace waypoint_maker
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_replan.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -28,7 +28,7 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "waypoint_filter.h"
+#include "waypoint_replan.h"
 
 namespace waypoint_maker
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_filter.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_replan.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="740b46003104c7cdb46476d88d35abeb153d8456" author="Yuma">
		<msg>Fix curve_radius_method on resampling_mode</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_replan.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_replan.cpp" added_lines="3" deleted_lines="10">
				<diff>@@ -71,9 +71,8 @@ void WaypointReplan::replanLaneWaypoint(autoware_msgs::lane* lane)
   std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt; curve_list;
 
   if (resample_mode_)
-    resampleLaneWaypoint(resample_interval_, lane, &amp;curve_radius);
-  else
-    getCurveAll(*lane, &amp;curve_radius);
+    resampleLaneWaypoint(resample_interval_, lane);
+  getCurveAll(*lane, &amp;curve_radius);
   const double vel_param = calcVelParam();
   createCurveList(curve_radius, &amp;curve_list);
   if (vel_param == DBL_MAX)
@@ -121,20 +120,16 @@ void WaypointReplan::replanLaneWaypoint(autoware_msgs::lane* lane)
   }
 }
 
-void WaypointReplan::resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane,
-                                          std::vector&lt;double&gt;* curve_radius)
+void WaypointReplan::resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane)
 {
   if (lane-&gt;waypoints.empty())
     return;
   autoware_msgs::lane original_lane = *lane;
   lane-&gt;waypoints.clear();
   lane-&gt;waypoints.push_back(original_lane.waypoints[0]);
-  curve_radius-&gt;clear();
-  curve_radius-&gt;push_back(r_inf_);
   double original_len = calcPathLength(original_lane);
   unsigned long waypoints_size = ceil(1.5 * original_len / resample_interval_);
   lane-&gt;waypoints.reserve(waypoints_size);
-  curve_radius-&gt;reserve(waypoints_size);
 
   const unsigned int n = (lookup_crv_width_ - 1) / 2;
   for (unsigned long i = 1; i &lt; original_lane.waypoints.size(); i++)
@@ -168,7 +163,6 @@ void WaypointReplan::resampleLaneWaypoint(const double resample_interval, autowa
         wp.pose.pose.position.y += resample_vec.y();
         wp.pose.pose.position.z += resample_vec.z();
         lane-&gt;waypoints.push_back(wp);
-        curve_radius-&gt;push_back(r_inf_);
       }
     }
     // else if turnning curve
@@ -206,7 +200,6 @@ void WaypointReplan::resampleLaneWaypoint(const double resample_interval, autowa
         wp.pose.pose.position.z += resample_dz;
         wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
         lane-&gt;waypoints.push_back(wp);
-        curve_radius-&gt;push_back(threshold_radius);
       }
     }
     lane-&gt;waypoints.back().wpstate = original_lane.waypoints[i].wpstate;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_replan.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_replan.h" added_lines="1" deleted_lines="2">
				<diff>@@ -60,8 +60,7 @@ public:
   void replanLaneWaypoint(autoware_msgs::lane* lane);
 
 protected:
-  void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane,
-                            std::vector&lt;double&gt;* curve_radius);
+  void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane);
   void getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius);
   const double calcVelParam() const;
   void createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="03eede8324cfa599364edcb23fae2f9f4229e77d" author="Kosuke Murakami">
		<msg>Merge visualize_cloud_cluster.launch to imm_ukf_pda_tracker.launch</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="13" deleted_lines="47">
				<diff>@@ -2,9 +2,6 @@
 #include "imm_ukf_pda_tracker.h"
 
 
-using std::cout;
-using std::endl;
-
 namespace States
 {
   enum TrackingState: int
@@ -29,14 +26,12 @@ namespace Matches
 typedef Matches::IsMatch IsMatch;
 
 
-//for print out iteration
-int g_count = 0;
 
 ImmUkfPda::ImmUkfPda()
 {
   ros::NodeHandle private_nh_("~");
-  private_nh_.param&lt;std::string&gt;("input_topic_", input_topic_, "/cloud_clusters");
-  private_nh_.param&lt;std::string&gt;("output_topic_", output_topic_, "/tracking_cluster_array");
+  // private_nh_.param&lt;std::string&gt;("input_topic_", input_topic_, "/cloud_clusters");
+  // private_nh_.param&lt;std::string&gt;("output_topic_", output_topic_, "/tracking_cluster_array");
   private_nh_.param&lt;std::string&gt;("pointcloud_frame_", pointcloud_frame_, "velodyne");
   private_nh_.param&lt;int&gt;("life_time_thres_", life_time_thres_, 8);
   private_nh_.param&lt;double&gt;("gating_thres_", gating_thres_, 9.22);
@@ -44,16 +39,15 @@ ImmUkfPda::ImmUkfPda()
   private_nh_.param&lt;double&gt;("detection_probability_", detection_probability_, 0.9);
   private_nh_.param&lt;double&gt;("distance_thres_", distance_thres_, 99);
   private_nh_.param&lt;double&gt;("static_distance_thres_", static_distance_thres_, 3.0);
-  // private_nh_.param&lt;double&gt;("bb_yaw_change_thres_", bb_yaw_change_thres_, 0.3);
-  // private_nh_.param&lt;double&gt;("init_yaw_", init_yaw_, 100);
+
 
   init_ = false;
 
   tf::TransformListener *lr (new  tf::TransformListener);
   tran_=lr;
 
-  sub_cloud_array_   = node_handle_.subscribe (input_topic_, 1, &amp;ImmUkfPda::callBack, this);
-  pub_cloud_array_  = node_handle_.advertise&lt;autoware_msgs::CloudClusterArray&gt; (output_topic_, 1);
+  sub_cloud_array_   = node_handle_.subscribe ("cloud_clusters", 1, &amp;ImmUkfPda::callBack, this);
+  pub_cloud_array_  = node_handle_.advertise&lt;autoware_msgs::CloudClusterArray&gt; ("tracking_cluster_array", 1);
 
 }
 
@@ -64,16 +58,13 @@ void ImmUkfPda::callBack(autoware_msgs::CloudClusterArray input)
   transformPoseToGlobal(input);
   tracker(input, output);
   transformPoseToLocal(output);
-  // output = input;
+
   pub_cloud_array_.publish(output);
-  g_count ++;
-  // std::cout &lt;&lt; "Frame " &lt;&lt;g_count&lt;&lt; "------------------------------------------------"&lt;&lt;std::endl;
+
 }
 
 void ImmUkfPda::transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input)
 {
-  // std::string local_frame = "base_link";
-
   for(size_t i = 0; i &lt; input.clusters.size(); i ++)
   {
     geometry_msgs::PoseStamped pose_in, pose_out;
@@ -88,7 +79,7 @@ void ImmUkfPda::transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input)
 
 void ImmUkfPda::transformPoseToLocal(autoware_msgs::CloudClusterArray&amp; output)
 {
-  // std::string local_frame = "base_link";
+
   for(size_t i = 0; i &lt; output.clusters.size(); i ++)
   {
     geometry_msgs::PoseStamped pose_in, pose_out;
@@ -158,7 +149,7 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
 
     Eigen::VectorXd diff = meas - max_det_z;
     double nis = diff.transpose()*max_det_s.inverse()*diff;
-    // cout &lt;&lt;"nis: " &lt;&lt;nis &lt;&lt; endl;
+
     if(nis &lt; gating_thres_)
     { // x^2 99% range
       count ++;
@@ -170,14 +161,12 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
         {
         smallest_nis = nis;
         smallest_meas_cluster = input.clusters[i];
-        // measVec.push_back(meas);
         matching_vec[i] = IsMatch::True;
         second_init_done = true;
         }
       }
       else
       {
-        // cout &lt;&lt; "check cp "&lt;&lt;input.clusters[i].bounding_box.pose.position.x &lt;&lt; " "&lt;&lt; input.clusters[i].bounding_box.pose.position.y &lt;&lt; endl;
         cluster_vec.push_back(input.clusters[i]);
         matching_vec[i] = IsMatch::True;
       }
@@ -330,7 +319,6 @@ void ImmUkfPda::filterPDA(UKF&amp; target,
     lambda_ctrv = (1 - gate_probability_*detection_probability_)/pow(Vk, num_meas);
     lambda_rm   = (1 - gate_probability_*detection_probability_)/pow(Vk, num_meas);
   }
-  // cout &lt;&lt;endl&lt;&lt; "lambda: "&lt;&lt;endl&lt;&lt;lambdaCV &lt;&lt; " "&lt;&lt; lambdaCTRV&lt;&lt;" "&lt;&lt; lambdaRM &lt;&lt; endl;
   lambda_vec.push_back(lambda_cv);
   lambda_vec.push_back(lambda_ctrv);
   lambda_vec.push_back(lambda_rm);
@@ -342,12 +330,12 @@ void ImmUkfPda::getNearestEuclidCluster(const UKF target,
   int min_ind = 0;
   double px = target.x_merge_(0);
   double py = target.x_merge_(1);
-  // cout &lt;&lt; "px py"&lt;&lt; px &lt;&lt; " "&lt;&lt; py &lt;&lt; endl;
+
   for (size_t i = 0; i &lt; cluster_vec.size(); i++)
   {
     double meas_x = cluster_vec[i].bounding_box.pose.position.x;
     double meas_y = cluster_vec[i].bounding_box.pose.position.y;
-    // cout &lt;&lt; "measx measY "&lt;&lt; measX &lt;&lt; " "&lt;&lt; measY &lt;&lt; endl;
+
     double dist = sqrt((px-meas_x)*(px-meas_x)+(py-meas_y)*(py-meas_y));
     if(dist &lt; min_dist)
     {
@@ -355,7 +343,7 @@ void ImmUkfPda::getNearestEuclidCluster(const UKF target,
       min_ind = i;
     }
   }
-  // assert(clusterVec[minInd].rows() == 2);
+
   cluster = cluster_vec[min_ind];
 }
 
@@ -368,20 +356,14 @@ void ImmUkfPda::associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; clust
   {
       return;
   }
-  // cout &lt;&lt; target.tracking_num_ &lt;&lt; " "&lt;&lt; target.lifetime_ &lt;&lt; endl;
   if(target.tracking_num_ == TrackingState::Stable &amp;&amp; target.lifetime_ &gt;= life_time_thres_)
   {
-    // cout &lt;&lt; "--------------" &lt;&lt; endl;
     autoware_msgs::CloudCluster nearest_cluster;
-    // double min_dist = 999;
     double min_dist = std::numeric_limits&lt;double&gt;::max();
     getNearestEuclidCluster(target, cluster_vec, nearest_cluster, min_dist);
-    // std::cout &lt;&lt; "minDist "&lt;&lt; min_dist &lt;&lt; std::endl;
     if(min_dist &lt; distance_thres_)
     {
       target.is_vis_bb_ = true;
-      // target.BBox_    = bbox;
-      // cout &lt;&lt;"nearestCluster "&lt;&lt; nearestCluster.bounding_box&lt;&lt;endl;
       target.jsk_bb_   = nearest_cluster.bounding_box;
     }
   }
@@ -424,10 +406,7 @@ double ImmUkfPda::getJskBBoxArea(const jsk_recognition_msgs::BoundingBox jsk_bb)
 
 void ImmUkfPda::updateBB(UKF&amp; target)
 {
-  //to do: initialize target.BBox_ somewhere else
-
   // skip to prevent memory leak by accessing empty target.bbox_
-
   if(!target.is_vis_bb_)
   {
       return;
@@ -435,8 +414,6 @@ void ImmUkfPda::updateBB(UKF&amp; target)
   double yaw = getJskBBoxYaw(target.jsk_bb_);
 
   // skip the rest of process if it is first bbox associaiton
-  // todo: wanna check if bestJskBBox is empty or not, there should be better method
-  // if(target.bestBBox_.empty()){
   if(target.is_best_jsk_bb_empty_ == false)
   {
     target.best_jsk_bb_ = target.jsk_bb_;
@@ -575,7 +552,6 @@ void ImmUkfPda::initTracker(autoware_msgs::CloudClusterArray input, double times
     targets_.push_back(ukf);
   }
   timestamp_ = timestamp;
-  // egoPreYaw_ = egoYaw_;
   init_ = true;
   return;
 }
@@ -587,8 +563,6 @@ void ImmUkfPda::secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; c
     target.tracking_num_ = TrackingState::Die;
     return;
   }
-
-  // assert(measVec.size() == 1);
   // record init measurement for env classification
   target.init_meas_ &lt;&lt; target.x_merge_(0), target.x_merge_(1);
 
@@ -600,7 +574,6 @@ void ImmUkfPda::secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; c
   double target_yaw = atan2(target_diff_y, target_diff_x);
   double dist      = sqrt(target_diff_x*target_diff_x + target_diff_y* target_diff_y);
   double target_v   = dist/dt;
-  // double targetV   = 2;
 
   while (target_yaw&gt; M_PI) target_yaw -= 2.*M_PI;
   while (target_yaw&lt;-M_PI) target_yaw += 2.*M_PI;
@@ -664,7 +637,7 @@ void ImmUkfPda::probabilisticDataAssociation(autoware_msgs::CloudClusterArray in
   is_skip_target = false;
   // find maxDetS associated with predZ
   findMaxZandS(target, max_det_z, max_det_s);
-  // to do: might modufy here: this code ensures that measurement is incorporated
+  // to do: might modify here: this code ensures that measurement is incorporated
   max_det_s = max_det_s*4;
   double det_s = max_det_s.determinant();
 
@@ -762,7 +735,6 @@ void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
   m.getRPY(roll, pitch, yaw);
 
   output.header = input.header;
-  // int target_num_count = 0;
   for(size_t i = 0; i &lt; targets_.size(); i++)
   {
     if(targets_[i].is_vis_bb_)
@@ -781,16 +753,11 @@ void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
       double tv = targets_[i].x_merge_(2);
       double tyaw = targets_[i].x_merge_(3) - yaw;
 
-      // tyaw += egoPoints_[0][2];
       while (tyaw&gt; M_PI) tyaw -= 2.*M_PI;
       while (tyaw&lt;-M_PI) tyaw += 2.*M_PI;
-      // cout &lt;&lt; "testing yaw off "&lt;&lt; tyaw &lt;&lt; endl;
-
-      // cout &lt;&lt; "inside tracker ----------------------------------------------------------------------------------------------"&lt;&lt;targets_[i].jskBB_.pose &lt;&lt; endl;
 
       autoware_msgs::CloudCluster cc;
       cc.header = input.header;
-      // std::cout &lt;&lt; "id "&lt;&lt; i &lt;&lt; std::endl;
       cc.id     = i;
       cc.bounding_box = targets_[i].jsk_bb_;
       cc.bounding_box.header = input.header;
@@ -805,7 +772,6 @@ void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
 void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
                         autoware_msgs::CloudClusterArray&amp; output)
 {
-  // int in_num_cluster = input.clusters.size();
   double timestamp = input.header.stamp.toSec();
 
   double det_explode_param = 10;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker_main.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker_main.cpp" added_lines="1" deleted_lines="8">
				<diff>@@ -1,15 +1,8 @@
-// #include &lt;ros/ros.h&gt;
-// #include &lt;iostream&gt;
-
-// #include "autoware_msgs/CloudCluster.h"
-// #include "autoware_msgs/CloudClusterArray.h"
 
 #include "imm_ukf_pda_tracker.h"
 
-int main(int argc, char **argv)
-{
+int main(int argc, char **argv) {
 
-  // std::cout&lt;&lt; 123&lt;&lt;std::endl;
   ros::init(argc, argv, "imm_ukf_pda_tracker");
   ImmUkfPda app;
   ros::spin();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" added_lines="0" deleted_lines="3">
				<diff>@@ -16,9 +16,6 @@
 #include "autoware_msgs/CloudClusterArray.h"
 
 
-// using namespace std;
-// using namespace pcl;
-// using namespace Eigen;
 
 class VisualizeCloudCluster
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" added_lines="3" deleted_lines="9">
				<diff>@@ -9,7 +9,7 @@ VisualizeCloudCluster::VisualizeCloudCluster()
   ros::NodeHandle private_nh_("~");
   private_nh_.param&lt;std::string&gt;("input_topic_", input_topic_, "/tracking_cluster_array");
   private_nh_.param&lt;std::string&gt;("pointcloud_frame_", pointcloud_frame_, "velodyne");
-  // sub_cloud_array_  = node_handle_.subscribe ("/bbox_cluster_array", 1, &amp;VisualizeCloudCluster::callBack, this);
+
   sub_cloud_array_  = node_handle_.subscribe (input_topic_, 1, &amp;VisualizeCloudCluster::callBack, this);
   pub_jsk_bb_       = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt; ("/tracking_cluster_array/jsk_bb", 1);
   pub_arrow_        = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/tracking_cluster_array/velocity_arrow", 1);
@@ -24,7 +24,6 @@ void VisualizeCloudCluster::callBack(autoware_msgs::CloudClusterArray input)
   getJskBBs(input, jsk_bbs);
   pub_jsk_bb_.publish(jsk_bbs);
   visMarkers(input);
-  // cout &lt;&lt; "receive jsk call back" &lt;&lt; endl;
 }
 
 void VisualizeCloudCluster::getJskBBs(autoware_msgs::CloudClusterArray input,
@@ -38,9 +37,7 @@ void VisualizeCloudCluster::getJskBBs(autoware_msgs::CloudClusterArray input,
     bb = input.clusters[i].bounding_box;
     bb.header = input.header;
     std::string label = input.clusters[i].label;
-    // cout &lt;&lt; label &lt;&lt; endl;
-    // bb.label = label;
-    // ? jsk bb, how to find appropriate color
+
     if(label == "Stable")
     {
       bb.label = 2;
@@ -52,7 +49,6 @@ void VisualizeCloudCluster::getJskBBs(autoware_msgs::CloudClusterArray input,
 
     jsk_bbs.boxes.push_back(bb);
   }
-  // cout &lt;&lt;"cluster size " &lt;&lt; jsk_bbs.boxes.size() &lt;&lt; endl;
 }
 
 void VisualizeCloudCluster::visMarkers(autoware_msgs::CloudClusterArray input)
@@ -97,9 +93,7 @@ void VisualizeCloudCluster::visMarkers(autoware_msgs::CloudClusterArray input)
     ids.pose.orientation.z = q_tf.getZ();
     ids.pose.orientation.w = q_tf.getW();
 
-    // Set the scale of the ids -- 1x1x1 here means 1m on a side
-    // ids.scale.x = tv;
-    // ids.scale.y = 0.1;
+
     ids.scale.z = 1.0;
 
     ids.text = std::to_string(input.clusters[i].id);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster_main.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster_main.cpp" added_lines="2" deleted_lines="8">
				<diff>@@ -1,14 +1,8 @@
-// #include &lt;ros/ros.h&gt;
-// #include &lt;iostream&gt;
-#include "visualize_cloud_cluster.h"
 
-// #include "autoware_msgs/CloudCluster.h"
-// #include "autoware_msgs/CloudClusterArray.h"
+#include "visualize_cloud_cluster.h"
 
-int main(int argc, char **argv)
-{
+int main(int argc, char **argv) {
 
-  // std::cout&lt;&lt; 122&lt;&lt;std::endl;
   ros::init(argc, argv, "visualize_cloud_cluster");
   VisualizeCloudCluster app;
   ros::spin();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e3a9c1ae0cd7250482785d3679268465988cf79d" author="Kosuke Murakami">
		<msg>Change naming for rosparams</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="7" deleted_lines="9">
				<diff>@@ -30,15 +30,13 @@ typedef Matches::IsMatch IsMatch;
 ImmUkfPda::ImmUkfPda()
 {
   ros::NodeHandle private_nh_("~");
-  // private_nh_.param&lt;std::string&gt;("input_topic_", input_topic_, "/cloud_clusters");
-  // private_nh_.param&lt;std::string&gt;("output_topic_", output_topic_, "/tracking_cluster_array");
-  private_nh_.param&lt;std::string&gt;("pointcloud_frame_", pointcloud_frame_, "velodyne");
-  private_nh_.param&lt;int&gt;("life_time_thres_", life_time_thres_, 8);
-  private_nh_.param&lt;double&gt;("gating_thres_", gating_thres_, 9.22);
-  private_nh_.param&lt;double&gt;("gate_probability_", gate_probability_, 0.99);
-  private_nh_.param&lt;double&gt;("detection_probability_", detection_probability_, 0.9);
-  private_nh_.param&lt;double&gt;("distance_thres_", distance_thres_, 99);
-  private_nh_.param&lt;double&gt;("static_distance_thres_", static_distance_thres_, 3.0);
+  private_nh_.param&lt;std::string&gt;("pointcloud_frame", pointcloud_frame_, "velodyne");
+  private_nh_.param&lt;int&gt;("life_time_thres", life_time_thres_, 8);
+  private_nh_.param&lt;double&gt;("gating_thres", gating_thres_, 9.22);
+  private_nh_.param&lt;double&gt;("gate_probability", gate_probability_, 0.99);
+  private_nh_.param&lt;double&gt;("detection_probability", detection_probability_, 0.9);
+  private_nh_.param&lt;double&gt;("distance_thres", distance_thres_, 99);
+  private_nh_.param&lt;double&gt;("static_distance_thres", static_distance_thres_, 3.0);
 
 
   init_ = false;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" added_lines="2" deleted_lines="3">
				<diff>@@ -7,10 +7,9 @@
 VisualizeCloudCluster::VisualizeCloudCluster()
 {
   ros::NodeHandle private_nh_("~");
-  private_nh_.param&lt;std::string&gt;("input_topic_", input_topic_, "/tracking_cluster_array");
-  private_nh_.param&lt;std::string&gt;("pointcloud_frame_", pointcloud_frame_, "velodyne");
+  private_nh_.param&lt;std::string&gt;("pointcloud_frame", pointcloud_frame_, "velodyne");
 
-  sub_cloud_array_  = node_handle_.subscribe (input_topic_, 1, &amp;VisualizeCloudCluster::callBack, this);
+  sub_cloud_array_  = node_handle_.subscribe ("tracking_cluster_array", 1, &amp;VisualizeCloudCluster::callBack, this);
   pub_jsk_bb_       = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt; ("/tracking_cluster_array/jsk_bb", 1);
   pub_arrow_        = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/tracking_cluster_array/velocity_arrow", 1);
   pub_id_           = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/tracking_cluster_array/target_id", 1);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f6efc370e1af00f2e31277e2c7a879ab32dbbc05" author="Kosuke Murakami">
		<msg>Add tracking_frame</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" added_lines="22" deleted_lines="15">
				<diff>@@ -17,11 +17,6 @@
 #include "ukf.h"
 
 
-// using namespace pcl;
-// using namespace Eigen;
-
-
-
 class ImmUkfPda
 {
 private:
@@ -29,14 +24,10 @@ private:
   double timestamp_ ;
 
   std::vector&lt;UKF&gt; targets_;
-  // std::vector&lt;int&gt; trackNumVec_;
 
   // probabilistic data association params
-  double gating_thres_;//9.22; // 99%
+  double gating_thres_;//9.22
   double gate_probability_;//0.99;
-  // extern double gammaG_ = 5.99; // 99%
-  // extern double pG_ = 0.95;
-  // extern double gammaG_ = 15.22; // 99%
   double detection_probability_;//0.9;
 
   //bbox association param
@@ -44,26 +35,42 @@ private:
   int life_time_thres_;//8;
   //bbox update params
   double bb_yaw_change_thres_;//0.2;
-  // double bb_area_change_thres_;//0.5;
 
   double static_distance_thres_;
 
   double init_yaw_;
 
+  //Tracking state paramas
+  int stable_num_;
+  int lost_num_;
+
   std::string input_topic_;
   std::string output_topic_;
 
   std::string pointcloud_frame_;
-  // std::vector&lt;UKF&gt; targets_;
-  // std::vector&lt;int&gt; trackNumVec_;
+  std::string tracking_frame_;
 
-  tf::TransformListener* tran_;
+  tf::TransformListener* tf_listener_;
 
   ros::NodeHandle node_handle_;
   ros::Subscriber sub_cloud_array_;
   ros::Publisher pub_cloud_array_;
 
-  void callBack(autoware_msgs::CloudClusterArray input);
+  enum TrackingState: int
+    {
+       Die = 0,
+       Init = 1,
+       Stable = 4,
+       Lost = 10,
+    };
+
+  enum IsMatch: int
+    {
+       False = 0,
+       True = 1,
+    };
+
+  void callback(autoware_msgs::CloudClusterArray input);
   void transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input);
   void transformPoseToLocal(autoware_msgs::CloudClusterArray&amp; input);
   void findMaxZandS(const UKF target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="13" deleted_lines="35">
				<diff>@@ -2,54 +2,32 @@
 #include "imm_ukf_pda_tracker.h"
 
 
-namespace States
-{
-  enum TrackingState: int
-  {
-     Die = 0,
-     Init = 1,
-     Stable = 4,
-     Lost = 10,
-
-  };
-}
-typedef States::TrackingState TrackingState;
-
-namespace Matches
-{
-  enum IsMatch: int
-  {
-     False = 0,
-     True = 1,
-  };
-}
-typedef Matches::IsMatch IsMatch;
-
-
-
 ImmUkfPda::ImmUkfPda()
 {
   ros::NodeHandle private_nh_("~");
   private_nh_.param&lt;std::string&gt;("pointcloud_frame", pointcloud_frame_, "velodyne");
+  private_nh_.param&lt;std::string&gt;("tracking_frame", tracking_frame_, "world");
   private_nh_.param&lt;int&gt;("life_time_thres", life_time_thres_, 8);
   private_nh_.param&lt;double&gt;("gating_thres", gating_thres_, 9.22);
   private_nh_.param&lt;double&gt;("gate_probability", gate_probability_, 0.99);
   private_nh_.param&lt;double&gt;("detection_probability", detection_probability_, 0.9);
   private_nh_.param&lt;double&gt;("distance_thres", distance_thres_, 99);
   private_nh_.param&lt;double&gt;("static_distance_thres", static_distance_thres_, 3.0);
+  private_nh_.param&lt;int&gt;("stable_num", stable_num_, 4);
+  private_nh_.param&lt;int&gt;("lost_num", lost_num_, 10);
 
 
   init_ = false;
 
   tf::TransformListener *lr (new  tf::TransformListener);
-  tran_=lr;
+  tf_listener_=lr;
 
-  sub_cloud_array_   = node_handle_.subscribe ("cloud_clusters", 1, &amp;ImmUkfPda::callBack, this);
+  sub_cloud_array_   = node_handle_.subscribe ("cloud_clusters", 1, &amp;ImmUkfPda::callback, this);
   pub_cloud_array_  = node_handle_.advertise&lt;autoware_msgs::CloudClusterArray&gt; ("tracking_cluster_array", 1);
 
 }
 
-void ImmUkfPda::callBack(autoware_msgs::CloudClusterArray input)
+void ImmUkfPda::callback(autoware_msgs::CloudClusterArray input)
 {
   autoware_msgs::CloudClusterArray output;
   // only transform pose(clusteArray.clusters.bouding_box.pose)
@@ -69,8 +47,8 @@ void ImmUkfPda::transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input)
 
     pose_in.header = input.header;
     pose_in.pose = input.clusters[i].bounding_box.pose;
-    tran_-&gt;waitForTransform(pointcloud_frame_, "/world",input.header.stamp, ros::Duration(3.0));
-    tran_-&gt;transformPose("world", ros::Time(0), pose_in, input.header.frame_id, pose_out);
+    tf_listener_-&gt;waitForTransform(pointcloud_frame_, tracking_frame_, input.header.stamp, ros::Duration(1.0));
+    tf_listener_-&gt;transformPose(tracking_frame_, ros::Time(0), pose_in, input.header.frame_id, pose_out);
     input.clusters[i].bounding_box.pose = pose_out.pose;
   }
 }
@@ -83,11 +61,11 @@ void ImmUkfPda::transformPoseToLocal(autoware_msgs::CloudClusterArray&amp; output)
     geometry_msgs::PoseStamped pose_in, pose_out;
 
     pose_in.header = output.header;
-    pose_in.header.frame_id = "world";
+    pose_in.header.frame_id = tracking_frame_;
     pose_in.pose = output.clusters[i].bounding_box.pose;
 
-    tran_-&gt;waitForTransform("/world", pointcloud_frame_, ros::Time(0), ros::Duration(3.0));
-    tran_-&gt;transformPose(pointcloud_frame_, ros::Time(0), pose_in, "world", pose_out);
+    tf_listener_-&gt;waitForTransform(tracking_frame_, pointcloud_frame_, ros::Time(0), ros::Duration(1.0));
+    tf_listener_-&gt;transformPose(pointcloud_frame_, ros::Time(0), pose_in, tracking_frame_, pose_out);
     pose_out.header.frame_id = output.header.frame_id = pointcloud_frame_;
     output.clusters[i].bounding_box.pose = pose_out.pose;
   }
@@ -725,9 +703,9 @@ void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
                            autoware_msgs::CloudClusterArray&amp; output)
 {
   tf::StampedTransform transform;
-  tran_-&gt;lookupTransform("/world", "/base_link", ros::Time(0), transform);
+  tf_listener_-&gt;lookupTransform(tracking_frame_, pointcloud_frame_, ros::Time(0), transform);
 
-  // get yaw angle from "world" to "velodyne" for direction(arrow) visualization
+  // get yaw angle from tracking_frame_ to pointcloud_frame_ for direction(arrow) visualization
   tf::Matrix3x3 m(transform.getRotation());
   double roll, pitch, yaw;
   m.getRPY(roll, pitch, yaw);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="37c46aca8ed078b7d69e92e893ec8aefaa8f8e60" author="Kosuke Murakami">
		<msg>Modify matching_vec</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" added_lines="3" deleted_lines="16">
				<diff>@@ -56,19 +56,6 @@ private:
   ros::Subscriber sub_cloud_array_;
   ros::Publisher pub_cloud_array_;
 
-  enum TrackingState: int
-    {
-       Die = 0,
-       Init = 1,
-       Stable = 4,
-       Lost = 10,
-    };
-
-  enum IsMatch: int
-    {
-       False = 0,
-       True = 1,
-    };
 
   void callback(autoware_msgs::CloudClusterArray input);
   void transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input);
@@ -77,7 +64,7 @@ private:
   void measurementValidation(const autoware_msgs::CloudClusterArray input, UKF&amp; target, const bool second_init,
                  const Eigen::VectorXd max_det_z, const Eigen::MatrixXd max_det_s,
                  std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
-                 std::vector&lt;int&gt;&amp; matching_vec);
+                 std::vector&lt;bool&gt;&amp; matching_vec);
   void filterPDA(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, std::vector&lt;double&gt;&amp; lambda_vec);
   void getNearestEuclidCluster(const UKF target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
                 autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist);
@@ -101,9 +88,9 @@ private:
   void updateTrackingNum(std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target);
 
   void probabilisticDataAssociation(autoware_msgs::CloudClusterArray input,
-                                    double dt, double det_explode_param, std::vector&lt;int&gt;&amp; matching_vec,
+                                    double dt, double det_explode_param, std::vector&lt;bool&gt;&amp; matching_vec,
                                     std::vector&lt;double&gt;&amp; lambda_vec, UKF&amp; target, bool&amp; is_skip_target);
-  void makeNewTargets(double timestamp, autoware_msgs::CloudClusterArray input, std::vector&lt;int&gt; matching_vec);
+  void makeNewTargets(double timestamp, autoware_msgs::CloudClusterArray input, std::vector&lt;bool&gt; matching_vec);
 
   void staticClassification();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="17" deleted_lines="8">
				<diff>@@ -1,6 +1,15 @@
 #include "ukf.h"
 #include "imm_ukf_pda_tracker.h"
 
+//
+enum TrackingState: int
+  {
+     Die = 0, // No longer tracking
+     Init = 1, // Start tracking
+     Stable = 4, // Stable tracking
+     Lost = 10, // About to lose target
+  };
+
 
 ImmUkfPda::ImmUkfPda()
 {
@@ -109,7 +118,7 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
                                      const bool second_init,
                                      const Eigen::VectorXd max_det_z, const Eigen::MatrixXd max_det_s,
                                      std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
-                                     std::vector&lt;int&gt;&amp; matching_vec)
+                                     std::vector&lt;bool&gt;&amp; matching_vec)
 {
   int count = 0;
   bool second_init_done = false;
@@ -129,7 +138,7 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
     if(nis &lt; gating_thres_)
     { // x^2 99% range
       count ++;
-      if(matching_vec[i] == IsMatch::False) target.lifetime_ ++;
+      if(matching_vec[i] == false) target.lifetime_ ++;
       // pick one meas with smallest nis
       if(second_init)
       {
@@ -137,14 +146,14 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
         {
         smallest_nis = nis;
         smallest_meas_cluster = input.clusters[i];
-        matching_vec[i] = IsMatch::True;
+        matching_vec[i] = true;
         second_init_done = true;
         }
       }
       else
       {
         cluster_vec.push_back(input.clusters[i]);
-        matching_vec[i] = IsMatch::True;
+        matching_vec[i] = true;
       }
     }
   }
@@ -604,7 +613,7 @@ void ImmUkfPda::updateTrackingNum(std::vector&lt;autoware_msgs::CloudCluster&gt; clust
 }
 
 void ImmUkfPda::probabilisticDataAssociation(autoware_msgs::CloudClusterArray input,
-                                            double dt, double det_explode_param, std::vector&lt;int&gt;&amp; matching_vec,
+                                            double dt, double det_explode_param, std::vector&lt;bool&gt;&amp; matching_vec,
                                             std::vector&lt;double&gt;&amp; lambda_vec, UKF&amp; target, bool&amp; is_skip_target)
 {
   Eigen::VectorXd max_det_z;
@@ -661,11 +670,11 @@ void ImmUkfPda::probabilisticDataAssociation(autoware_msgs::CloudClusterArray in
   filterPDA(target, cluster_vec, lambda_vec);
 }
 
-void ImmUkfPda::makeNewTargets(double timestamp, autoware_msgs::CloudClusterArray input, std::vector&lt;int&gt; matching_vec)
+void ImmUkfPda::makeNewTargets(double timestamp, autoware_msgs::CloudClusterArray input, std::vector&lt;bool&gt; matching_vec)
 {
   for(size_t i = 0; i &lt; input.clusters.size(); i ++)
   {
-    if(matching_vec[i] == IsMatch::False)
+    if(matching_vec[i] == false)
     {
       double px = input.clusters[i].bounding_box.pose.position.x;
       double py = input.clusters[i].bounding_box.pose.position.y;
@@ -763,7 +772,7 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
   double dt = (timestamp - timestamp_);
   timestamp_ = timestamp;
   // // used for making new target with no data association
-  std::vector&lt;int&gt; matching_vec(input.clusters.size()); // make 0 vector
+  std::vector&lt;bool&gt; matching_vec(input.clusters.size(), false); // make 0 vector
 
   // start UKF process
   for(size_t i = 0; i &lt; targets_.size(); i++)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fe00113691093713eaf7368340bd30e6de01009d" author="Kosuke Murakami">
		<msg>Refactor ukf codes</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" added_lines="4" deleted_lines="22">
				<diff>@@ -1,8 +1,7 @@
 #ifndef OBJECT_TRACKING_UKF_H
 #define OBJECT_TRACKING_UKF_H
-// #include "measurement_package.h"
+
 #include "Eigen/Dense"
-// #include &lt;eigen3&gt;
 #include &lt;vector&gt;
 #include &lt;string&gt;
 #include &lt;fstream&gt;
@@ -11,11 +10,6 @@
 
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 
-
-// using Eigen::Eigen::MatrixXd;
-// using Eigen::VectorXd;
-// using namespace Eigen;
-
 class UKF
 {
 public:
@@ -53,9 +47,6 @@ public:
   ///* state covariance matrix
   Eigen::MatrixXd p_rm_;
 
-//    ///* predicted sigma points matrix
-//    Eigen::MatrixXd Xsig_pred_;
-
   ///* predicted sigma points matrix
   Eigen::MatrixXd x_sig_pred_cv_;
 
@@ -74,6 +65,7 @@ public:
   double std_a_rm_;
   ///* Process noise standard deviation yaw acceleration in rad/s^2
 //    double std_yawdd_;
+
   // CTRV
   double std_ctrv_yawdd_;
   // CV
@@ -152,15 +144,12 @@ public:
   Eigen::MatrixXd s_cv_;
   Eigen::MatrixXd s_ctrv_;
   Eigen::MatrixXd s_rm_;
-  // Eigen::MatrixXd rS_cv_;
-  // Eigen::MatrixXd rS_ctrv_;
-  // Eigen::MatrixXd rS_rm_;
+
 
   Eigen::MatrixXd k_cv_;
   Eigen::MatrixXd k_ctrv_;
   Eigen::MatrixXd k_rm_;
 
-  // double gamma_g_;
   double pd_;
   double pg_;
 
@@ -169,14 +158,12 @@ public:
 
   // bounding box params
   bool is_vis_bb_;
-  // todo: need initialization?
 
   jsk_recognition_msgs::BoundingBox jsk_bb_;
   jsk_recognition_msgs::BoundingBox best_jsk_bb_;
 
   bool is_best_jsk_bb_empty_;
-  // pcl::PointCloud&lt;pcl::PointXYZ&gt; bbox_;
-  // pcl::PointCloud&lt;pcl::PointXYZ&gt; bestBBox_;
+
   double best_yaw_;
   double bb_yaw_;
   double bb_area_;
@@ -201,11 +188,6 @@ public:
    */
   UKF();
 
-  /**
-   * Destructor
-   */
-  // virtual ~UKF();
-
   void updateYawWithHighProb();
 
   void initialize(const Eigen::VectorXd z, const double timestamp);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" added_lines="1" deleted_lines="17">
				<diff>@@ -1,18 +1,5 @@
-//
-// Created by kosuke on 12/23/17.
-//
 
 #include "ukf.h"
-// #include "tools.h"
-#include "Eigen/Dense"
-#include &lt;iostream&gt;
-#include &lt;math.h&gt;
-
-
-using namespace std;
-// using namespace Eigen;
-//using Eigen::MatrixXd;
-//using Eigen::VectorXd;
 
 /**
 * Initializes Unscented Kalman filter
@@ -241,8 +228,6 @@ void UKF::updateModeProb(const std::vector&lt;double&gt; lambda_vec)
   if(fabs(mode_prob_cv_)   &lt; 0.0001) mode_prob_cv_   = 0.0001;
   if(fabs(mode_prob_ctrv_) &lt; 0.0001) mode_prob_ctrv_ = 0.0001;
   if(fabs(mode_prob_rm_)   &lt; 0.0001) mode_prob_rm_   = 0.0001;
-
-  // cout &lt;&lt; endl&lt;&lt;"mode prob"&lt;&lt;endl&lt;&lt;"cv: "&lt;&lt;mode_prob_CV_&lt;&lt;endl&lt;&lt;"ctrv: "&lt;&lt;mode_prob_CTRV_&lt;&lt;endl&lt;&lt;"rm: "&lt;&lt;mode_prob_RM_&lt;&lt;endl;
 }
 
 void UKF::updateYawWithHighProb()
@@ -428,7 +413,7 @@ void UKF::cv(const double p_x, const double p_y, const double v, const double ya
   double v_p = v;
   // not sure which one, works better in curve by using yaw
   double yaw_p = yaw;
-//    double yaw_p = 0;
+
   double yawd_p = yawd;
 
   //add noise
@@ -619,7 +604,6 @@ void UKF::prediction(const double delta_t, const int model_ind)
 */
 void UKF::updateLidar(const int model_ind)
 {
-  // TODO refactoring
   /*****************************************************************************
  *  Initialize model parameters
  ****************************************************************************/
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e703e6ecd8271f1a29e49851cf2e7d1259c0b6e3" author="Yuma">
		<msg>Rename waypoint_replan to velocity_replanner</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_replan.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" added_lines="13" deleted_lines="13">
				<diff>@@ -28,7 +28,7 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "waypoint_replan.h"
+#include "velocity_replanner.h"
 
 namespace waypoint_maker
 {
@@ -41,15 +41,15 @@ inline double mps2kmph(double velocity_mps)
   return (velocity_mps * 60 * 60) / 1000;
 }
 
-WaypointReplan::WaypointReplan() : private_nh_("~")
+VelocityReplanner::VelocityReplanner() : private_nh_("~")
 {
 }
 
-WaypointReplan::~WaypointReplan()
+VelocityReplanner::~VelocityReplanner()
 {
 }
 
-void WaypointReplan::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
+void VelocityReplanner::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
 {
   velocity_max_ = kmph2mps(conf-&gt;velocity_max);
   velocity_min_ = kmph2mps(conf-&gt;velocity_min);
@@ -65,7 +65,7 @@ void WaypointReplan::initParameter(const autoware_msgs::ConfigWaypointLoader::Co
   r_inf_ = 10 * r_th_;
 }
 
-void WaypointReplan::replanLaneWaypoint(autoware_msgs::lane* lane)
+void VelocityReplanner::replanLaneWaypointVel(autoware_msgs::lane* lane)
 {
   std::vector&lt;double&gt; curve_radius;
   std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt; curve_list;
@@ -120,7 +120,7 @@ void WaypointReplan::replanLaneWaypoint(autoware_msgs::lane* lane)
   }
 }
 
-void WaypointReplan::resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane)
+void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane)
 {
   if (lane-&gt;waypoints.empty())
     return;
@@ -209,7 +209,7 @@ void WaypointReplan::resampleLaneWaypoint(const double resample_interval, autowa
   lane-&gt;waypoints.back().change_flag = original_lane.waypoints.back().change_flag;
 }
 
-void WaypointReplan::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
+void VelocityReplanner::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
 {
   if (lane.waypoints.empty())
     return;
@@ -241,7 +241,7 @@ void WaypointReplan::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;do
   }
 }
 
-const double WaypointReplan::calcVelParam() const
+const double VelocityReplanner::calcVelParam() const
 {
   if(fabs(r_th_ - r_min_) &lt; 1e-8)
   {
@@ -250,7 +250,7 @@ const double WaypointReplan::calcVelParam() const
   return (velocity_max_ - velocity_min_) / (r_th_ - r_min_);
 }
 
-void WaypointReplan::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
+void VelocityReplanner::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
                                      std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list)
 {
   unsigned long index = 0;
@@ -278,7 +278,7 @@ void WaypointReplan::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
   }
 }
 
-void WaypointReplan::limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx,
+void VelocityReplanner::limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx,
                                      autoware_msgs::lane* lane)
 {
   double v = vmin_local;
@@ -305,7 +305,7 @@ void WaypointReplan::limitAccelDecel(const double vmax, const double vmin_local,
 }
 
 // get 3 parameter of curve, [center_x, center_y, radius]
-const std::vector&lt;double&gt; WaypointReplan::getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point) const
+const std::vector&lt;double&gt; VelocityReplanner::getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point) const
 {
   std::vector&lt;double&gt; curve_param(3, 0.0);
   const std::vector&lt;double&gt; dx = {point[0].x - point[1].x, point[1].x - point[2].x, point[2].x - point[0].x};
@@ -370,12 +370,12 @@ const std::vector&lt;double&gt; WaypointReplan::getCurveOnce(const std::vector&lt;geometr
   return curve_param;
 }
 
-const double WaypointReplan::calcSquareSum(const double x, const double y) const
+const double VelocityReplanner::calcSquareSum(const double x, const double y) const
 {
   return (x * x + y * y);
 }
 
-const double WaypointReplan::calcPathLength(const autoware_msgs::lane&amp; lane) const
+const double VelocityReplanner::calcPathLength(const autoware_msgs::lane&amp; lane) const
 {
   double distance = 0.0;
   for (unsigned long i = 1; i &lt; lane.waypoints.size(); i++)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_replan.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" added_lines="6" deleted_lines="6">
				<diff>@@ -28,8 +28,8 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#ifndef __WAYPOINT_REPLAN_H__
-#define __WAYPOINT_REPLAN_H__
+#ifndef __VELOCITY_REPLANNER_H__
+#define __VELOCITY_REPLANNER_H__
 
 #include &lt;ros/ros.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
@@ -41,7 +41,7 @@
 
 namespace waypoint_maker
 {
-class WaypointReplan
+class VelocityReplanner
 {
 private:
   ros::NodeHandle private_nh_;
@@ -54,10 +54,10 @@ private:
   int end_point_offset_;
 
 public:
-  WaypointReplan();
-  ~WaypointReplan();
+  VelocityReplanner();
+  ~VelocityReplanner();
   void initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
-  void replanLaneWaypoint(autoware_msgs::lane* lane);
+  void replanLaneWaypointVel(autoware_msgs::lane* lane);
 
 protected:
   void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -71,7 +71,7 @@ void WaypointLoaderNode::initParameter(const autoware_msgs::ConfigWaypointLoader
 void WaypointLoaderNode::configCallback(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
 {
   initParameter(conf);
-  replan_.initParameter(conf);
+  replanner_.initParameter(conf);
 
   multi_file_path_.clear();
   parseColumns(multi_lane_csv_, &amp;multi_file_path_);
@@ -113,7 +113,7 @@ void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt;&amp; paths,
     autoware_msgs::lane lane;
     createLaneWaypoint(el, &amp;lane);
     if (replanning_mode_)
-      replan_.replanLaneWaypoint(&amp;lane);
+      replanner_.replanLaneWaypointVel(&amp;lane);
     lane_array-&gt;lanes.push_back(lane);
   }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -43,7 +43,7 @@
 #include &lt;unordered_map&gt;
 
 #include "autoware_msgs/LaneArray.h"
-#include "waypoint_replan.h"
+#include "velocity_replanner.h"
 
 namespace waypoint_maker
 {
@@ -89,7 +89,7 @@ private:
   std::string multi_lane_csv_;
   bool disable_decision_maker_;
   bool replanning_mode_;
-  WaypointReplan replan_;
+  VelocityReplanner replanner_;
   std::vector&lt;std::string&gt; multi_file_path_;
   autoware_msgs::LaneArray output_lane_array_;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ba8c899faed8f2f5764ee619688bb93506aad336" author="Yuma">
		<msg>Optimize radius-calculate-method</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" added_lines="32" deleted_lines="78">
				<diff>@@ -72,7 +72,7 @@ void VelocityReplanner::replanLaneWaypointVel(autoware_msgs::lane* lane)
 
   if (resample_mode_)
     resampleLaneWaypoint(resample_interval_, lane);
-  getCurveAll(*lane, &amp;curve_radius);
+  getRadiusList(*lane, &amp;curve_radius);
   const double vel_param = calcVelParam();
   createCurveList(curve_radius, &amp;curve_list);
   if (vel_param == DBL_MAX)
@@ -134,13 +134,13 @@ void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, aut
   const unsigned int n = (lookup_crv_width_ - 1) / 2;
   for (unsigned long i = 1; i &lt; original_lane.waypoints.size(); i++)
   {
-    std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
-    curve_point[0] = (lane-&gt;waypoints.size() &lt; n) ? lane-&gt;waypoints[0].pose.pose.position :
-                                                    lane-&gt;waypoints[lane-&gt;waypoints.size() - n].pose.pose.position;
-    curve_point[1] = original_lane.waypoints[i].pose.pose.position;
-    curve_point[2] = (i &gt;= original_lane.waypoints.size() - n) ? original_lane.waypoints.back().pose.pose.position :
-                                                                 original_lane.waypoints[i + n].pose.pose.position;
-    const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
+    boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point(3);
+    curve_point.push_back((lane-&gt;waypoints.size() &lt; n) ? lane-&gt;waypoints[0].pose.pose.position :
+                                                         lane-&gt;waypoints[lane-&gt;waypoints.size() - n].pose.pose.position);
+    curve_point.push_back(original_lane.waypoints[i].pose.pose.position);
+    curve_point.push_back((i &gt;= original_lane.waypoints.size() - n) ? original_lane.waypoints.back().pose.pose.position :
+                                                                      original_lane.waypoints[i + n].pose.pose.position);
+    const std::vector&lt;double&gt; curve_param = getCurveParam(curve_point);
     // if going straight
     if (curve_param.empty())
     {
@@ -171,7 +171,6 @@ void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, aut
       const double&amp; cx = curve_param[0];
       const double&amp; cy = curve_param[1];
       const double&amp; radius = curve_param[2];
-      const double threshold_radius = (radius &gt; r_inf_) ? r_inf_ : radius;
 
       const geometry_msgs::Point&amp; p0 = lane-&gt;waypoints.back().pose.pose.position;
       const geometry_msgs::Point&amp; p1 = curve_point[1];
@@ -209,7 +208,7 @@ void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, aut
   lane-&gt;waypoints.back().change_flag = original_lane.waypoints.back().change_flag;
 }
 
-void VelocityReplanner::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
+void VelocityReplanner::getRadiusList(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
 {
   if (lane.waypoints.empty())
     return;
@@ -221,12 +220,12 @@ void VelocityReplanner::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector
   {
     //Three points used for curve detection (the target point is the center)
     //[0] = previous point, [1] = target point, [2] = next point
-    std::vector&lt;geometry_msgs::Point&gt; curve_point(3);
-    curve_point[0] = (i &lt; n) ? lane.waypoints[0].pose.pose.position : lane.waypoints[i - n].pose.pose.position;
-    curve_point[1] = lane.waypoints[i].pose.pose.position;
-    curve_point[2] = (i &gt;= lane.waypoints.size() - n) ? lane.waypoints.back().pose.pose.position :
-                                                        lane.waypoints[i + n].pose.pose.position;
-    const std::vector&lt;double&gt; curve_param = getCurveOnce(curve_point);
+    boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point(3);
+    curve_point.push_back((i &lt; n) ? lane.waypoints[0].pose.pose.position : lane.waypoints[i - n].pose.pose.position);
+    curve_point.push_back(lane.waypoints[i].pose.pose.position);
+    curve_point.push_back((i &gt;= lane.waypoints.size() - n) ? lane.waypoints.back().pose.pose.position :
+                                                             lane.waypoints[i + n].pose.pose.position);
+    const std::vector&lt;double&gt; curve_param = getCurveParam(curve_point);
     // if going straight
     if (curve_param.empty())
     {
@@ -243,7 +242,7 @@ void VelocityReplanner::getCurveAll(const autoware_msgs::lane&amp; lane, std::vector
 
 const double VelocityReplanner::calcVelParam() const
 {
-  if(fabs(r_th_ - r_min_) &lt; 1e-8)
+  if (fabs(r_th_ - r_min_) &lt; 1e-8)
   {
     return DBL_MAX;//error
   }
@@ -304,70 +303,25 @@ void VelocityReplanner::limitAccelDecel(const double vmax, const double vmin_loc
   }
 }
 
-// get 3 parameter of curve, [center_x, center_y, radius]
-const std::vector&lt;double&gt; VelocityReplanner::getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point) const
+// get curve 3-Parameter [center_x, center_y, radius] with 3 point input. If error occured, return empty vector.
+const std::vector&lt;double&gt; VelocityReplanner::getCurveParam(boost::circular_buffer&lt;geometry_msgs::Point&gt; p) const
 {
-  std::vector&lt;double&gt; curve_param(3, 0.0);
-  const std::vector&lt;double&gt; dx = {point[0].x - point[1].x, point[1].x - point[2].x, point[2].x - point[0].x};
-  const std::vector&lt;double&gt; dy = {point[0].y - point[1].y, point[1].y - point[2].y, point[2].y - point[0].y};
-  std::vector&lt;double&gt; dist(3);
-  // exclude identical points
-  for (int i = 0; i &lt; 3; i++)
+  for (int i = 0; i &lt; 3; i++, p.push_back(p.front()))//if exception occured, change points order
   {
-    dist[i] = sqrt(dx[i] * dx[i] + dy[i] * dy[i]);
-    if (dist[i] &lt; 1e-8)
-      return std::vector&lt;double&gt;();
+    const double d = 2 * ((p[0].y - p[2].y) * (p[0].x - p[1].x) - (p[0].y - p[1].y) * (p[0].x - p[2].x));
+    if (fabs(d) &lt; 1e-8)continue;
+    const std::vector&lt;double&gt; x2 = { p[0].x * p[0].x, p[1].x * p[1].x, p[2].x * p[2].x };
+    const std::vector&lt;double&gt; y2 = { p[0].y * p[0].y, p[1].y * p[1].y, p[2].y * p[2].y };
+    const double a = y2[0] - y2[1] + x2[0] - x2[1];
+    const double b = y2[0] - y2[2] + x2[0] - x2[2];
+    std::vector&lt;double&gt; param(3);
+    const double cx = param[0] = ((p[0].y - p[2].y) * a - (p[0].y - p[1].y) * b) / d;
+    const double cy = param[1] = ((p[0].x - p[2].x) * a - (p[0].x - p[1].x) * b) / -d;
+    param[2] = sqrt((cx - p[0].x) * (cx - p[0].x) + (cy - p[0].y) * (cy - p[0].y));
+    return param;
   }
-
-  // exclude identical x,y
-  int valid_dx_cnt = 0;
-  int valid_dy_cnt = 0;
-  int valid_dx_index, valid_dy_index;
-  for(int i = 0; i &lt; 3; i++)
-  {
-    if(fabs(dx[i]) &gt; 1e-8)
-    {
-      valid_dx_cnt++;
-      valid_dx_index = i;
-    }
-    if(fabs(dy[i]) &gt; 1e-8)
-    {
-      valid_dy_cnt++;
-      valid_dy_index = i;
-    }
-  }
-  if (valid_dx_cnt == 0 || valid_dy_cnt == 0)
-    return std::vector&lt;double&gt;();
-
-  // exclude idential line
-  const double cross_prod = dx[0] * dy[1] - dx[1] * dy[0];
-  if (asin(fabs(cross_prod) / (dist[0] * dist[1])) &lt; 1e-8)
-    return std::vector&lt;double&gt;();
-
-  //
-  std::vector&lt;double&gt; sq_diff(3);
-  {
-    std::vector&lt;double&gt; sx = {point[0].x + point[1].x, point[1].x + point[2].x, point[2].x + point[0].x};
-    std::vector&lt;double&gt; sy = {point[0].y + point[1].y, point[1].y + point[2].y, point[2].y + point[0].y};
-    std::transform(sx.begin(), sx.end(), dx.begin(), sx.begin(), std::multiplies&lt;double&gt;());
-    std::transform(sy.begin(), sy.end(), dy.begin(), sy.begin(), std::multiplies&lt;double&gt;());
-    std::transform(sx.begin(), sx.end(), sy.begin(), sq_diff.begin(), std::plus&lt;double&gt;());
-  }
-  if(valid_dx_cnt &lt; valid_dy_cnt)
-  {
-    curve_param[0] = - 0.5 / cross_prod * (dy[0] * sq_diff[1] - dy[1] * sq_diff[0]);
-    const int&amp; idx = valid_dy_index;
-    curve_param[1] = 0.5 / dy[idx] * (sq_diff[idx] - 2 * dx[idx] * curve_param[0]);
-  }
-  else
-  {
-    curve_param[1] = 0.5 / cross_prod * (dx[0] * sq_diff[1] - dx[1] * sq_diff[0]);
-    const int&amp; idx = valid_dx_index;
-    curve_param[0] = 0.5 / dx[idx] * (sq_diff[idx] - 2 * dy[idx] * curve_param[1]);
-  }
-  curve_param[2] = sqrt(calcSquareSum(point[0].x - curve_param[0], point[0].y - curve_param[1]));
-
-  return curve_param;
+  ROS_ERROR("error is occured");
+  return std::vector&lt;double&gt;();//error
 }
 
 const double VelocityReplanner::calcSquareSum(const double x, const double y) const
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" added_lines="3" deleted_lines="2">
				<diff>@@ -37,6 +37,7 @@
 #include &lt;fstream&gt;
 #include &lt;unordered_map&gt;
 #include &lt;algorithm&gt;
+#include &lt;boost/circular_buffer.hpp&gt;
 #include "autoware_msgs/lane.h"
 
 namespace waypoint_maker
@@ -61,12 +62,12 @@ public:
 
 protected:
   void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane);
-  void getCurveAll(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius);
+  void getRadiusList(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius);
   const double calcVelParam() const;
   void createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
                        std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list);
   void limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx, autoware_msgs::lane* lane);
-  const std::vector&lt;double&gt; getCurveOnce(const std::vector&lt;geometry_msgs::Point&gt;&amp; point) const;
+  const std::vector&lt;double&gt; getCurveParam(boost::circular_buffer&lt;geometry_msgs::Point&gt; point) const;
   const double calcSquareSum(const double x, const double y) const;
   const double calcPathLength(const autoware_msgs::lane&amp; lane) const;
 };
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="939f15d45963c64121fad2839d60b2fc51bff8d1" author="Yuma">
		<msg>Optimize accel_decel_limitation_method</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" added_lines="20" deleted_lines="31">
				<diff>@@ -72,7 +72,7 @@ void VelocityReplanner::replanLaneWaypointVel(autoware_msgs::lane* lane)
 
   if (resample_mode_)
     resampleLaneWaypoint(resample_interval_, lane);
-  getRadiusList(*lane, &amp;curve_radius);
+  createRadiusList(*lane, &amp;curve_radius);
   const double vel_param = calcVelParam();
   createCurveList(curve_radius, &amp;curve_list);
   if (vel_param == DBL_MAX)
@@ -140,7 +140,7 @@ void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, aut
     curve_point.push_back(original_lane.waypoints[i].pose.pose.position);
     curve_point.push_back((i &gt;= original_lane.waypoints.size() - n) ? original_lane.waypoints.back().pose.pose.position :
                                                                       original_lane.waypoints[i + n].pose.pose.position);
-    const std::vector&lt;double&gt; curve_param = getCurveParam(curve_point);
+    const std::vector&lt;double&gt; curve_param = calcCurveParam(curve_point);
     // if going straight
     if (curve_param.empty())
     {
@@ -152,7 +152,7 @@ void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, aut
       const std::vector&lt;double&gt; nvec = { curve_point[1].x - wp.pose.pose.position.x,
                                          curve_point[1].y - wp.pose.pose.position.y,
                                          curve_point[1].z - wp.pose.pose.position.z };
-      double dist = sqrt(calcSquareSum(nvec[0], nvec[1]));
+      double dist = sqrt(nvec[0] * nvec[0] + nvec[1] * nvec[1]);
       const tf::Vector3 resample_vec(resample_interval_ * nvec[0] / dist, resample_interval_ * nvec[1] / dist,
                                      resample_interval_ * nvec[2] / dist);
       for (; dist &gt; resample_interval_; dist -= resample_interval_)
@@ -208,7 +208,7 @@ void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, aut
   lane-&gt;waypoints.back().change_flag = original_lane.waypoints.back().change_flag;
 }
 
-void VelocityReplanner::getRadiusList(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
+void VelocityReplanner::createRadiusList(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
 {
   if (lane.waypoints.empty())
     return;
@@ -225,7 +225,7 @@ void VelocityReplanner::getRadiusList(const autoware_msgs::lane&amp; lane, std::vect
     curve_point.push_back(lane.waypoints[i].pose.pose.position);
     curve_point.push_back((i &gt;= lane.waypoints.size() - n) ? lane.waypoints.back().pose.pose.position :
                                                              lane.waypoints[i + n].pose.pose.position);
-    const std::vector&lt;double&gt; curve_param = getCurveParam(curve_point);
+    const std::vector&lt;double&gt; curve_param = calcCurveParam(curve_point);
     // if going straight
     if (curve_param.empty())
     {
@@ -280,31 +280,26 @@ void VelocityReplanner::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
 void VelocityReplanner::limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx,
                                      autoware_msgs::lane* lane)
 {
-  double v = vmin_local;
-  for (unsigned long i = 1;; i++)
+  const double acc[2] = {accel_limit_, decel_limit_};
+  const unsigned long end_idx[2] = {lane-&gt;waypoints.size() - idx - 1, idx};
+  const int sgn[2] = {1, -1};
+  for (int j = 0; j &lt; 2; j++)// [j=0]: accel_limit_process, [j=1]: decel_limit_process
   {
-    v = sqrt(2 * accel_limit_ * resample_interval_ + v * v);
-    if (i &gt; lane-&gt;waypoints.size() - idx - 1 || v &gt; vmax)
-      break;
-    if (lane-&gt;waypoints[idx + i].twist.twist.linear.x &lt; v)
-      break;
-    lane-&gt;waypoints[idx + i].twist.twist.linear.x = v;
-  }
-
-  v = vmin_local;
-  for (unsigned long i = 1;; i++)
-  {
-    v = sqrt(2 * decel_limit_ * resample_interval_ + v * v);
-    if (i &gt; idx || v &gt; vmax)
-      break;
-    if (lane-&gt;waypoints[idx - i].twist.twist.linear.x &lt; v)
-      break;
-    lane-&gt;waypoints[idx - i].twist.twist.linear.x = v;
+    double v = vmin_local;
+    for (unsigned long i = 1;; i++)
+    {
+      v = sqrt(2 * acc[j] * resample_interval_ + v * v);
+      if (i &gt; end_idx[j] || v &gt; vmax)
+        break;
+      if (lane-&gt;waypoints[idx + sgn[j] * i].twist.twist.linear.x &lt; v)
+        break;
+      lane-&gt;waypoints[idx + sgn[j] * i].twist.twist.linear.x = v;
+    }
   }
 }
 
 // get curve 3-Parameter [center_x, center_y, radius] with 3 point input. If error occured, return empty vector.
-const std::vector&lt;double&gt; VelocityReplanner::getCurveParam(boost::circular_buffer&lt;geometry_msgs::Point&gt; p) const
+const std::vector&lt;double&gt; VelocityReplanner::calcCurveParam(boost::circular_buffer&lt;geometry_msgs::Point&gt; p) const
 {
   for (int i = 0; i &lt; 3; i++, p.push_back(p.front()))//if exception occured, change points order
   {
@@ -320,15 +315,9 @@ const std::vector&lt;double&gt; VelocityReplanner::getCurveParam(boost::circular_buffe
     param[2] = sqrt((cx - p[0].x) * (cx - p[0].x) + (cy - p[0].y) * (cy - p[0].y));
     return param;
   }
-  ROS_ERROR("error is occured");
   return std::vector&lt;double&gt;();//error
 }
 
-const double VelocityReplanner::calcSquareSum(const double x, const double y) const
-{
-  return (x * x + y * y);
-}
-
 const double VelocityReplanner::calcPathLength(const autoware_msgs::lane&amp; lane) const
 {
   double distance = 0.0;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" added_lines="2" deleted_lines="3">
				<diff>@@ -62,13 +62,12 @@ public:
 
 protected:
   void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane);
-  void getRadiusList(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius);
+  void createRadiusList(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius);
   const double calcVelParam() const;
   void createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
                        std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list);
   void limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx, autoware_msgs::lane* lane);
-  const std::vector&lt;double&gt; getCurveParam(boost::circular_buffer&lt;geometry_msgs::Point&gt; point) const;
-  const double calcSquareSum(const double x, const double y) const;
+  const std::vector&lt;double&gt; calcCurveParam(boost::circular_buffer&lt;geometry_msgs::Point&gt; point) const;
   const double calcPathLength(const autoware_msgs::lane&amp; lane) const;
 };
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6663224a4d680b442b392baa893a1e29e44b53b5" author="Yuma">
		<msg>Move calculate method of velocity param to init_config</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -63,23 +63,23 @@ void VelocityReplanner::initParameter(const autoware_msgs::ConfigWaypointLoader:
   velocity_offset_ = conf-&gt;velocity_offset;
   end_point_offset_ = conf-&gt;end_point_offset;
   r_inf_ = 10 * r_th_;
+  vel_param_ = calcVelParam();
 }
 
 void VelocityReplanner::replanLaneWaypointVel(autoware_msgs::lane* lane)
 {
+  if (vel_param_ == DBL_MAX)
+  {
+    ROS_ERROR("velocity parameter is invalid: please change Rth or Rmin");
+    return;
+  }
   std::vector&lt;double&gt; curve_radius;
   std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt; curve_list;
 
   if (resample_mode_)
     resampleLaneWaypoint(resample_interval_, lane);
   createRadiusList(*lane, &amp;curve_radius);
-  const double vel_param = calcVelParam();
   createCurveList(curve_radius, &amp;curve_list);
-  if (vel_param == DBL_MAX)
-  {
-    ROS_ERROR("velocity parameter is invalid: please change Rth or Rmin");
-    return;
-  }
   // set velocity_max for all_point
   for (auto&amp; el : lane-&gt;waypoints)
     el.twist.twist.linear.x = velocity_max_;
@@ -90,7 +90,7 @@ void VelocityReplanner::replanLaneWaypointVel(autoware_msgs::lane* lane)
     const unsigned long end_idx = (el.second.first &gt; velocity_offset_) ? (el.second.first - velocity_offset_) : 0;
     const double radius = el.second.second;
     const double vmax = velocity_max_;
-    const double vmin = velocity_max_ - vel_param * (r_th_ - radius);
+    const double vmin = velocity_max_ - vel_param_ * (r_th_ - radius);
     for (unsigned long idx = start_idx; idx &lt;= end_idx; idx++)
     {
       if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" added_lines="1" deleted_lines="0">
				<diff>@@ -53,6 +53,7 @@ private:
   int velocity_offset_;
   bool resample_mode_;
   int end_point_offset_;
+  double vel_param_;
 
 public:
   VelocityReplanner();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e13ca8d38fca4c69f005e7d331a28252c4b3bbe5" author="Yuma">
		<msg>Split the velocity limit method.</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" added_lines="31" deleted_lines="40">
				<diff>@@ -83,41 +83,16 @@ void VelocityReplanner::replanLaneWaypointVel(autoware_msgs::lane* lane)
   // set velocity_max for all_point
   for (auto&amp; el : lane-&gt;waypoints)
     el.twist.twist.linear.x = velocity_max_;
-  // set curve_velocity on curve begining
+  // set velocity by curve
   for (const auto&amp; el : curve_list)
   {
-    const unsigned long start_idx = (el.first &gt; velocity_offset_) ? (el.first - velocity_offset_) : 0;
-    const unsigned long end_idx = (el.second.first &gt; velocity_offset_) ? (el.second.first - velocity_offset_) : 0;
-    const double radius = el.second.second;
-    const double vmax = velocity_max_;
+    const double&amp; radius = el.second.second;
     const double vmin = velocity_max_ - vel_param_ * (r_th_ - radius);
-    for (unsigned long idx = start_idx; idx &lt;= end_idx; idx++)
-    {
-      if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
-        continue;
-      lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
-    }
-    limitAccelDecel(vmax, vmin, start_idx, lane);
-    limitAccelDecel(vmax, vmin, end_idx, lane);
-  }
-  unsigned long end_id[2] = { 0, lane-&gt;waypoints.size() - 1 - end_point_offset_};
-  for (int i = 0; i &lt; 2; i++)
-  {
-    const unsigned long idx = end_id[i];
-    const double vmax = velocity_max_;
-    const double vmin = (i == 0) ? velocity_min_ : 0.0;
-    if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
-      continue;
-    lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
-    if (i == 1)
-    {
-      for (int j = 0; j &lt; end_point_offset_; j++)
-      {
-        lane-&gt;waypoints[idx + j + 1].twist.twist.linear.x = vmin;
-      }
-    }
-    limitAccelDecel(vmax, vmin, idx, lane);
+    limitVelocityByRange(el.first, el.second.first, velocity_offset_, vmin, lane);
   }
+  //set velocity on start &amp; end of lane
+  limitVelocityByRange(0, 0, 0, velocity_min_, lane);
+  limitVelocityByRange(lane-&gt;waypoints.size() - 1 - end_point_offset_, lane-&gt;waypoints.size() - 1, 0, 0.0, lane);
 }
 
 void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane)
@@ -277,23 +252,39 @@ void VelocityReplanner::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
   }
 }
 
-void VelocityReplanner::limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx,
-                                     autoware_msgs::lane* lane)
+void VelocityReplanner::limitVelocityByRange(unsigned long start_idx, unsigned long end_idx, unsigned int offset,
+                          double vmin, autoware_msgs::lane* lane)
+{
+  if(offset &gt; 0)
+  {
+    start_idx = (start_idx &gt; offset) ? (start_idx - offset) : 0;
+    end_idx = (end_idx &gt; offset) ? (end_idx - offset) : 0;
+  }
+  for (unsigned long idx = start_idx; idx &lt;= end_idx; idx++)
+  {
+    if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
+    continue;
+    lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
+  }
+  limitAccelDecel(start_idx, lane);
+  limitAccelDecel(end_idx, lane);
+}
+
+void VelocityReplanner::limitAccelDecel(const unsigned long idx, autoware_msgs::lane* lane)
 {
   const double acc[2] = {accel_limit_, decel_limit_};
-  const unsigned long end_idx[2] = {lane-&gt;waypoints.size() - idx - 1, idx};
+  const unsigned long end_idx[2] = {lane-&gt;waypoints.size() - idx, idx + 1};
   const int sgn[2] = {1, -1};
   for (int j = 0; j &lt; 2; j++)// [j=0]: accel_limit_process, [j=1]: decel_limit_process
   {
-    double v = vmin_local;
-    for (unsigned long i = 1;; i++)
+    double v = lane-&gt;waypoints[idx].twist.twist.linear.x;
+    unsigned long next = idx + sgn[j];
+    for (unsigned long i = 1; i &lt; end_idx[j]; i++, next += sgn[j])
     {
       v = sqrt(2 * acc[j] * resample_interval_ + v * v);
-      if (i &gt; end_idx[j] || v &gt; vmax)
-        break;
-      if (lane-&gt;waypoints[idx + sgn[j] * i].twist.twist.linear.x &lt; v)
+      if (v &gt; velocity_max_ || v &gt; lane-&gt;waypoints[next].twist.twist.linear.x)
         break;
-      lane-&gt;waypoints[idx + sgn[j] * i].twist.twist.linear.x = v;
+      lane-&gt;waypoints[next].twist.twist.linear.x = v;
     }
   }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" added_lines="3" deleted_lines="1">
				<diff>@@ -67,7 +67,9 @@ protected:
   const double calcVelParam() const;
   void createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
                        std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list);
-  void limitAccelDecel(const double vmax, const double vmin_local, const unsigned long idx, autoware_msgs::lane* lane);
+  void limitVelocityByRange(unsigned long start_idx, unsigned long end_idx, unsigned int offset,
+                            double vmin, autoware_msgs::lane* lane);
+  void limitAccelDecel(const unsigned long idx, autoware_msgs::lane* lane);
   const std::vector&lt;double&gt; calcCurveParam(boost::circular_buffer&lt;geometry_msgs::Point&gt; point) const;
   const double calcPathLength(const autoware_msgs::lane&amp; lane) const;
 };
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e3e1611f862747cb95b9eb1c50de6b79ea62d989" author="Alexander Carballo">
		<msg>[fix] kitti_player publisher add sequence number to header</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\kitti_pkg\kitti_player\src\kitti_player.cpp" new_path="ros\src\util\packages\kitti_pkg\kitti_player\src\kitti_player.cpp" added_lines="2" deleted_lines="0">
				<diff>@@ -119,6 +119,7 @@ int publish_velodyne(ros::Publisher &amp;pub, string infile, std_msgs::Header *heade
 
         pc2.header.frame_id= "velodyne"; //ros::this_node::getName();
         pc2.header.stamp=header-&gt;stamp;
+        pc2.header.seq=header-&gt;seq;
         points-&gt;header = pcl_conversions::toPCL(pc2.header);
         pub.publish(points);
 
@@ -1225,6 +1226,7 @@ int main(int argc, char **argv)
                 timestamps.seekg(30*entries_played);
                 getline(timestamps,str_support);
                 header_support.stamp = parseTime(str_support).stamp;
+                header_support.seq = progress.count();
                 publish_velodyne(map_pub, full_filename_velodyne,&amp;header_support);
             }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="eae8d93c7ac6617cf850161f18b6d539a15ef0e5" author="Yuma">
		<msg>Split resample method</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" added_lines="107" deleted_lines="88">
				<diff>@@ -102,80 +102,18 @@ void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, aut
   autoware_msgs::lane original_lane = *lane;
   lane-&gt;waypoints.clear();
   lane-&gt;waypoints.push_back(original_lane.waypoints[0]);
-  double original_len = calcPathLength(original_lane);
-  unsigned long waypoints_size = ceil(1.5 * original_len / resample_interval_);
-  lane-&gt;waypoints.reserve(waypoints_size);
+  lane-&gt;waypoints.reserve(ceil(1.5 * calcPathLength(original_lane) / resample_interval_));
 
-  const unsigned int n = (lookup_crv_width_ - 1) / 2;
   for (unsigned long i = 1; i &lt; original_lane.waypoints.size(); i++)
   {
-    boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point(3);
-    curve_point.push_back((lane-&gt;waypoints.size() &lt; n) ? lane-&gt;waypoints[0].pose.pose.position :
-                                                         lane-&gt;waypoints[lane-&gt;waypoints.size() - n].pose.pose.position);
-    curve_point.push_back(original_lane.waypoints[i].pose.pose.position);
-    curve_point.push_back((i &gt;= original_lane.waypoints.size() - n) ? original_lane.waypoints.back().pose.pose.position :
-                                                                      original_lane.waypoints[i + n].pose.pose.position);
+    boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point = getCrvPointsOnResample(*lane, original_lane, i);
     const std::vector&lt;double&gt; curve_param = calcCurveParam(curve_point);
-    // if going straight
-    if (curve_param.empty())
-    {
-      const std::vector&lt;double&gt; vec = { curve_point[2].x - curve_point[0].x, curve_point[2].y - curve_point[0].y };
-      autoware_msgs::waypoint wp;
-      wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
-      wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(atan2(vec[1], vec[0]));
-      wp.change_flag = lane-&gt;waypoints.back().change_flag;
-      const std::vector&lt;double&gt; nvec = { curve_point[1].x - wp.pose.pose.position.x,
-                                         curve_point[1].y - wp.pose.pose.position.y,
-                                         curve_point[1].z - wp.pose.pose.position.z };
-      double dist = sqrt(nvec[0] * nvec[0] + nvec[1] * nvec[1]);
-      const tf::Vector3 resample_vec(resample_interval_ * nvec[0] / dist, resample_interval_ * nvec[1] / dist,
-                                     resample_interval_ * nvec[2] / dist);
-      for (; dist &gt; resample_interval_; dist -= resample_interval_)
-      {
-        if (lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())
-          break;
-        wp.pose.pose.position.x += resample_vec.x();
-        wp.pose.pose.position.y += resample_vec.y();
-        wp.pose.pose.position.z += resample_vec.z();
-        lane-&gt;waypoints.push_back(wp);
-      }
-    }
-    // else if turnning curve
-    else
-    {
-      const double&amp; cx = curve_param[0];
-      const double&amp; cy = curve_param[1];
-      const double&amp; radius = curve_param[2];
 
-      const geometry_msgs::Point&amp; p0 = lane-&gt;waypoints.back().pose.pose.position;
-      const geometry_msgs::Point&amp; p1 = curve_point[1];
-      double theta = fmod(atan2(p1.y - cy, p1.x - cx) - atan2(p0.y - cy, p0.x - cx), 2 * M_PI);
-      if (theta &gt; M_PI)
-        theta -= 2 * M_PI;
-      else if (theta &lt; -M_PI)
-        theta += 2 * M_PI;
-      // interport
-      double t = atan2(p0.y - cy, p0.x - cx);
-      autoware_msgs::waypoint wp;
-      wp.pose.pose.position = lane-&gt;waypoints.back().pose.pose.position;
-      wp.change_flag = lane-&gt;waypoints.back().change_flag;
-      double dist = radius * fabs(theta);
-      double dz_nextpt = curve_point[1].z - lane-&gt;waypoints.back().pose.pose.position.z;
-      const double resample_dz = resample_interval_ * dz_nextpt / dist;
-      for (; dist &gt; resample_interval_; dist -= resample_interval_)
-      {
-        if (lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())
-          break;
-        const int sign = (theta &gt; 0.0) ? (1) : (-1);
-        t += sign * resample_interval_ / radius;
-        const double yaw = fmod(t + sign * M_PI / 2.0, 2 * M_PI);
-        wp.pose.pose.position.x = cx + radius * cos(t);
-        wp.pose.pose.position.y = cy + radius * sin(t);
-        wp.pose.pose.position.z += resample_dz;
-        wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
-        lane-&gt;waypoints.push_back(wp);
-      }
-    }
+    if (curve_param.empty())// if going straight
+      resampleOnStraight(curve_point, lane);
+    else// else if turnning curve
+      resampleOnCurve(curve_point[1], curve_param, lane);
+
     lane-&gt;waypoints.back().wpstate = original_lane.waypoints[i].wpstate;
     lane-&gt;waypoints.back().change_flag = original_lane.waypoints[i].change_flag;
   }
@@ -183,6 +121,100 @@ void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, aut
   lane-&gt;waypoints.back().change_flag = original_lane.waypoints.back().change_flag;
 }
 
+
+void VelocityReplanner::resampleOnStraight(const boost::circular_buffer&lt;geometry_msgs::Point&gt;&amp; curve_point, autoware_msgs::lane* lane)
+{
+  autoware_msgs::waypoint wp = lane-&gt;waypoints.back();
+  const geometry_msgs::Point&amp; pt= wp.pose.pose.position;
+  const double yaw = atan2(curve_point[2].y - curve_point[0].y, curve_point[2].x - curve_point[0].x);
+  wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
+
+  const std::vector&lt;double&gt; nvec = { curve_point[1].x - pt.x, curve_point[1].y - pt.y, curve_point[1].z - pt.z };
+  double dist = sqrt(nvec[0] * nvec[0] + nvec[1] * nvec[1]);
+  std::vector&lt;double&gt; resample_vec = nvec;
+  const double coeff = resample_interval_ / dist;
+  for (auto&amp; el : resample_vec)
+    el *= coeff;
+  for (; dist &gt; resample_interval_; dist -= resample_interval_)
+  {
+    wp.pose.pose.position.x += resample_vec[0];
+    wp.pose.pose.position.y += resample_vec[1];
+    wp.pose.pose.position.z += resample_vec[2];
+    lane-&gt;waypoints.push_back(wp);
+  }
+}
+
+
+void VelocityReplanner::resampleOnCurve(const geometry_msgs::Point&amp; target_point, const std::vector&lt;double&gt;&amp; curve_param, autoware_msgs::lane* lane)
+{
+  autoware_msgs::waypoint wp = lane-&gt;waypoints.back();
+  const double&amp; cx = curve_param[0];
+  const double&amp; cy = curve_param[1];
+  const double&amp; radius = curve_param[2];
+
+  const geometry_msgs::Point&amp; p0 = wp.pose.pose.position;
+  const geometry_msgs::Point&amp; p1 = target_point;
+  double theta = fmod(atan2(p1.y - cy, p1.x - cx) - atan2(p0.y - cy, p0.x - cx), 2 * M_PI);
+  int sgn = (theta &gt; 0.0) ? (1) : (-1);
+  if (fabs(theta) &gt; M_PI)
+    theta -= 2 * sgn * M_PI;
+  sgn = (theta &gt; 0.0) ? (1) : (-1);
+  // interport
+  double t = atan2(p0.y - cy, p0.x - cx);
+  double dist = radius * fabs(theta);
+  const double resample_dz = resample_interval_ * (p1.z - p0.z) / dist;
+  for (; dist &gt; resample_interval_; dist -= resample_interval_)
+  {
+    if (lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())
+      break;
+    t += sgn * resample_interval_ / radius;
+    const double yaw = fmod(t + sgn * M_PI / 2.0, 2 * M_PI);
+    wp.pose.pose.position.x = cx + radius * cos(t);
+    wp.pose.pose.position.y = cy + radius * sin(t);
+    wp.pose.pose.position.z += resample_dz;
+    wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
+    lane-&gt;waypoints.push_back(wp);
+  }
+}
+
+
+//Three points used for curve detection (the target point is the center)
+//[0] = previous point, [1] = target point, [2] = next point
+const boost::circular_buffer&lt;geometry_msgs::Point&gt;
+  VelocityReplanner::getCrvPointsOnResample(const autoware_msgs::lane&amp; lane, const autoware_msgs::lane&amp; original_lane, unsigned long original_index) const
+{
+  unsigned long id = original_index;
+  boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point(3);
+  const unsigned int n = (lookup_crv_width_ - 1) / 2;
+  const autoware_msgs::waypoint cp[3] =
+  {
+    (lane.waypoints.size() &lt; n) ? lane.waypoints.front() : lane.waypoints[lane.waypoints.size() - n],
+    original_lane.waypoints[id],
+    (id &lt; original_lane.waypoints.size() - n) ? original_lane.waypoints[id + n] : original_lane.waypoints.back()
+  };
+  for (int i = 0; i &lt; 3; i++)
+    curve_point.push_back(cp[i].pose.pose.position);
+  return curve_point;
+}
+
+const boost::circular_buffer&lt;geometry_msgs::Point&gt;
+  VelocityReplanner::getCrvPoints(const autoware_msgs::lane&amp; lane, unsigned long index) const
+{
+  boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point(3);
+  const unsigned int n = (lookup_crv_width_ - 1) / 2;
+  const unsigned long curve_index[3] =
+  {
+    (index &lt; n) ? 0 : (index - n),
+    index,
+    (index &gt;= lane.waypoints.size() - n) ? (lane.waypoints.size() - 1) : (index + n)
+  };
+  for (int i = 0; i &lt; 3; i++)
+    curve_point.push_back(lane.waypoints[curve_index[i]].pose.pose.position);
+  return curve_point;
+}
+
+
+
 void VelocityReplanner::createRadiusList(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
 {
   if (lane.waypoints.empty())
@@ -190,28 +222,15 @@ void VelocityReplanner::createRadiusList(const autoware_msgs::lane&amp; lane, std::v
   curve_radius-&gt;resize(lane.waypoints.size());
   curve_radius-&gt;at(0) = curve_radius-&gt;back() = r_inf_;
 
-  const unsigned int n = (lookup_crv_width_ - 1) / 2;
   for (unsigned long i = 1; i &lt; lane.waypoints.size() - 1; i++)
   {
-    //Three points used for curve detection (the target point is the center)
-    //[0] = previous point, [1] = target point, [2] = next point
-    boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point(3);
-    curve_point.push_back((i &lt; n) ? lane.waypoints[0].pose.pose.position : lane.waypoints[i - n].pose.pose.position);
-    curve_point.push_back(lane.waypoints[i].pose.pose.position);
-    curve_point.push_back((i &gt;= lane.waypoints.size() - n) ? lane.waypoints.back().pose.pose.position :
-                                                             lane.waypoints[i + n].pose.pose.position);
+    boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point = getCrvPoints(lane, i);
     const std::vector&lt;double&gt; curve_param = calcCurveParam(curve_point);
-    // if going straight
-    if (curve_param.empty())
-    {
+
+    if (curve_param.empty())// if going straight
       curve_radius-&gt;at(i) = r_inf_;
-    }
-    // else if turnning curve
-    else
-    {
-      const double&amp; radius = curve_param[2];
-      curve_radius-&gt;at(i) = (radius &gt; r_inf_) ? r_inf_ : radius;
-    }
+    else// else if turnning curve
+      curve_radius-&gt;at(i) = (curve_param[2] &gt; r_inf_) ? r_inf_ : curve_param[2];
   }
 }
 
@@ -255,7 +274,7 @@ void VelocityReplanner::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
 void VelocityReplanner::limitVelocityByRange(unsigned long start_idx, unsigned long end_idx, unsigned int offset,
                           double vmin, autoware_msgs::lane* lane)
 {
-  if(offset &gt; 0)
+  if (offset &gt; 0)
   {
     start_idx = (start_idx &gt; offset) ? (start_idx - offset) : 0;
     end_idx = (end_idx &gt; offset) ? (end_idx - offset) : 0;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" added_lines="10" deleted_lines="0">
				<diff>@@ -63,13 +63,23 @@ public:
 
 protected:
   void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane);
+  void resampleOnStraight(const boost::circular_buffer&lt;geometry_msgs::Point&gt;&amp; curve_point, autoware_msgs::lane* lane);
+  void resampleOnCurve(const geometry_msgs::Point&amp; target_point, const std::vector&lt;double&gt;&amp; param, autoware_msgs::lane* lane);
+
+  const boost::circular_buffer&lt;geometry_msgs::Point&gt;
+    getCrvPointsOnResample(const autoware_msgs::lane&amp; lane, const autoware_msgs::lane&amp; original_lane, unsigned long original_index) const;
+  const boost::circular_buffer&lt;geometry_msgs::Point&gt;
+    getCrvPoints(const autoware_msgs::lane&amp; lane, unsigned long index) const;
+
   void createRadiusList(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius);
   const double calcVelParam() const;
   void createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
                        std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list);
+
   void limitVelocityByRange(unsigned long start_idx, unsigned long end_idx, unsigned int offset,
                             double vmin, autoware_msgs::lane* lane);
   void limitAccelDecel(const unsigned long idx, autoware_msgs::lane* lane);
+
   const std::vector&lt;double&gt; calcCurveParam(boost::circular_buffer&lt;geometry_msgs::Point&gt; point) const;
   const double calcPathLength(const autoware_msgs::lane&amp; lane) const;
 };
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="664b8fa7a178ea66b059c064d11aeb29fb758efe" author="Yuma">
		<msg>Clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" added_lines="34" deleted_lines="39">
				<diff>@@ -90,7 +90,7 @@ void VelocityReplanner::replanLaneWaypointVel(autoware_msgs::lane* lane)
     const double vmin = velocity_max_ - vel_param_ * (r_th_ - radius);
     limitVelocityByRange(el.first, el.second.first, velocity_offset_, vmin, lane);
   }
-  //set velocity on start &amp; end of lane
+  // set velocity on start &amp; end of lane
   limitVelocityByRange(0, 0, 0, velocity_min_, lane);
   limitVelocityByRange(lane-&gt;waypoints.size() - 1 - end_point_offset_, lane-&gt;waypoints.size() - 1, 0, 0.0, lane);
 }
@@ -109,9 +109,9 @@ void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, aut
     boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point = getCrvPointsOnResample(*lane, original_lane, i);
     const std::vector&lt;double&gt; curve_param = calcCurveParam(curve_point);
 
-    if (curve_param.empty())// if going straight
+    if (curve_param.empty())  // if going straight
       resampleOnStraight(curve_point, lane);
-    else// else if turnning curve
+    else  // else if turnning curve
       resampleOnCurve(curve_point[1], curve_param, lane);
 
     lane-&gt;waypoints.back().wpstate = original_lane.waypoints[i].wpstate;
@@ -121,11 +121,11 @@ void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, aut
   lane-&gt;waypoints.back().change_flag = original_lane.waypoints.back().change_flag;
 }
 
-
-void VelocityReplanner::resampleOnStraight(const boost::circular_buffer&lt;geometry_msgs::Point&gt;&amp; curve_point, autoware_msgs::lane* lane)
+void VelocityReplanner::resampleOnStraight(const boost::circular_buffer&lt;geometry_msgs::Point&gt;&amp; curve_point,
+                                           autoware_msgs::lane* lane)
 {
   autoware_msgs::waypoint wp = lane-&gt;waypoints.back();
-  const geometry_msgs::Point&amp; pt= wp.pose.pose.position;
+  const geometry_msgs::Point&amp; pt = wp.pose.pose.position;
   const double yaw = atan2(curve_point[2].y - curve_point[0].y, curve_point[2].x - curve_point[0].x);
   wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
 
@@ -144,8 +144,8 @@ void VelocityReplanner::resampleOnStraight(const boost::circular_buffer&lt;geometry
   }
 }
 
-
-void VelocityReplanner::resampleOnCurve(const geometry_msgs::Point&amp; target_point, const std::vector&lt;double&gt;&amp; curve_param, autoware_msgs::lane* lane)
+void VelocityReplanner::resampleOnCurve(const geometry_msgs::Point&amp; target_point,
+                                        const std::vector&lt;double&gt;&amp; curve_param, autoware_msgs::lane* lane)
 {
   autoware_msgs::waypoint wp = lane-&gt;waypoints.back();
   const double&amp; cx = curve_param[0];
@@ -177,17 +177,15 @@ void VelocityReplanner::resampleOnCurve(const geometry_msgs::Point&amp; target_point
   }
 }
 
-
-//Three points used for curve detection (the target point is the center)
-//[0] = previous point, [1] = target point, [2] = next point
-const boost::circular_buffer&lt;geometry_msgs::Point&gt;
-  VelocityReplanner::getCrvPointsOnResample(const autoware_msgs::lane&amp; lane, const autoware_msgs::lane&amp; original_lane, unsigned long original_index) const
+// Three points used for curve detection (the target point is the center)
+// [0] = previous point, [1] = target point, [2] = next point
+const boost::circular_buffer&lt;geometry_msgs::Point&gt; VelocityReplanner::getCrvPointsOnResample(
+    const autoware_msgs::lane&amp; lane, const autoware_msgs::lane&amp; original_lane, unsigned long original_index) const
 {
   unsigned long id = original_index;
   boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point(3);
   const unsigned int n = (lookup_crv_width_ - 1) / 2;
-  const autoware_msgs::waypoint cp[3] =
-  {
+  const autoware_msgs::waypoint cp[3] = {
     (lane.waypoints.size() &lt; n) ? lane.waypoints.front() : lane.waypoints[lane.waypoints.size() - n],
     original_lane.waypoints[id],
     (id &lt; original_lane.waypoints.size() - n) ? original_lane.waypoints[id + n] : original_lane.waypoints.back()
@@ -197,24 +195,19 @@ const boost::circular_buffer&lt;geometry_msgs::Point&gt;
   return curve_point;
 }
 
-const boost::circular_buffer&lt;geometry_msgs::Point&gt;
-  VelocityReplanner::getCrvPoints(const autoware_msgs::lane&amp; lane, unsigned long index) const
+const boost::circular_buffer&lt;geometry_msgs::Point&gt; VelocityReplanner::getCrvPoints(const autoware_msgs::lane&amp; lane,
+                                                                                   unsigned long index) const
 {
   boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point(3);
   const unsigned int n = (lookup_crv_width_ - 1) / 2;
-  const unsigned long curve_index[3] =
-  {
-    (index &lt; n) ? 0 : (index - n),
-    index,
-    (index &gt;= lane.waypoints.size() - n) ? (lane.waypoints.size() - 1) : (index + n)
-  };
+  const unsigned long curve_index[3] = { (index &lt; n) ? 0 : (index - n), index, (index &gt;= lane.waypoints.size() - n) ?
+                                                                                   (lane.waypoints.size() - 1) :
+                                                                                   (index + n) };
   for (int i = 0; i &lt; 3; i++)
     curve_point.push_back(lane.waypoints[curve_index[i]].pose.pose.position);
   return curve_point;
 }
 
-
-
 void VelocityReplanner::createRadiusList(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
 {
   if (lane.waypoints.empty())
@@ -227,9 +220,9 @@ void VelocityReplanner::createRadiusList(const autoware_msgs::lane&amp; lane, std::v
     boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point = getCrvPoints(lane, i);
     const std::vector&lt;double&gt; curve_param = calcCurveParam(curve_point);
 
-    if (curve_param.empty())// if going straight
+    if (curve_param.empty())  // if going straight
       curve_radius-&gt;at(i) = r_inf_;
-    else// else if turnning curve
+    else  // else if turnning curve
       curve_radius-&gt;at(i) = (curve_param[2] &gt; r_inf_) ? r_inf_ : curve_param[2];
   }
 }
@@ -238,13 +231,14 @@ const double VelocityReplanner::calcVelParam() const
 {
   if (fabs(r_th_ - r_min_) &lt; 1e-8)
   {
-    return DBL_MAX;//error
+    return DBL_MAX;  // error
   }
   return (velocity_max_ - velocity_min_) / (r_th_ - r_min_);
 }
 
-void VelocityReplanner::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
-                                     std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list)
+void VelocityReplanner::createCurveList(
+    const std::vector&lt;double&gt;&amp; curve_radius,
+    std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list)
 {
   unsigned long index = 0;
   bool on_curve = false;
@@ -272,7 +266,7 @@ void VelocityReplanner::createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
 }
 
 void VelocityReplanner::limitVelocityByRange(unsigned long start_idx, unsigned long end_idx, unsigned int offset,
-                          double vmin, autoware_msgs::lane* lane)
+                                             double vmin, autoware_msgs::lane* lane)
 {
   if (offset &gt; 0)
   {
@@ -282,7 +276,7 @@ void VelocityReplanner::limitVelocityByRange(unsigned long start_idx, unsigned l
   for (unsigned long idx = start_idx; idx &lt;= end_idx; idx++)
   {
     if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
-    continue;
+      continue;
     lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
   }
   limitAccelDecel(start_idx, lane);
@@ -291,10 +285,10 @@ void VelocityReplanner::limitVelocityByRange(unsigned long start_idx, unsigned l
 
 void VelocityReplanner::limitAccelDecel(const unsigned long idx, autoware_msgs::lane* lane)
 {
-  const double acc[2] = {accel_limit_, decel_limit_};
-  const unsigned long end_idx[2] = {lane-&gt;waypoints.size() - idx, idx + 1};
-  const int sgn[2] = {1, -1};
-  for (int j = 0; j &lt; 2; j++)// [j=0]: accel_limit_process, [j=1]: decel_limit_process
+  const double acc[2] = { accel_limit_, decel_limit_ };
+  const unsigned long end_idx[2] = { lane-&gt;waypoints.size() - idx, idx + 1 };
+  const int sgn[2] = { 1, -1 };
+  for (int j = 0; j &lt; 2; j++)  // [j=0]: accel_limit_process, [j=1]: decel_limit_process
   {
     double v = lane-&gt;waypoints[idx].twist.twist.linear.x;
     unsigned long next = idx + sgn[j];
@@ -311,10 +305,11 @@ void VelocityReplanner::limitAccelDecel(const unsigned long idx, autoware_msgs::
 // get curve 3-Parameter [center_x, center_y, radius] with 3 point input. If error occured, return empty vector.
 const std::vector&lt;double&gt; VelocityReplanner::calcCurveParam(boost::circular_buffer&lt;geometry_msgs::Point&gt; p) const
 {
-  for (int i = 0; i &lt; 3; i++, p.push_back(p.front()))//if exception occured, change points order
+  for (int i = 0; i &lt; 3; i++, p.push_back(p.front()))  // if exception occured, change points order
   {
     const double d = 2 * ((p[0].y - p[2].y) * (p[0].x - p[1].x) - (p[0].y - p[1].y) * (p[0].x - p[2].x));
-    if (fabs(d) &lt; 1e-8)continue;
+    if (fabs(d) &lt; 1e-8)
+      continue;
     const std::vector&lt;double&gt; x2 = { p[0].x * p[0].x, p[1].x * p[1].x, p[2].x * p[2].x };
     const std::vector&lt;double&gt; y2 = { p[0].y * p[0].y, p[1].y * p[1].y, p[2].y * p[2].y };
     const double a = y2[0] - y2[1] + x2[0] - x2[1];
@@ -325,7 +320,7 @@ const std::vector&lt;double&gt; VelocityReplanner::calcCurveParam(boost::circular_buff
     param[2] = sqrt((cx - p[0].x) * (cx - p[0].x) + (cy - p[0].y) * (cy - p[0].y));
     return param;
   }
-  return std::vector&lt;double&gt;();//error
+  return std::vector&lt;double&gt;();  // error
 }
 
 const double VelocityReplanner::calcPathLength(const autoware_msgs::lane&amp; lane) const
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" added_lines="9" deleted_lines="7">
				<diff>@@ -64,20 +64,22 @@ public:
 protected:
   void resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane);
   void resampleOnStraight(const boost::circular_buffer&lt;geometry_msgs::Point&gt;&amp; curve_point, autoware_msgs::lane* lane);
-  void resampleOnCurve(const geometry_msgs::Point&amp; target_point, const std::vector&lt;double&gt;&amp; param, autoware_msgs::lane* lane);
+  void resampleOnCurve(const geometry_msgs::Point&amp; target_point, const std::vector&lt;double&gt;&amp; param,
+                       autoware_msgs::lane* lane);
 
-  const boost::circular_buffer&lt;geometry_msgs::Point&gt;
-    getCrvPointsOnResample(const autoware_msgs::lane&amp; lane, const autoware_msgs::lane&amp; original_lane, unsigned long original_index) const;
-  const boost::circular_buffer&lt;geometry_msgs::Point&gt;
-    getCrvPoints(const autoware_msgs::lane&amp; lane, unsigned long index) const;
+  const boost::circular_buffer&lt;geometry_msgs::Point&gt; getCrvPointsOnResample(const autoware_msgs::lane&amp; lane,
+                                                                            const autoware_msgs::lane&amp; original_lane,
+                                                                            unsigned long original_index) const;
+  const boost::circular_buffer&lt;geometry_msgs::Point&gt; getCrvPoints(const autoware_msgs::lane&amp; lane,
+                                                                  unsigned long index) const;
 
   void createRadiusList(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius);
   const double calcVelParam() const;
   void createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
                        std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list);
 
-  void limitVelocityByRange(unsigned long start_idx, unsigned long end_idx, unsigned int offset,
-                            double vmin, autoware_msgs::lane* lane);
+  void limitVelocityByRange(unsigned long start_idx, unsigned long end_idx, unsigned int offset, double vmin,
+                            autoware_msgs::lane* lane);
   void limitAccelDecel(const unsigned long idx, autoware_msgs::lane* lane);
 
   const std::vector&lt;double&gt; calcCurveParam(boost::circular_buffer&lt;geometry_msgs::Point&gt; point) const;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="58bb93d44ce2d2daf8fc509a5778ebbce08aeb81" author="Yuma">
		<msg>Return disable_decision_maker to rosparam</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -46,6 +46,7 @@ WaypointLoaderNode::~WaypointLoaderNode()
 
 void WaypointLoaderNode::initPubSub()
 {
+  private_nh_.param&lt;bool&gt;("disable_decision_maker", disable_decision_maker_, true);
   // setup publisher
   if (disable_decision_maker_)
   {
@@ -63,7 +64,6 @@ void WaypointLoaderNode::initPubSub()
 void WaypointLoaderNode::initParameter(const autoware_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
 {
   // parameter settings
-  disable_decision_maker_ = conf-&gt;disable_decision_maker;
   replanning_mode_ = conf-&gt;replanning_mode;
   multi_lane_csv_ = conf-&gt;multi_lane_csv;
 }
@@ -321,7 +321,7 @@ bool WaypointLoaderNode::verifyFileConsistency(const char* filename)
     return false;
 
   FileFormat format = checkFileFormat(filename);
-  ROS_INFO("format: %d", static_cast&lt;FileFormat&gt;(format));
+  ROS_INFO("format: %d", static_cast&lt;int&gt;(format));
   if (format == FileFormat::unknown)
   {
     ROS_ERROR("unknown file format");
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="34b806e2e353f3b924ee2b9b5d1c23165d31c24e" author="Kosuke Murakami">
		<msg>Change topic type from CloudClusterArray to DetectedObjectArray</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" added_lines="19" deleted_lines="5">
				<diff>@@ -14,6 +14,13 @@
 #include "autoware_msgs/CloudCluster.h"
 #include "autoware_msgs/CloudClusterArray.h"
 
+#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
+#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
+
+#include "autoware_msgs/DetectedObject.h"
+#include "autoware_msgs/DetectedObjectArray.h"
+
+
 #include "ukf.h"
 
 
@@ -54,12 +61,15 @@ private:
 
   ros::NodeHandle node_handle_;
   ros::Subscriber sub_cloud_array_;
-  ros::Publisher pub_cloud_array_;
+  ros::Publisher pub_object_array_;
+  ros::Publisher pub_jskbbox_array_;
+
 
 
   void callback(autoware_msgs::CloudClusterArray input);
   void transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input);
-  void transformPoseToLocal(autoware_msgs::CloudClusterArray&amp; input);
+  void transformPoseToLocal(jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
+                            autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
   void findMaxZandS(const UKF target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s);
   void measurementValidation(const autoware_msgs::CloudClusterArray input, UKF&amp; target, const bool second_init,
                  const Eigen::VectorXd max_det_z, const Eigen::MatrixXd max_det_s,
@@ -80,7 +90,9 @@ private:
                           const double p_x, const double p_y, const double cp_x, const double cp_y);
   void mergeOverSegmentation(const std::vector&lt;UKF&gt; targets);
 
-  void updateLabel(UKF target, autoware_msgs::CloudCluster&amp; cc);
+  void updateLabel(UKF target, autoware_msgs::DetectedObject&amp; dd);
+  void updateJskLabel(UKF target, jsk_recognition_msgs::BoundingBox&amp; bb);
+  bool isVisible(UKF target);
 
   void initTracker(autoware_msgs::CloudClusterArray input, double timestamp);
   void secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; clusterVec, UKF &amp;target);
@@ -95,10 +107,12 @@ private:
   void staticClassification();
 
   void makeOutput(autoware_msgs::CloudClusterArray input,
-                  autoware_msgs::CloudClusterArray&amp; output);
+                  jsk_recognition_msgs::BoundingBoxArray &amp;jskbboxes_output,
+                  autoware_msgs::DetectedObjectArray &amp;detected_objects_output);
 
   void tracker(autoware_msgs::CloudClusterArray input,
-                 autoware_msgs::CloudClusterArray&amp; output);
+               jsk_recognition_msgs::BoundingBoxArray &amp;jskbboxes_output,
+               autoware_msgs::DetectedObjectArray &amp;detected_objects_output);
 
 
 public:
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="78" deleted_lines="36">
				<diff>@@ -32,19 +32,24 @@ ImmUkfPda::ImmUkfPda()
   tf_listener_=lr;
 
   sub_cloud_array_   = node_handle_.subscribe ("cloud_clusters", 1, &amp;ImmUkfPda::callback, this);
-  pub_cloud_array_  = node_handle_.advertise&lt;autoware_msgs::CloudClusterArray&gt; ("tracking_cluster_array", 1);
+  pub_jskbbox_array_ = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt; ("/bounding_boxes_tracked", 1);
+  pub_object_array_  = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt; ("/detected_objects", 1);
 
 }
 
 void ImmUkfPda::callback(autoware_msgs::CloudClusterArray input)
 {
   autoware_msgs::CloudClusterArray output;
+  jsk_recognition_msgs::BoundingBoxArray jskbboxes_output;
+  autoware_msgs::DetectedObjectArray detected_objects_output;
+
   // only transform pose(clusteArray.clusters.bouding_box.pose)
   transformPoseToGlobal(input);
-  tracker(input, output);
-  transformPoseToLocal(output);
+  tracker(input, jskbboxes_output, detected_objects_output);
+  transformPoseToLocal(jskbboxes_output, detected_objects_output);
 
-  pub_cloud_array_.publish(output);
+  pub_jskbbox_array_.publish(jskbboxes_output);
+  pub_object_array_.publish(detected_objects_output);
 
 }
 
@@ -62,21 +67,23 @@ void ImmUkfPda::transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input)
   }
 }
 
-void ImmUkfPda::transformPoseToLocal(autoware_msgs::CloudClusterArray&amp; output)
+void ImmUkfPda::transformPoseToLocal(jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
+                                     autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
 {
 
-  for(size_t i = 0; i &lt; output.clusters.size(); i ++)
+  for(size_t i = 0; i &lt; jskbboxes_output.boxes.size(); i ++)
   {
     geometry_msgs::PoseStamped pose_in, pose_out;
 
-    pose_in.header = output.header;
+    pose_in.header = jskbboxes_output.header;
     pose_in.header.frame_id = tracking_frame_;
-    pose_in.pose = output.clusters[i].bounding_box.pose;
+    pose_in.pose = jskbboxes_output.boxes[i].pose;
 
     tf_listener_-&gt;waitForTransform(tracking_frame_, pointcloud_frame_, ros::Time(0), ros::Duration(1.0));
     tf_listener_-&gt;transformPose(pointcloud_frame_, ros::Time(0), pose_in, tracking_frame_, pose_out);
-    pose_out.header.frame_id = output.header.frame_id = pointcloud_frame_;
-    output.clusters[i].bounding_box.pose = pose_out.pose;
+    pose_out.header.frame_id = jskbboxes_output.header.frame_id = pointcloud_frame_;
+    jskbboxes_output.boxes[i].pose = pose_out.pose;
+    detected_objects_output.objects[i].pose = pose_out.pose;
   }
 }
 
@@ -122,7 +129,6 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
 {
   int count = 0;
   bool second_init_done = false;
-  // double smallest_nis = 999;
   double smallest_nis = std::numeric_limits&lt;double&gt;::max();
   autoware_msgs::CloudCluster smallest_meas_cluster;
   for(size_t i = 0; i &lt; input.clusters.size(); i++)
@@ -497,30 +503,59 @@ void ImmUkfPda::updateBB(UKF&amp; target)
 //     }
 // }
 
-void ImmUkfPda::updateLabel(UKF target, autoware_msgs::CloudCluster&amp; cc)
+void ImmUkfPda::updateLabel(UKF target, autoware_msgs::DetectedObject&amp; dd)
 {
   int tracking_num = target.tracking_num_;
   // cout &lt;&lt; "trackingnum "&lt;&lt; trackingNum &lt;&lt; endl;
   if(target.is_static_)
   {
-    cc.label = "Static";
+    dd.label = "Static";
   }
   else if(tracking_num &gt; TrackingState::Die &amp;&amp; tracking_num &lt; TrackingState::Stable)
   {
-    cc.label = "Initialized";
+    dd.label = "Initialized";
   }
   else if(tracking_num == TrackingState::Stable)
   {
-    cc.label = "Stable";
+    dd.label = "Stable";
   }
   else if(tracking_num &gt; TrackingState::Stable &amp;&amp; tracking_num &lt;= TrackingState::Lost)
   {
-    cc.label = "Lost";
+    dd.label = "Lost";
+  }
+  else
+  {
+    dd.label = "None";
+  }
+}
+
+void ImmUkfPda::updateJskLabel(UKF target, jsk_recognition_msgs::BoundingBox&amp; bb)
+{
+  int tracking_num = target.tracking_num_;
+  // cout &lt;&lt; "trackingnum "&lt;&lt; trackingNum &lt;&lt; endl;
+  if(target.is_static_)
+  {
+    bb.label = 15;//white color
+  }
+  else if(tracking_num == TrackingState::Stable)
+  {
+    bb.label = 2;//orange color
+  }
+}
+
+bool ImmUkfPda::isVisible(UKF target)
+{
+  bool is_visible = false;
+  int tracking_num = target.tracking_num_;
+  if(tracking_num == TrackingState::Stable || target.is_static_)
+  {
+    is_visible = true;
   }
   else
   {
-    cc.label = "None";
+    is_visible = false;
   }
+  return is_visible;
 }
 
 void ImmUkfPda::initTracker(autoware_msgs::CloudClusterArray input, double timestamp)
@@ -622,8 +657,7 @@ void ImmUkfPda::probabilisticDataAssociation(autoware_msgs::CloudClusterArray in
   is_skip_target = false;
   // find maxDetS associated with predZ
   findMaxZandS(target, max_det_z, max_det_s);
-  // to do: might modify here: this code ensures that measurement is incorporated
-  max_det_s = max_det_s*4;
+
   double det_s = max_det_s.determinant();
 
   // prevent ukf not to explode
@@ -709,7 +743,8 @@ void ImmUkfPda::staticClassification()
 }
 
 void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
-                           autoware_msgs::CloudClusterArray&amp; output)
+                           jsk_recognition_msgs::BoundingBoxArray &amp;jskbboxes_output,
+                           autoware_msgs::DetectedObjectArray &amp;detected_objects_output)
 {
   tf::StampedTransform transform;
   tf_listener_-&gt;lookupTransform(tracking_frame_, pointcloud_frame_, ros::Time(0), transform);
@@ -719,10 +754,12 @@ void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
   double roll, pitch, yaw;
   m.getRPY(roll, pitch, yaw);
 
-  output.header = input.header;
+  // output.header = input.header;
+  jskbboxes_output.header = input.header;
+  detected_objects_output.header = input.header;
   for(size_t i = 0; i &lt; targets_.size(); i++)
   {
-    if(targets_[i].is_vis_bb_)
+    if(targets_[i].is_vis_bb_ &amp;&amp; isVisible(targets_[i]))
     {
       double tx = targets_[i].x_merge_(0);
       double ty = targets_[i].x_merge_(1);
@@ -731,9 +768,6 @@ void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
 
       //for static classification
       targets_[i].dist_from_init_ = sqrt((tx - mx)*(tx - mx) + (ty - my)*(ty - my));
-      std::vector&lt;double&gt; cp;
-      cp.push_back(tx);
-      cp.push_back(ty);
 
       double tv = targets_[i].x_merge_(2);
       double tyaw = targets_[i].x_merge_(3) - yaw;
@@ -741,21 +775,28 @@ void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
       while (tyaw&gt; M_PI) tyaw -= 2.*M_PI;
       while (tyaw&lt;-M_PI) tyaw += 2.*M_PI;
 
-      autoware_msgs::CloudCluster cc;
-      cc.header = input.header;
-      cc.id     = i;
-      cc.bounding_box = targets_[i].jsk_bb_;
-      cc.bounding_box.header = input.header;
-      cc.score           = tv;
-      cc.estimated_angle = tyaw;
-      updateLabel(targets_[i], cc);
-      output.clusters.push_back(cc);
+      jsk_recognition_msgs::BoundingBox bb;
+      bb.header = input.header;
+      bb = targets_[i].jsk_bb_;
+      updateJskLabel(targets_[i], bb);
+      jskbboxes_output.boxes.push_back(bb);
+
+      autoware_msgs::DetectedObject dd;
+      dd.header = input.header;
+      dd.id = i;
+      dd.velocity.linear.x = tv;
+      dd.pose = targets_[i].jsk_bb_.pose;
+      // Store tyaw in velocity.linear.y since nowhere to store estimated_yaw
+      dd.velocity.linear.y = tyaw;
+      updateLabel(targets_[i], dd);
+      detected_objects_output.objects.push_back(dd);
     }
   }
 }
 
 void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
-                        autoware_msgs::CloudClusterArray&amp; output)
+             jsk_recognition_msgs::BoundingBoxArray &amp;jskbboxes_output,
+             autoware_msgs::DetectedObjectArray &amp;detected_objects_output)
 {
   double timestamp = input.header.stamp.toSec();
 
@@ -813,7 +854,8 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
   staticClassification();
 
   // making output(CludClusterArray) for visualization
-  makeOutput(input, output);
+  makeOutput(input, jskbboxes_output, detected_objects_output);
 
   assert(matching_vec.size() == input.clusters.size());
+  assert(jskbboxes_output.boxes.size() == detected_objects_output.objects.size());
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" added_lines="7" deleted_lines="5">
				<diff>@@ -15,6 +15,10 @@
 #include "autoware_msgs/CloudCluster.h"
 #include "autoware_msgs/CloudClusterArray.h"
 
+#include "autoware_msgs/DetectedObject.h"
+#include "autoware_msgs/DetectedObjectArray.h"
+
+
 
 
 class VisualizeCloudCluster
@@ -25,14 +29,12 @@ private:
 
   ros::NodeHandle node_handle_;
   ros::Subscriber sub_cloud_array_;
-  ros::Publisher  pub_jsk_bb_;
+
   ros::Publisher  pub_arrow_;
   ros::Publisher  pub_id_;
 
-  void getJskBBs(autoware_msgs::CloudClusterArray input,
-          jsk_recognition_msgs::BoundingBoxArray&amp; jskBBs);
-  void visMarkers(autoware_msgs::CloudClusterArray input);
-  void callBack(autoware_msgs::CloudClusterArray input);
+  void visMarkers(autoware_msgs::DetectedObjectArray input);
+  void callBack(autoware_msgs::DetectedObjectArray input);
 
 public:
   VisualizeCloudCluster();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" added_lines="14" deleted_lines="50">
				<diff>@@ -9,62 +9,25 @@ VisualizeCloudCluster::VisualizeCloudCluster()
   ros::NodeHandle private_nh_("~");
   private_nh_.param&lt;std::string&gt;("pointcloud_frame", pointcloud_frame_, "velodyne");
 
-  sub_cloud_array_  = node_handle_.subscribe ("tracking_cluster_array", 1, &amp;VisualizeCloudCluster::callBack, this);
-  pub_jsk_bb_       = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt; ("/tracking_cluster_array/jsk_bb", 1);
-  pub_arrow_        = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/tracking_cluster_array/velocity_arrow", 1);
-  pub_id_           = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/tracking_cluster_array/target_id", 1);
+  sub_cloud_array_  = node_handle_.subscribe ("/detected_objects", 1, &amp;VisualizeCloudCluster::callBack, this);
+  pub_arrow_        = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/detected_objects/velocity_arrow", 1);
+  pub_id_           = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/detected_objects/target_id", 1);
 }
 
-void VisualizeCloudCluster::callBack(autoware_msgs::CloudClusterArray input)
+void VisualizeCloudCluster::callBack(autoware_msgs::DetectedObjectArray input)
 {
-  jsk_recognition_msgs::BoundingBoxArray jsk_bbs;
-  visualization_msgs::Marker arrows;
-
-  getJskBBs(input, jsk_bbs);
-  pub_jsk_bb_.publish(jsk_bbs);
   visMarkers(input);
 }
 
-void VisualizeCloudCluster::getJskBBs(autoware_msgs::CloudClusterArray input,
-               jsk_recognition_msgs::BoundingBoxArray&amp; jsk_bbs)
+void VisualizeCloudCluster::visMarkers(autoware_msgs::DetectedObjectArray input)
 {
-  jsk_bbs.header = input.header;
-
-  for(size_t i = 0; i &lt; input.clusters.size(); i++)
+  for(size_t i = 0; i &lt; input.objects.size(); i++)
   {
-    jsk_recognition_msgs::BoundingBox bb;
-    bb = input.clusters[i].bounding_box;
-    bb.header = input.header;
-    std::string label = input.clusters[i].label;
-
-    if(label == "Stable")
-    {
-      bb.label = 2;
-    }
-    else if(label == "Static")
-    {
-      bb.label = 15;
-    }
-
-    jsk_bbs.boxes.push_back(bb);
-  }
-}
-
-void VisualizeCloudCluster::visMarkers(autoware_msgs::CloudClusterArray input)
-{
-  for(size_t i = 0; i &lt; input.clusters.size(); i++)
-  {
-
-    double tv   = input.clusters[i].score;
-    double tyaw = input.clusters[i].estimated_angle;
-    std::string label = input.clusters[i].label;
+    double tv   = input.objects[i].velocity.linear.x;
+    double tyaw = input.objects[i].velocity.linear.y;
 
     visualization_msgs::Marker ids;
 
-    if(label == "None" || label == "Initialized" || label == "Lost")
-    {
-      continue;
-    }
     ids.lifetime = ros::Duration(0.15);
     ids.header.frame_id = pointcloud_frame_;
     ids.header.stamp = input.header.stamp;
@@ -78,8 +41,8 @@ void VisualizeCloudCluster::visMarkers(autoware_msgs::CloudClusterArray input)
 
 
     // Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
-    ids.pose.position.x = input.clusters[i].bounding_box.pose.position.x;
-    ids.pose.position.y = input.clusters[i].bounding_box.pose.position.y;
+    ids.pose.position.x = input.objects[i].pose.position.x;
+    ids.pose.position.y = input.objects[i].pose.position.y;
     ids.pose.position.z = 1.5;
 
     // convert from RPY to quartenion
@@ -95,7 +58,7 @@ void VisualizeCloudCluster::visMarkers(autoware_msgs::CloudClusterArray input)
 
     ids.scale.z = 1.0;
 
-    ids.text = std::to_string(input.clusters[i].id);
+    ids.text = std::to_string(input.objects[i].id);
 
     pub_id_.publish(ids);
 
@@ -103,6 +66,7 @@ void VisualizeCloudCluster::visMarkers(autoware_msgs::CloudClusterArray input)
     visualization_msgs::Marker arrows;
     arrows.lifetime = ros::Duration(0.1);
 
+    std::string label = input.objects[i].label;
     if(label == "None" || label == "Initialized" || label == "Lost" || label == "Static")
     {
       continue;
@@ -119,8 +83,8 @@ void VisualizeCloudCluster::visMarkers(autoware_msgs::CloudClusterArray input)
     arrows.id = i;
 
     // Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
-    arrows.pose.position.x = input.clusters[i].bounding_box.pose.position.x;
-    arrows.pose.position.y = input.clusters[i].bounding_box.pose.position.y;
+    arrows.pose.position.x = input.objects[i].pose.position.x;
+    arrows.pose.position.y = input.objects[i].pose.position.y;
     arrows.pose.position.z = 0.5;
 
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b65f3e588cb977529adaabf2ec94741f224e5a00" author="Kosuke Murakami">
		<msg>Apply clang roscpp</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" added_lines="24" deleted_lines="33">
				<diff>@@ -10,7 +10,6 @@
 
 #include &lt;tf/transform_listener.h&gt;
 
-
 #include "autoware_msgs/CloudCluster.h"
 #include "autoware_msgs/CloudClusterArray.h"
 
@@ -20,34 +19,32 @@
 #include "autoware_msgs/DetectedObject.h"
 #include "autoware_msgs/DetectedObjectArray.h"
 
-
 #include "ukf.h"
 
-
 class ImmUkfPda
 {
 private:
   bool init_;
-  double timestamp_ ;
+  double timestamp_;
 
   std::vector&lt;UKF&gt; targets_;
 
   // probabilistic data association params
-  double gating_thres_;//9.22
-  double gate_probability_;//0.99;
-  double detection_probability_;//0.9;
+  double gating_thres_;           // 9.22
+  double gate_probability_;       // 0.99;
+  double detection_probability_;  // 0.9;
 
-  //bbox association param
-  double distance_thres_;//0.25;
-  int life_time_thres_;//8;
-  //bbox update params
-  double bb_yaw_change_thres_;//0.2;
+  // bbox association param
+  double distance_thres_;  // 0.25;
+  int life_time_thres_;    // 8;
+  // bbox update params
+  double bb_yaw_change_thres_;  // 0.2;
 
   double static_distance_thres_;
 
   double init_yaw_;
 
-  //Tracking state paramas
+  // Tracking state paramas
   int stable_num_;
   int lost_num_;
 
@@ -64,23 +61,20 @@ private:
   ros::Publisher pub_object_array_;
   ros::Publisher pub_jskbbox_array_;
 
-
-
   void callback(autoware_msgs::CloudClusterArray input);
   void transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input);
   void transformPoseToLocal(jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                             autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
   void findMaxZandS(const UKF target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s);
   void measurementValidation(const autoware_msgs::CloudClusterArray input, UKF&amp; target, const bool second_init,
-                 const Eigen::VectorXd max_det_z, const Eigen::MatrixXd max_det_s,
-                 std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
-                 std::vector&lt;bool&gt;&amp; matching_vec);
-  void filterPDA(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, std::vector&lt;double&gt;&amp; lambda_vec);
+                             const Eigen::VectorXd max_det_z, const Eigen::MatrixXd max_det_s,
+                             std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, std::vector&lt;bool&gt;&amp; matching_vec);
+  void filterPDA(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
+                 std::vector&lt;double&gt;&amp; lambda_vec);
   void getNearestEuclidCluster(const UKF target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
-                autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist);
+                               autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist);
   void getRightAngleBBox(const std::vector&lt;double&gt; nearest_bbox, std::vector&lt;double&gt;&amp; rightAngle_bbox);
-  void associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
-                     UKF&amp; target);
+  void associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target);
   double getBboxArea(const pcl::PointCloud&lt;pcl::PointXYZ&gt; bbox);
   double getBBoxYaw(const UKF target);
   double getJskBBoxArea(const jsk_recognition_msgs::BoundingBox jsk_bb);
@@ -95,25 +89,22 @@ private:
   bool isVisible(UKF target);
 
   void initTracker(autoware_msgs::CloudClusterArray input, double timestamp);
-  void secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; clusterVec, UKF &amp;target);
+  void secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; clusterVec, UKF&amp; target);
 
   void updateTrackingNum(std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target);
 
-  void probabilisticDataAssociation(autoware_msgs::CloudClusterArray input,
-                                    double dt, double det_explode_param, std::vector&lt;bool&gt;&amp; matching_vec,
-                                    std::vector&lt;double&gt;&amp; lambda_vec, UKF&amp; target, bool&amp; is_skip_target);
+  void probabilisticDataAssociation(autoware_msgs::CloudClusterArray input, double dt, double det_explode_param,
+                                    std::vector&lt;bool&gt;&amp; matching_vec, std::vector&lt;double&gt;&amp; lambda_vec, UKF&amp; target,
+                                    bool&amp; is_skip_target);
   void makeNewTargets(double timestamp, autoware_msgs::CloudClusterArray input, std::vector&lt;bool&gt; matching_vec);
 
   void staticClassification();
 
-  void makeOutput(autoware_msgs::CloudClusterArray input,
-                  jsk_recognition_msgs::BoundingBoxArray &amp;jskbboxes_output,
-                  autoware_msgs::DetectedObjectArray &amp;detected_objects_output);
-
-  void tracker(autoware_msgs::CloudClusterArray input,
-               jsk_recognition_msgs::BoundingBoxArray &amp;jskbboxes_output,
-               autoware_msgs::DetectedObjectArray &amp;detected_objects_output);
+  void makeOutput(autoware_msgs::CloudClusterArray input, jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
+                  autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
 
+  void tracker(autoware_msgs::CloudClusterArray input, jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
+               autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
 
 public:
   ImmUkfPda();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" added_lines="15" deleted_lines="21">
				<diff>@@ -13,7 +13,6 @@
 class UKF
 {
 public:
-
   ///* initially set to false, set to true in first call of ProcessMeasurement
   bool is_initialized_;
 
@@ -23,7 +22,7 @@ public:
   ///* if this is false, radar measurements will be ignored (except for init)
   bool use_radar_;
 
-//    ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
+  //    ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
   Eigen::MatrixXd x_merge_;
 
   ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
@@ -35,7 +34,7 @@ public:
   ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
   Eigen::MatrixXd x_rm_;
 
-//    ///* state covariance matrix
+  //    ///* state covariance matrix
   Eigen::MatrixXd p_merge_;
 
   ///* state covariance matrix
@@ -64,7 +63,7 @@ public:
   double std_a_ctrv_;
   double std_a_rm_;
   ///* Process noise standard deviation yaw acceleration in rad/s^2
-//    double std_yawdd_;
+  //    double std_yawdd_;
 
   // CTRV
   double std_ctrv_yawdd_;
@@ -86,7 +85,7 @@ public:
   double std_radphi_;
 
   ///* Radar measurement noise standard deviation radius change in m/s
-  double std_radrd_ ;
+  double std_radrd_;
 
   ///* Weights of sigma points
   Eigen::VectorXd weights_;
@@ -103,21 +102,20 @@ public:
   ///* Augmented sigma point spreading parameter
   double lambda_aug_;
 
-
   int count_;
   int count_empty_;
 
   double mode_match_prob_cv2cv_;
   double mode_match_prob_ctrv2cv_;
-  double mode_match_prob_rm2cv_ ;
+  double mode_match_prob_rm2cv_;
 
   double mode_match_prob_cv2ctrv_;
-  double mode_match_prob_ctrv2ctrv_ ;
-  double mode_match_prob_rm2ctrv_ ;
+  double mode_match_prob_ctrv2ctrv_;
+  double mode_match_prob_rm2ctrv_;
 
-  double mode_match_prob_cv2rm_ ;
-  double mode_match_prob_ctrv2rm_ ;
-  double mode_match_prob_rm2rm_ ;
+  double mode_match_prob_cv2rm_;
+  double mode_match_prob_ctrv2rm_;
+  double mode_match_prob_rm2rm_;
 
   double mode_match_prob_cv_;
 
@@ -145,7 +143,6 @@ public:
   Eigen::MatrixXd s_ctrv_;
   Eigen::MatrixXd s_rm_;
 
-
   Eigen::MatrixXd k_cv_;
   Eigen::MatrixXd k_ctrv_;
   Eigen::MatrixXd k_rm_;
@@ -175,7 +172,6 @@ public:
   Eigen::VectorXd init_meas_;
   double dist_from_init_;
 
-
   std::vector&lt;Eigen::VectorXd&gt; local2local_;
   std::vector&lt;double&gt; local2localYawVec_;
 
@@ -200,7 +196,6 @@ public:
 
   void interaction();
 
-
   /**
    * ProcessMeasurement
    * @param meas_package The latest measurement data of either radar or laser
@@ -209,15 +204,14 @@ public:
 
   void updateIMMUKF(const std::vector&lt;double&gt; lambda_vec);
 
+  void ctrv(const double p_x, const double p_y, const double v, const double yaw, const double yawd, const double nu_a,
+            const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp; state);
 
-  void ctrv(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
-      const double nu_a,const  double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state);
-
-  void cv(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
-      const double nu_a,const  double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state);
+  void cv(const double p_x, const double p_y, const double v, const double yaw, const double yawd, const double nu_a,
+          const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp; state);
 
   void randomMotion(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
-      const double nu_a,const  double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state);
+                    const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp; state);
   /**
    * Prediction Predicts sigma points, the state, and the state covariance
    * matrix
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="216" deleted_lines="219">
				<diff>@@ -1,15 +1,13 @@
 #include "ukf.h"
 #include "imm_ukf_pda_tracker.h"
 
-//
-enum TrackingState: int
-  {
-     Die = 0, // No longer tracking
-     Init = 1, // Start tracking
-     Stable = 4, // Stable tracking
-     Lost = 10, // About to lose target
-  };
-
+enum TrackingState : int
+{
+  Die = 0,     // No longer tracking
+  Init = 1,    // Start tracking
+  Stable = 4,  // Stable tracking
+  Lost = 10,   // About to lose target
+};
 
 ImmUkfPda::ImmUkfPda()
 {
@@ -22,19 +20,15 @@ ImmUkfPda::ImmUkfPda()
   private_nh_.param&lt;double&gt;("detection_probability", detection_probability_, 0.9);
   private_nh_.param&lt;double&gt;("distance_thres", distance_thres_, 99);
   private_nh_.param&lt;double&gt;("static_distance_thres", static_distance_thres_, 3.0);
-  private_nh_.param&lt;int&gt;("stable_num", stable_num_, 4);
-  private_nh_.param&lt;int&gt;("lost_num", lost_num_, 10);
-
 
   init_ = false;
 
-  tf::TransformListener *lr (new  tf::TransformListener);
-  tf_listener_=lr;
-
-  sub_cloud_array_   = node_handle_.subscribe ("cloud_clusters", 1, &amp;ImmUkfPda::callback, this);
-  pub_jskbbox_array_ = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt; ("/bounding_boxes_tracked", 1);
-  pub_object_array_  = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt; ("/detected_objects", 1);
+  tf::TransformListener* lr(new tf::TransformListener);
+  tf_listener_ = lr;
 
+  sub_cloud_array_ = node_handle_.subscribe("cloud_clusters", 1, &amp;ImmUkfPda::callback, this);
+  pub_jskbbox_array_ = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/bounding_boxes_tracked", 1);
+  pub_object_array_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detected_objects", 1);
 }
 
 void ImmUkfPda::callback(autoware_msgs::CloudClusterArray input)
@@ -50,12 +44,11 @@ void ImmUkfPda::callback(autoware_msgs::CloudClusterArray input)
 
   pub_jskbbox_array_.publish(jskbboxes_output);
   pub_object_array_.publish(detected_objects_output);
-
 }
 
 void ImmUkfPda::transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input)
 {
-  for(size_t i = 0; i &lt; input.clusters.size(); i ++)
+  for (size_t i = 0; i &lt; input.clusters.size(); i++)
   {
     geometry_msgs::PoseStamped pose_in, pose_out;
 
@@ -70,8 +63,7 @@ void ImmUkfPda::transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input)
 void ImmUkfPda::transformPoseToLocal(jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                                      autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
 {
-
-  for(size_t i = 0; i &lt; jskbboxes_output.boxes.size(); i ++)
+  for (size_t i = 0; i &lt; jskbboxes_output.boxes.size(); i++)
   {
     geometry_msgs::PoseStamped pose_in, pose_out;
 
@@ -87,16 +79,15 @@ void ImmUkfPda::transformPoseToLocal(jsk_recognition_msgs::BoundingBoxArray&amp; jsk
   }
 }
 
-
 void ImmUkfPda::findMaxZandS(const UKF target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s)
 {
-  double cv_det   = target.s_cv_.determinant();
+  double cv_det = target.s_cv_.determinant();
   double ctrv_det = target.s_ctrv_.determinant();
-  double rm_det   = target.s_rm_.determinant();
+  double rm_det = target.s_rm_.determinant();
 
-  if(cv_det &gt; ctrv_det)
+  if (cv_det &gt; ctrv_det)
   {
-    if(cv_det &gt; rm_det)
+    if (cv_det &gt; rm_det)
     {
       max_det_z = target.z_pred_cv_;
       max_det_s = target.s_cv_;
@@ -107,8 +98,9 @@ void ImmUkfPda::findMaxZandS(const UKF target, Eigen::VectorXd&amp; max_det_z, Eigen
       max_det_s = target.s_rm_;
     }
   }
-  else{
-    if(ctrv_det &gt; rm_det)
+  else
+  {
+    if (ctrv_det &gt; rm_det)
     {
       max_det_z = target.z_pred_ctrv_;
       max_det_s = target.s_ctrv_;
@@ -121,17 +113,16 @@ void ImmUkfPda::findMaxZandS(const UKF target, Eigen::VectorXd&amp; max_det_z, Eigen
   }
 }
 
-void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray input, UKF&amp; target,
-                                     const bool second_init,
-                                     const Eigen::VectorXd max_det_z, const Eigen::MatrixXd max_det_s,
-                                     std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
-                                     std::vector&lt;bool&gt;&amp; matching_vec)
+void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray input, UKF&amp; target, const bool second_init,
+                                      const Eigen::VectorXd max_det_z, const Eigen::MatrixXd max_det_s,
+                                      std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
+                                      std::vector&lt;bool&gt;&amp; matching_vec)
 {
   int count = 0;
   bool second_init_done = false;
   double smallest_nis = std::numeric_limits&lt;double&gt;::max();
   autoware_msgs::CloudCluster smallest_meas_cluster;
-  for(size_t i = 0; i &lt; input.clusters.size(); i++)
+  for (size_t i = 0; i &lt; input.clusters.size(); i++)
   {
     double x = input.clusters[i].bounding_box.pose.position.x;
     double y = input.clusters[i].bounding_box.pose.position.y;
@@ -139,21 +130,22 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
     meas &lt;&lt; x, y;
 
     Eigen::VectorXd diff = meas - max_det_z;
-    double nis = diff.transpose()*max_det_s.inverse()*diff;
+    double nis = diff.transpose() * max_det_s.inverse() * diff;
 
-    if(nis &lt; gating_thres_)
-    { // x^2 99% range
-      count ++;
-      if(matching_vec[i] == false) target.lifetime_ ++;
+    if (nis &lt; gating_thres_)
+    {  // x^2 99% range
+      count++;
+      if (matching_vec[i] == false)
+        target.lifetime_++;
       // pick one meas with smallest nis
-      if(second_init)
+      if (second_init)
       {
-        if(nis &lt; smallest_nis)
+        if (nis &lt; smallest_nis)
         {
-        smallest_nis = nis;
-        smallest_meas_cluster = input.clusters[i];
-        matching_vec[i] = true;
-        second_init_done = true;
+          smallest_nis = nis;
+          smallest_meas_cluster = input.clusters[i];
+          matching_vec[i] = true;
+          second_init_done = true;
         }
       }
       else
@@ -163,19 +155,19 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
       }
     }
   }
-  if(second_init_done) cluster_vec.push_back(smallest_meas_cluster);
+  if (second_init_done)
+    cluster_vec.push_back(smallest_meas_cluster);
 }
 
-void ImmUkfPda::filterPDA(UKF&amp; target,
-                          const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
+void ImmUkfPda::filterPDA(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
                           std::vector&lt;double&gt;&amp; lambda_vec)
 {
   // calculating association probability
   double num_meas = cluster_vec.size();
-  double b = 2*num_meas*(1-detection_probability_*gate_probability_)/(gating_thres_*detection_probability_);
-  double e_cv_sum   = 0;
+  double b = 2 * num_meas * (1 - detection_probability_ * gate_probability_) / (gating_thres_ * detection_probability_);
+  double e_cv_sum = 0;
   double e_ctrv_sum = 0;
-  double e_rm_sum   = 0;
+  double e_rm_sum = 0;
 
   std::vector&lt;double&gt; e_cv_vec;
   std::vector&lt;double&gt; e_ctrv_vec;
@@ -185,46 +177,45 @@ void ImmUkfPda::filterPDA(UKF&amp; target,
   std::vector&lt;Eigen::VectorXd&gt; diff_ctrv_vec;
   std::vector&lt;Eigen::VectorXd&gt; diff_rm_vec;
 
-  for(size_t i = 0; i &lt; num_meas; i++)
+  for (size_t i = 0; i &lt; num_meas; i++)
   {
     Eigen::VectorXd meas_vec = Eigen::VectorXd(2);
     meas_vec(0) = cluster_vec[i].bounding_box.pose.position.x;
     meas_vec(1) = cluster_vec[i].bounding_box.pose.position.y;
 
-    Eigen::VectorXd diff_cv   = meas_vec - target.z_pred_cv_;
+    Eigen::VectorXd diff_cv = meas_vec - target.z_pred_cv_;
     Eigen::VectorXd diff_ctrv = meas_vec - target.z_pred_ctrv_;
-    Eigen::VectorXd diff_rm   = meas_vec - target.z_pred_rm_;
+    Eigen::VectorXd diff_rm = meas_vec - target.z_pred_rm_;
 
     diff_cv_vec.push_back(diff_cv);
     diff_ctrv_vec.push_back(diff_ctrv);
     diff_rm_vec.push_back(diff_rm);
 
-    double e_cv   = exp(  -0.5*diff_cv.transpose()*  target.s_cv_.inverse()  *diff_cv);
-    double e_ctrv = exp(-0.5*diff_ctrv.transpose()*  target.s_ctrv_.inverse()*diff_ctrv);
-    double e_rm   = exp(  -0.5*diff_rm.transpose()*  target.s_rm_.inverse()  *diff_rm);
+    double e_cv = exp(-0.5 * diff_cv.transpose() * target.s_cv_.inverse() * diff_cv);
+    double e_ctrv = exp(-0.5 * diff_ctrv.transpose() * target.s_ctrv_.inverse() * diff_ctrv);
+    double e_rm = exp(-0.5 * diff_rm.transpose() * target.s_rm_.inverse() * diff_rm);
 
     e_cv_vec.push_back(e_cv);
     e_ctrv_vec.push_back(e_ctrv);
     e_rm_vec.push_back(e_rm);
 
-    e_cv_sum   += e_cv;
+    e_cv_sum += e_cv;
     e_ctrv_sum += e_ctrv;
-    e_rm_sum   += e_rm;
+    e_rm_sum += e_rm;
   }
-  double beta_cv_zero   = b/(b+e_cv_sum);
-  double beta_ctrv_zero = b/(b+e_ctrv_sum);
-  double beta_rm_zero   = b/(b+e_rm_sum);
+  double beta_cv_zero = b / (b + e_cv_sum);
+  double beta_ctrv_zero = b / (b + e_ctrv_sum);
+  double beta_rm_zero = b / (b + e_rm_sum);
 
   std::vector&lt;double&gt; beta_cv;
   std::vector&lt;double&gt; beta_ctrv;
   std::vector&lt;double&gt; beta_rm;
 
-
-  for(size_t i = 0; i &lt; num_meas; i++)
+  for (size_t i = 0; i &lt; num_meas; i++)
   {
-    double temp_cv   = e_cv_vec[i]/(b+e_cv_sum);
-    double temp_ctrv = e_ctrv_vec[i]/(b+e_ctrv_sum);
-    double temp_rm   = e_rm_vec[i]/(b+e_rm_sum);
+    double temp_cv = e_cv_vec[i] / (b + e_cv_sum);
+    double temp_ctrv = e_ctrv_vec[i] / (b + e_ctrv_sum);
+    double temp_rm = e_rm_vec[i] / (b + e_rm_sum);
 
     beta_cv.push_back(temp_cv);
     beta_ctrv.push_back(temp_ctrv);
@@ -237,87 +228,98 @@ void ImmUkfPda::filterPDA(UKF&amp; target,
   sigma_x_ctrv.setZero(2);
   sigma_x_rm.setZero(2);
 
-  for(size_t i = 0; i &lt; num_meas; i++)
+  for (size_t i = 0; i &lt; num_meas; i++)
   {
-    sigma_x_cv   += beta_cv[i]*diff_cv_vec[i];
-    sigma_x_ctrv += beta_ctrv[i]*diff_ctrv_vec[i];
-    sigma_x_rm   += beta_rm[i]*diff_rm_vec[i];
+    sigma_x_cv += beta_cv[i] * diff_cv_vec[i];
+    sigma_x_ctrv += beta_ctrv[i] * diff_ctrv_vec[i];
+    sigma_x_rm += beta_rm[i] * diff_rm_vec[i];
   }
 
   Eigen::MatrixXd sigma_p_cv;
   Eigen::MatrixXd sigma_p_ctrv;
   Eigen::MatrixXd sigma_p_rm;
-  sigma_p_cv.setZero(2,2);
-  sigma_p_ctrv.setZero(2,2);
-  sigma_p_rm.setZero(2,2);
-  for(size_t i = 0; i &lt; num_meas; i++)
+  sigma_p_cv.setZero(2, 2);
+  sigma_p_ctrv.setZero(2, 2);
+  sigma_p_rm.setZero(2, 2);
+  for (size_t i = 0; i &lt; num_meas; i++)
   {
-    sigma_p_cv   += (beta_cv[i]  *diff_cv_vec[i]  *diff_cv_vec[i].transpose()     - sigma_x_cv*sigma_x_cv.transpose());
-    sigma_p_ctrv += (beta_ctrv[i]*diff_ctrv_vec[i]*diff_ctrv_vec[i].transpose()   - sigma_x_ctrv*sigma_x_ctrv.transpose());
-    sigma_p_rm   += (beta_rm[i]  *diff_rm_vec[i]  *diff_rm_vec[i].transpose()     - sigma_x_rm*sigma_x_rm.transpose());
+    sigma_p_cv += (beta_cv[i] * diff_cv_vec[i] * diff_cv_vec[i].transpose() - sigma_x_cv * sigma_x_cv.transpose());
+    sigma_p_ctrv +=
+        (beta_ctrv[i] * diff_ctrv_vec[i] * diff_ctrv_vec[i].transpose() - sigma_x_ctrv * sigma_x_ctrv.transpose());
+    sigma_p_rm += (beta_rm[i] * diff_rm_vec[i] * diff_rm_vec[i].transpose() - sigma_x_rm * sigma_x_rm.transpose());
   }
 
   // update x and P
-  target.x_cv_   = target.x_cv_   + target.k_cv_*sigma_x_cv;
-  target.x_ctrv_ = target.x_ctrv_ + target.k_ctrv_*sigma_x_ctrv;
-  target.x_rm_   = target.x_rm_   + target.k_rm_*sigma_x_rm;
-
-  while (target.x_cv_(3)&gt; M_PI) target.x_cv_(3) -= 2.*M_PI;
-  while (target.x_cv_(3)&lt;-M_PI) target.x_cv_(3) += 2.*M_PI;
-  while (target.x_ctrv_(3)&gt; M_PI) target.x_ctrv_(3) -= 2.*M_PI;
-  while (target.x_ctrv_(3)&lt;-M_PI) target.x_ctrv_(3) += 2.*M_PI;
-  while (target.x_rm_(3)&gt; M_PI) target.x_rm_(3) -= 2.*M_PI;
-  while (target.x_rm_(3)&lt;-M_PI) target.x_rm_(3) += 2.*M_PI;
-
-  if(num_meas != 0)
-  {
-    target.p_cv_   = beta_cv_zero*target.p_cv_ +
-                (1-beta_cv_zero)*(target.p_cv_ - target.k_cv_*target.s_cv_*target.k_cv_.transpose()) +
-                target.k_cv_*sigma_p_cv*target.k_cv_.transpose();
-    target.p_ctrv_ = beta_ctrv_zero*target.p_ctrv_ +
-                  (1-beta_ctrv_zero)*(target.p_ctrv_ - target.k_ctrv_*target.s_ctrv_*target.k_ctrv_.transpose()) +
-                  target.k_ctrv_*sigma_p_ctrv*target.k_ctrv_.transpose();
-    target.p_rm_   = beta_rm_zero*target.p_rm_ +
-                  (1-beta_rm_zero)*(target.p_rm_ - target.k_rm_*target.s_rm_*target.k_rm_.transpose()) +
-                  target.k_rm_*sigma_p_rm*target.k_rm_.transpose();
+  target.x_cv_ = target.x_cv_ + target.k_cv_ * sigma_x_cv;
+  target.x_ctrv_ = target.x_ctrv_ + target.k_ctrv_ * sigma_x_ctrv;
+  target.x_rm_ = target.x_rm_ + target.k_rm_ * sigma_x_rm;
+
+  while (target.x_cv_(3) &gt; M_PI)
+    target.x_cv_(3) -= 2. * M_PI;
+  while (target.x_cv_(3) &lt; -M_PI)
+    target.x_cv_(3) += 2. * M_PI;
+  while (target.x_ctrv_(3) &gt; M_PI)
+    target.x_ctrv_(3) -= 2. * M_PI;
+  while (target.x_ctrv_(3) &lt; -M_PI)
+    target.x_ctrv_(3) += 2. * M_PI;
+  while (target.x_rm_(3) &gt; M_PI)
+    target.x_rm_(3) -= 2. * M_PI;
+  while (target.x_rm_(3) &lt; -M_PI)
+    target.x_rm_(3) += 2. * M_PI;
+
+  if (num_meas != 0)
+  {
+    target.p_cv_ = beta_cv_zero * target.p_cv_ +
+                   (1 - beta_cv_zero) * (target.p_cv_ - target.k_cv_ * target.s_cv_ * target.k_cv_.transpose()) +
+                   target.k_cv_ * sigma_p_cv * target.k_cv_.transpose();
+    target.p_ctrv_ =
+        beta_ctrv_zero * target.p_ctrv_ +
+        (1 - beta_ctrv_zero) * (target.p_ctrv_ - target.k_ctrv_ * target.s_ctrv_ * target.k_ctrv_.transpose()) +
+        target.k_ctrv_ * sigma_p_ctrv * target.k_ctrv_.transpose();
+    target.p_rm_ = beta_rm_zero * target.p_rm_ +
+                   (1 - beta_rm_zero) * (target.p_rm_ - target.k_rm_ * target.s_rm_ * target.k_rm_.transpose()) +
+                   target.k_rm_ * sigma_p_rm * target.k_rm_.transpose();
   }
   else
   {
-    target.p_cv_   = target.p_cv_   - target.k_cv_  *target.s_cv_  *target.k_cv_.transpose();
-    target.p_ctrv_ = target.p_ctrv_ - target.k_ctrv_*target.s_ctrv_*target.k_ctrv_.transpose();
-    target.p_rm_   = target.p_rm_   - target.k_rm_  *target.s_rm_  *target.k_rm_.transpose();
+    target.p_cv_ = target.p_cv_ - target.k_cv_ * target.s_cv_ * target.k_cv_.transpose();
+    target.p_ctrv_ = target.p_ctrv_ - target.k_ctrv_ * target.s_ctrv_ * target.k_ctrv_.transpose();
+    target.p_rm_ = target.p_rm_ - target.k_rm_ * target.s_rm_ * target.k_rm_.transpose();
   }
 
   Eigen::VectorXd max_det_z;
   Eigen::MatrixXd max_det_s;
 
   findMaxZandS(target, max_det_z, max_det_s);
-  double Vk =  M_PI *sqrt(gating_thres_ * max_det_s.determinant());
+  double Vk = M_PI * sqrt(gating_thres_ * max_det_s.determinant());
 
   double lambda_cv, lambda_ctrv, lambda_rm;
-  if(num_meas != 0)
-  {
-    lambda_cv   = (1 - gate_probability_*detection_probability_)/pow(Vk, num_meas) +
-                        detection_probability_*pow(Vk, 1-num_meas)*e_cv_sum/(num_meas*sqrt(2*M_PI*target.s_cv_.determinant()));
-    lambda_ctrv = (1 - gate_probability_*detection_probability_)/pow(Vk, num_meas) +
-                        detection_probability_*pow(Vk, 1-num_meas)*e_ctrv_sum/(num_meas*sqrt(2*M_PI*target.s_ctrv_.determinant()));
-    lambda_rm   = (1 - gate_probability_*detection_probability_)/pow(Vk, num_meas) +
-                        detection_probability_*pow(Vk, 1-num_meas)*e_rm_sum/(num_meas*sqrt(2*M_PI*target.s_rm_.determinant()));
+  if (num_meas != 0)
+  {
+    lambda_cv = (1 - gate_probability_ * detection_probability_) / pow(Vk, num_meas) +
+                detection_probability_ * pow(Vk, 1 - num_meas) * e_cv_sum /
+                    (num_meas * sqrt(2 * M_PI * target.s_cv_.determinant()));
+    lambda_ctrv = (1 - gate_probability_ * detection_probability_) / pow(Vk, num_meas) +
+                  detection_probability_ * pow(Vk, 1 - num_meas) * e_ctrv_sum /
+                      (num_meas * sqrt(2 * M_PI * target.s_ctrv_.determinant()));
+    lambda_rm = (1 - gate_probability_ * detection_probability_) / pow(Vk, num_meas) +
+                detection_probability_ * pow(Vk, 1 - num_meas) * e_rm_sum /
+                    (num_meas * sqrt(2 * M_PI * target.s_rm_.determinant()));
   }
   else
   {
-    lambda_cv   = (1 - gate_probability_*detection_probability_)/pow(Vk, num_meas);
-    lambda_ctrv = (1 - gate_probability_*detection_probability_)/pow(Vk, num_meas);
-    lambda_rm   = (1 - gate_probability_*detection_probability_)/pow(Vk, num_meas);
+    lambda_cv = (1 - gate_probability_ * detection_probability_) / pow(Vk, num_meas);
+    lambda_ctrv = (1 - gate_probability_ * detection_probability_) / pow(Vk, num_meas);
+    lambda_rm = (1 - gate_probability_ * detection_probability_) / pow(Vk, num_meas);
   }
   lambda_vec.push_back(lambda_cv);
   lambda_vec.push_back(lambda_ctrv);
   lambda_vec.push_back(lambda_rm);
 }
 
-void ImmUkfPda::getNearestEuclidCluster(const UKF target,
-                                        const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
-                                        autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist){
+void ImmUkfPda::getNearestEuclidCluster(const UKF target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
+                                        autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist)
+{
   int min_ind = 0;
   double px = target.x_merge_(0);
   double py = target.x_merge_(1);
@@ -327,8 +329,8 @@ void ImmUkfPda::getNearestEuclidCluster(const UKF target,
     double meas_x = cluster_vec[i].bounding_box.pose.position.x;
     double meas_y = cluster_vec[i].bounding_box.pose.position.y;
 
-    double dist = sqrt((px-meas_x)*(px-meas_x)+(py-meas_y)*(py-meas_y));
-    if(dist &lt; min_dist)
+    double dist = sqrt((px - meas_x) * (px - meas_x) + (py - meas_y) * (py - meas_y));
+    if (dist &lt; min_dist)
     {
       min_dist = dist;
       min_ind = i;
@@ -338,30 +340,26 @@ void ImmUkfPda::getNearestEuclidCluster(const UKF target,
   cluster = cluster_vec[min_ind];
 }
 
-
-void ImmUkfPda::associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
-                            UKF&amp; target)
+void ImmUkfPda::associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target)
 {
-  //skip if no validated measurement
-  if(cluster_vec.size() == 0)
+  // skip if no validated measurement
+  if (cluster_vec.size() == 0)
   {
-      return;
+    return;
   }
-  if(target.tracking_num_ == TrackingState::Stable &amp;&amp; target.lifetime_ &gt;= life_time_thres_)
+  if (target.tracking_num_ == TrackingState::Stable &amp;&amp; target.lifetime_ &gt;= life_time_thres_)
   {
     autoware_msgs::CloudCluster nearest_cluster;
     double min_dist = std::numeric_limits&lt;double&gt;::max();
     getNearestEuclidCluster(target, cluster_vec, nearest_cluster, min_dist);
-    if(min_dist &lt; distance_thres_)
+    if (min_dist &lt; distance_thres_)
     {
       target.is_vis_bb_ = true;
-      target.jsk_bb_   = nearest_cluster.bounding_box;
+      target.jsk_bb_ = nearest_cluster.bounding_box;
     }
   }
 }
 
-
-
 double ImmUkfPda::getBboxArea(const pcl::PointCloud&lt;pcl::PointXYZ&gt; bbox)
 {
   pcl::PointXYZ p1 = bbox[0];
@@ -369,46 +367,43 @@ double ImmUkfPda::getBboxArea(const pcl::PointCloud&lt;pcl::PointXYZ&gt; bbox)
   pcl::PointXYZ p3 = bbox[2];
   pcl::PointXYZ p4 = bbox[3];
 
-  //S=tri(p1,p2,p3) + tri(p1, p3, p4)
-  //s(triangle) = 1/2*|(x1−x3)(y2−y3)−(x2−x3)(y1−y3)|
-  double tri1 = 0.5*abs((p1.x - p3.x)*(p2.y - p3.y) - (p2.x - p3.x)*(p1.y - p3.y));
-  double tri2 = 0.5*abs((p1.x - p4.x)*(p3.y - p4.y) - (p3.x - p4.x)*(p1.y - p4.y));
+  // S=tri(p1,p2,p3) + tri(p1, p3, p4)
+  // s(triangle) = 1/2*|(x1−x3)(y2−y3)−(x2−x3)(y1−y3)|
+  double tri1 = 0.5 * abs((p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y));
+  double tri2 = 0.5 * abs((p1.x - p4.x) * (p3.y - p4.y) - (p3.x - p4.x) * (p1.y - p4.y));
   double S = tri1 + tri2;
   return S;
 }
 
-
-
-
 double ImmUkfPda::getJskBBoxYaw(const jsk_recognition_msgs::BoundingBox jsk_bb)
 {
-    tf::Quaternion q(jsk_bb.pose.orientation.x, jsk_bb.pose.orientation.y,
-                    jsk_bb.pose.orientation.z, jsk_bb.pose.orientation.w);
-    double roll, pitch, yaw;
-    tf::Matrix3x3(q).getRPY(roll, pitch, yaw);
-    return yaw;
+  tf::Quaternion q(jsk_bb.pose.orientation.x, jsk_bb.pose.orientation.y, jsk_bb.pose.orientation.z,
+                   jsk_bb.pose.orientation.w);
+  double roll, pitch, yaw;
+  tf::Matrix3x3(q).getRPY(roll, pitch, yaw);
+  return yaw;
 }
 
 double ImmUkfPda::getJskBBoxArea(const jsk_recognition_msgs::BoundingBox jsk_bb)
 {
-    double area = jsk_bb.dimensions.x*jsk_bb.dimensions.y;
-    return area;
+  double area = jsk_bb.dimensions.x * jsk_bb.dimensions.y;
+  return area;
 }
 
 void ImmUkfPda::updateBB(UKF&amp; target)
 {
   // skip to prevent memory leak by accessing empty target.bbox_
-  if(!target.is_vis_bb_)
+  if (!target.is_vis_bb_)
   {
-      return;
+    return;
   }
   double yaw = getJskBBoxYaw(target.jsk_bb_);
 
   // skip the rest of process if it is first bbox associaiton
-  if(target.is_best_jsk_bb_empty_ == false)
+  if (target.is_best_jsk_bb_empty_ == false)
   {
     target.best_jsk_bb_ = target.jsk_bb_;
-    target.best_yaw_   = yaw;
+    target.best_yaw_ = yaw;
     target.is_best_jsk_bb_empty_ = true;
     return;
   }
@@ -428,7 +423,7 @@ void ImmUkfPda::updateBB(UKF&amp; target)
   // }
 
   // // bbox area
-  double area     = getJskBBoxArea(target.jsk_bb_);
+  double area = getJskBBoxArea(target.jsk_bb_);
   double best_area = getJskBBoxArea(target.best_jsk_bb_);
   // double bestArea = getBboxArea(target.bestBBox_);
 
@@ -436,19 +431,19 @@ void ImmUkfPda::updateBB(UKF&amp; target)
   double delta_area = area - best_area;
 
   // when the delta area is under 0, keep best area and relocate(slide) it for current cp
-  if( delta_area &lt; 0 )
+  if (delta_area &lt; 0)
   {
     // updateVisBoxArea(target, dtCP);
     target.jsk_bb_.dimensions = target.best_jsk_bb_.dimensions;
     // for  mergeSegmentation, area comparison
     target.bb_area_ = best_area;
   }
-  else if(delta_area &gt; 0)
+  else if (delta_area &gt; 0)
   {
     // target.bestBBox_ = target.BBox_;
     target.best_jsk_bb_.dimensions = target.jsk_bb_.dimensions;
     // for mergeSegmentation, area comparison
-    target.bb_area_  = area;
+    target.bb_area_ = area;
   }
 }
 
@@ -461,7 +456,7 @@ void ImmUkfPda::updateBB(UKF&amp; target)
 //
 // }
 
-//naive method
+// naive method
 // void ImmUkfPda::mergeOverSegmentation(const std::vector&lt;UKF&gt; targets){
 //     // cout &lt;&lt; "mergeOverSegmentation"&lt;&lt;endl;
 //     for(size_t i = 0; i &lt; targets.size(); i++){
@@ -507,19 +502,19 @@ void ImmUkfPda::updateLabel(UKF target, autoware_msgs::DetectedObject&amp; dd)
 {
   int tracking_num = target.tracking_num_;
   // cout &lt;&lt; "trackingnum "&lt;&lt; trackingNum &lt;&lt; endl;
-  if(target.is_static_)
+  if (target.is_static_)
   {
     dd.label = "Static";
   }
-  else if(tracking_num &gt; TrackingState::Die &amp;&amp; tracking_num &lt; TrackingState::Stable)
+  else if (tracking_num &gt; TrackingState::Die &amp;&amp; tracking_num &lt; TrackingState::Stable)
   {
     dd.label = "Initialized";
   }
-  else if(tracking_num == TrackingState::Stable)
+  else if (tracking_num == TrackingState::Stable)
   {
     dd.label = "Stable";
   }
-  else if(tracking_num &gt; TrackingState::Stable &amp;&amp; tracking_num &lt;= TrackingState::Lost)
+  else if (tracking_num &gt; TrackingState::Stable &amp;&amp; tracking_num &lt;= TrackingState::Lost)
   {
     dd.label = "Lost";
   }
@@ -533,13 +528,13 @@ void ImmUkfPda::updateJskLabel(UKF target, jsk_recognition_msgs::BoundingBox&amp; bb
 {
   int tracking_num = target.tracking_num_;
   // cout &lt;&lt; "trackingnum "&lt;&lt; trackingNum &lt;&lt; endl;
-  if(target.is_static_)
+  if (target.is_static_)
   {
-    bb.label = 15;//white color
+    bb.label = 15;  // white color
   }
-  else if(tracking_num == TrackingState::Stable)
+  else if (tracking_num == TrackingState::Stable)
   {
-    bb.label = 2;//orange color
+    bb.label = 2;  // orange color
   }
 }
 
@@ -547,7 +542,7 @@ bool ImmUkfPda::isVisible(UKF target)
 {
   bool is_visible = false;
   int tracking_num = target.tracking_num_;
-  if(tracking_num == TrackingState::Stable || target.is_static_)
+  if (tracking_num == TrackingState::Stable || target.is_static_)
   {
     is_visible = true;
   }
@@ -560,7 +555,7 @@ bool ImmUkfPda::isVisible(UKF target)
 
 void ImmUkfPda::initTracker(autoware_msgs::CloudClusterArray input, double timestamp)
 {
-  for(size_t i = 0; i &lt; input.clusters.size(); i++)
+  for (size_t i = 0; i &lt; input.clusters.size(); i++)
   {
     double px = input.clusters[i].bounding_box.pose.position.x;
     double py = input.clusters[i].bounding_box.pose.position.y;
@@ -578,7 +573,7 @@ void ImmUkfPda::initTracker(autoware_msgs::CloudClusterArray input, double times
 
 void ImmUkfPda::secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target)
 {
-  if(cluster_vec.size() == 0)
+  if (cluster_vec.size() == 0)
   {
     target.tracking_num_ = TrackingState::Die;
     return;
@@ -592,11 +587,13 @@ void ImmUkfPda::secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; c
   double target_diff_x = target_x - target.x_merge_(0);
   double target_diff_y = target_y - target.x_merge_(1);
   double target_yaw = atan2(target_diff_y, target_diff_x);
-  double dist      = sqrt(target_diff_x*target_diff_x + target_diff_y* target_diff_y);
-  double target_v   = dist/dt;
+  double dist = sqrt(target_diff_x * target_diff_x + target_diff_y * target_diff_y);
+  double target_v = dist / dt;
 
-  while (target_yaw&gt; M_PI) target_yaw -= 2.*M_PI;
-  while (target_yaw&lt;-M_PI) target_yaw += 2.*M_PI;
+  while (target_yaw &gt; M_PI)
+    target_yaw -= 2. * M_PI;
+  while (target_yaw &lt; -M_PI)
+    target_yaw += 2. * M_PI;
 
   target.x_merge_(0) = target.x_cv_(0) = target.x_ctrv_(0) = target.x_rm_(0) = target_x;
   target.x_merge_(1) = target.x_cv_(1) = target.x_ctrv_(1) = target.x_rm_(1) = target_y;
@@ -609,36 +606,36 @@ void ImmUkfPda::secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; c
 
 void ImmUkfPda::updateTrackingNum(std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target)
 {
-  if(cluster_vec.size() &gt; 0)
+  if (cluster_vec.size() &gt; 0)
   {
-    if(target.tracking_num_ &lt; TrackingState::Stable)
+    if (target.tracking_num_ &lt; TrackingState::Stable)
     {
       target.tracking_num_++;
     }
-    else if(target.tracking_num_ == TrackingState::Stable)
+    else if (target.tracking_num_ == TrackingState::Stable)
     {
       target.tracking_num_ = TrackingState::Stable;
     }
-    else if(target.tracking_num_ &gt;= TrackingState::Stable &amp;&amp; target.tracking_num_ &lt; TrackingState::Lost)
+    else if (target.tracking_num_ &gt;= TrackingState::Stable &amp;&amp; target.tracking_num_ &lt; TrackingState::Lost)
     {
       target.tracking_num_ = TrackingState::Stable;
     }
-    else if(target.tracking_num_ == TrackingState::Lost)
+    else if (target.tracking_num_ == TrackingState::Lost)
     {
       target.tracking_num_ = TrackingState::Die;
     }
   }
   else
   {
-    if(target.tracking_num_ &lt; TrackingState::Stable)
+    if (target.tracking_num_ &lt; TrackingState::Stable)
     {
       target.tracking_num_ = TrackingState::Die;
     }
-    else if(target.tracking_num_ &gt;= TrackingState::Stable &amp;&amp; target.tracking_num_ &lt; TrackingState::Lost)
+    else if (target.tracking_num_ &gt;= TrackingState::Stable &amp;&amp; target.tracking_num_ &lt; TrackingState::Lost)
     {
       target.tracking_num_++;
     }
-    else if(target.tracking_num_ == TrackingState::Lost)
+    else if (target.tracking_num_ == TrackingState::Lost)
     {
       target.tracking_num_ = TrackingState::Die;
     }
@@ -647,9 +644,9 @@ void ImmUkfPda::updateTrackingNum(std::vector&lt;autoware_msgs::CloudCluster&gt; clust
   return;
 }
 
-void ImmUkfPda::probabilisticDataAssociation(autoware_msgs::CloudClusterArray input,
-                                            double dt, double det_explode_param, std::vector&lt;bool&gt;&amp; matching_vec,
-                                            std::vector&lt;double&gt;&amp; lambda_vec, UKF&amp; target, bool&amp; is_skip_target)
+void ImmUkfPda::probabilisticDataAssociation(autoware_msgs::CloudClusterArray input, double dt,
+                                             double det_explode_param, std::vector&lt;bool&gt;&amp; matching_vec,
+                                             std::vector&lt;double&gt;&amp; lambda_vec, UKF&amp; target, bool&amp; is_skip_target)
 {
   Eigen::VectorXd max_det_z;
   Eigen::MatrixXd max_det_s;
@@ -661,15 +658,15 @@ void ImmUkfPda::probabilisticDataAssociation(autoware_msgs::CloudClusterArray in
   double det_s = max_det_s.determinant();
 
   // prevent ukf not to explode
-  if(std::isnan(det_s)|| det_s &gt; det_explode_param)
+  if (std::isnan(det_s) || det_s &gt; det_explode_param)
   {
-      target.tracking_num_ = TrackingState::Die;
-      is_skip_target = true;
-      return;
+    target.tracking_num_ = TrackingState::Die;
+    is_skip_target = true;
+    return;
   }
 
   bool is_second_init;
-  if(target.tracking_num_ == TrackingState::Init)
+  if (target.tracking_num_ == TrackingState::Init)
   {
     is_second_init = true;
   }
@@ -679,14 +676,14 @@ void ImmUkfPda::probabilisticDataAssociation(autoware_msgs::CloudClusterArray in
   }
 
   // measurement gating, get measVec, bboxVec, matchingVec through reference
-  measurementValidation(input, target, is_second_init, max_det_z, max_det_s, cluster_vec,matching_vec);
+  measurementValidation(input, target, is_second_init, max_det_z, max_det_s, cluster_vec, matching_vec);
 
   // bounding box association if target is stable :plus, right angle correction if its needed
   // input: track number, bbox measurements, &amp;target
   associateBB(cluster_vec, target);
 
   // second detection for a target: update v and yaw
-  if(is_second_init)
+  if (is_second_init)
   {
     secondInit(dt, cluster_vec, target);
     is_skip_target = true;
@@ -696,7 +693,7 @@ void ImmUkfPda::probabilisticDataAssociation(autoware_msgs::CloudClusterArray in
   // update tracking number
   updateTrackingNum(cluster_vec, target);
 
-  if(target.tracking_num_ == TrackingState::Die)
+  if (target.tracking_num_ == TrackingState::Die)
   {
     is_skip_target = true;
     return;
@@ -706,9 +703,9 @@ void ImmUkfPda::probabilisticDataAssociation(autoware_msgs::CloudClusterArray in
 
 void ImmUkfPda::makeNewTargets(double timestamp, autoware_msgs::CloudClusterArray input, std::vector&lt;bool&gt; matching_vec)
 {
-  for(size_t i = 0; i &lt; input.clusters.size(); i ++)
+  for (size_t i = 0; i &lt; input.clusters.size(); i++)
   {
-    if(matching_vec[i] == false)
+    if (matching_vec[i] == false)
     {
       double px = input.clusters[i].bounding_box.pose.position.x;
       double py = input.clusters[i].bounding_box.pose.position.y;
@@ -727,24 +724,23 @@ void ImmUkfPda::staticClassification()
 {
   for (size_t i = 0; i &lt; targets_.size(); i++)
   {
-    if(!targets_[i].is_static_ &amp;&amp;
-     targets_[i].tracking_num_ == TrackingState::Stable &amp;&amp;
-     targets_[i].lifetime_ &gt; life_time_thres_ )
+    if (!targets_[i].is_static_ &amp;&amp; targets_[i].tracking_num_ == TrackingState::Stable &amp;&amp;
+        targets_[i].lifetime_ &gt; life_time_thres_)
     {
       // double dist_thres = 3.0;
-      if((targets_[i].dist_from_init_ &lt; static_distance_thres_)&amp;&amp;
+      if ((targets_[i].dist_from_init_ &lt; static_distance_thres_) &amp;&amp;
           (targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_cv_ ||
-           targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_ctrv_ ))
+           targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_ctrv_))
       {
-        targets_[i].is_static_    = true;
+        targets_[i].is_static_ = true;
       }
     }
   }
 }
 
 void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
-                           jsk_recognition_msgs::BoundingBoxArray &amp;jskbboxes_output,
-                           autoware_msgs::DetectedObjectArray &amp;detected_objects_output)
+                           jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
+                           autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
 {
   tf::StampedTransform transform;
   tf_listener_-&gt;lookupTransform(tracking_frame_, pointcloud_frame_, ros::Time(0), transform);
@@ -757,23 +753,25 @@ void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
   // output.header = input.header;
   jskbboxes_output.header = input.header;
   detected_objects_output.header = input.header;
-  for(size_t i = 0; i &lt; targets_.size(); i++)
+  for (size_t i = 0; i &lt; targets_.size(); i++)
   {
-    if(targets_[i].is_vis_bb_ &amp;&amp; isVisible(targets_[i]))
+    if (targets_[i].is_vis_bb_ &amp;&amp; isVisible(targets_[i]))
     {
       double tx = targets_[i].x_merge_(0);
       double ty = targets_[i].x_merge_(1);
       double mx = targets_[i].init_meas_(0);
       double my = targets_[i].init_meas_(1);
 
-      //for static classification
-      targets_[i].dist_from_init_ = sqrt((tx - mx)*(tx - mx) + (ty - my)*(ty - my));
+      // for static classification
+      targets_[i].dist_from_init_ = sqrt((tx - mx) * (tx - mx) + (ty - my) * (ty - my));
 
       double tv = targets_[i].x_merge_(2);
       double tyaw = targets_[i].x_merge_(3) - yaw;
 
-      while (tyaw&gt; M_PI) tyaw -= 2.*M_PI;
-      while (tyaw&lt;-M_PI) tyaw += 2.*M_PI;
+      while (tyaw &gt; M_PI)
+        tyaw -= 2. * M_PI;
+      while (tyaw &lt; -M_PI)
+        tyaw += 2. * M_PI;
 
       jsk_recognition_msgs::BoundingBox bb;
       bb.header = input.header;
@@ -795,48 +793,47 @@ void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
 }
 
 void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
-             jsk_recognition_msgs::BoundingBoxArray &amp;jskbboxes_output,
-             autoware_msgs::DetectedObjectArray &amp;detected_objects_output)
+                        jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
+                        autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
 {
   double timestamp = input.header.stamp.toSec();
 
   double det_explode_param = 10;
   double cov_explode_param = 1000;
 
-  if(!init_)
+  if (!init_)
   {
     initTracker(input, timestamp);
     return;
   }
 
-
   double dt = (timestamp - timestamp_);
   timestamp_ = timestamp;
   // // used for making new target with no data association
-  std::vector&lt;bool&gt; matching_vec(input.clusters.size(), false); // make 0 vector
+  std::vector&lt;bool&gt; matching_vec(input.clusters.size(), false);  // make 0 vector
 
   // start UKF process
-  for(size_t i = 0; i &lt; targets_.size(); i++)
+  for (size_t i = 0; i &lt; targets_.size(); i++)
   {
-    //reset is_vis_bb_ to false
+    // reset is_vis_bb_ to false
     targets_[i].is_vis_bb_ = false;
 
-    //todo: modify here. This skips irregular measurement and nan
-    if(targets_[i].tracking_num_ == TrackingState::Die) continue;
+    // todo: modify here. This skips irregular measurement and nan
+    if (targets_[i].tracking_num_ == TrackingState::Die)
+      continue;
     // prevent ukf not to explode
-    if(targets_[i].p_merge_.determinant() &gt; det_explode_param || targets_[i].p_merge_(4,4) &gt; cov_explode_param)
+    if (targets_[i].p_merge_.determinant() &gt; det_explode_param || targets_[i].p_merge_(4, 4) &gt; cov_explode_param)
     {
-        targets_[i].tracking_num_ = TrackingState::Die;
-        continue;
+      targets_[i].tracking_num_ = TrackingState::Die;
+      continue;
     }
     // immukf prediction step
     targets_[i].predictionIMMUKF(dt);
 
-
     bool is_skip_target;
     std::vector&lt;double&gt; lambda_vec;
     probabilisticDataAssociation(input, dt, det_explode_param, matching_vec, lambda_vec, targets_[i], is_skip_target);
-    if(is_skip_target)
+    if (is_skip_target)
       continue;
 
     // immukf update step
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker_main.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker_main.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,8 +1,8 @@
 
 #include "imm_ukf_pda_tracker.h"
 
-int main(int argc, char **argv) {
-
+int main(int argc, char** argv)
+{
   ros::init(argc, argv, "imm_ukf_pda_tracker");
   ImmUkfPda app;
   ros::spin();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" added_lines="199" deleted_lines="209">
				<diff>@@ -37,11 +37,11 @@ UKF::UKF()
   p_rm_ = Eigen::MatrixXd(5, 5);
 
   // Process noise standard deviation longitudinal acceleration in m/s^2
-  std_a_cv_   = 2;
+  std_a_cv_ = 2;
   std_a_ctrv_ = 2;
-  std_a_rm_   = 3;
+  std_a_rm_ = 3;
   std_ctrv_yawdd_ = 2;
-  std_cv_yawdd_   = 2;
+  std_cv_yawdd_ = 2;
   std_rm_yawdd_ = 3;
 
   //------------------
@@ -50,7 +50,6 @@ UKF::UKF()
   // Laser measurement noise standard deviation position2 in m
   std_laspy_ = 0.15;
 
-
   // initially set to false, set to true in first call of ProcessMeasurement
   is_initialized_ = false;
 
@@ -78,10 +77,9 @@ UKF::UKF()
   // predicted sigma points matrix
   x_sig_pred_rm_ = Eigen::MatrixXd(n_x_, 2 * n_aug_ + 1);
 
-  //create vector for weights
+  // create vector for weights
   weights_ = Eigen::VectorXd(2 * n_aug_ + 1);
 
-
   count_ = 0;
   count_empty_ = 0;
 
@@ -102,7 +100,6 @@ UKF::UKF()
   p3_.push_back(0.05);
   p3_.push_back(0.9);
 
-
   mode_match_prob_cv2cv_ = 0;
   mode_match_prob_ctrv2cv_ = 0;
   mode_match_prob_rm2cv_ = 0;
@@ -120,63 +117,54 @@ UKF::UKF()
   mode_prob_rm_ = 0.33;
 
   z_pred_cv_ = Eigen::VectorXd(2);
-  z_pred_ctrv_ =  Eigen::VectorXd(2);
-  z_pred_rm_ =  Eigen::VectorXd(2);
-
-
-  s_cv_   = Eigen::MatrixXd(2,2);
-  s_ctrv_ = Eigen::MatrixXd(2,2);
-  s_rm_   = Eigen::MatrixXd(2,2);
-
-  k_cv_   = Eigen::MatrixXd(2,2);
-  k_ctrv_ = Eigen::MatrixXd(2,2);
-  k_rm_   = Eigen::MatrixXd(2,2);
+  z_pred_ctrv_ = Eigen::VectorXd(2);
+  z_pred_rm_ = Eigen::VectorXd(2);
 
+  s_cv_ = Eigen::MatrixXd(2, 2);
+  s_ctrv_ = Eigen::MatrixXd(2, 2);
+  s_rm_ = Eigen::MatrixXd(2, 2);
 
+  k_cv_ = Eigen::MatrixXd(2, 2);
+  k_ctrv_ = Eigen::MatrixXd(2, 2);
+  k_rm_ = Eigen::MatrixXd(2, 2);
 
   // gamma_g_ = 9.21;
-  pd_     = 0.9;
-  pg_     = 0.99;
+  pd_ = 0.9;
+  pg_ = 0.99;
 
-  //track parameter
+  // track parameter
   lifetime_ = 0;
   is_static_ = false;
 
-  //bounding box params
+  // bounding box params
   is_best_jsk_bb_empty_ = false;
   is_vis_bb_ = false;
   best_yaw_ = 100;
-  bb_yaw_  = 0;
+  bb_yaw_ = 0;
   bb_area_ = 0;
 
-  //for env classification
+  // for env classification
   init_meas_ = Eigen::VectorXd(2);
   dist_from_init_ = 0;
 
   x_merge_yaw_ = 0;
-
 }
 
-
 void UKF::initialize(const Eigen::VectorXd z, const double timestamp)
 {
   // first measurement
   x_merge_ &lt;&lt; 1, 1, 0, 0, 0.1;
 
   // init covariance matrix
-  p_merge_ &lt;&lt;   0.5,    0, 0, 0, 0,
-                  0,  0.5, 0, 0, 0,
-                  0,    0, 3, 0, 0,
-                  0,    0, 0,10, 0,
-                  0,    0, 0, 0, 1;
+  p_merge_ &lt;&lt; 0.5, 0, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 1;
 
   // set weights
   double weight_0 = lambda_aug_ / (lambda_aug_ + n_aug_);
   weights_(0) = weight_0;
   for (int i = 1; i &lt; 2 * n_aug_ + 1; i++)
-  {  //2n+1 weights
-      double weight = 0.5 / (n_aug_ + lambda_aug_);
-      weights_(i) = weight;
+  {  // 2n+1 weights
+    double weight = 0.5 / (n_aug_ + lambda_aug_);
+    weights_(i) = weight;
   }
 
   // init timestamp
@@ -194,47 +182,43 @@ void UKF::initialize(const Eigen::VectorXd z, const double timestamp)
   z_pred_rm_(0) = z(0);
   z_pred_rm_(1) = z(1);
 
-
   x_cv_ = x_ctrv_ = x_rm_ = x_merge_;
   p_cv_ = p_ctrv_ = p_rm_ = p_merge_;
 
+  s_cv_ &lt;&lt; 1, 0, 0, 1;
+  s_ctrv_ &lt;&lt; 1, 0, 0, 1;
+  s_rm_ &lt;&lt; 1, 0, 0, 1;
 
-  s_cv_   &lt;&lt;  1, 0,
-               0, 1;
-  s_ctrv_ &lt;&lt;  1, 0,
-               0, 1;
-  s_rm_   &lt;&lt;  1, 0,
-               0, 1;
-
-  //init tracking num
+  // init tracking num
   tracking_num_ = 1;
 
-  //prevent transform pose error, if the condition meets, target_.jskBB_ would be updated
+  // prevent transform pose error, if the condition meets, target_.jskBB_ would be updated
   jsk_bb_.pose.orientation.x = 1.0;
-
 }
 
-
 void UKF::updateModeProb(const std::vector&lt;double&gt; lambda_vec)
 {
-  double cvGauss   = lambda_vec[0];
+  double cvGauss = lambda_vec[0];
   double ctrvGauss = lambda_vec[1];
-  double rmGauss   = lambda_vec[2];
-  double sumGauss  = cvGauss*mode_prob_cv_ + ctrvGauss*mode_prob_ctrv_ + rmGauss*mode_prob_rm_;
-  mode_prob_cv_   = (cvGauss  *mode_prob_cv_)  /sumGauss;
-  mode_prob_ctrv_ = (ctrvGauss*mode_prob_ctrv_)/sumGauss;
-  mode_prob_rm_   = (rmGauss  *mode_prob_rm_)  /sumGauss;
+  double rmGauss = lambda_vec[2];
+  double sumGauss = cvGauss * mode_prob_cv_ + ctrvGauss * mode_prob_ctrv_ + rmGauss * mode_prob_rm_;
+  mode_prob_cv_ = (cvGauss * mode_prob_cv_) / sumGauss;
+  mode_prob_ctrv_ = (ctrvGauss * mode_prob_ctrv_) / sumGauss;
+  mode_prob_rm_ = (rmGauss * mode_prob_rm_) / sumGauss;
   // prevent each prob from becoming 0
-  if(fabs(mode_prob_cv_)   &lt; 0.0001) mode_prob_cv_   = 0.0001;
-  if(fabs(mode_prob_ctrv_) &lt; 0.0001) mode_prob_ctrv_ = 0.0001;
-  if(fabs(mode_prob_rm_)   &lt; 0.0001) mode_prob_rm_   = 0.0001;
+  if (fabs(mode_prob_cv_) &lt; 0.0001)
+    mode_prob_cv_ = 0.0001;
+  if (fabs(mode_prob_ctrv_) &lt; 0.0001)
+    mode_prob_ctrv_ = 0.0001;
+  if (fabs(mode_prob_rm_) &lt; 0.0001)
+    mode_prob_rm_ = 0.0001;
 }
 
 void UKF::updateYawWithHighProb()
 {
-  if(mode_prob_cv_ &gt; mode_prob_ctrv_)
+  if (mode_prob_cv_ &gt; mode_prob_ctrv_)
   {
-    if(mode_prob_cv_ &gt; mode_prob_rm_)
+    if (mode_prob_cv_ &gt; mode_prob_rm_)
     {
       x_merge_yaw_ = x_cv_(3);
     }
@@ -245,7 +229,7 @@ void UKF::updateYawWithHighProb()
   }
   else
   {
-    if(mode_prob_ctrv_ &gt; mode_prob_rm_)
+    if (mode_prob_ctrv_ &gt; mode_prob_rm_)
     {
       x_merge_yaw_ = x_ctrv_(3);
     }
@@ -259,75 +243,81 @@ void UKF::updateYawWithHighProb()
 
 void UKF::mergeEstimationAndCovariance()
 {
-  x_merge_ = mode_prob_cv_*x_cv_ + mode_prob_ctrv_ *x_ctrv_ + mode_prob_rm_ * x_rm_;
-  while (x_merge_(3)&gt; M_PI) x_merge_(3) -= 2.*M_PI;
-  while (x_merge_(3)&lt;-M_PI) x_merge_(3) += 2.*M_PI;
+  x_merge_ = mode_prob_cv_ * x_cv_ + mode_prob_ctrv_ * x_ctrv_ + mode_prob_rm_ * x_rm_;
+  while (x_merge_(3) &gt; M_PI)
+    x_merge_(3) -= 2. * M_PI;
+  while (x_merge_(3) &lt; -M_PI)
+    x_merge_(3) += 2. * M_PI;
 
   // not interacting yaw(-pi ~ pi)
   updateYawWithHighProb();
 
-  p_merge_ = mode_prob_cv_  *(p_cv_   +(x_cv_   - x_merge_)*(x_cv_   - x_merge_).transpose()) +
-             mode_prob_ctrv_*(p_ctrv_ +(x_ctrv_ - x_merge_)*(x_ctrv_ - x_merge_).transpose())+
-             mode_prob_rm_  *(p_rm_   +(x_rm_   - x_merge_)*(x_rm_   - x_merge_).transpose());
-
+  p_merge_ = mode_prob_cv_ * (p_cv_ + (x_cv_ - x_merge_) * (x_cv_ - x_merge_).transpose()) +
+             mode_prob_ctrv_ * (p_ctrv_ + (x_ctrv_ - x_merge_) * (x_ctrv_ - x_merge_).transpose()) +
+             mode_prob_rm_ * (p_rm_ + (x_rm_ - x_merge_) * (x_rm_ - x_merge_).transpose());
 }
 
 void UKF::mixingProbability()
 {
-  double sumProb1 = mode_prob_cv_*p1_[0]+mode_prob_ctrv_*p2_[0]+mode_prob_rm_*p3_[0];
-  double sumProb2 = mode_prob_cv_*p1_[1]+mode_prob_ctrv_*p2_[1]+mode_prob_rm_*p3_[1];
-  double sumProb3 = mode_prob_cv_*p1_[2]+mode_prob_ctrv_*p2_[2]+mode_prob_rm_*p3_[2];
-  mode_match_prob_cv2cv_     = mode_prob_cv_  *p1_[0]/sumProb1;
-  mode_match_prob_ctrv2cv_   = mode_prob_ctrv_*p2_[0]/sumProb1;
-  mode_match_prob_rm2cv_     = mode_prob_rm_  *p3_[0]/sumProb1;
-
-  mode_match_prob_cv2ctrv_   = mode_prob_cv_  *p1_[1]/sumProb2;
-  mode_match_prob_ctrv2ctrv_ = mode_prob_ctrv_*p2_[1]/sumProb2;
-  mode_match_prob_rm2ctrv_   = mode_prob_rm_  *p3_[1]/sumProb2;
-
-  mode_match_prob_cv2rm_     = mode_prob_cv_  *p1_[2]/sumProb3;
-  mode_match_prob_ctrv2rm_   = mode_prob_ctrv_*p2_[2]/sumProb3;
-  mode_match_prob_rm2rm_     = mode_prob_rm_  *p3_[2]/sumProb3;
+  double sumProb1 = mode_prob_cv_ * p1_[0] + mode_prob_ctrv_ * p2_[0] + mode_prob_rm_ * p3_[0];
+  double sumProb2 = mode_prob_cv_ * p1_[1] + mode_prob_ctrv_ * p2_[1] + mode_prob_rm_ * p3_[1];
+  double sumProb3 = mode_prob_cv_ * p1_[2] + mode_prob_ctrv_ * p2_[2] + mode_prob_rm_ * p3_[2];
+  mode_match_prob_cv2cv_ = mode_prob_cv_ * p1_[0] / sumProb1;
+  mode_match_prob_ctrv2cv_ = mode_prob_ctrv_ * p2_[0] / sumProb1;
+  mode_match_prob_rm2cv_ = mode_prob_rm_ * p3_[0] / sumProb1;
+
+  mode_match_prob_cv2ctrv_ = mode_prob_cv_ * p1_[1] / sumProb2;
+  mode_match_prob_ctrv2ctrv_ = mode_prob_ctrv_ * p2_[1] / sumProb2;
+  mode_match_prob_rm2ctrv_ = mode_prob_rm_ * p3_[1] / sumProb2;
+
+  mode_match_prob_cv2rm_ = mode_prob_cv_ * p1_[2] / sumProb3;
+  mode_match_prob_ctrv2rm_ = mode_prob_ctrv_ * p2_[2] / sumProb3;
+  mode_match_prob_rm2rm_ = mode_prob_rm_ * p3_[2] / sumProb3;
 }
 
-
 void UKF::interaction()
 {
-  Eigen::MatrixXd x_pre_cv   = x_cv_;
+  Eigen::MatrixXd x_pre_cv = x_cv_;
   Eigen::MatrixXd x_pre_ctrv = x_ctrv_;
-  Eigen::MatrixXd x_pre_rm   = x_rm_;
-  Eigen::MatrixXd p_pre_cv   = p_cv_;
+  Eigen::MatrixXd x_pre_rm = x_rm_;
+  Eigen::MatrixXd p_pre_cv = p_cv_;
   Eigen::MatrixXd p_pre_ctrv = p_ctrv_;
-  Eigen::MatrixXd p_pre_rm   = p_rm_;
-  x_cv_   = mode_match_prob_cv2cv_  *x_pre_cv + mode_match_prob_ctrv2cv_  *x_pre_ctrv + mode_match_prob_rm2cv_  *x_pre_rm;
-  x_ctrv_ = mode_match_prob_cv2ctrv_*x_pre_cv + mode_match_prob_ctrv2ctrv_*x_pre_ctrv + mode_match_prob_rm2ctrv_*x_pre_rm;
-  x_rm_   = mode_match_prob_cv2rm_  *x_pre_cv + mode_match_prob_ctrv2rm_  *x_pre_ctrv + mode_match_prob_rm2rm_*x_pre_rm;
+  Eigen::MatrixXd p_pre_rm = p_rm_;
+  x_cv_ = mode_match_prob_cv2cv_ * x_pre_cv + mode_match_prob_ctrv2cv_ * x_pre_ctrv + mode_match_prob_rm2cv_ * x_pre_rm;
+  x_ctrv_ = mode_match_prob_cv2ctrv_ * x_pre_cv + mode_match_prob_ctrv2ctrv_ * x_pre_ctrv +
+            mode_match_prob_rm2ctrv_ * x_pre_rm;
+  x_rm_ = mode_match_prob_cv2rm_ * x_pre_cv + mode_match_prob_ctrv2rm_ * x_pre_ctrv + mode_match_prob_rm2rm_ * x_pre_rm;
 
   // not interacting yaw(-pi ~ pi)
-  x_cv_(3)   = x_pre_cv(3);
+  x_cv_(3) = x_pre_cv(3);
   x_ctrv_(3) = x_pre_ctrv(3);
-  x_rm_(3)   = x_pre_rm(3);
+  x_rm_(3) = x_pre_rm(3);
 
   // normalizing angle
-  while (x_cv_(3)  &gt; M_PI) x_cv_(3)   -= 2.*M_PI;
-  while (x_cv_(3)  &lt;-M_PI) x_cv_(3)   += 2.*M_PI;
-  while (x_ctrv_(3)&gt; M_PI) x_ctrv_(3) -= 2.*M_PI;
-  while (x_ctrv_(3)&lt;-M_PI) x_ctrv_(3) += 2.*M_PI;
-  while (x_rm_(3)  &gt; M_PI) x_rm_(3)   -= 2.*M_PI;
-  while (x_rm_(3)  &lt;-M_PI) x_rm_(3)   += 2.*M_PI;
-
-  p_cv_   = mode_match_prob_cv2cv_    *(p_pre_cv  +(x_pre_cv -  x_cv_)*   (x_pre_cv -  x_cv_).transpose()) +
-            mode_match_prob_ctrv2cv_  *(p_pre_ctrv+(x_pre_ctrv -x_cv_)*   (x_pre_ctrv -x_cv_).transpose())+
-            mode_match_prob_rm2cv_    *(p_pre_rm + (x_pre_rm -  x_cv_)*   (x_pre_rm -  x_cv_).transpose());
-  p_ctrv_ = mode_match_prob_cv2ctrv_  *(p_pre_cv+  (x_pre_cv -  x_ctrv_)* (x_pre_cv-   x_ctrv_).transpose()) +
-            mode_match_prob_ctrv2ctrv_*(p_pre_ctrv+(x_pre_ctrv -x_ctrv_)* (x_pre_ctrv -x_ctrv_).transpose())+
-            mode_match_prob_rm2ctrv_  *(p_pre_rm + (x_pre_rm -  x_ctrv_)* (x_pre_rm -  x_ctrv_).transpose());
-  p_rm_   = mode_match_prob_cv2rm_    *(p_pre_cv+  (x_pre_cv -  x_rm_)*   (x_pre_cv -  x_rm_).transpose()) +
-            mode_match_prob_ctrv2rm_  *(p_pre_ctrv+(x_pre_ctrv -x_rm_)*   (x_pre_ctrv -x_rm_).transpose())+
-            mode_match_prob_rm2rm_    *(p_pre_rm + (x_pre_rm -  x_rm_)*   (x_pre_rm -  x_rm_).transpose());
+  while (x_cv_(3) &gt; M_PI)
+    x_cv_(3) -= 2. * M_PI;
+  while (x_cv_(3) &lt; -M_PI)
+    x_cv_(3) += 2. * M_PI;
+  while (x_ctrv_(3) &gt; M_PI)
+    x_ctrv_(3) -= 2. * M_PI;
+  while (x_ctrv_(3) &lt; -M_PI)
+    x_ctrv_(3) += 2. * M_PI;
+  while (x_rm_(3) &gt; M_PI)
+    x_rm_(3) -= 2. * M_PI;
+  while (x_rm_(3) &lt; -M_PI)
+    x_rm_(3) += 2. * M_PI;
+
+  p_cv_ = mode_match_prob_cv2cv_ * (p_pre_cv + (x_pre_cv - x_cv_) * (x_pre_cv - x_cv_).transpose()) +
+          mode_match_prob_ctrv2cv_ * (p_pre_ctrv + (x_pre_ctrv - x_cv_) * (x_pre_ctrv - x_cv_).transpose()) +
+          mode_match_prob_rm2cv_ * (p_pre_rm + (x_pre_rm - x_cv_) * (x_pre_rm - x_cv_).transpose());
+  p_ctrv_ = mode_match_prob_cv2ctrv_ * (p_pre_cv + (x_pre_cv - x_ctrv_) * (x_pre_cv - x_ctrv_).transpose()) +
+            mode_match_prob_ctrv2ctrv_ * (p_pre_ctrv + (x_pre_ctrv - x_ctrv_) * (x_pre_ctrv - x_ctrv_).transpose()) +
+            mode_match_prob_rm2ctrv_ * (p_pre_rm + (x_pre_rm - x_ctrv_) * (x_pre_rm - x_ctrv_).transpose());
+  p_rm_ = mode_match_prob_cv2rm_ * (p_pre_cv + (x_pre_cv - x_rm_) * (x_pre_cv - x_rm_).transpose()) +
+          mode_match_prob_ctrv2rm_ * (p_pre_ctrv + (x_pre_ctrv - x_rm_) * (x_pre_ctrv - x_rm_).transpose()) +
+          mode_match_prob_rm2rm_ * (p_pre_rm + (x_pre_rm - x_rm_) * (x_pre_rm - x_rm_).transpose());
 }
 
-
 /**
 * @param {MeasurementPackage} meas_package The latest measurement data of
 * either radar or laser.
@@ -352,7 +342,6 @@ void UKF::predictionIMMUKF(const double dt)
   updateLidar(0);
   updateLidar(1);
   updateLidar(2);
-
 }
 
 void UKF::updateIMMUKF(const std::vector&lt;double&gt; lambda_vec)
@@ -364,15 +353,13 @@ void UKF::updateIMMUKF(const std::vector&lt;double&gt; lambda_vec)
   mergeEstimationAndCovariance();
 }
 
-
-
 void UKF::ctrv(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
-               const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state)
+               const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp; state)
 {
-  //predicted state values
+  // predicted state values
   double px_p, py_p;
 
-  //avoid division by zero
+  // avoid division by zero
   if (fabs(yawd) &gt; 0.001)
   {
     px_p = p_x + v / yawd * (sin(yaw + yawd * delta_t) - sin(yaw));
@@ -387,14 +374,13 @@ void UKF::ctrv(const double p_x, const double p_y, const double v, const double
   double yaw_p = yaw + yawd * delta_t;
   double yawd_p = yawd;
 
-  //add noise
+  // add noise
   px_p = px_p + 0.5 * nu_a * delta_t * delta_t * cos(yaw);
   py_p = py_p + 0.5 * nu_a * delta_t * delta_t * sin(yaw);
-  v_p = v_p + nu_a*delta_t;
-
-  yaw_p = yaw_p + 0.5*nu_yawdd*delta_t*delta_t;
-  yawd_p = yawd_p + nu_yawdd*delta_t;
+  v_p = v_p + nu_a * delta_t;
 
+  yaw_p = yaw_p + 0.5 * nu_yawdd * delta_t * delta_t;
+  yawd_p = yawd_p + nu_yawdd * delta_t;
 
   state[0] = px_p;
   state[1] = py_p;
@@ -403,12 +389,12 @@ void UKF::ctrv(const double p_x, const double p_y, const double v, const double
   state[4] = yawd_p;
 }
 
-void UKF::cv(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
-               const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state)
+void UKF::cv(const double p_x, const double p_y, const double v, const double yaw, const double yawd, const double nu_a,
+             const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp; state)
 {
-  //predicted state values
-  double px_p = p_x + v*cos(yaw)*delta_t;
-  double py_p = p_y + v*sin(yaw)*delta_t;
+  // predicted state values
+  double px_p = p_x + v * cos(yaw) * delta_t;
+  double py_p = p_y + v * sin(yaw) * delta_t;
 
   double v_p = v;
   // not sure which one, works better in curve by using yaw
@@ -416,13 +402,13 @@ void UKF::cv(const double p_x, const double p_y, const double v, const double ya
 
   double yawd_p = yawd;
 
-  //add noise
+  // add noise
   px_p = px_p + 0.5 * nu_a * delta_t * delta_t * cos(yaw);
   py_p = py_p + 0.5 * nu_a * delta_t * delta_t * sin(yaw);
-  v_p = v_p + nu_a*delta_t;
+  v_p = v_p + nu_a * delta_t;
 
-  yaw_p = yaw_p + 0.5*nu_yawdd*delta_t*delta_t;
-  yawd_p = yawd_p + nu_yawdd*delta_t;
+  yaw_p = yaw_p + 0.5 * nu_yawdd * delta_t * delta_t;
+  yawd_p = yawd_p + nu_yawdd * delta_t;
 
   state[0] = px_p;
   state[1] = py_p;
@@ -431,15 +417,14 @@ void UKF::cv(const double p_x, const double p_y, const double v, const double ya
   state[4] = yawd_p;
 }
 
-
 void UKF::randomMotion(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
-               const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp;state)
+                       const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp; state)
 {
-  double px_p   = p_x;
-  double py_p   = p_y;
-  double v_p    = v;
+  double px_p = p_x;
+  double py_p = p_y;
+  double v_p = v;
 
-  double yaw_p  = yaw;
+  double yaw_p = yaw;
   double yawd_p = yawd;
 
   state[0] = px_p;
@@ -461,23 +446,23 @@ void UKF::prediction(const double delta_t, const int model_ind)
  ****************************************************************************/
   double std_yawdd, std_a;
   Eigen::MatrixXd x_(x_cv_.rows(), 1);
-  Eigen::MatrixXd p_(p_cv_.rows(),p_cv_.cols());
+  Eigen::MatrixXd p_(p_cv_.rows(), p_cv_.cols());
   Eigen::MatrixXd x_sig_pred_(x_sig_pred_cv_.rows(), x_sig_pred_cv_.cols());
-  if(model_ind == 0)
+  if (model_ind == 0)
   {
     x_ = x_cv_.col(0);
     p_ = p_cv_;
     x_sig_pred_ = x_sig_pred_cv_;
     std_yawdd = std_cv_yawdd_;
-    std_a     = std_a_cv_;
+    std_a = std_a_cv_;
   }
-  else if(model_ind == 1)
+  else if (model_ind == 1)
   {
     x_ = x_ctrv_.col(0);
     p_ = p_ctrv_;
     x_sig_pred_ = x_sig_pred_ctrv_;
     std_yawdd = std_ctrv_yawdd_;
-    std_a     = std_a_ctrv_;
+    std_a = std_a_ctrv_;
   }
   else
   {
@@ -485,38 +470,38 @@ void UKF::prediction(const double delta_t, const int model_ind)
     p_ = p_rm_;
     x_sig_pred_ = x_sig_pred_rm_;
     std_yawdd = std_rm_yawdd_;
-    std_a     = std_a_rm_;
+    std_a = std_a_rm_;
   }
 
   /*****************************************************************************
   *  Augment Sigma Points
   ****************************************************************************/
-  //create augmented mean vector
+  // create augmented mean vector
   Eigen::VectorXd x_aug = Eigen::VectorXd(n_aug_);
 
-  //create augmented state covariance
+  // create augmented state covariance
   Eigen::MatrixXd p_aug = Eigen::MatrixXd(n_aug_, n_aug_);
 
-  //create sigma point matrix
+  // create sigma point matrix
   Eigen::MatrixXd x_sig_aug = Eigen::MatrixXd(n_aug_, 2 * n_aug_ + 1);
 
-  //create augmented mean state
+  // create augmented mean state
   x_aug.head(5) = x_;
   x_aug(5) = 0;
   x_aug(6) = 0;
 
-  //create augmented covariance matrix
+  // create augmented covariance matrix
   p_aug.fill(0.0);
   p_aug.topLeftCorner(5, 5) = p_;
-  p_aug(5, 5) = std_a*std_a;
-  p_aug(6, 6) = std_yawdd*std_yawdd;
+  p_aug(5, 5) = std_a * std_a;
+  p_aug(6, 6) = std_yawdd * std_yawdd;
 
-  //create square root matrix
+  // create square root matrix
   Eigen::MatrixXd L = p_aug.llt().matrixL();
 
-  //create augmented sigma points
+  // create augmented sigma points
   x_sig_aug.col(0) = x_aug;
-  for (int i = 0; i&lt; n_aug_; i++)
+  for (int i = 0; i &lt; n_aug_; i++)
   {
     x_sig_aug.col(i + 1) = x_aug + sqrt(lambda_aug_ + n_aug_) * L.col(i);
     x_sig_aug.col(i + 1 + n_aug_) = x_aug - sqrt(lambda_aug_ + n_aug_) * L.col(i);
@@ -525,24 +510,27 @@ void UKF::prediction(const double delta_t, const int model_ind)
   /*****************************************************************************
   *  Predict Sigma Points
   ****************************************************************************/
-  //predict sigma points
+  // predict sigma points
   for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
   {
-    //extract values for better readability
-    double p_x      = x_sig_aug(0, i);
-    double p_y      = x_sig_aug(1, i);
-    double v        = x_sig_aug(2, i);
-    double yaw      = x_sig_aug(3, i);
-    double yawd     = x_sig_aug(4, i);
-    double nu_a     = x_sig_aug(5, i);
+    // extract values for better readability
+    double p_x = x_sig_aug(0, i);
+    double p_y = x_sig_aug(1, i);
+    double v = x_sig_aug(2, i);
+    double yaw = x_sig_aug(3, i);
+    double yawd = x_sig_aug(4, i);
+    double nu_a = x_sig_aug(5, i);
     double nu_yawdd = x_sig_aug(6, i);
 
     std::vector&lt;double&gt; state(5);
-    if(model_ind == 0)        cv(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
-    else if(model_ind == 1) ctrv(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
-    else           randomMotion(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
+    if (model_ind == 0)
+      cv(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
+    else if (model_ind == 1)
+      ctrv(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
+    else
+      randomMotion(p_x, p_y, v, yaw, yawd, nu_a, nu_yawdd, delta_t, state);
 
-    //write predicted sigma point into right column
+    // write predicted sigma point into right column
     x_sig_pred_(0, i) = state[0];
     x_sig_pred_(1, i) = state[1];
     x_sig_pred_(2, i) = state[2];
@@ -550,41 +538,44 @@ void UKF::prediction(const double delta_t, const int model_ind)
     x_sig_pred_(4, i) = state[4];
   }
 
-
   /*****************************************************************************
   *  Convert Predicted Sigma Points to Mean/Covariance
   ****************************************************************************/
-  //predicted state mean
+  // predicted state mean
   x_.fill(0.0);
   for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
-  {  //iterate over sigma points
+  {  // iterate over sigma points
     x_ = x_ + weights_(i) * x_sig_pred_.col(i);
   }
 
-  while (x_(3)&gt; M_PI) x_(3) -= 2.*M_PI;
-  while (x_(3)&lt;-M_PI) x_(3) += 2.*M_PI;
-  //predicted state covariance matrix
+  while (x_(3) &gt; M_PI)
+    x_(3) -= 2. * M_PI;
+  while (x_(3) &lt; -M_PI)
+    x_(3) += 2. * M_PI;
+  // predicted state covariance matrix
   p_.fill(0.0);
   for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
-  {  //iterate over sigma points
+  {  // iterate over sigma points
     // state difference
     Eigen::VectorXd x_diff = x_sig_pred_.col(i) - x_;
-    //angle normalization
-    while (x_diff(3)&gt; M_PI) x_diff(3) -= 2.*M_PI;
-    while (x_diff(3)&lt;-M_PI) x_diff(3) += 2.*M_PI;
+    // angle normalization
+    while (x_diff(3) &gt; M_PI)
+      x_diff(3) -= 2. * M_PI;
+    while (x_diff(3) &lt; -M_PI)
+      x_diff(3) += 2. * M_PI;
     p_ = p_ + weights_(i) * x_diff * x_diff.transpose();
   }
 
   /*****************************************************************************
   *  Update model parameters
   ****************************************************************************/
-  if(model_ind == 0)
+  if (model_ind == 0)
   {
     x_cv_.col(0) = x_;
     p_cv_ = p_;
     x_sig_pred_cv_ = x_sig_pred_;
   }
-  else if(model_ind == 1)
+  else if (model_ind == 1)
   {
     x_ctrv_.col(0) = x_;
     p_ctrv_ = p_;
@@ -608,15 +599,15 @@ void UKF::updateLidar(const int model_ind)
  *  Initialize model parameters
  ****************************************************************************/
   Eigen::VectorXd x(x_cv_.rows());
-  Eigen::MatrixXd P(p_cv_.rows(),p_cv_.cols());
+  Eigen::MatrixXd P(p_cv_.rows(), p_cv_.cols());
   Eigen::MatrixXd x_sig_pred(x_sig_pred_cv_.rows(), x_sig_pred_cv_.cols());
-  if(model_ind == 0)
+  if (model_ind == 0)
   {
     x = x_cv_.col(0);
     P = p_cv_;
     x_sig_pred = x_sig_pred_cv_;
   }
-  else if(model_ind == 1)
+  else if (model_ind == 1)
   {
     x = x_ctrv_.col(0);
     P = p_ctrv_;
@@ -629,15 +620,15 @@ void UKF::updateLidar(const int model_ind)
     x_sig_pred = x_sig_pred_rm_;
   }
 
-  //set measurement dimension, lidar can measure p_x and p_y
+  // set measurement dimension, lidar can measure p_x and p_y
   int n_z = 2;
 
-  //create matrix for sigma points in measurement space
+  // create matrix for sigma points in measurement space
   Eigen::MatrixXd z_sig = Eigen::MatrixXd(n_z, 2 * n_aug_ + 1);
 
-  //transform sigma points into measurement space
+  // transform sigma points into measurement space
   for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
-  {  //2n+1 simga points
+  {  // 2n+1 simga points
     // extract values for better readibility
     double p_x = x_sig_pred(0, i);
     double p_y = x_sig_pred(1, i);
@@ -647,7 +638,7 @@ void UKF::updateLidar(const int model_ind)
     z_sig(1, i) = p_y;
   }
 
-  //mean predicted measurement
+  // mean predicted measurement
   Eigen::VectorXd z_pred = Eigen::VectorXd(n_z);
   z_pred.fill(0.0);
   for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
@@ -655,33 +646,32 @@ void UKF::updateLidar(const int model_ind)
     z_pred = z_pred + weights_(i) * z_sig.col(i);
   }
 
-  //measurement covariance matrix S
+  // measurement covariance matrix S
   Eigen::MatrixXd S = Eigen::MatrixXd(n_z, n_z);
   S.fill(0.0);
   for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
-  {  //2n+1 simga points
-    //residual
+  {  // 2n+1 simga points
+    // residual
     Eigen::VectorXd z_diff = z_sig.col(i) - z_pred;
     S = S + weights_(i) * z_diff * z_diff.transpose();
   }
 
-  //add measurement noise covariance matrix
+  // add measurement noise covariance matrix
   Eigen::MatrixXd R = Eigen::MatrixXd(n_z, n_z);
-  R &lt;&lt; std_laspx_*std_laspx_, 0,
-          0, std_laspy_*std_laspy_;
+  R &lt;&lt; std_laspx_ * std_laspx_, 0, 0, std_laspy_ * std_laspy_;
   S = S + R;
 
-  //create matrix for cross correlation Tc
+  // create matrix for cross correlation Tc
   Eigen::MatrixXd Tc = Eigen::MatrixXd(n_x_, n_z);
 
   /*****************************************************************************
   *  UKF Update for Lidar
   ****************************************************************************/
-  //calculate cross correlation matrix
+  // calculate cross correlation matrix
   Tc.fill(0.0);
   for (int i = 0; i &lt; 2 * n_aug_ + 1; i++)
-  {  //2n+1 simga points
-    //residual
+  {  // 2n+1 simga points
+    // residual
     Eigen::VectorXd z_diff = z_sig.col(i) - z_pred;
     // state difference
     Eigen::VectorXd x_diff = x_sig_pred.col(i) - x;
@@ -689,37 +679,37 @@ void UKF::updateLidar(const int model_ind)
     Tc = Tc + weights_(i) * x_diff * z_diff.transpose();
   }
 
-  //Kalman gain K;
+  // Kalman gain K;
   Eigen::MatrixXd K = Tc * S.inverse();
 
   /*****************************************************************************
   *  Update model parameters
   ****************************************************************************/
-  if(model_ind == 0)
+  if (model_ind == 0)
   {
-    x_cv_.col(0)  = x;
-    p_cv_         = P;
+    x_cv_.col(0) = x;
+    p_cv_ = P;
     x_sig_pred_cv_ = x_sig_pred;
-    z_pred_cv_     = z_pred;
-    s_cv_        = S;
-    k_cv_         = K;
+    z_pred_cv_ = z_pred;
+    s_cv_ = S;
+    k_cv_ = K;
   }
-  else if(model_ind == 1)
+  else if (model_ind == 1)
   {
-    x_ctrv_.col(0)  = x;
-    p_ctrv_         = P;
+    x_ctrv_.col(0) = x;
+    p_ctrv_ = P;
     x_sig_pred_ctrv_ = x_sig_pred;
-    z_pred_ctrv_     = z_pred;
-    s_ctrv_        = S;
-    k_ctrv_         = K;
+    z_pred_ctrv_ = z_pred;
+    s_ctrv_ = S;
+    k_ctrv_ = K;
   }
   else
   {
-    x_rm_.col(0)    = x;
-    p_rm_           = P;
-    x_sig_pred_rm_   = x_sig_pred;
-    z_pred_rm_       = z_pred;
-    s_rm_          = S;
-    k_rm_           = K;
+    x_rm_.col(0) = x;
+    p_rm_ = P;
+    x_sig_pred_rm_ = x_sig_pred;
+    z_pred_rm_ = z_pred;
+    s_rm_ = S;
+    k_rm_ = K;
   }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" added_lines="3" deleted_lines="9">
				<diff>@@ -12,15 +12,9 @@
 #include &lt;vector&gt;
 #include &lt;string&gt;
 
-#include "autoware_msgs/CloudCluster.h"
-#include "autoware_msgs/CloudClusterArray.h"
-
 #include "autoware_msgs/DetectedObject.h"
 #include "autoware_msgs/DetectedObjectArray.h"
 
-
-
-
 class VisualizeCloudCluster
 {
 private:
@@ -30,8 +24,8 @@ private:
   ros::NodeHandle node_handle_;
   ros::Subscriber sub_cloud_array_;
 
-  ros::Publisher  pub_arrow_;
-  ros::Publisher  pub_id_;
+  ros::Publisher pub_arrow_;
+  ros::Publisher pub_id_;
 
   void visMarkers(autoware_msgs::DetectedObjectArray input);
   void callBack(autoware_msgs::DetectedObjectArray input);
@@ -40,4 +34,4 @@ public:
   VisualizeCloudCluster();
 };
 
-#endif //OBJECT_TRACKING_VisualizeCloudCluster_H
+#endif  // OBJECT_TRACKING_VisualizeCloudCluster_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" added_lines="9" deleted_lines="14">
				<diff>@@ -3,15 +3,14 @@
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
 
-
 VisualizeCloudCluster::VisualizeCloudCluster()
 {
   ros::NodeHandle private_nh_("~");
   private_nh_.param&lt;std::string&gt;("pointcloud_frame", pointcloud_frame_, "velodyne");
 
-  sub_cloud_array_  = node_handle_.subscribe ("/detected_objects", 1, &amp;VisualizeCloudCluster::callBack, this);
-  pub_arrow_        = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/detected_objects/velocity_arrow", 1);
-  pub_id_           = node_handle_.advertise&lt;visualization_msgs::Marker&gt; ("/detected_objects/target_id", 1);
+  sub_cloud_array_ = node_handle_.subscribe("/detected_objects", 1, &amp;VisualizeCloudCluster::callBack, this);
+  pub_arrow_ = node_handle_.advertise&lt;visualization_msgs::Marker&gt;("/detected_objects/velocity_arrow", 1);
+  pub_id_ = node_handle_.advertise&lt;visualization_msgs::Marker&gt;("/detected_objects/target_id", 1);
 }
 
 void VisualizeCloudCluster::callBack(autoware_msgs::DetectedObjectArray input)
@@ -21,9 +20,9 @@ void VisualizeCloudCluster::callBack(autoware_msgs::DetectedObjectArray input)
 
 void VisualizeCloudCluster::visMarkers(autoware_msgs::DetectedObjectArray input)
 {
-  for(size_t i = 0; i &lt; input.objects.size(); i++)
+  for (size_t i = 0; i &lt; input.objects.size(); i++)
   {
-    double tv   = input.objects[i].velocity.linear.x;
+    double tv = input.objects[i].velocity.linear.x;
     double tyaw = input.objects[i].velocity.linear.y;
 
     visualization_msgs::Marker ids;
@@ -33,13 +32,12 @@ void VisualizeCloudCluster::visMarkers(autoware_msgs::DetectedObjectArray input)
     ids.header.stamp = input.header.stamp;
     ids.ns = "ids";
     ids.action = visualization_msgs::Marker::ADD;
-    ids.type   = visualization_msgs::Marker::TEXT_VIEW_FACING;
+    ids.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
     // green
     ids.color.g = 1.0f;
     ids.color.a = 1.0;
     ids.id = i;
 
-
     // Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
     ids.pose.position.x = input.objects[i].pose.position.x;
     ids.pose.position.y = input.objects[i].pose.position.y;
@@ -47,7 +45,7 @@ void VisualizeCloudCluster::visMarkers(autoware_msgs::DetectedObjectArray input)
 
     // convert from RPY to quartenion
     tf::Matrix3x3 obs_mat;
-    obs_mat.setEulerYPR(tyaw, 0, 0); // yaw, pitch, roll
+    obs_mat.setEulerYPR(tyaw, 0, 0);  // yaw, pitch, roll
     tf::Quaternion q_tf;
     obs_mat.getRotation(q_tf);
     ids.pose.orientation.x = q_tf.getX();
@@ -55,19 +53,17 @@ void VisualizeCloudCluster::visMarkers(autoware_msgs::DetectedObjectArray input)
     ids.pose.orientation.z = q_tf.getZ();
     ids.pose.orientation.w = q_tf.getW();
 
-
     ids.scale.z = 1.0;
 
     ids.text = std::to_string(input.objects[i].id);
 
     pub_id_.publish(ids);
 
-
     visualization_msgs::Marker arrows;
     arrows.lifetime = ros::Duration(0.1);
 
     std::string label = input.objects[i].label;
-    if(label == "None" || label == "Initialized" || label == "Lost" || label == "Static")
+    if (label == "None" || label == "Initialized" || label == "Lost" || label == "Static")
     {
       continue;
     }
@@ -76,7 +72,7 @@ void VisualizeCloudCluster::visMarkers(autoware_msgs::DetectedObjectArray input)
     arrows.header.stamp = input.header.stamp;
     arrows.ns = "arrows";
     arrows.action = visualization_msgs::Marker::ADD;
-    arrows.type   = visualization_msgs::Marker::ARROW;
+    arrows.type = visualization_msgs::Marker::ARROW;
     // green
     arrows.color.g = 1.0f;
     arrows.color.a = 1.0;
@@ -87,7 +83,6 @@ void VisualizeCloudCluster::visMarkers(autoware_msgs::DetectedObjectArray input)
     arrows.pose.position.y = input.objects[i].pose.position.y;
     arrows.pose.position.z = 0.5;
 
-
     arrows.pose.orientation.x = q_tf.getX();
     arrows.pose.orientation.y = q_tf.getY();
     arrows.pose.orientation.z = q_tf.getZ();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster_main.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster_main.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,8 +1,8 @@
 
 #include "visualize_cloud_cluster.h"
 
-int main(int argc, char **argv) {
-
+int main(int argc, char** argv)
+{
   ros::init(argc, argv, "visualize_cloud_cluster");
   VisualizeCloudCluster app;
   ros::spin();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="988ce2470c009781a857e7922cdefeedbf169724" author="Kosuke Murakami">
		<msg>Rename visualize_cloud_cluster to visualize_detected_objects</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster_main.cpp" new_path="" added_lines="0" deleted_lines="11">
				<diff>@@ -1,11 +0,0 @@
-
-#include "visualize_cloud_cluster.h"
-
-int main(int argc, char** argv)
-{
-  ros::init(argc, argv, "visualize_cloud_cluster");
-  VisualizeCloudCluster app;
-  ros::spin();
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\include\visualize_cloud_cluster.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_detected_objects\include\visualize_detected_objects.h" added_lines="4" deleted_lines="4">
				<diff>@@ -1,5 +1,5 @@
-#ifndef OBJECT_TRACKING_VisualizeCloudCluster_H
-#define OBJECT_TRACKING_VisualizeCloudCluster_H
+#ifndef OBJECT_TRACKING_VisualizeDetecedObjects_H
+#define OBJECT_TRACKING_VisualizeDetecedObjects_H
 
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Header.h&gt;
@@ -15,7 +15,7 @@
 #include "autoware_msgs/DetectedObject.h"
 #include "autoware_msgs/DetectedObjectArray.h"
 
-class VisualizeCloudCluster
+class VisualizeDetectedObjects
 {
 private:
   std::string input_topic_;
@@ -31,7 +31,7 @@ private:
   void callBack(autoware_msgs::DetectedObjectArray input);
 
 public:
-  VisualizeCloudCluster();
+  VisualizeDetectedObjects();
 };
 
 #endif  // OBJECT_TRACKING_VisualizeCloudCluster_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_cloud_cluster\src\visualize_cloud_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_detected_objects\src\visualize_detected_objects.cpp" added_lines="6" deleted_lines="5">
				<diff>@@ -1,24 +1,24 @@
-#include "visualize_cloud_cluster.h"
+#include "visualize_detected_objects.h"
 
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
 
-VisualizeCloudCluster::VisualizeCloudCluster()
+VisualizeDetectedObjects::VisualizeDetectedObjects()
 {
   ros::NodeHandle private_nh_("~");
   private_nh_.param&lt;std::string&gt;("pointcloud_frame", pointcloud_frame_, "velodyne");
 
-  sub_cloud_array_ = node_handle_.subscribe("/detected_objects", 1, &amp;VisualizeCloudCluster::callBack, this);
+  sub_cloud_array_ = node_handle_.subscribe("/detected_objects", 1, &amp;VisualizeDetectedObjects::callBack, this);
   pub_arrow_ = node_handle_.advertise&lt;visualization_msgs::Marker&gt;("/detected_objects/velocity_arrow", 1);
   pub_id_ = node_handle_.advertise&lt;visualization_msgs::Marker&gt;("/detected_objects/target_id", 1);
 }
 
-void VisualizeCloudCluster::callBack(autoware_msgs::DetectedObjectArray input)
+void VisualizeDetectedObjects::callBack(autoware_msgs::DetectedObjectArray input)
 {
   visMarkers(input);
 }
 
-void VisualizeCloudCluster::visMarkers(autoware_msgs::DetectedObjectArray input)
+void VisualizeDetectedObjects::visMarkers(autoware_msgs::DetectedObjectArray input)
 {
   for (size_t i = 0; i &lt; input.objects.size(); i++)
   {
@@ -62,6 +62,7 @@ void VisualizeCloudCluster::visMarkers(autoware_msgs::DetectedObjectArray input)
     visualization_msgs::Marker arrows;
     arrows.lifetime = ros::Duration(0.1);
 
+    // visualize velocity arrow only if its status is Stable
     std::string label = input.objects[i].label;
     if (label == "None" || label == "Initialized" || label == "Lost" || label == "Static")
     {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1b43b31811f7cd8ab568767b89a715b5295d7aeb" author="Yuma">
		<msg>Fix date of lisence &amp; add {}</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" added_lines="47" deleted_lines="5">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2015, Nagoya University
+ *  Copyright (c) 2018, TierIV, Inc.
 
  *  All rights reserved.
  *
@@ -77,12 +77,16 @@ void VelocityReplanner::replanLaneWaypointVel(autoware_msgs::lane* lane)
   std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt; curve_list;
 
   if (resample_mode_)
+  {
     resampleLaneWaypoint(resample_interval_, lane);
+  }
   createRadiusList(*lane, &amp;curve_radius);
   createCurveList(curve_radius, &amp;curve_list);
   // set velocity_max for all_point
   for (auto&amp; el : lane-&gt;waypoints)
+  {
     el.twist.twist.linear.x = velocity_max_;
+  }
   // set velocity by curve
   for (const auto&amp; el : curve_list)
   {
@@ -98,7 +102,9 @@ void VelocityReplanner::replanLaneWaypointVel(autoware_msgs::lane* lane)
 void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, autoware_msgs::lane* lane)
 {
   if (lane-&gt;waypoints.empty())
+  {
     return;
+  }
   autoware_msgs::lane original_lane = *lane;
   lane-&gt;waypoints.clear();
   lane-&gt;waypoints.push_back(original_lane.waypoints[0]);
@@ -109,10 +115,16 @@ void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, aut
     boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point = getCrvPointsOnResample(*lane, original_lane, i);
     const std::vector&lt;double&gt; curve_param = calcCurveParam(curve_point);
 
-    if (curve_param.empty())  // if going straight
+    // if going straight
+    if (curve_param.empty())
+    {
       resampleOnStraight(curve_point, lane);
-    else  // else if turnning curve
+    }
+    // else if turnning curve
+    else
+    {
       resampleOnCurve(curve_point[1], curve_param, lane);
+    }
 
     lane-&gt;waypoints.back().wpstate = original_lane.waypoints[i].wpstate;
     lane-&gt;waypoints.back().change_flag = original_lane.waypoints[i].change_flag;
@@ -134,7 +146,9 @@ void VelocityReplanner::resampleOnStraight(const boost::circular_buffer&lt;geometry
   std::vector&lt;double&gt; resample_vec = nvec;
   const double coeff = resample_interval_ / dist;
   for (auto&amp; el : resample_vec)
+  {
     el *= coeff;
+  }
   for (; dist &gt; resample_interval_; dist -= resample_interval_)
   {
     wp.pose.pose.position.x += resample_vec[0];
@@ -157,7 +171,9 @@ void VelocityReplanner::resampleOnCurve(const geometry_msgs::Point&amp; target_point
   double theta = fmod(atan2(p1.y - cy, p1.x - cx) - atan2(p0.y - cy, p0.x - cx), 2 * M_PI);
   int sgn = (theta &gt; 0.0) ? (1) : (-1);
   if (fabs(theta) &gt; M_PI)
+  {
     theta -= 2 * sgn * M_PI;
+  }
   sgn = (theta &gt; 0.0) ? (1) : (-1);
   // interport
   double t = atan2(p0.y - cy, p0.x - cx);
@@ -166,7 +182,9 @@ void VelocityReplanner::resampleOnCurve(const geometry_msgs::Point&amp; target_point
   for (; dist &gt; resample_interval_; dist -= resample_interval_)
   {
     if (lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())
+    {
       break;
+    }
     t += sgn * resample_interval_ / radius;
     const double yaw = fmod(t + sgn * M_PI / 2.0, 2 * M_PI);
     wp.pose.pose.position.x = cx + radius * cos(t);
@@ -191,7 +209,9 @@ const boost::circular_buffer&lt;geometry_msgs::Point&gt; VelocityReplanner::getCrvPoin
     (id &lt; original_lane.waypoints.size() - n) ? original_lane.waypoints[id + n] : original_lane.waypoints.back()
   };
   for (int i = 0; i &lt; 3; i++)
+  {
     curve_point.push_back(cp[i].pose.pose.position);
+  }
   return curve_point;
 }
 
@@ -204,14 +224,18 @@ const boost::circular_buffer&lt;geometry_msgs::Point&gt; VelocityReplanner::getCrvPoin
                                                                                    (lane.waypoints.size() - 1) :
                                                                                    (index + n) };
   for (int i = 0; i &lt; 3; i++)
+  {
     curve_point.push_back(lane.waypoints[curve_index[i]].pose.pose.position);
+  }
   return curve_point;
 }
 
 void VelocityReplanner::createRadiusList(const autoware_msgs::lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
 {
   if (lane.waypoints.empty())
+  {
     return;
+  }
   curve_radius-&gt;resize(lane.waypoints.size());
   curve_radius-&gt;at(0) = curve_radius-&gt;back() = r_inf_;
 
@@ -220,10 +244,16 @@ void VelocityReplanner::createRadiusList(const autoware_msgs::lane&amp; lane, std::v
     boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point = getCrvPoints(lane, i);
     const std::vector&lt;double&gt; curve_param = calcCurveParam(curve_point);
 
-    if (curve_param.empty())  // if going straight
+    // if going straight
+    if (curve_param.empty())
+    {
       curve_radius-&gt;at(i) = r_inf_;
-    else  // else if turnning curve
+    }
+    // else if turnning curve
+    else
+    {
       curve_radius-&gt;at(i) = (curve_param[2] &gt; r_inf_) ? r_inf_ : curve_param[2];
+    }
   }
 }
 
@@ -254,14 +284,20 @@ void VelocityReplanner::createCurveList(
     {
       on_curve = false;
       if (radius_localmin &lt; r_min_)
+      {
         radius_localmin = r_min_;
+      }
       (*curve_list)[index] = std::make_pair(i, radius_localmin);
       radius_localmin = DBL_MAX;
     }
     if (!on_curve)
+    {
       continue;
+    }
     if (radius_localmin &gt; curve_radius[i])
+    {
       radius_localmin = curve_radius[i];
+    }
   }
 }
 
@@ -276,7 +312,9 @@ void VelocityReplanner::limitVelocityByRange(unsigned long start_idx, unsigned l
   for (unsigned long idx = start_idx; idx &lt;= end_idx; idx++)
   {
     if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
+    {
       continue;
+    }
     lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
   }
   limitAccelDecel(start_idx, lane);
@@ -296,7 +334,9 @@ void VelocityReplanner::limitAccelDecel(const unsigned long idx, autoware_msgs::
     {
       v = sqrt(2 * acc[j] * resample_interval_ + v * v);
       if (v &gt; velocity_max_ || v &gt; lane-&gt;waypoints[next].twist.twist.linear.x)
+      {
         break;
+      }
       lane-&gt;waypoints[next].twist.twist.linear.x = v;
     }
   }
@@ -309,7 +349,9 @@ const std::vector&lt;double&gt; VelocityReplanner::calcCurveParam(boost::circular_buff
   {
     const double d = 2 * ((p[0].y - p[2].y) * (p[0].x - p[1].x) - (p[0].y - p[1].y) * (p[0].x - p[2].x));
     if (fabs(d) &lt; 1e-8)
+    {
       continue;
+    }
     const std::vector&lt;double&gt; x2 = { p[0].x * p[0].x, p[1].x * p[1].x, p[2].x * p[2].x };
     const std::vector&lt;double&gt; y2 = { p[0].y * p[0].y, p[1].y * p[1].y, p[2].y * p[2].y };
     const double a = y2[0] - y2[1] + x2[0] - x2[1];
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2015, Nagoya University
+ *  Copyright (c) 2018, TierIV, Inc.
 
  *  All rights reserved.
  *
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="28" deleted_lines="0">
				<diff>@@ -85,7 +85,9 @@ void WaypointLoaderNode::outputCommandCallback(const std_msgs::Bool::ConstPtr&amp; o
 {
   std::vector&lt;std::string&gt; dst_multi_file_path = multi_file_path_;
   for (auto&amp; el : dst_multi_file_path)
+  {
     el = addFileSuffix(el, "_replanned");
+  }
   saveLaneArray(dst_multi_file_path, output_lane_array_);
 }
 
@@ -97,11 +99,15 @@ const std::string addFileSuffix(std::string file_path, std::string suffix)
   tmp = file_path;
   const std::string::size_type idx_slash = tmp.find_last_of("/");
   if (idx_slash != std::string::npos)
+  {
     tmp.erase(0, idx_slash);
+  }
   const std::string::size_type idx_dot = tmp.find_last_of(".");
   const std::string::size_type idx_dot_allpath = file_path.find_last_of(".");
   if (idx_dot != std::string::npos &amp;&amp; idx_dot != tmp.size() - 1)
+  {
     file_path.erase(idx_dot_allpath, file_path.size() - 1);
+  }
   file_path += suffix + ".csv";
   return file_path;
 }
@@ -113,7 +119,9 @@ void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt;&amp; paths,
     autoware_msgs::lane lane;
     createLaneWaypoint(el, &amp;lane);
     if (replanning_mode_)
+    {
       replanner_.replanLaneWaypointVel(&amp;lane);
+    }
     lane_array-&gt;lanes.push_back(lane);
   }
 }
@@ -150,11 +158,17 @@ void WaypointLoaderNode::createLaneWaypoint(const std::string&amp; file_path, autowa
   FileFormat format = checkFileFormat(file_path.c_str());
   std::vector&lt;autoware_msgs::waypoint&gt; wps;
   if (format == FileFormat::ver1)
+  {
     loadWaypointsForVer1(file_path.c_str(), &amp;wps);
+  }
   else if (format == FileFormat::ver2)
+  {
     loadWaypointsForVer2(file_path.c_str(), &amp;wps);
+  }
   else
+  {
     loadWaypointsForVer3(file_path.c_str(), &amp;wps);
+  }
   lane-&gt;header.frame_id = "/map";
   lane-&gt;header.stamp = ros::Time(0);
   lane-&gt;waypoints = wps;
@@ -165,7 +179,9 @@ void WaypointLoaderNode::loadWaypointsForVer1(const char* filename, std::vector&lt;
   std::ifstream ifs(filename);
 
   if (!ifs)
+  {
     return;
+  }
 
   std::string line;
   std::getline(ifs, line);  // Remove first line
@@ -209,7 +225,9 @@ void WaypointLoaderNode::loadWaypointsForVer2(const char* filename, std::vector&lt;
   std::ifstream ifs(filename);
 
   if (!ifs)
+  {
     return;
+  }
 
   std::string line;
   std::getline(ifs, line);  // Remove first line
@@ -239,7 +257,9 @@ void WaypointLoaderNode::loadWaypointsForVer3(const char* filename, std::vector&lt;
   std::ifstream ifs(filename);
 
   if (!ifs)
+  {
     return;
+  }
 
   std::string line;
   std::getline(ifs, line);  // get first line
@@ -318,7 +338,9 @@ bool WaypointLoaderNode::verifyFileConsistency(const char* filename)
   std::ifstream ifs(filename);
 
   if (!ifs)
+  {
     return false;
+  }
 
   FileFormat format = checkFileFormat(filename);
   ROS_INFO("format: %d", static_cast&lt;int&gt;(format));
@@ -340,7 +362,9 @@ bool WaypointLoaderNode::verifyFileConsistency(const char* filename)
   while (std::getline(ifs, line))  // search from second line
   {
     if (countColumns(line) != ncol)
+    {
       return false;
+    }
   }
   return true;
 }
@@ -355,11 +379,15 @@ void parseColumns(const std::string&amp; line, std::vector&lt;std::string&gt;* columns)
     {
       auto res = std::find(column.begin(), column.end(), ' ');
       if (res == column.end())
+      {
         break;
+      }
       column.erase(res);
     }
     if (!column.empty())
+    {
       columns-&gt;push_back(column);
+    }
   }
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ad5553eb19f386e39fddcd8bc74a2273da5241cf" author="Kosuke Murakami">
		<msg>Modify input for callback</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" added_lines="4" deleted_lines="3">
				<diff>@@ -61,8 +61,9 @@ private:
   ros::Publisher pub_object_array_;
   ros::Publisher pub_jskbbox_array_;
 
-  void callback(autoware_msgs::CloudClusterArray input);
-  void transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input);
+  void callback(const autoware_msgs::CloudClusterArray&amp; input);
+  void transformPoseToGlobal(const autoware_msgs::CloudClusterArray&amp; input,
+                                   autoware_msgs::CloudClusterArray&amp; transformed_input);
   void transformPoseToLocal(jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                             autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
   void findMaxZandS(const UKF target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s);
@@ -103,7 +104,7 @@ private:
   void makeOutput(autoware_msgs::CloudClusterArray input, jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                   autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
 
-  void tracker(autoware_msgs::CloudClusterArray input, jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
+  void tracker(const autoware_msgs::CloudClusterArray transformed_input, jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
 
 public:
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" added_lines="0" deleted_lines="15">
				<diff>@@ -16,12 +16,6 @@ public:
   ///* initially set to false, set to true in first call of ProcessMeasurement
   bool is_initialized_;
 
-  ///* if this is false, laser measurements will be ignored (except for init)
-  bool use_laser_;
-
-  ///* if this is false, radar measurements will be ignored (except for init)
-  bool use_radar_;
-
   //    ///* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
   Eigen::MatrixXd x_merge_;
 
@@ -78,15 +72,6 @@ public:
   ///* Laser measurement noise standard deviation position2 in m
   double std_laspy_;
 
-  ///* Radar measurement noise standard deviation radius in m
-  double std_radr_;
-
-  ///* Radar measurement noise standard deviation angle in rad
-  double std_radphi_;
-
-  ///* Radar measurement noise standard deviation radius change in m/s
-  double std_radrd_;
-
   ///* Weights of sigma points
   Eigen::VectorXd weights_;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="18" deleted_lines="61">
				<diff>@@ -31,23 +31,25 @@ ImmUkfPda::ImmUkfPda()
   pub_object_array_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detected_objects", 1);
 }
 
-void ImmUkfPda::callback(autoware_msgs::CloudClusterArray input)
+void ImmUkfPda::callback(const autoware_msgs::CloudClusterArray&amp; input)
 {
-  autoware_msgs::CloudClusterArray output;
+  autoware_msgs::CloudClusterArray transformed_input;
   jsk_recognition_msgs::BoundingBoxArray jskbboxes_output;
   autoware_msgs::DetectedObjectArray detected_objects_output;
 
   // only transform pose(clusteArray.clusters.bouding_box.pose)
-  transformPoseToGlobal(input);
-  tracker(input, jskbboxes_output, detected_objects_output);
+  transformPoseToGlobal(input, transformed_input);
+  tracker(transformed_input, jskbboxes_output, detected_objects_output);
   transformPoseToLocal(jskbboxes_output, detected_objects_output);
 
   pub_jskbbox_array_.publish(jskbboxes_output);
   pub_object_array_.publish(detected_objects_output);
 }
 
-void ImmUkfPda::transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input)
+void ImmUkfPda::transformPoseToGlobal(const autoware_msgs::CloudClusterArray&amp; input,
+                                            autoware_msgs::CloudClusterArray&amp; transformed_input)
 {
+  transformed_input.header = input.header;
   for (size_t i = 0; i &lt; input.clusters.size(); i++)
   {
     geometry_msgs::PoseStamped pose_in, pose_out;
@@ -56,7 +58,13 @@ void ImmUkfPda::transformPoseToGlobal(autoware_msgs::CloudClusterArray&amp; input)
     pose_in.pose = input.clusters[i].bounding_box.pose;
     tf_listener_-&gt;waitForTransform(pointcloud_frame_, tracking_frame_, input.header.stamp, ros::Duration(1.0));
     tf_listener_-&gt;transformPose(tracking_frame_, ros::Time(0), pose_in, input.header.frame_id, pose_out);
-    input.clusters[i].bounding_box.pose = pose_out.pose;
+
+    autoware_msgs::CloudCluster cc;
+    cc.header = input.header;
+    cc = input.clusters[i];
+    cc.bounding_box.pose = pose_out.pose;
+    // input.clusters[i].bounding_box.pose = pose_out.pose;
+    transformed_input.clusters.push_back(cc);
   }
 }
 
@@ -447,57 +455,6 @@ void ImmUkfPda::updateBB(UKF&amp; target)
   }
 }
 
-// double ImmUkfPda::getIntersectCoef(const double vec1x, const double vec1y, const double vec2x, const double vec2y,
-//                                   const double px, const double py, const double cpx, const double cpy)
-// {
-//     double intersect_coef = (((vec1x-vec2x)*(py - vec1y) + (vec1y - vec2y)*(vec1x - px)) *
-//         ((vec1x - vec2x)*(cpy - vec1y) + (vec1y - vec2y)*(vec1x - cpx)));
-//     return intersect_coef;
-//
-// }
-
-// naive method
-// void ImmUkfPda::mergeOverSegmentation(const std::vector&lt;UKF&gt; targets){
-//     // cout &lt;&lt; "mergeOverSegmentation"&lt;&lt;endl;
-//     for(size_t i = 0; i &lt; targets.size(); i++){
-//         if(targets[i].is_vis_bb_ == true){
-//             double vec1x = targets[i].BBox_[0].x;
-//             double vec1y = targets[i].BBox_[0].y;
-//             double vec2x = targets[i].BBox_[1].x;
-//             double vec2y = targets[i].BBox_[1].y;
-//             double vec3x = targets[i].BBox_[2].x;
-//             double vec3y = targets[i].BBox_[2].y;
-//             double vec4x = targets[i].BBox_[3].x;
-//             double vec4y = targets[i].BBox_[3].y;
-//             double cp1x  = (vec1x+vec2x+vec3x)/3;
-//             double cp1y  = (vec1y+vec2y+vec3y)/3;
-//             double cp2x  = (vec1x+vec4x+vec3x)/3;
-//             double cp2y  = (vec1y+vec4y+vec3y)/3;
-//             for (int j = 0; j &lt; targets.size(); j++){
-//                 if(i == j) continue;
-//                 // make sure that merged area(i) is larger than compared area(j)
-//                 if(targets_[i].bb_area_ &lt; targets_[j].bb_area_){
-//                     double px = targets[j].x_merge_(0);
-//                     double py = targets[j].x_merge_(1);
-//                     // check if px, py are in triangle vec1, vec2, vec3
-//                     double cross1 = getIntersectCoef(vec1x, vec1y, vec2x, vec2y, px, py, cp1x, cp1y);
-//                     double cross2 = getIntersectCoef(vec1x, vec1y, vec3x, vec3y, px, py, cp1x, cp1y);
-//                     double cross3 = getIntersectCoef(vec3x, vec3y, vec2x, vec2y, px, py, cp1x, cp1y);
-//                     // check if px, py are in triangle vec1, vec3, vec4
-//                     double cross4 = getIntersectCoef(vec1x, vec1y, vec4x, vec4y, px, py, cp2x, cp2y);
-//                     double cross5 = getIntersectCoef(vec1x, vec1y, vec3x, vec3y, px, py, cp2x, cp2y);
-//                     double cross6 = getIntersectCoef(vec3x, vec3y, vec4x, vec4y, px, py, cp2x, cp2y);
-//                     // check if inside or not
-//                     if((cross1 &gt; 0 &amp;&amp; cross2&gt;0&amp;&amp;cross3&gt;0)||(cross4&gt;0 &amp;&amp; cross5 &gt; 0 &amp;&amp; cross6&gt;0)){
-//                         trackNumVec_[i] = 5;
-//                         trackNumVec_[j] = 0;
-//                     }
-//                 }
-//             }
-//         }
-//     }
-// }
-
 void ImmUkfPda::updateLabel(UKF target, autoware_msgs::DetectedObject&amp; dd)
 {
   int tracking_num = target.tracking_num_;
@@ -792,7 +749,7 @@ void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
   }
 }
 
-void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
+void ImmUkfPda::tracker(const autoware_msgs::CloudClusterArray transformed_input,
                         jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                         autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
 {
@@ -852,7 +809,7 @@ void ImmUkfPda::tracker(autoware_msgs::CloudClusterArray input,
 
   // making output(CludClusterArray) for visualization
   makeOutput(input, jskbboxes_output, detected_objects_output);
-
-  assert(matching_vec.size() == input.clusters.size());
-  assert(jskbboxes_output.boxes.size() == detected_objects_output.objects.size());
 }
+//   assert(matching_vec.size() == input.clusters.size());
+//   assert(jskbboxes_output.boxes.size() == detected_objects_output.objects.size());
+// }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" added_lines="3" deleted_lines="18">
				<diff>@@ -6,11 +6,6 @@
 */
 UKF::UKF()
 {
-  // if this is false, laser measurements will be ignored (except during init)
-  use_laser_ = true;
-
-  // if this is false, radar measurements will be ignored (except during init)
-  use_radar_ = true;
 
   // initial state vector
   x_merge_ = Eigen::MatrixXd(5, 1);
@@ -318,10 +313,7 @@ void UKF::interaction()
           mode_match_prob_rm2rm_ * (p_pre_rm + (x_pre_rm - x_rm_) * (x_pre_rm - x_rm_).transpose());
 }
 
-/**
-* @param {MeasurementPackage} meas_package The latest measurement data of
-* either radar or laser.
-*/
+
 void UKF::predictionIMMUKF(const double dt)
 {
   /*****************************************************************************
@@ -434,11 +426,7 @@ void UKF::randomMotion(const double p_x, const double p_y, const double v, const
   state[4] = yawd_p;
 }
 
-/**
-* Predicts sigma points, the state, and the state covariance matrix.
-* @param {double} delta_t the change in time (in seconds) between the last
-* measurement and this one.
-*/
+
 void UKF::prediction(const double delta_t, const int model_ind)
 {
   /*****************************************************************************
@@ -589,10 +577,7 @@ void UKF::prediction(const double delta_t, const int model_ind)
   }
 }
 
-/**
-* Updates the state and the state covariance matrix using a laser measurement.
-* @param {MeasurementPackage} meas_package
-*/
+
 void UKF::updateLidar(const int model_ind)
 {
   /*****************************************************************************
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c0121db3244d7ebceed9ce35cfa2898a8eea9ce7" author="Kosuke Murakami">
		<msg>Refactor codes</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" added_lines="18" deleted_lines="21">
				<diff>@@ -66,45 +66,42 @@ private:
                                    autoware_msgs::CloudClusterArray&amp; transformed_input);
   void transformPoseToLocal(jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                             autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
-  void findMaxZandS(const UKF target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s);
-  void measurementValidation(const autoware_msgs::CloudClusterArray input, UKF&amp; target, const bool second_init,
-                             const Eigen::VectorXd max_det_z, const Eigen::MatrixXd max_det_s,
+  void findMaxZandS(const UKF &amp;target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s);
+  void measurementValidation(const autoware_msgs::CloudClusterArray&amp; input, UKF&amp; target, const bool second_init,
+                             const Eigen::VectorXd&amp; max_det_z, const Eigen::MatrixXd&amp; max_det_s,
                              std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, std::vector&lt;bool&gt;&amp; matching_vec);
-  void filterPDA(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
+  void filterPDA(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
                  std::vector&lt;double&gt;&amp; lambda_vec);
-  void getNearestEuclidCluster(const UKF target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
+  void getNearestEuclidCluster(const UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
                                autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist);
   void getRightAngleBBox(const std::vector&lt;double&gt; nearest_bbox, std::vector&lt;double&gt;&amp; rightAngle_bbox);
-  void associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target);
-  double getBboxArea(const pcl::PointCloud&lt;pcl::PointXYZ&gt; bbox);
+  void associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, UKF&amp; target);
   double getBBoxYaw(const UKF target);
-  double getJskBBoxArea(const jsk_recognition_msgs::BoundingBox jsk_bb);
-  double getJskBBoxYaw(const jsk_recognition_msgs::BoundingBox jsk_bb);
+  double getJskBBoxArea(const jsk_recognition_msgs::BoundingBox&amp; jsk_bb);
+  double getJskBBoxYaw(const jsk_recognition_msgs::BoundingBox&amp; jsk_bb);
   void updateBB(UKF&amp; target);
-  double getIntersectCoef(const double vec1x, const double vec1y, const double vec2x, const double vec2y,
-                          const double p_x, const double p_y, const double cp_x, const double cp_y);
   void mergeOverSegmentation(const std::vector&lt;UKF&gt; targets);
 
-  void updateLabel(UKF target, autoware_msgs::DetectedObject&amp; dd);
-  void updateJskLabel(UKF target, jsk_recognition_msgs::BoundingBox&amp; bb);
-  bool isVisible(UKF target);
+  void updateLabel(const UKF&amp; target, autoware_msgs::DetectedObject&amp; dd);
+  void updateJskLabel(const UKF&amp; target, jsk_recognition_msgs::BoundingBox&amp; bb);
+  bool isVisible(const UKF&amp; target);
 
-  void initTracker(autoware_msgs::CloudClusterArray input, double timestamp);
-  void secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; clusterVec, UKF&amp; target);
+  void initTracker(const autoware_msgs::CloudClusterArray&amp; input, double timestamp);
+  void secondInit(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, double dt);
 
-  void updateTrackingNum(std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target);
+  void updateTrackingNum(const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, UKF&amp; target);
 
-  void probabilisticDataAssociation(autoware_msgs::CloudClusterArray input, double dt, double det_explode_param,
+  void probabilisticDataAssociation(const autoware_msgs::CloudClusterArray&amp; input, const double dt, const double det_explode_param,
                                     std::vector&lt;bool&gt;&amp; matching_vec, std::vector&lt;double&gt;&amp; lambda_vec, UKF&amp; target,
                                     bool&amp; is_skip_target);
-  void makeNewTargets(double timestamp, autoware_msgs::CloudClusterArray input, std::vector&lt;bool&gt; matching_vec);
+  void makeNewTargets(const double timestamp, const autoware_msgs::CloudClusterArray&amp; input, const std::vector&lt;bool&gt;&amp; matching_vec);
 
   void staticClassification();
 
-  void makeOutput(autoware_msgs::CloudClusterArray input, jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
+  void makeOutput(const autoware_msgs::CloudClusterArray&amp; input, jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                   autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
 
-  void tracker(const autoware_msgs::CloudClusterArray transformed_input, jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
+  void tracker(const autoware_msgs::CloudClusterArray&amp; transformed_input, jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
 
 public:
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="34" deleted_lines="49">
				<diff>@@ -87,7 +87,7 @@ void ImmUkfPda::transformPoseToLocal(jsk_recognition_msgs::BoundingBoxArray&amp; jsk
   }
 }
 
-void ImmUkfPda::findMaxZandS(const UKF target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s)
+void ImmUkfPda::findMaxZandS(const UKF&amp; target, Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s)
 {
   double cv_det = target.s_cv_.determinant();
   double ctrv_det = target.s_ctrv_.determinant();
@@ -121,8 +121,8 @@ void ImmUkfPda::findMaxZandS(const UKF target, Eigen::VectorXd&amp; max_det_z, Eigen
   }
 }
 
-void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray input, UKF&amp; target, const bool second_init,
-                                      const Eigen::VectorXd max_det_z, const Eigen::MatrixXd max_det_s,
+void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray &amp;input, UKF&amp; target, const bool second_init,
+                                      const Eigen::VectorXd &amp;max_det_z, const Eigen::MatrixXd &amp;max_det_s,
                                       std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
                                       std::vector&lt;bool&gt;&amp; matching_vec)
 {
@@ -167,7 +167,8 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::CloudClusterArray inp
     cluster_vec.push_back(smallest_meas_cluster);
 }
 
-void ImmUkfPda::filterPDA(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
+void ImmUkfPda::filterPDA(UKF&amp; target,
+                          const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
                           std::vector&lt;double&gt;&amp; lambda_vec)
 {
   // calculating association probability
@@ -325,7 +326,7 @@ void ImmUkfPda::filterPDA(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudClu
   lambda_vec.push_back(lambda_rm);
 }
 
-void ImmUkfPda::getNearestEuclidCluster(const UKF target, const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec,
+void ImmUkfPda::getNearestEuclidCluster(const UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec,
                                         autoware_msgs::CloudCluster&amp; cluster, double&amp; min_dist)
 {
   int min_ind = 0;
@@ -348,7 +349,7 @@ void ImmUkfPda::getNearestEuclidCluster(const UKF target, const std::vector&lt;auto
   cluster = cluster_vec[min_ind];
 }
 
-void ImmUkfPda::associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target)
+void ImmUkfPda::associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, UKF&amp; target)
 {
   // skip if no validated measurement
   if (cluster_vec.size() == 0)
@@ -368,22 +369,7 @@ void ImmUkfPda::associateBB(const std::vector&lt;autoware_msgs::CloudCluster&gt; clust
   }
 }
 
-double ImmUkfPda::getBboxArea(const pcl::PointCloud&lt;pcl::PointXYZ&gt; bbox)
-{
-  pcl::PointXYZ p1 = bbox[0];
-  pcl::PointXYZ p2 = bbox[1];
-  pcl::PointXYZ p3 = bbox[2];
-  pcl::PointXYZ p4 = bbox[3];
-
-  // S=tri(p1,p2,p3) + tri(p1, p3, p4)
-  // s(triangle) = 1/2*|(x1−x3)(y2−y3)−(x2−x3)(y1−y3)|
-  double tri1 = 0.5 * abs((p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y));
-  double tri2 = 0.5 * abs((p1.x - p4.x) * (p3.y - p4.y) - (p3.x - p4.x) * (p1.y - p4.y));
-  double S = tri1 + tri2;
-  return S;
-}
-
-double ImmUkfPda::getJskBBoxYaw(const jsk_recognition_msgs::BoundingBox jsk_bb)
+double ImmUkfPda::getJskBBoxYaw(const jsk_recognition_msgs::BoundingBox&amp; jsk_bb)
 {
   tf::Quaternion q(jsk_bb.pose.orientation.x, jsk_bb.pose.orientation.y, jsk_bb.pose.orientation.z,
                    jsk_bb.pose.orientation.w);
@@ -392,7 +378,7 @@ double ImmUkfPda::getJskBBoxYaw(const jsk_recognition_msgs::BoundingBox jsk_bb)
   return yaw;
 }
 
-double ImmUkfPda::getJskBBoxArea(const jsk_recognition_msgs::BoundingBox jsk_bb)
+double ImmUkfPda::getJskBBoxArea(const jsk_recognition_msgs::BoundingBox&amp; jsk_bb)
 {
   double area = jsk_bb.dimensions.x * jsk_bb.dimensions.y;
   return area;
@@ -417,23 +403,23 @@ void ImmUkfPda::updateBB(UKF&amp; target)
   }
 
   // restricting yaw movement
-  // double diff_yaw = yaw - target.best_yaw_;
-
-  // // diffYaw is within the threshold, apply the diffYaw chamge
-  // if(abs(diff_yaw) &lt; bb_yaw_change_thres_)
-  // {
-  //     target.best_jsk_bb_.pose.orientation = target.jsk_bb_.pose.orientation;
-  //     target.best_yaw_ = yaw;
-  // }
-  // else
-  // {
-  //     target.jsk_bb_.pose.orientation = target.best_jsk_bb_.pose.orientation;
-  // }
+  double diff_yaw = yaw - target.best_yaw_;
+
+  // diffYaw is within the threshold, apply the diffYaw chamge
+  if(abs(diff_yaw) &lt; bb_yaw_change_thres_)
+  {
+      target.best_jsk_bb_.pose.orientation = target.jsk_bb_.pose.orientation;
+      target.best_yaw_ = yaw;
+  }
+  else
+  {
+      target.jsk_bb_.pose.orientation = target.best_jsk_bb_.pose.orientation;
+  }
 
   // // bbox area
   double area = getJskBBoxArea(target.jsk_bb_);
   double best_area = getJskBBoxArea(target.best_jsk_bb_);
-  // double bestArea = getBboxArea(target.bestBBox_);
+
 
   // start updating bbox params
   double delta_area = area - best_area;
@@ -455,7 +441,7 @@ void ImmUkfPda::updateBB(UKF&amp; target)
   }
 }
 
-void ImmUkfPda::updateLabel(UKF target, autoware_msgs::DetectedObject&amp; dd)
+void ImmUkfPda::updateLabel(const UKF&amp; target, autoware_msgs::DetectedObject&amp; dd)
 {
   int tracking_num = target.tracking_num_;
   // cout &lt;&lt; "trackingnum "&lt;&lt; trackingNum &lt;&lt; endl;
@@ -481,10 +467,9 @@ void ImmUkfPda::updateLabel(UKF target, autoware_msgs::DetectedObject&amp; dd)
   }
 }
 
-void ImmUkfPda::updateJskLabel(UKF target, jsk_recognition_msgs::BoundingBox&amp; bb)
+void ImmUkfPda::updateJskLabel(const UKF&amp; target, jsk_recognition_msgs::BoundingBox&amp; bb)
 {
   int tracking_num = target.tracking_num_;
-  // cout &lt;&lt; "trackingnum "&lt;&lt; trackingNum &lt;&lt; endl;
   if (target.is_static_)
   {
     bb.label = 15;  // white color
@@ -495,7 +480,7 @@ void ImmUkfPda::updateJskLabel(UKF target, jsk_recognition_msgs::BoundingBox&amp; bb
   }
 }
 
-bool ImmUkfPda::isVisible(UKF target)
+bool ImmUkfPda::isVisible(const UKF&amp; target)
 {
   bool is_visible = false;
   int tracking_num = target.tracking_num_;
@@ -510,7 +495,7 @@ bool ImmUkfPda::isVisible(UKF target)
   return is_visible;
 }
 
-void ImmUkfPda::initTracker(autoware_msgs::CloudClusterArray input, double timestamp)
+void ImmUkfPda::initTracker(const autoware_msgs::CloudClusterArray&amp; input, double timestamp)
 {
   for (size_t i = 0; i &lt; input.clusters.size(); i++)
   {
@@ -528,7 +513,7 @@ void ImmUkfPda::initTracker(autoware_msgs::CloudClusterArray input, double times
   return;
 }
 
-void ImmUkfPda::secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target)
+void ImmUkfPda::secondInit(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, double dt)
 {
   if (cluster_vec.size() == 0)
   {
@@ -561,7 +546,7 @@ void ImmUkfPda::secondInit(double dt, std::vector&lt;autoware_msgs::CloudCluster&gt; c
   return;
 }
 
-void ImmUkfPda::updateTrackingNum(std::vector&lt;autoware_msgs::CloudCluster&gt; cluster_vec, UKF&amp; target)
+void ImmUkfPda::updateTrackingNum(const std::vector&lt;autoware_msgs::CloudCluster&gt;&amp; cluster_vec, UKF&amp; target)
 {
   if (cluster_vec.size() &gt; 0)
   {
@@ -601,8 +586,8 @@ void ImmUkfPda::updateTrackingNum(std::vector&lt;autoware_msgs::CloudCluster&gt; clust
   return;
 }
 
-void ImmUkfPda::probabilisticDataAssociation(autoware_msgs::CloudClusterArray input, double dt,
-                                             double det_explode_param, std::vector&lt;bool&gt;&amp; matching_vec,
+void ImmUkfPda::probabilisticDataAssociation(const autoware_msgs::CloudClusterArray&amp; input, const double dt,
+                                             const double det_explode_param, std::vector&lt;bool&gt;&amp; matching_vec,
                                              std::vector&lt;double&gt;&amp; lambda_vec, UKF&amp; target, bool&amp; is_skip_target)
 {
   Eigen::VectorXd max_det_z;
@@ -642,7 +627,7 @@ void ImmUkfPda::probabilisticDataAssociation(autoware_msgs::CloudClusterArray in
   // second detection for a target: update v and yaw
   if (is_second_init)
   {
-    secondInit(dt, cluster_vec, target);
+    secondInit(target, cluster_vec, dt);
     is_skip_target = true;
     return;
   }
@@ -658,7 +643,7 @@ void ImmUkfPda::probabilisticDataAssociation(autoware_msgs::CloudClusterArray in
   filterPDA(target, cluster_vec, lambda_vec);
 }
 
-void ImmUkfPda::makeNewTargets(double timestamp, autoware_msgs::CloudClusterArray input, std::vector&lt;bool&gt; matching_vec)
+void ImmUkfPda::makeNewTargets(const double timestamp, const autoware_msgs::CloudClusterArray&amp; input, const std::vector&lt;bool&gt;&amp; matching_vec)
 {
   for (size_t i = 0; i &lt; input.clusters.size(); i++)
   {
@@ -695,7 +680,7 @@ void ImmUkfPda::staticClassification()
   }
 }
 
-void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
+void ImmUkfPda::makeOutput(const autoware_msgs::CloudClusterArray&amp; input,
                            jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                            autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
 {
@@ -749,7 +734,7 @@ void ImmUkfPda::makeOutput(autoware_msgs::CloudClusterArray input,
   }
 }
 
-void ImmUkfPda::tracker(const autoware_msgs::CloudClusterArray transformed_input,
+void ImmUkfPda::tracker(const autoware_msgs::CloudClusterArray&amp; input,
                         jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                         autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_detected_objects\include\visualize_detected_objects.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_detected_objects\include\visualize_detected_objects.h" added_lines="2" deleted_lines="2">
				<diff>@@ -27,8 +27,8 @@ private:
   ros::Publisher pub_arrow_;
   ros::Publisher pub_id_;
 
-  void visMarkers(autoware_msgs::DetectedObjectArray input);
-  void callBack(autoware_msgs::DetectedObjectArray input);
+  void visMarkers(const autoware_msgs::DetectedObjectArray&amp; input);
+  void callBack(const autoware_msgs::DetectedObjectArray&amp; input);
 
 public:
   VisualizeDetectedObjects();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_detected_objects\src\visualize_detected_objects.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_detected_objects\src\visualize_detected_objects.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -13,12 +13,12 @@ VisualizeDetectedObjects::VisualizeDetectedObjects()
   pub_id_ = node_handle_.advertise&lt;visualization_msgs::Marker&gt;("/detected_objects/target_id", 1);
 }
 
-void VisualizeDetectedObjects::callBack(autoware_msgs::DetectedObjectArray input)
+void VisualizeDetectedObjects::callBack(const autoware_msgs::DetectedObjectArray&amp; input)
 {
   visMarkers(input);
 }
 
-void VisualizeDetectedObjects::visMarkers(autoware_msgs::DetectedObjectArray input)
+void VisualizeDetectedObjects::visMarkers(const autoware_msgs::DetectedObjectArray&amp; input)
 {
   for (size_t i = 0; i &lt; input.objects.size(); i++)
   {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4d28a4c855c5895e6e92a419dd85a7aeba93ce8c" author="Kosuke Murakami">
		<msg>Remove unnecessary comment</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" added_lines="4" deleted_lines="22">
				<diff>@@ -56,8 +56,7 @@ public:
   double std_a_cv_;
   double std_a_ctrv_;
   double std_a_rm_;
-  ///* Process noise standard deviation yaw acceleration in rad/s^2
-  //    double std_yawdd_;
+
 
   // CTRV
   double std_ctrv_yawdd_;
@@ -171,7 +170,7 @@ public:
 
   void updateYawWithHighProb();
 
-  void initialize(const Eigen::VectorXd z, const double timestamp);
+  void initialize(const Eigen::VectorXd&amp; z, const double timestamp);
 
   void updateModeProb(const std::vector&lt;double&gt; lambda_vec);
 
@@ -181,13 +180,9 @@ public:
 
   void interaction();
 
-  /**
-   * ProcessMeasurement
-   * @param meas_package The latest measurement data of either radar or laser
-   */
   void predictionIMMUKF(const double dt);
 
-  void updateIMMUKF(const std::vector&lt;double&gt; lambda_vec);
+  void updateIMMUKF(const std::vector&lt;double&gt;&amp; lambda_vec);
 
   void ctrv(const double p_x, const double p_y, const double v, const double yaw, const double yawd, const double nu_a,
             const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp; state);
@@ -197,24 +192,11 @@ public:
 
   void randomMotion(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
                     const double nu_a, const double nu_yawdd, const double delta_t, std::vector&lt;double&gt;&amp; state);
-  /**
-   * Prediction Predicts sigma points, the state, and the state covariance
-   * matrix
-   * @param delta_t Time between k and k+1 in s
-   */
+
   void prediction(const double delta_t, const int model_ind);
 
-  /**
-   * Updates the state and the state covariance matrix using a laser measurement
-   * @param meas_package The measurement at k+1
-   */
   void updateLidar(const int model_ind);
 
-  /**
-   * Updates the state and the state covariance matrix using a radar measurement
-   * @param meas_package The measurement at k+1
-   */
-  // void UpdateRadar(MeasurementPackage meas_package, int modelInd);
 };
 
 #endif /* UKF_H */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" added_lines="5" deleted_lines="10">
				<diff>@@ -63,7 +63,6 @@ void ImmUkfPda::transformPoseToGlobal(const autoware_msgs::CloudClusterArray&amp; in
     cc.header = input.header;
     cc = input.clusters[i];
     cc.bounding_box.pose = pose_out.pose;
-    // input.clusters[i].bounding_box.pose = pose_out.pose;
     transformed_input.clusters.push_back(cc);
   }
 }
@@ -523,7 +522,7 @@ void ImmUkfPda::secondInit(UKF&amp; target, const std::vector&lt;autoware_msgs::CloudCl
   // record init measurement for env classification
   target.init_meas_ &lt;&lt; target.x_merge_(0), target.x_merge_(1);
 
-  // abs update
+  // state update
   double target_x = cluster_vec[0].bounding_box.pose.position.x;
   double target_y = cluster_vec[0].bounding_box.pose.position.y;
   double target_diff_x = target_x - target.x_merge_(0);
@@ -669,7 +668,6 @@ void ImmUkfPda::staticClassification()
     if (!targets_[i].is_static_ &amp;&amp; targets_[i].tracking_num_ == TrackingState::Stable &amp;&amp;
         targets_[i].lifetime_ &gt; life_time_thres_)
     {
-      // double dist_thres = 3.0;
       if ((targets_[i].dist_from_init_ &lt; static_distance_thres_) &amp;&amp;
           (targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_cv_ ||
            targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_ctrv_))
@@ -781,10 +779,7 @@ void ImmUkfPda::tracker(const autoware_msgs::CloudClusterArray&amp; input,
     // immukf update step
     targets_[i].updateIMMUKF(lambda_vec);
   }
-  // // end UKF process
-
-  // // deling with over segmentation, update trackNumVec_
-  // mergeOverSegmentation(targets_);
+  // end UKF process
 
   // making new ukf target for no data association clusters
   makeNewTargets(timestamp, input, matching_vec);
@@ -794,7 +789,7 @@ void ImmUkfPda::tracker(const autoware_msgs::CloudClusterArray&amp; input,
 
   // making output(CludClusterArray) for visualization
   makeOutput(input, jskbboxes_output, detected_objects_output);
+
+  assert(matching_vec.size() == input.clusters.size());
+  assert(jskbboxes_output.boxes.size() == detected_objects_output.objects.size());
 }
-//   assert(matching_vec.size() == input.clusters.size());
-//   assert(jskbboxes_output.boxes.size() == detected_objects_output.objects.size());
-// }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -145,7 +145,7 @@ UKF::UKF()
   x_merge_yaw_ = 0;
 }
 
-void UKF::initialize(const Eigen::VectorXd z, const double timestamp)
+void UKF::initialize(const Eigen::VectorXd&amp; z, const double timestamp)
 {
   // first measurement
   x_merge_ &lt;&lt; 1, 1, 0, 0, 0.1;
@@ -336,7 +336,7 @@ void UKF::predictionIMMUKF(const double dt)
   updateLidar(2);
 }
 
-void UKF::updateIMMUKF(const std::vector&lt;double&gt; lambda_vec)
+void UKF::updateIMMUKF(const std::vector&lt;double&gt;&amp; lambda_vec)
 {
   /*****************************************************************************
   *  IMM Merge Step
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a3154b986aaab83b99d8c740bbf83693252bde55" author="Kosuke Murakami">
		<msg>Refactor codes</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" added_lines="1" deleted_lines="1">
				<diff>@@ -172,7 +172,7 @@ public:
 
   void initialize(const Eigen::VectorXd&amp; z, const double timestamp);
 
-  void updateModeProb(const std::vector&lt;double&gt; lambda_vec);
+  void updateModeProb(const std::vector&lt;double&gt;&amp; lambda_vec);
 
   void mergeEstimationAndCovariance();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -191,7 +191,7 @@ void UKF::initialize(const Eigen::VectorXd&amp; z, const double timestamp)
   jsk_bb_.pose.orientation.x = 1.0;
 }
 
-void UKF::updateModeProb(const std::vector&lt;double&gt; lambda_vec)
+void UKF::updateModeProb(const std::vector&lt;double&gt;&amp; lambda_vec)
 {
   double cvGauss = lambda_vec[0];
   double ctrvGauss = lambda_vec[1];
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="505a12d4db115380e7950173ccae022315585e0a" author="Manivannan Sadhasivam">
		<msg>Fix build failures on Aarch64

Following issues are detected and fixed while building Autoware on Aarch64 host:

1. FLOAT = abs(FLOAT) doesn't really makes sense. Hence modify that to use std::abs.
2. Include &lt;numeric&gt; header for using accumulate API.
3. Include &lt;boost/format.hpp&gt; header for using boost format API's.

Signed-off-by: Manivannan Sadhasivam &lt;manivannan.sadhasivam@linaro.org&gt;</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\get_boxes.cpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\get_boxes.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -480,7 +480,7 @@ FLOAT *dpm_ttic_cpu_get_boxes(FLOAT **features,FLOAT *scales,int *FSIZE,MODEL *M
 		}
 	}
 
-	FLOAT AS_OFF = abs(thresh);
+	FLOAT AS_OFF = std::abs(thresh);
 
 	//accumulated score calculation
 	FLOAT max_ac = 0.0;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -1,3 +1,4 @@
+#include &lt;numeric&gt;
 #include &lt;stdio.h&gt;
 
 #include &lt;geometry_msgs/PoseStamped.h&gt;
</diff>
			</file>
			<file old_path="ros\src\util\packages\kitti_pkg\kitti_player\src\kitti_player.cpp" new_path="ros\src\util\packages\kitti_pkg\kitti_player\src\kitti_player.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -26,6 +26,7 @@
 #include &lt;string&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;boost/algorithm/string.hpp&gt;
+#include &lt;boost/format.hpp&gt;
 #include &lt;boost/lexical_cast.hpp&gt;
 //#include &lt;boost/locale.hpp&gt;
 #include &lt;boost/program_options.hpp&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c50d17adb0e1e765ad7d665849c7170d2218c526" author="Kosuke Murakami">
		<msg>[Fix] rename packages (#1269)

* rename lidar_tracker

* Modify pf_lidar_track's cmake file

* Refactor code

* Rename from euclidean_lidar_tracker to lidar_euclidean_track

* Rename from kf_contour_track to lidar_kf_contour_track

* Rename from kf_lidar_track to lidar_kf_track, but need some modification in euclidean cluster(Cluster.h)

* Rename from pf_lidar_tarck to lidar_pf_track

* Rename range_fusion

* Rename obj_reproj

* Rename euclidean_cluster to lidar_euclidean_cluster_detect

* Rename svm_lidar_detect to lidar_svm_detect

* Rename kf_lidar_track to lidar_kf_track

* Change version 1.6.3 to 1.7.0 in pacakge.xml

* Modify CMake so that extrenal header would be loaded

* Remove obj_reproj from cv_tracker

* Add interface.yaml

* Rename road_wizard to trafficlight_recognizer

* create common directory

* Add lidar_imm_ukf_pda_track

* create vision_detector and moved cv

* Modify interface.yaml and package.xml

* remove dpm_ocv

* moved directory

* Delete unnecessary launch file

* Delete rcnn related file and code

* separated dummy_track from cv_tracker

* separated klt_track from cv_tracker

* Fix a cmake

* Remove unnecessary dependency of lidar_euclidean_cluster_detect package

* Rename image_segmenter to vision_segment_enet_detect

* Remove unnecessary dependency of lidar_svm_detect package

* separated kf_track and fix a some compiling issue

* move viewers

* merge ndt_localizer and icp_localizer, and rename to lidar_localizer

* Remove unnecessary dependency of lidar_euclidean_track

* moved image lib

* add launch

* lib move under lidar_tracker

* Rename dpm_ttic to vision_dpm_ttic_detect

* rename yolo3detector to vision_yolo3_detect

* Modify cmake and package.xml in vision_dpm_ttic_detect

* moved sourcefiles into nodes dir

* moved sourcefiles into nodes dir

* Move cv_tracker/data folder and delete cv_tracker/model folder

* fix a package file and cmake

* Rename yolo2 -&gt; vision_yolo2_detect

* fix a package file and cmake

* Fix package name of launch file

* Rename ssd to vision_ssd_detect

* fixed cmake and package for decerese dependencies

* remove top packages dir for detection

* fixed cmake for cuda

* Rename lane_detector to vision_lane_detect

* Modify package.xml in lidar-related packages

* Remove unnecessary dependencies in lidar_detector and lidar_tracker

* Modify computing.yaml for dpm_ttic

* Modify dpm_ttic launch file

* Remove/Add dependencies to trafficlight_recognizer

* Update data folder in dpm_ttic

* Modified CMake and package file in dpm_ttic.

* Remove src dir in imm_ukf_pda_track

* removed unnecessary comments

* rename lidar_tracker

* Modify pf_lidar_track's cmake file

* Refactor code

* Rename from euclidean_lidar_tracker to lidar_euclidean_track

* Rename from kf_contour_track to lidar_kf_contour_track

* Rename from kf_lidar_track to lidar_kf_track, but need some modification in euclidean cluster(Cluster.h)

* Rename from pf_lidar_tarck to lidar_pf_track

* Rename range_fusion

* Rename obj_reproj

* Rename road_wizard to trafficlight_recognizer

* Rename euclidean_cluster to lidar_euclidean_cluster_detect

* Rename svm_lidar_detect to lidar_svm_detect

* Rename kf_lidar_track to lidar_kf_track

* Change version 1.6.3 to 1.7.0 in pacakge.xml

* Modify CMake so that extrenal header would be loaded

* Remove obj_reproj from cv_tracker

* Add interface.yaml

* create common directory

* Add lidar_imm_ukf_pda_track

* create vision_detector and moved cv

* Modify interface.yaml and package.xml

* remove dpm_ocv

* moved directory

* Delete unnecessary launch file

* Delete rcnn related file and code

* separated dummy_track from cv_tracker

* separated klt_track from cv_tracker

* Fix a cmake

* Remove unnecessary dependency of lidar_euclidean_cluster_detect package

* Rename image_segmenter to vision_segment_enet_detect

* Remove unnecessary dependency of lidar_svm_detect package

* separated kf_track and fix a some compiling issue

* move viewers

* merge ndt_localizer and icp_localizer, and rename to lidar_localizer

* Remove unnecessary dependency of lidar_euclidean_track

* moved image lib

* add launch

* lib move under lidar_tracker

* Rename dpm_ttic to vision_dpm_ttic_detect

* rename yolo3detector to vision_yolo3_detect

* Modify cmake and package.xml in vision_dpm_ttic_detect

* moved sourcefiles into nodes dir

* moved sourcefiles into nodes dir

* Move cv_tracker/data folder and delete cv_tracker/model folder

* fix a package file and cmake

* Rename yolo2 -&gt; vision_yolo2_detect

* fix a package file and cmake

* Fix package name of launch file

* Rename ssd to vision_ssd_detect

* fixed cmake and package for decerese dependencies

* remove top packages dir for detection

* fixed cmake for cuda

* Rename lane_detector to vision_lane_detect

* Modify package.xml in lidar-related packages

* Remove unnecessary dependencies in lidar_detector and lidar_tracker

* Modify computing.yaml for dpm_ttic

* Modify dpm_ttic launch file

* Remove/Add dependencies to trafficlight_recognizer

* Update data folder in dpm_ttic

* Modified CMake and package file in dpm_ttic.

* Remove src dir in imm_ukf_pda_track

* Fix bug for not starting run time manager

* Remove invalid dependency</msg>
		<modified_files>
			<file old_path="ros\src\.config\quick_start\sample_lidar_camera\detection.launch" new_path="ros\src\.config\quick_start\sample_lidar_camera\detection.launch" added_lines="2" deleted_lines="2">
				<diff>@@ -44,11 +44,11 @@
 
   &lt;!-- traffic light recognition --&gt;
   &lt;!-- feat_proj --&gt;
-  &lt;node pkg="road_wizard" type="feat_proj" name="feat_proj"&gt;
+  &lt;node pkg="trafficlight_recognizer" type="feat_proj" name="feat_proj"&gt;
   &lt;/node&gt;
 
   &lt;!-- region_tlr --&gt;
-  &lt;include file="$(find road_wizard)/launch/traffic_light_recognition.launch"&gt;
+  &lt;include file="$(find trafficlight_recognizer)/launch/traffic_light_recognition.launch"&gt;
   &lt;/include&gt;
 
 &lt;/launch&gt;
</diff>
			</file>
			<file old_path="ros\src\.config\quick_start\sample_lidar_camera\localization.launch" new_path="ros\src\.config\quick_start\sample_lidar_camera\localization.launch" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
   &lt;include file="$(find gnss_localizer)/launch/nmea2tfpose.launch"/&gt;
 
   &lt;!-- ndt_matching --&gt;
-  &lt;include file="$(find ndt_localizer)/launch/ndt_matching.launch"/&gt;
+  &lt;include file="$(find lidar_localizer)/launch/ndt_matching.launch"/&gt;
 
   &lt;!-- calibration_publisher --&gt;
   &lt;include file="$(find runtime_manager)/scripts/calibration_publisher.launch"&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\amathutils_lib\include\amathutils_lib\amathutils.hpp" new_path="ros\src\common\libs\amathutils_lib\include\amathutils_lib\amathutils.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\amathutils_lib\src\Amathutils.cpp" new_path="ros\src\common\libs\amathutils_lib\src\Amathutils.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\state_machine_lib\include\state_machine_lib\state.hpp" new_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\state_machine_lib\include\state_machine_lib\state_common.hpp" new_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_common.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\state_machine_lib\include\state_machine_lib\state_context.hpp" new_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_context.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\state_machine_lib\include\state_machine_lib\state_drive.hpp" new_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_drive.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\state_machine_lib\include\state_machine_lib\state_emg.hpp" new_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_emg.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\state_machine_lib\include\state_machine_lib\state_flags.hpp" new_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_flags.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\state_machine_lib\include\state_machine_lib\state_main.hpp" new_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_main.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\state_machine_lib\src\state_context.cpp" new_path="ros\src\common\libs\state_machine_lib\src\state_context.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\libvectormap\FindEigen.cmake" new_path="ros\src\common\libvectormap\FindEigen.cmake" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\libvectormap\include\libvectormap\Math.h" new_path="ros\src\common\libvectormap\include\libvectormap\Math.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\libvectormap\include\libvectormap\vector_map.h" new_path="ros\src\common\libvectormap\include\libvectormap\vector_map.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\libvectormap\src\vector_map.cpp" new_path="ros\src\common\libvectormap\src\vector_map.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\cpu\dpm_ocv_cpu.cpp" new_path="" added_lines="0" deleted_lines="657">
				<diff>@@ -1,657 +0,0 @@
-#include &lt;opencv2/opencv.hpp&gt;
-#include &lt;opencv2/core/core.hpp&gt;
-#include &lt;libdpm_ocv/dpm_ocv.hpp&gt;
-
-// Macros in OpenCV private header files
-#define VAL_OF_TRUNCATE 0.2f
-#define LATENT_SVM_OK 0
-
-// Data structures in OpenCV private header files
-typedef struct{
-    int sizeX;
-    int sizeY;
-    int numFeatures;
-    float *map;
-} CvLSVMFeatureMap;
-
-typedef struct{
-    int numLevels;
-    CvLSVMFeatureMap **pyramid;
-} CvLSVMFeaturePyramid;
-
-// OpenCV non public functions
-extern int allocFeatureMapObject(CvLSVMFeatureMap **obj, const int sizeX, const int sizeY,
-                                const int p);
-extern IplImage * resize_opencv(IplImage * img, float scale);
-extern int computeBorderSize(int maxXBorder, int maxYBorder, int *bx, int *by);
-extern int addNullableBorder(CvLSVMFeatureMap *map, int bx, int by);
-
-extern "C" {
-extern int allocFeaturePyramidObject(CvLSVMFeaturePyramid **obj, const int countLevel);
-extern int freeFeaturePyramidObject(CvLSVMFeaturePyramid **obj);
-extern int getMaxFilterDims(const CvLSVMFilterObject **filters, int kComponents,
-                            const int *kPartFilters,
-                            unsigned int *maxXBorder, unsigned int *maxYBorder);
-extern int searchObjectThresholdSomeComponents(const CvLSVMFeaturePyramid *H,
-                                               const CvLSVMFilterObject **filters,
-                                               int kComponents, const int *kPartFilters,
-                                               const float *b, float scoreThreshold,
-                                               CvPoint **points, CvPoint **oppPoints,
-                                               float **score, int *kPoints, int numThreads);
-extern int clippingBoxes(int width, int height,
-                         CvPoint *points, int kPoints);
-extern int nonMaximumSuppression(int numBoxes, const CvPoint *points,
-                                 const CvPoint *oppositePoints, const float *score,
-                                 float overlapThreshold,
-                                 int *numBoxesOut, CvPoint **pointsOut,
-                                 CvPoint **oppositePointsOut, float **scoreOut);
-extern CvLatentSvmDetector* cvLoadLatentSvmDetector(const char* filename);
-};
-
-// [COPY] static functions in OpenCV
-static int normalizeAndTruncate(CvLSVMFeatureMap *map, const float alfa, int num_bins)
-{
-    int i,j, ii;
-    int sizeX, sizeY, p, pos, pp, xp, pos1, pos2;
-    float * partOfNorm; // norm of C(i, j)
-    float * newData;
-    float   valOfNorm;
-
-    sizeX     = map-&gt;sizeX;
-    sizeY     = map-&gt;sizeY;
-    partOfNorm = (float *)malloc (sizeof(float) * (sizeX * sizeY));
-
-    p  = num_bins;
-    xp = num_bins * 3;
-    pp = num_bins * 12;
-
-    for(i = 0; i &lt; sizeX * sizeY; i++)
-    {
-        valOfNorm = 0.0f;
-        pos = i * map-&gt;numFeatures;
-        for(j = 0; j &lt; p; j++)
-        {
-            valOfNorm += map-&gt;map[pos + j] * map-&gt;map[pos + j];
-        }/*for(j = 0; j &lt; p; j++)*/
-        partOfNorm[i] = valOfNorm;
-    }/*for(i = 0; i &lt; sizeX * sizeY; i++)*/
-
-    sizeX -= 2;
-    sizeY -= 2;
-
-    newData = (float *)malloc (sizeof(float) * (sizeX * sizeY * pp));
-    //normalization
-    for(i = 1; i &lt;= sizeY; i++)
-    {
-        for(j = 1; j &lt;= sizeX; j++)
-        {
-            valOfNorm = sqrtf(
-                partOfNorm[(i    )*(sizeX + 2) + (j    )] +
-                partOfNorm[(i    )*(sizeX + 2) + (j + 1)] +
-                partOfNorm[(i + 1)*(sizeX + 2) + (j    )] +
-                partOfNorm[(i + 1)*(sizeX + 2) + (j + 1)]) + FLT_EPSILON;
-            pos1 = (i  ) * (sizeX + 2) * xp + (j  ) * xp;
-            pos2 = (i-1) * (sizeX    ) * pp + (j-1) * pp;
-            for(ii = 0; ii &lt; p; ii++)
-            {
-                newData[pos2 + ii        ] = map-&gt;map[pos1 + ii    ] / valOfNorm;
-            }/*for(ii = 0; ii &lt; p; ii++)*/
-            for(ii = 0; ii &lt; 2 * p; ii++)
-            {
-                newData[pos2 + ii + p * 4] = map-&gt;map[pos1 + ii + p] / valOfNorm;
-            }/*for(ii = 0; ii &lt; 2 * p; ii++)*/
-            valOfNorm = sqrtf(
-                partOfNorm[(i    )*(sizeX + 2) + (j    )] +
-                partOfNorm[(i    )*(sizeX + 2) + (j + 1)] +
-                partOfNorm[(i - 1)*(sizeX + 2) + (j    )] +
-                partOfNorm[(i - 1)*(sizeX + 2) + (j + 1)]) + FLT_EPSILON;
-            for(ii = 0; ii &lt; p; ii++)
-            {
-                newData[pos2 + ii + p    ] = map-&gt;map[pos1 + ii    ] / valOfNorm;
-            }/*for(ii = 0; ii &lt; p; ii++)*/
-            for(ii = 0; ii &lt; 2 * p; ii++)
-            {
-                newData[pos2 + ii + p * 6] = map-&gt;map[pos1 + ii + p] / valOfNorm;
-            }/*for(ii = 0; ii &lt; 2 * p; ii++)*/
-            valOfNorm = sqrtf(
-                partOfNorm[(i    )*(sizeX + 2) + (j    )] +
-                partOfNorm[(i    )*(sizeX + 2) + (j - 1)] +
-                partOfNorm[(i + 1)*(sizeX + 2) + (j    )] +
-                partOfNorm[(i + 1)*(sizeX + 2) + (j - 1)]) + FLT_EPSILON;
-            for(ii = 0; ii &lt; p; ii++)
-            {
-                newData[pos2 + ii + p * 2] = map-&gt;map[pos1 + ii    ] / valOfNorm;
-            }/*for(ii = 0; ii &lt; p; ii++)*/
-            for(ii = 0; ii &lt; 2 * p; ii++)
-            {
-                newData[pos2 + ii + p * 8] = map-&gt;map[pos1 + ii + p] / valOfNorm;
-            }/*for(ii = 0; ii &lt; 2 * p; ii++)*/
-            valOfNorm = sqrtf(
-                partOfNorm[(i    )*(sizeX + 2) + (j    )] +
-                partOfNorm[(i    )*(sizeX + 2) + (j - 1)] +
-                partOfNorm[(i - 1)*(sizeX + 2) + (j    )] +
-                partOfNorm[(i - 1)*(sizeX + 2) + (j - 1)]) + FLT_EPSILON;
-            for(ii = 0; ii &lt; p; ii++)
-            {
-                newData[pos2 + ii + p * 3 ] = map-&gt;map[pos1 + ii    ] / valOfNorm;
-            }/*for(ii = 0; ii &lt; p; ii++)*/
-            for(ii = 0; ii &lt; 2 * p; ii++)
-            {
-                newData[pos2 + ii + p * 10] = map-&gt;map[pos1 + ii + p] / valOfNorm;
-            }/*for(ii = 0; ii &lt; 2 * p; ii++)*/
-        }/*for(j = 1; j &lt;= sizeX; j++)*/
-    }/*for(i = 1; i &lt;= sizeY; i++)*/
-    //truncation
-    for(i = 0; i &lt; sizeX * sizeY * pp; i++)
-    {
-        if(newData [i] &gt; alfa) newData [i] = alfa;
-    }/*for(i = 0; i &lt; sizeX * sizeY * pp; i++)*/
-    //swap data
-
-    map-&gt;numFeatures  = pp;
-    map-&gt;sizeX = sizeX;
-    map-&gt;sizeY = sizeY;
-
-    free (map-&gt;map);
-    free (partOfNorm);
-
-    map-&gt;map = newData;
-
-    return LATENT_SVM_OK;
-}
-
-static int PCAFeatureMaps(CvLSVMFeatureMap *map, int num_bins)
-{
-    int i,j, ii, jj, k;
-    int sizeX, sizeY, p,  pp, xp, yp, pos1, pos2;
-    float * newData;
-    float val;
-    float nx, ny;
-
-    sizeX = map-&gt;sizeX;
-    sizeY = map-&gt;sizeY;
-    p     = map-&gt;numFeatures;
-    pp    = num_bins * 3 + 4;
-    yp    = 4;
-    xp    = num_bins;
-
-    nx    = 1.0f / sqrtf((float)(xp * 2));
-    ny    = 1.0f / sqrtf((float)(yp    ));
-
-    newData = (float *)malloc (sizeof(float) * (sizeX * sizeY * pp));
-
-    for(i = 0; i &lt; sizeY; i++)
-    {
-        for(j = 0; j &lt; sizeX; j++)
-        {
-            pos1 = ((i)*sizeX + j)*p;
-            pos2 = ((i)*sizeX + j)*pp;
-            k = 0;
-            for(jj = 0; jj &lt; xp * 2; jj++)
-            {
-                val = 0;
-                for(ii = 0; ii &lt; yp; ii++)
-                {
-                    val += map-&gt;map[pos1 + yp * xp + ii * xp * 2 + jj];
-                }/*for(ii = 0; ii &lt; yp; ii++)*/
-                newData[pos2 + k] = val * ny;
-                k++;
-            }/*for(jj = 0; jj &lt; xp * 2; jj++)*/
-            for(jj = 0; jj &lt; xp; jj++)
-            {
-                val = 0;
-                for(ii = 0; ii &lt; yp; ii++)
-                {
-                    val += map-&gt;map[pos1 + ii * xp + jj];
-                }/*for(ii = 0; ii &lt; yp; ii++)*/
-                newData[pos2 + k] = val * ny;
-                k++;
-            }/*for(jj = 0; jj &lt; xp; jj++)*/
-            for(ii = 0; ii &lt; yp; ii++)
-            {
-                val = 0;
-                for(jj = 0; jj &lt; 2 * xp; jj++)
-                {
-                    val += map-&gt;map[pos1 + yp * xp + ii * xp * 2 + jj];
-                }/*for(jj = 0; jj &lt; xp; jj++)*/
-                newData[pos2 + k] = val * nx;
-                k++;
-            } /*for(ii = 0; ii &lt; yp; ii++)*/
-        }/*for(j = 0; j &lt; sizeX; j++)*/
-    }/*for(i = 0; i &lt; sizeY; i++)*/
-    //swap data
-
-    map-&gt;numFeatures = pp;
-
-    free (map-&gt;map);
-
-    map-&gt;map = newData;
-
-    return LATENT_SVM_OK;
-}
-
-static int getFeatureMaps(const IplImage* image, const int k, CvLSVMFeatureMap **map, int num_bins)
-{
-    int sizeX, sizeY;
-    int p, px, stringSize;
-    int height, width, numChannels;
-    int i, j, kk, c, ii, jj, d;
-    float  * datadx, * datady;
-
-    int   ch;
-    float magnitude, x, y, tx, ty;
-
-    IplImage * dx, * dy;
-    int *nearest;
-    float *w, a_x, b_x;
-
-    float kernel[3] = {-1.f, 0.f, 1.f};
-    CvMat kernel_dx = cvMat(1, 3, CV_32F, kernel);
-    CvMat kernel_dy = cvMat(3, 1, CV_32F, kernel);
-
-    float * r;
-    int   * alfa;
-
-    float boundary_x[num_bins + 1];
-    float boundary_y[num_bins + 1];
-    float max, dotProd;
-    int   maxi;
-
-    height = image-&gt;height;
-    width  = image-&gt;width ;
-
-    numChannels = image-&gt;nChannels;
-
-    dx    = cvCreateImage(cvSize(image-&gt;width, image-&gt;height),
-                          IPL_DEPTH_32F, 3);
-    dy    = cvCreateImage(cvSize(image-&gt;width, image-&gt;height),
-                          IPL_DEPTH_32F, 3);
-
-    sizeX = width  / k;
-    sizeY = height / k;
-    px    = 3 * num_bins;
-    p     = px;
-    stringSize = sizeX * p;
-    allocFeatureMapObject(map, sizeX, sizeY, p);
-
-    cvFilter2D(image, dx, &amp;kernel_dx, cvPoint(-1, 0));
-    cvFilter2D(image, dy, &amp;kernel_dy, cvPoint(0, -1));
-
-    float arg_vector;
-    for(i = 0; i &lt;= num_bins; i++)
-    {
-        arg_vector    = ( (float) i ) * ( (float)(CV_PI) / (float)(num_bins) );
-        boundary_x[i] = cosf(arg_vector);
-        boundary_y[i] = sinf(arg_vector);
-    }/*for(i = 0; i &lt;= NUM_SECTOR; i++) */
-
-    r    = (float *)malloc( sizeof(float) * (width * height));
-    alfa = (int   *)malloc( sizeof(int  ) * (width * height * 2));
-
-    for(j = 1; j &lt; height - 1; j++)
-    {
-        datadx = (float*)(dx-&gt;imageData + dx-&gt;widthStep * j);
-        datady = (float*)(dy-&gt;imageData + dy-&gt;widthStep * j);
-        for(i = 1; i &lt; width - 1; i++)
-        {
-            c = 0;
-            x = (datadx[i * numChannels + c]);
-            y = (datady[i * numChannels + c]);
-
-            r[j * width + i] =sqrtf(x * x + y * y);
-            for(ch = 1; ch &lt; numChannels; ch++)
-            {
-                tx = (datadx[i * numChannels + ch]);
-                ty = (datady[i * numChannels + ch]);
-                magnitude = sqrtf(tx * tx + ty * ty);
-                if(magnitude &gt; r[j * width + i])
-                {
-                    r[j * width + i] = magnitude;
-                    c = ch;
-                    x = tx;
-                    y = ty;
-                }
-            }/*for(ch = 1; ch &lt; numChannels; ch++)*/
-
-            max  = boundary_x[0] * x + boundary_y[0] * y;
-            maxi = 0;
-            for (kk = 0; kk &lt; num_bins; kk++)
-            {
-                dotProd = boundary_x[kk] * x + boundary_y[kk] * y;
-                if (dotProd &gt; max)
-                {
-                    max  = dotProd;
-                    maxi = kk;
-                }
-                else
-                {
-                    if (-dotProd &gt; max)
-                    {
-                        max  = -dotProd;
-                        maxi = kk + num_bins;
-                    }
-                }
-            }
-            alfa[j * width * 2 + i * 2    ] = maxi % num_bins;
-            alfa[j * width * 2 + i * 2 + 1] = maxi;
-        }/*for(i = 0; i &lt; width; i++)*/
-    }/*for(j = 0; j &lt; height; j++)*/
-
-    nearest = (int  *)malloc(sizeof(int  ) *  k);
-    w       = (float*)malloc(sizeof(float) * (k * 2));
-
-    for(i = 0; i &lt; k / 2; i++)
-    {
-        nearest[i] = -1;
-    }/*for(i = 0; i &lt; k / 2; i++)*/
-    for(i = k / 2; i &lt; k; i++)
-    {
-        nearest[i] = 1;
-    }/*for(i = k / 2; i &lt; k; i++)*/
-
-    for(j = 0; j &lt; k / 2; j++)
-    {
-        b_x = k / 2 + j + 0.5f;
-        a_x = k / 2 - j - 0.5f;
-        w[j * 2    ] = 1.0f/a_x * ((a_x * b_x) / ( a_x + b_x));
-        w[j * 2 + 1] = 1.0f/b_x * ((a_x * b_x) / ( a_x + b_x));
-    }/*for(j = 0; j &lt; k / 2; j++)*/
-    for(j = k / 2; j &lt; k; j++)
-    {
-        a_x = j - k / 2 + 0.5f;
-        b_x =-j + k / 2 - 0.5f + k;
-        w[j * 2    ] = 1.0f/a_x * ((a_x * b_x) / ( a_x + b_x));
-        w[j * 2 + 1] = 1.0f/b_x * ((a_x * b_x) / ( a_x + b_x));
-    }/*for(j = k / 2; j &lt; k; j++)*/
-
-
-    for(i = 0; i &lt; sizeY; i++)
-    {
-      for(j = 0; j &lt; sizeX; j++)
-      {
-        for(ii = 0; ii &lt; k; ii++)
-        {
-          for(jj = 0; jj &lt; k; jj++)
-          {
-            if ((i * k + ii &gt; 0) &amp;&amp;
-                (i * k + ii &lt; height - 1) &amp;&amp;
-                (j * k + jj &gt; 0) &amp;&amp;
-                (j * k + jj &lt; width  - 1))
-            {
-              d = (k * i + ii) * width + (j * k + jj);
-              (*map)-&gt;map[ i * stringSize + j * (*map)-&gt;numFeatures + alfa[d * 2    ]] +=
-                  r[d] * w[ii * 2] * w[jj * 2];
-              (*map)-&gt;map[ i * stringSize + j * (*map)-&gt;numFeatures + alfa[d * 2 + 1] + num_bins] +=
-                  r[d] * w[ii * 2] * w[jj * 2];
-              if ((i + nearest[ii] &gt;= 0) &amp;&amp;
-                  (i + nearest[ii] &lt;= sizeY - 1))
-              {
-                (*map)-&gt;map[(i + nearest[ii]) * stringSize + j * (*map)-&gt;numFeatures + alfa[d * 2    ]             ] +=
-                  r[d] * w[ii * 2 + 1] * w[jj * 2 ];
-                (*map)-&gt;map[(i + nearest[ii]) * stringSize + j * (*map)-&gt;numFeatures + alfa[d * 2 + 1] + num_bins] +=
-                  r[d] * w[ii * 2 + 1] * w[jj * 2 ];
-              }
-              if ((j + nearest[jj] &gt;= 0) &amp;&amp;
-                  (j + nearest[jj] &lt;= sizeX - 1))
-              {
-                (*map)-&gt;map[i * stringSize + (j + nearest[jj]) * (*map)-&gt;numFeatures + alfa[d * 2    ]             ] +=
-                  r[d] * w[ii * 2] * w[jj * 2 + 1];
-                (*map)-&gt;map[i * stringSize + (j + nearest[jj]) * (*map)-&gt;numFeatures + alfa[d * 2 + 1] + num_bins] +=
-                  r[d] * w[ii * 2] * w[jj * 2 + 1];
-              }
-              if ((i + nearest[ii] &gt;= 0) &amp;&amp;
-                  (i + nearest[ii] &lt;= sizeY - 1) &amp;&amp;
-                  (j + nearest[jj] &gt;= 0) &amp;&amp;
-                  (j + nearest[jj] &lt;= sizeX - 1))
-              {
-                (*map)-&gt;map[(i + nearest[ii]) * stringSize + (j + nearest[jj]) * (*map)-&gt;numFeatures + alfa[d * 2    ]             ] +=
-                  r[d] * w[ii * 2 + 1] * w[jj * 2 + 1];
-                (*map)-&gt;map[(i + nearest[ii]) * stringSize + (j + nearest[jj]) * (*map)-&gt;numFeatures + alfa[d * 2 + 1] + num_bins] +=
-                  r[d] * w[ii * 2 + 1] * w[jj * 2 + 1];
-              }
-            }
-          }/*for(jj = 0; jj &lt; k; jj++)*/
-        }/*for(ii = 0; ii &lt; k; ii++)*/
-      }/*for(j = 1; j &lt; sizeX - 1; j++)*/
-    }/*for(i = 1; i &lt; sizeY - 1; i++)*/
-
-    cvReleaseImage(&amp;dx);
-    cvReleaseImage(&amp;dy);
-
-
-    free(w);
-    free(nearest);
-
-    free(r);
-    free(alfa);
-
-    return LATENT_SVM_OK;
-}
-
-static int getPathOfFeaturePyramid(IplImage * image,
-                            float step, int numStep, int startIndex,
-                            int sideLength, CvLSVMFeaturePyramid **maps, int num_bins)
-{
-    CvLSVMFeatureMap *map;
-    IplImage *scaleTmp;
-    float scale;
-    int   i;
-
-    for(i = 0; i &lt; numStep; i++)
-    {
-        scale = 1.0f / powf(step, (float)i);
-        scaleTmp = resize_opencv (image, scale);
-        getFeatureMaps(scaleTmp, sideLength, &amp;map, num_bins);
-        normalizeAndTruncate(map, VAL_OF_TRUNCATE, num_bins);
-        PCAFeatureMaps(map, num_bins);
-        (*maps)-&gt;pyramid[startIndex + i] = map;
-        cvReleaseImage(&amp;scaleTmp);
-    }/*for(i = 0; i &lt; numStep; i++)*/
-    return LATENT_SVM_OK;
-}
-
-/* add some parameters to getFeaturePyramid OpenCV API for parameters configuration */
-static int getFeaturePyramid(IplImage * image, CvLSVMFeaturePyramid **maps,
-                             int lambda, int num_cells, int num_bins)
-{
-    IplImage *imgResize;
-    float step;
-    int   numStep;
-    int   maxNumCells;
-    int   W, H;
-
-    if(image-&gt;depth == IPL_DEPTH_32F)
-    {
-        imgResize = image;
-    }
-    else
-    {
-        imgResize = cvCreateImage(cvSize(image-&gt;width , image-&gt;height) ,
-                                  IPL_DEPTH_32F , 3);
-        cvConvert(image, imgResize);
-    }
-
-    W = imgResize-&gt;width;
-    H = imgResize-&gt;height;
-
-    step = powf(2.0f, 1.0f / ((float)lambda));
-    maxNumCells = W / num_cells;
-    if( maxNumCells &gt; H / num_cells )
-    {
-        maxNumCells = H / num_cells;
-    }
-    numStep = (int)(logf((float) maxNumCells / (5.0f)) / logf( step )) + 1;
-
-    allocFeaturePyramidObject(maps, numStep + lambda);
-
-    getPathOfFeaturePyramid(imgResize, step   , lambda, 0,
-                            num_cells / 2, maps, num_bins);
-    getPathOfFeaturePyramid(imgResize, step, numStep, lambda,
-                            num_cells    , maps, num_bins);
-    if(image-&gt;depth != IPL_DEPTH_32F)
-    {
-        cvReleaseImage(&amp;imgResize);
-    }
-
-    return LATENT_SVM_OK;
-}
-
-static CvLSVMFeaturePyramid* createFeaturePyramidWithBorder(IplImage *image,
-                                                            int maxXBorder, int maxYBorder,
-                                                            int lambda, int num_cells, int num_bins)
-{
-    int opResult;
-    int bx, by;
-    int level;
-    CvLSVMFeaturePyramid *H;
-
-    // Obtaining feature pyramid
-    opResult = getFeaturePyramid(image, &amp;H, lambda, num_cells, num_bins);
-
-    if (opResult != LATENT_SVM_OK)
-    {
-        freeFeaturePyramidObject(&amp;H);
-        return NULL;
-    } /* if (opResult != LATENT_SVM_OK) */
-
-    // Addition nullable border for each feature map
-    // the size of the border for root filters
-    computeBorderSize(maxXBorder, maxYBorder, &amp;bx, &amp;by);
-    for (level = 0; level &lt; H-&gt;numLevels; level++)
-    {
-        addNullableBorder(H-&gt;pyramid[level], bx, by);
-    }
-    return H;
-}
-
-static CvSeq* cvLatentSvmDetectObjects(IplImage* image,
-                                       CvLatentSvmDetector* detector,
-                                       CvMemStorage* storage,
-                                       float overlap_threshold, int numThreads,
-                                       double score_threshold,
-                                       int lambda,
-                                       int num_cells,
-                                       int num_bins)
-{
-    CvLSVMFeaturePyramid *H = 0;
-    CvPoint *points = 0, *oppPoints = 0;
-    int kPoints = 0;
-    float *score = 0;
-    unsigned int maxXBorder = 0, maxYBorder = 0;
-    int numBoxesOut = 0;
-    CvPoint *pointsOut = 0;
-    CvPoint *oppPointsOut = 0;
-    float *scoreOut = 0;
-    CvSeq* result_seq = 0;
-    int error = 0;
-
-    if(image-&gt;nChannels == 3)
-        cvCvtColor(image, image, CV_BGR2RGB);
-
-    // Getting maximum filter dimensions
-    getMaxFilterDims((const CvLSVMFilterObject**)(detector-&gt;filters), detector-&gt;num_components,
-                     detector-&gt;num_part_filters, &amp;maxXBorder, &amp;maxYBorder);
-    // Create feature pyramid with nullable border
-    H = createFeaturePyramidWithBorder(image, maxXBorder, maxYBorder, lambda, num_cells, num_bins);
-    
-    // Search object
-    error = searchObjectThresholdSomeComponents(H, (const CvLSVMFilterObject**)(detector-&gt;filters),
-        detector-&gt;num_components, detector-&gt;num_part_filters, detector-&gt;b, score_threshold,
-        &amp;points, &amp;oppPoints, &amp;score, &amp;kPoints, numThreads);
-    if (error != LATENT_SVM_OK)
-    {
-        return NULL;
-    }
-    // Clipping boxes
-    clippingBoxes(image-&gt;width, image-&gt;height, points, kPoints);
-    clippingBoxes(image-&gt;width, image-&gt;height, oppPoints, kPoints);
-    // NMS procedure
-    nonMaximumSuppression(kPoints, points, oppPoints, score, overlap_threshold,
-                &amp;numBoxesOut, &amp;pointsOut, &amp;oppPointsOut, &amp;scoreOut);
-
-    result_seq = cvCreateSeq( 0, sizeof(CvSeq), sizeof(CvObjectDetection), storage );
-
-    for (int i = 0; i &lt; numBoxesOut; i++)
-    {
-        CvObjectDetection detection = {{0, 0, 0, 0}, 0};
-        detection.score = scoreOut[i];
-        CvRect bounding_box = {0, 0, 0, 0};
-        bounding_box.x = pointsOut[i].x;
-        bounding_box.y = pointsOut[i].y;
-        bounding_box.width = oppPointsOut[i].x - pointsOut[i].x;
-        bounding_box.height = oppPointsOut[i].y - pointsOut[i].y;
-        detection.rect = bounding_box;
-        cvSeqPush(result_seq, &amp;detection);
-    }
-
-    if(image-&gt;nChannels == 3)
-        cvCvtColor(image, image, CV_RGB2BGR);
-
-    freeFeaturePyramidObject(&amp;H);
-    free(points);
-    free(oppPoints);
-    free(score);
-    free(scoreOut);
-
-    return result_seq;
-}
-
-DPMOCVCPULatentSvmDetector::DPMOCVCPULatentSvmDetector(const std::vector&lt;std::string&gt;&amp; filenames)
-{
-    for( size_t i = 0; i &lt; filenames.size(); i++ )
-    {
-        const std::string filename = filenames[i];
-        if( filename.length() &lt; 5 || filename.substr(filename.length()-4, 4) != ".xml" )
-            continue;
-
-        CvLatentSvmDetector* detector = cvLoadLatentSvmDetector( filename.c_str() );
-        if( detector )
-        {
-            detectors.push_back( detector );
-        }
-    }
-}
-
-bool DPMOCVCPULatentSvmDetector::empty() const
-{
-    return detectors.empty();
-}
-
-void DPMOCVCPULatentSvmDetector::detect( const cv::Mat&amp; image,
-                                         std::vector&lt;ObjectDetection&gt;&amp; objectDetections,
-                                         float overlapThreshold,
-                                         int numThreads,
-                                         double score_threshold,
-                                         int lambda,
-                                         int num_cells,
-                                         int num_bins)
-{
-    objectDetections.clear();
-    if( numThreads &lt;= 0 )
-        numThreads = 1;
-
-    for( size_t classID = 0; classID &lt; detectors.size(); classID++ )
-    {
-        IplImage image_ipl = image;
-        CvMemStorage* storage = cvCreateMemStorage(0);
-        CvSeq* detections = cvLatentSvmDetectObjects( &amp;image_ipl,
-                                                      detectors[classID],
-                                                      storage,
-                                                      overlapThreshold,
-                                                      numThreads,
-                                                      score_threshold,
-                                                      lambda,
-                                                      num_cells,
-                                                      num_bins );
-
-        // convert results
-        objectDetections.reserve( objectDetections.size() + detections-&gt;total );
-        for( int detectionIdx = 0; detectionIdx &lt; detections-&gt;total; detectionIdx++ )
-        {
-            CvObjectDetection detection = *(CvObjectDetection*)cvGetSeqElem( detections, detectionIdx );
-            objectDetections.push_back( ObjectDetection(cv::Rect(detection.rect), detection.score, (int)classID) );
-        }
-
-        cvReleaseMemStorage( &amp;storage );
-    }
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\cuda_check.h" new_path="" added_lines="0" deleted_lines="20">
				<diff>@@ -1,20 +0,0 @@
-#ifndef _CUDA_CHECK_H_
-#define _CUDA_CHECK_H_
-
-#include &lt;cstdio&gt;
-#include &lt;cstdlib&gt;
-#include &lt;cuda.h&gt;
-#include "drvapi_error_string.h"
-
-/* error handling macro */
-#define CUDA_CHECK(res, fmt, ...)							\
-do {											\
-	if ((res) != CUDA_SUCCESS) {							\
-		printf("[%s:%s:%d] Failed: %s\n" fmt "\n",				\
-		       __FILE__, __func__, __LINE__, getCudaDrvErrorString((res)),	\
-		       ##__VA_ARGS__);							\
-		std::exit(1);								\
-	}										\
-} while(0)
-
-#endif // _CUDA_CHECK_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\dpm_ocv_gpu.cpp" new_path="" added_lines="0" deleted_lines="474">
				<diff>@@ -1,474 +0,0 @@
-#include &lt;opencv2/opencv.hpp&gt;
-#include &lt;opencv2/core/core.hpp&gt;
-#include &lt;opencv2/objdetect/objdetect.hpp&gt;
-
-#include "for_use_gpu.h"
-#include "resizeimg_gpu.h"
-#include "featurepyramid_gpu.hpp"
-#include "matching_gpu.hpp"
-#include "routine_gpu.hpp"
-
-#include &lt;libdpm_ocv/dpm_ocv.hpp&gt;
-
-// OpenCV non public functions
-extern int freeFeatureMapObject(CvLSVMFeatureMap **obj);
-extern IplImage * resize_opencv(IplImage * img, float scale);
-extern int computeBorderSize(int maxXBorder, int maxYBorder, int *bx, int *by);
-extern int addNullableBorder(CvLSVMFeatureMap *map, int bx, int by);
-
-extern "C" {
-extern int allocFeaturePyramidObject(CvLSVMFeaturePyramid **obj, const int countLevel);
-extern int freeFeaturePyramidObject(CvLSVMFeaturePyramid **obj);
-extern int getMaxFilterDims(const CvLSVMFilterObject **filters, int kComponents,
-                            const int *kPartFilters,
-                            unsigned int *maxXBorder, unsigned int *maxYBorder);
-extern int clippingBoxes(int width, int height,
-                         CvPoint *points, int kPoints);
-extern int nonMaximumSuppression(int numBoxes, const CvPoint *points,
-                                 const CvPoint *oppositePoints, const float *score,
-                                 float overlapThreshold,
-                                 int *numBoxesOut, CvPoint **pointsOut,
-                                 CvPoint **oppositePointsOut, float **scoreOut);
-extern int loadModel(const char *modelPath, CvLSVMFilterObject ***filters,
-        int *kFilters, int *kComponents, int **kPartFilters, float **b,
-        float *scoreThreshold);
-};
-
-// Original global variables
-int Lambda = LAMBDA;
-int Side_Length = SIDE_LENGTH;
-float Val_Of_Truncate = VAL_OF_TRUNCATE;
-
-static int convertPoints(int /*countLevel*/, int lambda, int initialImageLevel,
-        CvPoint *points, int *levels, CvPoint **partsDisplacement, int kPoints,
-        int n, int maxXBorder, int maxYBorder)
-{
-    int i, j, bx, by;
-    float step, scale;
-    step = powf(2.0f, 1.0f / ((float) lambda));
-
-    computeBorderSize(maxXBorder, maxYBorder, &amp;bx, &amp;by);
-
-    for (i = 0; i &lt; kPoints; i++)
-    {
-        // scaling factor for root filter
-        scale = Side_Length
-                * powf(step, (float) (levels[i] - initialImageLevel));
-        points[i].x = (int) ((points[i].x - bx + 1) * scale);
-        points[i].y = (int) ((points[i].y - by + 1) * scale);
-
-        // scaling factor for part filters
-        scale = Side_Length
-                * powf(step, (float) (levels[i] - lambda - initialImageLevel));
-        for (j = 0; j &lt; n; j++)
-        {
-            partsDisplacement[i][j].x = (int) ((partsDisplacement[i][j].x
-                    - 2 * bx + 1) * scale);
-            partsDisplacement[i][j].y = (int) ((partsDisplacement[i][j].y
-                    - 2 * by + 1) * scale);
-        }
-    }
-    return LATENT_SVM_OK;
-}
-
-/*
- // load trained detector from a file
- //
- // API
- // CvLatentSvmDetector* cvLoadLatentSvmDetector(const char* filename);
- // INPUT
- // filename             - path to the file containing the parameters of
- //                      - trained Latent SVM detector
- // OUTPUT
- // trained Latent SVM detector in internal representation
- */
-static CvLatentSvmDetector* cvLoadLatentSvmDetector(const char* filename,
-        const float scoreThreshold)
-{
-    CvLatentSvmDetector* detector = 0;
-    CvLSVMFilterObject** filters = 0;
-    int kFilters = 0;
-    int kComponents = 0;
-    int* kPartFilters = 0;
-    float* b = 0;
-    float modelsScoreThreshold = 0.f;
-    int err_code = 0;
-
-#ifdef PROFILE
-    TickMeter tm;
-    tm.start();
-    cout &lt;&lt; "Loading model START" &lt;&lt; endl;
-#endif
-    err_code = loadModel(filename, &amp;filters, &amp;kFilters, &amp;kComponents,
-            &amp;kPartFilters, &amp;b, &amp;modelsScoreThreshold);
-#ifdef PROFILE
-    tm.stop();
-    cout &lt;&lt; "Loading model time = " &lt;&lt; tm.getTimeSec() &lt;&lt; " sec" &lt;&lt; endl;
-#endif
-    if (err_code != LATENT_SVM_OK)
-        return 0;
-
-    detector = (CvLatentSvmDetector*) malloc(sizeof(CvLatentSvmDetector));
-    detector-&gt;filters = filters;
-    detector-&gt;b = b;
-    detector-&gt;num_components = kComponents;
-    detector-&gt;num_filters = kFilters;
-    detector-&gt;num_part_filters = kPartFilters;
-    detector-&gt;score_threshold = modelsScoreThreshold;
-    if (scoreThreshold != 0.0f)
-    {
-        detector-&gt;score_threshold = scoreThreshold;
-    }
-
-    return detector;
-}
-
-static std::string extractModelName(const std::string&amp; filename)
-{
-    size_t startPos = filename.rfind('/');
-    if (startPos == std::string::npos)
-        startPos = filename.rfind('\\');
-
-    if (startPos == std::string::npos)
-        startPos = 0;
-    else
-        startPos++;
-
-    const int extentionSize = 4; //.xml
-
-    int substrLength = (int) (filename.size() - startPos - extentionSize);
-
-    return filename.substr(startPos, substrLength);
-}
-
-
-bool DPMOCVGPULatentSvmDetector::load(const std::vector&lt;std::string&gt;&amp; filenames, const float test_t)
-{
-    clear();
-
-    for (size_t i = 0; i &lt; filenames.size(); i++)
-    {
-        const std::string filename = filenames[i];
-        if (filename.length() &lt; 5
-                || filename.substr(filename.length() - 4, 4) != ".xml")
-            continue;
-
-        CvLatentSvmDetector* detector = cvLoadLatentSvmDetector(
-                filename.c_str(), test_t);
-        if (detector)
-        {
-            detectors.push_back(detector);
-            classNames.push_back(extractModelName(filenames[i]));
-        }
-    }
-
-    return !empty();
-}
-
-DPMOCVGPULatentSvmDetector::DPMOCVGPULatentSvmDetector(const std::vector&lt;std::string&gt;&amp; filenames,
-        const float scoreThreshold)
-{
-    load(filenames, scoreThreshold);
-    init_cuda();
-}
-
-DPMOCVGPULatentSvmDetector::~DPMOCVGPULatentSvmDetector()
-{
-    clear();
-    clean_cuda();
-}
-
-bool DPMOCVGPULatentSvmDetector::empty() const
-{
-    return detectors.empty();
-}
-
-static CvLSVMFeaturePyramid* createFeaturePyramidWithBorder(IplImage *image,
-    int maxXBorder, int maxYBorder)
-{
-    int opResult;
-    int bx, by;
-    CvLSVMFeaturePyramid *H;
-
-    // the size of the border for root filters
-    computeBorderSize(maxXBorder, maxYBorder, &amp;bx, &amp;by);
-
-    // Obtaining feature pyramid
-    opResult = getFeaturePyramid(image, &amp;H, bx, by);
-
-    if (opResult != LATENT_SVM_OK)
-    {
-        freeFeaturePyramidObject(&amp;H);
-        return NULL;
-    } /* if (opResult != LATENT_SVM_OK) */
-
-    return H;
-}
-
-static int searchObjectThreshold(const CvLSVMFeaturePyramid *H,
-    const CvLSVMFilterObject **all_F, int n, float b,
-    CvLSVMFeatureMap *map[], int maxXBorder, int maxYBorder,
-    float scoreThreshold, CvPoint **points, int **levels, int *kPoints,
-    float **score, CvPoint ***partsDisplacement, int numThreads)
-{
-    int opResult;
-
-    opResult = thresholdFunctionalScore(all_F, n, H, b, map, scoreThreshold,
-            score, points, levels, kPoints, partsDisplacement);
-
-    (void) numThreads;
-
-    if (opResult != LATENT_SVM_OK)
-    {
-        return LATENT_SVM_SEARCH_OBJECT_FAILED;
-    }
-
-    // Transformation filter displacement from the block space
-    // to the space of pixels at the initial image
-    // that settles at the level number Lambda
-    convertPoints(H-&gt;numLevels, Lambda, Lambda, (*points), (*levels),
-            (*partsDisplacement), (*kPoints), n, maxXBorder, maxYBorder);
-
-    return LATENT_SVM_OK;
-}
-
-static int getOppositePoint(CvPoint point, int sizeX, int sizeY, float step,
-    int degree, CvPoint *oppositePoint)
-{
-    float scale;
-    scale = Side_Length * powf(step, (float) degree);
-    oppositePoint-&gt;x = (int) (point.x + sizeX * scale);
-    oppositePoint-&gt;y = (int) (point.y + sizeY * scale);
-    return LATENT_SVM_OK;
-}
-
-static int estimateBoxes(CvPoint *points, int *levels, int kPoints, int sizeX,
-    int sizeY, CvPoint **oppositePoints)
-{
-    int i;
-    float step;
-
-    step = powf(2.0f, 1.0f / ((float) (Lambda)));
-
-    *oppositePoints = (CvPoint *) malloc(sizeof(CvPoint) * kPoints);
-    for (i = 0; i &lt; kPoints; i++)
-    {
-        getOppositePoint(points[i], sizeX, sizeY, step, levels[i] - Lambda,
-            &amp;((*oppositePoints)[i]));
-    }
-    return LATENT_SVM_OK;
-}
-
-static int searchObjectThresholdSomeComponents(const CvLSVMFeaturePyramid *H,
-    const CvLSVMFilterObject **filters, int kComponents,
-    const int *kPartFilters, const float *b, float scoreThreshold,
-    CvPoint **points, CvPoint **oppPoints, float **score, int *kPoints,
-    int numThreads)
-{
-    //int error = 0;
-    int i, j, s, f, componentIndex;
-    unsigned int maxXBorder, maxYBorder;
-    CvPoint **pointsArr, **oppPointsArr, ***partsDisplacementArr;
-    float **scoreArr;
-    int *kPointsArr, **levelsArr;
-
-    // Allocation memory
-    pointsArr = (CvPoint **) malloc(sizeof(CvPoint *) * kComponents);
-    oppPointsArr = (CvPoint **) malloc(sizeof(CvPoint *) * kComponents);
-    scoreArr = (float **) malloc(sizeof(float *) * kComponents);
-    kPointsArr = (int *) malloc(sizeof(int) * kComponents);
-    levelsArr = (int **) malloc(sizeof(int *) * kComponents);
-    partsDisplacementArr = (CvPoint ***) malloc(sizeof(CvPoint **) * kComponents);
-
-    // Getting maximum filter dimensions
-    getMaxFilterDims(filters, kComponents, kPartFilters, &amp;maxXBorder,
-            &amp;maxYBorder);
-
-    CvLSVMFeatureMap *map[H-&gt;numLevels - Lambda];
-
-    for (i = 0; i &lt; H-&gt;numLevels - Lambda; i++)
-    {
-        map[i] = featureMapBorderPartFilter(H-&gt;pyramid[i], maxXBorder,
-                                            maxYBorder);
-    }
-
-    componentIndex = 0;
-    *kPoints = 0;
-    // For each component perform searching
-    for (i = 0; i &lt; kComponents; i++)
-    {
-        int error = searchObjectThreshold(H, &amp;(filters[componentIndex]),
-                kPartFilters[i], b[i], map, maxXBorder, maxYBorder,
-                scoreThreshold, &amp;(pointsArr[i]), &amp;(levelsArr[i]),
-                &amp;(kPointsArr[i]), &amp;(scoreArr[i]), &amp;(partsDisplacementArr[i]),
-                numThreads);
-
-        if (error != LATENT_SVM_OK)
-        {
-            // Release allocated memory
-            free(pointsArr);
-            free(oppPointsArr);
-            free(scoreArr);
-            free(kPointsArr);
-            free(levelsArr);
-            free(partsDisplacementArr);
-            return LATENT_SVM_SEARCH_OBJECT_FAILED;
-        }
-
-        estimateBoxes(pointsArr[i], levelsArr[i], kPointsArr[i],
-                filters[componentIndex]-&gt;sizeX, filters[componentIndex]-&gt;sizeY,
-                &amp;(oppPointsArr[i]));
-        componentIndex += (kPartFilters[i] + 1);
-        *kPoints += kPointsArr[i];
-    }
-    for (i = 0; i &lt; H-&gt;numLevels - Lambda; i++)
-    {
-        freeFeatureMapObject(&amp;map[i]);
-    }
-    //freeFeatureMapObject(map);
-    *points = (CvPoint *) malloc(sizeof(CvPoint) * (*kPoints));
-    *oppPoints = (CvPoint *) malloc(sizeof(CvPoint) * (*kPoints));
-    *score = (float *) malloc(sizeof(float) * (*kPoints));
-    s = 0;
-    for (i = 0; i &lt; kComponents; i++)
-    {
-        f = s + kPointsArr[i];
-        for (j = s; j &lt; f; j++)
-        {
-            (*points)[j].x = pointsArr[i][j - s].x;
-            (*points)[j].y = pointsArr[i][j - s].y;
-            (*oppPoints)[j].x = oppPointsArr[i][j - s].x;
-            (*oppPoints)[j].y = oppPointsArr[i][j - s].y;
-            (*score)[j] = scoreArr[i][j - s];
-        }
-        s = f;
-    }
-
-    // Release allocated memory
-    for (i = 0; i &lt; kComponents; i++)
-    {
-        free(pointsArr[i]);
-        free(oppPointsArr[i]);
-        free(scoreArr[i]);
-        free(levelsArr[i]);
-        for (j = 0; j &lt; kPointsArr[i]; j++)
-        {
-            free(partsDisplacementArr[i][j]);
-        }
-        free(partsDisplacementArr[i]);
-    }
-    free(pointsArr);
-    free(oppPointsArr);
-    free(scoreArr);
-    free(kPointsArr);
-    free(levelsArr);
-    free(partsDisplacementArr);
-    return LATENT_SVM_OK;
-}
-
-static CvSeq* cvLatentSvmDetectObjectsGPU(IplImage* image, CvLatentSvmDetector* detector,
-    CvMemStorage* storage, float overlap_threshold, int numThreads)
-{
-    CvLSVMFeaturePyramid *H = 0;
-    CvPoint *points = 0, *oppPoints = 0;
-    int kPoints = 0;
-    float *score = 0;
-    unsigned int maxXBorder = 0, maxYBorder = 0;
-    int numBoxesOut = 0;
-    CvPoint *pointsOut = 0;
-    CvPoint *oppPointsOut = 0;
-    float *scoreOut = 0;
-    CvSeq* result_seq = 0;
-    int error = 0;
-
-    if (image-&gt;nChannels == 3)
-        cvCvtColor(image, image, CV_BGR2RGB);
-
-    // Getting maximum filter dimensions
-    getMaxFilterDims((const CvLSVMFilterObject**) (detector-&gt;filters),
-                detector-&gt;num_components, detector-&gt;num_part_filters, &amp;maxXBorder,
-                &amp;maxYBorder);
-    // Create feature pyramid with nullable border
-    H = createFeaturePyramidWithBorder(image, maxXBorder, maxYBorder);
-
-    error = searchObjectThresholdSomeComponents(H,
-                                            (const CvLSVMFilterObject**) (detector-&gt;filters),
-                                            detector-&gt;num_components, detector-&gt;num_part_filters, detector-&gt;b,
-                                            detector-&gt;score_threshold, &amp;points, &amp;oppPoints, &amp;score, &amp;kPoints,
-                                            numThreads);
-
-    if (error != LATENT_SVM_OK)
-    {
-        return NULL;
-    }
-    // Clipping boxes
-    clippingBoxes(image-&gt;width, image-&gt;height, points, kPoints);
-    clippingBoxes(image-&gt;width, image-&gt;height, oppPoints, kPoints);
-    // NMS procedure
-    nonMaximumSuppression(kPoints, points, oppPoints, score, overlap_threshold,
-                          &amp;numBoxesOut, &amp;pointsOut, &amp;oppPointsOut, &amp;scoreOut);
-
-    result_seq = cvCreateSeq(0, sizeof(CvSeq), sizeof(CvObjectDetection),
-                             storage);
-
-    for (int i = 0; i &lt; numBoxesOut; i++)
-    {
-        CvObjectDetection detection = {{ 0, 0, 0, 0 }, 0 };
-        detection.score = scoreOut[i];
-        CvRect bounding_box = { 0, 0, 0, 0 };
-        bounding_box.x = pointsOut[i].x;
-        bounding_box.y = pointsOut[i].y;
-        bounding_box.width = oppPointsOut[i].x - pointsOut[i].x;
-        bounding_box.height = oppPointsOut[i].y - pointsOut[i].y;
-        detection.rect = bounding_box;
-        cvSeqPush(result_seq, &amp;detection);
-    }
-
-    if (image-&gt;nChannels == 3)
-        cvCvtColor(image, image, CV_RGB2BGR);
-
-    freeFeaturePyramidObject(&amp;H);
-    free(points);
-    free(pointsOut);
-    free(oppPointsOut);
-    free(oppPoints);
-    free(score);
-    free(scoreOut);
-
-    return result_seq;
-}
-
-void DPMOCVGPULatentSvmDetector::detect(const cv::Mat&amp; image,
-        std::vector&lt;ObjectDetection&gt;&amp; objectDetections, float overlapThreshold,
-        int numThreads, const unsigned int lambda,
-        const unsigned int sideLength, const float valOfTruncate)
-{
-    Lambda = lambda;
-    Side_Length = sideLength;
-    Val_Of_Truncate = valOfTruncate;
-
-    objectDetections.clear();
-    if (numThreads &lt;= 0)
-        numThreads = 1;
-    for (size_t classID = 0; classID &lt; detectors.size(); classID++)
-    {
-        IplImage image_ipl = image;
-        CvMemStorage* storage = cvCreateMemStorage(0);
-        CvSeq* detections = cvLatentSvmDetectObjectsGPU(&amp;image_ipl,
-                detectors[classID], storage, overlapThreshold, numThreads);
-
-        // convert results
-        objectDetections.reserve(objectDetections.size() + detections-&gt;total);
-        for (int detectionIdx = 0; detectionIdx &lt; detections-&gt;total;
-                detectionIdx++)
-        {
-            CvObjectDetection detection = *(CvObjectDetection*) cvGetSeqElem(
-                    detections, detectionIdx);
-            objectDetections.push_back(
-                    ObjectDetection(cv::Rect(detection.rect), detection.score,
-                            (int) classID));
-        }
-
-        cvReleaseMemStorage(&amp;storage);
-    }
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\dpm_ocv_gpu.hpp" new_path="" added_lines="0" deleted_lines="28">
				<diff>@@ -1,28 +0,0 @@
-#ifndef _DPM_OCV_GPU_H_
-#define _DPM_OCV_GPU_H_
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;opencv2/objdetect/objdetect.hpp&gt;
-
-//class DPMOCVGPULatentSvmDetector : public cv::LatentSvmDetector {
-//private:
-//// this is private member in cv::LatentSvmDetector
-//    std::vector&lt;CvLatentSvmDetector*&gt; detectors;
-//    std::vector&lt;std::string&gt; classNames;
-//
-//public:
-//    explicit DPMOCVGPULatentSvmDetector(const std::vector&lt;std::string&gt;&amp; filenames,
-//        const float scoreThreshold, const std::vector&lt;std::string&gt;&amp; classNames);
-//    ~DPMOCVGPULatentSvmDetector();
-//
-//    bool load( const std::vector&lt;std::string&gt;&amp; filenames, const float scoreThreshold );
-//    void detect(const cv::Mat&amp; image,
-//        std::vector&lt;ObjectDetection&gt;&amp; objectDetections, float overlapThreshold,
-//        int numThreads, const unsigned int lambda,
-//        const unsigned int sideLength, const float valOfTruncate);
-//
-//    bool empty() const;
-//};
-
-#endif /* _DPM_OCV_GPU_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\drvapi_error_string.h" new_path="" added_lines="0" deleted_lines="331">
				<diff>@@ -1,331 +0,0 @@
-/*
- * Copyright 1993-2012 NVIDIA Corporation.  All rights reserved.
- *
- * Please refer to the NVIDIA end user license agreement (EULA) associated
- * with this source code for terms and conditions that govern your use of
- * this software. Any use, reproduction, disclosure, or distribution of
- * this software and related documentation outside the terms of the EULA
- * is strictly prohibited.
- *
- */
-
-#ifndef _DRVAPI_ERROR_STRING_H_
-#define _DRVAPI_ERROR_STRING_H_
-
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdlib.h&gt;
-
-// Error Code string definitions here
-typedef struct
-{
-    char const *error_string;
-    int error_id;
-} s_CudaErrorStr;
-
-/**
- * Error codes
- */
-static s_CudaErrorStr sCudaDrvErrorString[] =
-        {
-        /**
-         * The API call returned with no errors. In the case of query calls, this
-         * can also mean that the operation being queried is complete (see
-         * ::cuEventQuery() and ::cuStreamQuery()).
-         */
-        { "CUDA_SUCCESS", 0 },
-
-        /**
-         * This indicates that one or more of the parameters passed to the API call
-         * is not within an acceptable range of values.
-         */
-        { "CUDA_ERROR_INVALID_VALUE", 1 },
-
-        /**
-         * The API call failed because it was unable to allocate enough memory to
-         * perform the requested operation.
-         */
-        { "CUDA_ERROR_OUT_OF_MEMORY", 2 },
-
-        /**
-         * This indicates that the CUDA driver has not been initialized with
-         * ::cuInit() or that initialization has failed.
-         */
-        { "CUDA_ERROR_NOT_INITIALIZED", 3 },
-
-        /**
-         * This indicates that the CUDA driver is in the process of shutting down.
-         */
-        { "CUDA_ERROR_DEINITIALIZED", 4 },
-
-        /**
-         * This indicates profiling APIs are called while application is running
-         * in visual profiler mode.
-         */
-        { "CUDA_ERROR_PROFILER_DISABLED", 5 },
-        /**
-         * This indicates profiling has not been initialized for this context.
-         * Call cuProfilerInitialize() to resolve this.
-         */
-        { "CUDA_ERROR_PROFILER_NOT_INITIALIZED", 6 },
-        /**
-         * This indicates profiler has already been started and probably
-         * cuProfilerStart() is incorrectly called.
-         */
-        { "CUDA_ERROR_PROFILER_ALREADY_STARTED", 7 },
-        /**
-         * This indicates profiler has already been stopped and probably
-         * cuProfilerStop() is incorrectly called.
-         */
-        { "CUDA_ERROR_PROFILER_ALREADY_STOPPED", 8 },
-        /**
-         * This indicates that no CUDA-capable devices were detected by the installed
-         * CUDA driver.
-         */
-        { "CUDA_ERROR_NO_DEVICE (no CUDA-capable devices were detected)", 100 },
-
-                /**
-                 * This indicates that the device ordinal supplied by the user does not
-                 * correspond to a valid CUDA device.
-                 */
-                {
-                        "CUDA_ERROR_INVALID_DEVICE (device specified is not a valid CUDA device)",
-                        101 },
-
-                /**
-                 * This indicates that the device kernel image is invalid. This can also
-                 * indicate an invalid CUDA module.
-                 */
-                { "CUDA_ERROR_INVALID_IMAGE", 200 },
-
-                /**
-                 * This most frequently indicates that there is no context bound to the
-                 * current thread. This can also be returned if the context passed to an
-                 * API call is not a valid handle (such as a context that has had
-                 * ::cuCtxDestroy() invoked on it). This can also be returned if a user
-                 * mixes different API versions (i.e. 3010 context with 3020 API calls).
-                 * See ::cuCtxGetApiVersion() for more details.
-                 */
-                { "CUDA_ERROR_INVALID_CONTEXT", 201 },
-
-                /**
-                 * This indicated that the context being supplied as a parameter to the
-                 * API call was already the active context.
-                 * \deprecated
-                 * This error return is deprecated as of CUDA 3.2. It is no longer an
-                 * error to attempt to push the active context via ::cuCtxPushCurrent().
-                 */
-                { "CUDA_ERROR_CONTEXT_ALREADY_CURRENT", 202 },
-
-                /**
-                 * This indicates that a map or register operation has failed.
-                 */
-                { "CUDA_ERROR_MAP_FAILED", 205 },
-
-                /**
-                 * This indicates that an unmap or unregister operation has failed.
-                 */
-                { "CUDA_ERROR_UNMAP_FAILED", 206 },
-
-                /**
-                 * This indicates that the specified array is currently mapped and thus
-                 * cannot be destroyed.
-                 */
-                { "CUDA_ERROR_ARRAY_IS_MAPPED", 207 },
-
-                /**
-                 * This indicates that the resource is already mapped.
-                 */
-                { "CUDA_ERROR_ALREADY_MAPPED", 208 },
-
-                /**
-                 * This indicates that there is no kernel image available that is suitable
-                 * for the device. This can occur when a user specifies code generation
-                 * options for a particular CUDA source file that do not include the
-                 * corresponding device configuration.
-                 */
-                { "CUDA_ERROR_NO_BINARY_FOR_GPU", 209 },
-
-                /**
-                 * This indicates that a resource has already been acquired.
-                 */
-                { "CUDA_ERROR_ALREADY_ACQUIRED", 210 },
-
-                /**
-                 * This indicates that a resource is not mapped.
-                 */
-                { "CUDA_ERROR_NOT_MAPPED", 211 },
-
-                /**
-                 * This indicates that a mapped resource is not available for access as an
-                 * array.
-                 */
-                { "CUDA_ERROR_NOT_MAPPED_AS_ARRAY", 212 },
-
-                /**
-                 * This indicates that a mapped resource is not available for access as a
-                 * pointer.
-                 */
-                { "CUDA_ERROR_NOT_MAPPED_AS_POINTER", 213 },
-
-                /**
-                 * This indicates that an uncorrectable ECC error was detected during
-                 * execution.
-                 */
-                { "CUDA_ERROR_ECC_UNCORRECTABLE", 214 },
-
-                /**
-                 * This indicates that the ::CUlimit passed to the API call is not
-                 * supported by the active device.
-                 */
-                { "CUDA_ERROR_UNSUPPORTED_LIMIT", 215 },
-
-                /**
-                 * This indicates that the ::CUcontext passed to the API call can
-                 * only be bound to a single CPU thread at a time but is already
-                 * bound to a CPU thread.
-                 */
-                { "CUDA_ERROR_CONTEXT_ALREADY_IN_USE", 216 },
-
-                /**
-                 * This indicates that the device kernel source is invalid.
-                 */
-                { "CUDA_ERROR_INVALID_SOURCE", 300 },
-
-                /**
-                 * This indicates that the file specified was not found.
-                 */
-                { "CUDA_ERROR_FILE_NOT_FOUND", 301 },
-
-                /**
-                 * This indicates that a link to a shared object failed to resolve.
-                 */
-                { "CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND", 302 },
-
-                /**
-                 * This indicates that initialization of a shared object failed.
-                 */
-                { "CUDA_ERROR_SHARED_OBJECT_INIT_FAILED", 303 },
-
-                /**
-                 * This indicates that an OS call failed.
-                 */
-                { "CUDA_ERROR_OPERATING_SYSTEM", 304 },
-
-                /**
-                 * This indicates that a resource handle passed to the API call was not
-                 * valid. Resource handles are opaque types like ::CUstream and ::CUevent.
-                 */
-                { "CUDA_ERROR_INVALID_HANDLE", 400 },
-
-                /**
-                 * This indicates that a named symbol was not found. Examples of symbols
-                 * are global/constant variable names, texture names }, and surface names.
-                 */
-                { "CUDA_ERROR_NOT_FOUND", 500 },
-
-                /**
-                 * This indicates that asynchronous operations issued previously have not
-                 * completed yet. This result is not actually an error, but must be indicated
-                 * differently than ::CUDA_SUCCESS (which indicates completion). Calls that
-                 * may return this value include ::cuEventQuery() and ::cuStreamQuery().
-                 */
-                { "CUDA_ERROR_NOT_READY", 600 },
-
-                /**
-                 * An exception occurred on the device while executing a kernel. Common
-                 * causes include dereferencing an invalid device pointer and accessing
-                 * out of bounds shared memory. The context cannot be used }, so it must
-                 * be destroyed (and a new one should be created). All existing device
-                 * memory allocations from this context are invalid and must be
-                 * reconstructed if the program is to continue using CUDA.
-                 */
-                { "CUDA_ERROR_LAUNCH_FAILED", 700 },
-
-                /**
-                 * This indicates that a launch did not occur because it did not have
-                 * appropriate resources. This error usually indicates that the user has
-                 * attempted to pass too many arguments to the device kernel, or the
-                 * kernel launch specifies too many threads for the kernel's register
-                 * count. Passing arguments of the wrong size (i.e. a 64-bit pointer
-                 * when a 32-bit int is expected) is equivalent to passing too many
-                 * arguments and can also result in this error.
-                 */
-                { "CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES", 701 },
-
-                /**
-                 * This indicates that the device kernel took too long to execute. This can
-                 * only occur if timeouts are enabled - see the device attribute
-                 * ::CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT for more information. The
-                 * context cannot be used (and must be destroyed similar to
-                 * ::CUDA_ERROR_LAUNCH_FAILED). All existing device memory allocations from
-                 * this context are invalid and must be reconstructed if the program is to
-                 * continue using CUDA.
-                 */
-                { "CUDA_ERROR_LAUNCH_TIMEOUT", 702 },
-
-                /**
-                 * This error indicates a kernel launch that uses an incompatible texturing
-                 * mode.
-                 */
-                { "CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING", 703 },
-
-                /**
-                 * This error indicates that a call to ::cuCtxEnablePeerAccess() is
-                 * trying to re-enable peer access to a context which has already
-                 * had peer access to it enabled.
-                 */
-                { "CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED", 704 },
-
-                /**
-                 * This error indicates that ::cuCtxDisablePeerAccess() is
-                 * trying to disable peer access which has not been enabled yet
-                 * via ::cuCtxEnablePeerAccess().
-                 */
-                { "CUDA_ERROR_PEER_ACCESS_NOT_ENABLED", 705 },
-
-                /**
-                 * This error indicates that the primary context for the specified device
-                 * has already been initialized.
-                 */
-                { "CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE", 708 },
-
-                /**
-                 * This error indicates that the context current to the calling thread
-                 * has been destroyed using ::cuCtxDestroy }, or is a primary context which
-                 * has not yet been initialized.
-                 */
-                { "CUDA_ERROR_CONTEXT_IS_DESTROYED", 709 },
-
-                /**
-                 * A device-side assert triggered during kernel execution. The context
-                 * cannot be used anymore, and must be destroyed. All existing device
-                 * memory allocations from this context are invalid and must be
-                 * reconstructed if the program is to continue using CUDA.
-                 */
-                { "CUDA_ERROR_ASSERT", 710 },
-
-                /**
-                 * This indicates that an unknown internal error has occurred.
-                 */
-                { "CUDA_ERROR_UNKNOWN", 999 },
-                { NULL, -1 } };
-
-// This is just a linear search through the array, since the error_id's are not
-// always ocurring consecutively
-inline const char * getCudaDrvErrorString(CUresult error_id)
-{
-    int index = 0;
-    while (sCudaDrvErrorString[index].error_id != error_id
-            &amp;&amp; sCudaDrvErrorString[index].error_id != -1)
-    {
-        index++;
-    }
-
-    if (sCudaDrvErrorString[index].error_id == error_id)
-        return (const char *) sCudaDrvErrorString[index].error_string;
-    else
-        return (const char *) "CUDA_ERROR not found!";
-}
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\featurepyramid_gpu.cpp" new_path="" added_lines="0" deleted_lines="814">
				<diff>@@ -1,814 +0,0 @@
-#include &lt;cmath&gt;
-#include &lt;cuda.h&gt;
-#include &lt;unistd.h&gt;
-
-#include "featurepyramid_gpu.hpp"
-#include "for_use_gpu.h"
-#include "resizeimg_gpu.h"
-#include "cuda_check.h"
-#include "routine_gpu.hpp"
-
-extern int allocFeatureMapObject(CvLSVMFeatureMap **obj, const int sizeX, const int sizeY,
-                                const int p);
-extern "C" {
-extern int allocFeaturePyramidObject(CvLSVMFeaturePyramid **obj, const int numLevels);
-};
-
-/*
-// Launch GPU kernel of calculate histogram
-//
-// API
-//int calculateHistogramGPULaunch(const int k, CvLSVMFeatureMapGPU *dev_img,
-          CvLSVMFeatureMapGPU *dev_r, CvLSVMFeatureMapGPU *dev_alfa,
-          CUstream stream)
-// INPUT
-// k
-// dev_img
-// stream
-// OUTPUT
-// dev_r
-// dev_alfa
-// RESULT
-// Error status
-*/
-int calculateHistogramGPULaunch(const int k, CvLSVMFeatureMapGPU *dev_img,
-        CvLSVMFeatureMapGPU *dev_r, CvLSVMFeatureMapGPU *dev_alfa,
-        CUstream stream)
-{
-    int width, height, width_step, numChannels;
-    int thread_num_x, thread_num_y, thread_num_z;
-    int block_num_x, block_num_y, block_num_z;
-    int sharedMemBytes;
-
-    CUresult res;
-
-    width = dev_img-&gt;sizeX;
-    height = dev_img-&gt;sizeY;
-    numChannels = dev_img-&gt;numFeatures;
-    width_step = calculateWidthStep(width, numChannels, sizeof(float));
-
-    void *calc_hist_kernel_arg[] =
-    { (void *) &amp;dev_img-&gt;map, (void *) &amp;dev_r-&gt;map, (void *) &amp;dev_alfa-&gt;map,
-            (void *) &amp;width, (void *) &amp;height, (void *) &amp;width_step,
-            (void *) &amp;numChannels };
-
-    thread_num_x =
-            (width &lt; std::sqrt(max_threads_num)) ? width : std::sqrt(max_threads_num);
-    thread_num_y =
-            (height &lt; std::sqrt(max_threads_num)) ? height : std::sqrt(max_threads_num);
-    thread_num_z = 1;
-    block_num_x = width / thread_num_x;
-    block_num_y = height / thread_num_y;
-    block_num_z = 1;
-    if (width % thread_num_x != 0)
-        block_num_x++;
-    if (height % thread_num_y != 0)
-        block_num_y++;
-
-    sharedMemBytes = 0;
-
-    res = cuLaunchKernel(calculateHistogram_func[0], block_num_x, block_num_y,
-            block_num_z, thread_num_x, thread_num_y, thread_num_z,
-            sharedMemBytes, stream, calc_hist_kernel_arg, NULL);
-    CUDA_CHECK(res, "cuLaunchKernel(calculateHistogram)");
-
-    return LATENT_SVM_OK;
-}
-
-/*
-// Launch GPU kernel of get feature maps
-//
-// API
-//int getFeatureMapsGPULaunch(const int k, CvLSVMFeatureMapGPU *dev_r,
-          CvLSVMFeatureMapGPU *dev_alfa, CUdeviceptr *dev_nearest,
-          CUdeviceptr *dev_w, CvLSVMFeatureMapGPU *dev_map, CUstream stream)
-// INPUT
-// k
-// dev_r
-// dev_alfa
-// dev_nearest
-// dev_w
-// stream
-// OUTPUT
-// dev_map
-// RESULT
-// Error status
-*/
-int getFeatureMapsGPULaunch(const int k, CvLSVMFeatureMapGPU *dev_r,
-        CvLSVMFeatureMapGPU *dev_alfa, CUdeviceptr *dev_nearest,
-        CUdeviceptr *dev_w, CvLSVMFeatureMapGPU *dev_map, CUstream stream)
-{
-    int sizeX, sizeY;
-
-    int p, width, height;
-    int thread_num_x, thread_num_y, thread_num_z;
-    int block_num_x, block_num_y, block_num_z;
-    int sharedMemBytes;
-
-    CUresult res;
-
-    p = 3 * NUM_SECTOR;
-    width  = dev_r-&gt;sizeX;
-    height = dev_r-&gt;sizeY;
-    sizeX = dev_map-&gt;sizeX;
-    sizeY = dev_map-&gt;sizeY;
-
-    void *get_feature_maps_kernel_arg[] =
-    { (void *) &amp;dev_r-&gt;map, (void *) &amp;dev_alfa-&gt;map, (void *) dev_nearest,
-            (void *) dev_w, (void *) &amp;dev_map-&gt;map, (void *) &amp;width,
-            (void *) &amp;height, (void *) &amp;k, (void *) &amp;p };
-
-    thread_num_x =
-            (sizeX &lt; std::sqrt(max_threads_num)) ? sizeX : std::sqrt(max_threads_num);
-    thread_num_y =
-            (sizeY &lt; std::sqrt(max_threads_num)) ? sizeY : std::sqrt(max_threads_num);
-    thread_num_z = 1;
-    block_num_x = sizeX / thread_num_x;
-    block_num_y = sizeY / thread_num_y;
-    block_num_z = k * k;
-    if (sizeX % thread_num_x != 0)
-        block_num_x++;
-    if (sizeY % thread_num_y != 0)
-        block_num_y++;
-
-    sharedMemBytes = 0;
-
-    res = cuLaunchKernel(getFeatureMaps_func[0], block_num_x, block_num_y,
-            block_num_z, thread_num_x, thread_num_y, thread_num_z,
-            sharedMemBytes, stream, get_feature_maps_kernel_arg, NULL);
-    CUDA_CHECK(res, "cuLaunchKernel(getFeatureMaps)");
-
-    return LATENT_SVM_OK;
-}
-
-/*
-// Launch GPU kernel of calculate norm
-//
-// API
-//int calculateNormGPULaunch(CvLSVMFeatureMapGPU *dev_map_in,
-          CvLSVMFeatureMapGPU *dev_norm, CUstream stream)
-// INPUT
-// dev_map_in
-// stream
-// OUTPUT
-// dev_norm
-// RESULT
-// Error status
-*/
-int calculateNormGPULaunch(CvLSVMFeatureMapGPU *dev_map_in,
-        CvLSVMFeatureMapGPU *dev_norm, CUstream stream)
-{
-    int sizeX, sizeY, xp;
-    int thread_num_x, thread_num_y, thread_num_z;
-    int block_num_x, block_num_y, block_num_z;
-    int sharedMemBytes;
-    CUresult res;
-
-    sizeX = dev_map_in-&gt;sizeX;
-    sizeY = dev_map_in-&gt;sizeY;
-    xp = dev_map_in-&gt;numFeatures;
-
-    void *calc_norm_kernel_arg[] =
-    { (void *) &amp;dev_map_in-&gt;map, (void *) &amp;dev_norm-&gt;map, (void *) &amp;sizeX,
-            (void *) &amp;sizeY, (void *) &amp;xp, };
-
-    thread_num_x =
-            (sizeX &lt; std::sqrt(max_threads_num)) ? sizeX : std::sqrt(max_threads_num);
-    thread_num_y =
-            (sizeY &lt; std::sqrt(max_threads_num)) ? sizeY : std::sqrt(max_threads_num);
-    thread_num_z = 1;
-    block_num_x = sizeX / thread_num_x;
-    block_num_y = sizeY / thread_num_y;
-    block_num_z = 1;
-    if (sizeX % thread_num_x != 0)
-        block_num_x++;
-    if (sizeY % thread_num_y != 0)
-        block_num_y++;
-
-    sharedMemBytes = 0;
-
-    res = cuLaunchKernel(calculateNorm_func[0], block_num_x, block_num_y,
-            block_num_z, thread_num_x, thread_num_y, thread_num_z,
-            sharedMemBytes, stream, calc_norm_kernel_arg, NULL);
-    CUDA_CHECK(res, "cuLaunchKernel(calcuateNorm)");
-
-    return LATENT_SVM_OK;
-}
-
-/*
-// Launch GPU kernel of normalize
-//
-// API
-// int normalizeGPULaunch(const int alfa, CvLSVMFeatureMapGPU *dev_map_in,
-           CvLSVMFeatureMapGPU *dev_norm, CvLSVMFeatureMapGPU *dev_map_out,
-           CUstream stream);
-// INPUT
-// alfa
-// dev_map_in
-// dev_norm
-// stream
-// OUTPUT
-// dev_map_out
-// RESULT
-// Error status
-*/
-int normalizeGPULaunch(const float alfa, CvLSVMFeatureMapGPU *dev_map_in,
-        CvLSVMFeatureMapGPU *dev_norm, CvLSVMFeatureMapGPU *dev_map_out,
-        CUstream stream)
-{
-    int sizeX, sizeY;
-    int thread_num_x, thread_num_y, thread_num_z;
-    int block_num_x, block_num_y, block_num_z;
-    int sharedMemBytes;
-    CUresult res;
-
-    sizeX = dev_map_in-&gt;sizeX;
-    sizeY = dev_map_in-&gt;sizeY;
-
-    void *normalize_kernel_arg[] =
-    { (void *) &amp;dev_map_in-&gt;map, (void *) &amp;dev_norm-&gt;map,
-            (void *) &amp;dev_map_out-&gt;map, (void *) &amp;sizeX, (void *) &amp;sizeY,
-            (void *) &amp;alfa, };
-
-    thread_num_x =
-            (sizeX &lt; std::sqrt(max_threads_num)) ? sizeX : std::sqrt(max_threads_num);
-    thread_num_y =
-            (sizeY &lt; std::sqrt(max_threads_num)) ? sizeY : std::sqrt(max_threads_num);
-    thread_num_z = 1;
-    block_num_x = sizeX / thread_num_x;
-    block_num_y = sizeY / thread_num_y;
-    block_num_z = NUM_SECTOR * 2;
-    if (sizeX % thread_num_x != 0)
-        block_num_x++;
-    if (sizeY % thread_num_y != 0)
-        block_num_y++;
-
-    sharedMemBytes = 0;
-
-    res = cuLaunchKernel(normalizeAndTruncate_func[0], block_num_x, block_num_y,
-            block_num_z, thread_num_x, thread_num_y, thread_num_z,
-            sharedMemBytes, stream, normalize_kernel_arg, NULL);
-    CUDA_CHECK(res, "cuLaunchKernel(normalizeAndTruncate)");
-
-    return LATENT_SVM_OK;
-}
-
-/*
-// Launch GPU kernel of PCA feature maps
-//
-// API
-// int PCAFeatureMapsAddNullableBorderGPULaunch(CvLSVMFeatureMapGPU *dev_map_in,
-           CvLSVMFeatureMapGPU *dev_map_out, const int bx, const int by,
-           CUstream stream);
-// INPUT
-// dev_map_in
-// bx
-// by
-// stream
-// OUTPUT
-// dev_map_out
-// RESULT
-// Error status
-*/
-int PCAFeatureMapsAddNullableBorderGPULaunch(CvLSVMFeatureMapGPU *dev_map_in,
-        CvLSVMFeatureMapGPU *dev_map_out, const int bx, const int by,
-        CUstream stream)
-{
-    int sizeX, sizeY, p;
-    int thread_num_x, thread_num_y, thread_num_z;
-    int block_num_x, block_num_y, block_num_z;
-    int sharedMemBytes;
-    CUresult res;
-
-    sizeX = dev_map_in-&gt;sizeX;
-    sizeY = dev_map_in-&gt;sizeY;
-    p = dev_map_in-&gt;numFeatures;
-
-    void *pca_kernel_arg[] =
-    { (void *) &amp;dev_map_in-&gt;map, (void *) &amp;dev_map_out-&gt;map, (void *) &amp;sizeX,
-            (void *) &amp;sizeY, (void *) &amp;p, (void *) &amp;bx, (void *) &amp;by };
-
-    thread_num_x =
-            (sizeX &lt; std::sqrt(max_threads_num)) ? sizeX : std::sqrt(max_threads_num);
-    thread_num_y =
-            (sizeY &lt; std::sqrt(max_threads_num)) ? sizeY : std::sqrt(max_threads_num);
-    thread_num_z = 1;
-    block_num_x = sizeX / thread_num_x;
-    block_num_y = sizeY / thread_num_y;
-    block_num_z = 1;
-    if (sizeX % thread_num_x != 0)
-        block_num_x++;
-    if (sizeY % thread_num_y != 0)
-        block_num_y++;
-
-    sharedMemBytes = 0;
-
-    res = cuLaunchKernel(PCAFeatureMapsAddNullableBorder_func[0], block_num_x,
-            block_num_y, block_num_z, thread_num_x, thread_num_y, thread_num_z,
-            sharedMemBytes, stream, pca_kernel_arg, NULL);
-    CUDA_CHECK(res, "cuLaunchKernel(PCAFeatureMaps)");
-
-    return LATENT_SVM_OK;
-}
-
-
-/*
-// Getting feature map for the selected subimage in GPU
-//
-// API
-//int getFeatureMapsGPUStream(const int numStep, const int k,
-          CvLSVMFeatureMapGPU **devs_img, CvLSVMFeatureMapGPU **devs_map,
-          CUstream *streams)
-// INPUT
-// numStep
-// k
-// devs_img
-// streams
-// OUTPUT
-// devs_map
-// RESULT
-// Error status
-*/
-int getFeatureMapsGPUStream(const int numStep, const int k,
-        CvLSVMFeatureMapGPU **devs_img, CvLSVMFeatureMapGPU **devs_map,
-        CUstream *streams)
-{
-    int sizeX, sizeY;
-    int p, px;
-    int height, width;
-    int i, j;
-
-    int *nearest;
-    float *w, a_x, b_x;
-
-    int size_r, size_alfa, size_nearest, size_w, size_map;
-
-    CUresult res;
-    CvLSVMFeatureMapGPU **devs_r, **devs_alfa;
-    CUdeviceptr dev_nearest, dev_w;
-
-    px = 3 * NUM_SECTOR;
-    p = px;
-
-    size_nearest = k;
-    size_w = k * 2;
-
-    devs_r = (CvLSVMFeatureMapGPU **) malloc(
-            sizeof(CvLSVMFeatureMapGPU*) * numStep);
-    devs_alfa = (CvLSVMFeatureMapGPU **) malloc(
-            sizeof(CvLSVMFeatureMapGPU*) * numStep);
-    nearest = (int *) malloc(sizeof(int) * size_nearest);
-    w = (float *) malloc(sizeof(float) * size_w);
-
-    // initialize "nearest" and "w"
-    for (i = 0; i &lt; k / 2; i++)
-    {
-        nearest[i] = -1;
-    }/*for(i = 0; i &lt; k / 2; i++)*/
-    for (i = k / 2; i &lt; k; i++)
-    {
-        nearest[i] = 1;
-    }/*for(i = k / 2; i &lt; k; i++)*/
-
-    for (j = 0; j &lt; k / 2; j++)
-    {
-        b_x = k / 2 + j + 0.5f;
-        a_x = k / 2 - j - 0.5f;
-        w[j * 2] = 1.0f / a_x * ((a_x * b_x) / (a_x + b_x));
-        w[j * 2 + 1] = 1.0f / b_x * ((a_x * b_x) / (a_x + b_x));
-    }/*for(j = 0; j &lt; k / 2; j++)*/
-    for (j = k / 2; j &lt; k; j++)
-    {
-        a_x = j - k / 2 + 0.5f;
-        b_x = -j + k / 2 - 0.5f + k;
-        w[j * 2] = 1.0f / a_x * ((a_x * b_x) / (a_x + b_x));
-        w[j * 2 + 1] = 1.0f / b_x * ((a_x * b_x) / (a_x + b_x));
-    }/*for(j = k / 2; j &lt; k; j++)*/
-
-    res = cuMemAlloc(&amp;dev_nearest, sizeof(int) * size_nearest);
-    CUDA_CHECK(res, "cuMemAlloc(dev_nearest): %zd bytes", sizeof(int) * size_nearest);
-    res = cuMemAlloc(&amp;dev_w, sizeof(float) * size_w);
-    CUDA_CHECK(res, "cuMemAlloc(dev_w): %zd bytes", sizeof(float) * size_w);
-
-    res = cuMemcpyHtoDAsync(dev_nearest, nearest, sizeof(int) * size_nearest,
-            streams[numStep - 1]);
-    CUDA_CHECK(res, "cuMemcpyHtoDAsync(dev_nearest, nearest, %zd bytes)", sizeof(int) * size_nearest);
-    res = cuMemcpyHtoDAsync(dev_w, w, sizeof(float) * size_w,
-            streams[numStep - 1]);
-    CUDA_CHECK(res, "cuMemcpyHtoDAsync(dev_w, w, %zd bytes)", sizeof(float) * size_w);
-
-    // allocate device memory
-    for (i = 0; i &lt; numStep; i++)
-    {
-        width = devs_img[i]-&gt;sizeX;
-        height = devs_img[i]-&gt;sizeY;
-
-        allocFeatureMapObjectGPU&lt;float&gt;(&amp;devs_r[i], width, height, 1);
-        allocFeatureMapObjectGPU&lt;int&gt;(&amp;devs_alfa[i], width, height, 2);
-    }
-
-    // excute async
-    for (i = 0; i &lt; numStep; i++)
-    {
-        // initialize "map", "r" and "alfa"
-        width = devs_img[i]-&gt;sizeX;
-        height = devs_img[i]-&gt;sizeY;
-        sizeX = width / k;
-        sizeY = height / k;
-        size_map = sizeX * sizeY * p;
-        size_r = width * height;
-        size_alfa = width * height * 2;
-
-        // initilize device memory value of 0
-        res = cuMemsetD32Async(devs_map[i]-&gt;map, 0, size_map, streams[i]);
-        CUDA_CHECK(res, "cuMemset(dev_map[%d]-&gt;map)", i);
-        res = cuMemsetD32Async(devs_r[i]-&gt;map, 0, size_r, streams[i]);
-        CUDA_CHECK(res, "cuMemset(dev_r[%d]-&gt;map)", i);
-        res = cuMemsetD32Async(devs_alfa[i]-&gt;map, 0, size_alfa, streams[i]);
-        CUDA_CHECK(res, "cuMemset(dev_alfa[%d]-&gt;map)", i);
-
-        // launch kernel
-        calculateHistogramGPULaunch(k, devs_img[i], devs_r[i], devs_alfa[i],
-                streams[i]);
-    }
-
-    for (i = 0; i &lt; numStep; i++)
-    {
-        getFeatureMapsGPULaunch(k, devs_r[i], devs_alfa[i], &amp;dev_nearest,
-                &amp;dev_w, devs_map[i], streams[i]);
-    }
-
-    // free device memory
-    res = cuMemFree(dev_nearest);
-    CUDA_CHECK(res, "cuMemFree(dev_nearest)");
-    res = cuMemFree(dev_w);
-    CUDA_CHECK(res, "cuMemFree(dev_w)");
-
-    for (i = 0; i &lt; numStep; i++)
-    {
-        freeFeatureMapObjectGPU(&amp;devs_r[i]);
-        freeFeatureMapObjectGPU(&amp;devs_alfa[i]);
-    }
-
-    free(nearest);
-    free(w);
-    free(devs_r);
-    free(devs_alfa);
-
-    return LATENT_SVM_OK;
-}
-
-/*
-// Feature map Normalization and Truncation in GPU
-//
-// API
-//int normalizeAndTruncateGPUStream(const int numStep, const float alfa,
-          CvLSVMFeatureMapGPU **devs_map_in, CvLSVMFeatureMapGPU **devs_map_out,
-          CUstream *streams)
-// INPUT
-// numStep
-// alfa
-// devs_map_in
-// streams
-// OUTPUT
-// devs_map_out
-// RESULT
-// Error status
-*/
-int normalizeAndTruncateGPUStream(const int numStep, const float alfa,
-        CvLSVMFeatureMapGPU **devs_map_in, CvLSVMFeatureMapGPU **devs_map_out,
-        CUstream *streams)
-{
-
-    int sizeX, sizeY, newSizeX, newSizeY, pp;
-    int size_norm, size_map_out;
-    int i;
-    CUresult res;
-    CvLSVMFeatureMapGPU **devs_norm;
-
-    pp = NUM_SECTOR * 12;
-
-    devs_norm = (CvLSVMFeatureMapGPU **) malloc(
-            sizeof(CvLSVMFeatureMapGPU*) * (numStep));
-
-    // allocate device memory
-    for (i = 0; i &lt; numStep; i++)
-    {
-        sizeX = devs_map_in[i]-&gt;sizeX;
-        sizeY = devs_map_in[i]-&gt;sizeY;
-        newSizeX = sizeX - 2;
-        newSizeY = sizeY - 2;
-
-        allocFeatureMapObjectGPU&lt;float&gt;(&amp;devs_norm[i], sizeX, sizeY, 1);
-    }
-
-    // exucute async
-    for (i = 0; i &lt; numStep; i++)
-    {
-        sizeX = devs_map_in[i]-&gt;sizeX;
-        sizeY = devs_map_in[i]-&gt;sizeY;
-        newSizeX = sizeX - 2;
-        newSizeY = sizeY - 2;
-        size_norm = sizeX * sizeY;
-        size_map_out = newSizeX * newSizeY * pp;
-
-        // initilize device memory value of 0
-        res = cuMemsetD32Async(devs_norm[i]-&gt;map, 0, size_norm, streams[i]);
-        CUDA_CHECK(res, "cuMemset(dev_norm)");
-        res = cuMemsetD32Async(devs_map_out[i]-&gt;map, 0, size_map_out,
-                streams[i]);
-        CUDA_CHECK(res, "cuMemset(dev_map_out)");
-
-        // launch kernel
-        calculateNormGPULaunch(devs_map_in[i], devs_norm[i], streams[i]);
-
-    }
-
-    for (i = 0; i &lt; numStep; i++)
-    {
-        // launch kernel
-        normalizeGPULaunch(alfa, devs_map_in[i], devs_norm[i], devs_map_out[i],
-                streams[i]);
-    }
-
-    // synchronize cuda stream
-    for (i = 0; i &lt; numStep; i++)
-    {
-        CUresult res = cuStreamSynchronize(streams[i]);
-        CUDA_CHECK(res, "cuStreamSynchronize(streams[%d])", i);
-    }
-
-    // free device memory
-    for (i = 0; i &lt; numStep; i++)
-    {
-        freeFeatureMapObjectGPU(&amp;devs_norm[i]);
-    }
-
-    free(devs_norm);
-
-    return LATENT_SVM_OK;
-}
-
-/*
-// Feature map reduction in GPU
-// In each cell we reduce dimension of the feature vector
-// according to original paper special procedure
-//
-// API
-//int PCAFeatureMapsGPUStream(const int numStep, const int bx, const int by,
-          CvLSVMFeatureMapGPU **devs_map_in, CvLSVMFeatureMap **feature_maps,
-          CUstream *streams)
-// INPUT
-// numStep
-// bx
-// by
-// devs_map_in
-// streams
-// OUTPUT
-// feature_maps
-// RESULT
-// Error status
-*/
-int PCAFeatureMapsGPUStream(const int numStep, const int bx, const int by,
-        CvLSVMFeatureMapGPU **devs_map_in, CvLSVMFeatureMap **feature_maps,
-        CUstream *streams)
-{
-
-    int sizeX, sizeY, pp;
-    int size_map_pca;
-    int i;
-    CUresult res;
-    CvLSVMFeatureMapGPU **devs_map_pca;
-
-    pp = NUM_SECTOR * 3 + 4;
-
-    devs_map_pca = (CvLSVMFeatureMapGPU **) malloc(
-            sizeof(CvLSVMFeatureMapGPU*) * (numStep));
-
-    // allocate memory
-    for (i = 0; i &lt; numStep; i++)
-    {
-        sizeX = devs_map_in[i]-&gt;sizeX + 2 * bx;
-        sizeY = devs_map_in[i]-&gt;sizeY + 2 * by;
-
-        size_map_pca = sizeX * sizeY * pp;
-
-        allocFeatureMapObject(&amp;feature_maps[i], sizeX, sizeY, pp);
-        allocFeatureMapObjectGPU&lt;float&gt;(&amp;devs_map_pca[i], sizeX, sizeY, pp);
-    }
-
-    // exucute async
-    for (i = 0; i &lt; numStep; i++)
-    {
-        sizeX = devs_map_pca[i]-&gt;sizeX;
-        sizeY = devs_map_pca[i]-&gt;sizeY;
-        size_map_pca = sizeX * sizeY * pp;
-
-        // initilize device memory value of 0
-        res = cuMemsetD32Async(devs_map_pca[i]-&gt;map, 0, size_map_pca,
-                streams[i]);
-        CUDA_CHECK(res, "cuMemset(dev_map_pca[%d]-&gt;map)", i);
-
-        // launch kernel
-        PCAFeatureMapsAddNullableBorderGPULaunch(devs_map_in[i],
-                devs_map_pca[i], bx, by, streams[i]);
-    }
-
-    for (i = 0; i &lt; numStep; i++)
-    {
-        sizeX = devs_map_pca[i]-&gt;sizeX;
-        sizeY = devs_map_pca[i]-&gt;sizeY;
-        size_map_pca = sizeX * sizeY * pp;
-
-        // copy memory from device to host
-        res = cuMemcpyDtoHAsync(feature_maps[i]-&gt;map, devs_map_pca[i]-&gt;map,
-                sizeof(float) * size_map_pca, streams[i]);
-        CUDA_CHECK(res, "cuMemcpyDtoHAsync(feature_maps[%d]-&gt;map)", i);
-    }
-
-    // free device memory
-    for (i = 0; i &lt; numStep; i++)
-    {
-        freeFeatureMapObjectGPU(&amp;devs_map_pca[i]);
-    }
-
-    free(devs_map_pca);
-
-    return LATENT_SVM_OK;
-}
-
-/*
-// Property Message
-//
-// API
-//static int getPathOfFeaturePyramidGPUStream(IplImage * image, float step,
-          int numStep, int startIndex, int sideLength, int bx, int by,
-          CvLSVMFeaturePyramid **maps)
-// INPUT
-// image
-// step
-// numStep
-// startIndex
-// sideLength
-// bx
-// by
-// OUTPUT
-// maps
-// RESULT
-// Error status
-*/
-static int getPathOfFeaturePyramidGPUStream(IplImage * image, float step,
-        int numStep, int startIndex, int sideLength, int bx, int by,
-        CvLSVMFeaturePyramid **maps)
-{
-    CvLSVMFeatureMap **feature_maps;
-
-    int i;
-    int width, height, numChannels, sizeX, sizeY, p, pp, newSizeX, newSizeY;
-    float *scales;
-    CvLSVMFeatureMapGPU **devs_img, **devs_map_pre_norm, **devs_map_pre_pca;
-    CUstream *streams;
-    CUresult res;
-
-    scales = (float *) malloc(sizeof(float) * (numStep));
-    devs_img = (CvLSVMFeatureMapGPU **) malloc(
-            sizeof(CvLSVMFeatureMapGPU*) * (numStep));
-    devs_map_pre_norm = (CvLSVMFeatureMapGPU **) malloc(
-            sizeof(CvLSVMFeatureMapGPU*) * (numStep));
-    devs_map_pre_pca = (CvLSVMFeatureMapGPU **) malloc(
-            sizeof(CvLSVMFeatureMapGPU*) * (numStep));
-    streams = (CUstream *) malloc(sizeof(CUstream) * (numStep));
-    feature_maps = (CvLSVMFeatureMap **) malloc(
-            sizeof(CvLSVMFeatureMap *) * (numStep));
-
-    // allocate device memory
-    for (i = 0; i &lt; numStep; i++)
-    {
-        scales[i] = 1.0f / powf(step, (float) i);
-        width  = (int) (((float) image-&gt;width ) * scales[i] + 0.5);
-        height = (int) (((float) image-&gt;height) * scales[i] + 0.5);
-        numChannels = image-&gt;nChannels;
-        sizeX = width  / sideLength;
-        sizeY = height / sideLength;
-        p  = NUM_SECTOR * 3;
-        pp = NUM_SECTOR * 12;
-        newSizeX = sizeX - 2;
-        newSizeY = sizeY - 2;
-
-        allocFeatureMapObjectGPU&lt;float&gt;(&amp;devs_img[i], width, height,
-                numChannels);
-        allocFeatureMapObjectGPU&lt;float&gt;(&amp;devs_map_pre_norm[i], sizeX, sizeY, p);
-        allocFeatureMapObjectGPU&lt;float&gt;(&amp;devs_map_pre_pca[i], newSizeX,
-                newSizeY, pp);
-        res = cuStreamCreate(&amp;streams[i], CU_STREAM_DEFAULT);
-        CUDA_CHECK(res, "cuStreamCreate(&amp;streams[%d])", i);
-    }
-
-    // excute main function
-    resizeGPUStream(numStep, image, scales, devs_img, streams);
-
-    getFeatureMapsGPUStream(numStep, sideLength, devs_img, devs_map_pre_norm,
-            streams);
-
-    normalizeAndTruncateGPUStream(numStep, Val_Of_Truncate, devs_map_pre_norm,
-            devs_map_pre_pca, streams);
-
-    PCAFeatureMapsGPUStream(numStep, bx, by, devs_map_pre_pca, feature_maps,
-            streams);
-
-    // synchronize cuda stream
-    for (i = 0; i &lt; numStep; i++)
-    {
-        CUresult res = cuStreamSynchronize(streams[i]);
-        CUDA_CHECK(res, "cuStreamSynchronize(streams[%d])", i);
-
-        res = cuStreamDestroy(streams[i]);
-        CUDA_CHECK(res, "cuStreamDestroy(streams[%d])", i);
-    }
-
-    for (i = 0; i &lt; numStep; i++)
-    {
-        (*maps)-&gt;pyramid[startIndex + i] = feature_maps[i];
-    }/*for(i = 0; i &lt; numStep; i++)*/
-
-    // free device memory
-    for (i = 0; i &lt; numStep; i++)
-    {
-        freeFeatureMapObjectGPU(&amp;devs_img[i]);
-        freeFeatureMapObjectGPU(&amp;devs_map_pre_norm[i]);
-        freeFeatureMapObjectGPU(&amp;devs_map_pre_pca[i]);
-    }
-
-    free(scales);
-    free(devs_img);
-    free(devs_map_pre_norm);
-    free(devs_map_pre_pca);
-    free(streams);
-    free(feature_maps);
-
-    return LATENT_SVM_OK;
-}
-
-int getFeaturePyramid(IplImage * image, CvLSVMFeaturePyramid **maps,
-        const int bx, const int by)
-{
-    IplImage *imgResize;
-    float step;
-    unsigned int numStep;
-    unsigned int maxNumCells;
-    unsigned int W, H;
-
-    if (image-&gt;depth == IPL_DEPTH_32F)
-    {
-        imgResize = image;
-    }
-    else
-    {
-        imgResize = cvCreateImage(cvSize(image-&gt;width, image-&gt;height),
-                IPL_DEPTH_32F, 3);
-        cvConvert(image, imgResize);
-    }
-
-    W = imgResize-&gt;width;
-    H = imgResize-&gt;height;
-
-    step = powf(2.0f, 1.0f / ((float) Lambda));
-    maxNumCells = W / Side_Length;
-    if (maxNumCells &gt; H / Side_Length)
-    {
-        maxNumCells = H / Side_Length;
-    }
-    numStep = (int) (logf((float) maxNumCells / (5.0f)) / logf(step)) + 1;
-
-    allocFeaturePyramidObject(maps, numStep + Lambda);
-
-#ifdef PROFILE
-    TickMeter tm;
-
-    tm.start();
-    cout &lt;&lt; "(featurepyramid.cpp)getPathOfFeaturePyramid START " &lt;&lt; endl;
-#endif
-
-    uploadImageToGPU1D(imgResize);
-
-    getPathOfFeaturePyramidGPUStream(imgResize, step , Lambda, 0,
-            Side_Length / 2, bx, by, maps);
-
-    getPathOfFeaturePyramidGPUStream(imgResize, step, numStep, Lambda,
-            Side_Length , bx, by, maps);
-
-    cleanImageFromGPU1D();
-
-#ifdef PROFILE
-    tm.stop();
-    cout &lt;&lt; "(featurepyramid.cpp)getPathOfFeaturePyramid END time = "
-            &lt;&lt; tm.getTimeSec() &lt;&lt; " sec" &lt;&lt; endl;
-#endif
-
-    if (image-&gt;depth != IPL_DEPTH_32F)
-    {
-        cvReleaseImage(&amp;imgResize);
-    }
-
-    return LATENT_SVM_OK;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\featurepyramid_gpu.hpp" new_path="" added_lines="0" deleted_lines="61">
				<diff>@@ -1,61 +0,0 @@
-#ifndef _FEATUREPYRAMID_GPU_H_
-#define _FEATUREPYRAMID_GPU_H_
-
-#include &lt;opencv2/opencv.hpp&gt;
-#include &lt;opencv2/core/core.hpp&gt;
-
-#include "for_use_gpu.h"
-#include "cuda_check.h"
-
-extern int calculateHistogramGPULaunch(const int k, CvLSVMFeatureMapGPU *dev_img,
-        CvLSVMFeatureMapGPU *dev_r, CvLSVMFeatureMapGPU *dev_alfa,
-        CUstream stream);
-
-extern int getFeatureMapsGPULaunch(const int k, CvLSVMFeatureMapGPU *dev_r,
-        CvLSVMFeatureMapGPU *dev_alfa, CUdeviceptr *dev_nearest,
-        CUdeviceptr *dev_w, CvLSVMFeatureMapGPU *dev_map, CUstream stream);
-
-extern int calculateNormGPULaunch(CvLSVMFeatureMapGPU *dev_map_in,
-        CvLSVMFeatureMapGPU *dev_norm, CUstream stream);
-
-extern int normalizeGPULaunch(const float alfa, CvLSVMFeatureMapGPU *dev_map_in,
-        CvLSVMFeatureMapGPU *dev_norm, CvLSVMFeatureMapGPU *dev_map_out,
-        CUstream stream);
-
-extern int PCAFeatureMapsAddNullableBorderGPULaunch(CvLSVMFeatureMapGPU *dev_map_in,
-        CvLSVMFeatureMapGPU *dev_map_out, const int bx, const int by,
-        CUstream stream);
-
-extern int getFeatureMapsGPUStream(const int numStep, const int k,
-        CvLSVMFeatureMapGPU **devs_img, CvLSVMFeatureMapGPU **devs_map,
-        CUstream *streams);
-
-extern int normalizeAndTruncateGPUStream(const int numStep, const float alfa,
-        CvLSVMFeatureMapGPU **devs_map_in, CvLSVMFeatureMapGPU **devs_map_out,
-        CUstream *streams);
-
-extern int PCAFeatureMapsGPUStream(const int numStep, const int bx, const int by,
-        CvLSVMFeatureMapGPU **devs_map_in, CvLSVMFeatureMap **feature_maps,
-        CUstream *streams);
-
-extern int getFeaturePyramid(IplImage * image, CvLSVMFeaturePyramid **maps,
-        const int bx, const int by);
-
-// Add for gpu
-template&lt;typename T&gt;
-int allocFeatureMapObjectGPU(CvLSVMFeatureMapGPU **obj, const int sizeX,
-        const int sizeY, const int p)
-{
-    CUresult res;
-    (*obj) = (CvLSVMFeatureMapGPU *) malloc(sizeof(CvLSVMFeatureMapGPU));
-    (*obj)-&gt;sizeX = sizeX;
-    (*obj)-&gt;sizeY = sizeY;
-    (*obj)-&gt;numFeatures = p;
-
-    res = cuMemAlloc(&amp;(*obj)-&gt;map, sizeof(T) * sizeX * sizeY * p);
-    CUDA_CHECK(res, "cuMemAlloc(map)");
-
-    return LATENT_SVM_OK;
-}
-
-#endif /* _FEATUREPYRAMID_GPU_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\for_use_gpu.h" new_path="" added_lines="0" deleted_lines="91">
				<diff>@@ -1,91 +0,0 @@
-#ifndef _FOR_USE_GPU_H_
-#define _FOR_USE_GPU_H_
-
-#include &lt;cuda.h&gt;
-#include &lt;opencv2/objdetect/objdetect.hpp&gt;
-
-// Macros in OpenCV private header files
-#define LATENT_SVM_MEM_NULL 2
-#define LAMBDA 10 // ORIGINAL 10
-#define SIDE_LENGTH 8 //ORIGINAL 8
-#define VAL_OF_TRUNCATE 0.2f
-#define LATENT_SVM_OK 0
-#define NUM_SECTOR 9 // ORIGINAL 9
-#define LATENT_SVM_SEARCH_OBJECT_FAILED -5
-#define LATENT_SVM_FAILED_SUPERPOSITION -6
-
-// Data structures in OpenCV private header files
-typedef struct{
-    int sizeX;
-    int sizeY;
-    int numFeatures;
-    float *map;
-} CvLSVMFeatureMap;
-
-typedef struct{
-    int numLevels;
-    CvLSVMFeatureMap **pyramid;
-} CvLSVMFeaturePyramid;
-
-// Add for gpu
-typedef struct
-{
-    int sizeX;
-    int sizeY;
-    int numFeatures;
-    CUdeviceptr map;
-} CvLSVMFeatureMapGPU;
-
-typedef struct
-{
-    int numLevels;
-    CvLSVMFeatureMapGPU **pyramid;
-} CvLSVMFeaturePyramidGPU;
-
-typedef struct
-{
-    float *score;
-    int *x;
-    int *y;
-    int size;
-} CvLSVMFilterDisposition;
-
-extern int Lambda;
-extern int Side_Length;
-extern float Val_Of_Truncate;
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-// define variables for using GPU
-
-extern CUdevice *dev;
-extern CUcontext *ctx;
-
-extern CUfunction *BilinearKernelTex32F_func;
-extern CUfunction *calculateHistogram_func;
-extern CUfunction *getFeatureMaps_func;
-extern CUfunction *calculateNorm_func;
-extern CUfunction *normalizeAndTruncate_func;
-extern CUfunction *PCAFeatureMapsAddNullableBorder_func;
-extern CUfunction *ConvolutionKernel_func;
-extern CUfunction *DistanceTransformTwoDimensionalProblem_func;
-
-extern CUmodule *module;
-extern int *NR_MAXTHREADS_X, *NR_MAXTHREADS_Y;
-
-extern int device_num;
-extern int max_threads_num;
-
-// functions for using GPU and to calculate on GPU
-extern void init_cuda(void);
-
-extern void clean_cuda(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif // _FOR_USE_GPU_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\gpu_function.cu" new_path="" added_lines="0" deleted_lines="651">
				<diff>@@ -1,651 +0,0 @@
-#include &lt;stdio.h&gt;
-#include &lt;float.h&gt;
-#include &lt;math.h&gt;
-#include &lt;cuda.h&gt;
-#include "gpu_matching.h"
-
-// Copy from OpenCV
-#define F_MAX FLT_MAX
-#define F_MIN -FLT_MAX
-#define NUM_SECTOR 9
-
-texture&lt;float, cudaTextureType1D, cudaReadModeElementType&gt; texRef;
-texture&lt;float, cudaTextureType1D, cudaReadModeElementType&gt; texMap;
-texture&lt;float, cudaTextureType1D, cudaReadModeElementType&gt; texFi;
-
-__device__
-static inline float
-atomicAdd_float(float * __restrict__ address, float val)
-{
-    return atomicAdd(address, val); // atomicAdd must be called from "__device__" function
-}
-
-__device__
-int DistanceTransformOneDimensionalProblemX
-(
-        const int y,
-        const int x,
-        const float * __restrict__ score,
-        const float a,
-        const float b,
-        DistTransWork * __restrict__ work,
-        int indx
-)
-{
-    int i, k;
-    int diff;
-    float pointIntersection;
-    float tmp;
-    const int size = x * y;
-
-    k = 0;
-
-    work[indx].v = 0;
-    work[indx].z = (float)F_MIN;
-    work[indx+1].z = (float)F_MAX;
-
-    for (i = 1; i &lt; x; i++)
-    {
-        tmp = ( score[i + size] - a * i + b * i * i );
-        pointIntersection = ( tmp
-                - ( score[work[indx + k].v + size] - a * work[indx + k].v + b * work[indx + k].v * work[indx + k].v ) )
-        / (2 * b * (i - work[indx + k].v));
-        while (pointIntersection &lt;= work[indx + k].z)
-        {
-            k--;
-            pointIntersection = ( tmp
-                    - ( score[work[indx + k].v + size] - a * work[indx + k].v + b * work[indx + k].v * work[indx + k].v ) )
-            / (2 * b * (i - work[indx + k].v));
-        }
-        // Addition parabola to the envelope
-        k++;
-        work[indx + k].v = i;
-        work[indx + k].z = pointIntersection;
-        work[indx + k + 1].z = (float)F_MAX;
-    }
-
-    // Computation values of generalized distance transform at all grid points
-    k = 0;
-    for (i = 0; i &lt; x; i++)
-    {
-        while (work[indx + k + 1].z &lt; i)
-        {
-            k++;
-        }
-        work[size + i].internalPoints = work[indx + k].v;
-        diff = i - work[indx + k].v;
-        work[size + i].internalDistTrans = a * diff + b * diff * diff + score[work[indx + k].v + size];
-    }
-    return 0;
-}
-
-__device__ int DistanceTransformOneDimensionalProblemY
-(
-        const int x,
-        const int y,
-        const int diffX,
-        const float a,
-        const float b,
-        float * __restrict__ distanceTransform,
-        int * __restrict__ points,
-        DistTransWork * __restrict__ work,
-        int indx
-)
-{
-    int i, k;
-    int diff;
-    float pointIntersection;
-    float tmp;
-    k = 0;
-
-    work[indx].v = 0;
-    work[indx].z = (float)F_MIN;
-    work[indx+1].z = (float)F_MAX;
-
-    for (i = 1; i &lt; y; i++)
-    {
-        tmp = ( work[x + i * diffX].internalDistTrans - a * i + b * i * i );
-        pointIntersection = ( tmp
-                - ( work[x + work[indx + k].v * diffX].internalDistTrans - a * work[indx + k].v + b * work[indx + k].v * work[indx + k].v ))
-        / (2 * b * (i - work[indx + k].v));
-
-        while (pointIntersection &lt;= work[indx + k].z)
-        {
-            k--;
-            pointIntersection = ( tmp
-                    - ( work[x + work[indx + k].v * diffX].internalDistTrans - a * work[indx + k].v + b * work[indx + k].v * work[indx + k].v ))
-            / (2 * b * (i - work[indx + k].v));
-
-        }
-        // Addition parabola to the envelope
-        k++;
-        work[indx + k].v = i;
-        work[indx + k].z = pointIntersection;
-        work[indx + k + 1].z = (float)F_MAX;
-    }
-
-    // Computation values of generalized distance transform at all grid points
-    k = 0;
-    for (i = 0; i &lt; y; i++)
-    {
-        while (work[indx + k + 1].z &lt; i)
-        {
-            k++;
-        }
-        points[x + i * diffX] = work[indx + k].v;
-        diff = i - work[indx + k].v;
-        distanceTransform[x + i * diffX] = a * diff + b * diff * diff + work[x + work[indx + k].v * diffX].internalDistTrans;
-    }
-    return 0;
-}
-
-extern "C"
-{
-
-__global__
-void DistanceTransformTwoDimensionalProblemKernel
-(
-        float * __restrict__ score,
-        const int x,
-        const int y,
-        const float coeff0,
-        const float coeff1,
-        const float coeff2,
-        const float coeff3,
-        DistTransWork * __restrict__ work,
-        float * __restrict__ resalt,
-        int * __restrict__ pointsX,
-        int * __restrict__ pointsY
-)
-{
-
-    int t = threadIdx.x;
-    int i;
-    int size = x * y;
-
-    for (i = t; i &lt; size; i+=TRANS_THREAD)
-    {
-        score[i] = -score[i];
-    }
-
-    __syncthreads();
-
-    for (i = t; i &lt; y; i+=TRANS_THREAD)
-    {
-        DistanceTransformOneDimensionalProblemX(i,x,
-                score,
-                coeff0, coeff2,
-                work,
-                i * ( x + 1 ));
-    }
-
-    __syncthreads();
-
-    for (i = t; i &lt; x; i+=TRANS_THREAD)
-    {
-        DistanceTransformOneDimensionalProblemY(i,y,x,
-                coeff1, coeff3,
-                resalt,
-                pointsY,
-                work,
-                i * ( y + 1 ));
-    }
-
-    __syncthreads();
-
-    for (i = t; i &lt; size; i+=TRANS_THREAD)
-    {
-        pointsX[i] = work[pointsY[i] * (i % x) + (i / x)].internalPoints;
-    }
-}
-
-__global__
-void ConvolutionKernel
-(
-        const int idx,
-        float * __restrict__ dev_score,
-        const unsigned int * __restrict__ dev_filterIdxTbl,
-        const ConvolutionParam prm
-)
-{
-    
-    __shared__ float cache[CONV_THREAD];
-    
-    unsigned int score_idx; //スコア番号
-    unsigned int fi_idx;    //フィルタ距離
-    unsigned int t = threadIdx.x;
-    unsigned int b = gridDim.x;
-
-    unsigned int mtable;
-
-    score_idx = blockIdx.x; 
-
-    mtable = (( score_idx / prm.scoreX ) * prm.mapX ) + (( score_idx % prm.scoreX ) * prm.numSectors );
-
-    // 各ブロックでdev_score[score_idx]を計算
-    for( score_idx = blockIdx.x; score_idx &lt; prm.scoreSize; score_idx += b )
-    {      
-        // キャッシュの初期化
-        cache[t] = 0.0f;
-
-        // 各スレッドで対応した部分スコアを計算しキャッシュに格納
-        for( fi_idx = t; fi_idx &lt; prm.filterSize; fi_idx += CONV_THREAD)
-        {
-            cache[t] += tex1Dfetch(texMap,dev_filterIdxTbl[fi_idx] + mtable) * tex1Dfetch(texFi,fi_idx + idx);
-        }
-        //cache[t] = score;
-        // キャッシュ内の部分スコアの総和をcache[0]へ畳み込む
-        for( unsigned int i = CONV_THREAD &gt;&gt; 1; i &gt; 0; i &gt;&gt;= 1)
-        {
-            __syncthreads();
-            if( t &lt; i )
-            {
-                cache[t] += cache[t + i];
-            }
-        }
-        
-        // スコアの代入
-        if(t == 0)
-        {
-            dev_score[score_idx] = cache[0];
-        }
-    }
-    
-}
-
-__global__
-void BilinearKernelTex32F(
-        float * __restrict__ out,
-        const int widthIn,
-        const int heightIn,
-        const int widthOut,
-        const int heightOut,
-        const int channels,
-        const int widthStepIn,
-        const int widthStepOut
-)
-{
-    const int x = blockDim.x * blockIdx.x + threadIdx.x;
-    const int y = blockDim.y * blockIdx.y + threadIdx.y;
-    const int c = blockIdx.z;
-
-    if(x &lt; widthOut &amp;&amp; y &lt; heightOut)
-    {
-        const float fx = ((float)widthIn / widthOut);
-        const float fy = ((float)heightIn / heightOut);
-
-        const float src_x = x * fx;
-        const float src_y = y * fy;
-
-        const int x1 = __float2int_rd(src_x);
-        const int y1 = __float2int_rd(src_y);
-        const int x2 = x1 + 1;
-        const int y2 = y1 + 1;
-        const int x2_read = min(x2, widthIn - 1);
-        const int y2_read = min(y2, heightIn - 1);
-
-        int width_step_out_u = widthStepOut / 4;
-
-        float cell1 = (x2 - src_x) * (y2 - src_y);
-        float cell2 = (src_x - x1) * (y2 - src_y);
-        float cell3 = (x2 - src_x) * (src_y - y1);
-        float cell4 = (src_x - x1) * (src_y - y1);
-
-        out[y * width_step_out_u + x * channels + c] = (float)(
-                cell1 * (float)tex1Dfetch(texRef, y1 * widthIn * channels + x1 * channels + c)
-                + cell2 * (float)tex1Dfetch(texRef, y1 * widthIn * channels + x2_read * channels + c)
-                + cell3 * (float)tex1Dfetch(texRef, y2_read * widthIn * channels + x1 * channels + c)
-                + cell4 * (float)tex1Dfetch(texRef, y2_read * widthIn * channels + x2_read * channels + c));
-    }
-}
-
-__global__
-void calculateHistogram(
-        const float * __restrict__ in,
-        float * __restrict__ r,
-        int * __restrict__ alfa,
-        const int widthIn,
-        const int heightIn,
-        const int widthStep,
-        const int channels
-)
-{
-    const int i = blockDim.x * blockIdx.x + threadIdx.x;
-    const int j = blockDim.y * blockIdx.y + threadIdx.y;
-
-    int height, width, numChannels;
-    int kk, c;
-
-    float magnitude, x, y, tx, ty;
-
-    const float boundary_x[NUM_SECTOR + 1] =
-    {   1.000000, 0.939693, 0.766044, 0.500000, 0.173648, -0.173648, -0.500000, -0.766045, -0.939693, -1.000000};
-    const float boundary_y[NUM_SECTOR + 1] =
-    {   0.000000, 0.342020, 0.642788, 0.866025, 0.984808, 0.984808, 0.866025, 0.642787, 0.342020, 0.000000};
-    float max, dotProd;
-    int maxi;
-
-    height = heightIn;
-    width = widthIn;
-
-    numChannels = channels;
-
-    int width_step_u = widthStep / 4;
-
-    if(j &gt;= 1 &amp;&amp; j &lt; height - 1)
-    {
-        if(i &gt;= 1 &amp;&amp; i &lt; width - 1)
-        {
-
-            c = 0;
-            x = (-in[(j * width + (i - 1)) * numChannels + c]) + in[(j * width + (i + 1)) * numChannels + c];
-            y = (-in[((j - 1) * width + i) * numChannels + c]) + in[((j + 1) * width + i) * numChannels + c];
-
-            r[j * width + i] = sqrtf(x * x + y * y);
-            for(int ch = 1; ch &lt; numChannels; ch++)
-            {
-                tx = (-in[j * width_step_u + (i - 1) * numChannels + c]) + in[j * width_step_u + (i + 1) * numChannels + c];
-                ty = (-in[(j - 1) * width_step_u + i * numChannels + c]) + in[(j + 1) * width_step_u + i * numChannels + c];
-                magnitude = sqrtf(tx * tx + ty * ty);
-                if(magnitude &gt; r[j * width + i])
-                {
-                    r[j * width + i] = magnitude;
-                    c = ch;
-                    x = tx;
-                    y = ty;
-                }
-            }
-
-            max = boundary_x[0] * x + boundary_y[0] * y;
-            maxi = 0;
-
-            for (kk = 0; kk &lt; NUM_SECTOR; kk++)
-            {
-                dotProd = boundary_x[kk] * x + boundary_y[kk] * y;
-                if (dotProd &gt; max)
-                {
-                    max = dotProd;
-                    maxi = kk;
-                }
-                else
-                {
-                    if (-dotProd &gt; max)
-                    {
-                        max = -dotProd;
-                        maxi = kk + NUM_SECTOR;
-                    }
-                }
-            }
-            alfa[j * width * 2 + i * 2 ] = maxi % NUM_SECTOR;
-            alfa[j * width * 2 + i * 2 + 1] = maxi;
-        }
-    }
-}
-
-__global__
-void getFeatureMaps(
-        const float * __restrict__ r,
-        const int * __restrict__ alfa,
-        const int * __restrict__ nearest,
-        const float * __restrict__ w,
-        float * __restrict__ map,
-        const int widthMap,
-        const int heightMap,
-        const int k,
-        const int numFeatures
-)
-{
-    const int j = blockDim.x * blockIdx.x + threadIdx.x;
-    const int i = blockDim.y * blockIdx.y + threadIdx.y;
-    const int ii = blockIdx.z / k;
-    const int jj = blockIdx.z % k;
-
-    int sizeX, sizeY;
-    int p, px, stringSize;
-    int height, width;
-    int d;
-
-    height = heightMap;
-    width = widthMap;
-
-    sizeX = width / k;
-    sizeY = height / k;
-    px = 3 * NUM_SECTOR;
-    p = px;
-    stringSize = sizeX * p;
-
-    if(i &lt; sizeY)
-    {
-        if(j &lt; sizeX)
-        {
-            if(ii &lt; k)
-            {
-                if(jj &lt; k)
-                {
-                    if ((i * k + ii &gt; 0) &amp;&amp;
-                            (i * k + ii &lt; height - 1) &amp;&amp;
-                            (j * k + jj &gt; 0) &amp;&amp;
-                            (j * k + jj &lt; width - 1))
-                    {
-                        d = (k * i + ii) * width + (j * k + jj);
-                        atomicAdd_float(
-                                (float *)(map + (i * stringSize + j * numFeatures + alfa[d * 2 ])),
-                                (float)(r[d] * w[ii * 2] * w[jj * 2])
-                        );
-                        atomicAdd_float(
-                                (float *)(map + (i * stringSize + j * numFeatures + alfa[d * 2 + 1] + NUM_SECTOR)),
-                                (float)(r[d] * w[ii * 2] * w[jj * 2])
-                        );
-                        if ((i + nearest[ii] &gt;= 0) &amp;&amp;
-                                (i + nearest[ii] &lt;= sizeY - 1))
-                        {
-                            atomicAdd_float(
-                                    (float *)(map + ((i + nearest[ii]) * stringSize + j * numFeatures + alfa[d * 2 ])),
-                                    (float)(r[d] * w[ii * 2 + 1] * w[jj * 2])
-                            );
-                            atomicAdd_float(
-                                    (float *)(map + ((i + nearest[ii]) * stringSize + j * numFeatures + alfa[d * 2 + 1] + NUM_SECTOR)),
-                                    (float)(r[d] * w[ii * 2 + 1] * w[jj * 2])
-                            );
-                        }
-                        if ((j + nearest[jj] &gt;= 0) &amp;&amp;
-                                (j + nearest[jj] &lt;= sizeX - 1))
-                        {
-                            atomicAdd_float(
-                                    (float *)(map + (i * stringSize + (j + nearest[jj]) * numFeatures + alfa[d * 2 ])),
-                                    (float)(r[d] * w[ii * 2] * w[jj * 2 + 1])
-                            );
-                            atomicAdd_float(
-                                    (float *)(map + (i * stringSize + (j + nearest[jj]) * numFeatures + alfa[d * 2 + 1] + NUM_SECTOR)),
-                                    (float)(r[d] * w[ii * 2] * w[jj * 2 + 1])
-                            );
-                        }
-                        if ((i + nearest[ii] &gt;= 0) &amp;&amp;
-                                (i + nearest[ii] &lt;= sizeY - 1) &amp;&amp;
-                                (j + nearest[jj] &gt;= 0) &amp;&amp;
-                                (j + nearest[jj] &lt;= sizeX - 1))
-                        {
-                            atomicAdd_float(
-                                    (float *)(map + ((i + nearest[ii]) * stringSize + (j + nearest[jj]) * numFeatures + alfa[d * 2 ])),
-                                    (float)(r[d] * w[ii * 2 + 1] * w[jj * 2 + 1])
-                            );
-                            atomicAdd_float(
-                                    (float *)(map + ((i + nearest[ii]) * stringSize + (j + nearest[jj]) * numFeatures + alfa[d * 2 + 1] + NUM_SECTOR)),
-                                    (float)(r[d] * w[ii * 2 + 1] * w[jj * 2 + 1])
-                            );
-                        }
-                    }
-                }
-            }
-        }
-    }
-}
-
-__global__
-void calculateNorm(
-        const float * __restrict__ map,
-        float * __restrict__ partOfNorm,
-        const int sizeX,
-        const int sizeY,
-        const int numFeatures
-)
-{
-    const int x = blockDim.x * blockIdx.x + threadIdx.x;
-    const int y = blockDim.y * blockIdx.y + threadIdx.y;
-
-    if(y &lt; sizeY)
-    {
-        if(x &lt; sizeX)
-        {
-            int i, j, p, pos;
-            float valOfNorm = 0.0f;
-
-            p = NUM_SECTOR;
-
-            i = y * sizeX + x;
-            pos = i * numFeatures;
-            for(j = 0; j &lt; p; j++)
-            {
-                valOfNorm += map[pos + j] * map[pos + j];
-            }
-            partOfNorm[i] = valOfNorm;
-        }
-    }
-}
-
-__global__
-void normalizeAndTruncate(
-        const float * __restrict__ map,
-        const float * __restrict__ partOfNorm,
-        float * __restrict__ newData,
-        const int mapSizeX,
-        const int mapSizeY,
-        const float alfa
-)
-{
-    int x = blockDim.x * blockIdx.x + threadIdx.x;
-    int y = blockDim.y * blockIdx.y + threadIdx.y;
-    int ii = blockIdx.z;
-
-    int sizeX, sizeY, p, pp, xp, pos1, pos2;
-    float valOfNorm1, valOfNorm2, valOfNorm3, valOfNorm4;
-
-    p = NUM_SECTOR;
-    xp = NUM_SECTOR * 3;
-    pp = NUM_SECTOR * 12;
-
-    sizeX = mapSizeX - 2;
-    sizeY = mapSizeY - 2;
-
-    if(y &gt;= 1 &amp;&amp; y &lt;= sizeY)
-    {
-        if(x &gt;= 1 &amp;&amp; x &lt;= sizeX)
-        {
-            valOfNorm1 = sqrtf(
-                    partOfNorm[(y )*(sizeX + 2) + (x )] +
-                    partOfNorm[(y )*(sizeX + 2) + (x + 1)] +
-                    partOfNorm[(y + 1)*(sizeX + 2) + (x )] +
-                    partOfNorm[(y + 1)*(sizeX + 2) + (x + 1)]) + FLT_EPSILON;
-            valOfNorm2 = sqrtf(
-                    partOfNorm[(y )*(sizeX + 2) + (x )] +
-                    partOfNorm[(y )*(sizeX + 2) + (x + 1)] +
-                    partOfNorm[(y - 1)*(sizeX + 2) + (x )] +
-                    partOfNorm[(y - 1)*(sizeX + 2) + (x + 1)]) + FLT_EPSILON;
-            valOfNorm3 = sqrtf(
-                    partOfNorm[(y )*(sizeX + 2) + (x )] +
-                    partOfNorm[(y )*(sizeX + 2) + (x - 1)] +
-                    partOfNorm[(y + 1)*(sizeX + 2) + (x )] +
-                    partOfNorm[(y + 1)*(sizeX + 2) + (x - 1)]) + FLT_EPSILON;
-            valOfNorm4 = sqrtf(
-                    partOfNorm[(y )*(sizeX + 2) + (x )] +
-                    partOfNorm[(y )*(sizeX + 2) + (x - 1)] +
-                    partOfNorm[(y - 1)*(sizeX + 2) + (x )] +
-                    partOfNorm[(y - 1)*(sizeX + 2) + (x - 1)]) + FLT_EPSILON;
-            pos1 = (y ) * (sizeX + 2) * xp + (x ) * xp;
-            pos2 = (y-1) * (sizeX ) * pp + (x-1) * pp;
-
-            if(ii &lt; p)
-            {
-                newData[pos2 + ii ] = fminf(map[pos1 + ii] / valOfNorm1, alfa);
-                newData[pos2 + ii + p ] = fminf(map[pos1 + ii] / valOfNorm2, alfa);
-                newData[pos2 + ii + p * 2] = fminf(map[pos1 + ii] / valOfNorm3, alfa);
-                newData[pos2 + ii + p * 3] = fminf(map[pos1 + ii] / valOfNorm4, alfa);
-            }
-
-            newData[pos2 + ii + p * 4 ] = fminf(map[pos1 + ii + p] / valOfNorm1, alfa);
-            newData[pos2 + ii + p * 6 ] = fminf(map[pos1 + ii + p] / valOfNorm2, alfa);
-            newData[pos2 + ii + p * 8 ] = fminf(map[pos1 + ii + p] / valOfNorm3, alfa);
-            newData[pos2 + ii + p * 10] = fminf(map[pos1 + ii + p] / valOfNorm4, alfa);
-        }
-    }
-}
-
-__global__
-void PCAFeatureMapsAddNullableBorder(
-        const float * __restrict__ map,
-        float * __restrict__ newData,
-        const int borderMapSizeX,
-        const int borderMapSizeY,
-        const int numFeatures,
-        const int bx,
-        const int by
-)
-{
-    const int j = blockDim.x * blockIdx.x + threadIdx.x;
-    const int i = blockDim.y * blockIdx.y + threadIdx.y;
-
-    int ii, jj, k;
-    int sizeX, sizeY, p, pp, xp, yp, pos1, pos2;
-    float val;
-    float nx, ny;
-
-    sizeX = borderMapSizeX;
-    sizeY = borderMapSizeY;
-    p = numFeatures;
-    pp = NUM_SECTOR * 3 + 4;
-    yp = 4;
-    xp = NUM_SECTOR;
-
-    nx = 1.0f / sqrtf((float)(xp * 2));
-    ny = 1.0f / sqrtf((float)(yp ));
-
-    if(i &lt; sizeY)
-    {
-        if(j &lt; sizeX)
-        {
-            pos1 = ((i)*sizeX + j)*p;
-            pos2 = ((i + by)*(sizeX + 2 * bx) + j + bx)*pp;
-            k = 0;
-            for(jj = 0; jj &lt; xp * 2; jj++)
-            {
-                newData[pos2 + k] = ( map[pos1 + yp * xp + jj]
-                        + map[pos1 + (yp + 2) * xp + jj]
-                        + map[pos1 + (yp + 4) * xp + jj]
-                        + map[pos1 + (yp + 6) * xp + jj] ) * ny;
-
-                k++;
-            }
-            for(jj = 0; jj &lt; xp; jj++)
-            {
-                newData[pos2 + k] = ( map[pos1 + jj]
-                        + map[pos1 + xp + jj]
-                        + map[pos1 + 2 * xp + jj]
-                        + map[pos1 + 3 * xp + jj]) * ny;
-                k++;
-            }
-            for(ii = 0; ii &lt; yp; ii++)
-            {
-                val = 0;
-                for(jj = 0; jj &lt; 2 * xp; jj++)
-                {
-                    val += map[pos1 + yp * xp + ii * xp * 2 + jj];
-                }
-                newData[pos2 + k] = val * nx;
-                k++;
-            }
-        }
-    }
-
-}
-
-} // extern "C"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\gpu_init.cpp" new_path="" added_lines="0" deleted_lines="168">
				<diff>@@ -1,168 +0,0 @@
-#include "for_use_gpu.h"
-#include "cuda_check.h"
-#include &lt;stdio.h&gt;
-#include &lt;math.h&gt;
-#include &lt;string&gt;
-#include &lt;unistd.h&gt;
-
-#define XSTR(x) #x
-#define STR(x) XSTR(x)
-
-CUdevice *dev;
-CUcontext *ctx;
-
-CUfunction *DistanceTransformTwoDimensionalProblem_func;
-CUfunction *ConvolutionKernel_func;
-CUfunction *BilinearKernelTex32F_func;
-CUfunction *calculateHistogram_func;
-CUfunction *getFeatureMaps_func;
-CUfunction *calculateNorm_func;
-CUfunction *normalizeAndTruncate_func;
-CUfunction *PCAFeatureMapsAddNullableBorder_func;
-
-CUmodule *module;
-int *NR_MAXTHREADS_X, *NR_MAXTHREADS_Y;
-int device_num;
-int max_threads_num;
-
-void init_cuda(void)
-{
-    CUresult res;
-    std::string cubin_path(STR(CUBIN_PATH));
-
-    // initnialize GPU
-    res = cuInit(0);
-    CUDA_CHECK(res, "cuInit()");
-
-    // count the number of usable GPU
-    res = cuDeviceGetCount(&amp;device_num);
-    CUDA_CHECK(res, "cuDeviceGetCount()");
-
-    // unsupported multi GPU
-    device_num = 1;
-
-    // get device
-    dev = (CUdevice*) malloc(device_num * sizeof(CUdevice));
-
-    for (int i = 0; i &lt; device_num; i++)
-    {
-        res = cuDeviceGet(&amp;dev[i], i);
-        CUDA_CHECK(res, "cuDeviceGet(&amp;dev[%d])", i);
-    }
-
-    ctx = (CUcontext*) malloc(device_num * sizeof(CUcontext));
-
-    module = (CUmodule*) malloc(device_num * sizeof(CUmodule));
-
-    ConvolutionKernel_func = (CUfunction*) malloc(
-            device_num * sizeof(CUfunction));
-    DistanceTransformTwoDimensionalProblem_func = (CUfunction*) malloc(
-            device_num * sizeof(CUfunction));
-    BilinearKernelTex32F_func = (CUfunction*) malloc(
-            device_num * sizeof(CUfunction));
-    calculateHistogram_func = (CUfunction*) malloc(
-            device_num * sizeof(CUfunction));
-    getFeatureMaps_func = (CUfunction*) malloc(device_num * sizeof(CUfunction));
-    calculateNorm_func = (CUfunction*) malloc(device_num * sizeof(CUfunction));
-    normalizeAndTruncate_func = (CUfunction*) malloc(
-            device_num * sizeof(CUfunction));
-    PCAFeatureMapsAddNullableBorder_func = (CUfunction*) malloc(
-            device_num * sizeof(CUfunction));
-
-    for (int i = 0; i &lt; device_num; i++)
-    {
-        res = cuCtxCreate(&amp;ctx[i], 0, dev[i]);
-        CUDA_CHECK(res, "cuCtxCreate(&amp;ctx[%d])", i);
-    }
-
-    for (int i = 0; i &lt; device_num; i++)
-    {
-
-        res = cuCtxSetCurrent(ctx[i]);
-        CUDA_CHECK(res, "cuCtxSetCurrent(ctx[%d])", i);
-
-        // load .cubin file
-        res = cuModuleLoad(&amp;module[i], cubin_path.c_str());
-        CUDA_CHECK(res, "cuModuleLoad(&amp;module[%d]), cubin path=%s", i, cubin_path.c_str());
-
-        res = cuModuleGetFunction(&amp;ConvolutionKernel_func[i], module[i],
-                "ConvolutionKernel");
-        CUDA_CHECK(res, "cuModuleGetFunction(ConvolutionKernel)");
-
-        res = cuModuleGetFunction(
-                &amp;DistanceTransformTwoDimensionalProblem_func[i], module[i],
-                "DistanceTransformTwoDimensionalProblemKernel");
-        CUDA_CHECK(res, "cuModuleGetFunction(DistanceTransformTwoDimensionalProblemKernel)");
-
-        res = cuModuleGetFunction(&amp;BilinearKernelTex32F_func[i], module[i],
-                "BilinearKernelTex32F");
-        CUDA_CHECK(res, "cuModuleGetFunction(BilinearKernelTex32F)");
-
-        res = cuModuleGetFunction(&amp;calculateHistogram_func[i], module[i],
-                "calculateHistogram");
-        CUDA_CHECK(res, "cuModuleGetFunction(calculateHistogram)");
-
-        res = cuModuleGetFunction(&amp;getFeatureMaps_func[i], module[i],
-                "getFeatureMaps");
-        CUDA_CHECK(res, "cuModuleGetFunction(getFeatureMaps)");
-
-        res = cuModuleGetFunction(&amp;calculateNorm_func[i], module[i],
-                "calculateNorm");
-        CUDA_CHECK(res, "cuModuleGetFunction(calculateNorm)");
-
-        res = cuModuleGetFunction(&amp;normalizeAndTruncate_func[i], module[i],
-                "normalizeAndTruncate");
-        CUDA_CHECK(res, "cuModuleGetFunction(normalizeAndTruncate)");
-
-        res = cuModuleGetFunction(&amp;PCAFeatureMapsAddNullableBorder_func[i],
-                module[i], "PCAFeatureMapsAddNullableBorder");
-        CUDA_CHECK(res, "cuModuleGetFunction(PCAFeatureMapsAddNullableBorder)");
-    }
-
-    NR_MAXTHREADS_X = (int*) malloc(device_num * sizeof(int));
-    NR_MAXTHREADS_Y = (int*) malloc(device_num * sizeof(int));
-
-    for (int i = 0; i &lt; device_num; i++)
-    {
-        // get max thread num per block
-        max_threads_num = 0;
-        res = cuDeviceGetAttribute(&amp;max_threads_num,
-                CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK, dev[i]);
-        CUDA_CHECK(res, "cuDeviceGetAttribute(CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK)");
-
-        NR_MAXTHREADS_X[i] = (int) sqrt((double) max_threads_num);
-        NR_MAXTHREADS_Y[i] = (int) sqrt((double) max_threads_num);
-    }
-
-}
-
-void clean_cuda(void)
-{
-    CUresult res;
-
-    for (int i = 0; i &lt; device_num; i++)
-    {
-        res = cuModuleUnload(module[i]);
-        CUDA_CHECK(res, "cuModuleUnload(module[%d])", i);
-    }
-
-    for (int i = 0; i &lt; device_num; i++)
-    {
-        res = cuCtxDestroy(ctx[i]);
-        CUDA_CHECK(res, "cuCtxDestroy(ctx[%d])", i);
-    }
-
-    free(NR_MAXTHREADS_X);
-    free(NR_MAXTHREADS_Y);
-    free(ConvolutionKernel_func);
-    free(DistanceTransformTwoDimensionalProblem_func);
-    free(BilinearKernelTex32F_func);
-    free(calculateHistogram_func);
-    free(getFeatureMaps_func);
-    free(calculateNorm_func);
-    free(normalizeAndTruncate_func);
-    free(PCAFeatureMapsAddNullableBorder_func);
-    free(module);
-    free(dev);
-    free(ctx);
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\gpu_matching.h" new_path="" added_lines="0" deleted_lines="33">
				<diff>@@ -1,33 +0,0 @@
-#ifndef _GPU_MATCHING_H_
-#define _GPU_MATCHING_H_
-
-#define CONV_THREAD 128
-#define TRANS_THREAD 512
-#define DISTANCE_TRANSFORM_STREAMS 64
-#define WARP_SIZE 32
-#define NUM_WARP (CONV_THREAD / WARP_SIZE)
-#define TRANS_RESULT_COUNT 64
-
-typedef struct
-{
-    int numSectors;     //number of sectors
-    int mapX;           //map sizeX * numSectors
-    int mapY;           //map sizeY
-    int filterX;        //filter sizeX * numSectors
-    int filterY;        //filter sizeY
-    int scoreX;         //mapX - filterX + 1
-    int scoreY;         //mapY - filterY + 1
-    int mapSize;        //mapX * mapY
-    int filterSize;     //filterX * filterY
-    int scoreSize;      //scoreX * scoreY
-} ConvolutionParam;
-
-typedef struct
-{
-    float internalDistTrans;
-    int internalPoints;
-    int v;
-    float z;
-} DistTransWork;
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\matching_gpu.cpp" new_path="" added_lines="0" deleted_lines="1137">
				<diff>@@ -1,1137 +0,0 @@
-#include &lt;stdio.h&gt;
-#include &lt;iostream&gt;
-#include &lt;opencv2/opencv.hpp&gt;
-#include &lt;opencv2/core/core.hpp&gt;
-
-#include "for_use_gpu.h"
-#include "drvapi_error_string.h"
-#include "cuda_check.h"
-
-#include "gpu_matching.h"
-#include "matching_gpu.hpp"
-
-// OpenCV non public functions
-extern int allocFeatureMapObject(CvLSVMFeatureMap **obj, const int sizeX, const int sizeY,
-                                const int p);
-
-#ifndef max
-#define max(a,b)            (((a) &gt; (b)) ? (a) : (b))
-#endif
-
-#ifndef min
-#define min(a,b)            (((a) &lt; (b)) ? (a) : (b))
-#endif
-
-/*
- // Calculate the size of scores.
- //
- // API
- // int calculationScoreSize(const CvLSVMFilterObject *filter,
- //        const CvLSVMFeatureMap *map, int *diffX, int *diffY);
- // INPUT
- // filter             - filter object
- // map                - feature map
- // OUTPUT
- // diffX              - diff between filter sizeX and map sizeX
- // diffY              - diff between filter sizeY and map sizeY
- // RESULT
- // Error status
- */
-static int calculationScoreSize(const CvLSVMFilterObject *filter,
-        const CvLSVMFeatureMap *map, int *diffX, int *diffY)
-{
-    if (map-&gt;sizeX &lt; filter-&gt;sizeX || map-&gt;sizeY &lt; filter-&gt;sizeY)
-    {
-        *diffX = 0;
-        *diffY = 0;
-        return LATENT_SVM_FAILED_SUPERPOSITION;
-    }
-
-    *diffX = map-&gt;sizeX - filter-&gt;sizeX + 1;
-    *diffY = map-&gt;sizeY - filter-&gt;sizeY + 1;
-    return LATENT_SVM_OK;
-}
-
-/*
- // Function for convolution computation in GPU
- //
- // API
- // int convolutionGPU(const CvLSVMFilterObject *filter,
- //        const CvLSVMFeatureMap *map, CUdeviceptr *dev_filter,
- //        CUdeviceptr *dev_map, CUdeviceptr *dev_filterIdxTbl,
- //        CUdeviceptr *dev_score, int filterIdx, CUstream stream);
- // INPUT
- // filter            - filter object
- // map               - feature map
- // dev_filter        - device filter object
- // dev_map           - device feature map
- // dev_filterIdxTbl  - device filter index table
- // OUTPUT
- // dev_score         - device score
- // RESULT
- // Error status
- */
-static int convolutionGPU(const CvLSVMFilterObject *filter,
-        const CvLSVMFeatureMap *map, CUdeviceptr *dev_filter,
-        CUdeviceptr *dev_map, CUdeviceptr *dev_filterIdxTbl,
-        CUdeviceptr *dev_score, int filterIdx, CUstream stream)
-{
-    int diffX, diffY, res, i;
-
-    res = calculationScoreSize(filter, map, &amp;diffX, &amp;diffY);
-
-    if (res == LATENT_SVM_OK)
-    {
-        ConvolutionParam prm;
-
-        CUresult res = cuMemAlloc(dev_score, (diffX * diffY) * sizeof(float));
-        CUDA_CHECK(res, "cuMemAlloc(dev_score): %zd bytes", (diffX * diffY) * sizeof(float));
-
-        prm.numSectors = map-&gt;numFeatures;
-        prm.mapX = map-&gt;sizeX * prm.numSectors;
-        prm.mapY = map-&gt;sizeY;
-        prm.filterX = filter-&gt;sizeX * prm.numSectors;
-        prm.filterY = filter-&gt;sizeY;
-        prm.scoreX = map-&gt;sizeX - filter-&gt;sizeX + 1;
-        prm.scoreY = map-&gt;sizeY - filter-&gt;sizeY + 1;
-        prm.mapSize = prm.mapX * prm.mapY;
-        prm.filterSize = prm.filterX * prm.filterY;
-        prm.scoreSize = prm.scoreX * prm.scoreY;
-
-        // compute indexes to access filter elements.
-        unsigned int filterIdxTbl[prm.filterSize];
-        for (i = 0; i &lt; prm.filterSize; i++)
-        {
-            filterIdxTbl[i] = (i / (prm.filterX)) * prm.mapX
-                    + (i % prm.filterX);
-        }
-
-        res = cuMemAlloc(dev_filterIdxTbl, prm.filterSize * sizeof(float));
-        CUDA_CHECK(res, "cuMemAlloc(dev_filterIdxTbl) %zd bytes", prm.filterSize * sizeof(float));
-
-        res = cuMemcpyHtoDAsync(*dev_filterIdxTbl, filterIdxTbl,
-                    prm.filterSize * sizeof(float), stream);
-        CUDA_CHECK(res, "cuMemcpyHtoDAsync(*dev_filterIdxTbl, filterIdxTbl) %zd bytes",
-                   prm.filterSize * sizeof(float));
-
-        void *kernel_arg[] =
-        { (void *) &amp;filterIdx, (void *) dev_score, (void *) dev_filterIdxTbl,
-                (void *) &amp;prm };
-
-        res = cuLaunchKernel(ConvolutionKernel_func[0], prm.scoreSize, 1, 1,
-                     CONV_THREAD, 1, 1, CONV_THREAD * sizeof(float), stream,
-                     kernel_arg, NULL);
-        CUDA_CHECK(res, "cuLaunchKernel(ConvolutionKernel)");
-    }
-
-    return res;
-}
-
-/*
- // Decision of two dimensional problem generalized distance transform
- // on the regular grid at all points in GPU
- //
- // API
- // int DistanceTransformTwoDimensionalProblemGPU(const CvLSVMFilterObject *filter,
- //       const CvLSVMFeatureMap *map, CUdeviceptr *dev_score,
- //       CUdeviceptr *dev_distTransWork, CUdeviceptr *dev_distTransScore,
- //       CUdeviceptr *dev_x, CUdeviceptr *dev_y, int diffX, int diffY,
- //       CUstream stream);
- // INPUT
- // filter             - filter object
- // map                - feature map
- // dev_score          - device score
- // dev_distTransWork  - device distance transform work space
- // diffX              - diff between filter sizeX and map sizeX
- // diffY              - diff between filter sizeY and map sizeY
- // stream             - CUDA stream
- // OUTPUT
- // dev_distTransScore - device distance transform score
- // dev_x              - device disposition x
- // dev_y              - device disposition y
- // RESULT
- // Error status
- */
-static int DistanceTransformTwoDimensionalProblemGPU(const CvLSVMFilterObject *filter,
-        const CvLSVMFeatureMap *map, CUdeviceptr *dev_score,
-        CUdeviceptr *dev_distTransWork, CUdeviceptr *dev_distTransScore,
-        CUdeviceptr *dev_x, CUdeviceptr *dev_y, int diffX, int diffY,
-        CUstream stream)
-{
-
-    void *kernel_arg[] =
-    { (void *) dev_score, (void *) &amp;diffX, (void *) &amp;diffY,
-            (void *) &amp;filter-&gt;fineFunction[0],
-            (void *) &amp;filter-&gt;fineFunction[1],
-            (void *) &amp;filter-&gt;fineFunction[2],
-            (void *) &amp;filter-&gt;fineFunction[3], (void *) dev_distTransWork,
-            (void *) dev_distTransScore, (void *) dev_x, (void *) dev_y };
-
-    CUresult res = cuLaunchKernel(DistanceTransformTwoDimensionalProblem_func[0], 1, 1, 1,
-                       TRANS_THREAD, 1, 1, 0, stream, kernel_arg, NULL);
-    CUDA_CHECK(res, "cuLaunchKernel(DistanceTransformTwoDimensionalProblem)");
-
-    return LATENT_SVM_OK;
-}
-
-/*
- // Calculate scores from the scores of each filter
- //
- // API
- // int sumScore(const CvLSVMFilterObject **all_F, const int n,
- //        const CvLSVMFeaturePyramid *H, const int level, const float b,
- //        const float scoreThreshold, const CvLSVMFilterDisposition disposition[],
- //        CUdeviceptr dev_score[], CvLSVMFeatureMap *map, float **score,
- //        CvPoint **points, int *kPoints, CvPoint ***partsDisplacement);
- // INPUT
- // all_F              - the set of filters
- //                      (the first element is root filter,the other - part filters)
- // n                  - the number of part filters
- // H                  - feature pyramid
- // level              - feature pyramid level for computation maximum score
- // b                  - linear term of the score function
- // scoreThreshold     - score threshold
- // disposition        - filter disposition
- // dev_score          - device score
- // map                - feature map
- // OUTPUT
- // score              - the maximum of the score function at the level
- // points             - the set of root filter positions (in the block space)
- // kpoints            - number of root filter positions
- // partsDisplacement  - displacement of part filters (in the block space)
- // RESULT
- // Error status
- */
-static int sumScore(const CvLSVMFilterObject **all_F, const int n,
-        const CvLSVMFeaturePyramid *H, const int level, const float b,
-        const float scoreThreshold, const CvLSVMFilterDisposition disposition[],
-        CUdeviceptr dev_score[], CvLSVMFeatureMap *map, float **score,
-        CvPoint **points, int *kPoints, CvPoint ***partsDisplacement)
-{
-    int i, j, k;
-    int index, last;
-    float sumScorePartDisposition;
-    int diffX, diffY, res;
-
-    res = calculationScoreSize(all_F[0], H-&gt;pyramid[level], &amp;diffX, &amp;diffY);
-
-    if (res != LATENT_SVM_OK)
-    {
-        return res;
-    }
-
-    sumScorePartDisposition = 0.0;
-
-    float root_score[diffX * diffY];
-    CUresult cu_res = cuMemcpyDtoH(root_score, dev_score[0], diffX * diffY * sizeof(float));
-    CUDA_CHECK(cu_res, "cuMemcpyDtoH(root_score, dev_score[0]): %zd bytes", diffX * diffY * sizeof(float));
-
-    cu_res = cuMemFree(dev_score[0]);
-    CUDA_CHECK(cu_res, "cuMemFree(dev_score[0]");
-
-    // The scores of hypothesis is given by the scores of each filter at
-    // their respective locations minus deformation cost plus the bias.
-    (*kPoints) = 0;
-    for (i = 0; i &lt; diffY; i++)
-    {
-        for (j = 0; j &lt; diffX; j++)
-        {
-            sumScorePartDisposition = 0.0;
-            for (k = 1; k &lt;= n; k++)
-            {
-                if ((2 * i + all_F[k]-&gt;V.y &lt; map-&gt;sizeY - all_F[k]-&gt;sizeY + 1)
-                        &amp;&amp; (2 * j + all_F[k]-&gt;V.x
-                                &lt; map-&gt;sizeX - all_F[k]-&gt;sizeX + 1))
-                {
-                    index = (2 * i + all_F[k]-&gt;V.y)
-                            * (map-&gt;sizeX - all_F[k]-&gt;sizeX + 1)
-                            + (2 * j + all_F[k]-&gt;V.x);
-                    sumScorePartDisposition += disposition[k - 1].score[index];
-                }
-            }
-            root_score[i * diffX + j] = root_score[i * diffX + j]
-                    - sumScorePartDisposition + b;
-            if (root_score[i * diffX + j] &gt; scoreThreshold)
-            {
-                (*kPoints)++;
-            }
-        }
-    }
-
-    // Store part displacements that its scores are higher than the threshold
-    (*points) = (CvPoint *) malloc(sizeof(CvPoint) * (*kPoints));
-    (*partsDisplacement) = (CvPoint **) malloc(sizeof(CvPoint *) * (*kPoints));
-    for (i = 0; i &lt; (*kPoints); i++)
-    {
-        (*partsDisplacement)[i] = (CvPoint *) malloc(sizeof(CvPoint) * n);
-    }
-    (*score) = (float *) malloc(sizeof(float) * (*kPoints));
-    last = 0;
-    for (i = 0; i &lt; diffY; i++)
-    {
-        for (j = 0; j &lt; diffX; j++)
-        {
-            if (root_score[i * diffX + j] &gt; scoreThreshold)
-            {
-                (*score)[last] = root_score[i * diffX + j];
-                (*points)[last].y = i;
-                (*points)[last].x = j;
-                for (k = 1; k &lt;= n; k++)
-                {
-                    if ((2 * i + all_F[k]-&gt;V.y
-                            &lt; map-&gt;sizeY - all_F[k]-&gt;sizeY + 1)
-                            &amp;&amp; (2 * j + all_F[k]-&gt;V.x
-                                    &lt; map-&gt;sizeX - all_F[k]-&gt;sizeX + 1))
-                    {
-                        index = (2 * i + all_F[k]-&gt;V.y)
-                                * (map-&gt;sizeX - all_F[k]-&gt;sizeX + 1)
-                                + (2 * j + all_F[k]-&gt;V.x);
-                        (*partsDisplacement)[last][k - 1].x =
-                                disposition[k - 1].x[index];
-                        (*partsDisplacement)[last][k - 1].y =
-                                disposition[k - 1].y[index];
-                    }
-                }
-                last++;
-            }
-        }
-    }
-    return LATENT_SVM_OK;
-}
-
-/*
- // Computation border size for feature map
- //
- // API
- // int computeBorderSize(int maxXBorder, int maxYBorder, int *bx, int *by);
- // INPUT
- // maxXBorder        - the largest root filter size (X-direction)
- // maxYBorder        - the largest root filter size (Y-direction)
- // OUTPUT
- // bx                - border size (X-direction)
- // by                - border size (Y-direction)
- // RESULT
- // Error status
- */
-int computeBorderSize(int maxXBorder, int maxYBorder, int *bx, int *by)
-{
-    *bx = (int) ceilf(((float) maxXBorder) / 2.0f + 1.0f);
-    *by = (int) ceilf(((float) maxYBorder) / 2.0f + 1.0f);
-    return LATENT_SVM_OK;
-}
-
-/*
- //
- // API
- // CvLSVMFeatureMap* featureMapBorderPartFilter(CvLSVMFeatureMap *map,
- //     int maxXBorder, int maxYBorder);
- // INPUT
- // map               - feature map
- // maxXBorder        - the largest root filter size (X-direction)
- // maxYBorder        - the largest root filter size (Y-direction)
- // OUTPUT
- // RESULT
- // new_map           - new map
- */
-CvLSVMFeatureMap* featureMapBorderPartFilter(CvLSVMFeatureMap *map,
-        int maxXBorder, int maxYBorder)
-{
-    int bx, by;
-    int sizeX, sizeY, i, j, k;
-    CvLSVMFeatureMap *new_map;
-
-    computeBorderSize(maxXBorder, maxYBorder, &amp;bx, &amp;by);
-    sizeX = map-&gt;sizeX + 2 * bx;
-    sizeY = map-&gt;sizeY + 2 * by;
-    allocFeatureMapObject(&amp;new_map, sizeX, sizeY, map-&gt;numFeatures);
-    for (i = 0; i &lt; sizeX * sizeY * map-&gt;numFeatures; i++)
-    {
-        new_map-&gt;map[i] = 0.0f;
-    }
-    for (i = by; i &lt; map-&gt;sizeY + by; i++)
-    {
-        for (j = bx; j &lt; map-&gt;sizeX + bx; j++)
-        {
-            for (k = 0; k &lt; map-&gt;numFeatures; k++)
-            {
-                new_map-&gt;map[(i * sizeX + j) * map-&gt;numFeatures + k] =
-                        map-&gt;map[((i - by) * map-&gt;sizeX + j - bx)
-                                * map-&gt;numFeatures + k];
-            }
-        }
-    }
-    return new_map;
-}
-
-/*
- //
- // API
- // void dispositionMalloc(const CvLSVMFilterObject *filter,
- //        const CvLSVMFeatureMap *map, CvLSVMFilterDisposition *disposition,
- //        int *maxSize);
- // INPUT
- // filter             - filter object
- // map                - feature map
- // OUTPUT
- // disposition        - filter disposition
- // maxSize            -
- // RESULT
- // Error status
- */
-static void dispositionMalloc(const CvLSVMFilterObject *filter,
-        const CvLSVMFeatureMap *map, CvLSVMFilterDisposition *disposition,
-        int *maxSize)
-{
-    int diffX, diffY, res;
-    res = calculationScoreSize(filter, map, &amp;diffX, &amp;diffY);
-    if (res == LATENT_SVM_OK)
-    {
-        disposition-&gt;size = diffX * diffY;
-        if (*maxSize &lt; disposition-&gt;size)
-        {
-            *maxSize = disposition-&gt;size;
-        }
-        disposition-&gt;score = (float *) malloc(
-                sizeof(float) * disposition-&gt;size);
-        disposition-&gt;x = (int *) malloc(sizeof(int) * disposition-&gt;size);
-        disposition-&gt;y = (int *) malloc(sizeof(int) * disposition-&gt;size);
-    }
-}
-
-/*
- //
- // API
- // void dispositionCpyDtoH(CUdeviceptr *dev_distTransScore, CUdeviceptr *dev_x,
- //        CUdeviceptr *dev_y, CvLSVMFilterDisposition *disposition,
- //        CvLSVMFilterDisposition *tmp_disposition, CUstream *stream);
- // INPUT
- // dev_distTransScore - device distance transform score
- // dev_x              - device disposition x
- // dev_y              - device disposition y
- // tmp_disposition    - MemAllocHost
- // stream             - CUDA stream
- // OUTPUT
- // disposition        - filter disposition
- // RESULT
- // none
- */
-static void dispositionCpyDtoH(CUdeviceptr *dev_distTransScore, CUdeviceptr *dev_x,
-        CUdeviceptr *dev_y, CvLSVMFilterDisposition *disposition,
-        CvLSVMFilterDisposition *tmp_disposition, CUstream *stream)
-{
-    // Copy data from the device to the host by using the page-locked memory
-    // with fast transfer rate, and copy from the page-locked memory to
-    // normal memory in the host.
-    CUresult res = cuMemcpyDtoHAsync(tmp_disposition-&gt;score, *dev_distTransScore,
-                      disposition-&gt;size * sizeof(float), stream[0]);
-    CUDA_CHECK(res, "cuMemcpyDtoHAsync(tmp_disposition-&gt;score, *dev_distTransScore): %zd bytes",
-               disposition-&gt;size * sizeof(float));
-    res = cuMemcpyDtoHAsync(tmp_disposition-&gt;x, *dev_x,
-                 disposition-&gt;size * sizeof(int), stream[1]);
-    CUDA_CHECK(res, "cuMemcpyDtoHAsync(tmp_disposition-&gt;x, *dev_x): %zd bytes",
-               disposition-&gt;size * sizeof(int));
-    res = cuMemcpyDtoHAsync(tmp_disposition-&gt;y, *dev_y,
-            disposition-&gt;size * sizeof(int), stream[2]);
-    CUDA_CHECK(res, "cuMemcpyDtoHAsync(tmp_disposition-&gt;y, *dev_y): %zd bytes",
-               disposition-&gt;size * sizeof(int));
-
-    res = cuStreamSynchronize(stream[0]);
-    CUDA_CHECK(res, "cuStreamSynchronize(stream[0])");
-
-    memcpy(disposition-&gt;score, tmp_disposition-&gt;score,
-            disposition-&gt;size * sizeof(float));
-    res = cuStreamSynchronize(stream[1]);
-    CUDA_CHECK(res, "cuStreamSynchronize(stream[1])");
-
-    memcpy(disposition-&gt;x, tmp_disposition-&gt;x, disposition-&gt;size * sizeof(int));
-    res = cuStreamSynchronize(stream[2]);
-    CUDA_CHECK(res, "cuStreamSynchronize(stream[2])");
-
-    memcpy(disposition-&gt;y, tmp_disposition-&gt;y, disposition-&gt;size * sizeof(int));
-}
-
-/*
- //
- // API
- // void dispositionFree(CvLSVMFilterDisposition *disposition);
- // INPUT
- // disposition - filter disposition
- // OUTPUT
- // none
- // RESULT
- // none
- */
-static void dispositionFree(CvLSVMFilterDisposition *disposition)
-{
-    free(disposition-&gt;score);
-    free(disposition-&gt;x);
-    free(disposition-&gt;y);
-}
-
-/*
- // Calculate root and part scores.
- //
- // API
- // void calculationScore(int numLevels, int n, const CvLSVMFeaturePyramid* H,
- //        const CvLSVMFilterObject** all_F, int *res, CvLSVMFeatureMap* map[],
- //        CUdeviceptr** dev_score);
- // INPUT
- // b                  - linear term of the score function
- // numLevels          -
- // n                  - the number of part filters
- // H                  - feature pyramid
- // all_F              - the set of filters
- //                      (the first element is root filter,the other - part filters)
- // res                - response
- // map                - feature map
- // OUTPUT
- // dev_score          - device score
- // RESULT
- // none
- */
-static void calculationScore(int numLevels, int n, const CvLSVMFeaturePyramid* H,
-        const CvLSVMFilterObject** all_F, int *res, CvLSVMFeatureMap* map[],
-        CUdeviceptr** dev_score)
-{
-    int i, j, k;
-    CUdeviceptr dev_filterIdxTbl[numLevels][n + 1];
-    CUdeviceptr dev_filter;
-    CUdeviceptr dev_map[2][numLevels];
-    CUstream convStreams[numLevels + 3];
-    int size[2][numLevels];
-    int filterSize[n + 1];
-    int filterIdx[n + 1];
-    int totalFilterSize;
-    int numSectors;
-    float* filters;
-
-#ifdef PROFILE
-    TickMeter tm;
-    cout &lt;&lt; "root start" &lt;&lt; endl;
-    tm.reset();
-    tm.start();
-#endif
-
-    numSectors = H-&gt;pyramid[0]-&gt;numFeatures;
-    for (i = 0; i &lt; numLevels + 3; i++)
-    {
-        CUresult cu_res = cuStreamCreate(&amp;convStreams[i], CU_STREAM_DEFAULT);
-        CUDA_CHECK(cu_res, "cuStreamCreate(&amp;convStreams[%d], CU_STREAM_DEFAULT)", i);
-    }
-    totalFilterSize = 0;
-    for (i = 0; i &lt; n + 1; i++)
-    {
-        filterIdx[i] = totalFilterSize;
-        filterSize[i] = all_F[i]-&gt;sizeX * all_F[i]-&gt;sizeY * numSectors;
-        totalFilterSize += filterSize[i];
-    }
-
-    CUresult cu_res = cuMemAlloc(&amp;dev_filter, totalFilterSize * sizeof(float));
-    CUDA_CHECK(cu_res, "cuMemAlloc(&amp;dev_filter): %zd bytes", totalFilterSize * sizeof(float));
-
-    filters = (float*) (malloc(totalFilterSize * sizeof(float)));
-    for (i = 0; i &lt; n + 1; i++)
-    {
-        memcpy(&amp;(filters[filterIdx[i]]), all_F[i]-&gt;H,
-                filterSize[i] * sizeof(float));
-    }
-
-    cu_res = cuMemcpyHtoD(dev_filter, filters, totalFilterSize * sizeof(float));
-    CUDA_CHECK(cu_res, "cuMemcpyHtoD(dev_filter, filters): %zd bytes", totalFilterSize * sizeof(float));
-
-    free(filters);
-    for (k = Lambda; k &lt; H-&gt;numLevels; k++)
-    {
-        j = k - Lambda;
-        // map size of root filter
-        size[0][j] = H-&gt;pyramid[k]-&gt;sizeX * H-&gt;pyramid[k]-&gt;sizeY * numSectors;
-        // map size of part filters
-        size[1][j] = map[j]-&gt;sizeX * map[j]-&gt;sizeY * numSectors;
-    }
-    CUtexref image_texMap;
-    cu_res = cuModuleGetTexRef(&amp;image_texMap, module[0], "texMap");
-    CUDA_CHECK(cu_res, "cuModuleGetTexRef(&amp;image_texMap)");
-    cu_res = cuTexRefSetFlags(image_texMap, CU_TRSF_READ_AS_INTEGER);
-    CUDA_CHECK(cu_res, "cuTexRefSetFlags(image_texMap)");
-    cu_res = cuTexRefSetFormat(image_texMap, CU_AD_FORMAT_FLOAT, 1);
-    CUDA_CHECK(cu_res, "cuTexRefSetFormat(image_texMap)");
-
-    CUtexref image_texFi;
-    cu_res = cuModuleGetTexRef(&amp;image_texFi, module[0], "texFi");
-    CUDA_CHECK(cu_res, "cuModuleGetTexRef(&amp;image_texFi)");
-    cu_res = cuTexRefSetFlags(image_texFi, CU_TRSF_READ_AS_INTEGER);
-    CUDA_CHECK(cu_res, "cuTexRefSetFlags(image_texFi)");
-    cu_res = cuTexRefSetFormat(image_texFi, CU_AD_FORMAT_FLOAT, 1);
-    CUDA_CHECK(cu_res, "cuTexRefSetFormat(image_texFi)");
-    cu_res = cuTexRefSetAddress(NULL, image_texFi, dev_filter,
-            totalFilterSize * sizeof(float));
-    CUDA_CHECK(cu_res, "cuTexRefSetAddress(image_texFi)");
-
-    // Transfer of root maps
-    for (k = Lambda; k &lt; H-&gt;numLevels; k++)
-    {
-        j = k - Lambda;
-
-        CUresult cu_res = cuMemAlloc(&amp;dev_map[0][j], size[0][j] * sizeof(float));
-        CUDA_CHECK(cu_res, "cuMemAlloc(&amp;dev_map[0][%d]): %zd bytes", j, size[0][j] * sizeof(float));
-
-        cu_res = cuMemcpyHtoDAsync(dev_map[0][j], H-&gt;pyramid[k]-&gt;map,
-                        size[0][j] * sizeof(float), convStreams[j]);
-        CUDA_CHECK(cu_res, "cuMemcpyHtoDAsync(dev_map[0][%d], H-&gt;pyramid[%d]-&gt;map): %zd bytes",
-                   j, k, size[0][j] * sizeof(float));
-    }
-
-    // Calculate root scores
-    for (k = Lambda; k &lt; H-&gt;numLevels; k++)
-    {
-        j = k - Lambda;
-
-        CUresult cu_res = cuStreamSynchronize(convStreams[0]);
-        CUDA_CHECK(cu_res, "cuStreamSynchronize(convStreams[0])");
-        cu_res = cuTexRefSetAddress(NULL, image_texMap, dev_map[0][j],
-                        size[0][j] * sizeof(float));
-        CUDA_CHECK(cu_res, "cuTexRefSetAddress(image_texMap)");
-        res[j] = convolutionGPU(all_F[0], H-&gt;pyramid[k], &amp;dev_filter,
-                &amp;dev_map[0][j], &amp;dev_filterIdxTbl[j][0], &amp;dev_score[j][0],
-                filterIdx[0], convStreams[0]);
-    }
-
-    cu_res = cuStreamSynchronize(convStreams[0]);
-    CUDA_CHECK(cu_res, "cuStreamSynchronize(convStreams[0])");
-
-#ifdef PROFILE
-    tm.stop();
-    cout &lt;&lt; "END root time = " &lt;&lt; tm.getTimeSec() &lt;&lt; " sec" &lt;&lt; endl;
-    cout &lt;&lt; "part start" &lt;&lt; endl;
-    tm.reset();
-    tm.start();
-#endif
-
-    for (k = Lambda; k &lt; H-&gt;numLevels; k++)
-    {
-        // Transfer of part maps
-        j = k - Lambda;
-
-        CUresult cu_res = cuMemAlloc(&amp;dev_map[1][j], size[1][j] * sizeof(float));
-        CUDA_CHECK(cu_res, "cuMemAlloc(&amp;dev_map[1][%d]): %zd bytes", j, size[1][j] * sizeof(float));
-        cu_res = cuMemcpyHtoDAsync(dev_map[1][j], map[j]-&gt;map,
-                        size[1][j] * sizeof(float), convStreams[numLevels + 2]);
-        CUDA_CHECK(cu_res, "cuMemcpyHtoDAsync(dev_map[1][%d], map[%d]-&gt;map): %zd bytes",
-                   j, j, size[1][j] * sizeof(float));
-        cu_res = cuStreamSynchronize(convStreams[numLevels + 2]);
-        CUDA_CHECK(cu_res, "cuStreamSynchronize(convStreams[%d])", numLevels + 2);
-        cu_res = cuTexRefSetAddress(NULL, image_texMap, dev_map[1][j],
-                        size[1][j] * sizeof(float));
-        CUDA_CHECK(cu_res, "cuTexRefSetAddress(image_texMap)");
-        // Calculate part scores
-        for (i = 0; i &lt; n; i++)
-        {
-            if (res[j] == LATENT_SVM_OK)
-            {
-                res[j] = convolutionGPU(all_F[i + 1], map[j], &amp;dev_filter,
-                        &amp;dev_map[1][j], &amp;dev_filterIdxTbl[j][i + 1],
-                        &amp;dev_score[j][i + 1], filterIdx[i + 1],
-                        convStreams[i + 1]);
-            }
-        }
-    }
-
-    for (i = 0; i &lt; n + 1; i++)
-    {
-        CUresult cu_res = cuStreamSynchronize(convStreams[i]);
-        CUDA_CHECK(cu_res, "cuStreamSynchronize(convStreams[%d])", i);
-    }
-    for (i = 0; i &lt; numLevels + 3; i++)
-    {
-        CUresult cu_res = cuStreamDestroy(convStreams[i]);
-        CUDA_CHECK(cu_res, "cuStreamDestroy(convStreams[%d])", i);
-    }
-
-    cuMemFree(dev_filter);
-    for (j = 0; j &lt; numLevels; j++)
-    {
-        CUresult cu_res = cuMemFree(dev_map[0][j]);
-        CUDA_CHECK(cu_res, "cuMemFree(dev_map[0][%d])", j);
-        cu_res = cuMemFree(dev_map[1][j]);
-        CUDA_CHECK(cu_res, "cuMemFree(dev_map[1][%d])", j);
-        for (i = 0; i &lt; n + 1; i++)
-        {
-            cu_res = cuMemFree(dev_filterIdxTbl[j][i]);
-            CUDA_CHECK(cu_res, "cuMemFree(dev_filterIdxTbl[%d][%d])", j, i);
-        }
-    }
-#ifdef PROFILE
-    tm.stop();
-    cout &lt;&lt; "END part time = " &lt;&lt; tm.getTimeSec() &lt;&lt; " sec" &lt;&lt; endl;
-#endif
-}
-
-/*
- // Distance transformation
- //
- // API
- // void distanceTransform(int numLevels, int n, int max_size,
- //        const CvLSVMFilterObject** all_F, CvLSVMFeatureMap* map[],
- //        CvLSVMFilterDisposition** disposition, CUdeviceptr** dev_score);
- // INPUT
- // numLevels          -
- // n                  - the number of part filters
- // max_size           - max cuMemAllocHost size
- // all_F              - the set of filters
- //                      (the first element is root filter,the other - part filters)
- // map                - feature map
- // dev_score          - device score
- // OUTPUT
- // disposition        - filter disposition
- // RESULT
- // none
- */
-static void distanceTransform(int numLevels, int n, int max_size,
-        const CvLSVMFilterObject** all_F, CvLSVMFeatureMap* map[],
-        CvLSVMFilterDisposition** disposition, CUdeviceptr** dev_score)
-{
-    CvLSVMFilterDisposition tmp_disposition;
-    CUstream ditTransStreams[DISTANCE_TRANSFORM_STREAMS];
-    CUdeviceptr dev_distTransScore[DISTANCE_TRANSFORM_STREAMS];
-    CUdeviceptr dev_x[DISTANCE_TRANSFORM_STREAMS];
-    CUdeviceptr dev_y[DISTANCE_TRANSFORM_STREAMS];
-    CUdeviceptr dev_distTransWork[DISTANCE_TRANSFORM_STREAMS];
-    int diffX, diffY, size;
-    int i, j, k, l;
-
-    for (i = 0; i &lt; DISTANCE_TRANSFORM_STREAMS; i++)
-    {
-        CUresult res = cuStreamCreate(&amp;ditTransStreams[i], CU_STREAM_DEFAULT);
-        CUDA_CHECK(res, "cuStreamCreate(&amp;ditTransStreams[%d], CU_STREAM_DEFAULT)", i);
-    }
-
-    CUresult res = cuMemAllocHost((void**) &amp;tmp_disposition.score, sizeof(float) * max_size);
-    CUDA_CHECK(res, "cuMemAllocHost(&amp;tmp_disposition.score): %zd bytes", sizeof(float) * max_size);
-    res = cuMemAllocHost((void**) &amp;tmp_disposition.x, sizeof(int) * max_size);
-    CUDA_CHECK(res, "cuMemAllocHost(&amp;tmp_disposition.x): %zd bytes", sizeof(int) * max_size);
-    res = cuMemAllocHost((void**) &amp;tmp_disposition.y, sizeof(int) * max_size);
-    CUDA_CHECK(res, "cuMemAllocHost(&amp;tmp_disposition.y): %zd bytes", sizeof(int) * max_size);
-
-    bool isNew = true;
-    for (j = 0; j &lt; n * numLevels; j++)
-    {
-        // Computation by dividing the number of streams and using 
-        // the same memory area of device for processing speed by
-        // reducing the number of calling cuMemFree function
-        l = j % DISTANCE_TRANSFORM_STREAMS;
-        k = j / n;
-        i = j % n;
-
-        calculationScoreSize(all_F[i + 1], map[k], &amp;diffX, &amp;diffY);
-        if (isNew == true)
-        {
-            size = (diffX + 1) * (diffY + 1);
-            CUresult res = cuMemAlloc(&amp;dev_distTransWork[l], sizeof(DistTransWork) * size);
-            CUDA_CHECK(res, "cuMemAlloc(&amp;dev_distTransWork[%d]): %zd bytes", l, sizeof(DistTransWork) * size);
-            res = cuMemAlloc(&amp;dev_distTransScore[l], sizeof(float) * size);
-            CUDA_CHECK(res, "cuMemAlloc(&amp;dev_distTransScore[%d]): %zd bytes", l, sizeof(float) * size);
-            res = cuMemAlloc(&amp;dev_x[l], sizeof(int) * size);
-            CUDA_CHECK(res, "cuMemAlloc(&amp;dev_x[%d]): %zd bytes", l, sizeof(int) * size);
-            res = cuMemAlloc(&amp;dev_y[l], sizeof(int) * size);
-            CUDA_CHECK(res, "cuMemAlloc(&amp;dev_y[%d]): %zd bytes", l, sizeof(int) * size);
-        }
-
-        DistanceTransformTwoDimensionalProblemGPU(all_F[i + 1], map[k],
-                &amp;dev_score[k][i + 1], &amp;dev_distTransWork[l],
-                &amp;dev_distTransScore[l], &amp;dev_x[l], &amp;dev_y[l], diffX, diffY,
-                ditTransStreams[l]);
-
-        if (l == DISTANCE_TRANSFORM_STREAMS - 1 || j == n * numLevels - 1)
-        {
-            isNew = false;
-
-            for (int m = 0; m &lt;= l; m++)
-            {
-                CUresult res = cuStreamSynchronize(ditTransStreams[m]);
-                CUDA_CHECK(res, "cuStreamSynchronize(ditTransStreams[%d])", m);
-                k = (j - l + m) / n;
-                i = (j - l + m) % n;
-                dispositionCpyDtoH(&amp;dev_distTransScore[m], &amp;dev_x[m], &amp;dev_y[m],
-                        &amp;disposition[k][i], &amp;tmp_disposition, ditTransStreams);
-            }
-        }
-    }
-
-    res = cuMemFreeHost(tmp_disposition.score);
-    CUDA_CHECK(res, "cuMemFreeHost(tmp_disposition.score)");
-    res = cuMemFreeHost(tmp_disposition.x);
-    CUDA_CHECK(res, "cuMemFreeHost(tmp_disposition.x)");
-    res = cuMemFreeHost(tmp_disposition.y);
-    CUDA_CHECK(res, "cuMemFreeHost(tmp_disposition.y)");
-
-    for (i = 0; i &lt; DISTANCE_TRANSFORM_STREAMS; i++)
-    {
-        CUresult res = cuStreamSynchronize(ditTransStreams[i]);
-        CUDA_CHECK(res, "cuStreamSynchronize(ditTransStreams[%d])", i);
-        res = cuStreamDestroy(ditTransStreams[i]);
-        CUDA_CHECK(res, "cuStreamDestroy(ditTransStreams[%d])", i);
-        res = cuMemFree(dev_distTransWork[i]);
-        CUDA_CHECK(res, "cuMemFree(dev_distTransWork[%d])", i);
-        res = cuMemFree(dev_distTransScore[i]);
-        CUDA_CHECK(res, "cuMemFree(dev_distTransScore[%d])", i);
-        res = cuMemFree(dev_x[i]);
-        CUDA_CHECK(res, "cuMemFree(dev_x[%d])", i);
-        res = cuMemFree(dev_y[i]);
-        CUDA_CHECK(res, "cuMemFree(dev_y[i])");
-    }
-    for (k = 0; k &lt; numLevels; k++)
-    {
-        for (i = 0; i &lt; n; i++)
-        {
-            CUresult res = cuMemFree(dev_score[k][i + 1]);
-            CUDA_CHECK(res, "cuMemFree(dev_score[%d][%d])", k, i + 1);
-        }
-    }
-}
-
-/*
- // Computation score function that exceed threshold
- //
- // API
- // int thresholdFunctionalScore(const CvLSVMFilterObject **all_F, int n,
- //        const CvLSVMFeaturePyramid *H, float b, CvLSVMFeatureMap *map[],
- //        float scoreThreshold, float **score, CvPoint **points, int **levels,
- //        int *kPoints, CvPoint ***partsDisplacement);
- // INPUT
- // all_F             - the set of filters
- //                     (the first element is root filter,the other - part filters)
- // n                 - the number of part filters
- // H                 - feature pyramid
- // b                 - linear term of the score function
- // maxXBorder        - the largest root filter size (X-direction)
- // maxYBorder        - the largest root filter size (Y-direction)
- // scoreThreshold    - score threshold
- // OUTPUT
- // score             - score function values that exceed threshold
- // points            - the set of root filter positions (in the block space)
- // levels            - the set of levels
- // kPoints           - number of root filter positions
- // partsDisplacement - displacement of part filters (in the block space)
- // RESULT
- // Error status
- */
-int thresholdFunctionalScore(const CvLSVMFilterObject **all_F, int n,
-        const CvLSVMFeaturePyramid *H, float b, CvLSVMFeatureMap *map[],
-        float scoreThreshold, float **score, CvPoint **points, int **levels,
-        int *kPoints, CvPoint ***partsDisplacement)
-{
-    int l, i, j, k, s, f, level, numLevels;
-    float **tmpScore;
-    CvPoint ***tmpPoints;
-    CvPoint ****tmpPartsDisplacement;
-    int *tmpKPoints;
-
-#ifdef PROFILE
-    TickMeter tm;
-    TickMeter all_tm;
-
-    cout &lt;&lt; "(matching.cpp)thresholdFunctionalScore START" &lt;&lt; endl &lt;&lt; "{"
-    &lt;&lt; endl;
-    all_tm.reset();
-    all_tm.start();
-#endif
-
-    // Computation the number of levels for seaching object,
-    // first lambda-levels are used for computation values
-    // of score function for each position of root filter
-    numLevels = H-&gt;numLevels - Lambda;
-
-    // Allocation memory for values of score function for each level
-    // that exceed threshold
-    tmpScore = (float **) malloc(sizeof(float*) * numLevels);
-    // Allocation memory for the set of points that corresponds
-    // to the maximum of score function
-    tmpPoints = (CvPoint ***) malloc(sizeof(CvPoint **) * numLevels);
-    for (i = 0; i &lt; numLevels; i++)
-    {
-        tmpPoints[i] = (CvPoint **) malloc(sizeof(CvPoint *));
-    }
-    // Allocation memory for memory for saving parts displacement on each level
-    tmpPartsDisplacement = (CvPoint ****) malloc(
-            sizeof(CvPoint ***) * numLevels);
-    for (i = 0; i &lt; numLevels; i++)
-    {
-        tmpPartsDisplacement[i] = (CvPoint ***) malloc(sizeof(CvPoint **));
-    }
-    // Number of points that corresponds to the maximum
-    // of score function on each level
-    tmpKPoints = (int *) malloc(sizeof(int) * numLevels);
-    for (i = 0; i &lt; numLevels; i++)
-    {
-        tmpKPoints[i] = 0;
-    }
-
-    (*kPoints) = 0;
-
-    CUdeviceptr **dev_score;
-
-    dev_score = (CUdeviceptr **) malloc(sizeof(CUdeviceptr *) * (numLevels));
-
-    for (i = 0; i &lt; numLevels; i++)
-    {
-        dev_score[i] = (CUdeviceptr *) malloc(sizeof(CUdeviceptr) * (n + 1));
-    }
-
-    CvLSVMFilterDisposition **disposition;
-    disposition = (CvLSVMFilterDisposition **) malloc(
-            sizeof(CvLSVMFilterDisposition *) * (numLevels));
-
-    for (i = 0; i &lt; numLevels; i++)
-    {
-        disposition[i] = (CvLSVMFilterDisposition *) malloc(
-                sizeof(CvLSVMFilterDisposition) * n);
-    }
-
-    int res[numLevels];
-
-    // Calculation root and part scores
-    calculationScore(numLevels, n, H, all_F, res, map, dev_score);
-
-#ifdef PROFILE
-    cout &lt;&lt; "dt start" &lt;&lt; endl;
-    tm.reset();
-    tm.start();
-#endif
-
-    // Computation distance transform
-    int max_size;
-    max_size = 0;
-    for (k = 0; k &lt; numLevels; k++)
-    {
-        for (i = 0; i &lt; n; i++)
-        {
-            dispositionMalloc(all_F[i + 1], map[k], &amp;disposition[k][i],
-                    &amp;max_size);
-        }
-    }
-    distanceTransform(numLevels, n, max_size, all_F, map, disposition,
-            dev_score);
-
-#ifdef PROFILE
-    tm.stop();
-    cout &lt;&lt; "END dt time = " &lt;&lt; tm.getTimeSec() &lt;&lt; " sec" &lt;&lt; endl;
-    cout &lt;&lt; "sum start" &lt;&lt; endl;
-    tm.reset();
-    tm.start();
-#endif
-
-    // Computation displacements that its scores are higher than the threshold
-    for (l = Lambda; l &lt; H-&gt;numLevels; l++)
-    {
-        k = l - Lambda;
-        if (res[k] == LATENT_SVM_OK)
-        {
-            res[k] = sumScore(all_F, n, H, l, b, scoreThreshold,
-                    &amp;disposition[k][0], &amp;dev_score[k][0], map[k],
-                    &amp;(tmpScore[k]), tmpPoints[k], &amp;(tmpKPoints[k]),
-                    tmpPartsDisplacement[k]);
-
-            if (res[k] == LATENT_SVM_OK)
-            {
-                (*kPoints) += tmpKPoints[k];
-            }
-        }
-    }
-
-    for (k = 0; k &lt; numLevels; k++)
-    {
-        for (i = 0; i &lt; n; i++)
-        {
-            dispositionFree(&amp;disposition[k][i]);
-
-        }
-    }
-
-    // Allocation memory for levels
-    (*levels) = (int *) malloc(sizeof(int) * (*kPoints));
-    // Allocation memory for the set of points
-    (*points) = (CvPoint *) malloc(sizeof(CvPoint) * (*kPoints));
-    // Allocation memory for parts displacement
-    (*partsDisplacement) = (CvPoint **) malloc(sizeof(CvPoint *) * (*kPoints));
-    // Allocation memory for score function values
-    (*score) = (float *) malloc(sizeof(float) * (*kPoints));
-
-    // Filling the set of points, levels and parts displacement
-    s = 0;
-    f = 0;
-    for (i = 0; i &lt; numLevels; i++)
-    {
-        // Computation the number of level
-        level = i + Lambda;
-
-        // Addition a set of points
-        f += tmpKPoints[i];
-        for (j = s; j &lt; f; j++)
-        {
-            (*levels)[j] = level;
-            (*points)[j] = (*tmpPoints[i])[j - s];
-            (*score)[j] = tmpScore[i][j - s];
-            (*partsDisplacement)[j] = (*(tmpPartsDisplacement[i]))[j - s];
-        }
-        s = f;
-    }
-
-    // Release allocated memory
-    for (i = 0; i &lt; numLevels; i++)
-    {
-        free(*tmpPoints[i]);
-        free(tmpPoints[i]);
-        free(*tmpPartsDisplacement[i]);
-        free(tmpPartsDisplacement[i]);
-        free(tmpScore[i]);
-        free(dev_score[i]);
-        free(disposition[i]);
-    }
-    free(tmpPoints);
-    free(tmpScore);
-    free(tmpKPoints);
-    free(tmpPartsDisplacement);
-    free(dev_score);
-    free(disposition);
-
-#ifdef PROFILE
-    tm.stop();
-    cout &lt;&lt; "END sum time = " &lt;&lt; tm.getTimeSec() &lt;&lt; " sec" &lt;&lt; endl;
-    all_tm.stop();
-    cout &lt;&lt; "}" &lt;&lt; endl &lt;&lt; "(matching.cpp)thresholdFunctionalScore END time = "
-    &lt;&lt; all_tm.getTimeSec() &lt;&lt; " sec" &lt;&lt; endl;
-#endif
-
-    return LATENT_SVM_OK;
-}
-
-/*
- //
- // API
- // static void sort(int n, const float* x, int* indices);
- // INPUT
- // n
- // x
- // OUTPUT
- // indices
- // RESULT
- // none
- */
-static void sort(int n, const float* x, int* indices)
-{
-    int i, j;
-    for (i = 0; i &lt; n; i++)
-        for (j = i + 1; j &lt; n; j++)
-        {
-            if (x[indices[j]] &gt; x[indices[i]])
-            {
-                int index_tmp = indices[i];
-                indices[i] = indices[j];
-                indices[j] = index_tmp;
-            }
-        }
-}
-
-/*
- // Perform non-maximum suppression algorithm (described in original paper)
- // to remove "similar" bounding boxes
- //
- // API
- // int nonMaximumSuppression(int numBoxes, const CvPoint *points,
- //        const CvPoint *oppositePoints, const float *score,
- //        float overlapThreshold, int *numBoxesOut, CvPoint **pointsOut,
- //        CvPoint **oppositePointsOut, float **scoreOut);
- // INPUT
- // numBoxes          - number of bounding boxes
- // points            - array of left top corner coordinates
- // oppositePoints    - array of right bottom corner coordinates
- // score             - array of detection scores
- // overlapThreshold  - threshold: bounding box is removed if overlap part
- //                     is greater than passed value
- // OUTPUT
- // numBoxesOut       - the number of bounding boxes algorithm returns
- // pointsOut         - array of left top corner coordinates
- // oppositePointsOut - array of right bottom corner coordinates
- // scoreOut          - array of detection scores
- // RESULT
- // Error status
- */
-int nonMaximumSuppression(int numBoxes, const CvPoint *points,
-        const CvPoint *oppositePoints, const float *score,
-        float overlapThreshold, int *numBoxesOut, CvPoint **pointsOut,
-        CvPoint **oppositePointsOut, float **scoreOut)
-{
-    int i, j, index;
-    float* box_area = (float*) malloc(numBoxes * sizeof(float));
-    int* indices = (int*) malloc(numBoxes * sizeof(int));
-    int* is_suppressed = (int*) malloc(numBoxes * sizeof(int));
-
-    for (i = 0; i &lt; numBoxes; i++)
-    {
-        indices[i] = i;
-        is_suppressed[i] = 0;
-        box_area[i] = (float) ((oppositePoints[i].x - points[i].x + 1)
-                * (oppositePoints[i].y - points[i].y + 1));
-    }
-    sort(numBoxes, score, indices);
-    for (i = 0; i &lt; numBoxes; i++)
-    {
-        if (!is_suppressed[indices[i]])
-        {
-            for (j = i + 1; j &lt; numBoxes; j++)
-            {
-                if (!is_suppressed[indices[j]])
-                {
-                    int x1max = max(points[indices[i]].x, points[indices[j]].x);
-                    int x2min =
-                            min(oppositePoints[indices[i]].x, oppositePoints[indices[j]].x);
-                    int y1max = max(points[indices[i]].y, points[indices[j]].y);
-                    int y2min =
-                            min(oppositePoints[indices[i]].y, oppositePoints[indices[j]].y);
-                    int overlapWidth = x2min - x1max + 1;
-                    int overlapHeight = y2min - y1max + 1;
-                    if (overlapWidth &gt; 0 &amp;&amp; overlapHeight &gt; 0)
-                    {
-                        float overlapPart = (overlapWidth * overlapHeight)
-                                / box_area[indices[j]];
-                        if (overlapPart &gt; overlapThreshold)
-                        {
-                            is_suppressed[indices[j]] = 1;
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    *numBoxesOut = 0;
-    for (i = 0; i &lt; numBoxes; i++)
-    {
-        if (!is_suppressed[i])
-            (*numBoxesOut)++;
-    }
-
-    *pointsOut = (CvPoint *) malloc((*numBoxesOut) * sizeof(CvPoint));
-    *oppositePointsOut = (CvPoint *) malloc((*numBoxesOut) * sizeof(CvPoint));
-    *scoreOut = (float *) malloc((*numBoxesOut) * sizeof(float));
-    index = 0;
-    for (i = 0; i &lt; numBoxes; i++)
-    {
-        if (!is_suppressed[indices[i]])
-        {
-            (*pointsOut)[index].x = points[indices[i]].x;
-            (*pointsOut)[index].y = points[indices[i]].y;
-            (*oppositePointsOut)[index].x = oppositePoints[indices[i]].x;
-            (*oppositePointsOut)[index].y = oppositePoints[indices[i]].y;
-            (*scoreOut)[index] = score[indices[i]];
-            index++;
-        }
-
-    }
-
-    free(indices);
-    free(box_area);
-    free(is_suppressed);
-
-    return LATENT_SVM_OK;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\matching_gpu.hpp" new_path="" added_lines="0" deleted_lines="14">
				<diff>@@ -1,14 +0,0 @@
-#ifndef _MATCHING_GPU_H_
-#define _MATCHING_GPU_H_
-
-#include "for_use_gpu.h"
-
-extern CvLSVMFeatureMap* featureMapBorderPartFilter(CvLSVMFeatureMap *map,
-        int maxXBorder, int maxYBorder);
-
-extern int thresholdFunctionalScore(const CvLSVMFilterObject **all_F, int n,
-        const CvLSVMFeaturePyramid *H, float b, CvLSVMFeatureMap *map[],
-        float scoreThreshold, float **score, CvPoint **points, int **levels,
-        int *kPoints, CvPoint ***partsDisplacement);
-
-#endif /* _MATCHING_GPU_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\resizeimg_gpu.cpp" new_path="" added_lines="0" deleted_lines="138">
				<diff>@@ -1,138 +0,0 @@
-#include &lt;stdio.h&gt;
-#include &lt;assert.h&gt;
-#include &lt;math.h&gt;
-#include &lt;iostream&gt;
-
-#include "for_use_gpu.h"
-#include "resizeimg_gpu.h"
-#include "cuda_check.h"
-
-using namespace cv;
-
-extern CUmodule *module;
-
-CUdeviceptr dev_image;
-char *image;
-
-int calculateWidthStep(int width, int channel, size_t bytes)
-{
-    int widthStep = width * channel * bytes;
-    int mod = widthStep % 4;
-
-    switch (mod)
-    {
-    case 0:
-        widthStep += 0;
-        break;
-    case 1:
-        widthStep += 3;
-        break;
-    case 2:
-        widthStep += 2;
-        break;
-    case 3:
-        widthStep += 1;
-        break;
-    default:
-        break;
-    }
-    return widthStep;
-}
-
-void uploadImageToGPU1D(IplImage* img)
-{
-    CUresult res;
-    CUtexref image_texref;
-    int width, height, nChannels, size_img;
-
-    width  = img-&gt;width;
-    height = img-&gt;height;
-    nChannels = img-&gt;nChannels;
-
-    size_img = width * height * nChannels;
-
-    res = cuMemAlloc(&amp;dev_image, sizeof(float) * size_img);
-    CUDA_CHECK(res, "cuMemAlloc(&amp;dev_image): %zd bytes", sizeof(float) * size_img);
-
-    res = cuMemcpyHtoD(dev_image, img-&gt;imageData, sizeof(float) * size_img);
-    CUDA_CHECK(res, "cuMemcpyHtoD(dev_image, img-&gt;imageData): %zd bytes", sizeof(float) * size_img);
-
-    res = cuModuleGetTexRef(&amp;image_texref, module[0], "texRef");
-    CUDA_CHECK(res, "cuModuleGetTexRef(&amp;image_texref)");
-
-    res = cuTexRefSetAddress(NULL, image_texref, dev_image,
-            sizeof(float) * size_img);
-    CUDA_CHECK(res, "cuTexRefSetAddress(image_texref)");
-
-    res = cuTexRefSetFlags(image_texref, CU_TRSF_READ_AS_INTEGER);
-    CUDA_CHECK(res, "cuTexRefSetFlags(image_texref)");
-
-    res = cuTexRefSetFormat(image_texref, CU_AD_FORMAT_FLOAT, 1);
-    CUDA_CHECK(res, "cuTexRefSetFormat(image_texref)");
-}
-
-void cleanImageFromGPU1D()
-{
-    CUresult res;
-
-    res = cuMemFree(dev_image);
-    CUDA_CHECK(res, "cuMemFree(dev_image)");
-}
-
-void resizeLaunchUsingTex(IplImage* img, float scale, size_t type,
-        CvLSVMFeatureMapGPU *dev_img, CUstream stream)
-{
-    int W, H, tW, tH;
-    int nChannels;
-    int widthStepIn, widthStepOut;
-    int thread_num_x, thread_num_y, thread_num_z;
-    int block_num_x, block_num_y, block_num_z;
-    int sharedMemBytes;
-    CUresult res;
-
-    W = img-&gt;width;
-    H = img-&gt;height;
-
-    tW = dev_img-&gt;sizeX;
-    tH = dev_img-&gt;sizeY;
-
-    nChannels = img-&gt;nChannels;
-
-    widthStepIn = img-&gt;widthStep;
-    widthStepOut = calculateWidthStep(tW, nChannels, sizeof(float));
-
-    void *kernel_arg[] =
-    { (void *) &amp;dev_img-&gt;map, (void *) &amp;W, (void *) &amp;H, (void *) &amp;tW,
-            (void *) &amp;tH, (void *) &amp;nChannels, (void *) &amp;widthStepIn,
-            (void *) &amp;widthStepOut };
-
-    thread_num_x = (tW &lt; sqrt(max_threads_num)) ? tW : sqrt(max_threads_num);
-    thread_num_y = (tH &lt; sqrt(max_threads_num)) ? tH : sqrt(max_threads_num);
-    thread_num_z = 1;
-    block_num_x = tW / thread_num_x;
-    block_num_y = tH / thread_num_y;
-    block_num_z = nChannels;
-    if (tW % thread_num_x != 0)
-        block_num_x++;
-    if (tH % thread_num_y != 0)
-        block_num_y++;
-
-    sharedMemBytes = 0;
-
-    res = cuLaunchKernel(BilinearKernelTex32F_func[0], block_num_x, block_num_y,
-            block_num_z, thread_num_x, thread_num_y, thread_num_z,
-            sharedMemBytes, stream, kernel_arg, NULL);
-    CUDA_CHECK(res, "cuLaunchKernel(BilinearKernelTex32F)");
-
-}
-
-void resizeGPUStream(const int numStep, IplImage* img, float* scale,
-        CvLSVMFeatureMapGPU **devs_img, CUstream *stream)
-{
-    for (int i = 0; i &lt; numStep; i++)
-    {
-        resizeLaunchUsingTex(img, scale[i], sizeof(float), devs_img[i],
-                stream[i]);
-    }
-}
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\resizeimg_gpu.h" new_path="" added_lines="0" deleted_lines="21">
				<diff>@@ -1,21 +0,0 @@
-#ifndef _RESIZEIMG_GPU_H_
-#define _RESIZEIMG_GPU_H_
-
-#include &lt;opencv2/opencv.hpp&gt;
-#include &lt;opencv2/core/core.hpp&gt;
-#include &lt;cuda.h&gt;
-#include "for_use_gpu.h"
-
-extern int calculateWidthStep(int width, int channel, size_t bytes);
-
-extern void uploadImageToGPU1D(IplImage* img);
-
-extern void cleanImageFromGPU1D();
-
-extern void resizeLaunchUsingTex(IplImage* img, float scale, size_t type,
-        CvLSVMFeatureMapGPU *dev_out, CUstream stream);
-
-extern void resizeGPUStream(const int numStep, IplImage* img, float* scale,
-        CvLSVMFeatureMapGPU **devs_img, CUstream *stream);
-
-#endif // _RESIZE_IMG_GPU_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\routine_gpu.cpp" new_path="" added_lines="0" deleted_lines="31">
				<diff>@@ -1,31 +0,0 @@
-#include "for_use_gpu.h"
-#include "routine_gpu.hpp"
-#include "cuda_check.h"
-
-// Add for gpu
-int freeFeatureMapObjectGPU(CvLSVMFeatureMapGPU **obj)
-{
-    CUresult res;
-    if (*obj == NULL)
-        return LATENT_SVM_MEM_NULL;
-    res = cuMemFree((*obj)-&gt;map);
-    CUDA_CHECK(res, "cuMemFree(map)");
-    free(*obj);
-    (*obj) = NULL;
-    return LATENT_SVM_OK;
-}
-
-int freeFeaturePyramidObjectGPU(CvLSVMFeaturePyramidGPU **obj)
-{
-    int i;
-    if (*obj == NULL)
-        return LATENT_SVM_MEM_NULL;
-    for (i = 0; i &lt; (*obj)-&gt;numLevels; i++)
-    {
-        freeFeatureMapObjectGPU(&amp;((*obj)-&gt;pyramid[i]));
-    }
-    free((*obj)-&gt;pyramid);
-    free(*obj);
-    (*obj) = NULL;
-    return LATENT_SVM_OK;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\gpu\routine_gpu.hpp" new_path="" added_lines="0" deleted_lines="11">
				<diff>@@ -1,11 +0,0 @@
-#ifndef _ROUTINE_GPU_H_
-#define _ROUTINE_GPU_H_
-
-int freeFeatureMapObjectGPU(CvLSVMFeatureMapGPU **obj);
-
-#ifdef __cplusplus
-extern "C"
-#endif
-int freeFeaturePyramidObjectGPU(CvLSVMFeaturePyramidGPU **obj);
-
-#endif /* _ROUTINE_GPU_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\libdpm_ocv\include\libdpm_ocv\dpm_ocv.hpp" new_path="" added_lines="0" deleted_lines="40">
				<diff>@@ -1,40 +0,0 @@
-#ifndef _DPM_OCV_H_
-#define _DPM_OCV_H_
-
-#include &lt;vector&gt;
-#include &lt;opencv2/core/core.hpp&gt;
-
-class DPMOCVCPULatentSvmDetector : public cv::LatentSvmDetector {
-private:
-    std::vector&lt;CvLatentSvmDetector*&gt; detectors; // this is private member in cv::LatentSvmDetector
-
-public:
-    DPMOCVCPULatentSvmDetector(const std::vector&lt;std::string&gt;&amp; filenames);
-    void detect( const cv::Mat&amp; image, std::vector&lt;ObjectDetection&gt;&amp; objectDetections,
-                 float overlapThreshold, int numThreads, double score_threshold,
-                 int lambda, int num_cells, int num_bins);
-
-    bool empty() const;
-};
-
-class DPMOCVGPULatentSvmDetector : public cv::LatentSvmDetector {
-private:
-// this is private member in cv::LatentSvmDetector
-    std::vector&lt;CvLatentSvmDetector*&gt; detectors;
-    std::vector&lt;std::string&gt; classNames;
-
-public:
-    explicit DPMOCVGPULatentSvmDetector(const std::vector&lt;std::string&gt;&amp; filenames,
-        const float scoreThreshold);
-    ~DPMOCVGPULatentSvmDetector();
-
-    bool load( const std::vector&lt;std::string&gt;&amp; filenames, const float scoreThreshold );
-    void detect(const cv::Mat&amp; image,
-        std::vector&lt;ObjectDetection&gt;&amp; objectDetections, float overlapThreshold,
-        int numThreads, const unsigned int lambda,
-        const unsigned int sideLength, const float valOfTruncate);
-
-    bool empty() const;
-};
-
-#endif /* _DPM_OCV_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\librcnn\include\rcnn_detector.h" new_path="" added_lines="0" deleted_lines="128">
				<diff>@@ -1,128 +0,0 @@
-#ifndef RCNN_DETECTOR_H_
-#define RCNN_DETECTOR_H_
-
-#include &lt;opencv2/core/core.hpp&gt;
-#include &lt;opencv2/contrib/contrib.hpp&gt;
-#include &lt;opencv2/highgui/highgui.hpp&gt;
-
-#include &lt;iostream&gt;
-#include &lt;stdio.h&gt;
-#include &lt;vector&gt;
-
-#include &lt;sstream&gt;
-#include &lt;string&gt;
-#include &lt;algorithm&gt;
-
-#include "rect_class_score.h"
-
-#include "caffe/caffe.hpp"
-
-
-namespace Rcnn
-{
-	enum RcnnDetectorClasses
-	{
-		BACKGROUND,
-		PLANE, BICYCLE, BIRD, BOAT,
-		BOTTLE, BUS, CAR, CAT, CHAIR,
-		COW, TABLE, DOG, HORSE,
-		MOTORBIKE, PERSON, PLANT,
-		SHEEP, SOFA, TRAIN, TV, NUM_CLASSES
-	};
-}
-
-class RcnnDetector
-{
-	int counter_;
-	//pointer to Caffe neural net object
-	caffe::Net&lt;float&gt;* 			net_;
-	//pointer to BlobProto to store the Generated Proposals
-	caffe::BlobProto* 			rois_blob_proto_;
-	//BGR color pixel mean to subtract during pre processing
-	cv::Scalar 					pixel_mean_;
-	//number of times to slices the image to generate proposals
-	unsigned int 				image_slices_;
-	//sets if the network is loaded and ready
-	/**
-	* @brief Generate Object proposals to feed the ConvNet
-	*
-	* The proposals' size is decided based on the image dimensions,
-	* slices sets how many regions horizontally and vertically will be
-	* created. Increasing this value, might improve detection but it
-	* will impact performance.
-	*/
-	std::vector&lt; cv::Scalar &gt; GenerateProposals(unsigned int width,
-												unsigned int height,
-												unsigned int slices = 16,
-												float in_box_overlap = 0.7);
-
-	/**
-	* @brief Pre process the image before feeding it to the ConvNet
-	*
-	* Subtracts the color pixel mean to the image, use SetPixelMean to change the default value
-	*/
-	void PreProcessImage(cv::Mat&amp; in_image, cv::Mat&amp; out_image);
-
-	/**
-	* @brief Converts an OpenCV Mat to Caffe BlobProto
-	*
-	* Fills a BlobProto out_blob object from an OpenCV Mat, so it can be fed into the network
-	*/
-	void ConvertImageToBlob(cv::Mat&amp; in_image, caffe::BlobProto&amp; out_blob);
-
-	/**
-	* @brief Converts a vector of scalars to Caffe BlobProto
-	*
-	* Fills a BlobProto out_blob object from a vector of scalars, so it can be fed into the network
-	*/
-	void ConvertRoisToBlob(std::vector&lt; cv::Scalar  &gt;&amp; in_proposals, caffe::BlobProto&amp; out_blob);
-
-	/**
-	* @brief Generates Class Scored Rectangles of the ROIS input proposals
-	*
-	*/
-	std::vector&lt; RectClassScore&lt;float&gt; &gt; GetRectClassesScored(std::vector&lt; cv::Scalar &gt;&amp; in_proposals,
-								const std::vector&lt;unsigned int&gt;&amp; in_classes,
-								float in_score_threshold,
-								const float* in_boxes,
-								const float* in_probabilities,
-								unsigned int width,
-								unsigned int height);
-
-	/**
-	 * @brief Apply non maximum suppresion to the detections
-	 */
-	std::vector&lt; RectClassScore&lt;float&gt; &gt; ApplyNonMaximumSuppresion(std::vector&lt; RectClassScore&lt;float&gt; &gt; in_source, float in_nms_threshold);
-
-	bool CheckClasses(unsigned int in_class, const std::vector&lt;unsigned int&gt;&amp; in_classes);
-
-public:
-	/**
-	* @brief FastRCNN Constructor, creates the Caffe network,  loads the definition(.proto) and pretrained model(.caffemodel), also sets GPU mode and  Device ID
-	*/
-	RcnnDetector(std::string&amp; network_definition_file,
-					std::string&amp; pre_trained_model_file,
-					bool use_gpu = true,
-					unsigned int gpu_id = 0);
-
-	/**
-	* @brief Starts detection of the 21 classes on an image, using the parameters
-	*/
-	std::vector&lt; RectClassScore&lt;float&gt; &gt; Detect(cv::Mat&amp; in_image,
-											const std::vector&lt;unsigned int&gt;&amp; in_classes,
-											float in_threshold = 0.7,
-											unsigned int in_slices=16,
-											float in_box_overlap = 0.7,
-											float in_nms_threshold = 0.3);
-
-	void Sort(const std::vector&lt;float&gt; in_scores, std::vector&lt;unsigned int&gt;&amp; in_out_indices);
-
-	/**
-	* @brief Changes the default pixel mean used by PreProcessImage
-	*/
-	inline void SetPixelMean(cv::Scalar new_pixel_mean) { pixel_mean_ = new_pixel_mean; }
-};
-
-
-
-#endif /* RCNN_DETECTOR_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\librcnn\src\rcnn_detector.cpp" new_path="" added_lines="0" deleted_lines="405">
				<diff>@@ -1,405 +0,0 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "rcnn_detector.h"
-
-//#define _TIMEPROCESS
-
-RcnnDetector::RcnnDetector(std::string&amp; in_network_definition_file, std::string&amp; in_pre_trained_model_file,
-							bool in_use_gpu, unsigned int in_gpu_id)
-{
-	//Create Net based on RCNN model
-	net_ = new caffe::Net&lt;float&gt;(in_network_definition_file, caffe::TEST);
-
-	//If GPU mode is selected, set the GPU device ID if provided
-	if (in_use_gpu)
-	{
-		caffe::Caffe::set_mode(caffe::Caffe::GPU);
-		caffe::Caffe::SetDevice(in_gpu_id);
-	}
-	pixel_mean_ = cv::Scalar(102.9801, 115.9465, 122.7717);
-	image_slices_ = 16;
-	rois_blob_proto_ = NULL;
-
-	//Load Pre trained model
-	net_-&gt;CopyTrainedLayersFrom(in_pre_trained_model_file);
-
-	counter_ = 0;
-}
-
-std::vector&lt; cv::Scalar &gt; RcnnDetector::GenerateProposals(unsigned int in_width, unsigned int in_height, unsigned int in_slices, float in_box_overlap)
-{
-	std::vector&lt; cv::Scalar &gt; proposals;
-	unsigned int step_y = int(in_height/in_slices) + 1;
-	unsigned int step_x = int(in_width*in_box_overlap/in_slices) + 1;
-
-	for (unsigned int y = step_y*2; y&lt;=(in_height - step_y*2); y+=step_y*2)//create proposals starting after the first slice in Y until penultimate
-	{
-		for (unsigned int x = 0; x&lt;=in_width; x+=step_x)
-		{
-			proposals.push_back(cv::Scalar(x, y, step_x+x, step_y+y));//smallest subwindow
-
-			//tall objects
-			proposals.push_back(cv::Scalar(x, y, step_x+x, step_y*2+y));
-
-			//wider objects
-			//proposals.push_back(cv::Scalar(x, y, step_x*2+x, step_y+y));
-			//proposals.push_back(cv::Scalar(x, y, step_x*4+x, step_y+y));
-
-			//squared
-			for (unsigned int z = 2; z &lt;=in_slices; z+=2)
-			{
-				unsigned int w = step_x*z+x,
-							h = step_y*z+y;
-				if ((x+w) &lt;= (in_width+step_x) || (y+h) &lt;= (in_height+ step_y))
-				{
-					proposals.push_back(cv::Scalar(x, y, w, h));
-				}
-			}
-			/*proposals.push_back(cv::Scalar(x, y, step_x*2+x, step_y*2+y));
-			proposals.push_back(cv::Scalar(x, y, step_x*4+x, step_y*4+y));
-			proposals.push_back(cv::Scalar(x, y, step_x*8+x, step_y*8+y));
-			proposals.push_back(cv::Scalar(x, y, step_x*16+x, step_y*16+y));*/
-		}
-	}
-
-	return proposals;
-}
-
-void RcnnDetector::PreProcessImage(cv::Mat&amp; in_image, cv::Mat&amp; out_image)
-{
-	//convert image to float
-	in_image.convertTo(out_image,CV_32FC3);
-	//create a mat full of means
-	cv::Mat mean(in_image.rows,in_image.cols,CV_32FC3, pixel_mean_);
-	//subtract images to get subtracted
-	out_image -= mean;
-}
-
-void RcnnDetector::ConvertImageToBlob(cv::Mat&amp; in_image, caffe::BlobProto&amp; out_blob)
-{
-	out_blob.set_num(1);							//only 1 image
-	out_blob.set_channels(in_image.channels());		//channels
-	out_blob.set_height(in_image.rows);				//height
-	out_blob.set_width(in_image.cols);				//width
-
-	unsigned int img_channels = in_image.channels();
-	unsigned int img_total = in_image.total();
-	//OpenCV Data is stored in BGR
-	//RE ORDER PIXEL DATA FROM [(BGR)(BGR)(BGR)...(BGR)]   =&gt; [(BBB)..(BBB) (GGG)..(GGG) (RRR)..(RRR)]
-	for(unsigned int j = 0; j &lt; img_channels; j++)						//do as manychannels as we have (in our tests 3)
-	{
-		for (unsigned int i = j; i &lt; img_total; i++)
-		{
-			out_blob.add_data(((float*)(in_image.data))[i*img_channels]);// slide through each channel
-		}
-	}
-}
-
-void RcnnDetector::ConvertRoisToBlob(std::vector&lt; cv::Scalar &gt;&amp; in_rois, caffe::BlobProto&amp; out_blob)
-{
-	out_blob.set_num((int)in_rois.size());	//number of ROIS
-	out_blob.set_channels(5);				//depth, always 5 (0, x1, y1, x2,y2)
-	out_blob.set_height(1);				//one vector vector
-	out_blob.set_width(1);					//one column vector
-
-	for (unsigned int i = 0; i &lt; in_rois.size(); ++i)
-	{
-		for (unsigned int j = 0; j &lt; 4; ++j)
-		{
-			if (j == 0)
-				out_blob.add_data(0.0f);	//append a 0 as the first column
-			out_blob.add_data( (float) ((cv::Scalar)(in_rois)[i]).val[j] );
-		}
-	}
-}
-
-bool RcnnDetector::CheckClasses(unsigned int in_class, const std::vector&lt;unsigned int&gt;&amp; in_classes)
-{
-	for (unsigned int i = 0; i&lt; in_classes.size(); i++)
-	{
-		if(in_classes[i] == in_class)
-			return true;
-	}
-	return false;
-}
-
-std::vector&lt; RectClassScore&lt;float&gt; &gt; RcnnDetector::GetRectClassesScored(std::vector&lt; cv::Scalar &gt;&amp; in_proposals,
-										const std::vector&lt;unsigned int&gt;&amp; in_classes,
-										float in_score_threshold,
-										const float* in_boxes, const float* in_probabilities,
-										unsigned int in_width, unsigned int in_height)
-{
-	std::vector&lt; RectClassScore&lt;float&gt; &gt; out_boxes;
-	for (unsigned int j=0, k=0;j&lt;in_proposals.size();j++)//repeat for each proposal
-	{
-		float x,y,w,h;
-		x = ((cv::Scalar)(in_proposals)[j]).val[0];
-		y = ((cv::Scalar)(in_proposals)[j]).val[1];
-		w = ((cv::Scalar)(in_proposals)[j]).val[2] - ((cv::Scalar)(in_proposals)[j]).val[0];
-		h = ((cv::Scalar)(in_proposals)[j]).val[3] - ((cv::Scalar)(in_proposals)[j]).val[1];
-		for (int i = 0, m=0; i &lt; Rcnn::NUM_CLASSES*4; i+=4, k++, m++)//repeat for all 21 classes			// four points on each rect
-		{
-			if ( (in_probabilities[k] &gt;=in_score_threshold) &amp;&amp; CheckClasses(m, in_classes))//check if the class is being searched, otherwise do not add the detection
-			{
-				int index = j*Rcnn::NUM_CLASSES*4 + i;
-				//[0] = X1; [1] = Y1; [2] = W; [3] = H
-				float dx,dy,dw,dh;
-				dx = in_boxes[index];	//cout &lt;&lt; dx &lt;&lt; ", ";
-				dy = in_boxes[index+1]; //cout &lt;&lt; dy &lt;&lt; ", ";
-				dw = in_boxes[index+2]; //cout &lt;&lt; dw &lt;&lt; ", ";
-				dh = in_boxes[index+3]; //cout &lt;&lt; dh &lt;&lt; endl;
-
-				float pred_w = exp(dw)*w;
-				float pred_h = exp(dh)*h;
-				float new_x = dx*w + (x+0.5*w) - 0.5*pred_w;
-				float new_y = dy*h + (y+0.5*h) - 0.5*pred_h;
-
-				//clip boxes
-				/*new_x = (new_x &gt;= 0 ? new_x: 0);
-				new_x = (new_x &lt;= in_width ? new_x: in_width-1);
-
-				new_y = (new_y &gt;= 0 ? new_y : 0);
-				new_y = (new_y &lt;= in_height ? new_y: in_height-1);*/
-
-				RectClassScore&lt;float&gt; tmp_rect;
-				tmp_rect.x = new_x;
-				tmp_rect.y = new_y;
-				tmp_rect.w = pred_w;//(new_x + pred_w &gt; in_width) ? in_width-1: pred_w;
-				tmp_rect.h = pred_h;//(new_y + pred_h &gt; in_height) ? in_height-1: pred_h;
-				tmp_rect.score = in_probabilities[k];
-				tmp_rect.class_type = m;
-				tmp_rect.enabled = true;
-
-				out_boxes.push_back(tmp_rect);
-
-			}
-		}
-	}
-	return out_boxes;
-}
-
-std::vector&lt; RectClassScore&lt;float&gt; &gt;
-	RcnnDetector::Detect(cv::Mat&amp; in_image,
-						const std::vector&lt;unsigned int&gt;&amp; in_classes,
-						float in_score_threshold,
-						unsigned int in_slices,
-						float in_box_overlap,
-						float in_nms_threshold)
-{
-	/////IMAGE INPUT 'data'
-	//pre process image
-	cv::Mat float_image;
-#ifdef _TIMEPROCESS
-	cv::TickMeter timer;
-	timer.start();
-#endif
-
-	PreProcessImage(in_image, float_image);
-
-#ifdef _TIMEPROCESS
-	timer.stop();
-	float t_preprocess = timer.getTimeMilli();
-	timer.reset(); timer.start();
-	timer.start();
-#endif
-
-	std::vector&lt; cv::Scalar &gt; proposals = GenerateProposals(float_image.cols, float_image.rows, in_slices, in_box_overlap);
-
-#ifdef _TIMEPROCESS
-	timer.stop();
-	float t_proposal = timer.getTimeMilli();
-	timer.reset(); timer.start();
-#endif
-
-	caffe::Blob&lt;float&gt;* input_image_blob = net_-&gt;input_blobs()[0];	//Get pointer to image input blob [0] image input (defined by net)
-	input_image_blob-&gt;Reshape(	1, 									//sending only 1 image
-								float_image.channels(),				//blob's number of channels
-								float_image.rows, 					//blob's width
-								float_image.cols					//blob's height
-								);									//reshape input layer so it to matches the image
-
-	caffe::BlobProto image_blob_proto;
-
-	ConvertImageToBlob(float_image, image_blob_proto);				//convert float image to blob
-	input_image_blob-&gt;FromProto(image_blob_proto);					//set data into 'data' layer
-
-	/////PROPOSALS INPUT 'rois'
-	caffe::Blob&lt;float&gt;* input_rois_blob = net_-&gt;input_blobs()[1];	//[0]data (image), [1]rois (proposals)
-
-
-	caffe::BlobProto rois_blob_proto;
-	ConvertRoisToBlob(proposals, rois_blob_proto);
-	//GenerateBlobProposals(float_image.cols, float_image.rows, in_slices);	//generate proposals 1st time
-	input_rois_blob-&gt;FromProto(rois_blob_proto);							//set data into 'data' layer
-
-	//FORWARD the network
-	std::vector&lt;caffe::Blob&lt;float&gt;*&gt; input;
-	input.push_back( input_image_blob );
-	input.push_back( input_rois_blob );
-
-#ifdef _TIMEPROCESS
-	timer.stop();
-	float t_datapreparation = timer.getTimeMilli();
-	timer.reset(); timer.start();
-#endif
-
-	net_-&gt;Forward( input ); //Forward the Network////////////////
-
-#ifdef _TIMEPROCESS
-	timer.stop();
-	float t_fwd = timer.getTimeMilli();
-	timer.reset(); timer.start();
-#endif
-	//check output
-	const boost::shared_ptr&lt;caffe::Blob&lt;float&gt; &gt;&amp; class_probability_layer = net_-&gt;blob_by_name("cls_prob");
-	const boost::shared_ptr&lt;caffe::Blob&lt;float&gt; &gt;&amp; bounding_box_predicted_layer = net_-&gt;blob_by_name("bbox_pred");
-
-	//convert to rects
-	const float* class_probability_data = class_probability_layer-&gt;cpu_data();
-	const float* bounding_box_predicted_data = bounding_box_predicted_layer-&gt;cpu_data();
-
-	std::vector&lt; RectClassScore&lt;float&gt; &gt; detections;
-	if ((unsigned int)bounding_box_predicted_layer-&gt;count() == proposals.size()*Rcnn::NUM_CLASSES*4)//4 points for each of the 21 classes
-	{
-		detections = GetRectClassesScored(proposals, in_classes, in_score_threshold, bounding_box_predicted_data, class_probability_data, float_image.cols, float_image.rows);
-
-		detections = ApplyNonMaximumSuppresion(detections, in_nms_threshold);
-	}
-	else
-		std::cout &lt;&lt; "Wrong output size:" &lt;&lt; class_probability_layer-&gt;count() &lt;&lt; ", expecting " &lt;&lt; proposals.size()*Rcnn::NUM_CLASSES*4; std::cout &lt;&lt; std::endl;
-
-#ifdef _TIMEPROCESS
-	timer.stop();
-	float t_out = timer.getTimeMilli();
-	std::cout &lt;&lt; t_preprocess &lt;&lt; "," &lt;&lt; t_proposal &lt;&lt; ","&lt;&lt;  t_datapreparation &lt;&lt; "," &lt;&lt; t_fwd &lt;&lt; "," &lt;&lt; t_out &lt;&lt; std::endl;
-#endif
-
-
-	return detections;
-}
-
-std::vector&lt; RectClassScore&lt;float&gt; &gt; RcnnDetector::ApplyNonMaximumSuppresion(std::vector&lt; RectClassScore&lt;float&gt; &gt; in_source, float in_nms_threshold)
-{
-	std::vector&lt; RectClassScore&lt;float&gt; &gt; tmp_source = in_source;
-
-	if (tmp_source.empty())
-		return std::vector&lt;RectClassScore&lt;float&gt; &gt;();
-
-	unsigned int size = in_source.size();
-
-	std::vector&lt;float&gt; area(size);
-	std::vector&lt;float&gt; scores(size);
-	std::vector&lt;int&gt; x1(size);
-	std::vector&lt;int&gt; y1(size);
-	std::vector&lt;int&gt; x2(size);
-	std::vector&lt;int&gt; y2(size);
-	std::vector&lt;unsigned int&gt; indices(size);
-	std::vector&lt;bool&gt; is_suppresed(size);
-
-	for(unsigned int i = 0; i&lt; in_source.size(); i++)
-	{
-		RectClassScore&lt;float&gt; tmp = in_source[i];
-		area[i] = tmp.w * tmp.h;
-		indices[i] = i;
-		is_suppresed[i] = false;
-		scores[i] = tmp.score;
-		x1[i] = tmp.x;
-		y1[i] = tmp.y;
-		x2[i] = tmp.w + tmp.x;
-		y2[i] = tmp.h + tmp.y;
-	}
-
-	Sort(scores, indices);//returns indices ordered based on scores
-
-	for(unsigned int i=0; i&lt; size; i++)
-	{
-		if(!is_suppresed[indices[i]])
-		{
-			for(unsigned int j= i+1; j&lt; size; j++)
-			{
-				int x1_max = std::max(x1[indices[i]], x1[indices[j]]);
-				int x2_min = std::min(x2[indices[i]], x2[indices[j]]);
-				int y1_max = std::max(y1[indices[i]], y1[indices[j]]);
-				int y2_min = std::min(y2[indices[i]], y2[indices[j]]);
-				int overlap_width = x2_min - x1_max + 1;
-				int overlap_height = y2_min - y1_max + 1;
-				if(overlap_width &gt; 0 &amp;&amp; overlap_height&gt;0)
-				{
-					float overlap_part = (overlap_width*overlap_height)/area[indices[j]];
-					if(overlap_part &gt; in_nms_threshold)
-					{
-						is_suppresed[indices[j]] = true;
-					}
-				}
-			}
-		}
-	}
-
-	unsigned int size_out = 0;
-	for (unsigned int i = 0; i &lt; size; i++)
-	{
-		if (!is_suppresed[i])
-			size_out++;
-	}
-
-	std::vector&lt; RectClassScore&lt;float&gt; &gt; filtered_detections(size_out);
-
-	unsigned int index = 0;
-	for(unsigned int i = 0 ; i &lt; size_out; i++)
-	{
-		if(!is_suppresed[indices[i]])
-		{
-			filtered_detections[index].x = in_source[indices[i]].x;//x1[indices[i]];
-			filtered_detections[index].y = in_source[indices[i]].y;//y1[indices[i]];
-			filtered_detections[index].w = in_source[indices[i]].w;//x2[indices[i]] - x1[indices[i]];
-			filtered_detections[index].h = in_source[indices[i]].h;//y2[indices[i]] - y1[indices[i]];
-			filtered_detections[index].class_type = in_source[indices[i]].class_type;
-			filtered_detections[index].score = in_source[indices[i]].score;
-			index++;
-		}
-	}
-	return filtered_detections;
-}
-
-void RcnnDetector::Sort(const std::vector&lt;float&gt; in_scores, std::vector&lt;unsigned int&gt;&amp; in_out_indices)
-{
-	for (unsigned int i = 0; i &lt; in_scores.size(); i++)
-		for (unsigned int j = i + 1; j &lt; in_scores.size(); j++)
-		{
-			if (in_scores[in_out_indices[j]] &gt; in_scores[in_out_indices[i]])
-			{
-				std::swap(in_out_indices[i], in_out_indices[j]);
-				/*int index_tmp = in_out_indices[i];
-				in_out_indices[i] = in_out_indices[j];
-				in_out_indices[j] = index_tmp;*/
-			}
-		}
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\includes\Cluster.h" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\include\cluster.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\kf\include\gencolors.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\include\gencolors.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\includes\gpu_euclidean_clustering.h" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\include\gpu_euclidean_clustering.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\Cluster.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\cluster.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -5,7 +5,7 @@
  *      Author: Ne0
  */
 
-#include "Cluster.h"
+#include "cluster.h"
 
 Cluster::Cluster()
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\gpu_euclidean_clustering.cu" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\gpu_euclidean_clustering.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -75,7 +75,7 @@
 #endif
 
 
-#include "Cluster.h"
+#include "cluster.h"
 
 #ifdef GPU_CLUSTERING
 	#include "gpu_euclidean_clustering.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\fusion\include\fusion\fusion_func.h" new_path="ros\src\computing\perception\detection\lidar_tracker\libs\fusion\include\fusion\fusion_func.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\fusion\include\fusion\search_distance.h" new_path="ros\src\computing\perception\detection\lidar_tracker\libs\fusion\include\fusion\search_distance.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\fusion\src\fusion.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\libs\fusion\src\fusion.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\fusion\src\search_distance.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\libs\fusion\src\search_distance.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_lidar_track\euclidean_lidar_track.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_euclidean_track\nodes\lidar_euclidean_track\lidar_euclidean_track.cpp" added_lines="7" deleted_lines="5">
				<diff>@@ -1,16 +1,18 @@
 #include &lt;float.h&gt;
+#include &lt;math.h&gt;
+
 #include &lt;geometry_msgs/Point.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-#include "autoware_msgs/CloudCluster.h"
-#include "autoware_msgs/CloudClusterArray.h"
-#include "autoware_msgs/DetectedObject.h"
-#include "autoware_msgs/DetectedObjectArray.h"
-#include &lt;math.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
+#include &lt;autoware_msgs/CloudCluster.h&gt;
+#include &lt;autoware_msgs/CloudClusterArray.h&gt;
+#include &lt;autoware_msgs/DetectedObject.h&gt;
+#include &lt;autoware_msgs/DetectedObjectArray.h&gt;
+
 ros::Publisher tracked_pub;
 ros::Publisher tracked_bba_pub;
 ros::Publisher tracked_bba_textlabel_pub;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\imm_ukf_pda_tracker.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\imm_ukf_pda.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\include\ukf.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\ukf.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_detected_objects\include\visualize_detected_objects.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\visualize_detected_objects.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 #include "ukf.h"
-#include "imm_ukf_pda_tracker.h"
+#include "imm_ukf_pda.h"
 
 enum TrackingState : int
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\imm_ukf_pda_tracker_main.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda_main.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 
-#include "imm_ukf_pda_tracker.h"
+#include "imm_ukf_pda.h"
 
 int main(int argc, char** argv)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\imm_ukf_pda_tracker\src\ukf.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\ukf.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_detected_objects\src\visualize_detected_objects.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\visualize_detected_objects\visualize_detected_objects.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\visualize_detected_objects\src\visualize_detected_objects_main.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\visualize_detected_objects\visualize_detected_objects_main.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_contour_tracker\include\kf_contour_tracker_core.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\lidar_kf_contour_track_core.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_contour_tracker\kf_contour_tracker.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track.cpp" added_lines="14" deleted_lines="12">
				<diff>@@ -5,7 +5,8 @@
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions are met:
  *
- *  * Redistributions of source code must retain the above copyright notice, this
+ *  * Redistributions of source code must retain the above copyright notice,
+ * this
  *    list of conditions and the following disclaimer.
  *
  *  * Redistributions in binary form must reproduce the above copyright notice,
@@ -18,24 +19,25 @@
  *
  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE
  *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-
+#include "lidar_kf_contour_track_core.h"
 #include &lt;ros/ros.h&gt;
-#include "include/kf_contour_tracker_core.h"
 
-int main(int argc, char **argv)
-{
-	ros::init(argc, argv, "kf_contour_tracker");
-	ContourTrackerNS::ContourTracker tracker;
-	tracker.MainLoop();
-	return 0;
+int main(int argc, char **argv) {
+  ros::init(argc, argv, "kf_contour_track");
+  ContourTrackerNS::ContourTracker tracker;
+  tracker.MainLoop();
+  return 0;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\includes\HungarianAlg.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_track\include\hungarian_alg.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\includes\Kalman.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_track\include\kalman.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\HungarianAlg.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_track\nodes\lidar_kf_track\hungarian_alg.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,4 +1,4 @@
-#include "HungarianAlg.h"
+#include "hungarian_alg.h"
 #include &lt;limits&gt;
 
 AssignmentProblemSolver::AssignmentProblemSolver()
@@ -43,7 +43,7 @@ float AssignmentProblemSolver::Solve(
 // --------------------------------------------------------------------------
 void AssignmentProblemSolver::assignmentoptimal(std::vector&lt;int&gt;&amp; assignment, float&amp; cost, const std::vector&lt;float&gt;&amp; distMatrixIn, size_t nOfRows, size_t nOfColumns)
 {
-	// Generate distance cv::Matrix 
+	// Generate distance cv::Matrix
 	// and check cv::Matrix elements positiveness :)
 
 	// Total elements number
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\Kalman.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_track\nodes\lidar_kf_track\kalman.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -1,4 +1,4 @@
-#include "Kalman.h"
+#include "kalman.h"
 #include "opencv2/opencv.hpp"
 #include &lt;iostream&gt;
 #include &lt;vector&gt;
@@ -11,7 +11,7 @@ TKalmanFilter::TKalmanFilter(cv::Point2f pt, float dt, float Accel_noise_mag)
 	deltatime = dt; //0.2
 
 	// We don't know acceleration, so, assume it to process noise.
-	// But we can guess, the range of acceleration values thich can be achieved by tracked object. 
+	// But we can guess, the range of acceleration values thich can be achieved by tracked object.
     // Process noise. (standard deviation of acceleration: m/s^2)
 	// shows, woh much target can accelerate.
 	//float Accel_noise_mag = 0.5;
@@ -24,7 +24,7 @@ TKalmanFilter::TKalmanFilter(cv::Point2f pt, float dt, float Accel_noise_mag)
 															0, 0, 1, 0,
 															0, 0, 0, 1);
 
-	// init... 
+	// init...
 	LastResult = pt;
 	kalman.statePre.at&lt;float&gt;(0) = pt.x; // x
 	kalman.statePre.at&lt;float&gt;(1) = pt.y; // y
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\KfLidarTracker.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_track\nodes\lidar_kf_track\lidar_kf_track.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,4 +1,4 @@
-#include "KfLidarTracker.h"
+#include "lidar_kf_track.h"
 
 // ---------------------------------------------------------------------------
 // Tracker. Manage tracks. Create, remove, update.
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\kf_lidar_track.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_track\nodes\lidar_kf_track\lidar_kf_track_core.cpp" added_lines="1" deleted_lines="5">
				<diff>@@ -11,10 +11,6 @@
 
 #include &lt;pcl_ros/transforms.h&gt;
 
-#include &lt;sensor_msgs/point_cloud_conversion.h&gt;
-#include &lt;sensor_msgs/PointCloud.h&gt;
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-
 #include "autoware_msgs/CloudCluster.h"
 #include "autoware_msgs/CloudClusterArray.h"
 #include "autoware_msgs/DetectedObject.h"
@@ -26,7 +22,7 @@
 #include &lt;jsk_rviz_plugins/PictogramArray.h&gt;
 #include &lt;jsk_recognition_msgs/PolygonArray.h&gt;
 
-#include "KfLidarTracker.h"
+#include "lidar_kf_track.h"
 
 class KfLidarTrackNode
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\obj_fusion.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_fusion\nodes\obj_fusion\obj_fusion.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\axialMove.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\include\axial_move.h" added_lines="17" deleted_lines="17">
				<diff>@@ -32,7 +32,7 @@
 #define AXIALMOVE
 
 #include &lt;math.h&gt;
-#include "CalObjLoc.h"
+#include "cal_obj_loc.h"
 #include "structure.h"
 
 class axiMove{
@@ -41,30 +41,30 @@ public:
 
     LOCATION cal(LOCATION loc,double matrix[4][4]){
 /**
-calibration file is assumed that 
-axial z is front of car, 
-axial y is upper way 
+calibration file is assumed that
+axial z is front of car,
+axial y is upper way
 and axial x is left and right.
 
  */
         LOCATION newloc;
         //rotation around X
-        newloc.X = 
-            matrix[0][0]*loc.X + 
-            matrix[0][1]*loc.Y + 
-            matrix[0][2]*loc.Z + 
+        newloc.X =
+            matrix[0][0]*loc.X +
+            matrix[0][1]*loc.Y +
+            matrix[0][2]*loc.Z +
             matrix[0][3];
 
-        newloc.Y = 
-            matrix[1][0]*loc.X + 
-            matrix[1][1]*loc.Y + 
-            matrix[1][2]*loc.Z + 
+        newloc.Y =
+            matrix[1][0]*loc.X +
+            matrix[1][1]*loc.Y +
+            matrix[1][2]*loc.Z +
             matrix[1][3];
 
-        newloc.Z = 
-            matrix[2][0]*loc.X + 
-            matrix[2][1]*loc.Y + 
-            matrix[2][2]*loc.Z + 
+        newloc.Z =
+            matrix[2][0]*loc.X +
+            matrix[2][1]*loc.Y +
+            matrix[2][2]*loc.Z +
             matrix[2][3];
 
         newloc.W = 1;
@@ -82,7 +82,7 @@ and axial x is left and right.
 
         //rotation around Y
         newloc.X = loc.X*cos(ang.thiY) - loc.Z*sin(ang.thiY);
-        newloc.Z = loc.X*sin(ang.thiY) + loc.Z*cos(ang.thiY); 
+        newloc.Z = loc.X*sin(ang.thiY) + loc.Z*cos(ang.thiY);
         loc.X = newloc.X;
         loc.Z = newloc.Z;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\CalObjLoc.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\include\cal_obj_loc.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\calcoordinates.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\include\calcoordinates.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\structure.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\include\structure.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\range_fusion\range_fusion.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\range_fusion\nodes\range_fusion\range_fusion.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ocv\dpm_ocv.cpp" new_path="" added_lines="0" deleted_lines="207">
				<diff>@@ -1,207 +0,0 @@
-#include &lt;iostream&gt;
-#include &lt;string&gt;
-#include &lt;opencv2/objdetect/objdetect.hpp&gt;
-#include &lt;opencv2/contrib/contrib.hpp&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;cv_bridge/cv_bridge.h&gt;
-#include &lt;sensor_msgs/image_encodings.h&gt;
-#include "autoware_msgs/image_obj.h"
-#include "autoware_msgs/ConfigCarDpm.h"
-
-#include &lt;libdpm_ocv/dpm_ocv.hpp&gt;
-
-#define XSTR(x) #x
-#define STR(x) XSTR(x)
-
-#if defined(HAS_GPU)
-static bool use_gpu = true;
-#endif
-
-static constexpr float SCORE_THRESHOLD = -0.5;
-static constexpr int NUM_CELLS = 8;
-static constexpr int NUM_BINS = 9;
-
-class objectDetect
-{
-public:
-	objectDetect();
-	~objectDetect();
-	void run();
-
-private:
-	void imageCallback(const sensor_msgs::ImageConstPtr&amp; img);
-	void configCallback(const autoware_msgs::ConfigCarDpm::ConstPtr&amp; param);
-
-	ros::NodeHandle nh_;
-	ros::Subscriber config_sub_;
-	ros::Subscriber img_sub_;
-	ros::Publisher detect_pub_;
-	DPMOCVCPULatentSvmDetector *cpu_detector_;
-#if defined(HAS_GPU)
-	DPMOCVGPULatentSvmDetector *gpu_detector_;
-#endif
-	double score_threshold_;
-	double overlap_threshold_;
-	double val_of_truncate_;
-	int num_threads_;
-	int lambda_;
-	int num_cells_;
-	int num_bins_;
-	std::string model_file_;
-	std::string object_class;
-	std::string image_topic_name;
-};
-
-// Constructor
-objectDetect::objectDetect() :
-	cpu_detector_(NULL),
-#if defined(HAS_GPU)
-	gpu_detector_(NULL),
-#endif
-	object_class("car")
-{
-	ros::NodeHandle private_nh_("~");
-
-	private_nh_.param("overlap_threshold", overlap_threshold_, 0.5);
-	private_nh_.param("num_threads", num_threads_, 8);
-	private_nh_.param("lambda", lambda_, 10);
-	private_nh_.param("num_cells", num_cells_, NUM_CELLS);
-	private_nh_.param("num_bins", num_bins_, NUM_BINS);
-	private_nh_.param("val_of_tuncate", val_of_truncate_, 0.2);
-	private_nh_.param&lt;std::string&gt;("image_raw_topic", image_topic_name, "/image_raw");
-
-	if (!private_nh_.getParam("detection_class_name", object_class))  {
-		object_class = "car";
-	}
-
-#if defined(HAS_GPU)
-	if (!private_nh_.getParam("use_gpu", use_gpu)) {
-		use_gpu = false;
-	}
-#endif
-
-	std::string default_model;
-	// switch (type) {
-	// case DetectType::CAR:
-	// 	default_model =  std::string(STR(MODEL_DIR) "car_2008.xml");
-	// 	break;
-	// case DetectType::PEDESTRIAN:
-	// 	default_model =  std::string(STR(MODEL_DIR) "person.xml");
-	// 	break;
-	// default:
-	// 	break;
-	// }
-	if (object_class == "car") {
-		default_model =  std::string(STR(MODEL_DIR) "car_2008.xml");
-	}
-	else if (object_class == "person") {
-		default_model =  std::string(STR(MODEL_DIR) "person.xml");
-	}
-
-	private_nh_.param("model_file", model_file_, default_model);
-
-	std::vector&lt;std::string&gt; model_filenames;
-	model_filenames.clear();
-	model_filenames.push_back(model_file_);
-
-	cpu_detector_ = new DPMOCVCPULatentSvmDetector(model_filenames);
-	if (!private_nh_.getParam("score_threshold", score_threshold_))
-	{
-		score_threshold_ = SCORE_THRESHOLD;
-	}
-
-#if defined(HAS_GPU)
-	gpu_detector_ = new DPMOCVGPULatentSvmDetector(model_filenames, (float)score_threshold_);
-#endif
-}
-
-// Destructor
-objectDetect::~objectDetect()
-{
-	delete cpu_detector_;
-#if defined(HAS_GPU)
-	if(gpu_detector_ != NULL)
-	{
-		delete(gpu_detector_);
-		gpu_detector_ = NULL;
-	}
-#endif
-}
-
-void objectDetect::run()
-{
-	std::string config_topic("/config");
-	config_topic += ros::this_node::getNamespace() + "/dpm";
-	config_sub_ = nh_.subscribe&lt;autoware_msgs::ConfigCarDpm&gt;(config_topic, 1, &amp;objectDetect::configCallback, this);
-	img_sub_ = nh_.subscribe&lt;sensor_msgs::Image&gt;(image_topic_name, 1, &amp;objectDetect::imageCallback, this);
-	detect_pub_ = nh_.advertise&lt;autoware_msgs::image_obj&gt;("image_obj", 1);
-}
-
-// Callback
-void objectDetect::imageCallback(const sensor_msgs::ImageConstPtr&amp; img)
-{
-	// transform image
-	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(img, sensor_msgs::image_encodings::BGR8);
-	cv::Mat image = cv_image-&gt;image;
-
-	std::vector&lt;cv::LatentSvmDetector::ObjectDetection&gt; detections;
-
-	// detection main
-#if defined(HAS_GPU)
-	if (use_gpu) {
-		gpu_detector_-&gt;detect(image, detections, (float)overlap_threshold_, num_threads_,
-			lambda_, num_cells_, (float)val_of_truncate_);
-	} else {
-#endif
-		cpu_detector_-&gt;detect(image, detections, (float)overlap_threshold_, num_threads_,
-			score_threshold_, lambda_, num_cells_, num_bins_);
-#if defined(HAS_GPU)
-	}
-#endif
-
-	int num = detections.size();
-	std::vector&lt;int&gt; corner_point_array(num * 4.0);
-	std::vector&lt;int&gt; type_array(num, 0);
-
-	autoware_msgs::image_obj msg;
-	msg.header = img-&gt;header;
-	msg.type = object_class;
-
-	for(size_t i = 0; i &lt; detections.size(); i++)
-	{
-		const cv::LatentSvmDetector::ObjectDetection&amp; od = detections[i];
-		autoware_msgs::image_rect rect;
-
-		type_array[i] = od.classID;
-		rect.x = od.rect.x;
-		rect.y = od.rect.y;
-		rect.width = od.rect.width;
-		rect.height = od.rect.height;
-		rect.score = od.score;
-		msg.obj.push_back(rect);
-	}
-
-	detect_pub_.publish(msg);
-}
-
-void objectDetect::configCallback(const autoware_msgs::ConfigCarDpm::ConstPtr&amp; param)
-{
-	score_threshold_   = param-&gt;score_threshold;
-	overlap_threshold_ = param-&gt;group_threshold;
-	lambda_			   = param-&gt;Lambda;
-	num_cells_		   = param-&gt;num_cells;
-	num_bins_		   = param-&gt;num_bins;
-}
-
-int main(int argc, char* argv[])
-{
-	ros::init(argc, argv, "dpm_ocv");
-
-	objectDetect detector;
-
-	detector.run();
-
-	ros::spin();
-	return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\klt_track\klt_track.cpp" new_path="" added_lines="0" deleted_lines="443">
				<diff>@@ -1,443 +0,0 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-//ROS STUFF
-#include &lt;ros/ros.h&gt;
-
-#include &lt;message_filters/subscriber.h&gt;
-#include &lt;message_filters/time_synchronizer.h&gt;
-
-#include &lt;cv_bridge/cv_bridge.h&gt;
-#include &lt;sensor_msgs/Image.h&gt;
-#include &lt;sensor_msgs/image_encodings.h&gt;
-#include "autoware_msgs/image_obj.h"
-#include "autoware_msgs/image_obj_tracked.h"
-#include "autoware_msgs/image_obj_ranged.h"
-
-//TRACKING STUFF
-#include &lt;opencv2/core/core.hpp&gt;
-#include &lt;opencv2/objdetect/objdetect.hpp&gt;
-#include &lt;opencv2/highgui/highgui.hpp&gt;
-//#include &lt;opencv2/contrib/contrib.hpp&gt;
-#include &lt;opencv2/video/tracking.hpp&gt;
-#include &lt;opencv2/calib3d/calib3d.hpp&gt;
-
-#include "LkTracker.hpp"
-
-#include &lt;iostream&gt;
-#include &lt;stdio.h&gt;
-
-#include &lt;string&gt;
-#include &lt;sstream&gt;
-#include &lt;algorithm&gt;
-#include &lt;iterator&gt;
-
-#include "gencolors.cpp"
-
-class RosTrackerApp
-{
-	ros::Subscriber 	subscriber_image_raw_;
-	ros::Subscriber 	subscriber_image_obj_;
-	ros::Subscriber 	subscriber_klt_config_;
-	ros::Publisher 		publisher_tracked_objects_;//ROS
-	ros::NodeHandle 	node_handle_;
-
-	std::string 		tracked_type_;
-
-	bool 				ready_;
-
-	bool				track_ready_;
-	bool				detect_ready_;
-
-	int					num_trackers_;
-
-	std::vector&lt;LkTracker*&gt; obj_trackers_;
-	std::vector&lt;ObjectDetection&gt; obj_detections_;
-
-	std::vector&lt;float&gt; ranges_;
-	std::vector&lt;float&gt; min_heights_;
-	std::vector&lt;float&gt; max_heights_;
-
-	autoware_msgs::image_obj_tracked ros_objects_msg_;//sync
-
-	void Sort(const std::vector&lt;float&gt; in_scores, std::vector&lt;unsigned int&gt;&amp; in_out_indices)
-	{
-		for (unsigned int i = 0; i &lt; in_scores.size(); i++)
-			for (unsigned int j = i + 1; j &lt; in_scores.size(); j++)
-			{
-				if (in_scores[in_out_indices[j]] &gt; in_scores[in_out_indices[i]])
-				{
-					//float x_tmp = x[i];
-					int index_tmp = in_out_indices[i];
-					//x[i] = x[j];
-					in_out_indices[i] = in_out_indices[j];
-					//x[j] = x_tmp;
-					in_out_indices[j] = index_tmp;
-				}
-			}
-	}
-
-	void ApplyNonMaximumSuppresion(std::vector&lt; LkTracker* &gt;&amp; in_out_source, float in_nms_threshold)
-	{
-		if (in_out_source.empty())
-			return;
-
-		unsigned int size = in_out_source.size();
-
-		std::vector&lt;float&gt; area(size);
-		std::vector&lt;float&gt; scores(size);
-		std::vector&lt;int&gt; x1(size);
-		std::vector&lt;int&gt; y1(size);
-		std::vector&lt;int&gt; x2(size);
-		std::vector&lt;int&gt; y2(size);
-		std::vector&lt;unsigned int&gt; indices(size);
-		std::vector&lt;bool&gt; is_suppresed(size);
-
-		for(unsigned int i = 0; i&lt; in_out_source.size(); i++)
-		{
-			ObjectDetection tmp = in_out_source[i]-&gt;GetTrackedObject();
-			area[i] = tmp.rect.width * tmp.rect.height;
-			if (area[i]&gt;0)
-				is_suppresed[i] = false;
-			else
-			{
-				is_suppresed[i] = true;
-				in_out_source[i]-&gt;NullifyLifespan();
-			}
-			indices[i] = i;
-			scores[i] = tmp.score;
-			x1[i] = tmp.rect.x;
-			y1[i] = tmp.rect.y;
-			x2[i] = tmp.rect.width + tmp.rect.x;
-			y2[i] = tmp.rect.height + tmp.rect.y;
-		}
-
-		Sort(area, indices);//returns indices ordered based on scores
-
-		for(unsigned int i=0; i&lt; size; i++)
-		{
-
-			for(unsigned int j= i+1; j&lt; size; j++)
-			{
-				if(is_suppresed[indices[i]] || is_suppresed[indices[j]])
-					continue;
-				int x1_max = std::max(x1[indices[i]], x1[indices[j]]);
-				int x2_min = std::min(x2[indices[i]], x2[indices[j]]);
-				int y1_max = std::max(y1[indices[i]], y1[indices[j]]);
-				int y2_min = std::min(y2[indices[i]], y2[indices[j]]);
-				int overlap_width = x2_min - x1_max + 1;
-				int overlap_height = y2_min - y1_max + 1;
-				if(overlap_width &gt; 0 &amp;&amp; overlap_height&gt;0)
-				{
-					float overlap_part = (overlap_width*overlap_height)/area[indices[j]];
-					if(overlap_part &gt; in_nms_threshold)
-					{
-						is_suppresed[indices[j]] = true;
-						in_out_source[indices[j]]-&gt;NullifyLifespan();
-						if (in_out_source[indices[j]]-&gt;GetFrameCount() &gt; in_out_source[indices[i]]-&gt;GetFrameCount())
-						{
-							in_out_source[indices[i]]-&gt;object_id = in_out_source[indices[j]]-&gt;object_id;
-						}
-
-					}
-				}
-			}
-		}
-		return ;
-	}
-
-	void publish_if_possible()
-	{
-		if (track_ready_ &amp;&amp; detect_ready_)
-		{
-			publisher_tracked_objects_.publish(ros_objects_msg_);
-			track_ready_ = false;
-			detect_ready_ = false;
-		}
-	}
-
-public:
-	void image_callback(const sensor_msgs::Image&amp; image_source)
-	{
-		cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
-		cv::Mat image_track = cv_image-&gt;image;
-		
-		ObjectDetection empty_detection;
-		empty_detection.rect=cv::Rect(0,0,0,0);
-		empty_detection.score=0;
-		unsigned int i;
-
-		std::vector&lt;bool&gt; tracker_matched(obj_trackers_.size(), false);
-		std::vector&lt;bool&gt; object_matched(obj_detections_.size(), false);
-
-		//check object detections vs current trackers
-		for (i =0; i&lt; obj_detections_.size(); i++)
-		{
-			for (unsigned int j = 0; j &lt; obj_trackers_.size(); j++)
-			{
-				if (tracker_matched[j] || object_matched[i])
-					continue;
-
-				ObjectDetection tmp_detection = obj_detections_[i];
-				int area = tmp_detection.rect.width * tmp_detection.rect.height;
-				cv::Rect intersection = tmp_detection.rect &amp; obj_trackers_[j]-&gt;GetTrackedObject().rect;
-				if ( (intersection.width * intersection.height) &gt; area*0.3 )
-				{
-
-					obj_trackers_[j]-&gt;Track(image_track, obj_detections_[i], true);
-					tracker_matched[j] = true;
-					object_matched[i] = true;
-					//std::cout &lt;&lt; "matched " &lt;&lt; i &lt;&lt; " with " &lt;&lt; j &lt;&lt; std::endl;
-				}
-			}
-		}
-
-		//run the trackers not matched
-		for(i = 0; i &lt; obj_trackers_.size(); i++)
-		{
-			if(!tracker_matched[i])
-			{
-				obj_trackers_[i]-&gt;Track(image_track, empty_detection, false);
-			}
-		}
-
-		//create trackers for those objects not being tracked yet
-		for(unsigned int i=0; i&lt;obj_detections_.size(); i++)
-		{
-			if (!object_matched[i])//if object wasn't matched by overlapping area, create a new tracker
-			{
-				if (num_trackers_ &gt;10)
-					num_trackers_=0;
-				LkTracker* new_tracker = new LkTracker(++num_trackers_, min_heights_[i], max_heights_[i], ranges_[i]);
-				new_tracker-&gt;Track(image_track, obj_detections_[i], true);
-
-				//std::cout &lt;&lt; "added new tracker" &lt;&lt; std::endl;
-				obj_trackers_.push_back(new_tracker);
-			}
-		}
-
-		ApplyNonMaximumSuppresion(obj_trackers_, 0.3);
-
-		//remove those trackers with its lifespan &lt;=0
-		std::vector&lt;LkTracker*&gt;::iterator it;
-		for(it = obj_trackers_.begin(); it != obj_trackers_.end();)
-		{
-			if ( (*it)-&gt;GetRemainingLifespan()&lt;=0 )
-			{
-				it = obj_trackers_.erase(it);
-				//std::cout &lt;&lt; "deleted a tracker " &lt;&lt; std::endl;
-			}
-			else
-				it++;
-		}
-
-		//copy results to ros msg
-		unsigned int num = obj_trackers_.size();
-		std::vector&lt;autoware_msgs::image_rect_ranged&gt; rect_ranged_array;//tracked rectangles
-		std::vector&lt;int&gt; real_data(num,0);//boolean array to show if data in rect_ranged comes from tracking or detection
-		std::vector&lt;unsigned int&gt; obj_id(num, 0);//id number for each rect_range
-		std::vector&lt;unsigned int&gt; lifespan(num, 0);//remaining lifespan of each rectranged
-		for(i=0; i &lt; num; i++)
-		{
-			autoware_msgs::image_rect_ranged rect_ranged;
-			LkTracker tracker_tmp = *obj_trackers_[i];
-			rect_ranged.rect.x = tracker_tmp.GetTrackedObject().rect.x;
-			rect_ranged.rect.y = tracker_tmp.GetTrackedObject().rect.y;
-			rect_ranged.rect.width = tracker_tmp.GetTrackedObject().rect.width;
-			rect_ranged.rect.height = tracker_tmp.GetTrackedObject().rect.height;
-			rect_ranged.rect.score = tracker_tmp.GetTrackedObject().score;
-			rect_ranged.max_height = tracker_tmp.max_height_;
-			rect_ranged.min_height = tracker_tmp.min_height_;
-			rect_ranged.range = tracker_tmp.range_;
-
-			rect_ranged_array.push_back(rect_ranged);
-
-			lifespan[i] = tracker_tmp.GetRemainingLifespan();
-			obj_id[i] = tracker_tmp.object_id;
-			if(lifespan[i]==tracker_tmp.DEFAULT_LIFESPAN_)
-				real_data[i] = 1;
-
-			cv::rectangle(image_track, tracker_tmp.GetTrackedObject().rect, cv::Scalar(0,255,0), 2);
-		}
-
-		//std::cout &lt;&lt; "TRACKERS: " &lt;&lt; obj_trackers_.size() &lt;&lt; std::endl;
-
-		obj_detections_.clear();
-        ranges_.clear();
-
-		autoware_msgs::image_obj_tracked tmp_objects_msg;
-
-		tmp_objects_msg.type = tracked_type_;
-		tmp_objects_msg.total_num = num;
-		copy(rect_ranged_array.begin(), rect_ranged_array.end(), back_inserter(tmp_objects_msg.rect_ranged)); // copy vector
-		copy(real_data.begin(), real_data.end(), back_inserter(tmp_objects_msg.real_data)); // copy vector
-		copy(obj_id.begin(), obj_id.end(), back_inserter(tmp_objects_msg.obj_id)); // copy vector
-		copy(lifespan.begin(), lifespan.end(), back_inserter(tmp_objects_msg.lifespan)); // copy vector
-
-		tmp_objects_msg.header = image_source.header;
-
-		ros_objects_msg_ = tmp_objects_msg;
-
-		//publisher_tracked_objects_.publish(ros_objects_msg);
-
-		//cv::imshow("KLT",image_track);
-		//cv::waitKey(1);
-
-		track_ready_ = true;
-		//ready_ = false;
-
-		publish_if_possible();
-
-	}
-
-	void detections_callback(autoware_msgs::image_obj_ranged image_objects_msg)
-	{
-		//if(ready_)
-		//	return;
-		if (!detect_ready_)//must NOT overwrite, data is probably being used by tracking.
-		{
-			unsigned int num = image_objects_msg.obj.size();
-			std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects = image_objects_msg.obj;
-			tracked_type_ = image_objects_msg.type;
-			//points are X,Y,W,H and repeat for each instance
-			obj_detections_.clear();
-            ranges_.clear();
-            
-			for (unsigned int i=0; i&lt;num;i++)
-			{
-				cv::Rect tmp;
-				tmp.x = objects.at(i).rect.x;
-				tmp.y = objects.at(i).rect.y;
-				tmp.width = objects.at(i).rect.width;
-				tmp.height = objects.at(i).rect.height;
-				ObjectDetection tmp_obj;
-				tmp_obj.rect=tmp; tmp_obj.score=0;
-				obj_detections_.push_back(tmp_obj);
-				ranges_.push_back(objects.at(i).range);
-				min_heights_.push_back(objects.at(i).min_height);
-				max_heights_.push_back(objects.at(i).max_height);
-			}
-			detect_ready_ = true;
-		}
-
-		publish_if_possible();
-		//ready_ = true;
-	}
-	/*void detections_callback(autoware_msgs::image_obj image_objects_msg)
-	{
-		if (ready_)
-			return;
-		ready_ = false;
-		unsigned int num = image_objects_msg.obj.size();
-		std::vector&lt;autoware_msgs::image_rect&gt; objects = image_objects_msg.obj;
-		//object_type = image_objects_msg.type;
-		//points are X,Y,W,H and repeat for each instance
-		obj_detections_.clear();
-		tracked_type_ = image_objects_msg.type;
-		for (unsigned int i=0; i&lt;num;i++)
-		{
-			cv::Rect tmp;
-			tmp.x = objects.at(i).x;
-			tmp.y = objects.at(i).y;
-			tmp.width = objects.at(i).width;
-			tmp.height = objects.at(i).height;
-			obj_detections_.push_back(ObjectDetection(tmp, 0));
-		}
-		ready_ = true;
-	}*/
-
-	void klt_config_cb()
-	{
-
-	}
-
-
-	void Run()
-	{
-		std::string image_raw_topic_str;
-		std::string image_obj_topic_str;
-
-		ros::NodeHandle private_node_handle("~");//to receive args
-
-		if (private_node_handle.getParam("image_raw_node", image_raw_topic_str))
-			{
-				ROS_INFO("Setting image node to %s", image_raw_topic_str.c_str());
-			}
-		else
-		{
-			ROS_INFO("No image node received, defaulting to /image_raw, you can use _image_raw_node:=YOUR_TOPIC");
-			image_raw_topic_str = "/image_raw";
-		}
-		if (private_node_handle.getParam(ros::this_node::getNamespace() + "/img_obj_node", image_obj_topic_str))
-			{
-				ROS_INFO("Setting object node to %s", image_obj_topic_str.c_str());
-			}
-		else
-		{
-			ROS_INFO("No object node received, defaulting to image_obj_ranged, you can use _img_obj_node:=YOUR_TOPIC");
-			image_obj_topic_str = "image_obj_ranged";
-		}
-
-
-		publisher_tracked_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj_tracked&gt;("image_obj_tracked", 1);
-
-		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
-		ROS_INFO("Subscribing to... %s", image_obj_topic_str.c_str());
-		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosTrackerApp::image_callback, this);
-		subscriber_image_obj_ = node_handle_.subscribe(image_obj_topic_str, 1, &amp;RosTrackerApp::detections_callback, this);
-
-		std::string config_topic("/config");
-		config_topic += ros::this_node::getNamespace() + "/klt";
-		//node_handle.subscribe(config_topic, 1, &amp;RosTrackerApp::klt_config_cb, this);
-
-		ros::spin();
-		ROS_INFO("END klt");
-	}
-
-	RosTrackerApp()
-	{
-		ready_ = true;
-		num_trackers_ = 0;
-		track_ready_  = false;
-		detect_ready_ = false;
-	}
-
-};
-
-int main(int argc, char* argv[])
-{
-	ros::init(argc, argv, "klt");
-
-	RosTrackerApp app;
-
-	app.Run();
-
-	return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\obj_reproj.cpp" new_path="" added_lines="0" deleted_lines="414">
				<diff>@@ -1,414 +0,0 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include &lt;std_msgs/String.h&gt;
-#include &lt;ros/ros.h&gt;
-
-#include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;sensor_msgs/CompressedImage.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;time.h&gt;
-#include &lt;math.h&gt;
-#include &lt;vector&gt;
-#include &lt;boost/array.hpp&gt;
-#include &lt;iostream&gt;
-#include &lt;string&gt;
-#include &lt;sstream&gt;
-#include &lt;sys/time.h&gt;
-#include &lt;bitset&gt;
-
-#include &lt;opencv/cv.h&gt;
-#include &lt;opencv/highgui.h&gt;
-#include &lt;opencv/cxcore.h&gt;
-
-#include &lt;std_msgs/Float64.h&gt;
-#include &lt;std_msgs/Header.h&gt;
-#include &lt;geometry_msgs/TwistStamped.h&gt;
-#include &lt;geometry_msgs/Pose.h&gt;
-#include &lt;visualization_msgs/Marker.h&gt;
-#include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;tf/tf.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-#include &lt;sensor_msgs/NavSatFix.h&gt;
-#include "structure.h"
-#include "calcoordinates.h"
-#include "axialMove.h"
-#include &lt;gnss/geo_pos_conv.hpp&gt;
-#include "CalObjLoc.h"
-#include "autoware_msgs/image_obj_tracked.h"
-#include "autoware_msgs/obj_label.h"
-#include "autoware_msgs/projection_matrix.h"
-#include &lt;sensor_msgs/CameraInfo.h&gt;
-#include &lt;mutex&gt;
-
-#ifdef HAVE_JSK_PLUGIN
-#include "jsk_recognition_msgs/BoundingBox.h"
-#include "jsk_recognition_msgs/BoundingBoxArray.h"
-#endif  // ifdef HAVE_JSK_PLUGIN
-
-#define XSTR(x) #x
-#define STR(x) XSTR(x)
-
-using namespace std;
-
-static constexpr double LOOP_RATE = 15.0;
-
-typedef struct _OBJPOS{
-  int x1;
-  int y1;
-  int x2;
-  int y2;
-  float distance;
-  int id;
-}OBJPOS;
-
-static objLocation ol;
-
-//store subscribed value
-static vector&lt;OBJPOS&gt; global_cp_vector;
-
-//flag for comfirming whether updating position or not
-static bool ready_;
-
-static double cameraMatrix[4][4] = {
-  {-7.8577658642752374e-03, -6.2035361880992401e-02,9.9804301981022692e-01, 5.1542126095196206e-01},
-  {-9.9821250329813849e-01, 5.9620033356180935e-02,-4.1532977104442731e-03, -2.9214878315161133e-02},
-  {-5.9245706805522491e-02, -9.9629165684497312e-01,-6.2392954139163306e-02, -6.6728858508628075e-01},
-  {0, 0, 0, 1}
-};
-
-static ros::Publisher pub;
-static ros::Publisher marker_pub;
-#ifdef HAVE_JSK_PLUGIN
-static ros::Publisher jsk_bounding_box_pub;
-#endif // ifdef HAVE_JSK_PLUGIN
-
-static std::string object_type;
-static ros::Time image_obj_tracked_time;
-
-//coordinate system conversion between camera coordinate and map coordinate
-static tf::StampedTransform transformCam2Map;
-
-std::string camera_id_str;
-
-
-static visualization_msgs::MarkerArray convert_marker_array(const autoware_msgs::obj_label&amp; src)
-{
-  visualization_msgs::MarkerArray ret;
-  int index = 0;
-  std_msgs::ColorRGBA color_red;
-  color_red.r = 1.0f;
-  color_red.g = 0.0f;
-  color_red.b = 0.0f;
-  color_red.a = 0.7f;
-
-  std_msgs::ColorRGBA color_blue;
-  color_blue.r = 0.0f;
-  color_blue.g = 0.0f;
-  color_blue.b = 1.0f;
-  color_blue.a = 0.7f;
-
-  std_msgs::ColorRGBA color_green;
-  color_green.r = 0.0f;
-  color_green.g = 1.0f;
-  color_green.b = 0.0f;
-  color_green.a = 0.7f;
-
-  for (const auto&amp; reproj_pos : src.reprojected_pos)
-    {
-      visualization_msgs::Marker marker;
-      /* Set frame ID */
-      marker.header.frame_id = "map";
-
-      /* Set namespace adn id for this marker */
-      marker.ns = object_type;
-      marker.id = index;
-      index++;
-
-      /* set color */
-      if (object_type == "car") {
-        /* Set marker shape */
-        marker.type = visualization_msgs::Marker::SPHERE;
-
-        /* set pose of marker  */
-        marker.pose.position = reproj_pos;
-
-        /* set scale of marker */
-        marker.scale.x = (double)1.5;
-        marker.scale.y = (double)1.5;
-        marker.scale.z = (double)1.5;
-
-        marker.color = color_blue;
-      }
-      else if (object_type == "person") {
-        /* Set marker shape */
-        marker.type = visualization_msgs::Marker::CUBE;
-
-        /* set pose of marker  */
-        marker.pose.position = reproj_pos;
-
-        /* set scale of marker */
-        marker.scale.x = (double)0.7;
-        marker.scale.y = (double)0.7;
-        marker.scale.z = (double)1.8;
-
-        marker.color = color_green;
-      }
-      else {
-        marker.color = color_red;
-      }
-
-      marker.lifetime = ros::Duration(0.3);
-
-      ret.markers.push_back(marker);
-    }
-
-  return ret;
-}
-
-#ifdef HAVE_JSK_PLUGIN
-static jsk_recognition_msgs::BoundingBoxArray convertJskBoundingBoxArray(const autoware_msgs::obj_label&amp; src)
-{
-  jsk_recognition_msgs::BoundingBoxArray ret;
-  ret.header.frame_id ="map";
-
-  for (const auto&amp; reproj_pos : src.reprojected_pos)
-    {
-      jsk_recognition_msgs::BoundingBox bounding_box;
-      bounding_box.header.frame_id = "map";
-
-      bounding_box.pose.position = reproj_pos;
-
-      bounding_box.dimensions.x = 1.5;
-      bounding_box.dimensions.y = 1.5;
-      bounding_box.dimensions.z = 1.5;
-
-      ret.boxes.push_back(bounding_box);
-    }
-
-  return ret;
-}
-#endif  // ifdef HAVE_JSK_PLUGIN
-
-static void projection_callback(const autoware_msgs::projection_matrix&amp; msg)
-{
-  for (int row=0; row&lt;4; row++) {
-    for (int col=0; col&lt;4; col++) {
-      cameraMatrix[row][col] = msg.projection_matrix[row * 4 + col];
-    }
-  }
-  ready_ = true;
-}
-
-static void camera_info_callback(const sensor_msgs::CameraInfo&amp; msg)
-{
-  double fkx = msg.K[0 * 3 + 0]; // get K[0][0]
-  double fky = msg.K[1 * 3 + 1]; // get K[1][1]
-  double Ox  = msg.K[0 * 3 + 2]; // get K[0][2]
-  double Oy  = msg.K[1 * 3 + 2]; // get K[1][2]
-  ol.setCameraParam(fkx,fky,Ox,Oy);
-}
-
-void GetRPY(const geometry_msgs::Pose &amp;pose,
-	    double &amp;roll,
-	    double &amp;pitch,
-	    double &amp;yaw){
-  tf::Quaternion q;
-  tf::quaternionMsgToTF(pose.orientation,q);
-  tf::Matrix3x3(q).getRPY(roll,pitch,yaw);
-
-  //reverse angle value
-  roll  = -roll;
-  pitch = -pitch;
-  yaw   = -yaw;
-}
-
-void makeSendDataDetectedObj(vector&lt;OBJPOS&gt; car_position_vector,
-                             vector&lt;OBJPOS&gt;::iterator cp_iterator,
-                             autoware_msgs::obj_label&amp; send_data)
-{
-  geometry_msgs::Point tmpPoint;
-
-  for(uint i=0; i&lt;car_position_vector.size() ; i++, cp_iterator++){
-
-    //middle of right-lower and left-upper
-    double U = cp_iterator-&gt;x1 + cp_iterator-&gt;x2/2;
-    double V = cp_iterator-&gt;y1 + cp_iterator-&gt;y2/2;
-
-    //convert from "image" coordinate system to "camera" coordinate system
-    ol.setOriginalValue(U,V,cp_iterator-&gt;distance);
-    LOCATION ress = ol.cal();
-
-    /* convert from "camera" coordinate system to "map" coordinate system */
-    tf::Vector3 pos_in_camera_coord(ress.X, ress.Y, ress.Z);
-    static tf::TransformListener listener;
-    try {
-        listener.lookupTransform("map", camera_id_str, ros::Time(0), transformCam2Map);
-    }
-    catch (tf::TransformException ex) {
-        ROS_INFO("%s", ex.what());
-        return;
-    }
-    tf::Vector3 converted = transformCam2Map * pos_in_camera_coord;
-
-    tmpPoint.x = converted.x();
-    tmpPoint.y = converted.y();
-    tmpPoint.z = converted.z();
-
-    send_data.reprojected_pos.push_back(tmpPoint);
-    send_data.obj_id.push_back(cp_iterator-&gt;id);
-  }
-}
-
-//wrap SendData class
-void locatePublisher(void){
-
-  vector&lt;OBJPOS&gt; car_position_vector;
-  copy(global_cp_vector.begin(), global_cp_vector.end(), back_inserter(car_position_vector));
-
-  //get values from sample_corner_point , convert latitude and longitude,
-  //and send database server.
-
-  autoware_msgs::obj_label obj_label_msg;
-  visualization_msgs::MarkerArray obj_label_marker_msgs;
-
-  vector&lt;OBJPOS&gt;::iterator cp_iterator;
- 
-  cp_iterator = car_position_vector.begin();
-
-  //get data of car and pedestrian recognizing
-  if(!car_position_vector.empty()){
-    makeSendDataDetectedObj(car_position_vector,cp_iterator,obj_label_msg);
-  }
-
-  //publish recognized car data
-  obj_label_msg.type = object_type;
-  obj_label_marker_msgs = convert_marker_array(obj_label_msg);
-  /* Extraordinary correspondence because of wrong timestamp(current_pose)
-   * if a timestamp of current_pose is modified, this comment out should be removed
-   */
-//  if(image_obj_tracked_time.sec == current_pose.sec &amp;&amp; image_obj_tracked_time.nsec == current_pose.nsec) {
-    obj_label_msg.header.stamp = image_obj_tracked_time;
-//  }
-
-  pub.publish(obj_label_msg);
-  marker_pub.publish(obj_label_marker_msgs);
-
-#ifdef HAVE_JSK_PLUGIN
-  jsk_recognition_msgs::BoundingBoxArray obj_label_bounding_box_msgs = convertJskBoundingBoxArray(obj_label_msg);
-  jsk_bounding_box_pub.publish(obj_label_bounding_box_msgs);
-#endif  // ifdef HAVE_JSK_PLUGIN
-}
-
-static void obj_pos_xyzCallback(const autoware_msgs::image_obj_tracked&amp; fused_objects)
-{
-  if (!ready_)
-    return;
-  image_obj_tracked_time = fused_objects.header.stamp;
-
-  global_cp_vector.clear();
-
-  OBJPOS cp;
-
-  object_type = fused_objects.type;
-  //If angle and position data is not updated from prevous data send,
-  //data is not sent
-  //  if(gnssGetFlag || ndtGetFlag) {
-    for (unsigned int i = 0; i &lt; fused_objects.rect_ranged.size(); i++){
-
-      //If distance is zero, we cannot calculate position of recognized object
-      //so skip loop
-      if(fused_objects.rect_ranged.at(i).range &lt;= 0) continue;
-
-      cp.x1 = fused_objects.rect_ranged.at(i).rect.x;      // x-axis of the upper left
-      cp.y1 = fused_objects.rect_ranged.at(i).rect.y;      // y-axis of the upper left
-      cp.x2 = fused_objects.rect_ranged.at(i).rect.width;  // width of detection rectangle
-      cp.y2 = fused_objects.rect_ranged.at(i).rect.height; // height of detection rectangle
-
-      /*
-        As cameraMatrix[0][3] is offset from lidar to camera,
-        this cp.distance is z-axis value of detected object in camera coordinate system.
-        (As received distance is in [cm] unit, I convert unit from [cm] to [mm] here)
-      */
-      cp.distance = (fused_objects.rect_ranged.at(i).range - cameraMatrix[0][3]) * 10;
-      cp.id = fused_objects.obj_id.at(i);
-
-      global_cp_vector.push_back(cp);
-    }
-
-    locatePublisher();
-
-    //  }
-}
-
-
-int main(int argc, char **argv){
-
-  ros::init(argc ,argv, "obj_reproj") ;
-  cout &lt;&lt; "obj_reproj" &lt;&lt; endl;
-
-  ready_ = false;
-
-  /**
-   * NodeHandle is the main access point to communications with the ROS system.
-   * The first NodeHandle constructed will fully initialize this node, and the last
-   * NodeHandle destructed will close down the node.
-   */
-  ros::NodeHandle n;
-  ros::NodeHandle private_nh("~");
-  std::string projectionMat_topic_name;
-  private_nh.param&lt;std::string&gt;("projection_matrix_topic", projectionMat_topic_name, "/projection_matrix");
-  std::string camera_info_topic_name;
-  private_nh.param&lt;std::string&gt;("camera_info_topic", camera_info_topic_name, "/camera_info");
-
-  //get camera ID
-  camera_id_str = camera_info_topic_name;
-  camera_id_str.erase(camera_id_str.find("/camera_info"));
-  if (camera_id_str == "/") {
-    camera_id_str = "camera";
-  }
-
-  ros::Subscriber obj_pos_xyz = n.subscribe("image_obj_tracked", 1, obj_pos_xyzCallback);
-
-  pub = n.advertise&lt;autoware_msgs::obj_label&gt;("obj_label",1);
-  marker_pub = n.advertise&lt;visualization_msgs::MarkerArray&gt;("obj_label_marker", 1);
-
-#ifdef HAVE_JSK_PLUGIN
-  jsk_bounding_box_pub = n.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("obj_label_bounding_box", 1);
-#endif
-
-  ros::Subscriber projection = n.subscribe(projectionMat_topic_name, 1, projection_callback);
-  ros::Subscriber camera_info = n.subscribe(camera_info_topic_name, 1, camera_info_callback);
-
-  ros::spin();
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\rcnn\rcnn_node.cpp" new_path="" added_lines="0" deleted_lines="260">
				<diff>@@ -1,260 +0,0 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#include &lt;string&gt;
-#include &lt;ros/ros.h&gt;
-#include &lt;cv_bridge/cv_bridge.h&gt;
-#include &lt;sensor_msgs/Image.h&gt;
-#include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;autoware_msgs/image_obj.h&gt;
-#include &lt;autoware_msgs/ConfigRcnn.h&gt;
-
-#include &lt;rcnn_detector.h&gt;
-#include &lt;rect_class_score.h&gt;
-
-#include &lt;opencv2/contrib/contrib.hpp&gt;
-#include &lt;opencv2/highgui/highgui.hpp&gt;
-
-class RosRcnnApp
-{
-	ros::Subscriber subscriber_image_raw_;
-	ros::Subscriber subscriber_rcnn_config_;
-	ros::Publisher publisher_car_objects_;
-	ros::Publisher publisher_person_objects_;
-	ros::NodeHandle node_handle_;
-
-	//Caffe based Object Detection ConvNet
-	RcnnDetector* rcnn_detector_;
-
-	//The minimum score required to filter the detected objects by the ConvNet
-	float score_threshold_;
-
-	//The percentage area to group bounding boxes obtained by the ConvNet
-	float group_threshold_;
-
-	//Number of slices to use for the creation of proposals for the ConvNet
-	float image_slices_;
-
-	//percentage of overlapping between the slices
-	float slices_overlap_;
-
-	//If GPU is enabled, stores the GPU Device to use
-	unsigned int gpu_device_id_;
-
-	//Sets whether or not use GPU acceleration
-	bool use_gpu_;
-
-	//vector of indices of the classes to search for
-	std::vector&lt;unsigned int&gt; detect_classes_;
-
-	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, autoware_msgs::image_obj&amp; out_message, cv::Mat&amp; in_image, std::string in_class)
-	{
-		for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
-		{
-			if ( (in_objects[i].score &gt; score_threshold_)
-				&amp;&amp; (	(in_class == "car" &amp;&amp; (in_objects[i].class_type == Rcnn::CAR || in_objects[i].class_type == Rcnn::BUS))
-						|| (in_class == "person" &amp;&amp; (in_objects[i].class_type == Rcnn::PERSON || in_objects[i].class_type == Rcnn::BICYCLE))
-					)
-
-				)//check if the score is larger than minimum required
-			{
-				//std::cout &lt;&lt; in_objects[i].toString() &lt;&lt; std::endl;
-				autoware_msgs::image_rect rect;
-
-				rect.x = in_objects[i].x;
-				rect.y = in_objects[i].y;
-				rect.width = in_objects[i].w;
-				rect.height = in_objects[i].h;
-				if (in_objects[i].x &lt; 0)
-					rect.x = 0;
-				if (in_objects[i].y &lt; 0)
-					rect.y = 0;
-				if (in_objects[i].w &lt; 0)
-					rect.width = 0;
-				if (in_objects[i].h &lt; 0)
-					rect.height = 0;
-
-				rect.score = in_objects[i].score;
-
-				out_message.obj.push_back(rect);
-
-			}
-		}
-	}
-
-	void image_callback(const sensor_msgs::Image&amp; image_source)
-	{
-		//Receive Image, convert it to OpenCV Mat
-		cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source, "bgr8");//toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
-		cv::Mat image = cv_image-&gt;image;
-
-		//Detect Object in image
-		std::vector&lt; RectClassScore&lt;float&gt; &gt; detections;
-		//cv::TickMeter timer; timer.start();
-		//std::cout &lt;&lt; "score:" &lt;&lt; score_threshold_ &lt;&lt; " slices:" &lt;&lt; image_slices_ &lt;&lt; " slices overlap:" &lt;&lt; slices_overlap_ &lt;&lt; "nms" &lt;&lt; group_threshold_ &lt;&lt; std::endl;
-		detections = rcnn_detector_-&gt;Detect(image, detect_classes_, score_threshold_, image_slices_, slices_overlap_, group_threshold_);
-
-		//timer.stop();
-		//std::cout &lt;&lt; "Detection took: " &lt;&lt; timer.getTimeMilli() &lt;&lt; std::endl;
-
-		//Prepare Output message
-		autoware_msgs::image_obj output_car_message;
-		autoware_msgs::image_obj output_person_message;
-		output_car_message.header = image_source.header;
-		output_car_message.type = "car";
-
-		output_person_message.header = image_source.header;
-		output_person_message.type = "person";
-
-		//Convert Objects to Message type
-		//timer.reset(); timer.start();
-		convert_rect_to_image_obj(detections, output_car_message, image, "car");
-		convert_rect_to_image_obj(detections, output_person_message, image, "person");
-
-		publisher_car_objects_.publish(output_car_message);
-		publisher_person_objects_.publish(output_person_message);
-	}
-
-	void config_cb(const autoware_msgs::ConfigRcnn::ConstPtr&amp; param)
-	{
-		rcnn_detector_-&gt;SetPixelMean(cv::Scalar(param-&gt;b_mean, param-&gt;g_mean, param-&gt;r_mean));
-
-		score_threshold_ 	= param-&gt;score_threshold;
-		group_threshold_ 	= param-&gt;group_threshold;
-		image_slices_		= param-&gt;image_slices;
-		slices_overlap_		= param-&gt;slices_overlap;
-
-		/*use_gpu_			= param-&gt;use_gpu;
-		gpu_device_id_		= param-&gt;gpu_device_id;*/
-	}
-public:
-	void Run()
-	{
-		//ROS STUFF
-		ros::NodeHandle private_node_handle("~");//to receive args
-
-		//RECEIVE IMAGE TOPIC NAME
-		std::string image_raw_topic_str;
-		if (private_node_handle.getParam("image_raw_node", image_raw_topic_str))
-		{
-			ROS_INFO("Setting image node to %s", image_raw_topic_str.c_str());
-		}
-		else
-		{
-			ROS_INFO("No image node received, defaulting to /image_raw, you can use _image_raw_node:=YOUR_TOPIC");
-			image_raw_topic_str = "/image_raw";
-		}
-
-		//RECEIVE CONVNET FILENAMES
-		std::string network_definition_file;
-		std::string pretrained_model_file;
-		if (private_node_handle.getParam("network_definition_file", network_definition_file))
-		{
-			ROS_INFO("Network Definition File: %s", network_definition_file.c_str());
-		}
-		else
-		{
-			ROS_INFO("No Network Definition File was received. Finishing execution.");
-			return;
-		}
-		if (private_node_handle.getParam("pretrained_model_file", pretrained_model_file))
-		{
-			ROS_INFO("Pretrained Model File: %s", pretrained_model_file.c_str());
-		}
-		else
-		{
-			ROS_INFO("No Pretrained Model File was received. Finishing execution.");
-			return;
-		}
-
-		if (private_node_handle.getParam("use_gpu", use_gpu_))
-		{
-			ROS_INFO("GPU Mode: %d", use_gpu_);
-		}
-		int gpu_id;
-		if (private_node_handle.getParam("gpu_device_id", gpu_id ))
-		{
-			ROS_INFO("GPU Device ID: %d", gpu_id);
-			gpu_device_id_ = (unsigned int) gpu_id;
-		}
-
-		detect_classes_.push_back(Rcnn::CAR);
-		detect_classes_.push_back(Rcnn::PERSON);
-		detect_classes_.push_back(Rcnn::BUS);
-		//RCNN STUFF
-		rcnn_detector_ = new RcnnDetector(network_definition_file, pretrained_model_file, use_gpu_, gpu_device_id_);
-
-		if (NULL == rcnn_detector_)
-		{
-			ROS_INFO("Error while creating RCNN Object");
-			return;
-		}
-
-		publisher_car_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;("/obj_car/image_obj", 1);
-		publisher_person_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;("/obj_person/image_obj", 1);
-
-		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
-		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosRcnnApp::image_callback, this);
-
-		std::string config_topic("/config");	config_topic += ros::this_node::getNamespace() + "/rcnn";
-		subscriber_rcnn_config_ =node_handle_.subscribe(config_topic, 1, &amp;RosRcnnApp::config_cb, this);
-
-		ros::spin();
-		ROS_INFO("END rcnn");
-
-	}
-
-	~RosRcnnApp()
-	{
-		if (NULL != rcnn_detector_)
-			delete rcnn_detector_;
-	}
-
-	RosRcnnApp()
-	{
-		rcnn_detector_ 	= NULL;
-		score_threshold_= 0.6;
-		group_threshold_= 0.8;
-		image_slices_ 	= 16;
-		use_gpu_ 		= false;
-		gpu_device_id_ 	= 0;
-		slices_overlap_ = 0.7;
-	}
-};
-
-int main(int argc, char **argv)
-{
-	ros::init(argc, argv, "rcnn_msr");
-
-	RosRcnnApp app;
-
-	app.Run();
-
-	return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\include\rect_class_score.h" new_path="" added_lines="0" deleted_lines="52">
				<diff>@@ -1,52 +0,0 @@
-#ifndef RECTCLASSSCORE_H_
-#define RECTCLASSSCORE_H_
-
-#include &lt;sstream&gt;
-#include &lt;string&gt;
-
-template&lt;typename _Tp&gt; class RectClassScore
-{
-public:
-	_Tp x, y, w, h;
-	_Tp score;
-	unsigned int class_type;
-	bool enabled;
-
-	inline std::string toString()
-	{
-		std::ostringstream out;
-		out &lt;&lt; "P(" &lt;&lt; GetClassString() &lt;&lt; ") at " &lt;&lt; "(x:" &lt;&lt; x &lt;&lt; ", y:" &lt;&lt; y &lt;&lt; ", w:" &lt;&lt; w &lt;&lt; ", h:" &lt;&lt; h &lt;&lt; ") =" &lt;&lt; score;
-		return out.str();
-	}
-	inline std::string GetClassString()
-	{
-		switch (class_type)
-		{
-			case 0: return "nothing";
-			case 1: return "plane";
-			case 2: return "bicycle";
-			case 3: return "bird";
-			case 4: return "boat";
-			case 5: return "bottle";
-			case 6: return "bus";
-			case 7: return "car";
-			case 8: return "cat";
-			case 9: return "chair";
-			case 10:return "cow";
-			case 11:return "table";
-			case 12:return "dog";
-			case 13:return "horse";
-			case 14:return "motorbike";
-			case 15:return "person";
-			case 16:return "plant";
-			case 17:return "sheep";
-			case 18:return "sofa";
-			case 19:return "train";
-			case 20:return "tv";
-			default:return "error";
-		}
-	}
-};
-
-
-#endif /* RECTCLASSSCORE_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_contour_tracker\src\kf_contour_tracker_core.cpp" new_path="" added_lines="0" deleted_lines="231">
				<diff>@@ -1,231 +0,0 @@
-/*
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#include "../include/kf_contour_tracker_core.h"
-#include "op_ros_helpers/op_RosHelpers.h"
-
-
-namespace ContourTrackerNS
-{
-
-ContourTracker::ContourTracker()
-{
-	bNewClusters = false;
-	bNewCurrentPos = false;
-	ros::NodeHandle _nh;
-	_nh.getParam("/kf_contour_tracker/vehicle_width" 			, m_Params.VehicleWidth);
-	_nh.getParam("/kf_contour_tracker/vehicle_length" 			, m_Params.VehicleLength);
-	_nh.getParam("/kf_contour_tracker/horizon" 					, m_Params.DetectionRadius);
-	_nh.getParam("/kf_contour_tracker/min_object_size" 			, m_Params.MinObjSize);
-	_nh.getParam("/kf_contour_tracker/max_object_size" 			, m_Params.MaxObjSize);
-	_nh.getParam("/kf_contour_tracker/polygon_quarters" 		, m_Params.nQuarters);
-	_nh.getParam("/kf_contour_tracker/polygon_resolution" 		, m_Params.PolygonRes);
-	_nh.getParam("/kf_contour_tracker/max_association_distance" , m_ObstacleTracking.m_MAX_ASSOCIATION_DISTANCE);
-	_nh.getParam("/kf_contour_tracker/max_association_size_diff" , m_ObstacleTracking.m_MAX_ASSOCIATION_SIZE_DIFF);
-
-	int tracking_type = 0;
-	_nh.getParam("/kf_contour_tracker/tracking_type" 			, tracking_type);
-	if(tracking_type==0)
-		m_Params.trackingType = SimulationNS::ASSOCIATE_ONLY;
-	else if (tracking_type == 1)
-		m_Params.trackingType = SimulationNS::SIMPLE_TRACKER;
-	else if(tracking_type == 2)
-		m_Params.trackingType = SimulationNS::CONTOUR_TRACKER;
-
-	_nh.getParam("/kf_contour_tracker/max_remeber_time" 			, m_ObstacleTracking.m_MaxKeepTime);
-	_nh.getParam("/kf_contour_tracker/trust_counter" 				, m_ObstacleTracking.m_nMinTrustAppearances	);
-	_nh.getParam("/kf_contour_tracker/contours_circle_resolutions" 	, m_ObstacleTracking.m_CirclesResolution);
-
-	m_ObstacleTracking.m_dt = 0.12;
-	m_ObstacleTracking.m_bUseCenterOnly = true;
-	m_ObstacleTracking.m_Horizon = m_Params.DetectionRadius;
-	m_ObstacleTracking.InitSimpleTracker();
-
-	sub_cloud_clusters 		= nh.subscribe("/cloud_clusters", 1, &amp;ContourTracker::callbackGetCloudClusters, this);
-	sub_current_pose 		= nh.subscribe("/current_pose",   1, &amp;ContourTracker::callbackGetCurrentPose, 	this);
-
-	pub_AllTrackedObjects 	= nh.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detected_objects", 1);
-	pub_DetectedPolygonsRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detected_polygons", 1);
-	pub_TrackedObstaclesRviz = nh.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("op_planner_tracked_boxes", 1);
-
-
-	m_nDummyObjPerRep = 100;
-	m_nDetectedObjRepresentations = 5;
-	m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
-	m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
-	m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
-	m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
-	m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
-	m_DetectedPolygonsActual = m_DetectedPolygonsDummy;
-	PlannerHNS::RosHelpers::InitMarkers(m_nDummyObjPerRep, m_DetectedPolygonsDummy.at(0), m_DetectedPolygonsDummy.at(1), m_DetectedPolygonsDummy.at(2), m_DetectedPolygonsDummy.at(3), m_DetectedPolygonsDummy.at(4));
-}
-
-ContourTracker::~ContourTracker()
-{
-}
-
-
-void ContourTracker::callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr&amp; msg)
-{
-	if(bNewCurrentPos)
-	{
-		m_OriginalClusters.clear();
-		int nOriginalPoints = 0;
-		int nContourPoints = 0;
-
-		PlannerHNS::RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(m_CurrentPos, m_Params.VehicleWidth, m_Params.VehicleLength, *msg,
-				m_OriginalClusters, m_Params.MaxObjSize, m_Params.MinObjSize, m_Params.DetectionRadius, m_Params.nQuarters, m_Params.PolygonRes, nOriginalPoints, nContourPoints);
-
-		bNewClusters = true;
-	}
-}
-
-void ContourTracker::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg)
-{
-	m_CurrentPos = PlannerHNS::WayPoint(msg-&gt;pose.position.x, msg-&gt;pose.position.y, msg-&gt;pose.position.z, tf::getYaw(msg-&gt;pose.orientation));
-	bNewCurrentPos = true;
-}
-
-void ContourTracker::VisualizeLocalTracking()
-{
-	PlannerHNS::RosHelpers::ConvertTrackedObjectsMarkers(m_CurrentPos, m_ObstacleTracking.m_DetectedObjects,
-			m_DetectedPolygonsDummy.at(0),
-			m_DetectedPolygonsDummy.at(1),
-			m_DetectedPolygonsDummy.at(2),
-			m_DetectedPolygonsDummy.at(3),
-			m_DetectedPolygonsDummy.at(4),
-			m_DetectedPolygonsActual.at(0),
-			m_DetectedPolygonsActual.at(1),
-			m_DetectedPolygonsActual.at(2),
-			m_DetectedPolygonsActual.at(3),
-			m_DetectedPolygonsActual.at(4));
-
-	m_DetectedPolygonsAllMarkers.markers.clear();
-	m_DetectedPolygonsAllMarkers.markers.insert(m_DetectedPolygonsAllMarkers.markers.end(), m_DetectedPolygonsActual.at(0).markers.begin(), m_DetectedPolygonsActual.at(0).markers.end());
-	m_DetectedPolygonsAllMarkers.markers.insert(m_DetectedPolygonsAllMarkers.markers.end(), m_DetectedPolygonsActual.at(1).markers.begin(), m_DetectedPolygonsActual.at(1).markers.end());
-	m_DetectedPolygonsAllMarkers.markers.insert(m_DetectedPolygonsAllMarkers.markers.end(), m_DetectedPolygonsActual.at(2).markers.begin(), m_DetectedPolygonsActual.at(2).markers.end());
-	m_DetectedPolygonsAllMarkers.markers.insert(m_DetectedPolygonsAllMarkers.markers.end(), m_DetectedPolygonsActual.at(3).markers.begin(), m_DetectedPolygonsActual.at(3).markers.end());
-	m_DetectedPolygonsAllMarkers.markers.insert(m_DetectedPolygonsAllMarkers.markers.end(), m_DetectedPolygonsActual.at(4).markers.begin(), m_DetectedPolygonsActual.at(4).markers.end());
-
-
-	visualization_msgs::MarkerArray all_circles;
-	for(unsigned int i = 0; i &lt; m_ObstacleTracking.m_InterestRegions.size(); i++)
-	{
-		visualization_msgs::Marker circle_mkrs;
-		PlannerHNS::RosHelpers::CreateCircleMarker(m_CurrentPos, m_ObstacleTracking.m_InterestRegions.at(i)-&gt;radius, i ,circle_mkrs );
-		all_circles.markers.push_back(circle_mkrs);
-	}
-
-	m_DetectedPolygonsAllMarkers.markers.insert(m_DetectedPolygonsAllMarkers.markers.end(), all_circles.markers.begin(), all_circles.markers.end());
-
-	pub_DetectedPolygonsRviz.publish(m_DetectedPolygonsAllMarkers);
-
-	jsk_recognition_msgs::BoundingBoxArray boxes_array;
-	boxes_array.header.frame_id = "map";
-	boxes_array.header.stamp  = ros::Time();
-
-	for(unsigned int i = 0 ; i &lt; m_ObstacleTracking.m_DetectedObjects.size(); i++)
-	{
-		jsk_recognition_msgs::BoundingBox box;
-		box.header.frame_id = "map";
-		box.header.stamp = ros::Time();
-		box.pose.position.x = m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.x;
-		box.pose.position.y = m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.y;
-		box.pose.position.z = m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.z;
-
-		box.value = 0.9;
-
-		box.pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(0, 0, UtilityHNS::UtilityH::SplitPositiveAngle(m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.a));
-		box.dimensions.x = m_ObstacleTracking.m_DetectedObjects.at(i).w;
-		box.dimensions.y = m_ObstacleTracking.m_DetectedObjects.at(i).l;
-		box.dimensions.z = m_ObstacleTracking.m_DetectedObjects.at(i).h;
-		boxes_array.boxes.push_back(box);
-	}
-
-	pub_TrackedObstaclesRviz.publish(boxes_array);
-
-}
-
-void ContourTracker::MainLoop()
-{
-	ros::Rate loop_rate(25);
-
-	PlannerHNS::WayPoint prevState, state_change;
-
-	while (ros::ok())
-	{
-		ros::spinOnce();
-
-		if(bNewClusters)
-		{
-			m_ObstacleTracking.DoOneStep(m_CurrentPos, m_OriginalClusters, m_Params.trackingType);
-
-			m_OutPutResults.objects.clear();
-			autoware_msgs::DetectedObject obj;
-			for(unsigned int i = 0 ; i &lt;m_ObstacleTracking.m_DetectedObjects.size(); i++)
-			{
-				obj.id = m_ObstacleTracking.m_DetectedObjects.at(i).id;
-				obj.label = m_ObstacleTracking.m_DetectedObjects.at(i).label;
-				obj.dimensions.x = m_ObstacleTracking.m_DetectedObjects.at(i).l;
-				obj.dimensions.y = m_ObstacleTracking.m_DetectedObjects.at(i).w;
-				obj.dimensions.z = m_ObstacleTracking.m_DetectedObjects.at(i).h;
-
-				obj.pose.position.x = m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.x;
-				obj.pose.position.y = m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.y;
-				obj.pose.position.z = m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.z;
-
-				obj.pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(0, 0, UtilityHNS::UtilityH::SplitPositiveAngle(m_ObstacleTracking.m_DetectedObjects.at(i).center.pos.a));
-
-				geometry_msgs::Point32 p;
-				obj.convex_hull.polygon.points.clear();
-
-				for(unsigned int j=0; j &lt; m_ObstacleTracking.m_DetectedObjects.at(i).contour.size(); j++)
-				{
-					p.x = m_ObstacleTracking.m_DetectedObjects.at(i).contour.at(j).x;
-					p.y = m_ObstacleTracking.m_DetectedObjects.at(i).contour.at(j).y;
-					p.z = m_ObstacleTracking.m_DetectedObjects.at(i).contour.at(j).z;
-					obj.convex_hull.polygon.points.push_back(p);
-				}
-
-				m_OutPutResults.objects.push_back(obj);
-			}
-
-			m_OutPutResults.header.frame_id = "map";
-			m_OutPutResults.header.stamp  = ros::Time();
-
-			pub_AllTrackedObjects.publish(m_OutPutResults);
-
-			VisualizeLocalTracking();
-
-			bNewClusters = false;
-		}
-		loop_rate.sleep();
-	}
-}
-
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\includes\KfLidarTracker.h" new_path="" added_lines="0" deleted_lines="133">
				<diff>@@ -1,133 +0,0 @@
-#pragma once
-#include "Kalman.h"
-#include "HungarianAlg.h"
-#include &lt;iostream&gt;
-#include &lt;vector&gt;
-#include &lt;memory&gt;
-#include &lt;array&gt;
-#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
-#include &lt;jsk_recognition_msgs/PolygonArray.h&gt;
-#include &lt;geometry_msgs/Polygon.h&gt;
-#include &lt;geometry_msgs/PolygonStamped.h&gt;
-#include "autoware_msgs/CloudCluster.h"
-#include "autoware_msgs/CloudClusterArray.h"
-#include &lt;tf/tf.h&gt;
-
-#include &lt;boost/assert.hpp&gt;
-#include &lt;boost/geometry/geometries/point_xy.hpp&gt;
-#include &lt;boost/geometry/geometry.hpp&gt;
-#include &lt;boost/geometry/geometries/polygon.hpp&gt;
-#include &lt;boost/geometry/algorithms/disjoint.hpp&gt;
-#include &lt;boost/assign/std/vector.hpp&gt;
-
-#include &lt;pcl_ros/point_cloud.h&gt;
-#include &lt;pcl/point_types.h&gt;
-
-#include "Cluster.h"
-
-// --------------------------------------------------------------------------
-class CTrack
-{
-
-	cv::Point2f prediction_point_;
-	TKalmanFilter kf_;
-public:
-	autoware_msgs::CloudCluster cluster;
-
-	std::vector&lt;cv::Point2f&gt; trace;
-	size_t track_id;
-	size_t skipped_frames;
-	size_t life_span;
-	double area;
-
-	CTrack(const autoware_msgs::CloudCluster&amp; in_cluster, float in_time_delta, float in_acceleration_noise_magnitude, size_t in_track_id)
-		: kf_(cv::Point2f(in_cluster.centroid_point.point.x, in_cluster.centroid_point.point.y), in_time_delta, in_acceleration_noise_magnitude)
-	{
-		track_id = in_track_id;
-		skipped_frames = 0;
-		prediction_point_ = cv::Point2f(in_cluster.centroid_point.point.x, in_cluster.centroid_point.point.y);
-		cluster = in_cluster;
-		life_span = 0;
-		area = 0;
-	}
-
-	float CalculateDistance(const cv::Point2f&amp; in_point)
-	{
-		cv::Point2f diff = prediction_point_ - in_point;
-		return sqrt(pow(diff.x, 2) + pow(diff.y, 2));
-	}
-
-	float CalculateDistance(const cv::Rect_&lt;float&gt;&amp; in_rect)
-	{
-		return 0.0f;
-	}
-
-	void Update(const autoware_msgs::CloudCluster&amp; in_cluster, bool in_data_correct, size_t in_max_trace_length)
-	{
-		kf_.GetPrediction();
-		prediction_point_ = kf_.Update(cv::Point2f(in_cluster.centroid_point.point.x, in_cluster.centroid_point.point.y), in_data_correct);
-
-		if (in_data_correct
-			)
-		{
-			cluster = in_cluster;
-		}
-
-		if (trace.size() &gt; in_max_trace_length)
-		{
-			trace.erase(trace.begin(), trace.end() - in_max_trace_length);
-		}
-
-		trace.push_back(prediction_point_);
-	}
-
-	autoware_msgs::CloudCluster GetCluster()
-	{
-		return cluster;
-	}
-
-};
-
-// --------------------------------------------------------------------------
-class KfLidarTracker
-{
-	typedef boost::geometry::model::d2::point_xy&lt;double&gt; boost_point_xy;
-	typedef boost::geometry::model::polygon&lt;boost::geometry::model::d2::point_xy&lt;double&gt; &gt; boost_polygon;
-
-	float time_delta_;
-	float acceleration_noise_magnitude_;
-	float distance_threshold_;
-	float tracker_merging_threshold_;
-
-	size_t maximum_allowed_skipped_frames_;
-	size_t maximum_trace_length_;
-	size_t next_track_id_;
-	size_t maximum_track_id_;
-
-	bool pose_estimation_;
-	void CheckTrackerMerge(size_t in_tracker_id, std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector&lt;bool&gt;&amp; in_out_visited_trackers, std::vector&lt;size_t&gt;&amp; out_merge_indices, double in_merge_threshold);
-	void CheckAllTrackersForMerge(std::vector&lt;CTrack&gt;&amp; out_trackers);
-	void MergeTrackers(std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector&lt;CTrack&gt;&amp; out_trackers, std::vector&lt;size_t&gt; in_merge_indices, const size_t&amp; current_index, std::vector&lt;bool&gt;&amp; in_out_merged_trackers);
-	void CreatePolygonFromPoints(const geometry_msgs::Polygon&amp; in_points, boost_polygon&amp; out_polygon);
-public:
-	KfLidarTracker(float in_time_delta,
-					float accel_noise_mag,
-					float dist_thres = 3,
-					float tracker_merging_threshold=2,
-					size_t maximum_allowed_skipped_frames = 10,
-					size_t max_trace_length = 10,
-					bool in_pose_estimation = false,
-					size_t maximum_track_id = 200);
-	~KfLidarTracker(void);
-
-	enum DistType
-	{
-		CentersDist = 0,
-		RectsDist = 1
-	};
-
-	std::vector&lt; CTrack &gt; tracks_;//TODO: add GetTracks getter
-	void Update(const autoware_msgs::CloudClusterArray&amp; in_cloud_cluster_array, DistType in_disttype);
-
-
-};
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\pf_lidar_track\pf_lidar_track.cpp" new_path="" added_lines="0" deleted_lines="67">
				<diff>@@ -1,67 +0,0 @@
-/*
- * pf_track.cpp
- *
- *  Created on: Nov 3, 2016
- *      Author: ne0
- */
-
-
-#include "ros/ros.h"
-#include &lt;sensor_msgs/point_cloud_conversion.h&gt;
-#include &lt;sensor_msgs/PointCloud.h&gt;
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-
-#include "autoware_msgs/CloudCluster.h"
-#include "autoware_msgs/CloudClusterArray.h"
-#include "autoware_msgs/DetectedObject.h"
-#include "autoware_msgs/DetectedObjectArray.h"
-
-
-class PfTrack
-{
-public:
-	PfTrack();
-
-private:
-
-	ros::NodeHandle node_handle_;
-	ros::Subscriber cloud_clusters_sub_;
-	ros::Publisher detected_objects_pub_;
-
-	void CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr);
-};
-
-PfTrack::PfTrack() :
-		node_handle_("~")
-{
-	cloud_clusters_sub_ = node_handle_.subscribe("/cloud_clusters_class", 10, &amp;PfTrack::CloudClustersCallback, this);
-	detected_objects_pub_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;( "/detected_objects", 10);
-}
-
-void PfTrack::CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr)
-{
-	autoware_msgs::DetectedObjectArray detected_objects;
-	detected_objects.header = in_cloud_cluster_array_ptr-&gt;header;
-	for (auto i = in_cloud_cluster_array_ptr-&gt;clusters.begin(); i != in_cloud_cluster_array_ptr-&gt;clusters.end(); i++)
-	{
-		autoware_msgs::DetectedObject detected_object;
-		detected_object.header 		= i-&gt;header;
-		detected_object.id 			= i-&gt;id;
-		detected_object.label 		= i-&gt;label;
-		detected_object.dimensions 	= i-&gt;bounding_box.dimensions;
-		detected_object.pose 		= i-&gt;bounding_box.pose;
-
-		detected_objects.objects.push_back(detected_object);
-	}
-	detected_objects_pub_.publish(detected_objects);
-}
-
-int main(int argc, char **argv)
-{
-
-	ros::init(argc, argv, "pf_lidar_detect");
-	PfTrack node;
-	ros::spin();
-
-	return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\svm_lidar_detect\svm_lidar_detect.cpp" new_path="" added_lines="0" deleted_lines="118">
				<diff>@@ -1,118 +0,0 @@
-/*
- * svm_detect.cpp
- *
- *  Created on: Nov 3, 2016
- *      Author: ne0
- */
-
-
-#include "ros/ros.h"
-#include &lt;sensor_msgs/point_cloud_conversion.h&gt;
-#include &lt;sensor_msgs/PointCloud.h&gt;
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-
-#include "autoware_msgs/CloudCluster.h"
-#include "autoware_msgs/CloudClusterArray.h"
-
-#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
-#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-#include &lt;jsk_rviz_plugins/Pictogram.h&gt;
-#include &lt;jsk_rviz_plugins/PictogramArray.h&gt;
-
-#include &lt;tf/tf.h&gt;
-
-#include &lt;stdio.h&gt;
-#include &lt;string&gt;
-
-#include &lt;opencv/cv.h&gt;
-#include &lt;opencv/highgui.h&gt;
-
-#if(CV_MAJOR_VERSION !=3)
-#include &lt;opencv2/contrib/contrib.hpp&gt;
-#endif
-
-class SvmDetect
-{
-public:
-	SvmDetect();
-	~SvmDetect();
-	void Run();
-
-private:
-
-	ros::NodeHandle node_handle_;
-	ros::Subscriber cloud_clusters_sub_;
-	ros::Publisher cloud_clusters_pub_;
-	ros::Publisher text_pictogram_pub_;
-
-	std::string model_file_path_;
-
-	FILE *model_file_handle_;
-
-	void CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr);
-	void ClassifyFpfhDescriptor(const std::vector&lt;float&gt;&amp; in_fpfh_descriptor, double&amp; out_label, std::vector&lt;double&gt;&amp; out_scores, double&amp; out_sum_scores);
-
-	void CloseModel();
-};
-
-void SvmDetect::CloseModel()
-{
-	fclose(model_file_handle_);
-}
-
-SvmDetect::~SvmDetect()
-{
-}
-
-SvmDetect::SvmDetect() :
-		node_handle_("~")
-{
-
-}
-
-void SvmDetect::Run()
-{
-	ros::NodeHandle private_node_handle("~");
-	std::string clusters_node_name,
-			out_clusters_topic_name = "/cloud_clusters_class",
-			out_pictograms_topic_name="/pictogram_clusters_class";
-
-	private_node_handle.param&lt;std::string&gt;("svm_model_file_path", model_file_path_, "models/svm.model");	ROS_INFO("svm_model_file_path: %s", model_file_path_.c_str());
-	private_node_handle.param&lt;std::string&gt;("clusters_node_name", clusters_node_name, "/cloud_clusters");	ROS_INFO("clusters_node_name: %s", clusters_node_name.c_str());
-
-	cloud_clusters_sub_ = node_handle_.subscribe(clusters_node_name, 10, &amp;SvmDetect::CloudClustersCallback, this);
-	cloud_clusters_pub_ = node_handle_.advertise&lt;autoware_msgs::CloudClusterArray&gt;(out_clusters_topic_name, 10); ROS_INFO("output clusters topic: %s", out_clusters_topic_name.c_str());
-
-	/*text_pictogram_pub_ = node_handle_.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;(out_pictograms_topic_name, 10); ROS_INFO("output pictograms topic: %s", out_pictograms_topic_name.c_str());
-
-	model_ptr_ = LoadSvmModel(model_file_path_);
-
-	if(model_ptr_ == NULL)
-	{
-		ROS_INFO("SvmDetect. Cannot perform classification. Invalid model file.");
-	}
-	else
-	{
-		ROS_INFO("SvmDetect. Ready, waiting for clusters...");
-	}*/
-	ros::spin();
-
-}
-
-
-void SvmDetect::CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr)
-{
-	cloud_clusters_pub_.publish(*in_cloud_cluster_array_ptr);
-	return;
-}
-
-int main(int argc, char **argv)
-{
-	ros::init(argc, argv, "svm_lidar_detect");
-
-	SvmDetect node;
-
-	node.Run();
-
-	return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_filling\vscan_filling.cpp" new_path="" added_lines="0" deleted_lines="109">
				<diff>@@ -1,109 +0,0 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include &lt;ros/ros.h&gt;
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-
-#include &lt;visualization_msgs/Marker.h&gt;
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-#include &lt;pcl_conversions/pcl_conversions.h&gt;
-#include &lt;pcl/io/io.h&gt;
-#include &lt;pcl/io/pcd_io.h&gt;
-#include &lt;pcl/point_types.h&gt;
-
-
-
-static ros::Publisher _pub;
-const std::string FRAME = "/velodyne";
-
-static void Callback(const sensor_msgs::PointCloud2ConstPtr&amp; msg)
-{
-	pcl::PointCloud&lt;pcl::PointXYZ&gt; vscan;
-	pcl::fromROSMsg(*msg, vscan);
-
-	pcl::PointCloud&lt;pcl::PointXYZ&gt; filling_cloud;
-
-	for (pcl::PointCloud&lt;pcl::PointXYZ&gt;::const_iterator item = vscan.begin(); item != vscan.end(); item++) {
-		if ((item-&gt;x == 0 &amp;&amp; item-&gt;y == 0))
-			continue;
-
-		pcl::PointXYZ p;
-
-		//push back bottom pointcloud
-    p.x = item-&gt;x;
-		p.y = item-&gt;y;
-		p.z = item-&gt;z;
-    filling_cloud.points.push_back(p);
-
-		double bottom_z = item-&gt;z;
-	//	std::cout &lt;&lt; "bottom : " &lt;&lt;   bottom_z &lt;&lt; std::endl;
-		item++;
-
-		//move to top pointcloud
-		double top_z = item-&gt;z;
-	//	std::cout &lt;&lt; "top : " &lt;&lt;   top_z &lt;&lt; std::endl;
-
-		//filling pointcloud
-		double step = 0.3; //meter
-		int i = 1;
-		while(1){
-			p.z = bottom_z + step * (double)i;
-		//	std::cout &lt;&lt; i &lt;&lt; " : " &lt;&lt;   p.z &lt;&lt; std::endl;
-
-			if(p.z &gt; top_z)
-				break;
-			filling_cloud.points.push_back(p);
-			i++;
-		}
-
-		//push back top pointcloud
-		p.z = item-&gt;z;
-		filling_cloud.points.push_back(p);
-
-	}
-
-	sensor_msgs::PointCloud2::Ptr map_ptr(new sensor_msgs::PointCloud2);
-	pcl::toROSMsg(filling_cloud, *map_ptr);
-	map_ptr-&gt;header = msg-&gt;header;
-	_pub.publish(*map_ptr);
-
-}
-
-int main(int argc, char *argv[])
-{
-	ros::init(argc, argv, "vscan_filling");
-	ros::NodeHandle nh;
-
-	_pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;("/vscan_filling_cloud", 1, true);
-	ros::Subscriber sub = nh.subscribe("vscan_points", 100, Callback);
-
-	ros::spin();
-	return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\main.cpp" new_path="" added_lines="0" deleted_lines="11">
				<diff>@@ -1,11 +0,0 @@
-#include "mainwindow.h"
-#include &lt;QApplication&gt;
-
-int main(int argc, char *argv[])
-{
-    QApplication a(argc, argv);
-    MainWindow w;
-    w.show();
-
-    return a.exec();
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\mainwindow.cpp" new_path="" added_lines="0" deleted_lines="492">
				<diff>@@ -1,492 +0,0 @@
-#include "mainwindow.h"
-#include "ui_mainwindow.h"
-
-InitTrackerView::InitTrackerView(QWidget * parent)
-    : QGraphicsView(parent)
-{
-    scene=new QGraphicsScene;
-    scene-&gt;setSceneRect(-5000,-5000,10000,10000);
-    this-&gt;setScene(scene);
-    sx=sy=15;
-    this-&gt;scale(sx,sy);
-}
-
-void InitTrackerView::showLaserScan(LaserScan &amp; scan)
-{
-    scene-&gt;clear();
-    state.clear();
-    double density=2*PI/scan.beamnum;
-    for(int i=0;i&lt;scan.beamnum;i++)
-    {
-        double theta=i*density-PI;
-        double x=scan.length[i]*cos(theta);
-        double y=scan.length[i]*sin(theta);
-        scene-&gt;addEllipse(-y-0.05,-x-0.05,0.1,0.1,QPen(Qt::blue,0.1))-&gt;setZValue(1);
-    }
-    for(int i=10;i&lt;=100;i+=10)
-    {
-        scene-&gt;addEllipse(-i/2,-i/2,i,i,QPen(Qt::gray,0.2,Qt::DotLine))-&gt;setZValue(0);
-    }
-    scene-&gt;addLine(0,0,0,-5,QPen(Qt::red,0.2,Qt::DotLine))-&gt;setZValue(0);
-    scene-&gt;addLine(0,0,-5,0,QPen(Qt::green,0.2,Qt::DotLine))-&gt;setZValue(0);
-}
-
-void InitTrackerView::getInitState(QVector&lt;VehicleState&gt; &amp;initState)
-{
-    int statenum=state.size();
-    initState.resize(statenum);
-    for(int i=0;i&lt;statenum;i++)
-    {
-        initState[i].x=-state[i]-&gt;line().p1().y();
-        initState[i].y=-state[i]-&gt;line().p1().x();
-        initState[i].theta=atan2(state[i]-&gt;line().p1().x()-state[i]-&gt;line().p2().x(),state[i]-&gt;line().p1().y()-state[i]-&gt;line().p2().y());
-        initState[i].wl=1.5;initState[i].wr=1.5;initState[i].lf=2.5;initState[i].lb=2.5;
-        initState[i].a=0;initState[i].v=10;initState[i].k=0;initState[i].omega=0;
-    }
-}
-
-void InitTrackerView::mousePressEvent(QMouseEvent * event)
-{
-    switch(event-&gt;button())
-    {
-    case Qt::LeftButton:
-        if(pressflag)
-        {
-            point2=this-&gt;mapToScene(event-&gt;pos());
-            lineitem=scene-&gt;addLine(point1.x(),point1.y(),point2.x(),point2.y(),QPen(Qt::red,0.2));
-            lineitem-&gt;setZValue(2);
-            state.push_back(lineitem);
-            scene-&gt;removeItem(point1item);
-            delete point1item;
-            pressflag=0;
-        }
-        else
-        {
-            point1=this-&gt;mapToScene(event-&gt;pos());
-            point1item=scene-&gt;addEllipse(point1.x()-0.05,point1.y()-0.05,0.1,0.1,QPen(Qt::red,0.2));
-            point1item-&gt;setZValue(2);
-            pressflag=1;
-        }
-        break;
-    case Qt::RightButton:
-        if(pressflag)
-        {
-            scene-&gt;removeItem(point1item);
-            delete point1item;
-            pressflag=0;
-        }
-        else
-        {
-            QGraphicsLineItem * item=(QGraphicsLineItem *)(this-&gt;itemAt(event-&gt;pos()));
-            if(state.contains(item))
-            {
-                scene-&gt;removeItem(item);
-                delete item;
-            }
-        }
-        break;
-    default:
-        QGraphicsView::mousePressEvent(event);
-        break;
-    }
-}
-
-void InitTrackerView::wheelEvent(QWheelEvent *event)
-{
-    if(ctrlflag)
-    {
-        if(event-&gt;delta()&gt;0)
-        {
-            sx*=1.1;sy*=1.1;
-            this-&gt;scale(1.1,1.1);
-        }
-        else
-        {
-            sx*=0.9;sy*=0.9;
-            this-&gt;scale(0.9,0.9);
-        }
-    }
-    else
-    {
-        QGraphicsView::wheelEvent(event);
-    }
-}
-
-void InitTrackerView::keyPressEvent(QKeyEvent *event)
-{
-    switch(event-&gt;key())
-    {
-    case Qt::Key_Control:
-        ctrlflag=1;
-        break;
-    default:
-        QGraphicsView::keyPressEvent(event);
-        break;
-    }
-}
-
-void InitTrackerView::keyReleaseEvent(QKeyEvent *event)
-{
-    switch(event-&gt;key())
-    {
-    case Qt::Key_Control:
-        ctrlflag=0;
-        break;
-    default:
-        QGraphicsView::keyReleaseEvent(event);
-        break;
-    }
-}
-
-UpdateTrackerView::UpdateTrackerView(QWidget *parent)
-    : QGraphicsView(parent)
-{
-    scene=new QGraphicsScene;
-    scene-&gt;setSceneRect(-5000,-5000,10000,10000);
-    this-&gt;setScene(scene);
-    sx=sy=15;
-    this-&gt;scale(sx,sy);
-}
-
-//function to handle final tracking result stored in trackerresultmap [vehicleID, tracking result]
-void UpdateTrackerView::slotUpdateTrackerFinish(LaserScan scan, QMap&lt;int, TrackerResultContainer&gt; trackerresultmap)
-{
-    scene-&gt;clear();
-
-    QTransform transform;
-    transform.rotateRadians(-scan.theta);
-    transform.translate(-scan.y,-scan.x);
-    transform.scale(sx,sy);
-    setTransform(transform);
-
-    centerOn(0,0);
-
-    double density=2*PI/scan.beamnum;
-    for(int i=0;i&lt;scan.beamnum;i++)
-    {
-        double theta=i*density-PI;
-        double x=scan.length[i]*cos(theta);
-        double y=scan.length[i]*sin(theta);
-        scene-&gt;addEllipse(-y-0.05,-x-0.05,0.1,0.1,QPen(Qt::blue,0.1))-&gt;setZValue(1);
-    }
-    for(int i=10;i&lt;=100;i+=10)
-    {
-        scene-&gt;addEllipse(-i/2,-i/2,i,i,QPen(Qt::gray,0.2,Qt::DotLine))-&gt;setZValue(0);
-    }
-    scene-&gt;addLine(0,0,0,-5,QPen(Qt::red,0.2,Qt::DotLine))-&gt;setZValue(0);
-    scene-&gt;addLine(0,0,-5,0,QPen(Qt::green,0.2,Qt::DotLine))-&gt;setZValue(0);
-
-    QList&lt;int&gt; curidlist=pathmap.keys();
-    QList&lt;int&gt; trackidlist=trackerresultmap.keys();
-    //for loop to get all tracking results
-    for(int i=0;i&lt;trackidlist.size();i++)
-    {
-        //get one tracking result stored in trackerresult
-        TrackerResultContainer trackerresult=trackerresultmap[trackidlist[i]];
-        //for loop to draw rectangle of vehicle. the corner is represented as (cx[i],cy[i]) (0&lt;=i&lt;=3)
-        for(int j=0;j&lt;4;j++)
-        {
-            scene-&gt;addLine(-trackerresult.estimate.cy[j],-trackerresult.estimate.cx[j],-trackerresult.estimate.cy[(j+1)%4],-trackerresult.estimate.cx[(j+1)%4],QPen(Qt::red,0.1,Qt::DotLine));
-        }
-        scene-&gt;addLine(-trackerresult.estimate.cy[0],-trackerresult.estimate.cx[0],-trackerresult.estimate.cy[2],-trackerresult.estimate.cx[2],QPen(Qt::red,0.1,Qt::DotLine));
-        scene-&gt;addLine(-trackerresult.estimate.cy[1],-trackerresult.estimate.cx[1],-trackerresult.estimate.cy[3],-trackerresult.estimate.cx[3],QPen(Qt::red,0.1,Qt::DotLine));
-
-        for(int j=0;j&lt;2;j++)
-        {
-            for(int k=0;k&lt;trackerresult.edgepointnum[j];k++)
-            {
-                int id=trackerresult.edgepointid[j][k];
-                double theta=id*density-PI;
-                double x=scan.length[id]*cos(theta);
-                double y=scan.length[id]*sin(theta);
-                scene-&gt;addEllipse(-y-0.05,-x-0.05,0.1,0.1,QPen(Qt::green,0.1))-&gt;setZValue(2);
-            }
-        }
-    }
-
-    for(int i=0;i&lt;curidlist.size();i++)
-    {
-        bool flag=trackidlist.contains(curidlist[i]);
-        if(!flag)
-        {
-            pathmap.remove(curidlist[i]);
-        }
-    }
-}
-
-void UpdateTrackerView::wheelEvent(QWheelEvent *event)
-{
-    if(ctrlflag)
-    {
-        if(event-&gt;delta()&gt;0)
-        {
-            sx*=1.1;sy*=1.1;
-            this-&gt;scale(1.1,1.1);
-        }
-        else
-        {
-            sx*=0.9;sy*=0.9;
-            this-&gt;scale(0.9,0.9);
-        }
-    }
-    else
-    {
-        QGraphicsView::wheelEvent(event);
-    }
-}
-
-void UpdateTrackerView::keyPressEvent(QKeyEvent *event)
-{
-    switch(event-&gt;key())
-    {
-    case Qt::Key_Control:
-        ctrlflag=1;
-        break;
-    default:
-        QGraphicsView::keyPressEvent(event);
-        break;
-    }
-}
-
-void UpdateTrackerView::keyReleaseEvent(QKeyEvent *event)
-{
-    switch(event-&gt;key())
-    {
-    case Qt::Key_Control:
-        ctrlflag=0;
-        break;
-    default:
-        QGraphicsView::keyReleaseEvent(event);
-        break;
-    }
-}
-
-MainWindow::MainWindow(QWidget *parent) :
-    QMainWindow(parent),
-    ui(new Ui::MainWindow)
-{
-    ui-&gt;setupUi(this);
-
-    scansub=new ROSSub&lt;sensor_msgs::LaserScanConstPtr&gt;("/scan",1000,10,this);
-    //detectionsub=new ROSSub&lt;autoware_msgs::obj_label::ConstPtr&gt;("obj_label",1000,10,this);
-    boxessub=new ROSSub&lt;jsk_recognition_msgs::BoundingBoxArray::ConstPtr&gt;("bounding_boxes",1000,10,this);
-    tfsub=new ROSTFSub("/world","/velodyne",10,this);
-    tfMap2Lidarsub=new ROSTFSub("/velodyne","/map",10,this); // obj_pose is published into "map" frame
-
-
-    //subscribe vehicle detection results (array of [x,y,theta])
-
-    connect(scansub,SIGNAL(receiveMessageSignal()),this,SLOT(slotReceive()));
-    //connect(detectionsub,SIGNAL(receiveMessageSignal()), this, SLOT(slotReceiveDetection()));
-    connect(boxessub,SIGNAL(receiveMessageSignal()), this, SLOT(slotReceiveBoxes()));
-    connect(tfsub,SIGNAL(receiveTFSignal()),this,SLOT(slotReceiveTF()));
-    connect(tfMap2Lidarsub,SIGNAL(receiveTFSignal()),this,SLOT(slotReceiveTFMap2Lidar()));
-
-    QSplitter * splitter=new QSplitter(Qt::Horizontal);
-    ui-&gt;layout-&gt;addWidget(splitter);
-
-    initview=new InitTrackerView;
-    splitter-&gt;addWidget(initview);
-
-    updateview=new UpdateTrackerView;
-    splitter-&gt;addWidget(updateview);
-
-    vehicletracker=new RBSSPFVehicleTracker;
-    connect(vehicletracker,SIGNAL(signalUpdateTrackerFinish(LaserScan,QMap&lt;int,TrackerResultContainer&gt;)),updateview,SLOT(slotUpdateTrackerFinish(LaserScan,QMap&lt;int,TrackerResultContainer&gt;)));
-
-    scansub-&gt;startReceiveSlot();
-    //detectionsub-&gt;startReceiveSlot();
-    boxessub-&gt;startReceiveSlot();
-    tfsub-&gt;startReceiveSlot();
-    tfMap2Lidarsub-&gt;startReceiveSlot();
-}
-
-MainWindow::~MainWindow()
-{
-    scansub-&gt;stopReceiveSlot();
-    //detectionsub-&gt;stopReceiveSlot();
-    boxessub-&gt;stopReceiveSlot();
-    tfsub-&gt;stopReceiveSlot();
-    tfMap2Lidarsub-&gt;stopReceiveSlot();
-    delete ui;
-}
-
-void MainWindow::slotReceive()
-{
-    sensor_msgs::LaserScanConstPtr msg=scansub-&gt;getMessage();
-    int msec=(msg-&gt;header.stamp.sec)%(24*60*60)*1000+(msg-&gt;header.stamp.nsec)/1000000;
-    QTime timestamp=QTime::fromMSecsSinceStartOfDay(msec);
-    LaserScan scan;
-    scan.timestamp=timestamp.msecsSinceStartOfDay();
-    scan.beamnum=msg-&gt;ranges.size();
-    for(int i=0;i&lt;scan.beamnum;i++)
-    {
-        scan.length[i]=msg-&gt;ranges[i];
-    }
-    scanlist.push_back(QPair&lt;QTime, LaserScan &gt;(timestamp,scan));
-    if(ui-&gt;trigger-&gt;isChecked())
-    {
-        slotShowScan();
-    }
-}
-
-void MainWindow::slotReceiveDetection()
-{
-    autoware_msgs::obj_label::ConstPtr msg=detectionsub-&gt;getMessage();
-
-    for (const auto&amp; point : msg-&gt;reprojected_pos) {
-        int msec=(msg-&gt;header.stamp.sec)%(24*60*60)*1000+(msg-&gt;header.stamp.nsec)/1000000;
-        QTime timestamp=QTime::fromMSecsSinceStartOfDay(msec);
-        VehicleState state;
-        //fill state from msg;
-        // convert object position from map coordinate to sensor coordinate
-        tf::Vector3 pt(point.x, point.y, point.z);
-        tf::Vector3 converted = transformMap2Lidar * pt;
-        state.x = converted.x();
-        state.y = converted.y();
-
-        detectionlist.push_back(QPair&lt;QTime, VehicleState &gt;(timestamp,state));
-        if(ui-&gt;trigger-&gt;isChecked())
-            {
-                slotShowScan();
-            }
-    }
-}
-
-void MainWindow::slotReceiveBoxes()
-{
-	jsk_recognition_msgs::BoundingBoxArray::ConstPtr msg=boxessub-&gt;getMessage();
-    for (const auto&amp; box : msg-&gt;boxes) {
-        int msec=(msg-&gt;header.stamp.sec)%(24*60*60)*1000+(msg-&gt;header.stamp.nsec)/1000000;
-        QTime timestamp=QTime::fromMSecsSinceStartOfDay(msec);
-        VehicleState vstate;
-        //fill state from msg;
-        // convert object position from map coordinate to sensor coordinate
-        tf::Vector3 pt(box.pose.position.x, box.pose.position.y, box.pose.position.z);
-        //tf::Vector3 converted = transformMap2Lidar * pt;
-        vstate.x = pt.x();
-        vstate.y = pt.y();
-        tf::Quaternion quat;
-        tf::quaternionMsgToTF(box.pose.orientation, quat);
-        vstate.theta = tf::getYaw(quat);
-
-        detectionlist.push_back(QPair&lt;QTime, VehicleState &gt;(timestamp,vstate));
-        if(ui-&gt;trigger-&gt;isChecked())
-            {
-                slotShowScan();
-            }
-    }
-}
-
-void MainWindow::slotReceiveTF()
-{
-    tf::StampedTransform tf;
-    tfsub-&gt;getTF(tf);
-    int msec=(tf.stamp_.sec)%(24*60*60)*1000+(tf.stamp_.nsec)/1000000;
-    QTime timestamp=QTime::fromMSecsSinceStartOfDay(msec);
-
-    tf::Vector3 pos=tf.getOrigin();
-    tf::Matrix3x3 rot=tf.getBasis();
-    Eigen::Vector3d head;
-    head(0)=1;head(1)=0;head(2)=0;
-    Eigen::Matrix3d rotmat;
-    for(int i=0;i&lt;3;i++)
-    {
-        rotmat(i,0)=(double)(rot.getRow(i).x());
-        rotmat(i,1)=(double)(rot.getRow(i).y());
-        rotmat(i,2)=(double)(rot.getRow(i).z());
-    }
-    head=rotmat*head;
-    EGOMOTION ego={pos.x(),pos.y(),atan2(head(1),head(0))};
-
-    tflist.push_back(QPair&lt;QTime,EGOMOTION&gt;(timestamp,ego));
-
-    if(ui-&gt;trigger-&gt;isChecked())
-    {
-        slotShowScan();
-    }
-}
-
-
-void MainWindow::slotReceiveTFMap2Lidar()
-{
-    tfMap2Lidarsub-&gt;getTF(transformMap2Lidar);
-}
-
-
-void MainWindow::getInitStateFromTopic(QVector&lt;VehicleState&gt; &amp;initState)
-{
-    for (auto&amp; detected : detectionlist)
-    {
-        initState.push_back(detected.second);
-    }
-    detectionlist.clear();
-}
-
-void MainWindow::slotShowScan()
-{
-    //synchronization between vscan and tf
-    bool flag=1;
-    while(flag&amp;&amp;!scanlist.isEmpty()&amp;&amp;!tflist.isEmpty())
-    {
-        QTime scantime=scanlist[0].first;
-        QTime tftime=tflist[0].first;
-        if(scantime==tftime)
-        {
-            flag=0;
-        }
-        else if(scantime&gt;tftime)
-        {
-            tflist.pop_front();
-        }
-        else
-        {
-            scanlist.pop_front();
-        }
-    }
-
-    int scannum=scanlist.size();
-    int tfnum=tflist.size();
-    //it's better to synchronize detection with them
-
-
-    if(scannum&gt;=1&amp;&amp;tfnum&gt;=1)
-    {
-        if(initflag)
-        {
-            //=====================================
-            //fill initstate from subscribed detection topic
-            //=====================================
-            QVector&lt;VehicleState&gt; initstate;
-            //initview-&gt;getInitState(initstate);
-            getInitStateFromTopic(initstate);
-            vehicletracker-&gt;addTrackerData(curscan,initstate);
-        }
-        curscan=scanlist[0].second;
-        curscan.x=tflist[0].second.x;
-        curscan.y=tflist[0].second.y;
-        curscan.theta=tflist[0].second.theta;
-        initview-&gt;showLaserScan(curscan);
-        initflag=1;
-
-        scanlist.pop_front();
-        //detectionlist.pop_front();
-        tflist.pop_front();
-
-        if(ui-&gt;local-&gt;isChecked())
-        {
-            QTransform transform;
-            transform.scale(initview-&gt;sx,initview-&gt;sy);
-            initview-&gt;setTransform(transform);
-        }
-        else
-        {
-            QTransform transform;
-            transform.rotateRadians(-curscan.theta);
-            transform.translate(-curscan.y,-curscan.x);
-            transform.scale(initview-&gt;sx,initview-&gt;sy);
-            initview-&gt;setTransform(transform);
-        }
-        initview-&gt;centerOn(0,0);
-    }
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\mainwindow.h" new_path="" added_lines="0" deleted_lines="128">
				<diff>@@ -1,128 +0,0 @@
-#ifndef MAINWINDOW_H
-#define MAINWINDOW_H
-
-#include&lt;QMainWindow&gt;
-#include&lt;rosinterface/rosinterface.h&gt;
-#include&lt;sensor_msgs/LaserScan.h&gt;
-#include&lt;sensor_msgs/PointCloud2.h&gt;
-#include&lt;visualization_msgs/MarkerArray.h&gt;
-#include "autoware_msgs/obj_label.h"
-
-#include&lt;QGraphicsView&gt;
-#include&lt;QGraphicsScene&gt;
-#include&lt;QGraphicsLineItem&gt;
-#include&lt;QGraphicsEllipseItem&gt;
-#include&lt;QGraphicsPathItem&gt;
-#include&lt;QPainterPath&gt;
-#include&lt;QLayout&gt;
-#include&lt;QMouseEvent&gt;
-#include&lt;QKeyEvent&gt;
-#include&lt;QWheelEvent&gt;
-#include&lt;QPointF&gt;
-#include&lt;QListWidget&gt;
-#include&lt;QMap&gt;
-#include&lt;QTime&gt;
-#include&lt;QList&gt;
-#include&lt;QPair&gt;
-#include&lt;QSplitter&gt;
-#include&lt;Eigen/Dense&gt;
-
-#include&lt;rbsspfvehicletracker.h&gt;
-
-
-#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
-#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-
-namespace Ui {
-class MainWindow;
-}
-
-// using namespace RobotSDK;
-
-class InitTrackerView : public QGraphicsView
-{
-    Q_OBJECT
-public:
-    InitTrackerView(QWidget * parent=NULL);
-public:
-    void showLaserScan(LaserScan &amp; scan);
-    void getInitState(QVector&lt;VehicleState&gt; &amp; initState);
-protected:
-    void mousePressEvent(QMouseEvent *event);
-    void wheelEvent(QWheelEvent *event);
-    void keyPressEvent(QKeyEvent *event);
-    void keyReleaseEvent(QKeyEvent *event);
-protected:
-    bool pressflag=0;
-    bool ctrlflag=0;
-    QPointF point1,point2;
-    QGraphicsEllipseItem * point1item;
-    QGraphicsLineItem * lineitem;
-public:
-    double sx=1,sy=1;
-    QGraphicsScene * scene=NULL;
-    LaserScan scan;
-    QVector&lt;QGraphicsLineItem *&gt; state;
-};
-
-class UpdateTrackerView : public QGraphicsView
-{
-    Q_OBJECT
-public:
-    UpdateTrackerView(QWidget * parent=NULL);
-public slots:
-    void slotUpdateTrackerFinish(LaserScan scan, QMap&lt;int, TrackerResultContainer&gt; trackerresultmap);
-protected:
-    void wheelEvent(QWheelEvent *event);
-    void keyPressEvent(QKeyEvent *event);
-    void keyReleaseEvent(QKeyEvent *event);
-protected:
-    bool ctrlflag=0;
-    QMap&lt;int, QGraphicsPathItem *&gt; pathmap;
-public:
-    double sx=1,sy=1;
-    QGraphicsScene * scene=NULL;
-};
-
-struct EGOMOTION
-{
-    double x,y,theta;
-};
-
-class MainWindow : public QMainWindow
-{
-    Q_OBJECT
-public:
-    explicit MainWindow(QWidget *parent = 0);
-    ~MainWindow();
-    void getInitStateFromTopic(QVector&lt;VehicleState&gt; &amp; initState);
-private:
-    Ui::MainWindow *ui;
-public:
-    ROSSub&lt;sensor_msgs::LaserScanConstPtr&gt; * scansub;
-    ROSSub&lt;autoware_msgs::obj_label::ConstPtr&gt; * detectionsub;
-    ROSSub&lt;jsk_recognition_msgs::BoundingBoxArray::ConstPtr&gt; * boxessub;
-    ROSTFSub * tfsub;
-    ROSTFSub * tfMap2Lidarsub;
-    QList&lt; QPair&lt;QTime,LaserScan&gt; &gt; scanlist;
-    QList&lt; QPair&lt;QTime,VehicleState&gt; &gt; detectionlist;
-    QList&lt; QPair&lt;QTime,EGOMOTION&gt; &gt; tflist;
-public:
-    RBSSPFVehicleTracker * vehicletracker;
-    LaserScan curscan;
-public:
-    InitTrackerView * initview;
-    UpdateTrackerView * updateview;
-    bool initflag=0;
-public slots:
-    void slotReceive();
-    void slotReceiveDetection();
-    void slotReceiveBoxes();
-    void slotReceiveTF();
-    void slotReceiveTFMap2Lidar();
-    void slotShowScan();
-private:
-    tf::StampedTransform transformMap2Lidar;
-};
-
-#endif // MAINWINDOW_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\rbsspfvehicletracker.cpp" new_path="" added_lines="0" deleted_lines="222">
				<diff>@@ -1,222 +0,0 @@
-#include "rbsspfvehicletracker.h"
-
-
-RBSSPFVehicleTrackerInstance::RBSSPFVehicleTrackerInstance(int vehicleID, QThread *thread)
-    : QObject(NULL)
-{
-    id=vehicleID;
-    trackerstate=InitGeometry;
-    cuda_OpenTracker(trackerdatacontainer);
-    this-&gt;moveToThread(thread);
-    connect(thread,SIGNAL(finished()),this,SLOT(deleteLater()));
-    thread-&gt;start();
-}
-
-RBSSPFVehicleTrackerInstance::~RBSSPFVehicleTrackerInstance()
-{
-    cuda_CloseTracker(trackerdatacontainer);
-}
-
-void RBSSPFVehicleTrackerInstance::slotCheckInitState(int initNum, VehicleState * initState, bool * initFlag)
-{
-    for(int i=0;i&lt;initNum;i++)
-    {
-        double tmpdx=initState[i].x-trackerresultcontainer.estimate.x;
-        double tmpdy=initState[i].y-trackerresultcontainer.estimate.y;
-        double dx=tmpdx*cos(-trackerresultcontainer.estimate.theta)-tmpdy*sin(-trackerresultcontainer.estimate.theta);
-        double dy=tmpdx*sin(-trackerresultcontainer.estimate.theta)+tmpdy*cos(-trackerresultcontainer.estimate.theta);
-        if((dx&lt;=trackerresultcontainer.estimate.wl+MARGIN2)
-                &amp;&amp;(dx&gt;=-trackerresultcontainer.estimate.wr-MARGIN2)
-                &amp;&amp;(dy&lt;=trackerresultcontainer.estimate.lf+MARGIN2)
-                &amp;&amp;(dy&gt;=-trackerresultcontainer.estimate.lb-MARGIN2))
-        {
-            initFlag[i]=0;
-        }
-    }
-    emit signalCheckInitStateFinish();
-    return;
-}
-
-void RBSSPFVehicleTrackerInstance::slotUpdateTracker(QMap&lt;int, VehicleState&gt; * initStateMap)
-{
-    switch(trackerstate)
-    {
-    case InitGeometry:
-        trackerstate=InitMotion;
-        trackerresultcontainer.estimate=(*initStateMap)[id];
-        cuda_InitGeometry(trackerdatacontainer,trackerresultcontainer);
-        break;
-    case InitMotion:
-        trackerstate=UpdateTracker;
-        cuda_InitMotion(trackerdatacontainer,trackerresultcontainer);
-        break;
-    case UpdateTracker:
-//        cuda_InitMotion(trackerdatacontainer,trackerresultcontainer);
-        cuda_UpdateTracker(trackerdatacontainer,trackerresultcontainer);
-        break;
-    default:
-        return;
-    }
-    emit signalUpdateTrackerFinish(id,&amp;trackerresultcontainer);
-    return;
-}
-
-RBSSPFVehicleTracker::RBSSPFVehicleTracker()
-    : QObject(NULL)
-{
-    //qRegisterMetaType&lt;TrackerResultContainer&gt;("TrackerResultContainer");
-    trackerstate=NoLaserData;
-    cuda_InitLaserScan();
-}
-
-RBSSPFVehicleTracker::~RBSSPFVehicleTracker()
-{
-    QList&lt;QThread *&gt; threadlist=trackerthreadmap.values();
-    int i,n=threadlist.size();
-    for(i=0;i&lt;n;i++)
-    {
-        threadlist[i]-&gt;exit();
-        threadlist[i]-&gt;wait();
-    }
-    cuda_FreeLaserScan();
-}
-
-void RBSSPFVehicleTracker::addTrackerData(LaserScan &amp; scan, QVector&lt;VehicleState&gt; &amp; initState)
-{
-    switch(trackerstate)
-    {
-    case NoLaserData:
-        trackerstate=OneLaserData;
-        cuda_SetLaserScan(scan);
-        break;
-    case OneLaserData:
-        trackerstate=ReadyForTracking;
-        cuda_SetLaserScan(scan);
-        break;
-    case ReadyForTracking:
-        trackerstate=Processing;
-        cuda_SetLaserScan(scan);
-        curscan=scan;
-        initnum=initState.size();
-        if(initnum&gt;0)
-        {
-            initstate=initState;
-            initflag.fill(1,initnum);
-            trackercount=trackerthreadmap.size();
-            if(trackercount&gt;0)
-            {
-                emit signalCheckInitState(initnum,initstate.data(),initflag.data());
-            }
-            else
-            {
-                slotCheckInitStateFinish();
-            }
-        }
-        else if(trackerthreadmap.size()&gt;0)
-        {
-            initstatemap.clear();
-            trackercount=trackerthreadmap.size();
-            emit signalUpdateTracker(&amp;initstatemap);
-        }
-        else
-        {
-            trackerstate=ReadyForTracking;
-            emit signalUpdateTrackerFinish(curscan,trackerresultmap);
-        }
-        break;
-    case Processing:
-        scanbuffer.push_back(scan);
-        initstatebuffer.push_back(initState);
-        break;
-    }
-}
-
-void RBSSPFVehicleTracker::slotCheckInitStateFinish()
-{
-    trackercount--;
-
-    if(trackercount&lt;=0)
-    {
-        initstatemap.clear();
-        int i,n=initflag.size();
-        for(i=0;i&lt;n;i++)
-        {
-            if(initflag[i])
-            {
-                initstatemap.insert(idcount,initstate[i]);
-
-                QThread * thread=new QThread;
-                RBSSPFVehicleTrackerInstance * trackerinstance=new RBSSPFVehicleTrackerInstance(idcount,thread);
-                trackerresultmap.insert(idcount,TrackerResultContainer());
-                trackerthreadmap.insert(idcount,thread);
-                discontinuemap.insert(idcount,0);
-
-                connect(this,SIGNAL(signalCheckInitState(int,VehicleState*,bool*)),trackerinstance,SLOT(slotCheckInitState(int,VehicleState*,bool*)));
-                connect(this,SIGNAL(signalUpdateTracker(QMap&lt;int,VehicleState&gt;*)),trackerinstance,SLOT(slotUpdateTracker(QMap&lt;int,VehicleState&gt;*)));
-
-                connect(trackerinstance,SIGNAL(signalCheckInitStateFinish()),this,SLOT(slotCheckInitStateFinish()));
-                connect(trackerinstance,SIGNAL(signalUpdateTrackerFinish(int,TrackerResultContainer *)),this,SLOT(slotUpdateTrackerFinish(int,TrackerResultContainer *)));
-
-                idcount++;
-            }
-        }
-
-        trackercount=trackerthreadmap.size();
-        emit signalUpdateTracker(&amp;initstatemap);
-    }
-}
-
-void RBSSPFVehicleTracker::slotUpdateTrackerFinish(int vehicleID, TrackerResultContainer * trackerResult)
-{
-    trackercount--;
-
-    trackerresultmap[vehicleID]=*trackerResult;
-    if(trackerResult-&gt;estimate.dx&gt;1||trackerResult-&gt;estimate.dy&gt;1||trackerResult-&gt;estimate.dtheta&gt;DEG2RAD(20)||trackerResult-&gt;estimate.count&lt;1)
-    {
-        discontinuemap[vehicleID]++;
-    }
-    else
-    {
-        discontinuemap[vehicleID]/=2;
-    }
-    if(discontinuemap[vehicleID]&gt;10)
-    {
-        trackerthreadmap[vehicleID]-&gt;exit();
-        trackerresultmap.remove(vehicleID);
-        trackerthreadmap.remove(vehicleID);
-        discontinuemap.remove(vehicleID);
-    }
-
-    if(trackercount&lt;=0)
-    {
-        emit signalUpdateTrackerFinish(curscan,trackerresultmap);
-        if(scanbuffer.size()&gt;0)
-        {
-            LaserScan scan=scanbuffer.front();
-            curscan=scan;
-            scanbuffer.pop_front();
-            cuda_SetLaserScan(scan);
-
-            initstate=initstatebuffer.front();
-            initstatebuffer.pop_front();
-
-            initnum=initstate.size();
-            if(initnum&gt;0)
-            {
-                initflag.fill(1,initnum);
-                trackercount=trackerthreadmap.size();
-                emit signalCheckInitState(initnum,initstate.data(),initflag.data());
-            }
-            else
-            {
-                initstatemap.clear();
-                trackercount=trackerthreadmap.size();
-                emit signalUpdateTracker(&amp;initstatemap);
-            }
-        }
-        else
-        {
-            trackerstate=ReadyForTracking;
-        }
-    }
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\rbsspfvehicletracker.cu" new_path="" added_lines="0" deleted_lines="1015">
				<diff>@@ -1,1015 +0,0 @@
-#include"rbsspfvehicletracker.cuh"
-
-//==============================================================================
-
-LaserScan * d_scan=NULL;
-LaserScan h_scan;
-EgoMotion h_egomotion;
-
-//==============================================================================
-
-__host__ __device__
-void deviceBuildModel(VehicleState &amp; state, double &amp; density)
-{
-    double c=cos(state.theta);
-    double s=sin(state.theta);
-
-    state.ox=-c*state.x-s*state.y;
-    state.oy=s*state.x-c*state.y;
-
-    state.cx[0]=c*state.lf-s*state.wl+state.x; state.cy[0]=s*state.lf+c*state.wl+state.y;
-    state.cx[1]=c*state.lf+s*state.wr+state.x; state.cy[1]=s*state.lf-c*state.wr+state.y;
-    state.cx[2]=-c*state.lb+s*state.wr+state.x; state.cy[2]=-s*state.lb-c*state.wr+state.y;
-    state.cx[3]=-c*state.lb-s*state.wl+state.x; state.cy[3]=-s*state.lb+c*state.wl+state.y;
-
-    state.cl[0]=state.cl[2]=state.wl+state.wr;
-    state.cl[1]=state.cl[3]=state.lf+state.lb;
-
-    state.bid[0]=(atan2(state.cy[0],state.cx[0])+PI)/density;
-    state.bid[1]=(atan2(state.cy[1],state.cx[1])+PI)/density;
-    state.bid[2]=(atan2(state.cy[2],state.cx[2])+PI)/density;
-    state.bid[3]=(atan2(state.cy[3],state.cx[3])+PI)/density;
-
-    if(state.ox&gt;state.lf)
-    {
-        if(state.oy&gt;state.wl)
-        {
-            state.eid[0]=0;state.eid[1]=3;
-        }
-        else if(state.oy&lt;-state.wr)
-        {
-            state.eid[0]=0;state.eid[1]=1;
-        }
-        else
-        {
-            state.eid[0]=0;state.eid[1]=-1;
-        }
-    }
-    else if(state.ox&lt;-state.lb)
-    {
-        if(state.oy&gt;state.wl)
-        {
-            state.eid[0]=2;state.eid[1]=3;
-        }
-        else if(state.oy&lt;-state.wr)
-        {
-            state.eid[0]=2;state.eid[1]=1;
-        }
-        else
-        {
-            state.eid[0]=2;state.eid[1]=-1;
-        }
-    }
-    else
-    {
-        if(state.oy&gt;state.wl)
-        {
-            state.eid[0]=3;state.eid[1]=-1;
-        }
-        else if(state.oy&lt;-state.wr)
-        {
-            state.eid[0]=1;state.eid[1]=-1;
-        }
-        else
-        {
-            state.eid[0]=-1;state.eid[1]=-1;
-        }
-    }
-    return;
-}
-
-__host__ __device__
-void deviceMeasureEdge(VehicleState &amp; state, int edgeid, LaserScan * scan, double anneal, int * beamnum, int * beamid, bool uncertainflag)
-{
-    if(state.eid[edgeid]&lt;0)
-    {
-        return;
-    }
-
-    if(uncertainflag)
-    {
-        switch(state.eid[edgeid])
-        {
-        case 0:
-            if(state.dlf&gt;UNCERTAINTHRESH)
-            {
-                return;
-            }
-            break;
-        case 1:
-            if(state.dwr&gt;UNCERTAINTHRESH)
-            {
-                return;
-            }
-            break;
-        case 2:
-            if(state.dlb&gt;UNCERTAINTHRESH)
-            {
-                return;
-            }
-            break;
-        case 3:
-            if(state.dwl&gt;UNCERTAINTHRESH)
-            {
-                return;
-            }
-            break;
-        default:
-            break;
-        }
-    }
-
-    int starteid=state.eid[edgeid];
-    int endeid=(state.eid[edgeid]+1)%4;
-
-    int startbid=state.bid[starteid];
-    int endbid=state.bid[endeid];
-    if(startbid&gt;endbid)
-    {
-        endbid+=scan-&gt;beamnum;
-    }
-
-    int totalbeam=(endbid-startbid)+1;
-    if(totalbeam&lt;=UNCERTAINTHRESH_CNT)
-    {
-        state.eid[edgeid]=-1;
-    }
-
-    double dx1=state.cx[endeid]-state.cx[starteid];
-    double dy1=state.cy[endeid]-state.cy[starteid];
-    double dx2=-dy1/state.cl[starteid];
-    double dy2=dx1/state.cl[starteid];
-
-    double density=2*PI/scan-&gt;beamnum;
-    for(int i=startbid;i&lt;=endbid;i++)
-    {
-        double P[4]={MAXBEAMLENGTH,MAXBEAMLENGTH,MAXBEAMLENGTH,MAXBEAMLENGTH};
-        int tmpid=i%scan-&gt;beamnum;
-        double bear=tmpid*density-PI;
-        double c=cos(bear);
-        double s=sin(bear);
-        double tmpx=c*dx1+s*dy1;
-        double tmpy=s*dx1-c*dy1;
-        if(tmpy!=0)
-        {
-            double beta=tmpx/tmpy*(c*state.cy[starteid]-s*state.cx[starteid])+(c*state.cx[starteid]+s*state.cy[starteid]);
-            if(beta&gt;=MINBEAMLENGTH&amp;&amp;beta&lt;=MAXBEAMLENGTH)
-            {
-                P[2]=beta;
-                double gamma0,gamma1,gamma2;
-                if(beta&lt;NEARESTRING)
-                {
-                    gamma0=fabs(beta-(tmpx/tmpy*(c*(state.cy[starteid]+dy2*beta)-s*(state.cx[starteid]+dx2*beta))+c*(state.cx[starteid]+dx2*beta)+s*(state.cy[starteid]+dy2*beta)));
-                    gamma1=fabs(beta-(tmpx/tmpy*(c*(state.cy[starteid]+dy2*2)-s*(state.cx[starteid]+dx2*2))+c*(state.cx[starteid]+dx2*2)+s*(state.cy[starteid]+dy2*2)));
-                    gamma2=fabs(beta-(tmpx/tmpy*(c*(state.cy[starteid]+dy2*beta)-s*(state.cx[starteid]+dx2*beta))+c*(state.cx[starteid]+dx2*beta)+s*(state.cy[starteid]+dy2*beta)));
-                }
-                else
-                {
-                    gamma0=fabs(beta-(tmpx/tmpy*(c*(state.cy[starteid]+dy2*MARGIN0)-s*(state.cx[starteid]+dx2*MARGIN0))+c*(state.cx[starteid]+dx2*MARGIN0)+s*(state.cy[starteid]+dy2*MARGIN0)));
-                    gamma1=fabs(beta-(tmpx/tmpy*(c*(state.cy[starteid]+dy2*MARGIN1)-s*(state.cx[starteid]+dx2*MARGIN1))+c*(state.cx[starteid]+dx2*MARGIN1)+s*(state.cy[starteid]+dy2*MARGIN1)));
-                    gamma2=fabs(beta-(tmpx/tmpy*(c*(state.cy[starteid]+dy2*MARGIN2)-s*(state.cx[starteid]+dx2*MARGIN2))+c*(state.cx[starteid]+dx2*MARGIN2)+s*(state.cy[starteid]+dy2*MARGIN2)));
-                }
-                P[1]=P[2]-gamma0&gt;=MINBEAMLENGTH?P[2]-gamma0:MINBEAMLENGTH;
-                P[3]=P[2]+gamma1&lt;=MAXBEAMLENGTH?P[2]+gamma1:MAXBEAMLENGTH;
-                P[0]=P[2]-gamma2&gt;=MINBEAMLENGTH?P[2]-gamma2:MINBEAMLENGTH;
-                double tmplogweight;
-                if(scan-&gt;length[tmpid]&lt;=P[0])
-                {
-                    double delta=scan-&gt;length[tmpid]-P[0];
-                    double w1=WEIGHT0-WEIGHT0;
-                    double w2=WEIGHT1-WEIGHT0;
-                    tmplogweight=w1+(w2-w1)*exp(-delta*delta/0.01);
-                }
-                else if(scan-&gt;length[tmpid]&lt;=P[1])
-                {
-                    double delta=scan-&gt;length[tmpid]-P[1];
-                    double w1=WEIGHT1-WEIGHT0;
-                    double w2=WEIGHT2-WEIGHT0;
-                    tmplogweight=w1+(w2-w1)*exp(-delta*delta/0.01);
-                }
-                else if(scan-&gt;length[tmpid]&lt;=P[3])
-                {
-                    if(beta&gt;=NEARESTRING)
-                    {
-                        if(beamnum!=NULL&amp;&amp;beamid!=NULL&amp;&amp;totalbeam&gt;UNCERTAINTHRESH_CNT)
-                        {
-                            if((*beamnum)&lt;MAXEDGEPOINT)
-                            {
-                                beamid[*beamnum]=tmpid;
-                                (*beamnum)++;
-                            }
-                        }
-                        state.count++;
-                    }
-                    double delta=scan-&gt;length[tmpid]-P[2];
-                    double w1=WEIGHT2-WEIGHT0;
-                    double w2=2*w1;
-                    tmplogweight=w1+(w2-w1)*exp(-delta*delta/0.01);
-                }
-                else
-                {
-                    double delta=scan-&gt;length[tmpid]-P[3];
-                    double w1=WEIGHT3-WEIGHT0;
-                    double w2=WEIGHT2-WEIGHT0;
-                    tmplogweight=w1+(w2-w1)*exp(-delta*delta/0.01);
-                }
-                state.weight+=tmplogweight/anneal;
-            }
-        }
-    }
-}
-
-__host__ __device__
-void deviceEgoMotion(VehicleState &amp; state, EgoMotion &amp; egomotion)
-{
-    double c=cos(egomotion.dtheta);
-    double s=sin(egomotion.dtheta);
-    double tmpx=c*state.x-s*state.y+egomotion.dx;
-    double tmpy=s*state.x+c*state.y+egomotion.dy;
-    state.x=tmpx;
-    state.y=tmpy;
-    state.theta+=egomotion.dtheta;
-    return;
-}
-
-__host__ __device__
-void deviceAckermannModel(VehicleState &amp; state0, VehicleState &amp; state1, EgoMotion &amp; egomotion)
-{
-    state1=state0;
-    if(state1.v==0)
-    {
-        deviceEgoMotion(state1,egomotion);
-        return;
-    }
-
-    double c=cos(state1.theta);
-    double s=sin(state1.theta);
-
-    if(state1.k==0)
-    {
-        state1.x=state1.x+c*state1.v*egomotion.dt/1000;
-        state1.y=state1.y+s*state1.v*egomotion.dt/1000;
-        state1.a=0;
-        deviceEgoMotion(state1,egomotion);
-        return;
-    }
-
-    double c0=cos(state1.theta+state1.a);
-    double s0=sin(state1.theta+state1.a);
-    state1.omega=state1.v*state1.k;
-    double dtheta=state1.omega*egomotion.dt/1000;
-    state1.theta+=dtheta;
-    double c1=cos(state1.theta+state1.a);
-    double s1=sin(state1.theta+state1.a);
-    double R=1/state1.k;
-
-    state1.x=state1.x+R*(-s0+s1);
-    state1.y=state1.y+R*(c0-c1);
-    deviceEgoMotion(state1,egomotion);
-    return;
-}
-
-//==============================================================================
-
-__global__
-void kernelSetRandomSeed(int * seed, thrust::minstd_rand * rng, int tmppnum)
-{
-    GetThreadID_1D(id);
-    if(id&gt;=tmppnum)
-    {
-        return;
-    }
-    rng[id]=thrust::minstd_rand(seed[id]);
-    return;
-}
-
-__global__
-void kernelGeometryModel(LaserScan * scan, int pnum, VehicleState * particle, int tmppnum, VehicleState * tmpparticle, thrust::minstd_rand * rng, ObjectStateOffset objectstateoffset, StateConstrain stateconstrain, EgoMotion egomotion)
-{
-    GetThreadID_1D(id);
-    if(id&gt;=tmppnum)
-    {
-        return;
-    }
-    double index=double(pnum)/double(tmppnum);
-    int pid=int(id*index);
-
-    tmpparticle[id]=particle[pid];
-
-    if(objectstateoffset.thetaoff&gt;objectstateoffset.thetaprec)
-    {
-        double thetamin=tmpparticle[id].theta-objectstateoffset.thetaoff;thetamin=thetamin&gt;stateconstrain.thetamin?thetamin:stateconstrain.thetamin;
-        double thetamax=tmpparticle[id].theta+objectstateoffset.thetaoff;thetamax=thetamax&lt;stateconstrain.thetamax?thetamax:stateconstrain.thetamax;
-        tmpparticle[id].theta=thrust::random::uniform_real_distribution&lt;double&gt;(thetamin,thetamax)(rng[id]);
-    }
-
-    double wlmin=tmpparticle[id].wl-objectstateoffset.wloff;wlmin=wlmin&gt;stateconstrain.wlmin?wlmin:stateconstrain.wlmin;
-    double wlmax=tmpparticle[id].wl+objectstateoffset.wloff;wlmax=wlmax&lt;stateconstrain.wlmax?wlmax:stateconstrain.wlmax;
-    tmpparticle[id].wl=thrust::random::uniform_real_distribution&lt;double&gt;(wlmin,wlmax)(rng[id]);
-
-    double wrmin=tmpparticle[id].wr-objectstateoffset.wroff;wrmin=wrmin&gt;stateconstrain.wrmin?wrmin:stateconstrain.wrmin;
-    double wrmax=tmpparticle[id].wr+objectstateoffset.wroff;wrmax=wrmax&lt;stateconstrain.wrmax?wrmax:stateconstrain.wrmax;
-    tmpparticle[id].wr=thrust::random::uniform_real_distribution&lt;double&gt;(wrmin,wrmax)(rng[id]);
-
-    double lfmin=tmpparticle[id].lf-objectstateoffset.lfoff;lfmin=lfmin&gt;stateconstrain.lfmin?lfmin:stateconstrain.lfmin;
-    double lfmax=tmpparticle[id].lf+objectstateoffset.lfoff;lfmax=lfmax&lt;stateconstrain.lfmax?lfmax:stateconstrain.lfmax;
-    tmpparticle[id].lf=thrust::random::uniform_real_distribution&lt;double&gt;(lfmin,lfmax)(rng[id]);
-
-    double lbmin=tmpparticle[id].lb-objectstateoffset.lboff;lbmin=lbmin&gt;stateconstrain.lbmin?lbmin:stateconstrain.lbmin;
-    double lbmax=tmpparticle[id].lb+objectstateoffset.lboff;lbmax=lbmax&lt;stateconstrain.lbmax?lbmax:stateconstrain.lbmax;
-    tmpparticle[id].lb=thrust::random::uniform_real_distribution&lt;double&gt;(lbmin,lbmax)(rng[id]);
-
-    deviceBuildModel(tmpparticle[id],egomotion.density);
-
-    tmpparticle[id].weight=0;
-    tmpparticle[id].count=0;
-    deviceMeasureEdge(tmpparticle[id],0,scan,objectstateoffset.anneal,NULL,NULL,0);
-    deviceMeasureEdge(tmpparticle[id],1,scan,objectstateoffset.anneal,NULL,NULL,0);
-
-    return;
-}
-
-__global__
-void kernelMotionModel(LaserScan * scan, int pnum, VehicleState * particle, int tmppnum, VehicleState * tmpparticle, thrust::minstd_rand * rng, ObjectStateOffset objectstateoffset, StateConstrain stateconstrain, EgoMotion egomotion)
-{
-    GetThreadID_1D(id);
-    if(id&gt;=tmppnum)
-    {
-        return;
-    }
-    double index=double(pnum)/double(tmppnum);
-    int pid=int(id*index);
-
-    tmpparticle[id]=particle[pid];
-
-    if(egomotion.pfflag)
-    {
-        tmpparticle[id].v=thrust::random::normal_distribution&lt;double&gt;(tmpparticle[id].v,objectstateoffset.voff)(rng[id]);
-        tmpparticle[id].v=tmpparticle[id].v&gt;stateconstrain.vmin?tmpparticle[id].v:stateconstrain.vmin;
-        tmpparticle[id].v=tmpparticle[id].v&lt;stateconstrain.vmax?tmpparticle[id].v:stateconstrain.vmax;
-
-        tmpparticle[id].omega=thrust::random::normal_distribution&lt;double&gt;(tmpparticle[id].omega,objectstateoffset.omegaoff)(rng[id]);
-        tmpparticle[id].omega=tmpparticle[id].omega&gt;stateconstrain.omegamin?tmpparticle[id].omega:stateconstrain.omegamin;
-        tmpparticle[id].omega=tmpparticle[id].omega&lt;stateconstrain.omegamax?tmpparticle[id].omega:stateconstrain.omegamax;
-    }
-    else
-    {
-        double vmin=tmpparticle[id].v-objectstateoffset.voff;vmin=vmin&gt;stateconstrain.vmin?vmin:stateconstrain.vmin;
-        double vmax=tmpparticle[id].v+objectstateoffset.voff;vmax=vmax&lt;stateconstrain.vmax?vmax:stateconstrain.vmax;
-        tmpparticle[id].v=thrust::random::uniform_real_distribution&lt;double&gt;(vmin,vmax)(rng[id]);
-
-        double omegamin=tmpparticle[id].omega-objectstateoffset.omegaoff;omegamin=omegamin&gt;stateconstrain.omegamin?omegamin:stateconstrain.omegamin;
-        double omegamax=tmpparticle[id].omega+objectstateoffset.omegaoff;omegamax=omegamax&lt;stateconstrain.omegamax?omegamax:stateconstrain.omegamax;
-        tmpparticle[id].omega=thrust::random::uniform_real_distribution&lt;double&gt;(omegamin,omegamax)(rng[id]);
-    }
-
-    if(tmpparticle[id].v==0)
-    {
-        tmpparticle[id].k=(stateconstrain.kmin+stateconstrain.kmax)/2;
-    }
-    else
-    {
-        tmpparticle[id].k=tmpparticle[id].omega/tmpparticle[id].v;
-        if(tmpparticle[id].k&lt;stateconstrain.kmin)
-        {
-            tmpparticle[id].k=stateconstrain.kmin;
-        }
-        if(tmpparticle[id].k&gt;stateconstrain.kmax)
-        {
-            tmpparticle[id].k=stateconstrain.kmax;
-        }
-    }
-    tmpparticle[id].omega=tmpparticle[id].v*tmpparticle[id].k;
-
-    double R,phi;
-    if(tmpparticle[id].k!=0)
-    {
-        R=1/fabs(tmpparticle[id].k);
-        phi=atan2(4.0,R);
-    }
-
-    if(tmpparticle[id].omega&gt;0)
-    {
-        stateconstrain.amin=-MAXANGLEOFFSET;
-        stateconstrain.amax=phi;
-        stateconstrain.amax=stateconstrain.amax&gt;stateconstrain.amin?stateconstrain.amax:stateconstrain.amin;
-    }
-    else if(tmpparticle[id].omega&lt;0)
-    {
-        stateconstrain.amax=MAXANGLEOFFSET;
-        stateconstrain.amin=-phi;
-        stateconstrain.amin=stateconstrain.amin&lt;stateconstrain.amax?stateconstrain.amin:stateconstrain.amax;
-    }
-    else if(tmpparticle[id].omega==0)
-    {
-        stateconstrain.amin=0;
-        stateconstrain.amax=0;
-    }
-
-    if(egomotion.pfflag)
-    {
-        tmpparticle[id].a=thrust::random::normal_distribution&lt;double&gt;(tmpparticle[id].a,objectstateoffset.aoff)(rng[id]);
-        tmpparticle[id].a=tmpparticle[id].a&gt;stateconstrain.amin?tmpparticle[id].a:stateconstrain.amin;
-        tmpparticle[id].a=tmpparticle[id].a&lt;stateconstrain.amax?tmpparticle[id].a:stateconstrain.amax;
-    }
-    else
-    {
-        double amin=tmpparticle[id].a-objectstateoffset.aoff;amin=amin&gt;stateconstrain.amin?amin:stateconstrain.amin;
-        double amax=tmpparticle[id].a+objectstateoffset.aoff;amax=amax&lt;stateconstrain.amax?amax:stateconstrain.amax;
-        tmpparticle[id].a=thrust::random::uniform_real_distribution&lt;double&gt;(amin,amax)(rng[id]);
-    }
-
-    VehicleState movedparticle;
-    deviceAckermannModel(tmpparticle[id],movedparticle,egomotion);
-    deviceBuildModel(movedparticle,egomotion.density);
-
-    movedparticle.weight=0;
-    movedparticle.count=0;
-    deviceMeasureEdge(movedparticle,0,scan,objectstateoffset.anneal,NULL,NULL,1);
-    deviceMeasureEdge(movedparticle,1,scan,objectstateoffset.anneal,NULL,NULL,1);
-    tmpparticle[id].weight=movedparticle.weight;
-    tmpparticle[id].count=movedparticle.count;
-
-    return;
-}
-
-__global__
-void kernelMotionUpdate(int pnum, VehicleState * particle, EgoMotion egomotion)
-{
-    GetThreadID_1D(id);
-    if(id&gt;=pnum)
-    {
-        return;
-    }
-    deviceAckermannModel(particle[id],particle[id],egomotion);
-    deviceBuildModel(particle[id],egomotion.density);
-}
-
-//==============================================================================
-
-void sampleParticle(int &amp; pnum, VehicleState * d_particle, int &amp; tmppnum, VehicleState * d_tmpparticle, VehicleState &amp; estimate)
-{
-    VehicleState h_particle[RQPN];
-    VehicleState h_tmpparticle[MAXPN];
-    bool h_flag[MAXPN];
-
-    cudaMemcpy(h_tmpparticle,d_tmpparticle,sizeof(VehicleState)*tmppnum,cudaMemcpyDeviceToHost);
-
-    double maxlogweight=h_tmpparticle[0].weight;
-    double minlogweight=h_tmpparticle[0].weight;
-    for(int j=0;j&lt;tmppnum;j++)
-    {
-        if(maxlogweight&lt;h_tmpparticle[j].weight)
-        {
-            maxlogweight=h_tmpparticle[j].weight;
-        }
-        if(minlogweight&gt;h_tmpparticle[j].weight)
-        {
-            minlogweight=h_tmpparticle[j].weight;
-        }
-        h_flag[j]=1;
-    }
-
-    double maxscale=maxlogweight&lt;=30?1:30/maxlogweight;
-    double minscale=minlogweight&gt;=-30?1:-30/minlogweight;
-    double scale=maxscale&lt;minscale?maxscale:minscale;
-    for(int j=0;j&lt;tmppnum;j++)
-    {
-        h_tmpparticle[j].weight=exp(h_tmpparticle[j].weight*scale);
-        if(j&gt;0)
-        {
-            h_tmpparticle[j].weight+=h_tmpparticle[j-1].weight;
-        }
-    }
-
-    int planpnum=tmppnum&lt;RQPN?tmppnum:RQPN;
-    double weightstep=1.0/planpnum;
-    int accuracy=1000000;
-    double samplebase=(rand()%accuracy)*weightstep/accuracy;
-    double weightsum=h_tmpparticle[tmppnum-1].weight;
-    pnum=0;
-
-    estimate.weight=0;
-    estimate.x=0;estimate.y=0;estimate.theta=0;
-    estimate.wl=0;estimate.wr=0;estimate.lf=0;estimate.lb=0;
-    estimate.a=0;estimate.v=0;estimate.k=0;estimate.omega=0;
-    estimate.count=0;
-
-    VehicleState minstate,maxstate;
-    for(int j=0, k=0;j&lt;planpnum;j++)
-    {
-        double sample=samplebase+j*weightstep;
-        while(k&lt;tmppnum)
-        {
-            if(sample&gt;h_tmpparticle[k].weight/weightsum)
-            {
-                k++;
-                continue;
-            }
-            if(h_flag[k])
-            {
-                h_flag[k]=0;
-                h_particle[pnum]=h_tmpparticle[k];
-                h_particle[pnum].weight=weightstep;
-                if(pnum==0)
-                {
-                    minstate.x=h_particle[pnum].x;maxstate.x=h_particle[pnum].x;
-                    minstate.y=h_particle[pnum].y;maxstate.y=h_particle[pnum].y;
-                    minstate.theta=h_particle[pnum].theta;maxstate.theta=h_particle[pnum].theta;
-                    minstate.wl=h_particle[pnum].wl;maxstate.wl=h_particle[pnum].wl;
-                    minstate.wr=h_particle[pnum].wr;maxstate.wr=h_particle[pnum].wr;
-                    minstate.lf=h_particle[pnum].lf;maxstate.lf=h_particle[pnum].lf;
-                    minstate.lb=h_particle[pnum].lb;maxstate.lb=h_particle[pnum].lb;
-                    minstate.a=h_particle[pnum].a;maxstate.a=h_particle[pnum].a;
-                    minstate.v=h_particle[pnum].v;maxstate.v=h_particle[pnum].v;
-                    minstate.k=h_particle[pnum].k;maxstate.k=h_particle[pnum].k;
-                    minstate.omega=h_particle[pnum].omega;maxstate.omega=h_particle[pnum].omega;
-                }
-                else
-                {
-                    minstate.x=minstate.x&lt;h_particle[pnum].x?minstate.x:h_particle[pnum].x;
-                    maxstate.x=maxstate.x&gt;h_particle[pnum].x?maxstate.x:h_particle[pnum].x;
-                    minstate.y=minstate.y&lt;h_particle[pnum].y?minstate.y:h_particle[pnum].y;
-                    maxstate.y=maxstate.y&gt;h_particle[pnum].y?maxstate.y:h_particle[pnum].y;
-                    minstate.theta=minstate.theta&lt;h_particle[pnum].theta?minstate.theta:h_particle[pnum].theta;
-                    maxstate.theta=maxstate.theta&gt;h_particle[pnum].theta?maxstate.theta:h_particle[pnum].theta;
-                    minstate.wl=minstate.wl&lt;h_particle[pnum].wl?minstate.wl:h_particle[pnum].wl;
-                    maxstate.wl=maxstate.wl&gt;h_particle[pnum].wl?maxstate.wl:h_particle[pnum].wl;
-                    minstate.wr=minstate.wr&lt;h_particle[pnum].wr?minstate.wr:h_particle[pnum].wr;
-                    maxstate.wr=maxstate.wr&gt;h_particle[pnum].wr?maxstate.wr:h_particle[pnum].wr;
-                    minstate.lf=minstate.lf&lt;h_particle[pnum].lf?minstate.lf:h_particle[pnum].lf;
-                    maxstate.lf=maxstate.lf&gt;h_particle[pnum].lf?maxstate.lf:h_particle[pnum].lf;
-                    minstate.lb=minstate.lb&lt;h_particle[pnum].lb?minstate.lb:h_particle[pnum].lb;
-                    maxstate.lb=maxstate.lb&gt;h_particle[pnum].lb?maxstate.lb:h_particle[pnum].lb;
-                    minstate.a=minstate.a&lt;h_particle[pnum].a?minstate.a:h_particle[pnum].a;
-                    maxstate.a=maxstate.a&gt;h_particle[pnum].a?maxstate.a:h_particle[pnum].a;
-                    minstate.v=minstate.v&lt;h_particle[pnum].v?minstate.v:h_particle[pnum].v;
-                    maxstate.v=maxstate.v&gt;h_particle[pnum].v?maxstate.v:h_particle[pnum].v;
-                    minstate.k=minstate.k&lt;h_particle[pnum].k?minstate.k:h_particle[pnum].k;
-                    maxstate.k=maxstate.k&gt;h_particle[pnum].k?maxstate.k:h_particle[pnum].k;
-                    minstate.omega=minstate.omega&lt;h_particle[pnum].omega?minstate.omega:h_particle[pnum].omega;
-                    maxstate.omega=maxstate.omega&gt;h_particle[pnum].omega?maxstate.omega:h_particle[pnum].omega;
-                }
-                pnum++;
-            }
-            else
-            {
-                h_particle[pnum-1].weight+=weightstep;
-            }
-            estimate.weight+=weightstep;
-            estimate.x+=h_particle[pnum-1].x*weightstep;
-            estimate.y+=h_particle[pnum-1].y*weightstep;
-            estimate.theta+=h_particle[pnum-1].theta*weightstep;
-            estimate.wl+=h_particle[pnum-1].wl*weightstep;
-            estimate.wr+=h_particle[pnum-1].wr*weightstep;
-            estimate.lf+=h_particle[pnum-1].lf*weightstep;
-            estimate.lb+=h_particle[pnum-1].lb*weightstep;
-            estimate.a+=h_particle[pnum-1].a*weightstep;
-            estimate.v+=h_particle[pnum-1].v*weightstep;
-            estimate.k+=h_particle[pnum-1].k*weightstep;
-            estimate.omega+=h_particle[pnum-1].omega*weightstep;
-            estimate.count+=h_particle[pnum-1].count*weightstep;
-
-            break;
-        }
-    }
-
-    estimate.x/=estimate.weight;
-    estimate.y/=estimate.weight;
-    estimate.theta/=estimate.weight;
-    estimate.wl/=estimate.weight;
-    estimate.wr/=estimate.weight;
-    estimate.lf/=estimate.weight;
-    estimate.lb/=estimate.weight;
-    estimate.a/=estimate.weight;
-    estimate.v/=estimate.weight;
-    estimate.k/=estimate.weight;
-    estimate.omega=estimate.v*estimate.k;
-    estimate.count/=estimate.weight;
-    estimate.weight/=estimate.weight;
-
-    estimate.dx=std::max(estimate.x-minstate.x,maxstate.x-estimate.x);
-    estimate.dy=std::max(estimate.y-minstate.y,maxstate.y-estimate.y);
-    estimate.dtheta=std::max(estimate.theta-minstate.theta,maxstate.theta-estimate.theta);
-    estimate.dwl=std::max(estimate.wl-minstate.wl,maxstate.wl-estimate.wl);
-    estimate.dwr=std::max(estimate.wr-minstate.wr,maxstate.wr-estimate.wr);
-    estimate.dlf=std::max(estimate.lf-minstate.lf,maxstate.lf-estimate.lf);
-    estimate.dlb=std::max(estimate.lb-minstate.lb,maxstate.lb-estimate.lb);
-    estimate.da=std::max(estimate.a-minstate.a,maxstate.a-estimate.a);
-    estimate.dv=std::max(estimate.v-minstate.v,maxstate.v-estimate.v);
-    estimate.dk=std::max(estimate.k-minstate.k,maxstate.k-estimate.k);
-    estimate.domega=std::max(estimate.omega-minstate.omega,maxstate.omega-estimate.omega);
-
-    deviceBuildModel(estimate,h_egomotion.density);
-
-    cudaMemcpy(d_particle,h_particle,sizeof(VehicleState)*pnum,cudaMemcpyHostToDevice);
-    return;
-}
-
-#define CALRATIO(ratio, vratio, maxratio, maxrange, minrange) \
-    ratio=maxrange/minrange; vratio*=ratio; maxratio=ratio&gt;maxratio?ratio:maxratio;
-#define CALZOOM(zoom, maxrange, minrange, N) \
-    zoom=log(maxrange/minrange)/log(2)/N;zoom=1/pow(2,zoom);
-
-void SSPF_GeometryModel(LaserScan * scan, int &amp; pnum, VehicleState * d_particle, VehicleState * d_tmpparticle, thrust::minstd_rand * d_rng, VehicleState &amp; estimate, ObjectStateOffset &amp; objectstateoffset, EgoMotion &amp; egomotion)
-{
-    double ratio=1,vratio=1,maxratio=1;
-    CALRATIO(ratio,vratio,maxratio,objectstateoffset.thetaoff,objectstateoffset.thetaprec);
-    CALRATIO(ratio,vratio,maxratio,objectstateoffset.wloff,objectstateoffset.wlprec);
-    CALRATIO(ratio,vratio,maxratio,objectstateoffset.wroff,objectstateoffset.wrprec);
-    CALRATIO(ratio,vratio,maxratio,objectstateoffset.lfoff,objectstateoffset.lfprec);
-    CALRATIO(ratio,vratio,maxratio,objectstateoffset.lboff,objectstateoffset.lbprec);
-    objectstateoffset.anneal=maxratio*maxratio;
-    double N=log(vratio)/log(2);
-
-    CALZOOM(objectstateoffset.thetazoom,objectstateoffset.thetaoff,objectstateoffset.thetaprec,N);
-    CALZOOM(objectstateoffset.wlzoom,objectstateoffset.wloff,objectstateoffset.wlprec,N);
-    CALZOOM(objectstateoffset.wrzoom,objectstateoffset.wroff,objectstateoffset.wrprec,N);
-    CALZOOM(objectstateoffset.lfzoom,objectstateoffset.lfoff,objectstateoffset.lfprec,N);
-    CALZOOM(objectstateoffset.lbzoom,objectstateoffset.lboff,objectstateoffset.lbprec,N);
-    objectstateoffset.annealratio=pow(objectstateoffset.anneal,-1/N);
-
-    StateConstrain stateconstrain;
-    stateconstrain.thetamin=estimate.theta-objectstateoffset.thetaoff;
-    stateconstrain.thetamax=estimate.theta+objectstateoffset.thetaoff;
-
-    int tmppnum;
-    for(int i=1;i&lt;=N;i++)
-    {
-        tmppnum=pnum*SPN;
-
-        GetKernelDim_1D(blocknum,threadnum,tmppnum);
-        kernelGeometryModel&lt;&lt;&lt;blocknum,threadnum&gt;&gt;&gt;(scan,pnum,d_particle,tmppnum,d_tmpparticle,d_rng,objectstateoffset,stateconstrain,egomotion);
-        sampleParticle(pnum,d_particle,tmppnum,d_tmpparticle,estimate);
-
-        objectstateoffset.thetaoff*=objectstateoffset.thetazoom;
-        objectstateoffset.wloff*=objectstateoffset.wlzoom;
-        objectstateoffset.wroff*=objectstateoffset.wrzoom;
-        objectstateoffset.lfoff*=objectstateoffset.lfzoom;
-        objectstateoffset.lboff*=objectstateoffset.lbzoom;
-        objectstateoffset.anneal*=objectstateoffset.annealratio;
-    }
-    {
-        objectstateoffset.thetaoff=objectstateoffset.thetaprec;
-        objectstateoffset.wloff=objectstateoffset.wlprec;
-        objectstateoffset.wroff=objectstateoffset.wrprec;
-        objectstateoffset.lfoff=objectstateoffset.lfprec;
-        objectstateoffset.lboff=objectstateoffset.lbprec;
-        objectstateoffset.anneal=1;
-        tmppnum=pnum*SPN;
-        GetKernelDim_1D(blocknum,threadnum,tmppnum);
-        kernelGeometryModel&lt;&lt;&lt;blocknum,threadnum&gt;&gt;&gt;(scan,pnum,d_particle,tmppnum,d_tmpparticle,d_rng,objectstateoffset,stateconstrain,egomotion);
-        sampleParticle(pnum,d_particle,tmppnum,d_tmpparticle,estimate);
-    }
-}
-
-void SSPF_MotionModel(LaserScan * scan, int &amp; pnum, VehicleState * d_particle, VehicleState * d_tmpparticle, thrust::minstd_rand * d_rng, VehicleState &amp; estimate, ObjectStateOffset &amp; objectstateoffset, EgoMotion &amp; egomotion)
-{
-    double ratio=1,vratio=1,maxratio=1;
-    CALRATIO(ratio,vratio,maxratio,objectstateoffset.aoff,objectstateoffset.aprec);
-    CALRATIO(ratio,vratio,maxratio,objectstateoffset.voff,objectstateoffset.vprec);
-    CALRATIO(ratio,vratio,maxratio,objectstateoffset.omegaoff,objectstateoffset.omegaprec);
-    objectstateoffset.anneal=maxratio*maxratio;
-    double N=log(vratio)/log(2);
-
-    CALZOOM(objectstateoffset.azoom,objectstateoffset.aoff,objectstateoffset.aprec,N);
-    CALZOOM(objectstateoffset.vzoom,objectstateoffset.voff,objectstateoffset.vprec,N);
-    CALZOOM(objectstateoffset.omegazoom,objectstateoffset.omegaoff,objectstateoffset.omegaprec,N);
-    objectstateoffset.annealratio=pow(objectstateoffset.anneal,-1/N);
-
-    StateConstrain stateconstrain;
-    if(!(egomotion.pfflag))
-    {
-        stateconstrain.amin=std::max(stateconstrain.amin,estimate.a-objectstateoffset.aoff);
-        stateconstrain.amax=std::min(stateconstrain.amax,estimate.a+objectstateoffset.aoff);
-        stateconstrain.vmin=std::max(stateconstrain.vmin,estimate.v-objectstateoffset.voff);
-        stateconstrain.vmax=std::min(stateconstrain.vmax,estimate.v+objectstateoffset.voff);
-        stateconstrain.kmin=std::max(stateconstrain.kmin,estimate.k-objectstateoffset.koff);
-        stateconstrain.kmax=std::min(stateconstrain.kmax,estimate.k+objectstateoffset.koff);
-        stateconstrain.omegamin=std::max(stateconstrain.omegamin,estimate.omega-objectstateoffset.omegaoff);
-        stateconstrain.omegamax=std::min(stateconstrain.omegamax,estimate.omega+objectstateoffset.omegaoff);
-    }
-
-    int tmppnum;
-    for(int i=1;i&lt;=N&amp;&amp;!(egomotion.pfflag);i++)
-    {
-        tmppnum=pnum*SPN;
-
-        GetKernelDim_1D(blocknum,threadnum,tmppnum);
-        kernelMotionModel&lt;&lt;&lt;blocknum,threadnum&gt;&gt;&gt;(scan,pnum,d_particle,tmppnum,d_tmpparticle,d_rng,objectstateoffset,stateconstrain,egomotion);
-        sampleParticle(pnum,d_particle,tmppnum,d_tmpparticle,estimate);
-
-        objectstateoffset.aoff*=objectstateoffset.azoom;
-        objectstateoffset.voff*=objectstateoffset.vzoom;
-        objectstateoffset.omegaoff*=objectstateoffset.omegazoom;
-        objectstateoffset.anneal*=objectstateoffset.annealratio;
-    }
-    {
-        if(!(egomotion.pfflag))
-        {
-            objectstateoffset.aoff=objectstateoffset.aprec;
-            objectstateoffset.voff=objectstateoffset.vprec;
-            objectstateoffset.omegaoff=objectstateoffset.omegaprec;
-            objectstateoffset.anneal=1;
-            tmppnum=pnum*SPN;
-        }
-        else
-        {
-            objectstateoffset.anneal=1;
-            tmppnum=MAXPN;
-        }
-        GetKernelDim_1D(blocknum,threadnum,tmppnum);
-        kernelMotionModel&lt;&lt;&lt;blocknum,threadnum&gt;&gt;&gt;(scan,pnum,d_particle,tmppnum,d_tmpparticle,d_rng,objectstateoffset,stateconstrain,egomotion);
-        kernelMotionUpdate&lt;&lt;&lt;blocknum,threadnum&gt;&gt;&gt;(tmppnum,d_tmpparticle,egomotion);
-        sampleParticle(pnum,d_particle,tmppnum,d_tmpparticle,estimate);
-    }
-}
-
-//==============================================================================
-
-extern "C" void cuda_InitLaserScan()
-{
-    if(d_scan==NULL)
-    {
-        cudaMalloc(&amp;(d_scan),sizeof(LaserScan));
-    }
-}
-
-extern "C" void cuda_SetLaserScan(LaserScan &amp; laserScan)
-{
-    cudaMemcpy(d_scan,&amp;laserScan,sizeof(LaserScan),cudaMemcpyHostToDevice);
-    h_scan=laserScan;
-    if(h_egomotion.validflag)
-    {
-        double tmpdx=h_egomotion.x-laserScan.x;
-        double tmpdy=h_egomotion.y-laserScan.y;
-        double c=cos(laserScan.theta);
-        double s=sin(laserScan.theta);
-        h_egomotion.dx=c*tmpdx+s*tmpdy;
-        h_egomotion.dy=-s*tmpdx+c*tmpdy;
-        h_egomotion.dtheta=h_egomotion.theta-laserScan.theta;
-        h_egomotion.dt=laserScan.timestamp-h_egomotion.timestamp;
-    }
-    h_egomotion.x=laserScan.x;
-    h_egomotion.y=laserScan.y;
-    h_egomotion.theta=laserScan.theta;
-    h_egomotion.timestamp=laserScan.timestamp;
-    h_egomotion.validflag=1;
-    h_egomotion.density=2*PI/laserScan.beamnum;
-}
-
-extern "C" void cuda_FreeLaserScan()
-{
-    CUDAFREE(d_scan);
-}
-
-//==============================================================================
-
-extern "C" void cuda_OpenTracker(TrackerDataContainer &amp; trackerDataContainer)
-{
-    trackerDataContainer.pnum=0;
-    cudaMalloc(&amp;(trackerDataContainer.d_particle),sizeof(VehicleState)*RQPN);
-    cudaMalloc(&amp;(trackerDataContainer.d_tmpparticle),sizeof(VehicleState)*MAXPN);
-    cudaMalloc(&amp;(trackerDataContainer.d_rng),sizeof(thrust::minstd_rand)*MAXPN);
-
-    int h_seed[MAXPN];
-    thrust::generate(h_seed,h_seed+MAXPN,rand);
-    int * d_seed;
-    cudaMalloc(&amp;(d_seed),sizeof(int)*MAXPN);
-    cudaMemcpy(d_seed,h_seed,sizeof(int)*MAXPN,cudaMemcpyHostToDevice);
-    GetKernelDim_1D(blocks,threads,MAXPN);
-    kernelSetRandomSeed&lt;&lt;&lt;blocks,threads&gt;&gt;&gt;(d_seed,trackerDataContainer.d_rng,MAXPN);
-    CUDAFREE(d_seed);
-}
-
-extern "C" void cuda_CloseTracker(TrackerDataContainer &amp; trackerDataContainer)
-{
-    CUDAFREE(trackerDataContainer.d_particle);
-    CUDAFREE(trackerDataContainer.d_tmpparticle);
-    CUDAFREE(trackerDataContainer.d_rng);
-}
-
-//==============================================================================
-
-extern "C" void cuda_InitGeometry(TrackerDataContainer &amp; trackerDataContainer, TrackerResultContainer &amp; trackerResultContainer)
-{
-    ObjectStateOffset objectstateoffset;
-
-    EgoMotion egomotion=h_egomotion;
-    egomotion.pfflag=0;
-
-    trackerDataContainer.pnum=1;
-    cudaMemcpy(trackerDataContainer.d_particle,&amp;(trackerResultContainer.estimate),sizeof(VehicleState),cudaMemcpyHostToDevice);
-
-    SSPF_GeometryModel(d_scan,trackerDataContainer.pnum,trackerDataContainer.d_particle,trackerDataContainer.d_tmpparticle,trackerDataContainer.d_rng,trackerResultContainer.estimate,objectstateoffset,egomotion);
-
-    trackerResultContainer.estimate.dwl=trackerResultContainer.estimate.dwl&gt;MINSIGMA?trackerResultContainer.estimate.dwl:MINSIGMA;
-    trackerResultContainer.estimate.dwr=trackerResultContainer.estimate.dwr&gt;MINSIGMA?trackerResultContainer.estimate.dwr:MINSIGMA;
-    trackerResultContainer.estimate.dlf=trackerResultContainer.estimate.dlf&gt;MINSIGMA?trackerResultContainer.estimate.dlf:MINSIGMA;
-    trackerResultContainer.estimate.dlb=trackerResultContainer.estimate.dlb&gt;MINSIGMA?trackerResultContainer.estimate.dlb:MINSIGMA;
-
-    trackerResultContainer.estimate.dwl=trackerResultContainer.estimate.dwl&lt;UNCERTAINTHRESH?trackerResultContainer.estimate.dwl:MAXSIGMA;
-    trackerResultContainer.estimate.dwr=trackerResultContainer.estimate.dwr&lt;UNCERTAINTHRESH?trackerResultContainer.estimate.dwr:MAXSIGMA;
-    trackerResultContainer.estimate.dlf=trackerResultContainer.estimate.dlf&lt;UNCERTAINTHRESH?trackerResultContainer.estimate.dlf:MAXSIGMA;
-    trackerResultContainer.estimate.dlb=trackerResultContainer.estimate.dlb&lt;UNCERTAINTHRESH?trackerResultContainer.estimate.dlb:MAXSIGMA;
-
-    deviceBuildModel(trackerResultContainer.estimate,egomotion.density);
-    trackerResultContainer.estimate.weight=0;
-    trackerResultContainer.estimate.count=0;
-    trackerResultContainer.edgepointnum[0]=0;
-    deviceMeasureEdge(trackerResultContainer.estimate,0,&amp;h_scan,1,&amp;(trackerResultContainer.edgepointnum[0]),trackerResultContainer.edgepointid[0],1);
-    trackerResultContainer.edgepointnum[1]=0;
-    deviceMeasureEdge(trackerResultContainer.estimate,1,&amp;h_scan,1,&amp;(trackerResultContainer.edgepointnum[1]),trackerResultContainer.edgepointid[1],1);
-}
-
-extern "C" void cuda_InitMotion(TrackerDataContainer &amp; trackerDataContainer, TrackerResultContainer &amp; trackerResultContainer)
-{
-    VehicleState preestimate=trackerResultContainer.estimate;
-    VehicleState curestimate=preestimate;
-
-    ObjectStateOffset objectstateoffset;
-    objectstateoffset.thetaoff=objectstateoffset.thetaprec;
-    if(preestimate.dwl&lt;objectstateoffset.wlprec)
-    {
-        objectstateoffset.wloff=objectstateoffset.wlprec;
-    }
-    if(preestimate.dwr&lt;objectstateoffset.wrprec)
-    {
-        objectstateoffset.wroff=objectstateoffset.wrprec;
-    }
-    if(preestimate.dlf&lt;objectstateoffset.lfprec)
-    {
-        objectstateoffset.lfoff=objectstateoffset.lfprec;
-    }
-    if(preestimate.dlb&lt;objectstateoffset.lbprec)
-    {
-        objectstateoffset.lboff=objectstateoffset.lbprec;
-    }
-
-    EgoMotion egomotion=h_egomotion;
-    egomotion.pfflag=0;
-
-    trackerDataContainer.pnum=1;
-    cudaMemcpy(trackerDataContainer.d_particle,&amp;(preestimate),sizeof(VehicleState),cudaMemcpyHostToDevice);
-
-    SSPF_MotionModel(d_scan,trackerDataContainer.pnum,trackerDataContainer.d_particle,trackerDataContainer.d_tmpparticle,trackerDataContainer.d_rng,curestimate,objectstateoffset,egomotion);
-
-    double dx=curestimate.dx;
-    double dy=curestimate.dy;
-    double dtheta=curestimate.dtheta;
-
-    trackerDataContainer.pnum=1;
-    cudaMemcpy(trackerDataContainer.d_particle,&amp;(curestimate),sizeof(VehicleState),cudaMemcpyHostToDevice);
-
-    SSPF_GeometryModel(d_scan,trackerDataContainer.pnum,trackerDataContainer.d_particle,trackerDataContainer.d_tmpparticle,trackerDataContainer.d_rng,curestimate,objectstateoffset,egomotion);
-
-    trackerResultContainer.estimate=curestimate;
-
-    curestimate.dwl=curestimate.dwl&gt;MINSIGMA?curestimate.dwl:MINSIGMA;
-    curestimate.dwr=curestimate.dwr&gt;MINSIGMA?curestimate.dwr:MINSIGMA;
-    curestimate.dlf=curestimate.dlf&gt;MINSIGMA?curestimate.dlf:MINSIGMA;
-    curestimate.dlb=curestimate.dlb&gt;MINSIGMA?curestimate.dlb:MINSIGMA;
-
-    curestimate.dwl=curestimate.dwl&lt;UNCERTAINTHRESH?curestimate.dwl:MAXSIGMA;
-    curestimate.dwr=curestimate.dwr&lt;UNCERTAINTHRESH?curestimate.dwr:MAXSIGMA;
-    curestimate.dlf=curestimate.dlf&lt;UNCERTAINTHRESH?curestimate.dlf:MAXSIGMA;
-    curestimate.dlb=curestimate.dlb&lt;UNCERTAINTHRESH?curestimate.dlb:MAXSIGMA;
-
-    trackerResultContainer.estimate.dx=dx;trackerResultContainer.estimate.dy=dy;trackerResultContainer.estimate.dtheta=dtheta;
-
-    trackerResultContainer.estimate.wl=(preestimate.wl*curestimate.dwl*curestimate.dwl+curestimate.wl*preestimate.dwl*preestimate.dwl)/(preestimate.dwl*preestimate.dwl+curestimate.dwl*curestimate.dwl);
-    trackerResultContainer.estimate.dwl=sqrt((preestimate.dwl*preestimate.dwl*curestimate.dwl*curestimate.dwl)/(preestimate.dwl*preestimate.dwl+curestimate.dwl*curestimate.dwl));
-    trackerResultContainer.estimate.dwl=trackerResultContainer.estimate.dwl&gt;MINSIGMA?trackerResultContainer.estimate.dwl:MINSIGMA;
-
-    trackerResultContainer.estimate.wr=(preestimate.wr*curestimate.dwr*curestimate.dwr+curestimate.wr*preestimate.dwr*preestimate.dwr)/(preestimate.dwr*preestimate.dwr+curestimate.dwr*curestimate.dwr);
-    trackerResultContainer.estimate.dwr=sqrt((preestimate.dwr*preestimate.dwr*curestimate.dwr*curestimate.dwr)/(preestimate.dwr*preestimate.dwr+curestimate.dwr*curestimate.dwr));
-    trackerResultContainer.estimate.dwr=trackerResultContainer.estimate.dwr&gt;MINSIGMA?trackerResultContainer.estimate.dwr:MINSIGMA;
-
-    trackerResultContainer.estimate.lf=(preestimate.lf*curestimate.dlf*curestimate.dlf+curestimate.lf*preestimate.dlf*preestimate.dlf)/(preestimate.dlf*preestimate.dlf+curestimate.dlf*curestimate.dlf);
-    trackerResultContainer.estimate.dlf=sqrt((preestimate.dlf*preestimate.dlf*curestimate.dlf*curestimate.dlf)/(preestimate.dlf*preestimate.dlf+curestimate.dlf*curestimate.dlf));
-    trackerResultContainer.estimate.dlf=trackerResultContainer.estimate.dlf&gt;MINSIGMA?trackerResultContainer.estimate.dlf:MINSIGMA;
-
-    trackerResultContainer.estimate.lb=(preestimate.lb*curestimate.dlb*curestimate.dlb+curestimate.lb*preestimate.dlb*preestimate.dlb)/(preestimate.dlb*preestimate.dlb+curestimate.dlb*curestimate.dlb);
-    trackerResultContainer.estimate.dlb=sqrt((preestimate.dlb*preestimate.dlb*curestimate.dlb*curestimate.dlb)/(preestimate.dlb*preestimate.dlb+curestimate.dlb*curestimate.dlb));
-    trackerResultContainer.estimate.dlb=trackerResultContainer.estimate.dlb&gt;MINSIGMA?trackerResultContainer.estimate.dlb:MINSIGMA;
-
-    deviceBuildModel(trackerResultContainer.estimate,egomotion.density);
-    trackerResultContainer.estimate.weight=0;
-    trackerResultContainer.estimate.count=0;
-    trackerResultContainer.edgepointnum[0]=0;
-    deviceMeasureEdge(trackerResultContainer.estimate,0,&amp;h_scan,1,&amp;(trackerResultContainer.edgepointnum[0]),trackerResultContainer.edgepointid[0],1);
-    trackerResultContainer.edgepointnum[1]=0;
-    deviceMeasureEdge(trackerResultContainer.estimate,1,&amp;h_scan,1,&amp;(trackerResultContainer.edgepointnum[1]),trackerResultContainer.edgepointid[1],1);
-}
-
-extern "C" bool cuda_UpdateTracker(TrackerDataContainer &amp; trackerDataContainer, TrackerResultContainer &amp; trackerResultContainer)
-{
-    VehicleState preestimate=trackerResultContainer.estimate;
-    VehicleState curestimate=preestimate;
-
-    ObjectStateOffset objectstateoffset;
-    objectstateoffset.thetaoff=objectstateoffset.thetaprec;
-    if(preestimate.dwl&lt;objectstateoffset.wlprec)
-    {
-        objectstateoffset.wloff=objectstateoffset.wlprec;
-    }
-    if(preestimate.dwr&lt;objectstateoffset.wrprec)
-    {
-        objectstateoffset.wroff=objectstateoffset.wrprec;
-    }
-    if(preestimate.dlf&lt;objectstateoffset.lfprec)
-    {
-        objectstateoffset.lfoff=objectstateoffset.lfprec;
-    }
-    if(preestimate.dlb&lt;objectstateoffset.lbprec)
-    {
-        objectstateoffset.lboff=objectstateoffset.lbprec;
-    }
-
-    EgoMotion egomotion=h_egomotion;
-    if(preestimate.dx&lt;=2*UNCERTAINTHRESH&amp;&amp;preestimate.dy&lt;=2*UNCERTAINTHRESH&amp;&amp;preestimate.dtheta&lt;=UNCERTAINTHRESH_ANG&amp;&amp;preestimate.count&gt;=UNCERTAINTHRESH_CNT)
-    {
-        objectstateoffset.aoff=DEG2RAD(30);
-        objectstateoffset.voff=10;
-        objectstateoffset.koff=0.5;
-        objectstateoffset.omegaoff=DEG2RAD(60);
-
-        egomotion.pfflag=0;
-        trackerDataContainer.pnum=1;
-        cudaMemcpy(trackerDataContainer.d_particle,&amp;(preestimate),sizeof(VehicleState),cudaMemcpyHostToDevice);
-    }
-    else
-    {
-        objectstateoffset.aoff=DEG2RAD(5);
-        objectstateoffset.voff=2;
-        objectstateoffset.koff=0.05;
-        objectstateoffset.omegaoff=DEG2RAD(3);
-
-        egomotion.pfflag=1;
-    }
-
-    SSPF_MotionModel(d_scan,trackerDataContainer.pnum,trackerDataContainer.d_particle,trackerDataContainer.d_tmpparticle,trackerDataContainer.d_rng,curestimate,objectstateoffset,egomotion);
-
-    if(curestimate.count&gt;=10||curestimate.dx&lt;=2*UNCERTAINTHRESH&amp;&amp;curestimate.dy&lt;=2*UNCERTAINTHRESH&amp;&amp;curestimate.dtheta&lt;=UNCERTAINTHRESH_ANG&amp;&amp;curestimate.count&gt;=UNCERTAINTHRESH_CNT)
-    {
-        double dx=curestimate.dx;
-        double dy=curestimate.dy;
-        double dtheta=curestimate.dtheta;
-
-        trackerDataContainer.pnum=1;
-        cudaMemcpy(trackerDataContainer.d_particle,&amp;(curestimate),sizeof(VehicleState),cudaMemcpyHostToDevice);
-
-        SSPF_GeometryModel(d_scan,trackerDataContainer.pnum,trackerDataContainer.d_particle,trackerDataContainer.d_tmpparticle,trackerDataContainer.d_rng,curestimate,objectstateoffset,egomotion);
-
-        trackerResultContainer.estimate=curestimate;
-
-        curestimate.dwl=curestimate.dwl&gt;MINSIGMA?curestimate.dwl:MINSIGMA;
-        curestimate.dwr=curestimate.dwr&gt;MINSIGMA?curestimate.dwr:MINSIGMA;
-        curestimate.dlf=curestimate.dlf&gt;MINSIGMA?curestimate.dlf:MINSIGMA;
-        curestimate.dlb=curestimate.dlb&gt;MINSIGMA?curestimate.dlb:MINSIGMA;
-
-        curestimate.dwl=curestimate.dwl&lt;UNCERTAINTHRESH?curestimate.dwl:MAXSIGMA;
-        curestimate.dwr=curestimate.dwr&lt;UNCERTAINTHRESH?curestimate.dwr:MAXSIGMA;
-        curestimate.dlf=curestimate.dlf&lt;UNCERTAINTHRESH?curestimate.dlf:MAXSIGMA;
-        curestimate.dlb=curestimate.dlb&lt;UNCERTAINTHRESH?curestimate.dlb:MAXSIGMA;
-
-        trackerResultContainer.estimate.dx=dx;trackerResultContainer.estimate.dy=dy;trackerResultContainer.estimate.dtheta=dtheta;
-
-        trackerResultContainer.estimate.wl=(preestimate.wl*curestimate.dwl*curestimate.dwl+curestimate.wl*preestimate.dwl*preestimate.dwl)/(preestimate.dwl*preestimate.dwl+curestimate.dwl*curestimate.dwl);
-        trackerResultContainer.estimate.dwl=sqrt((preestimate.dwl*preestimate.dwl*curestimate.dwl*curestimate.dwl)/(preestimate.dwl*preestimate.dwl+curestimate.dwl*curestimate.dwl));
-        trackerResultContainer.estimate.dwl=trackerResultContainer.estimate.dwl&gt;MINSIGMA?trackerResultContainer.estimate.dwl:MINSIGMA;
-
-        trackerResultContainer.estimate.wr=(preestimate.wr*curestimate.dwr*curestimate.dwr+curestimate.wr*preestimate.dwr*preestimate.dwr)/(preestimate.dwr*preestimate.dwr+curestimate.dwr*curestimate.dwr);
-        trackerResultContainer.estimate.dwr=sqrt((preestimate.dwr*preestimate.dwr*curestimate.dwr*curestimate.dwr)/(preestimate.dwr*preestimate.dwr+curestimate.dwr*curestimate.dwr));
-        trackerResultContainer.estimate.dwr=trackerResultContainer.estimate.dwr&gt;MINSIGMA?trackerResultContainer.estimate.dwr:MINSIGMA;
-
-        trackerResultContainer.estimate.lf=(preestimate.lf*curestimate.dlf*curestimate.dlf+curestimate.lf*preestimate.dlf*preestimate.dlf)/(preestimate.dlf*preestimate.dlf+curestimate.dlf*curestimate.dlf);
-        trackerResultContainer.estimate.dlf=sqrt((preestimate.dlf*preestimate.dlf*curestimate.dlf*curestimate.dlf)/(preestimate.dlf*preestimate.dlf+curestimate.dlf*curestimate.dlf));
-        trackerResultContainer.estimate.dlf=trackerResultContainer.estimate.dlf&gt;MINSIGMA?trackerResultContainer.estimate.dlf:MINSIGMA;
-
-        trackerResultContainer.estimate.lb=(preestimate.lb*curestimate.dlb*curestimate.dlb+curestimate.lb*preestimate.dlb*preestimate.dlb)/(preestimate.dlb*preestimate.dlb+curestimate.dlb*curestimate.dlb);
-        trackerResultContainer.estimate.dlb=sqrt((preestimate.dlb*preestimate.dlb*curestimate.dlb*curestimate.dlb)/(preestimate.dlb*preestimate.dlb+curestimate.dlb*curestimate.dlb));
-        trackerResultContainer.estimate.dlb=trackerResultContainer.estimate.dlb&gt;MINSIGMA?trackerResultContainer.estimate.dlb:MINSIGMA;
-    }
-    else
-    {
-        trackerResultContainer.estimate=curestimate;
-
-        trackerResultContainer.estimate.wl=preestimate.wl;trackerResultContainer.estimate.dwl=preestimate.dwl;
-        trackerResultContainer.estimate.wr=preestimate.wr;trackerResultContainer.estimate.dwr=preestimate.dwr;
-        trackerResultContainer.estimate.lf=preestimate.lf;trackerResultContainer.estimate.dlf=preestimate.dlf;
-        trackerResultContainer.estimate.lb=preestimate.lb;trackerResultContainer.estimate.dlb=preestimate.dlb;
-    }
-
-    deviceBuildModel(trackerResultContainer.estimate,egomotion.density);
-    trackerResultContainer.estimate.weight=0;
-    trackerResultContainer.estimate.count=0;
-    trackerResultContainer.edgepointnum[0]=0;
-    deviceMeasureEdge(trackerResultContainer.estimate,0,&amp;h_scan,1,&amp;(trackerResultContainer.edgepointnum[0]),trackerResultContainer.edgepointid[0],1);
-    trackerResultContainer.edgepointnum[1]=0;
-    deviceMeasureEdge(trackerResultContainer.estimate,1,&amp;h_scan,1,&amp;(trackerResultContainer.edgepointnum[1]),trackerResultContainer.edgepointid[1],1);
-
-    return egomotion.pfflag;
-}
-
-//==============================================================================
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\rbsspfvehicletracker.cuh" new_path="" added_lines="0" deleted_lines="154">
				<diff>@@ -1,154 +0,0 @@
-#ifndef RBSSPFVEHICLETRACKER_CUH
-#define RBSSPFVEHICLETRACKER_CUH
-
-#include&lt;cuda.h&gt;
-#include&lt;cuda_runtime.h&gt;
-#include&lt;thrust/random/linear_congruential_engine.h&gt;
-#include&lt;thrust/random/uniform_real_distribution.h&gt;
-#include&lt;thrust/random/normal_distribution.h&gt;
-#include&lt;thrust/generate.h&gt;
-
-#include&lt;chrono&gt;
-#include&lt;vector&gt;
-#include&lt;random&gt;
-#include&lt;time.h&gt;
-#include&lt;algorithm&gt;
-
-#ifndef PI
-#define PI 3.14159265359
-#endif
-
-#define DEG2RAD(ang) (ang*PI/180)
-
-#define MINSIGMA 1e-2
-#define MAXSIGMA 1e6
-#define UNCERTAINTHRESH 0.3
-#define UNCERTAINTHRESH_ANG DEG2RAD(20)
-#define UNCERTAINTHRESH_CNT 3
-
-#define RQPN 1024
-#define SPN 4
-#define MAXPN (SPN*RQPN)
-#define MAXBEAMNUM 2048
-#define MAXEDGEPOINT 1024
-
-#define CUDAFREE(pointer) if(pointer!=NULL){cudaFree(pointer);pointer=NULL;}
-
-#define THREAD_1D 256
-#define THREAD_2D 16
-#define GetKernelDim_1D(numBlocks, threadsPerBlock, dim) int numBlocks=(dim+THREAD_1D-1)/THREAD_1D; int threadsPerBlock=THREAD_1D;
-#define GetKernelDim_2D(numBlocks, threadsPerBlock, xdim, ydim) dim3 numBlocks(int((xdim+THREAD_2D-1)/THREAD_2D), int((ydim+THREAD_2D-1)/THREAD_2D)); dim3 threadsPerBlock(THREAD_2D, THREAD_2D);
-#define GetThreadID_1D(id) int id=blockDim.x*blockIdx.x+threadIdx.x;
-#define GetThreadID_2D(xid,yid) int xid=blockDim.x*blockIdx.x+threadIdx.x;int yid=blockDim.y*blockIdx.y+threadIdx.y;
-
-#define NEARESTRING 3.3
-#define MINBEAMLENGTH 2
-#define MAXBEAMLENGTH 100
-#define MARGIN0 0.2
-#define MARGIN1 0.2
-#define MARGIN2 0.4
-
-#define SIGMA 0.5
-#define COST0 1
-#define WEIGHT0 -2
-#define COST1 2
-#define WEIGHT1 -8
-#define COST2 0
-#define WEIGHT2 0
-#define COST3 1.6
-#define WEIGHT3 -5.12
-
-#define MAXANGLEOFFSET DEG2RAD(8)
-
-struct VehicleState
-{
-    double weight;
-
-    double x,y,theta;
-    double dx,dy,dtheta;
-    double wl,wr,lf,lb;
-    double dwl,dwr,dlf,dlb;
-    double a,v,k,omega;
-    double da,dv,dk,domega;
-    double count;
-
-    double cx[4],cy[4],cl[4];
-    int bid[4];
-    int eid[2];
-
-    double ox,oy;
-};
-
-struct StateConstrain
-{
-    double thetamin,thetamax;
-    double wlmin=0,wlmax=3;
-    double wrmin=0,wrmax=3;
-    double lfmin=0,lfmax=5;
-    double lbmin=0,lbmax=5;
-    double amin=DEG2RAD(-60),amax=DEG2RAD(60);
-    double vmin=-10,vmax=30;
-    double kmin=-0.5,kmax=0.5;
-    double omegamin=DEG2RAD(-90),omegamax=DEG2RAD(90);
-};
-
-struct LaserScan
-{
-    int timestamp;
-    double x,y,theta;
-    int beamnum;
-    double length[MAXBEAMNUM];
-};
-
-struct EgoMotion
-{
-    bool validflag=0;
-    double x,y,theta;
-    int timestamp;
-    double dx=0,dy=0,dtheta=0;
-    int dt=0;
-    double density;
-    bool pfflag=0;
-};
-
-struct ObjectStateOffset
-{
-    double thetaoff=DEG2RAD(30),thetaprec=DEG2RAD(1),thetazoom=1;
-    double wloff=1.5,wlprec=0.1,wlzoom=1;
-    double wroff=1.5,wrprec=0.1,wrzoom=1;
-    double lfoff=2.5,lfprec=0.1,lfzoom=1;
-    double lboff=2.5,lbprec=0.1,lbzoom=1;
-    double aoff=DEG2RAD(60),aprec=DEG2RAD(1),azoom=1;
-    double voff=20,vprec=1,vzoom=1;
-    double koff=0.5,kprec=0.001,kzoom=1;
-    double omegaoff=DEG2RAD(90),omegaprec=DEG2RAD(1),omegazoom=1;
-    double anneal=1;
-    double annealratio=1;
-};
-
-struct TrackerDataContainer
-{
-    int pnum;
-    VehicleState * d_particle;
-    VehicleState * d_tmpparticle;
-    thrust::minstd_rand * d_rng;
-};
-
-struct TrackerResultContainer
-{
-    VehicleState estimate;
-    int edgepointnum[2];
-    int edgepointid[2][MAXEDGEPOINT];
-};
-
-extern "C" void cuda_InitLaserScan();
-extern "C" void cuda_FreeLaserScan();
-extern "C" void cuda_SetLaserScan(LaserScan &amp; laserScan);
-extern "C" void cuda_OpenTracker(TrackerDataContainer &amp; trackerDataContainer);
-extern "C" void cuda_CloseTracker(TrackerDataContainer &amp; trackerDataContainer);
-extern "C" void cuda_InitGeometry(TrackerDataContainer &amp; trackerDataContainer, TrackerResultContainer &amp; trackerResultContainer);
-extern "C" void cuda_InitMotion(TrackerDataContainer &amp; trackerDataContainer, TrackerResultContainer &amp; trackerResultContainer);
-extern "C" bool cuda_UpdateTracker(TrackerDataContainer &amp; trackerDataContainer, TrackerResultContainer &amp; trackerResultContainer);
-
-#endif // RBSSPFVEHICLETRACKER_CUH
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\rbsspfvehicletracker.h" new_path="" added_lines="0" deleted_lines="75">
				<diff>@@ -1,75 +0,0 @@
-#ifndef RBSSPFVEHICLETRACKER_H
-#define RBSSPFVEHICLETRACKER_H
-
-#include"rbsspfvehicletracker.cuh"
-
-#include&lt;QObject&gt;
-#include&lt;QThread&gt;
-#include&lt;QMap&gt;
-#include&lt;QVector&gt;
-#include&lt;QList&gt;
-
-class RBSSPFVehicleTrackerInstance : public QObject
-{
-    Q_OBJECT
-public:
-    RBSSPFVehicleTrackerInstance(int vehicleID, QThread * thread);
-    ~RBSSPFVehicleTrackerInstance();
-protected:
-    int id;
-    enum TrackerState
-    {
-        InitGeometry,
-        InitMotion,
-        UpdateTracker
-    } trackerstate;
-    TrackerDataContainer trackerdatacontainer;
-    TrackerResultContainer trackerresultcontainer;
-signals:
-    void signalCheckInitStateFinish();
-    void signalUpdateTrackerFinish(int vehicleID, TrackerResultContainer * trackerResult);
-public slots:
-    void slotCheckInitState(int initNum, VehicleState * initState, bool * initFlag);
-    void slotUpdateTracker(QMap&lt;int, VehicleState&gt; * initStateMap);
-};
-
-class RBSSPFVehicleTracker : public QObject
-{
-    Q_OBJECT
-public:
-    RBSSPFVehicleTracker();
-    ~RBSSPFVehicleTracker();
-protected:
-    enum TrackerState
-    {
-        NoLaserData,
-        OneLaserData,
-        ReadyForTracking,
-        Processing
-    } trackerstate;
-    int initnum;
-    QVector&lt;VehicleState&gt; initstate;
-    QVector&lt;bool&gt; initflag;
-    int trackercount;
-    QMap&lt;int, VehicleState&gt; initstatemap;
-protected:
-    int idcount=0;
-    LaserScan curscan;
-    QMap&lt;int, TrackerResultContainer&gt; trackerresultmap;
-    QMap&lt;int, QThread *&gt; trackerthreadmap;
-    QMap&lt;int, int&gt; discontinuemap;
-protected:
-    QList&lt;LaserScan&gt; scanbuffer;
-    QList&lt; QVector&lt;VehicleState&gt; &gt; initstatebuffer;
-public:
-    void addTrackerData(LaserScan &amp; scan, QVector&lt;VehicleState&gt; &amp; initState);
-signals:
-    void signalCheckInitState(int initNum, VehicleState * initState, bool * initFlag);
-    void signalUpdateTracker(QMap&lt;int, VehicleState&gt; * initStateMap);
-    void signalUpdateTrackerFinish(LaserScan scan, QMap&lt;int, TrackerResultContainer&gt; trackerresultmap);
-public slots:
-    void slotCheckInitStateFinish();
-    void slotUpdateTrackerFinish(int vehicleID, TrackerResultContainer * trackerResult);
-};
-
-#endif // RBSSPFVEHICLETRACKER_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\include\Context.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\include\Context.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\include\TrafficLight.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\include\TrafficLight.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\lib\Context.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\lib\Context.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\Rate.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\feat_proj\Rate.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\feat_proj\feat_proj.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\custom_graphics_view.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\label_maker\custom_graphics_view.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\custom_graphics_view.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\label_maker\custom_graphics_view.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\file_system_operator.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\label_maker\file_system_operator.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\file_system_operator.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\label_maker\file_system_operator.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\label_maker.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\label_maker\label_maker.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\label_maker_gui.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\label_maker\label_maker_gui.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -97,7 +97,7 @@ QString LabelMakerGui::GetTargetDirectoryPath() {
       error_message = "\"Images\" direcotry cannnot be found in \"" +
                       path + "\". \n\n" +
                       "Make sure DataSet directory surely exists. \n" +
-                      "Or Execute \"rosrun road_wizard roi_extractor\" first in order to create dataset source ";
+                      "Or Execute \"rosrun trafficlight_recognizer roi_extractor\" first in order to create dataset source ";
 
       QMessageBox::warning(this,
                            "ERROR",
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\label_maker_gui.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\label_maker\label_maker_gui.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\RegionTLR.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr\RegionTLR.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLightDetector.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr\TrafficLightDetector.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLightDetector.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr\TrafficLightDetector.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr\region_tlr.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_mxnet\mxnet_traffic_light_recognizer.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\mxnet_traffic_light_recognizer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_mxnet\mxnet_traffic_light_recognizer.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\mxnet_traffic_light_recognizer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_mxnet\region_tlr_mxnet.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_mxnet\region_tlr_mxnet.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\traffic_light_recognizer.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\traffic_light_recognizer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\traffic_light_recognizer.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\traffic_light_recognizer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\roi_extractor\roi_extractor.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\roi_extractor\roi_extractor.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\roi_extractor\roi_extractor.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\roi_extractor\roi_extractor.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tl_switch\tl_switch.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\tl_switch\tl_switch.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\mainwindow.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\tlr_tuner\mainwindow.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\mainwindow.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\tlr_tuner\mainwindow.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\tlr_tuner.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\tlr_tuner\tlr_tuner.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\tunerBody.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\tlr_tuner\tunerBody.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\tunerBody.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\tlr_tuner\tunerBody.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\include\gencolors.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\include\gencolors.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\lib\convert_image.h" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\lib\convert_image.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_lane.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_lane.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_lane.h" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_lane.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_points.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_points.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_points.h" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_points.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.h" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.h" new_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\include\gencolors.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\include\gencolors.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\image_d_viewer\image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\image_d_viewer\image_d_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\image_viewer\image_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\image_viewer\image_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\points_image_viewer\points_image_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\points_image_viewer\points_image_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\scan_image_d_viewer\scan_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\scan_image_d_viewer\scan_image_d_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\scan_image_viewer\scan_image_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\scan_image_viewer\scan_image_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\traffic_light_viewer\traffic_light_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\traffic_light_viewer\traffic_light_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\vscan_image_viewer\vscan_image_viewer.cpp" new_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\vscan_image_viewer\vscan_image_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\common\common.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\common\common.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\common\common.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\common\common.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\MODEL_info.h" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\MODEL_info.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\detect.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\detect.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\detect.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\dt.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\dt.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\dt.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\dt.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\fconvsMT.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\fconvsMT.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\fconvsMT.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\fconvsMT.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\featurepyramid.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\featurepyramid.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\featurepyramid.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\featurepyramid.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\get_boxes.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\get_boxes.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\get_boxes.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\get_boxes.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\load_model.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\load_model.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\load_model.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\load_model.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\main.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\main.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\nms.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\nms.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\nms.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\nms.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\resize.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\resize.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\resize.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\resize.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\switch_float.h" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\switch_float.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\tracking.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\tracking.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\cpu\tracking.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\cpu\tracking.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\GPU_function.cu" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\GPU_function.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\GPU_init.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\GPU_init.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\GPU_init.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\GPU_init.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\MODEL_info.h" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\MODEL_info.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\cuda_util.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\cuda_util.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\cuda_util.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\cuda_util.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\detect.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\detect.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\detect.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\drvapi_error_string.h" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\drvapi_error_string.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\dt_GPU.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\dt_GPU.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\dt_GPU.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\dt_GPU.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\fconvsMT.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\fconvsMT.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\fconvsMT.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\fconvsMT.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\featurepyramid.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\featurepyramid.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\featurepyramid.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\featurepyramid.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\for_use_GPU.h" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\for_use_GPU.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\get_boxes.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\get_boxes.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\get_boxes.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\get_boxes.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\load_model.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\load_model.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\load_model.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\load_model.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\multithreading.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\multithreading.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\multithreading.h" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\multithreading.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\nms.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\nms.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\nms.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\nms.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\obstacle_detection.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\obstacle_detection.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\resize_GPU.cc" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\resize_GPU.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\resize_GPU.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\resize_GPU.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\resize_GPU.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\resize_GPU.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\switch_float.h" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\switch_float.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\switch_release.h" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\switch_release.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\tracking.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\tracking.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\gpu\tracking.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\tracking.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\include\libdpm_ttic\dpm_ttic.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\include\libdpm_ttic\dpm_ttic.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ttic\util\capability_version_checker.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\util\capability_version_checker.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\data\car_comp.csv" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\data\car_comp.csv" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\data\car_part.csv" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\data\car_part.csv" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\data\car_root.csv" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\data\car_root.csv" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\data\person_comp.csv" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\data\person_comp.csv" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\data\person_part.csv" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\data\person_part.csv" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\data\person_root.csv" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\data\person_root.csv" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ttic\dpm_ttic.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\nodes\vision_dpm_ttic_detect\vision_dpm_ttic_detect.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lane_detector\nodes\lane_detector\utils.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_lane_detect\nodes\vision_lane_detect\utils.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lane_detector\nodes\lane_detector\lane_detector.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_lane_detect\nodes\vision_lane_detect\vision_lane_detect.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\image_segmenter\include\image_segmenter_enet.hpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_segment_enet_detect\include\vision_segment_enet_detect.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\image_segmenter\src\image_segmenter_enet.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_segment_enet_detect\nodes\vision_segment_enet_detect\vision_segment_enet_detect.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -5,7 +5,7 @@
  *      Author: amc
  */
 
-#include "image_segmenter_enet.hpp"
+#include "vision_segment_enet_detect.h"
 
 ENetSegmenter::ENetSegmenter(const std::string&amp; in_model_file,
 		const std::string&amp; in_trained_file,
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\image_segmenter\src\image_segmenter_enet_node.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_segment_enet_detect\nodes\vision_segment_enet_detect\vision_segment_enet_detect_node.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -11,7 +11,7 @@
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 
-#include "image_segmenter_enet.hpp"
+#include "vision_segment_enet_detect.h"
 
 class RosENetSegmenterApp
 {
@@ -144,4 +144,3 @@ int main(int argc, char **argv)
 
 	return 0;
 }
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\librcnn\include\rect_class_score.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\include\rect_class_score.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\include\ssd_detector.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\include\vision_ssd_detect.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\ssd_detector.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -27,7 +27,7 @@
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-#include "ssd_detector.h"
+#include "vision_ssd_detect.h"
 
 
 SsdDetector::SsdDetector(const std::string&amp; in_network_definition_file,
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\ssd_node.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -44,7 +44,7 @@
 #include &lt;opencv2/contrib/contrib.hpp&gt;
 #endif
 
-#include "ssd_detector.h"
+#include "vision_ssd_detect.h"
 
 class RosSsdApp
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\include\darknet\yolo2.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo2_detect\include\darknet\yolo2.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\include\rect_class_score.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo2_detect\include\rect_class_score.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\darknet\yolo2.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo2_detect\src\darknet\yolo2.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo2_detect\src\vision_yolo2_detect.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\cfg\yolov3-voc.cfg" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\cfg\yolov3-voc.cfg" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\cfg\yolov3.cfg" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\cfg\yolov3.cfg" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\activation_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\activation_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\activation_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\activation_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\activation_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\activation_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\activations.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\activations.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\activations.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\activations.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\avgpool_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\avgpool_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\avgpool_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\avgpool_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\avgpool_layer_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\avgpool_layer_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\batchnorm_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\batchnorm_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\batchnorm_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\batchnorm_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\blas.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\blas.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\blas.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\blas.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\blas_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\blas_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\box.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\box.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\box.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\box.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\classifier.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\classifier.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\col2im.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\col2im.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\col2im.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\col2im.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\col2im_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\col2im_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\connected_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\connected_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\connected_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\connected_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\convolutional_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\convolutional_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\convolutional_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\convolutional_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\convolutional_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\convolutional_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\cost_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\cost_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\cost_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\cost_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\crnn_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\crnn_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\crnn_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\crnn_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\crop_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\crop_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\crop_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\crop_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\crop_layer_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\crop_layer_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\cuda.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\cuda.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\cuda.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\cuda.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\darknet.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\darknet.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\data.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\data.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\data.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\data.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\deconvolutional_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\deconvolutional_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\deconvolutional_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\deconvolutional_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\deconvolutional_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\deconvolutional_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\demo.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\demo.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\demo.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\demo.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\detection_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\detection_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\detection_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\detection_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\dropout_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\dropout_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\dropout_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\dropout_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\dropout_layer_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\dropout_layer_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\gemm.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\gemm.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\gemm.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\gemm.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\gru_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\gru_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\gru_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\gru_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\im2col.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\im2col.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\im2col.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\im2col.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\im2col_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\im2col_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\image.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\image.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\image.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\image.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\l2norm_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\l2norm_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\l2norm_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\l2norm_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\list.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\list.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\list.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\list.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\local_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\local_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\local_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\local_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\logistic_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\logistic_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\logistic_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\logistic_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\lstm_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\lstm_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\lstm_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\lstm_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\matrix.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\matrix.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\matrix.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\matrix.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\maxpool_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\maxpool_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\maxpool_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\maxpool_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\maxpool_layer_kernels.cu" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\maxpool_layer_kernels.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\network.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\network.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\network.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\network.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\normalization_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\normalization_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\normalization_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\normalization_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\option_list.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\option_list.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\option_list.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\option_list.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\parser.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\parser.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\parser.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\parser.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\region_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\region_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\region_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\region_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\reorg_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\reorg_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\reorg_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\reorg_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\rnn_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\rnn_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\rnn_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\rnn_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\route_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\route_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\route_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\route_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\shortcut_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\shortcut_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\shortcut_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\shortcut_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\softmax_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\softmax_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\softmax_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\softmax_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\stb_image.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\stb_image.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\stb_image_write.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\stb_image_write.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\tree.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\tree.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\tree.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\tree.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\upsample_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\upsample_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\upsample_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\upsample_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\utils.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\utils.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\utils.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\utils.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\yolo_layer.c" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\yolo_layer.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\darknet\src\yolo_layer.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\darknet\src\yolo_layer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\src\rect_class_score.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\src\rect_class_score.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\src\yolo3_detector.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\src\vision_yolo3_detect.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -33,7 +33,7 @@
  *
  *  Created on: April 4th, 2018
  */
-#include "yolo3_detector.h"
+#include "vision_yolo3_detect.h"
 
 namespace darknet
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\src\yolo3_detector.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\src\vision_yolo3_detect.h" added_lines="1" deleted_lines="1">
				<diff>@@ -36,7 +36,7 @@
 #ifndef DARKNET_YOLO3_H
 #define DARKNET_YOLO3_H
 
-#define __APP_NAME__ "yolo3_detector"
+#define __APP_NAME__ "vision_yolo3_detect"
 
 #include &lt;cstdint&gt;
 #include &lt;cstdlib&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\yolo3_detector\src\yolo3_node.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_yolo3_detect\src\vision_yolo3_detect_node.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -32,11 +32,11 @@
  *  Created on: April 4th, 2018
  */
 
-#include "yolo3_detector.h"
+#include "vision_yolo3_detect.h"
 
 int main(int argc, char **argv)
 {
-    ros::init(argc, argv, "yolo3");
+    ros::init(argc, argv, "vision_yolo3_detect");
 
     Yolo3DetectorNode app;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\include\gencolors.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\libs\kf\include\gencolors.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\kf\src\kf_lib.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\libs\kf\src\kf_lib.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dummy_track\dummy_track.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_dummy_track\nodes\vision_dummy_track\vision_dummy_track.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\include\gencolors.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_kf_track\include\gencolors.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\lib\lktracker\LkTracker.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_kf_track\lib\lktracker\LkTracker.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\lib\lktracker\LkTracker.hpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_kf_track\lib\lktracker\LkTracker.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\kf_track\kf_track.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_kf_track\nodes\vision_kf_track\vision_kf_track.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\approximate_ndt_mapping\approximate_ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\approximate_ndt_mapping\approximate_ndt_mapping.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\icp_localizer\nodes\icp_matching\icp_matching.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\icp_matching\icp_matching.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\lazy_ndt_mapping\lazy_ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\lazy_ndt_mapping\lazy_ndt_mapping.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping_tku\mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping_tku\mapping.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping_tku\ndt_mapping_tku.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping_tku\ndt_mapping_tku.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.h" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor_node.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor_node.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching_tku\ndt_matching_tku.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_tku\ndt_matching_tku.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\queue_counter\queue_counter.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\queue_counter\queue_counter.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\tf_mapping\tf_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\tf_mapping\tf_mapping.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -302,7 +302,7 @@ int main(int argc, char **argv)
   {
     initialpose_subscriber = nh.subscribe("initialpose", 10, initialposeCallback);
   }
-  else if (initialize_source == "ndt_localizer")
+  else if (initialize_source == "lidar_localizer")
   {
     initialpose_subscriber = nh.subscribe("ndt_pose", 10, callbackFromPoseStamped);
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3472e98b19bbaf7e926c1073a5e65b5ae1a329dd" author="Kosuke Murakami">
		<msg>Modify quick start launch file</msg>
		<modified_files>
			<file old_path="ros\src\.config\quick_start\sample_lidar_camera\detection.launch" new_path="ros\src\.config\quick_start\sample_lidar_camera\detection.launch" added_lines="5" deleted_lines="11">
				<diff>@@ -7,36 +7,30 @@
 
   &lt;!-- car and pedestrian detection --&gt;
   &lt;!-- dpm_XXX --&gt;
-  &lt;include file="$(find cv_tracker)/launch/dpm_ttic.launch"&gt;
+  &lt;include file="$(find vision_dpm_ttic_detect)/launch/vision_dpm_ttic_detect.launch"&gt;
     &lt;arg name="car" value="$(arg car_detection)" /&gt;
     &lt;arg name="pedestrian" value="$(arg pedestrian_detection)" /&gt;
     &lt;arg name="use_gpu" value="$(arg is_use_gpu)" /&gt;
   &lt;/include&gt;
 
   &lt;!-- range_fusion --&gt;
-  &lt;include file="$(find cv_tracker)/launch/ranging.launch"&gt;
-    &lt;arg name="car" value="$(arg car_detection)" /&gt;
-    &lt;arg name="pedestrian" value="$(arg pedestrian_detection)" /&gt;
-  &lt;/include&gt;
-
-  &lt;!-- XXX_track --&gt;
-  &lt;include file="$(find cv_tracker)/launch/kf_tracking.launch"&gt;
+  &lt;include file="$(find range_fusion)/launch/range_fusion.launch"&gt;
     &lt;arg name="car" value="$(arg car_detection)" /&gt;
     &lt;arg name="pedestrian" value="$(arg pedestrian_detection)" /&gt;
   &lt;/include&gt;
 
   &lt;!-- obj_reproj --&gt;
-  &lt;include file="$(find cv_tracker)/launch/reprojection.launch"&gt;
+  &lt;include file="$(find obj_reproj)/launch/obj_reproj.launch"&gt;
     &lt;arg name="car" value="$(arg car_detection)" /&gt;
     &lt;arg name="pedestrian" value="$(arg pedestrian_detection)" /&gt;
   &lt;/include&gt;
 
   &lt;!-- euclidean_cluster --&gt;
-  &lt;include file="$(find lidar_tracker)/launch/euclidean_clustering.launch"&gt;
+  &lt;include file="$(find lidar_euclidean_cluster_detect)/launch/lidar_euclidean_cluster_detect.launch"&gt;
   &lt;/include&gt;
 
   &lt;!-- obj_fusion --&gt;
-  &lt;include file="$(find lidar_tracker)/launch/obj_fusion.launch"&gt;
+  &lt;include file="$(find obj_fusion)/launch/obj_fusion.launch"&gt;
     &lt;arg name="car" value="$(arg car_detection)" /&gt;
     &lt;arg name="pedestrian" value="$(arg pedestrian_detection)" /&gt;
   &lt;/include&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="776f46ab17ec14c3f0a2f920f49b9bdf1cbfda38" author="Yuma Nihei">
		<msg>Fix flashing marker &amp; set lifetime</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" added_lines="14" deleted_lines="1">
				<diff>@@ -75,6 +75,15 @@ enum class ChangeFlag : int32_t
 
 typedef std::underlying_type&lt;ChangeFlag&gt;::type ChangeFlagInteger;
 
+void setLifetime(double sec, visualization_msgs::MarkerArray* marker_array)
+{
+  ros::Duration lifetime(sec);
+  for (auto&amp; marker : marker_array-&gt;markers)
+  {
+    marker.lifetime = lifetime;
+  }
+}
+
 void publishMarkerArray(const visualization_msgs::MarkerArray&amp; marker_array, const ros::Publisher&amp; publisher, bool delete_markers=false)
 {
   visualization_msgs::MarkerArray msg;
@@ -85,12 +94,16 @@ void publishMarkerArray(const visualization_msgs::MarkerArray&amp; marker_array, con
   if (delete_markers)
   {
     for (auto&amp; marker : msg.markers)
+    {
       marker.action = visualization_msgs::Marker::DELETE;
+    }
   }
 
   publisher.publish(msg);
 }
 
+
+
 void createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray&amp; lane_waypoints_array)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
@@ -395,12 +408,12 @@ void laneArrayCallback(const autoware_msgs::LaneArrayConstPtr&amp; msg)
 
 void finalCallback(const autoware_msgs::laneConstPtr&amp; msg)
 {
-  publishMarkerArray(g_local_waypoints_marker_array, g_local_mark_pub, true);
   g_local_waypoints_marker_array.markers.clear();
   if (_closest_waypoint != -1)
     createLocalWaypointVelocityMarker(g_local_color, _closest_waypoint, *msg);
   createLocalPathMarker(g_local_color, *msg);
   createLocalPointMarker(*msg);
+  setLifetime(0.5, &amp;g_local_waypoints_marker_array);
   publishMarkerArray(g_local_waypoints_marker_array, g_local_mark_pub);
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
</Root>
