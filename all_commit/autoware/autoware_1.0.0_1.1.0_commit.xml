<?xml version="1.0" encoding="utf-8"?>
<Root>
	<commit hash="022c44a209256b7e380e0169e02876a76eea41a7" author="h_ohta">
		<msg>Add no name namespame instead of using static modifier</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader.cpp" added_lines="10" deleted_lines="7">
				<diff>@@ -38,6 +38,8 @@
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "waypoint_follower/LaneArray.h"
 
+namespace {
+
 struct WP
 {
   geometry_msgs::Pose pose;
@@ -45,13 +47,13 @@ struct WP
 };
 
 
-static const std::string DRIVING_LANE_CSV = "/tmp/driving_lane.csv";
-static const std::string PASSING_LANE_CSV = "/tmp/passing_lane.csv";
-static double _decelerate = 1.0;
+const std::string DRIVING_LANE_CSV = "/tmp/driving_lane.csv";
+const std::string PASSING_LANE_CSV = "/tmp/passing_lane.csv";
+double _decelerate = 1.0;
 
-static std::vector&lt;WP&gt; _waypoints;
+std::vector&lt;WP&gt; _waypoints;
 
-static WP parseWaypoint(const std::string&amp; line, bool yaw)
+WP parseWaypoint(const std::string&amp; line, bool yaw)
 {
   std::istringstream ss(line);
   std::vector&lt;std::string&gt; columns;
@@ -82,7 +84,7 @@ static WP parseWaypoint(const std::string&amp; line, bool yaw)
   return waypoint;
 }
 
-static size_t countColumn(const std::string&amp; line)
+size_t countColumn(const std::string&amp; line)
 {
   std::istringstream ss(line);
   size_t ncol = 0;
@@ -96,7 +98,7 @@ static size_t countColumn(const std::string&amp; line)
   return ncol;
 }
 
-static std::vector&lt;WP&gt; readWaypoint(const char *filename)
+std::vector&lt;WP&gt; readWaypoint(const char *filename)
 {
   std::ifstream ifs(filename);
   std::string line;
@@ -203,6 +205,7 @@ waypoint_follower::lane createLaneWaypoint(std::vector&lt;WP&gt; waypoints)
   }
   return lane_waypoint;
 }
+} //namespace
 
 int main(int argc, char **argv)
 {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e9058a26e8c5ef1bf6d8e5bc7e0b674e128eb6b5" author="h_ohta">
		<msg>Add support for multi lane files</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader.cpp" added_lines="26" deleted_lines="33">
				<diff>@@ -46,23 +46,23 @@ struct WP
   double velocity_kmh;
 };
 
-
-const std::string DRIVING_LANE_CSV = "/tmp/driving_lane.csv";
-const std::string PASSING_LANE_CSV = "/tmp/passing_lane.csv";
 double _decelerate = 1.0;
+const std::string MULTI_LANE_CSV = "/tmp/driving_lane.csv";
 
-std::vector&lt;WP&gt; _waypoints;
-
-WP parseWaypoint(const std::string&amp; line, bool yaw)
+void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns)
 {
   std::istringstream ss(line);
-  std::vector&lt;std::string&gt; columns;
-
   std::string column;
   while (std::getline(ss, column, ','))
-  {
-    columns.push_back(column);
-  }
+    {
+      columns-&gt;push_back(column);
+    }
+}
+
+WP parseWaypoint(const std::string&amp; line, bool yaw)
+{
+  std::vector&lt;std::string&gt; columns;
+  parseColumns(line, &amp;columns);
 
   WP waypoint;
   if (yaw)
@@ -213,36 +213,29 @@ int main(int argc, char **argv)
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
 
-  std::string driving_lane_csv;
-  std::string passing_lane_csv;
+  std::string multi_lane_csv;
 
-  private_nh.param&lt;std::string&gt;("driving_lane_csv", driving_lane_csv, DRIVING_LANE_CSV);
-  private_nh.param&lt;std::string&gt;("passing_lane_csv", passing_lane_csv, PASSING_LANE_CSV);
   private_nh.getParam("decelerate", _decelerate);
   ROS_INFO_STREAM("decelerate :" &lt;&lt; _decelerate);
+  private_nh.param&lt;std::string&gt;("multi_lane_csv", multi_lane_csv, MULTI_LANE_CSV);
 
   ros::Publisher lane_pub = nh.advertise&lt;waypoint_follower::LaneArray&gt;("lane_waypoints_array", 10, true);
   waypoint_follower::LaneArray lane_array;
 
-  if (!verifyFileConsistency(driving_lane_csv.c_str()))
+  std::vector&lt;std::string&gt; multi_file_path;
+  parseColumns(multi_lane_csv, &amp;multi_file_path);
+  for(auto el : multi_file_path)
   {
-    ROS_ERROR("driving lane data is something wrong...");
-    exit(-1);
-  }
-  else
-  {
-    ROS_INFO("driving lane data is valid. publishing...");
-    lane_array.lanes.push_back(createLaneWaypoint(readWaypoint(driving_lane_csv.c_str())));
-  }
-
-  if (!verifyFileConsistency(passing_lane_csv.c_str()))
-  {
-    ROS_INFO("no passing lane data...");
-  }
-  else
-  {
-    ROS_INFO("passing lane data is valid. publishing...");
-    lane_array.lanes.push_back(createLaneWaypoint(readWaypoint(passing_lane_csv.c_str())));
+    if (!verifyFileConsistency(el.c_str()))
+    {
+      ROS_ERROR("lane data is something wrong...");
+      exit(-1);
+    }
+    else
+    {
+      ROS_INFO("lane data is valid. publishing...");
+      lane_array.lanes.push_back(createLaneWaypoint(readWaypoint(el.c_str())));
+    }
   }
 
   lane_pub.publish(lane_array);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2fb6506b4a2b42e93029092ed324ebbece488c26" author="h_ohta">
		<msg>Add g_ prefix to global variables</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -46,7 +46,7 @@ struct WP
   double velocity_kmh;
 };
 
-double _decelerate = 1.0;
+double g_decelerate = 1.0;
 const std::string MULTI_LANE_CSV = "/tmp/driving_lane.csv";
 
 void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns)
@@ -147,7 +147,7 @@ double decelerate(tf::Vector3 v1, tf::Vector3 v2, double original_velocity_kmh)
 {
 
   double distance = tf::tfDistance(v1, v2);
-  double vel = mps2kmph(sqrt(2 * _decelerate * distance)); //km/h
+  double vel = mps2kmph(sqrt(2 * g_decelerate * distance)); //km/h
   if (vel &lt; 1.0)
     vel = 0;
   if (vel &gt; original_velocity_kmh)
@@ -215,8 +215,8 @@ int main(int argc, char **argv)
 
   std::string multi_lane_csv;
 
-  private_nh.getParam("decelerate", _decelerate);
-  ROS_INFO_STREAM("decelerate :" &lt;&lt; _decelerate);
+  private_nh.getParam("decelerate", g_decelerate);
+  ROS_INFO_STREAM("decelerate :" &lt;&lt; g_decelerate);
   private_nh.param&lt;std::string&gt;("multi_lane_csv", multi_lane_csv, MULTI_LANE_CSV);
 
   ros::Publisher lane_pub = nh.advertise&lt;waypoint_follower::LaneArray&gt;("lane_waypoints_array", 10, true);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4cff9ae23d4dc7b8bdd7cc8d2b65f48988e8d3f7" author="h_ohta">
		<msg>Add checkFileFormat() function</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader.cpp" added_lines="44" deleted_lines="1">
				<diff>@@ -40,6 +40,14 @@
 
 namespace {
 
+enum class FileFormat
+{
+  ver1,  //x,y,z,(velocity)
+  ver2,  //x,y,z,yaw,(velocity)
+  ver3,  //first line consists on explanation of values
+  unknown,
+};
+
 struct WP
 {
   geometry_msgs::Pose pose;
@@ -84,7 +92,7 @@ WP parseWaypoint(const std::string&amp; line, bool yaw)
   return waypoint;
 }
 
-size_t countColumn(const std::string&amp; line)
+size_t countColumns(const std::string&amp; line)
 {
   std::istringstream ss(line);
   size_t ncol = 0;
@@ -205,6 +213,41 @@ waypoint_follower::lane createLaneWaypoint(std::vector&lt;WP&gt; waypoints)
   }
   return lane_waypoint;
 }
+
+FileFormat checkFileFormat(const char* filename)
+{
+
+  std::ifstream ifs(filename);
+
+  if (!ifs)
+  {
+    return FileFormat::unknown;
+  }
+
+  // get first line
+  std::string line;
+  std::getline(ifs, line);
+
+  //parse first line
+  std::vector&lt;std::string&gt; parsed_columns;
+  parseColumns(line, &amp;parsed_columns);
+
+  //check if first element in the first column does not include digit
+  if (!std::any_of(parsed_columns.at(0).cbegin(),parsed_columns.at(0).cend(),isdigit))
+  {
+    return FileFormat::ver3;
+  }
+
+  //if element consists only digit
+  int num_of_columns = countColumns(line);
+  ROS_INFO("columns size: %d",num_of_columns);
+
+  return (num_of_columns == 3 ? FileFormat::ver1  // if data consists "x y z (velocity)"
+         : num_of_columns == 4 ? FileFormat::ver2  // if data consists "x y z yaw (velocity)
+                               : FileFormat::unknown
+          );
+}
+
 } //namespace
 
 int main(int argc, char **argv)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a99b93e9786196cf08e1341d732b54a1f4bdbb3a" author="h_ohta">
		<msg>Adjust for new fileformat</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader.cpp" added_lines="68" deleted_lines="56">
				<diff>@@ -35,6 +35,8 @@
 #include &lt;iostream&gt;
 #include &lt;vector&gt;
 #include &lt;string&gt;
+#include &lt;cctype&gt;
+#include &lt;algorithm&gt;
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "waypoint_follower/LaneArray.h"
 
@@ -52,6 +54,7 @@ struct WP
 {
   geometry_msgs::Pose pose;
   double velocity_kmh;
+  int32_t change_flag;
 };
 
 double g_decelerate = 1.0;
@@ -67,29 +70,30 @@ void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns)
     }
 }
 
-WP parseWaypoint(const std::string&amp; line, bool yaw)
+void parseWaypoint(const std::string&amp; line, FileFormat format, WP *waypoint)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
 
-  WP waypoint;
-  if (yaw)
+  waypoint-&gt;pose.position.x = std::stod(columns[0]);
+  waypoint-&gt;pose.position.y = std::stod(columns[1]);
+  waypoint-&gt;pose.position.z = std::stod(columns[2]);
+
+  if (format == FileFormat::ver2)
   {
-    waypoint.pose.position.x = std::stod(columns[0]);
-    waypoint.pose.position.y = std::stod(columns[1]);
-    waypoint.pose.position.z = std::stod(columns[2]);
-    waypoint.pose.orientation = tf::createQuaternionMsgFromYaw(std::stod(columns[3]));
-    waypoint.velocity_kmh = std::stod(columns[4]);
+    waypoint-&gt;pose.orientation = tf::createQuaternionMsgFromYaw(std::stod(columns[3]));
+    waypoint-&gt;velocity_kmh = std::stod(columns[4]);
   }
-  else
+  else if (format == FileFormat::ver1)
   {
-    waypoint.pose.position.x = std::stod(columns[0]);
-    waypoint.pose.position.y = std::stod(columns[1]);
-    waypoint.pose.position.z = std::stod(columns[2]);
-    waypoint.velocity_kmh = std::stod(columns[3]);
+    waypoint-&gt;velocity_kmh = std::stod(columns[3]);
+  }
+  else if (format == FileFormat::ver3)
+  {
+    waypoint-&gt;pose.orientation = tf::createQuaternionMsgFromYaw(std::stod(columns[3]));
+    waypoint-&gt;velocity_kmh = std::stod(columns[4]);
+    waypoint-&gt;change_flag = std::stoi(columns[5]);
   }
-
-  return waypoint;
 }
 
 size_t countColumns(const std::string&amp; line)
@@ -106,49 +110,50 @@ size_t countColumns(const std::string&amp; line)
   return ncol;
 }
 
-std::vector&lt;WP&gt; readWaypoint(const char *filename)
+bool readWaypoint(const char *filename, FileFormat format, std::vector&lt;WP&gt; *waypoints)
 {
   std::ifstream ifs(filename);
-  std::string line;
 
+  if(!ifs)
+  {
+    return false;
+  }
+
+  std::string line;
   std::getline(ifs, line); // Remove first line
-  size_t ncol = countColumn(line);
 
-  std::vector&lt;WP&gt; waypoints;
-  if (ncol == 3)
+  if(format == FileFormat::ver3)
   {
-    while (std::getline(ifs, line))
-    {
-      waypoints.push_back(parseWaypoint(line, false));
-    }
+    std::getline(ifs, line);  //remove second line
+  }
+
+  while (std::getline(ifs, line))
+  {
+    WP wp;
+    parseWaypoint(line, format, &amp;wp);
+    waypoints-&gt;push_back(wp);
+  }
 
-    size_t last = waypoints.size() - 1;
-    for (size_t i = 0; i &lt; waypoints.size(); ++i)
+  if (format == FileFormat::ver1)
+  {
+    size_t last = waypoints-&gt;size() - 1;
+    for (size_t i = 0; i &lt; waypoints-&gt;size(); ++i)
     {
-      double yaw;
-      if (i == last)
+      if (i != last)
       {
-        yaw = atan2(waypoints[i-1].pose.position.y - waypoints[i].pose.position.y,
-                    waypoints[i-1].pose.position.x - waypoints[i].pose.position.x);
-        yaw -= M_PI;
+        double yaw = atan2(waypoints-&gt;at(i+1).pose.position.y - waypoints-&gt;at(i).pose.position.y,
+                   waypoints-&gt;at(i+1).pose.position.x - waypoints-&gt;at(i).pose.position.x);
+        waypoints-&gt;at(i).pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
       }
       else
       {
-        yaw = atan2(waypoints[i+1].pose.position.y - waypoints[i].pose.position.y,
-                    waypoints[i+1].pose.position.x - waypoints[i].pose.position.x);
+        waypoints-&gt;at(i).pose.orientation = waypoints-&gt;at(i-1).pose.orientation;
       }
-      waypoints[i].pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
-    }
-  }
-  else if (ncol == 4)
-  {
-    while (std::getline(ifs, line))
-    {
-      waypoints.push_back(parseWaypoint(line, true));
+
     }
   }
 
-  return waypoints;
+  return true;
 }
 
 double decelerate(tf::Vector3 v1, tf::Vector3 v2, double original_velocity_kmh)
@@ -166,9 +171,9 @@ double decelerate(tf::Vector3 v1, tf::Vector3 v2, double original_velocity_kmh)
 }
 
 
-bool verifyFileConsistency(const char *filename)
+bool verifyFileConsistency(const char *filename, FileFormat format)
 {
-
+  ROS_INFO("verify...");
   std::ifstream ifs(filename);
 
   if (!ifs)
@@ -177,19 +182,21 @@ bool verifyFileConsistency(const char *filename)
   }
 
   std::string line;
-  std::getline(ifs, line);
-  size_t ncol = countColumn(line);
+  std::getline(ifs, line); //get first line
+  std::getline(ifs, line); //get second line
 
-  while (std::getline(ifs, line))
+  size_t ncol = countColumns(line);
+
+   while (std::getline(ifs, line))
   {
-    if (countColumn(line) != ncol + 1)
+    if (countColumns(line) != ncol)
       return false;
   }
   return true;
 }
 
 
-waypoint_follower::lane createLaneWaypoint(std::vector&lt;WP&gt; waypoints)
+waypoint_follower::lane createLaneWaypoint(const std::vector&lt;WP&gt; &amp;waypoints)
 {
   waypoint_follower::lane lane_waypoint;
   lane_waypoint.header.frame_id = "/map";
@@ -208,6 +215,7 @@ waypoint_follower::lane createLaneWaypoint(std::vector&lt;WP&gt; waypoints)
         point2vector(waypoints[waypoints.size() -1 ].pose.position),
         waypoints[i].velocity_kmh);
     wp.twist.twist.linear.x = kmph2mps(vel_kmh);
+    wp.change_flag = waypoints[i].change_flag;
 
     lane_waypoint.waypoints.push_back(wp);
   }
@@ -267,18 +275,22 @@ int main(int argc, char **argv)
 
   std::vector&lt;std::string&gt; multi_file_path;
   parseColumns(multi_lane_csv, &amp;multi_file_path);
-  for(auto el : multi_file_path)
+
+  for (auto el : multi_file_path)
   {
-    if (!verifyFileConsistency(el.c_str()))
+    FileFormat file_format = checkFileFormat(el.c_str());
+    ROS_INFO("Format: %d", file_format);
+
+    if (!verifyFileConsistency(el.c_str(),file_format))
     {
       ROS_ERROR("lane data is something wrong...");
       exit(-1);
     }
-    else
-    {
-      ROS_INFO("lane data is valid. publishing...");
-      lane_array.lanes.push_back(createLaneWaypoint(readWaypoint(el.c_str())));
-    }
+
+    ROS_INFO("lane data is valid. publishing...");
+    std::vector&lt;WP&gt; wps;
+    readWaypoint(el.c_str(), file_format, &amp;wps);
+    lane_array.lanes.push_back(createLaneWaypoint(wps));
   }
 
   lane_pub.publish(lane_array);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_saver\waypoint_saver.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_saver\waypoint_saver.cpp" added_lines="3" deleted_lines="2">
				<diff>@@ -134,8 +134,9 @@ void WaypointSaver::outputProcessing(geometry_msgs::Pose current_pose, double ve
   // first subscribe
   if (!receive_once)
   {
+    ofs &lt;&lt; "x,y,z,yaw,velocity,change_flag" &lt;&lt; std::endl;
     ofs &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; current_pose.position.x &lt;&lt; "," &lt;&lt; current_pose.position.y &lt;&lt; ","
-        &lt;&lt; current_pose.position.z &lt;&lt; "," &lt;&lt; tf::getYaw(current_pose.orientation) &lt;&lt; std::endl;
+        &lt;&lt; current_pose.position.z &lt;&lt; "," &lt;&lt; tf::getYaw(current_pose.orientation) &lt;&lt; ",0,0" &lt;&lt; std::endl;
     receive_once = true;
     displayMarker(current_pose, 0);
     previous_pose = current_pose;
@@ -149,7 +150,7 @@ void WaypointSaver::outputProcessing(geometry_msgs::Pose current_pose, double ve
     if (distance &gt; interval_)
     {
       ofs &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; current_pose.position.x &lt;&lt; "," &lt;&lt; current_pose.position.y &lt;&lt; ","
-          &lt;&lt; current_pose.position.z &lt;&lt; "," &lt;&lt; tf::getYaw(current_pose.orientation) &lt;&lt; "," &lt;&lt; velocity &lt;&lt; std::endl;
+          &lt;&lt; current_pose.position.z &lt;&lt; "," &lt;&lt; tf::getYaw(current_pose.orientation) &lt;&lt; "," &lt;&lt; velocity &lt;&lt; ",0" &lt;&lt; std::endl;
 
       displayMarker(current_pose, velocity);
       previous_pose = current_pose;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="51f83a5db98ae037760c875d7391b23455ce884e" author="h_ohta">
		<msg>Add visualization for change flag</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" added_lines="63" deleted_lines="3">
				<diff>@@ -127,6 +127,65 @@ void createGlobalLaneArrayVelocityMarker(const waypoint_follower::LaneArray &amp;lan
                                        tmp_marker_array.markers.end());
 }
 
+void createGlobalLaneArrayChangeFlagMarker(const waypoint_follower::LaneArray &amp;lane_waypoints_array)
+{
+  visualization_msgs::MarkerArray tmp_marker_array;
+  // display by markers the velocity of each waypoint.
+  visualization_msgs::Marker marker;
+  marker.header.frame_id = "map";
+  marker.header.stamp = ros::Time();
+  marker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
+  marker.action = visualization_msgs::Marker::ADD;
+  marker.scale.z = 0.4;
+  marker.color.a = 1.0;
+  marker.color.r = 1;
+  marker.color.g = 1;
+  marker.color.b = 1;
+  marker.frame_locked = true;
+
+  int count = 1;
+  for (auto lane : lane_waypoints_array.lanes)
+  {
+    marker.ns = "global_change_flag_lane_" + std::to_string(count);
+    for (int i = 0; i &lt; static_cast&lt;int&gt;(lane.waypoints.size()); i++)
+    {
+      //std::cout &lt;&lt; _waypoints[i].GetX() &lt;&lt; " " &lt;&lt; _waypoints[i].GetY() &lt;&lt; " " &lt;&lt; _waypoints[i].GetZ() &lt;&lt; " " &lt;&lt; _waypoints[i].GetVelocity_kmh() &lt;&lt; std::endl;
+      marker.id = i;
+      geometry_msgs::Point relative_p;
+      relative_p.x = -0.1;
+      marker.pose.position = calcAbsoluteCoordinate(relative_p, lane.waypoints[i].pose.pose);
+      marker.pose.position.z += 0.2;
+
+      // double to string
+      std::string str = "";
+      if(lane.waypoints[i].change_flag == 0)
+      {
+        str = "S";
+      }
+      else if(lane.waypoints[i].change_flag == 1)
+      {
+        str = "R";
+      }
+      else if(lane.waypoints[i].change_flag == 2)
+      {
+        str = "L";
+      }
+      else if(lane.waypoints[i].change_flag == 3)
+      {
+        str = "U";
+      }
+
+      marker.text = str;
+
+      tmp_marker_array.markers.push_back(marker);
+    }
+    count++;
+  }
+
+  g_global_marker_array.markers.insert(g_global_marker_array.markers.end(), tmp_marker_array.markers.begin(),
+                                       tmp_marker_array.markers.end());
+}
+
 void createLocalWaypointVelocityMarker(std_msgs::ColorRGBA color, int closest_waypoint,
                                        const waypoint_follower::lane &amp;lane_waypoint)
 {
@@ -199,9 +258,9 @@ void createGlobalLaneArrayOrientationMarker(const waypoint_follower::LaneArray &amp;
   lane_waypoint_marker.header.stamp = ros::Time();
   lane_waypoint_marker.type = visualization_msgs::Marker::ARROW;
   lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
-  lane_waypoint_marker.scale.x = 0.5;
-  lane_waypoint_marker.scale.y = 0.1;
-  lane_waypoint_marker.scale.z = 0.1;
+  lane_waypoint_marker.scale.x = 0.25;
+  lane_waypoint_marker.scale.y = 0.05;
+  lane_waypoint_marker.scale.z = 0.05;
   lane_waypoint_marker.color.r = 1.0;
   lane_waypoint_marker.color.a = 1.0;
   lane_waypoint_marker.frame_locked = true;
@@ -306,6 +365,7 @@ void laneArrayCallback(const waypoint_follower::LaneArrayConstPtr &amp;msg)
   createGlobalLaneArrayVelocityMarker(*msg);
   createGlobalLaneArrayMarker(_global_color, *msg);
   createGlobalLaneArrayOrientationMarker(*msg);
+  createGlobalLaneArrayChangeFlagMarker(*msg);
   publishGlobalMarker();
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5b9e9dc1160438badfbd23253a5088fc61776c63" author="h_ohta">
		<msg>Rewrite waypoint_loader</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader.cpp" new_path="" added_lines="0" deleted_lines="300">
				<diff>@@ -1,300 +0,0 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include &lt;ros/ros.h&gt;
-#include &lt;ros/console.h&gt;
-#include &lt;geometry_msgs/Point.h&gt;
-
-#include &lt;iostream&gt;
-#include &lt;vector&gt;
-#include &lt;string&gt;
-#include &lt;cctype&gt;
-#include &lt;algorithm&gt;
-#include "waypoint_follower/libwaypoint_follower.h"
-#include "waypoint_follower/LaneArray.h"
-
-namespace {
-
-enum class FileFormat
-{
-  ver1,  //x,y,z,(velocity)
-  ver2,  //x,y,z,yaw,(velocity)
-  ver3,  //first line consists on explanation of values
-  unknown,
-};
-
-struct WP
-{
-  geometry_msgs::Pose pose;
-  double velocity_kmh;
-  int32_t change_flag;
-};
-
-double g_decelerate = 1.0;
-const std::string MULTI_LANE_CSV = "/tmp/driving_lane.csv";
-
-void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns)
-{
-  std::istringstream ss(line);
-  std::string column;
-  while (std::getline(ss, column, ','))
-    {
-      columns-&gt;push_back(column);
-    }
-}
-
-void parseWaypoint(const std::string&amp; line, FileFormat format, WP *waypoint)
-{
-  std::vector&lt;std::string&gt; columns;
-  parseColumns(line, &amp;columns);
-
-  waypoint-&gt;pose.position.x = std::stod(columns[0]);
-  waypoint-&gt;pose.position.y = std::stod(columns[1]);
-  waypoint-&gt;pose.position.z = std::stod(columns[2]);
-
-  if (format == FileFormat::ver2)
-  {
-    waypoint-&gt;pose.orientation = tf::createQuaternionMsgFromYaw(std::stod(columns[3]));
-    waypoint-&gt;velocity_kmh = std::stod(columns[4]);
-  }
-  else if (format == FileFormat::ver1)
-  {
-    waypoint-&gt;velocity_kmh = std::stod(columns[3]);
-  }
-  else if (format == FileFormat::ver3)
-  {
-    waypoint-&gt;pose.orientation = tf::createQuaternionMsgFromYaw(std::stod(columns[3]));
-    waypoint-&gt;velocity_kmh = std::stod(columns[4]);
-    waypoint-&gt;change_flag = std::stoi(columns[5]);
-  }
-}
-
-size_t countColumns(const std::string&amp; line)
-{
-  std::istringstream ss(line);
-  size_t ncol = 0;
-
-  std::string column;
-  while (std::getline(ss, column, ','))
-  {
-    ++ncol;
-  }
-
-  return ncol;
-}
-
-bool readWaypoint(const char *filename, FileFormat format, std::vector&lt;WP&gt; *waypoints)
-{
-  std::ifstream ifs(filename);
-
-  if(!ifs)
-  {
-    return false;
-  }
-
-  std::string line;
-  std::getline(ifs, line); // Remove first line
-
-  if(format == FileFormat::ver3)
-  {
-    std::getline(ifs, line);  //remove second line
-  }
-
-  while (std::getline(ifs, line))
-  {
-    WP wp;
-    parseWaypoint(line, format, &amp;wp);
-    waypoints-&gt;push_back(wp);
-  }
-
-  if (format == FileFormat::ver1)
-  {
-    size_t last = waypoints-&gt;size() - 1;
-    for (size_t i = 0; i &lt; waypoints-&gt;size(); ++i)
-    {
-      if (i != last)
-      {
-        double yaw = atan2(waypoints-&gt;at(i+1).pose.position.y - waypoints-&gt;at(i).pose.position.y,
-                   waypoints-&gt;at(i+1).pose.position.x - waypoints-&gt;at(i).pose.position.x);
-        waypoints-&gt;at(i).pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
-      }
-      else
-      {
-        waypoints-&gt;at(i).pose.orientation = waypoints-&gt;at(i-1).pose.orientation;
-      }
-
-    }
-  }
-
-  return true;
-}
-
-double decelerate(tf::Vector3 v1, tf::Vector3 v2, double original_velocity_kmh)
-{
-
-  double distance = tf::tfDistance(v1, v2);
-  double vel = mps2kmph(sqrt(2 * g_decelerate * distance)); //km/h
-  if (vel &lt; 1.0)
-    vel = 0;
-  if (vel &gt; original_velocity_kmh)
-  {
-    vel = original_velocity_kmh;
-  }
-  return vel;
-}
-
-
-bool verifyFileConsistency(const char *filename, FileFormat format)
-{
-  ROS_INFO("verify...");
-  std::ifstream ifs(filename);
-
-  if (!ifs)
-  {
-    return false;
-  }
-
-  std::string line;
-  std::getline(ifs, line); //get first line
-  std::getline(ifs, line); //get second line
-
-  size_t ncol = countColumns(line);
-
-   while (std::getline(ifs, line))
-  {
-    if (countColumns(line) != ncol)
-      return false;
-  }
-  return true;
-}
-
-
-waypoint_follower::lane createLaneWaypoint(const std::vector&lt;WP&gt; &amp;waypoints)
-{
-  waypoint_follower::lane lane_waypoint;
-  lane_waypoint.header.frame_id = "/map";
-  lane_waypoint.header.stamp = ros::Time(0);
-
-  for (unsigned int i = 0; i &lt; waypoints.size(); i++)
-  {
-    waypoint_follower::waypoint wp;
-
-    wp.pose.header = lane_waypoint.header;
-    wp.pose.pose.position = waypoints[i].pose.position;
-    wp.pose.pose.orientation = waypoints[i].pose.orientation;
-
-    wp.twist.header = lane_waypoint.header;
-    double vel_kmh = decelerate(point2vector(waypoints[i].pose.position),
-        point2vector(waypoints[waypoints.size() -1 ].pose.position),
-        waypoints[i].velocity_kmh);
-    wp.twist.twist.linear.x = kmph2mps(vel_kmh);
-    wp.change_flag = waypoints[i].change_flag;
-
-    lane_waypoint.waypoints.push_back(wp);
-  }
-  return lane_waypoint;
-}
-
-FileFormat checkFileFormat(const char* filename)
-{
-
-  std::ifstream ifs(filename);
-
-  if (!ifs)
-  {
-    return FileFormat::unknown;
-  }
-
-  // get first line
-  std::string line;
-  std::getline(ifs, line);
-
-  //parse first line
-  std::vector&lt;std::string&gt; parsed_columns;
-  parseColumns(line, &amp;parsed_columns);
-
-  //check if first element in the first column does not include digit
-  if (!std::any_of(parsed_columns.at(0).cbegin(),parsed_columns.at(0).cend(),isdigit))
-  {
-    return FileFormat::ver3;
-  }
-
-  //if element consists only digit
-  int num_of_columns = countColumns(line);
-  ROS_INFO("columns size: %d",num_of_columns);
-
-  return (num_of_columns == 3 ? FileFormat::ver1  // if data consists "x y z (velocity)"
-         : num_of_columns == 4 ? FileFormat::ver2  // if data consists "x y z yaw (velocity)
-                               : FileFormat::unknown
-          );
-}
-
-} //namespace
-
-int main(int argc, char **argv)
-{
-  ros::init(argc, argv, "waypoint_loader");
-  ros::NodeHandle nh;
-  ros::NodeHandle private_nh("~");
-
-  std::string multi_lane_csv;
-
-  private_nh.getParam("decelerate", g_decelerate);
-  ROS_INFO_STREAM("decelerate :" &lt;&lt; g_decelerate);
-  private_nh.param&lt;std::string&gt;("multi_lane_csv", multi_lane_csv, MULTI_LANE_CSV);
-
-  ros::Publisher lane_pub = nh.advertise&lt;waypoint_follower::LaneArray&gt;("lane_waypoints_array", 10, true);
-  waypoint_follower::LaneArray lane_array;
-
-  std::vector&lt;std::string&gt; multi_file_path;
-  parseColumns(multi_lane_csv, &amp;multi_file_path);
-
-  for (auto el : multi_file_path)
-  {
-    FileFormat file_format = checkFileFormat(el.c_str());
-    ROS_INFO("Format: %d", file_format);
-
-    if (!verifyFileConsistency(el.c_str(),file_format))
-    {
-      ROS_ERROR("lane data is something wrong...");
-      exit(-1);
-    }
-
-    ROS_INFO("lane data is valid. publishing...");
-    std::vector&lt;WP&gt; wps;
-    readWaypoint(el.c_str(), file_format, &amp;wps);
-    lane_array.lanes.push_back(createLaneWaypoint(wps));
-  }
-
-  lane_pub.publish(lane_array);
-
-  ros::spin();
-
-}
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="16ff220a0492ffb39907c3f80dc2fb03896c9c9c" author="h_ohta">
		<msg>Rewrite lane_select node and add new function</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_node.cpp" added_lines="5" deleted_lines="28">
				<diff>@@ -26,41 +26,18 @@
  *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+*/
 
+// ROS Includes
 #include &lt;ros/ros.h&gt;
-#include &lt;iostream&gt;
 
-#include "waypoint_follower/LaneArray.h"
-#include "runtime_manager/ConfigLaneSelect.h"
-
-static ros::Publisher g_pub;
-static int g_lane_number = 0;
-static waypoint_follower::LaneArray g_lane_array;
-
-static void configCallback(const runtime_manager::ConfigLaneSelectConstPtr &amp;config)
-{
-  g_lane_number = config-&gt;number;
-  if ((int)g_lane_array.lanes.size() &gt; g_lane_number)
-    g_pub.publish(g_lane_array.lanes[g_lane_number]);
-}
-
-static void laneArrayCallback(const waypoint_follower::LaneArrayConstPtr &amp;msg)
-{
-  g_lane_array = *msg;
-  if ((int)g_lane_array.lanes.size() &gt; g_lane_number)
-    g_pub.publish(g_lane_array.lanes[g_lane_number]);
-}
+#include "lane_select_core.h"
 
 int main(int argc, char **argv)
 {
   ros::init(argc, argv, "lane_select");
-
-  ros::NodeHandle nh;
-  ros::Subscriber config_sub = nh.subscribe("/config/lane_select", 1, configCallback);
-  ros::Subscriber sub = nh.subscribe("traffic_waypoints_array", 1, laneArrayCallback);
-  g_pub = nh.advertise&lt;waypoint_follower::lane&gt;("base_waypoints", 10, true);
-
+  lane_planner::LaneSelectNode lsn;
   ros::spin();
+
   return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9a09f33d6d247f5d42f540e7affaddc6f741c8b5" author="h_ohta">
		<msg>Add enum class "ChangeFlag"</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" added_lines="15" deleted_lines="4">
				<diff>@@ -63,6 +63,17 @@ visualization_msgs::MarkerArray g_global_marker_array;
 visualization_msgs::MarkerArray g_local_waypoints_marker_array;
 bool g_config_manual_detection = true;
 
+enum class ChangeFlag : int32_t
+{
+  straight,
+  right,
+  left,
+
+  unknown = -1,
+};
+
+typedef std::underlying_type&lt;ChangeFlag&gt;::type ChangeFlagInteger;
+
 void publishLocalMarker()
 {
   visualization_msgs::MarkerArray marker_array;
@@ -158,19 +169,19 @@ void createGlobalLaneArrayChangeFlagMarker(const waypoint_follower::LaneArray &amp;l
 
       // double to string
       std::string str = "";
-      if(lane.waypoints[i].change_flag == 0)
+      if(lane.waypoints[i].change_flag == static_cast&lt;ChangeFlagInteger&gt;(ChangeFlag::straight))
       {
         str = "S";
       }
-      else if(lane.waypoints[i].change_flag == 1)
+      else if(lane.waypoints[i].change_flag == static_cast&lt;ChangeFlagInteger&gt;(ChangeFlag::right))
       {
         str = "R";
       }
-      else if(lane.waypoints[i].change_flag == 2)
+      else if(lane.waypoints[i].change_flag == static_cast&lt;ChangeFlagInteger&gt;(ChangeFlag::left))
       {
         str = "L";
       }
-      else if(lane.waypoints[i].change_flag == 3)
+      else if(lane.waypoints[i].change_flag == static_cast&lt;ChangeFlagInteger&gt;(ChangeFlag::unknown))
       {
         str = "U";
       }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="72465d1b374f4d2307d1e8df1873a4074fa14995" author="h_ohta">
		<msg>Adjust for new lane_select</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" added_lines="6" deleted_lines="4">
				<diff>@@ -132,7 +132,7 @@ void waypointCallback(const waypoint_follower::laneConstPtr &amp;msg)
   // _path_og.setPath(msg);
   _current_waypoints.setPath(*msg);
   _waypoint_set = true;
-  ROS_INFO_STREAM("waypoint subscribed");
+  //ROS_INFO_STREAM("waypoint subscribed");
 }
 
 void publishOdometry()
@@ -153,7 +153,7 @@ void publishOdometry()
     _pose_set = true;
   }
 
-  int closest_waypoint = getClosestWaypoint(_current_waypoints.getCurrentWaypoints(), pose);
+  /*int closest_waypoint = getClosestWaypoint(_current_waypoints.getCurrentWaypoints(), pose);
   if (closest_waypoint == -1)
   {
     ROS_INFO("cannot publish odometry because closest waypoint is -1.");
@@ -163,6 +163,8 @@ void publishOdometry()
   {
     pose.position.z = _current_waypoints.getWaypointPosition(closest_waypoint).z;
   }
+*/if(_waypoint_set)
+    pose.position.z = _current_waypoints.getWaypointPosition(1).z;
 
   double vx = _current_velocity.linear.x;
   double vth = _current_velocity.angular.z;
@@ -265,11 +267,11 @@ int main(int argc, char **argv)
   {
     ros::spinOnce();  // check subscribe topic
 
-    if (!_waypoint_set)
+    /*if (!_waypoint_set)
     {
       loop_rate.sleep();
       continue;
-    }
+    }*/
 
     if (!_initial_set)
     {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="88de5f83038bf97abebc3e58f2bd16ba1746c500" author="h_ohta">
		<msg>apply clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="7" deleted_lines="9">
				<diff>@@ -69,7 +69,7 @@ void LaneSelectNode::initPublisher()
 void LaneSelectNode::initParameter()
 {
   private_nh_.param&lt;int32_t&gt;("size_of_waypoints", size_of_waypoints_, int32_t(30));
-  private_nh_.param&lt;int32_t&gt;("lane_change_interval",lane_change_interval_,int32_t(2));
+  private_nh_.param&lt;int32_t&gt;("lane_change_interval", lane_change_interval_, int32_t(2));
 }
 
 void LaneSelectNode::publishLocalLane()
@@ -84,8 +84,8 @@ void LaneSelectNode::publishLocalLane()
     num_of_lane_++;
 
   ros::Time current_time = ros::Time::now();
-  double dt = (current_time -last_time_).toSec();
-  ROS_INFO("dt: %lf",dt);
+  double dt = (current_time - last_time_).toSec();
+  ROS_INFO("dt: %lf", dt);
   if (dt &gt; 1.0 &amp;&amp; (change_flag_ == ChangeFlag::right &amp;&amp; num_of_lane_ &lt; static_cast&lt;int32_t&gt;(lane_array_.lanes.size())))
   {
     num_of_lane_++;
@@ -102,8 +102,8 @@ void LaneSelectNode::publishLocalLane()
   createLocalLane(&amp;local_lane);
   pub_.publish(local_lane);
 
-  //if (current_lane.waypoints.at(num_of_closest_).change_flag == static_cast&lt;ChangeFlagInteger&gt;(ChangeFlag::right) &amp;&amp;
-   //   num_of_lane_ != lane_array_.size() - 1)
+  // if (current_lane.waypoints.at(num_of_closest_).change_flag == static_cast&lt;ChangeFlagInteger&gt;(ChangeFlag::right) &amp;&amp;
+  //   num_of_lane_ != lane_array_.size() - 1)
   //{
   //  num_of_lane_++;
   //}
@@ -128,11 +128,10 @@ void LaneSelectNode::createLocalLane(waypoint_follower::lane *lane)
   // push some waypoints
   for (auto i = 0; i &lt; size_of_waypoints_; i++)
   {
-    if(num_of_closest_ + i &gt; static_cast&lt;int32_t&gt;(lane_array_.lanes.at(num_of_lane_).waypoints.size() -1) )
+    if (num_of_closest_ + i &gt; static_cast&lt;int32_t&gt;(lane_array_.lanes.at(num_of_lane_).waypoints.size() - 1))
       break;
 
     lane-&gt;waypoints.push_back(lane_array_.lanes.at(num_of_lane_).waypoints.at(num_of_closest_ + i));
-
   }
 
   // push current_pose as first waypoint
@@ -141,10 +140,9 @@ void LaneSelectNode::createLocalLane(waypoint_follower::lane *lane)
   first_waypoint.pose.pose.position.x = current_pose_.pose.position.x;
   first_waypoint.pose.pose.position.y = current_pose_.pose.position.y;
   auto it = lane-&gt;waypoints.begin();
-  lane-&gt;waypoints.insert(it,first_waypoint);
+  lane-&gt;waypoints.insert(it, first_waypoint);
   change_flag_ = static_cast&lt;ChangeFlag&gt;(lane_array_.lanes.at(num_of_lane_).waypoints.at(num_of_closest_).change_flag);
   ROS_INFO("change_flag: %d", static_cast&lt;ChangeFlagInteger&gt;(change_flag_));
-
 }
 
 void LaneSelectNode::callbackFromLaneArray(const waypoint_follower::LaneArrayConstPtr &amp;msg)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="db661c48e06d13642bfba0d435c6bf41594349c8" author="h_ohta">
		<msg>Add launch file for lane_select, fix to use ros parameter</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -86,13 +86,13 @@ void LaneSelectNode::publishLocalLane()
   ros::Time current_time = ros::Time::now();
   double dt = (current_time - last_time_).toSec();
   ROS_INFO("dt: %lf", dt);
-  if (dt &gt; 1.0 &amp;&amp; (change_flag_ == ChangeFlag::right &amp;&amp; num_of_lane_ &lt; static_cast&lt;int32_t&gt;(lane_array_.lanes.size())))
+  if (dt &gt; lane_change_interval_ &amp;&amp; (change_flag_ == ChangeFlag::right &amp;&amp; num_of_lane_ &lt; static_cast&lt;int32_t&gt;(lane_array_.lanes.size())))
   {
     num_of_lane_++;
     last_time_ = current_time;
   }
 
-  if (dt &gt; 1.0 &amp;&amp; (change_flag_ == ChangeFlag::left &amp;&amp; num_of_lane_ &gt; 0))
+  if (dt &gt; lane_change_interval_ &amp;&amp; (change_flag_ == ChangeFlag::left &amp;&amp; num_of_lane_ &gt; 0))
   {
     num_of_lane_--;
     last_time_ = current_time;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d1f0a582093db343646328babfc84156d6fe7437" author="h_ohta">
		<msg>Delete comment out</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="0" deleted_lines="6">
				<diff>@@ -102,12 +102,6 @@ void LaneSelectNode::publishLocalLane()
   createLocalLane(&amp;local_lane);
   pub_.publish(local_lane);
 
-  // if (current_lane.waypoints.at(num_of_closest_).change_flag == static_cast&lt;ChangeFlagInteger&gt;(ChangeFlag::right) &amp;&amp;
-  //   num_of_lane_ != lane_array_.size() - 1)
-  //{
-  //  num_of_lane_++;
-  //}
-
   is_current_pose_subscribed_ = false;
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a792de019090886ca1500b0df969a15dd709977d" author="h_ohta">
		<msg>Rename function</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -61,7 +61,7 @@ void WaypointLoaderNode::initParameter()
   private_nh_.param&lt;std::string&gt;("multi_lane_csv", multi_lane_csv_, MULTI_LANE_CSV);
 }
 
-void WaypointLoaderNode::publishWaypointsArray()
+void WaypointLoaderNode::publishLaneArray()
 {
   // extract file paths
   std::vector&lt;std::string&gt; multi_file_path;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="3" deleted_lines="2">
				<diff>@@ -75,7 +75,7 @@ public:
   WaypointLoaderNode();
   ~WaypointLoaderNode();
 
-  void publishWaypointsArray();
+  void publishLaneArray();
 
 private:
 
@@ -97,6 +97,8 @@ private:
   // functions
 
   void createLaneWaypoint(const std::string &amp;file_path, waypoint_follower::lane *lane);
+  void createLaneArray(const std::vector&lt;std::string&gt; &amp;paths, waypoint_follower::LaneArray *lane_array);
+
   FileFormat checkFileFormat(const char *filename);
   bool verifyFileConsistency(const char *filename);
   void loadWaypointsForVer1(const char *filename, std::vector&lt;waypoint_follower::waypoint&gt; *wps);
@@ -113,6 +115,5 @@ private:
 void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns);
 size_t countColumns(const std::string&amp; line);
 
-
 }
 #endif  // _WAYPOINT_LOADER_CORE_H_
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_node.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -37,7 +37,7 @@ int main(int argc, char **argv)
 {
   ros::init(argc, argv, "waypoint_loader");
   waypoint_maker::WaypointLoaderNode wln;
-  wln.publishWaypointsArray();
+  wln.publishLaneArray();
   ros::spin();
 
   return 0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="46713828b7257596edcdf797b97335d816a8ce52" author="h_ohta">
		<msg>extract processing as function</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="8" deleted_lines="4">
				<diff>@@ -67,15 +67,19 @@ void WaypointLoaderNode::publishLaneArray()
   std::vector&lt;std::string&gt; multi_file_path;
   parseColumns(multi_lane_csv_, &amp;multi_file_path);
   waypoint_follower::LaneArray lane_array;
+  createLaneArray(multi_file_path, &amp;lane_array);
+  lane_pub_.publish(lane_array);
+}
 
-  for (auto el : multi_file_path)
+void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt; &amp;paths,
+                                         waypoint_follower::LaneArray *lane_array)
+{
+  for (auto el : paths)
   {
     waypoint_follower::lane lane;
     createLaneWaypoint(el, &amp;lane);
-    lane_array.lanes.push_back(lane);
+    lane_array-&gt;lanes.push_back(lane);
   }
-
-  lane_pub_.publish(lane_array);
 }
 
 void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, waypoint_follower::lane *lane)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="65cb99f0a3c22ee9d2b117373c437c7aa3b26190" author="h_ohta">
		<msg>Apply clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="22" deleted_lines="31">
				<diff>@@ -38,7 +38,6 @@ WaypointLoaderNode::WaypointLoaderNode() : private_nh_("~")
 {
   initParameter();
   initPublisher();
-
 }
 
 // Destructor
@@ -50,7 +49,6 @@ void WaypointLoaderNode::initPublisher()
 {
   // setup publisher
   lane_pub_ = nh_.advertise&lt;waypoint_follower::LaneArray&gt;("lane_waypoints_array", 10, true);
-
 }
 
 void WaypointLoaderNode::initParameter()
@@ -95,7 +93,7 @@ void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, waypoi
   std::vector&lt;waypoint_follower::waypoint&gt; wps;
   if (format == FileFormat::ver1)
     loadWaypointsForVer1(file_path.c_str(), &amp;wps);
-  else if(format == FileFormat::ver2)
+  else if (format == FileFormat::ver2)
     loadWaypointsForVer2(file_path.c_str(), &amp;wps);
   else
     loadWaypoints(file_path.c_str(), &amp;wps);
@@ -103,8 +101,6 @@ void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, waypoi
   lane-&gt;header.frame_id = "/map";
   lane-&gt;header.stamp = ros::Time(0);
   lane-&gt;waypoints = wps;
-
-
 }
 
 void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;waypoint_follower::waypoint&gt; *wps)
@@ -141,11 +137,9 @@ void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;
     wps-&gt;at(i).twist.twist.linear.x = decelerate(
         wps-&gt;at(i).pose.pose.position, wps-&gt;at(wps-&gt;size() - 1).pose.pose.position, wps-&gt;at(i).twist.twist.linear.x);
   }
-
-
 }
 
-void WaypointLoaderNode::parseWaypointForVer1(const std::string&amp; line, waypoint_follower::waypoint *wp)
+void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line, waypoint_follower::waypoint *wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
@@ -174,7 +168,7 @@ void WaypointLoaderNode::loadWaypointsForVer2(const char *filename, std::vector&lt;
   }
 }
 
-void WaypointLoaderNode::parseWaypointForVer2(const std::string&amp; line, waypoint_follower::waypoint *wp)
+void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line, waypoint_follower::waypoint *wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
@@ -196,9 +190,9 @@ void WaypointLoaderNode::loadWaypoints(const char *filename, std::vector&lt;waypoin
   std::string line;
   std::getline(ifs, line);  // get first line
   std::vector&lt;std::string&gt; contents;
-  parseColumns(line,&amp;contents);
+  parseColumns(line, &amp;contents);
 
-  std::getline(ifs,line);  // remove second line
+  std::getline(ifs, line);  // remove second line
   while (std::getline(ifs, line))
   {
     waypoint_follower::waypoint wp;
@@ -208,11 +202,11 @@ void WaypointLoaderNode::loadWaypoints(const char *filename, std::vector&lt;waypoin
 }
 
 void WaypointLoaderNode::parseWaypoint(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
-                          waypoint_follower::waypoint *wp)
+                                       waypoint_follower::waypoint *wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
-  std::unordered_map&lt;std::string,std::string&gt; map;
+  std::unordered_map&lt;std::string, std::string&gt; map;
   for (size_t i = 0; i &lt; contents.size(); i++)
   {
     map[contents.at(i)] = columns.at(i);
@@ -224,12 +218,10 @@ void WaypointLoaderNode::parseWaypoint(const std::string &amp;line, const std::vecto
   wp-&gt;pose.pose.orientation = tf::createQuaternionMsgFromYaw(std::stod(map["yaw"]));
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(map["velocity"]));
   wp-&gt;change_flag = std::stoi(map["change_flag"]);
-
 }
 
-FileFormat WaypointLoaderNode::checkFileFormat(const char* filename)
+FileFormat WaypointLoaderNode::checkFileFormat(const char *filename)
 {
-
   std::ifstream ifs(filename);
 
   if (!ifs)
@@ -241,21 +233,21 @@ FileFormat WaypointLoaderNode::checkFileFormat(const char* filename)
   std::string line;
   std::getline(ifs, line);
 
-  //parse first line
+  // parse first line
   std::vector&lt;std::string&gt; parsed_columns;
   parseColumns(line, &amp;parsed_columns);
 
-  //check if first element in the first column does not include digit
-  if (!std::any_of(parsed_columns.at(0).cbegin(),parsed_columns.at(0).cend(),isdigit))
+  // check if first element in the first column does not include digit
+  if (!std::any_of(parsed_columns.at(0).cbegin(), parsed_columns.at(0).cend(), isdigit))
   {
     return FileFormat::ver3;
   }
 
-  //if element consists only digit
+  // if element consists only digit
   int num_of_columns = countColumns(line);
-  ROS_INFO("columns size: %d",num_of_columns);
+  ROS_INFO("columns size: %d", num_of_columns);
 
-  return (num_of_columns == 3 ? FileFormat::ver1  // if data consists "x y z (velocity)"
+  return ( num_of_columns == 3 ? FileFormat::ver1  // if data consists "x y z (velocity)"
          : num_of_columns == 4 ? FileFormat::ver2  // if data consists "x y z yaw (velocity)
                                : FileFormat::unknown
           );
@@ -263,9 +255,8 @@ FileFormat WaypointLoaderNode::checkFileFormat(const char* filename)
 
 double WaypointLoaderNode::decelerate(geometry_msgs::Point p1, geometry_msgs::Point p2, double original_velocity_mps)
 {
-
-  double distance = sqrt(pow(p2.x - p1.x,2) + pow(p2.y - p1.y,2) + pow(p2.z - p1.z,2));
-  double vel = sqrt(2 * decelerate_ * distance); //km/h
+  double distance = sqrt(pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2) + pow(p2.z - p1.z, 2));
+  double vel = sqrt(2 * decelerate_ * distance);  // km/h
 
   if (mps2kmph(vel) &lt; 1.0)
     vel = 0;
@@ -293,13 +284,13 @@ bool WaypointLoaderNode::verifyFileConsistency(const char *filename)
   }
 
   std::string line;
-  std::getline(ifs, line); //remove first line
+  std::getline(ifs, line);  // remove first line
 
   size_t ncol = format == FileFormat::ver1 ? 4 //x,y,z,velocity
-               : format == FileFormat::ver2 ? 5 //x,y,z,yaw,velocity
-               : countColumns(line);
+              : format == FileFormat::ver2 ? 5 //x,y,z,yaw,velocity
+              : countColumns(line);
 
-   while (std::getline(ifs, line)) //search from second line
+  while (std::getline(ifs, line))  // search from second line
   {
     if (countColumns(line) != ncol)
       return false;
@@ -317,7 +308,7 @@ void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns)
   }
 }
 
-size_t countColumns(const std::string&amp; line)
+size_t countColumns(const std::string &amp;line)
 {
   std::istringstream ss(line);
   size_t ncol = 0;
@@ -331,4 +322,4 @@ size_t countColumns(const std::string&amp; line)
   return ncol;
 }
 
-} // waypoint_maker
+}  // waypoint_maker
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f3c3cfcf00fcf58246498b268ac5751846c8a58f" author="h_ohta">
		<msg>Fix include guard</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="3" deleted_lines="3">
				<diff>@@ -29,8 +29,8 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#ifndef _LANE_SELECT_CORE_H_
-#define _LANE_SELECT_CORE_H_
+#ifndef LANE_SELECT_CORE_H
+#define LANE_SELECT_CORE_H
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
@@ -98,4 +98,4 @@ private:
 
 int32_t getNumOfClosest(const waypoint_follower::lane &amp;current_path, const geometry_msgs::Pose &amp;current_pose);
 }
-#endif  // _LANE_SELECT_CORE_H_
+#endif  // LANE_SELECT_CORE_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d65a45aa59e4bb3be1e2217f1ca561a3625ff1f0" author="h_ohta">
		<msg>bring together initializer for ROS</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="3" deleted_lines="10">
				<diff>@@ -43,9 +43,7 @@ LaneSelectNode::LaneSelectNode()
   , is_current_pose_subscribed_(false)
   , last_time_(ros::Time::now())
 {
-  initParameter();
-  initSubscriber();
-  initPublisher();
+  initForROS();
 }
 
 // Destructor
@@ -53,21 +51,16 @@ LaneSelectNode::~LaneSelectNode()
 {
 }
 
-void LaneSelectNode::initSubscriber()
+void LaneSelectNode::initForROS()
 {
   // setup subscriber
   sub1_ = nh_.subscribe("traffic_waypoints_array", 100, &amp;LaneSelectNode::callbackFromLaneArray, this);
   sub2_ = nh_.subscribe("current_pose", 100, &amp;LaneSelectNode::callbackFromCurrentPose, this);
-}
 
-void LaneSelectNode::initPublisher()
-{
   // setup publisher
   pub_ = nh_.advertise&lt;waypoint_follower::lane&gt;("base_waypoints", 10, true);
-}
 
-void LaneSelectNode::initParameter()
-{
+  // get from rosparam
   private_nh_.param&lt;int32_t&gt;("size_of_waypoints", size_of_waypoints_, int32_t(30));
   private_nh_.param&lt;int32_t&gt;("lane_change_interval", lane_change_interval_, int32_t(2));
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="1" deleted_lines="3">
				<diff>@@ -87,9 +87,7 @@ private:
   void callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg);
 
   // initializer
-  void initSubscriber();
-  void initPublisher();
-  void initParameter();
+  void initForROS();
 
   // functions
   void publishLocalLane();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e3aeb7fd8837ff0353fe9f7d3fb812d24d711cbc" author="h_ohta">
		<msg>Create run function</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="5" deleted_lines="0">
				<diff>@@ -145,6 +145,11 @@ void LaneSelectNode::callbackFromCurrentPose(const geometry_msgs::PoseStampedCon
   publishLocalLane();
 }
 
+void LaneSelectNode::run()
+{
+  ros::spin();
+}
+
 // get closest waypoint from current pose
 /*int32_t getClosestWaypoint(const waypoint_follower::lane &amp;current_path, const geometry_msgs::Pose &amp;current_pose)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="2" deleted_lines="0">
				<diff>@@ -60,6 +60,8 @@ public:
   LaneSelectNode();
   ~LaneSelectNode();
 
+  void run();
+
 private:
   // handle
   ros::NodeHandle nh_;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_node.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -37,7 +37,7 @@ int main(int argc, char **argv)
 {
   ros::init(argc, argv, "lane_select");
   lane_planner::LaneSelectNode lsn;
-  ros::spin();
+  lsn.run();
 
   return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f565f04fb6d0f1d3cfec80a87dab9a206ac08ad8" author="h_ohta">
		<msg>Rewrite to change local planning to global planning</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="410" deleted_lines="96">
				<diff>@@ -36,14 +36,16 @@ namespace lane_planner
 // Constructor
 LaneSelectNode::LaneSelectNode()
   : private_nh_("~")
-  , num_of_lane_(-1)
-  , num_of_closest_(-1)
-  , change_flag_(ChangeFlag::unknown)
+  , current_lane_idx_(-1)
+  , right_lane_idx_(-1)
+  , left_lane_idx_(-1)
   , is_lane_array_subscribed_(false)
   , is_current_pose_subscribed_(false)
-  , last_time_(ros::Time::now())
+  , is_current_velocity_subscribed_(false)
+  , last_change_time_(ros::Time::now())
 {
   initForROS();
+  initForViz();
 }
 
 // Destructor
@@ -55,94 +57,372 @@ void LaneSelectNode::initForROS()
 {
   // setup subscriber
   sub1_ = nh_.subscribe("traffic_waypoints_array", 100, &amp;LaneSelectNode::callbackFromLaneArray, this);
-  sub2_ = nh_.subscribe("current_pose", 100, &amp;LaneSelectNode::callbackFromCurrentPose, this);
+  sub2_ = nh_.subscribe("current_pose", 100, &amp;LaneSelectNode::callbackFromPoseStamped, this);
+  sub3_ = nh_.subscribe("current_velocity", 100, &amp;LaneSelectNode::callbackFromTwistStamped, this);
 
   // setup publisher
-  pub_ = nh_.advertise&lt;waypoint_follower::lane&gt;("base_waypoints", 10, true);
+  pub1_ = nh_.advertise&lt;waypoint_follower::lane&gt;("base_waypoints", 10);
+  pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 10);
+  vis_pub1_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("lane_select_marker", 10);
 
   // get from rosparam
-  private_nh_.param&lt;int32_t&gt;("size_of_waypoints", size_of_waypoints_, int32_t(30));
   private_nh_.param&lt;int32_t&gt;("lane_change_interval", lane_change_interval_, int32_t(2));
+  private_nh_.param&lt;double&gt;("distance_threshold", distance_threshold_, double(3.0));
 }
 
-void LaneSelectNode::publishLocalLane()
+void LaneSelectNode::initCommonParamForLaneMarker(visualization_msgs::Marker *marker)
 {
-  if (!is_current_pose_subscribed_ || !is_lane_array_subscribed_)
+  marker-&gt;header.frame_id = "map";
+  marker-&gt;header.stamp = ros::Time();
+  marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
+  marker-&gt;action = visualization_msgs::Marker::ADD;
+  marker-&gt;scale.x = 1.0;
+}
+
+void LaneSelectNode::initForViz()
+{
+  std_msgs::ColorRGBA color_current;
+  color_current.b = 1.0;
+  color_current.g = 0.7;
+  color_current.a = 0.2;
+
+  std_msgs::ColorRGBA color_neighbor;
+  color_neighbor.r = 0.5;
+  color_neighbor.b = 0.5;
+  color_neighbor.g = 0.5;
+  color_neighbor.a = 0.2;
+
+  std_msgs::ColorRGBA color_closest_wp;
+  color_closest_wp.r = 1.0;
+  color_closest_wp.b = 1.0;
+  color_closest_wp.g = 1.0;
+  color_closest_wp.a = 1.0;
+
+  // current_lane_marker_
+  initCommonParamForLaneMarker(&amp;current_lane_marker_);
+  current_lane_marker_.ns = "current_lane_marker";
+  current_lane_marker_.color = color_current;
+
+  // left_lane_marker_
+  initCommonParamForLaneMarker(&amp;left_lane_marker_);
+  left_lane_marker_.ns = "left_lane_marker";
+  left_lane_marker_.color = color_neighbor;
+
+  // right_lane_marker_
+  initCommonParamForLaneMarker(&amp;right_lane_marker_);
+  right_lane_marker_.ns = "right_lane_marker";
+  right_lane_marker_.color = color_neighbor;
+
+  // closest_waypoints_marker_
+  closest_waypoints_marker_.header.frame_id = "map";
+  closest_waypoints_marker_.header.stamp = ros::Time();
+  closest_waypoints_marker_.ns = "closest_waypoints_marker";
+  closest_waypoints_marker_.type = visualization_msgs::Marker::POINTS;
+  closest_waypoints_marker_.action = visualization_msgs::Marker::ADD;
+  closest_waypoints_marker_.scale.x = 0.5;
+  closest_waypoints_marker_.color = color_closest_wp;
+}
+
+void LaneSelectNode::processing()
+{
+  if (!is_current_pose_subscribed_ || !is_lane_array_subscribed_ || !is_current_velocity_subscribed_)
   {
     ROS_ERROR("Necessary topics are not subscribed yet.");
     return;
   }
 
-  if (num_of_lane_ == -1)
-    num_of_lane_++;
+  // search closest waypoint number for each lanes
+  if (!getClosestWaypointNumberForEachLanes())
+  {
+    current_lane_idx_ = -1;
+    right_lane_idx_ = -1;
+    left_lane_idx_ = -1;
+    return;
+  }
+
+  // if current_lane_idx_ = -1, find the lane index which has the most closest waypoint
+  if (current_lane_idx_ == -1)
+  {
+    findCurrentLane();
+    findNeighborLanes();
+    publish();
+    return;
+  }
+
+  // if closest waypoint on current lane is not -1,
+  if (std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))) != -1)
+  {
+    const int32_t &amp;change_flag =
+        std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))
+            .waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))))
+            .change_flag;
+
+    // if change flag of current_lane is left or right, lane change
+    if (change_flag == enumToInteger(ChangeFlag::right) || change_flag == enumToInteger(ChangeFlag::left))
+      changeLane(change_flag);
+  }
+
+  publish();
+  return;
+}
 
+void LaneSelectNode::changeLane(const int32_t &amp;change_flag)
+{
   ros::Time current_time = ros::Time::now();
-  double dt = (current_time - last_time_).toSec();
-  ROS_INFO("dt: %lf", dt);
-  if (dt &gt; lane_change_interval_ &amp;&amp; (change_flag_ == ChangeFlag::right &amp;&amp; num_of_lane_ &lt; static_cast&lt;int32_t&gt;(lane_array_.lanes.size())))
+  double dt = (current_time - last_change_time_).toSec();
+  if (dt &lt; lane_change_interval_)
+    return;
+
+  if (change_flag == enumToInteger(ChangeFlag::right) &amp;&amp; right_lane_idx_ != -1)
+    current_lane_idx_ = right_lane_idx_;
+  else if (change_flag == enumToInteger(ChangeFlag::left) &amp;&amp; left_lane_idx_ != -1)
+    current_lane_idx_ = left_lane_idx_;
+
+  findNeighborLanes();
+
+  // for visualize
+  createCurrentLaneMarker();
+
+  last_change_time_ = ros::Time::now();
+}
+
+bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
+{
+  for (auto &amp;el : tuple_vec_)
   {
-    num_of_lane_++;
-    last_time_ = current_time;
+    int32_t number =
+        getClosestWaypointNumber(std::get&lt;0&gt;(el), current_pose_.pose, current_velocity_.twist, std::get&lt;1&gt;(el));
+    std::get&lt;1&gt;(el) = number;
+    ROS_INFO("closest: %d", std::get&lt;1&gt;(el));
   }
 
-  if (dt &gt; lane_change_interval_ &amp;&amp; (change_flag_ == ChangeFlag::left &amp;&amp; num_of_lane_ &gt; 0))
+  // confirm if all closest waypoint numbers are -1. If so, output error
+  int32_t accum = 0;
+  for (const auto &amp;el : tuple_vec_)
+  {
+    accum += std::get&lt;1&gt;(el);
+  }
+  if (accum == (-1) * static_cast&lt;int32_t&gt;(tuple_vec_.size()))
   {
-    num_of_lane_--;
-    last_time_ = current_time;
+    ROS_ERROR("cannot get closest waypoints");
+    return false;
   }
 
-  waypoint_follower::lane local_lane;
-  createLocalLane(&amp;local_lane);
-  pub_.publish(local_lane);
+  // for visualize
+  createClosestWaypointsMarker();
+  return true;
+}
 
-  is_current_pose_subscribed_ = false;
+void LaneSelectNode::findCurrentLane()
+{
+  std::vector&lt;uint32_t&gt; idx_vec;
+  idx_vec.reserve(tuple_vec_.size());
+  for (uint32_t i = 0; i &lt; tuple_vec_.size(); i++)
+  {
+    if (std::get&lt;1&gt;(tuple_vec_.at(i)) == -1)
+      continue;
+    idx_vec.push_back(i);
+  }
+  current_lane_idx_ = findMostClosestLane(idx_vec, current_pose_.pose.position);
+
+  // for visualize
+  createCurrentLaneMarker();
 }
 
-void LaneSelectNode::createLocalLane(waypoint_follower::lane *lane)
+int32_t LaneSelectNode::findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec, const geometry_msgs::Point p)
 {
-  num_of_closest_ = getClosestWaypoint(lane_array_.lanes.at(num_of_lane_), current_pose_.pose);
+  std::vector&lt;double&gt; dist_vec;
+  dist_vec.reserve(idx_vec.size());
+  for (const auto &amp;el : idx_vec)
+  {
+    uint32_t closest_number = static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(el)));
+    dist_vec.push_back(
+        getTwoDimensionalDistance(p, std::get&lt;0&gt;(tuple_vec_.at(el)).waypoints.at(closest_number).pose.pose.position));
+  }
+  std::vector&lt;double&gt;::iterator itr = std::min_element(dist_vec.begin(), dist_vec.end());
+  return idx_vec.at(static_cast&lt;uint32_t&gt;(std::distance(dist_vec.begin(), itr)));
+}
 
-  if (num_of_closest_ == -1)
+void LaneSelectNode::findNeighborLanes()
+{
+  uint32_t current_closest_num =
+      static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))));
+  const geometry_msgs::Pose &amp;current_closest_pose =
+      std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))).waypoints.at(current_closest_num).pose.pose;
+
+  std::vector&lt;uint32_t&gt; left_lane_idx_vec;
+  left_lane_idx_vec.reserve(tuple_vec_.size());
+  std::vector&lt;uint32_t&gt; right_lane_idx_vec;
+  right_lane_idx_vec.reserve(tuple_vec_.size());
+  for (uint32_t i = 0; i &lt; tuple_vec_.size(); i++)
   {
-    ROS_ERROR("cannot get closest waypoint");
-    return;
+    if (i == static_cast&lt;uint32_t&gt;(current_lane_idx_) || std::get&lt;1&gt;(tuple_vec_.at(i)) == -1)
+      continue;
+
+    uint32_t target_num = static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(i)));
+    const geometry_msgs::Point &amp;target_p = std::get&lt;0&gt;(tuple_vec_.at(i)).waypoints.at(target_num).pose.pose.position;
+
+    geometry_msgs::Point converted_p;
+    convertPointIntoRelativeCoordinate(target_p, current_closest_pose, &amp;converted_p);
+
+    ROS_INFO("distance: %lf", converted_p.y);
+    if (fabs(converted_p.y) &gt; distance_threshold_)
+    {
+      ROS_INFO("%d lane is far from current lane...", i);
+      continue;
+    }
+
+    if (converted_p.y &gt; 0)
+      left_lane_idx_vec.push_back(i);
+    else
+      right_lane_idx_vec.push_back(i);
   }
 
-  // setup
-  lane-&gt;header.stamp = ros::Time::now();
-  lane-&gt;header.frame_id = "map";
+  if (!left_lane_idx_vec.empty())
+  {
+    left_lane_idx_ = findMostClosestLane(left_lane_idx_vec, current_closest_pose.position);
 
-  // push some waypoints
-  for (auto i = 0; i &lt; size_of_waypoints_; i++)
+    // for visualize
+    createLeftLaneMarker();
+  }
+  else
   {
-    if (num_of_closest_ + i &gt; static_cast&lt;int32_t&gt;(lane_array_.lanes.at(num_of_lane_).waypoints.size() - 1))
-      break;
+    left_lane_idx_ = -1;
+  }
+  if (!right_lane_idx_vec.empty())
+  {
+    right_lane_idx_ = findMostClosestLane(right_lane_idx_vec, current_closest_pose.position);
 
-    lane-&gt;waypoints.push_back(lane_array_.lanes.at(num_of_lane_).waypoints.at(num_of_closest_ + i));
+    // for visualize
+    createRightLaneMarker();
   }
+  else
+  {
+    right_lane_idx_ = -1;
+  }
+}
 
-  // push current_pose as first waypoint
-  waypoint_follower::waypoint first_waypoint;
-  first_waypoint = lane-&gt;waypoints.at(0);
-  first_waypoint.pose.pose.position.x = current_pose_.pose.position.x;
-  first_waypoint.pose.pose.position.y = current_pose_.pose.position.y;
-  auto it = lane-&gt;waypoints.begin();
-  lane-&gt;waypoints.insert(it, first_waypoint);
-  change_flag_ = static_cast&lt;ChangeFlag&gt;(lane_array_.lanes.at(num_of_lane_).waypoints.at(num_of_closest_).change_flag);
-  ROS_INFO("change_flag: %d", static_cast&lt;ChangeFlagInteger&gt;(change_flag_));
+void LaneSelectNode::createCurrentLaneMarker()
+{
+  const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps =
+      std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))).waypoints;
+  current_lane_marker_.points.clear();
+  current_lane_marker_.points.shrink_to_fit();
+  current_lane_marker_.points.reserve(wps.size());
+  for (const auto &amp;el : wps)
+  {
+    current_lane_marker_.points.push_back(el.pose.pose.position);
+  }
+  publishForVisualize();
+}
+
+void LaneSelectNode::createRightLaneMarker()
+{
+  const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps =
+      std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(right_lane_idx_))).waypoints;
+
+  right_lane_marker_.points.clear();
+  right_lane_marker_.points.shrink_to_fit();
+  right_lane_marker_.points.reserve(wps.size());
+  for (const auto &amp;el : wps)
+  {
+    right_lane_marker_.points.push_back(el.pose.pose.position);
+  }
+  publishForVisualize();
+}
+
+void LaneSelectNode::createLeftLaneMarker()
+{
+  const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps =
+      std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(left_lane_idx_))).waypoints;
+
+  left_lane_marker_.points.clear();
+  left_lane_marker_.points.shrink_to_fit();
+  left_lane_marker_.points.reserve(wps.size());
+  for (const auto &amp;el : wps)
+  {
+    left_lane_marker_.points.push_back(el.pose.pose.position);
+  }
+  publishForVisualize();
+}
+
+void LaneSelectNode::createClosestWaypointsMarker()
+{
+  closest_waypoints_marker_.points.clear();
+  closest_waypoints_marker_.points.shrink_to_fit();
+  closest_waypoints_marker_.points.reserve(tuple_vec_.size());
+  for (uint32_t i = 0; i &lt; tuple_vec_.size(); i++)
+  {
+    if (std::get&lt;1&gt;(tuple_vec_.at(i)) == -1)
+      continue;
+
+    closest_waypoints_marker_.points.push_back(std::get&lt;0&gt;(tuple_vec_.at(i))
+                                                   .waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(i))))
+                                                   .pose.pose.position);
+  }
+  publishForVisualize();
+}
+
+void LaneSelectNode::publishForVisualize()
+{
+  visualization_msgs::MarkerArray marker_array;
+  marker_array.markers.push_back(closest_waypoints_marker_);
+  marker_array.markers.push_back(current_lane_marker_);
+  marker_array.markers.push_back(left_lane_marker_);
+  marker_array.markers.push_back(right_lane_marker_);
+
+  vis_pub1_.publish(marker_array);
+}
+
+void LaneSelectNode::publish()
+{
+  ROS_INFO("current_lane_idx: %d", current_lane_idx_);
+  ROS_INFO("right_lane_idx: %d", right_lane_idx_);
+  ROS_INFO("left_lane_idx: %d", left_lane_idx_);
+
+  // publish current global lane
+  waypoint_follower::lane global_lane;
+  global_lane = std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
+  pub1_.publish(global_lane);
+
+  // publish closest waypoint
+  std_msgs::Int32 closest_waypoint;
+  closest_waypoint.data = std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
+  pub2_.publish(closest_waypoint);
+
+  is_current_pose_subscribed_ = false;
+  is_current_velocity_subscribed_ = false;
 }
 
 void LaneSelectNode::callbackFromLaneArray(const waypoint_follower::LaneArrayConstPtr &amp;msg)
 {
-  lane_array_ = *msg;
+  tuple_vec_.reserve(msg-&gt;lanes.size());
+  for (const auto &amp;el : msg-&gt;lanes)
+  {
+    auto t = std::make_tuple(el, -1);
+    tuple_vec_.push_back(t);
+  }
+
+  // lane_array_ = *msg;
   is_lane_array_subscribed_ = true;
+
+  processing();
 }
 
-void LaneSelectNode::callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg)
+void LaneSelectNode::callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 {
   current_pose_ = *msg;
   is_current_pose_subscribed_ = true;
-  publishLocalLane();
+
+  processing();
+}
+
+void LaneSelectNode::callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr &amp;msg)
+{
+  current_velocity_ = *msg;
+  is_current_velocity_subscribed_ = true;
+
+  processing();
 }
 
 void LaneSelectNode::run()
@@ -150,73 +430,107 @@ void LaneSelectNode::run()
   ros::spin();
 }
 
-// get closest waypoint from current pose
-/*int32_t getClosestWaypoint(const waypoint_follower::lane &amp;current_path, const geometry_msgs::Pose &amp;current_pose)
+// distance between target 1 and target2 in 2-D
+double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geometry_msgs::Point &amp;target2)
 {
-  WayPoints wp;
-  wp.setPath(current_path);
-
-  if (wp.isEmpty())
-    return -1;
-
-  // search closest candidate within a certain meter
-  double search_distance = 5.0;
-  std::vector&lt;int&gt; waypoint_candidates;
-  for (int i = 1; i &lt; wp.getSize(); i++)
-  {
-    if (getPlaneDistance(wp.getWaypointPosition(i), current_pose.position) &gt; search_distance)
-      continue;
+  double distance = sqrt(pow(target1.x - target2.x, 2) + pow(target1.y - target2.y, 2));
+  return distance;
+}
 
-    if (!wp.isFront(i, current_pose))
-      continue;
+void convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose,
+                                        geometry_msgs::Point *output_point)
+{
+  tf::Transform inverse;
+  tf::poseMsgToTF(pose, inverse);
+  tf::Transform transform = inverse.inverse();
+
+  tf::Point p;
+  pointMsgToTF(input_point, p);
+  tf::Point tf_p = transform * p;
+  pointTFToMsg(tf_p, *output_point);
+}
 
-    double angle_threshold = 90;
-    if (getRelativeAngle(wp.getWaypointPose(i), current_pose) &gt; angle_threshold)
-      continue;
+double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry_msgs::Pose &amp;current_pose)
+{
+  tf::Vector3 x_axis(1, 0, 0);
+  tf::Transform waypoint_tfpose;
+  tf::poseMsgToTF(waypoint_pose, waypoint_tfpose);
+  tf::Vector3 waypoint_v = waypoint_tfpose.getBasis() * x_axis;
+  tf::Transform current_tfpose;
+  tf::poseMsgToTF(current_pose, current_tfpose);
+  tf::Vector3 current_v = current_tfpose.getBasis() * x_axis;
+
+  return current_v.angle(waypoint_v) * 180 / M_PI;
+}
 
-    waypoint_candidates.push_back(i);
+// get closest waypoint from current pose
+int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
+                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number)
+{
+  if (current_lane.waypoints.empty())
+  {
+    return -1;
   }
 
-  // get closest waypoint from candidates
-  if (!waypoint_candidates.empty())
+  // ROS_INFO("number: %d",previous_number);
+  std::vector&lt;uint32_t&gt; idx_vec;
+  // if previous number is -1, search closest waypoint from waypoints in front of current pose
+  if (previous_number == -1)
   {
-    int waypoint_min = -1;
-    double distance_min = DBL_MAX;
-    for (auto el : waypoint_candidates)
+    idx_vec.reserve(current_lane.waypoints.size());
+    for (uint32_t i = 0; i &lt; current_lane.waypoints.size(); i++)
     {
-      // ROS_INFO("closest_candidates : %d",el);
-      double d = getPlaneDistance(wp.getWaypointPosition(el), current_pose.position);
-      if (d &lt; distance_min)
+      geometry_msgs::Point converted_p;
+      convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose, &amp;converted_p);
+      double angle = getRelativeAngle(current_lane.waypoints.at(i).pose.pose, current_pose);
+      // ROS_INFO("angle: %lf",angle);
+      if (converted_p.x &gt; 0 &amp;&amp; angle &lt; 90)
       {
-        waypoint_min = el;
-        distance_min = d;
+        idx_vec.push_back(i);
+        // ROS_INFO("input idx: %d",i);
       }
     }
-    return waypoint_min;
   }
   else
   {
-    ROS_INFO("no candidate. search closest waypoint from all waypoints...");
-    // if there is no candidate...
-    int waypoint_min = -1;
-    double distance_min = DBL_MAX;
-    for (int i = 1; i &lt; wp.getSize(); i++)
-    {
-      if (!wp.isFront(i, current_pose))
-        continue;
+    double ratio = 3;
+    double minimum_dt = 2.0;
+    double dt = current_velocity.linear.x * ratio &gt; minimum_dt ? current_velocity.linear.x * ratio : minimum_dt;
 
-      // if (!wp.isValid(i, current_pose))
-      //  continue;
+    idx_vec.reserve(static_cast&lt;uint32_t&gt;(dt));
 
-      double d = getPlaneDistance(wp.getWaypointPosition(i), current_pose.position);
-      if (d &lt; distance_min)
+    auto range_max = static_cast&lt;uint32_t&gt;(previous_number + dt) &lt; current_lane.waypoints.size()
+                         ? static_cast&lt;uint32_t&gt;(previous_number + dt)
+                         : current_lane.waypoints.size();
+    for (uint32_t i = static_cast&lt;uint32_t&gt;(previous_number); i &lt; range_max; i++)
+    {
+      geometry_msgs::Point converted_p;
+      convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose, &amp;converted_p);
+      double angle = getRelativeAngle(current_lane.waypoints.at(i).pose.pose, current_pose);
+      // ROS_INFO("angle: %lf",angle);
+      if (converted_p.x &gt; 0 &amp;&amp; angle &lt; 90)
       {
-        waypoint_min = i;
-        distance_min = d;
+        idx_vec.push_back(i);
+        // ROS_INFO("input idx: %d",i);
       }
     }
-    return waypoint_min;
   }
-}*/
+
+  if (idx_vec.empty())
+    return -1;
+
+  std::vector&lt;double&gt; dist_vec;
+  dist_vec.reserve(idx_vec.size());
+  for (const auto &amp;el : idx_vec)
+  {
+    double dt = getTwoDimensionalDistance(current_pose.position, current_lane.waypoints.at(el).pose.pose.position);
+    dist_vec.push_back(dt);
+    // ROS_INFO("dt: %lf",dt);
+  }
+  std::vector&lt;double&gt;::iterator itr = std::min_element(dist_vec.begin(), dist_vec.end());
+  int32_t found_number = idx_vec.at(static_cast&lt;uint32_t&gt;(std::distance(dist_vec.begin(), itr)));
+  // ROS_INFO("found number: %d",found_number);
+  return found_number;
+}
 
 }  // lane_planner
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="52" deleted_lines="13">
				<diff>@@ -34,10 +34,15 @@
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
+#include &lt;tf/transform_datatypes.h&gt;
+#include &lt;std_msgs/Int32.h&gt;
+#include &lt;visualization_msgs/MarkerArray.h&gt;
 
 // C++ includes
 #include &lt;iostream&gt;
+#include &lt;numeric&gt;
 
+// User defined includes
 #include "waypoint_follower/LaneArray.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 
@@ -54,6 +59,12 @@ enum class ChangeFlag : int32_t
 
 typedef std::underlying_type&lt;ChangeFlag&gt;::type ChangeFlagInteger;
 
+template &lt;class T&gt;
+typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
+{
+  return static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(t);
+}
+
 class LaneSelectNode
 {
 public:
@@ -68,34 +79,62 @@ private:
   ros::NodeHandle private_nh_;
 
   // publisher
-  ros::Publisher pub_;
+  ros::Publisher pub1_, pub2_;
+  ros::Publisher vis_pub1_;
 
   // subscriber
-  ros::Subscriber sub1_, sub2_;
+  ros::Subscriber sub1_, sub2_, sub3_;
 
   // variables
-  int32_t num_of_lane_;  // the number of lane we are driving
-  int32_t num_of_closest_;
-  int32_t size_of_waypoints_;
+  int32_t current_lane_idx_;  // the index of the lane we are driving
+  int32_t right_lane_idx_;
+  int32_t left_lane_idx_;
   int32_t lane_change_interval_;
-  ChangeFlag change_flag_;
-  waypoint_follower::LaneArray lane_array_;
+  std::vector&lt;std::tuple&lt;waypoint_follower::lane, int32_t&gt;&gt; tuple_vec_;  // lane, closest_waypoint
   geometry_msgs::PoseStamped current_pose_;
-  bool is_lane_array_subscribed_, is_current_pose_subscribed_;
-  ros::Time last_time_;
+  geometry_msgs::TwistStamped current_velocity_;
+  bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_;
+  ros::Time last_change_time_;
+  double distance_threshold_;
+
+  // for visualize
+  visualization_msgs::Marker current_lane_marker_;
+  visualization_msgs::Marker right_lane_marker_;
+  visualization_msgs::Marker left_lane_marker_;
+  visualization_msgs::Marker closest_waypoints_marker_;
 
   // callbacks
   void callbackFromLaneArray(const waypoint_follower::LaneArrayConstPtr &amp;msg);
-  void callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg);
+  void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg);
+  void callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr &amp;msg);
 
   // initializer
   void initForROS();
+  void initForViz();
+  void initCommonParamForLaneMarker(visualization_msgs::Marker *marker);
 
   // functions
-  void publishLocalLane();
-  void createLocalLane(waypoint_follower::lane *lane);
+  void publish();
+  void createCurrentLaneMarker();
+  void createRightLaneMarker();
+  void createLeftLaneMarker();
+  void createClosestWaypointsMarker();
+  void publishForVisualize();
+  void processing();
+  bool getClosestWaypointNumberForEachLanes();
+  int32_t findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec, const geometry_msgs::Point p);
+  void findCurrentLane();
+  void findNeighborLanes();
+  void changeLane(const int32_t &amp;change_flag);
 };
 
-int32_t getNumOfClosest(const waypoint_follower::lane &amp;current_path, const geometry_msgs::Pose &amp;current_pose);
+int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
+                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number);
+
+double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geometry_msgs::Point &amp;target2);
+
+void convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose,
+                                        geometry_msgs::Point *output_point);
+double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry_msgs::Pose &amp;current_pose);
 }
 #endif  // LANE_SELECT_CORE_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5957812b861ba4ec8b80606c773979c6ad4369a0" author="h_ohta">
		<msg>Comment out conflict part in visualization, Add Local Point Marker</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" added_lines="30" deleted_lines="3">
				<diff>@@ -317,6 +317,32 @@ void createLocalPathMarker(std_msgs::ColorRGBA color, const waypoint_follower::l
   g_local_waypoints_marker_array.markers.push_back(lane_waypoint_marker);
 }
 
+void createLocalPointMarker(const waypoint_follower::lane &amp;lane_waypoint)
+{
+  visualization_msgs::Marker lane_waypoint_marker;
+  lane_waypoint_marker.header.frame_id = "map";
+  lane_waypoint_marker.header.stamp = ros::Time();
+  lane_waypoint_marker.ns = "local_point_marker";
+  lane_waypoint_marker.id = 0;
+  lane_waypoint_marker.type = visualization_msgs::Marker::CUBE_LIST;
+  lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
+  lane_waypoint_marker.scale.x = 0.2;
+  lane_waypoint_marker.scale.y = 0.2;
+  lane_waypoint_marker.scale.z = 0.2;
+  lane_waypoint_marker.color.r = 1.0;
+   lane_waypoint_marker.color.a = 1.0;
+  lane_waypoint_marker.frame_locked = true;
+
+  for (unsigned int i = 0; i &lt; lane_waypoint.waypoints.size(); i++)
+  {
+    geometry_msgs::Point point;
+    point = lane_waypoint.waypoints[i].pose.pose.position;
+    lane_waypoint_marker.points.push_back(point);
+
+  }
+  g_local_waypoints_marker_array.markers.push_back(lane_waypoint_marker);
+}
+
 void lightCallback(const runtime_manager::traffic_lightConstPtr&amp; msg)
 {
   std_msgs::ColorRGBA global_color;
@@ -374,7 +400,7 @@ void laneArrayCallback(const waypoint_follower::LaneArrayConstPtr &amp;msg)
 {
   g_global_marker_array.markers.clear();
   createGlobalLaneArrayVelocityMarker(*msg);
-  createGlobalLaneArrayMarker(_global_color, *msg);
+  //createGlobalLaneArrayMarker(_global_color, *msg);
   createGlobalLaneArrayOrientationMarker(*msg);
   createGlobalLaneArrayChangeFlagMarker(*msg);
   publishGlobalMarker();
@@ -383,9 +409,10 @@ void laneArrayCallback(const waypoint_follower::LaneArrayConstPtr &amp;msg)
 void temporalCallback(const waypoint_follower::laneConstPtr &amp;msg)
 {
   g_local_waypoints_marker_array.markers.clear();
-  if (_closest_waypoint != -1)
-    createLocalWaypointVelocityMarker(g_local_color, _closest_waypoint, *msg);
+  //if (_closest_waypoint != -1)
+   // createLocalWaypointVelocityMarker(g_local_color, _closest_waypoint, *msg);
   createLocalPathMarker(g_local_color, *msg);
+  createLocalPointMarker(*msg);
   publishLocalMarker();
 
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7276ce31bbc02972d841134e2c2255a97f58a1a8" author="h_ohta">
		<msg>Add lane initialization when subscribed lane array</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="3" deleted_lines="1">
				<diff>@@ -403,7 +403,9 @@ void LaneSelectNode::callbackFromLaneArray(const waypoint_follower::LaneArrayCon
     tuple_vec_.push_back(t);
   }
 
-  // lane_array_ = *msg;
+  current_lane_idx_ = -1;
+  right_lane_idx_ = -1;
+  left_lane_idx_ = -1;
   is_lane_array_subscribed_ = true;
 
   processing();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="18a0217774a4f84f4949a74c882b9a22e06d19d0" author="h_ohta">
		<msg>Fix comment</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_node.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -28,7 +28,7 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-// ROS Includes
+// ROS includes
 #include &lt;ros/ros.h&gt;
 
 #include "lane_select_core.h"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4900c26f52608c00d4aaa19c713962039a80725f" author="h_ohta">
		<msg>Fix keeping storing lane array infinitely in vector</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="2" deleted_lines="0">
				<diff>@@ -396,6 +396,8 @@ void LaneSelectNode::publish()
 
 void LaneSelectNode::callbackFromLaneArray(const waypoint_follower::LaneArrayConstPtr &amp;msg)
 {
+  tuple_vec_.clear();
+  tuple_vec_.shrink_to_fit();
   tuple_vec_.reserve(msg-&gt;lanes.size());
   for (const auto &amp;el : msg-&gt;lanes)
   {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="af5247ca28de4769121e6f77cf577b34b9069756" author="h_ohta">
		<msg>Change processing order, Fix not getting neighbor lanes when current lane index is fixed</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="16" deleted_lines="10">
				<diff>@@ -149,19 +149,25 @@ void LaneSelectNode::processing()
     return;
   }
 
-  // if closest waypoint on current lane is not -1,
-  if (std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))) != -1)
+  // if closest waypoint on current lane is -1,
+  if (std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))) == -1)
   {
-    const int32_t &amp;change_flag =
-        std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))
-            .waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))))
-            .change_flag;
-
-    // if change flag of current_lane is left or right, lane change
-    if (change_flag == enumToInteger(ChangeFlag::right) || change_flag == enumToInteger(ChangeFlag::left))
-      changeLane(change_flag);
+    current_lane_idx_ = -1;
+    right_lane_idx_ = -1;
+    left_lane_idx_ = -1;
+    return;
   }
 
+  findNeighborLanes();
+  const int32_t &amp;change_flag =
+      std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))
+          .waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))))
+          .change_flag;
+
+  // if change flag of current_lane is left or right, lane change
+  if (change_flag == enumToInteger(ChangeFlag::right) || change_flag == enumToInteger(ChangeFlag::left))
+    changeLane(change_flag);
+
   publish();
   return;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d45fec1bbf3b16797cb4a7dbc0259a4fa7a0f4f8" author="h_ohta">
		<msg>Fix not using reserved word in C++</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="3" deleted_lines="3">
				<diff>@@ -28,8 +28,8 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#ifndef _WAYPOINT_LOADER_CORE_H_
-#define _WAYPOINT_LOADER_CORE_H_
+#ifndef WAYPOINT_LOADER_CORE_H
+#define WAYPOINT_LOADER_CORE_H
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
@@ -116,4 +116,4 @@ void parseColumns(const std::string &amp;line, std::vector&lt;std::string&gt; *columns);
 size_t countColumns(const std::string&amp; line);
 
 }
-#endif  // _WAYPOINT_LOADER_CORE_H_
+#endif  // WAYPOINT_LOADER_CORE_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cbff08c8f9041b310d29ba8a841382e639695830" author="TomohitoAndo">
		<msg>Subscribe closest waypoint</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="5" deleted_lines="8">
				<diff>@@ -385,6 +385,10 @@ void localizerCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
   g_localizer_pose.pose = msg-&gt;pose;
 }
 
+void closestWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
+{
+  g_closest_waypoint = msg-&gt;data;
+}
 
 //===============================
 //          Callback
@@ -834,6 +838,7 @@ int main(int argc, char **argv)
   ros::Subscriber obj_pose_sub = nh.subscribe("obj_pose", 1, objPoseCallback);
   ros::Subscriber current_vel_sub = nh.subscribe("current_velocity", 1, currentVelCallback);
   ros::Subscriber config_sub = nh.subscribe("config/velocity_set", 10, configCallback);
+  ros::Subscriber closest_waypoint_sub = nh.subscribe("closest_waypoint", 1, closestWaypointCallback);
 
   //------------------ Vector Map ----------------------//
   ros::Subscriber sub_dtlane = nh.subscribe("vector_map_info/cross_walk", 1, &amp;CrossWalk::crossWalkCallback, &amp;vmap);
@@ -845,8 +850,6 @@ int main(int argc, char **argv)
   g_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 0);
   g_sound_pub = nh.advertise&lt;std_msgs::String&gt;("sound_player", 10);
   g_temporal_waypoints_pub = nh.advertise&lt;waypoint_follower::lane&gt;("temporal_waypoints", 1000, true);
-  ros::Publisher closest_waypoint_pub;
-  closest_waypoint_pub = nh.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1000);
   g_obstacle_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("obstacle", 0);
 
   ros::Rate loop_rate(LOOP_RATE);
@@ -863,12 +866,6 @@ int main(int argc, char **argv)
       continue;
     }
 
-    g_closest_waypoint = getClosestWaypoint(g_path_change.getCurrentWaypoints(), g_control_pose.pose);
-
-    std_msgs::Int32 closest_waypoint;
-    closest_waypoint.data = g_closest_waypoint;
-    closest_waypoint_pub.publish(closest_waypoint);
-
     if (use_crosswalk_detection)
       vmap.setDetectionWaypoint(findCrossWalk());
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e46f15eb1d9cb18ebcdcc193d06a886f0c580078" author="h_ohta">
		<msg>Edit Comment out and WARN message</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -127,7 +127,7 @@ void LaneSelectNode::processing()
 {
   if (!is_current_pose_subscribed_ || !is_lane_array_subscribed_ || !is_current_velocity_subscribed_)
   {
-    ROS_ERROR("Necessary topics are not subscribed yet.");
+    ROS_WARN("Necessary topics are not subscribed yet. Waiting...");
     return;
   }
 
@@ -202,7 +202,7 @@ bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
     ROS_INFO("closest: %d", std::get&lt;1&gt;(el));
   }
 
-  // confirm if all closest waypoint numbers are -1. If so, output error
+  // confirm if all closest waypoint numbers are -1. If so, output warning
   int32_t accum = 0;
   for (const auto &amp;el : tuple_vec_)
   {
@@ -210,7 +210,7 @@ bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
   }
   if (accum == (-1) * static_cast&lt;int32_t&gt;(tuple_vec_.size()))
   {
-    ROS_ERROR("cannot get closest waypoints");
+    ROS_WARN("Cannot get closest waypoints. All closest waypoints are changed to -1...");
     return false;
   }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="751f3a486356e238bd58107d2589d7352cc9e4e8" author="h_ohta">
		<msg>Add subscription for closest waypoint</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" added_lines="12" deleted_lines="2">
				<diff>@@ -36,6 +36,7 @@
 #include &lt;tf/transform_listener.h&gt;
 #include &lt;tf/tf.h&gt;
 #include &lt;iostream&gt;
+#include &lt;std_msgs/Int32.h&gt;
 
 #include "waypoint_follower/libwaypoint_follower.h"
 
@@ -50,9 +51,11 @@ geometry_msgs::Pose _initial_pose;
 bool _initial_set = false;
 bool _pose_set = false;
 bool _waypoint_set = false;
+bool g_is_closest_waypoint_subscribed = false;
 WayPoints _current_waypoints;
 ros::Publisher g_odometry_publisher;
 ros::Publisher g_velocity_publisher;
+int32_t g_closest_waypoint = -1;
 
 constexpr int LOOP_RATE = 50; // 50Hz
 
@@ -135,6 +138,12 @@ void waypointCallback(const waypoint_follower::laneConstPtr &amp;msg)
   //ROS_INFO_STREAM("waypoint subscribed");
 }
 
+void callbackFromClosestWaypoint(const std_msgs::Int32ConstPtr &amp;msg)
+{
+  g_closest_waypoint = msg-&gt;data;
+  g_is_closest_waypoint_subscribed = true;
+}
+
 void publishOdometry()
 {
   static ros::Time current_time = ros::Time::now();
@@ -163,8 +172,8 @@ void publishOdometry()
   {
     pose.position.z = _current_waypoints.getWaypointPosition(closest_waypoint).z;
   }
-*/if(_waypoint_set)
-    pose.position.z = _current_waypoints.getWaypointPosition(1).z;
+*/if(_waypoint_set &amp;&amp; g_is_closest_waypoint_subscribed)
+    pose.position.z = _current_waypoints.getWaypointPosition(g_closest_waypoint).z;
 
   double vx = _current_velocity.linear.x;
   double vth = _current_velocity.angular.z;
@@ -243,6 +252,7 @@ int main(int argc, char **argv)
   // subscribe topic
   ros::Subscriber cmd_subscriber = nh.subscribe&lt;geometry_msgs::TwistStamped&gt;("twist_cmd", 10, boost::bind(CmdCallBack, _1, accel_rate));
   ros::Subscriber waypoint_subcscriber = nh.subscribe("base_waypoints", 10, waypointCallback);
+  ros::Subscriber closest_sub = nh.subscribe("closest_waypoint", 10, callbackFromClosestWaypoint);
   ros::Subscriber initialpose_subscriber;
 
   if (initialize_source == "Rviz")
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8f5fb01bb6b54bf5be2f333189de436e0aef7248" author="h_ohta">
		<msg>Add include</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="1" deleted_lines="0">
				<diff>@@ -41,6 +41,7 @@
 // C++ includes
 #include &lt;iostream&gt;
 #include &lt;numeric&gt;
+#include &lt;tuple&gt;
 
 // User defined includes
 #include "waypoint_follower/LaneArray.h"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0c7c3db2cccfab1e9ac8a93b77d5a60ec595a334" author="h_ohta">
		<msg>Add state variable</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -43,6 +43,7 @@ LaneSelectNode::LaneSelectNode()
   , is_current_pose_subscribed_(false)
   , is_current_velocity_subscribed_(false)
   , last_change_time_(ros::Time::now())
+  , current_state_("LANE_CHANGE")
 {
   initForROS();
   initForViz();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="1" deleted_lines="0">
				<diff>@@ -97,6 +97,7 @@ private:
   bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_;
   ros::Time last_change_time_;
   double distance_threshold_;
+  std::string current_state_;
 
   // for visualize
   visualization_msgs::Marker current_lane_marker_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f569a2cb33564edb215dcf237e931bb8579a112f" author="h_ohta">
		<msg>Remove unused code</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="1" deleted_lines="3">
				<diff>@@ -58,8 +58,6 @@ enum class ChangeFlag : int32_t
   unknown = -1,
 };
 
-typedef std::underlying_type&lt;ChangeFlag&gt;::type ChangeFlagInteger;
-
 template &lt;class T&gt;
 typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
 {
@@ -91,7 +89,7 @@ private:
   int32_t right_lane_idx_;
   int32_t left_lane_idx_;
   int32_t lane_change_interval_;
-  std::vector&lt;std::tuple&lt;waypoint_follower::lane, int32_t&gt;&gt; tuple_vec_;  // lane, closest_waypoint
+  std::vector&lt;std::tuple&lt;waypoint_follower::lane, int32_t, int32_t&gt;&gt; tuple_vec_;  // lane, closest_waypoint, change_flag
   geometry_msgs::PoseStamped current_pose_;
   geometry_msgs::TwistStamped current_velocity_;
   bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8f98f7d6362a57691776ff1773528a8c57e8922b" author="h_ohta">
		<msg>Add ChangeFlag value into tuple</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="3" deleted_lines="1">
				<diff>@@ -201,6 +201,8 @@ bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
         getClosestWaypointNumber(std::get&lt;0&gt;(el), current_pose_.pose, current_velocity_.twist, std::get&lt;1&gt;(el));
     std::get&lt;1&gt;(el) = number;
     ROS_INFO("closest: %d", std::get&lt;1&gt;(el));
+
+    std::get&lt;2&gt;(el) = static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(el).waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(el))).change_flag);
   }
 
   // confirm if all closest waypoint numbers are -1. If so, output warning
@@ -408,7 +410,7 @@ void LaneSelectNode::callbackFromLaneArray(const waypoint_follower::LaneArrayCon
   tuple_vec_.reserve(msg-&gt;lanes.size());
   for (const auto &amp;el : msg-&gt;lanes)
   {
-    auto t = std::make_tuple(el, -1);
+    auto t = std::make_tuple(el, -1, ChangeFlag::unknown);
     tuple_vec_.push_back(t);
   }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="1" deleted_lines="1">
				<diff>@@ -89,7 +89,7 @@ private:
   int32_t right_lane_idx_;
   int32_t left_lane_idx_;
   int32_t lane_change_interval_;
-  std::vector&lt;std::tuple&lt;waypoint_follower::lane, int32_t, int32_t&gt;&gt; tuple_vec_;  // lane, closest_waypoint, change_flag
+  std::vector&lt;std::tuple&lt;waypoint_follower::lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint, change_flag
   geometry_msgs::PoseStamped current_pose_;
   geometry_msgs::TwistStamped current_velocity_;
   bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4346162edbc2a8002fc99e8a2a63d16a4b6bae8d" author="h_ohta">
		<msg>Modify value which will be added into tuple</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="5" deleted_lines="3">
				<diff>@@ -197,12 +197,14 @@ bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
 {
   for (auto &amp;el : tuple_vec_)
   {
-    int32_t number =
+    std::get&lt;1&gt;(el) =
         getClosestWaypointNumber(std::get&lt;0&gt;(el), current_pose_.pose, current_velocity_.twist, std::get&lt;1&gt;(el));
-    std::get&lt;1&gt;(el) = number;
     ROS_INFO("closest: %d", std::get&lt;1&gt;(el));
 
-    std::get&lt;2&gt;(el) = static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(el).waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(el))).change_flag);
+    std::get&lt;2&gt;(el) = (std::get&lt;1&gt;(el) != -1)
+            ? static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(el).waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(el))).change_flag)
+            : ChangeFlag::unknown;
+    ROS_INFO("change_flag: %d",enumToInteger(std::get&lt;2&gt;(el)));
   }
 
   // confirm if all closest waypoint numbers are -1. If so, output warning
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="33abffd5a55af60653f8d5a19ea31cc4ea7f7863" author="h_ohta">
		<msg>Move ROS_INFO</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="3" deleted_lines="4">
				<diff>@@ -164,6 +164,9 @@ void LaneSelectNode::processing()
       std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))
           .waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))))
           .change_flag;
+  ROS_INFO("current_lane_idx: %d", current_lane_idx_);
+  ROS_INFO("right_lane_idx: %d", right_lane_idx_);
+  ROS_INFO("left_lane_idx: %d", left_lane_idx_);
 
   // if change flag of current_lane is left or right, lane change
   if (change_flag == enumToInteger(ChangeFlag::right) || change_flag == enumToInteger(ChangeFlag::left))
@@ -387,10 +390,6 @@ void LaneSelectNode::publishForVisualize()
 
 void LaneSelectNode::publish()
 {
-  ROS_INFO("current_lane_idx: %d", current_lane_idx_);
-  ROS_INFO("right_lane_idx: %d", right_lane_idx_);
-  ROS_INFO("left_lane_idx: %d", left_lane_idx_);
-
   // publish current global lane
   waypoint_follower::lane global_lane;
   global_lane = std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="784e22511d190ae0a1b0c7da1f1227fba170eee1" author="h_ohta">
		<msg>Add ROS_INFO about current change_flag</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -167,6 +167,7 @@ void LaneSelectNode::processing()
   ROS_INFO("current_lane_idx: %d", current_lane_idx_);
   ROS_INFO("right_lane_idx: %d", right_lane_idx_);
   ROS_INFO("left_lane_idx: %d", left_lane_idx_);
+  ROS_INFO("current change_flag: %d", enumToInteger(std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))));
 
   // if change flag of current_lane is left or right, lane change
   if (change_flag == enumToInteger(ChangeFlag::right) || change_flag == enumToInteger(ChangeFlag::left))
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7355756922b93b5a3826315ca752f22e78dab2d3" author="h_ohta">
		<msg>Rewrite lane change processing adding state and new tuple</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="16" deleted_lines="13">
				<diff>@@ -159,35 +159,38 @@ void LaneSelectNode::processing()
     return;
   }
 
-  findNeighborLanes();
-  const int32_t &amp;change_flag =
-      std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))
-          .waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))))
-          .change_flag;
   ROS_INFO("current_lane_idx: %d", current_lane_idx_);
   ROS_INFO("right_lane_idx: %d", right_lane_idx_);
   ROS_INFO("left_lane_idx: %d", left_lane_idx_);
   ROS_INFO("current change_flag: %d", enumToInteger(std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))));
 
+  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
   // if change flag of current_lane is left or right, lane change
-  if (change_flag == enumToInteger(ChangeFlag::right) || change_flag == enumToInteger(ChangeFlag::left))
-    changeLane(change_flag);
+  if (current_state_ == "LANE_CHANGE")
+  {
+    if(change_flag == ChangeFlag::right &amp;&amp; right_lane_idx_ != -1)
+      if(std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(right_lane_idx_))) != -1)
+        changeLane();
+
+    if(change_flag == ChangeFlag::left &amp;&amp; left_lane_idx_ != -1)
+      if(std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(left_lane_idx_))) != -1)
+        changeLane();
+  }
 
   publish();
-  return;
 }
 
-void LaneSelectNode::changeLane(const int32_t &amp;change_flag)
+void LaneSelectNode::changeLane()
 {
   ros::Time current_time = ros::Time::now();
   double dt = (current_time - last_change_time_).toSec();
   if (dt &lt; lane_change_interval_)
     return;
 
-  if (change_flag == enumToInteger(ChangeFlag::right) &amp;&amp; right_lane_idx_ != -1)
-    current_lane_idx_ = right_lane_idx_;
-  else if (change_flag == enumToInteger(ChangeFlag::left) &amp;&amp; left_lane_idx_ != -1)
-    current_lane_idx_ = left_lane_idx_;
+  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
+  current_lane_idx_ = change_flag == ChangeFlag::right ? right_lane_idx_
+                                                       : change_flag == ChangeFlag::left ? left_lane_idx_
+                                                                                         : current_lane_idx_;
 
   findNeighborLanes();
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="1" deleted_lines="1">
				<diff>@@ -125,7 +125,7 @@ private:
   int32_t findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec, const geometry_msgs::Point p);
   void findCurrentLane();
   void findNeighborLanes();
-  void changeLane(const int32_t &amp;change_flag);
+  void changeLane();
 };
 
 int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="dfe7fab664a8791f0e81f48960544f2c64722944" author="h_ohta">
		<msg>Rewrite visualizer</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="127" deleted_lines="94">
				<diff>@@ -46,7 +46,6 @@ LaneSelectNode::LaneSelectNode()
   , current_state_("LANE_CHANGE")
 {
   initForROS();
-  initForViz();
 }
 
 // Destructor
@@ -71,59 +70,6 @@ void LaneSelectNode::initForROS()
   private_nh_.param&lt;double&gt;("distance_threshold", distance_threshold_, double(3.0));
 }
 
-void LaneSelectNode::initCommonParamForLaneMarker(visualization_msgs::Marker *marker)
-{
-  marker-&gt;header.frame_id = "map";
-  marker-&gt;header.stamp = ros::Time();
-  marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
-  marker-&gt;action = visualization_msgs::Marker::ADD;
-  marker-&gt;scale.x = 1.0;
-}
-
-void LaneSelectNode::initForViz()
-{
-  std_msgs::ColorRGBA color_current;
-  color_current.b = 1.0;
-  color_current.g = 0.7;
-  color_current.a = 0.2;
-
-  std_msgs::ColorRGBA color_neighbor;
-  color_neighbor.r = 0.5;
-  color_neighbor.b = 0.5;
-  color_neighbor.g = 0.5;
-  color_neighbor.a = 0.2;
-
-  std_msgs::ColorRGBA color_closest_wp;
-  color_closest_wp.r = 1.0;
-  color_closest_wp.b = 1.0;
-  color_closest_wp.g = 1.0;
-  color_closest_wp.a = 1.0;
-
-  // current_lane_marker_
-  initCommonParamForLaneMarker(&amp;current_lane_marker_);
-  current_lane_marker_.ns = "current_lane_marker";
-  current_lane_marker_.color = color_current;
-
-  // left_lane_marker_
-  initCommonParamForLaneMarker(&amp;left_lane_marker_);
-  left_lane_marker_.ns = "left_lane_marker";
-  left_lane_marker_.color = color_neighbor;
-
-  // right_lane_marker_
-  initCommonParamForLaneMarker(&amp;right_lane_marker_);
-  right_lane_marker_.ns = "right_lane_marker";
-  right_lane_marker_.color = color_neighbor;
-
-  // closest_waypoints_marker_
-  closest_waypoints_marker_.header.frame_id = "map";
-  closest_waypoints_marker_.header.stamp = ros::Time();
-  closest_waypoints_marker_.ns = "closest_waypoints_marker";
-  closest_waypoints_marker_.type = visualization_msgs::Marker::POINTS;
-  closest_waypoints_marker_.action = visualization_msgs::Marker::ADD;
-  closest_waypoints_marker_.scale.x = 0.5;
-  closest_waypoints_marker_.color = color_closest_wp;
-}
-
 void LaneSelectNode::processing()
 {
   if (!is_current_pose_subscribed_ || !is_lane_array_subscribed_ || !is_current_velocity_subscribed_)
@@ -138,6 +84,7 @@ void LaneSelectNode::processing()
     current_lane_idx_ = -1;
     right_lane_idx_ = -1;
     left_lane_idx_ = -1;
+    publishVisualizer();
     return;
   }
 
@@ -147,6 +94,7 @@ void LaneSelectNode::processing()
     findCurrentLane();
     findNeighborLanes();
     publish();
+    publishVisualizer();
     return;
   }
 
@@ -156,6 +104,7 @@ void LaneSelectNode::processing()
     current_lane_idx_ = -1;
     right_lane_idx_ = -1;
     left_lane_idx_ = -1;
+    publishVisualizer();
     return;
   }
 
@@ -178,6 +127,8 @@ void LaneSelectNode::processing()
   }
 
   publish();
+  publishVisualizer();
+
 }
 
 void LaneSelectNode::changeLane()
@@ -194,9 +145,6 @@ void LaneSelectNode::changeLane()
 
   findNeighborLanes();
 
-  // for visualize
-  createCurrentLaneMarker();
-
   last_change_time_ = ros::Time::now();
 }
 
@@ -226,8 +174,6 @@ bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
     return false;
   }
 
-  // for visualize
-  createClosestWaypointsMarker();
   return true;
 }
 
@@ -243,8 +189,6 @@ void LaneSelectNode::findCurrentLane()
   }
   current_lane_idx_ = findMostClosestLane(idx_vec, current_pose_.pose.position);
 
-  // for visualize
-  createCurrentLaneMarker();
 }
 
 int32_t LaneSelectNode::findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec, const geometry_msgs::Point p)
@@ -300,8 +244,6 @@ void LaneSelectNode::findNeighborLanes()
   {
     left_lane_idx_ = findMostClosestLane(left_lane_idx_vec, current_closest_pose.position);
 
-    // for visualize
-    createLeftLaneMarker();
   }
   else
   {
@@ -311,8 +253,6 @@ void LaneSelectNode::findNeighborLanes()
   {
     right_lane_idx_ = findMostClosestLane(right_lane_idx_vec, current_closest_pose.position);
 
-    // for visualize
-    createRightLaneMarker();
   }
   else
   {
@@ -320,74 +260,167 @@ void LaneSelectNode::findNeighborLanes()
   }
 }
 
-void LaneSelectNode::createCurrentLaneMarker()
+void LaneSelectNode::createCurrentLaneMarker(visualization_msgs::Marker *marker)
 {
+  marker-&gt;header.frame_id = "map";
+  marker-&gt;header.stamp = ros::Time();
+  marker-&gt;ns = "current_lane_marker";
+
+  if (current_lane_idx_ == -1)
+  {
+    marker-&gt;action = visualization_msgs::Marker::DELETE;
+    return;
+  }
+
+  marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
+  marker-&gt;action = visualization_msgs::Marker::ADD;
+  marker-&gt;scale.x = 1.0;
+
+  std_msgs::ColorRGBA color_current;
+  color_current.b = 1.0;
+  color_current.g = 0.7;
+  color_current.a = 0.2;
+
+  marker-&gt;color = color_current;
+
   const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps =
       std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))).waypoints;
-  current_lane_marker_.points.clear();
-  current_lane_marker_.points.shrink_to_fit();
-  current_lane_marker_.points.reserve(wps.size());
+
+  marker-&gt;points.reserve(wps.size());
   for (const auto &amp;el : wps)
   {
-    current_lane_marker_.points.push_back(el.pose.pose.position);
+    marker-&gt;points.push_back(el.pose.pose.position);
   }
-  publishForVisualize();
 }
 
-void LaneSelectNode::createRightLaneMarker()
+void LaneSelectNode::createRightLaneMarker(visualization_msgs::Marker *marker)
 {
+  marker-&gt;header.frame_id = "map";
+  marker-&gt;header.stamp = ros::Time();
+  marker-&gt;ns = "right_lane_marker";
+
+  if (right_lane_idx_ == -1)
+  {
+    marker-&gt;action = visualization_msgs::Marker::DELETE;
+    return;
+  }
+
+  marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
+  marker-&gt;action = visualization_msgs::Marker::ADD;
+  marker-&gt;scale.x = 1.0;
+
+  std_msgs::ColorRGBA color_neighbor;
+  color_neighbor.r = 0.5;
+  color_neighbor.b = 0.5;
+  color_neighbor.g = 0.5;
+  color_neighbor.a = 0.2;
+
+  std_msgs::ColorRGBA color_neighbor_change;
+  color_neighbor_change.b = 0.7;
+  color_neighbor_change.g = 1.0;
+   color_neighbor_change.a = 0.2;
+
+  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
+  marker-&gt;color =  change_flag == ChangeFlag::right ? color_neighbor_change : color_neighbor;
+
   const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps =
       std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(right_lane_idx_))).waypoints;
 
-  right_lane_marker_.points.clear();
-  right_lane_marker_.points.shrink_to_fit();
-  right_lane_marker_.points.reserve(wps.size());
+  marker-&gt;points.reserve(wps.size());
   for (const auto &amp;el : wps)
   {
-    right_lane_marker_.points.push_back(el.pose.pose.position);
+    marker-&gt;points.push_back(el.pose.pose.position);
   }
-  publishForVisualize();
 }
 
-void LaneSelectNode::createLeftLaneMarker()
+void LaneSelectNode::createLeftLaneMarker(visualization_msgs::Marker *marker)
 {
+  marker-&gt;header.frame_id = "map";
+  marker-&gt;header.stamp = ros::Time();
+  marker-&gt;ns = "left_lane_marker";
+
+  if (left_lane_idx_ == -1)
+  {
+    marker-&gt;action = visualization_msgs::Marker::DELETE;
+    return;
+  }
+
+  marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
+  marker-&gt;action = visualization_msgs::Marker::ADD;
+  marker-&gt;scale.x = 1.0;
+
+  std_msgs::ColorRGBA color_neighbor;
+  color_neighbor.r = 0.5;
+  color_neighbor.b = 0.5;
+  color_neighbor.g = 0.5;
+  color_neighbor.a = 0.2;
+
+  std_msgs::ColorRGBA color_neighbor_change;
+  color_neighbor_change.b = 0.7;
+  color_neighbor_change.g = 1.0;
+  color_neighbor_change.a = 0.2;
+
+  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
+  marker-&gt;color = change_flag == ChangeFlag::left ? color_neighbor_change
+                                                  : color_neighbor;
+
   const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps =
       std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(left_lane_idx_))).waypoints;
 
-  left_lane_marker_.points.clear();
-  left_lane_marker_.points.shrink_to_fit();
-  left_lane_marker_.points.reserve(wps.size());
+  marker-&gt;points.reserve(wps.size());
   for (const auto &amp;el : wps)
   {
-    left_lane_marker_.points.push_back(el.pose.pose.position);
+    marker-&gt;points.push_back(el.pose.pose.position);
   }
-  publishForVisualize();
 }
 
-void LaneSelectNode::createClosestWaypointsMarker()
+void LaneSelectNode::createClosestWaypointsMarker(visualization_msgs::Marker *marker)
 {
-  closest_waypoints_marker_.points.clear();
-  closest_waypoints_marker_.points.shrink_to_fit();
-  closest_waypoints_marker_.points.reserve(tuple_vec_.size());
+  std_msgs::ColorRGBA color_closest_wp;
+  color_closest_wp.r = 1.0;
+  color_closest_wp.b = 1.0;
+  color_closest_wp.g = 1.0;
+  color_closest_wp.a = 1.0;
+
+  marker-&gt;header.frame_id = "map";
+  marker-&gt;header.stamp = ros::Time();
+  marker-&gt;ns = "closest_waypoints_marker";
+  marker-&gt;type = visualization_msgs::Marker::POINTS;
+  marker-&gt;action = visualization_msgs::Marker::ADD;
+  marker-&gt;scale.x = 0.5;
+  marker-&gt;color = color_closest_wp;
+
+  marker-&gt;points.reserve(tuple_vec_.size());
   for (uint32_t i = 0; i &lt; tuple_vec_.size(); i++)
   {
     if (std::get&lt;1&gt;(tuple_vec_.at(i)) == -1)
       continue;
 
-    closest_waypoints_marker_.points.push_back(std::get&lt;0&gt;(tuple_vec_.at(i))
+    marker-&gt;points.push_back(std::get&lt;0&gt;(tuple_vec_.at(i))
                                                    .waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(i))))
                                                    .pose.pose.position);
   }
-  publishForVisualize();
 }
 
-void LaneSelectNode::publishForVisualize()
+void LaneSelectNode::publishVisualizer()
 {
   visualization_msgs::MarkerArray marker_array;
-  marker_array.markers.push_back(closest_waypoints_marker_);
-  marker_array.markers.push_back(current_lane_marker_);
-  marker_array.markers.push_back(left_lane_marker_);
-  marker_array.markers.push_back(right_lane_marker_);
+
+  visualization_msgs::Marker current_lane_marker;
+  createCurrentLaneMarker(&amp;current_lane_marker);
+  marker_array.markers.push_back(current_lane_marker);
+
+  visualization_msgs::Marker right_lane_marker;
+  createRightLaneMarker(&amp;right_lane_marker);
+  marker_array.markers.push_back(right_lane_marker);
+
+  visualization_msgs::Marker left_lane_marker;
+  createLeftLaneMarker(&amp;left_lane_marker);
+  marker_array.markers.push_back(left_lane_marker);
+
+  visualization_msgs::Marker closest_waypoints_marker;
+  createClosestWaypointsMarker(&amp;closest_waypoints_marker);
+  marker_array.markers.push_back(closest_waypoints_marker);
 
   vis_pub1_.publish(marker_array);
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="5" deleted_lines="13">
				<diff>@@ -97,12 +97,6 @@ private:
   double distance_threshold_;
   std::string current_state_;
 
-  // for visualize
-  visualization_msgs::Marker current_lane_marker_;
-  visualization_msgs::Marker right_lane_marker_;
-  visualization_msgs::Marker left_lane_marker_;
-  visualization_msgs::Marker closest_waypoints_marker_;
-
   // callbacks
   void callbackFromLaneArray(const waypoint_follower::LaneArrayConstPtr &amp;msg);
   void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg);
@@ -110,16 +104,14 @@ private:
 
   // initializer
   void initForROS();
-  void initForViz();
-  void initCommonParamForLaneMarker(visualization_msgs::Marker *marker);
 
   // functions
   void publish();
-  void createCurrentLaneMarker();
-  void createRightLaneMarker();
-  void createLeftLaneMarker();
-  void createClosestWaypointsMarker();
-  void publishForVisualize();
+  void publishVisualizer();
+  void createCurrentLaneMarker(visualization_msgs::Marker *marker);
+  void createRightLaneMarker(visualization_msgs::Marker *marker);
+  void createLeftLaneMarker(visualization_msgs::Marker *marker);
+  void createClosestWaypointsMarker(visualization_msgs::Marker *marker);
   void processing();
   bool getClosestWaypointNumberForEachLanes();
   int32_t findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec, const geometry_msgs::Point p);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5d6f12faacef4be191e3ad2f23ddb60dd2567168" author="h_ohta">
		<msg>Sort definitions</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="11" deleted_lines="5">
				<diff>@@ -88,13 +88,17 @@ private:
   int32_t current_lane_idx_;  // the index of the lane we are driving
   int32_t right_lane_idx_;
   int32_t left_lane_idx_;
-  int32_t lane_change_interval_;
   std::vector&lt;std::tuple&lt;waypoint_follower::lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint, change_flag
-  geometry_msgs::PoseStamped current_pose_;
-  geometry_msgs::TwistStamped current_velocity_;
   bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_;
   ros::Time last_change_time_;
+
+  // rosparam
   double distance_threshold_;
+  int32_t lane_change_interval_;
+
+  // topics
+  geometry_msgs::PoseStamped current_pose_;
+  geometry_msgs::TwistStamped current_velocity_;
   std::string current_state_;
 
   // callbacks
@@ -105,14 +109,16 @@ private:
   // initializer
   void initForROS();
 
-  // functions
-  void publish();
+  // visualizer
   void publishVisualizer();
   void createCurrentLaneMarker(visualization_msgs::Marker *marker);
   void createRightLaneMarker(visualization_msgs::Marker *marker);
   void createLeftLaneMarker(visualization_msgs::Marker *marker);
   void createClosestWaypointsMarker(visualization_msgs::Marker *marker);
+
+  // functions
   void processing();
+  void publish();
   bool getClosestWaypointNumberForEachLanes();
   int32_t findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec, const geometry_msgs::Point p);
   void findCurrentLane();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bc3e8e527e3e9281de178c30079eb80a2d6ed385" author="h_ohta">
		<msg>Fix Indent</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="14" deleted_lines="17">
				<diff>@@ -111,24 +111,24 @@ void LaneSelectNode::processing()
   ROS_INFO("current_lane_idx: %d", current_lane_idx_);
   ROS_INFO("right_lane_idx: %d", right_lane_idx_);
   ROS_INFO("left_lane_idx: %d", left_lane_idx_);
-  ROS_INFO("current change_flag: %d", enumToInteger(std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))));
+  ROS_INFO("current change_flag: %d",
+           enumToInteger(std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))));
 
   const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
   // if change flag of current_lane is left or right, lane change
   if (current_state_ == "LANE_CHANGE")
   {
-    if(change_flag == ChangeFlag::right &amp;&amp; right_lane_idx_ != -1)
-      if(std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(right_lane_idx_))) != -1)
+    if (change_flag == ChangeFlag::right &amp;&amp; right_lane_idx_ != -1)
+      if (std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(right_lane_idx_))) != -1)
         changeLane();
 
-    if(change_flag == ChangeFlag::left &amp;&amp; left_lane_idx_ != -1)
-      if(std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(left_lane_idx_))) != -1)
+    if (change_flag == ChangeFlag::left &amp;&amp; left_lane_idx_ != -1)
+      if (std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(left_lane_idx_))) != -1)
         changeLane();
   }
 
   publish();
   publishVisualizer();
-
 }
 
 void LaneSelectNode::changeLane()
@@ -156,10 +156,11 @@ bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
         getClosestWaypointNumber(std::get&lt;0&gt;(el), current_pose_.pose, current_velocity_.twist, std::get&lt;1&gt;(el));
     ROS_INFO("closest: %d", std::get&lt;1&gt;(el));
 
-    std::get&lt;2&gt;(el) = (std::get&lt;1&gt;(el) != -1)
+    std::get&lt;2&gt;(el) =
+        (std::get&lt;1&gt;(el) != -1)
             ? static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(el).waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(el))).change_flag)
             : ChangeFlag::unknown;
-    ROS_INFO("change_flag: %d",enumToInteger(std::get&lt;2&gt;(el)));
+    ROS_INFO("change_flag: %d", enumToInteger(std::get&lt;2&gt;(el)));
   }
 
   // confirm if all closest waypoint numbers are -1. If so, output warning
@@ -188,7 +189,6 @@ void LaneSelectNode::findCurrentLane()
     idx_vec.push_back(i);
   }
   current_lane_idx_ = findMostClosestLane(idx_vec, current_pose_.pose.position);
-
 }
 
 int32_t LaneSelectNode::findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec, const geometry_msgs::Point p)
@@ -243,7 +243,6 @@ void LaneSelectNode::findNeighborLanes()
   if (!left_lane_idx_vec.empty())
   {
     left_lane_idx_ = findMostClosestLane(left_lane_idx_vec, current_closest_pose.position);
-
   }
   else
   {
@@ -252,7 +251,6 @@ void LaneSelectNode::findNeighborLanes()
   if (!right_lane_idx_vec.empty())
   {
     right_lane_idx_ = findMostClosestLane(right_lane_idx_vec, current_closest_pose.position);
-
   }
   else
   {
@@ -318,10 +316,10 @@ void LaneSelectNode::createRightLaneMarker(visualization_msgs::Marker *marker)
   std_msgs::ColorRGBA color_neighbor_change;
   color_neighbor_change.b = 0.7;
   color_neighbor_change.g = 1.0;
-   color_neighbor_change.a = 0.2;
+  color_neighbor_change.a = 0.2;
 
   const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
-  marker-&gt;color =  change_flag == ChangeFlag::right ? color_neighbor_change : color_neighbor;
+  marker-&gt;color = change_flag == ChangeFlag::right ? color_neighbor_change : color_neighbor;
 
   const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps =
       std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(right_lane_idx_))).waypoints;
@@ -361,8 +359,7 @@ void LaneSelectNode::createLeftLaneMarker(visualization_msgs::Marker *marker)
   color_neighbor_change.a = 0.2;
 
   const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
-  marker-&gt;color = change_flag == ChangeFlag::left ? color_neighbor_change
-                                                  : color_neighbor;
+  marker-&gt;color = change_flag == ChangeFlag::left ? color_neighbor_change : color_neighbor;
 
   const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps =
       std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(left_lane_idx_))).waypoints;
@@ -397,8 +394,8 @@ void LaneSelectNode::createClosestWaypointsMarker(visualization_msgs::Marker *ma
       continue;
 
     marker-&gt;points.push_back(std::get&lt;0&gt;(tuple_vec_.at(i))
-                                                   .waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(i))))
-                                                   .pose.pose.position);
+                                 .waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(i))))
+                                 .pose.pose.position);
   }
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9da0d9366dac66335fdfd805c84ebb2fcbdd41eb" author="h_ohta">
		<msg>Add the function, velocity plannning, for format ver2 and 3</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="11" deleted_lines="0">
				<diff>@@ -166,6 +166,7 @@ void WaypointLoaderNode::loadWaypointsForVer2(const char *filename, std::vector&lt;
     parseWaypointForVer2(line, &amp;wp);
     wps-&gt;push_back(wp);
   }
+  planningVelocity(&amp;*wps);
 }
 
 void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line, waypoint_follower::waypoint *wp)
@@ -199,6 +200,7 @@ void WaypointLoaderNode::loadWaypoints(const char *filename, std::vector&lt;waypoin
     parseWaypoint(line, contents, &amp;wp);
     wps-&gt;push_back(wp);
   }
+  planningVelocity(&amp;*wps);
 }
 
 void WaypointLoaderNode::parseWaypoint(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
@@ -253,6 +255,15 @@ FileFormat WaypointLoaderNode::checkFileFormat(const char *filename)
           );
 }
 
+void WaypointLoaderNode::planningVelocity(std::vector&lt;waypoint_follower::waypoint&gt; *wps)
+{
+  for (size_t i = 0; i &lt; wps-&gt;size(); ++i)
+  {
+    wps-&gt;at(i).twist.twist.linear.x = decelerate(
+      wps-&gt;at(i).pose.pose.position, wps-&gt;at(wps-&gt;size() - 1).pose.pose.position, wps-&gt;at(i).twist.twist.linear.x);
+  }
+}
+
 double WaypointLoaderNode::decelerate(geometry_msgs::Point p1, geometry_msgs::Point p2, double original_velocity_mps)
 {
   double distance = sqrt(pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2) + pow(p2.z - p1.z, 2));
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="1" deleted_lines="0">
				<diff>@@ -108,6 +108,7 @@ private:
   void loadWaypoints(const char *filename, std::vector&lt;waypoint_follower::waypoint&gt; *wps);
   void parseWaypoint(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
                             waypoint_follower::waypoint *wp);
+  void planningVelocity(std::vector&lt;waypoint_follower::waypoint&gt; *wps);
   double decelerate(geometry_msgs::Point p1, geometry_msgs::Point p2, double original_velocity_mps);
 
 };
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="819c8bcf94c6edfb0bdad636adaef5bd6bf1a12c" author="h_ohta">
		<msg>Delete useless braces</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="0" deleted_lines="2">
				<diff>@@ -516,9 +516,7 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
                                  const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number)
 {
   if (current_lane.waypoints.empty())
-  {
     return -1;
-  }
 
   // ROS_INFO("number: %d",previous_number);
   std::vector&lt;uint32_t&gt; idx_vec;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3fe407b609a4d9608b8ac235bbea056a030d4d30" author="h_ohta">
		<msg>Initialize the closest waypoint number when the vehicle is outside of a search distance</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="3" deleted_lines="0">
				<diff>@@ -543,6 +543,9 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
     double minimum_dt = 2.0;
     double dt = current_velocity.linear.x * ratio &gt; minimum_dt ? current_velocity.linear.x * ratio : minimum_dt;
 
+    if(dt &lt; getTwoDimensionalDistance(current_lane.waypoints.at(previous_number).pose.pose.position,current_pose.position))
+      return -1;
+
     idx_vec.reserve(static_cast&lt;uint32_t&gt;(dt));
 
     auto range_max = static_cast&lt;uint32_t&gt;(previous_number + dt) &lt; current_lane.waypoints.size()
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c6596520c98efcc5a991288648afa08dc3b0f809" author="h_ohta">
		<msg>Add ROS_WARN</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="3" deleted_lines="0">
				<diff>@@ -544,7 +544,10 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
     double dt = current_velocity.linear.x * ratio &gt; minimum_dt ? current_velocity.linear.x * ratio : minimum_dt;
 
     if(dt &lt; getTwoDimensionalDistance(current_lane.waypoints.at(previous_number).pose.pose.position,current_pose.position))
+    {
+      ROS_WARN("Current_pose is far away from previous closest waypoint. Initilized...");
       return -1;
+    }
 
     idx_vec.reserve(static_cast&lt;uint32_t&gt;(dt));
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5bcd9bd3c699389c4cf8860ba520928f03ae70c1" author="h_ohta">
		<msg>Update visualization</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="191" deleted_lines="35">
				<diff>@@ -44,6 +44,7 @@ LaneSelectNode::LaneSelectNode()
   , is_current_velocity_subscribed_(false)
   , last_change_time_(ros::Time::now())
   , current_state_("LANE_CHANGE")
+  , LANE_SIZE_(1.0)
 {
   initForROS();
 }
@@ -264,7 +265,7 @@ void LaneSelectNode::createCurrentLaneMarker(visualization_msgs::Marker *marker)
   marker-&gt;header.stamp = ros::Time();
   marker-&gt;ns = "current_lane_marker";
 
-  if (current_lane_idx_ == -1)
+  if (current_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
   {
     marker-&gt;action = visualization_msgs::Marker::DELETE;
     return;
@@ -272,23 +273,16 @@ void LaneSelectNode::createCurrentLaneMarker(visualization_msgs::Marker *marker)
 
   marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
   marker-&gt;action = visualization_msgs::Marker::ADD;
-  marker-&gt;scale.x = 1.0;
+  marker-&gt;scale.x = 0.05;
 
   std_msgs::ColorRGBA color_current;
   color_current.b = 1.0;
   color_current.g = 0.7;
-  color_current.a = 0.2;
-
+  color_current.a = 1.0;
   marker-&gt;color = color_current;
 
-  const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps =
-      std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))).waypoints;
+  marker-&gt;points = *createRectangleFromWaypoints(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints, LANE_SIZE_);
 
-  marker-&gt;points.reserve(wps.size());
-  for (const auto &amp;el : wps)
-  {
-    marker-&gt;points.push_back(el.pose.pose.position);
-  }
 }
 
 void LaneSelectNode::createRightLaneMarker(visualization_msgs::Marker *marker)
@@ -297,7 +291,7 @@ void LaneSelectNode::createRightLaneMarker(visualization_msgs::Marker *marker)
   marker-&gt;header.stamp = ros::Time();
   marker-&gt;ns = "right_lane_marker";
 
-  if (right_lane_idx_ == -1)
+  if (right_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
   {
     marker-&gt;action = visualization_msgs::Marker::DELETE;
     return;
@@ -305,30 +299,23 @@ void LaneSelectNode::createRightLaneMarker(visualization_msgs::Marker *marker)
 
   marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
   marker-&gt;action = visualization_msgs::Marker::ADD;
-  marker-&gt;scale.x = 1.0;
+  marker-&gt;scale.x = 0.05;
 
   std_msgs::ColorRGBA color_neighbor;
   color_neighbor.r = 0.5;
   color_neighbor.b = 0.5;
   color_neighbor.g = 0.5;
-  color_neighbor.a = 0.2;
+  color_neighbor.a = 1.0;
 
   std_msgs::ColorRGBA color_neighbor_change;
   color_neighbor_change.b = 0.7;
   color_neighbor_change.g = 1.0;
-  color_neighbor_change.a = 0.2;
+  color_neighbor_change.a = 1.0;
 
   const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
   marker-&gt;color = change_flag == ChangeFlag::right ? color_neighbor_change : color_neighbor;
 
-  const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps =
-      std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(right_lane_idx_))).waypoints;
-
-  marker-&gt;points.reserve(wps.size());
-  for (const auto &amp;el : wps)
-  {
-    marker-&gt;points.push_back(el.pose.pose.position);
-  }
+  marker-&gt;points = *createRectangleFromWaypoints(std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_)).waypoints, LANE_SIZE_);
 }
 
 void LaneSelectNode::createLeftLaneMarker(visualization_msgs::Marker *marker)
@@ -337,7 +324,7 @@ void LaneSelectNode::createLeftLaneMarker(visualization_msgs::Marker *marker)
   marker-&gt;header.stamp = ros::Time();
   marker-&gt;ns = "left_lane_marker";
 
-  if (left_lane_idx_ == -1)
+  if (left_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
   {
     marker-&gt;action = visualization_msgs::Marker::DELETE;
     return;
@@ -345,30 +332,23 @@ void LaneSelectNode::createLeftLaneMarker(visualization_msgs::Marker *marker)
 
   marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
   marker-&gt;action = visualization_msgs::Marker::ADD;
-  marker-&gt;scale.x = 1.0;
+  marker-&gt;scale.x = 0.05;
 
   std_msgs::ColorRGBA color_neighbor;
   color_neighbor.r = 0.5;
   color_neighbor.b = 0.5;
   color_neighbor.g = 0.5;
-  color_neighbor.a = 0.2;
+  color_neighbor.a = 1.0;
 
   std_msgs::ColorRGBA color_neighbor_change;
   color_neighbor_change.b = 0.7;
   color_neighbor_change.g = 1.0;
-  color_neighbor_change.a = 0.2;
+  color_neighbor_change.a = 1.0;
 
   const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
   marker-&gt;color = change_flag == ChangeFlag::left ? color_neighbor_change : color_neighbor;
 
-  const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps =
-      std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(left_lane_idx_))).waypoints;
-
-  marker-&gt;points.reserve(wps.size());
-  for (const auto &amp;el : wps)
-  {
-    marker-&gt;points.push_back(el.pose.pose.position);
-  }
+  marker-&gt;points = *createRectangleFromWaypoints(std::get&lt;0&gt;(tuple_vec_.at(left_lane_idx_)).waypoints, LANE_SIZE_);
 }
 
 void LaneSelectNode::createClosestWaypointsMarker(visualization_msgs::Marker *marker)
@@ -399,6 +379,165 @@ void LaneSelectNode::createClosestWaypointsMarker(visualization_msgs::Marker *ma
   }
 }
 
+std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneFlagMarker()
+{
+  std::unique_ptr&lt;visualization_msgs::Marker&gt; marker(new visualization_msgs::Marker);
+  marker-&gt;header.frame_id = "map";
+  marker-&gt;header.stamp = ros::Time();
+  marker-&gt;ns = "current_lane_flag_marker";
+
+  if (current_lane_idx_ == -1)
+  {
+    marker-&gt;action = visualization_msgs::Marker::DELETE;
+    return marker;
+  }
+
+  std_msgs::ColorRGBA red;
+  red.r = 1.0;
+  red.a = 1.0;
+
+  marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
+  marker-&gt;action = visualization_msgs::Marker::ADD;
+  marker-&gt;scale.x = 0.05;
+  marker-&gt;color = red;
+
+  const uint32_t &amp;start = static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)));
+  const size_t &amp;end = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.size();
+  const auto &amp;wps = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints;
+
+
+  std::vector&lt;waypoint_follower::waypoint&gt; wps_extracted;
+  for (uint32_t i = start; i &lt; end; i++)
+  {
+    if (static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::right)
+    {
+      wps_extracted.push_back(wps.at(i));
+      if (i == end - 1)
+        break;
+
+      if (static_cast&lt;ChangeFlag&gt;(wps.at(i + 1).change_flag) != ChangeFlag::right)
+        break;
+    }
+    else if (static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::left)
+    {
+      wps_extracted.push_back(wps.at(i));
+      if (i == end - 1)
+        break;
+
+      if (static_cast&lt;ChangeFlag&gt;(wps.at(i + 1).change_flag) != ChangeFlag::left)
+        break;
+    }
+  }
+
+  if(wps_extracted.empty())
+  {
+    marker-&gt;action = visualization_msgs::Marker::DELETE;
+    return marker;
+  }
+  marker-&gt;points = *createRectangleFromWaypoints(wps_extracted, LANE_SIZE_* 0.8);
+
+  return marker;
+}
+
+std::unique_ptr&lt;std::vector&lt;geometry_msgs::Point&gt;&gt;
+LaneSelectNode::createRectangleFromWaypoints(const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps, const double &amp;width)
+{
+  std::vector&lt;std::tuple&lt;geometry_msgs::Point, geometry_msgs::Point&gt;&gt; vertex;
+
+  for (const auto &amp;el : wps)
+  {
+    geometry_msgs::Point relative_p1;
+    relative_p1.y = width / 2;
+    geometry_msgs::Point relative_p2;
+    relative_p2.y = -width / 2;
+    vertex.push_back(std::make_tuple(*convertPointIntoWorldCoordinate(relative_p1, el.pose.pose),
+                                     *convertPointIntoWorldCoordinate(relative_p2, el.pose.pose)));
+  }
+
+  std::unique_ptr&lt;std::vector&lt;geometry_msgs::Point&gt;&gt; rectangle(new std::vector&lt;geometry_msgs::Point&gt;);
+  for (const auto &amp;el : vertex)
+    rectangle-&gt;push_back(std::get&lt;0&gt;(el));
+
+  std::reverse(vertex.begin(), vertex.end());
+  for (const auto &amp;el : vertex)
+    rectangle-&gt;push_back(std::get&lt;1&gt;(el));
+  std::reverse(vertex.begin(), vertex.end());
+  rectangle-&gt;push_back(std::get&lt;0&gt;(vertex.at(0)));
+
+  return rectangle;
+}
+
+std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneFlagArrowMarker()
+{
+  std::unique_ptr&lt;visualization_msgs::Marker&gt; marker(new visualization_msgs::Marker);
+
+
+  marker-&gt;header.frame_id = "map";
+  marker-&gt;header.stamp = ros::Time();
+  marker-&gt;ns = "current_lane_flag_arrow_marker";
+
+  if (current_lane_idx_ == -1)
+  {
+    marker-&gt;action = visualization_msgs::Marker::DELETE;
+    return marker;
+  }
+
+  std_msgs::ColorRGBA red;
+  red.r = 1.0;
+  red.a = 1.0;
+
+  //marker-&gt;type = visualization_msgs::Marker::TRIANGLE_LIST;
+  marker-&gt;type = visualization_msgs::Marker::ARROW;
+  marker-&gt;action = visualization_msgs::Marker::ADD;
+  marker-&gt;color = red;
+  marker-&gt;scale.x = 0.25;
+  marker-&gt;scale.y = 0.5;
+
+  const uint32_t &amp;start = static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)));
+  const uint32_t &amp;end = std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))).waypoints.size();
+  const auto &amp;wps = std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))).waypoints;
+
+  std::vector&lt;waypoint_follower::waypoint&gt; wps_extracted;
+  for (uint32_t i = start; i &lt; end; i++)
+  {
+    if (static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::right)
+    {
+      wps_extracted.push_back(wps.at(i));
+      if (i == end - 1)
+        break;
+
+      if (static_cast&lt;ChangeFlag&gt;(wps.at(i + 1).change_flag) != ChangeFlag::right)
+        break;
+    }
+    else if (static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::left)
+    {
+      wps_extracted.push_back(wps.at(i));
+      if (i == end - 1)
+        break;
+
+      if (static_cast&lt;ChangeFlag&gt;(wps.at(i + 1).change_flag) != ChangeFlag::left)
+        break;
+    }
+  }
+
+  if(wps_extracted.empty())
+  {
+    marker-&gt;action = visualization_msgs::Marker::DELETE;
+    return marker;
+  }
+  uint32_t num = static_cast&lt;uint32_t&gt;(wps_extracted.size() / 2.0);
+  geometry_msgs::Point relative_p1;
+  relative_p1.y =
+    static_cast&lt;ChangeFlag&gt;(wps_extracted.at(0).change_flag) == ChangeFlag::right ? -LANE_SIZE_/2 : LANE_SIZE_/2;
+  marker-&gt;points.push_back(*convertPointIntoWorldCoordinate(relative_p1, wps_extracted.at(num).pose.pose));
+  geometry_msgs::Point relative_p2;
+  relative_p2.y = 3 * relative_p1.y;
+  marker-&gt;points.push_back(*convertPointIntoWorldCoordinate(relative_p2, wps_extracted.at(num).pose.pose));
+
+  return marker;
+}
+
+
 void LaneSelectNode::publishVisualizer()
 {
   visualization_msgs::MarkerArray marker_array;
@@ -407,6 +546,9 @@ void LaneSelectNode::publishVisualizer()
   createCurrentLaneMarker(&amp;current_lane_marker);
   marker_array.markers.push_back(current_lane_marker);
 
+  marker_array.markers.push_back(*createCurrentLaneFlagMarker());
+  marker_array.markers.push_back(*createCurrentLaneFlagArrowMarker());
+
   visualization_msgs::Marker right_lane_marker;
   createRightLaneMarker(&amp;right_lane_marker);
   marker_array.markers.push_back(right_lane_marker);
@@ -498,6 +640,20 @@ void convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point,
   pointTFToMsg(tf_p, *output_point);
 }
 
+std::unique_ptr&lt;geometry_msgs::Point&gt; convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose)
+{
+  tf::Transform inverse;
+  tf::poseMsgToTF(pose, inverse);
+
+  tf::Point p;
+  pointMsgToTF(input_point, p);
+  tf::Point tf_p = inverse * p;
+
+  std::unique_ptr&lt;geometry_msgs::Point&gt; tf_point_msg(new geometry_msgs::Point);
+  pointTFToMsg(tf_p, *tf_point_msg);
+  return tf_point_msg;
+}
+
 double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry_msgs::Pose &amp;current_pose)
 {
   tf::Vector3 x_axis(1, 0, 0);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="7" deleted_lines="0">
				<diff>@@ -110,8 +110,13 @@ private:
   void initForROS();
 
   // visualizer
+  const double LANE_SIZE_;
   void publishVisualizer();
   void createCurrentLaneMarker(visualization_msgs::Marker *marker);
+  std::unique_ptr&lt;visualization_msgs::Marker&gt; createCurrentLaneFlagMarker();
+  std::unique_ptr&lt;visualization_msgs::Marker&gt; createCurrentLaneFlagArrowMarker();
+  std::unique_ptr&lt;std::vector&lt;geometry_msgs::Point&gt;&gt;
+  createRectangleFromWaypoints(const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps, const double &amp;width);
   void createRightLaneMarker(visualization_msgs::Marker *marker);
   void createLeftLaneMarker(visualization_msgs::Marker *marker);
   void createClosestWaypointsMarker(visualization_msgs::Marker *marker);
@@ -133,6 +138,8 @@ double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geom
 
 void convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose,
                                         geometry_msgs::Point *output_point);
+
+std::unique_ptr&lt;geometry_msgs::Point&gt; convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose);
 double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry_msgs::Pose &amp;current_pose);
 }
 #endif  // LANE_SELECT_CORE_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9f9ab1bf065b3e8eb3e0395eff94cad56c391e30" author="h_ohta">
		<msg>Refactoring code</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="46" deleted_lines="55">
				<diff>@@ -100,7 +100,7 @@ void LaneSelectNode::processing()
   }
 
   // if closest waypoint on current lane is -1,
-  if (std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))) == -1)
+  if (std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)) == -1)
   {
     current_lane_idx_ = -1;
     right_lane_idx_ = -1;
@@ -113,18 +113,18 @@ void LaneSelectNode::processing()
   ROS_INFO("right_lane_idx: %d", right_lane_idx_);
   ROS_INFO("left_lane_idx: %d", left_lane_idx_);
   ROS_INFO("current change_flag: %d",
-           enumToInteger(std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)))));
+           enumToInteger(std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_))));
 
-  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
+  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
   // if change flag of current_lane is left or right, lane change
   if (current_state_ == "LANE_CHANGE")
   {
     if (change_flag == ChangeFlag::right &amp;&amp; right_lane_idx_ != -1)
-      if (std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(right_lane_idx_))) != -1)
+      if (std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_)) != -1)
         changeLane();
 
     if (change_flag == ChangeFlag::left &amp;&amp; left_lane_idx_ != -1)
-      if (std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(left_lane_idx_))) != -1)
+      if (std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_)) != -1)
         changeLane();
   }
 
@@ -139,7 +139,7 @@ void LaneSelectNode::changeLane()
   if (dt &lt; lane_change_interval_)
     return;
 
-  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
+  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
   current_lane_idx_ = change_flag == ChangeFlag::right ? right_lane_idx_
                                                        : change_flag == ChangeFlag::left ? left_lane_idx_
                                                                                          : current_lane_idx_;
@@ -159,7 +159,7 @@ bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
 
     std::get&lt;2&gt;(el) =
         (std::get&lt;1&gt;(el) != -1)
-            ? static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(el).waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(el))).change_flag)
+            ? static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(el).waypoints.at(std::get&lt;1&gt;(el)).change_flag)
             : ChangeFlag::unknown;
     ROS_INFO("change_flag: %d", enumToInteger(std::get&lt;2&gt;(el)));
   }
@@ -198,20 +198,20 @@ int32_t LaneSelectNode::findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec,
   dist_vec.reserve(idx_vec.size());
   for (const auto &amp;el : idx_vec)
   {
-    uint32_t closest_number = static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(el)));
+    int32_t closest_number = std::get&lt;1&gt;(tuple_vec_.at(el));
     dist_vec.push_back(
         getTwoDimensionalDistance(p, std::get&lt;0&gt;(tuple_vec_.at(el)).waypoints.at(closest_number).pose.pose.position));
   }
   std::vector&lt;double&gt;::iterator itr = std::min_element(dist_vec.begin(), dist_vec.end());
-  return idx_vec.at(static_cast&lt;uint32_t&gt;(std::distance(dist_vec.begin(), itr)));
+  return idx_vec.at(std::distance(dist_vec.begin(), itr));
 }
 
 void LaneSelectNode::findNeighborLanes()
 {
-  uint32_t current_closest_num =
-      static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))));
+  int32_t current_closest_num =
+      std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
   const geometry_msgs::Pose &amp;current_closest_pose =
-      std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))).waypoints.at(current_closest_num).pose.pose;
+      std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.at(current_closest_num).pose.pose;
 
   std::vector&lt;uint32_t&gt; left_lane_idx_vec;
   left_lane_idx_vec.reserve(tuple_vec_.size());
@@ -222,7 +222,7 @@ void LaneSelectNode::findNeighborLanes()
     if (i == static_cast&lt;uint32_t&gt;(current_lane_idx_) || std::get&lt;1&gt;(tuple_vec_.at(i)) == -1)
       continue;
 
-    uint32_t target_num = static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(i)));
+    int32_t target_num = std::get&lt;1&gt;(tuple_vec_.at(i));
     const geometry_msgs::Point &amp;target_p = std::get&lt;0&gt;(tuple_vec_.at(i)).waypoints.at(target_num).pose.pose.position;
 
     geometry_msgs::Point converted_p;
@@ -242,25 +242,20 @@ void LaneSelectNode::findNeighborLanes()
   }
 
   if (!left_lane_idx_vec.empty())
-  {
     left_lane_idx_ = findMostClosestLane(left_lane_idx_vec, current_closest_pose.position);
-  }
   else
-  {
     left_lane_idx_ = -1;
-  }
+
   if (!right_lane_idx_vec.empty())
-  {
     right_lane_idx_ = findMostClosestLane(right_lane_idx_vec, current_closest_pose.position);
-  }
   else
-  {
     right_lane_idx_ = -1;
-  }
+
 }
 
-void LaneSelectNode::createCurrentLaneMarker(visualization_msgs::Marker *marker)
+std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneMarker()
 {
+  std::unique_ptr&lt;visualization_msgs::Marker&gt; marker(new visualization_msgs::Marker);
   marker-&gt;header.frame_id = "map";
   marker-&gt;header.stamp = ros::Time();
   marker-&gt;ns = "current_lane_marker";
@@ -268,7 +263,7 @@ void LaneSelectNode::createCurrentLaneMarker(visualization_msgs::Marker *marker)
   if (current_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
   {
     marker-&gt;action = visualization_msgs::Marker::DELETE;
-    return;
+    return marker;
   }
 
   marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
@@ -283,10 +278,12 @@ void LaneSelectNode::createCurrentLaneMarker(visualization_msgs::Marker *marker)
 
   marker-&gt;points = *createRectangleFromWaypoints(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints, LANE_SIZE_);
 
+  return marker;
 }
 
-void LaneSelectNode::createRightLaneMarker(visualization_msgs::Marker *marker)
+std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createRightLaneMarker()
 {
+  std::unique_ptr&lt;visualization_msgs::Marker&gt; marker(new visualization_msgs::Marker);
   marker-&gt;header.frame_id = "map";
   marker-&gt;header.stamp = ros::Time();
   marker-&gt;ns = "right_lane_marker";
@@ -294,7 +291,7 @@ void LaneSelectNode::createRightLaneMarker(visualization_msgs::Marker *marker)
   if (right_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
   {
     marker-&gt;action = visualization_msgs::Marker::DELETE;
-    return;
+    return marker;
   }
 
   marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
@@ -312,14 +309,17 @@ void LaneSelectNode::createRightLaneMarker(visualization_msgs::Marker *marker)
   color_neighbor_change.g = 1.0;
   color_neighbor_change.a = 1.0;
 
-  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
+  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
   marker-&gt;color = change_flag == ChangeFlag::right ? color_neighbor_change : color_neighbor;
 
   marker-&gt;points = *createRectangleFromWaypoints(std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_)).waypoints, LANE_SIZE_);
+
+  return marker;
 }
 
-void LaneSelectNode::createLeftLaneMarker(visualization_msgs::Marker *marker)
+std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createLeftLaneMarker()
 {
+  std::unique_ptr&lt;visualization_msgs::Marker&gt; marker(new visualization_msgs::Marker);
   marker-&gt;header.frame_id = "map";
   marker-&gt;header.stamp = ros::Time();
   marker-&gt;ns = "left_lane_marker";
@@ -327,7 +327,7 @@ void LaneSelectNode::createLeftLaneMarker(visualization_msgs::Marker *marker)
   if (left_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
   {
     marker-&gt;action = visualization_msgs::Marker::DELETE;
-    return;
+    return marker;
   }
 
   marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
@@ -345,14 +345,17 @@ void LaneSelectNode::createLeftLaneMarker(visualization_msgs::Marker *marker)
   color_neighbor_change.g = 1.0;
   color_neighbor_change.a = 1.0;
 
-  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
+  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
   marker-&gt;color = change_flag == ChangeFlag::left ? color_neighbor_change : color_neighbor;
 
   marker-&gt;points = *createRectangleFromWaypoints(std::get&lt;0&gt;(tuple_vec_.at(left_lane_idx_)).waypoints, LANE_SIZE_);
+
+  return marker;
 }
 
-void LaneSelectNode::createClosestWaypointsMarker(visualization_msgs::Marker *marker)
+std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createClosestWaypointsMarker()
 {
+  std::unique_ptr&lt;visualization_msgs::Marker&gt; marker(new visualization_msgs::Marker);
   std_msgs::ColorRGBA color_closest_wp;
   color_closest_wp.r = 1.0;
   color_closest_wp.b = 1.0;
@@ -374,9 +377,11 @@ void LaneSelectNode::createClosestWaypointsMarker(visualization_msgs::Marker *ma
       continue;
 
     marker-&gt;points.push_back(std::get&lt;0&gt;(tuple_vec_.at(i))
-                                 .waypoints.at(static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(i))))
+                                 .waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(i)))
                                  .pose.pose.position);
   }
+
+  return marker;
 }
 
 std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneFlagMarker()
@@ -401,7 +406,7 @@ std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneFla
   marker-&gt;scale.x = 0.05;
   marker-&gt;color = red;
 
-  const uint32_t &amp;start = static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)));
+  const int32_t &amp;start = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
   const size_t &amp;end = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.size();
   const auto &amp;wps = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints;
 
@@ -486,16 +491,15 @@ std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneFla
   red.r = 1.0;
   red.a = 1.0;
 
-  //marker-&gt;type = visualization_msgs::Marker::TRIANGLE_LIST;
   marker-&gt;type = visualization_msgs::Marker::ARROW;
   marker-&gt;action = visualization_msgs::Marker::ADD;
   marker-&gt;color = red;
   marker-&gt;scale.x = 0.25;
   marker-&gt;scale.y = 0.5;
 
-  const uint32_t &amp;start = static_cast&lt;uint32_t&gt;(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)));
-  const uint32_t &amp;end = std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))).waypoints.size();
-  const auto &amp;wps = std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_))).waypoints;
+  const int32_t &amp;start = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
+  const size_t &amp;end = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.size();
+  const auto &amp;wps = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints;
 
   std::vector&lt;waypoint_follower::waypoint&gt; wps_extracted;
   for (uint32_t i = start; i &lt; end; i++)
@@ -537,29 +541,16 @@ std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneFla
   return marker;
 }
 
-
 void LaneSelectNode::publishVisualizer()
 {
   visualization_msgs::MarkerArray marker_array;
 
-  visualization_msgs::Marker current_lane_marker;
-  createCurrentLaneMarker(&amp;current_lane_marker);
-  marker_array.markers.push_back(current_lane_marker);
-
+  marker_array.markers.push_back(*createCurrentLaneMarker());
   marker_array.markers.push_back(*createCurrentLaneFlagMarker());
   marker_array.markers.push_back(*createCurrentLaneFlagArrowMarker());
-
-  visualization_msgs::Marker right_lane_marker;
-  createRightLaneMarker(&amp;right_lane_marker);
-  marker_array.markers.push_back(right_lane_marker);
-
-  visualization_msgs::Marker left_lane_marker;
-  createLeftLaneMarker(&amp;left_lane_marker);
-  marker_array.markers.push_back(left_lane_marker);
-
-  visualization_msgs::Marker closest_waypoints_marker;
-  createClosestWaypointsMarker(&amp;closest_waypoints_marker);
-  marker_array.markers.push_back(closest_waypoints_marker);
+  marker_array.markers.push_back(*createRightLaneMarker());
+  marker_array.markers.push_back(*createLeftLaneMarker());
+  marker_array.markers.push_back(*createClosestWaypointsMarker());
 
   vis_pub1_.publish(marker_array);
 }
@@ -568,12 +559,12 @@ void LaneSelectNode::publish()
 {
   // publish current global lane
   waypoint_follower::lane global_lane;
-  global_lane = std::get&lt;0&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
+  global_lane = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_));
   pub1_.publish(global_lane);
 
   // publish closest waypoint
   std_msgs::Int32 closest_waypoint;
-  closest_waypoint.data = std::get&lt;1&gt;(tuple_vec_.at(static_cast&lt;uint32_t&gt;(current_lane_idx_)));
+  closest_waypoint.data = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
   pub2_.publish(closest_waypoint);
 
   is_current_pose_subscribed_ = false;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="4" deleted_lines="4">
				<diff>@@ -112,14 +112,14 @@ private:
   // visualizer
   const double LANE_SIZE_;
   void publishVisualizer();
-  void createCurrentLaneMarker(visualization_msgs::Marker *marker);
+  std::unique_ptr&lt;visualization_msgs::Marker&gt; createCurrentLaneMarker();
   std::unique_ptr&lt;visualization_msgs::Marker&gt; createCurrentLaneFlagMarker();
   std::unique_ptr&lt;visualization_msgs::Marker&gt; createCurrentLaneFlagArrowMarker();
   std::unique_ptr&lt;std::vector&lt;geometry_msgs::Point&gt;&gt;
   createRectangleFromWaypoints(const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps, const double &amp;width);
-  void createRightLaneMarker(visualization_msgs::Marker *marker);
-  void createLeftLaneMarker(visualization_msgs::Marker *marker);
-  void createClosestWaypointsMarker(visualization_msgs::Marker *marker);
+  std::unique_ptr&lt;visualization_msgs::Marker&gt; createRightLaneMarker();
+  std::unique_ptr&lt;visualization_msgs::Marker&gt; createLeftLaneMarker();
+  std::unique_ptr&lt;visualization_msgs::Marker&gt; createClosestWaypointsMarker();
 
   // functions
   void processing();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4b9375296283c3787b97b6fa7dc7c12c048f8b92" author="h_ohta">
		<msg>Apply clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="18" deleted_lines="23">
				<diff>@@ -112,8 +112,7 @@ void LaneSelectNode::processing()
   ROS_INFO("current_lane_idx: %d", current_lane_idx_);
   ROS_INFO("right_lane_idx: %d", right_lane_idx_);
   ROS_INFO("left_lane_idx: %d", left_lane_idx_);
-  ROS_INFO("current change_flag: %d",
-           enumToInteger(std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_))));
+  ROS_INFO("current change_flag: %d", enumToInteger(std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_))));
 
   const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
   // if change flag of current_lane is left or right, lane change
@@ -140,9 +139,9 @@ void LaneSelectNode::changeLane()
     return;
 
   const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
-  current_lane_idx_ = change_flag == ChangeFlag::right ? right_lane_idx_
-                                                       : change_flag == ChangeFlag::left ? left_lane_idx_
-                                                                                         : current_lane_idx_;
+  current_lane_idx_ = change_flag == ChangeFlag::right ? right_lane_idx_ : change_flag == ChangeFlag::left
+                                                                               ? left_lane_idx_
+                                                                               : current_lane_idx_;
 
   findNeighborLanes();
 
@@ -157,10 +156,9 @@ bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
         getClosestWaypointNumber(std::get&lt;0&gt;(el), current_pose_.pose, current_velocity_.twist, std::get&lt;1&gt;(el));
     ROS_INFO("closest: %d", std::get&lt;1&gt;(el));
 
-    std::get&lt;2&gt;(el) =
-        (std::get&lt;1&gt;(el) != -1)
-            ? static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(el).waypoints.at(std::get&lt;1&gt;(el)).change_flag)
-            : ChangeFlag::unknown;
+    std::get&lt;2&gt;(el) = (std::get&lt;1&gt;(el) != -1)
+                          ? static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(el).waypoints.at(std::get&lt;1&gt;(el)).change_flag)
+                          : ChangeFlag::unknown;
     ROS_INFO("change_flag: %d", enumToInteger(std::get&lt;2&gt;(el)));
   }
 
@@ -208,8 +206,7 @@ int32_t LaneSelectNode::findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec,
 
 void LaneSelectNode::findNeighborLanes()
 {
-  int32_t current_closest_num =
-      std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
+  int32_t current_closest_num = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
   const geometry_msgs::Pose &amp;current_closest_pose =
       std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.at(current_closest_num).pose.pose;
 
@@ -250,7 +247,6 @@ void LaneSelectNode::findNeighborLanes()
     right_lane_idx_ = findMostClosestLane(right_lane_idx_vec, current_closest_pose.position);
   else
     right_lane_idx_ = -1;
-
 }
 
 std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneMarker()
@@ -376,9 +372,8 @@ std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createClosestWaypoin
     if (std::get&lt;1&gt;(tuple_vec_.at(i)) == -1)
       continue;
 
-    marker-&gt;points.push_back(std::get&lt;0&gt;(tuple_vec_.at(i))
-                                 .waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(i)))
-                                 .pose.pose.position);
+    marker-&gt;points.push_back(
+        std::get&lt;0&gt;(tuple_vec_.at(i)).waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(i))).pose.pose.position);
   }
 
   return marker;
@@ -410,7 +405,6 @@ std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneFla
   const size_t &amp;end = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.size();
   const auto &amp;wps = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints;
 
-
   std::vector&lt;waypoint_follower::waypoint&gt; wps_extracted;
   for (uint32_t i = start; i &lt; end; i++)
   {
@@ -434,12 +428,12 @@ std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneFla
     }
   }
 
-  if(wps_extracted.empty())
+  if (wps_extracted.empty())
   {
     marker-&gt;action = visualization_msgs::Marker::DELETE;
     return marker;
   }
-  marker-&gt;points = *createRectangleFromWaypoints(wps_extracted, LANE_SIZE_* 0.8);
+  marker-&gt;points = *createRectangleFromWaypoints(wps_extracted, LANE_SIZE_ * 0.8);
 
   return marker;
 }
@@ -476,7 +470,6 @@ std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneFla
 {
   std::unique_ptr&lt;visualization_msgs::Marker&gt; marker(new visualization_msgs::Marker);
 
-
   marker-&gt;header.frame_id = "map";
   marker-&gt;header.stamp = ros::Time();
   marker-&gt;ns = "current_lane_flag_arrow_marker";
@@ -524,7 +517,7 @@ std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneFla
     }
   }
 
-  if(wps_extracted.empty())
+  if (wps_extracted.empty())
   {
     marker-&gt;action = visualization_msgs::Marker::DELETE;
     return marker;
@@ -532,7 +525,7 @@ std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneFla
   uint32_t num = static_cast&lt;uint32_t&gt;(wps_extracted.size() / 2.0);
   geometry_msgs::Point relative_p1;
   relative_p1.y =
-    static_cast&lt;ChangeFlag&gt;(wps_extracted.at(0).change_flag) == ChangeFlag::right ? -LANE_SIZE_/2 : LANE_SIZE_/2;
+      static_cast&lt;ChangeFlag&gt;(wps_extracted.at(0).change_flag) == ChangeFlag::right ? -LANE_SIZE_ / 2 : LANE_SIZE_ / 2;
   marker-&gt;points.push_back(*convertPointIntoWorldCoordinate(relative_p1, wps_extracted.at(num).pose.pose));
   geometry_msgs::Point relative_p2;
   relative_p2.y = 3 * relative_p1.y;
@@ -631,7 +624,8 @@ void convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point,
   pointTFToMsg(tf_p, *output_point);
 }
 
-std::unique_ptr&lt;geometry_msgs::Point&gt; convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose)
+std::unique_ptr&lt;geometry_msgs::Point&gt; convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point,
+                                                                      const geometry_msgs::Pose &amp;pose)
 {
   tf::Transform inverse;
   tf::poseMsgToTF(pose, inverse);
@@ -690,7 +684,8 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
     double minimum_dt = 2.0;
     double dt = current_velocity.linear.x * ratio &gt; minimum_dt ? current_velocity.linear.x * ratio : minimum_dt;
 
-    if(dt &lt; getTwoDimensionalDistance(current_lane.waypoints.at(previous_number).pose.pose.position,current_pose.position))
+    if (dt &lt;
+        getTwoDimensionalDistance(current_lane.waypoints.at(previous_number).pose.pose.position, current_pose.position))
     {
       ROS_WARN("Current_pose is far away from previous closest waypoint. Initilized...");
       return -1;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="4" deleted_lines="2">
				<diff>@@ -88,7 +88,8 @@ private:
   int32_t current_lane_idx_;  // the index of the lane we are driving
   int32_t right_lane_idx_;
   int32_t left_lane_idx_;
-  std::vector&lt;std::tuple&lt;waypoint_follower::lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint, change_flag
+  std::vector&lt;std::tuple&lt;waypoint_follower::lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint,
+                                                                                     // change_flag
   bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_;
   ros::Time last_change_time_;
 
@@ -139,7 +140,8 @@ double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geom
 void convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose,
                                         geometry_msgs::Point *output_point);
 
-std::unique_ptr&lt;geometry_msgs::Point&gt; convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose);
+std::unique_ptr&lt;geometry_msgs::Point&gt; convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point,
+                                                                      const geometry_msgs::Pose &amp;pose);
 double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry_msgs::Pose &amp;current_pose);
 }
 #endif  // LANE_SELECT_CORE_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2413da5df00d40d8f8ad019a6a9221c2206f2c02" author="h_ohta">
		<msg>Rewrite for applying new template</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" added_lines="377" deleted_lines="44">
				<diff>@@ -28,64 +28,397 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include "pure_pursuit/pure_pursuit_core.h"
-#include "pure_pursuit/pure_pursuit_viz.h"
+#include "pure_pursuit.h"
 
-constexpr int LOOP_RATE = 30; //processing frequency
+namespace waypoint_follower
+{
+// Constructor
+PurePursuit::PurePursuit()
+  : RADIUS_MAX_(9e10)
+  , KAPPA_MIN_(1 / RADIUS_MAX_)
+  , is_linear_interpolation_(false)
+  , param_flag_(0)
+  , const_lookahead_distance_(4.0)
+  , initial_velocity_(5.0)
+  , lookahead_distance_calc_ratio_(2.0)
+  , minimum_lookahead_distance_(6.0)
+  , displacement_threshold_(0.2)
+  , relative_angle_threshold_(10)
+  , is_waypoint_set_(false)
+  , is_pose_set_(false)
+  , is_velocity_set_(false)
+  , next_waypoint_number_(-1)
+  , lookahead_distance_(0)
+{
+}
+
+// Destructor
+PurePursuit::~PurePursuit()
+{
+}
+
+void PurePursuit::getConfigForROS(const runtime_manager::ConfigWaypointFollowerConstPtr &amp;config)
+{
+  param_flag_ = config-&gt;param_flag;
+  const_lookahead_distance_ = config-&gt;lookahead_distance;
+  initial_velocity_ = config-&gt;velocity;
+  lookahead_distance_calc_ratio_ = config-&gt;lookahead_ratio;
+  minimum_lookahead_distance_ = config-&gt;minimum_lookahead_distance;
+  displacement_threshold_ = config-&gt;displacement_threshold;
+  relative_angle_threshold_ = config-&gt;relative_angle_threshold;
+}
+
+void PurePursuit::getCurrentPoseForROS(const geometry_msgs::PoseStampedConstPtr &amp;msg)
+{
+  current_pose_.header = msg-&gt;header;
+  current_pose_.pose = msg-&gt;pose;
+  is_pose_set_ = true;
+}
+
+void PurePursuit::getCurrentVelocityForROS(const geometry_msgs::TwistStampedConstPtr &amp;msg)
+{
+  current_velocity_ = *msg;
+  is_velocity_set_ = true;
+}
+
+void PurePursuit::getWayPointsForROS(const waypoint_follower::laneConstPtr &amp;msg)
+{
+  current_waypoints_.setPath(*msg);
+  is_waypoint_set_ = true;
+  // ROS_INFO_STREAM("waypoint subscribed");
+}
+
+void PurePursuit::getLinearInterpolationParameter(const bool &amp;param)
+{
+  is_linear_interpolation_ = param;
+}
+
+double PurePursuit::getCmdVelocity(int waypoint) const
+{
+  if (param_flag_ == static_cast&lt;int&gt;(Mode::dialog))
+  {
+    ROS_INFO_STREAM("dialog : " &lt;&lt; initial_velocity_ &lt;&lt; " km/h (" &lt;&lt; kmph2mps(initial_velocity_) &lt;&lt; " m/s )");
+    return kmph2mps(initial_velocity_);
+  }
+
+  if (current_waypoints_.isEmpty())
+  {
+    ROS_INFO_STREAM("waypoint : not loaded path");
+    return 0;
+  }
 
+  double velocity = current_waypoints_.getWaypointVelocityMPS(waypoint);
+  // ROS_INFO_STREAM("waypoint : " &lt;&lt; mps2kmph(velocity) &lt;&lt; " km/h ( " &lt;&lt; velocity &lt;&lt; "m/s )");
+  return velocity;
+}
+
+void PurePursuit::calcLookaheadDistance(int waypoint)
+{
+  if (param_flag_ == static_cast&lt;int&gt;(Mode::dialog))
+  {
+    lookahead_distance_ = const_lookahead_distance_;
+    return;
+  }
+
+  double current_velocity_mps = current_velocity_.twist.linear.x;
+  double maximum_lookahead_distance = current_velocity_mps * 10;
+  double ld = current_velocity_mps * lookahead_distance_calc_ratio_;
+
+  lookahead_distance_ = ld &lt; minimum_lookahead_distance_
+                            ? minimum_lookahead_distance_
+                            : ld &gt; maximum_lookahead_distance ? maximum_lookahead_distance : ld;
+
+  ROS_INFO("lookahead distance: %f", lookahead_distance_);
+
+  return;
+}
+
+double PurePursuit::calcCurvature(geometry_msgs::Point target) const
+{
+  double kappa;
+  double denominator = pow(getPlaneDistance(target, current_pose_.pose.position), 2);
+  double numerator = 2 * calcRelativeCoordinate(target, current_pose_.pose).y;
+
+  if (denominator != 0)
+    kappa = numerator / denominator;
+  else
+  {
+    if (numerator &gt; 0)
+      kappa = KAPPA_MIN_;
+    else
+      kappa = -KAPPA_MIN_;
+  }
+  ROS_INFO("kappa : %lf", kappa);
+  return kappa;
+}
 
-int main(int argc, char **argv)
+// linear interpolation of next target
+bool PurePursuit::interpolateNextTarget(int next_waypoint, geometry_msgs::Point *next_target) const
 {
+  constexpr double ERROR = pow(10, -5);  // 0.00001
+
+  int path_size = static_cast&lt;int&gt;(current_waypoints_.getSize());
+  if (next_waypoint == path_size - 1)
+  {
+    *next_target = current_waypoints_.getWaypointPosition(next_waypoint);
+    return true;
+  }
+  double search_radius = lookahead_distance_;
+  geometry_msgs::Point zero_p;
+  geometry_msgs::Point end = current_waypoints_.getWaypointPosition(next_waypoint);
+  geometry_msgs::Point start = current_waypoints_.getWaypointPosition(next_waypoint - 1);
+
+  // let the linear equation be "ax + by + c = 0"
+  // if there are two points (x1,y1) , (x2,y2), a = "y2-y1, b = "(-1) * x2 - x1" ,c = "(-1) * (y2-y1)x1 + (x2-x1)y1"
+  double a = 0;
+  double b = 0;
+  double c = 0;
+  double get_linear_flag = getLinearEquation(start, end, &amp;a, &amp;b, &amp;c);
+  if (!get_linear_flag)
+    return false;
+
+  // let the center of circle be "(x0,y0)", in my code , the center of circle is vehicle position
+  // the distance  "d" between the foot of a perpendicular line and the center of circle is ...
+  //    | a * x0 + b * y0 + c |
+  // d = -------------------------------
+  //          ( a~2 + b~2)
+  double d = getDistanceBetweenLineAndPoint(current_pose_.pose.position, a, b, c);
 
+  // ROS_INFO("a : %lf ", a);
+  // ROS_INFO("b : %lf ", b);
+  // ROS_INFO("c : %lf ", c);
+  // ROS_INFO("distance : %lf ", d);
 
-  // set up ros
-  ros::init(argc, argv, "pure_pursuit");
+  if (d &gt; search_radius)
+    return false;
 
-  ros::NodeHandle nh;
-  ros::NodeHandle private_nh("~");
+  // unit vector of point 'start' to point 'end'
+  tf::Vector3 v((end.x - start.x), (end.y - start.y), 0);
+  tf::Vector3 unit_v = v.normalize();
 
-  bool linear_interpolate_mode;
-  private_nh.param("linear_interpolate_mode", linear_interpolate_mode, bool(true));
-  ROS_INFO_STREAM("linear_interpolate_mode : " &lt;&lt; linear_interpolate_mode);
+  // normal unit vectors of v
+  tf::Vector3 unit_w1 = rotateUnitVector(unit_v, 90);   // rotate to counter clockwise 90 degree
+  tf::Vector3 unit_w2 = rotateUnitVector(unit_v, -90);  // rotate to counter clockwise 90 degree
 
-  waypoint_follower::PurePursuit pp(linear_interpolate_mode);
+  // the foot of a perpendicular line
+  geometry_msgs::Point h1;
+  h1.x = current_pose_.pose.position.x + d * unit_w1.getX();
+  h1.y = current_pose_.pose.position.y + d * unit_w1.getY();
+  h1.z = current_pose_.pose.position.z;
 
-  ROS_INFO("set publisher...");
-  // publish topic
-  ros::Publisher cmd_velocity_publisher = nh.advertise&lt;geometry_msgs::TwistStamped&gt;("twist_raw", 10);
-  ros::Publisher vis_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("next_waypoint_mark", 0);
-  //ros::Publisher stat_pub = nh.advertise&lt;std_msgs::Bool&gt;("wf_stat", 0);
-  ros::Publisher target_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("next_target_mark", 0);
-  ros::Publisher search_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("search_circle_mark", 0);
-  ros::Publisher line_point_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("line_point_mark", 0);  // debug tool
-  ros::Publisher traj_circle_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("trajectory_circle_mark", 0);
+  geometry_msgs::Point h2;
+  h2.x = current_pose_.pose.position.x + d * unit_w2.getX();
+  h2.y = current_pose_.pose.position.y + d * unit_w2.getY();
+  h2.z = current_pose_.pose.position.z;
 
-  ROS_INFO("set subscriber...");
-  // subscribe topic
-  ros::Subscriber waypoint_subscriber =
-      nh.subscribe("final_waypoints", 10, &amp;waypoint_follower::PurePursuit::callbackFromWayPoints, &amp;pp);
-  ros::Subscriber ndt_subscriber =
-      nh.subscribe("current_pose", 10, &amp;waypoint_follower::PurePursuit::callbackFromCurrentPose, &amp;pp);
-  ros::Subscriber config_subscriber =
-      nh.subscribe("config/waypoint_follower", 10, &amp;waypoint_follower::PurePursuit::callbackFromConfig, &amp;pp);
-  ros::Subscriber est_twist_subscriber =
-      nh.subscribe("current_velocity", 10, &amp;waypoint_follower::PurePursuit::callbackFromCurrentVelocity, &amp;pp);
+  // ROS_INFO("error : %lf", error);
+  // ROS_INFO("whether h1 on line : %lf", h1.y - (slope * h1.x + intercept));
+  // ROS_INFO("whether h2 on line : %lf", h2.y - (slope * h2.x + intercept));
 
-  ROS_INFO_STREAM("pure pursuit start");
-  ros::Rate loop_rate(LOOP_RATE);
-  while (ros::ok())
+  // check which of two foot of a perpendicular line is on the line equation
+  geometry_msgs::Point h;
+  if (fabs(a * h1.x + b * h1.y + c) &lt; ERROR)
   {
-    ros::spinOnce();
-    cmd_velocity_publisher.publish(pp.go());
+    h = h1;
+    //   ROS_INFO("use h1");
+  }
+  else if (fabs(a * h2.x + b * h2.y + c) &lt; ERROR)
+  {
+    //   ROS_INFO("use h2");
+    h = h2;
+  }
+  else
+  {
+    return false;
+  }
 
-    // for visualization with Rviz
-    vis_pub.publish(waypoint_follower::displayNextWaypoint(pp.getPoseOfNextWaypoint()));
-    search_pub.publish(waypoint_follower::displaySearchRadius(pp.getCurrentPose().position, pp.getLookaheadDistance()));
-    target_pub.publish(waypoint_follower::displayNextTarget(pp.getPoseOfNextTarget()));
-    traj_circle_pub.publish(waypoint_follower::displayTrajectoryCircle(
-        waypoint_follower::generateTrajectoryCircle(pp.getPoseOfNextTarget(), pp.getCurrentPose())));
-    loop_rate.sleep();
+  // get intersection[s]
+  // if there is a intersection
+  if (d == search_radius)
+  {
+    *next_target = h;
+    return true;
   }
+  else
+  {
+    // if there are two intersection
+    // get intersection in front of vehicle
+    double s = sqrt(pow(search_radius, 2) - pow(d, 2));
+    geometry_msgs::Point target1;
+    target1.x = h.x + s * unit_v.getX();
+    target1.y = h.y + s * unit_v.getY();
+    target1.z = current_pose_.pose.position.z;
+
+    geometry_msgs::Point target2;
+    target2.x = h.x - s * unit_v.getX();
+    target2.y = h.y - s * unit_v.getY();
+    target2.z = current_pose_.pose.position.z;
+
+    // ROS_INFO("target1 : ( %lf , %lf , %lf)", target1.x, target1.y, target1.z);
+    // ROS_INFO("target2 : ( %lf , %lf , %lf)", target2.x, target2.y, target2.z);
+    // displayLinePoint(a, b, c, target1, target2, h);  // debug tool
+
+    // check intersection is between end and start
+    double interval = getPlaneDistance(end, start);
+    if (getPlaneDistance(target1, end) &lt; interval)
+    {
+      // ROS_INFO("result : target1");
+      *next_target = target1;
+      return true;
+    }
+    else if (getPlaneDistance(target2, end) &lt; interval)
+    {
+      // ROS_INFO("result : target2");
+      *next_target = target2;
+      return true;
+    }
+    else
+    {
+      // ROS_INFO("result : false ");
+      return false;
+    }
+  }
+}
+
+bool PurePursuit::verifyFollowing() const
+{
+  double a = 0;
+  double b = 0;
+  double c = 0;
+  getLinearEquation(current_waypoints_.getWaypointPosition(1), current_waypoints_.getWaypointPosition(2), &amp;a, &amp;b, &amp;c);
+  double displacement = getDistanceBetweenLineAndPoint(current_pose_.pose.position, a, b, c);
+  double relative_angle = getRelativeAngle(current_waypoints_.getWaypointPose(1), current_pose_.pose);
+  // ROS_INFO("side diff : %lf , angle diff : %lf",displacement,relative_angle);
+  if (displacement &lt; displacement_threshold_ || relative_angle &lt; relative_angle_threshold_)
+  {
+    // ROS_INFO("Following : True");
+    return true;
+  }
+  else
+  {
+    // ROS_INFO("Following : False");
+    return false;
+  }
+}
+
+geometry_msgs::Twist PurePursuit::calcTwist(double curvature, double cmd_velocity) const
+{
+  // verify whether vehicle is following the path
+  bool following_flag = verifyFollowing();
+  static double prev_angular_velocity = 0;
+
+  geometry_msgs::Twist twist;
+  twist.linear.x = cmd_velocity;
+  if (!following_flag)
+  {
+    twist.angular.z = current_velocity_.twist.linear.x * curvature;
+  }
+  else
+  {
+    twist.angular.z = prev_angular_velocity;
+  }
+
+  prev_angular_velocity = twist.angular.z;
+  return twist;
+}
+
+void PurePursuit::getNextWaypoint()
+{
+  int path_size = static_cast&lt;int&gt;(current_waypoints_.getSize());
+
+  // if waypoints are not given, do nothing.
+  if (path_size == 0)
+  {
+    next_waypoint_number_ = -1;
+    return;
+  }
+
+  // look for the next waypoint.
+  for (int i = 0; i &lt; path_size; i++)
+  {
+    // if search waypoint is the last
+    if (i == (path_size - 1))
+    {
+      ROS_INFO("search waypoint is the last");
+      next_waypoint_number_ = i;
+      return;
+    }
+
+    // if there exists an effective waypoint
+    if (getPlaneDistance(current_waypoints_.getWaypointPosition(i), current_pose_.pose.position) &gt; lookahead_distance_)
+    {
+      next_waypoint_number_ = i;
+      return;
+    }
+  }
+
+  // if this program reaches here , it means we lost the waypoint!
+  next_waypoint_number_ = -1;
+  return;
+}
+
+geometry_msgs::TwistStamped PurePursuit::outputZero() const
+{
+  geometry_msgs::TwistStamped twist;
+  twist.twist.linear.x = 0;
+  twist.twist.angular.z = 0;
+  twist.header.stamp = ros::Time::now();
+  return twist;
+}
+
+geometry_msgs::TwistStamped PurePursuit::outputTwist(geometry_msgs::Twist t) const
+{
+  geometry_msgs::TwistStamped twist;
+  twist.twist = t;
+  twist.header.stamp = ros::Time::now();
+  return twist;
+}
+
+geometry_msgs::TwistStamped PurePursuit::go()
+{
+  if (!is_pose_set_ || !is_waypoint_set_ || !is_velocity_set_)
+  {
+    ROS_INFO("somethins is missing... ");
+    return outputZero();
+  }
+
+  calcLookaheadDistance(1);
+  // search next waypoint
+  getNextWaypoint();
+  if (next_waypoint_number_ == -1)
+  {
+    ROS_INFO("lost next waypoint");
+    return outputZero();
+  }
+
+  // if g_linear_interpolate_mode is false or next waypoint is first or last
+  if (!is_linear_interpolation_ || next_waypoint_number_ == 0 ||
+      next_waypoint_number_ == (static_cast&lt;int&gt;(current_waypoints_.getSize() - 1)))
+  {
+    next_target_position_ = current_waypoints_.getWaypointPosition(next_waypoint_number_);
+    return outputTwist(calcTwist(calcCurvature(next_target_position_), getCmdVelocity(0)));
+  }
+
+  // linear interpolation and calculate angular velocity
+  bool interpolation = interpolateNextTarget(next_waypoint_number_, &amp;next_target_position_);
+
+  if (!interpolation)
+  {
+    ROS_INFO_STREAM("lost target! ");
+    return outputZero();
+  }
+
+  // ROS_INFO("next_target : ( %lf , %lf , %lf)", next_target.x, next_target.y,next_target.z);
+
+  return outputTwist(calcTwist(calcCurvature(next_target_position_), getCmdVelocity(0)));
+
+// ROS_INFO("linear : %lf, angular : %lf",twist.twist.linear.x,twist.twist.angular.z);
 
-  return 0;
+#ifdef LOG
+  std::ofstream ofs("/tmp/pure_pursuit.log", std::ios::app);
+  ofs &lt;&lt; _current_waypoints.getWaypointPosition(next_waypoint).x &lt;&lt; " "
+      &lt;&lt; _current_waypoints.getWaypointPosition(next_waypoint).y &lt;&lt; " " &lt;&lt; next_target.x &lt;&lt; " " &lt;&lt; next_target.y
+      &lt;&lt; std::endl;
+#endif
 }
+}  // waypoint_follower
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\include\pure_pursuit\pure_pursuit_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" added_lines="53" deleted_lines="72">
				<diff>@@ -28,52 +28,83 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#ifndef PURE_PURSUIT_CORE_H
-#define PURE_PURSUIT_CORE_H
+#ifndef PURE_PURSUIT_H
+#define PURE_PURSUIT_H
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
-#include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
-#include "runtime_manager/ConfigWaypointFollower.h"
-#include &lt;visualization_msgs/Marker.h&gt;
-// C++ includes
-#include &lt;memory&gt;
-#include "waypoint_follower/libwaypoint_follower.h"
+#include &lt;geometry_msgs/TwistStamped.h&gt;
 
+// User defined includes
+#include "waypoint_follower/lane.h"
+#include "waypoint_follower/libwaypoint_follower.h"
+#include "runtime_manager/ConfigWaypointFollower.h"
 
+namespace waypoint_follower
+{
 enum class Mode
 {
   waypoint,
   dialog
 };
 
-namespace waypoint_follower
-{
 class PurePursuit
 {
-private:
+public:
+  PurePursuit();
+  ~PurePursuit();
+
+  // for getting data from ROS
+  void getConfigForROS(const runtime_manager::ConfigWaypointFollowerConstPtr &amp;config);
+  void getCurrentPoseForROS(const geometry_msgs::PoseStampedConstPtr &amp;msg);
+  void getCurrentVelocityForROS(const geometry_msgs::TwistStampedConstPtr &amp;msg);
+  void getWayPointsForROS(const waypoint_follower::laneConstPtr &amp;msg);
+  void getLinearInterpolationParameter(const bool &amp;param);
+
+  // for debug on ROS
+  geometry_msgs::Point getPoseOfNextWaypoint() const
+  {
+    return current_waypoints_.getWaypointPosition(next_waypoint_number_);
+  }
+  geometry_msgs::Point getPoseOfNextTarget() const
+  {
+    return next_target_position_;
+  }
+  geometry_msgs::Pose getCurrentPose() const
+  {
+    return current_pose_.pose;
+  }
 
-  //constant
+  double getLookaheadDistance() const
+  {
+    return lookahead_distance_;
+  }
+  // processing
+  geometry_msgs::TwistStamped go();
+
+private:
+  // constant
   const double RADIUS_MAX_;
   const double KAPPA_MIN_;
 
-  bool linear_interpolate_;
+  // variables
+  bool is_linear_interpolation_;
 
   // config topic
-  int param_flag_;              // 0 = waypoint, 1 = Dialog
+  int param_flag_;                   // 0 = waypoint, 1 = Dialog
   double const_lookahead_distance_;  // meter
-  double initial_velocity_;     // km/h
+  double initial_velocity_;          // km/h
   double lookahead_distance_calc_ratio_;
   double minimum_lookahead_distance_;  // the next waypoint must be outside of this threshold.
   double displacement_threshold_;
   double relative_angle_threshold_;
 
-  bool waypoint_set_;
-  bool pose_set_;
-  bool velocity_set_;
-  int num_of_next_waypoint_;
-  geometry_msgs::Point position_of_next_target_;
+  bool is_waypoint_set_;
+  bool is_pose_set_;
+  bool is_velocity_set_;
+  int next_waypoint_number_;
+  geometry_msgs::Point next_target_position_;
   double lookahead_distance_;
 
   geometry_msgs::PoseStamped current_pose_;
@@ -90,57 +121,7 @@ private:
   void getNextWaypoint();
   geometry_msgs::TwistStamped outputZero() const;
   geometry_msgs::TwistStamped outputTwist(geometry_msgs::Twist t) const;
-
-public:
-  PurePursuit(bool linear_interpolate_mode)
-    : RADIUS_MAX_(9e10)
-    , KAPPA_MIN_(1/RADIUS_MAX_)
-    , linear_interpolate_(linear_interpolate_mode)
-    , param_flag_(0)
-    , const_lookahead_distance_(4.0)
-    , initial_velocity_(5.0)
-    , lookahead_distance_calc_ratio_(2.0)
-    , minimum_lookahead_distance_(6.0)
-    , displacement_threshold_(0.2)
-    , relative_angle_threshold_(10)
-    , waypoint_set_(false)
-    , pose_set_(false)
-    , velocity_set_(false)
-    , num_of_next_waypoint_(-1)
-    , lookahead_distance_(0)
-  {
-  }
-  ~PurePursuit()
-  {
-  }
-
-  // for ROS
-  void callbackFromConfig(const runtime_manager::ConfigWaypointFollowerConstPtr &amp;config);
-  void callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg);
-  void callbackFromCurrentVelocity(const geometry_msgs::TwistStampedConstPtr &amp;msg);
-  void callbackFromWayPoints(const waypoint_follower::laneConstPtr &amp;msg);
-
-  // for debug
-  geometry_msgs::Point getPoseOfNextWaypoint() const
-  {
-    return current_waypoints_.getWaypointPosition(num_of_next_waypoint_);
-  }
-  geometry_msgs::Point getPoseOfNextTarget() const
-  {
-    return position_of_next_target_;
-  }
-  geometry_msgs::Pose getCurrentPose() const
-  {
-    return current_pose_.pose;
-  }
-
-  double getLookaheadDistance() const
-  {
-    return lookahead_distance_;
-  }
-  // processing for ROS
-  geometry_msgs::TwistStamped go();
 };
-}
+}  // waypoint_follower
 
-#endif  // PURE_PURSUIT_CORE_H
+#endif  // PURE_PURSUIT_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="49" deleted_lines="336">
				<diff>@@ -28,368 +28,81 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include "pure_pursuit/pure_pursuit_core.h"
+#include "pure_pursuit_core.h"
 
 namespace waypoint_follower
 {
-
-void PurePursuit::callbackFromConfig(const runtime_manager::ConfigWaypointFollowerConstPtr &amp;config)
+// Constructor
+PurePursuitNode::PurePursuitNode() : private_nh_("~"), pp_(), LOOP_RATE_(30)
 {
-  param_flag_ = config-&gt;param_flag;
-  const_lookahead_distance_ = config-&gt;lookahead_distance;
-  initial_velocity_ = config-&gt;velocity;
-  lookahead_distance_calc_ratio_ = config-&gt;lookahead_ratio;
-  minimum_lookahead_distance_ = config-&gt;minimum_lookahead_distance;
-  displacement_threshold_ = config-&gt;displacement_threshold;
-  relative_angle_threshold_ = config-&gt;relative_angle_threshold;
+  initForROS();
 }
 
-void PurePursuit::callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg)
-{
-  current_pose_.header = msg-&gt;header;
-  current_pose_.pose = msg-&gt;pose;
-  pose_set_ = true;
-}//processing frequency
-
-void PurePursuit::callbackFromCurrentVelocity(const geometry_msgs::TwistStampedConstPtr &amp;msg)
+// Destructor
+PurePursuitNode::~PurePursuitNode()
 {
-  current_velocity_ = *msg;
-  velocity_set_ = true;
 }
 
-void PurePursuit::callbackFromWayPoints(const waypoint_follower::laneConstPtr &amp;msg)
+void PurePursuitNode::initForROS()
 {
-  current_waypoints_.setPath(*msg);
-  waypoint_set_ = true;
-  // ROS_INFO_STREAM("waypoint subscribed");
+  // ros parameter settings
+  private_nh_.param("is_linear_interpolation", is_linear_interpolation_, bool(true));
+  // ROS_INFO_STREAM("is_linear_interpolation : " &lt;&lt; is_linear_interpolation_);
+  pp_.getLinearInterpolationParameter(is_linear_interpolation_);
+
+  // setup subscriber
+  sub1_ = nh_.subscribe("final_waypoints", 10, &amp;PurePursuitNode::callbackFromWayPoints, this);
+  sub2_ = nh_.subscribe("current_pose", 10, &amp;PurePursuitNode::callbackFromCurrentPose, this);
+  sub3_ = nh_.subscribe("config/waypoint_follower", 10, &amp;PurePursuitNode::callbackFromConfig, this);
+  sub4_ = nh_.subscribe("current_velocity", 10, &amp;PurePursuitNode::callbackFromCurrentVelocity, this);
+
+  // setup publisher
+  pub1_ = nh_.advertise&lt;geometry_msgs::TwistStamped&gt;("twist_raw", 10);
+  // pub2_ = nh_advertise&lt;&gt;("",10);
+  pub11_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("next_waypoint_mark", 0);
+  pub12_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("next_target_mark", 0);
+  pub13_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("search_circle_mark", 0);
+  pub14_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("line_point_mark", 0);  // debug tool
+  pub15_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("trajectory_circle_mark", 0);
+  // pub7_ = nh.advertise&lt;std_msgs::Bool&gt;("wf_stat", 0);
 }
 
-double PurePursuit::getCmdVelocity(int waypoint) const
+void PurePursuitNode::run()
 {
-  if (param_flag_ == static_cast&lt;int&gt;(Mode::dialog))
+  ROS_INFO_STREAM("pure pursuit start");
+  ros::Rate loop_rate(LOOP_RATE_);
+  while (ros::ok())
   {
-    ROS_INFO_STREAM("dialog : " &lt;&lt; initial_velocity_ &lt;&lt; " km/h (" &lt;&lt; kmph2mps(initial_velocity_) &lt;&lt; " m/s )");
-    return kmph2mps(initial_velocity_);
-  }
+    ros::spinOnce();
+    pub1_.publish(pp_.go());
 
-  if (current_waypoints_.isEmpty())
-  {
-    ROS_INFO_STREAM("waypoint : not loaded path");
-    return 0;
+    // for visualization with Rviz
+    pub11_.publish(displayNextWaypoint(pp_.getPoseOfNextWaypoint()));
+    pub13_.publish(displaySearchRadius(pp_.getCurrentPose().position, pp_.getLookaheadDistance()));
+    pub12_.publish(displayNextTarget(pp_.getPoseOfNextTarget()));
+    pub15_.publish(displayTrajectoryCircle(
+        waypoint_follower::generateTrajectoryCircle(pp_.getPoseOfNextTarget(), pp_.getCurrentPose())));
+    loop_rate.sleep();
   }
-
-  double velocity = current_waypoints_.getWaypointVelocityMPS(waypoint);
-  // ROS_INFO_STREAM("waypoint : " &lt;&lt; mps2kmph(velocity) &lt;&lt; " km/h ( " &lt;&lt; velocity &lt;&lt; "m/s )");
-  return velocity;
 }
 
-void PurePursuit::calcLookaheadDistance(int waypoint)
+void PurePursuitNode::callbackFromConfig(const runtime_manager::ConfigWaypointFollowerConstPtr &amp;config)
 {
-  if (param_flag_ == static_cast&lt;int&gt;(Mode::dialog))
-  {
-    lookahead_distance_ = const_lookahead_distance_;
-    return;
-  }
-
-  double current_velocity_mps = current_velocity_.twist.linear.x;
-  double maximum_lookahead_distance =  current_velocity_mps * 10;
-  double ld = current_velocity_mps * lookahead_distance_calc_ratio_;
-
-  lookahead_distance_ = ld &lt; minimum_lookahead_distance_ ? minimum_lookahead_distance_
-                      : ld &gt; maximum_lookahead_distance ? maximum_lookahead_distance
-                      : ld ;
-
-  ROS_INFO("lookahead distance: %f",lookahead_distance_);
-
-  return ;
+  pp_.getConfigForROS(config);
 }
 
-double PurePursuit::calcCurvature(geometry_msgs::Point target) const
+void PurePursuitNode::callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 {
-  double kappa;
-  double denominator = pow(getPlaneDistance(target, current_pose_.pose.position), 2);
-  double numerator = 2 * calcRelativeCoordinate(target, current_pose_.pose).y;
-
-  if (denominator != 0)
-    kappa = numerator / denominator;
-  else
-  {
-    if(numerator &gt; 0)
-     kappa = KAPPA_MIN_;
-    else
-      kappa = -KAPPA_MIN_;
-  }
-  ROS_INFO("kappa : %lf", kappa);
-  return kappa;
+  pp_.getCurrentPoseForROS(msg);
 }
 
-// linear interpolation of next target
-bool PurePursuit::interpolateNextTarget(int next_waypoint, geometry_msgs::Point *next_target) const
+void PurePursuitNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStampedConstPtr &amp;msg)
 {
-  constexpr double ERROR = pow(10, -5);  // 0.00001
-
-  int path_size = static_cast&lt;int&gt;(current_waypoints_.getSize());
-  if (next_waypoint == path_size - 1)
-  {
-    *next_target = current_waypoints_.getWaypointPosition(next_waypoint);
-    return true;
-  }
-  double search_radius = lookahead_distance_;
-  geometry_msgs::Point zero_p;
-  geometry_msgs::Point end = current_waypoints_.getWaypointPosition(next_waypoint);
-  geometry_msgs::Point start = current_waypoints_.getWaypointPosition(next_waypoint - 1);
-
-  // let the linear equation be "ax + by + c = 0"
-  // if there are two points (x1,y1) , (x2,y2), a = "y2-y1, b = "(-1) * x2 - x1" ,c = "(-1) * (y2-y1)x1 + (x2-x1)y1"
-  double a = 0;
-  double b = 0;
-  double c = 0;
-  double get_linear_flag = getLinearEquation(start, end, &amp;a, &amp;b, &amp;c);
-  if (!get_linear_flag)
-    return false;
-
-  // let the center of circle be "(x0,y0)", in my code , the center of circle is vehicle position
-  // the distance  "d" between the foot of a perpendicular line and the center of circle is ...
-  //    | a * x0 + b * y0 + c |
-  // d = -------------------------------
-  //          ( a~2 + b~2)
-  double d = getDistanceBetweenLineAndPoint(current_pose_.pose.position, a, b, c);
-
-  // ROS_INFO("a : %lf ", a);
-  // ROS_INFO("b : %lf ", b);
-  // ROS_INFO("c : %lf ", c);
-  // ROS_INFO("distance : %lf ", d);
-
-  if (d &gt; search_radius)
-    return false;
-
-  // unit vector of point 'start' to point 'end'
-  tf::Vector3 v((end.x - start.x), (end.y - start.y), 0);
-  tf::Vector3 unit_v = v.normalize();
-
-  // normal unit vectors of v
-  tf::Vector3 unit_w1 = rotateUnitVector(unit_v, 90);   // rotate to counter clockwise 90 degree
-  tf::Vector3 unit_w2 = rotateUnitVector(unit_v, -90);  // rotate to counter clockwise 90 degree
-
-  // the foot of a perpendicular line
-  geometry_msgs::Point h1;
-  h1.x = current_pose_.pose.position.x + d * unit_w1.getX();
-  h1.y = current_pose_.pose.position.y + d * unit_w1.getY();
-  h1.z = current_pose_.pose.position.z;
-
-  geometry_msgs::Point h2;
-  h2.x = current_pose_.pose.position.x + d * unit_w2.getX();
-  h2.y = current_pose_.pose.position.y + d * unit_w2.getY();
-  h2.z = current_pose_.pose.position.z;
-
-  // ROS_INFO("error : %lf", error);
-  // ROS_INFO("whether h1 on line : %lf", h1.y - (slope * h1.x + intercept));
-  // ROS_INFO("whether h2 on line : %lf", h2.y - (slope * h2.x + intercept));
-
-  // check which of two foot of a perpendicular line is on the line equation
-  geometry_msgs::Point h;
-  if (fabs(a * h1.x + b * h1.y + c) &lt; ERROR)
-  {
-    h = h1;
-    //   ROS_INFO("use h1");
-  }
-  else if (fabs(a * h2.x + b * h2.y + c) &lt; ERROR)
-  {
-    //   ROS_INFO("use h2");
-    h = h2;
-  }
-  else
-  {
-    return false;
-  }
-
-  // get intersection[s]
-  // if there is a intersection
-  if (d == search_radius)
-  {
-    *next_target = h;
-    return true;
-  }
-  else
-  {
-    // if there are two intersection
-    // get intersection in front of vehicle
-    double s = sqrt(pow(search_radius, 2) - pow(d, 2));
-    geometry_msgs::Point target1;
-    target1.x = h.x + s * unit_v.getX();
-    target1.y = h.y + s * unit_v.getY();
-    target1.z = current_pose_.pose.position.z;
-
-    geometry_msgs::Point target2;
-    target2.x = h.x - s * unit_v.getX();
-    target2.y = h.y - s * unit_v.getY();
-    target2.z = current_pose_.pose.position.z;
-
-    // ROS_INFO("target1 : ( %lf , %lf , %lf)", target1.x, target1.y, target1.z);
-    // ROS_INFO("target2 : ( %lf , %lf , %lf)", target2.x, target2.y, target2.z);
-    //displayLinePoint(a, b, c, target1, target2, h);  // debug tool
-
-    // check intersection is between end and start
-    double interval = getPlaneDistance(end, start);
-    if (getPlaneDistance(target1, end) &lt; interval)
-    {
-      // ROS_INFO("result : target1");
-      *next_target = target1;
-      return true;
-    }
-    else if (getPlaneDistance(target2, end) &lt; interval)
-    {
-      // ROS_INFO("result : target2");
-      *next_target = target2;
-      return true;
-    }
-    else
-    {
-      // ROS_INFO("result : false ");
-      return false;
-    }
-  }
+  pp_.getCurrentVelocityForROS(msg);
 }
 
-bool PurePursuit::verifyFollowing() const
+void PurePursuitNode::callbackFromWayPoints(const waypoint_follower::laneConstPtr &amp;msg)
 {
-  double a = 0;
-  double b = 0;
-  double c = 0;
-  getLinearEquation(current_waypoints_.getWaypointPosition(1), current_waypoints_.getWaypointPosition(2), &amp;a, &amp;b, &amp;c);
-  double displacement = getDistanceBetweenLineAndPoint(current_pose_.pose.position, a, b, c);
-  double relative_angle = getRelativeAngle(current_waypoints_.getWaypointPose(1), current_pose_.pose);
-  // ROS_INFO("side diff : %lf , angle diff : %lf",displacement,relative_angle);
-  if (displacement &lt; displacement_threshold_ || relative_angle &lt; relative_angle_threshold_)
-  {
-    // ROS_INFO("Following : True");
-    return true;
-  }
-  else
-  {
-    // ROS_INFO("Following : False");
-    return false;
-  }
-}
-geometry_msgs::Twist PurePursuit::calcTwist(double curvature, double cmd_velocity) const
-{
-  // verify whether vehicle is following the path
-  bool following_flag = verifyFollowing();
-  static double prev_angular_velocity = 0;
-
-  geometry_msgs::Twist twist;
-  twist.linear.x = cmd_velocity;
-  if (!following_flag)
-  {
-    twist.angular.z = current_velocity_.twist.linear.x * curvature;
-  }
-  else
-  {
-    twist.angular.z = prev_angular_velocity;
-  }
-
-  prev_angular_velocity = twist.angular.z;
-  return twist;
-}
-
-void PurePursuit::getNextWaypoint()
-{
-  int path_size = static_cast&lt;int&gt;(current_waypoints_.getSize());
-
-  // if waypoints are not given, do nothing.
-  if (path_size == 0)
-  {
-    num_of_next_waypoint_ = -1;
-    return;
-  }
-
-  // look for the next waypoint.
-  for (int i = 0; i &lt; path_size; i++)
-  {
-    // if search waypoint is the last
-    if (i == (path_size - 1))
-    {
-      ROS_INFO("search waypoint is the last");
-      num_of_next_waypoint_ = i;
-      return;
-    }
-
-    // if there exists an effective waypoint
-    if (getPlaneDistance(current_waypoints_.getWaypointPosition(i), current_pose_.pose.position) &gt; lookahead_distance_)
-    {
-      num_of_next_waypoint_ = i;
-      return;
-    }
-  }
-
-  // if this program reaches here , it means we lost the waypoint!
-  num_of_next_waypoint_ = -1;
-  return;
-}
-
-geometry_msgs::TwistStamped PurePursuit::outputZero() const
-{
-  geometry_msgs::TwistStamped twist;
-  twist.twist.linear.x = 0;
-  twist.twist.angular.z = 0;
-  twist.header.stamp = ros::Time::now();
-  return twist;
-}
-geometry_msgs::TwistStamped PurePursuit::outputTwist(geometry_msgs::Twist t) const
-{
-  geometry_msgs::TwistStamped twist;
-  twist.twist = t;
-  twist.header.stamp = ros::Time::now();
-  return twist;
-}
-
-geometry_msgs::TwistStamped PurePursuit::go()
-{
-  if(!pose_set_ || !waypoint_set_ || !velocity_set_){
-    ROS_INFO("somethins is missing... ");
-    return outputZero();
-
-  }
-
-  bool interpolate_flag = false;
-
-  calcLookaheadDistance(1);
-  // search next waypoint
-  getNextWaypoint();
-  if (num_of_next_waypoint_ == -1)
-  {
-    ROS_INFO("lost next waypoint");
-    return outputZero();
-  }
-
-  // if g_linear_interpolate_mode is false or next waypoint is first or last
-  if (!linear_interpolate_ || num_of_next_waypoint_ == 0 ||
-      num_of_next_waypoint_ == (static_cast&lt;int&gt;(current_waypoints_.getSize() - 1)))
-  {
-    position_of_next_target_ = current_waypoints_.getWaypointPosition(num_of_next_waypoint_);
-    return outputTwist(calcTwist(calcCurvature(position_of_next_target_), getCmdVelocity(0)));
-  }
-
-  // linear interpolation and calculate angular velocity
-  interpolate_flag = interpolateNextTarget(num_of_next_waypoint_, &amp;position_of_next_target_);
-
-  if (!interpolate_flag)
-  {
-    ROS_INFO_STREAM("lost target! ");
-    return outputZero();
-  }
-
-  // ROS_INFO("next_target : ( %lf , %lf , %lf)", next_target.x, next_target.y,next_target.z);
-
-  return outputTwist(calcTwist(calcCurvature(position_of_next_target_), getCmdVelocity(0)));
-
-// ROS_INFO("linear : %lf, angular : %lf",twist.twist.linear.x,twist.twist.angular.z);
-
-#ifdef LOG
-  std::ofstream ofs("/tmp/pure_pursuit.log", std::ios::app);
-  ofs &lt;&lt; _current_waypoints.getWaypointPosition(next_waypoint).x &lt;&lt; " "
-      &lt;&lt; _current_waypoints.getWaypointPosition(next_waypoint).y &lt;&lt; " " &lt;&lt; next_target.x &lt;&lt; " " &lt;&lt; next_target.y
-      &lt;&lt; std::endl;
-#endif
-}
+  pp_.getWayPointsForROS(msg);
 }
+}  // waypoint_follower
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_viz.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_viz.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -28,11 +28,10 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include "pure_pursuit/pure_pursuit_viz.h"
+#include "pure_pursuit_viz.h"
 
 namespace waypoint_follower
 {
-
 const std::string MAP_FRAME = "map";
 // display the next waypoint by markers.
 visualization_msgs::Marker displayNextWaypoint(geometry_msgs::Point position)
@@ -96,7 +95,8 @@ double calcRadius(geometry_msgs::Point target, geometry_msgs::Pose current_pose)
 }
 
 // generate the locus of pure pursuit
-std::vector&lt;geometry_msgs::Point&gt; generateTrajectoryCircle(geometry_msgs::Point target, geometry_msgs::Pose current_pose)
+std::vector&lt;geometry_msgs::Point&gt; generateTrajectoryCircle(geometry_msgs::Point target,
+                                                           geometry_msgs::Pose current_pose)
 {
   std::vector&lt;geometry_msgs::Point&gt; traj_circle_array;
   double radius = calcRadius(target, current_pose);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\include\pure_pursuit\pure_pursuit_viz.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_viz.h" added_lines="6" deleted_lines="3">
				<diff>@@ -35,12 +35,15 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
-#include "runtime_manager/ConfigWaypointFollower.h"
+
 #include &lt;visualization_msgs/Marker.h&gt;
 
 // C++ includes
 #include &lt;memory&gt;
+
+// User defined includes
 #include "waypoint_follower/libwaypoint_follower.h"
+#include "runtime_manager/ConfigWaypointFollower.h"
 
 namespace waypoint_follower
 {
@@ -52,13 +55,13 @@ visualization_msgs::Marker displayNextTarget(geometry_msgs::Point target);
 double calcRadius(geometry_msgs::Point target, geometry_msgs::Pose current_pose);
 
 // generate the locus of pure pursuit
-std::vector&lt;geometry_msgs::Point&gt; generateTrajectoryCircle(geometry_msgs::Point target, geometry_msgs::Pose current_pose);
+std::vector&lt;geometry_msgs::Point&gt; generateTrajectoryCircle(geometry_msgs::Point target,
+                                                           geometry_msgs::Pose current_pose);
 // display the locus of pure pursuit by markers.
 visualization_msgs::Marker displayTrajectoryCircle(std::vector&lt;geometry_msgs::Point&gt; traj_circle_array);
 
 // display the search radius by markers.
 visualization_msgs::Marker displaySearchRadius(geometry_msgs::Point current_pose, double search_radius);
-
 }
 
 #endif  // PURE_PURSUIT_VIZ_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d18c3662d4c9132a4536b9e9617f8758710320fe" author="h_ohta">
		<msg>Delete unused value</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -112,7 +112,7 @@ double PurePursuit::getCmdVelocity(int waypoint) const
   return velocity;
 }
 
-void PurePursuit::calcLookaheadDistance(int waypoint)
+void PurePursuit::calcLookaheadDistance()
 {
   if (param_flag_ == static_cast&lt;int&gt;(Mode::dialog))
   {
@@ -382,7 +382,7 @@ geometry_msgs::TwistStamped PurePursuit::go()
     return outputZero();
   }
 
-  calcLookaheadDistance(1);
+  calcLookaheadDistance();
   // search next waypoint
   getNextWaypoint();
   if (next_waypoint_number_ == -1)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" added_lines="1" deleted_lines="1">
				<diff>@@ -112,7 +112,7 @@ private:
   WayPoints current_waypoints_;
 
   double getCmdVelocity(int waypoint) const;
-  void calcLookaheadDistance(int waypoint);
+  void calcLookaheadDistance();
   double calcCurvature(geometry_msgs::Point target) const;
   double calcRadius(geometry_msgs::Point target) const;
   bool interpolateNextTarget(int next_waypoint, geometry_msgs::Point *next_target) const;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3f15cbd12e7cc5ba0f93e46dd7b27c383be96527" author="h_ohta">
		<msg>Comment out unused function</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" added_lines="2" deleted_lines="1">
				<diff>@@ -83,7 +83,8 @@ private:
   void initForROS();
 
   // functions
-  void publish();
+  //void publish();
+
 };
 }  // waypoint_follower
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="de3cc148f28c9241de8ac7719969945ef7477be3" author="h_ohta">
		<msg>Update comments</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" added_lines="1" deleted_lines="1">
				<diff>@@ -91,7 +91,6 @@ private:
   // variables
   bool is_linear_interpolation_;
 
-  // config topic
   int param_flag_;                   // 0 = waypoint, 1 = Dialog
   double const_lookahead_distance_;  // meter
   double initial_velocity_;          // km/h
@@ -111,6 +110,7 @@ private:
   geometry_msgs::TwistStamped current_velocity_;
   WayPoints current_waypoints_;
 
+  //functions
   double getCmdVelocity(int waypoint) const;
   void calcLookaheadDistance();
   double calcCurvature(geometry_msgs::Point target) const;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="051585f5190ce112202f2c061861b135fbf88be3" author="h_ohta">
		<msg>Add topic publisher for steering robot</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" added_lines="42" deleted_lines="0">
				<diff>@@ -421,4 +421,46 @@ geometry_msgs::TwistStamped PurePursuit::go()
       &lt;&lt; std::endl;
 #endif
 }
+
+bool PurePursuit::canGetCurvature(double *output_kappa)
+{
+  if (!is_pose_set_ || !is_waypoint_set_ || !is_velocity_set_)
+  {
+    ROS_INFO("something is missing... ");
+    return false;
+  }
+
+  calcLookaheadDistance();
+  // search next waypoint
+  getNextWaypoint();
+  if (next_waypoint_number_ == -1)
+  {
+    ROS_INFO("lost next waypoint");
+    return false;
+  }
+
+  // if g_linear_interpolate_mode is false or next waypoint is first or last
+  if (!is_linear_interpolation_ || next_waypoint_number_ == 0 ||
+      next_waypoint_number_ == (static_cast&lt;int&gt;(current_waypoints_.getSize() - 1)))
+  {
+    next_target_position_ = current_waypoints_.getWaypointPosition(next_waypoint_number_);
+    *output_kappa = calcCurvature(next_target_position_);
+    return true;
+  }
+
+  // linear interpolation and calculate angular velocity
+  bool interpolation = interpolateNextTarget(next_waypoint_number_, &amp;next_target_position_);
+
+  if (!interpolation)
+  {
+    ROS_INFO_STREAM("lost target! ");
+    return false;
+  }
+
+  // ROS_INFO("next_target : ( %lf , %lf , %lf)", next_target.x, next_target.y,next_target.z);
+
+  *output_kappa = calcCurvature(next_target_position_);
+  return true;
+}
+
 }  // waypoint_follower
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" added_lines="1" deleted_lines="0">
				<diff>@@ -82,6 +82,7 @@ public:
   }
   // processing
   geometry_msgs::TwistStamped go();
+  bool canGetCurvature(double *output_kappa);
 
 private:
   // constant
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="30" deleted_lines="2">
				<diff>@@ -33,7 +33,7 @@
 namespace waypoint_follower
 {
 // Constructor
-PurePursuitNode::PurePursuitNode() : private_nh_("~"), pp_(), LOOP_RATE_(30)
+PurePursuitNode::PurePursuitNode() : private_nh_("~"), pp_(), LOOP_RATE_(30), current_velocity_(0), cmd_velocity_(0)
 {
   initForROS();
 }
@@ -49,6 +49,8 @@ void PurePursuitNode::initForROS()
   private_nh_.param("is_linear_interpolation", is_linear_interpolation_, bool(true));
   // ROS_INFO_STREAM("is_linear_interpolation : " &lt;&lt; is_linear_interpolation_);
   pp_.getLinearInterpolationParameter(is_linear_interpolation_);
+  private_nh_.param("publishes_for_steering_robot",publishes_for_steering_robot_,bool(false));
+  private_nh_.param("vehicle_info/wheel_base",wheel_base_,double(2.7));
 
   // setup subscriber
   sub1_ = nh_.subscribe("final_waypoints", 10, &amp;PurePursuitNode::callbackFromWayPoints, this);
@@ -58,7 +60,7 @@ void PurePursuitNode::initForROS()
 
   // setup publisher
   pub1_ = nh_.advertise&lt;geometry_msgs::TwistStamped&gt;("twist_raw", 10);
-  // pub2_ = nh_advertise&lt;&gt;("",10);
+  pub2_ = nh_.advertise&lt;waypoint_follower::ControlCommandStamped&gt;("ctrl_cmd",10);
   pub11_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("next_waypoint_mark", 0);
   pub12_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("next_target_mark", 0);
   pub13_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("search_circle_mark", 0);
@@ -76,6 +78,24 @@ void PurePursuitNode::run()
     ros::spinOnce();
     pub1_.publish(pp_.go());
 
+    double kappa = 0;
+    if(publishes_for_steering_robot_)
+    {
+      waypoint_follower::ControlCommandStamped ccs;
+      ccs.header.stamp = ros::Time::now();
+      if(pp_.canGetCurvature(&amp;kappa))
+      {
+        ccs.cmd.linear_velocity = cmd_velocity_;
+        ccs.cmd.steering_angle = convertCurvatureToSteeringAngle(wheel_base_,kappa);
+      }
+      else
+      {
+        ccs.cmd.linear_velocity = 0;
+        ccs.cmd.steering_angle = 0;
+      }
+      pub2_.publish(ccs);
+    }
+
     // for visualization with Rviz
     pub11_.publish(displayNextWaypoint(pp_.getPoseOfNextWaypoint()));
     pub13_.publish(displaySearchRadius(pp_.getCurrentPose().position, pp_.getLookaheadDistance()));
@@ -98,11 +118,19 @@ void PurePursuitNode::callbackFromCurrentPose(const geometry_msgs::PoseStampedCo
 
 void PurePursuitNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStampedConstPtr &amp;msg)
 {
+  current_velocity_ = msg-&gt;twist.linear.x;
   pp_.getCurrentVelocityForROS(msg);
 }
 
 void PurePursuitNode::callbackFromWayPoints(const waypoint_follower::laneConstPtr &amp;msg)
 {
+  cmd_velocity_ = msg-&gt;waypoints.at(0).twist.twist.linear.x;
   pp_.getWayPointsForROS(msg);
 }
+
+double convertCurvatureToSteeringAngle(const double &amp;wheel_base, const double &amp;kappa)
+{
+  return atan(wheel_base * kappa);
+}
+
 }  // waypoint_follower
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" added_lines="6" deleted_lines="1">
				<diff>@@ -40,6 +40,7 @@
 // User defined includes
 #include "runtime_manager/ConfigWaypointFollower.h"
 #include "waypoint_follower/lane.h"
+#include "waypoint_follower/ControlCommandStamped.h"
 #include "pure_pursuit_viz.h"
 #include "pure_pursuit.h"
 
@@ -71,7 +72,9 @@ private:
   const int LOOP_RATE_;  // processing frequency
 
   // variables
-  bool is_linear_interpolation_;
+  bool is_linear_interpolation_,publishes_for_steering_robot_;
+  double current_velocity_, cmd_velocity_;
+  double wheel_base_;
 
   // callbacks
   void callbackFromConfig(const runtime_manager::ConfigWaypointFollowerConstPtr &amp;config);
@@ -86,6 +89,8 @@ private:
   //void publish();
 
 };
+
+double convertCurvatureToSteeringAngle(const double &amp;wheel_base, const double &amp;kappa);
 }  // waypoint_follower
 
 #endif  // PURE_PURSUIT_CORE_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f82d98b8f9968c44489a22df903556cf1bede99a" author="h_ohta">
		<msg>Move non-ROS initializer outside InitForROS()</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="3" deleted_lines="1">
				<diff>@@ -36,6 +36,9 @@ namespace waypoint_follower
 PurePursuitNode::PurePursuitNode() : private_nh_("~"), pp_(), LOOP_RATE_(30), current_velocity_(0), cmd_velocity_(0)
 {
   initForROS();
+
+  // initialize for PurePursuit
+  pp_.setLinearInterpolationParameter(is_linear_interpolation_);
 }
 
 // Destructor
@@ -48,7 +51,6 @@ void PurePursuitNode::initForROS()
   // ros parameter settings
   private_nh_.param("is_linear_interpolation", is_linear_interpolation_, bool(true));
   // ROS_INFO_STREAM("is_linear_interpolation : " &lt;&lt; is_linear_interpolation_);
-  pp_.getLinearInterpolationParameter(is_linear_interpolation_);
   private_nh_.param("publishes_for_steering_robot",publishes_for_steering_robot_,bool(false));
   private_nh_.param("vehicle_info/wheel_base",wheel_base_,double(2.7));
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c1edc1d3c2752a8db76ab9496af19c4522ffd76b" author="h_ohta">
		<msg>Fix indent</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -51,8 +51,8 @@ void PurePursuitNode::initForROS()
   // ros parameter settings
   private_nh_.param("is_linear_interpolation", is_linear_interpolation_, bool(true));
   // ROS_INFO_STREAM("is_linear_interpolation : " &lt;&lt; is_linear_interpolation_);
-  private_nh_.param("publishes_for_steering_robot",publishes_for_steering_robot_,bool(false));
-  private_nh_.param("vehicle_info/wheel_base",wheel_base_,double(2.7));
+  private_nh_.param("publishes_for_steering_robot", publishes_for_steering_robot_, bool(false));
+  private_nh_.param("vehicle_info/wheel_base", wheel_base_, double(2.7));
 
   // setup subscriber
   sub1_ = nh_.subscribe("final_waypoints", 10, &amp;PurePursuitNode::callbackFromWayPoints, this);
@@ -62,7 +62,7 @@ void PurePursuitNode::initForROS()
 
   // setup publisher
   pub1_ = nh_.advertise&lt;geometry_msgs::TwistStamped&gt;("twist_raw", 10);
-  pub2_ = nh_.advertise&lt;waypoint_follower::ControlCommandStamped&gt;("ctrl_cmd",10);
+  pub2_ = nh_.advertise&lt;waypoint_follower::ControlCommandStamped&gt;("ctrl_cmd", 10);
   pub11_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("next_waypoint_mark", 0);
   pub12_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("next_target_mark", 0);
   pub13_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("search_circle_mark", 0);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="270aab68301d4521c40580b88f37343070301a8c" author="h_ohta">
		<msg>Change variable type, extract ros code from PurePursuit Class</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" added_lines="20" deleted_lines="112">
				<diff>@@ -37,18 +37,9 @@ PurePursuit::PurePursuit()
   : RADIUS_MAX_(9e10)
   , KAPPA_MIN_(1 / RADIUS_MAX_)
   , is_linear_interpolation_(false)
-  , param_flag_(0)
-  , const_lookahead_distance_(4.0)
-  , initial_velocity_(5.0)
-  , lookahead_distance_calc_ratio_(2.0)
-  , minimum_lookahead_distance_(6.0)
-  , displacement_threshold_(0.2)
-  , relative_angle_threshold_(10)
-  , is_waypoint_set_(false)
-  , is_pose_set_(false)
-  , is_velocity_set_(false)
   , next_waypoint_number_(-1)
   , lookahead_distance_(0)
+  , current_linear_velocity_(0)
 {
 }
 
@@ -57,87 +48,11 @@ PurePursuit::~PurePursuit()
 {
 }
 
-void PurePursuit::getConfigForROS(const runtime_manager::ConfigWaypointFollowerConstPtr &amp;config)
-{
-  param_flag_ = config-&gt;param_flag;
-  const_lookahead_distance_ = config-&gt;lookahead_distance;
-  initial_velocity_ = config-&gt;velocity;
-  lookahead_distance_calc_ratio_ = config-&gt;lookahead_ratio;
-  minimum_lookahead_distance_ = config-&gt;minimum_lookahead_distance;
-  displacement_threshold_ = config-&gt;displacement_threshold;
-  relative_angle_threshold_ = config-&gt;relative_angle_threshold;
-}
-
-void PurePursuit::getCurrentPoseForROS(const geometry_msgs::PoseStampedConstPtr &amp;msg)
-{
-  current_pose_.header = msg-&gt;header;
-  current_pose_.pose = msg-&gt;pose;
-  is_pose_set_ = true;
-}
-
-void PurePursuit::getCurrentVelocityForROS(const geometry_msgs::TwistStampedConstPtr &amp;msg)
-{
-  current_velocity_ = *msg;
-  is_velocity_set_ = true;
-}
-
-void PurePursuit::getWayPointsForROS(const waypoint_follower::laneConstPtr &amp;msg)
-{
-  current_waypoints_.setPath(*msg);
-  is_waypoint_set_ = true;
-  // ROS_INFO_STREAM("waypoint subscribed");
-}
-
-void PurePursuit::getLinearInterpolationParameter(const bool &amp;param)
-{
-  is_linear_interpolation_ = param;
-}
-
-double PurePursuit::getCmdVelocity(int waypoint) const
-{
-  if (param_flag_ == static_cast&lt;int&gt;(Mode::dialog))
-  {
-    ROS_INFO_STREAM("dialog : " &lt;&lt; initial_velocity_ &lt;&lt; " km/h (" &lt;&lt; kmph2mps(initial_velocity_) &lt;&lt; " m/s )");
-    return kmph2mps(initial_velocity_);
-  }
-
-  if (current_waypoints_.isEmpty())
-  {
-    ROS_INFO_STREAM("waypoint : not loaded path");
-    return 0;
-  }
-
-  double velocity = current_waypoints_.getWaypointVelocityMPS(waypoint);
-  // ROS_INFO_STREAM("waypoint : " &lt;&lt; mps2kmph(velocity) &lt;&lt; " km/h ( " &lt;&lt; velocity &lt;&lt; "m/s )");
-  return velocity;
-}
-
-void PurePursuit::calcLookaheadDistance()
-{
-  if (param_flag_ == static_cast&lt;int&gt;(Mode::dialog))
-  {
-    lookahead_distance_ = const_lookahead_distance_;
-    return;
-  }
-
-  double current_velocity_mps = current_velocity_.twist.linear.x;
-  double maximum_lookahead_distance = current_velocity_mps * 10;
-  double ld = current_velocity_mps * lookahead_distance_calc_ratio_;
-
-  lookahead_distance_ = ld &lt; minimum_lookahead_distance_
-                            ? minimum_lookahead_distance_
-                            : ld &gt; maximum_lookahead_distance ? maximum_lookahead_distance : ld;
-
-  ROS_INFO("lookahead distance: %f", lookahead_distance_);
-
-  return;
-}
-
 double PurePursuit::calcCurvature(geometry_msgs::Point target) const
 {
   double kappa;
-  double denominator = pow(getPlaneDistance(target, current_pose_.pose.position), 2);
-  double numerator = 2 * calcRelativeCoordinate(target, current_pose_.pose).y;
+  double denominator = pow(getPlaneDistance(target, current_pose_.position), 2);
+  double numerator = 2 * calcRelativeCoordinate(target, current_pose_).y;
 
   if (denominator != 0)
     kappa = numerator / denominator;
@@ -157,16 +72,16 @@ bool PurePursuit::interpolateNextTarget(int next_waypoint, geometry_msgs::Point
 {
   constexpr double ERROR = pow(10, -5);  // 0.00001
 
-  int path_size = static_cast&lt;int&gt;(current_waypoints_.getSize());
+  int path_size = static_cast&lt;int&gt;(current_waypoints_.size());
   if (next_waypoint == path_size - 1)
   {
-    *next_target = current_waypoints_.getWaypointPosition(next_waypoint);
+    *next_target = current_waypoints_.at(next_waypoint).pose.pose.position;
     return true;
   }
   double search_radius = lookahead_distance_;
   geometry_msgs::Point zero_p;
-  geometry_msgs::Point end = current_waypoints_.getWaypointPosition(next_waypoint);
-  geometry_msgs::Point start = current_waypoints_.getWaypointPosition(next_waypoint - 1);
+  geometry_msgs::Point end = current_waypoints_.at(next_waypoint).pose.pose.position;
+  geometry_msgs::Point start = current_waypoints_.at(next_waypoint - 1).pose.pose.position;
 
   // let the linear equation be "ax + by + c = 0"
   // if there are two points (x1,y1) , (x2,y2), a = "y2-y1, b = "(-1) * x2 - x1" ,c = "(-1) * (y2-y1)x1 + (x2-x1)y1"
@@ -182,7 +97,7 @@ bool PurePursuit::interpolateNextTarget(int next_waypoint, geometry_msgs::Point
   //    | a * x0 + b * y0 + c |
   // d = -------------------------------
   //          ( a~2 + b~2)
-  double d = getDistanceBetweenLineAndPoint(current_pose_.pose.position, a, b, c);
+  double d = getDistanceBetweenLineAndPoint(current_pose_.position, a, b, c);
 
   // ROS_INFO("a : %lf ", a);
   // ROS_INFO("b : %lf ", b);
@@ -202,14 +117,14 @@ bool PurePursuit::interpolateNextTarget(int next_waypoint, geometry_msgs::Point
 
   // the foot of a perpendicular line
   geometry_msgs::Point h1;
-  h1.x = current_pose_.pose.position.x + d * unit_w1.getX();
-  h1.y = current_pose_.pose.position.y + d * unit_w1.getY();
-  h1.z = current_pose_.pose.position.z;
+  h1.x = current_pose_.position.x + d * unit_w1.getX();
+  h1.y = current_pose_.position.y + d * unit_w1.getY();
+  h1.z = current_pose_.position.z;
 
   geometry_msgs::Point h2;
-  h2.x = current_pose_.pose.position.x + d * unit_w2.getX();
-  h2.y = current_pose_.pose.position.y + d * unit_w2.getY();
-  h2.z = current_pose_.pose.position.z;
+  h2.x = current_pose_.position.x + d * unit_w2.getX();
+  h2.y = current_pose_.position.y + d * unit_w2.getY();
+  h2.z = current_pose_.position.z;
 
   // ROS_INFO("error : %lf", error);
   // ROS_INFO("whether h1 on line : %lf", h1.y - (slope * h1.x + intercept));
@@ -247,12 +162,12 @@ bool PurePursuit::interpolateNextTarget(int next_waypoint, geometry_msgs::Point
     geometry_msgs::Point target1;
     target1.x = h.x + s * unit_v.getX();
     target1.y = h.y + s * unit_v.getY();
-    target1.z = current_pose_.pose.position.z;
+    target1.z = current_pose_.position.z;
 
     geometry_msgs::Point target2;
     target2.x = h.x - s * unit_v.getX();
     target2.y = h.y - s * unit_v.getY();
-    target2.z = current_pose_.pose.position.z;
+    target2.z = current_pose_.position.z;
 
     // ROS_INFO("target1 : ( %lf , %lf , %lf)", target1.x, target1.y, target1.z);
     // ROS_INFO("target2 : ( %lf , %lf , %lf)", target2.x, target2.y, target2.z);
@@ -324,7 +239,7 @@ geometry_msgs::Twist PurePursuit::calcTwist(double curvature, double cmd_velocit
 
 void PurePursuit::getNextWaypoint()
 {
-  int path_size = static_cast&lt;int&gt;(current_waypoints_.getSize());
+  int path_size = static_cast&lt;int&gt;(current_waypoints_.size());
 
   // if waypoints are not given, do nothing.
   if (path_size == 0)
@@ -345,7 +260,7 @@ void PurePursuit::getNextWaypoint()
     }
 
     // if there exists an effective waypoint
-    if (getPlaneDistance(current_waypoints_.getWaypointPosition(i), current_pose_.pose.position) &gt; lookahead_distance_)
+    if (getPlaneDistance(current_waypoints_.at(i).pose.pose.position, current_pose_.position) &gt; lookahead_distance_)
     {
       next_waypoint_number_ = i;
       return;
@@ -424,13 +339,6 @@ geometry_msgs::TwistStamped PurePursuit::go()
 
 bool PurePursuit::canGetCurvature(double *output_kappa)
 {
-  if (!is_pose_set_ || !is_waypoint_set_ || !is_velocity_set_)
-  {
-    ROS_INFO("something is missing... ");
-    return false;
-  }
-
-  calcLookaheadDistance();
   // search next waypoint
   getNextWaypoint();
   if (next_waypoint_number_ == -1)
@@ -441,9 +349,9 @@ bool PurePursuit::canGetCurvature(double *output_kappa)
 
   // if g_linear_interpolate_mode is false or next waypoint is first or last
   if (!is_linear_interpolation_ || next_waypoint_number_ == 0 ||
-      next_waypoint_number_ == (static_cast&lt;int&gt;(current_waypoints_.getSize() - 1)))
+      next_waypoint_number_ == (static_cast&lt;int&gt;(current_waypoints_.size() - 1)))
   {
-    next_target_position_ = current_waypoints_.getWaypointPosition(next_waypoint_number_);
+    next_target_position_ = current_waypoints_.at(next_waypoint_number_).pose.pose.position;
     *output_kappa = calcCurvature(next_target_position_);
     return true;
   }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" added_lines="27" deleted_lines="34">
				<diff>@@ -39,33 +39,41 @@
 // User defined includes
 #include "waypoint_follower/lane.h"
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "runtime_manager/ConfigWaypointFollower.h"
 
 namespace waypoint_follower
 {
-enum class Mode
-{
-  waypoint,
-  dialog
-};
-
 class PurePursuit
 {
 public:
   PurePursuit();
   ~PurePursuit();
 
-  // for getting data from ROS
-  void getConfigForROS(const runtime_manager::ConfigWaypointFollowerConstPtr &amp;config);
-  void getCurrentPoseForROS(const geometry_msgs::PoseStampedConstPtr &amp;msg);
-  void getCurrentVelocityForROS(const geometry_msgs::TwistStampedConstPtr &amp;msg);
-  void getWayPointsForROS(const waypoint_follower::laneConstPtr &amp;msg);
-  void getLinearInterpolationParameter(const bool &amp;param);
+  // for setting data
+  void setLookaheadDistance(const double &amp;ld)
+  {
+    lookahead_distance_ = ld;
+  }
+  void setCurrentVelocity(const double &amp;cur_vel)
+  {
+    current_linear_velocity_ = cur_vel;
+  }
+  void setCurrentWaypoints(const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps)
+  {
+    current_waypoints_ = wps;
+  }
+  void setCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg)
+  {
+    current_pose_ = msg-&gt;pose;
+  }
+  void setLinearInterpolationParameter(const bool &amp;param)
+  {
+    is_linear_interpolation_ = param;
+  }
 
   // for debug on ROS
   geometry_msgs::Point getPoseOfNextWaypoint() const
   {
-    return current_waypoints_.getWaypointPosition(next_waypoint_number_);
+    return current_waypoints_.at(next_waypoint_number_).pose.pose.position;
   }
   geometry_msgs::Point getPoseOfNextTarget() const
   {
@@ -73,7 +81,7 @@ public:
   }
   geometry_msgs::Pose getCurrentPose() const
   {
-    return current_pose_.pose;
+    return current_pose_;
   }
 
   double getLookaheadDistance() const
@@ -91,29 +99,14 @@ private:
 
   // variables
   bool is_linear_interpolation_;
-
-  int param_flag_;                   // 0 = waypoint, 1 = Dialog
-  double const_lookahead_distance_;  // meter
-  double initial_velocity_;          // km/h
-  double lookahead_distance_calc_ratio_;
-  double minimum_lookahead_distance_;  // the next waypoint must be outside of this threshold.
-  double displacement_threshold_;
-  double relative_angle_threshold_;
-
-  bool is_waypoint_set_;
-  bool is_pose_set_;
-  bool is_velocity_set_;
   int next_waypoint_number_;
   geometry_msgs::Point next_target_position_;
   double lookahead_distance_;
+  geometry_msgs::Pose current_pose_;
+  double current_linear_velocity_;
+  std::vector&lt;waypoint_follower::waypoint&gt; current_waypoints_;
 
-  geometry_msgs::PoseStamped current_pose_;
-  geometry_msgs::TwistStamped current_velocity_;
-  WayPoints current_waypoints_;
-
-  //functions
-  double getCmdVelocity(int waypoint) const;
-  void calcLookaheadDistance();
+  // functions
   double calcCurvature(geometry_msgs::Point target) const;
   double calcRadius(geometry_msgs::Point target) const;
   bool interpolateNextTarget(int next_waypoint, geometry_msgs::Point *next_target) const;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="91" deleted_lines="24">
				<diff>@@ -33,7 +33,21 @@
 namespace waypoint_follower
 {
 // Constructor
-PurePursuitNode::PurePursuitNode() : private_nh_("~"), pp_(), LOOP_RATE_(30), current_velocity_(0), cmd_velocity_(0)
+PurePursuitNode::PurePursuitNode()
+  : private_nh_("~")
+  , pp_()
+  , LOOP_RATE_(30)
+  , is_waypoint_set_(false)
+  , is_pose_set_(false)
+  , is_velocity_set_(false)
+  , is_config_set_(false)
+  , current_linear_velocity_(0)
+  , command_linear_velocity_(0)
+  , param_flag_(-1)
+  , const_lookahead_distance_(4.0)
+  , const_velocity_(5.0)
+  , lookahead_distance_ratio_(2.0)
+  , minimum_lookahead_distance_(6.0)
 {
   initForROS();
 
@@ -78,56 +92,109 @@ void PurePursuitNode::run()
   while (ros::ok())
   {
     ros::spinOnce();
-    pub1_.publish(pp_.go());
-
-    double kappa = 0;
-    if(publishes_for_steering_robot_)
+    if (!is_pose_set_ || !is_waypoint_set_ || !is_velocity_set_ || !is_config_set_)
     {
-      waypoint_follower::ControlCommandStamped ccs;
-      ccs.header.stamp = ros::Time::now();
-      if(pp_.canGetCurvature(&amp;kappa))
-      {
-        ccs.cmd.linear_velocity = cmd_velocity_;
-        ccs.cmd.steering_angle = convertCurvatureToSteeringAngle(wheel_base_,kappa);
-      }
-      else
-      {
-        ccs.cmd.linear_velocity = 0;
-        ccs.cmd.steering_angle = 0;
-      }
-      pub2_.publish(ccs);
+      ROS_WARN("Necessary topics are not subscribed yet ... ");
+      loop_rate.sleep();
+      continue;
     }
 
+    pp_.setLookaheadDistance(computeLookaheadDistance());
+
+    double kappa = 0;
+    bool can_get_curvature = pp_.canGetCurvature(&amp;kappa);
+    publishTwistStamped(can_get_curvature, kappa);
+    publishControlCommandStamped(can_get_curvature, kappa);
+
     // for visualization with Rviz
     pub11_.publish(displayNextWaypoint(pp_.getPoseOfNextWaypoint()));
     pub13_.publish(displaySearchRadius(pp_.getCurrentPose().position, pp_.getLookaheadDistance()));
     pub12_.publish(displayNextTarget(pp_.getPoseOfNextTarget()));
     pub15_.publish(displayTrajectoryCircle(
         waypoint_follower::generateTrajectoryCircle(pp_.getPoseOfNextTarget(), pp_.getCurrentPose())));
+
+    is_pose_set_ = false;
+    is_velocity_set_ = false;
+    is_waypoint_set_ = false;
     loop_rate.sleep();
   }
 }
 
+void PurePursuitNode::publishTwistStamped(const bool &amp;can_get_curvature, const double &amp;kappa) const
+{
+  geometry_msgs::TwistStamped ts;
+  ts.header.stamp = ros::Time::now();
+  ts.twist.linear.x = can_get_curvature ? command_linear_velocity_ : 0;
+  ts.twist.angular.z = can_get_curvature ? kappa * ts.twist.linear.x : 0;
+  pub1_.publish(ts);
+}
+
+void PurePursuitNode::publishControlCommandStamped(const bool &amp;can_get_curvature, const double &amp;kappa) const
+{
+  if (!publishes_for_steering_robot_)
+    return;
+
+  waypoint_follower::ControlCommandStamped ccs;
+  ccs.header.stamp = ros::Time::now();
+  ccs.cmd.linear_velocity = can_get_curvature ? computeCommandVelocity() : 0;
+  ccs.cmd.steering_angle = can_get_curvature ? convertCurvatureToSteeringAngle(wheel_base_, kappa) : 0;
+
+  pub2_.publish(ccs);
+}
+
+double PurePursuitNode::computeLookaheadDistance() const
+{
+  if (param_flag_ == enumToInteger(Mode::dialog))
+    return const_lookahead_distance_;
+
+  double maximum_lookahead_distance = current_linear_velocity_ * 10;
+  double ld = current_linear_velocity_ * lookahead_distance_ratio_;
+
+  return ld &lt; minimum_lookahead_distance_ ? minimum_lookahead_distance_
+        : ld &gt; maximum_lookahead_distance ? maximum_lookahead_distance
+        : ld;
+}
+
+double PurePursuitNode::computeCommandVelocity() const
+{
+  if (param_flag_ == enumToInteger(Mode::dialog))
+    return kmph2mps(const_velocity_);
+
+  return command_linear_velocity_;
+}
+
 void PurePursuitNode::callbackFromConfig(const runtime_manager::ConfigWaypointFollowerConstPtr &amp;config)
 {
-  pp_.getConfigForROS(config);
+  param_flag_ = config-&gt;param_flag;
+  const_lookahead_distance_ = config-&gt;lookahead_distance;
+  const_velocity_ = config-&gt;velocity;
+  lookahead_distance_ratio_ = config-&gt;lookahead_ratio;
+  minimum_lookahead_distance_ = config-&gt;minimum_lookahead_distance;
+  is_config_set_ = true;
 }
 
 void PurePursuitNode::callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 {
-  pp_.getCurrentPoseForROS(msg);
+  pp_.setCurrentPose(msg);
+  is_pose_set_ = true;
 }
 
 void PurePursuitNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStampedConstPtr &amp;msg)
 {
-  current_velocity_ = msg-&gt;twist.linear.x;
-  pp_.getCurrentVelocityForROS(msg);
+  current_linear_velocity_ = msg-&gt;twist.linear.x;
+  pp_.setCurrentVelocity(current_linear_velocity_);
+  is_velocity_set_ = true;
 }
 
 void PurePursuitNode::callbackFromWayPoints(const waypoint_follower::laneConstPtr &amp;msg)
 {
-  cmd_velocity_ = msg-&gt;waypoints.at(0).twist.twist.linear.x;
-  pp_.getWayPointsForROS(msg);
+  if (!msg-&gt;waypoints.empty())
+    command_linear_velocity_ = msg-&gt;waypoints.at(0).twist.twist.linear.x;
+  else
+    command_linear_velocity_ = 0;
+
+  pp_.setCurrentWaypoints(msg-&gt;waypoints);
+  is_waypoint_set_ = true;
 }
 
 double convertCurvatureToSteeringAngle(const double &amp;wheel_base, const double &amp;kappa)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" added_lines="33" deleted_lines="3">
				<diff>@@ -46,6 +46,20 @@
 
 namespace waypoint_follower
 {
+enum class Mode : int32_t
+{
+  waypoint,
+  dialog,
+
+  unknown = -1,
+};
+
+template &lt;class T&gt;
+typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
+{
+  return static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(t);
+}
+
 class PurePursuitNode
 {
 public:
@@ -72,10 +86,17 @@ private:
   const int LOOP_RATE_;  // processing frequency
 
   // variables
-  bool is_linear_interpolation_,publishes_for_steering_robot_;
-  double current_velocity_, cmd_velocity_;
+  bool is_linear_interpolation_, publishes_for_steering_robot_;
+  bool is_waypoint_set_, is_pose_set_, is_velocity_set_, is_config_set_;
+  double current_linear_velocity_, command_linear_velocity_;
   double wheel_base_;
 
+  int32_t param_flag_;               // 0 = waypoint, 1 = Dialog
+  double const_lookahead_distance_;  // meter
+  double const_velocity_;            // km/h
+  double lookahead_distance_ratio_;
+  double minimum_lookahead_distance_;  // the next waypoint must be outside of this threshold.
+
   // callbacks
   void callbackFromConfig(const runtime_manager::ConfigWaypointFollowerConstPtr &amp;config);
   void callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg);
@@ -86,11 +107,20 @@ private:
   void initForROS();
 
   // functions
-  //void publish();
+  void publishTwistStamped(const bool &amp;can_get_curvature, const double &amp;kappa) const;
+  void publishControlCommandStamped(const bool &amp;can_get_curvature, const double &amp;kappa) const;
 
+  double computeLookaheadDistance() const;
+  double computeCommandVelocity() const;
 };
 
 double convertCurvatureToSteeringAngle(const double &amp;wheel_base, const double &amp;kappa);
+
+inline double kmph2mps(double velocity_kmph)
+{
+  return (velocity_kmph * 1000) / (60 * 60);
+}
+
 }  // waypoint_follower
 
 #endif  // PURE_PURSUIT_CORE_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="88abf1a2692580abcbcbeeb9aa5bdde22cbf28da" author="h_ohta">
		<msg>Delete unused functions</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" added_lines="0" deleted_lines="107">
				<diff>@@ -195,48 +195,6 @@ bool PurePursuit::interpolateNextTarget(int next_waypoint, geometry_msgs::Point
   }
 }
 
-bool PurePursuit::verifyFollowing() const
-{
-  double a = 0;
-  double b = 0;
-  double c = 0;
-  getLinearEquation(current_waypoints_.getWaypointPosition(1), current_waypoints_.getWaypointPosition(2), &amp;a, &amp;b, &amp;c);
-  double displacement = getDistanceBetweenLineAndPoint(current_pose_.pose.position, a, b, c);
-  double relative_angle = getRelativeAngle(current_waypoints_.getWaypointPose(1), current_pose_.pose);
-  // ROS_INFO("side diff : %lf , angle diff : %lf",displacement,relative_angle);
-  if (displacement &lt; displacement_threshold_ || relative_angle &lt; relative_angle_threshold_)
-  {
-    // ROS_INFO("Following : True");
-    return true;
-  }
-  else
-  {
-    // ROS_INFO("Following : False");
-    return false;
-  }
-}
-
-geometry_msgs::Twist PurePursuit::calcTwist(double curvature, double cmd_velocity) const
-{
-  // verify whether vehicle is following the path
-  bool following_flag = verifyFollowing();
-  static double prev_angular_velocity = 0;
-
-  geometry_msgs::Twist twist;
-  twist.linear.x = cmd_velocity;
-  if (!following_flag)
-  {
-    twist.angular.z = current_velocity_.twist.linear.x * curvature;
-  }
-  else
-  {
-    twist.angular.z = prev_angular_velocity;
-  }
-
-  prev_angular_velocity = twist.angular.z;
-  return twist;
-}
-
 void PurePursuit::getNextWaypoint()
 {
   int path_size = static_cast&lt;int&gt;(current_waypoints_.size());
@@ -272,71 +230,6 @@ void PurePursuit::getNextWaypoint()
   return;
 }
 
-geometry_msgs::TwistStamped PurePursuit::outputZero() const
-{
-  geometry_msgs::TwistStamped twist;
-  twist.twist.linear.x = 0;
-  twist.twist.angular.z = 0;
-  twist.header.stamp = ros::Time::now();
-  return twist;
-}
-
-geometry_msgs::TwistStamped PurePursuit::outputTwist(geometry_msgs::Twist t) const
-{
-  geometry_msgs::TwistStamped twist;
-  twist.twist = t;
-  twist.header.stamp = ros::Time::now();
-  return twist;
-}
-
-geometry_msgs::TwistStamped PurePursuit::go()
-{
-  if (!is_pose_set_ || !is_waypoint_set_ || !is_velocity_set_)
-  {
-    ROS_INFO("somethins is missing... ");
-    return outputZero();
-  }
-
-  calcLookaheadDistance();
-  // search next waypoint
-  getNextWaypoint();
-  if (next_waypoint_number_ == -1)
-  {
-    ROS_INFO("lost next waypoint");
-    return outputZero();
-  }
-
-  // if g_linear_interpolate_mode is false or next waypoint is first or last
-  if (!is_linear_interpolation_ || next_waypoint_number_ == 0 ||
-      next_waypoint_number_ == (static_cast&lt;int&gt;(current_waypoints_.getSize() - 1)))
-  {
-    next_target_position_ = current_waypoints_.getWaypointPosition(next_waypoint_number_);
-    return outputTwist(calcTwist(calcCurvature(next_target_position_), getCmdVelocity(0)));
-  }
-
-  // linear interpolation and calculate angular velocity
-  bool interpolation = interpolateNextTarget(next_waypoint_number_, &amp;next_target_position_);
-
-  if (!interpolation)
-  {
-    ROS_INFO_STREAM("lost target! ");
-    return outputZero();
-  }
-
-  // ROS_INFO("next_target : ( %lf , %lf , %lf)", next_target.x, next_target.y,next_target.z);
-
-  return outputTwist(calcTwist(calcCurvature(next_target_position_), getCmdVelocity(0)));
-
-// ROS_INFO("linear : %lf, angular : %lf",twist.twist.linear.x,twist.twist.angular.z);
-
-#ifdef LOG
-  std::ofstream ofs("/tmp/pure_pursuit.log", std::ios::app);
-  ofs &lt;&lt; _current_waypoints.getWaypointPosition(next_waypoint).x &lt;&lt; " "
-      &lt;&lt; _current_waypoints.getWaypointPosition(next_waypoint).y &lt;&lt; " " &lt;&lt; next_target.x &lt;&lt; " " &lt;&lt; next_target.y
-      &lt;&lt; std::endl;
-#endif
-}
-
 bool PurePursuit::canGetCurvature(double *output_kappa)
 {
   // search next waypoint
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" added_lines="0" deleted_lines="7">
				<diff>@@ -83,13 +83,11 @@ public:
   {
     return current_pose_;
   }
-
   double getLookaheadDistance() const
   {
     return lookahead_distance_;
   }
   // processing
-  geometry_msgs::TwistStamped go();
   bool canGetCurvature(double *output_kappa);
 
 private:
@@ -108,13 +106,8 @@ private:
 
   // functions
   double calcCurvature(geometry_msgs::Point target) const;
-  double calcRadius(geometry_msgs::Point target) const;
   bool interpolateNextTarget(int next_waypoint, geometry_msgs::Point *next_target) const;
-  bool verifyFollowing() const;
-  geometry_msgs::Twist calcTwist(double curvature, double cmd_velocity) const;
   void getNextWaypoint();
-  geometry_msgs::TwistStamped outputZero() const;
-  geometry_msgs::TwistStamped outputTwist(geometry_msgs::Twist t) const;
 };
 }  // waypoint_follower
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="96969ed4919cd66c3d7933b37ba4adf7530b5588" author="USUDA Hisashi">
		<msg>Rewrite vehicle_sender and autoware_socket for applying the topic /ctrl_cmd.</msg>
		<modified_files>
			<file old_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" new_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" added_lines="16" deleted_lines="2">
				<diff>@@ -35,6 +35,7 @@
 #include &lt;runtime_manager/accel_cmd.h&gt;
 #include &lt;runtime_manager/brake_cmd.h&gt;
 #include &lt;runtime_manager/steer_cmd.h&gt;
+#include &lt;waypoint_follower/ControlCommandStamped.h&gt;
 
 #include &lt;iostream&gt;
 #include &lt;string&gt;
@@ -54,6 +55,8 @@ struct CommandData {
   int accellValue;
   int brakeValue;
   int steerValue;
+  double linear_velocity;
+  double steering_angle;
 
   void reset();
 };
@@ -67,6 +70,8 @@ void CommandData::reset()
   accellValue = 0;
   brakeValue  = 0;
   steerValue  = 0;
+  linear_velocity = -1;
+  steering_angle = 0;
 }
 
 static CommandData command_data;
@@ -106,6 +111,12 @@ static void brakeCMDCallback(const runtime_manager::brake_cmd &amp;brake)
   command_data.brakeValue = brake.brake;
 }
 
+static void ctrlCMDCallback(const waypoint_follower::ControlCommandStamped&amp; msg)
+{
+  command_data.linear_velocity = msg.cmd.linear_velocity;
+  command_data.steering_angle = msg.cmd.steering_angle;
+}
+
 static void *sendCommand(void *arg)
 {
   int *client_sockp = static_cast&lt;int*&gt;(arg);
@@ -119,7 +130,9 @@ static void *sendCommand(void *arg)
   oss &lt;&lt; command_data.gearValue &lt;&lt; ",";
   oss &lt;&lt; command_data.accellValue &lt;&lt; ",";
   oss &lt;&lt; command_data.brakeValue &lt;&lt; ",";
-  oss &lt;&lt; command_data.steerValue;
+  oss &lt;&lt; command_data.steerValue &lt;&lt; ",";
+  oss &lt;&lt; command_data.linear_velocity &lt;&lt; ",";
+  oss &lt;&lt; command_data.steering_angle;
 
   std::string cmd(oss.str());
   ssize_t n = write(client_sock, cmd.c_str(), cmd.size());
@@ -204,13 +217,14 @@ int main(int argc, char **argv)
   ros::NodeHandle nh;
 
   std::cout &lt;&lt; "vehicle sender" &lt;&lt; std::endl;
-  ros::Subscriber sub[6];
+  ros::Subscriber sub[7];
   sub[0] = nh.subscribe("/twist_cmd", 1, twistCMDCallback);
   sub[1] = nh.subscribe("/mode_cmd",  1, modeCMDCallback);
   sub[2] = nh.subscribe("/gear_cmd",  1, gearCMDCallback);
   sub[3] = nh.subscribe("/accel_cmd", 1, accellCMDCallback);
   sub[4] = nh.subscribe("/steer_cmd", 1, steerCMDCallback);
   sub[5] = nh.subscribe("/brake_cmd", 1, brakeCMDCallback);
+  sub[6] = nh.subscribe("/ctrl_cmd", 1, ctrlCMDCallback);
 
   command_data.reset();
 
</diff>
			</file>
			<file old_path="vehicle\zmp\autoware_socket\autoware_socket.h" new_path="vehicle\zmp\autoware_socket\autoware_socket.h" added_lines="2" deleted_lines="0">
				<diff>@@ -83,6 +83,8 @@ typedef struct pose_data {
 typedef struct vel_data {
   double tv;
   double sv;
+  double lv; // linear_velocity
+  double sa; // steering_angle
   long long int tstamp;
 } vel_data_t;
 
</diff>
			</file>
			<file old_path="vehicle\zmp\autoware_socket\cmd.cpp" new_path="vehicle\zmp\autoware_socket\cmd.cpp" added_lines="34" deleted_lines="5">
				<diff>@@ -135,7 +135,7 @@ void Getter(CMDDATA &amp;cmddata)
   // string version
   std::vector&lt;std::string&gt; cmdVector;
   cmdVector = split(cmdRes,',');
-  if (cmdVector.size() == 7) {
+  if (cmdVector.size() == 7 || cmdVector.size() == 9) {
     cmddata.vel.tv = atof(cmdVector[0].c_str());
     cmddata.vel.sv = atof(cmdVector[1].c_str());
     
@@ -155,6 +155,14 @@ void Getter(CMDDATA &amp;cmddata)
     cmddata.accel = atoi(cmdVector[4].c_str());
     cmddata.steer = atoi(cmdVector[5].c_str());
     cmddata.brake = atoi(cmdVector[6].c_str());
+
+    if (cmdVector.size() == 7) {
+      cmddata.vel.lv = -1;
+      cmddata.vel.sa = 0;
+    } else {
+      cmddata.vel.lv = atof(cmdVector[7].c_str());
+      cmddata.vel.sa = atof(cmdVector[8].c_str());
+    }
   } else {
     fprintf(stderr,"cmd : Recv data is invalid\n");
   }
@@ -199,7 +207,12 @@ void Control(vel_data_t vel, void* p)
   double current_velocity = vstate.velocity; // km/h
   double current_steering_angle = vstate.steering_angle; // degree
  
-  int cmd_velocity = vel.tv * 3.6;
+  int cmd_velocity;
+  if (vel.lv &lt; 0) {
+    cmd_velocity = vel.tv * 3.6;
+  } else {
+    cmd_velocity = vel.lv * 3.6;
+  }
   int cmd_steering_angle;
 
   // We assume that the slope against the entire arc toward the 
@@ -208,13 +221,29 @@ void Control(vel_data_t vel, void* p)
   // \theta = cmd_wheel_angle
   // vel.sv/vel.tv = Radius
   // l \simeq VEHICLE_LENGTH
-  if (vel.tv &lt; 0.1) { // just avoid divided by zero.
+  if (vel.tv &lt; 0.1 &amp;&amp; vel.lv &lt; 0) { // just avoid divided by zero.
     cmd_steering_angle = current_steering_angle;
   }
   else {
-    double wheel_angle_pi = (vel.sv / vel.tv) * WHEEL_BASE;
-    double wheel_angle = (wheel_angle_pi / M_PI) * 180.0;
+    double wheel_angle_pi;
+    double wheel_angle;
+    if (vel.lv &lt; 0) {
+      wheel_angle_pi = (vel.sv / vel.tv) * WHEEL_BASE;
+    } else {
+      wheel_angle_pi = vel.sa;
+    }
+    wheel_angle = (wheel_angle_pi / M_PI) * 180.0;
     cmd_steering_angle = wheel_angle * WHEEL_TO_STEERING;
+#if 0 /* log */
+    ofstream ofs("/tmp/lvsa.log", ios::app);
+    ofs &lt;&lt; vel.tv &lt;&lt; " " 
+      &lt;&lt; vel.sv &lt;&lt; " " 
+      &lt;&lt; vel.lv &lt;&lt; " " 
+      &lt;&lt; vel.sa &lt;&lt; " " 
+      &lt;&lt; (((vel.sv / vel.tv) * WHEEL_BASE)/M_PI*180.0) &lt;&lt; " "
+      &lt;&lt; (vel.sa/M_PI*180.0) &lt;&lt; " "
+      &lt;&lt; endl;
+#endif
   }
 
 #if 0 /* just for a debug */
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b3eb79efe32b8fa9e061bb90ecbb66b4483d870c" author="h_ohta">
		<msg>Rewrite nmea2tfpose Node</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose.cpp" new_path="" added_lines="0" deleted_lines="206">
				<diff>@@ -1,206 +0,0 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include &lt;fstream&gt;
-#include &lt;iostream&gt;
-#include &lt;string&gt;
-#include &lt;sstream&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;nmea_msgs/Sentence.h&gt;
-#include &lt;tf/transform_broadcaster.h&gt;
-#include &lt;geometry_msgs/PoseStamped.h&gt;
-#include &lt;std_msgs/Bool.h&gt;
-
-#include "geo_pos_conv.hh"
-
-static geo_pos_conv geo;
-static ros::Publisher pose_publisher;
-static ros::Publisher stat_publisher;
-static std_msgs::Bool gnss_stat_msg;
-static int _plane = 0;
-#define NEW_QQ_SIZE 11
-
-using namespace std;
-
-static void csv_div(string str, std::vector&lt;std::string&gt; *items)
-{
-    string token;
-    istringstream stream(str);
-
-    items-&gt;clear();
-    while (getline(stream, token, ',')) {
-        //printf("%s|  ",token.c_str());
-        items-&gt;push_back(token);
-    }
-    //  printf("\n");
-}
-/*
- double str2double(std::string str)
- {
- stringstream ss;
- double val;
- ss &lt;&lt; str;
- ss &gt;&gt; val;
- return val;
- }
- */
-
-static void NmeaCallback(const nmea_msgs::Sentence::ConstPtr&amp; msg)
-{
-    static double qq_time, roll, pitch, yaw;
-    //static double gga_time, x, y, z;
-    static double gga_time;
-    static tf::TransformBroadcaster br;
-    static ros::Time pc_time;
-    std::vector&lt;std::string&gt; nmea;
-    csv_div(msg-&gt;sentence, &amp;nmea);
-    //static bool calibration_flag = true;
-
-    // printf("%s\n",msg-&gt;sentence.c_str());
-
-    if (nmea[0].compare(0, 2, "QQ") == 0) {
-        pc_time = msg-&gt;header.stamp;
-        /*
-         qq_time = str2double(nmea[3]);
-         roll = str2double(nmea[4]) * M_PI / 180.;
-         pitch = -1 * str2double(nmea[5]) * M_PI / 180.;
-         yaw = -1 * str2double(nmea[6]) * M_PI / 180. + M_PI / 2;
-         */
-        qq_time = stod(nmea[3]);
-        roll = stod(nmea[4]) * M_PI / 180.;
-        pitch = -1 * stod(nmea[5]) * M_PI / 180.;
-        yaw = -1 * stod(nmea[6]) * M_PI / 180. + M_PI / 2;
-
-        // new QQ message
-   /*     if (nmea.size() == NEW_QQ_SIZE) {
-            if (stod(nmea[7]) == 1 &amp;&amp; stod(nmea[8]) == 1 &amp;&amp; stod(nmea[9]) == 1) {
-                calibration_flag = true;
-            } else {
-                calibration_flag = false;
-            }
-        }*/
-        //printf("angle %f  %f %f %f\n",qq_time,roll,pitch,yaw);
-    }
-
-//    if (calibration_flag == true) {
-        if (nmea[0] == "$GPGGA") {
-            pc_time = msg-&gt;header.stamp;
-            /*
-             gga_time = str2double(nmea[1]);
-             double lat = str2double(nmea[2]);
-             double lon = str2double(nmea[4]);
-             double h = str2double(nmea[9]); //+str2double(nmea[11]);
-             */
-            gga_time = stod(nmea[1]);
-            double lat = stod(nmea[2]);
-            double lon = stod(nmea[4]);
-            double h = stod(nmea[9]);
-
-            geo.set_llh_nmea_degrees(lat, lon, h);
-            //    printf("pos %f  %f %f %f\n",gga_time,geo.x,geo.y,geo.z);
-        }
-
-
-        if (nmea[0] == "$PASHR") {
-          pc_time = msg-&gt;header.stamp;
-          qq_time = stod(nmea[1]);
-          roll    = stod(nmea[4]) * M_PI / 180.;
-          pitch   = -1 * stod(nmea[5]) * M_PI / 180.;
-          yaw     = -1 * stod(nmea[2]) * M_PI / 180. + M_PI / 2;
-        }
-
-        if (nmea[0] == "$GNGGA") {
-            pc_time    = msg-&gt;header.stamp;
-            gga_time   = stod(nmea[1]);
-            double lat = stod(nmea[2]);
-            double lon = stod(nmea[4]);
-            double h   = stod(nmea[9]);
-
-            geo.set_llh_nmea_degrees(lat, lon, h);
-        }
-
-
-        // if (qq_time == gga_time) {
-        if (fabs(qq_time - gga_time) &lt;= __FLT_EPSILON__) {
-            //printf("%f %f %f %f %f  %f %f %f\n", pc_time.toSec(), gga_time, geo.x(), geo.y(), geo.z(), roll, pitch, yaw);
-
-            tf::Transform transform;
-            tf::Quaternion q;
-
-            transform.setOrigin(tf::Vector3(geo.y(), geo.x(), geo.z()));
-            q.setRPY(roll, pitch, yaw);
-            transform.setRotation(q);
-            br.sendTransform(tf::StampedTransform(transform, pc_time, "map", "gps"));
-
-            geometry_msgs::PoseStamped pose;
-            pose.header = msg-&gt;header;
-            pose.header.frame_id = "map";
-            pose.pose.position.x = geo.y();
-            pose.pose.position.y = geo.x();
-            pose.pose.position.z = geo.z();
-            pose.pose.orientation.x = q.x();
-            pose.pose.orientation.y = q.y();
-            pose.pose.orientation.z = q.z();
-            pose.pose.orientation.w = q.w();
-
-            // set gnss_stat
-            if (pose.pose.position.x == 0.0 || pose.pose.position.y == 0.0 || pose.pose.position.z == 0.0) {
-                gnss_stat_msg.data = false;
-            } else {
-                gnss_stat_msg.data = true;
-            }
-
-            pose_publisher.publish(pose);
-            stat_publisher.publish(gnss_stat_msg);
-        }
- /*   } else {
-        std::cout &lt;&lt; "not calibrated!!" &lt;&lt; std::endl;
-    }*/
-}
-
-int main(int argc, char **argv)
-{
-    ros::init(argc, argv, "nmea2tfpose");
-
-    ros::NodeHandle n;
-    ros::NodeHandle private_nh("~");
-
-    private_nh.getParam("plane", _plane);
-    std::cout &lt;&lt; "plane number : " &lt;&lt; _plane &lt;&lt; std::endl;
-
-    geo.set_plane(_plane);
-    ros::Subscriber sub = n.subscribe("nmea_sentence", 1000, NmeaCallback);
-    pose_publisher = n.advertise&lt;geometry_msgs::PoseStamped&gt;("gnss_pose", 1000);
-    stat_publisher = n.advertise&lt;std_msgs::Bool&gt;("/gnss_stat", 100);
-    ros::spin();
-
-    return 0;
-}
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="956f0c4bf728201a783725639e36332765793aca" author="yukikitsukawa">
		<msg>Modifed the origin of the map.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="2" deleted_lines="1">
				<diff>@@ -206,7 +206,8 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     
     // Add initial point cloud to velodyne_map
     if(initial_scan_loaded == 0){
-      map += *scan_ptr;
+      pcl::transformPointCloud(*scan_ptr, *transformed_scan_ptr, tf_btol);
+      map += *transformed_scan_ptr;
       initial_scan_loaded = 1;
     }
     
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f0fbdfbb0b5741f073c46403e327bc0a05b7e8c1" author="yukikitsukawa">
		<msg>Apply clang-format.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="326" deleted_lines="306">
				<diff>@@ -34,7 +34,7 @@
  Yuki KITSUKAWA
  */
 
-#define OUTPUT // If you want to output "position_log.txt", "#define OUTPUT".
+#define OUTPUT  // If you want to output "position_log.txt", "#define OUTPUT".
 
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;
@@ -67,33 +67,35 @@
 #include &lt;runtime_manager/ConfigNdtMapping.h&gt;
 #include &lt;runtime_manager/ConfigNdtMappingOutput.h&gt;
 
-struct pose {
-    double x;
-    double y;
-    double z;
-    double roll;
-    double pitch;
-    double yaw;
+struct pose
+{
+  double x;
+  double y;
+  double z;
+  double roll;
+  double pitch;
+  double yaw;
 };
 
 // global variables
 static pose previous_pose, guess_pose, current_pose, ndt_pose, added_pose, localizer_pose;
 
-static double offset_x, offset_y, offset_z, offset_yaw; // current_pose - previous_pose
+static double offset_x, offset_y, offset_z, offset_yaw;  // current_pose - previous_pose
 
 static pcl::PointCloud&lt;pcl::PointXYZI&gt; map;
 
 static pcl::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; ndt;
 // Default values
-static int iter = 30; // Maximum iterations
-static float ndt_res = 1.0; // Resolution
-static double step_size = 0.1; // Step size
-static double trans_eps = 0.01; // Transformation epsilon
+static int iter = 30;            // Maximum iterations
+static float ndt_res = 1.0;      // Resolution
+static double step_size = 0.1;   // Step size
+static double trans_eps = 0.01;  // Transformation epsilon
 
 // Leaf size of VoxelGrid filter.
 static double voxel_leaf_size = 2.0;
 
-static ros::Time callback_start, callback_end, t1_start, t1_end, t2_start, t2_end, t3_start, t3_end, t4_start, t4_end, t5_start, t5_end;
+static ros::Time callback_start, callback_end, t1_start, t1_end, t2_start, t2_end, t3_start, t3_end, t4_start, t4_end,
+    t5_start, t5_end;
 static ros::Duration d_callback, d1, d2, d3, d4, d5;
 
 static ros::Publisher ndt_map_pub;
@@ -147,10 +149,13 @@ static void output_callback(const runtime_manager::ConfigNdtMappingOutput::Const
   sensor_msgs::PointCloud2::Ptr map_msg_ptr(new sensor_msgs::PointCloud2);
 
   // Apply voxelgrid filter
-  if(filter_res == 0.0){
+  if (filter_res == 0.0)
+  {
     std::cout &lt;&lt; "Original: " &lt;&lt; map_ptr-&gt;points.size() &lt;&lt; " points." &lt;&lt; std::endl;
     pcl::toROSMsg(*map_ptr, *map_msg_ptr);
-  }else{
+  }
+  else
+  {
     pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
     voxel_grid_filter.setLeafSize(filter_res, filter_res, filter_res);
     voxel_grid_filter.setInputCloud(map_ptr);
@@ -163,320 +168,335 @@ static void output_callback(const runtime_manager::ConfigNdtMappingOutput::Const
   ndt_map_pub.publish(*map_msg_ptr);
 
   // Writing Point Cloud data to PCD file
-  if(filter_res == 0.0){
+  if (filter_res == 0.0)
+  {
     pcl::io::savePCDFileASCII(filename, *map_ptr);
     std::cout &lt;&lt; "Saved " &lt;&lt; map_ptr-&gt;points.size() &lt;&lt; " data points to " &lt;&lt; filename &lt;&lt; "." &lt;&lt; std::endl;
-  }else{
+  }
+  else
+  {
     pcl::io::savePCDFileASCII(filename, *map_filtered);
     std::cout &lt;&lt; "Saved " &lt;&lt; map_filtered-&gt;points.size() &lt;&lt; " data points to " &lt;&lt; filename &lt;&lt; "." &lt;&lt; std::endl;
-  }    
+  }
 }
 
 static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 {
-    double r;
-    pcl::PointXYZI p; 
-    pcl::PointCloud&lt;pcl::PointXYZI&gt; tmp, scan;
-    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr (new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
-    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr transformed_scan_ptr (new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
-    tf::Quaternion q;
-
-    Eigen::Matrix4f t_localizer(Eigen::Matrix4f::Identity());
-    Eigen::Matrix4f t_base_link(Eigen::Matrix4f::Identity());
-    tf::TransformBroadcaster br;
-    tf::Transform transform;
-
-    ros::Time scan_time = input-&gt;header.stamp;
-
-    pcl::fromROSMsg(*input, tmp);
-
-    for (pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator item = tmp.begin(); item != tmp.end(); item++){
-    	p.x = (double) item-&gt;x;
-    	p.y = (double) item-&gt;y;
-    	p.z = (double) item-&gt;z;
-    	p.intensity = (double) item-&gt;intensity;
-
-    	r = sqrt(pow(p.x, 2.0) + pow(p.y, 2.0));
-    	if(r &gt; RANGE){
-    		scan.push_back(p);
-    	}
+  double r;
+  pcl::PointXYZI p;
+  pcl::PointCloud&lt;pcl::PointXYZI&gt; tmp, scan;
+  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
+  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr transformed_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
+  tf::Quaternion q;
+
+  Eigen::Matrix4f t_localizer(Eigen::Matrix4f::Identity());
+  Eigen::Matrix4f t_base_link(Eigen::Matrix4f::Identity());
+  tf::TransformBroadcaster br;
+  tf::Transform transform;
+
+  ros::Time scan_time = input-&gt;header.stamp;
+
+  pcl::fromROSMsg(*input, tmp);
+
+  for (pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator item = tmp.begin(); item != tmp.end(); item++)
+  {
+    p.x = (double)item-&gt;x;
+    p.y = (double)item-&gt;y;
+    p.z = (double)item-&gt;z;
+    p.intensity = (double)item-&gt;intensity;
+
+    r = sqrt(pow(p.x, 2.0) + pow(p.y, 2.0));
+    if (r &gt; RANGE)
+    {
+      scan.push_back(p);
     }
+  }
 
-    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(scan));
-    
-    // Add initial point cloud to velodyne_map
-    if(initial_scan_loaded == 0){
-      pcl::transformPointCloud(*scan_ptr, *transformed_scan_ptr, tf_btol);
-      map += *transformed_scan_ptr;
-      initial_scan_loaded = 1;
-    }
-    
-    // Apply voxelgrid filter
-    pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
-    voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
-    voxel_grid_filter.setInputCloud(scan_ptr);
-    voxel_grid_filter.filter(*filtered_scan_ptr);
-    
-    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
-
-    ndt.setTransformationEpsilon(trans_eps);
-    ndt.setStepSize(step_size);
-    ndt.setResolution(ndt_res);
-    ndt.setMaximumIterations(iter);
-    ndt.setInputSource(filtered_scan_ptr);
-    
-    if(isMapUpdate == true){
-    	ndt.setInputTarget(map_ptr);
-    	isMapUpdate = false;
-    }
+  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(scan));
+
+  // Add initial point cloud to velodyne_map
+  if (initial_scan_loaded == 0)
+  {
+    pcl::transformPointCloud(*scan_ptr, *transformed_scan_ptr, tf_btol);
+    map += *transformed_scan_ptr;
+    initial_scan_loaded = 1;
+  }
 
-    guess_pose.x = previous_pose.x + offset_x;
-    guess_pose.y = previous_pose.y + offset_y;
-    guess_pose.z = previous_pose.z + offset_z;
-    guess_pose.roll = previous_pose.roll;
-    guess_pose.pitch = previous_pose.pitch;
-    guess_pose.yaw = previous_pose.yaw + offset_yaw;
-    
-    Eigen::AngleAxisf init_rotation_x(guess_pose.roll, Eigen::Vector3f::UnitX());
-    Eigen::AngleAxisf init_rotation_y(guess_pose.pitch, Eigen::Vector3f::UnitY());
-    Eigen::AngleAxisf init_rotation_z(guess_pose.yaw, Eigen::Vector3f::UnitZ());
-    
-    Eigen::Translation3f init_translation(guess_pose.x, guess_pose.y, guess_pose.z);
-    
-    Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).matrix() * tf_btol;
-    
-    t3_end = ros::Time::now();
-    d3 = t3_end - t3_start;
-    
-    t4_start = ros::Time::now();
-
-    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
+  // Apply voxelgrid filter
+  pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
+  voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
+  voxel_grid_filter.setInputCloud(scan_ptr);
+  voxel_grid_filter.filter(*filtered_scan_ptr);
+
+  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
+
+  ndt.setTransformationEpsilon(trans_eps);
+  ndt.setStepSize(step_size);
+  ndt.setResolution(ndt_res);
+  ndt.setMaximumIterations(iter);
+  ndt.setInputSource(filtered_scan_ptr);
+
+  if (isMapUpdate == true)
+  {
+    ndt.setInputTarget(map_ptr);
+    isMapUpdate = false;
+  }
+
+  guess_pose.x = previous_pose.x + offset_x;
+  guess_pose.y = previous_pose.y + offset_y;
+  guess_pose.z = previous_pose.z + offset_z;
+  guess_pose.roll = previous_pose.roll;
+  guess_pose.pitch = previous_pose.pitch;
+  guess_pose.yaw = previous_pose.yaw + offset_yaw;
+
+  Eigen::AngleAxisf init_rotation_x(guess_pose.roll, Eigen::Vector3f::UnitX());
+  Eigen::AngleAxisf init_rotation_y(guess_pose.pitch, Eigen::Vector3f::UnitY());
+  Eigen::AngleAxisf init_rotation_z(guess_pose.yaw, Eigen::Vector3f::UnitZ());
+
+  Eigen::Translation3f init_translation(guess_pose.x, guess_pose.y, guess_pose.z);
+
+  Eigen::Matrix4f init_guess =
+      (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).matrix() * tf_btol;
+
+  t3_end = ros::Time::now();
+  d3 = t3_end - t3_start;
+
+  t4_start = ros::Time::now();
+
+  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
 #ifdef USE_FAST_PCL
-    if(_use_openmp == true){
-    	ndt.omp_align(*output_cloud, init_guess);
-    	fitness_score = ndt.omp_getFitnessScore();
-    }else{
+  if (_use_openmp == true)
+  {
+    ndt.omp_align(*output_cloud, init_guess);
+    fitness_score = ndt.omp_getFitnessScore();
+  }
+  else
+  {
 #endif
-    	ndt.align(*output_cloud, init_guess);
-    	fitness_score = ndt.getFitnessScore();
+    ndt.align(*output_cloud, init_guess);
+    fitness_score = ndt.getFitnessScore();
 #ifdef USE_FAST_PCL
-    }
+  }
 #endif
-    
-    t_localizer = ndt.getFinalTransformation();
-    t_base_link = t_localizer * tf_ltob;
-
-    pcl::transformPointCloud(*scan_ptr, *transformed_scan_ptr, t_localizer);
-
-    tf::Matrix3x3 mat_l, mat_b;
-
-    mat_l.setValue(static_cast&lt;double&gt;(t_localizer(0, 0)), static_cast&lt;double&gt;(t_localizer(0, 1)), static_cast&lt;double&gt;(t_localizer(0, 2)),
-		  static_cast&lt;double&gt;(t_localizer(1, 0)), static_cast&lt;double&gt;(t_localizer(1, 1)), static_cast&lt;double&gt;(t_localizer(1, 2)),
-		  static_cast&lt;double&gt;(t_localizer(2, 0)), static_cast&lt;double&gt;(t_localizer(2, 1)), static_cast&lt;double&gt;(t_localizer(2, 2)));
-    
-    
-    mat_b.setValue(static_cast&lt;double&gt;(t_base_link(0, 0)), static_cast&lt;double&gt;(t_base_link(0, 1)), static_cast&lt;double&gt;(t_base_link(0, 2)),
-		  static_cast&lt;double&gt;(t_base_link(1, 0)), static_cast&lt;double&gt;(t_base_link(1, 1)), static_cast&lt;double&gt;(t_base_link(1, 2)),
-		  static_cast&lt;double&gt;(t_base_link(2, 0)), static_cast&lt;double&gt;(t_base_link(2, 1)), static_cast&lt;double&gt;(t_base_link(2, 2)));
-    
-    // Update localizer_pose.
-    localizer_pose.x = t_localizer(0, 3);
-    localizer_pose.y = t_localizer(1, 3);
-    localizer_pose.z = t_localizer(2, 3);
-    mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1);
-    
-    // Update ndt_pose.
-    ndt_pose.x = t_base_link(0, 3);
-    ndt_pose.y = t_base_link(1, 3);
-    ndt_pose.z = t_base_link(2, 3);
-    mat_b.getRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, 1);
-    
-    current_pose.x = ndt_pose.x;
-    current_pose.y = ndt_pose.y;
-    current_pose.z = ndt_pose.z;
-    current_pose.roll = ndt_pose.roll;
-    current_pose.pitch = ndt_pose.pitch;
-    current_pose.yaw = ndt_pose.yaw;
-
-    transform.setOrigin(tf::Vector3(current_pose.x, current_pose.y, current_pose.z));
-    q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
-    transform.setRotation(q);
-    
-    br.sendTransform(tf::StampedTransform(transform, scan_time, "map", "base_link"));
-    
-    // Calculate the offset (curren_pos - previous_pos)
-    offset_x = current_pose.x - previous_pose.x;
-    offset_y = current_pose.y - previous_pose.y;
-    offset_z = current_pose.z - previous_pose.z;
-    offset_yaw = current_pose.yaw - previous_pose.yaw;
-    
-    // Update position and posture. current_pos -&gt; previous_pos
-    previous_pose.x = current_pose.x;
-    previous_pose.y = current_pose.y;
-    previous_pose.z = current_pose.z;
-    previous_pose.roll = current_pose.roll;
-    previous_pose.pitch = current_pose.pitch;
-    previous_pose.yaw = current_pose.yaw;
-    
-    // Calculate the shift between added_pos and current_pos
-    double shift = sqrt(pow(current_pose.x-added_pose.x, 2.0) + pow(current_pose.y-added_pose.y, 2.0));
-    if(shift &gt;= SHIFT){
-      map += *transformed_scan_ptr;
-      added_pose.x = current_pose.x;
-      added_pose.y = current_pose.y;
-      added_pose.z = current_pose.z;
-      added_pose.roll = current_pose.roll;
-      added_pose.pitch = current_pose.pitch;
-      added_pose.yaw = current_pose.yaw;
-      isMapUpdate = true;
-    }
-    
-    sensor_msgs::PointCloud2::Ptr map_msg_ptr(new sensor_msgs::PointCloud2);
-    pcl::toROSMsg(*map_ptr, *map_msg_ptr);
-    ndt_map_pub.publish(*map_msg_ptr);
-    
-    q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
-    current_pose_msg.header.frame_id = "map";
-    current_pose_msg.header.stamp = scan_time;
-    current_pose_msg.pose.position.x = current_pose.x;
-    current_pose_msg.pose.position.y = current_pose.y;
-    current_pose_msg.pose.position.z = current_pose.z;
-    current_pose_msg.pose.orientation.x = q.x();
-    current_pose_msg.pose.orientation.y = q.y();
-    current_pose_msg.pose.orientation.z = q.z();
-    current_pose_msg.pose.orientation.w = q.w();
-    
-    current_pose_pub.publish(current_pose_msg);
-    
-    std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
-    std::cout &lt;&lt; "Sequence number: " &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
-    std::cout &lt;&lt; "Number of scan points: " &lt;&lt; scan_ptr-&gt;size() &lt;&lt; " points." &lt;&lt; std::endl;
-    std::cout &lt;&lt; "Number of filtered scan points: " &lt;&lt; filtered_scan_ptr-&gt;size() &lt;&lt; " points." &lt;&lt; std::endl;
-    std::cout &lt;&lt; "transformed_scan_ptr: " &lt;&lt; transformed_scan_ptr-&gt;points.size() &lt;&lt; " points." &lt;&lt; std::endl;
-    std::cout &lt;&lt; "map: " &lt;&lt; map.points.size() &lt;&lt; " points." &lt;&lt; std::endl;
-    std::cout &lt;&lt; "NDT has converged: " &lt;&lt; ndt.hasConverged() &lt;&lt; std::endl;
-    std::cout &lt;&lt; "Fitness score: " &lt;&lt; fitness_score &lt;&lt; std::endl;
-    std::cout &lt;&lt; "Number of iteration: " &lt;&lt; ndt.getFinalNumIteration() &lt;&lt; std::endl;
-    std::cout &lt;&lt; "(x,y,z,roll,pitch,yaw):" &lt;&lt; std::endl;
-    std::cout &lt;&lt; "(" &lt;&lt; current_pose.x &lt;&lt; ", " &lt;&lt; current_pose.y &lt;&lt; ", " &lt;&lt; current_pose.z &lt;&lt; ", " &lt;&lt; current_pose.roll &lt;&lt; ", " &lt;&lt; current_pose.pitch &lt;&lt; ", " &lt;&lt; current_pose.yaw &lt;&lt; ")" &lt;&lt; std::endl;
-    std::cout &lt;&lt; "Transformation Matrix:" &lt;&lt; std::endl;
-    std::cout &lt;&lt; t_localizer &lt;&lt; std::endl;
-    std::cout &lt;&lt; "shift: " &lt;&lt; shift &lt;&lt; std::endl;
-    std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
-    
+
+  t_localizer = ndt.getFinalTransformation();
+  t_base_link = t_localizer * tf_ltob;
+
+  pcl::transformPointCloud(*scan_ptr, *transformed_scan_ptr, t_localizer);
+
+  tf::Matrix3x3 mat_l, mat_b;
+
+  mat_l.setValue(static_cast&lt;double&gt;(t_localizer(0, 0)), static_cast&lt;double&gt;(t_localizer(0, 1)),
+                 static_cast&lt;double&gt;(t_localizer(0, 2)), static_cast&lt;double&gt;(t_localizer(1, 0)),
+                 static_cast&lt;double&gt;(t_localizer(1, 1)), static_cast&lt;double&gt;(t_localizer(1, 2)),
+                 static_cast&lt;double&gt;(t_localizer(2, 0)), static_cast&lt;double&gt;(t_localizer(2, 1)),
+                 static_cast&lt;double&gt;(t_localizer(2, 2)));
+
+  mat_b.setValue(static_cast&lt;double&gt;(t_base_link(0, 0)), static_cast&lt;double&gt;(t_base_link(0, 1)),
+                 static_cast&lt;double&gt;(t_base_link(0, 2)), static_cast&lt;double&gt;(t_base_link(1, 0)),
+                 static_cast&lt;double&gt;(t_base_link(1, 1)), static_cast&lt;double&gt;(t_base_link(1, 2)),
+                 static_cast&lt;double&gt;(t_base_link(2, 0)), static_cast&lt;double&gt;(t_base_link(2, 1)),
+                 static_cast&lt;double&gt;(t_base_link(2, 2)));
+
+  // Update localizer_pose.
+  localizer_pose.x = t_localizer(0, 3);
+  localizer_pose.y = t_localizer(1, 3);
+  localizer_pose.z = t_localizer(2, 3);
+  mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1);
+
+  // Update ndt_pose.
+  ndt_pose.x = t_base_link(0, 3);
+  ndt_pose.y = t_base_link(1, 3);
+  ndt_pose.z = t_base_link(2, 3);
+  mat_b.getRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, 1);
+
+  current_pose.x = ndt_pose.x;
+  current_pose.y = ndt_pose.y;
+  current_pose.z = ndt_pose.z;
+  current_pose.roll = ndt_pose.roll;
+  current_pose.pitch = ndt_pose.pitch;
+  current_pose.yaw = ndt_pose.yaw;
+
+  transform.setOrigin(tf::Vector3(current_pose.x, current_pose.y, current_pose.z));
+  q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
+  transform.setRotation(q);
+
+  br.sendTransform(tf::StampedTransform(transform, scan_time, "map", "base_link"));
+
+  // Calculate the offset (curren_pos - previous_pos)
+  offset_x = current_pose.x - previous_pose.x;
+  offset_y = current_pose.y - previous_pose.y;
+  offset_z = current_pose.z - previous_pose.z;
+  offset_yaw = current_pose.yaw - previous_pose.yaw;
+
+  // Update position and posture. current_pos -&gt; previous_pos
+  previous_pose.x = current_pose.x;
+  previous_pose.y = current_pose.y;
+  previous_pose.z = current_pose.z;
+  previous_pose.roll = current_pose.roll;
+  previous_pose.pitch = current_pose.pitch;
+  previous_pose.yaw = current_pose.yaw;
+
+  // Calculate the shift between added_pos and current_pos
+  double shift = sqrt(pow(current_pose.x - added_pose.x, 2.0) + pow(current_pose.y - added_pose.y, 2.0));
+  if (shift &gt;= SHIFT)
+  {
+    map += *transformed_scan_ptr;
+    added_pose.x = current_pose.x;
+    added_pose.y = current_pose.y;
+    added_pose.z = current_pose.z;
+    added_pose.roll = current_pose.roll;
+    added_pose.pitch = current_pose.pitch;
+    added_pose.yaw = current_pose.yaw;
+    isMapUpdate = true;
+  }
+
+  sensor_msgs::PointCloud2::Ptr map_msg_ptr(new sensor_msgs::PointCloud2);
+  pcl::toROSMsg(*map_ptr, *map_msg_ptr);
+  ndt_map_pub.publish(*map_msg_ptr);
+
+  q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
+  current_pose_msg.header.frame_id = "map";
+  current_pose_msg.header.stamp = scan_time;
+  current_pose_msg.pose.position.x = current_pose.x;
+  current_pose_msg.pose.position.y = current_pose.y;
+  current_pose_msg.pose.position.z = current_pose.z;
+  current_pose_msg.pose.orientation.x = q.x();
+  current_pose_msg.pose.orientation.y = q.y();
+  current_pose_msg.pose.orientation.z = q.z();
+  current_pose_msg.pose.orientation.w = q.w();
+
+  current_pose_pub.publish(current_pose_msg);
+
+  std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
+  std::cout &lt;&lt; "Sequence number: " &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
+  std::cout &lt;&lt; "Number of scan points: " &lt;&lt; scan_ptr-&gt;size() &lt;&lt; " points." &lt;&lt; std::endl;
+  std::cout &lt;&lt; "Number of filtered scan points: " &lt;&lt; filtered_scan_ptr-&gt;size() &lt;&lt; " points." &lt;&lt; std::endl;
+  std::cout &lt;&lt; "transformed_scan_ptr: " &lt;&lt; transformed_scan_ptr-&gt;points.size() &lt;&lt; " points." &lt;&lt; std::endl;
+  std::cout &lt;&lt; "map: " &lt;&lt; map.points.size() &lt;&lt; " points." &lt;&lt; std::endl;
+  std::cout &lt;&lt; "NDT has converged: " &lt;&lt; ndt.hasConverged() &lt;&lt; std::endl;
+  std::cout &lt;&lt; "Fitness score: " &lt;&lt; fitness_score &lt;&lt; std::endl;
+  std::cout &lt;&lt; "Number of iteration: " &lt;&lt; ndt.getFinalNumIteration() &lt;&lt; std::endl;
+  std::cout &lt;&lt; "(x,y,z,roll,pitch,yaw):" &lt;&lt; std::endl;
+  std::cout &lt;&lt; "(" &lt;&lt; current_pose.x &lt;&lt; ", " &lt;&lt; current_pose.y &lt;&lt; ", " &lt;&lt; current_pose.z &lt;&lt; ", " &lt;&lt; current_pose.roll
+            &lt;&lt; ", " &lt;&lt; current_pose.pitch &lt;&lt; ", " &lt;&lt; current_pose.yaw &lt;&lt; ")" &lt;&lt; std::endl;
+  std::cout &lt;&lt; "Transformation Matrix:" &lt;&lt; std::endl;
+  std::cout &lt;&lt; t_localizer &lt;&lt; std::endl;
+  std::cout &lt;&lt; "shift: " &lt;&lt; shift &lt;&lt; std::endl;
+  std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
 }
 
-int main(int argc, char **argv)
+int main(int argc, char** argv)
 {
-    previous_pose.x = 0.0;
-    previous_pose.y = 0.0;
-    previous_pose.z = 0.0;
-    previous_pose.roll = 0.0;
-    previous_pose.pitch = 0.0;
-    previous_pose.yaw = 0.0;
-
-    ndt_pose.x = 0.0;
-    ndt_pose.y = 0.0;
-    ndt_pose.z = 0.0;
-    ndt_pose.roll = 0.0;
-    ndt_pose.pitch = 0.0;
-    ndt_pose.yaw = 0.0;
-
-    current_pose.x = 0.0;
-    current_pose.y = 0.0;
-    current_pose.z = 0.0;
-    current_pose.roll = 0.0;
-    current_pose.pitch = 0.0;
-    current_pose.yaw = 0.0;
-
-    guess_pose.x = 0.0;
-    guess_pose.y = 0.0;
-    guess_pose.z = 0.0;
-    guess_pose.roll = 0.0;
-    guess_pose.pitch = 0.0;
-    guess_pose.yaw = 0.0;
-
-    added_pose.x = 0.0;
-    added_pose.y = 0.0;
-    added_pose.z = 0.0;
-    added_pose.roll = 0.0;
-    added_pose.pitch = 0.0;
-    added_pose.yaw = 0.0;
-
-    offset_x = 0.0;
-    offset_y = 0.0;
-    offset_z = 0.0;
-    offset_yaw = 0.0;
-
-    ros::init(argc, argv, "ndt_mapping");
-
-    ros::NodeHandle nh;
-    ros::NodeHandle private_nh("~");
-
-    // setting parameters
-    private_nh.getParam("range", RANGE);
-    std::cout &lt;&lt; "RANGE: " &lt;&lt; RANGE &lt;&lt; std::endl;
-    private_nh.getParam("shift", SHIFT);
-    std::cout &lt;&lt; "SHIFT: " &lt;&lt; SHIFT &lt;&lt; std::endl;
-    private_nh.getParam("use_openmp", _use_openmp);
-    std::cout &lt;&lt; "use_openmp: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
-
-    if (nh.getParam("tf_x", _tf_x) == false)
-    {
-      std::cout &lt;&lt; "tf_x is not set." &lt;&lt; std::endl;
-      return 1;
-    }
-    if (nh.getParam("tf_y", _tf_y) == false)
-    {
-      std::cout &lt;&lt; "tf_y is not set." &lt;&lt; std::endl;
-      return 1;
-    }
-    if (nh.getParam("tf_z", _tf_z) == false)
-    {
-      std::cout &lt;&lt; "tf_z is not set." &lt;&lt; std::endl;
-      return 1;
-    }
-    if (nh.getParam("tf_roll", _tf_roll) == false)
-    {
-      std::cout &lt;&lt; "tf_roll is not set." &lt;&lt; std::endl;
-      return 1;
-    }
-    if (nh.getParam("tf_pitch", _tf_pitch) == false)
-    {
-      std::cout &lt;&lt; "tf_pitch is not set." &lt;&lt; std::endl;
-      return 1;
-    }
-    if (nh.getParam("tf_yaw", _tf_yaw) == false)
-    {
-      std::cout &lt;&lt; "tf_yaw is not set." &lt;&lt; std::endl;
-      return 1;
-    }
+  previous_pose.x = 0.0;
+  previous_pose.y = 0.0;
+  previous_pose.z = 0.0;
+  previous_pose.roll = 0.0;
+  previous_pose.pitch = 0.0;
+  previous_pose.yaw = 0.0;
+
+  ndt_pose.x = 0.0;
+  ndt_pose.y = 0.0;
+  ndt_pose.z = 0.0;
+  ndt_pose.roll = 0.0;
+  ndt_pose.pitch = 0.0;
+  ndt_pose.yaw = 0.0;
+
+  current_pose.x = 0.0;
+  current_pose.y = 0.0;
+  current_pose.z = 0.0;
+  current_pose.roll = 0.0;
+  current_pose.pitch = 0.0;
+  current_pose.yaw = 0.0;
+
+  guess_pose.x = 0.0;
+  guess_pose.y = 0.0;
+  guess_pose.z = 0.0;
+  guess_pose.roll = 0.0;
+  guess_pose.pitch = 0.0;
+  guess_pose.yaw = 0.0;
+
+  added_pose.x = 0.0;
+  added_pose.y = 0.0;
+  added_pose.z = 0.0;
+  added_pose.roll = 0.0;
+  added_pose.pitch = 0.0;
+  added_pose.yaw = 0.0;
+
+  offset_x = 0.0;
+  offset_y = 0.0;
+  offset_z = 0.0;
+  offset_yaw = 0.0;
+
+  ros::init(argc, argv, "ndt_mapping");
+
+  ros::NodeHandle nh;
+  ros::NodeHandle private_nh("~");
+
+  // setting parameters
+  private_nh.getParam("range", RANGE);
+  std::cout &lt;&lt; "RANGE: " &lt;&lt; RANGE &lt;&lt; std::endl;
+  private_nh.getParam("shift", SHIFT);
+  std::cout &lt;&lt; "SHIFT: " &lt;&lt; SHIFT &lt;&lt; std::endl;
+  private_nh.getParam("use_openmp", _use_openmp);
+  std::cout &lt;&lt; "use_openmp: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
+
+  if (nh.getParam("tf_x", _tf_x) == false)
+  {
+    std::cout &lt;&lt; "tf_x is not set." &lt;&lt; std::endl;
+    return 1;
+  }
+  if (nh.getParam("tf_y", _tf_y) == false)
+  {
+    std::cout &lt;&lt; "tf_y is not set." &lt;&lt; std::endl;
+    return 1;
+  }
+  if (nh.getParam("tf_z", _tf_z) == false)
+  {
+    std::cout &lt;&lt; "tf_z is not set." &lt;&lt; std::endl;
+    return 1;
+  }
+  if (nh.getParam("tf_roll", _tf_roll) == false)
+  {
+    std::cout &lt;&lt; "tf_roll is not set." &lt;&lt; std::endl;
+    return 1;
+  }
+  if (nh.getParam("tf_pitch", _tf_pitch) == false)
+  {
+    std::cout &lt;&lt; "tf_pitch is not set." &lt;&lt; std::endl;
+    return 1;
+  }
+  if (nh.getParam("tf_yaw", _tf_yaw) == false)
+  {
+    std::cout &lt;&lt; "tf_yaw is not set." &lt;&lt; std::endl;
+    return 1;
+  }
 
-    std::cout &lt;&lt; "(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (" &lt;&lt; _tf_x &lt;&lt; ", " &lt;&lt; _tf_y &lt;&lt; ", " &lt;&lt; _tf_z &lt;&lt; ", "
-              &lt;&lt; _tf_roll &lt;&lt; ", " &lt;&lt; _tf_pitch &lt;&lt; ", " &lt;&lt; _tf_yaw &lt;&lt; ")" &lt;&lt; std::endl;
+  std::cout &lt;&lt; "(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (" &lt;&lt; _tf_x &lt;&lt; ", " &lt;&lt; _tf_y &lt;&lt; ", " &lt;&lt; _tf_z &lt;&lt; ", "
+            &lt;&lt; _tf_roll &lt;&lt; ", " &lt;&lt; _tf_pitch &lt;&lt; ", " &lt;&lt; _tf_yaw &lt;&lt; ")" &lt;&lt; std::endl;
 
-    Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);  // tl: translation
-    Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
-    Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
-    Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
-    tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();
+  Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);                 // tl: translation
+  Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
+  Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
+  Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
+  tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();
 
-    Eigen::Translation3f tl_ltob((-1.0) * _tf_x, (-1.0) * _tf_y, (-1.0) * _tf_z);  // tl: translation
-    Eigen::AngleAxisf rot_x_ltob((-1.0) * _tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
-    Eigen::AngleAxisf rot_y_ltob((-1.0) * _tf_pitch, Eigen::Vector3f::UnitY());
-    Eigen::AngleAxisf rot_z_ltob((-1.0) * _tf_yaw, Eigen::Vector3f::UnitZ());
-    tf_ltob = (tl_ltob * rot_z_ltob * rot_y_ltob * rot_x_ltob).matrix();
+  Eigen::Translation3f tl_ltob((-1.0) * _tf_x, (-1.0) * _tf_y, (-1.0) * _tf_z);  // tl: translation
+  Eigen::AngleAxisf rot_x_ltob((-1.0) * _tf_roll, Eigen::Vector3f::UnitX());     // rot: rotation
+  Eigen::AngleAxisf rot_y_ltob((-1.0) * _tf_pitch, Eigen::Vector3f::UnitY());
+  Eigen::AngleAxisf rot_z_ltob((-1.0) * _tf_yaw, Eigen::Vector3f::UnitZ());
+  tf_ltob = (tl_ltob * rot_z_ltob * rot_y_ltob * rot_x_ltob).matrix();
 
-    map.header.frame_id = "map";
+  map.header.frame_id = "map";
 
-    ndt_map_pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;("/ndt_map", 1000);
-    current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/current_pose", 1000);
+  ndt_map_pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;("/ndt_map", 1000);
+  current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/current_pose", 1000);
 
-    ros::Subscriber param_sub = nh.subscribe("config/ndt_mapping", 10, param_callback);
-    ros::Subscriber output_sub = nh.subscribe("config/ndt_mapping_output", 10, output_callback);
-    ros::Subscriber points_sub = nh.subscribe("points_raw", 100000, points_callback);
+  ros::Subscriber param_sub = nh.subscribe("config/ndt_mapping", 10, param_callback);
+  ros::Subscriber output_sub = nh.subscribe("config/ndt_mapping_output", 10, output_callback);
+  ros::Subscriber points_sub = nh.subscribe("points_raw", 100000, points_callback);
 
-    ros::spin();
+  ros::spin();
 
-    return 0;
+  return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f5e1b1725b5dc2f175bfc9d56837bc425423e2ac" author="TomohitoAndo">
		<msg>Split class into separate files</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="29" deleted_lines="242">
				<diff>@@ -46,9 +46,9 @@
 #include &lt;runtime_manager/ConfigVelocitySet.h&gt;
 #include &lt;iostream&gt;
 
-#include "waypoint_follower/lane.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "libvelocity_set.h"
+#include "velocity_set_path.h"
 
 namespace
 {
@@ -67,7 +67,6 @@ bool g_points_flag = false;
 int g_obstacle_waypoint = -1;
 double g_deceleration_search_distance = 30;
 double g_search_distance = 60;
-int g_closest_waypoint = -1;
 double g_current_vel = 0.0;  // (m/s) subscribe estimated_vel
 CrossWalk vmap;
 ObstaclePoints g_obstacle;
@@ -93,220 +92,8 @@ ros::Publisher g_crosswalk_points_pub;
 ros::Publisher g_obstacle_pub;
 
 WayPoints g_path_dk;
+VelocitySetPath g_path_change;
 
-class PathVset : public WayPoints
-{
-private:
-  waypoint_follower::lane temporal_waypoints_;
-
-public:
-  void changeWaypoints(int stop_waypoint);
-  void avoidSuddenBraking();
-  void avoidSuddenAceleration();
-  void setDeceleration();
-  bool checkWaypoint(int num, const char *name) const;
-  void setTemporalWaypoints();
-  waypoint_follower::lane getTemporalWaypoints() const
-  {
-    return temporal_waypoints_;
-  }
-};
-PathVset g_path_change;
-
-//===============================
-//       class function
-//===============================
-
-// check if waypoint number is valid
-bool PathVset::checkWaypoint(int num, const char *name) const
-{
-  if (num &lt; 0 || num &gt;= getSize())
-  {
-    return false;
-  }
-  return true;
-}
-
-// set about '_temporal_waypoints_size' meter waypoints from closest waypoint
-void PathVset::setTemporalWaypoints()
-{
-  if (g_closest_waypoint &lt; 0)
-    return;
-  int size = (int)(g_temporal_waypoints_size / getInterval()) + 1;
-
-  temporal_waypoints_.waypoints.clear();
-  temporal_waypoints_.header = current_waypoints_.header;
-  temporal_waypoints_.increment = current_waypoints_.increment;
-  // push current pose
-  waypoint_follower::waypoint current_point;
-
-  current_point.pose = g_control_pose;
-  current_point.twist = current_waypoints_.waypoints[g_closest_waypoint].twist;
-  current_point.dtlane = current_waypoints_.waypoints[g_closest_waypoint].dtlane;
-  temporal_waypoints_.waypoints.push_back(current_point);
-  for (int i = 0; i &lt; size; i++)
-  {
-    if (g_closest_waypoint + i &gt;= getSize())
-      return;
-    temporal_waypoints_.waypoints.push_back(current_waypoints_.waypoints[g_closest_waypoint + i]);
-  }
-
-  return;
-}
-
-void PathVset::setDeceleration()
-{
-  int velocity_change_range = 5;
-  double intervel = getInterval();
-  double temp1 = g_current_vel * g_current_vel;
-  double temp2 = 2 * g_decel * intervel;
-  double deceleration_minimum = kmph2mps(4.0);
-
-  for (int i = 0; i &lt; velocity_change_range; i++)
-  {
-    if (!checkWaypoint(g_closest_waypoint + i, "setDeceleration"))
-      continue;
-    double waypoint_velocity = current_waypoints_.waypoints[g_closest_waypoint + i].twist.twist.linear.x;
-    double changed_vel = temp1 - temp2;
-    if (changed_vel &lt; 0)
-    {
-      changed_vel = deceleration_minimum * deceleration_minimum;
-    }
-    if (sqrt(changed_vel) &gt; waypoint_velocity || deceleration_minimum &gt; waypoint_velocity)
-      continue;
-    if (sqrt(changed_vel) &lt; deceleration_minimum)
-    {
-      current_waypoints_.waypoints[g_closest_waypoint + i].twist.twist.linear.x = deceleration_minimum;
-      continue;
-    }
-    current_waypoints_.waypoints[g_closest_waypoint + i].twist.twist.linear.x = sqrt(changed_vel);
-  }
-
-  return;
-}
-
-void PathVset::avoidSuddenAceleration()
-{
-  double changed_vel;
-  double interval = getInterval();
-  double temp1 = g_current_vel * g_current_vel;
-  double temp2 = 2 * g_decel * interval;
-  double velocity_offset = 1.389; // m/s
-
-  for (int i = 0;; i++)
-  {
-    if (!checkWaypoint(g_closest_waypoint + i, "avoidSuddenAceleration"))
-      return;
-    changed_vel = sqrt(temp1 + temp2 * (double)(i + 1)) + velocity_offset;
-    if (changed_vel &gt; current_waypoints_.waypoints[g_closest_waypoint + i].twist.twist.linear.x)
-      return;
-    current_waypoints_.waypoints[g_closest_waypoint + i].twist.twist.linear.x = changed_vel;
-  }
-
-  return;
-}
-
-void PathVset::avoidSuddenBraking()
-{
-  int i = 0;
-  int fill_in_zero = 20;
-  int fill_in_vel = 15;
-  int examin_range = 1;  // need to change according to waypoint interval?
-  int num;
-  double interval = getInterval();
-  double changed_vel;
-
-  for (int j = -1; j &lt; examin_range; j++)
-  {
-    if (!checkWaypoint(g_closest_waypoint + j, "avoidSuddenBraking"))
-      return;
-    if (getWaypointVelocityMPS(g_closest_waypoint + j) &lt;
-        g_current_vel - g_velocity_change_limit)  // we must change waypoints
-      break;
-    if (j == examin_range - 1)  // we don't have to change waypoints
-      return;
-  }
-
-  // fill in waypoints velocity behind vehicle
-  for (num = g_closest_waypoint - 1; fill_in_vel &gt; 0; fill_in_vel--)
-  {
-    if (!checkWaypoint(num - fill_in_vel, "avoidSuddenBraking"))
-      continue;
-    current_waypoints_.waypoints[num - fill_in_vel].twist.twist.linear.x = g_current_vel;
-  }
-
-  // decelerate gradually
-  double temp1 = (g_current_vel - g_velocity_change_limit + 1.389) * (g_current_vel - g_velocity_change_limit + 1.389);
-  double temp2 = 2 * g_decel * interval;
-  for (num = g_closest_waypoint - 1;; num++)
-  {
-    if (num &gt;= getSize())
-      return;
-    if (!checkWaypoint(num, "avoidSuddenBraking"))
-      continue;
-    changed_vel = temp1 - temp2 * (double)i;  // sqrt(v^2 - 2*a*x)
-    if (changed_vel &lt;= 0)
-      break;
-    current_waypoints_.waypoints[num].twist.twist.linear.x = sqrt(changed_vel);
-
-    i++;
-  }
-
-  for (int j = 0; j &lt; fill_in_zero; j++)
-  {
-    if (!checkWaypoint(num + j, "avoidSuddenBraking"))
-      continue;
-    current_waypoints_.waypoints[num + j].twist.twist.linear.x = 0.0;
-  }
-
-
-  return;
-}
-
-void PathVset::changeWaypoints(int stop_waypoint)
-{
-  int i = 0;
-  int close_waypoint_threshold = 4;
-  int fill_in_zero = 20;
-  double changed_vel;
-  double interval = getInterval();
-
-  // change waypoints to decelerate
-  for (int num = stop_waypoint; num &gt; g_closest_waypoint - close_waypoint_threshold; num--)
-  {
-    if (!checkWaypoint(num, "changeWaypoints"))
-      continue;
-
-    changed_vel = sqrt(2.0 * g_decel * (interval * i));  // sqrt(2*a*x)
-
-    waypoint_follower::waypoint initial_waypoint = g_path_dk.getCurrentWaypoints().waypoints[num];
-    if (changed_vel &gt; initial_waypoint.twist.twist.linear.x)
-    {  // avoid acceleration
-      current_waypoints_.waypoints[num].twist.twist.linear.x = initial_waypoint.twist.twist.linear.x;
-    }
-    else
-    {
-      current_waypoints_.waypoints[num].twist.twist.linear.x = changed_vel;
-    }
-
-    i++;
-  }
-
-  // fill in 0
-  for (int j = 1; j &lt; fill_in_zero; j++)
-  {
-    if (!checkWaypoint(stop_waypoint + j, "changeWaypoints"))
-      continue;
-    current_waypoints_.waypoints[stop_waypoint + j].twist.twist.linear.x = 0.0;
-  }
-
-
-  return;
-}
-
-//===============================
-//       class function
-//===============================
 
 //===============================
 //          Callback
@@ -529,16 +316,16 @@ void displayDetectionRange(const int &amp;crosswalk_id, const int &amp;num, const EContr
   marker_array.markers.clear();
 }
 
-int findCrossWalk()
+int findCrossWalk(int closest_waypoint)
 {
-  if (!vmap.set_points || g_closest_waypoint &lt; 0)
+  if (!vmap.set_points || closest_waypoint &lt; 0)
     return -1;
 
   double find_distance = 2.0 * 2.0;      // meter
   double ignore_distance = 20.0 * 20.0;  // meter
   static std::vector&lt;int&gt; bdid = vmap.getBDID();
   // Find near cross walk
-  for (int num = g_closest_waypoint; num &lt; g_closest_waypoint + g_search_distance; num++)
+  for (int num = closest_waypoint; num &lt; closest_waypoint + g_search_distance; num++)
   {
     geometry_msgs::Point waypoint = g_path_dk.getWaypointPosition(num);
     waypoint.z = 0.0;  // ignore Z axis
@@ -601,15 +388,15 @@ EControl crossWalkDetection(const int &amp;crosswalk_id)
   return KEEP;  // find no obstacles
 }
 
-EControl vscanDetection()
+EControl vscanDetection(int closest_waypoint)
 {
-  if (g_points.empty() == true || g_closest_waypoint &lt; 0)
+  if (g_points.empty() == true || closest_waypoint &lt; 0)
     return KEEP;
 
   int decelerate_or_stop = -10000;
   int decelerate2stop_waypoints = 15;
 
-  for (int i = g_closest_waypoint; i &lt; g_closest_waypoint + g_search_distance; i++)
+  for (int i = closest_waypoint; i &lt; closest_waypoint + g_search_distance; i++)
   {
     g_obstacle.clearStopPoints();
     if (!g_obstacle.isDecided())
@@ -617,7 +404,7 @@ EControl vscanDetection()
 
     decelerate_or_stop++;
     if (decelerate_or_stop &gt; decelerate2stop_waypoints || (decelerate_or_stop &gt;= 0 &amp;&amp; i &gt;= g_path_dk.getSize() - 1) ||
-        (decelerate_or_stop &gt;= 0 &amp;&amp; i == g_closest_waypoint + g_search_distance - 1))
+        (decelerate_or_stop &gt;= 0 &amp;&amp; i == closest_waypoint + g_search_distance - 1))
       return DECELERATE;
     if (i &gt; g_path_dk.getSize() - 1)
       return KEEP;
@@ -665,7 +452,7 @@ EControl vscanDetection()
       if (g_deceleration_range &lt; 0.01)
         continue;
       // deceleration search runs "decelerate_search_distance" waypoints from closest
-      if (i &gt; g_closest_waypoint + g_deceleration_search_distance || decelerate_or_stop &gt;= 0)
+      if (i &gt; closest_waypoint + g_deceleration_search_distance || decelerate_or_stop &gt;= 0)
         continue;
 
       // ---DECELERATE OBSTACLE DETECTION---
@@ -722,13 +509,13 @@ void soundPlay()
 }
   */
 
-EControl obstacleDetection()
+EControl obstacleDetection(int closest_waypoint)
 {
   static int false_count = 0;
   static EControl prev_detection = KEEP;
 
-  EControl vscan_result = vscanDetection();
-  displayDetectionRange(vmap.getDetectionCrossWalkID(), g_closest_waypoint, vscan_result);
+  EControl vscan_result = vscanDetection(closest_waypoint);
+  displayDetectionRange(vmap.getDetectionCrossWalkID(), closest_waypoint, vscan_result);
 
   if (prev_detection == KEEP)
   {
@@ -776,7 +563,7 @@ EControl obstacleDetection()
   }
 }
 
-void changeWaypoint(EControl detection_result)
+void changeWaypoint(EControl detection_result, int closest_waypoint)
 {
   int obs = g_obstacle_waypoint;
 
@@ -785,24 +572,24 @@ void changeWaypoint(EControl detection_result)
     // stop_waypoint is about g_others_distance meter away from obstacles
     int stop_waypoint = obs - ((int)(g_others_distance / g_path_change.getInterval()));
     // change waypoints to stop by the stop_waypoint
-    g_path_change.changeWaypoints(stop_waypoint);
-    g_path_change.avoidSuddenBraking();
-    g_path_change.setTemporalWaypoints();
+    g_path_change.changeWaypoints(stop_waypoint, closest_waypoint, g_decel, g_path_dk);
+    g_path_change.avoidSuddenBraking(g_velocity_change_limit, g_current_vel, g_decel, closest_waypoint);
+    g_path_change.setTemporalWaypoints(g_temporal_waypoints_size, closest_waypoint, g_control_pose);
     g_temporal_waypoints_pub.publish(g_path_change.getTemporalWaypoints());
   }
   else if (detection_result == DECELERATE)
   {  // DECELERATE for obstacles
     g_path_change.setPath(g_path_dk.getCurrentWaypoints());
-    g_path_change.setDeceleration();
-    g_path_change.setTemporalWaypoints();
+    g_path_change.setDeceleration(g_current_vel, g_decel, closest_waypoint);
+    g_path_change.setTemporalWaypoints(g_temporal_waypoints_size, closest_waypoint, g_control_pose);
     g_temporal_waypoints_pub.publish(g_path_change.getTemporalWaypoints());
   }
   else
   {  // ACELERATE or KEEP
     g_path_change.setPath(g_path_dk.getCurrentWaypoints());
-    g_path_change.avoidSuddenAceleration();
-    g_path_change.avoidSuddenBraking();
-    g_path_change.setTemporalWaypoints();
+    g_path_change.avoidSuddenAceleration(g_current_vel, g_decel, closest_waypoint);
+    g_path_change.avoidSuddenBraking(g_velocity_change_limit, g_current_vel, g_decel, closest_waypoint);
+    g_path_change.setTemporalWaypoints(g_temporal_waypoints_size, closest_waypoint, g_control_pose);
     g_temporal_waypoints_pub.publish(g_path_change.getTemporalWaypoints());
   }
 
@@ -863,18 +650,18 @@ int main(int argc, char **argv)
       continue;
     }
 
-    g_closest_waypoint = getClosestWaypoint(g_path_change.getCurrentWaypoints(), g_control_pose.pose);
+    int closest_waypoint = getClosestWaypoint(g_path_change.getCurrentWaypoints(), g_control_pose.pose);
 
-    std_msgs::Int32 closest_waypoint;
-    closest_waypoint.data = g_closest_waypoint;
-    closest_waypoint_pub.publish(closest_waypoint);
+    std_msgs::Int32 closest_waypoint_msg;
+    closest_waypoint_msg.data = closest_waypoint;
+    closest_waypoint_pub.publish(closest_waypoint_msg);
 
     if (use_crosswalk_detection)
-      vmap.setDetectionWaypoint(findCrossWalk());
+      vmap.setDetectionWaypoint(findCrossWalk(closest_waypoint));
 
-    EControl detection_result = obstacleDetection();
+    EControl detection_result = obstacleDetection(closest_waypoint);
 
-    changeWaypoint(detection_result);
+    changeWaypoint(detection_result, closest_waypoint);
 
     g_points.clear();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cd434c4da30d8d88450057341b7b2c6e57faaef1" author="TomohitoAndo">
		<msg>Format comments</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="12" deleted_lines="34">
				<diff>@@ -52,7 +52,6 @@
 
 namespace
 {
-
 const int LOOP_RATE = 10;
 
 geometry_msgs::TwistStamped g_current_twist;
@@ -67,25 +66,24 @@ bool g_points_flag = false;
 int g_obstacle_waypoint = -1;
 double g_deceleration_search_distance = 30;
 double g_search_distance = 60;
-double g_current_vel = 0.0;  // (m/s) subscribe estimated_vel
+double g_current_vel = 0.0;  // (m/s)
 CrossWalk vmap;
 ObstaclePoints g_obstacle;
 
-/* Config Parameter */
+// Config Parameter
 double g_detection_range = 0;                   // if obstacle is in this range, stop
 double g_deceleration_range = 1.8;              // if obstacle is in this range, decelerate
 int g_threshold_points = 15;
-double g_detection_height_top = 2.0;  // actually +2.0m
+double g_detection_height_top = 2.0;
 double g_detection_height_bottom = -2.0;
-double g_others_distance = 8.0;            // meter: stopping distance from obstacles (using VSCAN)
-double g_decel = 1.5;                      // (m/s) deceleration
-double g_velocity_change_limit = 2.778;    // (m/s) about 10 km/h
-double g_temporal_waypoints_size = 100.0;  // meter
+double g_others_distance = 8.0;            // (meter) stopping distance from obstacles
+double g_decel = 1.5;                      // (m/s^2) deceleration
+double g_velocity_change_limit = 2.778;    // (m/s)
+double g_temporal_waypoints_size = 100.0;  // (meter)
 
 // Publisher
 ros::Publisher g_range_pub;
 ros::Publisher g_deceleration_range_pub;
-ros::Publisher g_sound_pub;
 ros::Publisher g_safety_waypoint_pub;
 ros::Publisher g_temporal_waypoints_pub;
 ros::Publisher g_crosswalk_points_pub;
@@ -94,11 +92,6 @@ ros::Publisher g_obstacle_pub;
 WayPoints g_path_dk;
 VelocitySetPath g_path_change;
 
-
-//===============================
-//          Callback
-//===============================
-
 void configCallback(const runtime_manager::ConfigVelocitySetConstPtr &amp;config)
 {
   g_others_distance = config-&gt;others_distance;
@@ -172,11 +165,7 @@ void localizerCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
   g_localizer_pose.pose = msg-&gt;pose;
 }
 
-
-//===============================
-//          Callback
-//===============================
-
+// Display a detected obstacle
 void displayObstacle(const EControl &amp;kind)
 {
   visualization_msgs::Marker marker;
@@ -316,6 +305,7 @@ void displayDetectionRange(const int &amp;crosswalk_id, const int &amp;num, const EContr
   marker_array.markers.clear();
 }
 
+// find the closest cross walk against following waypoints
 int findCrossWalk(int closest_waypoint)
 {
   if (!vmap.set_points || closest_waypoint &lt; 0)
@@ -353,6 +343,7 @@ int findCrossWalk(int closest_waypoint)
   return -1;  // no near crosswalk
 }
 
+// obstacle detection for crosswalk
 EControl crossWalkDetection(const int &amp;crosswalk_id)
 {
   double search_radius = vmap.getDetectionPoints(crosswalk_id).width / 2;
@@ -388,6 +379,7 @@ EControl crossWalkDetection(const int &amp;crosswalk_id)
   return KEEP;  // find no obstacles
 }
 
+// Detect an obstacle by using pointcloud
 EControl vscanDetection(int closest_waypoint)
 {
   if (g_points.empty() == true || closest_waypoint &lt; 0)
@@ -500,15 +492,6 @@ EControl vscanDetection(int closest_waypoint)
   return KEEP;  // no obstacles
 }
 
-  /*
-void soundPlay()
-{
-  std_msgs::String string;
-  string.data = pedestrian_sound;
-  g_sound_pub.publish(string);
-}
-  */
-
 EControl obstacleDetection(int closest_waypoint)
 {
   static int false_count = 0;
@@ -598,9 +581,6 @@ void changeWaypoint(EControl detection_result, int closest_waypoint)
 
 } // end namespace
 
-//======================================
-//                 main
-//======================================
 
 int main(int argc, char **argv)
 {
@@ -622,15 +602,13 @@ int main(int argc, char **argv)
   ros::Subscriber current_vel_sub = nh.subscribe("current_velocity", 1, currentVelCallback);
   ros::Subscriber config_sub = nh.subscribe("config/velocity_set", 10, configCallback);
 
-  //------------------ Vector Map ----------------------//
+  // vector map subscribers
   ros::Subscriber sub_dtlane = nh.subscribe("vector_map_info/cross_walk", 1, &amp;CrossWalk::crossWalkCallback, &amp;vmap);
   ros::Subscriber sub_area = nh.subscribe("vector_map_info/area", 1, &amp;CrossWalk::areaCallback, &amp;vmap);
   ros::Subscriber sub_line = nh.subscribe("vector_map_info/line", 1, &amp;CrossWalk::lineCallback, &amp;vmap);
   ros::Subscriber sub_point = nh.subscribe("vector_map_info/point", 1, &amp;CrossWalk::pointCallback, &amp;vmap);
-  //----------------------------------------------------//
 
   g_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 0);
-  g_sound_pub = nh.advertise&lt;std_msgs::String&gt;("sound_player", 10);
   g_temporal_waypoints_pub = nh.advertise&lt;waypoint_follower::lane&gt;("temporal_waypoints", 1000, true);
   ros::Publisher closest_waypoint_pub;
   closest_waypoint_pub = nh.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1000);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="115b9903e0075463cd873d90b1274ff6e808dd3a" author="TomohitoAndo">
		<msg>Remove unused function</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="0" deleted_lines="6">
				<diff>@@ -120,11 +120,6 @@ void baseWaypointCallback(const waypoint_follower::laneConstPtr &amp;msg)
   }
 }
 
-void objPoseCallback(const visualization_msgs::MarkerConstPtr &amp;msg)
-{
-  //ROS_INFO("subscribed obj_pose\n");
-}
-
 void pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg)
 {
   pcl::PointCloud&lt;pcl::PointXYZ&gt; sub_points;
@@ -598,7 +593,6 @@ int main(int argc, char **argv)
   ros::Subscriber control_pose_sub = nh.subscribe("current_pose", 1, controlCallback);
   ros::Subscriber points_sub = nh.subscribe(points_topic, 1, pointsCallback);
   ros::Subscriber base_waypoint_sub = nh.subscribe("base_waypoints", 1, baseWaypointCallback);
-  ros::Subscriber obj_pose_sub = nh.subscribe("obj_pose", 1, objPoseCallback);
   ros::Subscriber current_vel_sub = nh.subscribe("current_velocity", 1, currentVelCallback);
   ros::Subscriber config_sub = nh.subscribe("config/velocity_set", 10, configCallback);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1cbd16fc089f6adf0cf281b4d6c8788f5983a99c" author="TomohitoAndo">
		<msg>Fix dependencies</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="0" deleted_lines="11">
				<diff>@@ -29,19 +29,8 @@
  */
 
 #include &lt;ros/ros.h&gt;
-#include &lt;geometry_msgs/TwistStamped.h&gt;
-#include &lt;geometry_msgs/PoseArray.h&gt;
-#include &lt;geometry_msgs/Point.h&gt;
-#include &lt;nav_msgs/Odometry.h&gt;
-#include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
-#include &lt;pcl/io/io.h&gt;
-#include &lt;pcl/io/pcd_io.h&gt;
-#include &lt;pcl/point_types.h&gt;
-#include &lt;std_msgs/String.h&gt;
-#include &lt;std_msgs/Float32.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 #include &lt;runtime_manager/ConfigVelocitySet.h&gt;
 #include &lt;iostream&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3daf76c3d4e932de4ed954d99d1ac11f4d349e83" author="TomohitoAndo">
		<msg>Remove unused variables</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="0" deleted_lines="11">
				<diff>@@ -43,15 +43,12 @@ namespace
 {
 const int LOOP_RATE = 10;
 
-geometry_msgs::TwistStamped g_current_twist;
 geometry_msgs::PoseStamped g_localizer_pose;  // pose of sensor
 geometry_msgs::PoseStamped g_control_pose;  // pose of base_link
 pcl::PointCloud&lt;pcl::PointXYZ&gt; g_points;
 
-const std::string pedestrian_sound = "pedestrian";
 bool g_pose_flag = false;
 bool g_path_flag = false;
-bool g_points_flag = false;
 int g_obstacle_waypoint = -1;
 double g_deceleration_search_distance = 30;
 double g_search_distance = 60;
@@ -72,10 +69,7 @@ double g_temporal_waypoints_size = 100.0;  // (meter)
 
 // Publisher
 ros::Publisher g_range_pub;
-ros::Publisher g_deceleration_range_pub;
-ros::Publisher g_safety_waypoint_pub;
 ros::Publisher g_temporal_waypoints_pub;
-ros::Publisher g_crosswalk_points_pub;
 ros::Publisher g_obstacle_pub;
 
 WayPoints g_path_dk;
@@ -127,11 +121,6 @@ void pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg)
       continue;
     g_points.push_back(v);
   }
-
-  if (g_points_flag == false)
-  {
-    g_points_flag = true;
-  }
 }
 
 void controlCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="67689953f42f2fb0f5414b81fd68a1a18a162842" author="TomohitoAndo">
		<msg>Don't use call by reference with primitive data types</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -174,7 +174,7 @@ void displayObstacle(const EControl &amp;kind)
   //g_obstacle_pub.publish(marker);
 }
 
-void displayDetectionRange(const int &amp;crosswalk_id, const int &amp;num, const EControl &amp;kind)
+void displayDetectionRange(const int crosswalk_id, const int num, const EControl &amp;kind)
 {
   // set up for marker array
   visualization_msgs::MarkerArray marker_array;
@@ -317,7 +317,7 @@ int findCrossWalk(int closest_waypoint)
 }
 
 // obstacle detection for crosswalk
-EControl crossWalkDetection(const int &amp;crosswalk_id)
+EControl crossWalkDetection(const int crosswalk_id)
 {
   double search_radius = vmap.getDetectionPoints(crosswalk_id).width / 2;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6571d09b1bbc60011004d6c91c1509444b3cb583" author="TomohitoAndo">
		<msg>Remove ignore range</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="2" deleted_lines="4">
				<diff>@@ -108,17 +108,15 @@ void pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg)
   pcl::PointCloud&lt;pcl::PointXYZ&gt; sub_points;
   pcl::fromROSMsg(*msg, sub_points);
 
-  // if x is less than this, we regard the point as our vehicle's one
-  double ignore_range = 2.0;
   g_points.clear();
   for (const auto &amp;v : sub_points)
   {
     if (v.x == 0 &amp;&amp; v.y == 0)
       continue;
+
     if (v.z &gt; g_detection_height_top || v.z &lt; g_detection_height_bottom)
       continue;
-    if (v.x &lt; ignore_range)
-      continue;
+
     g_points.push_back(v);
   }
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8995b3eb00118a4c811df767a67cd49b68c7db24" author="TomohitoAndo">
		<msg>Modify variable names</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="93" deleted_lines="93">
				<diff>@@ -53,16 +53,16 @@ int g_obstacle_waypoint = -1;
 double g_deceleration_search_distance = 30;
 double g_search_distance = 60;
 double g_current_vel = 0.0;  // (m/s)
-CrossWalk vmap;
+CrossWalk g_cross_walk;
 ObstaclePoints g_obstacle;
 
 // Config Parameter
-double g_detection_range = 0;                   // if obstacle is in this range, stop
+double g_stop_range = 0;                   // if obstacle is in this range, stop
 double g_deceleration_range = 1.8;              // if obstacle is in this range, decelerate
 int g_threshold_points = 15;
 double g_detection_height_top = 2.0;
 double g_detection_height_bottom = -2.0;
-double g_others_distance = 8.0;            // (meter) stopping distance from obstacles
+double g_stop_distance = 8.0;            // (meter) stopping distance from obstacles
 double g_decel = 1.5;                      // (m/s^2) deceleration
 double g_velocity_change_limit = 2.778;    // (m/s)
 double g_temporal_waypoints_size = 100.0;  // (meter)
@@ -72,13 +72,13 @@ ros::Publisher g_range_pub;
 ros::Publisher g_temporal_waypoints_pub;
 ros::Publisher g_obstacle_pub;
 
-WayPoints g_path_dk;
-VelocitySetPath g_path_change;
+WayPoints g_prev_path;
+VelocitySetPath g_new_path;
 
 void configCallback(const runtime_manager::ConfigVelocitySetConstPtr &amp;config)
 {
-  g_others_distance = config-&gt;others_distance;
-  g_detection_range = config-&gt;detection_range;
+  g_stop_distance = config-&gt;others_distance;
+  g_stop_range = config-&gt;detection_range;
   g_threshold_points = config-&gt;threshold_points;
   g_detection_height_top = config-&gt;detection_height_top;
   g_detection_height_bottom = config-&gt;detection_height_bottom;
@@ -95,8 +95,8 @@ void currentVelCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg)
 
 void baseWaypointCallback(const waypoint_follower::laneConstPtr &amp;msg)
 {
-  g_path_dk.setPath(*msg);
-  g_path_change.setPath(*msg);
+  g_prev_path.setPath(*msg);
+  g_new_path.setPath(*msg);
   if (g_path_flag == false)
   {
     g_path_flag = true;
@@ -197,7 +197,7 @@ void displayDetectionRange(const int crosswalk_id, const int num, const EControl
   stop_line.ns = "Stop Line";
 
   // set scale and color
-  double scale = 2 * g_detection_range;
+  double scale = 2 * g_stop_range;
   waypoint_marker_stop.scale.x = scale;
   waypoint_marker_stop.scale.y = scale;
   waypoint_marker_stop.scale.z = scale;
@@ -207,7 +207,7 @@ void displayDetectionRange(const int crosswalk_id, const int num, const EControl
   waypoint_marker_stop.color.b = 0.0;
   waypoint_marker_stop.frame_locked = true;
 
-  scale = 2 * (g_detection_range + g_deceleration_range);
+  scale = 2 * (g_stop_range + g_deceleration_range);
   waypoint_marker_decelerate.scale.x = scale;
   waypoint_marker_decelerate.scale.y = scale;
   waypoint_marker_decelerate.scale.z = scale;
@@ -219,8 +219,8 @@ void displayDetectionRange(const int crosswalk_id, const int num, const EControl
 
   if (g_obstacle_waypoint &gt; -1)
   {
-    stop_line.pose.position = g_path_dk.getWaypointPosition(g_obstacle_waypoint);
-    stop_line.pose.orientation = g_path_dk.getWaypointOrientation(g_obstacle_waypoint);
+    stop_line.pose.position = g_prev_path.getWaypointPosition(g_obstacle_waypoint);
+    stop_line.pose.orientation = g_prev_path.getWaypointOrientation(g_obstacle_waypoint);
   }
   stop_line.pose.position.z += 1.0;
   stop_line.scale.x = 0.1;
@@ -234,7 +234,7 @@ void displayDetectionRange(const int crosswalk_id, const int num, const EControl
   stop_line.frame_locked = true;
 
   if (crosswalk_id &gt; 0)
-    scale = vmap.getDetectionPoints(crosswalk_id).width;
+    scale = g_cross_walk.getDetectionPoints(crosswalk_id).width;
   crosswalk_marker.scale.x = scale;
   crosswalk_marker.scale.y = scale;
   crosswalk_marker.scale.z = scale;
@@ -247,11 +247,11 @@ void displayDetectionRange(const int crosswalk_id, const int num, const EControl
   // set marker points coordinate
   for (int i = 0; i &lt; g_search_distance; i++)
   {
-    if (num &lt; 0 || i + num &gt; g_path_dk.getSize() - 1)
+    if (num &lt; 0 || i + num &gt; g_prev_path.getSize() - 1)
       break;
 
     geometry_msgs::Point point;
-    point = g_path_dk.getWaypointPosition(num + i);
+    point = g_prev_path.getWaypointPosition(num + i);
 
     waypoint_marker_stop.points.push_back(point);
 
@@ -262,7 +262,7 @@ void displayDetectionRange(const int crosswalk_id, const int num, const EControl
 
   if (crosswalk_id &gt; 0)
   {
-    for (const auto &amp;p : vmap.getDetectionPoints(crosswalk_id).points)
+    for (const auto &amp;p : g_cross_walk.getDetectionPoints(crosswalk_id).points)
       crosswalk_marker.points.push_back(p);
   }
 
@@ -279,66 +279,66 @@ void displayDetectionRange(const int crosswalk_id, const int num, const EControl
 // find the closest cross walk against following waypoints
 int findCrossWalk(int closest_waypoint)
 {
-  if (!vmap.set_points || closest_waypoint &lt; 0)
+  if (!g_cross_walk.set_points || closest_waypoint &lt; 0)
     return -1;
 
   double find_distance = 2.0 * 2.0;      // meter
   double ignore_distance = 20.0 * 20.0;  // meter
-  static std::vector&lt;int&gt; bdid = vmap.getBDID();
+  static std::vector&lt;int&gt; bdid = g_cross_walk.getBDID();
   // Find near cross walk
   for (int num = closest_waypoint; num &lt; closest_waypoint + g_search_distance; num++)
   {
-    geometry_msgs::Point waypoint = g_path_dk.getWaypointPosition(num);
+    geometry_msgs::Point waypoint = g_prev_path.getWaypointPosition(num);
     waypoint.z = 0.0;  // ignore Z axis
     for (const auto &amp;i : bdid)
     {
       // ignore far crosswalk
-      geometry_msgs::Point crosswalk_center = vmap.getDetectionPoints(i).center;
+      geometry_msgs::Point crosswalk_center = g_cross_walk.getDetectionPoints(i).center;
       crosswalk_center.z = 0.0;
       if (calcSquareOfLength(crosswalk_center, waypoint) &gt; ignore_distance)
         continue;
 
-      for (auto p : vmap.getDetectionPoints(i).points)
+      for (auto p : g_cross_walk.getDetectionPoints(i).points)
       {
         p.z = waypoint.z;
         if (calcSquareOfLength(p, waypoint) &lt; find_distance)
         {
-          vmap.setDetectionCrossWalkID(i);
+          g_cross_walk.setDetectionCrossWalkID(i);
           return num;
         }
       }
     }
   }
 
-  vmap.setDetectionCrossWalkID(-1);
+  g_cross_walk.setDetectionCrossWalkID(-1);
   return -1;  // no near crosswalk
 }
 
 // obstacle detection for crosswalk
 EControl crossWalkDetection(const int crosswalk_id)
 {
-  double search_radius = vmap.getDetectionPoints(crosswalk_id).width / 2;
+  double search_radius = g_cross_walk.getDetectionPoints(crosswalk_id).width / 2;
 
   // Search each calculated points in the crosswalk
-  for (const auto &amp;p : vmap.getDetectionPoints(crosswalk_id).points)
+  for (const auto &amp;p : g_cross_walk.getDetectionPoints(crosswalk_id).points)
   {
     geometry_msgs::Point detection_point = calcRelativeCoordinate(p, g_localizer_pose.pose);
     tf::Vector3 detection_vector = point2vector(detection_point);
     detection_vector.setZ(0.0);
 
     int stop_count = 0;  // the number of points in the detection area
-    for (const auto &amp;vscan : g_points)
+    for (const auto &amp;p : g_points)
     {
-      tf::Vector3 vscan_vector(vscan.x, vscan.y, 0.0);
-      double distance = tf::tfDistance(vscan_vector, detection_vector);
+      tf::Vector3 point_vector(p.x, p.y, 0.0);
+      double distance = tf::tfDistance(point_vector, detection_vector);
       if (distance &lt; search_radius)
       {
         stop_count++;
-        geometry_msgs::Point vscan_temp;
-        vscan_temp.x = vscan.x;
-        vscan_temp.y = vscan.y;
-        vscan_temp.z = vscan.z;
-	g_obstacle.setStopPoint(calcAbsoluteCoordinate(vscan_temp, g_localizer_pose.pose));
+        geometry_msgs::Point point_temp;
+        point_temp.x = p.x;
+        point_temp.y = p.y;
+        point_temp.z = p.z;
+	g_obstacle.setStopPoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
       }
       if (stop_count &gt; g_threshold_points)
         return STOP;
@@ -351,7 +351,7 @@ EControl crossWalkDetection(const int crosswalk_id)
 }
 
 // Detect an obstacle by using pointcloud
-EControl vscanDetection(int closest_waypoint)
+EControl pointsDetection(int closest_waypoint)
 {
   if (g_points.empty() == true || closest_waypoint &lt; 0)
     return KEEP;
@@ -366,16 +366,16 @@ EControl vscanDetection(int closest_waypoint)
       g_obstacle.clearDeceleratePoints();
 
     decelerate_or_stop++;
-    if (decelerate_or_stop &gt; decelerate2stop_waypoints || (decelerate_or_stop &gt;= 0 &amp;&amp; i &gt;= g_path_dk.getSize() - 1) ||
+    if (decelerate_or_stop &gt; decelerate2stop_waypoints || (decelerate_or_stop &gt;= 0 &amp;&amp; i &gt;= g_prev_path.getSize() - 1) ||
         (decelerate_or_stop &gt;= 0 &amp;&amp; i == closest_waypoint + g_search_distance - 1))
       return DECELERATE;
-    if (i &gt; g_path_dk.getSize() - 1)
+    if (i &gt; g_prev_path.getSize() - 1)
       return KEEP;
 
     // Detection for cross walk
-    if (i == vmap.getDetectionWaypoint())
+    if (i == g_cross_walk.getDetectionWaypoint())
     {
-      if (crossWalkDetection(vmap.getDetectionCrossWalkID()) == STOP)
+      if (crossWalkDetection(g_cross_walk.getDetectionCrossWalkID()) == STOP)
       {
         g_obstacle_waypoint = i;
         return STOP;
@@ -383,7 +383,7 @@ EControl vscanDetection(int closest_waypoint)
     }
 
     // waypoint seen by vehicle
-    geometry_msgs::Point waypoint = calcRelativeCoordinate(g_path_dk.getWaypointPosition(i), g_localizer_pose.pose);
+    geometry_msgs::Point waypoint = calcRelativeCoordinate(g_prev_path.getWaypointPosition(i), g_localizer_pose.pose);
     tf::Vector3 tf_waypoint = point2vector(waypoint);
     tf_waypoint.setZ(0);
 
@@ -391,19 +391,19 @@ EControl vscanDetection(int closest_waypoint)
     int decelerate_point_count = 0;
     for (pcl::PointCloud&lt;pcl::PointXYZ&gt;::const_iterator item = g_points.begin(); item != g_points.end(); item++)
     {
-      tf::Vector3 vscan_vector((double)item-&gt;x, (double)item-&gt;y, 0);
+      tf::Vector3 point_vector((double)item-&gt;x, (double)item-&gt;y, 0);
 
-      // 2D distance between waypoint and vscan points(obstacle)
+      // 2D distance between waypoint and points(obstacle)
       // ---STOP OBSTACLE DETECTION---
-      double dt = tf::tfDistance(vscan_vector, tf_waypoint);
-      if (dt &lt; g_detection_range)
+      double dt = tf::tfDistance(point_vector, tf_waypoint);
+      if (dt &lt; g_stop_range)
       {
         stop_point_count++;
-        geometry_msgs::Point vscan_temp;
-        vscan_temp.x = item-&gt;x;
-        vscan_temp.y = item-&gt;y;
-        vscan_temp.z = item-&gt;z;
-	g_obstacle.setStopPoint(calcAbsoluteCoordinate(vscan_temp, g_localizer_pose.pose));
+        geometry_msgs::Point point_temp;
+        point_temp.x = item-&gt;x;
+        point_temp.y = item-&gt;y;
+        point_temp.z = item-&gt;z;
+	g_obstacle.setStopPoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
       }
       if (stop_point_count &gt; g_threshold_points)
       {
@@ -419,21 +419,21 @@ EControl vscanDetection(int closest_waypoint)
         continue;
 
       // ---DECELERATE OBSTACLE DETECTION---
-      if (dt &gt; g_detection_range &amp;&amp; dt &lt; g_detection_range + g_deceleration_range)
+      if (dt &gt; g_stop_range &amp;&amp; dt &lt; g_stop_range + g_deceleration_range)
       {
         bool count_flag = true;
 
         // search overlaps between DETECTION range and DECELERATION range
         for (int waypoint_search = -5; waypoint_search &lt;= 5; waypoint_search++)
         {
-          if (i + waypoint_search &lt; 0 || i + waypoint_search &gt;= g_path_dk.getSize() || !waypoint_search)
+          if (i + waypoint_search &lt; 0 || i + waypoint_search &gt;= g_prev_path.getSize() || !waypoint_search)
             continue;
           geometry_msgs::Point temp_waypoint =
-              calcRelativeCoordinate(g_path_dk.getWaypointPosition(i + waypoint_search), g_localizer_pose.pose);
+              calcRelativeCoordinate(g_prev_path.getWaypointPosition(i + waypoint_search), g_localizer_pose.pose);
           tf::Vector3 waypoint_vector = point2vector(temp_waypoint);
           waypoint_vector.setZ(0);
           // if there is a overlap, give priority to DETECTION range
-          if (tf::tfDistance(vscan_vector, waypoint_vector) &lt; g_detection_range)
+          if (tf::tfDistance(point_vector, waypoint_vector) &lt; g_stop_range)
           {
             count_flag = false;
             break;
@@ -442,11 +442,11 @@ EControl vscanDetection(int closest_waypoint)
         if (count_flag)
         {
           decelerate_point_count++;
-          geometry_msgs::Point vscan_temp;
-          vscan_temp.x = item-&gt;x;
-          vscan_temp.y = item-&gt;y;
-          vscan_temp.z = item-&gt;z;
-	  g_obstacle.setDeceleratePoint(calcAbsoluteCoordinate(vscan_temp, g_localizer_pose.pose));
+          geometry_msgs::Point point_temp;
+          point_temp.x = item-&gt;x;
+          point_temp.y = item-&gt;y;
+          point_temp.z = item-&gt;z;
+	  g_obstacle.setDeceleratePoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
         }
       }
 
@@ -468,33 +468,33 @@ EControl obstacleDetection(int closest_waypoint)
   static int false_count = 0;
   static EControl prev_detection = KEEP;
 
-  EControl vscan_result = vscanDetection(closest_waypoint);
-  displayDetectionRange(vmap.getDetectionCrossWalkID(), closest_waypoint, vscan_result);
+  EControl detection_result = pointsDetection(closest_waypoint);
+  displayDetectionRange(g_cross_walk.getDetectionCrossWalkID(), closest_waypoint, detection_result);
 
   if (prev_detection == KEEP)
   {
-    if (vscan_result != KEEP)
+    if (detection_result != KEEP)
     {  // found obstacle
-      displayObstacle(vscan_result);
-      prev_detection = vscan_result;
+      displayObstacle(detection_result);
+      prev_detection = detection_result;
       // SoundPlay();
       false_count = 0;
-      return vscan_result;
+      return detection_result;
     }
     else
     {  // no obstacle
       prev_detection = KEEP;
-      return vscan_result;
+      return detection_result;
     }
   }
   else
   {  // prev_detection = STOP or DECELERATE
-    if (vscan_result != KEEP)
+    if (detection_result != KEEP)
     {  // found obstacle
-      displayObstacle(vscan_result);
-      prev_detection = vscan_result;
+      displayObstacle(detection_result);
+      prev_detection = detection_result;
       false_count = 0;
-      return vscan_result;
+      return detection_result;
     }
     else
     {  // no obstacle
@@ -506,7 +506,7 @@ EControl obstacleDetection(int closest_waypoint)
         g_obstacle_waypoint = -1;
         false_count = 0;
         prev_detection = KEEP;
-        return vscan_result;
+        return detection_result;
       }
       else
       {
@@ -523,28 +523,28 @@ void changeWaypoint(EControl detection_result, int closest_waypoint)
 
   if (detection_result == STOP)
   {  // STOP for obstacle
-    // stop_waypoint is about g_others_distance meter away from obstacles
-    int stop_waypoint = obs - ((int)(g_others_distance / g_path_change.getInterval()));
+    // stop_waypoint is about g_stop_distance meter away from obstacles
+    int stop_waypoint = obs - ((int)(g_stop_distance / g_new_path.getInterval()));
     // change waypoints to stop by the stop_waypoint
-    g_path_change.changeWaypoints(stop_waypoint, closest_waypoint, g_decel, g_path_dk);
-    g_path_change.avoidSuddenBraking(g_velocity_change_limit, g_current_vel, g_decel, closest_waypoint);
-    g_path_change.setTemporalWaypoints(g_temporal_waypoints_size, closest_waypoint, g_control_pose);
-    g_temporal_waypoints_pub.publish(g_path_change.getTemporalWaypoints());
+    g_new_path.changeWaypoints(stop_waypoint, closest_waypoint, g_decel, g_prev_path);
+    g_new_path.avoidSuddenBraking(g_velocity_change_limit, g_current_vel, g_decel, closest_waypoint);
+    g_new_path.setTemporalWaypoints(g_temporal_waypoints_size, closest_waypoint, g_control_pose);
+    g_temporal_waypoints_pub.publish(g_new_path.getTemporalWaypoints());
   }
   else if (detection_result == DECELERATE)
   {  // DECELERATE for obstacles
-    g_path_change.setPath(g_path_dk.getCurrentWaypoints());
-    g_path_change.setDeceleration(g_current_vel, g_decel, closest_waypoint);
-    g_path_change.setTemporalWaypoints(g_temporal_waypoints_size, closest_waypoint, g_control_pose);
-    g_temporal_waypoints_pub.publish(g_path_change.getTemporalWaypoints());
+    g_new_path.setPath(g_prev_path.getCurrentWaypoints());
+    g_new_path.setDeceleration(g_current_vel, g_decel, closest_waypoint);
+    g_new_path.setTemporalWaypoints(g_temporal_waypoints_size, closest_waypoint, g_control_pose);
+    g_temporal_waypoints_pub.publish(g_new_path.getTemporalWaypoints());
   }
   else
   {  // ACELERATE or KEEP
-    g_path_change.setPath(g_path_dk.getCurrentWaypoints());
-    g_path_change.avoidSuddenAceleration(g_current_vel, g_decel, closest_waypoint);
-    g_path_change.avoidSuddenBraking(g_velocity_change_limit, g_current_vel, g_decel, closest_waypoint);
-    g_path_change.setTemporalWaypoints(g_temporal_waypoints_size, closest_waypoint, g_control_pose);
-    g_temporal_waypoints_pub.publish(g_path_change.getTemporalWaypoints());
+    g_new_path.setPath(g_prev_path.getCurrentWaypoints());
+    g_new_path.avoidSuddenAceleration(g_current_vel, g_decel, closest_waypoint);
+    g_new_path.avoidSuddenBraking(g_velocity_change_limit, g_current_vel, g_decel, closest_waypoint);
+    g_new_path.setTemporalWaypoints(g_temporal_waypoints_size, closest_waypoint, g_control_pose);
+    g_temporal_waypoints_pub.publish(g_new_path.getTemporalWaypoints());
   }
 
   return;
@@ -573,10 +573,10 @@ int main(int argc, char **argv)
   ros::Subscriber config_sub = nh.subscribe("config/velocity_set", 10, configCallback);
 
   // vector map subscribers
-  ros::Subscriber sub_dtlane = nh.subscribe("vector_map_info/cross_walk", 1, &amp;CrossWalk::crossWalkCallback, &amp;vmap);
-  ros::Subscriber sub_area = nh.subscribe("vector_map_info/area", 1, &amp;CrossWalk::areaCallback, &amp;vmap);
-  ros::Subscriber sub_line = nh.subscribe("vector_map_info/line", 1, &amp;CrossWalk::lineCallback, &amp;vmap);
-  ros::Subscriber sub_point = nh.subscribe("vector_map_info/point", 1, &amp;CrossWalk::pointCallback, &amp;vmap);
+  ros::Subscriber sub_dtlane = nh.subscribe("vector_map_info/cross_walk", 1, &amp;CrossWalk::crossWalkCallback, &amp;g_cross_walk);
+  ros::Subscriber sub_area = nh.subscribe("vector_map_info/area", 1, &amp;CrossWalk::areaCallback, &amp;g_cross_walk);
+  ros::Subscriber sub_line = nh.subscribe("vector_map_info/line", 1, &amp;CrossWalk::lineCallback, &amp;g_cross_walk);
+  ros::Subscriber sub_point = nh.subscribe("vector_map_info/point", 1, &amp;CrossWalk::pointCallback, &amp;g_cross_walk);
 
   g_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 0);
   g_temporal_waypoints_pub = nh.advertise&lt;waypoint_follower::lane&gt;("temporal_waypoints", 1000, true);
@@ -589,8 +589,8 @@ int main(int argc, char **argv)
   {
     ros::spinOnce();
 
-    if (vmap.loaded_all &amp;&amp; !vmap.set_points)
-      vmap.setCrossWalkPoints();
+    if (g_cross_walk.loaded_all &amp;&amp; !g_cross_walk.set_points)
+      g_cross_walk.setCrossWalkPoints();
 
     if (g_pose_flag == false || g_path_flag == false)
     {
@@ -598,14 +598,14 @@ int main(int argc, char **argv)
       continue;
     }
 
-    int closest_waypoint = getClosestWaypoint(g_path_change.getCurrentWaypoints(), g_control_pose.pose);
+    int closest_waypoint = getClosestWaypoint(g_new_path.getCurrentWaypoints(), g_control_pose.pose);
 
     std_msgs::Int32 closest_waypoint_msg;
     closest_waypoint_msg.data = closest_waypoint;
     closest_waypoint_pub.publish(closest_waypoint_msg);
 
     if (use_crosswalk_detection)
-      vmap.setDetectionWaypoint(findCrossWalk(closest_waypoint));
+      g_cross_walk.setDetectionWaypoint(findCrossWalk(closest_waypoint));
 
     EControl detection_result = obstacleDetection(closest_waypoint);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ee50d6aa14b8dc809b7c36e63bf5768895f47301" author="TomohitoAndo">
		<msg>Make obstacle detection function more concise</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="118" deleted_lines="76">
				<diff>@@ -350,117 +350,159 @@ EControl crossWalkDetection(const int crosswalk_id)
   return KEEP;  // find no obstacles
 }
 
-// Detect an obstacle by using pointcloud
-EControl pointsDetection(int closest_waypoint)
+int detectStopObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points)
 {
-  if (g_points.empty() == true || closest_waypoint &lt; 0)
-    return KEEP;
-
-  int decelerate_or_stop = -10000;
-  int decelerate2stop_waypoints = 15;
-
+  int stop_obstacle_waypoint = -1;
+  // start search from the closest waypoint
   for (int i = closest_waypoint; i &lt; closest_waypoint + g_search_distance; i++)
   {
-    g_obstacle.clearStopPoints();
-    if (!g_obstacle.isDecided())
-      g_obstacle.clearDeceleratePoints();
-
-    decelerate_or_stop++;
-    if (decelerate_or_stop &gt; decelerate2stop_waypoints || (decelerate_or_stop &gt;= 0 &amp;&amp; i &gt;= g_prev_path.getSize() - 1) ||
-        (decelerate_or_stop &gt;= 0 &amp;&amp; i == closest_waypoint + g_search_distance - 1))
-      return DECELERATE;
-    if (i &gt; g_prev_path.getSize() - 1)
-      return KEEP;
+    // reach the end of waypoints
+    if (i &gt;= g_prev_path.getSize())
+      break;
 
     // Detection for cross walk
     if (i == g_cross_walk.getDetectionWaypoint())
     {
+      // found an obstacle in the cross walk
       if (crossWalkDetection(g_cross_walk.getDetectionCrossWalkID()) == STOP)
       {
-        g_obstacle_waypoint = i;
-        return STOP;
+        stop_obstacle_waypoint = i;
+        break;
       }
     }
 
-    // waypoint seen by vehicle
+    // waypoint seen by localizer
     geometry_msgs::Point waypoint = calcRelativeCoordinate(g_prev_path.getWaypointPosition(i), g_localizer_pose.pose);
     tf::Vector3 tf_waypoint = point2vector(waypoint);
     tf_waypoint.setZ(0);
 
     int stop_point_count = 0;
-    int decelerate_point_count = 0;
-    for (pcl::PointCloud&lt;pcl::PointXYZ&gt;::const_iterator item = g_points.begin(); item != g_points.end(); item++)
+    for (const auto&amp; p : points)
     {
-      tf::Vector3 point_vector((double)item-&gt;x, (double)item-&gt;y, 0);
+      tf::Vector3 point_vector(p.x, p.y, 0);
 
-      // 2D distance between waypoint and points(obstacle)
-      // ---STOP OBSTACLE DETECTION---
+      // 2D distance between waypoint and points (obstacle)
       double dt = tf::tfDistance(point_vector, tf_waypoint);
       if (dt &lt; g_stop_range)
       {
         stop_point_count++;
         geometry_msgs::Point point_temp;
-        point_temp.x = item-&gt;x;
-        point_temp.y = item-&gt;y;
-        point_temp.z = item-&gt;z;
+        point_temp.x = p.x;
+        point_temp.y = p.y;
+        point_temp.z = p.z;
 	g_obstacle.setStopPoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
       }
-      if (stop_point_count &gt; g_threshold_points)
-      {
-        g_obstacle_waypoint = i;
-        return STOP;
-      }
+    }
 
-      // without deceleration range
-      if (g_deceleration_range &lt; 0.01)
-        continue;
-      // deceleration search runs "decelerate_search_distance" waypoints from closest
-      if (i &gt; closest_waypoint + g_deceleration_search_distance || decelerate_or_stop &gt;= 0)
-        continue;
+    // there is an obstacle if the number of points exceeded the threshold
+    if (stop_point_count &gt; g_threshold_points)
+    {
+      stop_obstacle_waypoint = i;
+      break;
+    }
 
-      // ---DECELERATE OBSTACLE DETECTION---
-      if (dt &gt; g_stop_range &amp;&amp; dt &lt; g_stop_range + g_deceleration_range)
-      {
-        bool count_flag = true;
+    g_obstacle.clearStopPoints();
 
-        // search overlaps between DETECTION range and DECELERATION range
-        for (int waypoint_search = -5; waypoint_search &lt;= 5; waypoint_search++)
-        {
-          if (i + waypoint_search &lt; 0 || i + waypoint_search &gt;= g_prev_path.getSize() || !waypoint_search)
-            continue;
-          geometry_msgs::Point temp_waypoint =
-              calcRelativeCoordinate(g_prev_path.getWaypointPosition(i + waypoint_search), g_localizer_pose.pose);
-          tf::Vector3 waypoint_vector = point2vector(temp_waypoint);
-          waypoint_vector.setZ(0);
-          // if there is a overlap, give priority to DETECTION range
-          if (tf::tfDistance(point_vector, waypoint_vector) &lt; g_stop_range)
-          {
-            count_flag = false;
-            break;
-          }
-        }
-        if (count_flag)
-        {
-          decelerate_point_count++;
-          geometry_msgs::Point point_temp;
-          point_temp.x = item-&gt;x;
-          point_temp.y = item-&gt;y;
-          point_temp.z = item-&gt;z;
-	  g_obstacle.setDeceleratePoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
-        }
-      }
+    // check next waypoint...
+  }
+
+  return stop_obstacle_waypoint;
+}
+
+int detectDecelerateObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points)
+{
+  int decelerate_obstacle_waypoint = -1;
+  // start search from the closest waypoint
+  for (int i = closest_waypoint; i &lt; closest_waypoint + g_deceleration_search_distance; i++)
+  {
+    // reach the end of waypoints
+    if (i &gt;= g_prev_path.getSize())
+      break;
+
+    // waypoint seen by localizer
+    geometry_msgs::Point waypoint = calcRelativeCoordinate(g_prev_path.getWaypointPosition(i), g_localizer_pose.pose);
+    tf::Vector3 tf_waypoint = point2vector(waypoint);
+    tf_waypoint.setZ(0);
 
-      // found obstacle to DECELERATE
-      if (decelerate_point_count &gt; g_threshold_points)
+    int decelerate_point_count = 0;
+    for (const auto&amp; p : points)
+    {
+      tf::Vector3 point_vector(p.x, p.y, 0);
+
+      // 2D distance between waypoint and points (obstacle)
+      double dt = tf::tfDistance(point_vector, tf_waypoint);
+      if (dt &gt; g_stop_range &amp;&amp; dt &lt; g_stop_range + g_deceleration_range)
       {
-        g_obstacle_waypoint = i;
-        decelerate_or_stop = 0;  // for searching near STOP obstacle
-        g_obstacle.setDecided(true);
+        decelerate_point_count++;
+        geometry_msgs::Point point_temp;
+        point_temp.x = p.x;
+        point_temp.y = p.y;
+        point_temp.z = p.z;
+	g_obstacle.setDeceleratePoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
       }
     }
+
+    // there is an obstacle if the number of points exceeded the threshold
+    if (decelerate_point_count &gt; g_threshold_points)
+    {
+      decelerate_obstacle_waypoint = i;
+      break;
+    }
+
+    g_obstacle.clearDeceleratePoints();
+
+    // check next waypoint...
+  }
+
+  return decelerate_obstacle_waypoint;
+}
+
+
+// Detect an obstacle by using pointcloud
+EControl pointsDetection(const int closest_waypoint)
+{
+  if (g_points.empty() == true || closest_waypoint &lt; 0)
+    return KEEP;
+
+  int stop_obstacle_waypoint = detectStopObstacle(closest_waypoint, g_points);
+
+  // skip searching deceleration range
+  if (g_deceleration_range &lt; 0.01)
+  {
+    g_obstacle_waypoint = stop_obstacle_waypoint;
+    return stop_obstacle_waypoint &lt; 0 ? KEEP : STOP;
+  }
+
+  int decelerate_obstacle_waypoint = detectDecelerateObstacle(closest_waypoint, g_points);
+
+  // stop obstacle was not found
+  if (stop_obstacle_waypoint &lt; 0)
+  {
+    g_obstacle_waypoint  = decelerate_obstacle_waypoint;
+    return decelerate_obstacle_waypoint &lt; 0 ? KEEP : DECELERATE;
+  }
+
+  // stop obstacle was found but decelerate obstacle was not found
+  if (decelerate_obstacle_waypoint &lt; 0)
+  {
+    g_obstacle_waypoint = stop_obstacle_waypoint;
+    return STOP;
+  }
+
+  int stop_decelerate_threshold = 5.0 / g_prev_path.getInterval(); // about 5.0 meter
+
+  // both were found
+  if (stop_obstacle_waypoint - decelerate_obstacle_waypoint &gt; stop_decelerate_threshold)
+  {
+    g_obstacle_waypoint = decelerate_obstacle_waypoint;
+    return DECELERATE;
+  }
+  else
+  {
+    g_obstacle_waypoint = stop_obstacle_waypoint;
+    return STOP;
   }
 
-  return KEEP;  // no obstacles
 }
 
 EControl obstacleDetection(int closest_waypoint)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a7e343e7a197da70b353ff8859f86d4e21ec76cc" author="Yukihiro Saito">
		<msg>Add vscan points in potential field</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\potential_field\potential_field.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\potential_field\potential_field.cpp" added_lines="232" deleted_lines="74">
				<diff>@@ -1,113 +1,271 @@
+#include "tf/transform_listener.h"
 #include &lt;cmath&gt;
+#include &lt;geometry_msgs/PointStamped.h&gt;
 #include &lt;grid_map_msgs/GridMap.h&gt;
 #include &lt;grid_map_ros/grid_map_ros.hpp&gt;
 #include &lt;iostream&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
+//#include &lt;omp.h&gt;
+#include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include &lt;ros/ros.h&gt;
+#include &lt;sensor_msgs/PointCloud2.h&gt;
+#include &lt;visualization_msgs/Marker.h&gt;
+#include &lt;visualization_msgs/MarkerArray.h&gt;
 
 using namespace grid_map;
 ros::Publisher publisher;
 
-double ver_y_p = 1.0;
-double ver_x_p = 1.0;
+double ver_y_p = 0.7;
+double ver_x_p = 0.7;
+double target_ver_y_p = 1.0;
+double target_ver_x_p = 1.0;
+
+double tf_x = 1.2;
+double tf_z = 2.0;
+
+static GridMap map({"obstacle_potential_field", "potential_field",
+                    "waypoint_field", "vscan_field"});
 
 void obj_callback(jsk_recognition_msgs::BoundingBoxArray::ConstPtr
                       obj_msg) { // Create grid map.
-  ROS_INFO("Created map");
-  GridMap map({"potential_field"});
-  map.setFrameId("velodyne");
-  map.setGeometry(Length(30.0, 30.0), 0.5);
-  ROS_INFO("Created map with size %f x %f m (%i x %i cells).",
-           map.getLength().x(), map.getLength().y(), map.getSize()(0),
-           map.getSize()(1));
 
   // Add data to grid map.
   ros::Time time = ros::Time::now();
+#if 0
+#ifdef _OPENMP
+  std::vector&lt;float&gt; v_map;
+  {
+    GridMapIterator it(map);
+    int j;
+    std::cout &lt;&lt; "openMP" &lt;&lt; std::endl;
+    v_map.resize(
+        (int)(40.0 * 20.0 / (map.getResolution() * map.getResolution())));
+    double pos_x;
+    double pos_y;
+    double len_x;
+    double len_y;
+    Position position;
+#pragma omp parallel for private(map, position, pos_x, pos_y, len_x, len_y)
+    for (j = 0;
+         j &lt; (int)(40.0 * 20.0 / (map.getResolution() * map.getResolution()));
+         ++j) {
+      if (j != 0)
+        ++it;
+      map.getPosition(*it, position);
+      v_map.at(j) = -0.1;
+      for (int i(0); i &lt; (int)obj_msg-&gt;boxes.size(); ++i) {
+        pos_x = obj_msg-&gt;boxes.at(i).pose.position.x + 2.0;
+        pos_y = obj_msg-&gt;boxes.at(i).pose.position.y;
+        len_x = obj_msg-&gt;boxes.at(i).dimensions.x / 2.0;
+        len_y = obj_msg-&gt;boxes.at(i).dimensions.y / 2.0;
+
+        if (pos_x - len_x &lt; position.x() &amp;&amp; position.x() &lt; pos_x + len_x) {
+          if (pos_y - len_y &lt; position.y() &amp;&amp; position.y() &lt; pos_y + len_y) {
+            v_map.at(j) += std::exp(0.0);
+          }
+        }
+      }
+    }
+  }
+  GridMapIterator it(map);
+  int j;
+
+  for (j = 0;
+       j &lt; (int)(40.0 * 20.0 / (map.getResolution() * map.getResolution()));
+       ++j) {
+    if (j != 0)
+      ++it;
+    map.at("obstacle_potential_field", *it) = v_map.at(j);
+  }
+#endif
+#else
   for (GridMapIterator it(map); !it.isPastEnd(); ++it) {
+
     Position position;
     map.getPosition(*it, position);
-    map.at("potential_field", *it) = -0.04;
+    map.at("obstacle_potential_field", *it) = 0.0;
     for (int i(0); i &lt; (int)obj_msg-&gt;boxes.size(); ++i) {
-      if (obj_msg-&gt;boxes.at(i).pose.position.x -
-                  obj_msg-&gt;boxes.at(i).dimensions.x &lt;
-              position.x() &amp;&amp;
-          position.x() &lt; obj_msg-&gt;boxes.at(i).pose.position.x +
-                             obj_msg-&gt;boxes.at(i).dimensions.x)
-        if (obj_msg-&gt;boxes.at(i).pose.position.y -
-                    obj_msg-&gt;boxes.at(i).dimensions.y &lt;
-                position.y() &amp;&amp;
-            position.y() &lt; obj_msg-&gt;boxes.at(i).pose.position.y +
-                               obj_msg-&gt;boxes.at(i).dimensions.y)
-          map.at("potential_field", *it) = 1.0;
-
-      map.at("potential_field", *it) += std::exp(
-          (-1.0 *
-           (std::pow((position.y() - (obj_msg-&gt;boxes.at(i).pose.position.y -
-                                      obj_msg-&gt;boxes.at(i).dimensions.y)),
-                     2.0) /
-            std::pow(2.0 * ver_y_p, 2.0))) +
-          (-1.0 *
-           (std::pow((position.x() - (obj_msg-&gt;boxes.at(i).pose.position.x -
-                                      obj_msg-&gt;boxes.at(i).dimensions.x)),
-                     2.0) /
-            std::pow(2.0 * ver_x_p, 2.0))));
-      map.at("potential_field", *it) += std::exp(
-          (-1.0 *
-           (std::pow((position.y() - (obj_msg-&gt;boxes.at(i).pose.position.y +
-                                      obj_msg-&gt;boxes.at(i).dimensions.y)),
-                     2.0) /
-            std::pow(2.0 * ver_y_p, 2.0))) +
-          (-1.0 *
-           (std::pow((position.x() - (obj_msg-&gt;boxes.at(i).pose.position.x -
-                                      obj_msg-&gt;boxes.at(i).dimensions.x)),
-                     2.0) /
-            std::pow(2.0 * ver_x_p, 2.0))));
-      map.at("potential_field", *it) += std::exp(
-          (-1.0 *
-           (std::pow((position.y() - (obj_msg-&gt;boxes.at(i).pose.position.y -
-                                      obj_msg-&gt;boxes.at(i).dimensions.y)),
-                     2.0) /
-            std::pow(2.0 * ver_y_p, 2.0))) +
-          (-1.0 *
-           (std::pow((position.x() - (obj_msg-&gt;boxes.at(i).pose.position.x +
-                                      obj_msg-&gt;boxes.at(i).dimensions.x)),
-                     2.0) /
-            std::pow(2.0 * ver_x_p, 2.0))));
-      map.at("potential_field", *it) += std::exp(
-          (-1.0 *
-           (std::pow((position.y() - (obj_msg-&gt;boxes.at(i).pose.position.y +
-                                      obj_msg-&gt;boxes.at(i).dimensions.y)),
-                     2.0) /
-            std::pow(2.0 * ver_y_p, 2.0))) +
-          (-1.0 *
-           (std::pow((position.x() - (obj_msg-&gt;boxes.at(i).pose.position.x +
-                                      obj_msg-&gt;boxes.at(i).dimensions.x)),
-                     2.0) /
-            std::pow(2.0 * ver_x_p, 2.0))));
+      double pos_x = obj_msg-&gt;boxes.at(i).pose.position.x + tf_z;
+      double pos_y = obj_msg-&gt;boxes.at(i).pose.position.y;
+      double len_x = obj_msg-&gt;boxes.at(i).dimensions.x / 2.0;
+      double len_y = obj_msg-&gt;boxes.at(i).dimensions.y / 2.0;
+
+      if (-0.5 &lt; pos_x &amp;&amp; pos_x &lt; 4.0) {
+        if (-1.0 &lt; pos_y &amp;&amp; pos_y &lt; 1.0)
+          continue;
+      }
+      if (pos_x - len_x &lt; position.x() &amp;&amp; position.x() &lt; pos_x + len_x) {
+        if (pos_y - len_y &lt; position.y() &amp;&amp; position.y() &lt; pos_y + len_y) {
+          map.at("obstacle_potential_field", *it) += std::exp(0.0);
+        } else if (position.y() &lt; pos_y - len_y) {
+          map.at("obstacle_potential_field", *it) += std::exp(
+              (-1.0 * (std::pow((position.y() - (pos_y - len_y)), 2.0) /
+                       std::pow(2.0 * ver_y_p, 2.0))));
+        } else if (pos_y + len_y &lt; position.y()) {
+          map.at("obstacle_potential_field", *it) += std::exp(
+              (-1.0 * (std::pow((position.y() - (pos_y + len_y)), 2.0) /
+                       std::pow(2.0 * ver_y_p, 2.0))));
+        }
+      } else if (pos_y - len_y &lt; position.y() &amp;&amp; position.y() &lt; pos_y + len_y) {
+        if (pos_x - len_x &lt; position.x() &amp;&amp; position.x() &lt; pos_x + len_x) {
+          map.at("obstacle_potential_field", *it) += std::exp(0.0);
+        } else if (position.x() &lt; pos_x - len_x) {
+          map.at("obstacle_potential_field", *it) += std::exp(
+              (-1.0 * (std::pow((position.x() - (pos_x - len_x)), 2.0) /
+                       std::pow(2.0 * ver_x_p, 2.0))));
+        } else if (pos_x + len_x &lt; position.x()) {
+          map.at("obstacle_potential_field", *it) += std::exp(
+              (-1.0 * (std::pow((position.x() - (pos_x + len_x)), 2.0) /
+                       std::pow(2.0 * ver_x_p, 2.0))));
+        }
+      } else if (position.x() &lt; pos_x - len_x) {
+        if (position.y() &lt; pos_y - len_y) {
+          map.at("obstacle_potential_field", *it) += std::exp(
+              (-1.0 * (std::pow((position.y() - (pos_y - len_y)), 2.0) /
+                       std::pow(2.0 * ver_y_p, 2.0))) +
+              (-1.0 * (std::pow((position.x() - (pos_x - len_x)), 2.0) /
+                       std::pow(2.0 * ver_x_p, 2.0))));
+        } else if (pos_y + len_y &lt; position.y()) {
+          map.at("obstacle_potential_field", *it) += std::exp(
+              (-1.0 * (std::pow((position.y() - (pos_y + len_y)), 2.0) /
+                       std::pow(2.0 * ver_y_p, 2.0))) +
+              (-1.0 * (std::pow((position.x() - (pos_x - len_x)), 2.0) /
+                       std::pow(2.0 * ver_x_p, 2.0))));
+        }
+      } else if (pos_x + len_x &lt; position.x()) {
+        if (position.y() &lt; pos_y - len_y) {
+          map.at("obstacle_potential_field", *it) += std::exp(
+              (-1.0 * (std::pow((position.y() - (pos_y - len_y)), 2.0) /
+                       std::pow(2.0 * ver_y_p, 2.0))) +
+              (-1.0 * (std::pow((position.x() - (pos_x + len_x)), 2.0) /
+                       std::pow(2.0 * ver_x_p, 2.0))));
+        } else if (pos_y + len_y / 2.0 &lt; position.y()) {
+          map.at("obstacle_potential_field", *it) += std::exp(
+              (-1.0 * (std::pow((position.y() - (pos_y + len_y)), 2.0) /
+                       std::pow(2.0 * ver_y_p, 2.0))) +
+              (-1.0 * (std::pow((position.x() - (pos_x + len_x)), 2.0) /
+                       std::pow(2.0 * ver_x_p, 2.0))));
+        }
+      }
     }
-    // map.at("potential_field", *it) = std::exp(
-    //     (-1.0 * (std::pow((position.y()), 2) / std::pow(2.0 * ver_y_p, 2.0)))
-    //     +
-    //     (-1.0 *
-    //      (std::pow((position.x() - 3.0), 2) / std::pow(2.0 * ver_x_p,
-    //      2.0))));
   }
+#endif
   // Publish grid map.
   map.setTimestamp(time.toNSec());
   grid_map_msgs::GridMap message;
+  // map["potential_field"] = map["obstacle_potential_field"] +
+  //                          map["waypoint_field"] + map["vscan_field"];
+  map["potential_field"] =
+      map["obstacle_potential_field"].cwiseMax(map["vscan_field"]) +
+      map["waypoint_field"];
+
   GridMapRosConverter::toMessage(map, message);
   publisher.publish(message);
   ROS_INFO_THROTTLE(1.0, "Grid map (timestamp %f) published.",
                     message.info.header.stamp.toSec());
 }
+void target_poiny_callback(
+    visualization_msgs::Marker::ConstPtr target_point_msgs) {
+  ros::Time time = ros::Time::now();
+  geometry_msgs::PointStamped in, out;
+  in.header = target_point_msgs-&gt;header;
+  in.point = target_point_msgs-&gt;pose.position;
+  tf::TransformListener tflistener;
+  try {
+    ros::Time now = ros::Time(0);
+    tflistener.waitForTransform("/map", "/base_link", now, ros::Duration(10.0));
+    tflistener.transformPoint("/base_link", in.header.stamp, in, "/map", out);
+
+  } catch (tf::TransformException &amp;ex) {
+    ROS_ERROR("%s", ex.what());
+  }
 
+  for (GridMapIterator it(map); !it.isPastEnd(); ++it) {
+    Position position;
+    map.getPosition(*it, position);
+    map.at("waypoint_field", *it) = 0.0;
+    map.at("waypoint_field", *it) -=
+        0.5 * std::exp((-1.0 * (std::pow((position.y() - (out.point.y)), 2.0) /
+                                std::pow(2.0 * target_ver_y_p, 2.0))) +
+                       (-1.0 * (std::pow((position.x() - (out.point.x)), 2.0) /
+                                std::pow(2.0 * target_ver_x_p, 2.0))));
+  }
+  map.setTimestamp(time.toNSec());
+  grid_map_msgs::GridMap message;
+  // map["potential_field"] = map["obstacle_potential_field"] +
+  //                          map["waypoint_field"] + map["vscan_field"];
+  map["potential_field"] =
+      map["obstacle_potential_field"].cwiseMax(map["vscan_field"]) +
+      map["waypoint_field"];
+
+  GridMapRosConverter::toMessage(map, message);
+  publisher.publish(message);
+  ROS_INFO_THROTTLE(1.0, "Grid map (timestamp %f) published.",
+                    message.info.header.stamp.toSec());
+}
+void vscan_points_callback(sensor_msgs::PointCloud2::ConstPtr vscan_msg) {
+  ros::Time time = ros::Time::now();
+  pcl::PointCloud&lt;pcl::PointXYZ&gt; pcl_vscan;
+  pcl::fromROSMsg(*vscan_msg, pcl_vscan);
+  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr pcl_vscan_ptr(
+      new pcl::PointCloud&lt;pcl::PointXYZ&gt;(pcl_vscan));
+  // for (int i(0); i &lt; (int)pcl_vscan.size(); ++i)
+  //   std::cout &lt;&lt; pcl_vscan.at(i).x &lt;&lt; "," &lt;&lt; pcl_vscan.at(i).y &lt;&lt; std::endl;
+
+  for (GridMapIterator it(map); !it.isPastEnd(); ++it) {
+    Position position;
+    map.getPosition(*it, position);
+    map.at("vscan_field", *it) = 0.0;
+    for (int i(0); i &lt; (int)pcl_vscan.size(); ++i) {
+      if (3.5 &lt; pcl_vscan.at(i).z + tf_x || pcl_vscan.at(i).z + tf_x &lt; 0.2)
+        continue;
+      if (pcl_vscan.at(i).x + tf_z - map.getResolution() &lt; position.x() &amp;&amp;
+          position.x() &lt; pcl_vscan.at(i).x + tf_z + map.getResolution()) {
+        if (pcl_vscan.at(i).y - map.getResolution() &lt; position.y() &amp;&amp;
+            position.y() &lt; pcl_vscan.at(i).y + map.getResolution()) {
+          map.at("vscan_field", *it) = std::exp(0.0);
+        }
+      }
+    }
+  }
+  map.setTimestamp(time.toNSec());
+  grid_map_msgs::GridMap message;
+  // map["potential_field"] = map["obstacle_potential_field"] +
+  //                          map["waypoint_field"] + map["vscan_field"];
+  map["potential_field"] =
+      map["obstacle_potential_field"].cwiseMax(map["vscan_field"]) +
+      map["waypoint_field"];
+  GridMapRosConverter::toMessage(map, message);
+  publisher.publish(message);
+  ROS_INFO_THROTTLE(1.0, "Grid map (timestamp %f) published.",
+                    message.info.header.stamp.toSec());
+}
 int main(int argc, char **argv) {
   // Initialize node and publisher.
   ros::init(argc, argv, "potential_field");
-  ros::NodeHandle nh("~");
+  ros::NodeHandle nh;
+
   publisher = nh.advertise&lt;grid_map_msgs::GridMap&gt;("/potential_field", 1, true);
-  ros::Subscriber subscriber = nh.subscribe("/bounding_boxes", 1, obj_callback);
+  ros::Subscriber obj_subscriber =
+      nh.subscribe("/bounding_boxes", 1, obj_callback);
+  ros::Subscriber waypoint_subscriber =
+      nh.subscribe("/next_target_mark", 1, target_poiny_callback);
+  ros::Subscriber vscan_subscriber =
+      nh.subscribe("/vscan_points", 1, vscan_points_callback);
+  ROS_INFO("Created map");
+  map.setFrameId("/base_link");
+  map.setGeometry(Length(40.0, 25.0), 0.5);
+  for (GridMapIterator it(map); !it.isPastEnd(); ++it) {
+    Position position;
+    map.getPosition(*it, position);
+    map.at("obstacle_potential_field", *it) = 0.0;
+    map.at("waypoint_field", *it) = 0.0;
+    map.at("vscan_field", *it) = 0.0;
+  }
+  ROS_INFO("Created map with size %f x %f m (%i x %i cells).",
+           map.getLength().x(), map.getLength().y(), map.getSize()(0),
+           map.getSize()(1));
   ros::spin();
   return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1072ceafb40e32da82a2ceb1a572ede991017456" author="TomohitoAndo">
		<msg>Use constexpr for constant values</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -41,7 +41,7 @@
 
 namespace
 {
-const int LOOP_RATE = 10;
+constexpr int LOOP_RATE = 10;
 
 geometry_msgs::PoseStamped g_localizer_pose;  // pose of sensor
 geometry_msgs::PoseStamped g_control_pose;  // pose of base_link
@@ -50,8 +50,8 @@ pcl::PointCloud&lt;pcl::PointXYZ&gt; g_points;
 bool g_pose_flag = false;
 bool g_path_flag = false;
 int g_obstacle_waypoint = -1;
-double g_deceleration_search_distance = 30;
-double g_search_distance = 60;
+constexpr double g_deceleration_search_distance = 30;
+constexpr double g_search_distance = 60;
 double g_current_vel = 0.0;  // (m/s)
 CrossWalk g_cross_walk;
 ObstaclePoints g_obstacle;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cc19c9676fa870e25584f75cef408bace881e2e8" author="TomohitoAndo">
		<msg>Remove the dependency of libvelocity_set</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\lib\libvelocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\include\libvelocity_set.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c3ece95a7ae0b015ee38cd552a80ebafb733c075" author="Takahiro Miki">
		<msg>Add low pass filter to twist</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_filter\twist_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_filter\twist_filter.cpp" added_lines="11" deleted_lines="0">
				<diff>@@ -42,6 +42,8 @@ ros::Publisher g_twist_pub;
 double g_lateral_accel_limit = 5.0;
 constexpr double RADIUS_MAX = 9e10;
 constexpr double ERROR = 1e-8;
+const double g_lowpass_gain_linear_x = 0.9;
+const double g_lowpass_gain_angular_z = 0.9;
 
 void configCallback(const runtime_manager::ConfigTwistFilterConstPtr &amp;config)
 {
@@ -68,10 +70,19 @@ void TwistCmdCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg)
   double a = v * omega;
   ROS_INFO("lateral accel = %lf", a);
 
+
   tp.twist.linear.x = fabs(a) &gt; g_lateral_accel_limit ? max_v
                     : v;
   tp.twist.angular.z = omega;
 
+  static double lowpass_linear_x = 0;
+  static double lowpass_angular_z = 0;
+  lowpass_linear_x = g_lowpass_gain_linear_x * lowpass_linear_x + (1 - g_lowpass_gain_linear_x) * tp.twist.linear.x;
+  lowpass_angular_z = g_lowpass_gain_angular_z * lowpass_angular_z + (1 - g_lowpass_gain_angular_z) * tp.twist.angular.z;
+
+  tp.twist.linear.x = lowpass_linear_x;
+  tp.twist.angular.z = lowpass_angular_z;
+
   ROS_INFO("v: %f -&gt; %f",v,tp.twist.linear.x);
   g_twist_pub.publish(tp);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="776d5b948597f6ce0972f86880e5afccabb2a389" author="TomohitoAndo">
		<msg>Use local variables instead of global variables</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" added_lines="40" deleted_lines="9">
				<diff>@@ -248,10 +248,47 @@ void CrossWalk::setCrossWalkPoints()
   set_points = true;
 }
 
-geometry_msgs::Point ObstaclePoints::getObstaclePoint(const EControl &amp;kind)
+int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const waypoint_follower::lane&amp; lane, const int search_distance)
+{
+  if (!set_points || closest_waypoint &lt; 0)
+    return -1;
+
+  double find_distance = 2.0 * 2.0;      // meter
+  double ignore_distance = 20.0 * 20.0;  // meter
+  static std::vector&lt;int&gt; bdid = getBDID();
+  // Find near cross walk
+  for (int num = closest_waypoint; num &lt; closest_waypoint + search_distance; num++)
+  {
+    geometry_msgs::Point waypoint = lane.waypoints[num].pose.pose.position;
+    waypoint.z = 0.0;  // ignore Z axis
+    for (const auto &amp;i : bdid)
+    {
+      // ignore far crosswalk
+      geometry_msgs::Point crosswalk_center = getDetectionPoints(i).center;
+      crosswalk_center.z = 0.0;
+      if (calcSquareOfLength(crosswalk_center, waypoint) &gt; ignore_distance)
+        continue;
+
+      for (auto p : getDetectionPoints(i).points)
+      {
+        p.z = waypoint.z;
+        if (calcSquareOfLength(p, waypoint) &lt; find_distance)
+        {
+          setDetectionCrossWalkID(i);
+          return num;
+        }
+      }
+    }
+  }
+
+  setDetectionCrossWalkID(-1);
+  return -1;  // no near crosswalk
+
+}
+
+geometry_msgs::Point ObstaclePoints::getObstaclePoint(const EControl &amp;kind) const
 {
   geometry_msgs::Point point;
-  decided_ = false;
 
   if (kind == STOP)
   {
@@ -265,10 +302,9 @@ geometry_msgs::Point ObstaclePoints::getObstaclePoint(const EControl &amp;kind)
     point.y /= stop_points_.size();
     point.z /= stop_points_.size();
 
-    previous_detection_ = point;
     return point;
   }
-  else if (kind == DECELERATE)
+  else // kind == DECELERATE
   {
     for (const auto &amp;p : decelerate_points_)
     {
@@ -280,11 +316,6 @@ geometry_msgs::Point ObstaclePoints::getObstaclePoint(const EControl &amp;kind)
     point.y /= decelerate_points_.size();
     point.z /= decelerate_points_.size();
 
-    previous_detection_ = point;
     return point;
   }
-  else
-  {
-    return previous_detection_;
-  }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" added_lines="5" deleted_lines="15">
				<diff>@@ -11,6 +11,8 @@
 #include &lt;geometry_msgs/Point.h&gt;
 #include &lt;vector_map/vector_map.h&gt;
 
+#include "waypoint_follower/libwaypoint_follower.h"
+
 enum EControl
 {
   KEEP = -1,
@@ -61,6 +63,7 @@ public:
   geometry_msgs::Point getPoint(const int &amp;pid) const;
   void calcCenterPoints();
   void setCrossWalkPoints();
+  int findClosestCrosswalk(const int closest_waypoint, const waypoint_follower::lane&amp; lane, const int search_distance);
   int getSize() const
   {
     return detection_points_.size();
@@ -112,7 +115,6 @@ private:
   std::vector&lt;geometry_msgs::Point&gt; stop_points_;
   std::vector&lt;geometry_msgs::Point&gt; decelerate_points_;
   geometry_msgs::Point previous_detection_;
-  bool decided_;
 
 public:
   void setStopPoint(const geometry_msgs::Point &amp;p)
@@ -123,11 +125,7 @@ public:
   {
     decelerate_points_.push_back(p);
   }
-  void setDecided(const bool &amp;b)
-  {
-    decided_ = b;
-  }
-  geometry_msgs::Point getObstaclePoint(const EControl &amp;kind);
+  geometry_msgs::Point getObstaclePoint(const EControl &amp;kind) const;
   void clearStopPoints()
   {
     stop_points_.clear();
@@ -136,16 +134,8 @@ public:
   {
     decelerate_points_.clear();
   }
-  bool isDecided()
-  {
-    return decided_;
-  }
-  geometry_msgs::Point getPreviousDetection()
-  {
-    return previous_detection_;
-  }
 
-  ObstaclePoints() : stop_points_(0), decelerate_points_(0), decided_(false)
+  ObstaclePoints() : stop_points_(0), decelerate_points_(0)
   {
   }
 };
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="66" deleted_lines="94">
				<diff>@@ -35,7 +35,6 @@
 #include &lt;runtime_manager/ConfigVelocitySet.h&gt;
 #include &lt;iostream&gt;
 
-#include "waypoint_follower/libwaypoint_follower.h"
 #include "libvelocity_set.h"
 #include "velocity_set_path.h"
 
@@ -49,12 +48,9 @@ pcl::PointCloud&lt;pcl::PointXYZ&gt; g_points;
 
 bool g_pose_flag = false;
 bool g_path_flag = false;
-int g_obstacle_waypoint = -1;
 constexpr double g_deceleration_search_distance = 30;
 constexpr double g_search_distance = 60;
 double g_current_vel = 0.0;  // (m/s)
-CrossWalk g_cross_walk;
-ObstaclePoints g_obstacle;
 
 // Config Parameter
 double g_stop_range = 0;                   // if obstacle is in this range, stop
@@ -137,7 +133,7 @@ void localizerCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 }
 
 // Display a detected obstacle
-void displayObstacle(const EControl &amp;kind)
+void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points)
 {
   visualization_msgs::Marker marker;
   marker.header.frame_id = "/map";
@@ -146,10 +142,19 @@ void displayObstacle(const EControl &amp;kind)
   marker.id = 0;
   marker.type = visualization_msgs::Marker::CUBE;
   marker.action = visualization_msgs::Marker::ADD;
-  marker.pose.position = g_obstacle.getObstaclePoint(kind);
-  if (kind == OTHERS)
-    marker.pose.position = g_obstacle.getPreviousDetection();
+
+  static geometry_msgs::Point prev_obstacle_point;
+  if (kind == STOP || kind == DECELERATE)
+  {
+    marker.pose.position = obstacle_points.getObstaclePoint(kind);
+    prev_obstacle_point = marker.pose.position;
+  }
+  else // kind == OTHERS
+  {
+    marker.pose.position = prev_obstacle_point;
+  }
   marker.pose.orientation = g_localizer_pose.pose.orientation;
+
   marker.scale.x = 1.0;
   marker.scale.y = 1.0;
   marker.scale.z = 2.0;
@@ -169,10 +174,10 @@ void displayObstacle(const EControl &amp;kind)
   marker.lifetime = ros::Duration(0.1);
   marker.frame_locked = true;
 
-  //g_obstacle_pub.publish(marker);
+  g_obstacle_pub.publish(marker);
 }
 
-void displayDetectionRange(const int crosswalk_id, const int num, const EControl &amp;kind)
+void displayDetectionRange(const CrossWalk&amp; crosswalk, const int num, const EControl &amp;kind, const int obstacle_waypoint)
 {
   // set up for marker array
   visualization_msgs::MarkerArray marker_array;
@@ -217,10 +222,10 @@ void displayDetectionRange(const int crosswalk_id, const int num, const EControl
   waypoint_marker_decelerate.color.b = 0.0;
   waypoint_marker_decelerate.frame_locked = true;
 
-  if (g_obstacle_waypoint &gt; -1)
+  if (obstacle_waypoint &gt; -1)
   {
-    stop_line.pose.position = g_prev_path.getWaypointPosition(g_obstacle_waypoint);
-    stop_line.pose.orientation = g_prev_path.getWaypointOrientation(g_obstacle_waypoint);
+    stop_line.pose.position = g_prev_path.getWaypointPosition(obstacle_waypoint);
+    stop_line.pose.orientation = g_prev_path.getWaypointOrientation(obstacle_waypoint);
   }
   stop_line.pose.position.z += 1.0;
   stop_line.scale.x = 0.1;
@@ -233,8 +238,9 @@ void displayDetectionRange(const int crosswalk_id, const int num, const EControl
   stop_line.lifetime = ros::Duration(0.1);
   stop_line.frame_locked = true;
 
+  int crosswalk_id = crosswalk.getDetectionCrossWalkID();
   if (crosswalk_id &gt; 0)
-    scale = g_cross_walk.getDetectionPoints(crosswalk_id).width;
+    scale = crosswalk.getDetectionPoints(crosswalk_id).width;
   crosswalk_marker.scale.x = scale;
   crosswalk_marker.scale.y = scale;
   crosswalk_marker.scale.z = scale;
@@ -262,7 +268,7 @@ void displayDetectionRange(const int crosswalk_id, const int num, const EControl
 
   if (crosswalk_id &gt; 0)
   {
-    for (const auto &amp;p : g_cross_walk.getDetectionPoints(crosswalk_id).points)
+    for (const auto &amp;p : crosswalk.getDetectionPoints(crosswalk_id).points)
       crosswalk_marker.points.push_back(p);
   }
 
@@ -276,51 +282,14 @@ void displayDetectionRange(const int crosswalk_id, const int num, const EControl
   marker_array.markers.clear();
 }
 
-// find the closest cross walk against following waypoints
-int findCrossWalk(int closest_waypoint)
-{
-  if (!g_cross_walk.set_points || closest_waypoint &lt; 0)
-    return -1;
-
-  double find_distance = 2.0 * 2.0;      // meter
-  double ignore_distance = 20.0 * 20.0;  // meter
-  static std::vector&lt;int&gt; bdid = g_cross_walk.getBDID();
-  // Find near cross walk
-  for (int num = closest_waypoint; num &lt; closest_waypoint + g_search_distance; num++)
-  {
-    geometry_msgs::Point waypoint = g_prev_path.getWaypointPosition(num);
-    waypoint.z = 0.0;  // ignore Z axis
-    for (const auto &amp;i : bdid)
-    {
-      // ignore far crosswalk
-      geometry_msgs::Point crosswalk_center = g_cross_walk.getDetectionPoints(i).center;
-      crosswalk_center.z = 0.0;
-      if (calcSquareOfLength(crosswalk_center, waypoint) &gt; ignore_distance)
-        continue;
-
-      for (auto p : g_cross_walk.getDetectionPoints(i).points)
-      {
-        p.z = waypoint.z;
-        if (calcSquareOfLength(p, waypoint) &lt; find_distance)
-        {
-          g_cross_walk.setDetectionCrossWalkID(i);
-          return num;
-        }
-      }
-    }
-  }
-
-  g_cross_walk.setDetectionCrossWalkID(-1);
-  return -1;  // no near crosswalk
-}
-
 // obstacle detection for crosswalk
-EControl crossWalkDetection(const int crosswalk_id)
+EControl crossWalkDetection(const CrossWalk&amp; crosswalk, ObstaclePoints* obstacle_points)
 {
-  double search_radius = g_cross_walk.getDetectionPoints(crosswalk_id).width / 2;
+  int crosswalk_id = crosswalk.getDetectionCrossWalkID();
+  double search_radius = crosswalk.getDetectionPoints(crosswalk_id).width / 2;
 
   // Search each calculated points in the crosswalk
-  for (const auto &amp;p : g_cross_walk.getDetectionPoints(crosswalk_id).points)
+  for (const auto &amp;p : crosswalk.getDetectionPoints(crosswalk_id).points)
   {
     geometry_msgs::Point detection_point = calcRelativeCoordinate(p, g_localizer_pose.pose);
     tf::Vector3 detection_vector = point2vector(detection_point);
@@ -338,19 +307,19 @@ EControl crossWalkDetection(const int crosswalk_id)
         point_temp.x = p.x;
         point_temp.y = p.y;
         point_temp.z = p.z;
-	g_obstacle.setStopPoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
+	obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
       }
       if (stop_count &gt; g_threshold_points)
         return STOP;
     }
 
-    g_obstacle.clearStopPoints();
+    obstacle_points-&gt;clearStopPoints();
   }
 
   return KEEP;  // find no obstacles
 }
 
-int detectStopObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points)
+int detectStopObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const CrossWalk&amp; crosswalk, ObstaclePoints* obstacle_points)
 {
   int stop_obstacle_waypoint = -1;
   // start search from the closest waypoint
@@ -361,10 +330,10 @@ int detectStopObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::Po
       break;
 
     // Detection for cross walk
-    if (i == g_cross_walk.getDetectionWaypoint())
+    if (i == crosswalk.getDetectionWaypoint())
     {
       // found an obstacle in the cross walk
-      if (crossWalkDetection(g_cross_walk.getDetectionCrossWalkID()) == STOP)
+      if (crossWalkDetection(crosswalk, obstacle_points) == STOP)
       {
         stop_obstacle_waypoint = i;
         break;
@@ -390,7 +359,7 @@ int detectStopObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::Po
         point_temp.x = p.x;
         point_temp.y = p.y;
         point_temp.z = p.z;
-	g_obstacle.setStopPoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
+	obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
       }
     }
 
@@ -401,7 +370,7 @@ int detectStopObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::Po
       break;
     }
 
-    g_obstacle.clearStopPoints();
+    obstacle_points-&gt;clearStopPoints();
 
     // check next waypoint...
   }
@@ -409,7 +378,7 @@ int detectStopObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::Po
   return stop_obstacle_waypoint;
 }
 
-int detectDecelerateObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points)
+int detectDecelerateObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, ObstaclePoints* obstacle_points)
 {
   int decelerate_obstacle_waypoint = -1;
   // start search from the closest waypoint
@@ -438,7 +407,7 @@ int detectDecelerateObstacle(const int closest_waypoint, const pcl::PointCloud&lt;p
         point_temp.x = p.x;
         point_temp.y = p.y;
         point_temp.z = p.z;
-	g_obstacle.setDeceleratePoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
+	obstacle_points-&gt;setDeceleratePoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
       }
     }
 
@@ -449,7 +418,7 @@ int detectDecelerateObstacle(const int closest_waypoint, const pcl::PointCloud&lt;p
       break;
     }
 
-    g_obstacle.clearDeceleratePoints();
+    obstacle_points-&gt;clearDeceleratePoints();
 
     // check next waypoint...
   }
@@ -459,33 +428,33 @@ int detectDecelerateObstacle(const int closest_waypoint, const pcl::PointCloud&lt;p
 
 
 // Detect an obstacle by using pointcloud
-EControl pointsDetection(const int closest_waypoint)
+EControl pointsDetection(const int closest_waypoint, const CrossWalk&amp; crosswalk, int* obstacle_waypoint, ObstaclePoints* obstacle_points)
 {
   if (g_points.empty() == true || closest_waypoint &lt; 0)
     return KEEP;
 
-  int stop_obstacle_waypoint = detectStopObstacle(closest_waypoint, g_points);
+  int stop_obstacle_waypoint = detectStopObstacle(closest_waypoint, g_points, crosswalk, obstacle_points);
 
   // skip searching deceleration range
   if (g_deceleration_range &lt; 0.01)
   {
-    g_obstacle_waypoint = stop_obstacle_waypoint;
+    *obstacle_waypoint = stop_obstacle_waypoint;
     return stop_obstacle_waypoint &lt; 0 ? KEEP : STOP;
   }
 
-  int decelerate_obstacle_waypoint = detectDecelerateObstacle(closest_waypoint, g_points);
+  int decelerate_obstacle_waypoint = detectDecelerateObstacle(closest_waypoint, g_points, obstacle_points);
 
   // stop obstacle was not found
   if (stop_obstacle_waypoint &lt; 0)
   {
-    g_obstacle_waypoint  = decelerate_obstacle_waypoint;
+    *obstacle_waypoint  = decelerate_obstacle_waypoint;
     return decelerate_obstacle_waypoint &lt; 0 ? KEEP : DECELERATE;
   }
 
   // stop obstacle was found but decelerate obstacle was not found
   if (decelerate_obstacle_waypoint &lt; 0)
   {
-    g_obstacle_waypoint = stop_obstacle_waypoint;
+    *obstacle_waypoint = stop_obstacle_waypoint;
     return STOP;
   }
 
@@ -494,30 +463,31 @@ EControl pointsDetection(const int closest_waypoint)
   // both were found
   if (stop_obstacle_waypoint - decelerate_obstacle_waypoint &gt; stop_decelerate_threshold)
   {
-    g_obstacle_waypoint = decelerate_obstacle_waypoint;
+    *obstacle_waypoint = decelerate_obstacle_waypoint;
     return DECELERATE;
   }
   else
   {
-    g_obstacle_waypoint = stop_obstacle_waypoint;
+    *obstacle_waypoint = stop_obstacle_waypoint;
     return STOP;
   }
 
 }
 
-EControl obstacleDetection(int closest_waypoint)
+EControl obstacleDetection(int closest_waypoint, int* obstacle_waypoint, const CrossWalk&amp; crosswalk)
 {
   static int false_count = 0;
   static EControl prev_detection = KEEP;
 
-  EControl detection_result = pointsDetection(closest_waypoint);
-  displayDetectionRange(g_cross_walk.getDetectionCrossWalkID(), closest_waypoint, detection_result);
+  ObstaclePoints obstacle_points;
+  EControl detection_result = pointsDetection(closest_waypoint, crosswalk, obstacle_waypoint, &amp;obstacle_points);
+  displayDetectionRange(crosswalk, closest_waypoint, detection_result, *obstacle_waypoint);
 
   if (prev_detection == KEEP)
   {
     if (detection_result != KEEP)
     {  // found obstacle
-      displayObstacle(detection_result);
+      displayObstacle(detection_result, obstacle_points);
       prev_detection = detection_result;
       // SoundPlay();
       false_count = 0;
@@ -533,7 +503,7 @@ EControl obstacleDetection(int closest_waypoint)
   {  // prev_detection = STOP or DECELERATE
     if (detection_result != KEEP)
     {  // found obstacle
-      displayObstacle(detection_result);
+      displayObstacle(detection_result, obstacle_points);
       prev_detection = detection_result;
       false_count = 0;
       return detection_result;
@@ -545,28 +515,26 @@ EControl obstacleDetection(int closest_waypoint)
       // fail-safe
       if (false_count &gt;= LOOP_RATE / 2)
       {
-        g_obstacle_waypoint = -1;
+        *obstacle_waypoint = -1;
         false_count = 0;
         prev_detection = KEEP;
         return detection_result;
       }
       else
       {
-        displayObstacle(OTHERS);
+        displayObstacle(OTHERS, obstacle_points);
         return prev_detection;
       }
     }
   }
 }
 
-void changeWaypoint(EControl detection_result, int closest_waypoint)
+void changeWaypoint(EControl detection_result, int closest_waypoint, int obstacle_waypoint)
 {
-  int obs = g_obstacle_waypoint;
-
   if (detection_result == STOP)
   {  // STOP for obstacle
     // stop_waypoint is about g_stop_distance meter away from obstacles
-    int stop_waypoint = obs - ((int)(g_stop_distance / g_new_path.getInterval()));
+    int stop_waypoint = obstacle_waypoint - ((int)(g_stop_distance / g_new_path.getInterval()));
     // change waypoints to stop by the stop_waypoint
     g_new_path.changeWaypoints(stop_waypoint, closest_waypoint, g_decel, g_prev_path);
     g_new_path.avoidSuddenBraking(g_velocity_change_limit, g_current_vel, g_decel, closest_waypoint);
@@ -607,6 +575,9 @@ int main(int argc, char **argv)
   private_nh.param&lt;bool&gt;("use_crosswalk_detection", use_crosswalk_detection, true);
   private_nh.param&lt;std::string&gt;("points_topic", points_topic, "points_lanes");
 
+  // classes
+  CrossWalk crosswalk;
+
   ros::Subscriber localizer_sub = nh.subscribe("localizer_pose", 1, localizerCallback);
   ros::Subscriber control_pose_sub = nh.subscribe("current_pose", 1, controlCallback);
   ros::Subscriber points_sub = nh.subscribe(points_topic, 1, pointsCallback);
@@ -615,10 +586,10 @@ int main(int argc, char **argv)
   ros::Subscriber config_sub = nh.subscribe("config/velocity_set", 10, configCallback);
 
   // vector map subscribers
-  ros::Subscriber sub_dtlane = nh.subscribe("vector_map_info/cross_walk", 1, &amp;CrossWalk::crossWalkCallback, &amp;g_cross_walk);
-  ros::Subscriber sub_area = nh.subscribe("vector_map_info/area", 1, &amp;CrossWalk::areaCallback, &amp;g_cross_walk);
-  ros::Subscriber sub_line = nh.subscribe("vector_map_info/line", 1, &amp;CrossWalk::lineCallback, &amp;g_cross_walk);
-  ros::Subscriber sub_point = nh.subscribe("vector_map_info/point", 1, &amp;CrossWalk::pointCallback, &amp;g_cross_walk);
+  ros::Subscriber sub_dtlane = nh.subscribe("vector_map_info/cross_walk", 1, &amp;CrossWalk::crossWalkCallback, &amp;crosswalk);
+  ros::Subscriber sub_area = nh.subscribe("vector_map_info/area", 1, &amp;CrossWalk::areaCallback, &amp;crosswalk);
+  ros::Subscriber sub_line = nh.subscribe("vector_map_info/line", 1, &amp;CrossWalk::lineCallback, &amp;crosswalk);
+  ros::Subscriber sub_point = nh.subscribe("vector_map_info/point", 1, &amp;CrossWalk::pointCallback, &amp;crosswalk);
 
   g_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 0);
   g_temporal_waypoints_pub = nh.advertise&lt;waypoint_follower::lane&gt;("temporal_waypoints", 1000, true);
@@ -631,8 +602,8 @@ int main(int argc, char **argv)
   {
     ros::spinOnce();
 
-    if (g_cross_walk.loaded_all &amp;&amp; !g_cross_walk.set_points)
-      g_cross_walk.setCrossWalkPoints();
+    if (crosswalk.loaded_all &amp;&amp; !crosswalk.set_points)
+      crosswalk.setCrossWalkPoints();
 
     if (g_pose_flag == false || g_path_flag == false)
     {
@@ -647,11 +618,12 @@ int main(int argc, char **argv)
     closest_waypoint_pub.publish(closest_waypoint_msg);
 
     if (use_crosswalk_detection)
-      g_cross_walk.setDetectionWaypoint(findCrossWalk(closest_waypoint));
+      crosswalk.setDetectionWaypoint(crosswalk.findClosestCrosswalk(closest_waypoint, g_prev_path.getCurrentWaypoints(), g_search_distance));
 
-    EControl detection_result = obstacleDetection(closest_waypoint);
+    int obstacle_waypoint = -1;
+    EControl detection_result = obstacleDetection(closest_waypoint, &amp;obstacle_waypoint, crosswalk);
 
-    changeWaypoint(detection_result, closest_waypoint);
+    changeWaypoint(detection_result, closest_waypoint, obstacle_waypoint);
 
     g_points.clear();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="85fe29c6b30dc8b5d882af36377f0a3fe84f1a2a" author="Yukihiro Saito">
		<msg>Cleaned potential field node</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\potential_field\potential_field.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\potential_field\potential_field.cpp" added_lines="221" deleted_lines="180">
				<diff>@@ -6,7 +6,6 @@
 #include &lt;iostream&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-//#include &lt;omp.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
@@ -14,159 +13,229 @@
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
 using namespace grid_map;
-ros::Publisher publisher;
 
-double ver_y_p = 0.7;
-double ver_x_p = 0.7;
-double target_ver_y_p = 1.0;
-double target_ver_x_p = 1.0;
+class PotentialField {
+private:
+  ros::NodeHandle nh_;
+  ros::Publisher publisher_;
+  ros::Subscriber waypoint_subscriber_;
+  ros::Subscriber vscan_subscriber_;
+  ros::Subscriber obj_subscriber_;
+  bool use_target_waypoint_;
+  bool use_obstacle_box_;
+  bool use_vscan_points_;
+  double map_x_size_;
+  double map_y_size_;
+  double map_resolution_;
+  double tf_x_;
+  double tf_z_;
+  GridMap map_;
+  class ObstacleFieldParameter {
+  public:
+    ObstacleFieldParameter() : ver_x_p(0.9), ver_y_p(0.9) {}
+    double ver_x_p;
+    double ver_y_p;
+  };
+  class TargetWaypointFieldParamater {
+  public:
+    TargetWaypointFieldParamater() : ver_x_p(1.0), ver_y_p(1.0) {}
+    double ver_x_p;
+    double ver_y_p;
+  };
+  class VscanPointsFieldParamater {
+  public:
+    VscanPointsFieldParamater() : around_x(0.5), around_y(0.5) {}
+    double around_x;
+    double around_y;
+  };
 
-double tf_x = 1.2;
-double tf_z = 2.0;
+  void obj_callback(jsk_recognition_msgs::BoundingBoxArray::ConstPtr obj_msg);
+  void target_waypoint_callback(
+      visualization_msgs::Marker::ConstPtr target_point_msgs);
+  void vscan_points_callback(sensor_msgs::PointCloud2::ConstPtr vscan_msg);
+  void publish_potential_field();
 
-static GridMap map({"obstacle_potential_field", "potential_field",
-                    "waypoint_field", "vscan_field"});
+public:
+  PotentialField();
+  void run();
+  void init();
+};
 
-void obj_callback(jsk_recognition_msgs::BoundingBoxArray::ConstPtr
-                      obj_msg) { // Create grid map.
+PotentialField::PotentialField()
+    : tf_x_(1.2), tf_z_(2.0),
+      map_({"potential_field", "obstacle_field", "target_waypoint_field",
+            "vscan_points_field"}) {
+  ros::NodeHandle private_nh("~");
+  if (!private_nh.getParam("use_obstacle_box", use_obstacle_box_)) {
+    ROS_INFO("use obstacle_box");
+    use_obstacle_box_ = true;
+  }
+  if (!private_nh.getParam("use_vscan_points", use_vscan_points_)) {
+    ROS_INFO("use vscan points");
+    use_vscan_points_ = true;
+  }
+  if (!private_nh.getParam("use_target_waypoint", use_target_waypoint_)) {
+    ROS_INFO("don't use target_waypoint");
+    use_target_waypoint_ = false;
+  }
+  if (!private_nh.getParam("map_resolution", map_resolution_)) {
+    map_resolution_ = 0.25;
+    ROS_INFO("map resolution %f", map_resolution_);
+  }
+  if (!private_nh.getParam("map_x_size", map_x_size_)) {
+    map_x_size_ = 40.0;
+    ROS_INFO("map x size %f", map_x_size_);
+  }
+  if (!private_nh.getParam("map_y_size", map_y_size_)) {
+    map_y_size_ = 25.0;
+    ROS_INFO("map y size %f", map_y_size_);
+  }
 
-  // Add data to grid map.
-  ros::Time time = ros::Time::now();
-#if 0
-#ifdef _OPENMP
-  std::vector&lt;float&gt; v_map;
-  {
-    GridMapIterator it(map);
-    int j;
-    std::cout &lt;&lt; "openMP" &lt;&lt; std::endl;
-    v_map.resize(
-        (int)(40.0 * 20.0 / (map.getResolution() * map.getResolution())));
-    double pos_x;
-    double pos_y;
-    double len_x;
-    double len_y;
-    Position position;
-#pragma omp parallel for private(map, position, pos_x, pos_y, len_x, len_y)
-    for (j = 0;
-         j &lt; (int)(40.0 * 20.0 / (map.getResolution() * map.getResolution()));
-         ++j) {
-      if (j != 0)
-        ++it;
-      map.getPosition(*it, position);
-      v_map.at(j) = -0.1;
-      for (int i(0); i &lt; (int)obj_msg-&gt;boxes.size(); ++i) {
-        pos_x = obj_msg-&gt;boxes.at(i).pose.position.x + 2.0;
-        pos_y = obj_msg-&gt;boxes.at(i).pose.position.y;
-        len_x = obj_msg-&gt;boxes.at(i).dimensions.x / 2.0;
-        len_y = obj_msg-&gt;boxes.at(i).dimensions.y / 2.0;
+  publisher_ =
+      nh_.advertise&lt;grid_map_msgs::GridMap&gt;("/potential_field", 1, true);
 
-        if (pos_x - len_x &lt; position.x() &amp;&amp; position.x() &lt; pos_x + len_x) {
-          if (pos_y - len_y &lt; position.y() &amp;&amp; position.y() &lt; pos_y + len_y) {
-            v_map.at(j) += std::exp(0.0);
-          }
-        }
-      }
-    }
-  }
-  GridMapIterator it(map);
-  int j;
+  if (use_obstacle_box_)
+    obj_subscriber_ = nh_.subscribe("/bounding_boxes", 1,
+                                    &amp;PotentialField::obj_callback, this);
+  if (use_vscan_points_)
+    vscan_subscriber_ = nh_.subscribe(
+        "/vscan_points", 1, &amp;PotentialField::vscan_points_callback, this);
+  if (use_target_waypoint_)
+    waypoint_subscriber_ =
+        nh_.subscribe("/next_target_mark", 1,
+                      &amp;PotentialField::target_waypoint_callback, this);
+}
 
-  for (j = 0;
-       j &lt; (int)(40.0 * 20.0 / (map.getResolution() * map.getResolution()));
-       ++j) {
-    if (j != 0)
-      ++it;
-    map.at("obstacle_potential_field", *it) = v_map.at(j);
+void PotentialField::init() {
+  ROS_INFO("Created map");
+  map_.setFrameId("/base_link");
+  map_.setGeometry(Length(map_x_size_, map_y_size_), map_resolution_);
+  for (GridMapIterator it(map_); !it.isPastEnd(); ++it) {
+    Position position;
+    map_.getPosition(*it, position);
+    map_.at("obstacle_field", *it) = 0.0;
+    map_.at("target_waypoint_field", *it) = 0.0;
+    map_.at("vscan_points_field", *it) = 0.0;
   }
-#endif
-#else
-  for (GridMapIterator it(map); !it.isPastEnd(); ++it) {
+  ROS_INFO("Created map with size %f x %f m (%i x %i cells).",
+           map_.getLength().x(), map_.getLength().y(), map_.getSize()(0),
+           map_.getSize()(1));
+}
+void PotentialField::run() { ros::spin(); }
+
+void PotentialField::publish_potential_field() {
+  grid_map_msgs::GridMap message;
+
+  map_["potential_field"] =
+      map_["obstacle_field"].cwiseMax(map_["vscan_points_field"]) +
+      map_["target_waypoint_field"];
+  GridMapRosConverter::toMessage(map_, message);
+  publisher_.publish(message);
+  ROS_INFO_THROTTLE(1.0, "Grid map (timestamp %f) published.",
+                    message.info.header.stamp.toSec());
+}
+void PotentialField::obj_callback(
+    jsk_recognition_msgs::BoundingBoxArray::ConstPtr
+        obj_msg) { // Create grid map.
+  static ObstacleFieldParameter param;
+  double ver_x_p(param.ver_x_p);
+  double ver_y_p(param.ver_y_p);
+
+  // Add data to grid map.
+  ros::Time time = ros::Time::now();
+
+  for (GridMapIterator it(map_); !it.isPastEnd(); ++it) {
 
     Position position;
-    map.getPosition(*it, position);
-    map.at("obstacle_potential_field", *it) = 0.0;
+    map_.getPosition(*it, position);
+    map_.at("obstacle_field", *it) = 0.0;
     for (int i(0); i &lt; (int)obj_msg-&gt;boxes.size(); ++i) {
-      double pos_x = obj_msg-&gt;boxes.at(i).pose.position.x + tf_z;
+      double pos_x = obj_msg-&gt;boxes.at(i).pose.position.x + tf_x_;
       double pos_y = obj_msg-&gt;boxes.at(i).pose.position.y;
       double len_x = obj_msg-&gt;boxes.at(i).dimensions.x / 2.0;
       double len_y = obj_msg-&gt;boxes.at(i).dimensions.y / 2.0;
 
+      double r, p, y;
+      tf::Quaternion quat(obj_msg-&gt;boxes.at(i).pose.orientation.x,
+                          obj_msg-&gt;boxes.at(i).pose.orientation.y,
+                          obj_msg-&gt;boxes.at(i).pose.orientation.z,
+                          obj_msg-&gt;boxes.at(i).pose.orientation.w);
+      tf::Matrix3x3(quat).getRPY(r, p, y);
+
+      double rotated_pos_x = std::cos(-1.0 * y) * (position.x() - pos_x) -
+                             std::sin(-1.0 * y) * (position.y() - pos_y) +
+                             pos_x;
+      double rotated_pos_y = std::sin(-1.0 * y) * (position.x() - pos_x) +
+                             std::cos(-1.0 * y) * (position.y() - pos_y) +
+                             pos_y;
+
       if (-0.5 &lt; pos_x &amp;&amp; pos_x &lt; 4.0) {
         if (-1.0 &lt; pos_y &amp;&amp; pos_y &lt; 1.0)
           continue;
       }
-      if (pos_x - len_x &lt; position.x() &amp;&amp; position.x() &lt; pos_x + len_x) {
-        if (pos_y - len_y &lt; position.y() &amp;&amp; position.y() &lt; pos_y + len_y) {
-          map.at("obstacle_potential_field", *it) += std::exp(0.0);
-        } else if (position.y() &lt; pos_y - len_y) {
-          map.at("obstacle_potential_field", *it) += std::exp(
-              (-1.0 * (std::pow((position.y() - (pos_y - len_y)), 2.0) /
+      if (pos_x - len_x &lt; rotated_pos_x &amp;&amp; rotated_pos_x &lt; pos_x + len_x) {
+        if (pos_y - len_y &lt; rotated_pos_y &amp;&amp; rotated_pos_y &lt; pos_y + len_y) {
+          map_.at("obstacle_field", *it) += std::exp(0.0);
+        } else if (rotated_pos_y &lt; pos_y - len_y) {
+          map_.at("obstacle_field", *it) += std::exp(
+              (-1.0 * (std::pow((rotated_pos_y - (pos_y - len_y)), 2.0) /
                        std::pow(2.0 * ver_y_p, 2.0))));
-        } else if (pos_y + len_y &lt; position.y()) {
-          map.at("obstacle_potential_field", *it) += std::exp(
-              (-1.0 * (std::pow((position.y() - (pos_y + len_y)), 2.0) /
+        } else if (pos_y + len_y &lt; rotated_pos_y) {
+          map_.at("obstacle_field", *it) += std::exp(
+              (-1.0 * (std::pow((rotated_pos_y - (pos_y + len_y)), 2.0) /
                        std::pow(2.0 * ver_y_p, 2.0))));
         }
-      } else if (pos_y - len_y &lt; position.y() &amp;&amp; position.y() &lt; pos_y + len_y) {
-        if (pos_x - len_x &lt; position.x() &amp;&amp; position.x() &lt; pos_x + len_x) {
-          map.at("obstacle_potential_field", *it) += std::exp(0.0);
-        } else if (position.x() &lt; pos_x - len_x) {
-          map.at("obstacle_potential_field", *it) += std::exp(
-              (-1.0 * (std::pow((position.x() - (pos_x - len_x)), 2.0) /
-                       std::pow(2.0 * ver_x_p, 2.0))));
-        } else if (pos_x + len_x &lt; position.x()) {
-          map.at("obstacle_potential_field", *it) += std::exp(
-              (-1.0 * (std::pow((position.x() - (pos_x + len_x)), 2.0) /
-                       std::pow(2.0 * ver_x_p, 2.0))));
-        }
-      } else if (position.x() &lt; pos_x - len_x) {
-        if (position.y() &lt; pos_y - len_y) {
-          map.at("obstacle_potential_field", *it) += std::exp(
-              (-1.0 * (std::pow((position.y() - (pos_y - len_y)), 2.0) /
+      } else if (rotated_pos_x &lt; pos_x - len_x) {
+        if (rotated_pos_y &lt; pos_y - len_y) {
+          map_.at("obstacle_field", *it) += std::exp(
+              (-1.0 * (std::pow((rotated_pos_y - (pos_y - len_y)), 2.0) /
                        std::pow(2.0 * ver_y_p, 2.0))) +
-              (-1.0 * (std::pow((position.x() - (pos_x - len_x)), 2.0) /
+              (-1.0 * (std::pow((rotated_pos_x - (pos_x - len_x)), 2.0) /
                        std::pow(2.0 * ver_x_p, 2.0))));
-        } else if (pos_y + len_y &lt; position.y()) {
-          map.at("obstacle_potential_field", *it) += std::exp(
-              (-1.0 * (std::pow((position.y() - (pos_y + len_y)), 2.0) /
+        } else if (pos_y + len_y &lt; rotated_pos_y) {
+          map_.at("obstacle_field", *it) += std::exp(
+              (-1.0 * (std::pow((rotated_pos_y - (pos_y + len_y)), 2.0) /
                        std::pow(2.0 * ver_y_p, 2.0))) +
-              (-1.0 * (std::pow((position.x() - (pos_x - len_x)), 2.0) /
+              (-1.0 * (std::pow((rotated_pos_x - (pos_x - len_x)), 2.0) /
+                       std::pow(2.0 * ver_x_p, 2.0))));
+        } else if (pos_y - len_y &lt; rotated_pos_y &amp;&amp;
+                   rotated_pos_y &lt; pos_y + len_y) {
+          map_.at("obstacle_field", *it) += std::exp(
+              (-1.0 * (std::pow((rotated_pos_x - (pos_x - len_x)), 2.0) /
                        std::pow(2.0 * ver_x_p, 2.0))));
         }
-      } else if (pos_x + len_x &lt; position.x()) {
-        if (position.y() &lt; pos_y - len_y) {
-          map.at("obstacle_potential_field", *it) += std::exp(
-              (-1.0 * (std::pow((position.y() - (pos_y - len_y)), 2.0) /
+      } else if (pos_x + len_x &lt; rotated_pos_x) {
+        if (rotated_pos_y &lt; pos_y - len_y) {
+          map_.at("obstacle_field", *it) += std::exp(
+              (-1.0 * (std::pow((rotated_pos_y - (pos_y - len_y)), 2.0) /
                        std::pow(2.0 * ver_y_p, 2.0))) +
-              (-1.0 * (std::pow((position.x() - (pos_x + len_x)), 2.0) /
+              (-1.0 * (std::pow((rotated_pos_x - (pos_x + len_x)), 2.0) /
                        std::pow(2.0 * ver_x_p, 2.0))));
-        } else if (pos_y + len_y / 2.0 &lt; position.y()) {
-          map.at("obstacle_potential_field", *it) += std::exp(
-              (-1.0 * (std::pow((position.y() - (pos_y + len_y)), 2.0) /
+        } else if (pos_y + len_y / 2.0 &lt; rotated_pos_y) {
+          map_.at("obstacle_field", *it) += std::exp(
+              (-1.0 * (std::pow((rotated_pos_y - (pos_y + len_y)), 2.0) /
                        std::pow(2.0 * ver_y_p, 2.0))) +
-              (-1.0 * (std::pow((position.x() - (pos_x + len_x)), 2.0) /
+              (-1.0 * (std::pow((rotated_pos_x - (pos_x + len_x)), 2.0) /
+                       std::pow(2.0 * ver_x_p, 2.0))));
+        } else if (pos_y - len_y &lt; rotated_pos_y &amp;&amp;
+                   rotated_pos_y &lt; pos_y + len_y) {
+          map_.at("obstacle_field", *it) += std::exp(
+              (-1.0 * (std::pow((rotated_pos_x - (pos_x + len_x)), 2.0) /
                        std::pow(2.0 * ver_x_p, 2.0))));
         }
       }
     }
   }
-#endif
   // Publish grid map.
-  map.setTimestamp(time.toNSec());
-  grid_map_msgs::GridMap message;
-  // map["potential_field"] = map["obstacle_potential_field"] +
-  //                          map["waypoint_field"] + map["vscan_field"];
-  map["potential_field"] =
-      map["obstacle_potential_field"].cwiseMax(map["vscan_field"]) +
-      map["waypoint_field"];
-
-  GridMapRosConverter::toMessage(map, message);
-  publisher.publish(message);
-  ROS_INFO_THROTTLE(1.0, "Grid map (timestamp %f) published.",
-                    message.info.header.stamp.toSec());
+  map_.setTimestamp(time.toNSec());
+  publish_potential_field();
 }
-void target_poiny_callback(
+
+void PotentialField::target_waypoint_callback(
     visualization_msgs::Marker::ConstPtr target_point_msgs) {
+  static TargetWaypointFieldParamater param;
+  double ver_x_p(param.ver_x_p);
+  double ver_y_p(param.ver_y_p);
   ros::Time time = ros::Time::now();
   geometry_msgs::PointStamped in, out;
   in.header = target_point_msgs-&gt;header;
@@ -181,91 +250,63 @@ void target_poiny_callback(
     ROS_ERROR("%s", ex.what());
   }
 
-  for (GridMapIterator it(map); !it.isPastEnd(); ++it) {
+  for (GridMapIterator it(map_); !it.isPastEnd(); ++it) {
     Position position;
-    map.getPosition(*it, position);
-    map.at("waypoint_field", *it) = 0.0;
-    map.at("waypoint_field", *it) -=
+    map_.getPosition(*it, position);
+    map_.at("target_waypoint_field", *it) = 0.0;
+    map_.at("target_waypoint_field", *it) -=
         0.5 * std::exp((-1.0 * (std::pow((position.y() - (out.point.y)), 2.0) /
-                                std::pow(2.0 * target_ver_y_p, 2.0))) +
+                                std::pow(2.0 * ver_y_p, 2.0))) +
                        (-1.0 * (std::pow((position.x() - (out.point.x)), 2.0) /
-                                std::pow(2.0 * target_ver_x_p, 2.0))));
+                                std::pow(2.0 * ver_x_p, 2.0))));
   }
-  map.setTimestamp(time.toNSec());
-  grid_map_msgs::GridMap message;
-  // map["potential_field"] = map["obstacle_potential_field"] +
-  //                          map["waypoint_field"] + map["vscan_field"];
-  map["potential_field"] =
-      map["obstacle_potential_field"].cwiseMax(map["vscan_field"]) +
-      map["waypoint_field"];
-
-  GridMapRosConverter::toMessage(map, message);
-  publisher.publish(message);
-  ROS_INFO_THROTTLE(1.0, "Grid map (timestamp %f) published.",
-                    message.info.header.stamp.toSec());
+  map_.setTimestamp(time.toNSec());
 }
-void vscan_points_callback(sensor_msgs::PointCloud2::ConstPtr vscan_msg) {
+
+void PotentialField::vscan_points_callback(
+    sensor_msgs::PointCloud2::ConstPtr vscan_msg) {
+  static VscanPointsFieldParamater param;
+  double around_x(param.around_x);
+  double around_y(param.around_y);
+
   ros::Time time = ros::Time::now();
   pcl::PointCloud&lt;pcl::PointXYZ&gt; pcl_vscan;
   pcl::fromROSMsg(*vscan_msg, pcl_vscan);
   pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr pcl_vscan_ptr(
       new pcl::PointCloud&lt;pcl::PointXYZ&gt;(pcl_vscan));
-  // for (int i(0); i &lt; (int)pcl_vscan.size(); ++i)
-  //   std::cout &lt;&lt; pcl_vscan.at(i).x &lt;&lt; "," &lt;&lt; pcl_vscan.at(i).y &lt;&lt; std::endl;
 
-  for (GridMapIterator it(map); !it.isPastEnd(); ++it) {
+  double length_x = map_.getLength().x() / 2.0;
+  double length_y = map_.getLength().y() / 2.0;
+
+  for (GridMapIterator it(map_); !it.isPastEnd(); ++it) {
     Position position;
-    map.getPosition(*it, position);
-    map.at("vscan_field", *it) = 0.0;
+    map_.getPosition(*it, position);
+    map_.at("vscan_points_field", *it) = 0.0;
     for (int i(0); i &lt; (int)pcl_vscan.size(); ++i) {
-      if (3.5 &lt; pcl_vscan.at(i).z + tf_x || pcl_vscan.at(i).z + tf_x &lt; 0.2)
+      if (3.0 &lt; pcl_vscan.at(i).z + tf_z_ || pcl_vscan.at(i).z + tf_z_ &lt; 0.3)
         continue;
-      if (pcl_vscan.at(i).x + tf_z - map.getResolution() &lt; position.x() &amp;&amp;
-          position.x() &lt; pcl_vscan.at(i).x + tf_z + map.getResolution()) {
-        if (pcl_vscan.at(i).y - map.getResolution() &lt; position.y() &amp;&amp;
-            position.y() &lt; pcl_vscan.at(i).y + map.getResolution()) {
-          map.at("vscan_field", *it) = std::exp(0.0);
+      if (length_x &lt; pcl_vscan.at(i).x &amp;&amp; pcl_vscan.at(i).x &lt; -1.0 * length_x)
+        continue;
+      if (length_y &lt; pcl_vscan.at(i).y &amp;&amp; pcl_vscan.at(i).y &lt; -1.0 * length_y)
+        continue;
+      if (pcl_vscan.at(i).x + tf_x_ - around_x &lt; position.x() &amp;&amp;
+          position.x() &lt; pcl_vscan.at(i).x + tf_x_ + around_x) {
+        if (pcl_vscan.at(i).y - around_y &lt; position.y() &amp;&amp;
+            position.y() &lt; pcl_vscan.at(i).y + around_y) {
+          map_.at("vscan_points_field", *it) = 1.0; // std::exp(0.0) ;
         }
       }
     }
   }
-  map.setTimestamp(time.toNSec());
-  grid_map_msgs::GridMap message;
-  // map["potential_field"] = map["obstacle_potential_field"] +
-  //                          map["waypoint_field"] + map["vscan_field"];
-  map["potential_field"] =
-      map["obstacle_potential_field"].cwiseMax(map["vscan_field"]) +
-      map["waypoint_field"];
-  GridMapRosConverter::toMessage(map, message);
-  publisher.publish(message);
-  ROS_INFO_THROTTLE(1.0, "Grid map (timestamp %f) published.",
-                    message.info.header.stamp.toSec());
+  map_.setTimestamp(time.toNSec());
+  publish_potential_field();
 }
+
 int main(int argc, char **argv) {
-  // Initialize node and publisher.
   ros::init(argc, argv, "potential_field");
-  ros::NodeHandle nh;
 
-  publisher = nh.advertise&lt;grid_map_msgs::GridMap&gt;("/potential_field", 1, true);
-  ros::Subscriber obj_subscriber =
-      nh.subscribe("/bounding_boxes", 1, obj_callback);
-  ros::Subscriber waypoint_subscriber =
-      nh.subscribe("/next_target_mark", 1, target_poiny_callback);
-  ros::Subscriber vscan_subscriber =
-      nh.subscribe("/vscan_points", 1, vscan_points_callback);
-  ROS_INFO("Created map");
-  map.setFrameId("/base_link");
-  map.setGeometry(Length(40.0, 25.0), 0.5);
-  for (GridMapIterator it(map); !it.isPastEnd(); ++it) {
-    Position position;
-    map.getPosition(*it, position);
-    map.at("obstacle_potential_field", *it) = 0.0;
-    map.at("waypoint_field", *it) = 0.0;
-    map.at("vscan_field", *it) = 0.0;
-  }
-  ROS_INFO("Created map with size %f x %f m (%i x %i cells).",
-           map.getLength().x(), map.getLength().y(), map.getSize()(0),
-           map.getSize()(1));
-  ros::spin();
+  PotentialField potential_field;
+  potential_field.init();
+  potential_field.run();
   return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c4be752a666dae02e5c49091464eab981146ff8e" author="h_ohta">
		<msg>Bug fix for linear interpolation flag and command velocity</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -240,7 +240,7 @@ bool PurePursuit::canGetCurvature(double *output_kappa)
     return false;
   }
 
-  // if g_linear_interpolate_mode is false or next waypoint is first or last
+  // if is_linear_interpolation_ is false or next waypoint is first or last
   if (!is_linear_interpolation_ || next_waypoint_number_ == 0 ||
       next_waypoint_number_ == (static_cast&lt;int&gt;(current_waypoints_.size() - 1)))
   {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -124,7 +124,7 @@ void PurePursuitNode::publishTwistStamped(const bool &amp;can_get_curvature, const d
 {
   geometry_msgs::TwistStamped ts;
   ts.header.stamp = ros::Time::now();
-  ts.twist.linear.x = can_get_curvature ? command_linear_velocity_ : 0;
+  ts.twist.linear.x = can_get_curvature ? computeCommandVelocity() : 0;
   ts.twist.angular.z = can_get_curvature ? kappa * ts.twist.linear.x : 0;
   pub1_.publish(ts);
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="dbea98a05dc71bc39334e3a5a42af1afa4375106" author="TomohitoAndo">
		<msg>Implement callbacks in class</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="79" deleted_lines="150">
				<diff>@@ -30,107 +30,24 @@
 
 #include &lt;ros/ros.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
-#include &lt;runtime_manager/ConfigVelocitySet.h&gt;
 #include &lt;iostream&gt;
 
 #include "libvelocity_set.h"
 #include "velocity_set_path.h"
+#include "velocity_set_info.h"
 
 namespace
 {
 constexpr int LOOP_RATE = 10;
-
-geometry_msgs::PoseStamped g_localizer_pose;  // pose of sensor
-geometry_msgs::PoseStamped g_control_pose;  // pose of base_link
-pcl::PointCloud&lt;pcl::PointXYZ&gt; g_points;
-
-bool g_pose_flag = false;
-bool g_path_flag = false;
 constexpr double g_deceleration_search_distance = 30;
 constexpr double g_search_distance = 60;
-double g_current_vel = 0.0;  // (m/s)
-
-// Config Parameter
-double g_stop_range = 0;                   // if obstacle is in this range, stop
-double g_deceleration_range = 1.8;              // if obstacle is in this range, decelerate
-int g_threshold_points = 15;
-double g_detection_height_top = 2.0;
-double g_detection_height_bottom = -2.0;
-double g_stop_distance = 8.0;            // (meter) stopping distance from obstacles
-double g_decel = 1.5;                      // (m/s^2) deceleration
-double g_velocity_change_limit = 2.778;    // (m/s)
-double g_temporal_waypoints_size = 100.0;  // (meter)
 
 // Publisher
 ros::Publisher g_range_pub;
 ros::Publisher g_temporal_waypoints_pub;
 ros::Publisher g_obstacle_pub;
 
-WayPoints g_prev_path;
-VelocitySetPath g_new_path;
-
-void configCallback(const runtime_manager::ConfigVelocitySetConstPtr &amp;config)
-{
-  g_stop_distance = config-&gt;others_distance;
-  g_stop_range = config-&gt;detection_range;
-  g_threshold_points = config-&gt;threshold_points;
-  g_detection_height_top = config-&gt;detection_height_top;
-  g_detection_height_bottom = config-&gt;detection_height_bottom;
-  g_decel = config-&gt;deceleration;
-  g_velocity_change_limit = kmph2mps(config-&gt;velocity_change_limit);
-  g_deceleration_range = config-&gt;deceleration_range;
-  g_temporal_waypoints_size = config-&gt;temporal_waypoints_size;
-}
-
-void currentVelCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg)
-{
-  g_current_vel = msg-&gt;twist.linear.x;
-}
-
-void baseWaypointCallback(const waypoint_follower::laneConstPtr &amp;msg)
-{
-  g_prev_path.setPath(*msg);
-  g_new_path.setPath(*msg);
-  if (g_path_flag == false)
-  {
-    g_path_flag = true;
-  }
-}
-
-void pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg)
-{
-  pcl::PointCloud&lt;pcl::PointXYZ&gt; sub_points;
-  pcl::fromROSMsg(*msg, sub_points);
-
-  g_points.clear();
-  for (const auto &amp;v : sub_points)
-  {
-    if (v.x == 0 &amp;&amp; v.y == 0)
-      continue;
-
-    if (v.z &gt; g_detection_height_top || v.z &lt; g_detection_height_bottom)
-      continue;
-
-    g_points.push_back(v);
-  }
-}
-
-void controlCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
-{
-  if (!g_pose_flag)
-    g_pose_flag = true;
-
-  g_control_pose.header = msg-&gt;header;
-  g_control_pose.pose = msg-&gt;pose;
-}
-
-void localizerCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
-{
-  g_localizer_pose.header = msg-&gt;header;
-  g_localizer_pose.pose = msg-&gt;pose;
-}
 
 // Display a detected obstacle
 void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points)
@@ -153,7 +70,8 @@ void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points
   {
     marker.pose.position = prev_obstacle_point;
   }
-  marker.pose.orientation = g_localizer_pose.pose.orientation;
+  geometry_msgs::Quaternion quat;
+  marker.pose.orientation = quat;//g_localizer_pose.pose.orientation;
 
   marker.scale.x = 1.0;
   marker.scale.y = 1.0;
@@ -177,7 +95,7 @@ void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points
   g_obstacle_pub.publish(marker);
 }
 
-void displayDetectionRange(const CrossWalk&amp; crosswalk, const int num, const EControl &amp;kind, const int obstacle_waypoint)
+void displayDetectionRange(const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, const int closest_waypoint, const EControl &amp;kind, const int obstacle_waypoint, const double stop_range, const double deceleration_range)
 {
   // set up for marker array
   visualization_msgs::MarkerArray marker_array;
@@ -202,7 +120,7 @@ void displayDetectionRange(const CrossWalk&amp; crosswalk, const int num, const ECon
   stop_line.ns = "Stop Line";
 
   // set scale and color
-  double scale = 2 * g_stop_range;
+  double scale = 2 * stop_range;
   waypoint_marker_stop.scale.x = scale;
   waypoint_marker_stop.scale.y = scale;
   waypoint_marker_stop.scale.z = scale;
@@ -212,7 +130,7 @@ void displayDetectionRange(const CrossWalk&amp; crosswalk, const int num, const ECon
   waypoint_marker_stop.color.b = 0.0;
   waypoint_marker_stop.frame_locked = true;
 
-  scale = 2 * (g_stop_range + g_deceleration_range);
+  scale = 2 * (stop_range + deceleration_range);
   waypoint_marker_decelerate.scale.x = scale;
   waypoint_marker_decelerate.scale.y = scale;
   waypoint_marker_decelerate.scale.z = scale;
@@ -224,8 +142,8 @@ void displayDetectionRange(const CrossWalk&amp; crosswalk, const int num, const ECon
 
   if (obstacle_waypoint &gt; -1)
   {
-    stop_line.pose.position = g_prev_path.getWaypointPosition(obstacle_waypoint);
-    stop_line.pose.orientation = g_prev_path.getWaypointOrientation(obstacle_waypoint);
+    stop_line.pose.position = lane.waypoints[obstacle_waypoint].pose.pose.position;
+    stop_line.pose.orientation = lane.waypoints[obstacle_waypoint].pose.pose.orientation;
   }
   stop_line.pose.position.z += 1.0;
   stop_line.scale.x = 0.1;
@@ -253,11 +171,11 @@ void displayDetectionRange(const CrossWalk&amp; crosswalk, const int num, const ECon
   // set marker points coordinate
   for (int i = 0; i &lt; g_search_distance; i++)
   {
-    if (num &lt; 0 || i + num &gt; g_prev_path.getSize() - 1)
+    if (closest_waypoint &lt; 0 || i + closest_waypoint &gt; static_cast&lt;int&gt;(lane.waypoints.size()) - 1)
       break;
 
     geometry_msgs::Point point;
-    point = g_prev_path.getWaypointPosition(num + i);
+    point = lane.waypoints[closest_waypoint + i].pose.pose.position;
 
     waypoint_marker_stop.points.push_back(point);
 
@@ -283,7 +201,7 @@ void displayDetectionRange(const CrossWalk&amp; crosswalk, const int num, const ECon
 }
 
 // obstacle detection for crosswalk
-EControl crossWalkDetection(const CrossWalk&amp; crosswalk, ObstaclePoints* obstacle_points)
+EControl crossWalkDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const CrossWalk&amp; crosswalk, const geometry_msgs::PoseStamped&amp; localizer_pose, const int points_threshold, ObstaclePoints* obstacle_points)
 {
   int crosswalk_id = crosswalk.getDetectionCrossWalkID();
   double search_radius = crosswalk.getDetectionPoints(crosswalk_id).width / 2;
@@ -291,12 +209,12 @@ EControl crossWalkDetection(const CrossWalk&amp; crosswalk, ObstaclePoints* obstacle
   // Search each calculated points in the crosswalk
   for (const auto &amp;p : crosswalk.getDetectionPoints(crosswalk_id).points)
   {
-    geometry_msgs::Point detection_point = calcRelativeCoordinate(p, g_localizer_pose.pose);
+    geometry_msgs::Point detection_point = calcRelativeCoordinate(p, localizer_pose.pose);
     tf::Vector3 detection_vector = point2vector(detection_point);
     detection_vector.setZ(0.0);
 
     int stop_count = 0;  // the number of points in the detection area
-    for (const auto &amp;p : g_points)
+    for (const auto &amp;p : points)
     {
       tf::Vector3 point_vector(p.x, p.y, 0.0);
       double distance = tf::tfDistance(point_vector, detection_vector);
@@ -307,9 +225,9 @@ EControl crossWalkDetection(const CrossWalk&amp; crosswalk, ObstaclePoints* obstacle
         point_temp.x = p.x;
         point_temp.y = p.y;
         point_temp.z = p.z;
-	obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
+	obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
       }
-      if (stop_count &gt; g_threshold_points)
+      if (stop_count &gt; points_threshold)
         return STOP;
     }
 
@@ -319,21 +237,21 @@ EControl crossWalkDetection(const CrossWalk&amp; crosswalk, ObstaclePoints* obstacle
   return KEEP;  // find no obstacles
 }
 
-int detectStopObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const CrossWalk&amp; crosswalk, ObstaclePoints* obstacle_points)
+int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, double stop_range, double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose, ObstaclePoints* obstacle_points)
 {
   int stop_obstacle_waypoint = -1;
   // start search from the closest waypoint
   for (int i = closest_waypoint; i &lt; closest_waypoint + g_search_distance; i++)
   {
     // reach the end of waypoints
-    if (i &gt;= g_prev_path.getSize())
+    if (i &gt;= static_cast&lt;int&gt;(lane.waypoints.size()))
       break;
 
     // Detection for cross walk
     if (i == crosswalk.getDetectionWaypoint())
     {
       // found an obstacle in the cross walk
-      if (crossWalkDetection(crosswalk, obstacle_points) == STOP)
+      if (crossWalkDetection(points, crosswalk, localizer_pose, points_threshold, obstacle_points) == STOP)
       {
         stop_obstacle_waypoint = i;
         break;
@@ -341,7 +259,7 @@ int detectStopObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::Po
     }
 
     // waypoint seen by localizer
-    geometry_msgs::Point waypoint = calcRelativeCoordinate(g_prev_path.getWaypointPosition(i), g_localizer_pose.pose);
+    geometry_msgs::Point waypoint = calcRelativeCoordinate(lane.waypoints[i].pose.pose.position, localizer_pose.pose);
     tf::Vector3 tf_waypoint = point2vector(waypoint);
     tf_waypoint.setZ(0);
 
@@ -352,19 +270,19 @@ int detectStopObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::Po
 
       // 2D distance between waypoint and points (obstacle)
       double dt = tf::tfDistance(point_vector, tf_waypoint);
-      if (dt &lt; g_stop_range)
+      if (dt &lt; stop_range)
       {
         stop_point_count++;
         geometry_msgs::Point point_temp;
         point_temp.x = p.x;
         point_temp.y = p.y;
         point_temp.z = p.z;
-	obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
+	obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
       }
     }
 
     // there is an obstacle if the number of points exceeded the threshold
-    if (stop_point_count &gt; g_threshold_points)
+    if (stop_point_count &gt; points_threshold)
     {
       stop_obstacle_waypoint = i;
       break;
@@ -378,18 +296,18 @@ int detectStopObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::Po
   return stop_obstacle_waypoint;
 }
 
-int detectDecelerateObstacle(const int closest_waypoint, const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, ObstaclePoints* obstacle_points)
+int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const waypoint_follower::lane&amp; lane, const double stop_range, const double deceleration_range, const double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose, ObstaclePoints* obstacle_points)
 {
   int decelerate_obstacle_waypoint = -1;
   // start search from the closest waypoint
   for (int i = closest_waypoint; i &lt; closest_waypoint + g_deceleration_search_distance; i++)
   {
     // reach the end of waypoints
-    if (i &gt;= g_prev_path.getSize())
+    if (i &gt;= static_cast&lt;int&gt;(lane.waypoints.size()))
       break;
 
     // waypoint seen by localizer
-    geometry_msgs::Point waypoint = calcRelativeCoordinate(g_prev_path.getWaypointPosition(i), g_localizer_pose.pose);
+    geometry_msgs::Point waypoint = calcRelativeCoordinate(lane.waypoints[i].pose.pose.position, localizer_pose.pose);
     tf::Vector3 tf_waypoint = point2vector(waypoint);
     tf_waypoint.setZ(0);
 
@@ -400,19 +318,19 @@ int detectDecelerateObstacle(const int closest_waypoint, const pcl::PointCloud&lt;p
 
       // 2D distance between waypoint and points (obstacle)
       double dt = tf::tfDistance(point_vector, tf_waypoint);
-      if (dt &gt; g_stop_range &amp;&amp; dt &lt; g_stop_range + g_deceleration_range)
+      if (dt &gt; stop_range &amp;&amp; dt &lt; stop_range + deceleration_range)
       {
         decelerate_point_count++;
         geometry_msgs::Point point_temp;
         point_temp.x = p.x;
         point_temp.y = p.y;
         point_temp.z = p.z;
-	obstacle_points-&gt;setDeceleratePoint(calcAbsoluteCoordinate(point_temp, g_localizer_pose.pose));
+	obstacle_points-&gt;setDeceleratePoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
       }
     }
 
     // there is an obstacle if the number of points exceeded the threshold
-    if (decelerate_point_count &gt; g_threshold_points)
+    if (decelerate_point_count &gt; points_threshold)
     {
       decelerate_obstacle_waypoint = i;
       break;
@@ -428,21 +346,21 @@ int detectDecelerateObstacle(const int closest_waypoint, const pcl::PointCloud&lt;p
 
 
 // Detect an obstacle by using pointcloud
-EControl pointsDetection(const int closest_waypoint, const CrossWalk&amp; crosswalk, int* obstacle_waypoint, ObstaclePoints* obstacle_points)
+EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo&amp; vs_info, int* obstacle_waypoint, ObstaclePoints* obstacle_points)
 {
-  if (g_points.empty() == true || closest_waypoint &lt; 0)
+  if (points.empty() == true || closest_waypoint &lt; 0)
     return KEEP;
 
-  int stop_obstacle_waypoint = detectStopObstacle(closest_waypoint, g_points, crosswalk, obstacle_points);
+  int stop_obstacle_waypoint = detectStopObstacle(points, closest_waypoint, lane, crosswalk, vs_info.getStopRange(), vs_info.getPointsThreshold(), vs_info.getLocalizerPose(), obstacle_points);
 
   // skip searching deceleration range
-  if (g_deceleration_range &lt; 0.01)
+  if (vs_info.getDecelerationRange() &lt; 0.01)
   {
     *obstacle_waypoint = stop_obstacle_waypoint;
     return stop_obstacle_waypoint &lt; 0 ? KEEP : STOP;
   }
 
-  int decelerate_obstacle_waypoint = detectDecelerateObstacle(closest_waypoint, g_points, obstacle_points);
+  int decelerate_obstacle_waypoint = detectDecelerateObstacle(points, closest_waypoint, lane, vs_info.getStopRange(), vs_info.getDecelerationRange(), vs_info.getPointsThreshold(), vs_info.getLocalizerPose(), obstacle_points);
 
   // stop obstacle was not found
   if (stop_obstacle_waypoint &lt; 0)
@@ -458,7 +376,9 @@ EControl pointsDetection(const int closest_waypoint, const CrossWalk&amp; crosswalk,
     return STOP;
   }
 
-  int stop_decelerate_threshold = 5.0 / g_prev_path.getInterval(); // about 5.0 meter
+  // about 5.0 meter
+  double waypoint_interval = getPlaneDistance(lane.waypoints[0].pose.pose.position, lane.waypoints[1].pose.pose.position);
+  int stop_decelerate_threshold = 5 / waypoint_interval;
 
   // both were found
   if (stop_obstacle_waypoint - decelerate_obstacle_waypoint &gt; stop_decelerate_threshold)
@@ -474,14 +394,15 @@ EControl pointsDetection(const int closest_waypoint, const CrossWalk&amp; crosswalk,
 
 }
 
-EControl obstacleDetection(int closest_waypoint, int* obstacle_waypoint, const CrossWalk&amp; crosswalk)
+EControl obstacleDetection(int closest_waypoint, const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo vs_info, int* obstacle_waypoint)
 {
   static int false_count = 0;
   static EControl prev_detection = KEEP;
+  static int prev_obstacle_waypoint = -1;
 
   ObstaclePoints obstacle_points;
-  EControl detection_result = pointsDetection(closest_waypoint, crosswalk, obstacle_waypoint, &amp;obstacle_points);
-  displayDetectionRange(crosswalk, closest_waypoint, detection_result, *obstacle_waypoint);
+  EControl detection_result = pointsDetection(vs_info.getPoints(), closest_waypoint, lane, crosswalk, vs_info, obstacle_waypoint, &amp;obstacle_points);
+  displayDetectionRange(lane, crosswalk, closest_waypoint, detection_result, *obstacle_waypoint, vs_info.getStopRange(), vs_info.getDecelerationRange());
 
   if (prev_detection == KEEP)
   {
@@ -491,6 +412,7 @@ EControl obstacleDetection(int closest_waypoint, int* obstacle_waypoint, const C
       prev_detection = detection_result;
       // SoundPlay();
       false_count = 0;
+      prev_obstacle_waypoint = *obstacle_waypoint;
       return detection_result;
     }
     else
@@ -506,6 +428,7 @@ EControl obstacleDetection(int closest_waypoint, int* obstacle_waypoint, const C
       displayObstacle(detection_result, obstacle_points);
       prev_detection = detection_result;
       false_count = 0;
+      prev_obstacle_waypoint = *obstacle_waypoint;
       return detection_result;
     }
     else
@@ -522,6 +445,7 @@ EControl obstacleDetection(int closest_waypoint, int* obstacle_waypoint, const C
       }
       else
       {
+        *obstacle_waypoint = prev_obstacle_waypoint;
         displayObstacle(OTHERS, obstacle_points);
         return prev_detection;
       }
@@ -529,35 +453,34 @@ EControl obstacleDetection(int closest_waypoint, int* obstacle_waypoint, const C
   }
 }
 
-void changeWaypoint(EControl detection_result, int closest_waypoint, int obstacle_waypoint)
+void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_result, int closest_waypoint, int obstacle_waypoint, VelocitySetPath* vs_path)
 {
   if (detection_result == STOP)
   {  // STOP for obstacle
     // stop_waypoint is about g_stop_distance meter away from obstacles
-    int stop_waypoint = obstacle_waypoint - ((int)(g_stop_distance / g_new_path.getInterval()));
+    int stop_waypoint = obstacle_waypoint - vs_info.getStopDistance() / vs_path-&gt;calcInterval(0, 1);
+
     // change waypoints to stop by the stop_waypoint
-    g_new_path.changeWaypoints(stop_waypoint, closest_waypoint, g_decel, g_prev_path);
-    g_new_path.avoidSuddenBraking(g_velocity_change_limit, g_current_vel, g_decel, closest_waypoint);
-    g_new_path.setTemporalWaypoints(g_temporal_waypoints_size, closest_waypoint, g_control_pose);
-    g_temporal_waypoints_pub.publish(g_new_path.getTemporalWaypoints());
+    vs_path-&gt;changeWaypoints(stop_waypoint, closest_waypoint, vs_info.getDeceleration());
+    vs_path-&gt;avoidSuddenBraking(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
+    vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
+    g_temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
   }
   else if (detection_result == DECELERATE)
   {  // DECELERATE for obstacles
-    g_new_path.setPath(g_prev_path.getCurrentWaypoints());
-    g_new_path.setDeceleration(g_current_vel, g_decel, closest_waypoint);
-    g_new_path.setTemporalWaypoints(g_temporal_waypoints_size, closest_waypoint, g_control_pose);
-    g_temporal_waypoints_pub.publish(g_new_path.getTemporalWaypoints());
+    vs_path-&gt;initializeNewWaypoints();
+    vs_path-&gt;setDeceleration(vs_info.getDeceleration(), closest_waypoint);
+    vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
+    g_temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
   }
   else
   {  // ACELERATE or KEEP
-    g_new_path.setPath(g_prev_path.getCurrentWaypoints());
-    g_new_path.avoidSuddenAceleration(g_current_vel, g_decel, closest_waypoint);
-    g_new_path.avoidSuddenBraking(g_velocity_change_limit, g_current_vel, g_decel, closest_waypoint);
-    g_new_path.setTemporalWaypoints(g_temporal_waypoints_size, closest_waypoint, g_control_pose);
-    g_temporal_waypoints_pub.publish(g_new_path.getTemporalWaypoints());
+    vs_path-&gt;initializeNewWaypoints();
+    vs_path-&gt;avoidSuddenAceleration(vs_info.getDeceleration(), closest_waypoint);
+    vs_path-&gt;avoidSuddenBraking(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
+    vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
+    g_temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
   }
-
-  return;
 }
 
 } // end namespace
@@ -575,22 +498,28 @@ int main(int argc, char **argv)
   private_nh.param&lt;bool&gt;("use_crosswalk_detection", use_crosswalk_detection, true);
   private_nh.param&lt;std::string&gt;("points_topic", points_topic, "points_lanes");
 
-  // classes
+  // class
   CrossWalk crosswalk;
+  VelocitySetPath vs_path;
+  VelocitySetInfo vs_info;
+
+  // velocity set subscriber
+  ros::Subscriber waypoints_sub = nh.subscribe("base_waypoints", 1, &amp;VelocitySetPath::waypointsCallback, &amp;vs_path);
+  ros::Subscriber current_vel_sub = nh.subscribe("current_velocity", 1, &amp;VelocitySetPath::currentVelocityCallback, &amp;vs_path);
 
-  ros::Subscriber localizer_sub = nh.subscribe("localizer_pose", 1, localizerCallback);
-  ros::Subscriber control_pose_sub = nh.subscribe("current_pose", 1, controlCallback);
-  ros::Subscriber points_sub = nh.subscribe(points_topic, 1, pointsCallback);
-  ros::Subscriber base_waypoint_sub = nh.subscribe("base_waypoints", 1, baseWaypointCallback);
-  ros::Subscriber current_vel_sub = nh.subscribe("current_velocity", 1, currentVelCallback);
-  ros::Subscriber config_sub = nh.subscribe("config/velocity_set", 10, configCallback);
+  // velocity set info subscriber
+  ros::Subscriber config_sub = nh.subscribe("config/velocity_set", 1, &amp;VelocitySetInfo::configCallback, &amp;vs_info);
+  ros::Subscriber points_sub = nh.subscribe(points_topic, 1, &amp;VelocitySetInfo::pointsCallback, &amp;vs_info);
+  ros::Subscriber localizer_sub = nh.subscribe("localizer_pose", 1, &amp;VelocitySetInfo::localizerPoseCallback, &amp;vs_info);
+  ros::Subscriber control_pose_sub = nh.subscribe("current_pose", 1, &amp;VelocitySetInfo::controlPoseCallback, &amp;vs_info);
 
-  // vector map subscribers
+  // vector map subscriber
   ros::Subscriber sub_dtlane = nh.subscribe("vector_map_info/cross_walk", 1, &amp;CrossWalk::crossWalkCallback, &amp;crosswalk);
   ros::Subscriber sub_area = nh.subscribe("vector_map_info/area", 1, &amp;CrossWalk::areaCallback, &amp;crosswalk);
   ros::Subscriber sub_line = nh.subscribe("vector_map_info/line", 1, &amp;CrossWalk::lineCallback, &amp;crosswalk);
   ros::Subscriber sub_point = nh.subscribe("vector_map_info/point", 1, &amp;CrossWalk::pointCallback, &amp;crosswalk);
 
+  // publisher
   g_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 0);
   g_temporal_waypoints_pub = nh.advertise&lt;waypoint_follower::lane&gt;("temporal_waypoints", 1000, true);
   ros::Publisher closest_waypoint_pub;
@@ -605,27 +534,27 @@ int main(int argc, char **argv)
     if (crosswalk.loaded_all &amp;&amp; !crosswalk.set_points)
       crosswalk.setCrossWalkPoints();
 
-    if (g_pose_flag == false || g_path_flag == false)
+    if (!vs_info.getSetPose() || !vs_path.getSetPath())
     {
       loop_rate.sleep();
       continue;
     }
 
-    int closest_waypoint = getClosestWaypoint(g_new_path.getCurrentWaypoints(), g_control_pose.pose);
+    int closest_waypoint = getClosestWaypoint(vs_path.getPrevWaypoints(), vs_info.getControlPose().pose);
 
     std_msgs::Int32 closest_waypoint_msg;
     closest_waypoint_msg.data = closest_waypoint;
     closest_waypoint_pub.publish(closest_waypoint_msg);
 
     if (use_crosswalk_detection)
-      crosswalk.setDetectionWaypoint(crosswalk.findClosestCrosswalk(closest_waypoint, g_prev_path.getCurrentWaypoints(), g_search_distance));
+      crosswalk.setDetectionWaypoint(crosswalk.findClosestCrosswalk(closest_waypoint, vs_path.getPrevWaypoints(), g_search_distance));
 
     int obstacle_waypoint = -1;
-    EControl detection_result = obstacleDetection(closest_waypoint, &amp;obstacle_waypoint, crosswalk);
+    EControl detection_result = obstacleDetection(closest_waypoint, vs_path.getPrevWaypoints(), crosswalk, vs_info, &amp;obstacle_waypoint);
 
-    changeWaypoint(detection_result, closest_waypoint, obstacle_waypoint);
+    changeWaypoints(vs_info, detection_result, closest_waypoint, obstacle_waypoint, &amp;vs_path);
 
-    g_points.clear();
+    vs_info.clearPoints();
 
     loop_rate.sleep();
   }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="90" deleted_lines="34">
				<diff>@@ -30,10 +30,20 @@
 
 #include "velocity_set_path.h"
 
+VelocitySetPath::VelocitySetPath()
+  : set_path_(false),
+    current_vel_(0)
+{
+}
+
+VelocitySetPath::~VelocitySetPath()
+{
+}
+
 // check if waypoint number is valid
 bool VelocitySetPath::checkWaypoint(int num, const char *name) const
 {
-  if (num &lt; 0 || num &gt;= getSize())
+  if (num &lt; 0 || num &gt;= getPrevWaypointsSize())
   {
     return false;
   }
@@ -45,33 +55,33 @@ void VelocitySetPath::setTemporalWaypoints(int temporal_waypoints_size, int clos
 {
   if (closest_waypoint &lt; 0)
     return;
-  int size = (int)(temporal_waypoints_size / getInterval()) + 1;
+  int size = temporal_waypoints_size / calcInterval(0, 1);
 
   temporal_waypoints_.waypoints.clear();
-  temporal_waypoints_.header = current_waypoints_.header;
-  temporal_waypoints_.increment = current_waypoints_.increment;
+  temporal_waypoints_.header = new_waypoints_.header;
+  temporal_waypoints_.increment = new_waypoints_.increment;
   // push current pose
   waypoint_follower::waypoint current_point;
 
   current_point.pose = control_pose;
-  current_point.twist = current_waypoints_.waypoints[closest_waypoint].twist;
-  current_point.dtlane = current_waypoints_.waypoints[closest_waypoint].dtlane;
+  current_point.twist = new_waypoints_.waypoints[closest_waypoint].twist;
+  current_point.dtlane = new_waypoints_.waypoints[closest_waypoint].dtlane;
   temporal_waypoints_.waypoints.push_back(current_point);
   for (int i = 0; i &lt; size; i++)
   {
-    if (closest_waypoint + i &gt;= getSize())
+    if (closest_waypoint + i &gt;= getPrevWaypointsSize())
       return;
-    temporal_waypoints_.waypoints.push_back(current_waypoints_.waypoints[closest_waypoint + i]);
+    temporal_waypoints_.waypoints.push_back(new_waypoints_.waypoints[closest_waypoint + i]);
   }
 
   return;
 }
 
-void VelocitySetPath::setDeceleration(double current_velocity, double deceleration, int closest_waypoint)
+void VelocitySetPath::setDeceleration(double deceleration, int closest_waypoint)
 {
   int velocity_change_range = 5;
-  double intervel = getInterval();
-  double temp1 = current_velocity * current_velocity;
+  double intervel = calcInterval(0, 1);
+  double temp1 = current_vel_ * current_vel_;
   double temp2 = 2 * deceleration * intervel;
   double deceleration_minimum = kmph2mps(4.0);
 
@@ -79,7 +89,7 @@ void VelocitySetPath::setDeceleration(double current_velocity, double decelerati
   {
     if (!checkWaypoint(closest_waypoint + i, "setDeceleration"))
       continue;
-    double waypoint_velocity = current_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x;
+    double waypoint_velocity = prev_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x;
     double changed_vel = temp1 - temp2;
     if (changed_vel &lt; 0)
     {
@@ -89,20 +99,20 @@ void VelocitySetPath::setDeceleration(double current_velocity, double decelerati
       continue;
     if (sqrt(changed_vel) &lt; deceleration_minimum)
     {
-      current_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x = deceleration_minimum;
+      new_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x = deceleration_minimum;
       continue;
     }
-    current_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x = sqrt(changed_vel);
+    new_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x = sqrt(changed_vel);
   }
 
   return;
 }
 
-void VelocitySetPath::avoidSuddenAceleration(double current_velocity, double deceleration, int closest_waypoint)
+void VelocitySetPath::avoidSuddenAceleration(double deceleration, int closest_waypoint)
 {
   double changed_vel;
-  double interval = getInterval();
-  double temp1 = current_velocity * current_velocity;
+  double interval = calcInterval(0, 1);
+  double temp1 = current_vel_ * current_vel_;
   double temp2 = 2 * deceleration * interval;
   double velocity_offset = 1.389; // m/s
 
@@ -111,56 +121,58 @@ void VelocitySetPath::avoidSuddenAceleration(double current_velocity, double dec
     if (!checkWaypoint(closest_waypoint + i, "avoidSuddenAceleration"))
       return;
     changed_vel = sqrt(temp1 + temp2 * (double)(i + 1)) + velocity_offset;
-    if (changed_vel &gt; current_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x)
+    if (changed_vel &gt; prev_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x)
       return;
-    current_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x = changed_vel;
+    new_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x = changed_vel;
   }
 
   return;
 }
 
-void VelocitySetPath::avoidSuddenBraking(double velocity_change_limit, double current_velocity, double deceleration, int closest_waypoint)
+void VelocitySetPath::avoidSuddenBraking(double velocity_change_limit, double deceleration, int closest_waypoint)
 {
   int i = 0;
   int fill_in_zero = 20;
   int fill_in_vel = 15;
   int examin_range = 1;  // need to change according to waypoint interval?
   int num;
-  double interval = getInterval();
+  double interval = calcInterval(0, 1);
   double changed_vel;
 
   for (int j = -1; j &lt; examin_range; j++)
   {
     if (!checkWaypoint(closest_waypoint + j, "avoidSuddenBraking"))
       return;
-    if (getWaypointVelocityMPS(closest_waypoint + j) &lt;
-        current_velocity - velocity_change_limit)  // we must change waypoints
+    if (new_waypoints_.waypoints[closest_waypoint + j].twist.twist.linear.x &lt;
+        current_vel_ - velocity_change_limit)  // we must change waypoints
       break;
     if (j == examin_range - 1)  // we don't have to change waypoints
       return;
   }
 
+  ROS_INFO("avoid sudden braking!!");
+
   // fill in waypoints velocity behind vehicle
   for (num = closest_waypoint - 1; fill_in_vel &gt; 0; fill_in_vel--)
   {
     if (!checkWaypoint(num - fill_in_vel, "avoidSuddenBraking"))
       continue;
-    current_waypoints_.waypoints[num - fill_in_vel].twist.twist.linear.x = current_velocity;
+    new_waypoints_.waypoints[num - fill_in_vel].twist.twist.linear.x = current_vel_;
   }
 
   // decelerate gradually
-  double temp1 = (current_velocity - velocity_change_limit + 1.389) * (current_velocity - velocity_change_limit + 1.389);
+  double temp1 = (current_vel_ - velocity_change_limit + 1.389) * (current_vel_ - velocity_change_limit + 1.389);
   double temp2 = 2 * deceleration * interval;
   for (num = closest_waypoint - 1;; num++)
   {
-    if (num &gt;= getSize())
+    if (num &gt;= getPrevWaypointsSize())
       return;
     if (!checkWaypoint(num, "avoidSuddenBraking"))
       continue;
     changed_vel = temp1 - temp2 * (double)i;  // sqrt(v^2 - 2*a*x)
     if (changed_vel &lt;= 0)
       break;
-    current_waypoints_.waypoints[num].twist.twist.linear.x = sqrt(changed_vel);
+    new_waypoints_.waypoints[num].twist.twist.linear.x = sqrt(changed_vel);
 
     i++;
   }
@@ -169,20 +181,20 @@ void VelocitySetPath::avoidSuddenBraking(double velocity_change_limit, double cu
   {
     if (!checkWaypoint(num + j, "avoidSuddenBraking"))
       continue;
-    current_waypoints_.waypoints[num + j].twist.twist.linear.x = 0.0;
+    new_waypoints_.waypoints[num + j].twist.twist.linear.x = 0.0;
   }
 
 
   return;
 }
 
-void VelocitySetPath::changeWaypoints(int stop_waypoint, int closest_waypoint, double deceleration, const WayPoints&amp; prev_path)
+void VelocitySetPath::changeWaypoints(int stop_waypoint, int closest_waypoint, double deceleration)
 {
   int i = 0;
   int close_waypoint_threshold = 4;
   int fill_in_zero = 20;
   double changed_vel;
-  double interval = getInterval();
+  double interval = calcInterval(0, 1);
 
   // change waypoints to decelerate
   for (int num = stop_waypoint; num &gt; closest_waypoint - close_waypoint_threshold; num--)
@@ -192,14 +204,14 @@ void VelocitySetPath::changeWaypoints(int stop_waypoint, int closest_waypoint, d
 
     changed_vel = sqrt(2.0 * deceleration * (interval * i));  // sqrt(2*a*x)
 
-    waypoint_follower::waypoint initial_waypoint = prev_path.getCurrentWaypoints().waypoints[num];
+    waypoint_follower::waypoint initial_waypoint = prev_waypoints_.waypoints[num];
     if (changed_vel &gt; initial_waypoint.twist.twist.linear.x)
     {  // avoid acceleration
-      current_waypoints_.waypoints[num].twist.twist.linear.x = initial_waypoint.twist.twist.linear.x;
+      new_waypoints_.waypoints[num].twist.twist.linear.x = initial_waypoint.twist.twist.linear.x;
     }
     else
     {
-      current_waypoints_.waypoints[num].twist.twist.linear.x = changed_vel;
+      new_waypoints_.waypoints[num].twist.twist.linear.x = changed_vel;
     }
 
     i++;
@@ -210,10 +222,54 @@ void VelocitySetPath::changeWaypoints(int stop_waypoint, int closest_waypoint, d
   {
     if (!checkWaypoint(stop_waypoint + j, "changeWaypoints"))
       continue;
-    current_waypoints_.waypoints[stop_waypoint + j].twist.twist.linear.x = 0.0;
+    new_waypoints_.waypoints[stop_waypoint + j].twist.twist.linear.x = 0.0;
   }
 
 
   return;
 }
 
+void VelocitySetPath::initializeNewWaypoints()
+{
+  new_waypoints_ = prev_waypoints_;
+}
+
+double VelocitySetPath::calcInterval(const int begin, const int end) const
+{
+  // check index
+  if (begin &lt; 0 || begin &gt;= getPrevWaypointsSize() || end &lt; 0 || end &gt;= getPrevWaypointsSize())
+  {
+    ROS_WARN("Invalid index");
+    return -1;
+  }
+
+  // Calculate the inteval of waypoints
+  double dist_sum = 0;
+  for (int i = begin; i &lt; end; i++)
+  {
+    tf::Vector3 v1(prev_waypoints_.waypoints[i].pose.pose.position.x,
+                   prev_waypoints_.waypoints[i].pose.pose.position.y, 0);
+
+    tf::Vector3 v2(prev_waypoints_.waypoints[i + 1].pose.pose.position.x,
+                   prev_waypoints_.waypoints[i + 1].pose.pose.position.y, 0);
+
+    dist_sum += tf::tfDistance(v1, v2);
+  }
+
+  return dist_sum;
+}
+
+
+void VelocitySetPath::waypointsCallback(const waypoint_follower::laneConstPtr&amp; msg)
+{
+  prev_waypoints_ = *msg;
+  new_waypoints_ = *msg;
+
+  if (!set_path_)
+    set_path_ = true;
+}
+
+void VelocitySetPath::currentVelocityCallback(const geometry_msgs::TwistStampedConstPtr&amp; msg)
+{
+  current_vel_ = msg-&gt;twist.linear.x;
+}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" added_lines="44" deleted_lines="6">
				<diff>@@ -32,25 +32,63 @@
 #define VELOCITY_SET_PATH_H
 
 #include "waypoint_follower/libwaypoint_follower.h"
-
-class VelocitySetPath : public WayPoints
+class VelocitySetPath
 {
  private:
+  waypoint_follower::lane prev_waypoints_;
+  waypoint_follower::lane new_waypoints_;
   waypoint_follower::lane temporal_waypoints_;
+  bool set_path_;
+  double current_vel_;
 
   bool checkWaypoint(int num, const char *name) const;
 
  public:
-  void changeWaypoints(int stop_waypoint, int closest_waypoint, double deceleration, const WayPoints&amp; prev_path);
-  void avoidSuddenBraking(double velocity_change_limit, double current_velocity, double deceleration, int closest_waypoint);
-  void avoidSuddenAceleration(double current_velocity, double decelerationint, int closest_waypoint);
-  void setDeceleration(double current_velocity, double deceleration, int closest_waypoint);
+  VelocitySetPath();
+  ~VelocitySetPath();
+
+  void changeWaypoints(int stop_waypoint, int closest_waypoint, double deceleration);
+  void avoidSuddenBraking(double velocity_change_limit, double deceleration, int closest_waypoint);
+  void avoidSuddenAceleration(double decelerationint, int closest_waypoint);
+  void setDeceleration(double deceleration, int closest_waypoint);
   void setTemporalWaypoints(int temporal_waypoints_size, int closest_waypoint, geometry_msgs::PoseStamped control_pose);
+  void initializeNewWaypoints();
+
+  // ROS Callbacks
+  void waypointsCallback(const waypoint_follower::laneConstPtr&amp; msg);
+  void currentVelocityCallback(const geometry_msgs::TwistStampedConstPtr&amp; msg);
+
+  double calcInterval(const int begin, const int end) const;
+
+  waypoint_follower::lane getPrevWaypoints() const
+  {
+    return prev_waypoints_;
+  }
+
+  waypoint_follower::lane getNewWaypoints() const
+  {
+    return new_waypoints_;
+  }
 
   waypoint_follower::lane getTemporalWaypoints() const
   {
     return temporal_waypoints_;
   }
+
+  bool getSetPath() const
+  {
+    return set_path_;
+  }
+
+  double getCurrentVelocity() const
+  {
+    return current_vel_;
+  }
+
+  int getPrevWaypointsSize() const
+  {
+    return prev_waypoints_.waypoints.size();
+  }  
 };
 
 #endif // VELOCITY_SET_PATH_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bc12cfafa90c6054b0b04ed359ed7585bd098416" author="TomohitoAndo">
		<msg>Use local variables for publishers</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="19" deleted_lines="25">
				<diff>@@ -43,14 +43,9 @@ constexpr int LOOP_RATE = 10;
 constexpr double g_deceleration_search_distance = 30;
 constexpr double g_search_distance = 60;
 
-// Publisher
-ros::Publisher g_range_pub;
-ros::Publisher g_temporal_waypoints_pub;
-ros::Publisher g_obstacle_pub;
-
 
 // Display a detected obstacle
-void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points)
+void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points, const ros::Publisher&amp; obstacle_pub)
 {
   visualization_msgs::Marker marker;
   marker.header.frame_id = "/map";
@@ -92,10 +87,10 @@ void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points
   marker.lifetime = ros::Duration(0.1);
   marker.frame_locked = true;
 
-  g_obstacle_pub.publish(marker);
+  obstacle_pub.publish(marker);
 }
 
-void displayDetectionRange(const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, const int closest_waypoint, const EControl &amp;kind, const int obstacle_waypoint, const double stop_range, const double deceleration_range)
+void displayDetectionRange(const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, const int closest_waypoint, const EControl &amp;kind, const int obstacle_waypoint, const double stop_range, const double deceleration_range, const ros::Publisher&amp; detection_range_pub)
 {
   // set up for marker array
   visualization_msgs::MarkerArray marker_array;
@@ -196,7 +191,7 @@ void displayDetectionRange(const waypoint_follower::lane&amp; lane, const CrossWalk&amp;
   marker_array.markers.push_back(waypoint_marker_decelerate);
   if (kind == STOP)
     marker_array.markers.push_back(stop_line);
-  g_range_pub.publish(marker_array);
+  detection_range_pub.publish(marker_array);
   marker_array.markers.clear();
 }
 
@@ -394,7 +389,7 @@ EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int
 
 }
 
-EControl obstacleDetection(int closest_waypoint, const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo vs_info, int* obstacle_waypoint)
+EControl obstacleDetection(int closest_waypoint, const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo vs_info, const ros::Publisher&amp; detection_range_pub, const ros::Publisher&amp; obstacle_pub, int* obstacle_waypoint)
 {
   static int false_count = 0;
   static EControl prev_detection = KEEP;
@@ -402,13 +397,13 @@ EControl obstacleDetection(int closest_waypoint, const waypoint_follower::lane&amp;
 
   ObstaclePoints obstacle_points;
   EControl detection_result = pointsDetection(vs_info.getPoints(), closest_waypoint, lane, crosswalk, vs_info, obstacle_waypoint, &amp;obstacle_points);
-  displayDetectionRange(lane, crosswalk, closest_waypoint, detection_result, *obstacle_waypoint, vs_info.getStopRange(), vs_info.getDecelerationRange());
+  displayDetectionRange(lane, crosswalk, closest_waypoint, detection_result, *obstacle_waypoint, vs_info.getStopRange(), vs_info.getDecelerationRange(), detection_range_pub);
 
   if (prev_detection == KEEP)
   {
     if (detection_result != KEEP)
     {  // found obstacle
-      displayObstacle(detection_result, obstacle_points);
+      displayObstacle(detection_result, obstacle_points, obstacle_pub);
       prev_detection = detection_result;
       // SoundPlay();
       false_count = 0;
@@ -425,7 +420,7 @@ EControl obstacleDetection(int closest_waypoint, const waypoint_follower::lane&amp;
   {  // prev_detection = STOP or DECELERATE
     if (detection_result != KEEP)
     {  // found obstacle
-      displayObstacle(detection_result, obstacle_points);
+      displayObstacle(detection_result, obstacle_points, obstacle_pub);
       prev_detection = detection_result;
       false_count = 0;
       prev_obstacle_waypoint = *obstacle_waypoint;
@@ -446,14 +441,14 @@ EControl obstacleDetection(int closest_waypoint, const waypoint_follower::lane&amp;
       else
       {
         *obstacle_waypoint = prev_obstacle_waypoint;
-        displayObstacle(OTHERS, obstacle_points);
+        displayObstacle(OTHERS, obstacle_points, obstacle_pub);
         return prev_detection;
       }
     }
   }
 }
 
-void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_result, int closest_waypoint, int obstacle_waypoint, VelocitySetPath* vs_path)
+void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_result, int closest_waypoint, int obstacle_waypoint, const ros::Publisher&amp; temporal_waypoints_pub, VelocitySetPath* vs_path)
 {
   if (detection_result == STOP)
   {  // STOP for obstacle
@@ -464,14 +459,14 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
     vs_path-&gt;changeWaypoints(stop_waypoint, closest_waypoint, vs_info.getDeceleration());
     vs_path-&gt;avoidSuddenBraking(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
-    g_temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
+    temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
   }
   else if (detection_result == DECELERATE)
   {  // DECELERATE for obstacles
     vs_path-&gt;initializeNewWaypoints();
     vs_path-&gt;setDeceleration(vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
-    g_temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
+    temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
   }
   else
   {  // ACELERATE or KEEP
@@ -479,7 +474,7 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
     vs_path-&gt;avoidSuddenAceleration(vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;avoidSuddenBraking(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
-    g_temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
+    temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
   }
 }
 
@@ -520,11 +515,10 @@ int main(int argc, char **argv)
   ros::Subscriber sub_point = nh.subscribe("vector_map_info/point", 1, &amp;CrossWalk::pointCallback, &amp;crosswalk);
 
   // publisher
-  g_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 0);
-  g_temporal_waypoints_pub = nh.advertise&lt;waypoint_follower::lane&gt;("temporal_waypoints", 1000, true);
-  ros::Publisher closest_waypoint_pub;
-  closest_waypoint_pub = nh.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1000);
-  g_obstacle_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("obstacle", 0);
+  ros::Publisher detection_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 0);
+  ros::Publisher temporal_waypoints_pub = nh.advertise&lt;waypoint_follower::lane&gt;("temporal_waypoints", 1000, true);
+  ros::Publisher closest_waypoint_pub = nh.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1000);
+  ros::Publisher obstacle_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("obstacle", 0);
 
   ros::Rate loop_rate(LOOP_RATE);
   while (ros::ok())
@@ -550,9 +544,9 @@ int main(int argc, char **argv)
       crosswalk.setDetectionWaypoint(crosswalk.findClosestCrosswalk(closest_waypoint, vs_path.getPrevWaypoints(), g_search_distance));
 
     int obstacle_waypoint = -1;
-    EControl detection_result = obstacleDetection(closest_waypoint, vs_path.getPrevWaypoints(), crosswalk, vs_info, &amp;obstacle_waypoint);
+    EControl detection_result = obstacleDetection(closest_waypoint, vs_path.getPrevWaypoints(), crosswalk, vs_info, detection_range_pub, obstacle_pub, &amp;obstacle_waypoint);
 
-    changeWaypoints(vs_info, detection_result, closest_waypoint, obstacle_waypoint, &amp;vs_path);
+    changeWaypoints(vs_info, detection_result, closest_waypoint, obstacle_waypoint, temporal_waypoints_pub, &amp;vs_path);
 
     vs_info.clearPoints();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="dd26ee3894ee3688b820b21e165c9de3bfff5c05" author="TomohitoAndo">
		<msg>Make the function more concise</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="23" deleted_lines="42">
				<diff>@@ -391,61 +391,42 @@ EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int
 
 EControl obstacleDetection(int closest_waypoint, const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo vs_info, const ros::Publisher&amp; detection_range_pub, const ros::Publisher&amp; obstacle_pub, int* obstacle_waypoint)
 {
-  static int false_count = 0;
-  static EControl prev_detection = KEEP;
-  static int prev_obstacle_waypoint = -1;
-
   ObstaclePoints obstacle_points;
   EControl detection_result = pointsDetection(vs_info.getPoints(), closest_waypoint, lane, crosswalk, vs_info, obstacle_waypoint, &amp;obstacle_points);
   displayDetectionRange(lane, crosswalk, closest_waypoint, detection_result, *obstacle_waypoint, vs_info.getStopRange(), vs_info.getDecelerationRange(), detection_range_pub);
 
-  if (prev_detection == KEEP)
+  static int false_count = 0;
+  static EControl prev_detection = KEEP;
+  static int prev_obstacle_waypoint = -1;
+
+  // stop or decelerate because we found obstacles
+  if (detection_result == STOP || detection_result == DECELERATE)
   {
-    if (detection_result != KEEP)
-    {  // found obstacle
-      displayObstacle(detection_result, obstacle_points, obstacle_pub);
+    displayObstacle(detection_result, obstacle_points, obstacle_pub);
       prev_detection = detection_result;
-      // SoundPlay();
       false_count = 0;
       prev_obstacle_waypoint = *obstacle_waypoint;
       return detection_result;
-    }
-    else
-    {  // no obstacle
-      prev_detection = KEEP;
-      return detection_result;
-    }
   }
-  else
-  {  // prev_detection = STOP or DECELERATE
-    if (detection_result != KEEP)
-    {  // found obstacle
-      displayObstacle(detection_result, obstacle_points, obstacle_pub);
-      prev_detection = detection_result;
-      false_count = 0;
-      prev_obstacle_waypoint = *obstacle_waypoint;
-      return detection_result;
-    }
-    else
-    {  // no obstacle
-      false_count++;
 
-      // fail-safe
-      if (false_count &gt;= LOOP_RATE / 2)
-      {
-        *obstacle_waypoint = -1;
-        false_count = 0;
-        prev_detection = KEEP;
-        return detection_result;
-      }
-      else
-      {
-        *obstacle_waypoint = prev_obstacle_waypoint;
-        displayObstacle(OTHERS, obstacle_points, obstacle_pub);
-        return prev_detection;
-      }
+  // there are no obstacles, but wait a little for safety
+  if (prev_detection == STOP || prev_detection == DECELERATE)
+  {
+    false_count++;
+
+    if (false_count &lt; LOOP_RATE / 2)
+    {
+      *obstacle_waypoint = prev_obstacle_waypoint;
+      displayObstacle(OTHERS, obstacle_points, obstacle_pub);
+      return prev_detection;
     }
   }
+
+  // there are no obstacles, so we move forward
+  *obstacle_waypoint = -1;
+  false_count = 0;
+  prev_detection = KEEP;
+  return detection_result;
 }
 
 void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_result, int closest_waypoint, int obstacle_waypoint, const ros::Publisher&amp; temporal_waypoints_pub, VelocitySetPath* vs_path)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="11ed7ac2ddfccc3c3daa9498a8bb01615dba6c21" author="TomohitoAndo">
		<msg>Make constans all capitals</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -40,8 +40,8 @@
 namespace
 {
 constexpr int LOOP_RATE = 10;
-constexpr double g_deceleration_search_distance = 30;
-constexpr double g_search_distance = 60;
+constexpr double DECELERATION_SEARCH_DISTANCE = 30;
+constexpr double STOP_SEARCH_DISTANCE = 60;
 
 
 // Display a detected obstacle
@@ -164,7 +164,7 @@ void displayDetectionRange(const waypoint_follower::lane&amp; lane, const CrossWalk&amp;
   crosswalk_marker.frame_locked = true;
 
   // set marker points coordinate
-  for (int i = 0; i &lt; g_search_distance; i++)
+  for (int i = 0; i &lt; STOP_SEARCH_DISTANCE; i++)
   {
     if (closest_waypoint &lt; 0 || i + closest_waypoint &gt; static_cast&lt;int&gt;(lane.waypoints.size()) - 1)
       break;
@@ -174,7 +174,7 @@ void displayDetectionRange(const waypoint_follower::lane&amp; lane, const CrossWalk&amp;
 
     waypoint_marker_stop.points.push_back(point);
 
-    if (i &gt; g_deceleration_search_distance)
+    if (i &gt; DECELERATION_SEARCH_DISTANCE)
       continue;
     waypoint_marker_decelerate.points.push_back(point);
   }
@@ -236,7 +236,7 @@ int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int c
 {
   int stop_obstacle_waypoint = -1;
   // start search from the closest waypoint
-  for (int i = closest_waypoint; i &lt; closest_waypoint + g_search_distance; i++)
+  for (int i = closest_waypoint; i &lt; closest_waypoint + STOP_SEARCH_DISTANCE; i++)
   {
     // reach the end of waypoints
     if (i &gt;= static_cast&lt;int&gt;(lane.waypoints.size()))
@@ -295,7 +295,7 @@ int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const
 {
   int decelerate_obstacle_waypoint = -1;
   // start search from the closest waypoint
-  for (int i = closest_waypoint; i &lt; closest_waypoint + g_deceleration_search_distance; i++)
+  for (int i = closest_waypoint; i &lt; closest_waypoint + DECELERATION_SEARCH_DISTANCE; i++)
   {
     // reach the end of waypoints
     if (i &gt;= static_cast&lt;int&gt;(lane.waypoints.size()))
@@ -522,7 +522,7 @@ int main(int argc, char **argv)
     closest_waypoint_pub.publish(closest_waypoint_msg);
 
     if (use_crosswalk_detection)
-      crosswalk.setDetectionWaypoint(crosswalk.findClosestCrosswalk(closest_waypoint, vs_path.getPrevWaypoints(), g_search_distance));
+      crosswalk.setDetectionWaypoint(crosswalk.findClosestCrosswalk(closest_waypoint, vs_path.getPrevWaypoints(), STOP_SEARCH_DISTANCE));
 
     int obstacle_waypoint = -1;
     EControl detection_result = obstacleDetection(closest_waypoint, vs_path.getPrevWaypoints(), crosswalk, vs_info, detection_range_pub, obstacle_pub, &amp;obstacle_waypoint);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="322a7ba2caacb1a96aa0bb4a44f971152509125c" author="TomohitoAndo">
		<msg>Comment out publishing of the obstacle marker</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -87,7 +87,7 @@ void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points
   marker.lifetime = ros::Duration(0.1);
   marker.frame_locked = true;
 
-  obstacle_pub.publish(marker);
+  //obstacle_pub.publish(marker);
 }
 
 void displayDetectionRange(const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, const int closest_waypoint, const EControl &amp;kind, const int obstacle_waypoint, const double stop_range, const double deceleration_range, const ros::Publisher&amp; detection_range_pub)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="92f616be8776759453580b60630d33928b47e19d" author="TomohitoAndo">
		<msg>Remove unnecessary comment</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -66,7 +66,7 @@ void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points
     marker.pose.position = prev_obstacle_point;
   }
   geometry_msgs::Quaternion quat;
-  marker.pose.orientation = quat;//g_localizer_pose.pose.orientation;
+  marker.pose.orientation = quat;
 
   marker.scale.x = 1.0;
   marker.scale.y = 1.0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6fb43f59db27df66830d316c1327f239c8fb559c" author="TomohitoAndo">
		<msg>Publish local waypoint velocity</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -409,8 +409,8 @@ void laneArrayCallback(const waypoint_follower::LaneArrayConstPtr &amp;msg)
 void temporalCallback(const waypoint_follower::laneConstPtr &amp;msg)
 {
   g_local_waypoints_marker_array.markers.clear();
-  //if (_closest_waypoint != -1)
-   // createLocalWaypointVelocityMarker(g_local_color, _closest_waypoint, *msg);
+  if (_closest_waypoint != -1)
+    createLocalWaypointVelocityMarker(g_local_color, _closest_waypoint, *msg);
   createLocalPathMarker(g_local_color, *msg);
   createLocalPointMarker(*msg);
   publishLocalMarker();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="22fdbb1462ff2a7c2faa5c47a711242edcae0880" author="TomohitoAndo">
		<msg>Remove unnecessary include</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -30,7 +30,6 @@
 
 #include &lt;ros/ros.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;std_msgs/Int32.h&gt;
 #include &lt;iostream&gt;
 
 #include "libvelocity_set.h"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f5050cd85ccd230400c0977e330895415905347a" author="h_ohta">
		<msg>New simulator with angle and position errors</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" added_lines="17" deleted_lines="3">
				<diff>@@ -37,6 +37,7 @@
 #include &lt;tf/tf.h&gt;
 #include &lt;iostream&gt;
 #include &lt;std_msgs/Int32.h&gt;
+#include &lt;random&gt;
 
 #include "waypoint_follower/libwaypoint_follower.h"
 
@@ -56,6 +57,8 @@ WayPoints _current_waypoints;
 ros::Publisher g_odometry_publisher;
 ros::Publisher g_velocity_publisher;
 int32_t g_closest_waypoint = -1;
+double g_position_error;
+double g_angle_error;
 
 constexpr int LOOP_RATE = 50; // 50Hz
 
@@ -180,10 +183,17 @@ void publishOdometry()
   current_time = ros::Time::now();
 
   // compute odometry in a typical way given the velocities of the robot
+  std::random_device rnd;
+  std::mt19937 mt(rnd());
+  std::uniform_real_distribution&lt;double&gt; rnd_dist(0.0, 2.0);
+  double rnd_value_x = rnd_dist(mt) - 1.0;
+  double rnd_value_y = rnd_dist(mt) - 1.0;
+  double rnd_value_th = rnd_dist(mt) - 1.0;
+
   double dt = (current_time - last_time).toSec();
-  double delta_x = (vx * cos(th)) * dt;
-  double delta_y = (vx * sin(th)) * dt;
-  double delta_th = vth * dt;
+  double delta_x = (vx * cos(th)) * dt + rnd_value_x * g_position_error;
+  double delta_y = (vx * sin(th)) * dt + rnd_value_y * g_position_error;
+  double delta_th = vth * dt + rnd_value_th * g_angle_error * M_PI / 180;
 
   pose.position.x += delta_x;
   pose.position.y += delta_y;
@@ -245,6 +255,10 @@ int main(int argc, char **argv)
   double accel_rate;
   private_nh.param("accel_rate",accel_rate,double(1.0));
   ROS_INFO_STREAM("accel_rate : " &lt;&lt; accel_rate);
+
+
+  private_nh.param("position_error", g_position_error, double(0.0));
+  private_nh.param("angle_error", g_angle_error, double(0.0));
   // publish topic
   g_odometry_publisher = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("sim_pose", 10);
   g_velocity_publisher = nh.advertise&lt;geometry_msgs::TwistStamped&gt;("sim_velocity", 10);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="778bc63114a75a2ab2ccfbd0da4971125ad1c27b" author="TomohitoAndo">
		<msg>Remove unnecessary comments</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="0" deleted_lines="8">
				<diff>@@ -514,14 +514,6 @@ int main(int argc, char **argv)
       continue;
     }
 
-    /*
-    int closest_waypoint = getClosestWaypoint(vs_path.getPrevWaypoints(), vs_info.getControlPose().pose);
-
-    std_msgs::Int32 closest_waypoint_msg;
-    closest_waypoint_msg.data = closest_waypoint;
-    closest_waypoint_pub.publish(closest_waypoint_msg);
-    */
-
     if (use_crosswalk_detection)
       crosswalk.setDetectionWaypoint(crosswalk.findClosestCrosswalk(vs_info.getClosestWaypoint(), vs_path.getPrevWaypoints(), STOP_SEARCH_DISTANCE));
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5549abdda8791a13aaf5a3f505cae46ffed794c4" author="h_ohta">
		<msg>Add comments</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" added_lines="2" deleted_lines="0">
				<diff>@@ -35,12 +35,14 @@ namespace state_machine
 
 void StateTrafficLightStop::update(StateContext *context)
 {
+  //if light is GREEN, Go to MOVE_FORWARD
   if(context-&gt;getLightColor() == TrafficLight::GREEN)
   context-&gt;setState(StateMoveForward::create());
 }
 
 void StateMoveForward::update(StateContext *context)
 {
+  //if light is RED, Go to TRAFFIC_LIGHT_STOP
   if (context-&gt;getLightColor() == TrafficLight::RED)
     context-&gt;setState(StateTrafficLightStop::create());
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bf2ebb56a1391389769d474ebf60d1b6f0d7ec45" author="h_ohta">
		<msg>Add new state for LANE_CHANGE</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" added_lines="5" deleted_lines="0">
				<diff>@@ -47,4 +47,9 @@ void StateMoveForward::update(StateContext *context)
     context-&gt;setState(StateTrafficLightStop::create());
 }
 
+void StateLaneChange::update(StateContext *context)
+{
+  //lane change
+}
+
 }  // state_machine
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" added_lines="31" deleted_lines="0">
				<diff>@@ -41,6 +41,7 @@ enum class StateList : int32_t
 {
   MOVE_FORWARD,
   TRAFFIC_LIGHT_STOP,
+  LANE_CHANGE,
   MISSION_COMPLETE,
 
   EMERGENCY = -1,
@@ -53,6 +54,15 @@ enum class TrafficLight : int32_t
   UNKNOWN,
 };
 
+enum class ChangeFlag : int32_t
+{
+  straight,
+  right,
+  left,
+
+  unknown = -1,
+};
+
 template &lt;class T&gt;
 typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
 {
@@ -107,7 +117,23 @@ private:
   StateTrafficLightStop() = default;
 };
 
+// State : LANE_CHANGE
+class StateLaneChange : public BaseState
+{
+ public:
+  void update(StateContext *context) override;
+  int32_t getStateName() override
+  {
+    return enumToInteger(StateList::LANE_CHANGE);
+  }
+  static std::unique_ptr&lt;BaseState&gt; create() const
+  {
+    return std::unique_ptr&lt;BaseState&gt;(new StateLaneChange);
+  };
 
+ private:
+  StateLaneChange() = default;
+};
 
 // State : EMERGENCY
 class StateEmergency : public BaseState
@@ -165,6 +191,10 @@ public:
   {
     light_color_ = static_cast&lt;TrafficLight&gt;(msg);
   }
+  void setChangeFlag(const int32_t &amp;msg)
+  {
+    change_flag_ = static_cast&lt;ChangeFlag&gt;(msg);
+  }
 
   TrafficLight getLightColor() const
   {
@@ -178,6 +208,7 @@ public:
 private:
   std::unique_ptr&lt;BaseState&gt; state_;
   TrafficLight light_color_;
+  ChangeFlag change_flag_;
 };
 
 }  // state_machine
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6b3003ff011c2d4a35156108a32c82649588f1b4" author="h_ohta">
		<msg>Delete const</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" added_lines="5" deleted_lines="5">
				<diff>@@ -90,7 +90,7 @@ public:
   {
     return enumToInteger(StateList::MOVE_FORWARD);
   }
-  static std::unique_ptr&lt;BaseState&gt; create() const
+  static std::unique_ptr&lt;BaseState&gt; create()
   {
     return std::unique_ptr&lt;BaseState&gt;(new StateMoveForward);
   };
@@ -108,7 +108,7 @@ public:
   {
     return enumToInteger(StateList::TRAFFIC_LIGHT_STOP);
   }
-  static std::unique_ptr&lt;BaseState&gt; create() const
+  static std::unique_ptr&lt;BaseState&gt; create()
   {
     return std::unique_ptr&lt;BaseState&gt;(new StateTrafficLightStop);
   };
@@ -126,7 +126,7 @@ class StateLaneChange : public BaseState
   {
     return enumToInteger(StateList::LANE_CHANGE);
   }
-  static std::unique_ptr&lt;BaseState&gt; create() const
+  static std::unique_ptr&lt;BaseState&gt; create()
   {
     return std::unique_ptr&lt;BaseState&gt;(new StateLaneChange);
   };
@@ -144,7 +144,7 @@ class StateEmergency : public BaseState
   {
     return enumToInteger(StateList::EMERGENCY);
   }
-  static std::unique_ptr&lt;BaseState&gt; create() const
+  static std::unique_ptr&lt;BaseState&gt; create()
   {
     return std::unique_ptr&lt;BaseState&gt;(new StateEmergency);
   };
@@ -162,7 +162,7 @@ class StateMissionComplete : public BaseState
   {
     return enumToInteger(StateList::MISSION_COMPLETE);
   }
-  static std::unique_ptr&lt;BaseState&gt; create() const
+  static std::unique_ptr&lt;BaseState&gt; create()
   {
     return std::unique_ptr&lt;BaseState&gt;(new StateMissionComplete);
   };
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0fe911716fca12c817966fb91bc4ab99b2e3a1dc" author="h_ohta">
		<msg>Publish string topic for state, test version</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" added_lines="25" deleted_lines="0">
				<diff>@@ -79,6 +79,7 @@ public:
   virtual ~BaseState() = default;
   virtual void update(StateContext *context) = 0;
   virtual int32_t getStateName() { return 0;};
+  virtual std::unique_ptr&lt;std::string&gt; getStateNameString() { return 0;};
 };
 
 // State : MOVE_FORWARD
@@ -90,6 +91,10 @@ public:
   {
     return enumToInteger(StateList::MOVE_FORWARD);
   }
+  std::unique_ptr&lt;std::string&gt; getStateNameString() override
+  {
+    return std::unique_ptr&lt;std::string&gt;(new std::string("MOVE_FORWARD"));
+  }
   static std::unique_ptr&lt;BaseState&gt; create()
   {
     return std::unique_ptr&lt;BaseState&gt;(new StateMoveForward);
@@ -108,6 +113,10 @@ public:
   {
     return enumToInteger(StateList::TRAFFIC_LIGHT_STOP);
   }
+  std::unique_ptr&lt;std::string&gt; getStateNameString() override
+  {
+    return std::unique_ptr&lt;std::string&gt;(new std::string("TRAFFIC_LIGHT_STOP"));
+  }
   static std::unique_ptr&lt;BaseState&gt; create()
   {
     return std::unique_ptr&lt;BaseState&gt;(new StateTrafficLightStop);
@@ -126,6 +135,10 @@ class StateLaneChange : public BaseState
   {
     return enumToInteger(StateList::LANE_CHANGE);
   }
+  std::unique_ptr&lt;std::string&gt; getStateNameString() override
+  {
+    return std::unique_ptr&lt;std::string&gt;(new std::string("LANE_CHANGE"));
+  }
   static std::unique_ptr&lt;BaseState&gt; create()
   {
     return std::unique_ptr&lt;BaseState&gt;(new StateLaneChange);
@@ -144,6 +157,10 @@ class StateEmergency : public BaseState
   {
     return enumToInteger(StateList::EMERGENCY);
   }
+  std::unique_ptr&lt;std::string&gt; getStateNameString() override
+  {
+    return std::unique_ptr&lt;std::string&gt;(new std::string("EMERGENCY"));
+  }
   static std::unique_ptr&lt;BaseState&gt; create()
   {
     return std::unique_ptr&lt;BaseState&gt;(new StateEmergency);
@@ -162,6 +179,10 @@ class StateMissionComplete : public BaseState
   {
     return enumToInteger(StateList::MISSION_COMPLETE);
   }
+  std::unique_ptr&lt;std::string&gt; getStateNameString() override
+  {
+    return std::unique_ptr&lt;std::string&gt;(new std::string("MISSION_COMPLETE"));
+  }
   static std::unique_ptr&lt;BaseState&gt; create()
   {
     return std::unique_ptr&lt;BaseState&gt;(new StateMissionComplete);
@@ -204,6 +225,10 @@ public:
   {
     return state_-&gt;getStateName();
   }
+  std::unique_ptr&lt;std::string&gt; getCurrentStateString() const
+  {
+    return state_-&gt;getStateNameString();
+  }
 
 private:
   std::unique_ptr&lt;BaseState&gt; state_;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.cpp" added_lines="7" deleted_lines="1">
				<diff>@@ -56,7 +56,7 @@ void StateMachineNode::initForROS()
   sub2_ = nh_.subscribe("light_color_managed", 100, &amp;StateMachineNode::callbackFromLightColorManaged, this);
 
   // setup publisher
-  pub_ = nh_.advertise&lt;std_msgs::Int32&gt;("state",10);
+  pub_ = nh_.advertise&lt;std_msgs::String&gt;("state",10);
 }
 
 void StateMachineNode::run()
@@ -66,11 +66,17 @@ void StateMachineNode::run()
 
 void StateMachineNode::publish() const
 {
+  /*
   std_msgs::Int32 msg;
   msg.data = sc_.getCurrentState();
   ROS_INFO("Current State: %d",sc_.getCurrentState());
   pub_.publish(msg);
+  */
 
+  std_msgs::String msg;
+  msg.data = *sc_.getCurrentStateString();
+  ROS_INFO_STREAM("Current State String : " &lt;&lt; msg.data);
+  pub_.publish(msg);
 }
 
 void StateMachineNode::callbackFromLightColor(const runtime_manager::traffic_lightConstPtr&amp; msg)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.h" added_lines="1" deleted_lines="0">
				<diff>@@ -33,6 +33,7 @@
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
+#include &lt;std_msgs/String.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 
 // User Defined includes
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="036ddc3091761cd8731d8aad37d86089f3daf4c2" author="h_ohta">
		<msg>Fix Indent</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" added_lines="5" deleted_lines="6">
				<diff>@@ -32,24 +32,23 @@
 
 namespace state_machine
 {
-
 void StateTrafficLightStop::update(StateContext *context)
 {
-  //if light is GREEN, Go to MOVE_FORWARD
-  if(context-&gt;getLightColor() == TrafficLight::GREEN)
-  context-&gt;setState(StateMoveForward::create());
+  // if light is GREEN, Go to MOVE_FORWARD
+  if (context-&gt;getLightColor() == TrafficLight::GREEN)
+    context-&gt;setState(StateMoveForward::create());
 }
 
 void StateMoveForward::update(StateContext *context)
 {
-  //if light is RED, Go to TRAFFIC_LIGHT_STOP
+  // if light is RED, Go to TRAFFIC_LIGHT_STOP
   if (context-&gt;getLightColor() == TrafficLight::RED)
     context-&gt;setState(StateTrafficLightStop::create());
 }
 
 void StateLaneChange::update(StateContext *context)
 {
-  //lane change
+  // lane change
 }
 
 }  // state_machine
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" added_lines="16" deleted_lines="15">
				<diff>@@ -36,7 +36,6 @@
 
 namespace state_machine
 {
-
 enum class StateList : int32_t
 {
   MOVE_FORWARD,
@@ -69,7 +68,7 @@ typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
   return static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(t);
 }
 
-//Forward Decralation
+// Forward Decralation
 class StateContext;
 
 // abstract class for states
@@ -78,8 +77,14 @@ class BaseState
 public:
   virtual ~BaseState() = default;
   virtual void update(StateContext *context) = 0;
-  virtual int32_t getStateName() { return 0;};
-  virtual std::unique_ptr&lt;std::string&gt; getStateNameString() { return 0;};
+  virtual int32_t getStateName()
+  {
+    return 0;
+  };
+  virtual std::unique_ptr&lt;std::string&gt; getStateNameString()
+  {
+    return 0;
+  };
 };
 
 // State : MOVE_FORWARD
@@ -129,7 +134,7 @@ private:
 // State : LANE_CHANGE
 class StateLaneChange : public BaseState
 {
- public:
+public:
   void update(StateContext *context) override;
   int32_t getStateName() override
   {
@@ -144,14 +149,14 @@ class StateLaneChange : public BaseState
     return std::unique_ptr&lt;BaseState&gt;(new StateLaneChange);
   };
 
- private:
+private:
   StateLaneChange() = default;
 };
 
 // State : EMERGENCY
 class StateEmergency : public BaseState
 {
- public:
+public:
   void update(StateContext *context) override;
   int32_t getStateName() override
   {
@@ -166,14 +171,14 @@ class StateEmergency : public BaseState
     return std::unique_ptr&lt;BaseState&gt;(new StateEmergency);
   };
 
- private:
+private:
   StateEmergency() = default;
 };
 
 // State : MISSION_COMPLETE
 class StateMissionComplete : public BaseState
 {
- public:
+public:
   void update(StateContext *context) override;
   int32_t getStateName() override
   {
@@ -188,18 +193,14 @@ class StateMissionComplete : public BaseState
     return std::unique_ptr&lt;BaseState&gt;(new StateMissionComplete);
   };
 
- private:
+private:
   StateMissionComplete() = default;
 };
 
-
 class StateContext
 {
 public:
-  StateContext()
-    : state_(StateMoveForward::create())
-    , light_color_(TrafficLight::UNKNOWN)
-  {};
+  StateContext() : state_(StateMoveForward::create()), light_color_(TrafficLight::UNKNOWN){};
   void setState(std::unique_ptr&lt;BaseState&gt; newState)
   {
     state_ = std::move(newState);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.cpp" added_lines="4" deleted_lines="7">
				<diff>@@ -34,9 +34,7 @@
 namespace state_machine
 {
 // Constructor
-StateMachineNode::StateMachineNode()
-  : private_nh_("~")
-  , sc_()
+StateMachineNode::StateMachineNode() : private_nh_("~"), sc_()
 {
   initForROS();
 }
@@ -49,14 +47,14 @@ StateMachineNode::~StateMachineNode()
 void StateMachineNode::initForROS()
 {
   // ros parameter settings
-  private_nh_.param&lt;bool&gt;("is_manual_light_detection",is_manual_light_detection_,true);
+  private_nh_.param&lt;bool&gt;("is_manual_light_detection", is_manual_light_detection_, true);
 
   // setup subscriber
   sub1_ = nh_.subscribe("light_color", 100, &amp;StateMachineNode::callbackFromLightColor, this);
   sub2_ = nh_.subscribe("light_color_managed", 100, &amp;StateMachineNode::callbackFromLightColorManaged, this);
 
   // setup publisher
-  pub_ = nh_.advertise&lt;std_msgs::String&gt;("state",10);
+  pub_ = nh_.advertise&lt;std_msgs::String&gt;("state", 10);
 }
 
 void StateMachineNode::run()
@@ -88,7 +86,6 @@ void StateMachineNode::callbackFromLightColor(const runtime_manager::traffic_lig
   sc_.setLightColor(msg-&gt;traffic_light);
   sc_.update();
   publish();
-
 }
 
 void StateMachineNode::callbackFromLightColorManaged(const runtime_manager::traffic_lightConstPtr&amp; msg)
@@ -102,4 +99,4 @@ void StateMachineNode::callbackFromLightColorManaged(const runtime_manager::traf
   publish();
 }
 
-} //state_machine
+}  // state_machine
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.h" added_lines="2" deleted_lines="4">
				<diff>@@ -45,14 +45,12 @@ namespace state_machine
 class StateMachineNode
 {
 public:
-
   StateMachineNode();
   ~StateMachineNode();
 
   void run();
 
 private:
-
   // handle
   ros::NodeHandle nh_;
   ros::NodeHandle private_nh_;
@@ -64,7 +62,7 @@ private:
   ros::Publisher pub_;
 
   // subscriber
-  ros::Subscriber sub1_,sub2_;
+  ros::Subscriber sub1_, sub2_;
 
   // variables
   bool is_manual_light_detection_;
@@ -79,5 +77,5 @@ private:
   // functions
   void publish() const;
 };
-} // state_machine
+}  // state_machine
 #endif  // STATE_MACHINE_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_node.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -38,6 +38,6 @@ int main(int argc, char **argv)
   ros::init(argc, argv, "state_machine");
   state_machine::StateMachineNode smn;
   smn.run();
- 
+
   return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ce0ae33cef24adfcf5751c91c9365e4e897b24c7" author="h_ohta">
		<msg>Lock MISSION_COMPLETE as 100 in enum class</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" added_lines="1" deleted_lines="1">
				<diff>@@ -41,8 +41,8 @@ enum class StateList : int32_t
   MOVE_FORWARD,
   TRAFFIC_LIGHT_STOP,
   LANE_CHANGE,
-  MISSION_COMPLETE,
 
+  MISSION_COMPLETE = 100,
   EMERGENCY = -1,
 };
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="33584305d0eabf64bc3e5dac144f1f19b181293a" author="h_ohta">
		<msg>Add new state "STOP_SIGN_STOP"</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" added_lines="5" deleted_lines="0">
				<diff>@@ -51,4 +51,9 @@ void StateLaneChange::update(StateContext *context)
   // lane change
 }
 
+void StateStopSignStop::update(StateContext *context)
+{
+  // stop sign stop
+}
+
 }  // state_machine
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" added_lines="23" deleted_lines="0">
				<diff>@@ -41,6 +41,7 @@ enum class StateList : int32_t
   MOVE_FORWARD,
   TRAFFIC_LIGHT_STOP,
   LANE_CHANGE,
+  STOP_SIGN_STOP,
 
   MISSION_COMPLETE = 100,
   EMERGENCY = -1,
@@ -153,6 +154,28 @@ private:
   StateLaneChange() = default;
 };
 
+// State : STOP_SIGN_STOP
+class StateStopSignStop : public BaseState
+{
+ public:
+  void update(StateContext *context) override;
+  int32_t getStateName() override
+  {
+    return enumToInteger(StateList::STOP_SIGN_STOP);
+  }
+  std::unique_ptr&lt;std::string&gt; getStateNameString() override
+  {
+    return std::unique_ptr&lt;std::string&gt;(new std::string("STOP_SIGN_STOP"));
+  }
+  static std::unique_ptr&lt;BaseState&gt; create()
+  {
+    return std::unique_ptr&lt;BaseState&gt;(new StateStopSignStop);
+  };
+
+ private:
+  StateStopSignStop() = default;
+};
+
 // State : EMERGENCY
 class StateEmergency : public BaseState
 {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ef8a93a32e265846977b4b3a8dd15e07381b30a5" author="h_ohta">
		<msg>right and left lane index is -1 when closest waypoint on each lane is -1</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="11" deleted_lines="0">
				<diff>@@ -109,6 +109,17 @@ void LaneSelectNode::processing()
     return;
   }
 
+  if(right_lane_idx_ != -1)
+  {
+    if (std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_)) == -1)
+      right_lane_idx_ = -1;
+  }
+  if(left_lane_idx_ != -1)
+  {
+    if (std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_)) == -1)
+      left_lane_idx_ = -1;
+  }
+
   ROS_INFO("current_lane_idx: %d", current_lane_idx_);
   ROS_INFO("right_lane_idx: %d", right_lane_idx_);
   ROS_INFO("left_lane_idx: %d", left_lane_idx_);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="55adb891d7c47da6dd82af14d8e173f7cb91ad75" author="h_ohta">
		<msg>Publish change flag as topic, which keeps the same value until lane change is finished</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="104" deleted_lines="17">
				<diff>@@ -43,6 +43,7 @@ LaneSelectNode::LaneSelectNode()
   , is_current_pose_subscribed_(false)
   , is_current_velocity_subscribed_(false)
   , last_change_time_(ros::Time::now())
+  , current_change_flag_(ChangeFlag::unknown)
   , current_state_("LANE_CHANGE")
   , LANE_SIZE_(1.0)
 {
@@ -64,6 +65,7 @@ void LaneSelectNode::initForROS()
   // setup publisher
   pub1_ = nh_.advertise&lt;waypoint_follower::lane&gt;("base_waypoints", 10);
   pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 10);
+  pub3_ = nh_.advertise&lt;std_msgs::Int32&gt;("change_flag", 10);
   vis_pub1_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("lane_select_marker", 10);
 
   // get from rosparam
@@ -125,21 +127,61 @@ void LaneSelectNode::processing()
   ROS_INFO("left_lane_idx: %d", left_lane_idx_);
   ROS_INFO("current change_flag: %d", enumToInteger(std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_))));
 
-  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
-  // if change flag of current_lane is left or right, lane change
+  updateChangeFlag();
   if (current_state_ == "LANE_CHANGE")
+    changeLane();
+
+  publish();
+  publishVisualizer();
+}
+
+
+
+void LaneSelectNode::updateChangeFlag()
+{
+  if(current_change_flag_ == ChangeFlag::unknown || current_change_flag_ == ChangeFlag::straight)
   {
-    if (change_flag == ChangeFlag::right &amp;&amp; right_lane_idx_ != -1)
-      if (std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_)) != -1)
-        changeLane();
+    current_change_flag_ = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
 
-    if (change_flag == ChangeFlag::left &amp;&amp; left_lane_idx_ != -1)
-      if (std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_)) != -1)
-        changeLane();
+    if ((current_change_flag_ == ChangeFlag::left &amp;&amp; left_lane_idx_ == -1) ||
+        (current_change_flag_ == ChangeFlag::right &amp;&amp; right_lane_idx_ == -1))
+      current_change_flag_ = ChangeFlag::straight;
+    return;
   }
 
-  publish();
-  publishVisualizer();
+  // if current change flag is right or left
+  double a, b, c;
+
+  if (std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)) == 0 ||
+                  std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)) ==
+                    static_cast&lt;int32_t&gt;(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.size()))
+  {
+    geometry_msgs::Point &amp;closest_p = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_))
+                                          .waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)))
+                                          .pose.pose.position;
+    geometry_msgs::Point &amp;front_of_closest_p = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_))
+                                                   .waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)) - 1)
+                                                   .pose.pose.position;
+    getLinearEquation(front_of_closest_p, closest_p, &amp;a, &amp;b, &amp;c);
+  }
+  else
+  {
+    geometry_msgs::Point &amp;closest_p = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_))
+                                          .waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)) - 1)
+                                          .pose.pose.position;
+    geometry_msgs::Point &amp;front_of_closest_p = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_))
+                                                   .waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)))
+                                                   .pose.pose.position;
+    getLinearEquation(front_of_closest_p, closest_p, &amp;a, &amp;b, &amp;c);
+  }
+  geometry_msgs::Point &amp;current_point = current_pose_.pose.position;
+  double d = getDistanceBetweenLineAndPoint(current_point, a, b, c);
+
+  double threshold = 1.0;
+  if(d &lt; threshold)
+  {
+    current_change_flag_ = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
+  }
 }
 
 void LaneSelectNode::changeLane()
@@ -149,14 +191,27 @@ void LaneSelectNode::changeLane()
   if (dt &lt; lane_change_interval_)
     return;
 
-  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
-  current_lane_idx_ = change_flag == ChangeFlag::right ? right_lane_idx_ : change_flag == ChangeFlag::left
-                                                                               ? left_lane_idx_
-                                                                               : current_lane_idx_;
-
-  findNeighborLanes();
+  if (current_change_flag_ == ChangeFlag::right &amp;&amp; right_lane_idx_ != -1)
+  {
+    if (std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_)) != -1)
+    {
+      current_lane_idx_ = right_lane_idx_;
+      findNeighborLanes();
+      last_change_time_ = ros::Time::now();
+      return;
+    }
+  }
 
-  last_change_time_ = ros::Time::now();
+  if (current_change_flag_ == ChangeFlag::left &amp;&amp; left_lane_idx_ != -1)
+  {
+    if (std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_)) != -1)
+    {
+      current_lane_idx_ = left_lane_idx_;
+      findNeighborLanes();
+      last_change_time_ = ros::Time::now();
+      return;
+    }
+  }
 }
 
 bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
@@ -571,6 +626,10 @@ void LaneSelectNode::publish()
   closest_waypoint.data = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
   pub2_.publish(closest_waypoint);
 
+  std_msgs::Int32 change_flag;
+  change_flag.data = enumToInteger(current_change_flag_);
+  pub3_.publish(change_flag);
+
   is_current_pose_subscribed_ = false;
   is_current_velocity_subscribed_ = false;
 }
@@ -738,4 +797,32 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
   return found_number;
 }
 
+// let the linear equation be "ax + by + c = 0"
+// if there are two points (x1,y1) , (x2,y2), a = "y2-y1, b = "(-1) * x2 - x1" ,c = "(-1) * (y2-y1)x1 + (x2-x1)y1"
+bool getLinearEquation(geometry_msgs::Point start, geometry_msgs::Point end, double *a, double *b, double *c)
+{
+  //(x1, y1) = (start.x, star.y), (x2, y2) = (end.x, end.y)
+  double sub_x = fabs(start.x - end.x);
+  double sub_y = fabs(start.y - end.y);
+  double error = pow(10, -5);  // 0.00001
+
+  if (sub_x &lt; error &amp;&amp; sub_y &lt; error)
+  {
+    ROS_INFO("two points are the same point!!");
+    return false;
+  }
+
+  *a = end.y - start.y;
+  *b = (-1) * (end.x - start.x);
+  *c = (-1) * (end.y - start.y) * start.x + (end.x - start.x) * start.y;
+
+  return true;
+}
+double getDistanceBetweenLineAndPoint(geometry_msgs::Point point, double a, double b, double c)
+{
+  double d = fabs(a * point.x + b * point.y + c) / sqrt(pow(a, 2) + pow(b, 2));
+
+  return d;
+}
+
 }  // lane_planner
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="5" deleted_lines="1">
				<diff>@@ -78,7 +78,7 @@ private:
   ros::NodeHandle private_nh_;
 
   // publisher
-  ros::Publisher pub1_, pub2_;
+  ros::Publisher pub1_, pub2_, pub3_;
   ros::Publisher vis_pub1_;
 
   // subscriber
@@ -92,6 +92,7 @@ private:
                                                                                      // change_flag
   bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_;
   ros::Time last_change_time_;
+  ChangeFlag current_change_flag_;
 
   // rosparam
   double distance_threshold_;
@@ -130,6 +131,7 @@ private:
   void findCurrentLane();
   void findNeighborLanes();
   void changeLane();
+  void updateChangeFlag();
 };
 
 int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
@@ -143,5 +145,7 @@ void convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point,
 std::unique_ptr&lt;geometry_msgs::Point&gt; convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point,
                                                                       const geometry_msgs::Pose &amp;pose);
 double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry_msgs::Pose &amp;current_pose);
+bool getLinearEquation(geometry_msgs::Point start, geometry_msgs::Point end, double *a, double *b, double *c);
+double getDistanceBetweenLineAndPoint(geometry_msgs::Point point, double sa, double b, double c);
 }
 #endif  // LANE_SELECT_CORE_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b8e0a88418bffba34b8772a5f592b311867c69e6" author="h_ohta">
		<msg>Delete needless comment</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" added_lines="0" deleted_lines="2">
				<diff>@@ -34,7 +34,6 @@ namespace state_machine
 {
 void StateTrafficLightStop::update(StateContext *context)
 {
-  // if light is GREEN, Go to MOVE_FORWARD
   if (context-&gt;getLightColor() == TrafficLight::GREEN)
     context-&gt;setState(StateMoveForward::create());
 }
@@ -48,7 +47,6 @@ void StateMoveForward::update(StateContext *context)
 
 void StateLaneChange::update(StateContext *context)
 {
-  // lane change
 }
 
 void StateStopSignStop::update(StateContext *context)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="609dfed71d37173f80ca24de4142e6d4c196b2de" author="h_ohta">
		<msg>Subscribe change flag</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" added_lines="2" deleted_lines="1">
				<diff>@@ -223,7 +223,8 @@ private:
 class StateContext
 {
 public:
-  StateContext() : state_(StateMoveForward::create()), light_color_(TrafficLight::UNKNOWN){};
+  StateContext()
+    : state_(StateMoveForward::create()), light_color_(TrafficLight::UNKNOWN), change_flag_(ChangeFlag::unknown){};
   void setState(std::unique_ptr&lt;BaseState&gt; newState)
   {
     state_ = std::move(newState);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.cpp" added_lines="9" deleted_lines="0">
				<diff>@@ -53,6 +53,8 @@ void StateMachineNode::initForROS()
   sub1_ = nh_.subscribe("light_color", 100, &amp;StateMachineNode::callbackFromLightColor, this);
   sub2_ = nh_.subscribe("light_color_managed", 100, &amp;StateMachineNode::callbackFromLightColorManaged, this);
 
+  sub3_ = nh_.subscribe("change_flag", 100, &amp;StateMachineNode::callbackFromChangeFlag, this);
+
   // setup publisher
   pub_ = nh_.advertise&lt;std_msgs::String&gt;("state", 10);
 }
@@ -99,4 +101,11 @@ void StateMachineNode::callbackFromLightColorManaged(const runtime_manager::traf
   publish();
 }
 
+void StateMachineNode::callbackFromChangeFlag(const std_msgs::Int32ConstPtr&amp; msg)
+{
+  ROS_INFO("Change flag callback");
+  sc_.setChangeFlag(msg-&gt;data);
+  sc_.update();
+  publish();
+}
 }  // state_machine
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.h" added_lines="2" deleted_lines="1">
				<diff>@@ -62,7 +62,7 @@ private:
   ros::Publisher pub_;
 
   // subscriber
-  ros::Subscriber sub1_, sub2_;
+  ros::Subscriber sub1_, sub2_, sub3_;
 
   // variables
   bool is_manual_light_detection_;
@@ -70,6 +70,7 @@ private:
   // callbacks
   void callbackFromLightColor(const runtime_manager::traffic_lightConstPtr &amp;msg);
   void callbackFromLightColorManaged(const runtime_manager::traffic_lightConstPtr &amp;msg);
+  void callbackFromChangeFlag(const std_msgs::Int32ConstPtr&amp; msg);
 
   // initializer
   void initForROS();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="99cfa4b36aa5c247690be3f6f64192f4d44f8647" author="h_ohta">
		<msg>Boot lane change state</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" added_lines="5" deleted_lines="0">
				<diff>@@ -43,10 +43,15 @@ void StateMoveForward::update(StateContext *context)
   // if light is RED, Go to TRAFFIC_LIGHT_STOP
   if (context-&gt;getLightColor() == TrafficLight::RED)
     context-&gt;setState(StateTrafficLightStop::create());
+
+  if(context-&gt;getChangeFlag() != ChangeFlag::straight)
+    context-&gt;setState(StateLaneChange::create());
 }
 
 void StateLaneChange::update(StateContext *context)
 {
+  if(context-&gt;getChangeFlag() != ChangeFlag::right || context-&gt;getChangeFlag() != ChangeFlag::left)
+    context-&gt;setState(StateMoveForward::create());
 }
 
 void StateStopSignStop::update(StateContext *context)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" added_lines="4" deleted_lines="0">
				<diff>@@ -246,6 +246,10 @@ public:
   {
     return light_color_;
   }
+  ChangeFlag getChangeFlag() const
+  {
+    return change_flag_;
+  }
   int32_t getCurrentState() const
   {
     return state_-&gt;getStateName();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="971a4bdea4e3a427f5285278aabbbed2f9f3a120" author="h_ohta">
		<msg>Subscribe state</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="12" deleted_lines="1">
				<diff>@@ -42,9 +42,10 @@ LaneSelectNode::LaneSelectNode()
   , is_lane_array_subscribed_(false)
   , is_current_pose_subscribed_(false)
   , is_current_velocity_subscribed_(false)
+  , is_current_state_subscribed_(false)
   , last_change_time_(ros::Time::now())
   , current_change_flag_(ChangeFlag::unknown)
-  , current_state_("LANE_CHANGE")
+  , current_state_("UNKNOWN")
   , LANE_SIZE_(1.0)
 {
   initForROS();
@@ -61,6 +62,7 @@ void LaneSelectNode::initForROS()
   sub1_ = nh_.subscribe("traffic_waypoints_array", 100, &amp;LaneSelectNode::callbackFromLaneArray, this);
   sub2_ = nh_.subscribe("current_pose", 100, &amp;LaneSelectNode::callbackFromPoseStamped, this);
   sub3_ = nh_.subscribe("current_velocity", 100, &amp;LaneSelectNode::callbackFromTwistStamped, this);
+  sub4_ = nh_.subscribe("state", 100, &amp;LaneSelectNode::callbackFromState, this);
 
   // setup publisher
   pub1_ = nh_.advertise&lt;waypoint_follower::lane&gt;("base_waypoints", 10);
@@ -632,6 +634,7 @@ void LaneSelectNode::publish()
 
   is_current_pose_subscribed_ = false;
   is_current_velocity_subscribed_ = false;
+  is_current_state_subscribed_ = false;
 }
 
 void LaneSelectNode::callbackFromLaneArray(const waypoint_follower::LaneArrayConstPtr &amp;msg)
@@ -669,6 +672,14 @@ void LaneSelectNode::callbackFromTwistStamped(const geometry_msgs::TwistStampedC
   processing();
 }
 
+void LaneSelectNode::callbackFromState(const std_msgs::StringConstPtr &amp;msg)
+{
+  current_state_ = msg-&gt;data;
+  is_current_state_subscribed_ = true;
+
+  processing();
+}
+
 void LaneSelectNode::run()
 {
   ros::spin();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="4" deleted_lines="2">
				<diff>@@ -37,6 +37,7 @@
 #include &lt;tf/transform_datatypes.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
+#include &lt;std_msgs/String.h&gt;
 
 // C++ includes
 #include &lt;iostream&gt;
@@ -82,7 +83,7 @@ private:
   ros::Publisher vis_pub1_;
 
   // subscriber
-  ros::Subscriber sub1_, sub2_, sub3_;
+  ros::Subscriber sub1_, sub2_, sub3_, sub4_;
 
   // variables
   int32_t current_lane_idx_;  // the index of the lane we are driving
@@ -90,7 +91,7 @@ private:
   int32_t left_lane_idx_;
   std::vector&lt;std::tuple&lt;waypoint_follower::lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint,
                                                                                      // change_flag
-  bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_;
+  bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_, is_current_state_subscribed_;
   ros::Time last_change_time_;
   ChangeFlag current_change_flag_;
 
@@ -107,6 +108,7 @@ private:
   void callbackFromLaneArray(const waypoint_follower::LaneArrayConstPtr &amp;msg);
   void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr &amp;msg);
+  void callbackFromState(const std_msgs::StringConstPtr &amp;msg);
 
   // initializer
   void initForROS();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0fb9f63a1023b40eed964f023fa668dbc2c6a341" author="h_ohta">
		<msg>Delete needless comment</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -40,7 +40,6 @@ void StateTrafficLightStop::update(StateContext *context)
 
 void StateMoveForward::update(StateContext *context)
 {
-  // if light is RED, Go to TRAFFIC_LIGHT_STOP
   if (context-&gt;getLightColor() == TrafficLight::RED)
     context-&gt;setState(StateTrafficLightStop::create());
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2fc6e912f5e2994d8662f2db6033320451892afa" author="h_ohta">
		<msg>Fix if condition</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -43,13 +43,13 @@ void StateMoveForward::update(StateContext *context)
   if (context-&gt;getLightColor() == TrafficLight::RED)
     context-&gt;setState(StateTrafficLightStop::create());
 
-  if(context-&gt;getChangeFlag() != ChangeFlag::straight)
+  if(context-&gt;getChangeFlag() == ChangeFlag::right || context-&gt;getChangeFlag() == ChangeFlag::left)
     context-&gt;setState(StateLaneChange::create());
 }
 
 void StateLaneChange::update(StateContext *context)
 {
-  if(context-&gt;getChangeFlag() != ChangeFlag::right || context-&gt;getChangeFlag() != ChangeFlag::left)
+  if(context-&gt;getChangeFlag() == ChangeFlag::straight)
     context-&gt;setState(StateMoveForward::create());
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4e98ae5394c78e39ddb48b02b7aed4719232968f" author="h_ohta">
		<msg>Update comment</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -103,7 +103,7 @@ void StateMachineNode::callbackFromLightColorManaged(const runtime_manager::traf
 
 void StateMachineNode::callbackFromChangeFlag(const std_msgs::Int32ConstPtr&amp; msg)
 {
-  ROS_INFO("Change flag callback");
+  ROS_INFO("Change flag callback: %d",msg-&gt;data);
   sc_.setChangeFlag(msg-&gt;data);
   sc_.update();
   publish();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8b74b89f0b2ea506182a3767b9b25388a17a7397" author="h_ohta">
		<msg>Add update function</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" added_lines="12" deleted_lines="0">
				<diff>@@ -58,4 +58,16 @@ void StateStopSignStop::update(StateContext *context)
   // stop sign stop
 }
 
+void StateMissionComplete::update(StateContext *context)
+{
+  // Mission complete
+}
+
+void StateEmergency::update(StateContext *context)
+{
+  // Emergency
+}
+
+
+
 }  // state_machine
\ No newline at end of file
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7904b89ab734922fe9d59dfcebbb974553a8ea49" author="h_ohta">
		<msg>Create new state "OBSTACLE_AVOIDANCE"</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" added_lines="5" deleted_lines="0">
				<diff>@@ -68,6 +68,11 @@ void StateEmergency::update(StateContext *context)
   // Emergency
 }
 
+void StateObstacleAvoidance::update(StateContext *context)
+{
+  // Obstacle Avoidance
+}
+
 
 
 }  // state_machine
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" added_lines="23" deleted_lines="0">
				<diff>@@ -42,6 +42,7 @@ enum class StateList : int32_t
   TRAFFIC_LIGHT_STOP,
   LANE_CHANGE,
   STOP_SIGN_STOP,
+  OBSTACLE_AVOIDANCE,
 
   MISSION_COMPLETE = 100,
   EMERGENCY = -1,
@@ -176,6 +177,28 @@ class StateStopSignStop : public BaseState
   StateStopSignStop() = default;
 };
 
+// State : Obstacle Avoidance
+class StateObstacleAvoidance : public BaseState
+{
+ public:
+  void update(StateContext *context) override;
+  int32_t getStateName() override
+  {
+    return enumToInteger(StateList::STOP_SIGN_STOP);
+  }
+  std::unique_ptr&lt;std::string&gt; getStateNameString() override
+  {
+    return std::unique_ptr&lt;std::string&gt;(new std::string("OBSTACLE_AVOIDANCE"));
+  }
+  static std::unique_ptr&lt;BaseState&gt; create()
+  {
+    return std::unique_ptr&lt;BaseState&gt;(new StateObstacleAvoidance);
+  };
+
+ private:
+  StateObstacleAvoidance() = default;
+};
+
 // State : EMERGENCY
 class StateEmergency : public BaseState
 {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="763bafdccf7d5f9d9ed0db13d8570d86ef3ff1f9" author="h_ohta">
		<msg>Fix bug for searching closest wapoint</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="8" deleted_lines="9">
				<diff>@@ -220,8 +220,8 @@ bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
 {
   for (auto &amp;el : tuple_vec_)
   {
-    std::get&lt;1&gt;(el) =
-        getClosestWaypointNumber(std::get&lt;0&gt;(el), current_pose_.pose, current_velocity_.twist, std::get&lt;1&gt;(el));
+    std::get&lt;1&gt;(el) = getClosestWaypointNumber(std::get&lt;0&gt;(el), current_pose_.pose, current_velocity_.twist,
+                                               std::get&lt;1&gt;(el), distance_threshold_);
     ROS_INFO("closest: %d", std::get&lt;1&gt;(el));
 
     std::get&lt;2&gt;(el) = (std::get&lt;1&gt;(el) != -1)
@@ -735,7 +735,8 @@ double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry
 
 // get closest waypoint from current pose
 int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
-                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number)
+                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number,
+                                 const double distance_threshold)
 {
   if (current_lane.waypoints.empty())
     return -1;
@@ -761,18 +762,16 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
   }
   else
   {
-    double ratio = 3;
-    double minimum_dt = 2.0;
-    double dt = current_velocity.linear.x * ratio &gt; minimum_dt ? current_velocity.linear.x * ratio : minimum_dt;
-
-    if (dt &lt;
+    if (distance_threshold &lt;
         getTwoDimensionalDistance(current_lane.waypoints.at(previous_number).pose.pose.position, current_pose.position))
     {
       ROS_WARN("Current_pose is far away from previous closest waypoint. Initilized...");
       return -1;
     }
 
-    idx_vec.reserve(static_cast&lt;uint32_t&gt;(dt));
+    double ratio = 3;
+    double minimum_dt = 2.0;
+    double dt = current_velocity.linear.x * ratio &gt; minimum_dt ? current_velocity.linear.x * ratio : minimum_dt;
 
     auto range_max = static_cast&lt;uint32_t&gt;(previous_number + dt) &lt; current_lane.waypoints.size()
                          ? static_cast&lt;uint32_t&gt;(previous_number + dt)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="1" deleted_lines="1">
				<diff>@@ -137,7 +137,7 @@ private:
 };
 
 int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
-                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number);
+                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number, const double distance_threshold);
 
 double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geometry_msgs::Point &amp;target2);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5dd1622a78eea9c5c5f2a9dadf295180360cfedf" author="yukikitsukawa">
		<msg>Catch exception for nmea sentence</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_core.cpp" new_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_core.cpp" added_lines="37" deleted_lines="14">
				<diff>@@ -110,29 +110,52 @@ void Nmea2TFPoseNode::callbackFromNmeaSentence(const nmea_msgs::Sentence::ConstP
   // QQ
   if (nmea.at(0).compare(0, 2, "QQ") == 0)
   {
-    orientation_time_ = stod(nmea.at(3));
-    roll_ = stod(nmea.at(4)) * M_PI / 180.;
-    pitch_ = -1 * stod(nmea.at(5)) * M_PI / 180.;
-    yaw_ = -1 * stod(nmea.at(6)) * M_PI / 180. + M_PI / 2;
-    orientation_stamp_ = msg-&gt;header.stamp;
+    try
+    {
+      orientation_time_ = stod(nmea.at(3));
+      roll_ = stod(nmea.at(4)) * M_PI / 180.;
+      pitch_ = -1 * stod(nmea.at(5)) * M_PI / 180.;
+      yaw_ = -1 * stod(nmea.at(6)) * M_PI / 180. + M_PI / 2;
+      orientation_stamp_ = msg-&gt;header.stamp;
+    }
+    catch (const std::exception &amp;e)
+    {
+      ROS_WARN_STREAM("$QQ*** is invalid : " &lt;&lt; e.what());
+    }
+    ROS_INFO("QQ is subscribed.");
   }
 
   if (nmea.at(0) == "$PASHR")
   {
-    orientation_time_ = stod(nmea.at(1));
-    roll_ = stod(nmea.at(4)) * M_PI / 180.;
-    pitch_ = -1 * stod(nmea.at(5)) * M_PI / 180.;
-    yaw_ = -1 * stod(nmea.at(2)) * M_PI / 180. + M_PI / 2;
+    try
+    {
+      orientation_time_ = stod(nmea.at(1));
+      roll_ = stod(nmea.at(4)) * M_PI / 180.;
+      pitch_ = -1 * stod(nmea.at(5)) * M_PI / 180.;
+      yaw_ = -1 * stod(nmea.at(2)) * M_PI / 180. + M_PI / 2;
+    }
+    catch (const std::exception &amp;e)
+    {
+      ROS_WARN_STREAM("$PASHR is invalid : " &lt;&lt; e.what());
+    }
   }
 
   // GGA
   if (nmea.at(0).compare(3, 3, "GGA") == 0)
   {
-    position_time_ = stod(nmea.at(1));
-    double lat = stod(nmea.at(2));
-    double lon = stod(nmea.at(4));
-    double h = stod(nmea.at(9));
-    geo_.set_llh_nmea_degrees(lat, lon, h);
+    try
+    {
+      position_time_ = stod(nmea.at(1));
+      double lat = stod(nmea.at(2));
+      double lon = stod(nmea.at(4));
+      double h = stod(nmea.at(9));
+      geo_.set_llh_nmea_degrees(lat, lon, h);
+    }
+    catch (const std::exception &amp;e)
+    {
+      ROS_WARN_STREAM("$**GGA is invalid : " &lt;&lt; e.what());
+    }
+
   }
 
   double timeout = 10.0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="20b48a298885503e70a19a880aac08e50fd58f69" author="TomohitoAndo">
		<msg>Avoid sudden aceleration after changing waypoints</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -437,6 +437,7 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
 
     // change waypoints to stop by the stop_waypoint
     vs_path-&gt;changeWaypoints(stop_waypoint, closest_waypoint, vs_info.getDeceleration());
+    vs_path-&gt;avoidSuddenAceleration(vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;avoidSuddenBraking(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
     temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="4" deleted_lines="1">
				<diff>@@ -120,9 +120,12 @@ void VelocitySetPath::avoidSuddenAceleration(double deceleration, int closest_wa
   {
     if (!checkWaypoint(closest_waypoint + i, "avoidSuddenAceleration"))
       return;
+
     changed_vel = sqrt(temp1 + temp2 * (double)(i + 1)) + velocity_offset;
-    if (changed_vel &gt; prev_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x)
+
+    if (changed_vel &gt; new_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x)
       return;
+
     new_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x = changed_vel;
   }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b6a3635016dcefadef81792000e1779f1a3956db" author="TomohitoAndo">
		<msg>Use integer size with temporal waypoints</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -55,7 +55,6 @@ void VelocitySetPath::setTemporalWaypoints(int temporal_waypoints_size, int clos
 {
   if (closest_waypoint &lt; 0)
     return;
-  int size = temporal_waypoints_size / calcInterval(0, 1);
 
   temporal_waypoints_.waypoints.clear();
   temporal_waypoints_.header = new_waypoints_.header;
@@ -67,10 +66,11 @@ void VelocitySetPath::setTemporalWaypoints(int temporal_waypoints_size, int clos
   current_point.twist = new_waypoints_.waypoints[closest_waypoint].twist;
   current_point.dtlane = new_waypoints_.waypoints[closest_waypoint].dtlane;
   temporal_waypoints_.waypoints.push_back(current_point);
-  for (int i = 0; i &lt; size; i++)
+  for (int i = 0; i &lt; temporal_waypoints_size; i++)
   {
-    if (closest_waypoint + i &gt;= getPrevWaypointsSize())
+    if (closest_waypoint + i &gt;= getNewWaypoints().waypoints.size())
       return;
+
     temporal_waypoints_.waypoints.push_back(new_waypoints_.waypoints[closest_waypoint + i]);
   }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bc8583aa14a7ee4370bde905f8586a9ff01e1fe7" author="TomohitoAndo">
		<msg>improve acceleration</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="7" deleted_lines="6">
				<diff>@@ -34,6 +34,8 @@ VelocitySetPath::VelocitySetPath()
   : set_path_(false),
     current_vel_(0)
 {
+  ros::NodeHandle private_nh_("~");
+  private_nh_.param&lt;double&gt;("velocity_offset", velocity_offset_, 1.2);
 }
 
 VelocitySetPath::~VelocitySetPath()
@@ -110,19 +112,18 @@ void VelocitySetPath::setDeceleration(double deceleration, int closest_waypoint)
 
 void VelocitySetPath::avoidSuddenAceleration(double deceleration, int closest_waypoint)
 {
-  double changed_vel;
-  double interval = calcInterval(0, 1);
-  double temp1 = current_vel_ * current_vel_;
-  double temp2 = 2 * deceleration * interval;
-  double velocity_offset = 1.389; // m/s
+  double square_current_vel = current_vel_ * current_vel_;
 
   for (int i = 0;; i++)
   {
     if (!checkWaypoint(closest_waypoint + i, "avoidSuddenAceleration"))
       return;
 
-    changed_vel = sqrt(temp1 + temp2 * (double)(i + 1)) + velocity_offset;
+    // accelerate with constant acceleration
+    // v = root((v0)^2 + 2ax)
+    double changed_vel = std::sqrt(square_current_vel + 2 * deceleration * calcInterval(closest_waypoint, closest_waypoint + i)) + velocity_offset_;
 
+    // Don't exceed original velocity
     if (changed_vel &gt; new_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x)
       return;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" added_lines="3" deleted_lines="0">
				<diff>@@ -41,6 +41,9 @@ class VelocitySetPath
   bool set_path_;
   double current_vel_;
 
+  // ROS param
+  double velocity_offset_; // m/s
+
   bool checkWaypoint(int num, const char *name) const;
 
  public:
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="732cb241c3b81f3a116c3e20dd99f2c514d2e316" author="TomohitoAndo">
		<msg>Fix typo</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -437,7 +437,7 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
 
     // change waypoints to stop by the stop_waypoint
     vs_path-&gt;changeWaypoints(stop_waypoint, closest_waypoint, vs_info.getDeceleration());
-    vs_path-&gt;avoidSuddenAceleration(vs_info.getDeceleration(), closest_waypoint);
+    vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;avoidSuddenBraking(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
     temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
@@ -450,9 +450,9 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
     temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
   }
   else
-  {  // ACELERATE or KEEP
+  {  // ACCELERATE or KEEP
     vs_path-&gt;initializeNewWaypoints();
-    vs_path-&gt;avoidSuddenAceleration(vs_info.getDeceleration(), closest_waypoint);
+    vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;avoidSuddenBraking(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
     temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -110,13 +110,13 @@ void VelocitySetPath::setDeceleration(double deceleration, int closest_waypoint)
   return;
 }
 
-void VelocitySetPath::avoidSuddenAceleration(double deceleration, int closest_waypoint)
+void VelocitySetPath::avoidSuddenAcceleration(double deceleration, int closest_waypoint)
 {
   double square_current_vel = current_vel_ * current_vel_;
 
   for (int i = 0;; i++)
   {
-    if (!checkWaypoint(closest_waypoint + i, "avoidSuddenAceleration"))
+    if (!checkWaypoint(closest_waypoint + i, "avoidSuddenAcceleration"))
       return;
 
     // accelerate with constant acceleration
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" added_lines="1" deleted_lines="1">
				<diff>@@ -52,7 +52,7 @@ class VelocitySetPath
 
   void changeWaypoints(int stop_waypoint, int closest_waypoint, double deceleration);
   void avoidSuddenBraking(double velocity_change_limit, double deceleration, int closest_waypoint);
-  void avoidSuddenAceleration(double decelerationint, int closest_waypoint);
+  void avoidSuddenAcceleration(double decelerationint, int closest_waypoint);
   void setDeceleration(double deceleration, int closest_waypoint);
   void setTemporalWaypoints(int temporal_waypoints_size, int closest_waypoint, geometry_msgs::PoseStamped control_pose);
   void initializeNewWaypoints();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="30ca9141f5d9b42371a2381aea9029b2c64a6034" author="TomohitoAndo">
		<msg>Add get size method for new waypoints</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -70,7 +70,7 @@ void VelocitySetPath::setTemporalWaypoints(int temporal_waypoints_size, int clos
   temporal_waypoints_.waypoints.push_back(current_point);
   for (int i = 0; i &lt; temporal_waypoints_size; i++)
   {
-    if (closest_waypoint + i &gt;= getNewWaypoints().waypoints.size())
+    if (closest_waypoint + i &gt;= getNewWaypointsSize())
       return;
 
     temporal_waypoints_.waypoints.push_back(new_waypoints_.waypoints[closest_waypoint + i]);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" added_lines="5" deleted_lines="0">
				<diff>@@ -92,6 +92,11 @@ class VelocitySetPath
   {
     return prev_waypoints_.waypoints.size();
   }  
+
+  int getNewWaypointsSize() const
+  {
+    return new_waypoints_.waypoints.size();
+  }
 };
 
 #endif // VELOCITY_SET_PATH_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f73f7bc441653597739c69b1f3b96dd06fbae82d" author="TomohitoAndo">
		<msg>Remove unnecessary calcalation</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="15" deleted_lines="46">
				<diff>@@ -135,61 +135,30 @@ void VelocitySetPath::avoidSuddenAcceleration(double deceleration, int closest_w
 
 void VelocitySetPath::avoidSuddenBraking(double velocity_change_limit, double deceleration, int closest_waypoint)
 {
-  int i = 0;
-  int fill_in_zero = 20;
-  int fill_in_vel = 15;
-  int examin_range = 1;  // need to change according to waypoint interval?
-  int num;
-  double interval = calcInterval(0, 1);
-  double changed_vel;
-
-  for (int j = -1; j &lt; examin_range; j++)
-  {
-    if (!checkWaypoint(closest_waypoint + j, "avoidSuddenBraking"))
-      return;
-    if (new_waypoints_.waypoints[closest_waypoint + j].twist.twist.linear.x &lt;
-        current_vel_ - velocity_change_limit)  // we must change waypoints
-      break;
-    if (j == examin_range - 1)  // we don't have to change waypoints
-      return;
-  }
+  if (closest_waypoint &lt; 0)
+    return;
 
-  ROS_INFO("avoid sudden braking!!");
+  // not avoid braking
+  if (current_vel_ - new_waypoints_.waypoints[closest_waypoint].twist.twist.linear.x &lt; velocity_change_limit)
+    return;
 
-  // fill in waypoints velocity behind vehicle
-  for (num = closest_waypoint - 1; fill_in_vel &gt; 0; fill_in_vel--)
-  {
-    if (!checkWaypoint(num - fill_in_vel, "avoidSuddenBraking"))
-      continue;
-    new_waypoints_.waypoints[num - fill_in_vel].twist.twist.linear.x = current_vel_;
-  }
+  //std::cout &lt;&lt; "avoid sudden braking!" &lt;&lt; std::endl;
 
-  // decelerate gradually
-  double temp1 = (current_vel_ - velocity_change_limit + 1.389) * (current_vel_ - velocity_change_limit + 1.389);
-  double temp2 = 2 * deceleration * interval;
-  for (num = closest_waypoint - 1;; num++)
+  double square_vel = (current_vel_ - velocity_change_limit) * (current_vel_ - velocity_change_limit);
+  for (int i = 0;; i++)
   {
-    if (num &gt;= getPrevWaypointsSize())
+    if (!checkWaypoint(i, "avoidSuddenBraking"))
       return;
-    if (!checkWaypoint(num, "avoidSuddenBraking"))
-      continue;
-    changed_vel = temp1 - temp2 * (double)i;  // sqrt(v^2 - 2*a*x)
-    if (changed_vel &lt;= 0)
-      break;
-    new_waypoints_.waypoints[num].twist.twist.linear.x = sqrt(changed_vel);
 
-    i++;
-  }
+    // sqrt(v^2 - 2ax)
+    double changed_vel = square_vel - 2 * deceleration * calcInterval(closest_waypoint, closest_waypoint + i);
 
-  for (int j = 0; j &lt; fill_in_zero; j++)
-  {
-    if (!checkWaypoint(num + j, "avoidSuddenBraking"))
-      continue;
-    new_waypoints_.waypoints[num + j].twist.twist.linear.x = 0.0;
-  }
+    if (changed_vel &lt; 0)
+      break;
 
+    new_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x = std::sqrt(changed_vel);
+  }
 
-  return;
 }
 
 void VelocitySetPath::changeWaypoints(int stop_waypoint, int closest_waypoint, double deceleration)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9dfdc1df160f364e6c3dda4dd26df1edf28459e9" author="TomohitoAndo">
		<msg>Avoid sudden acceleration after changing waypoints for deceleration</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -446,6 +446,7 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
   {  // DECELERATE for obstacles
     vs_path-&gt;initializeNewWaypoints();
     vs_path-&gt;setDeceleration(vs_info.getDeceleration(), closest_waypoint);
+    vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
     temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="23c15a3692751c2862bb2ddab1c204f199a85b3a" author="TomohitoAndo">
		<msg>Decide the number of zero velocity from the position of the obstacle</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -436,7 +436,7 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
     int stop_waypoint = obstacle_waypoint - vs_info.getStopDistance() / vs_path-&gt;calcInterval(0, 1);
 
     // change waypoints to stop by the stop_waypoint
-    vs_path-&gt;changeWaypoints(stop_waypoint, closest_waypoint, vs_info.getDeceleration());
+    vs_path-&gt;changeWaypoints(stop_waypoint, obstacle_waypoint, closest_waypoint, vs_info.getDeceleration());
     vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;avoidSuddenBraking(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="17" deleted_lines="25">
				<diff>@@ -161,45 +161,37 @@ void VelocitySetPath::avoidSuddenBraking(double velocity_change_limit, double de
 
 }
 
-void VelocitySetPath::changeWaypoints(int stop_waypoint, int closest_waypoint, double deceleration)
+void VelocitySetPath::changeWaypoints(int stop_waypoint, int obstacle_waypoint, int closest_waypoint, double deceleration)
 {
-  int i = 0;
-  int close_waypoint_threshold = 4;
-  int fill_in_zero = 20;
-  double changed_vel;
-  double interval = calcInterval(0, 1);
-
-  // change waypoints to decelerate
-  for (int num = stop_waypoint; num &gt; closest_waypoint - close_waypoint_threshold; num--)
+  if (closest_waypoint &lt; 0)
+    return;
+
+  // decelerate with constant deceleration
+  for (int index = stop_waypoint; index &gt;= closest_waypoint; index--)
   {
-    if (!checkWaypoint(num, "changeWaypoints"))
+    if (!checkWaypoint(index, __FUNCTION__))
       continue;
 
-    changed_vel = sqrt(2.0 * deceleration * (interval * i));  // sqrt(2*a*x)
+    // v = (v0)^2 + 2ax, and v0 = 0
+    double changed_vel = std::sqrt(2.0 * deceleration * calcInterval(index, stop_waypoint));
 
-    waypoint_follower::waypoint initial_waypoint = prev_waypoints_.waypoints[num];
-    if (changed_vel &gt; initial_waypoint.twist.twist.linear.x)
-    {  // avoid acceleration
-      new_waypoints_.waypoints[num].twist.twist.linear.x = initial_waypoint.twist.twist.linear.x;
+    double prev_vel = prev_waypoints_.waypoints[index].twist.twist.linear.x;
+    if (changed_vel &gt; prev_vel)
+    {
+      new_waypoints_.waypoints[index].twist.twist.linear.x = prev_vel;
     }
     else
     {
-      new_waypoints_.waypoints[num].twist.twist.linear.x = changed_vel;
+      new_waypoints_.waypoints[index].twist.twist.linear.x = changed_vel;
     }
-
-    i++;
   }
 
-  // fill in 0
-  for (int j = 1; j &lt; fill_in_zero; j++)
+  // fill velocity with 0 for stopping
+  for (int i = stop_waypoint; i &lt;= obstacle_waypoint; i++)
   {
-    if (!checkWaypoint(stop_waypoint + j, "changeWaypoints"))
-      continue;
-    new_waypoints_.waypoints[stop_waypoint + j].twist.twist.linear.x = 0.0;
+    new_waypoints_.waypoints[i].twist.twist.linear.x = 0;
   }
 
-
-  return;
 }
 
 void VelocitySetPath::initializeNewWaypoints()
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" added_lines="1" deleted_lines="1">
				<diff>@@ -50,7 +50,7 @@ class VelocitySetPath
   VelocitySetPath();
   ~VelocitySetPath();
 
-  void changeWaypoints(int stop_waypoint, int closest_waypoint, double deceleration);
+  void changeWaypoints(int stop_waypoint, int obstacle_waypoint, int closest_waypoint, double deceleration);
   void avoidSuddenBraking(double velocity_change_limit, double deceleration, int closest_waypoint);
   void avoidSuddenAcceleration(double decelerationint, int closest_waypoint);
   void setDeceleration(double deceleration, int closest_waypoint);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="de0b202cff0c77e333b9c6e9126c09a92b4e774c" author="TomohitoAndo">
		<msg>Make function names more concise</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -436,7 +436,7 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
     int stop_waypoint = obstacle_waypoint - vs_info.getStopDistance() / vs_path-&gt;calcInterval(0, 1);
 
     // change waypoints to stop by the stop_waypoint
-    vs_path-&gt;changeWaypoints(stop_waypoint, obstacle_waypoint, closest_waypoint, vs_info.getDeceleration());
+    vs_path-&gt;changeWaypointsForStopping(stop_waypoint, obstacle_waypoint, closest_waypoint, vs_info.getDeceleration());
     vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;avoidSuddenBraking(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
@@ -445,7 +445,7 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
   else if (detection_result == DECELERATE)
   {  // DECELERATE for obstacles
     vs_path-&gt;initializeNewWaypoints();
-    vs_path-&gt;setDeceleration(vs_info.getDeceleration(), closest_waypoint);
+    vs_path-&gt;changeWaypointsForDeceleration(vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
     temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -79,7 +79,7 @@ void VelocitySetPath::setTemporalWaypoints(int temporal_waypoints_size, int clos
   return;
 }
 
-void VelocitySetPath::setDeceleration(double deceleration, int closest_waypoint)
+void VelocitySetPath::changeWaypointsForDeceleration(double deceleration, int closest_waypoint)
 {
   int velocity_change_range = 5;
   double intervel = calcInterval(0, 1);
@@ -116,7 +116,7 @@ void VelocitySetPath::avoidSuddenAcceleration(double deceleration, int closest_w
 
   for (int i = 0;; i++)
   {
-    if (!checkWaypoint(closest_waypoint + i, "avoidSuddenAcceleration"))
+    if (!checkWaypoint(closest_waypoint + i, __FUNCTION__))
       return;
 
     // accelerate with constant acceleration
@@ -133,7 +133,7 @@ void VelocitySetPath::avoidSuddenAcceleration(double deceleration, int closest_w
   return;
 }
 
-void VelocitySetPath::avoidSuddenBraking(double velocity_change_limit, double deceleration, int closest_waypoint)
+void VelocitySetPath::avoidSuddenDeceleration(double velocity_change_limit, double deceleration, int closest_waypoint)
 {
   if (closest_waypoint &lt; 0)
     return;
@@ -147,7 +147,7 @@ void VelocitySetPath::avoidSuddenBraking(double velocity_change_limit, double de
   double square_vel = (current_vel_ - velocity_change_limit) * (current_vel_ - velocity_change_limit);
   for (int i = 0;; i++)
   {
-    if (!checkWaypoint(i, "avoidSuddenBraking"))
+    if (!checkWaypoint(i, __FUNCTION__))
       return;
 
     // sqrt(v^2 - 2ax)
@@ -161,7 +161,7 @@ void VelocitySetPath::avoidSuddenBraking(double velocity_change_limit, double de
 
 }
 
-void VelocitySetPath::changeWaypoints(int stop_waypoint, int obstacle_waypoint, int closest_waypoint, double deceleration)
+void VelocitySetPath::changeWaypointsForStopping(int stop_waypoint, int obstacle_waypoint, int closest_waypoint, double deceleration)
 {
   if (closest_waypoint &lt; 0)
     return;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" added_lines="3" deleted_lines="3">
				<diff>@@ -50,10 +50,10 @@ class VelocitySetPath
   VelocitySetPath();
   ~VelocitySetPath();
 
-  void changeWaypoints(int stop_waypoint, int obstacle_waypoint, int closest_waypoint, double deceleration);
-  void avoidSuddenBraking(double velocity_change_limit, double deceleration, int closest_waypoint);
+  void changeWaypointsForStopping(int stop_waypoint, int obstacle_waypoint, int closest_waypoint, double deceleration);
+  void avoidSuddenDeceleration(double velocity_change_limit, double deceleration, int closest_waypoint);
   void avoidSuddenAcceleration(double decelerationint, int closest_waypoint);
-  void setDeceleration(double deceleration, int closest_waypoint);
+  void changeWaypointsForDeceleration(double deceleration, int closest_waypoint);
   void setTemporalWaypoints(int temporal_waypoints_size, int closest_waypoint, geometry_msgs::PoseStamped control_pose);
   void initializeNewWaypoints();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ef3667ceea26f5005b0ad1d0edc8748acda1d4b5" author="Yukihiro Saito">
		<msg>Tuned gazebo parameter</msg>
		<modified_files>
			<file old_path="ros\src\system\gazebo\point_cloud_converter\src\converter.cpp" new_path="ros\src\system\gazebo\point_cloud_converter\src\converter.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -144,7 +144,7 @@ class PointCloudConverter
       sensor_msgs::PointCloud2 filtered_output;
       for (pcl::PointCloud&lt;pcl::PointXYZ&gt;::const_iterator item = pcl_output.begin(); item != pcl_output.end(); item++)
       {
-        if (item-&gt;x * item-&gt;x + item-&gt;y * item-&gt;y + item-&gt;z * item-&gt;z &gt; 10000.0)
+        if (item-&gt;x * item-&gt;x + item-&gt;y * item-&gt;y + item-&gt;z * item-&gt;z &gt; 100.0*100.0)
 	  continue;
         pcl::PointXYZI sampled_p;
         sampled_p.x = item-&gt;x;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="92d88d47c2dc560f9c1800db92398b6c8ad8963d" author="TomohitoAndo">
		<msg>improve deceleratiion for obstacles</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="4" deleted_lines="3">
				<diff>@@ -438,14 +438,15 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
     // change waypoints to stop by the stop_waypoint
     vs_path-&gt;changeWaypointsForStopping(stop_waypoint, obstacle_waypoint, closest_waypoint, vs_info.getDeceleration());
     vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
-    vs_path-&gt;avoidSuddenBraking(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
+    vs_path-&gt;avoidSuddenDeceleration(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
     temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
   }
   else if (detection_result == DECELERATE)
   {  // DECELERATE for obstacles
     vs_path-&gt;initializeNewWaypoints();
-    vs_path-&gt;changeWaypointsForDeceleration(vs_info.getDeceleration(), closest_waypoint);
+    vs_path-&gt;changeWaypointsForDeceleration(vs_info.getDeceleration(), closest_waypoint, obstacle_waypoint);
+    vs_path-&gt;avoidSuddenDeceleration(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
     temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
@@ -454,7 +455,7 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
   {  // ACCELERATE or KEEP
     vs_path-&gt;initializeNewWaypoints();
     vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
-    vs_path-&gt;avoidSuddenBraking(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
+    vs_path-&gt;avoidSuddenDeceleration(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
     temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
   }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="16" deleted_lines="19">
				<diff>@@ -36,6 +36,7 @@ VelocitySetPath::VelocitySetPath()
 {
   ros::NodeHandle private_nh_("~");
   private_nh_.param&lt;double&gt;("velocity_offset", velocity_offset_, 1.2);
+  private_nh_.param&lt;double&gt;("decelerate_vel_min", decelerate_vel_min_, 1.3);
 }
 
 VelocitySetPath::~VelocitySetPath()
@@ -79,35 +80,31 @@ void VelocitySetPath::setTemporalWaypoints(int temporal_waypoints_size, int clos
   return;
 }
 
-void VelocitySetPath::changeWaypointsForDeceleration(double deceleration, int closest_waypoint)
+void VelocitySetPath::changeWaypointsForDeceleration(double deceleration, int closest_waypoint, int obstacle_waypoint)
 {
-  int velocity_change_range = 5;
-  double intervel = calcInterval(0, 1);
-  double temp1 = current_vel_ * current_vel_;
-  double temp2 = 2 * deceleration * intervel;
-  double deceleration_minimum = kmph2mps(4.0);
+  double square_vel_min = decelerate_vel_min_ * decelerate_vel_min_;
+  int extra = 4; // for safety
 
-  for (int i = 0; i &lt; velocity_change_range; i++)
+  // decelerate with constant deceleration
+  for (int index = obstacle_waypoint + extra; index &gt;= closest_waypoint; index--)
   {
-    if (!checkWaypoint(closest_waypoint + i, "setDeceleration"))
+    if (!checkWaypoint(index, __FUNCTION__))
       continue;
-    double waypoint_velocity = prev_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x;
-    double changed_vel = temp1 - temp2;
-    if (changed_vel &lt; 0)
+
+    // v = sqrt( (v0)^2 + 2ax )
+    double changed_vel = std::sqrt(square_vel_min + 2.0 * deceleration * calcInterval(index, obstacle_waypoint));
+
+    double prev_vel = prev_waypoints_.waypoints[index].twist.twist.linear.x;
+    if (changed_vel &gt; prev_vel)
     {
-      changed_vel = deceleration_minimum * deceleration_minimum;
+      new_waypoints_.waypoints[index].twist.twist.linear.x = prev_vel;
     }
-    if (sqrt(changed_vel) &gt; waypoint_velocity || deceleration_minimum &gt; waypoint_velocity)
-      continue;
-    if (sqrt(changed_vel) &lt; deceleration_minimum)
+    else
     {
-      new_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x = deceleration_minimum;
-      continue;
+      new_waypoints_.waypoints[index].twist.twist.linear.x = changed_vel;
     }
-    new_waypoints_.waypoints[closest_waypoint + i].twist.twist.linear.x = sqrt(changed_vel);
   }
 
-  return;
 }
 
 void VelocitySetPath::avoidSuddenAcceleration(double deceleration, int closest_waypoint)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" added_lines="2" deleted_lines="1">
				<diff>@@ -43,6 +43,7 @@ class VelocitySetPath
 
   // ROS param
   double velocity_offset_; // m/s
+  double decelerate_vel_min_; // m/s
 
   bool checkWaypoint(int num, const char *name) const;
 
@@ -53,7 +54,7 @@ class VelocitySetPath
   void changeWaypointsForStopping(int stop_waypoint, int obstacle_waypoint, int closest_waypoint, double deceleration);
   void avoidSuddenDeceleration(double velocity_change_limit, double deceleration, int closest_waypoint);
   void avoidSuddenAcceleration(double decelerationint, int closest_waypoint);
-  void changeWaypointsForDeceleration(double deceleration, int closest_waypoint);
+  void changeWaypointsForDeceleration(double deceleration, int closest_waypoint, int obstacle_waypoint);
   void setTemporalWaypoints(int temporal_waypoints_size, int closest_waypoint, geometry_msgs::PoseStamped control_pose);
   void initializeNewWaypoints();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7028d758c04a28b7a43fa7b8718b8eb54c8baf18" author="TomohitoAndo">
		<msg>Use enum class instead of enum</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -290,7 +290,7 @@ geometry_msgs::Point ObstaclePoints::getObstaclePoint(const EControl &amp;kind) cons
 {
   geometry_msgs::Point point;
 
-  if (kind == STOP)
+  if (kind == EControl::STOP)
   {
     for (const auto &amp;p : stop_points_)
     {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" added_lines="1" deleted_lines="1">
				<diff>@@ -13,7 +13,7 @@
 
 #include "waypoint_follower/libwaypoint_follower.h"
 
-enum EControl
+enum class EControl
 {
   KEEP = -1,
   STOP = 1,
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="19" deleted_lines="19">
				<diff>@@ -55,7 +55,7 @@ void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points
   marker.action = visualization_msgs::Marker::ADD;
 
   static geometry_msgs::Point prev_obstacle_point;
-  if (kind == STOP || kind == DECELERATE)
+  if (kind == EControl::STOP || kind == EControl::DECELERATE)
   {
     marker.pose.position = obstacle_points.getObstaclePoint(kind);
     prev_obstacle_point = marker.pose.position;
@@ -71,7 +71,7 @@ void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points
   marker.scale.y = 1.0;
   marker.scale.z = 2.0;
   marker.color.a = 0.7;
-  if (kind == STOP)
+  if (kind == EControl::STOP)
   {
     marker.color.r = 1.0;
     marker.color.g = 0.0;
@@ -188,7 +188,7 @@ void displayDetectionRange(const waypoint_follower::lane&amp; lane, const CrossWalk&amp;
   marker_array.markers.push_back(crosswalk_marker);
   marker_array.markers.push_back(waypoint_marker_stop);
   marker_array.markers.push_back(waypoint_marker_decelerate);
-  if (kind == STOP)
+  if (kind == EControl::STOP)
     marker_array.markers.push_back(stop_line);
   detection_range_pub.publish(marker_array);
   marker_array.markers.clear();
@@ -222,13 +222,13 @@ EControl crossWalkDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const
 	obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
       }
       if (stop_count &gt; points_threshold)
-        return STOP;
+        return EControl::STOP;
     }
 
     obstacle_points-&gt;clearStopPoints();
   }
 
-  return KEEP;  // find no obstacles
+  return EControl::KEEP;  // find no obstacles
 }
 
 int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, double stop_range, double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose, ObstaclePoints* obstacle_points)
@@ -245,7 +245,7 @@ int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int c
     if (i == crosswalk.getDetectionWaypoint())
     {
       // found an obstacle in the cross walk
-      if (crossWalkDetection(points, crosswalk, localizer_pose, points_threshold, obstacle_points) == STOP)
+      if (crossWalkDetection(points, crosswalk, localizer_pose, points_threshold, obstacle_points) == EControl::STOP)
       {
         stop_obstacle_waypoint = i;
         break;
@@ -343,7 +343,7 @@ int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const
 EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo&amp; vs_info, int* obstacle_waypoint, ObstaclePoints* obstacle_points)
 {
   if (points.empty() == true || closest_waypoint &lt; 0)
-    return KEEP;
+    return EControl::KEEP;
 
   int stop_obstacle_waypoint = detectStopObstacle(points, closest_waypoint, lane, crosswalk, vs_info.getStopRange(), vs_info.getPointsThreshold(), vs_info.getLocalizerPose(), obstacle_points);
 
@@ -351,7 +351,7 @@ EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int
   if (vs_info.getDecelerationRange() &lt; 0.01)
   {
     *obstacle_waypoint = stop_obstacle_waypoint;
-    return stop_obstacle_waypoint &lt; 0 ? KEEP : STOP;
+    return stop_obstacle_waypoint &lt; 0 ? EControl::KEEP : EControl::STOP;
   }
 
   int decelerate_obstacle_waypoint = detectDecelerateObstacle(points, closest_waypoint, lane, vs_info.getStopRange(), vs_info.getDecelerationRange(), vs_info.getPointsThreshold(), vs_info.getLocalizerPose(), obstacle_points);
@@ -360,14 +360,14 @@ EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int
   if (stop_obstacle_waypoint &lt; 0)
   {
     *obstacle_waypoint  = decelerate_obstacle_waypoint;
-    return decelerate_obstacle_waypoint &lt; 0 ? KEEP : DECELERATE;
+    return decelerate_obstacle_waypoint &lt; 0 ? EControl::KEEP : EControl::DECELERATE;
   }
 
   // stop obstacle was found but decelerate obstacle was not found
   if (decelerate_obstacle_waypoint &lt; 0)
   {
     *obstacle_waypoint = stop_obstacle_waypoint;
-    return STOP;
+    return EControl::STOP;
   }
 
   // about 5.0 meter
@@ -378,12 +378,12 @@ EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int
   if (stop_obstacle_waypoint - decelerate_obstacle_waypoint &gt; stop_decelerate_threshold)
   {
     *obstacle_waypoint = decelerate_obstacle_waypoint;
-    return DECELERATE;
+    return EControl::DECELERATE;
   }
   else
   {
     *obstacle_waypoint = stop_obstacle_waypoint;
-    return STOP;
+    return EControl::STOP;
   }
 
 }
@@ -395,11 +395,11 @@ EControl obstacleDetection(int closest_waypoint, const waypoint_follower::lane&amp;
   displayDetectionRange(lane, crosswalk, closest_waypoint, detection_result, *obstacle_waypoint, vs_info.getStopRange(), vs_info.getDecelerationRange(), detection_range_pub);
 
   static int false_count = 0;
-  static EControl prev_detection = KEEP;
+  static EControl prev_detection = EControl::KEEP;
   static int prev_obstacle_waypoint = -1;
 
   // stop or decelerate because we found obstacles
-  if (detection_result == STOP || detection_result == DECELERATE)
+  if (detection_result == EControl::STOP || detection_result == EControl::DECELERATE)
   {
     displayObstacle(detection_result, obstacle_points, obstacle_pub);
       prev_detection = detection_result;
@@ -409,14 +409,14 @@ EControl obstacleDetection(int closest_waypoint, const waypoint_follower::lane&amp;
   }
 
   // there are no obstacles, but wait a little for safety
-  if (prev_detection == STOP || prev_detection == DECELERATE)
+  if (prev_detection == EControl::STOP || prev_detection == EControl::DECELERATE)
   {
     false_count++;
 
     if (false_count &lt; LOOP_RATE / 2)
     {
       *obstacle_waypoint = prev_obstacle_waypoint;
-      displayObstacle(OTHERS, obstacle_points, obstacle_pub);
+      displayObstacle(EControl::OTHERS, obstacle_points, obstacle_pub);
       return prev_detection;
     }
   }
@@ -424,13 +424,13 @@ EControl obstacleDetection(int closest_waypoint, const waypoint_follower::lane&amp;
   // there are no obstacles, so we move forward
   *obstacle_waypoint = -1;
   false_count = 0;
-  prev_detection = KEEP;
+  prev_detection = EControl::KEEP;
   return detection_result;
 }
 
 void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_result, int closest_waypoint, int obstacle_waypoint, const ros::Publisher&amp; temporal_waypoints_pub, VelocitySetPath* vs_path)
 {
-  if (detection_result == STOP)
+  if (detection_result == EControl::STOP)
   {  // STOP for obstacle
     // stop_waypoint is about g_stop_distance meter away from obstacles
     int stop_waypoint = obstacle_waypoint - vs_info.getStopDistance() / vs_path-&gt;calcInterval(0, 1);
@@ -442,7 +442,7 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
     temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
   }
-  else if (detection_result == DECELERATE)
+  else if (detection_result == EControl::DECELERATE)
   {  // DECELERATE for obstacles
     vs_path-&gt;initializeNewWaypoints();
     vs_path-&gt;changeWaypointsForDeceleration(vs_info.getDeceleration(), closest_waypoint, obstacle_waypoint);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fe9f61cda7999d646f8fa8e7c2e386fb7345de3f" author="h_ohta">
		<msg>Catch exception of invalid message</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_core.cpp" new_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_core.cpp" added_lines="18" deleted_lines="34">
				<diff>@@ -101,62 +101,46 @@ void Nmea2TFPoseNode::createOrientation()
   pitch_ = 0;
 }
 
-void Nmea2TFPoseNode::callbackFromNmeaSentence(const nmea_msgs::Sentence::ConstPtr &amp;msg)
+void Nmea2TFPoseNode::convert(std::vector&lt;std::string&gt; nmea, ros::Time current_stamp)
 {
-  current_time_ = msg-&gt;header.stamp;
-
-  std::vector&lt;std::string&gt; nmea = split(msg-&gt;sentence);
-
-  // QQ
-  if (nmea.at(0).compare(0, 2, "QQ") == 0)
+  try
   {
-    try
+    if (nmea.at(0).compare(0, 2, "QQ") == 0)
     {
       orientation_time_ = stod(nmea.at(3));
       roll_ = stod(nmea.at(4)) * M_PI / 180.;
       pitch_ = -1 * stod(nmea.at(5)) * M_PI / 180.;
       yaw_ = -1 * stod(nmea.at(6)) * M_PI / 180. + M_PI / 2;
-      orientation_stamp_ = msg-&gt;header.stamp;
-    }
-    catch (const std::exception &amp;e)
-    {
-      ROS_WARN_STREAM("$QQ*** is invalid : " &lt;&lt; e.what());
+      orientation_stamp_ = current_stamp;
+      ROS_INFO("QQ is subscribed.");
     }
-    ROS_INFO("QQ is subscribed.");
-  }
-
-  if (nmea.at(0) == "$PASHR")
-  {
-    try
+    else if (nmea.at(0) == "$PASHR")
     {
       orientation_time_ = stod(nmea.at(1));
       roll_ = stod(nmea.at(4)) * M_PI / 180.;
       pitch_ = -1 * stod(nmea.at(5)) * M_PI / 180.;
       yaw_ = -1 * stod(nmea.at(2)) * M_PI / 180. + M_PI / 2;
+      ROS_INFO("PASHR is subscribed.");
     }
-    catch (const std::exception &amp;e)
-    {
-      ROS_WARN_STREAM("$PASHR is invalid : " &lt;&lt; e.what());
-    }
-  }
-
-  // GGA
-  if (nmea.at(0).compare(3, 3, "GGA") == 0)
-  {
-    try
+    else if(nmea.at(0).compare(3, 3, "GGA") == 0)
     {
       position_time_ = stod(nmea.at(1));
       double lat = stod(nmea.at(2));
       double lon = stod(nmea.at(4));
       double h = stod(nmea.at(9));
       geo_.set_llh_nmea_degrees(lat, lon, h);
+      ROS_INFO("GGA is subscribed.");
     }
-    catch (const std::exception &amp;e)
-    {
-      ROS_WARN_STREAM("$**GGA is invalid : " &lt;&lt; e.what());
-    }
-
+  }catch (const std::exception &amp;e)
+  {
+    ROS_WARN_STREAM("Message is invalid : " &lt;&lt; e.what());
   }
+}
+
+void Nmea2TFPoseNode::callbackFromNmeaSentence(const nmea_msgs::Sentence::ConstPtr &amp;msg)
+{
+  current_time_ = msg-&gt;header.stamp;
+  convert(split(msg-&gt;sentence), msg-&gt;header.stamp);
 
   double timeout = 10.0;
   if (fabs(orientation_stamp_.toSec() - msg-&gt;header.stamp.toSec()) &gt; timeout)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_core.h" new_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_core.h" added_lines="1" deleted_lines="0">
				<diff>@@ -87,6 +87,7 @@ private:
   void publishPoseStamped();
   void publishTF();
   void createOrientation();
+  void convert(std::vector&lt;std::string&gt; nmea, ros::Time current_stamp);
 };
 
 std::vector&lt;std::string&gt; split(const std::string &amp;string);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="33b185a23f2e97862ef4f0a26f01ced3f7449503" author="Yukihiro Saito">
		<msg>Add param bar of twist filter node in runtime manager</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_filter\twist_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_filter\twist_filter.cpp" added_lines="6" deleted_lines="2">
				<diff>@@ -40,15 +40,19 @@ namespace {
 //Publisher
 ros::Publisher g_twist_pub;
 double g_lateral_accel_limit = 5.0;
+double g_lowpass_gain_linear_x = 0.0;
+double g_lowpass_gain_angular_z = 0.0;
 constexpr double RADIUS_MAX = 9e10;
 constexpr double ERROR = 1e-8;
-const double g_lowpass_gain_linear_x = 0.9;
-const double g_lowpass_gain_angular_z = 0.9;
 
 void configCallback(const runtime_manager::ConfigTwistFilterConstPtr &amp;config)
 {
   g_lateral_accel_limit = config-&gt;lateral_accel_limit;
   ROS_INFO("g_lateral_accel_limit = %lf",g_lateral_accel_limit);
+  g_lowpass_gain_linear_x = config-&gt;lowpass_gain_linear_x;
+  ROS_INFO("lowpass_gain_linear_x = %lf",g_lowpass_gain_linear_x);
+  g_lowpass_gain_angular_z = config-&gt;lowpass_gain_angular_z;
+  ROS_INFO("lowpass_gain_angular_z = %lf",g_lowpass_gain_angular_z);
 }
 
 void TwistCmdCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fa108c777813aa4d44fb75942d51742a569f2f66" author="h_ohta">
		<msg>Remove debug code</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="2" deleted_lines="11">
				<diff>@@ -741,7 +741,7 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
   if (current_lane.waypoints.empty())
     return -1;
 
-  // ROS_INFO("number: %d",previous_number);
+
   std::vector&lt;uint32_t&gt; idx_vec;
   // if previous number is -1, search closest waypoint from waypoints in front of current pose
   if (previous_number == -1)
@@ -752,12 +752,8 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
       geometry_msgs::Point converted_p;
       convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose, &amp;converted_p);
       double angle = getRelativeAngle(current_lane.waypoints.at(i).pose.pose, current_pose);
-      // ROS_INFO("angle: %lf",angle);
       if (converted_p.x &gt; 0 &amp;&amp; angle &lt; 90)
-      {
         idx_vec.push_back(i);
-        // ROS_INFO("input idx: %d",i);
-      }
     }
   }
   else
@@ -781,12 +777,9 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
       geometry_msgs::Point converted_p;
       convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose, &amp;converted_p);
       double angle = getRelativeAngle(current_lane.waypoints.at(i).pose.pose, current_pose);
-      // ROS_INFO("angle: %lf",angle);
       if (converted_p.x &gt; 0 &amp;&amp; angle &lt; 90)
-      {
         idx_vec.push_back(i);
-        // ROS_INFO("input idx: %d",i);
-      }
+
     }
   }
 
@@ -799,11 +792,9 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
   {
     double dt = getTwoDimensionalDistance(current_pose.position, current_lane.waypoints.at(el).pose.pose.position);
     dist_vec.push_back(dt);
-    // ROS_INFO("dt: %lf",dt);
   }
   std::vector&lt;double&gt;::iterator itr = std::min_element(dist_vec.begin(), dist_vec.end());
   int32_t found_number = idx_vec.at(static_cast&lt;uint32_t&gt;(std::distance(dist_vec.begin(), itr)));
-  // ROS_INFO("found number: %d",found_number);
   return found_number;
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="412860bf4523e3b1689a2f6083bca5aafa12da9f" author="h_ohta">
		<msg>Create new lane for lane change</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="253" deleted_lines="307">
				<diff>@@ -44,9 +44,7 @@ LaneSelectNode::LaneSelectNode()
   , is_current_velocity_subscribed_(false)
   , is_current_state_subscribed_(false)
   , last_change_time_(ros::Time::now())
-  , current_change_flag_(ChangeFlag::unknown)
   , current_state_("UNKNOWN")
-  , LANE_SIZE_(1.0)
 {
   initForROS();
 }
@@ -75,145 +73,210 @@ void LaneSelectNode::initForROS()
   private_nh_.param&lt;double&gt;("distance_threshold", distance_threshold_, double(3.0));
 }
 
-void LaneSelectNode::processing()
+bool LaneSelectNode::isAllTopicsSubscribed()
 {
   if (!is_current_pose_subscribed_ || !is_lane_array_subscribed_ || !is_current_velocity_subscribed_)
   {
     ROS_WARN("Necessary topics are not subscribed yet. Waiting...");
-    return;
+    return false;
   }
+  return true;
+}
+
+void LaneSelectNode::initForLaneSelect()
+{
+  if(!isAllTopicsSubscribed())
+    return;
 
   // search closest waypoint number for each lanes
   if (!getClosestWaypointNumberForEachLanes())
   {
-    current_lane_idx_ = -1;
-    right_lane_idx_ = -1;
-    left_lane_idx_ = -1;
-    publishVisualizer();
+    resetLaneIdx();
     return;
   }
 
-  // if current_lane_idx_ = -1, find the lane index which has the most closest waypoint
-  if (current_lane_idx_ == -1)
+  findCurrentLane();
+  findNeighborLanes();
+  updateChangeFlag();
+  createLaneForChange();
+  publish(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)), std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)),
+          std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)));
+  publishVisualizer();
+  return;
+}
+
+void LaneSelectNode::resetLaneIdx()
+{
+  current_lane_idx_ = -1;
+  right_lane_idx_ = -1;
+  left_lane_idx_ = -1;
+  publishVisualizer();
+}
+
+void LaneSelectNode::processing()
+{
+  if(!isAllTopicsSubscribed())
+    return;
+
+  // search closest waypoint number for each lanes
+  if (!getClosestWaypointNumberForEachLanes())
   {
-    findCurrentLane();
-    findNeighborLanes();
-    publish();
-    publishVisualizer();
+    resetLaneIdx();
     return;
   }
 
   // if closest waypoint on current lane is -1,
   if (std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)) == -1)
   {
-    current_lane_idx_ = -1;
-    right_lane_idx_ = -1;
-    left_lane_idx_ = -1;
-    publishVisualizer();
+    resetLaneIdx();
     return;
   }
 
-  if(right_lane_idx_ != -1)
-  {
-    if (std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_)) == -1)
-      right_lane_idx_ = -1;
-  }
-  if(left_lane_idx_ != -1)
-  {
-    if (std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_)) == -1)
-      left_lane_idx_ = -1;
-  }
+  if (right_lane_idx_ != -1 &amp;&amp; std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_)) == -1)
+    right_lane_idx_ = -1;
+
+  if (left_lane_idx_ != -1 &amp;&amp; std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_)) == -1)
+    left_lane_idx_ = -1;
 
   ROS_INFO("current_lane_idx: %d", current_lane_idx_);
   ROS_INFO("right_lane_idx: %d", right_lane_idx_);
   ROS_INFO("left_lane_idx: %d", left_lane_idx_);
-  ROS_INFO("current change_flag: %d", enumToInteger(std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_))));
 
-  updateChangeFlag();
   if (current_state_ == "LANE_CHANGE")
+  {
     changeLane();
-
-  publish();
+    std::get&lt;1&gt;(lane_for_change_) =
+        getClosestWaypointNumber(std::get&lt;0&gt;(lane_for_change_), current_pose_.pose, current_velocity_.twist,
+                                 std::get&lt;1&gt;(lane_for_change_), distance_threshold_);
+    std::get&lt;2&gt;(lane_for_change_) =
+        static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(lane_for_change_).waypoints.at(std::get&lt;1&gt;(lane_for_change_)).change_flag);
+    ROS_INFO("closest: %d", std::get&lt;1&gt;(lane_for_change_));
+    publish(std::get&lt;0&gt;(lane_for_change_), std::get&lt;1&gt;(lane_for_change_), std::get&lt;2&gt;(lane_for_change_));
+  }
+  else
+  {
+    updateChangeFlag();
+    createLaneForChange();
+    publish(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)), std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)),
+            std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)));
+  }
   publishVisualizer();
 }
 
+int32_t LaneSelectNode::getClosestLaneChangeWaypointNumber(const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps, int32_t cl_wp)
+{
 
+  for (uint32_t i = cl_wp; i &lt; wps.size(); i++)
+  {
+    if (static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::right ||
+      static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::left)
+    {
+      return i;
+    }
+  }
+  return -1;
+}
 
-void LaneSelectNode::updateChangeFlag()
+void LaneSelectNode::createLaneForChange()
 {
-  if(current_change_flag_ == ChangeFlag::unknown || current_change_flag_ == ChangeFlag::straight)
-  {
-    current_change_flag_ = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
+  std::get&lt;0&gt;(lane_for_change_).waypoints.clear();
+  std::get&lt;0&gt;(lane_for_change_).waypoints.shrink_to_fit();
+  std::get&lt;1&gt;(lane_for_change_) = -1;
 
-    if ((current_change_flag_ == ChangeFlag::left &amp;&amp; left_lane_idx_ == -1) ||
-        (current_change_flag_ == ChangeFlag::right &amp;&amp; right_lane_idx_ == -1))
-      current_change_flag_ = ChangeFlag::straight;
+  const waypoint_follower::lane &amp;cur_lane = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_));
+  const int32_t &amp;clst_wp = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
+
+  int32_t num_lane_change = getClosestLaneChangeWaypointNumber(cur_lane.waypoints, clst_wp);
+  ROS_INFO("num_lane_change: %d",num_lane_change);
+  if (num_lane_change &lt; 0 || num_lane_change &gt;= static_cast&lt;int32_t&gt;(cur_lane.waypoints.size()))
+  {
+    ROS_INFO("current lane doesn't have change flag");
     return;
   }
 
-  // if current change flag is right or left
-  double a, b, c;
-
-  if (std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)) == 0 ||
-                  std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)) ==
-                    static_cast&lt;int32_t&gt;(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.size()))
-  {
-    geometry_msgs::Point &amp;closest_p = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_))
-                                          .waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)))
-                                          .pose.pose.position;
-    geometry_msgs::Point &amp;front_of_closest_p = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_))
-                                                   .waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)) - 1)
-                                                   .pose.pose.position;
-    getLinearEquation(front_of_closest_p, closest_p, &amp;a, &amp;b, &amp;c);
+  double dt = getTwoDimensionalDistance(cur_lane.waypoints.at(num_lane_change).pose.pose.position, cur_lane.waypoints.at(clst_wp).pose.pose.position);
+  double ratio = 3.0;
+  double minimum = 5.0;
+  double dt_by_vel = current_velocity_.twist.linear.x * ratio &gt; minimum ? current_velocity_.twist.linear.x * ratio : minimum;
+  ROS_INFO("dt : %lf, dt_by_vel : %lf",dt,dt_by_vel);
+  waypoint_follower::lane &amp;nghbr_lane =
+      static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right
+          ? std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_))
+          : std::get&lt;0&gt;(tuple_vec_.at(left_lane_idx_));
+  const int32_t &amp;nghbr_clst_wp = static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right
+                                      ? std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_))
+                                      : std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_));
+
+  int32_t target_num = -1;
+  for (uint32_t i = nghbr_clst_wp; i &lt; nghbr_lane.waypoints.size(); i++)
+  {
+    if(i == nghbr_lane.waypoints.size() - 1 ||
+      dt + dt_by_vel &lt; getTwoDimensionalDistance(nghbr_lane.waypoints.at(nghbr_clst_wp).pose.pose.position,nghbr_lane.waypoints.at(i).pose.pose.position))
+    {
+      target_num = i;
+      break;
+    }
   }
-  else
+
+  ROS_INFO("target_num : %d", target_num);
+  if(target_num &lt; 0)
+    return;
+
+  std::get&lt;0&gt;(lane_for_change_).header.stamp = nghbr_lane.header.stamp;
+  std::vector&lt;waypoint_follower::waypoint&gt; hermite_wps = generateHermiteCurveForROS(
+      cur_lane.waypoints.at(num_lane_change).pose.pose, nghbr_lane.waypoints.at(target_num).pose.pose,
+      cur_lane.waypoints.at(num_lane_change).twist.twist.linear.x, 5);
+
+  for(auto &amp;&amp;el : hermite_wps)
+    el.change_flag = cur_lane.waypoints.at(num_lane_change).change_flag;
+
+  std::get&lt;0&gt;(lane_for_change_).waypoints.reserve(nghbr_lane.waypoints.size() + hermite_wps.size());
+  std::copy(hermite_wps.begin(), hermite_wps.end(), std::back_inserter(std::get&lt;0&gt;(lane_for_change_).waypoints));
+  auto itr = nghbr_lane.waypoints.begin();
+  std::advance(itr, target_num);
+  for(auto i = itr; i != nghbr_lane.waypoints.end();i++)
   {
-    geometry_msgs::Point &amp;closest_p = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_))
-                                          .waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)) - 1)
-                                          .pose.pose.position;
-    geometry_msgs::Point &amp;front_of_closest_p = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_))
-                                                   .waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)))
-                                                   .pose.pose.position;
-    getLinearEquation(front_of_closest_p, closest_p, &amp;a, &amp;b, &amp;c);
+    if(getTwoDimensionalDistance(itr-&gt;pose.pose.position,i-&gt;pose.pose.position) &lt; 10)
+      i-&gt;change_flag = enumToInteger(ChangeFlag::straight);
+    else
+      break;
   }
-  geometry_msgs::Point &amp;current_point = current_pose_.pose.position;
-  double d = getDistanceBetweenLineAndPoint(current_point, a, b, c);
+  std::copy(itr,nghbr_lane.waypoints.end(), std::back_inserter(std::get&lt;0&gt;(lane_for_change_).waypoints));
+}
 
-  double threshold = 1.0;
-  if(d &lt; threshold)
+void LaneSelectNode::updateChangeFlag()
+{
+  for (auto &amp;el : tuple_vec_)
   {
-    current_change_flag_ = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
+    std::get&lt;2&gt;(el) = (std::get&lt;1&gt;(el) != -1)
+                          ? static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(el).waypoints.at(std::get&lt;1&gt;(el)).change_flag)
+                          : ChangeFlag::unknown;
+
+    if(std::get&lt;2&gt;(el) == ChangeFlag::right &amp;&amp; right_lane_idx_ == -1)
+      std::get&lt;2&gt;(el) = ChangeFlag::unknown;
+    else if(std::get&lt;2&gt;(el) == ChangeFlag::left &amp;&amp; left_lane_idx_ == -1)
+      std::get&lt;2&gt;(el) = ChangeFlag::unknown;
+
+    ROS_INFO("change_flag: %d", enumToInteger(std::get&lt;2&gt;(el)));
   }
 }
 
 void LaneSelectNode::changeLane()
 {
-  ros::Time current_time = ros::Time::now();
-  double dt = (current_time - last_change_time_).toSec();
-  if (dt &lt; lane_change_interval_)
-    return;
-
-  if (current_change_flag_ == ChangeFlag::right &amp;&amp; right_lane_idx_ != -1)
+  if (std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)) == ChangeFlag::right &amp;&amp; right_lane_idx_ != -1 &amp;&amp;
+      std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_)) != -1)
   {
-    if (std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_)) != -1)
-    {
-      current_lane_idx_ = right_lane_idx_;
-      findNeighborLanes();
-      last_change_time_ = ros::Time::now();
-      return;
-    }
+    current_lane_idx_ = right_lane_idx_;
   }
-
-  if (current_change_flag_ == ChangeFlag::left &amp;&amp; left_lane_idx_ != -1)
+  else if (std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)) == ChangeFlag::left &amp;&amp; left_lane_idx_ != -1 &amp;&amp;
+           std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_)) != -1)
   {
-    if (std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_)) != -1)
-    {
-      current_lane_idx_ = left_lane_idx_;
-      findNeighborLanes();
-      last_change_time_ = ros::Time::now();
-      return;
-    }
+    current_lane_idx_ = left_lane_idx_;
   }
+
+  findNeighborLanes();
+  last_change_time_ = ros::Time::now();
+  return;
 }
 
 bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
@@ -223,11 +286,6 @@ bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
     std::get&lt;1&gt;(el) = getClosestWaypointNumber(std::get&lt;0&gt;(el), current_pose_.pose, current_velocity_.twist,
                                                std::get&lt;1&gt;(el), distance_threshold_);
     ROS_INFO("closest: %d", std::get&lt;1&gt;(el));
-
-    std::get&lt;2&gt;(el) = (std::get&lt;1&gt;(el) != -1)
-                          ? static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(el).waypoints.at(std::get&lt;1&gt;(el)).change_flag)
-                          : ChangeFlag::unknown;
-    ROS_INFO("change_flag: %d", enumToInteger(std::get&lt;2&gt;(el)));
   }
 
   // confirm if all closest waypoint numbers are -1. If so, output warning
@@ -316,51 +374,51 @@ void LaneSelectNode::findNeighborLanes()
   else
     right_lane_idx_ = -1;
 }
-
-std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneMarker()
+visualization_msgs::Marker LaneSelectNode::createCurrentLaneMarker()
 {
-  std::unique_ptr&lt;visualization_msgs::Marker&gt; marker(new visualization_msgs::Marker);
-  marker-&gt;header.frame_id = "map";
-  marker-&gt;header.stamp = ros::Time();
-  marker-&gt;ns = "current_lane_marker";
+  visualization_msgs::Marker marker;
+  marker.header.frame_id = "map";
+  marker.header.stamp = ros::Time();
+  marker.ns = "current_lane_marker";
 
   if (current_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
   {
-    marker-&gt;action = visualization_msgs::Marker::DELETE;
+    marker.action = visualization_msgs::Marker::DELETE;
     return marker;
   }
 
-  marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
-  marker-&gt;action = visualization_msgs::Marker::ADD;
-  marker-&gt;scale.x = 0.05;
+  marker.type = visualization_msgs::Marker::LINE_STRIP;
+  marker.action = visualization_msgs::Marker::ADD;
+  marker.scale.x = 0.05;
 
   std_msgs::ColorRGBA color_current;
   color_current.b = 1.0;
   color_current.g = 0.7;
   color_current.a = 1.0;
-  marker-&gt;color = color_current;
+  marker.color = color_current;
 
-  marker-&gt;points = *createRectangleFromWaypoints(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints, LANE_SIZE_);
+  for(const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints)
+    marker.points.push_back(em.pose.pose.position);
 
   return marker;
 }
 
-std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createRightLaneMarker()
+visualization_msgs::Marker LaneSelectNode::createRightLaneMarker()
 {
-  std::unique_ptr&lt;visualization_msgs::Marker&gt; marker(new visualization_msgs::Marker);
-  marker-&gt;header.frame_id = "map";
-  marker-&gt;header.stamp = ros::Time();
-  marker-&gt;ns = "right_lane_marker";
+  visualization_msgs::Marker marker;
+  marker.header.frame_id = "map";
+  marker.header.stamp = ros::Time();
+  marker.ns = "right_lane_marker";
 
   if (right_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
   {
-    marker-&gt;action = visualization_msgs::Marker::DELETE;
+    marker.action = visualization_msgs::Marker::DELETE;
     return marker;
   }
 
-  marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
-  marker-&gt;action = visualization_msgs::Marker::ADD;
-  marker-&gt;scale.x = 0.05;
+  marker.type = visualization_msgs::Marker::LINE_STRIP;
+  marker.action = visualization_msgs::Marker::ADD;
+  marker.scale.x = 0.05;
 
   std_msgs::ColorRGBA color_neighbor;
   color_neighbor.r = 0.5;
@@ -374,29 +432,30 @@ std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createRightLaneMarke
   color_neighbor_change.a = 1.0;
 
   const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
-  marker-&gt;color = change_flag == ChangeFlag::right ? color_neighbor_change : color_neighbor;
+  marker.color = change_flag == ChangeFlag::right ? color_neighbor_change : color_neighbor;
 
-  marker-&gt;points = *createRectangleFromWaypoints(std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_)).waypoints, LANE_SIZE_);
+  for(const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_)).waypoints)
+    marker.points.push_back(em.pose.pose.position);
 
   return marker;
 }
 
-std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createLeftLaneMarker()
+visualization_msgs::Marker LaneSelectNode::createLeftLaneMarker()
 {
-  std::unique_ptr&lt;visualization_msgs::Marker&gt; marker(new visualization_msgs::Marker);
-  marker-&gt;header.frame_id = "map";
-  marker-&gt;header.stamp = ros::Time();
-  marker-&gt;ns = "left_lane_marker";
+  visualization_msgs::Marker marker;
+  marker.header.frame_id = "map";
+  marker.header.stamp = ros::Time();
+  marker.ns = "left_lane_marker";
 
   if (left_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
   {
-    marker-&gt;action = visualization_msgs::Marker::DELETE;
+    marker.action = visualization_msgs::Marker::DELETE;
     return marker;
   }
 
-  marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
-  marker-&gt;action = visualization_msgs::Marker::ADD;
-  marker-&gt;scale.x = 0.05;
+  marker.type = visualization_msgs::Marker::LINE_STRIP;
+  marker.action = visualization_msgs::Marker::ADD;
+  marker.scale.x = 0.05;
 
   std_msgs::ColorRGBA color_neighbor;
   color_neighbor.r = 0.5;
@@ -410,194 +469,73 @@ std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createLeftLaneMarker
   color_neighbor_change.a = 1.0;
 
   const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
-  marker-&gt;color = change_flag == ChangeFlag::left ? color_neighbor_change : color_neighbor;
+  marker.color = change_flag == ChangeFlag::left ? color_neighbor_change : color_neighbor;
 
-  marker-&gt;points = *createRectangleFromWaypoints(std::get&lt;0&gt;(tuple_vec_.at(left_lane_idx_)).waypoints, LANE_SIZE_);
+  for(const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at((left_lane_idx_))).waypoints)
+    marker.points.push_back(em.pose.pose.position);
 
   return marker;
 }
 
-std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createClosestWaypointsMarker()
+visualization_msgs::Marker LaneSelectNode::createChangeLaneMarker()
 {
-  std::unique_ptr&lt;visualization_msgs::Marker&gt; marker(new visualization_msgs::Marker);
-  std_msgs::ColorRGBA color_closest_wp;
-  color_closest_wp.r = 1.0;
-  color_closest_wp.b = 1.0;
-  color_closest_wp.g = 1.0;
-  color_closest_wp.a = 1.0;
-
-  marker-&gt;header.frame_id = "map";
-  marker-&gt;header.stamp = ros::Time();
-  marker-&gt;ns = "closest_waypoints_marker";
-  marker-&gt;type = visualization_msgs::Marker::POINTS;
-  marker-&gt;action = visualization_msgs::Marker::ADD;
-  marker-&gt;scale.x = 0.5;
-  marker-&gt;color = color_closest_wp;
+  visualization_msgs::Marker marker;
+  marker.header.frame_id = "map";
+  marker.header.stamp = ros::Time();
+  marker.ns = "change_lane_marker";
 
-  marker-&gt;points.reserve(tuple_vec_.size());
-  for (uint32_t i = 0; i &lt; tuple_vec_.size(); i++)
+  if (std::get&lt;0&gt;(lane_for_change_).waypoints.empty())
   {
-    if (std::get&lt;1&gt;(tuple_vec_.at(i)) == -1)
-      continue;
-
-    marker-&gt;points.push_back(
-        std::get&lt;0&gt;(tuple_vec_.at(i)).waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(i))).pose.pose.position);
-  }
-
-  return marker;
-}
-
-std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneFlagMarker()
-{
-  std::unique_ptr&lt;visualization_msgs::Marker&gt; marker(new visualization_msgs::Marker);
-  marker-&gt;header.frame_id = "map";
-  marker-&gt;header.stamp = ros::Time();
-  marker-&gt;ns = "current_lane_flag_marker";
-
-  if (current_lane_idx_ == -1)
-  {
-    marker-&gt;action = visualization_msgs::Marker::DELETE;
+    marker.action = visualization_msgs::Marker::DELETE;
     return marker;
   }
 
-  std_msgs::ColorRGBA red;
-  red.r = 1.0;
-  red.a = 1.0;
+  marker.type = visualization_msgs::Marker::LINE_STRIP;
+  marker.action = visualization_msgs::Marker::ADD;
+  marker.scale.x = 0.05;
 
-  marker-&gt;type = visualization_msgs::Marker::LINE_STRIP;
-  marker-&gt;action = visualization_msgs::Marker::ADD;
-  marker-&gt;scale.x = 0.05;
-  marker-&gt;color = red;
+  std_msgs::ColorRGBA color;
+  color.r = 1.0;
+  color.a = 0.5;
 
-  const int32_t &amp;start = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
-  const size_t &amp;end = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.size();
-  const auto &amp;wps = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints;
-
-  std::vector&lt;waypoint_follower::waypoint&gt; wps_extracted;
-  for (uint32_t i = start; i &lt; end; i++)
-  {
-    if (static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::right)
-    {
-      wps_extracted.push_back(wps.at(i));
-      if (i == end - 1)
-        break;
-
-      if (static_cast&lt;ChangeFlag&gt;(wps.at(i + 1).change_flag) != ChangeFlag::right)
-        break;
-    }
-    else if (static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::left)
-    {
-      wps_extracted.push_back(wps.at(i));
-      if (i == end - 1)
-        break;
+  std_msgs::ColorRGBA color_current;
+  color_current.b = 1.0;
+  color_current.g = 0.7;
+  color_current.a = 1.0;
 
-      if (static_cast&lt;ChangeFlag&gt;(wps.at(i + 1).change_flag) != ChangeFlag::left)
-        break;
-    }
-  }
-
-  if (wps_extracted.empty())
-  {
-    marker-&gt;action = visualization_msgs::Marker::DELETE;
-    return marker;
-  }
-  marker-&gt;points = *createRectangleFromWaypoints(wps_extracted, LANE_SIZE_ * 0.8);
+  marker.color = current_state_ == "LANE_CHANGE" ? color_current : color;
+  for(const auto &amp;em : std::get&lt;0&gt;(lane_for_change_).waypoints)
+    marker.points.push_back(em.pose.pose.position);
 
   return marker;
 }
 
-std::unique_ptr&lt;std::vector&lt;geometry_msgs::Point&gt;&gt;
-LaneSelectNode::createRectangleFromWaypoints(const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps, const double &amp;width)
-{
-  std::vector&lt;std::tuple&lt;geometry_msgs::Point, geometry_msgs::Point&gt;&gt; vertex;
-
-  for (const auto &amp;el : wps)
-  {
-    geometry_msgs::Point relative_p1;
-    relative_p1.y = width / 2;
-    geometry_msgs::Point relative_p2;
-    relative_p2.y = -width / 2;
-    vertex.push_back(std::make_tuple(*convertPointIntoWorldCoordinate(relative_p1, el.pose.pose),
-                                     *convertPointIntoWorldCoordinate(relative_p2, el.pose.pose)));
-  }
-
-  std::unique_ptr&lt;std::vector&lt;geometry_msgs::Point&gt;&gt; rectangle(new std::vector&lt;geometry_msgs::Point&gt;);
-  for (const auto &amp;el : vertex)
-    rectangle-&gt;push_back(std::get&lt;0&gt;(el));
-
-  std::reverse(vertex.begin(), vertex.end());
-  for (const auto &amp;el : vertex)
-    rectangle-&gt;push_back(std::get&lt;1&gt;(el));
-  std::reverse(vertex.begin(), vertex.end());
-  rectangle-&gt;push_back(std::get&lt;0&gt;(vertex.at(0)));
-
-  return rectangle;
-}
-
-std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneFlagArrowMarker()
+visualization_msgs::Marker LaneSelectNode::createClosestWaypointsMarker()
 {
-  std::unique_ptr&lt;visualization_msgs::Marker&gt; marker(new visualization_msgs::Marker);
-
-  marker-&gt;header.frame_id = "map";
-  marker-&gt;header.stamp = ros::Time();
-  marker-&gt;ns = "current_lane_flag_arrow_marker";
-
-  if (current_lane_idx_ == -1)
-  {
-    marker-&gt;action = visualization_msgs::Marker::DELETE;
-    return marker;
-  }
-
-  std_msgs::ColorRGBA red;
-  red.r = 1.0;
-  red.a = 1.0;
-
-  marker-&gt;type = visualization_msgs::Marker::ARROW;
-  marker-&gt;action = visualization_msgs::Marker::ADD;
-  marker-&gt;color = red;
-  marker-&gt;scale.x = 0.25;
-  marker-&gt;scale.y = 0.5;
+  visualization_msgs::Marker marker;
+  std_msgs::ColorRGBA color_closest_wp;
+  color_closest_wp.r = 1.0;
+  color_closest_wp.b = 1.0;
+  color_closest_wp.g = 1.0;
+  color_closest_wp.a = 1.0;
 
-  const int32_t &amp;start = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
-  const size_t &amp;end = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.size();
-  const auto &amp;wps = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints;
+  marker.header.frame_id = "map";
+  marker.header.stamp = ros::Time();
+  marker.ns = "closest_waypoints_marker";
+  marker.type = visualization_msgs::Marker::POINTS;
+  marker.action = visualization_msgs::Marker::ADD;
+  marker.scale.x = 0.5;
+  marker.color = color_closest_wp;
 
-  std::vector&lt;waypoint_follower::waypoint&gt; wps_extracted;
-  for (uint32_t i = start; i &lt; end; i++)
+  marker.points.reserve(tuple_vec_.size());
+  for (uint32_t i = 0; i &lt; tuple_vec_.size(); i++)
   {
-    if (static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::right)
-    {
-      wps_extracted.push_back(wps.at(i));
-      if (i == end - 1)
-        break;
-
-      if (static_cast&lt;ChangeFlag&gt;(wps.at(i + 1).change_flag) != ChangeFlag::right)
-        break;
-    }
-    else if (static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::left)
-    {
-      wps_extracted.push_back(wps.at(i));
-      if (i == end - 1)
-        break;
-
-      if (static_cast&lt;ChangeFlag&gt;(wps.at(i + 1).change_flag) != ChangeFlag::left)
-        break;
-    }
-  }
+    if (std::get&lt;1&gt;(tuple_vec_.at(i)) == -1)
+      continue;
 
-  if (wps_extracted.empty())
-  {
-    marker-&gt;action = visualization_msgs::Marker::DELETE;
-    return marker;
+    marker.points.push_back(
+        std::get&lt;0&gt;(tuple_vec_.at(i)).waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(i))).pose.pose.position);
   }
-  uint32_t num = static_cast&lt;uint32_t&gt;(wps_extracted.size() / 2.0);
-  geometry_msgs::Point relative_p1;
-  relative_p1.y =
-      static_cast&lt;ChangeFlag&gt;(wps_extracted.at(0).change_flag) == ChangeFlag::right ? -LANE_SIZE_ / 2 : LANE_SIZE_ / 2;
-  marker-&gt;points.push_back(*convertPointIntoWorldCoordinate(relative_p1, wps_extracted.at(num).pose.pose));
-  geometry_msgs::Point relative_p2;
-  relative_p2.y = 3 * relative_p1.y;
-  marker-&gt;points.push_back(*convertPointIntoWorldCoordinate(relative_p2, wps_extracted.at(num).pose.pose));
 
   return marker;
 }
@@ -605,31 +543,27 @@ std::unique_ptr&lt;visualization_msgs::Marker&gt; LaneSelectNode::createCurrentLaneFla
 void LaneSelectNode::publishVisualizer()
 {
   visualization_msgs::MarkerArray marker_array;
-
-  marker_array.markers.push_back(*createCurrentLaneMarker());
-  marker_array.markers.push_back(*createCurrentLaneFlagMarker());
-  marker_array.markers.push_back(*createCurrentLaneFlagArrowMarker());
-  marker_array.markers.push_back(*createRightLaneMarker());
-  marker_array.markers.push_back(*createLeftLaneMarker());
-  marker_array.markers.push_back(*createClosestWaypointsMarker());
+  marker_array.markers.push_back(createChangeLaneMarker());
+  marker_array.markers.push_back(createCurrentLaneMarker());
+  marker_array.markers.push_back(createRightLaneMarker());
+  marker_array.markers.push_back(createLeftLaneMarker());
+  marker_array.markers.push_back(createClosestWaypointsMarker());
 
   vis_pub1_.publish(marker_array);
 }
 
-void LaneSelectNode::publish()
+void LaneSelectNode::publish(const waypoint_follower::lane &amp;lane, const int32_t clst_wp, const ChangeFlag flag)
 {
-  // publish current global lane
-  waypoint_follower::lane global_lane;
-  global_lane = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_));
-  pub1_.publish(global_lane);
+  // publish global lane
+  pub1_.publish(lane);
 
   // publish closest waypoint
   std_msgs::Int32 closest_waypoint;
-  closest_waypoint.data = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
+  closest_waypoint.data = clst_wp;
   pub2_.publish(closest_waypoint);
 
   std_msgs::Int32 change_flag;
-  change_flag.data = enumToInteger(current_change_flag_);
+  change_flag.data = enumToInteger(flag);
   pub3_.publish(change_flag);
 
   is_current_pose_subscribed_ = false;
@@ -653,7 +587,10 @@ void LaneSelectNode::callbackFromLaneArray(const waypoint_follower::LaneArrayCon
   left_lane_idx_ = -1;
   is_lane_array_subscribed_ = true;
 
-  processing();
+  if(current_lane_idx_ == -1)
+    initForLaneSelect();
+  else
+    processing();
 }
 
 void LaneSelectNode::callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg)
@@ -661,7 +598,10 @@ void LaneSelectNode::callbackFromPoseStamped(const geometry_msgs::PoseStampedCon
   current_pose_ = *msg;
   is_current_pose_subscribed_ = true;
 
-  processing();
+  if(current_lane_idx_ == -1)
+    initForLaneSelect();
+  else
+    processing();
 }
 
 void LaneSelectNode::callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr &amp;msg)
@@ -669,7 +609,10 @@ void LaneSelectNode::callbackFromTwistStamped(const geometry_msgs::TwistStampedC
   current_velocity_ = *msg;
   is_current_velocity_subscribed_ = true;
 
-  processing();
+  if(current_lane_idx_ == -1)
+    initForLaneSelect();
+  else
+    processing();
 }
 
 void LaneSelectNode::callbackFromState(const std_msgs::StringConstPtr &amp;msg)
@@ -677,7 +620,10 @@ void LaneSelectNode::callbackFromState(const std_msgs::StringConstPtr &amp;msg)
   current_state_ = msg-&gt;data;
   is_current_state_subscribed_ = true;
 
-  processing();
+  if(current_lane_idx_ == -1)
+    initForLaneSelect();
+  else
+    processing();
 }
 
 void LaneSelectNode::run()
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="13" deleted_lines="11">
				<diff>@@ -47,6 +47,7 @@
 // User defined includes
 #include "waypoint_follower/LaneArray.h"
 #include "waypoint_follower/libwaypoint_follower.h"
+#include "hermite_curve.h"
 
 namespace lane_planner
 {
@@ -91,9 +92,9 @@ private:
   int32_t left_lane_idx_;
   std::vector&lt;std::tuple&lt;waypoint_follower::lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint,
                                                                                      // change_flag
+  std::tuple&lt;waypoint_follower::lane, int32_t, ChangeFlag&gt; lane_for_change_;
   bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_, is_current_state_subscribed_;
   ros::Time last_change_time_;
-  ChangeFlag current_change_flag_;
 
   // rosparam
   double distance_threshold_;
@@ -112,28 +113,29 @@ private:
 
   // initializer
   void initForROS();
+  void initForLaneSelect();
 
   // visualizer
-  const double LANE_SIZE_;
   void publishVisualizer();
-  std::unique_ptr&lt;visualization_msgs::Marker&gt; createCurrentLaneMarker();
-  std::unique_ptr&lt;visualization_msgs::Marker&gt; createCurrentLaneFlagMarker();
-  std::unique_ptr&lt;visualization_msgs::Marker&gt; createCurrentLaneFlagArrowMarker();
-  std::unique_ptr&lt;std::vector&lt;geometry_msgs::Point&gt;&gt;
-  createRectangleFromWaypoints(const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps, const double &amp;width);
-  std::unique_ptr&lt;visualization_msgs::Marker&gt; createRightLaneMarker();
-  std::unique_ptr&lt;visualization_msgs::Marker&gt; createLeftLaneMarker();
-  std::unique_ptr&lt;visualization_msgs::Marker&gt; createClosestWaypointsMarker();
+  visualization_msgs::Marker createCurrentLaneMarker();
+  visualization_msgs::Marker createRightLaneMarker();
+  visualization_msgs::Marker createLeftLaneMarker();
+  visualization_msgs::Marker createClosestWaypointsMarker();
+  visualization_msgs::Marker createChangeLaneMarker();
 
   // functions
+  void resetLaneIdx();
+  bool isAllTopicsSubscribed();
   void processing();
-  void publish();
+  void publish(const waypoint_follower::lane &amp;lane, const int32_t clst_wp, const ChangeFlag flag);
   bool getClosestWaypointNumberForEachLanes();
   int32_t findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec, const geometry_msgs::Point p);
   void findCurrentLane();
   void findNeighborLanes();
   void changeLane();
   void updateChangeFlag();
+  void createLaneForChange();
+  int32_t getClosestLaneChangeWaypointNumber(const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps, int32_t cl_wp);
 };
 
 int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c06604f61ca21b38379048e77a11dd99770b4510" author="h_ohta">
		<msg>Remove unused variable</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="0" deleted_lines="2">
				<diff>@@ -43,7 +43,6 @@ LaneSelectNode::LaneSelectNode()
   , is_current_pose_subscribed_(false)
   , is_current_velocity_subscribed_(false)
   , is_current_state_subscribed_(false)
-  , last_change_time_(ros::Time::now())
   , current_state_("UNKNOWN")
 {
   initForROS();
@@ -275,7 +274,6 @@ void LaneSelectNode::changeLane()
   }
 
   findNeighborLanes();
-  last_change_time_ = ros::Time::now();
   return;
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="0" deleted_lines="1">
				<diff>@@ -94,7 +94,6 @@ private:
                                                                                      // change_flag
   std::tuple&lt;waypoint_follower::lane, int32_t, ChangeFlag&gt; lane_for_change_;
   bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_, is_current_state_subscribed_;
-  ros::Time last_change_time_;
 
   // rosparam
   double distance_threshold_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="87c5bda47ffce7bc97073bd7bcff3e4bf6865f64" author="h_ohta">
		<msg>optimize for RVO</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="10" deleted_lines="12">
				<diff>@@ -346,8 +346,7 @@ void LaneSelectNode::findNeighborLanes()
     int32_t target_num = std::get&lt;1&gt;(tuple_vec_.at(i));
     const geometry_msgs::Point &amp;target_p = std::get&lt;0&gt;(tuple_vec_.at(i)).waypoints.at(target_num).pose.pose.position;
 
-    geometry_msgs::Point converted_p;
-    convertPointIntoRelativeCoordinate(target_p, current_closest_pose, &amp;converted_p);
+    geometry_msgs::Point converted_p = convertPointIntoRelativeCoordinate(target_p, current_closest_pose);
 
     ROS_INFO("distance: %lf", converted_p.y);
     if (fabs(converted_p.y) &gt; distance_threshold_)
@@ -636,8 +635,7 @@ double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geom
   return distance;
 }
 
-void convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose,
-                                        geometry_msgs::Point *output_point)
+geometry_msgs::Point convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose)
 {
   tf::Transform inverse;
   tf::poseMsgToTF(pose, inverse);
@@ -646,10 +644,12 @@ void convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point,
   tf::Point p;
   pointMsgToTF(input_point, p);
   tf::Point tf_p = transform * p;
-  pointTFToMsg(tf_p, *output_point);
+  geometry_msgs::Point tf_point_msg;
+  pointTFToMsg(tf_p, tf_point_msg);
+  return tf_point_msg;
 }
 
-std::unique_ptr&lt;geometry_msgs::Point&gt; convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point,
+geometry_msgs::Point convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point,
                                                                       const geometry_msgs::Pose &amp;pose)
 {
   tf::Transform inverse;
@@ -659,8 +659,8 @@ std::unique_ptr&lt;geometry_msgs::Point&gt; convertPointIntoWorldCoordinate(const geom
   pointMsgToTF(input_point, p);
   tf::Point tf_p = inverse * p;
 
-  std::unique_ptr&lt;geometry_msgs::Point&gt; tf_point_msg(new geometry_msgs::Point);
-  pointTFToMsg(tf_p, *tf_point_msg);
+  geometry_msgs::Point tf_point_msg;
+  pointTFToMsg(tf_p, tf_point_msg);
   return tf_point_msg;
 }
 
@@ -693,8 +693,7 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
     idx_vec.reserve(current_lane.waypoints.size());
     for (uint32_t i = 0; i &lt; current_lane.waypoints.size(); i++)
     {
-      geometry_msgs::Point converted_p;
-      convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose, &amp;converted_p);
+      geometry_msgs::Point converted_p = convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose);
       double angle = getRelativeAngle(current_lane.waypoints.at(i).pose.pose, current_pose);
       if (converted_p.x &gt; 0 &amp;&amp; angle &lt; 90)
         idx_vec.push_back(i);
@@ -718,8 +717,7 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
                          : current_lane.waypoints.size();
     for (uint32_t i = static_cast&lt;uint32_t&gt;(previous_number); i &lt; range_max; i++)
     {
-      geometry_msgs::Point converted_p;
-      convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose, &amp;converted_p);
+      geometry_msgs::Point converted_p = convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose);
       double angle = getRelativeAngle(current_lane.waypoints.at(i).pose.pose, current_pose);
       if (converted_p.x &gt; 0 &amp;&amp; angle &lt; 90)
         idx_vec.push_back(i);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="2" deleted_lines="3">
				<diff>@@ -142,10 +142,9 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
 
 double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geometry_msgs::Point &amp;target2);
 
-void convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose,
-                                        geometry_msgs::Point *output_point);
+geometry_msgs::Point convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose);
 
-std::unique_ptr&lt;geometry_msgs::Point&gt; convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point,
+geometry_msgs::Point convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point,
                                                                       const geometry_msgs::Pose &amp;pose);
 double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry_msgs::Pose &amp;current_pose);
 bool getLinearEquation(geometry_msgs::Point start, geometry_msgs::Point end, double *a, double *b, double *c);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0926701fc1af9721ae44d1e220ab15b665a4dd76" author="h_ohta">
		<msg>add error avoidance</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="8" deleted_lines="0">
				<diff>@@ -193,6 +193,14 @@ void LaneSelectNode::createLaneForChange()
     return;
   }
 
+  if((static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right &amp;&amp; right_lane_idx_ &lt; 0)
+    || (static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::left &amp;&amp; left_lane_idx_ &lt; 0))
+  {
+    ROS_WARN("current lane doesn't have the lane for lane change");
+    return;
+  }
+
+
   double dt = getTwoDimensionalDistance(cur_lane.waypoints.at(num_lane_change).pose.pose.position, cur_lane.waypoints.at(clst_wp).pose.pose.position);
   double ratio = 3.0;
   double minimum = 5.0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="124d2c0f76008d2aff3a2288134c2e81b5006b56" author="h_ohta">
		<msg>Change copy to move</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -238,7 +238,7 @@ void LaneSelectNode::createLaneForChange()
     el.change_flag = cur_lane.waypoints.at(num_lane_change).change_flag;
 
   std::get&lt;0&gt;(lane_for_change_).waypoints.reserve(nghbr_lane.waypoints.size() + hermite_wps.size());
-  std::copy(hermite_wps.begin(), hermite_wps.end(), std::back_inserter(std::get&lt;0&gt;(lane_for_change_).waypoints));
+  std::move(hermite_wps.begin(), hermite_wps.end(), std::back_inserter(std::get&lt;0&gt;(lane_for_change_).waypoints));
   auto itr = nghbr_lane.waypoints.begin();
   std::advance(itr, target_num);
   for(auto i = itr; i != nghbr_lane.waypoints.end();i++)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="33981fcc47b6adb969f2e8e2b61c77889eb3ed38" author="h_ohta">
		<msg>Fix definition of function</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -687,8 +687,7 @@ double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry
 
 // get closest waypoint from current pose
 int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
-                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number,
-                                 const double distance_threshold)
+                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number, const double distance_threshold)
 {
   if (current_lane.waypoints.empty())
     return -1;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="86254175d798f614e57e1ce0489bfce8e8704d9d" author="h_ohta">
		<msg>parameter from runtime manager</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="27" deleted_lines="7">
				<diff>@@ -43,6 +43,12 @@ LaneSelectNode::LaneSelectNode()
   , is_current_pose_subscribed_(false)
   , is_current_velocity_subscribed_(false)
   , is_current_state_subscribed_(false)
+  , is_config_subscribed_(false)
+  , distance_threshold_(3.0)
+  , lane_change_interval_(10.0)
+  , lane_change_target_ratio_(2.0)
+  , lane_change_target_minimum_(5.0)
+  , vlength_hermite_curve_(10)
   , current_state_("UNKNOWN")
 {
   initForROS();
@@ -60,6 +66,7 @@ void LaneSelectNode::initForROS()
   sub2_ = nh_.subscribe("current_pose", 100, &amp;LaneSelectNode::callbackFromPoseStamped, this);
   sub3_ = nh_.subscribe("current_velocity", 100, &amp;LaneSelectNode::callbackFromTwistStamped, this);
   sub4_ = nh_.subscribe("state", 100, &amp;LaneSelectNode::callbackFromState, this);
+  sub5_ = nh_.subscribe("/config/lane_select", 100, &amp;LaneSelectNode::callbackFromConfig, this);
 
   // setup publisher
   pub1_ = nh_.advertise&lt;waypoint_follower::lane&gt;("base_waypoints", 10);
@@ -68,7 +75,7 @@ void LaneSelectNode::initForROS()
   vis_pub1_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("lane_select_marker", 10);
 
   // get from rosparam
-  private_nh_.param&lt;int32_t&gt;("lane_change_interval", lane_change_interval_, int32_t(2));
+  private_nh_.param&lt;double&gt;("lane_change_interval", lane_change_interval_, double(2));
   private_nh_.param&lt;double&gt;("distance_threshold", distance_threshold_, double(3.0));
 }
 
@@ -189,7 +196,7 @@ void LaneSelectNode::createLaneForChange()
   ROS_INFO("num_lane_change: %d",num_lane_change);
   if (num_lane_change &lt; 0 || num_lane_change &gt;= static_cast&lt;int32_t&gt;(cur_lane.waypoints.size()))
   {
-    ROS_INFO("current lane doesn't have change flag");
+    ROS_WARN("current lane doesn't have change flag");
     return;
   }
 
@@ -202,9 +209,7 @@ void LaneSelectNode::createLaneForChange()
 
 
   double dt = getTwoDimensionalDistance(cur_lane.waypoints.at(num_lane_change).pose.pose.position, cur_lane.waypoints.at(clst_wp).pose.pose.position);
-  double ratio = 3.0;
-  double minimum = 5.0;
-  double dt_by_vel = current_velocity_.twist.linear.x * ratio &gt; minimum ? current_velocity_.twist.linear.x * ratio : minimum;
+  double dt_by_vel = current_velocity_.twist.linear.x * lane_change_target_ratio_ &gt; lane_change_target_minimum_ ? current_velocity_.twist.linear.x * lane_change_target_ratio_ : lane_change_target_minimum_;
   ROS_INFO("dt : %lf, dt_by_vel : %lf",dt,dt_by_vel);
   waypoint_follower::lane &amp;nghbr_lane =
       static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right
@@ -232,7 +237,7 @@ void LaneSelectNode::createLaneForChange()
   std::get&lt;0&gt;(lane_for_change_).header.stamp = nghbr_lane.header.stamp;
   std::vector&lt;waypoint_follower::waypoint&gt; hermite_wps = generateHermiteCurveForROS(
       cur_lane.waypoints.at(num_lane_change).pose.pose, nghbr_lane.waypoints.at(target_num).pose.pose,
-      cur_lane.waypoints.at(num_lane_change).twist.twist.linear.x, 5);
+      cur_lane.waypoints.at(num_lane_change).twist.twist.linear.x, vlength_hermite_curve_);
 
   for(auto &amp;&amp;el : hermite_wps)
     el.change_flag = cur_lane.waypoints.at(num_lane_change).change_flag;
@@ -243,7 +248,7 @@ void LaneSelectNode::createLaneForChange()
   std::advance(itr, target_num);
   for(auto i = itr; i != nghbr_lane.waypoints.end();i++)
   {
-    if(getTwoDimensionalDistance(itr-&gt;pose.pose.position,i-&gt;pose.pose.position) &lt; 10)
+    if(getTwoDimensionalDistance(itr-&gt;pose.pose.position,i-&gt;pose.pose.position) &lt; lane_change_interval_)
       i-&gt;change_flag = enumToInteger(ChangeFlag::straight);
     else
       break;
@@ -631,6 +636,21 @@ void LaneSelectNode::callbackFromState(const std_msgs::StringConstPtr &amp;msg)
     processing();
 }
 
+void LaneSelectNode::callbackFromConfig(const runtime_manager::ConfigLaneSelectConstPtr &amp;msg)
+{
+  distance_threshold_ = msg-&gt; distance_threshold_neighbor_lanes;
+  lane_change_interval_= msg-&gt;lane_change_interval;
+    lane_change_target_ratio_ = msg-&gt;lane_change_target_ratio;
+  lane_change_target_minimum_ = msg-&gt;lane_change_target_minimum;
+    vlength_hermite_curve_= msg-&gt;vector_length_hermite_curve;
+  is_config_subscribed_ = true;
+
+  if(current_lane_idx_ == -1)
+    initForLaneSelect();
+  else
+    processing();
+}
+
 void LaneSelectNode::run()
 {
   ros::spin();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="6" deleted_lines="5">
				<diff>@@ -47,6 +47,7 @@
 // User defined includes
 #include "waypoint_follower/LaneArray.h"
 #include "waypoint_follower/libwaypoint_follower.h"
+#include "runtime_manager/ConfigLaneSelect.h"
 #include "hermite_curve.h"
 
 namespace lane_planner
@@ -84,7 +85,7 @@ private:
   ros::Publisher vis_pub1_;
 
   // subscriber
-  ros::Subscriber sub1_, sub2_, sub3_, sub4_;
+  ros::Subscriber sub1_, sub2_, sub3_, sub4_, sub5_;
 
   // variables
   int32_t current_lane_idx_;  // the index of the lane we are driving
@@ -93,11 +94,10 @@ private:
   std::vector&lt;std::tuple&lt;waypoint_follower::lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint,
                                                                                      // change_flag
   std::tuple&lt;waypoint_follower::lane, int32_t, ChangeFlag&gt; lane_for_change_;
-  bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_, is_current_state_subscribed_;
+  bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_, is_current_state_subscribed_, is_config_subscribed_;
 
-  // rosparam
-  double distance_threshold_;
-  int32_t lane_change_interval_;
+  // parameter from runtime manager
+  double distance_threshold_, lane_change_interval_, lane_change_target_ratio_, lane_change_target_minimum_, vlength_hermite_curve_;
 
   // topics
   geometry_msgs::PoseStamped current_pose_;
@@ -109,6 +109,7 @@ private:
   void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr &amp;msg);
   void callbackFromState(const std_msgs::StringConstPtr &amp;msg);
+  void callbackFromConfig(const runtime_manager::ConfigLaneSelectConstPtr &amp;msg);
 
   // initializer
   void initForROS();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bcc56e585d2792234761934221e8b4d33c032dc0" author="h_ohta">
		<msg>every time find neighbor lanes</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="1" deleted_lines="6">
				<diff>@@ -138,12 +138,7 @@ void LaneSelectNode::processing()
     return;
   }
 
-  if (right_lane_idx_ != -1 &amp;&amp; std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_)) == -1)
-    right_lane_idx_ = -1;
-
-  if (left_lane_idx_ != -1 &amp;&amp; std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_)) == -1)
-    left_lane_idx_ = -1;
-
+  findNeighborLanes();
   ROS_INFO("current_lane_idx: %d", current_lane_idx_);
   ROS_INFO("right_lane_idx: %d", right_lane_idx_);
   ROS_INFO("left_lane_idx: %d", left_lane_idx_);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="29d3d2bcc2a20f1f98e03622bcef8f725d0bf5b7" author="h_ohta">
		<msg>Change buffer size</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -62,17 +62,17 @@ LaneSelectNode::~LaneSelectNode()
 void LaneSelectNode::initForROS()
 {
   // setup subscriber
-  sub1_ = nh_.subscribe("traffic_waypoints_array", 100, &amp;LaneSelectNode::callbackFromLaneArray, this);
-  sub2_ = nh_.subscribe("current_pose", 100, &amp;LaneSelectNode::callbackFromPoseStamped, this);
-  sub3_ = nh_.subscribe("current_velocity", 100, &amp;LaneSelectNode::callbackFromTwistStamped, this);
-  sub4_ = nh_.subscribe("state", 100, &amp;LaneSelectNode::callbackFromState, this);
-  sub5_ = nh_.subscribe("/config/lane_select", 100, &amp;LaneSelectNode::callbackFromConfig, this);
+  sub1_ = nh_.subscribe("traffic_waypoints_array", 1, &amp;LaneSelectNode::callbackFromLaneArray, this);
+  sub2_ = nh_.subscribe("current_pose", 1, &amp;LaneSelectNode::callbackFromPoseStamped, this);
+  sub3_ = nh_.subscribe("current_velocity", 1, &amp;LaneSelectNode::callbackFromTwistStamped, this);
+  sub4_ = nh_.subscribe("state", 1, &amp;LaneSelectNode::callbackFromState, this);
+  sub5_ = nh_.subscribe("/config/lane_select", 1, &amp;LaneSelectNode::callbackFromConfig, this);
 
   // setup publisher
-  pub1_ = nh_.advertise&lt;waypoint_follower::lane&gt;("base_waypoints", 10);
-  pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 10);
-  pub3_ = nh_.advertise&lt;std_msgs::Int32&gt;("change_flag", 10);
-  vis_pub1_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("lane_select_marker", 10);
+  pub1_ = nh_.advertise&lt;waypoint_follower::lane&gt;("base_waypoints", 1);
+  pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1);
+  pub3_ = nh_.advertise&lt;std_msgs::Int32&gt;("change_flag", 1);
+  vis_pub1_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("lane_select_marker", 1);
 
   // get from rosparam
   private_nh_.param&lt;double&gt;("lane_change_interval", lane_change_interval_, double(2));
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c5e4ba1ccb4f405d441891a902166fde329a69f1" author="h_ohta">
		<msg>Change transparency of lane for change</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -501,7 +501,7 @@ visualization_msgs::Marker LaneSelectNode::createChangeLaneMarker()
 
   std_msgs::ColorRGBA color;
   color.r = 1.0;
-  color.a = 0.5;
+  color.a = 1.0;
 
   std_msgs::ColorRGBA color_current;
   color_current.b = 1.0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b80a102257622c799f81058b8d212dfb07da6a94" author="h_ohta">
		<msg>Fix style</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="29" deleted_lines="22">
				<diff>@@ -188,37 +188,43 @@ void LaneSelectNode::createLaneForChange()
   const int32_t &amp;clst_wp = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
 
   int32_t num_lane_change = getClosestLaneChangeWaypointNumber(cur_lane.waypoints, clst_wp);
-  ROS_INFO("num_lane_change: %d",num_lane_change);
+  ROS_INFO("num_lane_change: %d", num_lane_change);
   if (num_lane_change &lt; 0 || num_lane_change &gt;= static_cast&lt;int32_t&gt;(cur_lane.waypoints.size()))
   {
     ROS_WARN("current lane doesn't have change flag");
     return;
   }
 
-  if((static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right &amp;&amp; right_lane_idx_ &lt; 0)
-    || (static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::left &amp;&amp; left_lane_idx_ &lt; 0))
+  if ((static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right &amp;&amp;
+       right_lane_idx_ &lt; 0) ||
+      (static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::left &amp;&amp;
+       left_lane_idx_ &lt; 0))
   {
     ROS_WARN("current lane doesn't have the lane for lane change");
     return;
   }
 
-
-  double dt = getTwoDimensionalDistance(cur_lane.waypoints.at(num_lane_change).pose.pose.position, cur_lane.waypoints.at(clst_wp).pose.pose.position);
-  double dt_by_vel = current_velocity_.twist.linear.x * lane_change_target_ratio_ &gt; lane_change_target_minimum_ ? current_velocity_.twist.linear.x * lane_change_target_ratio_ : lane_change_target_minimum_;
-  ROS_INFO("dt : %lf, dt_by_vel : %lf",dt,dt_by_vel);
+  double dt = getTwoDimensionalDistance(cur_lane.waypoints.at(num_lane_change).pose.pose.position,
+                                        cur_lane.waypoints.at(clst_wp).pose.pose.position);
+  double dt_by_vel = current_velocity_.twist.linear.x * lane_change_target_ratio_ &gt; lane_change_target_minimum_
+                         ? current_velocity_.twist.linear.x * lane_change_target_ratio_
+                         : lane_change_target_minimum_;
+  ROS_INFO("dt : %lf, dt_by_vel : %lf", dt, dt_by_vel);
   waypoint_follower::lane &amp;nghbr_lane =
       static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right
           ? std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_))
           : std::get&lt;0&gt;(tuple_vec_.at(left_lane_idx_));
-  const int32_t &amp;nghbr_clst_wp = static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right
-                                      ? std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_))
-                                      : std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_));
+  const int32_t &amp;nghbr_clst_wp =
+      static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right
+          ? std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_))
+          : std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_));
 
   int32_t target_num = -1;
   for (uint32_t i = nghbr_clst_wp; i &lt; nghbr_lane.waypoints.size(); i++)
   {
-    if(i == nghbr_lane.waypoints.size() - 1 ||
-      dt + dt_by_vel &lt; getTwoDimensionalDistance(nghbr_lane.waypoints.at(nghbr_clst_wp).pose.pose.position,nghbr_lane.waypoints.at(i).pose.pose.position))
+    if (i == nghbr_lane.waypoints.size() - 1 ||
+        dt + dt_by_vel &lt; getTwoDimensionalDistance(nghbr_lane.waypoints.at(nghbr_clst_wp).pose.pose.position,
+                                                   nghbr_lane.waypoints.at(i).pose.pose.position))
     {
       target_num = i;
       break;
@@ -226,7 +232,7 @@ void LaneSelectNode::createLaneForChange()
   }
 
   ROS_INFO("target_num : %d", target_num);
-  if(target_num &lt; 0)
+  if (target_num &lt; 0)
     return;
 
   std::get&lt;0&gt;(lane_for_change_).header.stamp = nghbr_lane.header.stamp;
@@ -234,21 +240,21 @@ void LaneSelectNode::createLaneForChange()
       cur_lane.waypoints.at(num_lane_change).pose.pose, nghbr_lane.waypoints.at(target_num).pose.pose,
       cur_lane.waypoints.at(num_lane_change).twist.twist.linear.x, vlength_hermite_curve_);
 
-  for(auto &amp;&amp;el : hermite_wps)
+  for (auto &amp;&amp;el : hermite_wps)
     el.change_flag = cur_lane.waypoints.at(num_lane_change).change_flag;
 
   std::get&lt;0&gt;(lane_for_change_).waypoints.reserve(nghbr_lane.waypoints.size() + hermite_wps.size());
   std::move(hermite_wps.begin(), hermite_wps.end(), std::back_inserter(std::get&lt;0&gt;(lane_for_change_).waypoints));
   auto itr = nghbr_lane.waypoints.begin();
   std::advance(itr, target_num);
-  for(auto i = itr; i != nghbr_lane.waypoints.end();i++)
+  for (auto i = itr; i != nghbr_lane.waypoints.end(); i++)
   {
-    if(getTwoDimensionalDistance(itr-&gt;pose.pose.position,i-&gt;pose.pose.position) &lt; lane_change_interval_)
+    if (getTwoDimensionalDistance(itr-&gt;pose.pose.position, i-&gt;pose.pose.position) &lt; lane_change_interval_)
       i-&gt;change_flag = enumToInteger(ChangeFlag::straight);
     else
       break;
   }
-  std::copy(itr,nghbr_lane.waypoints.end(), std::back_inserter(std::get&lt;0&gt;(lane_for_change_).waypoints));
+  std::copy(itr, nghbr_lane.waypoints.end(), std::back_inserter(std::get&lt;0&gt;(lane_for_change_).waypoints));
 }
 
 void LaneSelectNode::updateChangeFlag()
@@ -702,12 +708,12 @@ double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry
 
 // get closest waypoint from current pose
 int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
-                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number, const double distance_threshold)
+                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number,
+                                 const double distance_threshold)
 {
   if (current_lane.waypoints.empty())
     return -1;
 
-
   std::vector&lt;uint32_t&gt; idx_vec;
   // if previous number is -1, search closest waypoint from waypoints in front of current pose
   if (previous_number == -1)
@@ -715,7 +721,8 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
     idx_vec.reserve(current_lane.waypoints.size());
     for (uint32_t i = 0; i &lt; current_lane.waypoints.size(); i++)
     {
-      geometry_msgs::Point converted_p = convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose);
+      geometry_msgs::Point converted_p =
+          convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose);
       double angle = getRelativeAngle(current_lane.waypoints.at(i).pose.pose, current_pose);
       if (converted_p.x &gt; 0 &amp;&amp; angle &lt; 90)
         idx_vec.push_back(i);
@@ -739,11 +746,11 @@ int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, co
                          : current_lane.waypoints.size();
     for (uint32_t i = static_cast&lt;uint32_t&gt;(previous_number); i &lt; range_max; i++)
     {
-      geometry_msgs::Point converted_p = convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose);
+      geometry_msgs::Point converted_p =
+          convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose);
       double angle = getRelativeAngle(current_lane.waypoints.at(i).pose.pose, current_pose);
       if (converted_p.x &gt; 0 &amp;&amp; angle &lt; 90)
         idx_vec.push_back(i);
-
     }
   }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b9e09acdffe3dd6d28f22b6430801ad7dd3c8468" author="h_ohta">
		<msg>Fix hermite curve</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.cpp" added_lines="6" deleted_lines="5">
				<diff>@@ -95,9 +95,9 @@ std::vector&lt;Element2D&gt; generateHermiteCurve(const Element2D &amp;p0, const Element2D
 {
   std::vector&lt;Element2D&gt; result;
   const double interval = 1.0;
-  const double error = 1e-3;
   int32_t divide = 2;
-  while (divide &lt; 100)
+  const int32_t loop = 100;
+  while (divide &lt; loop)
   {
     result.reserve(divide);
     for (int32_t i = 0; i &lt; divide; i++)
@@ -114,9 +114,10 @@ std::vector&lt;Element2D&gt; generateHermiteCurve(const Element2D &amp;p0, const Element2D
           Element2D((p0.x * coeff_p0 + vlength * v0.x * coeff_v0 + p1.x * coeff_p1 + vlength * v1.x * coeff_v1),
                     (p0.y * coeff_p0 + vlength * v0.y * coeff_v0 + p1.y * coeff_p1 + vlength * v1.y * coeff_v1)));
     }
-    ROS_INFO_STREAM(sqrt(pow((result.at(0).x - result.at(1).x), 2) + pow((result.at(0).y - result.at(1).y), 2)));
-    if (fabs(interval &lt; sqrt(pow((result.at(0).x - result.at(1).x), 2) + pow((result.at(0).y - result.at(1).y), 2))) &lt;
-        error)
+
+    double dt = sqrt(pow((result.at(divide/2 - 1).x - result.at(divide/2).x), 2) + pow((result.at(divide/2 - 1).y - result.at(divide/2).y), 2));
+    std::cout &lt;&lt; "interval : " &lt;&lt; dt &lt;&lt; std::endl;
+    if (interval &gt; dt || divide == loop -1)
       return result;
     else
     {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3025300194b202ffff7af34c91f4d2c140e9d929" author="h_ohta">
		<msg>Fix style</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.cpp" added_lines="10" deleted_lines="7">
				<diff>@@ -70,9 +70,9 @@ std::vector&lt;waypoint_follower::waypoint&gt; generateHermiteCurveForROS(const geomet
     wp.twist.twist.linear.x = velocity_mps;
 
     // height
-    wp.pose.pose.position.z = (i == 0) ? start.position.z
-                                       : (i == result.size() - 1) ? end.position.z
-                                       : start.position.z &lt; end.position.z ?start.position.z + height_d * i / result.size()
+    wp.pose.pose.position.z = (i == 0) ? start.position.z : (i == result.size() - 1)
+                                       ? end.position.z : start.position.z &lt; end.position.z
+                                       ? start.position.z + height_d * i / result.size()
                                        : start.position.z - height_d * i / result.size();
 
     // orientation
@@ -91,7 +91,8 @@ std::vector&lt;waypoint_follower::waypoint&gt; generateHermiteCurveForROS(const geomet
   return wps;
 }
 
-std::vector&lt;Element2D&gt; generateHermiteCurve(const Element2D &amp;p0, const Element2D &amp;v0, const Element2D &amp;p1, const Element2D &amp;v1, const double vlength)
+std::vector&lt;Element2D&gt; generateHermiteCurve(const Element2D &amp;p0, const Element2D &amp;v0, const Element2D &amp;p1,
+                                            const Element2D &amp;v1, const double vlength)
 {
   std::vector&lt;Element2D&gt; result;
   const double interval = 1.0;
@@ -109,15 +110,17 @@ std::vector&lt;Element2D&gt; generateHermiteCurve(const Element2D &amp;p0, const Element2D
       double coeff_v0 = u_cube - 2 * u_square + u;
       double coeff_p1 = (-1) * 2 * u_cube + 3 * u_square;
       double coeff_v1 = u_cube - u_square;
-      //printf("u: %lf, u^2: %lf, u^3: %lf, coeff_p0: %lf, coeff_v0: %lf, coeff_p1: %lf, coeff_v1: %lf\n", u, u_square, u_cube, coeff_p0, coeff_p1, coeff_v0, coeff_v1);
+      // printf("u: %lf, u^2: %lf, u^3: %lf, coeff_p0: %lf, coeff_v0: %lf, coeff_p1: %lf, coeff_v1: %lf\n", u, u_square,
+      // u_cube, coeff_p0, coeff_p1, coeff_v0, coeff_v1);
       result.push_back(
           Element2D((p0.x * coeff_p0 + vlength * v0.x * coeff_v0 + p1.x * coeff_p1 + vlength * v1.x * coeff_v1),
                     (p0.y * coeff_p0 + vlength * v0.y * coeff_v0 + p1.y * coeff_p1 + vlength * v1.y * coeff_v1)));
     }
 
-    double dt = sqrt(pow((result.at(divide/2 - 1).x - result.at(divide/2).x), 2) + pow((result.at(divide/2 - 1).y - result.at(divide/2).y), 2));
+    double dt = sqrt(pow((result.at(divide / 2 - 1).x - result.at(divide / 2).x), 2) +
+                     pow((result.at(divide / 2 - 1).y - result.at(divide / 2).y), 2));
     std::cout &lt;&lt; "interval : " &lt;&lt; dt &lt;&lt; std::endl;
-    if (interval &gt; dt || divide == loop -1)
+    if (interval &gt; dt || divide == loop - 1)
       return result;
     else
     {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.h" added_lines="5" deleted_lines="2">
				<diff>@@ -63,8 +63,11 @@ struct Element2D
   double y;
 };
 
-std::vector&lt;Element2D&gt; generateHermiteCurve(const Element2D &amp;p0, const Element2D &amp;v0, const Element2D &amp;p1, const Element2D &amp;v1, const double vlength = 20);
-std::vector&lt;waypoint_follower::waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start, const geometry_msgs::Pose &amp;end, const double velocity,  const double vlength);
+std::vector&lt;Element2D&gt; generateHermiteCurve(const Element2D &amp;p0, const Element2D &amp;v0, const Element2D &amp;p1,
+                                            const Element2D &amp;v1, const double vlength = 20);
+std::vector&lt;waypoint_follower::waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
+                                                                    const geometry_msgs::Pose &amp;end,
+                                                                    const double velocity, const double vlength);
 void createVectorFromPose(const geometry_msgs::Pose &amp;p, tf::Vector3 *v);
 }  // namespace
 #endif  // HERMITE_CURVE_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="71faa58f5fb0c2083e741f01f0835342a4a88456" author="Yukihiro Saito">
		<msg>Change to use cloud_cluster node in obj fusion</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\obj_fusion.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\obj_fusion.cpp" added_lines="54" deleted_lines="116">
				<diff>@@ -1,8 +1,9 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_tracker/obj_label.h&gt;
-#include &lt;lidar_tracker/centroids.h&gt;
-#include &lt;visualization_msgs/Marker.h&gt;
-#include &lt;visualization_msgs/MarkerArray.h&gt;
+#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
+#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
+#include &lt;lidar_tracker/CloudCluster.h&gt;
+#include &lt;lidar_tracker/CloudClusterArray.h&gt;
 #include &lt;geometry_msgs/Point.h&gt;
 #include &lt;math.h&gt;
 #include &lt;float.h&gt;
@@ -21,13 +22,15 @@ static constexpr bool ADVERTISE_LATCH = false;
 static constexpr double LOOP_RATE = 15.0;
 
 ros::Publisher obj_pose_pub;
-ros::Publisher obj_pose_textlabel_pub;
 ros::Publisher obj_pose_timestamp_pub;
+ros::Publisher cluster_class_pub;
 
 static std::string object_type;
 static std::vector&lt;geometry_msgs::Point&gt; centroids;
+static std_msgs::Header sensor_header;
+static std::vector&lt;lidar_tracker::CloudCluster&gt; v_cloud_cluster;
 static ros::Time obj_pose_timestamp;
-
+static double threshold_min_dist;
 static tf::StampedTransform transform;
 
 struct obj_label_t {
@@ -59,6 +62,8 @@ static double euclid_distance(const geometry_msgs::Point pos1,
 static void fusion_objects(void)
 {
     obj_label_t obj_label_current;
+    std::vector&lt;lidar_tracker::CloudCluster&gt; v_cloud_cluster_current;
+    std_msgs::Header header = sensor_header;
     std::vector&lt;geometry_msgs::Point&gt; centroids_current;
 
     LOCK(mtx_reprojected_positions);
@@ -68,10 +73,12 @@ static void fusion_objects(void)
 
     LOCK(mtx_centroids);
     copy(centroids.begin(), centroids.end(), back_inserter(centroids_current));
+    copy(v_cloud_cluster.begin(), v_cloud_cluster.end(), back_inserter(v_cloud_cluster_current));
     UNLOCK(mtx_centroids);
 
     if (centroids_current.empty() || obj_label_current.reprojected_positions.empty() ||  obj_label_current.obj_id.empty()) {
-        visualization_msgs::MarkerArray pub_msg;
+        jsk_recognition_msgs::BoundingBoxArray pub_msg;
+        pub_msg.header = header;
         std_msgs::Time time;
         obj_pose_pub.publish(pub_msg);
 
@@ -80,7 +87,7 @@ static void fusion_objects(void)
         return;
     }
 
-    std::vector&lt;unsigned int&gt; obj_indices;
+    std::vector&lt;int&gt; obj_indices;
 
     for(unsigned int i = 0; i &lt; obj_label_current.obj_id.size(); ++i) {
         unsigned int min_idx      = 0;
@@ -97,115 +104,39 @@ static void fusion_objects(void)
                 min_idx      = j;
             }
         }
-        obj_indices.push_back(min_idx);
+        if (min_distance &lt; threshold_min_dist) {
+            obj_indices.push_back(min_idx);
+        } else {
+            obj_indices.push_back(-1);
+        }
     }
 
     /* Publish marker with centroids coordinates */
-    visualization_msgs::MarkerArray pub_msg;
-    visualization_msgs::MarkerArray pub_textlabel_msg;
-
-    std_msgs::ColorRGBA color_red;
-    color_red.r = 1.0f;
-    color_red.g = 0.0f;
-    color_red.b = 0.0f;
-    color_red.a = 0.7f;
-
-    std_msgs::ColorRGBA color_blue;
-    color_blue.r = 0.0f;
-    color_blue.g = 0.0f;
-    color_blue.b = 1.0f;
-    color_blue.a = 0.7f;
-
-    std_msgs::ColorRGBA color_green;
-    color_green.r = 0.0f;
-    color_green.g = 1.0f;
-    color_green.b = 0.0f;
-    color_green.a = 0.7f;
-
-    std_msgs::ColorRGBA color_white;
-    color_white.r = 1.0f;
-    color_white.g = 1.0f;
-    color_white.b = 1.0f;
-    color_white.a = 0.7f;
+    jsk_recognition_msgs::BoundingBoxArray pub_msg;
+    pub_msg.header = header;
+    lidar_tracker::CloudClusterArray cloud_clusters_msg;
+    cloud_clusters_msg.header = header;
 
     for(unsigned int i = 0; i &lt; obj_label_current.obj_id.size(); ++i) {
-        visualization_msgs::Marker marker;
-        visualization_msgs::Marker marker_textlabel;
-
-        /*Set the frame ID */
-        marker.header.frame_id = "map";
-        marker_textlabel.header.frame_id = "map";
-
-        /* Set the namespace and id for this marker */
-        marker.ns = object_type;
-        marker.id = obj_label_current.obj_id.at(i);
-        marker_textlabel.ns = object_type;
-        marker_textlabel.id = obj_label_current.obj_id.at(i);
-
-        /* Set the pose of the marker */
-        marker.pose.position = centroids_current.at(obj_indices.at(i));
-        marker.pose.orientation.x = 0.0;
-        marker.pose.orientation.y = 0.0;
-        marker.pose.orientation.y = 0.0;
-        marker.pose.orientation.w = 0.0;
-        marker_textlabel.pose.position = centroids_current.at(obj_indices.at(i));
-        marker_textlabel.pose.orientation.x = 0.0;
-        marker_textlabel.pose.orientation.y = 0.0;
-        marker_textlabel.pose.orientation.y = 0.0;
-        marker_textlabel.pose.orientation.w = 0.0;
-
-        if (object_type == "car") {
-            /* Set the marker type */
-            marker.type = visualization_msgs::Marker::SPHERE;
-            /* Set the scale of the marker -- We assume object as 1.5m sphere */
-            marker.scale.x = (double)1.5;
-            marker.scale.y = (double)1.5;
-            marker.scale.z = (double)1.5;
-
-            /* Set the color */
-            marker.color = color_blue;
-        }
-        else if (object_type == "person") {
-            /* Set the marker type */
-            marker.type = visualization_msgs::Marker::CUBE;
-            /* Set the scale of the marker */
-            marker.scale.x = (double)0.7;
-            marker.scale.y = (double)0.7;
-            marker.scale.z = (double)1.8;
-
-            /* Set the color */
-            marker.color = color_green;
-        }
-        else {
-            /* Set the marker type */
-            marker.type = visualization_msgs::Marker::SPHERE;
-            /* Set the scale of the marker -- We assume object as 1.5m sphere */
-            marker.scale.x = (double)1.5;
-            marker.scale.y = (double)1.5;
-            marker.scale.z = (double)1.5;
-
-            /* Set the color */
-            marker.color = color_red;
-        }
-
-        marker.lifetime = ros::Duration(0.3);
-
-	/* Set the text label */
-	marker_textlabel.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
-	marker_textlabel.scale.z = 1.0;
-	marker_textlabel.text = object_type;
-	// marker_textlabel.text = object_type + std::to_string(obj_label_current.obj_id.at(i));
-	marker_textlabel.pose.position.z += marker.scale.z/2 + 0.5;
-	marker_textlabel.color = color_white;
-        marker_textlabel.lifetime = ros::Duration(0.3);
-
-        pub_msg.markers.push_back(marker);
-        pub_textlabel_msg.markers.push_back(marker_textlabel);
+        jsk_recognition_msgs::BoundingBox bounding_box;
+        if (obj_indices.at(i) == -1)
+            continue;
+
+        if(object_type == "car")
+          v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box.label = 0;
+        else if(object_type == "person")
+          v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box.label = 1;
+        else
+          v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box.label = 2;
+
+        v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box.value = obj_label_current.obj_id.at(i);
+        bounding_box = v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box;
+        pub_msg.boxes.push_back(bounding_box);
+        cloud_clusters_msg.clusters.push_back(v_cloud_cluster_current.at(obj_indices.at(i)));
     }
 
     obj_pose_pub.publish(pub_msg);
-    obj_pose_textlabel_pub.publish(pub_textlabel_msg);
-
+    cluster_class_pub.publish(cloud_clusters_msg);
     std_msgs::Time time;
     time.data = obj_pose_timestamp;
     obj_pose_timestamp_pub.publish(time);
@@ -251,22 +182,24 @@ void obj_label_cb(const cv_tracker::obj_label&amp; obj_label_msg)
 } /* void obj_label_cb() */
 
 
-void cluster_centroids_cb(const lidar_tracker::centroids&amp; cluster_centroids_msg)
+void cluster_centroids_cb(const lidar_tracker::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr)
 {
     LOCK(mtx_centroids);
     centroids.clear();
+    v_cloud_cluster.clear();
     UNLOCK(mtx_centroids);
 
     LOCK(mtx_centroids);
     static tf::TransformListener trf_listener;
     try {
         trf_listener.lookupTransform("map", "velodyne", ros::Time(0), transform);
-
-        for (const auto&amp; point : cluster_centroids_msg.points) {
+        for (int i(0) ; i &lt; (int)in_cloud_cluster_array_ptr-&gt;clusters.size(); ++i) {
+            lidar_tracker::CloudCluster cloud_cluster = in_cloud_cluster_array_ptr-&gt;clusters.at(i);
             /* convert centroids coodinate from velodyne frame to map frame */
-            tf::Vector3 pt(point.x, point.y, point.z);
+            tf::Vector3 pt(cloud_cluster.centroid_point.point.x, cloud_cluster.centroid_point.point.y, cloud_cluster.centroid_point.point.z);
             tf::Vector3 converted = transform * pt;
-
+            sensor_header = cloud_cluster.header;
+            v_cloud_cluster.push_back(cloud_cluster);
             geometry_msgs::Point point_in_map;
             point_in_map.x = converted.x();
             point_in_map.y = converted.y();
@@ -307,15 +240,20 @@ int main(int argc, char* argv[])
     ros::init(argc, argv, "obj_fusion");
 
     ros::NodeHandle n;
+    ros::NodeHandle private_n ("~");
 
+    if (private_n.getParam("min_dist", threshold_min_dist))
+  	{
+      threshold_min_dist = 5.0;
+  	}
     /* Initialize flags */
     isReady_obj_label         = false;
     isReady_cluster_centroids = false;
 
     ros::Subscriber obj_label_sub         = n.subscribe("obj_label", SUBSCRIBE_QUEUE_SIZE, obj_label_cb);
-    ros::Subscriber cluster_centroids_sub = n.subscribe("/cluster_centroids", SUBSCRIBE_QUEUE_SIZE, cluster_centroids_cb);
-    obj_pose_pub = n.advertise&lt;visualization_msgs::MarkerArray&gt;("obj_pose", ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
-    obj_pose_textlabel_pub = n.advertise&lt;visualization_msgs::MarkerArray&gt;("obj_pose_textlabel", ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
+    ros::Subscriber cluster_centroids_sub = n.subscribe("/cloud_clusters", SUBSCRIBE_QUEUE_SIZE, cluster_centroids_cb);
+    obj_pose_pub = n.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("obj_pose", ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
+	  cluster_class_pub = n.advertise&lt;lidar_tracker::CloudClusterArray&gt;("/cloud_cluster_class", ADVERTISE_QUEUE_SIZE);
     obj_pose_timestamp_pub = n.advertise&lt;std_msgs::Time&gt;("obj_pose_timestamp", ADVERTISE_QUEUE_SIZE);
     ros::spin();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fd5f01e4f2ebb1571b365de5d8622fbd1164ddd1" author="Yukihiro Saito">
		<msg>Change to use final object topic in potential field</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\potential_field\potential_field.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\potential_field\potential_field.cpp" added_lines="14" deleted_lines="12">
				<diff>@@ -4,6 +4,8 @@
 #include &lt;grid_map_msgs/GridMap.h&gt;
 #include &lt;grid_map_ros/grid_map_ros.hpp&gt;
 #include &lt;iostream&gt;
+#include &lt;lidar_tracker/DetectedObject.h&gt;
+#include &lt;lidar_tracker/DetectedObjectArray.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
@@ -49,7 +51,7 @@ private:
     double around_y;
   };
 
-  void obj_callback(jsk_recognition_msgs::BoundingBoxArray::ConstPtr obj_msg);
+  void obj_callback(lidar_tracker::DetectedObjectArray::ConstPtr obj_msg);
   void target_waypoint_callback(
       visualization_msgs::Marker::ConstPtr target_point_msgs);
   void vscan_points_callback(sensor_msgs::PointCloud2::ConstPtr vscan_msg);
@@ -95,7 +97,7 @@ PotentialField::PotentialField()
       nh_.advertise&lt;grid_map_msgs::GridMap&gt;("/potential_field", 1, true);
 
   if (use_obstacle_box_)
-    obj_subscriber_ = nh_.subscribe("/bounding_boxes", 1,
+    obj_subscriber_ = nh_.subscribe("/detected_objects", 1,
                                     &amp;PotentialField::obj_callback, this);
   if (use_vscan_points_)
     vscan_subscriber_ = nh_.subscribe(
@@ -135,7 +137,7 @@ void PotentialField::publish_potential_field() {
                     message.info.header.stamp.toSec());
 }
 void PotentialField::obj_callback(
-    jsk_recognition_msgs::BoundingBoxArray::ConstPtr
+    lidar_tracker::DetectedObjectArray::ConstPtr
         obj_msg) { // Create grid map.
   static ObstacleFieldParameter param;
   double ver_x_p(param.ver_x_p);
@@ -149,17 +151,17 @@ void PotentialField::obj_callback(
     Position position;
     map_.getPosition(*it, position);
     map_.at("obstacle_field", *it) = 0.0;
-    for (int i(0); i &lt; (int)obj_msg-&gt;boxes.size(); ++i) {
-      double pos_x = obj_msg-&gt;boxes.at(i).pose.position.x + tf_x_;
-      double pos_y = obj_msg-&gt;boxes.at(i).pose.position.y;
-      double len_x = obj_msg-&gt;boxes.at(i).dimensions.x / 2.0;
-      double len_y = obj_msg-&gt;boxes.at(i).dimensions.y / 2.0;
+    for (int i(0); i &lt; (int)obj_msg-&gt;objects.size(); ++i) {
+      double pos_x = obj_msg-&gt;objects.at(i).pose.position.x + tf_x_;
+      double pos_y = obj_msg-&gt;objects.at(i).pose.position.y;
+      double len_x = obj_msg-&gt;objects.at(i).dimensions.x / 2.0;
+      double len_y = obj_msg-&gt;objects.at(i).dimensions.y / 2.0;
 
       double r, p, y;
-      tf::Quaternion quat(obj_msg-&gt;boxes.at(i).pose.orientation.x,
-                          obj_msg-&gt;boxes.at(i).pose.orientation.y,
-                          obj_msg-&gt;boxes.at(i).pose.orientation.z,
-                          obj_msg-&gt;boxes.at(i).pose.orientation.w);
+      tf::Quaternion quat(obj_msg-&gt;objects.at(i).pose.orientation.x,
+                          obj_msg-&gt;objects.at(i).pose.orientation.y,
+                          obj_msg-&gt;objects.at(i).pose.orientation.z,
+                          obj_msg-&gt;objects.at(i).pose.orientation.w);
       tf::Matrix3x3(quat).getRPY(r, p, y);
 
       double rotated_pos_x = std::cos(-1.0 * y) * (position.x() - pos_x) -
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f946e508027c6f585f48f57e3783e273cf469f9a" author="yukikitsukawa">
		<msg>pcd_filter supports PointXYZ, PointXYZI and PointXYZRGB</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\map_tools\nodes\pcd_filter\pcd_filter.cpp" new_path="ros\src\util\packages\map_tools\nodes\pcd_filter\pcd_filter.cpp" added_lines="81" deleted_lines="25">
				<diff>@@ -16,38 +16,94 @@ int main (int argc, char** argv)
   int i;
 
   if(argc &lt; 3){
-    std::cout &lt;&lt; "Usage: rosrun map_tools pcd_filter \"leaf_size\" \"***.pcd\" " &lt;&lt; std::endl;
+    std::cout &lt;&lt; "Usage: rosrun map_tools pcd_filter \"point_type [PointXYZ|PointXYZI|PointXYZRGB]\" \"leaf_size\" \"***.pcd\" " &lt;&lt; std::endl;
     return 1;
   }
 
-  double leaf_size = std::stod(argv[1]);
+  std::string point_type = argv[1];
+  double leaf_size = std::stod(argv[2]);
 
-  for(i = 2; i &lt; argc; i++){
+  for(i = 3; i &lt; argc; i++){
     // Loading input_cloud.
     std::string input = argv[i];
-    pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr input_cloud (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
-    if (pcl::io::loadPCDFile&lt;pcl::PointXYZRGB&gt; (input, *input_cloud) == -1){
-      std::cout &lt;&lt; "Couldn't find " &lt;&lt; input &lt;&lt; "." &lt;&lt; std::endl;
-      break;
+
+    if(point_type == "PointXYZ"){
+      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr input_cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+      if (pcl::io::loadPCDFile&lt;pcl::PointXYZ&gt; (input, *input_cloud) == -1){
+        std::cout &lt;&lt; "Couldn't find " &lt;&lt; input &lt;&lt; "." &lt;&lt; std::endl;
+        break;
+      }
+      std::cout &lt;&lt; "Input: " &lt;&lt; input &lt;&lt; " (" &lt;&lt; input_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
+
+      // Filtering input scan
+      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+      pcl::VoxelGrid&lt;pcl::PointXYZ&gt; voxel_grid_filter;
+      voxel_grid_filter.setLeafSize (leaf_size, leaf_size, leaf_size);
+      voxel_grid_filter.setInputCloud (input_cloud);
+      voxel_grid_filter.filter (*filtered_cloud);
+
+      int tmp = input.find_last_of("/");
+      std::string prefix = std::to_string(leaf_size);
+      prefix = prefix.substr(0, 4);
+      prefix += "_";
+      std::string output = input.insert(tmp+1, prefix);
+
+      pcl::io::savePCDFileBinary(output, *filtered_cloud);
+      std::cout &lt;&lt; "Output: " &lt;&lt; output &lt;&lt; " (" &lt;&lt; filtered_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
+      std::cout &lt;&lt; "Voxel Leaf Size: " &lt;&lt; leaf_size &lt;&lt; std::endl &lt;&lt; std::endl;
+    }
+
+    else if(point_type == "PointXYZI"){
+      pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr input_cloud (new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
+      if (pcl::io::loadPCDFile&lt;pcl::PointXYZI&gt; (input, *input_cloud) == -1){
+        std::cout &lt;&lt; "Couldn't find " &lt;&lt; input &lt;&lt; "." &lt;&lt; std::endl;
+        break;
+      }
+      std::cout &lt;&lt; "Input: " &lt;&lt; input &lt;&lt; " (" &lt;&lt; input_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
+
+      // Filtering input scan
+      pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_cloud (new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
+      pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
+      voxel_grid_filter.setLeafSize (leaf_size, leaf_size, leaf_size);
+      voxel_grid_filter.setInputCloud (input_cloud);
+      voxel_grid_filter.filter (*filtered_cloud);
+
+      int tmp = input.find_last_of("/");
+      std::string prefix = std::to_string(leaf_size);
+      prefix = prefix.substr(0, 4);
+      prefix += "_";
+      std::string output = input.insert(tmp+1, prefix);
+
+      pcl::io::savePCDFileBinary(output, *filtered_cloud);
+      std::cout &lt;&lt; "Output: " &lt;&lt; output &lt;&lt; " (" &lt;&lt; filtered_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
+      std::cout &lt;&lt; "Voxel Leaf Size: " &lt;&lt; leaf_size &lt;&lt; std::endl &lt;&lt; std::endl;
+    }
+
+    else if(point_type == "PointXYZRGB"){
+      pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr input_cloud (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
+      if (pcl::io::loadPCDFile&lt;pcl::PointXYZRGB&gt; (input, *input_cloud) == -1){
+        std::cout &lt;&lt; "Couldn't find " &lt;&lt; input &lt;&lt; "." &lt;&lt; std::endl;
+        break;
+      }
+      std::cout &lt;&lt; "Input: " &lt;&lt; input &lt;&lt; " (" &lt;&lt; input_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
+
+      // Filtering input scan
+      pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr filtered_cloud (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
+      pcl::VoxelGrid&lt;pcl::PointXYZRGB&gt; voxel_grid_filter;
+      voxel_grid_filter.setLeafSize (leaf_size, leaf_size, leaf_size);
+      voxel_grid_filter.setInputCloud (input_cloud);
+      voxel_grid_filter.filter (*filtered_cloud);
+
+      int tmp = input.find_last_of("/");
+      std::string prefix = std::to_string(leaf_size);
+      prefix = prefix.substr(0, 4);
+      prefix += "_";
+      std::string output = input.insert(tmp+1, prefix);
+
+      pcl::io::savePCDFileBinary(output, *filtered_cloud);
+      std::cout &lt;&lt; "Output: " &lt;&lt; output &lt;&lt; " (" &lt;&lt; filtered_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
+      std::cout &lt;&lt; "Voxel Leaf Size: " &lt;&lt; leaf_size &lt;&lt; std::endl &lt;&lt; std::endl;
     }
-    std::cout &lt;&lt; "Input: " &lt;&lt; input &lt;&lt; " (" &lt;&lt; input_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
-
-    // Filtering input scan
-    pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr filtered_cloud (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
-    pcl::VoxelGrid&lt;pcl::PointXYZRGB&gt; voxel_grid_filter;
-    voxel_grid_filter.setLeafSize (leaf_size, leaf_size, leaf_size);
-    voxel_grid_filter.setInputCloud (input_cloud);
-    voxel_grid_filter.filter (*filtered_cloud);
-    //    std::cout &lt;&lt; "Filtered cloud contains " &lt;&lt; filtered_cloud-&gt;size () &lt;&lt; " data points from " &lt;&lt; input &lt;&lt; "."&lt;&lt; std::endl;
-
-    int tmp = input.find_last_of("/");
-    std::string prefix = std::to_string(leaf_size);
-    prefix += "_";
-    std::string output = input.insert(tmp+1, prefix);
-
-    pcl::io::savePCDFileBinary(output, *filtered_cloud);
-    std::cout &lt;&lt; "Output: " &lt;&lt; output &lt;&lt; " (" &lt;&lt; filtered_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
-    std::cout &lt;&lt; "Voxel Leaf Size: " &lt;&lt; leaf_size &lt;&lt; std::endl &lt;&lt; std::endl;
   }
 
   return 0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="07033d266f3ce93b8eed99050ba94d0698e11101" author="yukikitsukawa">
		<msg>pcd_binarizer supports PointXYZ, PointXYZI and PointXYZRGB</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\map_tools\nodes\pcd_binarizer\pcd_binarizer.cpp" new_path="ros\src\util\packages\map_tools\nodes\pcd_binarizer\pcd_binarizer.cpp" added_lines="59" deleted_lines="16">
				<diff>@@ -13,32 +13,75 @@ int main (int argc, char** argv)
 {
   int i;
 
-  if(argc &lt; 2){
-    std::cout &lt;&lt; "Usage: rosrun map_tools pcd_binarizer '***.pcd'" &lt;&lt; std::endl;
+  if(argc &lt; 3){
+    std::cout &lt;&lt; "Usage: rosrun map_tools pcd_binarizer 'point_type [PointXYZ|PointXYZI|PointXYZRGB]' '***.pcd'" &lt;&lt; std::endl;
     exit(-1);
   }
 
-  for(i = 1; i &lt; argc; i++){
+  std::string point_type = argv[1];
+
+  for(i = 2; i &lt; argc; i++){
     // Loading input_cloud.
     std::string input = argv[i];
-    pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr input_cloud (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
-    if (pcl::io::loadPCDFile&lt;pcl::PointXYZRGB&gt; (input, *input_cloud) == -1){
-      std::cout &lt;&lt; "Couldn't find " &lt;&lt; input &lt;&lt; "." &lt;&lt; std::endl;
-      break;
+
+    if(point_type == "PointXYZ"){
+      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr input_cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+      if (pcl::io::loadPCDFile&lt;pcl::PointXYZ&gt; (input, *input_cloud) == -1){
+        std::cout &lt;&lt; "Couldn't find " &lt;&lt; input &lt;&lt; "." &lt;&lt; std::endl;
+        break;
+      }
+      std::cout &lt;&lt; "Input: " &lt;&lt; input &lt;&lt; std::endl;
+
+      int tmp = input.find_last_of("/");
+      std::string prefix = "bin_";
+      std::string output = input.insert(tmp+1, prefix);
+
+      if(pcl::io::savePCDFileBinary(output, *input_cloud) == -1){
+        std::cout &lt;&lt; "Failed saving " &lt;&lt; output &lt;&lt; std::endl;
+        return -1;
+      }
+      std::cout &lt;&lt; "Output: " &lt;&lt; output &lt;&lt; std::endl &lt;&lt; std::endl;
     }
-    std::cout &lt;&lt; "Input: " &lt;&lt; input &lt;&lt; std::endl;
 
-    int tmp = input.find_last_of("/");
-    std::string prefix = "bin_";
-    std::string output = input.insert(tmp+1, prefix);
+    else if(point_type == "PointXYZI"){
+      pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr input_cloud (new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
+      if (pcl::io::loadPCDFile&lt;pcl::PointXYZI&gt; (input, *input_cloud) == -1){
+        std::cout &lt;&lt; "Couldn't find " &lt;&lt; input &lt;&lt; "." &lt;&lt; std::endl;
+        break;
+      }
+      std::cout &lt;&lt; "Input: " &lt;&lt; input &lt;&lt; std::endl;
+
+      int tmp = input.find_last_of("/");
+      std::string prefix = "bin_";
+      std::string output = input.insert(tmp+1, prefix);
 
-    if(pcl::io::savePCDFileBinary(output, *input_cloud) == -1){
-      std::cout &lt;&lt; "Failed saving " &lt;&lt; output &lt;&lt; std::endl;
-      return -1;
+      if(pcl::io::savePCDFileBinary(output, *input_cloud) == -1){
+        std::cout &lt;&lt; "Failed saving " &lt;&lt; output &lt;&lt; std::endl;
+        return -1;
+      }
+      std::cout &lt;&lt; "Output: " &lt;&lt; output &lt;&lt; std::endl &lt;&lt; std::endl;
     }
-    std::cout &lt;&lt; "Output: " &lt;&lt; output &lt;&lt; std::endl &lt;&lt; std::endl;
+
+    else if(point_type == "PointXYZRGB"){
+      pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr input_cloud (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
+      if (pcl::io::loadPCDFile&lt;pcl::PointXYZRGB&gt; (input, *input_cloud) == -1){
+        std::cout &lt;&lt; "Couldn't find " &lt;&lt; input &lt;&lt; "." &lt;&lt; std::endl;
+        break;
+      }
+      std::cout &lt;&lt; "Input: " &lt;&lt; input &lt;&lt; std::endl;
+
+      int tmp = input.find_last_of("/");
+      std::string prefix = "bin_";
+      std::string output = input.insert(tmp+1, prefix);
+
+      if(pcl::io::savePCDFileBinary(output, *input_cloud) == -1){
+        std::cout &lt;&lt; "Failed saving " &lt;&lt; output &lt;&lt; std::endl;
+        return -1;
+      }
+      std::cout &lt;&lt; "Output: " &lt;&lt; output &lt;&lt; std::endl &lt;&lt; std::endl;
+    }
+
   }
 
   return 0;
-
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="faa485b7b2f9d2d6fdeee49c0faf9ae3401119d0" author="Yukihiro Saito">
		<msg>Fixed a bug. It is don't publish when subscribing topic data is empty.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\obj_fusion.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\obj_fusion.cpp" added_lines="197" deleted_lines="184">
				<diff>@@ -1,16 +1,16 @@
-#include &lt;ros/ros.h&gt;
 #include &lt;cv_tracker/obj_label.h&gt;
+#include &lt;float.h&gt;
+#include &lt;geometry_msgs/Point.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 #include &lt;lidar_tracker/CloudCluster.h&gt;
 #include &lt;lidar_tracker/CloudClusterArray.h&gt;
-#include &lt;geometry_msgs/Point.h&gt;
 #include &lt;math.h&gt;
-#include &lt;float.h&gt;
-#include &lt;tf/tf.h&gt;
-#include &lt;tf/transform_listener.h&gt;
 #include &lt;mutex&gt;
+#include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Time.h&gt;
+#include &lt;tf/tf.h&gt;
+#include &lt;tf/transform_listener.h&gt;
 
 /* flag for comfirming whether multiple topics are received */
 static bool isReady_obj_label;
@@ -34,8 +34,8 @@ static double threshold_min_dist;
 static tf::StampedTransform transform;
 
 struct obj_label_t {
-    std::vector&lt;geometry_msgs::Point&gt; reprojected_positions;
-    std::vector&lt;int&gt; obj_id;
+  std::vector&lt;geometry_msgs::Point&gt; reprojected_positions;
+  std::vector&lt;int&gt; obj_id;
 };
 
 obj_label_t obj_label;
@@ -49,213 +49,226 @@ std::mutex mtx_centroids;
 #define UNLOCK(mtx) (mtx).unlock()
 
 static double euclid_distance(const geometry_msgs::Point pos1,
-                              const geometry_msgs::Point pos2)
-{
-    return sqrt(pow(pos1.x - pos2.x, 2) +
-                pow(pos1.y - pos2.y, 2) +
-                pow(pos1.z - pos2.z, 2));
+                              const geometry_msgs::Point pos2) {
+  return sqrt(pow(pos1.x - pos2.x, 2) + pow(pos1.y - pos2.y, 2) +
+              pow(pos1.z - pos2.z, 2));
 
 } /* static double distance() */
 
-
 /* fusion reprojected position and pointcloud centroids */
-static void fusion_objects(void)
-{
-    obj_label_t obj_label_current;
-    std::vector&lt;lidar_tracker::CloudCluster&gt; v_cloud_cluster_current;
-    std_msgs::Header header = sensor_header;
-    std::vector&lt;geometry_msgs::Point&gt; centroids_current;
-
-    LOCK(mtx_reprojected_positions);
-    copy(obj_label.reprojected_positions.begin(), obj_label.reprojected_positions.end(), back_inserter(obj_label_current.reprojected_positions));
-    copy(obj_label.obj_id.begin(), obj_label.obj_id.end(), back_inserter(obj_label_current.obj_id));
-    UNLOCK(mtx_reprojected_positions);
-
-    LOCK(mtx_centroids);
-    copy(centroids.begin(), centroids.end(), back_inserter(centroids_current));
-    copy(v_cloud_cluster.begin(), v_cloud_cluster.end(), back_inserter(v_cloud_cluster_current));
-    UNLOCK(mtx_centroids);
-
-    if (centroids_current.empty() || obj_label_current.reprojected_positions.empty() ||  obj_label_current.obj_id.empty()) {
-        jsk_recognition_msgs::BoundingBoxArray pub_msg;
-        pub_msg.header = header;
-        std_msgs::Time time;
-        obj_pose_pub.publish(pub_msg);
-
-        time.data = obj_pose_timestamp;
-        obj_pose_timestamp_pub.publish(time);
-        return;
-    }
-
-    std::vector&lt;int&gt; obj_indices;
-
-    for(unsigned int i = 0; i &lt; obj_label_current.obj_id.size(); ++i) {
-        unsigned int min_idx      = 0;
-        double       min_distance = DBL_MAX;
-
-        /* calculate each euclid distance between reprojected position and centroids */
-        for (unsigned int j=0; j&lt;centroids_current.size(); j++) {
-            double distance = euclid_distance(obj_label_current.reprojected_positions.at(i), centroids_current.at(j));
-
-            /* Nearest centroid correspond to this reprojected object */
-            if (distance &lt; min_distance)
-            {
-                min_distance = distance;
-                min_idx      = j;
-            }
-        }
-        if (min_distance &lt; threshold_min_dist) {
-            obj_indices.push_back(min_idx);
-        } else {
-            obj_indices.push_back(-1);
-        }
-    }
-
-    /* Publish marker with centroids coordinates */
+static void fusion_objects(void) {
+  obj_label_t obj_label_current;
+  std::vector&lt;lidar_tracker::CloudCluster&gt; v_cloud_cluster_current;
+  std_msgs::Header header = sensor_header;
+  std::vector&lt;geometry_msgs::Point&gt; centroids_current;
+
+  LOCK(mtx_reprojected_positions);
+  copy(obj_label.reprojected_positions.begin(),
+       obj_label.reprojected_positions.end(),
+       back_inserter(obj_label_current.reprojected_positions));
+  copy(obj_label.obj_id.begin(), obj_label.obj_id.end(),
+       back_inserter(obj_label_current.obj_id));
+  UNLOCK(mtx_reprojected_positions);
+
+  LOCK(mtx_centroids);
+  copy(centroids.begin(), centroids.end(), back_inserter(centroids_current));
+  copy(v_cloud_cluster.begin(), v_cloud_cluster.end(),
+       back_inserter(v_cloud_cluster_current));
+  UNLOCK(mtx_centroids);
+
+  if (centroids_current.empty() ||
+      obj_label_current.reprojected_positions.empty() ||
+      obj_label_current.obj_id.empty()) {
     jsk_recognition_msgs::BoundingBoxArray pub_msg;
     pub_msg.header = header;
+    std_msgs::Time time;
+    obj_pose_pub.publish(pub_msg);
     lidar_tracker::CloudClusterArray cloud_clusters_msg;
     cloud_clusters_msg.header = header;
-
-    for(unsigned int i = 0; i &lt; obj_label_current.obj_id.size(); ++i) {
-        jsk_recognition_msgs::BoundingBox bounding_box;
-        if (obj_indices.at(i) == -1)
-            continue;
-
-        if(object_type == "car")
-          v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box.label = 0;
-        else if(object_type == "person")
-          v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box.label = 1;
-        else
-          v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box.label = 2;
-
-        v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box.value = obj_label_current.obj_id.at(i);
-        bounding_box = v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box;
-        pub_msg.boxes.push_back(bounding_box);
-        cloud_clusters_msg.clusters.push_back(v_cloud_cluster_current.at(obj_indices.at(i)));
-    }
-
-    obj_pose_pub.publish(pub_msg);
     cluster_class_pub.publish(cloud_clusters_msg);
-    std_msgs::Time time;
+
     time.data = obj_pose_timestamp;
     obj_pose_timestamp_pub.publish(time);
+    return;
+  }
+
+  std::vector&lt;int&gt; obj_indices;
+
+  for (unsigned int i = 0; i &lt; obj_label_current.obj_id.size(); ++i) {
+    unsigned int min_idx = 0;
+    double min_distance = DBL_MAX;
+
+    /* calculate each euclid distance between reprojected position and centroids
+     */
+    for (unsigned int j = 0; j &lt; centroids_current.size(); j++) {
+      double distance =
+          euclid_distance(obj_label_current.reprojected_positions.at(i),
+                          centroids_current.at(j));
+
+      /* Nearest centroid correspond to this reprojected object */
+      if (distance &lt; min_distance) {
+        min_distance = distance;
+        min_idx = j;
+      }
+    }
+    if (min_distance &lt; threshold_min_dist) {
+      obj_indices.push_back(min_idx);
+    } else {
+      obj_indices.push_back(-1);
+    }
+  }
+
+  /* Publish marker with centroids coordinates */
+  jsk_recognition_msgs::BoundingBoxArray pub_msg;
+  pub_msg.header = header;
+  lidar_tracker::CloudClusterArray cloud_clusters_msg;
+  cloud_clusters_msg.header = header;
+
+  for (unsigned int i = 0; i &lt; obj_label_current.obj_id.size(); ++i) {
+    jsk_recognition_msgs::BoundingBox bounding_box;
+    if (obj_indices.at(i) == -1)
+      continue;
+
+    v_cloud_cluster_current.at(obj_indices.at(i)).label = object_type;
+
+    if (object_type == "car") {
+      v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box.label = 0;
+    } else if (object_type == "person") {
+      v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box.label = 1;
+    } else {
+      v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box.label = 2;
+      v_cloud_cluster_current.at(obj_indices.at(i)).label = "unknown";
+    }
+    v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box.value =
+        obj_label_current.obj_id.at(i);
+    bounding_box = v_cloud_cluster_current.at(obj_indices.at(i)).bounding_box;
+    pub_msg.boxes.push_back(bounding_box);
+    cloud_clusters_msg.clusters.push_back(
+        v_cloud_cluster_current.at(obj_indices.at(i)));
+  }
+
+  obj_pose_pub.publish(pub_msg);
+  cluster_class_pub.publish(cloud_clusters_msg);
+  std_msgs::Time time;
+  time.data = obj_pose_timestamp;
+  obj_pose_timestamp_pub.publish(time);
 }
 
+void obj_label_cb(const cv_tracker::obj_label &amp;obj_label_msg) {
+  object_type = obj_label_msg.type;
+  obj_pose_timestamp = obj_label_msg.header.stamp;
 
-void obj_label_cb(const cv_tracker::obj_label&amp; obj_label_msg)
-{
-    object_type = obj_label_msg.type;
-    obj_pose_timestamp = obj_label_msg.header.stamp;
+  LOCK(mtx_reprojected_positions);
+  obj_label.reprojected_positions.clear();
+  obj_label.obj_id.clear();
+  UNLOCK(mtx_reprojected_positions);
 
-    LOCK(mtx_reprojected_positions);
-    obj_label.reprojected_positions.clear();
-    obj_label.obj_id.clear();
-    UNLOCK(mtx_reprojected_positions);
+  LOCK(mtx_reprojected_positions);
+  for (unsigned int i = 0; i &lt; obj_label_msg.obj_id.size(); ++i) {
+    obj_label.reprojected_positions.push_back(
+        obj_label_msg.reprojected_pos.at(i));
+    obj_label.obj_id.push_back(obj_label_msg.obj_id.at(i));
+  }
+  UNLOCK(mtx_reprojected_positions);
 
-    LOCK(mtx_reprojected_positions);
-    for (unsigned int i = 0; i &lt; obj_label_msg.obj_id.size(); ++i) {
-        obj_label.reprojected_positions.push_back(obj_label_msg.reprojected_pos.at(i));
-        obj_label.obj_id.push_back(obj_label_msg.obj_id.at(i));
-    }
-    UNLOCK(mtx_reprojected_positions);
+  /* confirm obj_label is subscribed */
+  LOCK(mtx_flag_obj_label);
+  isReady_obj_label = true;
+  UNLOCK(mtx_flag_obj_label);
+
+  /* Publish fusion result if both of topics are ready */
+  if (isReady_obj_label &amp;&amp; isReady_cluster_centroids) {
+    fusion_objects();
 
-    /* confirm obj_label is subscribed */
     LOCK(mtx_flag_obj_label);
-    isReady_obj_label = true;
+    isReady_obj_label = false;
     UNLOCK(mtx_flag_obj_label);
 
-    /* Publish fusion result if both of topics are ready */
-   if (isReady_obj_label &amp;&amp; isReady_cluster_centroids)
-        {
-            fusion_objects();
-
-            LOCK(mtx_flag_obj_label);
-            isReady_obj_label = false;
-            UNLOCK(mtx_flag_obj_label);
-
-            LOCK(mtx_flag_cluster_centroids);
-            isReady_cluster_centroids = false;
-            UNLOCK(mtx_flag_cluster_centroids);
-        }
-
-} /* void obj_label_cb() */
-
-
-void cluster_centroids_cb(const lidar_tracker::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr)
-{
-    LOCK(mtx_centroids);
-    centroids.clear();
-    v_cloud_cluster.clear();
-    UNLOCK(mtx_centroids);
-
-    LOCK(mtx_centroids);
-    static tf::TransformListener trf_listener;
-    try {
-        trf_listener.lookupTransform("map", "velodyne", ros::Time(0), transform);
-        for (int i(0) ; i &lt; (int)in_cloud_cluster_array_ptr-&gt;clusters.size(); ++i) {
-            lidar_tracker::CloudCluster cloud_cluster = in_cloud_cluster_array_ptr-&gt;clusters.at(i);
-            /* convert centroids coodinate from velodyne frame to map frame */
-            tf::Vector3 pt(cloud_cluster.centroid_point.point.x, cloud_cluster.centroid_point.point.y, cloud_cluster.centroid_point.point.z);
-            tf::Vector3 converted = transform * pt;
-            sensor_header = cloud_cluster.header;
-            v_cloud_cluster.push_back(cloud_cluster);
-            geometry_msgs::Point point_in_map;
-            point_in_map.x = converted.x();
-            point_in_map.y = converted.y();
-            point_in_map.z = converted.z();
-
-            centroids.push_back(point_in_map);
-        }
-    }
-    catch (tf::TransformException ex) {
-        ROS_INFO("%s", ex.what());
-        ros::Duration(1.0).sleep();
-    }
-    UNLOCK(mtx_centroids);
-
     LOCK(mtx_flag_cluster_centroids);
-    isReady_cluster_centroids = true;
+    isReady_cluster_centroids = false;
     UNLOCK(mtx_flag_cluster_centroids);
+  }
 
-    /* Publish fusion result if both of topics are ready */
-    if (isReady_obj_label &amp;&amp; isReady_cluster_centroids) {
-        fusion_objects();
-
-        LOCK(mtx_flag_obj_label);
-        isReady_obj_label = false;
-        UNLOCK(mtx_flag_obj_label);
+} /* void obj_label_cb() */
 
-        LOCK(mtx_flag_cluster_centroids);
-        isReady_cluster_centroids = false;
-        UNLOCK(mtx_flag_cluster_centroids);
+void cluster_centroids_cb(
+    const lidar_tracker::CloudClusterArray::Ptr &amp;in_cloud_cluster_array_ptr) {
+  LOCK(mtx_centroids);
+  centroids.clear();
+  v_cloud_cluster.clear();
+  UNLOCK(mtx_centroids);
+
+  LOCK(mtx_centroids);
+  static tf::TransformListener trf_listener;
+  try {
+    trf_listener.lookupTransform("map", "velodyne", ros::Time(0), transform);
+    for (int i(0); i &lt; (int)in_cloud_cluster_array_ptr-&gt;clusters.size(); ++i) {
+      lidar_tracker::CloudCluster cloud_cluster =
+          in_cloud_cluster_array_ptr-&gt;clusters.at(i);
+      /* convert centroids coodinate from velodyne frame to map frame */
+      tf::Vector3 pt(cloud_cluster.centroid_point.point.x,
+                     cloud_cluster.centroid_point.point.y,
+                     cloud_cluster.centroid_point.point.z);
+      tf::Vector3 converted = transform * pt;
+      sensor_header = cloud_cluster.header;
+      v_cloud_cluster.push_back(cloud_cluster);
+      geometry_msgs::Point point_in_map;
+      point_in_map.x = converted.x();
+      point_in_map.y = converted.y();
+      point_in_map.z = converted.z();
+
+      centroids.push_back(point_in_map);
     }
+  } catch (tf::TransformException ex) {
+    ROS_INFO("%s", ex.what());
+    ros::Duration(1.0).sleep();
+  }
+  UNLOCK(mtx_centroids);
 
-} /* void cluster_centroids_cb() */
-
+  LOCK(mtx_flag_cluster_centroids);
+  isReady_cluster_centroids = true;
+  UNLOCK(mtx_flag_cluster_centroids);
 
-int main(int argc, char* argv[])
-{
-    /* ROS initialization */
-    ros::init(argc, argv, "obj_fusion");
+  /* Publish fusion result if both of topics are ready */
+  if (isReady_obj_label &amp;&amp; isReady_cluster_centroids) {
+    fusion_objects();
 
-    ros::NodeHandle n;
-    ros::NodeHandle private_n ("~");
+    LOCK(mtx_flag_obj_label);
+    isReady_obj_label = false;
+    UNLOCK(mtx_flag_obj_label);
 
-    if (private_n.getParam("min_dist", threshold_min_dist))
-  	{
-      threshold_min_dist = 5.0;
-  	}
-    /* Initialize flags */
-    isReady_obj_label         = false;
+    LOCK(mtx_flag_cluster_centroids);
     isReady_cluster_centroids = false;
+    UNLOCK(mtx_flag_cluster_centroids);
+  }
 
-    ros::Subscriber obj_label_sub         = n.subscribe("obj_label", SUBSCRIBE_QUEUE_SIZE, obj_label_cb);
-    ros::Subscriber cluster_centroids_sub = n.subscribe("/cloud_clusters", SUBSCRIBE_QUEUE_SIZE, cluster_centroids_cb);
-    obj_pose_pub = n.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("obj_pose", ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
-	  cluster_class_pub = n.advertise&lt;lidar_tracker::CloudClusterArray&gt;("/cloud_cluster_class", ADVERTISE_QUEUE_SIZE);
-    obj_pose_timestamp_pub = n.advertise&lt;std_msgs::Time&gt;("obj_pose_timestamp", ADVERTISE_QUEUE_SIZE);
-    ros::spin();
+} /* void cluster_centroids_cb() */
 
-    return 0;
+int main(int argc, char *argv[]) {
+  /* ROS initialization */
+  ros::init(argc, argv, "obj_fusion");
+
+  ros::NodeHandle n;
+  ros::NodeHandle private_n("~");
+
+  if (!private_n.getParam("min_dist", threshold_min_dist)) {
+    threshold_min_dist = 2.0;
+  }
+  /* Initialize flags */
+  isReady_obj_label = false;
+  isReady_cluster_centroids = false;
+
+  ros::Subscriber obj_label_sub =
+      n.subscribe("obj_label", SUBSCRIBE_QUEUE_SIZE, obj_label_cb);
+  ros::Subscriber cluster_centroids_sub = n.subscribe(
+      "/cloud_clusters", SUBSCRIBE_QUEUE_SIZE, cluster_centroids_cb);
+  obj_pose_pub = n.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(
+      "obj_pose", ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
+  cluster_class_pub = n.advertise&lt;lidar_tracker::CloudClusterArray&gt;(
+      "/cloud_cluster_class", ADVERTISE_QUEUE_SIZE);
+  obj_pose_timestamp_pub =
+      n.advertise&lt;std_msgs::Time&gt;("obj_pose_timestamp", ADVERTISE_QUEUE_SIZE);
+  ros::spin();
+
+  return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="63d64875fa513b3d5727557169bc6b048b0b8948" author="yukikitsukawa">
		<msg>add max_iterations</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\lazy_ndt_mapping\lazy_ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\lazy_ndt_mapping\lazy_ndt_mapping.cpp" added_lines="6" deleted_lines="4">
				<diff>@@ -87,7 +87,7 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; reference_map;
 
 static pcl::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; ndt;
 // Default values
-static int iter = 30; // Maximum iterations
+static int max_iter = 30; // Maximum iterations
 static float ndt_res = 1.0; // Resolution
 static double step_size = 0.1; // Step size
 static double trans_eps = 0.01; // Transformation epsilon
@@ -129,13 +129,15 @@ static void param_callback(const runtime_manager::ConfigNdtMapping::ConstPtr&amp; in
 {
   ndt_res = input-&gt;resolution;
   step_size = input-&gt;step_size;
-  trans_eps = input-&gt;trans_eps;
+  trans_eps = input-&gt;trans_epsilon;
+  max_iter = input-&gt;max_iterations;
   voxel_leaf_size = input-&gt;leaf_size;
 
   std::cout &lt;&lt; "param_callback" &lt;&lt; std::endl;
   std::cout &lt;&lt; "ndt_res: " &lt;&lt; ndt_res &lt;&lt; std::endl;
   std::cout &lt;&lt; "step_size: " &lt;&lt; step_size &lt;&lt; std::endl;
-  std::cout &lt;&lt; "trans_eps: " &lt;&lt; trans_eps &lt;&lt; std::endl;
+  std::cout &lt;&lt; "trans_epsilon: " &lt;&lt; trans_eps &lt;&lt; std::endl;
+  std::cout &lt;&lt; "max_iter: " &lt;&lt; max_iter &lt;&lt; std::endl;
   std::cout &lt;&lt; "voxel_leaf_size: " &lt;&lt; voxel_leaf_size &lt;&lt; std::endl;
 }
 
@@ -230,7 +232,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     ndt.setTransformationEpsilon(trans_eps);
     ndt.setStepSize(step_size);
     ndt.setResolution(ndt_res);
-    ndt.setMaximumIterations(iter);
+    ndt.setMaximumIterations(max_iter);
     ndt.setInputSource(filtered_scan_ptr);
     
     if(isMapUpdate == true){
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="6" deleted_lines="4">
				<diff>@@ -86,7 +86,7 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; map;
 
 static pcl::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; ndt;
 // Default values
-static int iter = 30;            // Maximum iterations
+static int max_iter = 30;            // Maximum iterations
 static float ndt_res = 1.0;      // Resolution
 static double step_size = 0.1;   // Step size
 static double trans_eps = 0.01;  // Transformation epsilon
@@ -124,13 +124,15 @@ static void param_callback(const runtime_manager::ConfigNdtMapping::ConstPtr&amp; in
 {
   ndt_res = input-&gt;resolution;
   step_size = input-&gt;step_size;
-  trans_eps = input-&gt;trans_eps;
+  trans_eps = input-&gt;trans_epsilon;
+  max_iter = input-&gt;max_iterations;
   voxel_leaf_size = input-&gt;leaf_size;
 
   std::cout &lt;&lt; "param_callback" &lt;&lt; std::endl;
   std::cout &lt;&lt; "ndt_res: " &lt;&lt; ndt_res &lt;&lt; std::endl;
   std::cout &lt;&lt; "step_size: " &lt;&lt; step_size &lt;&lt; std::endl;
-  std::cout &lt;&lt; "trans_eps: " &lt;&lt; trans_eps &lt;&lt; std::endl;
+  std::cout &lt;&lt; "trans_epsilon: " &lt;&lt; trans_eps &lt;&lt; std::endl;
+  std::cout &lt;&lt; "max_iter: " &lt;&lt; max_iter &lt;&lt; std::endl;
   std::cout &lt;&lt; "voxel_leaf_size: " &lt;&lt; voxel_leaf_size &lt;&lt; std::endl;
 }
 
@@ -233,7 +235,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   ndt.setTransformationEpsilon(trans_eps);
   ndt.setStepSize(step_size);
   ndt.setResolution(ndt_res);
-  ndt.setMaximumIterations(iter);
+  ndt.setMaximumIterations(max_iter);
   ndt.setInputSource(filtered_scan_ptr);
 
   if (isMapUpdate == true)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="9" deleted_lines="4">
				<diff>@@ -104,7 +104,7 @@ static int init_pos_set = 0;
 
 static pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;
 // Default values
-static int iter = 30;            // Maximum iterations
+static int max_iter = 30;        // Maximum iterations
 static float ndt_res = 1.0;      // Resolution
 static double step_size = 0.1;   // Step size
 static double trans_eps = 0.01;  // Transformation epsilon
@@ -216,11 +216,16 @@ static void param_callback(const runtime_manager::ConfigNdt::ConstPtr&amp; input)
     step_size = input-&gt;step_size;
     ndt.setStepSize(step_size);
   }
-  if (input-&gt;trans_esp != trans_eps)
+  if (input-&gt;trans_epsilon != trans_eps)
   {
-    trans_eps = input-&gt;trans_esp;
+    trans_eps = input-&gt;trans_epsilon;
     ndt.setTransformationEpsilon(trans_eps);
   }
+  if (input-&gt;max_iterations != max_iter)
+  {
+    max_iter = input-&gt;max_iterations;
+    ndt.setMaximumIterations(max_iter);
+  }
 
   if (_use_gnss == 0 &amp;&amp; init_pos_set == 0)
   {
@@ -307,7 +312,7 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     ndt.setInputTarget(map_ptr);
 
     // Setting NDT parameters to default values
-    ndt.setMaximumIterations(iter);
+    ndt.setMaximumIterations(max_iter);
     ndt.setResolution(ndt_res);
     ndt.setStepSize(step_size);
     ndt.setTransformationEpsilon(trans_eps);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7f067e6174391dc9787b0f3585d1070c83e4ca1f" author="h_ohta">
		<msg>Delete needless file</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\vel_pose_mux\nodes\vel_pose_mux.cpp" new_path="" added_lines="0" deleted_lines="249">
				<diff>@@ -1,249 +0,0 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-// ROS includes
-#include &lt;ros/ros.h&gt;
-#include &lt;geometry_msgs/TwistStamped.h&gt;
-#include &lt;geometry_msgs/PoseStamped.h&gt;
-#include &lt;std_msgs/Float32.h&gt;
-#include "vehicle_socket/CanInfo.h"
-
-
-namespace vel_pose_mux
-{
-
-struct VehicleInfo {
-  double wheel_base;
-  double minimum_turning_radius;
-  double maximum_steering_angle;
-};
-
-inline double kmph2mps(double velocity_kmph)
-{
-  return (velocity_kmph * 1000) / (60 * 60);
-}
-
-inline double mps2kmph(double velocity_mps)
-{
-  return (velocity_mps * 60 * 60) / 1000;
-}
-
-// convert degree to radian
-inline double deg2rad(double deg)
-{
-  return deg * M_PI / 180;
-}
-
-// convert degree to radian
-inline double rad2deg(double rad)
-{
-  return rad * 180 / M_PI;
-}
-
-void callbackFromCanInfoAndPublishAsTwistStamped(const vehicle_socket::CanInfoConstPtr &amp;msg,
-                                                 ros::Publisher *pub_twist_stamped, ros::Publisher *pub_float,
-                                                 const VehicleInfo &amp;vehicle_info)
-{
-  geometry_msgs::TwistStamped tw;
-  tw.header = msg-&gt;header;
-
-  // linear velocity
-  tw.twist.linear.x = kmph2mps(msg-&gt;speed);  // km/h -&gt; m/s
-
-  // angular velocity
-  double maximum_tire_angle = rad2deg(asin(vehicle_info.wheel_base / vehicle_info.minimum_turning_radius));  //[degree]
-  double current_tire_angle =
-      msg-&gt;angle * maximum_tire_angle / vehicle_info.maximum_steering_angle;  // steering [degree] -&gt; tire [degree]
-  tw.twist.angular.z = sin(deg2rad(current_tire_angle)) * kmph2mps(msg-&gt;speed) / vehicle_info.wheel_base;
-
-  pub_twist_stamped-&gt;publish(tw);
-
-  std_msgs::Float32 fl;
-  fl.data = msg-&gt;speed;
-  pub_float-&gt;publish(fl);
-}
-
-void callbackFromCanInfoAndPublishAsTwistStamped(const vehicle_socket::CanInfoConstPtr &amp;msg,
-                                                 ros::Publisher *pub_twist_stamped, ros::Publisher *pub_float)
-{
-  geometry_msgs::TwistStamped tw;
-  tw.header = msg-&gt;header;
-
-  // linear velocity
-  tw.twist.linear.x = kmph2mps(msg-&gt;speed);  // km/h -&gt; m/s
-
-  pub_twist_stamped-&gt;publish(tw);
-
-  std_msgs::Float32 fl;
-  fl.data = msg-&gt;speed;
-  pub_float-&gt;publish(fl);
-}
-
-void callbackFromPoseStampedAndPublish(const geometry_msgs::PoseStampedConstPtr &amp;msg, ros::Publisher *pub_message)
-{
-  pub_message-&gt;publish(*msg);
-}
-
-void callbackFromTwistStampedAndPublish(const geometry_msgs::TwistStampedConstPtr &amp;msg,
-                                        ros::Publisher *pub_twist_stamped, ros::Publisher *pub_float)
-{
-  pub_twist_stamped-&gt;publish(*msg);
-
-  std_msgs::Float32 fl;
-  fl.data = mps2kmph(msg-&gt;twist.linear.x);
-  pub_float-&gt;publish(fl);
-}
-
-}  // namespace
-
-int main(int argc, char **argv)
-{
-  // set up ros
-  ros::init(argc, argv, "vel_pose_mux");
-
-  ros::NodeHandle nh;
-  ros::NodeHandle private_nh("~");
-
-  int32_t pose_mux_select, vel_mux_select;
-  bool sim_mode;
-
-  // setting params
-  private_nh.param&lt;int32_t&gt;("pose_mux_select", pose_mux_select, int32_t(0));
-  // ROS_INFO_STREAM("pose_mux_select : " &lt;&lt; pose_mux_select);
-
-  private_nh.param&lt;int32_t&gt;("vel_mux_select", vel_mux_select, int32_t(1));
-  // ROS_INFO_STREAM("vel_mux_select : " &lt;&lt; vel_mux_select);
-
-  private_nh.param&lt;bool&gt;("sim_mode", sim_mode, false);
-  // ROS_INFO_STREAM("sim_mode : " &lt;&lt; sim_mode);
-
-  bool vehicle_info_flag = false;
-  vel_pose_mux::VehicleInfo vehicle_info;
-  if (!nh.hasParam("/vehicle_info/wheel_base") || !nh.hasParam("/vehicle_info/minimum_turning_radius") ||
-      !nh.hasParam("/vehicle_info/maximum_steering_angle"))
-  {
-    ROS_INFO("vehicle_info is not set");
-  }
-  else
-  {
-    private_nh.getParam("/vehicle_info/wheel_base", vehicle_info.wheel_base);
-    // ROS_INFO_STREAM("wheel_base : " &lt;&lt; wheel_base);
-
-    private_nh.getParam("/vehicle_info/minimum_turning_radius", vehicle_info.minimum_turning_radius);
-    // ROS_INFO_STREAM("minimum_turning_radius : " &lt;&lt; minimum_turning_radius);
-
-    private_nh.getParam("/vehicle_info/maximum_steering_angle", vehicle_info.maximum_steering_angle);  //[degree:
-    // ROS_INFO_STREAM("maximum_steering_angle : " &lt;&lt; maximum_steering_angle);
-
-    vehicle_info_flag = true;
-  }
-
-  // publish topic
-  ros::Publisher vel_publisher = nh.advertise&lt;geometry_msgs::TwistStamped&gt;("current_velocity", 10);
-  ros::Publisher pose_publisher = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("current_pose", 10);
-  ros::Publisher linear_viz_publisher = nh.advertise&lt;std_msgs::Float32&gt;("linear_velocity_viz", 10);
-
-  // subscribe topic
-  ros::Subscriber pose_subcscriber;
-  ros::Subscriber vel_subcscriber;
-
-  if (sim_mode)
-  {
-    vel_subcscriber = nh.subscribe&lt;geometry_msgs::TwistStamped&gt;(
-        "sim_velocity", 10,
-        boost::bind(vel_pose_mux::callbackFromTwistStampedAndPublish, _1, &amp;vel_publisher, &amp;linear_viz_publisher));
-    pose_subcscriber = nh.subscribe&lt;geometry_msgs::PoseStamped&gt;(
-        "sim_pose", 10, boost::bind(vel_pose_mux::callbackFromPoseStampedAndPublish, _1, &amp;pose_publisher));
-  }
-  else
-  {
-    // pose
-    switch (pose_mux_select)
-    {
-      case 0:  // ndt_localizer
-      {
-        pose_subcscriber = nh.subscribe&lt;geometry_msgs::PoseStamped&gt;(
-            "ndt_pose", 10, boost::bind(vel_pose_mux::callbackFromPoseStampedAndPublish, _1, &amp;pose_publisher));
-        break;
-      }
-      case 1:  // gnss
-      {
-        pose_subcscriber = nh.subscribe&lt;geometry_msgs::PoseStamped&gt;(
-            "gnss_pose", 10, boost::bind(vel_pose_mux::callbackFromPoseStampedAndPublish, _1, &amp;pose_publisher));
-        break;
-      }
-      default:
-        break;
-    }
-
-    // velocity
-    switch (vel_mux_select)
-    {
-      case 0:  // ndt_localizer
-      {
-        vel_subcscriber = nh.subscribe&lt;geometry_msgs::TwistStamped&gt;(
-            "estimate_twist", 10,
-            boost::bind(vel_pose_mux::callbackFromTwistStampedAndPublish, _1, &amp;vel_publisher, &amp;linear_viz_publisher));
-        break;
-      }
-      case 1:  // CAN
-      {
-        if (vehicle_info_flag)  // has vehicle info
-        {
-          vel_subcscriber = nh.subscribe&lt;vehicle_socket::CanInfo&gt;(
-              "can_info", 10, boost::bind(vel_pose_mux::callbackFromCanInfoAndPublishAsTwistStamped, _1, &amp;vel_publisher,
-                                          &amp;linear_viz_publisher, vehicle_info));
-        }
-        else
-        {
-          vel_subcscriber = nh.subscribe&lt;vehicle_socket::CanInfo&gt;(
-              "can_info", 10, boost::bind(vel_pose_mux::callbackFromCanInfoAndPublishAsTwistStamped, _1, &amp;vel_publisher,
-                                          &amp;linear_viz_publisher));
-        }
-
-        break;
-      }
-      case 2:  // MKZ
-      {
-          vel_subcscriber = nh.subscribe&lt;geometry_msgs::TwistStamped&gt;(
-              "vehicle/twist", 10, boost::bind(vel_pose_mux::callbackFromTwistStampedAndPublish, _1, &amp;vel_publisher,
-                                          &amp;linear_viz_publisher));
-
-        break;
-      }
-      default:
-        break;
-    }
-  }
-
-  ros::spin();
-
-  return 0;
-}
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d65cd391c1346ab52bac49b7cc902c358e3e3907" author="yukikitsukawa">
		<msg>add max_iterations, min_scan_range and min_add_scan_shift</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\lazy_ndt_mapping\lazy_ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\lazy_ndt_mapping\lazy_ndt_mapping.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -110,8 +110,8 @@ static int initial_scan_loaded = 0;
 
 static Eigen::Matrix4f gnss_transform = Eigen::Matrix4f::Identity();
 
-static double RANGE = 0.0;
-static double SHIFT = 0.0;
+static double min_scan_range = 5.0;
+static double min_add_scan_shift = 1.0;
 static int REFERENCE_MAP_SIZE = 3;
 
 static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
@@ -132,6 +132,8 @@ static void param_callback(const runtime_manager::ConfigNdtMapping::ConstPtr&amp; in
   trans_eps = input-&gt;trans_epsilon;
   max_iter = input-&gt;max_iterations;
   voxel_leaf_size = input-&gt;leaf_size;
+  min_scan_range = input-&gt;min_scan_range;
+  min_add_scan_shift = input-&gt;min_add_scan_shift;
 
   std::cout &lt;&lt; "param_callback" &lt;&lt; std::endl;
   std::cout &lt;&lt; "ndt_res: " &lt;&lt; ndt_res &lt;&lt; std::endl;
@@ -139,6 +141,8 @@ static void param_callback(const runtime_manager::ConfigNdtMapping::ConstPtr&amp; in
   std::cout &lt;&lt; "trans_epsilon: " &lt;&lt; trans_eps &lt;&lt; std::endl;
   std::cout &lt;&lt; "max_iter: " &lt;&lt; max_iter &lt;&lt; std::endl;
   std::cout &lt;&lt; "voxel_leaf_size: " &lt;&lt; voxel_leaf_size &lt;&lt; std::endl;
+  std::cout &lt;&lt; "min_scan_range: " &lt;&lt; min_scan_range &lt;&lt; std::endl;
+  std::cout &lt;&lt; "min_add_scan_shift: " &lt;&lt; min_add_scan_shift &lt;&lt; std::endl;
 }
 
 static void output_callback(const runtime_manager::ConfigNdtMappingOutput::ConstPtr&amp; input)
@@ -206,7 +210,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     	p.intensity = (double) item-&gt;intensity;
 
     	r = sqrt(pow(p.x, 2.0) + pow(p.y, 2.0));
-    	if(r &gt; RANGE){
+    	if(r &gt; min_scan_range){
     		scan.push_back(p);
     	}
     }
@@ -331,7 +335,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     
     // Calculate the shift between added_pose and current_pose
     double shift = sqrt(pow(current_pose.x-added_pose.x, 2.0) + pow(current_pose.y-added_pose.y, 2.0));
-    if(shift &gt;= SHIFT){
+    if(shift &gt;= min_add_scan_shift){
       map += *transformed_scan_ptr;
 
       if(previous_scans.size() &gt;= (unsigned int)REFERENCE_MAP_SIZE){
@@ -443,10 +447,6 @@ int main(int argc, char **argv)
     ros::NodeHandle private_nh("~");
 
     // setting parameters
-    private_nh.getParam("range", RANGE);
-    std::cout &lt;&lt; "RANGE: " &lt;&lt; RANGE &lt;&lt; std::endl;
-    private_nh.getParam("shift", SHIFT);
-    std::cout &lt;&lt; "SHIFT: " &lt;&lt; SHIFT &lt;&lt; std::endl;
     private_nh.getParam("reference_map_size", REFERENCE_MAP_SIZE);
     std::cout &lt;&lt; "REFERENCE_MAP_SIZE: " &lt;&lt; REFERENCE_MAP_SIZE &lt;&lt; std::endl;
     private_nh.getParam("use_openmp", _use_openmp);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -109,8 +109,8 @@ static int initial_scan_loaded = 0;
 
 static Eigen::Matrix4f gnss_transform = Eigen::Matrix4f::Identity();
 
-static double RANGE = 0.0;
-static double SHIFT = 0.0;
+static double min_scan_range = 5.0;
+static double min_add_scan_shift = 1.0;
 
 static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
 static Eigen::Matrix4f tf_btol, tf_ltob;
@@ -127,6 +127,8 @@ static void param_callback(const runtime_manager::ConfigNdtMapping::ConstPtr&amp; in
   trans_eps = input-&gt;trans_epsilon;
   max_iter = input-&gt;max_iterations;
   voxel_leaf_size = input-&gt;leaf_size;
+  min_scan_range = input-&gt;min_scan_range;
+  min_add_scan_shift = input-&gt;min_add_scan_shift;
 
   std::cout &lt;&lt; "param_callback" &lt;&lt; std::endl;
   std::cout &lt;&lt; "ndt_res: " &lt;&lt; ndt_res &lt;&lt; std::endl;
@@ -134,6 +136,8 @@ static void param_callback(const runtime_manager::ConfigNdtMapping::ConstPtr&amp; in
   std::cout &lt;&lt; "trans_epsilon: " &lt;&lt; trans_eps &lt;&lt; std::endl;
   std::cout &lt;&lt; "max_iter: " &lt;&lt; max_iter &lt;&lt; std::endl;
   std::cout &lt;&lt; "voxel_leaf_size: " &lt;&lt; voxel_leaf_size &lt;&lt; std::endl;
+  std::cout &lt;&lt; "min_scan_range: " &lt;&lt; min_scan_range &lt;&lt; std::endl;
+  std::cout &lt;&lt; "min_add_scan_shift: " &lt;&lt; min_add_scan_shift &lt;&lt; std::endl;
 }
 
 static void output_callback(const runtime_manager::ConfigNdtMappingOutput::ConstPtr&amp; input)
@@ -208,7 +212,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     p.intensity = (double)item-&gt;intensity;
 
     r = sqrt(pow(p.x, 2.0) + pow(p.y, 2.0));
-    if (r &gt; RANGE)
+    if (r &gt; min_scan_range)
     {
       scan.push_back(p);
     }
@@ -341,7 +345,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   // Calculate the shift between added_pos and current_pos
   double shift = sqrt(pow(current_pose.x - added_pose.x, 2.0) + pow(current_pose.y - added_pose.y, 2.0));
-  if (shift &gt;= SHIFT)
+  if (shift &gt;= min_add_scan_shift)
   {
     map += *transformed_scan_ptr;
     added_pose.x = current_pose.x;
@@ -436,10 +440,6 @@ int main(int argc, char** argv)
   ros::NodeHandle private_nh("~");
 
   // setting parameters
-  private_nh.getParam("range", RANGE);
-  std::cout &lt;&lt; "RANGE: " &lt;&lt; RANGE &lt;&lt; std::endl;
-  private_nh.getParam("shift", SHIFT);
-  std::cout &lt;&lt; "SHIFT: " &lt;&lt; SHIFT &lt;&lt; std::endl;
   private_nh.getParam("use_openmp", _use_openmp);
   std::cout &lt;&lt; "use_openmp: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c945e6315bb978f8ac3cce4d1e278e0af0597ad6" author="yukikitsukawa">
		<msg>add tf_mapping
select points_topic in points_downsample.launch</msg>
		<modified_files>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" added_lines="4" deleted_lines="1">
				<diff>@@ -54,6 +54,8 @@ static bool _output_log = false;
 static std::ofstream ofs;
 static std::string filename;
 
+static std::string POINTS_TOPIC;
+
 static void config_callback(const runtime_manager::ConfigDistanceFilter::ConstPtr&amp; input)
 {
   sample_num = input-&gt;sample_num;
@@ -141,6 +143,7 @@ int main(int argc, char** argv)
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
 
+  private_nh.getParam("points_topic", POINTS_TOPIC);
   private_nh.getParam("output_log", _output_log);
   if(_output_log == true){
 	  char buffer[80];
@@ -157,7 +160,7 @@ int main(int argc, char** argv)
 
   // Subscribers
   ros::Subscriber config_sub = nh.subscribe("config/distance_filter", 10, config_callback);
-  ros::Subscriber scan_sub = nh.subscribe("points_raw", 10, scan_callback);
+  ros::Subscriber scan_sub = nh.subscribe(POINTS_TOPIC, 10, scan_callback);
 
   ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" added_lines="4" deleted_lines="1">
				<diff>@@ -53,6 +53,8 @@ static bool _output_log = false;
 static std::ofstream ofs;
 static std::string filename;
 
+static std::string POINTS_TOPIC;
+
 static void config_callback(const runtime_manager::ConfigRandomFilter::ConstPtr&amp; input)
 {
   sample_num = input-&gt;sample_num;
@@ -124,6 +126,7 @@ int main(int argc, char** argv)
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
 
+  private_nh.getParam("points_topic", POINTS_TOPIC);
   private_nh.getParam("output_log", _output_log);
   if(_output_log == true){
 	  char buffer[80];
@@ -140,7 +143,7 @@ int main(int argc, char** argv)
 
   // Subscribers
   ros::Subscriber config_sub = nh.subscribe("config/random_filter", 10, config_callback);
-  ros::Subscriber scan_sub = nh.subscribe("points_raw", 10, scan_callback);
+  ros::Subscriber scan_sub = nh.subscribe(POINTS_TOPIC, 10, scan_callback);
 
   ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\ring_filter\ring_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\ring_filter\ring_filter.cpp" added_lines="4" deleted_lines="1">
				<diff>@@ -60,6 +60,8 @@ static bool _output_log = false;
 static std::ofstream ofs;
 static std::string filename;
 
+static std::string POINTS_TOPIC;
+
 static void config_callback(const runtime_manager::ConfigRingFilter::ConstPtr&amp; input)
 {
   ring_div = input-&gt;ring_div;
@@ -162,6 +164,7 @@ int main(int argc, char** argv)
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
 
+  private_nh.getParam("points_topic", POINTS_TOPIC);
   private_nh.getParam("output_log", _output_log);
   if(_output_log == true){
 	  char buffer[80];
@@ -178,7 +181,7 @@ int main(int argc, char** argv)
 
   // Subscribers
   ros::Subscriber config_sub = nh.subscribe("config/ring_filter", 10, config_callback);
-  ros::Subscriber scan_sub = nh.subscribe("points_raw", 10, scan_callback);
+  ros::Subscriber scan_sub = nh.subscribe(POINTS_TOPIC, 10, scan_callback);
 
   ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" added_lines="4" deleted_lines="1">
				<diff>@@ -55,6 +55,8 @@ static bool _output_log = false;
 static std::ofstream ofs;
 static std::string filename;
 
+static std::string POINTS_TOPIC;
+
 static void config_callback(const runtime_manager::ConfigVoxelGridFilter::ConstPtr&amp; input)
 {
   voxel_leaf_size = input-&gt;voxel_leaf_size;
@@ -134,6 +136,7 @@ int main(int argc, char** argv)
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
 
+  private_nh.getParam("points_topic", POINTS_TOPIC);
   private_nh.getParam("output_log", _output_log);
   if(_output_log == true){
 	  char buffer[80];
@@ -150,7 +153,7 @@ int main(int argc, char** argv)
 
   // Subscribers
   ros::Subscriber config_sub = nh.subscribe("config/voxel_grid_filter", 10, config_callback);
-  ros::Subscriber scan_sub = nh.subscribe("points_raw", 10, scan_callback);
+  ros::Subscriber scan_sub = nh.subscribe(POINTS_TOPIC, 10, scan_callback);
 
   ros::spin();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f1d40c48cd8eecaa65112c1060126cca942cb451" author="Yukihiro Saito">
		<msg>Change topic name</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_lidar_track\euclidean_lidar_track.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_lidar_track\euclidean_lidar_track.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -130,7 +130,7 @@ int main(int argc, char *argv[]) {
     threshold_dist = 2.0;
   }
   ros::Subscriber cluster_centroids_sub =
-      n.subscribe("/cloud_cluster_class", 1, cluster_cb);
+      n.subscribe("/cloud_clusters_class", 1, cluster_cb);
   tracked_pub =
       n.advertise&lt;lidar_tracker::DetectedObjectArray&gt;("/detected_objects", 1);
   tracked_bba_pub = n.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\obj_fusion.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\obj_fusion.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -265,7 +265,7 @@ int main(int argc, char *argv[]) {
   obj_pose_pub = n.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(
       "obj_pose", ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
   cluster_class_pub = n.advertise&lt;lidar_tracker::CloudClusterArray&gt;(
-      "/cloud_cluster_class", ADVERTISE_QUEUE_SIZE);
+      "/cloud_clusters_class", ADVERTISE_QUEUE_SIZE);
   obj_pose_timestamp_pub =
       n.advertise&lt;std_msgs::Time&gt;("obj_pose_timestamp", ADVERTISE_QUEUE_SIZE);
   ros::spin();
</diff>
			</file>
		</modified_files>
	</commit>
</Root>
