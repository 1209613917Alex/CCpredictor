<?xml version="1.0" encoding="utf-8"?>
<Root>
	<commit hash="114e7584884bc2591db495a68cd0e345586417a3" author="YamatoAndo">
		<msg>[Feature] negative estimate twist (#1798)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="31" deleted_lines="1">
				<diff>@@ -232,6 +232,30 @@ static unsigned int points_map_num = 0;
 
 pthread_mutex_t mutex;
 
+static pose convertPoseIntoRelativeCoordinate(const pose &amp;target_pose, const pose &amp;reference_pose)
+{
+    tf::Quaternion target_q;
+    target_q.setRPY(target_pose.roll, target_pose.pitch, target_pose.yaw);
+    tf::Vector3 target_v(target_pose.x, target_pose.y, target_pose.z);
+    tf::Transform target_tf(target_q, target_v);
+
+    tf::Quaternion reference_q;
+    reference_q.setRPY(reference_pose.roll, reference_pose.pitch, reference_pose.yaw);
+    tf::Vector3 reference_v(reference_pose.x, reference_pose.y, reference_pose.z);
+    tf::Transform reference_tf(reference_q, reference_v);
+
+    tf::Transform trans_target_tf = reference_tf.inverse() * target_tf;
+
+    pose trans_target_pose;
+    trans_target_pose.x = trans_target_tf.getOrigin().getX();
+    trans_target_pose.y = trans_target_tf.getOrigin().getY();
+    trans_target_pose.z = trans_target_tf.getOrigin().getZ();
+    tf::Matrix3x3 tmp_m(trans_target_tf.getRotation());
+    tmp_m.getRPY(trans_target_pose.roll, trans_target_pose.pitch, trans_target_pose.yaw);
+
+    return trans_target_pose;
+}
+
 static void param_callback(const autoware_config_msgs::ConfigNDT::ConstPtr&amp; input)
 {
   if (_use_gnss != input-&gt;init_pos_gnss)
@@ -545,8 +569,11 @@ static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
     diff_yaw = current_pose.yaw - previous_pose.yaw;
     diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);
 
+    const pose trans_current_pose = convertPoseIntoRelativeCoordinate(current_pose, previous_pose);
+
     const double diff_time = (current_gnss_time - previous_gnss_time).toSec();
     current_velocity = (diff_time &gt; 0) ? (diff / diff_time) : 0;
+    current_velocity =  (trans_current_pose.x &gt;= 0) ? current_velocity : -current_velocity;
     current_velocity_x = (diff_time &gt; 0) ? (diff_x / diff_time) : 0;
     current_velocity_y = (diff_time &gt; 0) ? (diff_y / diff_time) : 0;
     current_velocity_z = (diff_time &gt; 0) ? (diff_z / diff_time) : 0;
@@ -1131,7 +1158,10 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     diff_yaw = calcDiffForRadian(current_pose.yaw, previous_pose.yaw);
     diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);
 
+    const pose trans_current_pose = convertPoseIntoRelativeCoordinate(current_pose, previous_pose);
+
     current_velocity = (diff_time &gt; 0) ? (diff / diff_time) : 0;
+    current_velocity =  (trans_current_pose.x &gt;= 0) ? current_velocity : -current_velocity;
     current_velocity_x = (diff_time &gt; 0) ? (diff_x / diff_time) : 0;
     current_velocity_y = (diff_time &gt; 0) ? (diff_y / diff_time) : 0;
     current_velocity_z = (diff_time &gt; 0) ? (diff_z / diff_time) : 0;
@@ -1163,7 +1193,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     current_pose_imu_odom.yaw = current_pose.yaw;
 
     current_velocity_smooth = (current_velocity + previous_velocity + previous_previous_velocity) / 3.0;
-    if (current_velocity_smooth &lt; 0.2)
+    if (std::fabs(current_velocity_smooth) &lt; 0.2)
     {
       current_velocity_smooth = 0.0;
     }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="be923156d525508e6a2eea77fd4b372227cf749a" author="YamatoAndo">
		<msg>add constructor (#1913)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\gnss\include\gnss\geo_pos_conv.hpp" new_path="ros\src\computing\perception\localization\lib\gnss\include\gnss\geo_pos_conv.hpp" added_lines="3" deleted_lines="2">
				<diff>@@ -12,15 +12,16 @@ private:
 	double m_lat;  //latitude
 	double m_lon; //longitude
 	double m_h;
-  
+
 	double m_PLato;        //plane lat
 	double m_PLo;          //plane lon
 
 public:
+	geo_pos_conv();
 	double x() const;
 	double y() const;
 	double z() const;
-  
+
 	void set_plane(double lat,   double lon);
 	void set_plane(int num);
 	void set_xyz(double cx,   double cy,   double cz);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\gnss\src\geo_pos_conv.cpp" new_path="ros\src\computing\perception\localization\lib\gnss\src\geo_pos_conv.cpp" added_lines="12" deleted_lines="0">
				<diff>@@ -16,6 +16,18 @@
 
 #include &lt;gnss/geo_pos_conv.hpp&gt;
 
+geo_pos_conv::geo_pos_conv()
+    : m_x(0)
+    , m_y(0)
+    , m_z(0)
+    , m_lat(0)
+    , m_lon(0)
+    , m_h(0)
+    , m_PLato(0)
+    , m_PLo(0)
+{
+}
+
 double geo_pos_conv::x() const
 {
   return m_x;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="92425d7de662e05b6eca7fc40eb05152bd340e0b" author="ChenxiTU">
		<msg>Feature/RosbagController (#1791)

* add rviz plugin RosbagController

* add rosbag_controller

* refine core and add specify the license

* Fix runtime warning and aborting

* sort topics alphabetically

* add license in .cpp .h</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\autoware_rviz_plugins\src\sim_object\autoware_flag_tool.cpp" new_path="ros\src\util\packages\autoware_rviz_plugins\state_panel\src\sim_object\autoware_flag_tool.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\util\packages\autoware_rviz_plugins\src\sim_object\autoware_flag_tool.h" new_path="ros\src\util\packages\autoware_rviz_plugins\state_panel\src\sim_object\autoware_flag_tool.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\util\packages\autoware_rviz_plugins\src\sim_object\flag.h" new_path="ros\src\util\packages\autoware_rviz_plugins\state_panel\src\sim_object\flag.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\util\packages\autoware_rviz_plugins\src\state_panel\state_panel.cpp" new_path="ros\src\util\packages\autoware_rviz_plugins\state_panel\src\state_panel\state_panel.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\util\packages\autoware_rviz_plugins\src\state_panel\state_panel.h" new_path="ros\src\util\packages\autoware_rviz_plugins\state_panel\src\state_panel\state_panel.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4af8736e6111050469c3a8b166a8ecae91d20faa" author="Yukihiro SAITO">
		<msg>fixed bug (vehicle_gazebo_input_subscriber)</msg>
		<modified_files>
			<file old_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_input_subscriber.cpp" new_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_input_subscriber.cpp" added_lines="16" deleted_lines="18">
				<diff>@@ -66,9 +66,8 @@ VehicleGazeboInputSubscriber::VehicleGazeboInputSubscriber() : nh_(""), pnh_("~"
 
 void VehicleGazeboInputSubscriber::twistStampedCallback(const geometry_msgs::TwistStamped::ConstPtr &amp;input_twist_msg)
 {
-    std_msgs::Float64 output_wheel_right_rear, output_wheel_left_rear, output_steering_right_front, output_steering_left_front;
-    output_wheel_right_rear.data = input_twist_msg-&gt;twist.linear.x / wheel_radius_;
-    output_wheel_left_rear.data = input_twist_msg-&gt;twist.linear.x / wheel_radius_;
+    std_msgs::Float64 output_wheel_rear, output_steering_right_front, output_steering_left_front;
+    output_wheel_rear.data = input_twist_msg-&gt;twist.linear.x / wheel_radius_;
 
     double vref_rear = input_twist_msg-&gt;twist.linear.x;
     if (std::fabs(vref_rear) &lt; 0.01)
@@ -86,17 +85,16 @@ void VehicleGazeboInputSubscriber::twistStampedCallback(const geometry_msgs::Twi
     output_steering_right_front.data = std::atan(std::tan(delta_ref) / (1.0 + (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
     output_steering_left_front.data = std::atan(std::tan(delta_ref) / (1.0 - (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
 
-    wheel_right_rear_pub_.publish(output_wheel_right_rear);
-    wheel_left_rear_pub_.publish(output_wheel_left_rear);
+    wheel_right_rear_pub_.publish(output_wheel_rear);
+    wheel_left_rear_pub_.publish(output_wheel_rear);
     steering_right_front_pub_.publish(output_steering_right_front);
     steering_left_front_pub_.publish(output_steering_left_front);
 }
 
 void VehicleGazeboInputSubscriber::twistCallback(const geometry_msgs::Twist::ConstPtr &amp;input_twist_msg)
 {
-    std_msgs::Float64 output_wheel_right_rear, output_wheel_left_rear, output_steering_right_front, output_steering_left_front;
-    output_wheel_right_rear.data = input_twist_msg-&gt;linear.x / wheel_radius_;
-    output_wheel_left_rear.data = input_twist_msg-&gt;linear.x / wheel_radius_;
+    std_msgs::Float64 output_wheel_rear, output_steering_right_front, output_steering_left_front;
+    output_wheel_rear.data = input_twist_msg-&gt;linear.x / wheel_radius_;
 
     double vref_rear = input_twist_msg-&gt;linear.x;
     if (std::fabs(vref_rear) &lt; 0.01)
@@ -114,8 +112,8 @@ void VehicleGazeboInputSubscriber::twistCallback(const geometry_msgs::Twist::Con
     output_steering_right_front.data = std::atan(std::tan(delta_ref) / (1.0 + (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
     output_steering_left_front.data = std::atan(std::tan(delta_ref) / (1.0 - (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
 
-    wheel_right_rear_pub_.publish(output_wheel_right_rear);
-    wheel_left_rear_pub_.publish(output_wheel_left_rear);
+    wheel_right_rear_pub_.publish(output_wheel_rear);
+    wheel_left_rear_pub_.publish(output_wheel_rear);
     steering_right_front_pub_.publish(output_steering_right_front);
     steering_left_front_pub_.publish(output_steering_left_front);
 }
@@ -138,26 +136,26 @@ void VehicleGazeboInputSubscriber::sterringAngleCallback(const std_msgs::Float64
 
 void VehicleGazeboInputSubscriber::velocityCallback(const std_msgs::Float64::ConstPtr &amp;input_velocity_msg)
 {
-    wheel_right_rear_pub_.publish(input_velocity_msg);
-    wheel_left_rear_pub_.publish(input_velocity_msg);
+    std_msgs::Float64 output_wheel_rear;
+    output_wheel_rear.data = input_velocity_msg-&gt;data / wheel_radius_;
+    wheel_right_rear_pub_.publish(output_wheel_rear);
+    wheel_left_rear_pub_.publish(output_wheel_rear);
 }
 
 void VehicleGazeboInputSubscriber::controlCommandStampedCallback(const autoware_msgs::ControlCommandStamped::ConstPtr &amp;input_msg)
 {
-    std_msgs::Float64 output_wheel_right_rear, output_wheel_left_rear, output_steering_right_front, output_steering_left_front;
+    std_msgs::Float64 output_wheel_rear, output_steering_right_front, output_steering_left_front;
 
     double delta_ref = input_msg-&gt;cmd.steering_angle;
     if (M_PI / 4.0 &lt; std::fabs(delta_ref))
     {
         delta_ref = 0.0 &lt; delta_ref ? M_PI / 4.0 : -M_PI / 4.0;
     }
-
     output_steering_right_front.data = std::atan(std::tan(delta_ref) / (1.0 + (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
     output_steering_left_front.data = std::atan(std::tan(delta_ref) / (1.0 - (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
-    output_wheel_right_rear.data = input_msg-&gt;cmd.linear_velocity;
-    output_wheel_left_rear.data = input_msg-&gt;cmd.linear_velocity;
-    wheel_right_rear_pub_.publish(output_wheel_right_rear);
-    wheel_left_rear_pub_.publish(output_wheel_left_rear);
+    output_wheel_rear.data = input_msg-&gt;cmd.linear_velocity / wheel_radius_;
+    wheel_right_rear_pub_.publish(output_wheel_rear);
+    wheel_left_rear_pub_.publish(output_wheel_rear);
     steering_right_front_pub_.publish(output_steering_right_front);
     steering_left_front_pub_.publish(output_steering_left_front);
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="eb9cf22a8f4a4ca76341822b0ec7f910f28b49ea" author="Yukihiro SAITO">
		<msg>add comment for vehicle_gazebo_input_subscriber</msg>
		<modified_files>
			<file old_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_input_subscriber.cpp" new_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_input_subscriber.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -70,14 +70,14 @@ void VehicleGazeboInputSubscriber::twistStampedCallback(const geometry_msgs::Twi
     output_wheel_rear.data = input_twist_msg-&gt;twist.linear.x / wheel_radius_;
 
     double vref_rear = input_twist_msg-&gt;twist.linear.x;
-    if (std::fabs(vref_rear) &lt; 0.01)
+    if (std::fabs(vref_rear) &lt; 0.01) // Prevent zero division when calculating ackerman steering
     {
         vref_rear = 0.0 &lt; vref_rear ? 0.01 : -0.01;
     }
 
     double delta_ref = std::atan(input_twist_msg-&gt;twist.angular.z * wheel_base_ / vref_rear);
     delta_ref = 0.0 &lt; vref_rear ? delta_ref : -delta_ref;
-    if (M_PI / 4.0 &lt; std::fabs(delta_ref))
+    if (M_PI / 4.0 &lt; std::fabs(delta_ref)) // It is a constraint that the theory does not turn more than 90 degrees
     {
         delta_ref = 0.0 &lt; delta_ref ? M_PI / 4.0 : -M_PI / 4.0;
     }
@@ -97,14 +97,14 @@ void VehicleGazeboInputSubscriber::twistCallback(const geometry_msgs::Twist::Con
     output_wheel_rear.data = input_twist_msg-&gt;linear.x / wheel_radius_;
 
     double vref_rear = input_twist_msg-&gt;linear.x;
-    if (std::fabs(vref_rear) &lt; 0.01)
+    if (std::fabs(vref_rear) &lt; 0.01) // Prevent zero division when calculating ackerman steering
     {
         vref_rear = 0.0 &lt; vref_rear ? 0.01 : -0.01;
     }
 
     double delta_ref = std::atan(input_twist_msg-&gt;angular.z * wheel_base_ / vref_rear);
     delta_ref = 0.0 &lt; vref_rear ? delta_ref : -delta_ref;
-    if (M_PI / 4.0 &lt; std::fabs(delta_ref))
+    if (M_PI / 4.0 &lt; std::fabs(delta_ref)) // It is a constraint that the theory does not turn more than 90 degrees
     {
         delta_ref = 0.0 &lt; delta_ref ? M_PI / 4.0 : -M_PI / 4.0;
     }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d77454e8fe4ca3f5bea3233cf5c11cd185db0bca" author="Yukihiro SAITO">
		<msg>cosmetic change</msg>
		<modified_files>
			<file old_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_input_subscriber.cpp" new_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_input_subscriber.cpp" added_lines="18" deleted_lines="12">
				<diff>@@ -70,16 +70,18 @@ void VehicleGazeboInputSubscriber::twistStampedCallback(const geometry_msgs::Twi
     output_wheel_rear.data = input_twist_msg-&gt;twist.linear.x / wheel_radius_;
 
     double vref_rear = input_twist_msg-&gt;twist.linear.x;
-    if (std::fabs(vref_rear) &lt; 0.01) // Prevent zero division when calculating ackerman steering
+    constexpr double min_vref_rear = 0.01;
+    if (std::fabs(vref_rear) &lt; min_vref_rear) // Prevent zero division when calculating ackerman steering
     {
-        vref_rear = 0.0 &lt; vref_rear ? 0.01 : -0.01;
+        vref_rear = 0.0 &lt; vref_rear ? min_vref_rear : -min_vref_rear;
     }
 
     double delta_ref = std::atan(input_twist_msg-&gt;twist.angular.z * wheel_base_ / vref_rear);
     delta_ref = 0.0 &lt; vref_rear ? delta_ref : -delta_ref;
-    if (M_PI / 4.0 &lt; std::fabs(delta_ref)) // It is a constraint that the theory does not turn more than 90 degrees
+    constexpr double max_delta_ref = M_PI / 4.0;
+    if (max_delta_ref &lt; std::fabs(delta_ref)) // It is a constraint that the theory does not turn more than 90 degrees
     {
-        delta_ref = 0.0 &lt; delta_ref ? M_PI / 4.0 : -M_PI / 4.0;
+        delta_ref = 0.0 &lt; delta_ref ? max_delta_ref : -max_delta_ref;
     }
 
     output_steering_right_front.data = std::atan(std::tan(delta_ref) / (1.0 + (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
@@ -97,16 +99,18 @@ void VehicleGazeboInputSubscriber::twistCallback(const geometry_msgs::Twist::Con
     output_wheel_rear.data = input_twist_msg-&gt;linear.x / wheel_radius_;
 
     double vref_rear = input_twist_msg-&gt;linear.x;
-    if (std::fabs(vref_rear) &lt; 0.01) // Prevent zero division when calculating ackerman steering
+    constexpr double min_vref_rear = 0.01;
+    if (std::fabs(vref_rear) &lt; min_vref_rear) // Prevent zero division when calculating ackerman steering
     {
-        vref_rear = 0.0 &lt; vref_rear ? 0.01 : -0.01;
+        vref_rear = 0.0 &lt; vref_rear ? min_vref_rear : -min_vref_rear;
     }
 
     double delta_ref = std::atan(input_twist_msg-&gt;angular.z * wheel_base_ / vref_rear);
     delta_ref = 0.0 &lt; vref_rear ? delta_ref : -delta_ref;
-    if (M_PI / 4.0 &lt; std::fabs(delta_ref)) // It is a constraint that the theory does not turn more than 90 degrees
+    constexpr double max_delta_ref = M_PI / 4.0;
+    if (max_delta_ref &lt; std::fabs(delta_ref)) // It is a constraint that the theory does not turn more than 90 degrees
     {
-        delta_ref = 0.0 &lt; delta_ref ? M_PI / 4.0 : -M_PI / 4.0;
+        delta_ref = 0.0 &lt; delta_ref ? max_delta_ref : -max_delta_ref;
     }
 
     output_steering_right_front.data = std::atan(std::tan(delta_ref) / (1.0 + (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
@@ -123,9 +127,10 @@ void VehicleGazeboInputSubscriber::sterringAngleCallback(const std_msgs::Float64
     std_msgs::Float64 output_steering_right_front, output_steering_left_front;
 
     double delta_ref = input_steering_angle_msg-&gt;data;
-    if (M_PI / 4.0 &lt; std::fabs(delta_ref))
+    constexpr double max_delta_ref = M_PI / 4.0;
+    if (max_delta_ref &lt; std::fabs(delta_ref)) // It is a constraint that the theory does not turn more than 90 degrees
     {
-        delta_ref = 0.0 &lt; delta_ref ? M_PI / 4.0 : -M_PI / 4.0;
+        delta_ref = 0.0 &lt; delta_ref ? max_delta_ref : -max_delta_ref;
     }
     output_steering_right_front.data = std::atan(std::tan(delta_ref) / (1.0 + (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
     output_steering_left_front.data = std::atan(std::tan(delta_ref) / (1.0 - (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
@@ -147,9 +152,10 @@ void VehicleGazeboInputSubscriber::controlCommandStampedCallback(const autoware_
     std_msgs::Float64 output_wheel_rear, output_steering_right_front, output_steering_left_front;
 
     double delta_ref = input_msg-&gt;cmd.steering_angle;
-    if (M_PI / 4.0 &lt; std::fabs(delta_ref))
+    constexpr double max_delta_ref = M_PI / 4.0;
+    if (max_delta_ref &lt; std::fabs(delta_ref)) // It is a constraint that the theory does not turn more than 90 degrees
     {
-        delta_ref = 0.0 &lt; delta_ref ? M_PI / 4.0 : -M_PI / 4.0;
+        delta_ref = 0.0 &lt; delta_ref ? max_delta_ref : -max_delta_ref;
     }
     output_steering_right_front.data = std::atan(std::tan(delta_ref) / (1.0 + (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
     output_steering_left_front.data = std::atan(std::tan(delta_ref) / (1.0 - (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ce223de115d0e234645ff8d596629a25a73f4a4b" author="Yukihiro SAITO">
		<msg>subscribe autoware_msgs::VehicleCmd message</msg>
		<modified_files>
			<file old_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_input_subscriber.cpp" new_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_input_subscriber.cpp" added_lines="55" deleted_lines="48">
				<diff>@@ -3,7 +3,8 @@
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;std_msgs/Float64.h&gt;
 #include &lt;cmath&gt;
-#include &lt;autoware_msgs/ControlCommandStamped.h&gt;
+#include &lt;autoware_msgs/ControlCommand.h&gt;
+#include &lt;autoware_msgs/VehicleCmd.h&gt;
 
 class VehicleGazeboInputSubscriber
 {
@@ -14,21 +15,22 @@ class VehicleGazeboInputSubscriber
     ros::Publisher wheel_left_rear_pub_;
     ros::Publisher steering_right_front_pub_;
     ros::Publisher steering_left_front_pub_;
-    ros::Subscriber twiststamped_sub_;
     ros::Subscriber twist_sub_;
     ros::Subscriber steering_angle_sub_;
     ros::Subscriber velocity_sub_;
-    ros::Subscriber ctrl_cmd_sub_;
+    ros::Subscriber vehicle_cmd_sub_;
 
-    void twistStampedCallback(const geometry_msgs::TwistStamped::ConstPtr &amp;input_twist_msg);
     void twistCallback(const geometry_msgs::Twist::ConstPtr &amp;input_twist_msg);
     void sterringAngleCallback(const std_msgs::Float64::ConstPtr &amp;input_steering_angle_msg);
     void velocityCallback(const std_msgs::Float64::ConstPtr &amp;input_velocity_msg);
-    void controlCommandStampedCallback(const autoware_msgs::ControlCommandStamped::ConstPtr &amp;input_msg);
-
+    void vehicleCmdCallback(const autoware_msgs::VehicleCmd::ConstPtr &amp;input_msg);
+    void publishControlCommandStamped2Gazebo(const autoware_msgs::ControlCommand &amp;input_msg);
+    void publishTwistStamped2Gazebo(const geometry_msgs::TwistStamped &amp;input_twist_msg);
     double wheel_base_;
     double wheel_tread_;
     double wheel_radius_;
+    bool twiststamped_;
+    bool ctrl_cmd_;
 
   public:
     VehicleGazeboInputSubscriber();
@@ -41,56 +43,24 @@ VehicleGazeboInputSubscriber::VehicleGazeboInputSubscriber() : nh_(""), pnh_("~"
     pnh_.param("wheel_base", wheel_base_, 2.95);
     pnh_.param("wheel_radius", wheel_radius_, 0.341);
     pnh_.param("wheel_tread", wheel_tread_, 1.55);
-    bool twist_sub, twiststamped_sub, steering_angle_sub, velocity_sub, cmd_vel_sub, ctrl_cmd_sub;
-    pnh_.param("twist_sub", twist_sub, true);
-    pnh_.param("twiststamped_sub", twiststamped_sub, false);
-    pnh_.param("steering_angle_sub", steering_angle_sub, false);
-    pnh_.param("velocity_sub", velocity_sub, false);
-    pnh_.param("ctrl_cmd_sub", ctrl_cmd_sub, true);
+    pnh_.param("twiststamped_", twiststamped_, true);
+    pnh_.param("ctrl_cmd", ctrl_cmd_, false);
     wheel_right_rear_pub_ = nh_.advertise&lt;std_msgs::Float64&gt;("wheel_right_rear_velocity_controller/command", 1, true);
     wheel_left_rear_pub_ = nh_.advertise&lt;std_msgs::Float64&gt;("wheel_left_rear_velocity_controller/command", 1, true);
     steering_right_front_pub_ = nh_.advertise&lt;std_msgs::Float64&gt;("steering_right_front_position_controller/command", 1, true);
     steering_left_front_pub_ = nh_.advertise&lt;std_msgs::Float64&gt;("steering_left_front_position_controller/command", 1, true);
 
+    bool twist_sub, steering_angle_sub, velocity_sub;
+    pnh_.param("twist_sub", twist_sub, true);
+    pnh_.param("steering_angle_sub", steering_angle_sub, false);
+    pnh_.param("velocity_sub", velocity_sub, false);
     if (twist_sub)
         twist_sub_ = nh_.subscribe("/cmd_vel", 1, &amp;VehicleGazeboInputSubscriber::twistCallback, this);
-    if (twiststamped_sub)
-        twiststamped_sub_ = nh_.subscribe("/twist_cmd", 1, &amp;VehicleGazeboInputSubscriber::twistStampedCallback, this);
     if (steering_angle_sub)
         steering_angle_sub_ = nh_.subscribe("/steering_angle", 1, &amp;VehicleGazeboInputSubscriber::sterringAngleCallback, this);
     if (velocity_sub)
         velocity_sub_ = nh_.subscribe("/velocity", 1, &amp;VehicleGazeboInputSubscriber::velocityCallback, this);
-    if (ctrl_cmd_sub)
-        ctrl_cmd_sub_ = nh_.subscribe("/ctrl_cmd", 1, &amp;VehicleGazeboInputSubscriber::controlCommandStampedCallback, this);
-}
-
-void VehicleGazeboInputSubscriber::twistStampedCallback(const geometry_msgs::TwistStamped::ConstPtr &amp;input_twist_msg)
-{
-    std_msgs::Float64 output_wheel_rear, output_steering_right_front, output_steering_left_front;
-    output_wheel_rear.data = input_twist_msg-&gt;twist.linear.x / wheel_radius_;
-
-    double vref_rear = input_twist_msg-&gt;twist.linear.x;
-    constexpr double min_vref_rear = 0.01;
-    if (std::fabs(vref_rear) &lt; min_vref_rear) // Prevent zero division when calculating ackerman steering
-    {
-        vref_rear = 0.0 &lt; vref_rear ? min_vref_rear : -min_vref_rear;
-    }
-
-    double delta_ref = std::atan(input_twist_msg-&gt;twist.angular.z * wheel_base_ / vref_rear);
-    delta_ref = 0.0 &lt; vref_rear ? delta_ref : -delta_ref;
-    constexpr double max_delta_ref = M_PI / 4.0;
-    if (max_delta_ref &lt; std::fabs(delta_ref)) // It is a constraint that the theory does not turn more than 90 degrees
-    {
-        delta_ref = 0.0 &lt; delta_ref ? max_delta_ref : -max_delta_ref;
-    }
-
-    output_steering_right_front.data = std::atan(std::tan(delta_ref) / (1.0 + (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
-    output_steering_left_front.data = std::atan(std::tan(delta_ref) / (1.0 - (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
-
-    wheel_right_rear_pub_.publish(output_wheel_rear);
-    wheel_left_rear_pub_.publish(output_wheel_rear);
-    steering_right_front_pub_.publish(output_steering_right_front);
-    steering_left_front_pub_.publish(output_steering_left_front);
+    vehicle_cmd_sub_ = nh_.subscribe("/vehicle_cmd", 1, &amp;VehicleGazeboInputSubscriber::vehicleCmdCallback, this);
 }
 
 void VehicleGazeboInputSubscriber::twistCallback(const geometry_msgs::Twist::ConstPtr &amp;input_twist_msg)
@@ -147,19 +117,56 @@ void VehicleGazeboInputSubscriber::velocityCallback(const std_msgs::Float64::Con
     wheel_left_rear_pub_.publish(output_wheel_rear);
 }
 
-void VehicleGazeboInputSubscriber::controlCommandStampedCallback(const autoware_msgs::ControlCommandStamped::ConstPtr &amp;input_msg)
+void VehicleGazeboInputSubscriber::vehicleCmdCallback(const autoware_msgs::VehicleCmd::ConstPtr &amp;input_msg)
+{
+    if (twiststamped_)
+        publishTwistStamped2Gazebo(input_msg-&gt;twist_cmd);
+    if (ctrl_cmd_)
+        publishControlCommandStamped2Gazebo(input_msg-&gt;ctrl_cmd);
+}
+
+void VehicleGazeboInputSubscriber::publishControlCommandStamped2Gazebo(const autoware_msgs::ControlCommand &amp;input_msg)
+{
+    std_msgs::Float64 output_wheel_rear, output_steering_right_front, output_steering_left_front;
+
+    double delta_ref = input_msg.steering_angle;
+    constexpr double max_delta_ref = M_PI / 4.0;
+    if (max_delta_ref &lt; std::fabs(delta_ref)) // It is a constraint that the theory does not turn more than 90 degrees
+    {
+        delta_ref = 0.0 &lt; delta_ref ? max_delta_ref : -max_delta_ref;
+    }
+    output_steering_right_front.data = std::atan(std::tan(delta_ref) / (1.0 + (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
+    output_steering_left_front.data = std::atan(std::tan(delta_ref) / (1.0 - (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
+    output_wheel_rear.data = input_msg.linear_velocity / wheel_radius_;
+    wheel_right_rear_pub_.publish(output_wheel_rear);
+    wheel_left_rear_pub_.publish(output_wheel_rear);
+    steering_right_front_pub_.publish(output_steering_right_front);
+    steering_left_front_pub_.publish(output_steering_left_front);
+}
+
+void VehicleGazeboInputSubscriber::publishTwistStamped2Gazebo(const geometry_msgs::TwistStamped &amp;input_twist_msg)
 {
     std_msgs::Float64 output_wheel_rear, output_steering_right_front, output_steering_left_front;
+    output_wheel_rear.data = input_twist_msg.twist.linear.x / wheel_radius_;
 
-    double delta_ref = input_msg-&gt;cmd.steering_angle;
+    double vref_rear = input_twist_msg.twist.linear.x;
+    constexpr double min_vref_rear = 0.01;
+    if (std::fabs(vref_rear) &lt; min_vref_rear) // Prevent zero division when calculating ackerman steering
+    {
+        vref_rear = 0.0 &lt; vref_rear ? min_vref_rear : -min_vref_rear;
+    }
+
+    double delta_ref = std::atan(input_twist_msg.twist.angular.z * wheel_base_ / vref_rear);
+    delta_ref = 0.0 &lt; vref_rear ? delta_ref : -delta_ref;
     constexpr double max_delta_ref = M_PI / 4.0;
     if (max_delta_ref &lt; std::fabs(delta_ref)) // It is a constraint that the theory does not turn more than 90 degrees
     {
         delta_ref = 0.0 &lt; delta_ref ? max_delta_ref : -max_delta_ref;
     }
+
     output_steering_right_front.data = std::atan(std::tan(delta_ref) / (1.0 + (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
     output_steering_left_front.data = std::atan(std::tan(delta_ref) / (1.0 - (wheel_tread_ / (2.0 * wheel_base_)) * std::tan(delta_ref)));
-    output_wheel_rear.data = input_msg-&gt;cmd.linear_velocity / wheel_radius_;
+
     wheel_right_rear_pub_.publish(output_wheel_rear);
     wheel_left_rear_pub_.publish(output_wheel_rear);
     steering_right_front_pub_.publish(output_steering_right_front);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="38204b91ba030295cc00832809e53038c4e51091" author="Yukihiro SAITO">
		<msg>publish tf and twist from gazebo</msg>
		<modified_files>
			<file old_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_info_publisher.cpp" new_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_info_publisher.cpp" added_lines="70" deleted_lines="6">
				<diff>@@ -1,9 +1,18 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Float64.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
+#include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;gazebo_msgs/GetLinkState.h&gt;
 #include &lt;sensor_msgs/JointState.h&gt;
 #include &lt;autoware_msgs/VehicleStatus.h&gt;
+#include &lt;tf2_ros/transform_broadcaster.h&gt;
+#include &lt;geometry_msgs/TransformStamped.h&gt;
+#include &lt;tf2/transform_datatypes.h&gt;
+#include &lt;tf2/convert.h&gt;
+#include &lt;tf2/LinearMath/Transform.h&gt;
+#include &lt;tf2_ros/transform_listener.h&gt;
+#include &lt;tf2_ros/buffer.h&gt;
+#include &lt;tf2_geometry_msgs/tf2_geometry_msgs.h&gt;
 #include &lt;string&gt;
 #include &lt;cmath&gt;
 
@@ -14,13 +23,19 @@ class VehicleGazeboInfoPublisher
     ros::NodeHandle pnh_;
     ros::ServiceClient client_;
     ros::Publisher vehicle_pose_pub_;
+    ros::Publisher vehicle_twist_pub_;
     ros::Publisher vehicle_vel_pub_;
     ros::Publisher steering_angle_pub_;
     ros::Publisher vehicle_status_pub_;
     ros::Timer publish_timer_; // publish timer
     ros::Subscriber odom_sub_;
+    tf2_ros::TransformBroadcaster tf_broadcaster_;
+    tf2_ros::Buffer tf_buffer_;
+    tf2_ros::TransformListener tf_listener_;
     double wheel_radius_;
+    double wheel_base_;
     std::string ns_;
+    bool enable_base_link_tf_;
     void publishTimerCallback(const ros::TimerEvent &amp;e);
     void jointStateCallback(const sensor_msgs::JointState::ConstPtr &amp;input_msg);
 
@@ -29,17 +44,21 @@ class VehicleGazeboInfoPublisher
     ~VehicleGazeboInfoPublisher(){};
 };
 
-VehicleGazeboInfoPublisher::VehicleGazeboInfoPublisher() : nh_(""), pnh_("~")
+VehicleGazeboInfoPublisher::VehicleGazeboInfoPublisher() : nh_(""), pnh_("~"), tf_listener_(tf_buffer_)
 {
     client_ = nh_.serviceClient&lt;gazebo_msgs::GetLinkState&gt;("/gazebo/get_link_state");
-    vehicle_pose_pub_ = nh_.advertise&lt;geometry_msgs::PoseStamped&gt;("/vehicle_info/pose", 1, true);
-    vehicle_vel_pub_ = nh_.advertise&lt;std_msgs::Float64&gt;("/vehicle_info/velocity", 1, true);
-    steering_angle_pub_ = nh_.advertise&lt;std_msgs::Float64&gt;("/vehicle_info/steering_angle", 1, true);
-    vehicle_status_pub_ = nh_.advertise&lt;autoware_msgs::VehicleStatus&gt;("/vehicle_status", 1, true);
+    vehicle_pose_pub_ = nh_.advertise&lt;geometry_msgs::PoseStamped&gt;("/gazebo_vehicle/pose", 1);
+    vehicle_twist_pub_ = nh_.advertise&lt;geometry_msgs::TwistStamped&gt;("/gazebo_vehicle/twist", 1);
+    vehicle_vel_pub_ = nh_.advertise&lt;std_msgs::Float64&gt;("/gazebo_vehicle/velocity", 1);
+    steering_angle_pub_ = nh_.advertise&lt;std_msgs::Float64&gt;("/gazebo_vehicle/steering_angle", 1);
+    vehicle_status_pub_ = nh_.advertise&lt;autoware_msgs::VehicleStatus&gt;("/vehicle_status", 1);
     double publish_pose_rate;
     pnh_.param&lt;double&gt;("publish_pose_rate", publish_pose_rate, double(10.0));
     pnh_.param&lt;double&gt;("wheel_radius", wheel_radius_, 0.341);
+    pnh_.param("wheel_base", wheel_base_, 2.95);
     pnh_.param("ns", ns_, std::string("autoware_gazebo"));
+    pnh_.param("enable_base_link_tf", enable_base_link_tf_, false);
+
     publish_timer_ = nh_.createTimer(ros::Duration(1.0 / publish_pose_rate), &amp;VehicleGazeboInfoPublisher::publishTimerCallback, this);
     odom_sub_ = nh_.subscribe("joint_states", 1, &amp;VehicleGazeboInfoPublisher::jointStateCallback, this);
 }
@@ -58,11 +77,50 @@ void VehicleGazeboInfoPublisher::publishTimerCallback(const ros::TimerEvent &amp;e)
     output_pose.pose = base_link_srv.response.link_state.pose;
 
     vehicle_pose_pub_.publish(output_pose);
+
+    if (enable_base_link_tf_)
+    {
+        tf2::Transform tf_world2map, tf_world2base_link, tf_map2base_link;
+
+        try
+        {
+            geometry_msgs::TransformStamped ros_world2map;
+            ros_world2map = tf_buffer_.lookupTransform("world", "map", ros::Time(0));
+            tf2::fromMsg(ros_world2map.transform, tf_world2map);
+        }
+        catch (tf2::TransformException &amp;ex)
+        {
+            ROS_WARN("%s", ex.what());
+            return;
+        }
+
+        {
+            geometry_msgs::Pose ros_world2base_link;
+            ros_world2base_link.position.x = output_pose.pose.position.x;
+            ros_world2base_link.position.y = output_pose.pose.position.y;
+            ros_world2base_link.position.z = output_pose.pose.position.z;
+            ros_world2base_link.orientation.x = output_pose.pose.orientation.x;
+            ros_world2base_link.orientation.y = output_pose.pose.orientation.y;
+            ros_world2base_link.orientation.z = output_pose.pose.orientation.z;
+            ros_world2base_link.orientation.w = output_pose.pose.orientation.w;
+            tf2::fromMsg(ros_world2base_link, tf_world2base_link);
+        }
+
+        tf_map2base_link = tf_world2map.inverse() * tf_world2base_link;
+
+        geometry_msgs::TransformStamped ros_map2base_link;
+        ros_map2base_link.header.frame_id = "map";
+        ros_map2base_link.child_frame_id = "base_link";
+        ros_map2base_link.header.stamp = current_time;
+        ros_map2base_link.transform = tf2::toMsg(tf_map2base_link);
+        tf_broadcaster_.sendTransform(ros_map2base_link);
+    }
 }
 
 void VehicleGazeboInfoPublisher::jointStateCallback(const sensor_msgs::JointState::ConstPtr &amp;input_msg)
 {
     std_msgs::Float64 output_vel, output_steering_angle;
+    geometry_msgs::TwistStamped output_twiststamped;
     autoware_msgs::VehicleStatus output_vehicle_status;
     double steering_right_front_angle = 0;
     double steering_left_front_angle = 0;
@@ -79,13 +137,19 @@ void VehicleGazeboInfoPublisher::jointStateCallback(const sensor_msgs::JointStat
         if (input_msg-&gt;name.at(i) == std::string("wheel_left_rear_joint"))
             wheel_left_rear_vel = input_msg-&gt;velocity.at(i);
     }
+    ros::Time current_time = ros::Time::now();
     output_vel.data = wheel_radius_ * (wheel_left_rear_vel + wheel_right_rear_vel) / 2.0;
     output_steering_angle.data = (steering_right_front_angle + steering_left_front_angle) / 2.0;
-    output_vehicle_status.header.stamp = ros::Time::now();
+    output_vehicle_status.header.stamp = current_time;
     output_vehicle_status.header.frame_id = "base_link";
     output_vehicle_status.speed = output_vel.data;
     output_vehicle_status.angle = output_steering_angle.data;
 
+    output_twiststamped.header.stamp = current_time;
+    output_twiststamped.header.frame_id = "base_link";
+    output_twiststamped.twist.linear.x = output_vel.data;
+    output_twiststamped.twist.angular.z = std::tan(output_steering_angle.data) * output_vel.data / wheel_base_;
+    vehicle_twist_pub_.publish(output_twiststamped);
     vehicle_vel_pub_.publish(output_vel);
     steering_angle_pub_.publish(output_steering_angle);
     vehicle_status_pub_.publish(output_vehicle_status);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c7c88a1893838addb5cc0a8f3027d140bcfded13" author="Masaya Kataoka">
		<msg>Feature/autoware health checker (#1943)</msg>
		<modified_files>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\diag_filter.h" new_path="" added_lines="0" deleted_lines="32">
				<diff>@@ -1,32 +0,0 @@
-#ifndef DIAG_FILTER_H_INCLUDED
-#define DIAG_FILTER_H_INCLUDED
-
-//headers in diag_msgs
-#include &lt;diag_msgs/diag.h&gt;
-#include &lt;diag_msgs/diag_error.h&gt;
-#include &lt;diag_msgs/diag_node_errors.h&gt;
-
-//headers in ROS
-#include &lt;ros/ros.h&gt;
-
-//headers in Boost
-#include &lt;boost/optional.hpp&gt;
-
-//headers in STL
-#include &lt;map&gt;
-
-class diag_filter
-{
-public:
-    diag_filter();
-    ~diag_filter();
-    boost::optional&lt;diag_msgs::diag_node_errors&gt; filter(diag_msgs::diag diag, std::string target_node);
-    boost::optional&lt;diag_msgs::diag_node_errors&gt; filter(diag_msgs::diag diag, int target_node_number);
-private:
-    std::map&lt;std::string,int&gt; node_number_data_;
-    ros::NodeHandle nh_;
-    bool check_resource_(std::string target_resource_path);
-    volatile bool enable_;
-    std::string error_code_config_path_;
-};
-#endif  //DIAG_FILTER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\diag_info.h" new_path="" added_lines="0" deleted_lines="30">
				<diff>@@ -1,30 +0,0 @@
-#ifndef DIAG_INFO_H_INCLUDED
-#define DIAG_INFO_H_INCLUDED
-
-//headers in diag_lib
-#include &lt;diag_lib/diag_manager_config.h&gt;
-
-//headers in STL
-#include &lt;string&gt;
-
-//headers in boost
-#include &lt;boost/optional.hpp&gt;
-
-struct diag_info
-{
-    const int num;
-    const std::string name;
-    const int category;
-    const std::string description;
-    const boost::optional&lt;double&gt; threshold;
-    const boost::optional&lt;int&gt; level;
-    diag_info(int num_, std::string name_, int category_, std::string description_) 
-    : num(num_), name(name_), category(category_) ,description(description_) , threshold(boost::none), level(boost::none)
-    {};
-    diag_info(int num_, std::string name_, int category_, std::string description_, double threshold_, int level_)
-    : num(num_), name(name_), category(category_) ,description(description_) , threshold(threshold_), level(level_)
-    {
-
-    }
-};
-#endif  //DIAG_INFO_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\diag_macros.h" new_path="" added_lines="0" deleted_lines="6">
				<diff>@@ -1,6 +0,0 @@
-#ifndef DIAG_MACROS_H_INCLUDED
-#define DIAG_MACROS_H_INCLUDED
-
-#define GET_VARIABLE_NAME(Variable)
-
-#endif  //DIAG_MACROS_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\diag_manager.h" new_path="" added_lines="0" deleted_lines="137">
				<diff>@@ -1,137 +0,0 @@
-#ifndef DIAG_MANAGER_H_INCLUDED
-#define DIAG_MANAGER_H_INCLUDED
-
-//headers in diag_lib
-#include &lt;diag_lib/diag_macros.h&gt;
-#include &lt;diag_lib/diag_manager.h&gt;
-#include &lt;diag_lib/diag_info.h&gt;
-#include &lt;diag_lib/rate_checker.h&gt;
-#include &lt;diag_lib/error_category.h&gt;
-#include &lt;diag_lib/diag_manager_config.h&gt;
-
-//headers in ROS
-#include &lt;ros/ros.h&gt;
-
-//headers in STL
-#include &lt;vector&gt;
-#include &lt;map&gt;
-#include &lt;thread&gt;
-#include&lt;fstream&gt;
-
-//headers in diag_msgs
-#include &lt;diag_msgs/diag_error.h&gt;
-
-//headers in boost
-#include &lt;boost/filesystem.hpp&gt;
-#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;
-#include &lt;boost/optional.hpp&gt;
-#include &lt;boost/shared_ptr.hpp&gt;
-#include &lt;boost/thread.hpp&gt;
-#include &lt;boost/bind.hpp&gt;
-
-// headers in YAML-CPP
-#include &lt;yaml-cpp/yaml.h&gt;
-
-class diag_manager
-{
-public:
-    diag_manager();
-    ~diag_manager();
-    template&lt;typename T&gt;
-    void DIAG_ASSERT_VALUE_RANGE(T min, T max, T value, int num)
-    {
-        if(enable_diag_ == false)
-            return;
-        std::vector&lt;int&gt; required_error_code = {INVALID_INITIAL_VALUE, INVALID_VALUE};
-        if(check_error_code(num, required_error_code))
-        {
-            if(value &lt; min)
-            {
-                ADD_DIAG_LOG_WARN(query_diag_info(num)-&gt;description);
-                publish_diag_(query_diag_info(num).get());
-                return;
-            }
-            if(value &gt; max)
-            {
-                ADD_DIAG_LOG_WARN(query_diag_info(num)-&gt;description);
-                publish_diag_(query_diag_info(num).get());
-                return;
-            }
-        }
-        return;
-    }
-    template&lt;typename T&gt;
-    void DIAG_ASSERT_VALUE_MIN(T min, T value, int num)
-    {
-        if(enable_diag_ == false)
-            return;
-        std::vector&lt;int&gt; required_error_code = {INVALID_INITIAL_VALUE, INVALID_VALUE};
-        if(check_error_code(num, required_error_code))
-        {
-            if(value &lt; min)
-            {
-                ADD_DIAG_LOG_WARN(query_diag_info(num)-&gt;description);
-                publish_diag_(query_diag_info(num).get());
-                return;
-            }
-        }
-        return;
-    }
-    template&lt;typename T&gt;
-    void DIAG_ASSERT_VALUE_MAX(T max, T value, int num)
-    {
-        if(enable_diag_ == false)
-            return;
-        std::vector&lt;int&gt; required_error_code = {INVALID_INITIAL_VALUE, INVALID_VALUE};
-        if(check_error_code(num, required_error_code))
-        {
-            if(value &gt; max)
-            {
-                ADD_DIAG_LOG_WARN(query_diag_info(num)-&gt;description);
-                publish_diag_(query_diag_info(num).get());
-                return;
-            }
-        }
-        return;
-    }
-    template&lt;class T&gt;
-    void DIAG_ASSERT_EXCEPTION(T exception,int num)
-    {
-        if(enable_diag_ == false)
-            return;
-        std::vector&lt;int&gt; required_error_code = {EXCEPTION};
-        if(check_error_code(num, required_error_code))
-        {
-            ADD_DIAG_LOG_WARN(query_diag_info(num)-&gt;description);
-            ADD_DIAG_LOG_WARN(exception.what());
-            publish_diag_(query_diag_info(num).get());
-        }
-        return;
-    }
-    void DIAG_RESOURCE(std::string target_resource_path, int num);
-    void DIAG_RATE_CHECK(int num);
-    void DIAG_LOW_RELIABILITY(int num);
-    std::vector&lt;diag_info&gt; get_diag_info(){return diag_info_;}
-    boost::optional&lt;diag_info&gt; query_diag_info(int num);
-    void WRITE_LOG();
-private:
-    void ADD_DIAG_LOG_WARN(std::string log_text);
-    void ADD_DIAG_LOG_ERROR(std::string log_text);
-    void check_rate_();
-    bool check_error_code(int requested_error_code, std::vector&lt;int&gt; right_categories);
-    void publish_diag_(diag_info info);
-    // check resource for diag_manager
-    bool diag_resource(std::string target_resource_path);
-    volatile bool enable_diag_;
-    std::vector&lt;diag_info&gt; diag_info_;
-    std::vector&lt;std::string&gt; diag_log_;
-    ros::Publisher diag_pub_;
-    ros::NodeHandle nh_;
-    ros::Time timer_;
-    //config
-    std::string error_code_config_path_;
-    YAML::Node error_code_config_;
-    //rate checker
-    std::map&lt;int,boost::shared_ptr&lt;rate_checker&gt; &gt; checkers_;
-};
-#endif //DIAG_MANAGER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\diag_manager_config.h" new_path="" added_lines="0" deleted_lines="17">
				<diff>@@ -1,17 +0,0 @@
-#ifndef DIAG_MANGER_CONFIG_H_INCLUDED
-#define DIAG_MANGER_CONFIG_H_INCLUDED
-
-/*
-define values for rate checker
-*/
-#define RATE_CHECKER_BUFFER_LENGTH 1
-#define RATE_CHECK_FREQUENCY 1.0
-
-/*
-define for Pub/Sub Operation cycle critical LEVEL
-*/
-//#define LEVEL_NORMAL 0
-#define LEVEL_WARN 1
-#define LEVEL_ERROR 2
-
-#endif  //DIAGMANAGER_CONFIG_H_INCULDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\diag_subscriber.h" new_path="" added_lines="0" deleted_lines="32">
				<diff>@@ -1,32 +0,0 @@
-#ifndef DIAG_SUBSCRIBER_H_INCLUDED
-#define DIAG_SUBSCRIBER_H_INCLUDED
-
-//headers in STL
-#include &lt;vector&gt;
-#include &lt;mutex&gt;
-#include &lt;algorithm&gt;
-
-//headers in ROS
-#include &lt;ros/ros.h&gt;
-
-//headers in diag_msgs
-#include &lt;diag_msgs/diag_node_errors.h&gt;
-#include &lt;diag_msgs/diag_error.h&gt;
-
-class diag_subscriber
-{
-    public:
-        diag_subscriber(std::string target_node,int target_node_number);
-        ~diag_subscriber();
-        diag_msgs::diag_node_errors get_diag_node_errors();
-    private:
-        std::mutex mtx_;
-        std::vector&lt;diag_msgs::diag_error&gt; buffer_;
-        ros::Subscriber diag_sub_;
-        ros::NodeHandle nh_;
-        void callback_(diag_msgs::diag_error msg);
-        const std::string target_node_;
-        const int target_node_number_;
-};
-
-#endif  //DIAG_SUBSCRIBER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\error_category.h" new_path="" added_lines="0" deleted_lines="17">
				<diff>@@ -1,17 +0,0 @@
-#ifndef ERROR_CATEGORY_H_INCLUDED
-#define ERROR_CATEGORY_H_INCLUDED
-
-//#define MEMORY_ERROR 0
-//#define SEGMENTATION_FAULT 2
-#define EXCEPTION 2
-#define NODE_IS_DEAD 3
-#define LOW_SUBSCRIBE_RATE 4
-#define LOW_PUBLISH_RATE 5
-#define LOW_OPERATION_CYCLE 6
-#define RESOURCE_NOT_FOUND 7
-#define INVALID_INITIAL_VALUE 8
-#define INVALID_VALUE 9
-#define LOW_RELIABILITY 12
-#define DEVICE_CONNECTION_LOST 13
-
-#endif //ERROR_CATEGORY_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\rate_checker.h" new_path="" added_lines="0" deleted_lines="28">
				<diff>@@ -1,28 +0,0 @@
-#ifndef RATE_CHECKER_H_INCLUDED
-#define RATE_CHECKER_H_INCLUDED
-
-//headers in ROS
-#include &lt;ros/ros.h&gt;
-
-//headers in STL
-#include &lt;vector&gt;
-#include &lt;mutex&gt;
-
-//headers in Boost
-#include &lt;boost/optional.hpp&gt;
-
-class rate_checker
-{
-    public:
-        rate_checker(double buffer_length);
-        ~rate_checker();
-        void check();
-        boost::optional&lt;double&gt; get_rate();
-    private:
-        ros::Time start_time_;
-        void update_();
-        std::vector&lt;ros::Time&gt; data_;
-        const double buffer_length_;
-        std::mutex mtx_;
-};
-#endif  //RATE_CHECKER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\include\diag_lib\watchdog.h" new_path="" added_lines="0" deleted_lines="50">
				<diff>@@ -1,50 +0,0 @@
-#ifndef WATCHDOG_H_INCLUDED
-#define WATCHDOG_H_INCLUDED
-
-//headers in diag_lib
-#include &lt;diag_lib/diag_info.h&gt;
-#include &lt;diag_lib/diag_manager.h&gt;
-#include &lt;diag_lib/diag_subscriber.h&gt;
-
-//headers in diag_msgs
-#include &lt;diag_msgs/diag.h&gt;
-#include &lt;diag_msgs/diag_error.h&gt;
-#include &lt;diag_msgs/diag_node_errors.h&gt;
-
-//headers in STL
-#include &lt;vector&gt;
-#include &lt;map&gt;
-
-//headers in YAML-CPP
-#include &lt;yaml-cpp/yaml.h&gt;
-
-//headers in Boost
-#include &lt;boost/shared_ptr.hpp&gt;
-#include &lt;boost/thread.hpp&gt;
-#include &lt;boost/bind.hpp&gt;
-#include &lt;boost/filesystem.hpp&gt;
-
-class watchdog
-{
-public:
-    watchdog();
-    ~watchdog();
-    void run();
-private:
-    ros::NodeHandle nh_;
-    // parameters
-    std::string config_filepath_;
-    double publish_rate_;
-    // diagnostic manager
-    diag_manager diag_;
-    std::map&lt;std::string,boost::shared_ptr&lt;std::vector&lt;diag_info&gt; &gt; &gt; watchdog_diag_info_;
-    std::vector&lt;std::string&gt; diag_target_nodes_;
-    std::vector&lt;std::string&gt; watchdog_target_nodes_;
-    std::map&lt;std::string,bool&gt; connection_status_;
-    std::map&lt;std::string,boost::shared_ptr&lt;diag_subscriber&gt; &gt; diag_sub_;
-    ros::Publisher diag_pub_;
-    void update_connection_status_();
-    void publish_diag_();
-    void write_error_code_csv_(YAML::Node config);
-};
-#endif  //WATCHDOG_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\src\diag_filter.cpp" new_path="" added_lines="0" deleted_lines="66">
				<diff>@@ -1,66 +0,0 @@
-// headers in diag_lib
-#include &lt;diag_lib/diag_filter.h&gt;
-
-// headers in YAML-CPP
-#include &lt;yaml-cpp/yaml.h&gt;
-
-//headers in boost
-#include &lt;boost/filesystem.hpp&gt;
-
-diag_filter::diag_filter()
-{
-    nh_.param&lt;std::string&gt;("/error_code_config_path", error_code_config_path_, std::string(""));
-    if(check_resource_(error_code_config_path_))
-    {
-        enable_ = true;
-    }
-    else
-    {
-        enable_ = false;
-        return;
-    }
-    YAML::Node config = YAML::LoadFile(error_code_config_path_.c_str());
-    try
-    {
-        for(YAML::const_iterator it=config.begin();it != config.end();++it)
-        {
-            YAML::Node single_node_data = config[it-&gt;first.as&lt;std::string&gt;()];
-            node_number_data_[it-&gt;first.as&lt;std::string&gt;()] = single_node_data["node_number"].as&lt;int&gt;();
-        }
-    }
-    catch(...)
-    {
-        ROS_ERROR_STREAM("Failed to parse error code yaml file.");
-    }
-}
-
-diag_filter::~diag_filter()
-{
-
-}
-
-bool diag_filter::check_resource_(std::string target_resource_path)
-{
-    namespace fs = boost::filesystem;
-    fs::path path(target_resource_path);
-    boost::system::error_code error;
-    const bool result = fs::exists(path, error);
-    if (!result || error)
-        return false;
-    return true;
-}
-
-boost::optional&lt;diag_msgs::diag_node_errors&gt; diag_filter::filter(diag_msgs::diag diag, std::string target_node)
-{
-    return filter(diag,node_number_data_[target_node]);
-}
-
-boost::optional&lt;diag_msgs::diag_node_errors&gt; diag_filter::filter(diag_msgs::diag diag, int target_node_number)
-{
-    for(int i=0; i&lt;diag.nodes.size() ; i++)
-    {
-        if(diag.nodes[i].node_number == target_node_number)
-            return diag.nodes[i];
-    }
-    return boost::none;
-}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\src\diag_manager.cpp" new_path="" added_lines="0" deleted_lines="274">
				<diff>@@ -1,274 +0,0 @@
-#include &lt;diag_lib/diag_manager.h&gt;
-
-diag_manager::diag_manager()
-{
-    enable_diag_ = false;
-    nh_.param&lt;std::string&gt;("/error_code_config_path", error_code_config_path_, std::string(""));
-    if(!diag_resource(error_code_config_path_))
-    {
-        return;
-    }
-    YAML::Node config = YAML::LoadFile(error_code_config_path_.c_str());
-    error_code_config_ = config[ros::this_node::getName()];
-    try
-    {
-        for(const YAML::Node &amp;error : error_code_config_["errors"])
-        {
-            diag_info info(error["num"].as&lt;int&gt;(), error["name"].as&lt;std::string&gt;(), error["category"].as&lt;int&gt;(), error["description"].as&lt;std::string&gt;());
-            if((info.category == LOW_SUBSCRIBE_RATE) || (info.category == LOW_PUBLISH_RATE) || (info.category == LOW_OPERATION_CYCLE))
-            {
-                if(error["level"].as&lt;std::string&gt;() == "warn")
-                {
-                    diag_info detail_info(error["num"].as&lt;int&gt;(), error["name"].as&lt;std::string&gt;(), error["category"].as&lt;int&gt;(), error["description"].as&lt;std::string&gt;() ,error["threshold"].as&lt;double&gt;(), LEVEL_WARN);
-                    boost::shared_ptr&lt;rate_checker&gt; rate_checker_ptr = boost::make_shared&lt;rate_checker&gt;(RATE_CHECKER_BUFFER_LENGTH);
-                    checkers_[info.num] = rate_checker_ptr;
-                    diag_info_.push_back(detail_info);
-                }
-                if(error["level"].as&lt;std::string&gt;() == "error")
-                {
-                    diag_info detail_info(error["num"].as&lt;int&gt;(), error["name"].as&lt;std::string&gt;(), error["category"].as&lt;int&gt;(), error["description"].as&lt;std::string&gt;() ,error["threshold"].as&lt;double&gt;(), LEVEL_ERROR);
-                    boost::shared_ptr&lt;rate_checker&gt; rate_checker_ptr = boost::make_shared&lt;rate_checker&gt;(RATE_CHECKER_BUFFER_LENGTH);
-                    checkers_[info.num] = rate_checker_ptr;
-                    diag_info_.push_back(detail_info);
-                }
-                continue;
-            }
-            diag_info_.push_back(info);
-        }
-    }
-    catch(...)
-    {
-#ifdef STRICT_ERROR_CODE_CHECK
-        ROS_ERROR_STREAM("diag config file format was wrong. kill " + ros::this_node::getName() + ". Please check " &lt;&lt; error_code_config_path_);
-        WRITE_LOG();
-        std::exit(-1);
-#else
-        ROS_WARN_STREAM("diag config file format was wrong in " + ros::this_node::getName() + ". Please check " &lt;&lt; error_code_config_path_);
-#endif
-    }
-    diag_pub_ = nh_.advertise&lt;diag_msgs::diag_error&gt;(ros::this_node::getName() + "/diag", 10);
-    boost::thread rate_check_thread(boost::bind(&amp;diag_manager::check_rate_, this));;
-    enable_diag_ = true;
-}
-
-diag_manager::~diag_manager()
-{
-
-}
-
-void diag_manager::check_rate_()
-{
-    ros::Rate rate(RATE_CHECK_FREQUENCY);
-    while(ros::ok())
-    {
-        for (auto const&amp; checker : checkers_)
-        {
-            boost::optional&lt;double&gt; rate = checker.second-&gt;get_rate();
-            boost::optional&lt;diag_info&gt; info = query_diag_info(checker.first);
-            if(rate &amp;&amp; info &amp;&amp; info.get().threshold)
-            {
-                if(*rate &lt;info.get().threshold.get())
-                {
-                    if(info.get().level.get() == LEVEL_WARN)
-                    {
-                        ADD_DIAG_LOG_WARN(info.get().description);
-                        publish_diag_(query_diag_info(info.get().num).get());
-                    }
-                    if(info.get().level.get() == LEVEL_ERROR)
-                    {
-                        ADD_DIAG_LOG_ERROR(info.get().description);
-                        publish_diag_(query_diag_info(info.get().num).get());
-                    }
-                }
-            }
-        }
-        rate.sleep();
-    }
-    return;
-}
-
-void diag_manager::DIAG_LOW_RELIABILITY(int num)
-{
-    if(enable_diag_ == false)
-        return;    
-    std::vector&lt;int&gt; required_error_code = {LOW_RELIABILITY};
-    if(check_error_code(num, required_error_code))
-    {
-        boost::optional&lt;diag_info&gt; info = query_diag_info(num);
-        ADD_DIAG_LOG_WARN(info.get().description);
-        publish_diag_(query_diag_info(info.get().num).get());
-    }
-    return;
-}
-
-void diag_manager::DIAG_RATE_CHECK(int num)
-{
-    if(enable_diag_ == false)
-        return;
-    std::vector&lt;int&gt; required_error_code = {LOW_SUBSCRIBE_RATE, LOW_PUBLISH_RATE, LOW_OPERATION_CYCLE};
-    if(check_error_code(num, required_error_code))
-    {
-        try
-        {
-            checkers_.at(num)-&gt;check();
-        }
-        catch(std::out_of_range&amp;)
-        {
-#ifdef STRICT_ERROR_CODE_CHECK
-        ROS_ERROR_STREAM("rate checker object cannot found. Please check " &lt;&lt; error_code_config_path_);
-        WRITE_LOG();
-        std::exit(-1);
-#else
-        ROS_WARN_STREAM("rate checker object cannot found. Please check " &lt;&lt; error_code_config_path_);
-#endif
-        }
-    }
-    return;
-}
-
-boost::optional&lt;diag_info&gt; diag_manager::query_diag_info(int num)
-{
-    for(auto diag_info_itr = diag_info_.begin(); diag_info_itr != diag_info_.end(); diag_info_itr++)
-    {
-        if(diag_info_itr-&gt;num == num)
-        {
-            if(diag_info_itr-&gt;threshold &amp;&amp; diag_info_itr-&gt;level)
-            {
-                diag_info ret(diag_info_itr-&gt;num, diag_info_itr-&gt;name, diag_info_itr-&gt;category, diag_info_itr-&gt;description, diag_info_itr-&gt;threshold.get(), diag_info_itr-&gt;level.get());
-                return ret;
-            }
-            else
-            {
-                diag_info ret(diag_info_itr-&gt;num, diag_info_itr-&gt;name, diag_info_itr-&gt;category, diag_info_itr-&gt;description);
-                return ret;  
-            }
-        }
-    }
-    return boost::none;
-}
-
-void diag_manager::WRITE_LOG()
-{
-    namespace fs = boost::filesystem;
-    const fs::path path("/tmp/Autoware/Diag/Log/" + ros::this_node::getName());
-    boost::system::error_code error;
-    const bool result = fs::create_directories(path, error);
-    std::vector&lt;std::string&gt;::iterator it = diag_log_.begin();
-    std::string write_string = "";
-    while( it != diag_log_.end() ) {
-        write_string = write_string + *it + "\n";
-        ++it;
-    }
-    std::ofstream outputfile(std::string("/tmp/Autoware/Diag/Log/" + ros::this_node::getName() + "/log.txt").c_str());
-    outputfile &lt;&lt; write_string;
-    outputfile.close();
-    return;
-}
-
-void diag_manager::ADD_DIAG_LOG_ERROR(std::string log_text)
-{
-    log_text = "in " + ros::this_node::getName() + ": " + log_text;
-    boost::posix_time::ptime my_posix_time = ros::Time::now().toBoost();
-    std::string iso_time_str = boost::posix_time::to_iso_extended_string(my_posix_time);
-    std::string text =  "[" + iso_time_str + "] : " + log_text;
-    ROS_ERROR_STREAM(log_text);
-    diag_log_.push_back(text);
-    return;
-}
-
-void diag_manager::ADD_DIAG_LOG_WARN(std::string log_text)
-{
-    log_text = "in " + ros::this_node::getName() + ": " + log_text;
-    boost::posix_time::ptime my_posix_time = ros::Time::now().toBoost();
-    std::string iso_time_str = boost::posix_time::to_iso_extended_string(my_posix_time);
-    std::string text =  "[" + iso_time_str + "] : " + log_text;
-    ROS_WARN_STREAM(log_text);
-    diag_log_.push_back(text);
-    return;
-}
-
-void diag_manager::DIAG_RESOURCE(std::string target_resource_path, int num)
-{
-    if(enable_diag_ == false)
-        return;
-    std::vector&lt;int&gt; required_error_code = {RESOURCE_NOT_FOUND};
-    if(check_error_code(num, required_error_code))
-    {
-        if(query_diag_info(num))
-        {
-            namespace fs = boost::filesystem;
-            fs::path path(target_resource_path);
-            boost::system::error_code error;
-            const bool result = fs::exists(path, error);
-            if (!result || error)
-            {
-                //ROS_ERROR_STREAM("required resource " &lt;&lt; path &lt;&lt; " does not found.");
-                ADD_DIAG_LOG_ERROR("required resource " + target_resource_path + " does not found.");
-                publish_diag_(query_diag_info(num).get());
-                ROS_ERROR_STREAM("shutdonw " &lt;&lt; ros::this_node::getName());
-                WRITE_LOG();
-                std::exit(-1);
-            }
-            return;
-        }
-        else
-        {
-            ADD_DIAG_LOG_WARN(query_diag_info(num)-&gt;description);
-            publish_diag_(query_diag_info(num).get());
-            return;
-        }
-    }
-}
-
-bool diag_manager::diag_resource(std::string target_resource_path)
-{
-    namespace fs = boost::filesystem;
-    fs::path path(target_resource_path);
-    boost::system::error_code error;
-    const bool result = fs::exists(path, error);
-    if (!result || error)
-    {
-        ADD_DIAG_LOG_ERROR("required resource " + target_resource_path + " does not found.");
-        ADD_DIAG_LOG_ERROR("disable diag module in " + ros::this_node::getName());
-        return false;
-    }
-    return true;
-}
-
-bool diag_manager::check_error_code(int requested_error_number, std::vector&lt;int&gt; right_categories)
-{
-    if(query_diag_info(requested_error_number))
-    {
-        for(auto category_itr = right_categories.begin(); category_itr != right_categories.end(); category_itr++)
-        {
-            if(*category_itr == query_diag_info(requested_error_number)-&gt;category)
-            {
-                return true;
-            }
-        }
-#ifdef STRICT_ERROR_CODE_CHECK
-        ROS_ERROR_STREAM("error category : " &lt;&lt; query_diag_info(requested_error_number)-&gt;category &lt;&lt; " in " &lt;&lt; ros::this_node::getName() &lt;&lt; " does not match. Please check " &lt;&lt; error_code_config_path_);
-        WRITE_LOG();
-        std::exit(-1);
-#else
-        ROS_WARN_STREAM("error category : " &lt;&lt; query_diag_info(requested_error_number)-&gt;category &lt;&lt; " in " &lt;&lt; ros::this_node::getName() &lt;&lt; " does not match. Please check " &lt;&lt; error_code_config_path_);
-#endif
-        return false;
-    }
-    else
-    {
-        ROS_WARN_STREAM("error number : " &lt;&lt; requested_error_number &lt;&lt; " in " &lt;&lt; ros::this_node::getName() &lt;&lt; " does not exist. Check " &lt;&lt; error_code_config_path_);
-        return false;
-    }
-}
-
-void diag_manager::publish_diag_(diag_info info)
-{
-    diag_msgs::diag_error msg;
-    msg.num = info.num;
-    msg.name = info.name;
-    msg.category = info.category;
-    msg.description = info.description;
-    diag_pub_.publish(msg);
-    return;
-}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\src\diag_subscriber.cpp" new_path="" added_lines="0" deleted_lines="32">
				<diff>@@ -1,32 +0,0 @@
-#include &lt;diag_lib/diag_subscriber.h&gt;
-
-diag_subscriber::diag_subscriber(std::string target_node,int target_node_number) : target_node_(target_node), target_node_number_(target_node_number)
-{
-    diag_sub_ = nh_.subscribe(target_node+"/diag", 1, &amp;diag_subscriber::callback_, this);
-}
-
-diag_subscriber::~diag_subscriber()
-{
-
-}
-
-void diag_subscriber::callback_(diag_msgs::diag_error msg)
-{
-    mtx_.lock();
-    buffer_.push_back(msg);
-    //ROS_ERROR_STREAM(msg);
-    mtx_.unlock();
-    return;
-}
-
-diag_msgs::diag_node_errors diag_subscriber::get_diag_node_errors()
-{
-    diag_msgs::diag_node_errors ret;
-    mtx_.lock();
-    std::copy(buffer_.begin(), buffer_.end(), back_inserter(ret.errors));
-    buffer_.clear();
-    mtx_.unlock();
-    ret.header.stamp = ros::Time::now();
-    ret.node_number = target_node_number_;
-    return ret;
-}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\src\rate_checker.cpp" new_path="" added_lines="0" deleted_lines="49">
				<diff>@@ -1,49 +0,0 @@
-#include &lt;diag_lib/rate_checker.h&gt;
-
-rate_checker::rate_checker(double buffer_length) : buffer_length_(buffer_length)
-{
-    start_time_ = ros::Time::now();
-}
-
-rate_checker::~rate_checker()
-{
-
-}
-
-void rate_checker::check()
-{
-    update_();
-    mtx_.lock();
-    data_.push_back(ros::Time::now());
-    mtx_.unlock();
-}
-
-void rate_checker::update_()
-{
-    std::vector&lt;ros::Time&gt; buffer;
-    for(auto data_itr = data_.begin(); data_itr != data_.end(); data_itr++)
-    {
-        if(*data_itr &gt; ros::Time::now()-ros::Duration(buffer_length_))
-        {
-            buffer.push_back(*data_itr);
-        }
-    }
-    mtx_.lock();
-    data_ = buffer;
-    mtx_.unlock();
-    return;
-}
-
-boost::optional&lt;double&gt; rate_checker::get_rate()
-{
-    boost::optional&lt;double&gt; rate;
-    if(ros::Time::now() - start_time_ &lt; ros::Duration(buffer_length_))
-    {
-        return boost::none;
-    }
-    update_();
-    mtx_.lock();
-    rate = data_.size()/buffer_length_;
-    mtx_.unlock();
-    return rate;
-}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\src\watchdog.cpp" new_path="" added_lines="0" deleted_lines="144">
				<diff>@@ -1,144 +0,0 @@
-//headers in diag_lib
-#include &lt;diag_lib/watchdog.h&gt;
-
-//headers in ROS
-#include &lt;ros/ros.h&gt;
-
-watchdog::watchdog()
-{
-    nh_.param&lt;std::string&gt;("/error_code_config_path", config_filepath_, "");
-    nh_.param&lt;double&gt;(ros::this_node::getName() + "/publish_rate", publish_rate_, 10);
-    diag_.DIAG_RESOURCE(config_filepath_, 0);
-    YAML::Node config = YAML::LoadFile(config_filepath_.c_str());
-    for(YAML::const_iterator it=config.begin();it != config.end();++it)
-    {
-        if(it-&gt;first.as&lt;std::string&gt;() != ros::this_node::getName())
-        {
-            std::string itr_node_name = it-&gt;first.as&lt;std::string&gt;();
-            diag_target_nodes_.push_back(itr_node_name);
-            YAML::Node target_node = config[itr_node_name];
-            diag_sub_[itr_node_name] = boost::make_shared&lt;diag_subscriber&gt;(itr_node_name, target_node["node_number"].as&lt;int&gt;());
-            boost::shared_ptr&lt;std::vector&lt;diag_info&gt; &gt; target_node_watchdog_diag_info = boost::make_shared&lt;std::vector&lt;diag_info&gt; &gt;();
-            for(const YAML::Node &amp;error : target_node["errors"])
-            {
-                if(error["category"].as&lt;int&gt;() == NODE_IS_DEAD)
-                {
-                    diag_info info(error["num"].as&lt;int&gt;(), error["name"].as&lt;std::string&gt;(), error["category"].as&lt;int&gt;(), error["description"].as&lt;std::string&gt;());
-                    target_node_watchdog_diag_info-&gt;push_back(info);
-                }
-            }
-            if(target_node_watchdog_diag_info-&gt;size() != 0)
-            {
-                watchdog_diag_info_[itr_node_name] = target_node_watchdog_diag_info;
-                watchdog_target_nodes_.push_back(itr_node_name);
-            }
-        }
-    }
-    write_error_code_csv_(config);
-    diag_pub_ = nh_.advertise&lt;diag_msgs::diag&gt;(ros::this_node::getName()+"/diag/all", 1);
-}
-
-watchdog::~watchdog()
-{
-    
-}
-
-void watchdog::write_error_code_csv_(YAML::Node config)
-{
-    namespace fs = boost::filesystem;
-    const fs::path path("/tmp/Autoware/Diag/");
-    boost::system::error_code error;
-    const bool result = fs::create_directories(path, error);
-    std::string write_string = "node_name,node_number,num,name,category,description,threshold,level\n";
-    for(YAML::const_iterator it=config.begin();it != config.end();++it)
-    {
-        std::string node_name = it-&gt;first.as&lt;std::string&gt;();
-        YAML::Node target_node = config[node_name];
-        int node_number = target_node["node_number"].as&lt;int&gt;();
-        for(const YAML::Node &amp;error : target_node["errors"])
-        {
-            std::string line = "";
-            int num = error["num"].as&lt;int&gt;();
-            std::string name = error["name"].as&lt;std::string&gt;();
-            int category = error["category"].as&lt;int&gt;();
-            std::string description = error["description"].as&lt;std::string&gt;();
-            if((category == LOW_SUBSCRIBE_RATE) || (category == LOW_PUBLISH_RATE) || (category == LOW_OPERATION_CYCLE))
-            {
-                double threashold = error["threshold"].as&lt;double&gt;();
-                std::string level = error["level"].as&lt;std::string&gt;();
-                line = node_name + "," + std::to_string(node_number) + "," + std::to_string(num) + "," + name + "," + std::to_string(category) + "," + description + "," + std::to_string(threashold) + "," + level + "\n";
-            }
-            else
-            {
-                line = node_name + "," + std::to_string(node_number) + "," + std::to_string(num) + "," + name + "," + std::to_string(category) + "," + description + ",,\n";
-            }
-            write_string = write_string + line;
-        }
-    }
-    std::ofstream outputfile(std::string("/tmp/Autoware/Diag/error_list.csv").c_str());
-    outputfile &lt;&lt; write_string;
-    outputfile.close();
-    return;
-}
-
-void watchdog::publish_diag_()
-{
-    ros::Rate rate(publish_rate_);
-    while(ros::ok())
-    {
-        update_connection_status_();
-        diag_msgs::diag diag_msg;
-        for(auto itr = watchdog_target_nodes_.begin(); itr != watchdog_target_nodes_.end(); ++itr)
-        {
-            diag_msgs::diag_node_errors errors = diag_sub_[*itr]-&gt;get_diag_node_errors();
-            if(connection_status_[*itr] == false)
-            {
-                std::vector&lt;diag_info&gt; target_node_watchdog_diag_info = *watchdog_diag_info_[*itr];
-                for(int i=0; i&lt;target_node_watchdog_diag_info.size(); i++)
-                {
-                    diag_msgs::diag_error error;
-                    error.name = target_node_watchdog_diag_info[i].name;
-                    error.num = target_node_watchdog_diag_info[i].num;
-                    error.category = target_node_watchdog_diag_info[i].category;
-                    error.description = target_node_watchdog_diag_info[i].description;
-                    errors.errors.push_back(error);
-                }
-            }
-            if(errors.errors.size() != 0)
-            {
-                diag_msg.nodes.push_back(errors);
-            }
-        }
-        diag_msg.header.stamp = ros::Time::now();
-        diag_pub_.publish(diag_msg);
-        rate.sleep();
-    }
-    diag_.WRITE_LOG();
-    return;
-}
-
-void watchdog::run()
-{
-    boost::thread publish_thread(boost::bind(&amp;watchdog::publish_diag_, this));
-    ros::spin();
-    publish_thread.join();
-    return;
-}
-
-void watchdog::update_connection_status_()
-{
-    std::vector&lt;std::string&gt; detected_nodes;
-    ros::master::getNodes(detected_nodes);
-    for(auto itr = watchdog_target_nodes_.begin(); itr != watchdog_target_nodes_.end(); ++itr)
-    {
-        if(std::find(detected_nodes.begin(), detected_nodes.end(), *itr) != detected_nodes.end())
-        {
-            connection_status_[*itr] = true;
-        }
-        else
-        {
-            connection_status_[*itr] = false;
-        }
-    }
-    return;
-}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\diag_lib\src\watchdog_node.cpp" new_path="" added_lines="0" deleted_lines="10">
				<diff>@@ -1,10 +0,0 @@
-#include &lt;ros/ros.h&gt;
-
-#include &lt;diag_lib/watchdog.h&gt;
-
-int main(int argc, char *argv[]) {
-  ros::init(argc, argv, "watchdog_node");
-  watchdog wd;
-  wd.run();
-  return 0;
-}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\fake_autoware_nodes\include\fake_autoware_nodes\fake_publisher.h" new_path="" added_lines="0" deleted_lines="20">
				<diff>@@ -1,20 +0,0 @@
-#ifndef FAKE_PUBLISHER_H_INCLUDED
-#define FAKE_PUBLISHER_H_INCLUDED
-
-//headers in diag_lib
-#include &lt;diag_lib/diag_manager.h&gt;
-
-class fake_publisher
-{
-    public:
-        fake_publisher();
-        ~fake_publisher();
-        void run();
-        double divide(double a, double b);
-    private:
-        ros::NodeHandle nh_;
-        ros::Publisher fake_pub_;
-        diag_manager diag_manager_;
-};
-
-#endif  //FAKE_PUBLISHER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\fake_autoware_nodes\include\fake_autoware_nodes\fake_subscriber.h" new_path="" added_lines="0" deleted_lines="33">
				<diff>@@ -1,33 +0,0 @@
-#ifndef FAKE_SUBSCRIBER_H_INCLUDED
-#define FAKE_SUBSCRIBER_H_INCLUDED
-
-//headers in diag_lib
-#include &lt;diag_lib/diag_manager.h&gt;
-#include &lt;diag_lib/diag_filter.h&gt;
-
-//headers in diag_msg
-#include &lt;diag_msgs/diag_error.h&gt;
-#include &lt;diag_msgs/diag.h&gt;
-
-//headers in std_msgs
-#include &lt;std_msgs/Float64.h&gt;
-
-//headers in ROS
-#include &lt;ros/ros.h&gt;
-
-class fake_subscriber
-{
-    public:
-        fake_subscriber();
-        ~fake_subscriber();
-    private:
-        void diag_callback_(const diag_msgs::diagConstPtr msg);
-        void callback_(const std_msgs::Float64ConstPtr msg);
-        ros::NodeHandle nh_;
-        ros::Subscriber fake_sub_;
-        ros::Subscriber diag_sub_;
-        diag_manager diag_manager_;
-        diag_filter diag_filter_;
-};
-
-#endif  //FAKE_SUBSCRIBER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\fake_autoware_nodes\src\fake_publisher.cpp" new_path="" added_lines="0" deleted_lines="52">
				<diff>@@ -1,52 +0,0 @@
-#include &lt;fake_autoware_nodes/fake_publisher.h&gt;
-
-#include &lt;std_msgs/Float64.h&gt;
-
-fake_publisher::fake_publisher()
-{
-    fake_pub_ = nh_.advertise&lt;std_msgs::Float64&gt;(ros::this_node::getName()+"/data", 1);
-}
-
-fake_publisher::~fake_publisher()
-{
-
-}
-
-void fake_publisher::run()
-{
-    ros::Rate rate(10);
-    std_msgs::Float64 msg;
-    msg.data = -50;
-    while(ros::ok())
-    {
-        diag_manager_.DIAG_RATE_CHECK(3);
-        fake_pub_.publish(msg);
-        msg.data = msg.data + 1.0;
-        diag_manager_.DIAG_ASSERT_VALUE_RANGE(-20.0, 20.0, msg.data, 0);
-        if(msg.data == 50)
-        {
-            diag_manager_.DIAG_LOW_RELIABILITY(4);
-            msg.data = -50;
-        }
-        try
-        {
-            divide(1,msg.data);
-        }
-        catch(std::range_error&amp; exception)
-        {
-            diag_manager_.DIAG_ASSERT_EXCEPTION(exception,1);
-        }
-        rate.sleep();
-    }
-    diag_manager_.WRITE_LOG();
-    return;
-}
-
-double fake_publisher::divide(double a, double b)
-{
-    if (b == 0)
-    {
-        throw std::range_error("Divided by zero.");
-    }
-    return a / b;
-}
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\fake_autoware_nodes\src\fake_publisher_node.cpp" new_path="" added_lines="0" deleted_lines="12">
				<diff>@@ -1,12 +0,0 @@
-//headers in ROS
-#include &lt;ros/ros.h&gt;
-
-//headers in fake_autoware_nodes
-#include &lt;fake_autoware_nodes/fake_publisher.h&gt;
-
-int main(int argc, char *argv[]) {
-  ros::init(argc, argv, "fake_publisher_node");
-  fake_publisher fake_pub;
-  fake_pub.run();
-  return 0;
-}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\fake_autoware_nodes\src\fake_subscriber.cpp" new_path="" added_lines="0" deleted_lines="28">
				<diff>@@ -1,28 +0,0 @@
-#include &lt;fake_autoware_nodes/fake_subscriber.h&gt;
-
-fake_subscriber::fake_subscriber()
-{
-    diag_sub_ = nh_.subscribe("watchdog_node/diag/all", 1, &amp;fake_subscriber::diag_callback_, this);
-    fake_sub_ = nh_.subscribe(ros::this_node::getName()+"/data", 1, &amp;fake_subscriber::callback_, this);
-}
-
-fake_subscriber::~fake_subscriber()
-{
-
-}
-
-void fake_subscriber::callback_(const std_msgs::Float64ConstPtr msg)
-{
-    diag_manager_.DIAG_ASSERT_VALUE_MIN(0.0, msg-&gt;data, 0);
-    return;
-}
-
-void fake_subscriber::diag_callback_(const diag_msgs::diagConstPtr msg)
-{
-    boost::optional&lt;diag_msgs::diag_node_errors&gt; error = diag_filter_.filter(*msg, ros::this_node::getName());
-    if(error)
-    {
-        ROS_ERROR_STREAM(error.get());
-    }
-    return;
-}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\common\libs\diagnostics_lib\fake_autoware_nodes\src\fake_subscriber_node.cpp" new_path="" added_lines="0" deleted_lines="14">
				<diff>@@ -1,14 +0,0 @@
-#include &lt;ros/ros.h&gt;
-
-//headers in diag_lib
-#include &lt;diag_lib/diag_manager.h&gt;
-
-//headers in fake_autoware_nodes
-#include &lt;fake_autoware_nodes/fake_subscriber.h&gt;
-
-int main(int argc, char *argv[]) {
-  ros::init(argc, argv, "fake_subscriber_node");
-  fake_subscriber fake_sub;
-  ros::spin();
-  return 0;
-}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="13" deleted_lines="0">
				<diff>@@ -69,12 +69,17 @@
 
 #include &lt;autoware_msgs/NDTStat.h&gt;
 
+//headers in Autoware Health Checker
+#include &lt;autoware_health_checker/node_status_publisher.h&gt;
+
 #define PREDICT_POSE_THRESHOLD 0.5
 
 #define Wa 0.4
 #define Wb 0.3
 #define Wc 0.3
 
+static std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr_;
+
 struct pose
 {
   double x;
@@ -916,6 +921,7 @@ static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
 
 static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 {
+  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/points_raw/slow",8,5,1,"topic points_raw subscribe rate low.");
   if (map_loaded == 1 &amp;&amp; init_pos_set == 1)
   {
     matching_start = std::chrono::system_clock::now();
@@ -1348,6 +1354,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     }
 
     predict_pose_pub.publish(predict_pose_msg);
+    node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/ndt_pose/slow",8,5,1,"topic points_raw publish rate low.");
     ndt_pose_pub.publish(ndt_pose_msg);
     // current_pose is published by vel_pose_mux
     //    current_pose_pub.publish(current_pose_msg);
@@ -1369,6 +1376,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     matching_end = std::chrono::system_clock::now();
     exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(matching_end - matching_start).count() / 1000.0;
     time_ndt_matching.data = exe_time;
+    node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/time_ndt_matching",time_ndt_matching.data,50,70,100,"value time_ndt_matching is too high.");
     time_ndt_matching_pub.publish(time_ndt_matching);
 
     // Set values for /estimate_twist
@@ -1386,6 +1394,8 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     geometry_msgs::Vector3Stamped estimate_vel_msg;
     estimate_vel_msg.header.stamp = current_scan_time;
     estimate_vel_msg.vector.x = current_velocity;
+    node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/estimate_twist/linear",current_velocity,5,10,15,"value linear estimated twist is too high.");
+    node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/estimate_twist/angular",angular_velocity,5,10,15,"value linear angular twist is too high.");
     estimated_vel_pub.publish(estimate_vel_msg);
 
     // Set values for /ndt_stat
@@ -1514,6 +1524,9 @@ int main(int argc, char** argv)
 
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
+  node_status_publisher_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh,private_nh);
+  node_status_publisher_ptr_-&gt;ENABLE();
+  node_status_publisher_ptr_-&gt;NODE_ACTIVATE();
 
   // Set log file name.
   private_nh.getParam("output_log_data", _output_log_data);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" added_lines="13" deleted_lines="1">
				<diff>@@ -30,7 +30,10 @@ SearchInfo::SearchInfo()
   , state_("")
   , upper_bound_distance_(-1)
 {
+  ros::NodeHandle nh;
   ros::NodeHandle private_nh_("~");
+  node_status_publisher_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh,private_nh_);
+  node_status_publisher_ptr_-&gt;ENABLE();
   private_nh_.param&lt;std::string&gt;("map_frame", map_frame_, "map");
   private_nh_.param&lt;int&gt;("obstacle_detect_count", obstacle_detect_count_, 10);
   private_nh_.param&lt;int&gt;("avoid_distance", avoid_distance_, 13);
@@ -95,7 +98,15 @@ void SearchInfo::mapCallback(const nav_msgs::OccupancyGridConstPtr &amp;msg)
 void SearchInfo::currentPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 {
   current_pose_ = *msg;
-
+  node_status_publisher_ptr_-&gt;NODE_ACTIVATE();
+  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/current_pose/slow",8,5,1,"topic current_pose subscribe rate low.");
+  if(closest_waypoint_index_!=-1 &amp;&amp; path_set_)
+  {
+    autoware_msgs::Waypoint closest_waypoint = subscribed_waypoints_.waypoints[closest_waypoint_index_];
+    double dist = std::sqrt(std::pow(closest_waypoint.pose.pose.position.x-current_pose_.pose.position.x,2)
+      +std::pow(closest_waypoint.pose.pose.position.y-current_pose_.pose.position.y,2));
+    node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/range/closest_waypoint_distance",dist,0.5,1.0,2.0,"distance between closest_waypoint and current_pose is too long.");
+  }
   return;
 }
 
@@ -171,6 +182,7 @@ void SearchInfo::waypointsCallback(const autoware_msgs::LaneConstPtr &amp;msg)
 
 void SearchInfo::closestWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
 {
+  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/closest_waypoint/slow",8,5,1,"topic closest_waypoint subscribe rate low.");
   closest_waypoint_index_ = msg-&gt;data;
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" added_lines="4" deleted_lines="1">
				<diff>@@ -27,6 +27,9 @@
 #include &lt;std_msgs/Int32.h&gt;
 #include &lt;std_msgs/String.h&gt;
 
+#include &lt;autoware_health_checker/node_status_publisher.h&gt;
+#include &lt;memory&gt;
+
 namespace astar_planner
 {
 class SearchInfo
@@ -140,7 +143,7 @@ public:
 private:
   double calcPathLength(const autoware_msgs::Lane &amp;lane, const int start_waypoint_index,
                         const int goal_waypoint_index) const;
-
+  std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr_;
   nav_msgs::OccupancyGrid map_;
   geometry_msgs::PoseStamped start_pose_global_;
   geometry_msgs::PoseStamped goal_pose_global_;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" added_lines="5" deleted_lines="0">
				<diff>@@ -41,7 +41,10 @@ VelocitySetInfo::VelocitySetInfo()
     wpidx_detectionResultByOtherNodes_(-1)
 {
   ros::NodeHandle private_nh_("~");
+  ros::NodeHandle nh;
   private_nh_.param&lt;double&gt;("remove_points_upto", remove_points_upto_, 2.3);
+  node_status_publisher_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh,private_nh_);
+  node_status_publisher_ptr_-&gt;ENABLE();
 }
 
 VelocitySetInfo::~VelocitySetInfo()
@@ -70,6 +73,7 @@ void VelocitySetInfo::configCallback(const autoware_config_msgs::ConfigVelocityS
 
 void VelocitySetInfo::pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg)
 {
+  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/points_no_ground/slow",8,5,1,"topic points_no_ground subscribe rate low.");
   pcl::PointCloud&lt;pcl::PointXYZ&gt; sub_points;
   pcl::fromROSMsg(*msg, sub_points);
 
@@ -111,6 +115,7 @@ void VelocitySetInfo::controlPoseCallback(const geometry_msgs::PoseStampedConstP
 
 void VelocitySetInfo::localizerPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 {
+  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/current_pose/slow",8,5,1,"topic current_pose subscribe rate low.");
   localizer_pose_ = *msg;
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" added_lines="5" deleted_lines="0">
				<diff>@@ -24,6 +24,9 @@
 
 #include "autoware_config_msgs/ConfigVelocitySet.h"
 
+#include &lt;autoware_health_checker/node_status_publisher.h&gt;
+#include &lt;memory&gt;
+
 class VelocitySetInfo
 {
  private:
@@ -51,6 +54,8 @@ class VelocitySetInfo
   bool set_pose_;
   bool use_obstacle_sim_;
 
+  std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr_;
+
  public:
   VelocitySetInfo();
   ~VelocitySetInfo();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -28,6 +28,7 @@ PurePursuit::PurePursuit()
   , current_linear_velocity_(0)
   , minimum_lookahead_distance_(6)
 {
+  
 }
 
 // Destructor
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="6" deleted_lines="2">
				<diff>@@ -36,7 +36,8 @@ PurePursuitNode::PurePursuitNode()
   , minimum_lookahead_distance_(6.0)
 {
   initForROS();
-
+  node_status_publisher_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh_,private_nh_);
+  node_status_publisher_ptr_-&gt;ENABLE();
   // initialize for PurePursuit
   pp_.setLinearInterpolationParameter(is_linear_interpolation_);
 }
@@ -92,9 +93,11 @@ void PurePursuitNode::run()
 
     double kappa = 0;
     bool can_get_curvature = pp_.canGetCurvature(&amp;kappa);
+    
     publishTwistStamped(can_get_curvature, kappa);
     publishControlCommandStamped(can_get_curvature, kappa);
-
+    node_status_publisher_ptr_-&gt;NODE_ACTIVATE();
+    node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/vehicle/slow",8,5,1,"topic vehicle_cmd publish rate low.");
     // for visualization with Rviz
     pub11_.publish(displayNextWaypoint(pp_.getPoseOfNextWaypoint()));
     pub13_.publish(displaySearchRadius(pp_.getCurrentPose().position, pp_.getLookaheadDistance()));
@@ -121,6 +124,7 @@ void PurePursuitNode::publishTwistStamped(const bool &amp;can_get_curvature, const d
   ts.header.stamp = ros::Time::now();
   ts.twist.linear.x = can_get_curvature ? computeCommandVelocity() : 0;
   ts.twist.angular.z = can_get_curvature ? kappa * ts.twist.linear.x : 0;
+  node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/twist",ts.twist.linear.x,2.2,3.3,4.4,"linear twist_cmd is too high");
   pub1_.publish(ts);
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" added_lines="6" deleted_lines="0">
				<diff>@@ -31,6 +31,10 @@
 #include "pure_pursuit.h"
 #include "pure_pursuit_viz.h"
 
+#include &lt;autoware_health_checker/node_status_publisher.h&gt;
+
+#include &lt;memory&gt;
+
 namespace waypoint_follower
 {
 enum class Mode : int32_t
@@ -60,6 +64,8 @@ private:
   ros::NodeHandle nh_;
   ros::NodeHandle private_nh_;
 
+  std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr_;
+
   // class
   PurePursuit pp_;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" added_lines="9" deleted_lines="0">
				<diff>@@ -32,6 +32,7 @@
 #include &lt;thread&gt;
 #include &lt;chrono&gt;
 #include &lt;map&gt;
+#include &lt;memory&gt;
 
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
@@ -48,6 +49,9 @@
 #include "autoware_msgs/SteerCmd.h"
 #include "autoware_msgs/ControlCommandStamped.h"
 
+//headers in Autowae Health Checker
+#include &lt;autoware_health_checker/node_status_publisher.h&gt;
+
 class TwistGate
 {
   using remote_msgs_t = autoware_msgs::RemoteCmd;
@@ -72,6 +76,7 @@ class TwistGate
 
     ros::NodeHandle nh_;
     ros::NodeHandle private_nh_;
+    std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_pub_ptr_;
     ros::Publisher emergency_stop_pub_;
     ros::Publisher control_command_pub_;
     ros::Publisher vehicle_cmd_pub_;
@@ -99,6 +104,7 @@ TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_n
     ,command_mode_(CommandMode::AUTO)
     ,previous_command_mode_(CommandMode::AUTO)
 {
+  node_status_pub_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh_,private_nh_);
   emergency_stop_pub_ = nh_.advertise&lt;std_msgs::Bool&gt;("/emergency_stop", 1, true);
   control_command_pub_ = nh_.advertise&lt;std_msgs::String&gt;("/ctrl_mode", 1);
   vehicle_cmd_pub_ = nh_.advertise&lt;vehicle_cmd_msg_t&gt;("/vehicle_cmd", 1, true);
@@ -118,6 +124,7 @@ TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_n
   twist_gate_msg_.header.seq = 0;
   emergency_stop_msg_.data = false;
   send_emergency_cmd = false;
+  node_status_pub_ptr_-&gt;ENABLE();
 
   remote_cmd_time_ = ros::Time::now();
   watchdog_timer_thread_ = std::thread(&amp;TwistGate::watchdog_timer, this);
@@ -226,6 +233,8 @@ void TwistGate::remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg)
 
 void TwistGate::auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::ConstPtr&amp; input_msg)
 {
+  node_status_pub_ptr_-&gt;NODE_ACTIVATE();
+  node_status_pub_ptr_-&gt;CHECK_RATE("/topic/rate/twist_cmd/slow",8,5,1,"topic twist_cmd subscribe rate low.");
   if(command_mode_ == CommandMode::AUTO)
   {
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\include\ray_ground_filter.h" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\include\ray_ground_filter.h" added_lines="5" deleted_lines="1">
				<diff>@@ -21,6 +21,7 @@
 #include &lt;iostream&gt;
 #include &lt;algorithm&gt;
 #include &lt;vector&gt;
+#include &lt;memory&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;pcl_ros/point_cloud.h&gt;
@@ -32,6 +33,9 @@
 #include &lt;velodyne_pointcloud/point_types.h&gt;
 #include "autoware_config_msgs/ConfigRayGroundFilter.h"
 
+//headers in Autoware Health Checker
+#include &lt;autoware_health_checker/node_status_publisher.h&gt;
+
 #include &lt;opencv2/core/version.hpp&gt;
 #if (CV_MAJOR_VERSION == 3)
 	#include "gencolors.cpp"
@@ -42,7 +46,7 @@
 class RayGroundFilter
 {
 private:
-
+	std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_pub_ptr_;
 	ros::NodeHandle     node_handle_;
 	ros::Subscriber     points_node_sub_;
 	ros::Subscriber     config_node_sub_;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\ray_ground_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\ray_ground_filter.cpp" added_lines="6" deleted_lines="0">
				<diff>@@ -283,6 +283,8 @@ void RayGroundFilter::RemovePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Pt
 
 void RayGroundFilter::CloudCallback(const sensor_msgs::PointCloud2ConstPtr &amp;in_sensor_cloud)
 {
+  node_status_pub_ptr_-&gt;NODE_ACTIVATE();
+  node_status_pub_ptr_-&gt;CHECK_RATE("/topic/rate/points_raw/slow",8,5,1,"topic points_raw subscribe rate low.");
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr current_sensor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
   pcl::fromROSMsg(*in_sensor_cloud, *current_sensor_cloud_ptr);
 
@@ -327,6 +329,10 @@ void RayGroundFilter::CloudCallback(const sensor_msgs::PointCloud2ConstPtr &amp;in_s
 
 RayGroundFilter::RayGroundFilter():node_handle_("~")
 {
+  ros::NodeHandle nh;
+  ros::NodeHandle pnh("~");
+  node_status_pub_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh,pnh);
+  node_status_pub_ptr_-&gt;ENABLE();
 }
 
 void RayGroundFilter::Run()
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="db61b3c6b076c592cb7287104b8298dae795b0e9" author="Yuma Nihei">
		<msg>[Feature] waypoint replanner and extractor (#1951)</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.cpp" new_path="" added_lines="0" deleted_lines="381">
				<diff>@@ -1,381 +0,0 @@
-/*
- *  Copyright (c) 2018, TierIV, Inc.
-
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#include "velocity_replanner.h"
-
-namespace waypoint_maker
-{
-inline double kmph2mps(double velocity_kmph)
-{
-  return (velocity_kmph * 1000) / (60 * 60);
-}
-inline double mps2kmph(double velocity_mps)
-{
-  return (velocity_mps * 60 * 60) / 1000;
-}
-
-VelocityReplanner::VelocityReplanner() : private_nh_("~")
-{
-}
-
-VelocityReplanner::~VelocityReplanner()
-{
-}
-
-void VelocityReplanner::initParameter(const autoware_config_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
-{
-  velocity_max_ = kmph2mps(conf-&gt;velocity_max);
-  velocity_min_ = kmph2mps(conf-&gt;velocity_min);
-  accel_limit_ = conf-&gt;accel_limit;
-  decel_limit_ = conf-&gt;decel_limit;
-  r_th_ = conf-&gt;radius_thresh;
-  r_min_ = conf-&gt;radius_min;
-  lookup_crv_width_ = 5;
-  resample_mode_ = conf-&gt;resample_mode;
-  resample_interval_ = conf-&gt;resample_interval;
-  velocity_offset_ = conf-&gt;velocity_offset;
-  end_point_offset_ = conf-&gt;end_point_offset;
-  r_inf_ = 10 * r_th_;
-  vel_param_ = calcVelParam();
-}
-
-void VelocityReplanner::replanLaneWaypointVel(autoware_msgs::Lane* lane)
-{
-  if (vel_param_ == DBL_MAX)
-  {
-    ROS_ERROR("velocity parameter is invalid: please change Rth or Rmin");
-    return;
-  }
-  std::vector&lt;double&gt; curve_radius;
-  std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt; curve_list;
-
-  if (resample_mode_)
-  {
-    resampleLaneWaypoint(resample_interval_, lane);
-  }
-  createRadiusList(*lane, &amp;curve_radius);
-  createCurveList(curve_radius, &amp;curve_list);
-  // set velocity_max for all_point
-  for (auto&amp; el : lane-&gt;waypoints)
-  {
-    el.twist.twist.linear.x = velocity_max_;
-  }
-  // set velocity by curve
-  for (const auto&amp; el : curve_list)
-  {
-    const double&amp; radius = el.second.second;
-    const double vmin = velocity_max_ - vel_param_ * (r_th_ - radius);
-    limitVelocityByRange(el.first, el.second.first, velocity_offset_, vmin, lane);
-  }
-  // set velocity on start &amp; end of lane
-  limitVelocityByRange(0, 0, 0, velocity_min_, lane);
-  limitVelocityByRange(lane-&gt;waypoints.size() - 1 - end_point_offset_, lane-&gt;waypoints.size() - 1, 0, 0.0, lane);
-}
-
-void VelocityReplanner::resampleLaneWaypoint(const double resample_interval, autoware_msgs::Lane* lane)
-{
-  if (lane-&gt;waypoints.empty())
-  {
-    return;
-  }
-  autoware_msgs::Lane original_lane = *lane;
-  lane-&gt;waypoints.clear();
-  lane-&gt;waypoints.push_back(original_lane.waypoints[0]);
-  lane-&gt;waypoints.reserve(ceil(1.5 * calcPathLength(original_lane) / resample_interval_));
-
-  for (unsigned long i = 1; i &lt; original_lane.waypoints.size(); i++)
-  {
-    boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point = getCrvPointsOnResample(*lane, original_lane, i);
-    const std::vector&lt;double&gt; curve_param = calcCurveParam(curve_point);
-
-    // if going straight
-    if (curve_param.empty())
-    {
-      resampleOnStraight(curve_point, lane);
-    }
-    // else if turnning curve
-    else
-    {
-      resampleOnCurve(curve_point[1], curve_param, lane);
-    }
-
-    lane-&gt;waypoints.back().wpstate = original_lane.waypoints[i].wpstate;
-    lane-&gt;waypoints.back().change_flag = original_lane.waypoints[i].change_flag;
-  }
-  lane-&gt;waypoints.back().wpstate = original_lane.waypoints.back().wpstate;
-  lane-&gt;waypoints.back().change_flag = original_lane.waypoints.back().change_flag;
-}
-
-void VelocityReplanner::resampleOnStraight(const boost::circular_buffer&lt;geometry_msgs::Point&gt;&amp; curve_point,
-                                           autoware_msgs::Lane* lane)
-{
-  autoware_msgs::Waypoint wp = lane-&gt;waypoints.back();
-  const geometry_msgs::Point&amp; pt = wp.pose.pose.position;
-  const double yaw = atan2(curve_point[2].y - curve_point[0].y, curve_point[2].x - curve_point[0].x);
-  wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
-
-  const std::vector&lt;double&gt; nvec = { curve_point[1].x - pt.x, curve_point[1].y - pt.y, curve_point[1].z - pt.z };
-  double dist = sqrt(nvec[0] * nvec[0] + nvec[1] * nvec[1]);
-  std::vector&lt;double&gt; resample_vec = nvec;
-  const double coeff = resample_interval_ / dist;
-  for (auto&amp; el : resample_vec)
-  {
-    el *= coeff;
-  }
-  for (; dist &gt; resample_interval_; dist -= resample_interval_)
-  {
-    wp.pose.pose.position.x += resample_vec[0];
-    wp.pose.pose.position.y += resample_vec[1];
-    wp.pose.pose.position.z += resample_vec[2];
-    lane-&gt;waypoints.push_back(wp);
-  }
-}
-
-void VelocityReplanner::resampleOnCurve(const geometry_msgs::Point&amp; target_point,
-                                        const std::vector&lt;double&gt;&amp; curve_param, autoware_msgs::Lane* lane)
-{
-  autoware_msgs::Waypoint wp = lane-&gt;waypoints.back();
-  const double&amp; cx = curve_param[0];
-  const double&amp; cy = curve_param[1];
-  const double&amp; radius = curve_param[2];
-
-  const geometry_msgs::Point&amp; p0 = wp.pose.pose.position;
-  const geometry_msgs::Point&amp; p1 = target_point;
-  double theta = fmod(atan2(p1.y - cy, p1.x - cx) - atan2(p0.y - cy, p0.x - cx), 2 * M_PI);
-  int sgn = (theta &gt; 0.0) ? (1) : (-1);
-  if (fabs(theta) &gt; M_PI)
-  {
-    theta -= 2 * sgn * M_PI;
-  }
-  sgn = (theta &gt; 0.0) ? (1) : (-1);
-  // interport
-  double t = atan2(p0.y - cy, p0.x - cx);
-  double dist = radius * fabs(theta);
-  const double resample_dz = resample_interval_ * (p1.z - p0.z) / dist;
-  for (; dist &gt; resample_interval_; dist -= resample_interval_)
-  {
-    if (lane-&gt;waypoints.size() == lane-&gt;waypoints.capacity())
-    {
-      break;
-    }
-    t += sgn * resample_interval_ / radius;
-    const double yaw = fmod(t + sgn * M_PI / 2.0, 2 * M_PI);
-    wp.pose.pose.position.x = cx + radius * cos(t);
-    wp.pose.pose.position.y = cy + radius * sin(t);
-    wp.pose.pose.position.z += resample_dz;
-    wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
-    lane-&gt;waypoints.push_back(wp);
-  }
-}
-
-// Three points used for curve detection (the target point is the center)
-// [0] = previous point, [1] = target point, [2] = next point
-const boost::circular_buffer&lt;geometry_msgs::Point&gt; VelocityReplanner::getCrvPointsOnResample(
-    const autoware_msgs::Lane&amp; lane, const autoware_msgs::Lane&amp; original_lane, unsigned long original_index) const
-{
-  unsigned long id = original_index;
-  boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point(3);
-  const unsigned int n = (lookup_crv_width_ - 1) / 2;
-  const autoware_msgs::Waypoint cp[3] = {
-    (lane.waypoints.size() &lt; n) ? lane.waypoints.front() : lane.waypoints[lane.waypoints.size() - n],
-    original_lane.waypoints[id],
-    (id &lt; original_lane.waypoints.size() - n) ? original_lane.waypoints[id + n] : original_lane.waypoints.back()
-  };
-  for (int i = 0; i &lt; 3; i++)
-  {
-    curve_point.push_back(cp[i].pose.pose.position);
-  }
-  return curve_point;
-}
-
-const boost::circular_buffer&lt;geometry_msgs::Point&gt; VelocityReplanner::getCrvPoints(const autoware_msgs::Lane&amp; lane,
-                                                                                   unsigned long index) const
-{
-  boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point(3);
-  const unsigned int n = (lookup_crv_width_ - 1) / 2;
-  const unsigned long curve_index[3] = { (index &lt; n) ? 0 : (index - n), index, (index &gt;= lane.waypoints.size() - n) ?
-                                                                                   (lane.waypoints.size() - 1) :
-                                                                                   (index + n) };
-  for (int i = 0; i &lt; 3; i++)
-  {
-    curve_point.push_back(lane.waypoints[curve_index[i]].pose.pose.position);
-  }
-  return curve_point;
-}
-
-void VelocityReplanner::createRadiusList(const autoware_msgs::Lane&amp; lane, std::vector&lt;double&gt;* curve_radius)
-{
-  if (lane.waypoints.empty())
-  {
-    return;
-  }
-  curve_radius-&gt;resize(lane.waypoints.size());
-  curve_radius-&gt;at(0) = curve_radius-&gt;back() = r_inf_;
-
-  for (unsigned long i = 1; i &lt; lane.waypoints.size() - 1; i++)
-  {
-    boost::circular_buffer&lt;geometry_msgs::Point&gt; curve_point = getCrvPoints(lane, i);
-    const std::vector&lt;double&gt; curve_param = calcCurveParam(curve_point);
-
-    // if going straight
-    if (curve_param.empty())
-    {
-      curve_radius-&gt;at(i) = r_inf_;
-    }
-    // else if turnning curve
-    else
-    {
-      curve_radius-&gt;at(i) = (curve_param[2] &gt; r_inf_) ? r_inf_ : curve_param[2];
-    }
-  }
-}
-
-const double VelocityReplanner::calcVelParam() const
-{
-  if (fabs(r_th_ - r_min_) &lt; 1e-8)
-  {
-    return DBL_MAX;  // error
-  }
-  return (velocity_max_ - velocity_min_) / (r_th_ - r_min_);
-}
-
-void VelocityReplanner::createCurveList(
-    const std::vector&lt;double&gt;&amp; curve_radius,
-    std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list)
-{
-  unsigned long index = 0;
-  bool on_curve = false;
-  double radius_localmin = DBL_MAX;
-  for (unsigned long i = 1; i &lt; curve_radius.size(); i++)
-  {
-    if (!on_curve &amp;&amp; curve_radius[i] &lt;= r_th_ &amp;&amp; curve_radius[i - 1] &gt; r_th_)
-    {
-      index = i;
-      on_curve = true;
-    }
-    else if (on_curve &amp;&amp; curve_radius[i - 1] &lt;= r_th_ &amp;&amp; curve_radius[i] &gt; r_th_)
-    {
-      on_curve = false;
-      if (radius_localmin &lt; r_min_)
-      {
-        radius_localmin = r_min_;
-      }
-      (*curve_list)[index] = std::make_pair(i, radius_localmin);
-      radius_localmin = DBL_MAX;
-    }
-    if (!on_curve)
-    {
-      continue;
-    }
-    if (radius_localmin &gt; curve_radius[i])
-    {
-      radius_localmin = curve_radius[i];
-    }
-  }
-}
-
-void VelocityReplanner::limitVelocityByRange(unsigned long start_idx, unsigned long end_idx, unsigned int offset,
-                                             double vmin, autoware_msgs::Lane* lane)
-{
-  if (offset &gt; 0)
-  {
-    start_idx = (start_idx &gt; offset) ? (start_idx - offset) : 0;
-    end_idx = (end_idx &gt; offset) ? (end_idx - offset) : 0;
-  }
-  for (unsigned long idx = start_idx; idx &lt;= end_idx; idx++)
-  {
-    if (lane-&gt;waypoints[idx].twist.twist.linear.x &lt; vmin)
-    {
-      continue;
-    }
-    lane-&gt;waypoints[idx].twist.twist.linear.x = vmin;
-  }
-  limitAccelDecel(start_idx, lane);
-  limitAccelDecel(end_idx, lane);
-}
-
-void VelocityReplanner::limitAccelDecel(const unsigned long idx, autoware_msgs::Lane* lane)
-{
-  const double acc[2] = { accel_limit_, decel_limit_ };
-  const unsigned long end_idx[2] = { lane-&gt;waypoints.size() - idx, idx + 1 };
-  const int sgn[2] = { 1, -1 };
-  for (int j = 0; j &lt; 2; j++)  // [j=0]: accel_limit_process, [j=1]: decel_limit_process
-  {
-    double v = lane-&gt;waypoints[idx].twist.twist.linear.x;
-    unsigned long next = idx + sgn[j];
-    for (unsigned long i = 1; i &lt; end_idx[j]; i++, next += sgn[j])
-    {
-      v = sqrt(2 * acc[j] * resample_interval_ + v * v);
-      if (v &gt; velocity_max_ || v &gt; lane-&gt;waypoints[next].twist.twist.linear.x)
-      {
-        break;
-      }
-      lane-&gt;waypoints[next].twist.twist.linear.x = v;
-    }
-  }
-}
-
-// get curve 3-Parameter [center_x, center_y, radius] with 3 point input. If error occured, return empty vector.
-const std::vector&lt;double&gt; VelocityReplanner::calcCurveParam(boost::circular_buffer&lt;geometry_msgs::Point&gt; p) const
-{
-  for (int i = 0; i &lt; 3; i++, p.push_back(p.front()))  // if exception occured, change points order
-  {
-    const double d = 2 * ((p[0].y - p[2].y) * (p[0].x - p[1].x) - (p[0].y - p[1].y) * (p[0].x - p[2].x));
-    if (fabs(d) &lt; 1e-8)
-    {
-      continue;
-    }
-    const std::vector&lt;double&gt; x2 = { p[0].x * p[0].x, p[1].x * p[1].x, p[2].x * p[2].x };
-    const std::vector&lt;double&gt; y2 = { p[0].y * p[0].y, p[1].y * p[1].y, p[2].y * p[2].y };
-    const double a = y2[0] - y2[1] + x2[0] - x2[1];
-    const double b = y2[0] - y2[2] + x2[0] - x2[2];
-    std::vector&lt;double&gt; param(3);
-    const double cx = param[0] = ((p[0].y - p[2].y) * a - (p[0].y - p[1].y) * b) / d;
-    const double cy = param[1] = ((p[0].x - p[2].x) * a - (p[0].x - p[1].x) * b) / -d;
-    param[2] = sqrt((cx - p[0].x) * (cx - p[0].x) + (cy - p[0].y) * (cy - p[0].y));
-    return param;
-  }
-  return std::vector&lt;double&gt;();  // error
-}
-
-const double VelocityReplanner::calcPathLength(const autoware_msgs::Lane&amp; lane) const
-{
-  double distance = 0.0;
-  for (unsigned long i = 1; i &lt; lane.waypoints.size(); i++)
-  {
-    const geometry_msgs::Point&amp; p0 = lane.waypoints[i - 1].pose.pose.position;
-    const geometry_msgs::Point&amp; p1 = lane.waypoints[i].pose.pose.position;
-    tf::Vector3 tf0(p0.x, p0.y, 0.0);
-    tf::Vector3 tf1(p1.x, p1.y, 0.0);
-    distance += tf::tfDistance(tf0, tf1);
-  }
-  return distance;
-}
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\velocity_replanner.h" new_path="" added_lines="0" deleted_lines="89">
				<diff>@@ -1,89 +0,0 @@
-/*
- *  Copyright (c) 2018, TierIV, Inc.
-
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#ifndef __VELOCITY_REPLANNER_H__
-#define __VELOCITY_REPLANNER_H__
-
-#include &lt;ros/ros.h&gt;
-#include &lt;tf/transform_datatypes.h&gt;
-#include &lt;autoware_config_msgs/ConfigWaypointLoader.h&gt;
-#include &lt;fstream&gt;
-#include &lt;unordered_map&gt;
-#include &lt;algorithm&gt;
-#include &lt;boost/circular_buffer.hpp&gt;
-#include "autoware_msgs/Lane.h"
-
-namespace waypoint_maker
-{
-class VelocityReplanner
-{
-private:
-  ros::NodeHandle private_nh_;
-  double r_th_, r_min_, r_inf_;
-  int lookup_crv_width_;
-  double velocity_max_, velocity_min_;
-  double accel_limit_, decel_limit_, resample_interval_;
-  int velocity_offset_;
-  bool resample_mode_;
-  int end_point_offset_;
-  double vel_param_;
-
-public:
-  VelocityReplanner();
-  ~VelocityReplanner();
-  void initParameter(const autoware_config_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
-  void replanLaneWaypointVel(autoware_msgs::Lane* lane);
-
-protected:
-  void resampleLaneWaypoint(const double resample_interval, autoware_msgs::Lane* lane);
-  void resampleOnStraight(const boost::circular_buffer&lt;geometry_msgs::Point&gt;&amp; curve_point, autoware_msgs::Lane* lane);
-  void resampleOnCurve(const geometry_msgs::Point&amp; target_point, const std::vector&lt;double&gt;&amp; param,
-                       autoware_msgs::Lane* lane);
-
-  const boost::circular_buffer&lt;geometry_msgs::Point&gt; getCrvPointsOnResample(const autoware_msgs::Lane&amp; lane,
-                                                                            const autoware_msgs::Lane&amp; original_lane,
-                                                                            unsigned long original_index) const;
-  const boost::circular_buffer&lt;geometry_msgs::Point&gt; getCrvPoints(const autoware_msgs::Lane&amp; lane,
-                                                                  unsigned long index) const;
-
-  void createRadiusList(const autoware_msgs::Lane&amp; lane, std::vector&lt;double&gt;* curve_radius);
-  const double calcVelParam() const;
-  void createCurveList(const std::vector&lt;double&gt;&amp; curve_radius,
-                       std::unordered_map&lt;unsigned long, std::pair&lt;unsigned long, double&gt; &gt;* curve_list);
-
-  void limitVelocityByRange(unsigned long start_idx, unsigned long end_idx, unsigned int offset, double vmin,
-                            autoware_msgs::Lane* lane);
-  void limitAccelDecel(const unsigned long idx, autoware_msgs::Lane* lane);
-
-  const std::vector&lt;double&gt; calcCurveParam(boost::circular_buffer&lt;geometry_msgs::Point&gt; point) const;
-  const double calcPathLength(const autoware_msgs::Lane&amp; lane) const;
-};
-}
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="9" deleted_lines="83">
				<diff>@@ -31,70 +31,20 @@ WaypointLoaderNode::~WaypointLoaderNode()
 
 void WaypointLoaderNode::initPubSub()
 {
-  private_nh_.param&lt;bool&gt;("disable_decision_maker", disable_decision_maker_, true);
+  private_nh_.param&lt;std::string&gt;("multi_lane_csv", multi_lane_csv_, "/tmp/driving_lane.csv");
   // setup publisher
-  if (disable_decision_maker_)
-  {
-    lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/lane_waypoints_array", 10, true);
-  }
-  else
-  {
-    lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/based/lane_waypoints_array", 10, true);
-  }
-  config_sub_ = nh_.subscribe("/config/waypoint_loader", 1, &amp;WaypointLoaderNode::configCallback, this);
-  output_cmd_sub_ =
-      nh_.subscribe("/config/waypoint_loader_output", 1, &amp;WaypointLoaderNode::outputCommandCallback, this);
-}
-
-void WaypointLoaderNode::initParameter(const autoware_config_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
-{
-  // parameter settings
-  replanning_mode_ = conf-&gt;replanning_mode;
-  multi_lane_csv_ = conf-&gt;multi_lane_csv;
+  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/based/lane_waypoints_raw", 10, true);
 }
 
-void WaypointLoaderNode::configCallback(const autoware_config_msgs::ConfigWaypointLoader::ConstPtr&amp; conf)
+void WaypointLoaderNode::run()
 {
-  initParameter(conf);
-  replanner_.initParameter(conf);
-
   multi_file_path_.clear();
   parseColumns(multi_lane_csv_, &amp;multi_file_path_);
   autoware_msgs::LaneArray lane_array;
   createLaneArray(multi_file_path_, &amp;lane_array);
   lane_pub_.publish(lane_array);
   output_lane_array_ = lane_array;
-}
-
-void WaypointLoaderNode::outputCommandCallback(const std_msgs::Bool::ConstPtr&amp; output_cmd)
-{
-  std::vector&lt;std::string&gt; dst_multi_file_path = multi_file_path_;
-  for (auto&amp; el : dst_multi_file_path)
-  {
-    el = addFileSuffix(el, "_replanned");
-  }
-  saveLaneArray(dst_multi_file_path, output_lane_array_);
-}
-
-const std::string addFileSuffix(std::string file_path, std::string suffix)
-{
-  std::string output_file_path, tmp;
-  std::string directory_path, filename, extension;
-
-  tmp = file_path;
-  const std::string::size_type idx_slash = tmp.find_last_of("/");
-  if (idx_slash != std::string::npos)
-  {
-    tmp.erase(0, idx_slash);
-  }
-  const std::string::size_type idx_dot = tmp.find_last_of(".");
-  const std::string::size_type idx_dot_allpath = file_path.find_last_of(".");
-  if (idx_dot != std::string::npos &amp;&amp; idx_dot != tmp.size() - 1)
-  {
-    file_path.erase(idx_dot_allpath, file_path.size() - 1);
-  }
-  file_path += suffix + ".csv";
-  return file_path;
+  ros::spin();
 }
 
 void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt;&amp; paths, autoware_msgs::LaneArray* lane_array)
@@ -103,31 +53,7 @@ void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt;&amp; paths,
   {
     autoware_msgs::Lane lane;
     createLaneWaypoint(el, &amp;lane);
-    if (replanning_mode_)
-    {
-      replanner_.replanLaneWaypointVel(&amp;lane);
-    }
-    lane_array-&gt;lanes.push_back(lane);
-  }
-}
-
-void WaypointLoaderNode::saveLaneArray(const std::vector&lt;std::string&gt;&amp; paths,
-                                       const autoware_msgs::LaneArray&amp; lane_array)
-{
-  unsigned long idx = 0;
-  for (const auto&amp; file_path : paths)
-  {
-    std::ofstream ofs(file_path.c_str());
-    ofs &lt;&lt; "x,y,z,yaw,velocity,change_flag,steering_flag,accel_flag,stop_flag,event_flag" &lt;&lt; std::endl;
-    for (const auto&amp; el : lane_array.lanes[idx].waypoints)
-    {
-      ofs &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; el.pose.pose.position.x &lt;&lt; "," &lt;&lt; el.pose.pose.position.y &lt;&lt; ","
-          &lt;&lt; el.pose.pose.position.z &lt;&lt; "," &lt;&lt; tf::getYaw(el.pose.pose.orientation) &lt;&lt; ","
-          &lt;&lt; mps2kmph(el.twist.twist.linear.x) &lt;&lt; "," &lt;&lt; (int)el.change_flag &lt;&lt; "," &lt;&lt; (int)el.wpstate.steering_state
-          &lt;&lt; "," &lt;&lt; (int)el.wpstate.accel_state &lt;&lt; "," &lt;&lt; (int)el.wpstate.stop_state &lt;&lt; ","
-          &lt;&lt; (int)el.wpstate.event_state &lt;&lt; std::endl;
-    }
-    idx++;
+    lane_array-&gt;lanes.emplace_back(lane);
   }
 }
 
@@ -175,7 +101,7 @@ void WaypointLoaderNode::loadWaypointsForVer1(const char* filename, std::vector&lt;
   {
     autoware_msgs::Waypoint wp;
     parseWaypointForVer1(line, &amp;wp);
-    wps-&gt;push_back(wp);
+    wps-&gt;emplace_back(wp);
   }
 
   size_t last = wps-&gt;size() - 1;
@@ -221,7 +147,7 @@ void WaypointLoaderNode::loadWaypointsForVer2(const char* filename, std::vector&lt;
   {
     autoware_msgs::Waypoint wp;
     parseWaypointForVer2(line, &amp;wp);
-    wps-&gt;push_back(wp);
+    wps-&gt;emplace_back(wp);
   }
 }
 
@@ -256,7 +182,7 @@ void WaypointLoaderNode::loadWaypointsForVer3(const char* filename, std::vector&lt;
   {
     autoware_msgs::Waypoint wp;
     parseWaypointForVer3(line, contents, &amp;wp);
-    wps-&gt;push_back(wp);
+    wps-&gt;emplace_back(wp);
   }
 }
 
@@ -371,7 +297,7 @@ void parseColumns(const std::string&amp; line, std::vector&lt;std::string&gt;* columns)
     }
     if (!column.empty())
     {
-      columns-&gt;push_back(column);
+      columns-&gt;emplace_back(column);
     }
   }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="1" deleted_lines="9">
				<diff>@@ -29,7 +29,6 @@
 #include &lt;unordered_map&gt;
 
 #include "autoware_msgs/LaneArray.h"
-#include "velocity_replanner.h"
 
 namespace waypoint_maker
 {
@@ -60,6 +59,7 @@ class WaypointLoaderNode
 public:
   WaypointLoaderNode();
   ~WaypointLoaderNode();
+  void run();
 
 private:
   // handle
@@ -69,26 +69,18 @@ private:
   // publisher &amp; subscriber
   ros::Publisher lane_pub_;
   ros::Subscriber config_sub_;
-  ros::Subscriber output_cmd_sub_;
 
   // variables
   std::string multi_lane_csv_;
-  bool disable_decision_maker_;
-  bool replanning_mode_;
-  VelocityReplanner replanner_;
   std::vector&lt;std::string&gt; multi_file_path_;
   autoware_msgs::LaneArray output_lane_array_;
 
   // initializer
   void initPubSub();
-  void initParameter(const autoware_config_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
 
   // functions
-  void configCallback(const autoware_config_msgs::ConfigWaypointLoader::ConstPtr&amp; conf);
-  void outputCommandCallback(const std_msgs::Bool::ConstPtr&amp; output_cmd);
   void createLaneWaypoint(const std::string&amp; file_path, autoware_msgs::Lane* lane);
   void createLaneArray(const std::vector&lt;std::string&gt;&amp; paths, autoware_msgs::LaneArray* lane_array);
-  void saveLaneArray(const std::vector&lt;std::string&gt;&amp; paths, const autoware_msgs::LaneArray&amp; lane_array);
 
   FileFormat checkFileFormat(const char* filename);
   bool verifyFileConsistency(const char* filename);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_node.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -23,7 +23,7 @@ int main(int argc, char** argv)
 {
   ros::init(argc, argv, "waypoint_loader");
   waypoint_maker::WaypointLoaderNode wln;
-  ros::spin();
+  wln.run();
 
   return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="28bf8bb0c96f6ff45759933798747f50f322bec4" author="Yukihiro SAITO">
		<msg>fixed bug and typo</msg>
		<modified_files>
			<file old_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_info_publisher.cpp" new_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_info_publisher.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -54,8 +54,8 @@ VehicleGazeboInfoPublisher::VehicleGazeboInfoPublisher() : nh_(""), pnh_("~"), t
     vehicle_status_pub_ = nh_.advertise&lt;autoware_msgs::VehicleStatus&gt;("/vehicle_status", 1);
     double publish_pose_rate;
     pnh_.param&lt;double&gt;("publish_pose_rate", publish_pose_rate, double(10.0));
-    pnh_.param&lt;double&gt;("wheel_radius", wheel_radius_, 0.341);
-    pnh_.param("wheel_base", wheel_base_, 2.95);
+    pnh_.param&lt;double&gt;("/vehicle_info/wheel_radius", wheel_radius_, 0.341);
+    pnh_.param("/vehicle_info/wheel_base", wheel_base_, 2.95);
     pnh_.param("ns", ns_, std::string("autoware_gazebo"));
     pnh_.param("enable_base_link_tf", enable_base_link_tf_, false);
 
@@ -72,7 +72,7 @@ void VehicleGazeboInfoPublisher::publishTimerCallback(const ros::TimerEvent &amp;e)
     client_.call(base_link_srv);
 
     geometry_msgs::PoseStamped output_pose;
-    output_pose.header.frame_id = "base_link";
+    output_pose.header.frame_id = "world";
     output_pose.header.stamp = current_time;
     output_pose.pose = base_link_srv.response.link_state.pose;
 
@@ -142,7 +142,7 @@ void VehicleGazeboInfoPublisher::jointStateCallback(const sensor_msgs::JointStat
     output_steering_angle.data = (steering_right_front_angle + steering_left_front_angle) / 2.0;
     output_vehicle_status.header.stamp = current_time;
     output_vehicle_status.header.frame_id = "base_link";
-    output_vehicle_status.speed = output_vel.data;
+    output_vehicle_status.speed = output_vel.data * 3.6; //km/h
     output_vehicle_status.angle = output_steering_angle.data;
 
     output_twiststamped.header.stamp = current_time;
</diff>
			</file>
			<file old_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_input_subscriber.cpp" new_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_input_subscriber.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -40,10 +40,10 @@ class VehicleGazeboInputSubscriber
 VehicleGazeboInputSubscriber::VehicleGazeboInputSubscriber() : nh_(""), pnh_("~")
 {
 
-    pnh_.param("wheel_base", wheel_base_, 2.95);
-    pnh_.param("wheel_radius", wheel_radius_, 0.341);
-    pnh_.param("wheel_tread", wheel_tread_, 1.55);
-    pnh_.param("twiststamped_", twiststamped_, true);
+    pnh_.param("/vehicle_info/wheel_base", wheel_base_, 2.95);
+    pnh_.param("/vehicle_info/wheel_radius", wheel_radius_, 0.341);
+    pnh_.param("/vehicle_info/wheel_tread", wheel_tread_, 1.55);
+    pnh_.param("twiststamped", twiststamped_, true);
     pnh_.param("ctrl_cmd", ctrl_cmd_, false);
     wheel_right_rear_pub_ = nh_.advertise&lt;std_msgs::Float64&gt;("wheel_right_rear_velocity_controller/command", 1, true);
     wheel_left_rear_pub_ = nh_.advertise&lt;std_msgs::Float64&gt;("wheel_left_rear_velocity_controller/command", 1, true);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="36fd263b0bee85845dd7f4129a652f17cbea99cf" author="Yukihiro SAITO">
		<msg>update for can odometry</msg>
		<modified_files>
			<file old_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_info_publisher.cpp" new_path="ros\src\simulation\gazebo_simulator\vehicle\vehicle_gazebo_simulation_interface\src\vehicle_gazebo_info_publisher.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -143,7 +143,7 @@ void VehicleGazeboInfoPublisher::jointStateCallback(const sensor_msgs::JointStat
     output_vehicle_status.header.stamp = current_time;
     output_vehicle_status.header.frame_id = "base_link";
     output_vehicle_status.speed = output_vel.data * 3.6; //km/h
-    output_vehicle_status.angle = output_steering_angle.data;
+    output_vehicle_status.angle = output_steering_angle.data * 180.0 / M_PI; //degree 
 
     output_twiststamped.header.stamp = current_time;
     output_twiststamped.header.frame_id = "base_link";
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="724e8b0767a9a6f91f5bd5f57d9dc64fa5442319" author="Masaya Kataoka">
		<msg>[Feature] enable display errors (#1970)</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\default.rviz" new_path="ros\src\.config\rviz\default.rviz" added_lines="145" deleted_lines="70">
				<diff>@@ -6,14 +6,19 @@ Panels:
       Expanded:
         - /Global Options1
         - /Camera1/Visibility1
+        - /Points Raw1
         - /Points Raw1/Status1
         - /Local Waypoints1/Status1
         - /Vector Map CenterLines1/Namespaces1
         - /Global Path1/Namespaces1
         - /Local Rollouts1/Namespaces1
         - /GlobalPathAnimation1/Status1
+        - /OverlayImage1
+        - /OK1
+        - /ERROR1
+        - /FATAL1
       Splitter Ratio: 0.695804
-    Tree Height: 667
+    Tree Height: 1903
   - Class: rviz/Selection
     Name: Selection
   - Class: rviz/Tool Properties
@@ -22,7 +27,7 @@ Panels:
       - /2D Nav Goal1
       - /Publish Point1
     Name: Tool Properties
-    Splitter Ratio: 0.588679
+    Splitter Ratio: 0.588679016
   - Class: rviz/Views
     Expanded:
       - /Current View1
@@ -32,7 +37,7 @@ Panels:
     Experimental: false
     Name: Time
     SyncMode: 0
-    SyncSource: Points Map
+    SyncSource: ""
 Visualization Manager:
   Class: ""
   Displays:
@@ -42,7 +47,7 @@ Visualization Manager:
       Color: 160; 160; 164
       Enabled: false
       Line Style:
-        Line Width: 0.03
+        Line Width: 0.0299999993
         Value: Lines
       Name: Grid
       Normal Cell Count: 0
@@ -59,36 +64,16 @@ Visualization Manager:
       Frame Timeout: 15
       Frames:
         All Enabled: true
-        base_link:
-          Value: true
-        gps:
-          Value: true
-        map:
-          Value: true
-        mobility:
-          Value: true
-        velodyne:
-          Value: true
-        world:
-          Value: true
       Marker Scale: 5
       Name: TF
       Show Arrows: true
       Show Axes: true
       Show Names: true
       Tree:
-        world:
-          map:
-            base_link:
-              velodyne:
-                {}
-            gps:
-              {}
-            mobility:
-              {}
+        {}
       Update Interval: 0
       Value: true
-    - Alpha: 0.05
+    - Alpha: 0.0500000007
       Autocompute Intensity Bounds: true
       Autocompute Value Bounds:
         Max Value: 10
@@ -111,7 +96,7 @@ Visualization Manager:
       Queue Size: 10
       Selectable: true
       Size (Pixels): 2
-      Size (m): 0.01
+      Size (m): 0.00999999978
       Style: Points
       Topic: /points_map
       Unreliable: false
@@ -123,19 +108,7 @@ Visualization Manager:
       Marker Topic: /vector_map
       Name: Vector Map
       Namespaces:
-        cross_walk: true
-        curb: true
-        gutter: true
-        road_edge: true
-        road_mark: true
-        road_pole: true
-        road_sign: true
-        signal: true
-        stop_line: true
-        street_light: true
-        utility_pole: true
-        white_line: true
-        zebra_zone: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Camera
@@ -143,13 +116,12 @@ Visualization Manager:
       Image Rendering: overlay
       Image Topic: /image_raw
       Name: Camera
-      Overlay Alpha: 0.4
+      Overlay Alpha: 0.400000006
       Queue Size: 10
       Transport Hint: raw
       Unreliable: false
       Value: false
       Visibility:
-        "": true
         A* Sim Obstacle: true
         Behavior State: true
         Control Pose: true
@@ -159,10 +131,13 @@ Visualization Manager:
         Global Waypoints: true
         GlobalPathAnimation: true
         Grid: true
+        Image: true
         Local Rollouts: true
         Local Waypoints: true
         Next Waypoint Mark: true
         Occupancy Grid Map: true
+        OverlayImage: true
+        OverlayText: true
         PP Trajectory Mark: true
         Points Cluster: true
         Points Map: true
@@ -180,17 +155,17 @@ Visualization Manager:
         Vscan Points: true
         Waypoint Guide: true
       Zoom Factor: 1
-    - Alpha: 0.5
+    - Alpha: 0.300000012
       Autocompute Intensity Bounds: true
       Autocompute Value Bounds:
-        Max Value: 10
-        Min Value: -10
+        Max Value: 30.3039417
+        Min Value: 9.71042252
         Value: true
       Axis: Z
       Channel Name: intensity
       Class: rviz/PointCloud2
       Color: 255; 255; 255
-      Color Transformer: Intensity
+      Color Transformer: AxisColor
       Decay Time: 0
       Enabled: true
       Invert Rainbow: false
@@ -202,8 +177,8 @@ Visualization Manager:
       Position Transformer: XYZ
       Queue Size: 10
       Selectable: true
-      Size (Pixels): 1
-      Size (m): 0.01
+      Size (Pixels): 5
+      Size (m): 0.00999999978
       Style: Points
       Topic: /points_raw
       Unreliable: false
@@ -233,7 +208,7 @@ Visualization Manager:
       Queue Size: 10
       Selectable: true
       Size (Pixels): 3
-      Size (m): 0.01
+      Size (m): 0.00999999978
       Style: Points
       Topic: /vscan_points
       Unreliable: false
@@ -242,7 +217,7 @@ Visualization Manager:
       Value: false
     - Alpha: 1
       Axes Length: 1
-      Axes Radius: 0.1
+      Axes Radius: 0.100000001
       Class: rviz/Pose
       Color: 255; 25; 0
       Enabled: false
@@ -257,7 +232,7 @@ Visualization Manager:
       Value: false
     - Alpha: 1
       Axes Length: 1
-      Axes Radius: 0.1
+      Axes Radius: 0.100000001
       Class: rviz/Pose
       Color: 255; 170; 255
       Enabled: false
@@ -341,7 +316,7 @@ Visualization Manager:
       Queue Size: 10
       Selectable: true
       Size (Pixels): 5
-      Size (m): 0.01
+      Size (m): 0.00999999978
       Style: Points
       Topic: /points_cluster
       Unreliable: false
@@ -380,7 +355,7 @@ Visualization Manager:
         {}
       Queue Size: 100
       Value: true
-    - Alpha: 0.7
+    - Alpha: 0.699999988
       Class: rviz/Map
       Color Scheme: map
       Draw Behind: true
@@ -388,6 +363,7 @@ Visualization Manager:
       Name: Occupancy Grid Map
       Topic: /grid_map_visualization/distance_transform
       Unreliable: false
+      Use Timestamp: false
       Value: true
     - Class: rviz/MarkerArray
       Enabled: true
@@ -451,10 +427,10 @@ Visualization Manager:
       Topic: /dp_planner_tracked_boxes
       Unreliable: false
       Value: true
-      alpha: 0.8
+      alpha: 0.800000012
       color: 25; 255; 0
       coloring: Value
-      line width: 0.01
+      line width: 0.00999999978
       only edge: false
       show coords: false
     - Buffer length: 100
@@ -469,7 +445,7 @@ Visualization Manager:
       background color: 0; 0; 0
       backround alpha: 0
       border: true
-      foreground alpha: 0.7
+      foreground alpha: 0.699999988
       foreground color: 85; 255; 0
       height: 80
       left: 40
@@ -480,13 +456,13 @@ Visualization Manager:
       show caption: true
       text size: 8
       top: 30
-      update interval: 0.04
+      update interval: 0.0399999991
       width: 80
-    - Background Alpha: 0.8
+    - Background Alpha: 0.800000012
       Background Color: 0; 0; 0
       Class: jsk_rviz_plugin/OverlayText
       Enabled: true
-      Foreground Alpha: 0.8
+      Foreground Alpha: 0.800000012
       Foreground Color: 25; 255; 240
       Name: OverlayText
       Overtake Color Properties: false
@@ -500,10 +476,106 @@ Visualization Manager:
       text size: 12
       top: 0
       width: 128
+    - Class: rviz/Image
+      Enabled: false
+      Image Topic: /image_raw
+      Max Value: 1
+      Median window: 5
+      Min Value: 0
+      Name: Image
+      Normalize Range: true
+      Queue Size: 2
+      Transport Hint: raw
+      Unreliable: false
+      Value: false
+    - Class: jsk_rviz_plugin/OverlayImage
+      Enabled: false
+      Name: OverlayImage
+      Topic: /image_raw
+      Value: false
+      alpha: 0.800000012
+      height: 128
+      keep aspect ratio: true
+      left: 128
+      top: 128
+      width: 640
+    - Background Alpha: 0.800000012
+      Background Color: 0; 0; 0
+      Class: jsk_rviz_plugin/OverlayText
+      Enabled: true
+      Foreground Alpha: 0.800000012
+      Foreground Color: 25; 255; 240
+      Name: OK
+      Overtake Color Properties: false
+      Overtake Position Properties: false
+      Topic: /health_aggreator/ok_text
+      Value: true
+      font: DejaVu Sans Mono
+      height: 128
+      left: 0
+      line width: 2
+      text size: 12
+      top: 0
+      width: 128
+    - Background Alpha: 0.800000012
+      Background Color: 0; 0; 0
+      Class: jsk_rviz_plugin/OverlayText
+      Enabled: true
+      Foreground Alpha: 0.800000012
+      Foreground Color: 25; 255; 240
+      Name: WARN
+      Overtake Color Properties: false
+      Overtake Position Properties: false
+      Topic: /health_aggreator/warn_text
+      Value: true
+      font: DejaVu Sans Mono
+      height: 128
+      left: 0
+      line width: 2
+      text size: 12
+      top: 0
+      width: 128
+    - Background Alpha: 0.800000012
+      Background Color: 0; 0; 0
+      Class: jsk_rviz_plugin/OverlayText
+      Enabled: true
+      Foreground Alpha: 0.800000012
+      Foreground Color: 25; 255; 240
+      Name: ERROR
+      Overtake Color Properties: false
+      Overtake Position Properties: false
+      Topic: /health_aggreator/error_text
+      Value: true
+      font: DejaVu Sans Mono
+      height: 128
+      left: 0
+      line width: 2
+      text size: 12
+      top: 0
+      width: 128
+    - Background Alpha: 0.800000012
+      Background Color: 0; 0; 0
+      Class: jsk_rviz_plugin/OverlayText
+      Enabled: true
+      Foreground Alpha: 0.800000012
+      Foreground Color: 25; 255; 240
+      Name: FATAL
+      Overtake Color Properties: false
+      Overtake Position Properties: false
+      Topic: /health_aggreator/fatal_text
+      Value: true
+      font: DejaVu Sans Mono
+      height: 128
+      left: 0
+      line width: 2
+      text size: 12
+      top: 0
+      width: 128
   Enabled: true
   Global Options:
     Background Color: 48; 48; 48
-    Fixed Frame: world
+    Default Light: true
+    Fixed Frame: map
     Frame Rate: 30
   Name: root
   Tools:
@@ -526,27 +598,30 @@ Visualization Manager:
       Angle: 0
       Class: rviz/TopDownOrtho
       Enable Stereo Rendering:
-        Stereo Eye Separation: 0.06
+        Stereo Eye Separation: 0.0599999987
         Stereo Focal Distance: 1
         Swap Stereo Eyes: false
         Value: false
+      Invert Z Axis: false
       Name: Current View
-      Near Clip Distance: 0.01
-      Scale: 3.97317
+      Near Clip Distance: 0.00999999978
+      Scale: 10
       Target Frame: &lt;Fixed Frame&gt;
       Value: TopDownOrtho (rviz)
-      X: -27.0383
-      Y: 47.1504
+      X: 0
+      Y: 0
     Saved: ~
 Window Geometry:
   Camera:
     collapsed: false
   Displays:
     collapsed: false
-  Height: 900
+  Height: 2136
   Hide Left Dock: false
   Hide Right Dock: false
-  QMainWindow State: 000000ff00000000fd00000004000000000000016a000002dcfc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc00000028000002dc000000dd00fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000c00430061006d0065007200610000000000ffffffff0000006500fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb00000000000000000000000100000163000002dcfc0200000003fb0000000a005600690065007700730100000028000002dc000000b000fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000006400000005cfc0100000002fb0000000800540069006d0065010000000000000640000002f600fffffffb0000000800540069006d0065010000000000000450000000000000000000000367000002dc00000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  Image:
+    collapsed: false
+  QMainWindow State: 000000ff00000000fd000000040000000000000454000007b0fc020000000efb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006100fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc00000028000007b0000000d700fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000005c00fffffffb0000000c00430061006d0065007200610000000000ffffffff0000006700fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb0000000000000000fb0000000a0049006d006100670065010000056c0000026c00000000000000000000000100000163000007b0fc0200000003fb0000000a005600690065007700730100000028000007b0000000ad00fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e1000001970000000300000ebf0000005cfc0100000002fb0000000800540069006d0065010000000000000ebf0000030000fffffffb0000000800540069006d00650100000000000004500000000000000000000008fc000007b000000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
@@ -555,6 +630,6 @@ Window Geometry:
     collapsed: false
   Views:
     collapsed: false
-  Width: 1600
-  X: 43
-  Y: 174
+  Width: 3775
+  X: 65
+  Y: 24
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -115,6 +115,7 @@ void VelocitySetInfo::controlPoseCallback(const geometry_msgs::PoseStampedConstP
 
 void VelocitySetInfo::localizerPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 {
+  node_status_publisher_ptr_-&gt;NODE_ACTIVATE();
   node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/current_pose/slow",8,5,1,"topic current_pose subscribe rate low.");
   localizer_pose_ = *msg;
 }
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\constants.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\constants.h" added_lines="35" deleted_lines="13">
				<diff>@@ -1,22 +1,44 @@
 #ifndef CONSTANTS_H_INCLUDED
 #define CONSTANTS_H_INCLUDED
 
+/*
+ * Copyright 2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * v1.0 Masaya Kataoka
+ */
+
 #include &lt;autoware_system_msgs/DiagnosticStatus.h&gt;
 
-namespace autoware_health_checker
-{
-    constexpr uint8_t LEVEL_UNDEFINED = autoware_system_msgs::DiagnosticStatus::UNDEFINED;
-    constexpr uint8_t LEVEL_OK = autoware_system_msgs::DiagnosticStatus::OK;
-    constexpr uint8_t LEVEL_WARN = autoware_system_msgs::DiagnosticStatus::WARN;
-    constexpr uint8_t LEVEL_ERROR = autoware_system_msgs::DiagnosticStatus::ERROR;
-    constexpr uint8_t LEVEL_FATAL = autoware_system_msgs::DiagnosticStatus::FATAL;
+namespace autoware_health_checker {
+constexpr uint8_t LEVEL_UNDEFINED =
+    autoware_system_msgs::DiagnosticStatus::UNDEFINED;
+constexpr uint8_t LEVEL_OK = autoware_system_msgs::DiagnosticStatus::OK;
+constexpr uint8_t LEVEL_WARN = autoware_system_msgs::DiagnosticStatus::WARN;
+constexpr uint8_t LEVEL_ERROR = autoware_system_msgs::DiagnosticStatus::ERROR;
+constexpr uint8_t LEVEL_FATAL = autoware_system_msgs::DiagnosticStatus::FATAL;
 
-    constexpr uint8_t TYPE_UNDEFINED = autoware_system_msgs::DiagnosticStatus::UNDEFINED;
-    constexpr uint8_t TYPE_OUT_OF_RANGE = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
-    constexpr uint8_t TYPE_RATE_IS_SLOW = autoware_system_msgs::DiagnosticStatus::RATE_IS_SLOW;
+constexpr uint8_t TYPE_UNDEFINED =
+    autoware_system_msgs::DiagnosticStatus::UNDEFINED;
+constexpr uint8_t TYPE_OUT_OF_RANGE =
+    autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
+constexpr uint8_t TYPE_RATE_IS_SLOW =
+    autoware_system_msgs::DiagnosticStatus::RATE_IS_SLOW;
 
-    constexpr double BUFFER_LENGTH = 5.0;
-    constexpr double UPDATE_RATE = 10.0;
+constexpr double BUFFER_LENGTH = 5.0;
+constexpr double UPDATE_RATE = 10.0;
 }
 
-#endif //CONSTANTS_H_INCLUDED
\ No newline at end of file
+#endif // CONSTANTS_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\diag_buffer.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\diag_buffer.h" added_lines="49" deleted_lines="28">
				<diff>@@ -1,41 +1,62 @@
 #ifndef DIAG_BUFFER_H_INCLUDED
 #define DIAG_BUFFER_H_INCLUDED
 
-//headers in Autoare
+/*
+ * Copyright 2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * v1.0 Masaya Kataoka
+ */
+
+// headers in Autoare
 #include &lt;autoware_health_checker/constants.h&gt;
 #include &lt;autoware_system_msgs/DiagnosticStatusArray.h&gt;
 
-//headers in STL
-#include &lt;vector&gt;
-#include &lt;string&gt;
+// headers in STL
 #include &lt;map&gt;
 #include &lt;mutex&gt;
+#include &lt;string&gt;
+#include &lt;vector&gt;
 
-//headers in ROS
+// headers in ROS
 #include &lt;ros/ros.h&gt;
 
-namespace autoware_health_checker
-{
-    class DiagBuffer
-    {
-    public:
-        DiagBuffer(std::string key,uint8_t type,std::string description,double buffer_length);
-        ~DiagBuffer();
-        void addDiag(autoware_system_msgs::DiagnosticStatus status);
-        autoware_system_msgs::DiagnosticStatusArray getAndClearData();
-        const uint8_t type;
-        const std::string description;
-    private:
-        std::mutex mtx_;
-        uint8_t getErrorLevel();
-        void updateBuffer();
-        std::string key_;
-        ros::Duration buffer_length_;
-        std::map&lt;uint8_t,autoware_system_msgs::DiagnosticStatusArray &gt; buffer_;
-        autoware_system_msgs::DiagnosticStatusArray filterBuffer(ros::Time now, uint8_t level);
-        ros::Publisher status_pub_;
-        bool isOlderTimestamp(const autoware_system_msgs::DiagnosticStatus &amp;a, const autoware_system_msgs::DiagnosticStatus &amp;b);
-    };
+namespace autoware_health_checker {
+class DiagBuffer {
+public:
+  DiagBuffer(std::string key, uint8_t type, std::string description,
+             double buffer_length);
+  ~DiagBuffer();
+  void addDiag(autoware_system_msgs::DiagnosticStatus status);
+  autoware_system_msgs::DiagnosticStatusArray getAndClearData();
+  const uint8_t type;
+  const std::string description;
+
+private:
+  std::mutex mtx_;
+  uint8_t getErrorLevel();
+  void updateBuffer();
+  std::string key_;
+  ros::Duration buffer_length_;
+  std::map&lt;uint8_t, autoware_system_msgs::DiagnosticStatusArray&gt; buffer_;
+  autoware_system_msgs::DiagnosticStatusArray filterBuffer(ros::Time now,
+                                                           uint8_t level);
+  ros::Publisher status_pub_;
+  bool isOlderTimestamp(const autoware_system_msgs::DiagnosticStatus &amp;a,
+                        const autoware_system_msgs::DiagnosticStatus &amp;b);
+};
 }
 
-#endif  //DIAG_BUFFER_H_INCLUDED
\ No newline at end of file
+#endif // DIAG_BUFFER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_aggregator.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_aggregator.h" added_lines="55" deleted_lines="26">
				<diff>@@ -1,44 +1,73 @@
 #ifndef HEALTH_AGGREGATOR_H_INCLUDED
 #define HEALTH_AGGREGATOR_H_INCLUDED
 
-//headers in ROS
-#include &lt;ros/ros.h&gt;
+/*
+ * Copyright 2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * v1.0 Masaya Kataoka
+ */
+
+// headers in ROS
 #include &lt;diagnostic_msgs/DiagnosticArray.h&gt;
+#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
+#include &lt;ros/ros.h&gt;
 
-//headers in Autoware
+// headers in Autoware
 #include &lt;autoware_health_checker/constants.h&gt;
 #include &lt;autoware_system_msgs/NodeStatus.h&gt;
 #include &lt;autoware_system_msgs/SystemStatus.h&gt;
 
-//headers in boost
+// headers in boost
+#include &lt;boost/foreach.hpp&gt;
 #include &lt;boost/optional.hpp&gt;
-#include &lt;boost/property_tree/ptree.hpp&gt;
 #include &lt;boost/property_tree/json_parser.hpp&gt;
-#include &lt;boost/foreach.hpp&gt;
+#include &lt;boost/property_tree/ptree.hpp&gt;
 #include &lt;boost/thread.hpp&gt;
 
-//headers in STL
-#include &lt;mutex&gt;
+// headers in STL
 #include &lt;map&gt;
+#include &lt;mutex&gt;
 
-class HealthAggregator
-{
+class HealthAggregator {
 public:
-    HealthAggregator(ros::NodeHandle nh,ros::NodeHandle pnh);
-    ~HealthAggregator();
-    void run();
+  HealthAggregator(ros::NodeHandle nh, ros::NodeHandle pnh);
+  ~HealthAggregator();
+  void run();
+
 private:
-    ros::NodeHandle nh_;
-    ros::NodeHandle pnh_;
-    ros::Publisher system_status_pub_;
-    ros::Subscriber node_status_sub_;
-    ros::Subscriber diagnostic_array_sub_;
-    void publishSystemStatus();
-    void nodeStatusCallback(const autoware_system_msgs::NodeStatus::ConstPtr msg);
-    void diagnosticArrayCallback(const diagnostic_msgs::DiagnosticArray::ConstPtr msg);
-    boost::optional&lt;autoware_system_msgs::HardwareStatus&gt; convert(const diagnostic_msgs::DiagnosticArray::ConstPtr msg);
-    autoware_system_msgs::SystemStatus system_status_;
-    std::mutex mtx_;
-    void updateConnectionStatus();
+  ros::NodeHandle nh_;
+  ros::NodeHandle pnh_;
+  ros::Publisher system_status_pub_;
+  std::map&lt;uint8_t, ros::Publisher&gt; text_pub_;
+  ros::Subscriber node_status_sub_;
+  ros::Subscriber diagnostic_array_sub_;
+  void publishSystemStatus();
+  void nodeStatusCallback(const autoware_system_msgs::NodeStatus::ConstPtr msg);
+  void
+  diagnosticArrayCallback(const diagnostic_msgs::DiagnosticArray::ConstPtr msg);
+  std::string
+  generateText(std::vector&lt;autoware_system_msgs::DiagnosticStatus&gt; status);
+  jsk_rviz_plugins::OverlayText
+  generateOverlayText(autoware_system_msgs::SystemStatus status, uint8_t level);
+  std::vector&lt;autoware_system_msgs::DiagnosticStatus&gt;
+  filterNodeStatus(autoware_system_msgs::SystemStatus status, uint8_t level);
+  boost::optional&lt;autoware_system_msgs::HardwareStatus&gt;
+  convert(const diagnostic_msgs::DiagnosticArray::ConstPtr msg);
+  autoware_system_msgs::SystemStatus system_status_;
+  std::mutex mtx_;
+  void updateConnectionStatus();
 };
-#endif  //HEALTH_AGGREGATOR_H_INCLUDED
\ No newline at end of file
+#endif // HEALTH_AGGREGATOR_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\node_status_publisher.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\node_status_publisher.h" added_lines="94" deleted_lines="68">
				<diff>@@ -1,87 +1,113 @@
 #ifndef NODE_STATUS_PUBLISHER_H_INCLUDED
 #define NODE_STATUS_PUBLISHER_H_INCLUDED
 
-//headers in ROS
+/*
+ * Copyright 2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * v1.0 Masaya Kataoka
+ */
+
+// headers in ROS
 #include &lt;ros/ros.h&gt;
 
-//headers in Autoware
+// headers in Autoware
 #include &lt;autoware_health_checker/constants.h&gt;
 #include &lt;autoware_health_checker/diag_buffer.h&gt;
 #include &lt;autoware_health_checker/rate_checker.h&gt;
 #include &lt;autoware_system_msgs/NodeStatus.h&gt;
 
-//headers in STL
+// headers in STL
+#include &lt;functional&gt;
 #include &lt;map&gt;
 #include &lt;memory&gt;
-#include &lt;functional&gt;
 #include &lt;sstream&gt;
 
-//headers in boost
-#include &lt;boost/property_tree/ptree.hpp&gt;
-#include &lt;boost/property_tree/json_parser.hpp&gt;
+// headers in boost
+#include &lt;boost/bind.hpp&gt;
 #include &lt;boost/foreach.hpp&gt;
 #include &lt;boost/optional.hpp&gt;
+#include &lt;boost/property_tree/json_parser.hpp&gt;
+#include &lt;boost/property_tree/ptree.hpp&gt;
 #include &lt;boost/thread.hpp&gt;
-#include &lt;boost/bind.hpp&gt;
 
-namespace autoware_health_checker
-{
-    class NodeStatusPublisher
-    {
-    public:
-        NodeStatusPublisher(ros::NodeHandle nh,ros::NodeHandle pnh);
-        ~NodeStatusPublisher();
-        void ENABLE();
-        uint8_t CHECK_MIN_VALUE(std::string key,double value,double warn_value,double error_value,double fatal_value, std::string description);
-        uint8_t CHECK_MAX_VALUE(std::string key,double value,double warn_value,double error_value,double fatal_value, std::string description);
-        // std::pair&lt;double,double&gt; first value is min value and second value is max value
-        uint8_t CHECK_RANGE(std::string key,double value,std::pair&lt;double,double&gt; warn_value,std::pair&lt;double,double&gt; error_value,std::pair&lt;double,double&gt; fatal_value,std::string description);
-        template&lt;class T&gt;
-        uint8_t CHECK_VALUE(std::string key,T value,std::function&lt;uint8_t(T value)&gt; check_func,std::function&lt;boost::property_tree::ptree(T value)&gt; value_json_func,std::string description)
-        {
-            addNewBuffer(key,autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,description);
-            uint8_t check_result = check_func(value);
-            boost::property_tree::ptree pt = value_json_func(value);
-            std::stringstream ss;
-            write_json(ss, pt);
-            autoware_system_msgs::DiagnosticStatus new_status;
-            new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
-            new_status.level = check_result;
-            new_status.description = description;
-            new_status.description = ss.str();
-            new_status.header.stamp = ros::Time::now();
-            diag_buffers_[key]-&gt;addDiag(new_status);
-            return new_status.level;
-        }
-        void CHECK_RATE(std::string key,double warn_rate,double error_rate,double fatal_rate,std::string description);
-        void NODE_ACTIVATE()
-        {
-            std::lock_guard&lt;std::mutex&gt; lock(mtx_);
-            node_activated_ = true;
-        };
-        void NODE_DEACTIVATE()
-        {
-            std::lock_guard&lt;std::mutex&gt; lock(mtx_);
-            node_activated_ = false;
-        };
-        bool getNodeStatus()
-        {
-            return node_activated_;
-        };
-    private:
-        std::vector&lt;std::string&gt; getKeys();
-        std::vector&lt;std::string&gt; getRateCheckerKeys();
-        ros::NodeHandle nh_;
-        ros::NodeHandle pnh_;
-        std::map&lt;std::string,std::shared_ptr&lt;DiagBuffer&gt; &gt; diag_buffers_;
-        std::map&lt;std::string,std::shared_ptr&lt;RateChecker&gt; &gt; rate_checkers_;
-        ros::Publisher status_pub_;
-        bool keyExist(std::string key);
-        void addNewBuffer(std::string key, uint8_t type, std::string description);
-        std::string doubeToJson(double value);
-        void publishStatus();
-        bool node_activated_;
-        std::mutex mtx_;
-    };
+namespace autoware_health_checker {
+class NodeStatusPublisher {
+public:
+  NodeStatusPublisher(ros::NodeHandle nh, ros::NodeHandle pnh);
+  ~NodeStatusPublisher();
+  void ENABLE();
+  uint8_t CHECK_MIN_VALUE(std::string key, double value, double warn_value,
+                          double error_value, double fatal_value,
+                          std::string description);
+  uint8_t CHECK_MAX_VALUE(std::string key, double value, double warn_value,
+                          double error_value, double fatal_value,
+                          std::string description);
+  // std::pair&lt;double,double&gt; first value is min value and second value is max
+  // value
+  uint8_t CHECK_RANGE(std::string key, double value,
+                      std::pair&lt;double, double&gt; warn_value,
+                      std::pair&lt;double, double&gt; error_value,
+                      std::pair&lt;double, double&gt; fatal_value,
+                      std::string description);
+  template &lt;class T&gt;
+  uint8_t CHECK_VALUE(
+      std::string key, T value, std::function&lt;uint8_t(T value)&gt; check_func,
+      std::function&lt;boost::property_tree::ptree(T value)&gt; value_json_func,
+      std::string description) {
+    addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,
+                 description);
+    uint8_t check_result = check_func(value);
+    boost::property_tree::ptree pt = value_json_func(value);
+    std::stringstream ss;
+    write_json(ss, pt);
+    autoware_system_msgs::DiagnosticStatus new_status;
+    new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
+    new_status.level = check_result;
+    new_status.description = description;
+    new_status.description = ss.str();
+    new_status.header.stamp = ros::Time::now();
+    diag_buffers_[key]-&gt;addDiag(new_status);
+    return new_status.level;
+  }
+  void CHECK_RATE(std::string key, double warn_rate, double error_rate,
+                  double fatal_rate, std::string description);
+  void NODE_ACTIVATE() {
+    std::lock_guard&lt;std::mutex&gt; lock(mtx_);
+    node_activated_ = true;
+  };
+  void NODE_DEACTIVATE() {
+    std::lock_guard&lt;std::mutex&gt; lock(mtx_);
+    node_activated_ = false;
+  };
+  bool getNodeStatus() { return node_activated_; };
+
+private:
+  std::vector&lt;std::string&gt; getKeys();
+  std::vector&lt;std::string&gt; getRateCheckerKeys();
+  ros::NodeHandle nh_;
+  ros::NodeHandle pnh_;
+  std::map&lt;std::string, std::shared_ptr&lt;DiagBuffer&gt;&gt; diag_buffers_;
+  std::map&lt;std::string, std::shared_ptr&lt;RateChecker&gt;&gt; rate_checkers_;
+  ros::Publisher status_pub_;
+  bool keyExist(std::string key);
+  void addNewBuffer(std::string key, uint8_t type, std::string description);
+  std::string doubeToJson(double value);
+  void publishStatus();
+  bool node_activated_;
+  std::mutex mtx_;
+};
 }
-#endif  //NODE_STATUS_PUBLISHER_H_INCLUDED
\ No newline at end of file
+#endif // NODE_STATUS_PUBLISHER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\rate_checker.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\rate_checker.h" added_lines="47" deleted_lines="28">
				<diff>@@ -1,40 +1,59 @@
 #ifndef RATE_CHECKER_H_INCLUDED
 #define RATE_CHECKER_H_INCLUDED
 
-//headers in ROS
+/*
+ * Copyright 2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * v1.0 Masaya Kataoka
+ */
+
+// headers in ROS
 #include &lt;ros/ros.h&gt;
 
-//headers in STL
-#include &lt;vector&gt;
+// headers in STL
 #include &lt;mutex&gt;
+#include &lt;vector&gt;
 
-//headers in Boost
+// headers in Boost
 #include &lt;boost/optional.hpp&gt;
 
-//headers in Autoware
+// headers in Autoware
 #include &lt;autoware_health_checker/constants.h&gt;
 
-namespace autoware_health_checker
-{
-    class RateChecker
-    {
-        public:
-            RateChecker(double buffer_length,double warn_rate,double error_rate,double fatal_rate,std::string description);
-            ~RateChecker();
-            void check();
-            std::pair&lt;uint8_t,double&gt; getErrorLevelAndRate();
-            uint8_t getErrorLevel();
-            boost::optional&lt;double&gt; getRate();
-            const std::string description;
-        private:
-            ros::Time start_time_;
-            void update();
-            std::vector&lt;ros::Time&gt; data_;
-            const double buffer_length_;
-            const double warn_rate_;
-            const double error_rate_;
-            const double fatal_rate_;
-            std::mutex mtx_;
-    };
+namespace autoware_health_checker {
+class RateChecker {
+public:
+  RateChecker(double buffer_length, double warn_rate, double error_rate,
+              double fatal_rate, std::string description);
+  ~RateChecker();
+  void check();
+  std::pair&lt;uint8_t, double&gt; getErrorLevelAndRate();
+  uint8_t getErrorLevel();
+  boost::optional&lt;double&gt; getRate();
+  const std::string description;
+
+private:
+  ros::Time start_time_;
+  void update();
+  std::vector&lt;ros::Time&gt; data_;
+  const double buffer_length_;
+  const double warn_rate_;
+  const double error_rate_;
+  const double fatal_rate_;
+  std::mutex mtx_;
+};
 }
-#endif //RATE_CHECKER_H_INCLUDED
\ No newline at end of file
+#endif // RATE_CHECKER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\system_status_subscriber.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\system_status_subscriber.h" added_lines="43" deleted_lines="22">
				<diff>@@ -1,34 +1,55 @@
 #ifndef SYSTEM_STATUS_SUBSCRIBER_H_INCLUDED
 #define SYSTEM_STATUS_SUBSCRIBER_H_INCLUDED
 
-//headers in Autoware
+/*
+ * Copyright 2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * v1.0 Masaya Kataoka
+ */
+
+// headers in Autoware
 #include &lt;autoware_health_checker/constants.h&gt;
 #include &lt;autoware_system_msgs/SystemStatus.h&gt;
 
-//headers in ROS
+// headers in ROS
 #include &lt;ros/ros.h&gt;
 
-//headers in STL
-#include &lt;mutex&gt;
+// headers in STL
 #include &lt;functional&gt;
+#include &lt;mutex&gt;
+
+namespace autoware_health_checker {
+class SystemStatusSubscriber {
+public:
+  SystemStatusSubscriber(ros::NodeHandle nh, ros::NodeHandle pnh);
+  ~SystemStatusSubscriber();
+  void enable();
+  void
+  addCallback(std::function&lt;void(autoware_system_msgs::SystemStatus)&gt; func);
 
-namespace autoware_health_checker
-{
-    class SystemStatusSubscriber
-    {
-    public:
-        SystemStatusSubscriber(ros::NodeHandle nh,ros::NodeHandle pnh);
-        ~SystemStatusSubscriber();
-        void enable();
-        void addCallback(std::function&lt;void(autoware_system_msgs::SystemStatus)&gt; func);
-    private:
-        void systemStatusCallback(const autoware_system_msgs::SystemStatus::ConstPtr msg);
-        std::mutex mtx_;
-        ros::Subscriber status_sub_;
-        ros::NodeHandle nh_;
-        ros::NodeHandle pnh_;
-        std::vector&lt;std::function&lt;void(autoware_system_msgs::SystemStatus)&gt; &gt; functions_;
-    };
+private:
+  void
+  systemStatusCallback(const autoware_system_msgs::SystemStatus::ConstPtr msg);
+  std::mutex mtx_;
+  ros::Subscriber status_sub_;
+  ros::NodeHandle nh_;
+  ros::NodeHandle pnh_;
+  std::vector&lt;std::function&lt;void(autoware_system_msgs::SystemStatus)&gt;&gt;
+      functions_;
+};
 }
 
-#endif  //SYSTEM_STATUS_SUBSCRIBER_H_INCLUDED
\ No newline at end of file
+#endif // SYSTEM_STATUS_SUBSCRIBER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\diag_buffer.cpp" new_path="ros\src\system\autoware_health_checker\src\diag_buffer.cpp" added_lines="105" deleted_lines="83">
				<diff>@@ -1,94 +1,116 @@
+/*
+ * Copyright 2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * v1.0 Masaya Kataoka
+ */
+ 
 #include &lt;autoware_health_checker/diag_buffer.h&gt;
 
-namespace autoware_health_checker
-{
-    DiagBuffer::DiagBuffer(std::string key, uint8_t type, std::string description, double buffer_length) : type(type), description(description)
-    {
-        key_ = key;
-        buffer_length_ = ros::Duration(buffer_length);
-    }
+namespace autoware_health_checker {
+DiagBuffer::DiagBuffer(std::string key, uint8_t type, std::string description,
+                       double buffer_length)
+    : type(type), description(description) {
+  key_ = key;
+  buffer_length_ = ros::Duration(buffer_length);
+}
 
-    DiagBuffer::~DiagBuffer()
-    {
-        
-    }
+DiagBuffer::~DiagBuffer() {}
 
-    void DiagBuffer::addDiag(autoware_system_msgs::DiagnosticStatus status)
-    {
-        std::lock_guard&lt;std::mutex&gt; lock(mtx_);
-        buffer_[status.level].status.emplace_back(status);
-        updateBuffer();
-        return;
-    }
+void DiagBuffer::addDiag(autoware_system_msgs::DiagnosticStatus status) {
+  std::lock_guard&lt;std::mutex&gt; lock(mtx_);
+  buffer_[status.level].status.emplace_back(status);
+  updateBuffer();
+  return;
+}
 
-    autoware_system_msgs::DiagnosticStatusArray DiagBuffer::getAndClearData()
-    {
-        std::lock_guard&lt;std::mutex&gt; lock(mtx_);
-        autoware_system_msgs::DiagnosticStatusArray data;
-        data = buffer_[autoware_health_checker::LEVEL_FATAL];
-        data.status.insert(data.status.end(),buffer_[autoware_health_checker::LEVEL_ERROR].status.begin(),buffer_[autoware_health_checker::LEVEL_ERROR].status.end());
-        data.status.insert(data.status.end(),buffer_[autoware_health_checker::LEVEL_WARN].status.begin(),buffer_[autoware_health_checker::LEVEL_WARN].status.end());
-        data.status.insert(data.status.end(),buffer_[autoware_health_checker::LEVEL_OK].status.begin(),buffer_[autoware_health_checker::LEVEL_OK].status.end());
-        data.status.insert(data.status.end(),buffer_[autoware_health_checker::LEVEL_UNDEFINED].status.begin(),buffer_[autoware_health_checker::LEVEL_UNDEFINED].status.end());
-        std::sort(data.status.begin(), data.status.end(), std::bind(&amp;DiagBuffer::isOlderTimestamp, this, std::placeholders::_1, std::placeholders::_2));
-        buffer_.clear();
-        return data;
-    }
+autoware_system_msgs::DiagnosticStatusArray DiagBuffer::getAndClearData() {
+  std::lock_guard&lt;std::mutex&gt; lock(mtx_);
+  autoware_system_msgs::DiagnosticStatusArray data;
+  data = buffer_[autoware_health_checker::LEVEL_FATAL];
+  data.status.insert(
+      data.status.end(),
+      buffer_[autoware_health_checker::LEVEL_ERROR].status.begin(),
+      buffer_[autoware_health_checker::LEVEL_ERROR].status.end());
+  data.status.insert(
+      data.status.end(),
+      buffer_[autoware_health_checker::LEVEL_WARN].status.begin(),
+      buffer_[autoware_health_checker::LEVEL_WARN].status.end());
+  data.status.insert(data.status.end(),
+                     buffer_[autoware_health_checker::LEVEL_OK].status.begin(),
+                     buffer_[autoware_health_checker::LEVEL_OK].status.end());
+  data.status.insert(
+      data.status.end(),
+      buffer_[autoware_health_checker::LEVEL_UNDEFINED].status.begin(),
+      buffer_[autoware_health_checker::LEVEL_UNDEFINED].status.end());
+  std::sort(data.status.begin(), data.status.end(),
+            std::bind(&amp;DiagBuffer::isOlderTimestamp, this,
+                      std::placeholders::_1, std::placeholders::_2));
+  buffer_.clear();
+  return data;
+}
 
-    uint8_t DiagBuffer::getErrorLevel()
-    {
-        std::lock_guard&lt;std::mutex&gt; lock(mtx_);
-        updateBuffer();
-        if(buffer_[autoware_health_checker::LEVEL_FATAL].status.size() != 0)
-        {
-            return autoware_health_checker::LEVEL_FATAL;
-        }
-        else if(buffer_[autoware_health_checker::LEVEL_ERROR].status.size() != 0)
-        {
-            return autoware_health_checker::LEVEL_ERROR;
-        }
-        else if(buffer_[autoware_health_checker::LEVEL_WARN].status.size() != 0)
-        {
-            return autoware_health_checker::LEVEL_WARN;
-        }
-        else
-        {
-            return autoware_health_checker::LEVEL_OK;
-        }
-    }
+uint8_t DiagBuffer::getErrorLevel() {
+  std::lock_guard&lt;std::mutex&gt; lock(mtx_);
+  updateBuffer();
+  if (buffer_[autoware_health_checker::LEVEL_FATAL].status.size() != 0) {
+    return autoware_health_checker::LEVEL_FATAL;
+  } else if (buffer_[autoware_health_checker::LEVEL_ERROR].status.size() != 0) {
+    return autoware_health_checker::LEVEL_ERROR;
+  } else if (buffer_[autoware_health_checker::LEVEL_WARN].status.size() != 0) {
+    return autoware_health_checker::LEVEL_WARN;
+  } else {
+    return autoware_health_checker::LEVEL_OK;
+  }
+}
 
-    // filter data from timestamp and level
-    autoware_system_msgs::DiagnosticStatusArray DiagBuffer::filterBuffer(ros::Time now, uint8_t level)
-    {
-        autoware_system_msgs::DiagnosticStatusArray filterd_data;
-        autoware_system_msgs::DiagnosticStatusArray ret;
-        if(buffer_.count(level) != 0)
-        {
-            filterd_data = buffer_[level];
-        }
-        for(auto data_itr = filterd_data.status.begin(); data_itr != filterd_data.status.end(); data_itr++)
-        {
-            if(data_itr-&gt;header.stamp&gt; (now - buffer_length_))
-            {
-                ret.status.push_back(*data_itr);
-            }
-        }
-        return ret;
+// filter data from timestamp and level
+autoware_system_msgs::DiagnosticStatusArray
+DiagBuffer::filterBuffer(ros::Time now, uint8_t level) {
+  autoware_system_msgs::DiagnosticStatusArray filterd_data;
+  autoware_system_msgs::DiagnosticStatusArray ret;
+  if (buffer_.count(level) != 0) {
+    filterd_data = buffer_[level];
+  }
+  for (auto data_itr = filterd_data.status.begin();
+       data_itr != filterd_data.status.end(); data_itr++) {
+    if (data_itr-&gt;header.stamp &gt; (now - buffer_length_)) {
+      ret.status.push_back(*data_itr);
     }
+  }
+  return ret;
+}
 
-    void DiagBuffer::updateBuffer()
-    {
-        ros::Time now = ros::Time::now();
-        buffer_[autoware_health_checker::LEVEL_FATAL] = filterBuffer(now, autoware_health_checker::LEVEL_FATAL);
-        buffer_[autoware_health_checker::LEVEL_ERROR] = filterBuffer(now, autoware_health_checker::LEVEL_ERROR);
-        buffer_[autoware_health_checker::LEVEL_WARN] = filterBuffer(now, autoware_health_checker::LEVEL_WARN);
-        buffer_[autoware_health_checker::LEVEL_OK] = filterBuffer(now, autoware_health_checker::LEVEL_OK);
-        buffer_[autoware_health_checker::LEVEL_UNDEFINED] = filterBuffer(now, autoware_health_checker::LEVEL_UNDEFINED);
-        return;
-    }
+void DiagBuffer::updateBuffer() {
+  ros::Time now = ros::Time::now();
+  buffer_[autoware_health_checker::LEVEL_FATAL] =
+      filterBuffer(now, autoware_health_checker::LEVEL_FATAL);
+  buffer_[autoware_health_checker::LEVEL_ERROR] =
+      filterBuffer(now, autoware_health_checker::LEVEL_ERROR);
+  buffer_[autoware_health_checker::LEVEL_WARN] =
+      filterBuffer(now, autoware_health_checker::LEVEL_WARN);
+  buffer_[autoware_health_checker::LEVEL_OK] =
+      filterBuffer(now, autoware_health_checker::LEVEL_OK);
+  buffer_[autoware_health_checker::LEVEL_UNDEFINED] =
+      filterBuffer(now, autoware_health_checker::LEVEL_UNDEFINED);
+  return;
+}
 
-    bool DiagBuffer::isOlderTimestamp(const autoware_system_msgs::DiagnosticStatus &amp;a, const autoware_system_msgs::DiagnosticStatus &amp;b)
-    {
-        return a.header.stamp &lt; b.header.stamp;
-    }
+bool DiagBuffer::isOlderTimestamp(
+    const autoware_system_msgs::DiagnosticStatus &amp;a,
+    const autoware_system_msgs::DiagnosticStatus &amp;b) {
+  return a.header.stamp &lt; b.header.stamp;
+}
 }
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_aggregator.cpp" new_path="ros\src\system\autoware_health_checker\src\health_aggregator.cpp" added_lines="191" deleted_lines="93">
				<diff>@@ -1,114 +1,212 @@
+/*
+ * Copyright 2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * v1.0 Masaya Kataoka
+ */
+ 
 #include &lt;autoware_health_checker/health_aggregator.h&gt;
 
-HealthAggregator::HealthAggregator(ros::NodeHandle nh,ros::NodeHandle pnh)
-{
-    nh_ = nh;
-    pnh_ = pnh;
+HealthAggregator::HealthAggregator(ros::NodeHandle nh, ros::NodeHandle pnh) {
+  nh_ = nh;
+  pnh_ = pnh;
 }
 
-HealthAggregator::~HealthAggregator()
-{
+HealthAggregator::~HealthAggregator() {}
 
+void HealthAggregator::run() {
+  system_status_pub_ =
+      nh_.advertise&lt;autoware_system_msgs::SystemStatus&gt;("/system_status", 10);
+  text_pub_[autoware_health_checker::LEVEL_OK] =
+      pnh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("ok_text", 1);
+  text_pub_[autoware_health_checker::LEVEL_WARN] =
+      pnh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("warn_text", 1);
+  text_pub_[autoware_health_checker::LEVEL_ERROR] =
+      pnh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("error_text", 1);
+  text_pub_[autoware_health_checker::LEVEL_FATAL] =
+      pnh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("fatal_text", 1);
+  node_status_sub_ = nh_.subscribe("/node_status", 10,
+                                   &amp;HealthAggregator::nodeStatusCallback, this);
+  diagnostic_array_sub_ = nh_.subscribe(
+      "/diagnostic_agg", 10, &amp;HealthAggregator::diagnosticArrayCallback, this);
+  boost::thread publish_thread(
+      boost::bind(&amp;HealthAggregator::publishSystemStatus, this));
+  return;
 }
 
-void HealthAggregator::run()
-{
-    system_status_pub_ = nh_.advertise&lt;autoware_system_msgs::SystemStatus&gt;("/system_status",10);
-    node_status_sub_ = nh_.subscribe("/node_status",10,&amp;HealthAggregator::nodeStatusCallback,this);
-    diagnostic_array_sub_ = nh_.subscribe("/diagnostic_agg",10,&amp;HealthAggregator::diagnosticArrayCallback,this);
-    boost::thread publish_thread(boost::bind(&amp;HealthAggregator::publishSystemStatus, this));
-    return;
+void HealthAggregator::publishSystemStatus() {
+  ros::Rate rate = ros::Rate(autoware_health_checker::UPDATE_RATE);
+  while (ros::ok()) {
+    mtx_.lock();
+    system_status_.header.stamp = ros::Time::now();
+    updateConnectionStatus();
+    system_status_pub_.publish(system_status_);
+    text_pub_[autoware_health_checker::LEVEL_OK].publish(
+        generateOverlayText(system_status_, autoware_health_checker::LEVEL_OK));
+    text_pub_[autoware_health_checker::LEVEL_WARN].publish(generateOverlayText(
+        system_status_, autoware_health_checker::LEVEL_WARN));
+    text_pub_[autoware_health_checker::LEVEL_ERROR].publish(generateOverlayText(
+        system_status_, autoware_health_checker::LEVEL_ERROR));
+    text_pub_[autoware_health_checker::LEVEL_FATAL].publish(generateOverlayText(
+        system_status_, autoware_health_checker::LEVEL_FATAL));
+    system_status_.node_status.clear();
+    system_status_.hardware_status.clear();
+    mtx_.unlock();
+    rate.sleep();
+  }
+  return;
 }
 
-void HealthAggregator::publishSystemStatus()
-{
-    ros::Rate rate = ros::Rate(autoware_health_checker::UPDATE_RATE);
-    while(ros::ok())
-    {
-        mtx_.lock();
-        system_status_.header.stamp = ros::Time::now();
-        updateConnectionStatus();
-        system_status_pub_.publish(system_status_);
-        system_status_.node_status.clear();
-        system_status_.hardware_status.clear();
-        mtx_.unlock();
-        rate.sleep();
-    }
-    return;
+void HealthAggregator::updateConnectionStatus() {
+  std::vector&lt;std::string&gt; detected_nodes;
+  ros::master::getNodes(detected_nodes);
+  system_status_.available_nodes = detected_nodes;
+  return;
 }
 
-void HealthAggregator::updateConnectionStatus()
-{
-    std::vector&lt;std::string&gt; detected_nodes;
-    ros::master::getNodes(detected_nodes);
-    system_status_.available_nodes = detected_nodes;
-    return;
+void HealthAggregator::nodeStatusCallback(
+    const autoware_system_msgs::NodeStatus::ConstPtr msg) {
+  mtx_.lock();
+  system_status_.node_status.push_back(*msg);
+  mtx_.unlock();
+  return;
 }
 
-void HealthAggregator::nodeStatusCallback(const autoware_system_msgs::NodeStatus::ConstPtr msg)
-{
-    mtx_.lock();
-    system_status_.node_status.push_back(*msg);
-    mtx_.unlock();
-    return;
+void HealthAggregator::diagnosticArrayCallback(
+    const diagnostic_msgs::DiagnosticArray::ConstPtr msg) {
+  mtx_.lock();
+  boost::optional&lt;autoware_system_msgs::HardwareStatus&gt; status = convert(msg);
+  if (status) {
+    system_status_.hardware_status.push_back(*status);
+  }
+  mtx_.unlock();
+  return;
 }
 
-void HealthAggregator::diagnosticArrayCallback(const diagnostic_msgs::DiagnosticArray::ConstPtr msg)
-{
-    mtx_.lock();
-    boost::optional&lt;autoware_system_msgs::HardwareStatus&gt; status = convert(msg);
-    if(status)
-    {
-        system_status_.hardware_status.push_back(*status);
+std::string HealthAggregator::generateText(
+    std::vector&lt;autoware_system_msgs::DiagnosticStatus&gt; status) {
+  std::string text;
+  for (auto itr = status.begin(); itr != status.end(); itr++) {
+    text = text + itr-&gt;description + "\n";
+    // text = itr-&gt;key + " : " + itr-&gt;description + "\n";
+  }
+  return text;
+}
+
+jsk_rviz_plugins::OverlayText
+HealthAggregator::generateOverlayText(autoware_system_msgs::SystemStatus status,
+                                      uint8_t level) {
+  jsk_rviz_plugins::OverlayText text;
+  text.action = text.ADD;
+  text.width = 640;
+  text.height = 640;
+  text.top = 0;
+  text.bg_color.r = 0;
+  text.bg_color.g = 0;
+  text.bg_color.b = 0;
+  text.bg_color.a = 0.7;
+  text.text_size = 20.0;
+  if (level == autoware_health_checker::LEVEL_OK) {
+    text.left = 0;
+    text.fg_color.r = 0.0;
+    text.fg_color.g = 0.0;
+    text.fg_color.b = 1.0;
+    text.fg_color.a = 1.0;
+    text.text = generateText(filterNodeStatus(status, level));
+  } else if (level == autoware_health_checker::LEVEL_WARN) {
+    text.left = 640 * 1;
+    text.fg_color.r = 1.0;
+    text.fg_color.g = 1.0;
+    text.fg_color.b = 0.0;
+    text.fg_color.a = 1.0;
+    text.text = generateText(filterNodeStatus(status, level));
+  } else if (level == autoware_health_checker::LEVEL_ERROR) {
+    text.left = 640 * 2;
+    text.fg_color.r = 1.0;
+    text.fg_color.g = 0.0;
+    text.fg_color.b = 0.0;
+    text.fg_color.a = 1.0;
+    text.text = generateText(filterNodeStatus(status, level));
+  } else if (level == autoware_health_checker::LEVEL_FATAL) {
+    text.left = 640 * 3;
+    text.fg_color.r = 1.0;
+    text.fg_color.g = 1.0;
+    text.fg_color.b = 1.0;
+    text.fg_color.a = 1.0;
+    text.text = generateText(filterNodeStatus(status, level));
+  }
+  return text;
+}
+
+std::vector&lt;autoware_system_msgs::DiagnosticStatus&gt;
+HealthAggregator::filterNodeStatus(autoware_system_msgs::SystemStatus status,
+                                   uint8_t level) {
+  std::vector&lt;autoware_system_msgs::DiagnosticStatus&gt; ret;
+  for (auto node_status_itr = status.node_status.begin();
+       node_status_itr != status.node_status.end(); node_status_itr++) {
+    if (node_status_itr-&gt;node_activated) {
+      for (auto array_itr = node_status_itr-&gt;status.begin();
+           array_itr != node_status_itr-&gt;status.end(); array_itr++) {
+        for (auto itr = array_itr-&gt;status.begin();
+             itr != array_itr-&gt;status.end(); itr++) {
+          if (itr-&gt;level == level) {
+            ret.push_back(*itr);
+          }
+        }
+      }
     }
-    mtx_.unlock();
-    return;
+  }
+  return ret;
 }
 
-boost::optional&lt;autoware_system_msgs::HardwareStatus&gt; HealthAggregator::convert(const diagnostic_msgs::DiagnosticArray::ConstPtr msg)
-{
-    autoware_system_msgs::HardwareStatus status;
-    if(msg-&gt;status.size() == 0)
-    {
-        return boost::none;
+boost::optional&lt;autoware_system_msgs::HardwareStatus&gt; HealthAggregator::convert(
+    const diagnostic_msgs::DiagnosticArray::ConstPtr msg) {
+  autoware_system_msgs::HardwareStatus status;
+  if (msg-&gt;status.size() == 0) {
+    return boost::none;
+  }
+  status.header = msg-&gt;header;
+  for (auto diag_itr = msg-&gt;status.begin(); diag_itr != msg-&gt;status.end();
+       diag_itr++) {
+    status.hardware_name = diag_itr-&gt;hardware_id;
+    autoware_system_msgs::DiagnosticStatus diag;
+    autoware_system_msgs::DiagnosticStatusArray diag_array;
+    diag.header = msg-&gt;header;
+    diag.key = diag_itr-&gt;hardware_id;
+    diag.description = diag_itr-&gt;message;
+    diag.type = autoware_system_msgs::DiagnosticStatus::HARDWARE;
+    if (diag_itr-&gt;level == diagnostic_msgs::DiagnosticStatus::OK) {
+      diag.level = autoware_health_checker::LEVEL_OK;
+    } else if (diag_itr-&gt;level == diagnostic_msgs::DiagnosticStatus::WARN) {
+      diag.level = autoware_health_checker::LEVEL_WARN;
+    } else if (diag_itr-&gt;level == diagnostic_msgs::DiagnosticStatus::ERROR) {
+      diag.level = autoware_health_checker::LEVEL_ERROR;
+    } else if (diag_itr-&gt;level == diagnostic_msgs::DiagnosticStatus::STALE) {
+      diag.level = autoware_health_checker::LEVEL_FATAL;
     }
-    status.header = msg-&gt;header;
-    for(auto diag_itr = msg-&gt;status.begin(); diag_itr != msg-&gt;status.end(); diag_itr++)
-    {
-        status.hardware_name = diag_itr-&gt;hardware_id;
-        autoware_system_msgs::DiagnosticStatus diag;
-        autoware_system_msgs::DiagnosticStatusArray diag_array;
-        diag.header = msg-&gt;header;
-        diag.key = diag_itr-&gt;hardware_id;
-        diag.description = diag_itr-&gt;message;
-        diag.type = autoware_system_msgs::DiagnosticStatus::HARDWARE;
-        if(diag_itr-&gt;level == diagnostic_msgs::DiagnosticStatus::OK)
-        {
-            diag.level = autoware_health_checker::LEVEL_OK;
-        }
-        else if(diag_itr-&gt;level == diagnostic_msgs::DiagnosticStatus::WARN)
-        {
-            diag.level = autoware_health_checker::LEVEL_WARN;
-        }
-        else if(diag_itr-&gt;level == diagnostic_msgs::DiagnosticStatus::ERROR)
-        {
-            diag.level = autoware_health_checker::LEVEL_ERROR;
-        }
-        else if(diag_itr-&gt;level == diagnostic_msgs::DiagnosticStatus::STALE)
-        {
-            diag.level = autoware_health_checker::LEVEL_FATAL;
-        }
-        using namespace boost::property_tree;
-        std::stringstream ss;
-        ptree pt;
-        for(auto value_itr = diag_itr-&gt;values.begin(); value_itr != diag_itr-&gt;values.end(); value_itr++)
-        {
-            pt.put(value_itr-&gt;key+".string", value_itr-&gt;value);
-        }
-        write_json(ss, pt);
-        diag.value = ss.str();
-        diag_array.status.push_back(diag);
-        status.status.push_back(diag_array);
+    using namespace boost::property_tree;
+    std::stringstream ss;
+    ptree pt;
+    for (auto value_itr = diag_itr-&gt;values.begin();
+         value_itr != diag_itr-&gt;values.end(); value_itr++) {
+      pt.put(value_itr-&gt;key + ".string", value_itr-&gt;value);
     }
-    return status;
+    write_json(ss, pt);
+    diag.value = ss.str();
+    diag_array.status.push_back(diag);
+    status.status.push_back(diag_array);
+  }
+  return status;
 }
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_aggregator_node.cpp" new_path="ros\src\system\autoware_health_checker\src\health_aggregator_node.cpp" added_lines="27" deleted_lines="9">
				<diff>@@ -1,14 +1,32 @@
+/*
+ * Copyright 2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * v1.0 Masaya Kataoka
+ */
+
 #include &lt;ros/ros.h&gt;
 
 #include &lt;autoware_health_checker/health_aggregator.h&gt;
 
-int main(int argc, char *argv[])
-{
-    ros::init(argc, argv, "health_aggreator");
-    ros::NodeHandle nh;
-    ros::NodeHandle pnh("~");
-    HealthAggregator agg(nh,pnh);
-    agg.run();
-    ros::spin();
-    return 0;
+int main(int argc, char *argv[]) {
+  ros::init(argc, argv, "health_aggreator");
+  ros::NodeHandle nh;
+  ros::NodeHandle pnh("~");
+  HealthAggregator agg(nh, pnh);
+  agg.run();
+  ros::spin();
+  return 0;
 }
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\node_status_publisher.cpp" new_path="ros\src\system\autoware_health_checker\src\node_status_publisher.cpp" added_lines="204" deleted_lines="205">
				<diff>@@ -1,222 +1,221 @@
+/*
+ * Copyright 2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * v1.0 Masaya Kataoka
+ */
+ 
 #include &lt;autoware_health_checker/node_status_publisher.h&gt;
 
-namespace autoware_health_checker
-{
-    NodeStatusPublisher::NodeStatusPublisher(ros::NodeHandle nh,ros::NodeHandle pnh)
-    {
-        node_activated_ = false;
-        nh_ = nh;
-        pnh_ = pnh;
-        status_pub_ = nh_.advertise&lt;autoware_system_msgs::NodeStatus&gt;("node_status",10);
-    }
+namespace autoware_health_checker {
+NodeStatusPublisher::NodeStatusPublisher(ros::NodeHandle nh,
+                                         ros::NodeHandle pnh) {
+  node_activated_ = false;
+  nh_ = nh;
+  pnh_ = pnh;
+  status_pub_ =
+      nh_.advertise&lt;autoware_system_msgs::NodeStatus&gt;("node_status", 10);
+}
 
-    NodeStatusPublisher::~NodeStatusPublisher()
-    {
-        
-    }
+NodeStatusPublisher::~NodeStatusPublisher() {}
 
-    void NodeStatusPublisher::publishStatus()
-    {
-        ros::Rate rate = ros::Rate(autoware_health_checker::UPDATE_RATE);
-        while(ros::ok())
-        {
-            mtx_.lock();
-            autoware_system_msgs::NodeStatus status;
-            status.node_activated = node_activated_;
-            ros::Time now = ros::Time::now();
-            status.header.stamp = now;
-            status.node_name = ros::this_node::getName();
-            std::vector&lt;std::string&gt; checker_keys = getRateCheckerKeys();
-            // iterate Rate checker and publish rate_check result
-            for(auto key_itr = checker_keys.begin(); key_itr != checker_keys.end(); key_itr++)
-            {
-                autoware_system_msgs::DiagnosticStatusArray diag_array;
-                autoware_system_msgs::DiagnosticStatus diag;
-                diag.type = autoware_system_msgs::DiagnosticStatus::RATE_IS_SLOW;
-                std::pair&lt;uint8_t,double&gt; result = rate_checkers_[*key_itr]-&gt;getErrorLevelAndRate();
-                diag.level = result.first;
-                diag.key = *key_itr;
-                diag.value = doubeToJson(result.second);
-                diag.description = rate_checkers_[*key_itr]-&gt;description;
-                diag.header.stamp = now;
-                diag_array.status.push_back(diag);
-                status.status.push_back(diag_array);
-            }
-            // iterate Diagnostic Buffer and publish all diagnostic data
-            std::vector&lt;std::string&gt; keys = getKeys();
-            for(auto key_itr = keys.begin(); key_itr != keys.end(); key_itr++)
-            {
-                status.status.push_back(diag_buffers_[*key_itr]-&gt;getAndClearData());
-            }
-            status_pub_.publish(status);
-            mtx_.unlock();
-            rate.sleep();
-        }
-        return;
+void NodeStatusPublisher::publishStatus() {
+  ros::Rate rate = ros::Rate(autoware_health_checker::UPDATE_RATE);
+  while (ros::ok()) {
+    mtx_.lock();
+    autoware_system_msgs::NodeStatus status;
+    status.node_activated = node_activated_;
+    ros::Time now = ros::Time::now();
+    status.header.stamp = now;
+    status.node_name = ros::this_node::getName();
+    std::vector&lt;std::string&gt; checker_keys = getRateCheckerKeys();
+    // iterate Rate checker and publish rate_check result
+    for (auto key_itr = checker_keys.begin(); key_itr != checker_keys.end();
+         key_itr++) {
+      autoware_system_msgs::DiagnosticStatusArray diag_array;
+      autoware_system_msgs::DiagnosticStatus diag;
+      diag.type = autoware_system_msgs::DiagnosticStatus::RATE_IS_SLOW;
+      std::pair&lt;uint8_t, double&gt; result =
+          rate_checkers_[*key_itr]-&gt;getErrorLevelAndRate();
+      diag.level = result.first;
+      diag.key = *key_itr;
+      diag.value = doubeToJson(result.second);
+      diag.description = rate_checkers_[*key_itr]-&gt;description;
+      diag.header.stamp = now;
+      diag_array.status.push_back(diag);
+      status.status.push_back(diag_array);
     }
-
-    void NodeStatusPublisher::ENABLE()
-    {
-        boost::thread publish_thread(boost::bind(&amp;NodeStatusPublisher::publishStatus, this));
-        return;
+    // iterate Diagnostic Buffer and publish all diagnostic data
+    std::vector&lt;std::string&gt; keys = getKeys();
+    for (auto key_itr = keys.begin(); key_itr != keys.end(); key_itr++) {
+      status.status.push_back(diag_buffers_[*key_itr]-&gt;getAndClearData());
     }
+    status_pub_.publish(status);
+    mtx_.unlock();
+    rate.sleep();
+  }
+  return;
+}
 
-    std::vector&lt;std::string&gt; NodeStatusPublisher::getKeys()
-    {
-        std::vector&lt;std::string&gt; keys;
-        std::vector&lt;std::string&gt; checker_keys = getRateCheckerKeys();
-        std::pair&lt;std::string,std::shared_ptr&lt;DiagBuffer&gt; &gt; buf_itr;
-        BOOST_FOREACH(buf_itr,diag_buffers_)
-        {
-            bool matched = false;
-            for(auto checker_key_itr = checker_keys.begin(); checker_key_itr != checker_keys.end(); checker_key_itr++)
-            {
-                if(*checker_key_itr == buf_itr.first)
-                {
-                    matched = true;
-                }
-            }
-            if(!matched)
-            {
-                keys.push_back(buf_itr.first);
-            }
-        }
-        return keys;
-    }
+void NodeStatusPublisher::ENABLE() {
+  boost::thread publish_thread(
+      boost::bind(&amp;NodeStatusPublisher::publishStatus, this));
+  return;
+}
 
-    std::vector&lt;std::string&gt; NodeStatusPublisher::getRateCheckerKeys()
-    {
-        std::vector&lt;std::string&gt; keys;
-        std::pair&lt;std::string,std::shared_ptr&lt;RateChecker&gt; &gt; checker_itr;
-        BOOST_FOREACH(checker_itr,rate_checkers_)
-        {
-            keys.push_back(checker_itr.first);
-        }
-        return keys;
+std::vector&lt;std::string&gt; NodeStatusPublisher::getKeys() {
+  std::vector&lt;std::string&gt; keys;
+  std::vector&lt;std::string&gt; checker_keys = getRateCheckerKeys();
+  std::pair&lt;std::string, std::shared_ptr&lt;DiagBuffer&gt;&gt; buf_itr;
+  BOOST_FOREACH (buf_itr, diag_buffers_) {
+    bool matched = false;
+    for (auto checker_key_itr = checker_keys.begin();
+         checker_key_itr != checker_keys.end(); checker_key_itr++) {
+      if (*checker_key_itr == buf_itr.first) {
+        matched = true;
+      }
     }
-
-    bool NodeStatusPublisher::keyExist(std::string key)
-    {
-        if(diag_buffers_.count(key) == 0)
-        {
-            return false;
-        }
-        return true;
+    if (!matched) {
+      keys.push_back(buf_itr.first);
     }
+  }
+  return keys;
+}
 
-    // add New Diagnostic Buffer if the key does not exist
-    void NodeStatusPublisher::addNewBuffer(std::string key, uint8_t type, std::string description)
-    {
-        if(!keyExist(key))
-        {
-            std::shared_ptr&lt;DiagBuffer&gt; buf_ptr = std::make_shared&lt;DiagBuffer&gt;(key, type, description, autoware_health_checker::BUFFER_LENGTH);
-            diag_buffers_[key] = buf_ptr;
-        }
-        return;
-    }
+std::vector&lt;std::string&gt; NodeStatusPublisher::getRateCheckerKeys() {
+  std::vector&lt;std::string&gt; keys;
+  std::pair&lt;std::string, std::shared_ptr&lt;RateChecker&gt;&gt; checker_itr;
+  BOOST_FOREACH (checker_itr, rate_checkers_) {
+    keys.push_back(checker_itr.first);
+  }
+  return keys;
+}
 
-    uint8_t NodeStatusPublisher::CHECK_MIN_VALUE(std::string key,double value,double warn_value,double error_value,double fatal_value,std::string description)
-    {
-        addNewBuffer(key,autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,description);
-        autoware_system_msgs::DiagnosticStatus new_status;
-        new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
-        if(value &lt; fatal_value)
-        {
-            new_status.level = autoware_system_msgs::DiagnosticStatus::FATAL;
-        }
-        else if(value &lt; error_value)
-        {
-            new_status.level = autoware_system_msgs::DiagnosticStatus::ERROR;
-        }
-        else if(value &lt; warn_value)
-        {
-            new_status.level = autoware_system_msgs::DiagnosticStatus::WARN;
-        }
-        else
-        {
-            new_status.level = autoware_system_msgs::DiagnosticStatus::OK;
-        }
-        new_status.description = description;
-        new_status.value = doubeToJson(value);
-        diag_buffers_[key]-&gt;addDiag(new_status);
-        return new_status.level;
-    }
+bool NodeStatusPublisher::keyExist(std::string key) {
+  if (diag_buffers_.count(key) == 0) {
+    return false;
+  }
+  return true;
+}
 
-    uint8_t NodeStatusPublisher::CHECK_MAX_VALUE(std::string key,double value,double warn_value,double error_value,double fatal_value,std::string description)
-    {
-        addNewBuffer(key,autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,description);
-        autoware_system_msgs::DiagnosticStatus new_status;
-        new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
-        if(value &gt; fatal_value)
-        {
-            new_status.level = autoware_system_msgs::DiagnosticStatus::FATAL;
-        }
-        else if(value &gt; error_value)
-        {
-            new_status.level = autoware_system_msgs::DiagnosticStatus::ERROR;
-        }
-        else if(value &gt; warn_value)
-        {
-            new_status.level = autoware_system_msgs::DiagnosticStatus::WARN;
-        }
-        else
-        {
-            new_status.level = autoware_system_msgs::DiagnosticStatus::OK;
-        }
-        new_status.description = description;
-        new_status.value = doubeToJson(value);
-        new_status.header.stamp = ros::Time::now();
-        diag_buffers_[key]-&gt;addDiag(new_status);
-        return new_status.level;
-    }
+// add New Diagnostic Buffer if the key does not exist
+void NodeStatusPublisher::addNewBuffer(std::string key, uint8_t type,
+                                       std::string description) {
+  if (!keyExist(key)) {
+    std::shared_ptr&lt;DiagBuffer&gt; buf_ptr = std::make_shared&lt;DiagBuffer&gt;(
+        key, type, description, autoware_health_checker::BUFFER_LENGTH);
+    diag_buffers_[key] = buf_ptr;
+  }
+  return;
+}
 
-    uint8_t NodeStatusPublisher::CHECK_RANGE(std::string key,double value,std::pair&lt;double,double&gt; warn_value,std::pair&lt;double,double&gt; error_value,std::pair&lt;double,double&gt; fatal_value,std::string description)
-    {
-        addNewBuffer(key,autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,description);
-        autoware_system_msgs::DiagnosticStatus new_status;
-        new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
-        if(value &lt; fatal_value.first || value &gt; fatal_value.second)
-        {
-            new_status.level = autoware_system_msgs::DiagnosticStatus::FATAL;
-        }
-        else if(value &lt; error_value.first || value &gt; error_value.second)
-        {
-            new_status.level = autoware_system_msgs::DiagnosticStatus::ERROR;
-        }
-        else if(value &lt; warn_value.first || value &gt; warn_value.second)
-        {
-            new_status.level = autoware_system_msgs::DiagnosticStatus::WARN;
-        }
-        else
-        {
-            new_status.level = autoware_system_msgs::DiagnosticStatus::OK;
-        }
-        new_status.value = doubeToJson(value);
-        new_status.description = description;
-        new_status.header.stamp = ros::Time::now();
-        diag_buffers_[key]-&gt;addDiag(new_status);
-        return new_status.level;
-    }
+uint8_t NodeStatusPublisher::CHECK_MIN_VALUE(std::string key, double value,
+                                             double warn_value,
+                                             double error_value,
+                                             double fatal_value,
+                                             std::string description) {
+  addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,
+               description);
+  autoware_system_msgs::DiagnosticStatus new_status;
+  new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
+  if (value &lt; fatal_value) {
+    new_status.level = autoware_system_msgs::DiagnosticStatus::FATAL;
+  } else if (value &lt; error_value) {
+    new_status.level = autoware_system_msgs::DiagnosticStatus::ERROR;
+  } else if (value &lt; warn_value) {
+    new_status.level = autoware_system_msgs::DiagnosticStatus::WARN;
+  } else {
+    new_status.level = autoware_system_msgs::DiagnosticStatus::OK;
+  }
+  new_status.description = description;
+  new_status.value = doubeToJson(value);
+  diag_buffers_[key]-&gt;addDiag(new_status);
+  return new_status.level;
+}
 
-    void NodeStatusPublisher::CHECK_RATE(std::string key,double warn_rate,double error_rate,double fatal_rate,std::string description)
-    {
-        if(!keyExist(key))
-        {
-            std::shared_ptr&lt;RateChecker&gt; checker_ptr = std::make_shared&lt;RateChecker&gt;(autoware_health_checker::BUFFER_LENGTH,warn_rate,error_rate,fatal_rate,description);
-            rate_checkers_[key] = checker_ptr;
-        }
-        addNewBuffer(key,autoware_system_msgs::DiagnosticStatus::RATE_IS_SLOW,description);
-        rate_checkers_[key]-&gt;check();
-        return;
-    }
+uint8_t NodeStatusPublisher::CHECK_MAX_VALUE(std::string key, double value,
+                                             double warn_value,
+                                             double error_value,
+                                             double fatal_value,
+                                             std::string description) {
+  addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,
+               description);
+  autoware_system_msgs::DiagnosticStatus new_status;
+  new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
+  if (value &gt; fatal_value) {
+    new_status.level = autoware_system_msgs::DiagnosticStatus::FATAL;
+  } else if (value &gt; error_value) {
+    new_status.level = autoware_system_msgs::DiagnosticStatus::ERROR;
+  } else if (value &gt; warn_value) {
+    new_status.level = autoware_system_msgs::DiagnosticStatus::WARN;
+  } else {
+    new_status.level = autoware_system_msgs::DiagnosticStatus::OK;
+  }
+  new_status.description = description;
+  new_status.value = doubeToJson(value);
+  new_status.header.stamp = ros::Time::now();
+  diag_buffers_[key]-&gt;addDiag(new_status);
+  return new_status.level;
+}
 
-    std::string NodeStatusPublisher::doubeToJson(double value)
-    {
-        using namespace boost::property_tree;
-        std::stringstream ss;
-        ptree pt;
-        pt.put("value.double", value);
-        write_json(ss, pt);
-        return ss.str();
-    }
+uint8_t NodeStatusPublisher::CHECK_RANGE(std::string key, double value,
+                                         std::pair&lt;double, double&gt; warn_value,
+                                         std::pair&lt;double, double&gt; error_value,
+                                         std::pair&lt;double, double&gt; fatal_value,
+                                         std::string description) {
+  addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,
+               description);
+  autoware_system_msgs::DiagnosticStatus new_status;
+  new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
+  if (value &lt; fatal_value.first || value &gt; fatal_value.second) {
+    new_status.level = autoware_system_msgs::DiagnosticStatus::FATAL;
+  } else if (value &lt; error_value.first || value &gt; error_value.second) {
+    new_status.level = autoware_system_msgs::DiagnosticStatus::ERROR;
+  } else if (value &lt; warn_value.first || value &gt; warn_value.second) {
+    new_status.level = autoware_system_msgs::DiagnosticStatus::WARN;
+  } else {
+    new_status.level = autoware_system_msgs::DiagnosticStatus::OK;
+  }
+  new_status.value = doubeToJson(value);
+  new_status.description = description;
+  new_status.header.stamp = ros::Time::now();
+  diag_buffers_[key]-&gt;addDiag(new_status);
+  return new_status.level;
+}
+
+void NodeStatusPublisher::CHECK_RATE(std::string key, double warn_rate,
+                                     double error_rate, double fatal_rate,
+                                     std::string description) {
+  if (!keyExist(key)) {
+    std::shared_ptr&lt;RateChecker&gt; checker_ptr = std::make_shared&lt;RateChecker&gt;(
+        autoware_health_checker::BUFFER_LENGTH, warn_rate, error_rate,
+        fatal_rate, description);
+    rate_checkers_[key] = checker_ptr;
+  }
+  addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::RATE_IS_SLOW,
+               description);
+  rate_checkers_[key]-&gt;check();
+  return;
+}
+
+std::string NodeStatusPublisher::doubeToJson(double value) {
+  using namespace boost::property_tree;
+  std::stringstream ss;
+  ptree pt;
+  pt.put("value.double", value);
+  write_json(ss, pt);
+  return ss.str();
+}
 }
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\rate_checker.cpp" new_path="ros\src\system\autoware_health_checker\src\rate_checker.cpp" added_lines="89" deleted_lines="92">
				<diff>@@ -1,102 +1,99 @@
-#include &lt;autoware_health_checker/rate_checker.h&gt;
+/*
+ * Copyright 2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * v1.0 Masaya Kataoka
+ */
 
-namespace autoware_health_checker
-{
-    RateChecker::RateChecker(double buffer_length,double warn_rate,double error_rate,double fatal_rate,std::string description) 
-        : buffer_length_(buffer_length), warn_rate_(warn_rate), error_rate_(error_rate), fatal_rate_(fatal_rate), description(description)
-    {
-        start_time_ = ros::Time::now();
-    }
+#include &lt;autoware_health_checker/rate_checker.h&gt;
 
-    RateChecker::~RateChecker()
-    {
+namespace autoware_health_checker {
+RateChecker::RateChecker(double buffer_length, double warn_rate,
+                         double error_rate, double fatal_rate,
+                         std::string description)
+    : buffer_length_(buffer_length), warn_rate_(warn_rate),
+      error_rate_(error_rate), fatal_rate_(fatal_rate),
+      description(description) {
+  start_time_ = ros::Time::now();
+}
 
-    }
+RateChecker::~RateChecker() {}
 
-    std::pair&lt;uint8_t,double&gt; RateChecker::getErrorLevelAndRate()
-    {
-        std::pair&lt;uint8_t,double&gt; ret;
-        boost::optional&lt;double&gt; rate = getRate();
-        if(!rate)
-        {
-            ret = std::make_pair(autoware_health_checker::LEVEL_ERROR,0);
-        }
-        else if(rate.get() &lt; fatal_rate_)
-        {
-            ret = std::make_pair(autoware_health_checker::LEVEL_FATAL,rate.get());
-        }
-        else if(rate.get() &lt; error_rate_)
-        {
-            ret = std::make_pair(autoware_health_checker::LEVEL_ERROR,rate.get());
-        }
-        else if(rate.get() &lt; warn_rate_)
-        {
-            ret = std::make_pair(autoware_health_checker::LEVEL_WARN,rate.get());
-        }
-        else
-        {
-            ret = std::make_pair(autoware_health_checker::LEVEL_OK,rate.get());
-        }
-        return ret;
-    }
+std::pair&lt;uint8_t, double&gt; RateChecker::getErrorLevelAndRate() {
+  std::pair&lt;uint8_t, double&gt; ret;
+  boost::optional&lt;double&gt; rate = getRate();
+  if (!rate) {
+    ret = std::make_pair(autoware_health_checker::LEVEL_ERROR, 0);
+  } else if (rate.get() &lt; fatal_rate_) {
+    ret = std::make_pair(autoware_health_checker::LEVEL_FATAL, rate.get());
+  } else if (rate.get() &lt; error_rate_) {
+    ret = std::make_pair(autoware_health_checker::LEVEL_ERROR, rate.get());
+  } else if (rate.get() &lt; warn_rate_) {
+    ret = std::make_pair(autoware_health_checker::LEVEL_WARN, rate.get());
+  } else {
+    ret = std::make_pair(autoware_health_checker::LEVEL_OK, rate.get());
+  }
+  return ret;
+}
 
-    uint8_t RateChecker::getErrorLevel()
-    {
-        boost::optional&lt;double&gt; rate = getRate();
-        if(!rate)
-        {
-            return autoware_health_checker::LEVEL_ERROR;
-        }
-        if(rate.get() &lt; fatal_rate_)
-        {
-            return autoware_health_checker::LEVEL_FATAL;
-        }
-        if(rate.get() &lt; error_rate_)
-        {
-            return autoware_health_checker::LEVEL_ERROR;
-        }
-        if(rate.get() &lt; warn_rate_)
-        {
-            return autoware_health_checker::LEVEL_WARN;
-        }
-        return autoware_health_checker::LEVEL_OK;
-    }
+uint8_t RateChecker::getErrorLevel() {
+  boost::optional&lt;double&gt; rate = getRate();
+  if (!rate) {
+    return autoware_health_checker::LEVEL_ERROR;
+  }
+  if (rate.get() &lt; fatal_rate_) {
+    return autoware_health_checker::LEVEL_FATAL;
+  }
+  if (rate.get() &lt; error_rate_) {
+    return autoware_health_checker::LEVEL_ERROR;
+  }
+  if (rate.get() &lt; warn_rate_) {
+    return autoware_health_checker::LEVEL_WARN;
+  }
+  return autoware_health_checker::LEVEL_OK;
+}
 
-    void RateChecker::check()
-    {
-        update();
-        mtx_.lock();
-        data_.push_back(ros::Time::now());
-        mtx_.unlock();
-    }
+void RateChecker::check() {
+  update();
+  mtx_.lock();
+  data_.push_back(ros::Time::now());
+  mtx_.unlock();
+}
 
-    void RateChecker::update()
-    {
-        mtx_.lock();
-        std::vector&lt;ros::Time&gt; buffer;
-        for(auto data_itr = data_.begin(); data_itr != data_.end(); data_itr++)
-        {
-            if(*data_itr &gt; ros::Time::now()-ros::Duration(buffer_length_))
-            {
-                buffer.push_back(*data_itr);
-            }
-        }
-        data_ = buffer;
-        mtx_.unlock();
-        return;
+void RateChecker::update() {
+  mtx_.lock();
+  std::vector&lt;ros::Time&gt; buffer;
+  for (auto data_itr = data_.begin(); data_itr != data_.end(); data_itr++) {
+    if (*data_itr &gt; ros::Time::now() - ros::Duration(buffer_length_)) {
+      buffer.push_back(*data_itr);
     }
+  }
+  data_ = buffer;
+  mtx_.unlock();
+  return;
+}
 
-    boost::optional&lt;double&gt; RateChecker::getRate()
-    {
-        boost::optional&lt;double&gt; rate;
-        if(ros::Time::now() - start_time_ &lt; ros::Duration(buffer_length_))
-        {
-            return boost::none;
-        }
-        update();
-        mtx_.lock();
-        rate = data_.size()/buffer_length_;
-        mtx_.unlock();
-        return rate;
-    }
+boost::optional&lt;double&gt; RateChecker::getRate() {
+  boost::optional&lt;double&gt; rate;
+  if (ros::Time::now() - start_time_ &lt; ros::Duration(buffer_length_)) {
+    return boost::none;
+  }
+  update();
+  mtx_.lock();
+  rate = data_.size() / buffer_length_;
+  mtx_.unlock();
+  return rate;
+}
 }
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\system_status_subscriber.cpp" new_path="ros\src\system\autoware_health_checker\src\system_status_subscriber.cpp" added_lines="53" deleted_lines="38">
				<diff>@@ -1,45 +1,60 @@
-#include &lt;autoware_health_checker/system_status_subscriber.h&gt;
+/*
+ * Copyright 2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * v1.0 Masaya Kataoka
+ */
 
-namespace autoware_health_checker
-{
-    SystemStatusSubscriber::SystemStatusSubscriber(ros::NodeHandle nh,ros::NodeHandle pnh)
-    {
-        nh_ = nh;
-        pnh_ = pnh;
-    }
+#include &lt;autoware_health_checker/system_status_subscriber.h&gt;
 
-    SystemStatusSubscriber::~SystemStatusSubscriber()
-    {
+namespace autoware_health_checker {
+SystemStatusSubscriber::SystemStatusSubscriber(ros::NodeHandle nh,
+                                               ros::NodeHandle pnh) {
+  nh_ = nh;
+  pnh_ = pnh;
+}
 
-    }
+SystemStatusSubscriber::~SystemStatusSubscriber() {}
 
-    void SystemStatusSubscriber::enable()
-    {
-        ros::AsyncSpinner spinner(1);
-        spinner.start();
-        ros::Rate rate(1);
-        status_sub_ = nh_.subscribe("system_status",10,&amp;SystemStatusSubscriber::systemStatusCallback,this);
-        while(ros::ok())
-        {
-            rate.sleep();
-        }
-        spinner.stop();
-        return;
-    }
+void SystemStatusSubscriber::enable() {
+  ros::AsyncSpinner spinner(1);
+  spinner.start();
+  ros::Rate rate(1);
+  status_sub_ = nh_.subscribe(
+      "system_status", 10, &amp;SystemStatusSubscriber::systemStatusCallback, this);
+  while (ros::ok()) {
+    rate.sleep();
+  }
+  spinner.stop();
+  return;
+}
 
-    void SystemStatusSubscriber::systemStatusCallback(const autoware_system_msgs::SystemStatus::ConstPtr msg)
-    {
-        for(auto function_itr = functions_.begin(); function_itr != functions_.end(); function_itr++)
-        {
-            std::function&lt;void(autoware_system_msgs::SystemStatus)&gt; func = *function_itr;
-            func(*msg);
-        }
-        return;
-    }
+void SystemStatusSubscriber::systemStatusCallback(
+    const autoware_system_msgs::SystemStatus::ConstPtr msg) {
+  for (auto function_itr = functions_.begin(); function_itr != functions_.end();
+       function_itr++) {
+    std::function&lt;void(autoware_system_msgs::SystemStatus)&gt; func =
+        *function_itr;
+    func(*msg);
+  }
+  return;
+}
 
-    void SystemStatusSubscriber::addCallback(std::function&lt;void(autoware_system_msgs::SystemStatus)&gt; func)
-    {
-        functions_.push_back(func);
-        return;
-    }
+void SystemStatusSubscriber::addCallback(
+    std::function&lt;void(autoware_system_msgs::SystemStatus)&gt; func) {
+  functions_.push_back(func);
+  return;
+}
 }
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\test\src\test_autoware_health_checker.cpp" new_path="ros\src\system\autoware_health_checker\test\src\test_autoware_health_checker.cpp" added_lines="121" deleted_lines="84">
				<diff>@@ -16,127 +16,164 @@
  *
  * v1.0 Masaya Kataoka
  */
-#include &lt;ros/ros.h&gt;
-#include &lt;gtest/gtest.h&gt;
 #include &lt;autoware_health_checker/node_status_publisher.h&gt;
+#include &lt;gtest/gtest.h&gt;
+#include &lt;ros/ros.h&gt;
 
-class AutowareHealthCheckerTestSuite : public ::testing::Test
-{
+class AutowareHealthCheckerTestSuite : public ::testing::Test {
 public:
-  AutowareHealthCheckerTestSuite()
-  {
-  }
+  AutowareHealthCheckerTestSuite() {}
 
-  ~AutowareHealthCheckerTestSuite()
-  {
-  }
+  ~AutowareHealthCheckerTestSuite() {}
 };
 
-class AutowareHealthCheckerTestClass
-{
+class AutowareHealthCheckerTestClass {
 public:
-  AutowareHealthCheckerTestClass()
-  {
+  AutowareHealthCheckerTestClass() {
     ros::NodeHandle nh;
     ros::NodeHandle pnh("~");
-    node_status_publisher_ptr = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh,pnh);
+    node_status_publisher_ptr =
+        std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh, pnh);
   };
-  std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr;
+  std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt;
+      node_status_publisher_ptr;
 };
 
-TEST(TestSuite, CHECK_MIN_VALUE)
-{
+TEST(TestSuite, CHECK_MIN_VALUE) {
   AutowareHealthCheckerTestClass test_autoware_health_checker;
-  uint8_t ret_fatal = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE("test",1,6,4,2,"test");
-  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL) &lt;&lt; "The value was self-diagnosed as fatal"; 
-  uint8_t ret_error = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE("test",3,6,4,2,"test");
-  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR) &lt;&lt; "The value was self-diagnosed as error";
-  uint8_t ret_warn = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE("test",5,6,4,2,"test");
-  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN) &lt;&lt; "The value was self-diagnosed as warn";
-  uint8_t ret_ok = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE("test",7,6,4,2,"test");
-  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK) &lt;&lt; "The value was self-diagnosed as ok";
+  uint8_t ret_fatal =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE(
+          "test", 1, 6, 4, 2, "test");
+  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL)
+      &lt;&lt; "The value was self-diagnosed as fatal";
+  uint8_t ret_error =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE(
+          "test", 3, 6, 4, 2, "test");
+  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR)
+      &lt;&lt; "The value was self-diagnosed as error";
+  uint8_t ret_warn =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE(
+          "test", 5, 6, 4, 2, "test");
+  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN)
+      &lt;&lt; "The value was self-diagnosed as warn";
+  uint8_t ret_ok =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE(
+          "test", 7, 6, 4, 2, "test");
+  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK)
+      &lt;&lt; "The value was self-diagnosed as ok";
 }
 
-TEST(TestSuite, CHECK_MAX_VALUE)
-{
+TEST(TestSuite, CHECK_MAX_VALUE) {
   AutowareHealthCheckerTestClass test_autoware_health_checker;
-  uint8_t ret_fatal = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE("test",7,2,4,6,"test");
-  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL) &lt;&lt; "The value was self-diagnosed as fatal"; 
-  uint8_t ret_error = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE("test",5,2,4,6,"test");
-  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR) &lt;&lt; "The value was self-diagnosed as error";
-  uint8_t ret_warn = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE("test",3,2,4,6,"test");
-  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN) &lt;&lt; "The value was self-diagnosed as warn";
-  uint8_t ret_ok = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE("test",1,2,4,6,"test");
-  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK) &lt;&lt; "The value was self-diagnosed as ok";
+  uint8_t ret_fatal =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE(
+          "test", 7, 2, 4, 6, "test");
+  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL)
+      &lt;&lt; "The value was self-diagnosed as fatal";
+  uint8_t ret_error =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE(
+          "test", 5, 2, 4, 6, "test");
+  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR)
+      &lt;&lt; "The value was self-diagnosed as error";
+  uint8_t ret_warn =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE(
+          "test", 3, 2, 4, 6, "test");
+  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN)
+      &lt;&lt; "The value was self-diagnosed as warn";
+  uint8_t ret_ok =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE(
+          "test", 1, 2, 4, 6, "test");
+  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK)
+      &lt;&lt; "The value was self-diagnosed as ok";
 }
 
-TEST(TestSuite, CHECK_RANGE)
-{
+TEST(TestSuite, CHECK_RANGE) {
   AutowareHealthCheckerTestClass test_autoware_health_checker;
-  uint8_t ret_fatal = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE("test",7.0,{2.0,4.0},{1.0,5.0},{0.0,6.0},"test");
-  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL) &lt;&lt; "The value was self-diagnosed as fatal"; 
-  uint8_t ret_error = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE("test",5.5,{2.0,4.0},{1.0,5.0},{0.0,6.0},"test");
-  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR) &lt;&lt; "The value was self-diagnosed as error";
-  uint8_t ret_warn = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE("test",4.5,{2.0,4.0},{1.0,5.0},{0.0,6.0},"test");
-  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN) &lt;&lt; "The value was self-diagnosed as warn";
-  uint8_t ret_ok = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE("test",3.0,{2.0,4.0},{1.0,5.0},{0.0,6.0},"test");
-  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK) &lt;&lt; "The value was self-diagnosed as ok";
+  uint8_t ret_fatal =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE(
+          "test", 7.0, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
+  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL)
+      &lt;&lt; "The value was self-diagnosed as fatal";
+  uint8_t ret_error =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE(
+          "test", 5.5, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
+  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR)
+      &lt;&lt; "The value was self-diagnosed as error";
+  uint8_t ret_warn =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE(
+          "test", 4.5, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
+  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN)
+      &lt;&lt; "The value was self-diagnosed as warn";
+  uint8_t ret_ok =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE(
+          "test", 3.0, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
+  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK)
+      &lt;&lt; "The value was self-diagnosed as ok";
 }
 
-uint8_t test_function(double value)
-{
-if(value == 0.0)
-{
+uint8_t test_function(double value) {
+  if (value == 0.0) {
     return autoware_health_checker::LEVEL_FATAL;
-}
-if(value == 1.0)
-{
+  }
+  if (value == 1.0) {
     return autoware_health_checker::LEVEL_ERROR;
-}
-if(value == 2.0)
-{
+  }
+  if (value == 2.0) {
     return autoware_health_checker::LEVEL_WARN;
-}
-return autoware_health_checker::LEVEL_OK;
+  }
+  return autoware_health_checker::LEVEL_OK;
 };
 
-boost::property_tree::ptree test_value_json_func(double value)
-{
-boost::property_tree::ptree tree;
-tree.put("value", value);
-return tree;
+boost::property_tree::ptree test_value_json_func(double value) {
+  boost::property_tree::ptree tree;
+  tree.put("value", value);
+  return tree;
 };
 
-TEST(TestSuite, CHECK_VALUE)
-{
+TEST(TestSuite, CHECK_VALUE) {
   AutowareHealthCheckerTestClass test_autoware_health_checker;
   std::function&lt;uint8_t(double value)&gt; check_func = test_function;
-  std::function&lt;boost::property_tree::ptree(double value)&gt; check_value_json_func = test_value_json_func;
-  uint8_t ret_fatal = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE("test",0.0,check_func,check_value_json_func,"test");
-  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL) &lt;&lt; "The value was self-diagnosed as fatal"; 
-  uint8_t ret_error = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE("test",1.0,check_func,check_value_json_func,"test");
-  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR) &lt;&lt; "The value was self-diagnosed as fatal"; 
-  uint8_t ret_warn = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE("test",2.0,check_func,check_value_json_func,"test");
-  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN) &lt;&lt; "The value was self-diagnosed as fatal"; 
-  uint8_t ret_ok = test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE("test",-1.0,check_func,check_value_json_func,"test");
-  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK) &lt;&lt; "The value was self-diagnosed as fatal";
-  boost::optional&lt;double&gt; value = check_value_json_func(0.0).get_optional&lt;double&gt;("value");
-  ASSERT_EQ(value.get(),0.0) &lt;&lt; "The value must be true, failed to get json value";
+  std::function&lt;boost::property_tree::ptree(double value)&gt;
+      check_value_json_func = test_value_json_func;
+  uint8_t ret_fatal =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE(
+          "test", 0.0, check_func, check_value_json_func, "test");
+  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL)
+      &lt;&lt; "The value was self-diagnosed as fatal";
+  uint8_t ret_error =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE(
+          "test", 1.0, check_func, check_value_json_func, "test");
+  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR)
+      &lt;&lt; "The value was self-diagnosed as fatal";
+  uint8_t ret_warn =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE(
+          "test", 2.0, check_func, check_value_json_func, "test");
+  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN)
+      &lt;&lt; "The value was self-diagnosed as fatal";
+  uint8_t ret_ok =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE(
+          "test", -1.0, check_func, check_value_json_func, "test");
+  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK)
+      &lt;&lt; "The value was self-diagnosed as fatal";
+  boost::optional&lt;double&gt; value =
+      check_value_json_func(0.0).get_optional&lt;double&gt;("value");
+  ASSERT_EQ(value.get(), 0.0)
+      &lt;&lt; "The value must be true, failed to get json value";
 }
 
-TEST(TestSuite, NODE_STATUS)
-{
+TEST(TestSuite, NODE_STATUS) {
   AutowareHealthCheckerTestClass test_autoware_health_checker;
   test_autoware_health_checker.node_status_publisher_ptr-&gt;NODE_ACTIVATE();
-  uint8_t ret_active = test_autoware_health_checker.node_status_publisher_ptr-&gt;getNodeStatus();
-  ASSERT_EQ(ret_active, true) &lt;&lt; "The value must be true"; 
+  uint8_t ret_active =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;getNodeStatus();
+  ASSERT_EQ(ret_active, true) &lt;&lt; "The value must be true";
   test_autoware_health_checker.node_status_publisher_ptr-&gt;NODE_DEACTIVATE();
-  uint8_t ret_inactive = test_autoware_health_checker.node_status_publisher_ptr-&gt;getNodeStatus();
-  ASSERT_EQ(ret_inactive, false) &lt;&lt; "The value must be true"; 
+  uint8_t ret_inactive =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;getNodeStatus();
+  ASSERT_EQ(ret_inactive, false) &lt;&lt; "The value must be true";
 }
 
-int main(int argc, char** argv)
-{
+int main(int argc, char **argv) {
   testing::InitGoogleTest(&amp;argc, argv);
   ros::init(argc, argv, "AutowareHealthCheckerTestNode");
   return RUN_ALL_TESTS();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3af11e68739293f92be7bb8e05dc30805527d013" author="Abraham Monrroy Cano">
		<msg>Fix/remove velodyne subtree (#1966)

* Removed subtree

* Add rtm launchfiles

* Launch files adapted to upstream driver

* Added install commands for runtiume manager velodyne launch files

* Fix remapping VLP-32C topic name (#1967)

* Updated cross-build image date (#1975)</msg>
		<modified_files>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\cfg\VelodyneNode.cfg" new_path="" added_lines="0" deleted_lines="14">
				<diff>@@ -1,14 +0,0 @@
-#!/usr/bin/env python
-PACKAGE = "velodyne_driver"
-NODE_NAME = "velodyne_node"
-PARAMS_NAME = "VelodyneNode"
-
-from math import pi
-from dynamic_reconfigure.parameter_generator_catkin import *
-
-gen = ParameterGenerator()
-
-gen.add("time_offset", double_t,  0, "A manually calibrated offset (in seconds) to add to the timestamp before publication of a message.",
-        0.0, -1.0, 1.0)
-
-exit(gen.generate(PACKAGE, NODE_NAME, PARAMS_NAME))
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\include\velodyne_driver\input.h" new_path="" added_lines="0" deleted_lines="126">
				<diff>@@ -1,126 +0,0 @@
-/* -*- mode: C++ -*-
- *
- *  Copyright (C) 2007 Austin Robot Technology, Yaxin Liu, Patrick Beeson
- *  Copyright (C) 2009, 2010 Austin Robot Technology, Jack O'Quin
- *  Copyright (C) 2015, Jack O'Quin
- *
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
- *
- *  Velodyne 3D LIDAR data input classes
- *
- *    These classes provide raw Velodyne LIDAR input packets from
- *    either a live socket interface or a previously-saved PCAP dump
- *    file.
- *
- *  Classes:
- *
- *     velodyne::Input -- base class for accessing the data
- *                      independently of its source
- *
- *     velodyne::InputSocket -- derived class reads live data from the
- *                      device via a UDP socket
- *
- *     velodyne::InputPCAP -- derived class provides a similar interface
- *                      from a PCAP dump file
- */
-
-#ifndef __VELODYNE_INPUT_H
-#define __VELODYNE_INPUT_H
-
-#include &lt;unistd.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;pcap.h&gt;
-#include &lt;netinet/in.h&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;velodyne_msgs/VelodynePacket.h&gt;
-
-namespace velodyne_driver
-{
-  static uint16_t DATA_PORT_NUMBER = 2368;     // default data port
-  static uint16_t POSITION_PORT_NUMBER = 8308; // default position port
-
-  /** @brief Velodyne input base class */
-  class Input
-  {
-  public:
-    Input(ros::NodeHandle private_nh, uint16_t port);
-    virtual ~Input() {}
-
-    /** @brief Read one Velodyne packet.
-     *
-     * @param pkt points to VelodynePacket message
-     *
-     * @returns 0 if successful,
-     *          -1 if end of file
-     *          &gt; 0 if incomplete packet (is this possible?)
-     */
-    virtual int getPacket(velodyne_msgs::VelodynePacket *pkt,
-                          const double time_offset) = 0;
-
-  protected:
-    ros::NodeHandle private_nh_;
-    uint16_t port_;
-    std::string devip_str_;
-  };
-
-  /** @brief Live Velodyne input from socket. */
-  class InputSocket: public Input
-  {
-  public:
-    InputSocket(ros::NodeHandle private_nh,
-                uint16_t port = DATA_PORT_NUMBER);
-    virtual ~InputSocket();
-
-    virtual int getPacket(velodyne_msgs::VelodynePacket *pkt, 
-                          const double time_offset);
-    void setDeviceIP( const std::string&amp; ip );
-  private:
-
-  private:
-    int sockfd_;
-    in_addr devip_;
-  };
-
-
-  /** @brief Velodyne input from PCAP dump file.
-   *
-   * Dump files can be grabbed by libpcap, Velodyne's DSR software,
-   * ethereal, wireshark, tcpdump, or the \ref vdump_command.
-   */
-  class InputPCAP: public Input
-  {
-  public:
-    InputPCAP(ros::NodeHandle private_nh,
-              uint16_t port = DATA_PORT_NUMBER,
-              double packet_rate = 0.0,
-              std::string filename="",
-              bool read_once=false,
-              bool read_fast=false,
-              double repeat_delay=0.0);
-    virtual ~InputPCAP();
-
-    virtual int getPacket(velodyne_msgs::VelodynePacket *pkt, 
-                          const double time_offset);
-    void setDeviceIP( const std::string&amp; ip );
-
-  private:
-    ros::Rate packet_rate_;
-    std::string filename_;
-    pcap_t *pcap_;
-    bpf_program pcap_packet_filter_;
-    char errbuf_[PCAP_ERRBUF_SIZE];
-    bool empty_;
-    bool read_once_;
-    bool read_fast_;
-    double repeat_delay_;
-  };
-
-} // velodyne_driver namespace
-
-#endif // __VELODYNE_INPUT_H
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\include\velodyne_driver\ring_sequence.h" new_path="" added_lines="0" deleted_lines="54">
				<diff>@@ -1,54 +0,0 @@
-/* -*- mode: C++ -*-
- *
- *  Copyright (C) 2010 Austin Robot Technology, Jack O'Quin
- *
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
- *
- *  Velodyne HDL-64E 3D LIDAR laser ring sequence.
- *
- *  \author Jack O'Quin
- */
-
-
-#ifndef __VELODYNE_RING_SEQUENCE_H
-#define __VELODYNE_RING_SEQUENCE_H
-
-namespace velodyne
-{
-  /// number of lasers
-  const int N_LASERS = 64;
-
-  /// ring sequence for device laser numbers
-  const int LASER_SEQUENCE[N_LASERS] =
-    {
-      6,  7, 10, 11,  0,  1,  4,  5,
-      8,  9, 14, 15, 18, 19, 22, 23,
-     12, 13, 16, 17, 20, 21, 26, 27,
-     30, 31,  2,  3, 24, 25, 28, 29,
-     38, 39, 42, 43, 32, 33, 36, 37,
-     40, 41, 46, 47, 50, 51, 54, 55,
-     44, 45, 48, 49, 52, 53, 58, 59,
-     62, 63, 34, 35, 56, 57, 60, 61
-    };
-
-  /// convert laser number to ring sequence (inverse of LASER_SEQUENCE)
-  const int LASER_RING[N_LASERS] =
-    {
-       4,  5, 26, 27,  6,  7,  0,  1,
-       8,  9,  2,  3, 16, 17, 10, 11,
-      18, 19, 12, 13, 20, 21, 14, 15,
-      28, 29, 22, 23, 30, 31, 24, 25,
-      36, 37, 58, 59, 38, 39, 32, 33,
-      40, 41, 34, 35, 48, 49, 42, 43,
-      50, 51, 44, 45, 52, 53, 46, 47,
-      60, 61, 54, 55, 62, 63, 56, 57
-    };
-
-} // velodyne namespace
-
-#endif // __VELODYNE_RING_SEQUENCE_H
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\src\driver\driver.cc" new_path="" added_lines="0" deleted_lines="236">
				<diff>@@ -1,236 +0,0 @@
-/*
- *  Copyright (C) 2007 Austin Robot Technology, Patrick Beeson
- *  Copyright (C) 2009-2012 Austin Robot Technology, Jack O'Quin
- * 
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
- *
- *  ROS driver implementation for the Velodyne 3D LIDARs
- */
-
-#include &lt;string&gt;
-#include &lt;cmath&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-#include &lt;velodyne_msgs/VelodyneScan.h&gt;
-
-#include "driver.h"
-
-namespace velodyne_driver
-{
-
-VelodyneDriver::VelodyneDriver(ros::NodeHandle node,
-                               ros::NodeHandle private_nh)
-{
-  // use private node handle to get parameters
-  private_nh.param("frame_id", config_.frame_id, std::string("velodyne"));
-  std::string tf_prefix = tf::getPrefixParam(private_nh);
-  ROS_DEBUG_STREAM("tf_prefix: " &lt;&lt; tf_prefix);
-  config_.frame_id = tf::resolve(tf_prefix, config_.frame_id);
-
-  // get model name, validate string, determine packet rate
-  private_nh.param("model", config_.model, std::string("64E"));
-  double packet_rate;                   // packet frequency (Hz)
-  std::string model_full_name;
-  if ((config_.model == "64E_S2") || 
-      (config_.model == "64E_S2.1"))    // generates 1333312 points per second
-    {                                   // 1 packet holds 384 points
-      packet_rate = 3472.17;            // 1333312 / 384
-      model_full_name = std::string("HDL-") + config_.model;
-    }
-  else if (config_.model == "64E_S3")
-    {
-      packet_rate = 5800.0; // experimental
-      model_full_name = std::string("HDL-") + config_.model;
-    }
-  else if (config_.model == "64E")
-    {
-      packet_rate = 2600.0;
-      model_full_name = std::string("HDL-") + config_.model;
-    }
-  else if (config_.model == "32E")
-    {
-      packet_rate = 1808.0;
-      model_full_name = std::string("HDL-") + config_.model;
-    }
-    else if (config_.model == "32C")
-    {
-      packet_rate = 1507.0;
-      model_full_name = std::string("VLP-") + config_.model;
-    }
-  else if (config_.model == "VLP16")
-    {
-      packet_rate = 754;             // 754 Packets/Second for Last or Strongest mode 1508 for dual (VLP-16 User Manual)
-      model_full_name = "VLP-16";
-    }
-  else
-    {
-      ROS_ERROR_STREAM("unknown Velodyne LIDAR model: " &lt;&lt; config_.model);
-      packet_rate = 2600.0;
-    }
-  std::string deviceName(std::string("Velodyne ") + model_full_name);
-
-  private_nh.param("rpm", config_.rpm, 600.0);
-  ROS_INFO_STREAM(deviceName &lt;&lt; " rotating at " &lt;&lt; config_.rpm &lt;&lt; " RPM");
-  double frequency = (config_.rpm / 60.0);     // expected Hz rate
-
-  // default number of packets for each scan is a single revolution
-  // (fractions rounded up)
-  config_.npackets = (int) ceil(packet_rate / frequency);
-  private_nh.getParam("npackets", config_.npackets);
-  ROS_INFO_STREAM("publishing " &lt;&lt; config_.npackets &lt;&lt; " packets per scan");
-
-  std::string dump_file;
-  private_nh.param("pcap", dump_file, std::string(""));
-
-  double cut_angle;
-  private_nh.param("cut_angle", cut_angle, -0.01);
-  if (cut_angle &lt; 0.0)
-  {
-    ROS_INFO_STREAM("Cut at specific angle feature deactivated.");
-  }
-  else if (cut_angle &lt; (2*M_PI))
-  {
-      ROS_INFO_STREAM("Cut at specific angle feature activated. " 
-        "Cutting velodyne points always at " &lt;&lt; cut_angle &lt;&lt; " rad.");
-  }
-  else
-  {
-    ROS_ERROR_STREAM("cut_angle parameter is out of range. Allowed range is "
-    &lt;&lt; "between 0.0 and 2*PI or negative values to deactivate this feature.");
-    cut_angle = -0.01;
-  }
-
-  // Convert cut_angle from radian to one-hundredth degree, 
-  // which is used in velodyne packets
-  config_.cut_angle = int((cut_angle*360/(2*M_PI))*100);
-
-  int udp_port;
-  private_nh.param("port", udp_port, (int) DATA_PORT_NUMBER);
-
-  // Initialize dynamic reconfigure
-  srv_ = boost::make_shared &lt;dynamic_reconfigure::Server&lt;velodyne_driver::
-    VelodyneNodeConfig&gt; &gt; (private_nh);
-  dynamic_reconfigure::Server&lt;velodyne_driver::VelodyneNodeConfig&gt;::
-    CallbackType f;
-  f = boost::bind (&amp;VelodyneDriver::callback, this, _1, _2);
-  srv_-&gt;setCallback (f); // Set callback function und call initially
-
-  // initialize diagnostics
-  diagnostics_.setHardwareID(deviceName);
-  const double diag_freq = packet_rate/config_.npackets;
-  diag_max_freq_ = diag_freq;
-  diag_min_freq_ = diag_freq;
-  ROS_INFO("expected frequency: %.3f (Hz)", diag_freq);
-
-  using namespace diagnostic_updater;
-  diag_topic_.reset(new TopicDiagnostic("velodyne_packets", diagnostics_,
-                                        FrequencyStatusParam(&amp;diag_min_freq_,
-                                                             &amp;diag_max_freq_,
-                                                             0.1, 10),
-                                        TimeStampStatusParam()));
-
-  // open Velodyne input device or file
-  if (dump_file != "")                  // have PCAP file?
-    {
-      // read data from packet capture file
-      input_.reset(new velodyne_driver::InputPCAP(private_nh, udp_port,
-                                                  packet_rate, dump_file));
-    }
-  else
-    {
-      // read data from live socket
-      input_.reset(new velodyne_driver::InputSocket(private_nh, udp_port));
-    }
-
-  // raw packet output topic
-  output_ =
-    node.advertise&lt;velodyne_msgs::VelodyneScan&gt;("velodyne_packets", 10);
-}
-
-/** poll the device
- *
- *  @returns true unless end of file reached
- */
-bool VelodyneDriver::poll(void)
-{
-  // Allocate a new shared pointer for zero-copy sharing with other nodelets.
-  velodyne_msgs::VelodyneScanPtr scan(new velodyne_msgs::VelodyneScan);
-
-  if( config_.cut_angle &gt;= 0) //Cut at specific angle feature enabled
-  {
-    scan-&gt;packets.reserve(config_.npackets);
-    velodyne_msgs::VelodynePacket tmp_packet;
-    while(true)
-    {
-      while(true)
-      {
-        int rc = input_-&gt;getPacket(&amp;tmp_packet, config_.time_offset);
-        if (rc == 0) break;       // got a full packet?
-        if (rc &lt; 0) return false; // end of file reached?
-      }
-      scan-&gt;packets.push_back(tmp_packet);
-
-      static int last_azimuth = -1;
-      // Extract base rotation of first block in packet
-      std::size_t azimuth_data_pos = 100*0+2;
-      int azimuth = *( (u_int16_t*) (&amp;tmp_packet.data[azimuth_data_pos]));
-
-      // Handle overflow 35999-&gt;0
-      if(azimuth&lt;last_azimuth)
-        last_azimuth-=36000;
-      // Check if currently passing cut angle
-      if(   last_azimuth != -1
-         &amp;&amp; last_azimuth &lt; config_.cut_angle
-         &amp;&amp; azimuth &gt;= config_.cut_angle )
-      {
-        last_azimuth = azimuth;
-        break; // Cut angle passed, one full revolution collected
-      }
-      last_azimuth = azimuth;
-    }
-  }
-  else // standard behaviour
-  {
-  // Since the velodyne delivers data at a very high rate, keep
-  // reading and publishing scans as fast as possible.
-    scan-&gt;packets.resize(config_.npackets);
-    for (int i = 0; i &lt; config_.npackets; ++i)
-    {
-      while (true)
-        {
-          // keep reading until full packet received
-          int rc = input_-&gt;getPacket(&amp;scan-&gt;packets[i], config_.time_offset);
-          if (rc == 0) break;       // got a full packet?
-          if (rc &lt; 0) return false; // end of file reached?
-        }
-    }
-  }
-
-  // publish message using time of last packet read
-  ROS_DEBUG("Publishing a full Velodyne scan.");
-  scan-&gt;header.stamp = scan-&gt;packets.back().stamp;
-  scan-&gt;header.frame_id = config_.frame_id;
-  output_.publish(scan);
-
-  // notify diagnostics that a message has been published, updating
-  // its status
-  diag_topic_-&gt;tick(scan-&gt;header.stamp);
-  diagnostics_.update();
-
-  return true;
-}
-
-void VelodyneDriver::callback(velodyne_driver::VelodyneNodeConfig &amp;config,
-              uint32_t level)
-{
-  ROS_INFO("Reconfigure Request");
-  config_.time_offset = config.time_offset;
-}
-
-} // namespace velodyne_driver
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\src\driver\driver.h" new_path="" added_lines="0" deleted_lines="73">
				<diff>@@ -1,73 +0,0 @@
-/* -*- mode: C++ -*- */
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- * 
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
- *
- *  ROS driver interface for the Velodyne 3D LIDARs
- */
-
-#ifndef _VELODYNE_DRIVER_H_
-#define _VELODYNE_DRIVER_H_ 1
-
-#include &lt;string&gt;
-#include &lt;ros/ros.h&gt;
-#include &lt;diagnostic_updater/diagnostic_updater.h&gt;
-#include &lt;diagnostic_updater/publisher.h&gt;
-#include &lt;dynamic_reconfigure/server.h&gt;
-
-#include &lt;velodyne_driver/input.h&gt;
-#include &lt;velodyne_driver/VelodyneNodeConfig.h&gt;
-
-namespace velodyne_driver
-{
-
-class VelodyneDriver
-{
-public:
-
-  VelodyneDriver(ros::NodeHandle node,
-                 ros::NodeHandle private_nh);
-  ~VelodyneDriver() {}
-
-  bool poll(void);
-
-private:
-
-  ///Callback for dynamic reconfigure
-  void callback(velodyne_driver::VelodyneNodeConfig &amp;config,
-              uint32_t level);
-
-  ///Pointer to dynamic reconfigure service srv_
-  boost::shared_ptr&lt;dynamic_reconfigure::Server&lt;velodyne_driver::
-              VelodyneNodeConfig&gt; &gt; srv_;
-
-  // configuration parameters
-  struct
-  {
-    std::string frame_id;            ///&lt; tf frame ID
-    std::string model;               ///&lt; device model name
-    int    npackets;                 ///&lt; number of packets to collect
-    double rpm;                      ///&lt; device rotation rate (RPMs)
-    int cut_angle;                   ///&lt; cutting angle in 1/100
-    double time_offset;              ///&lt; time in seconds added to each velodyne time stamp
-  } config_;
-
-  boost::shared_ptr&lt;Input&gt; input_;
-  ros::Publisher output_;
-
-  /** diagnostics updater */
-  diagnostic_updater::Updater diagnostics_;
-  double diag_min_freq_;
-  double diag_max_freq_;
-  boost::shared_ptr&lt;diagnostic_updater::TopicDiagnostic&gt; diag_topic_;
-};
-
-} // namespace velodyne_driver
-
-#endif // _VELODYNE_DRIVER_H_
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\src\driver\nodelet.cc" new_path="" added_lines="0" deleted_lines="85">
				<diff>@@ -1,85 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- * 
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
- *
- *  ROS driver nodelet for the Velodyne 3D LIDARs
- */
-
-#include &lt;string&gt;
-#include &lt;boost/thread.hpp&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;pluginlib/class_list_macros.h&gt;
-#include &lt;nodelet/nodelet.h&gt;
-
-#include "driver.h"
-
-namespace velodyne_driver
-{
-
-class DriverNodelet: public nodelet::Nodelet
-{
-public:
-
-  DriverNodelet():
-    running_(false)
-  {}
-
-  ~DriverNodelet()
-  {
-    if (running_)
-      {
-        NODELET_INFO("shutting down driver thread");
-        running_ = false;
-        deviceThread_-&gt;join();
-        NODELET_INFO("driver thread stopped");
-      }
-  }
-
-private:
-
-  virtual void onInit(void);
-  virtual void devicePoll(void);
-
-  volatile bool running_;               ///&lt; device thread is running
-  boost::shared_ptr&lt;boost::thread&gt; deviceThread_;
-
-  boost::shared_ptr&lt;VelodyneDriver&gt; dvr_; ///&lt; driver implementation class
-};
-
-void DriverNodelet::onInit()
-{
-  // start the driver
-  dvr_.reset(new VelodyneDriver(getNodeHandle(), getPrivateNodeHandle()));
-
-  // spawn device poll thread
-  running_ = true;
-  deviceThread_ = boost::shared_ptr&lt; boost::thread &gt;
-    (new boost::thread(boost::bind(&amp;DriverNodelet::devicePoll, this)));
-}
-
-/** @brief Device poll thread main loop. */
-void DriverNodelet::devicePoll()
-{
-  while(ros::ok())
-    {
-      // poll device until end of file
-      running_ = dvr_-&gt;poll();
-      if (!running_)
-        break;
-    }
-  running_ = false;
-}
-
-} // namespace velodyne_driver
-
-// Register this plugin with pluginlib.  Names must match nodelet_velodyne.xml.
-//
-// parameters are: class type, base class type
-PLUGINLIB_EXPORT_CLASS(velodyne_driver::DriverNodelet, nodelet::Nodelet)
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\src\driver\velodyne_node.cc" new_path="" added_lines="0" deleted_lines="33">
				<diff>@@ -1,33 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- * 
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
- *
- *  ROS driver node for the Velodyne 3D LIDARs.
- */
-
-#include &lt;ros/ros.h&gt;
-#include "driver.h"
-
-int main(int argc, char** argv)
-{
-  ros::init(argc, argv, "velodyne_node");
-  ros::NodeHandle node;
-  ros::NodeHandle private_nh("~");
-
-  // start the driver
-  velodyne_driver::VelodyneDriver dvr(node, private_nh);
-
-  // loop until shut down or end of file
-  while(ros::ok() &amp;&amp; dvr.poll())
-    {
-      ros::spinOnce();
-    }
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_driver\src\lib\input.cc" new_path="" added_lines="0" deleted_lines="327">
				<diff>@@ -1,327 +0,0 @@
-/*
- *  Copyright (C) 2007 Austin Robot Technology, Patrick Beeson
- *  Copyright (C) 2009, 2010 Austin Robot Technology, Jack O'Quin
- *  Copyright (C) 2015, Jack O'Quin
- *
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
- *
- *  Input classes for the Velodyne HDL-64E 3D LIDAR:
- *
- *     Input -- base class used to access the data independently of
- *              its source
- *
- *     InputSocket -- derived class reads live data from the device
- *              via a UDP socket
- *
- *     InputPCAP -- derived class provides a similar interface from a
- *              PCAP dump
- */
-
-#include &lt;unistd.h&gt;
-#include &lt;string&gt;
-#include &lt;sstream&gt;
-#include &lt;sys/socket.h&gt;
-#include &lt;arpa/inet.h&gt;
-#include &lt;poll.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;sys/file.h&gt;
-#include &lt;velodyne_driver/input.h&gt;
-
-namespace velodyne_driver
-{
-  static const size_t packet_size =
-    sizeof(velodyne_msgs::VelodynePacket().data);
-
-  ////////////////////////////////////////////////////////////////////////
-  // Input base class implementation
-  ////////////////////////////////////////////////////////////////////////
-
-  /** @brief constructor
-   *
-   *  @param private_nh ROS private handle for calling node.
-   *  @param port UDP port number.
-   */
-  Input::Input(ros::NodeHandle private_nh, uint16_t port):
-    private_nh_(private_nh),
-    port_(port)
-  {
-    private_nh.param("device_ip", devip_str_, std::string(""));
-    if (!devip_str_.empty())
-      ROS_INFO_STREAM("Only accepting packets from IP address: "
-                      &lt;&lt; devip_str_);
-  }
-
-  ////////////////////////////////////////////////////////////////////////
-  // InputSocket class implementation
-  ////////////////////////////////////////////////////////////////////////
-
-  /** @brief constructor
-   *
-   *  @param private_nh ROS private handle for calling node.
-   *  @param port UDP port number
-   */
-  InputSocket::InputSocket(ros::NodeHandle private_nh, uint16_t port):
-    Input(private_nh, port)
-  {
-    sockfd_ = -1;
-    
-    if (!devip_str_.empty()) {
-      inet_aton(devip_str_.c_str(),&amp;devip_);
-    }    
-
-    // connect to Velodyne UDP port
-    ROS_INFO_STREAM("Opening UDP socket: port " &lt;&lt; port);
-    sockfd_ = socket(PF_INET, SOCK_DGRAM, 0);
-    if (sockfd_ == -1)
-      {
-        perror("socket");               // TODO: ROS_ERROR errno
-        return;
-      }
-  
-    sockaddr_in my_addr;                     // my address information
-    memset(&amp;my_addr, 0, sizeof(my_addr));    // initialize to zeros
-    my_addr.sin_family = AF_INET;            // host byte order
-    my_addr.sin_port = htons(port);          // port in network byte order
-    my_addr.sin_addr.s_addr = INADDR_ANY;    // automatically fill in my IP
-  
-    if (bind(sockfd_, (sockaddr *)&amp;my_addr, sizeof(sockaddr)) == -1)
-      {
-        perror("bind");                 // TODO: ROS_ERROR errno
-        return;
-      }
-  
-    if (fcntl(sockfd_,F_SETFL, O_NONBLOCK|FASYNC) &lt; 0)
-      {
-        perror("non-block");
-        return;
-      }
-
-    ROS_DEBUG("Velodyne socket fd is %d\n", sockfd_);
-  }
-
-  /** @brief destructor */
-  InputSocket::~InputSocket(void)
-  {
-    (void) close(sockfd_);
-  }
-
-  /** @brief Get one velodyne packet. */
-  int InputSocket::getPacket(velodyne_msgs::VelodynePacket *pkt, const double time_offset)
-  {
-    double time1 = ros::Time::now().toSec();
-
-    struct pollfd fds[1];
-    fds[0].fd = sockfd_;
-    fds[0].events = POLLIN;
-    static const int POLL_TIMEOUT = 1000; // one second (in msec)
-
-    sockaddr_in sender_address;
-    socklen_t sender_address_len = sizeof(sender_address);
-
-    while (true)
-      {
-        // Unfortunately, the Linux kernel recvfrom() implementation
-        // uses a non-interruptible sleep() when waiting for data,
-        // which would cause this method to hang if the device is not
-        // providing data.  We poll() the device first to make sure
-        // the recvfrom() will not block.
-        //
-        // Note, however, that there is a known Linux kernel bug:
-        //
-        //   Under Linux, select() may report a socket file descriptor
-        //   as "ready for reading", while nevertheless a subsequent
-        //   read blocks.  This could for example happen when data has
-        //   arrived but upon examination has wrong checksum and is
-        //   discarded.  There may be other circumstances in which a
-        //   file descriptor is spuriously reported as ready.  Thus it
-        //   may be safer to use O_NONBLOCK on sockets that should not
-        //   block.
-
-        // poll() until input available
-        do
-          {
-            int retval = poll(fds, 1, POLL_TIMEOUT);
-            if (retval &lt; 0)             // poll() error?
-              {
-                if (errno != EINTR)
-                  ROS_ERROR("poll() error: %s", strerror(errno));
-                return 1;
-              }
-            if (retval == 0)            // poll() timeout?
-              {
-                ROS_WARN("Velodyne poll() timeout");
-                return 1;
-              }
-            if ((fds[0].revents &amp; POLLERR)
-                || (fds[0].revents &amp; POLLHUP)
-                || (fds[0].revents &amp; POLLNVAL)) // device error?
-              {
-                ROS_ERROR("poll() reports Velodyne error");
-                return 1;
-              }
-          } while ((fds[0].revents &amp; POLLIN) == 0);
-
-        // Receive packets that should now be available from the
-        // socket using a blocking read.
-        ssize_t nbytes = recvfrom(sockfd_, &amp;pkt-&gt;data[0],
-                                  packet_size,  0,
-                                  (sockaddr*) &amp;sender_address,
-                                  &amp;sender_address_len);
-
-        if (nbytes &lt; 0)
-          {
-            if (errno != EWOULDBLOCK)
-              {
-                perror("recvfail");
-                ROS_INFO("recvfail");
-                return 1;
-              }
-          }
-        else if ((size_t) nbytes == packet_size)
-          {
-            // read successful,
-            // if packet is not from the lidar scanner we selected by IP,
-            // continue otherwise we are done
-            if(devip_str_ != ""
-               &amp;&amp; sender_address.sin_addr.s_addr != devip_.s_addr)
-              continue;
-            else
-              break; //done
-          }
-
-        ROS_DEBUG_STREAM("incomplete Velodyne packet read: "
-                         &lt;&lt; nbytes &lt;&lt; " bytes");
-      }
-
-    // Average the times at which we begin and end reading.  Use that to
-    // estimate when the scan occurred. Add the time offset.
-    double time2 = ros::Time::now().toSec();
-    pkt-&gt;stamp = ros::Time((time2 + time1) / 2.0 + time_offset);
-
-    return 0;
-  }
-
-  ////////////////////////////////////////////////////////////////////////
-  // InputPCAP class implementation
-  ////////////////////////////////////////////////////////////////////////
-
-  /** @brief constructor
-   *
-   *  @param private_nh ROS private handle for calling node.
-   *  @param port UDP port number
-   *  @param packet_rate expected device packet frequency (Hz)
-   *  @param filename PCAP dump file name
-   */
-  InputPCAP::InputPCAP(ros::NodeHandle private_nh, uint16_t port,
-                       double packet_rate, std::string filename,
-                       bool read_once, bool read_fast, double repeat_delay):
-    Input(private_nh, port),
-    packet_rate_(packet_rate),
-    filename_(filename)
-  {
-    pcap_ = NULL;  
-    empty_ = true;
-
-    // get parameters using private node handle
-    private_nh.param("read_once", read_once_, false);
-    private_nh.param("read_fast", read_fast_, false);
-    private_nh.param("repeat_delay", repeat_delay_, 0.0);
-
-    if (read_once_)
-      ROS_INFO("Read input file only once.");
-    if (read_fast_)
-      ROS_INFO("Read input file as quickly as possible.");
-    if (repeat_delay_ &gt; 0.0)
-      ROS_INFO("Delay %.3f seconds before repeating input file.",
-               repeat_delay_);
-
-    // Open the PCAP dump file
-    ROS_INFO("Opening PCAP file \"%s\"", filename_.c_str());
-    if ((pcap_ = pcap_open_offline(filename_.c_str(), errbuf_) ) == NULL)
-      {
-        ROS_FATAL("Error opening Velodyne socket dump file.");
-        return;
-      }
-
-    std::stringstream filter;
-    if( devip_str_ != "" )              // using specific IP?
-      {
-        filter &lt;&lt; "src host " &lt;&lt; devip_str_ &lt;&lt; " &amp;&amp; ";
-      }
-    filter &lt;&lt; "udp dst port " &lt;&lt; port;
-    pcap_compile(pcap_, &amp;pcap_packet_filter_,
-                 filter.str().c_str(), 1, PCAP_NETMASK_UNKNOWN);
-  }
-
-  /** destructor */
-  InputPCAP::~InputPCAP(void)
-  {
-    pcap_close(pcap_);
-  }
-
-  /** @brief Get one velodyne packet. */
-  int InputPCAP::getPacket(velodyne_msgs::VelodynePacket *pkt, const double time_offset)
-  {
-    struct pcap_pkthdr *header;
-    const u_char *pkt_data;
-
-    while (true)
-      {
-        int res;
-        if ((res = pcap_next_ex(pcap_, &amp;header, &amp;pkt_data)) &gt;= 0)
-          {
-            // Skip packets not for the correct port and from the
-            // selected IP address.
-            if (!devip_str_.empty() &amp;&amp;
-                (0 == pcap_offline_filter(&amp;pcap_packet_filter_,
-                                          header, pkt_data)))
-              continue;
-
-            // Keep the reader from blowing through the file.
-            if (read_fast_ == false)
-              packet_rate_.sleep();
-            
-            memcpy(&amp;pkt-&gt;data[0], pkt_data+42, packet_size);
-            pkt-&gt;stamp = ros::Time::now(); // time_offset not considered here, as no synchronization required
-            empty_ = false;
-            return 0;                   // success
-          }
-
-        if (empty_)                 // no data in file?
-          {
-            ROS_WARN("Error %d reading Velodyne packet: %s", 
-                     res, pcap_geterr(pcap_));
-            return -1;
-          }
-
-        if (read_once_)
-          {
-            ROS_INFO("end of file reached -- done reading.");
-            return -1;
-          }
-        
-        if (repeat_delay_ &gt; 0.0)
-          {
-            ROS_INFO("end of file reached -- delaying %.3f seconds.",
-                     repeat_delay_);
-            usleep(rint(repeat_delay_ * 1000000.0));
-          }
-
-        ROS_DEBUG("replaying Velodyne dump file");
-
-        // I can't figure out how to rewind the file, because it
-        // starts with some kind of header.  So, close the file
-        // and reopen it with pcap.
-        pcap_close(pcap_);
-        pcap_ = pcap_open_offline(filename_.c_str(), errbuf_);
-        empty_ = true;              // maybe the file disappeared?
-      } // loop back and try again
-  }
-
-} // velodyne namespace
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_laserscan\cfg\VelodyneLaserScan.cfg" new_path="" added_lines="0" deleted_lines="13">
				<diff>@@ -1,13 +0,0 @@
-#! /usr/bin/env python
- 
-PACKAGE='velodyne_laserscan'
-
-from dynamic_reconfigure.parameter_generator_catkin import *
-
-gen = ParameterGenerator()
-
-#       Name                    Type      Lvl   Description                                     Default   Min     Max
-gen.add("ring",                 int_t,    0,    "Ring to extract as laser scan (-1 default)",   -1,       -1,     31)
-gen.add("resolution",           double_t, 0,    "Laser scan angular resolution (rad)",          0.007,    0.001,  0.05)
-
-exit(gen.generate(PACKAGE, PACKAGE, "VelodyneLaserScan"))
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_laserscan\src\VelodyneLaserScan.cpp" new_path="" added_lines="0" deleted_lines="174">
				<diff>@@ -1,174 +0,0 @@
-#include "VelodyneLaserScan.h"
-#include &lt;sensor_msgs/point_cloud2_iterator.h&gt;
-
-namespace velodyne_laserscan {
-  
-VelodyneLaserScan::VelodyneLaserScan(ros::NodeHandle &amp;nh, ros::NodeHandle &amp;nh_priv) :
-    ring_count_(0), nh_(nh), srv_(nh_priv)
-{
-  ros::SubscriberStatusCallback connect_cb = boost::bind(&amp;VelodyneLaserScan::connectCb, this);
-  pub_ = nh.advertise&lt;sensor_msgs::LaserScan&gt;("scan", 10, connect_cb, connect_cb);
-  
-  srv_.setCallback(boost::bind(&amp;VelodyneLaserScan::reconfig, this, _1, _2));
-}
-
-void VelodyneLaserScan::connectCb()
-{
-  boost::lock_guard&lt;boost::mutex&gt; lock(connect_mutex_);
-  if (!pub_.getNumSubscribers()) {
-    sub_.shutdown();
-  } else if (!sub_) {
-    sub_ = nh_.subscribe("velodyne_points", 10, &amp;VelodyneLaserScan::recvCallback, this);
-  }
-}
-
-void VelodyneLaserScan::recvCallback(const sensor_msgs::PointCloud2ConstPtr&amp; msg)
-{
-  // Latch ring count
-  if (!ring_count_) {
-    // Check for PointCloud2 field 'ring'
-    bool found = false;
-    for (size_t i = 0; i &lt; msg-&gt;fields.size(); i++) {
-      if (msg-&gt;fields[i].datatype == sensor_msgs::PointField::UINT16) {
-        if (msg-&gt;fields[i].name == "ring") {
-          found = true;
-          break;
-        }
-      }
-    }
-    if (!found) {
-      ROS_ERROR("VelodyneLaserScan: Field 'ring' of type 'UINT16' not present in PointCloud2");
-      return;
-    }
-    for (sensor_msgs::PointCloud2ConstIterator&lt;uint16_t&gt; it(*msg, "ring"); it != it.end(); ++it) {
-      const uint16_t ring = *it;
-      if (ring + 1 &gt; ring_count_) {
-        ring_count_ = ring + 1;
-      }
-    }
-    if (ring_count_) {
-      ROS_INFO("VelodyneLaserScan: Latched ring count of %u", ring_count_);
-    } else {
-      ROS_ERROR("VelodyneLaserScan: Field 'ring' of type 'UINT16' not present in PointCloud2");
-      return;
-    }
-  }
-
-  // Select ring to use
-  uint16_t ring;
-  if ((cfg_.ring &lt; 0) || (cfg_.ring &gt;= ring_count_)) {
-    // Default to ring closest to being level for each known sensor
-    if (ring_count_ &gt; 32) {
-      ring = 57; // HDL-64E
-    } else if (ring_count_ &gt; 16) {
-      ring = 23; // HDL-32E
-    } else {
-      ring = 8; // VLP-16
-    }
-  } else {
-    ring = cfg_.ring;
-  }
-  ROS_INFO_ONCE("VelodyneLaserScan: Extracting ring %u", ring);
-
-  // Load structure of PointCloud2
-  int offset_x = -1;
-  int offset_y = -1;
-  int offset_z = -1;
-  int offset_i = -1;
-  int offset_r = -1;
-  for (size_t i = 0; i &lt; msg-&gt;fields.size(); i++) {
-    if (msg-&gt;fields[i].datatype == sensor_msgs::PointField::FLOAT32) {
-      if (msg-&gt;fields[i].name == "x") {
-        offset_x = msg-&gt;fields[i].offset;
-      } else if (msg-&gt;fields[i].name == "y") {
-        offset_y = msg-&gt;fields[i].offset;
-      } else if (msg-&gt;fields[i].name == "z") {
-        offset_z = msg-&gt;fields[i].offset;
-      } else if (msg-&gt;fields[i].name == "intensity") {
-        offset_i = msg-&gt;fields[i].offset;
-      }
-    } else if (msg-&gt;fields[i].datatype == sensor_msgs::PointField::UINT16) {
-      if (msg-&gt;fields[i].name == "ring") {
-        offset_r = msg-&gt;fields[i].offset;
-      }
-    }
-  }
-
-  // Construct LaserScan message
-  if ((offset_x &gt;= 0) &amp;&amp; (offset_y &gt;= 0) &amp;&amp; (offset_r &gt;= 0)) {
-    const float RESOLUTION = std::abs(cfg_.resolution);
-    const size_t SIZE = 2.0 * M_PI / RESOLUTION;
-    sensor_msgs::LaserScanPtr scan(new sensor_msgs::LaserScan());
-    scan-&gt;header = msg-&gt;header;
-    scan-&gt;angle_increment = RESOLUTION;
-    scan-&gt;angle_min = -M_PI;
-    scan-&gt;angle_max = M_PI;
-    scan-&gt;range_min = 0.0;
-    scan-&gt;range_max = 200.0;
-    scan-&gt;time_increment = 0.0;
-    scan-&gt;ranges.resize(SIZE, INFINITY);
-    if ((offset_x == 0) &amp;&amp; (offset_y == 4) &amp;&amp; (offset_z == 8) &amp;&amp; (offset_i == 16) &amp;&amp; (offset_r == 20)) {
-      scan-&gt;intensities.resize(SIZE);
-      for (sensor_msgs::PointCloud2ConstIterator&lt;float&gt; it(*msg, "x"); it != it.end(); ++it) {
-        const uint16_t r = *((const uint16_t*)(&amp;it[5])); // ring
-        if (r == ring) {
-          const float x = it[0]; // x
-          const float y = it[1]; // y
-          const float i = it[4]; // intensity
-          const int bin = (atan2f(y, x) + (float)M_PI) / RESOLUTION;
-          if ((bin &gt;= 0) &amp;&amp; (bin &lt; (int)SIZE)) {
-            scan-&gt;ranges[bin] = sqrtf(x * x + y * y);
-            scan-&gt;intensities[bin] = i;
-          }
-        }
-      }
-    } else {
-      ROS_WARN_ONCE("VelodyneLaserScan: PointCloud2 fields in unexpected order. Using slower generic method.");
-      if (offset_i &gt;= 0) {
-        scan-&gt;intensities.resize(SIZE);
-        sensor_msgs::PointCloud2ConstIterator&lt;uint16_t&gt; iter_r(*msg, "ring");
-        sensor_msgs::PointCloud2ConstIterator&lt;float&gt; iter_x(*msg, "x");
-        sensor_msgs::PointCloud2ConstIterator&lt;float&gt; iter_y(*msg, "y");
-        sensor_msgs::PointCloud2ConstIterator&lt;float&gt; iter_i(*msg, "intensity");
-        for ( ; iter_r != iter_r.end(); ++iter_x, ++iter_y, ++iter_r, ++iter_i) {
-          const uint16_t r = *iter_r; // ring
-          if (r == ring) {
-            const float x = *iter_x; // x
-            const float y = *iter_y; // y
-            const float i = *iter_i; // intensity
-            const int bin = (atan2f(y, x) + (float)M_PI) / RESOLUTION;
-            if ((bin &gt;= 0) &amp;&amp; (bin &lt; (int)SIZE)) {
-              scan-&gt;ranges[bin] = sqrtf(x * x + y * y);
-              scan-&gt;intensities[bin] = i;
-            }
-          }
-        }
-      } else {
-        sensor_msgs::PointCloud2ConstIterator&lt;uint16_t&gt; iter_r(*msg, "ring");
-        sensor_msgs::PointCloud2ConstIterator&lt;float&gt; iter_x(*msg, "x");
-        sensor_msgs::PointCloud2ConstIterator&lt;float&gt; iter_y(*msg, "y");
-        for ( ; iter_r != iter_r.end(); ++iter_x, ++iter_y, ++iter_r) {
-          const uint16_t r = *iter_r; // ring
-          if (r == ring) {
-            const float x = *iter_x; // x
-            const float y = *iter_y; // y
-            const int bin = (atan2f(y, x) + (float)M_PI) / RESOLUTION;
-            if ((bin &gt;= 0) &amp;&amp; (bin &lt; (int)SIZE)) {
-              scan-&gt;ranges[bin] = sqrtf(x * x + y * y);
-            }
-          }
-        }
-      }
-    }
-    pub_.publish(scan);
-  } else {
-    ROS_ERROR("VelodyneLaserScan: PointCloud2 missing one or more required fields! (x,y,ring)");
-  }
-}
-
-void VelodyneLaserScan::reconfig(VelodyneLaserScanConfig&amp; config, uint32_t level)
-{
-  cfg_ = config;
-}
-
-}
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_laserscan\src\VelodyneLaserScan.h" new_path="" added_lines="0" deleted_lines="39">
				<diff>@@ -1,39 +0,0 @@
-#ifndef VELODYNELASERSCAN_H
-#define VELODYNELASERSCAN_H
-
-#include &lt;ros/ros.h&gt;
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-#include &lt;sensor_msgs/LaserScan.h&gt;
-
-#include &lt;boost/thread/mutex.hpp&gt;
-#include &lt;boost/thread/lock_guard.hpp&gt;
-
-#include &lt;dynamic_reconfigure/server.h&gt;
-#include &lt;velodyne_laserscan/VelodyneLaserScanConfig.h&gt;
-
-namespace velodyne_laserscan {
-
-class VelodyneLaserScan
-{
-public:
-  VelodyneLaserScan(ros::NodeHandle &amp;nh, ros::NodeHandle &amp;nh_priv);
-
-private:
-  boost::mutex connect_mutex_;
-  void connectCb();
-  void recvCallback(const sensor_msgs::PointCloud2ConstPtr&amp; msg);
-
-  ros::NodeHandle nh_;
-  ros::Subscriber sub_;
-  ros::Publisher pub_;
-
-  VelodyneLaserScanConfig cfg_;
-  dynamic_reconfigure::Server&lt;VelodyneLaserScanConfig&gt; srv_;
-  void reconfig(VelodyneLaserScanConfig&amp; config, uint32_t level);
-
-  unsigned int ring_count_;
-};
-
-}
-
-#endif // VELODYNELASERSCAN_H
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_laserscan\src\node.cpp" new_path="" added_lines="0" deleted_lines="17">
				<diff>@@ -1,17 +0,0 @@
-#include &lt;ros/ros.h&gt;
-#include "VelodyneLaserScan.h"
-
-int main(int argc, char** argv)
-{
-  ros::init(argc, argv, "velodyne_laserscan_node");
-  ros::NodeHandle nh;
-  ros::NodeHandle nh_priv("~");
-
-  // create VelodyneLaserScan class
-  velodyne_laserscan::VelodyneLaserScan n(nh, nh_priv);
-
-  // handle callbacks until shut down
-  ros::spin();
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_laserscan\src\nodelet.cpp" new_path="" added_lines="0" deleted_lines="24">
				<diff>@@ -1,24 +0,0 @@
-#include &lt;ros/ros.h&gt;
-#include &lt;pluginlib/class_list_macros.h&gt;
-#include &lt;nodelet/nodelet.h&gt;
-#include "VelodyneLaserScan.h"
-
-namespace velodyne_laserscan
-{
-
-class LaserScanNodelet: public nodelet::Nodelet
-{
-public:
-  LaserScanNodelet() {}
-  ~LaserScanNodelet() {}
-
-private:
-  virtual void onInit() {
-    node_.reset(new VelodyneLaserScan(getNodeHandle(), getPrivateNodeHandle()));
-  }
-  boost::shared_ptr&lt;VelodyneLaserScan&gt; node_;
-};
-
-}
-
-PLUGINLIB_EXPORT_CLASS(velodyne_laserscan::LaserScanNodelet, nodelet::Nodelet);
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_laserscan\tests\lazy_subscriber.cpp" new_path="" added_lines="0" deleted_lines="90">
				<diff>@@ -1,90 +0,0 @@
-/*********************************************************************
- * C++ unit test for velodyne_laserscan
- * Verify correct handling of subscribe and unsubscribe events
- *********************************************************************/
-
-#include &lt;gtest/gtest.h&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-#include &lt;sensor_msgs/LaserScan.h&gt;
-
-// Subscriber receive callback
-void recv(const sensor_msgs::LaserScanConstPtr&amp; msg) {}
-
-// Build and publish a minimal PointCloud2 message
-void publish(const ros::Publisher &amp;pub) {
-  const uint32_t POINT_STEP = 32;
-  sensor_msgs::PointCloud2 msg;
-  msg.header.frame_id = "";
-  msg.header.stamp = ros::Time::now();
-  msg.fields.resize(5);
-  msg.fields[0].name = "x";
-  msg.fields[0].offset = 0;
-  msg.fields[0].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[0].count = 1;
-  msg.fields[1].name = "y";
-  msg.fields[1].offset = 4;
-  msg.fields[1].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[1].count = 1;
-  msg.fields[2].name = "z";
-  msg.fields[2].offset = 8;
-  msg.fields[2].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[2].count = 1;
-  msg.fields[3].name = "intensity";
-  msg.fields[3].offset = 16;
-  msg.fields[3].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[3].count = 1;
-  msg.fields[4].name = "ring";
-  msg.fields[4].offset = 20;
-  msg.fields[4].datatype = sensor_msgs::PointField::UINT16;
-  msg.fields[4].count = 1;
-  msg.data.resize(1 * POINT_STEP, 0x00);
-  msg.point_step = POINT_STEP;
-  msg.row_step = msg.data.size();
-  msg.height = 1;
-  msg.width = msg.row_step / POINT_STEP;
-  msg.is_bigendian = false;
-  msg.is_dense = true;
-  pub.publish(msg);
-}
-
-// Verify correct handling of subscribe and unsubscribe events
-TEST(Main, subscribe_unsubscribe)
-{
-  ros::NodeHandle nh;
-  ros::Publisher pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;("velodyne_points", 2);
-
-  // Wait for node to startup
-  ros::WallDuration(2.0).sleep();
-  ros::spinOnce();
-  EXPECT_EQ(0, pub.getNumSubscribers());
-
-  // Subscribe to 'scan' and expect the node to subscribe to 'velodyne_points'
-  ros::Subscriber sub = nh.subscribe("scan", 2, recv);
-  for (size_t i = 10; i &gt; 0; i--) {
-    publish(pub);
-    ros::WallDuration(0.1).sleep();
-    ros::spinOnce();
-  }
-  EXPECT_EQ(1, sub.getNumPublishers());
-  EXPECT_EQ(1, pub.getNumSubscribers());
-
-  // Unsubscribe from 'scan' and expect the node to unsubscribe from 'velodyne_points'
-  sub.shutdown();
-  for (size_t i = 10; i &gt; 0; i--) {
-    publish(pub);
-    ros::WallDuration(0.1).sleep();
-    ros::spinOnce();
-  }
-  EXPECT_EQ(0, sub.getNumPublishers());
-  EXPECT_EQ(0, pub.getNumSubscribers());
-}
-
-// Run all the tests that were declared with TEST()
-int main(int argc, char **argv)
-{
-  testing::InitGoogleTest(&amp;argc, argv);
-  ros::init(argc, argv, "test_lazy_subscriber");
-  return RUN_ALL_TESTS();
-}
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_laserscan\tests\system.cpp" new_path="" added_lines="0" deleted_lines="582">
				<diff>@@ -1,582 +0,0 @@
-/*********************************************************************
- * C++ unit test for velodyne_laserscan
- * Verify all aspects of the system
- *********************************************************************/
-
-#include &lt;gtest/gtest.h&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-#include &lt;sensor_msgs/LaserScan.h&gt;
-
-// Define our own PointCloud type for easy use
-typedef struct {
-  float x; // x
-  float y; // y
-  float z; // z
-  float i; // intensity
-  uint16_t r; // ring
-} Point;
-typedef struct {
-  std_msgs::Header header;
-  std::vector&lt;Point&gt; points;
-} PointCloud;
-
-// Global variables
-ros::Publisher g_pub;
-ros::Subscriber g_sub;
-sensor_msgs::LaserScan g_scan;
-volatile bool g_scan_new = false;
-
-// Convert WallTime to Time
-static inline ros::Time rosTime(const ros::WallTime &amp;stamp) {
-  return ros::Time(stamp.sec, stamp.nsec);
-}
-
-// Subscriber receive callback
-void recv(const sensor_msgs::LaserScanConstPtr&amp; msg) {
-  g_scan = *msg;
-  g_scan_new = true;
-}
-
-// Wait for incoming LaserScan message
-bool waitForScan(ros::WallDuration dur) {
-  const ros::WallTime start = ros::WallTime::now();
-  while (!g_scan_new) {
-    if ((ros::WallTime::now() - start) &gt; dur) {
-      return false;
-    }
-    ros::WallDuration(0.001).sleep();
-    ros::spinOnce();
-  }
-  return true;
-}
-
-// Build and publish PointCloud2 messages of various structures
-void publishXYZIR1(const PointCloud &amp;cloud) {
-  g_scan_new = false;
-  const uint32_t POINT_STEP = 32;
-  sensor_msgs::PointCloud2 msg;
-  msg.header.frame_id = cloud.header.frame_id;
-  msg.header.stamp = cloud.header.stamp;
-  msg.fields.resize(5);
-  msg.fields[0].name = "x";
-  msg.fields[0].offset = 0;
-  msg.fields[0].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[0].count = 1;
-  msg.fields[1].name = "y";
-  msg.fields[1].offset = 4;
-  msg.fields[1].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[1].count = 1;
-  msg.fields[2].name = "z";
-  msg.fields[2].offset = 8;
-  msg.fields[2].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[2].count = 1;
-  msg.fields[3].name = "intensity";
-  msg.fields[3].offset = 16;
-  msg.fields[3].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[3].count = 1;
-  msg.fields[4].name = "ring";
-  msg.fields[4].offset = 20;
-  msg.fields[4].datatype = sensor_msgs::PointField::UINT16;
-  msg.fields[4].count = 1;
-  msg.data.resize(std::max((size_t)1, cloud.points.size()) * POINT_STEP, 0x00);
-  msg.point_step = POINT_STEP;
-  msg.row_step = msg.data.size();
-  msg.height = 1;
-  msg.width = msg.row_step / POINT_STEP;
-  msg.is_bigendian = false;
-  msg.is_dense = true;
-  uint8_t *ptr = msg.data.data();
-  for (size_t i = 0; i &lt; cloud.points.size(); i++) {
-    *((float*)(ptr +  0)) = cloud.points[i].x;
-    *((float*)(ptr +  4)) = cloud.points[i].y;
-    *((float*)(ptr +  8)) = cloud.points[i].z;
-    *((float*)(ptr + 16)) = cloud.points[i].i;
-    *((uint16_t*)(ptr + 20)) = cloud.points[i].r;
-    ptr += POINT_STEP;
-  }
-  g_pub.publish(msg);
-}
-void publishXYZIR2(const PointCloud &amp;cloud) {
-  g_scan_new = false;
-  const uint32_t POINT_STEP = 19;
-  sensor_msgs::PointCloud2 msg;
-  msg.header.frame_id = cloud.header.frame_id;
-  msg.header.stamp = cloud.header.stamp;
-  msg.fields.resize(5);
-  msg.fields[0].name = "z";
-  msg.fields[0].offset = 4;
-  msg.fields[0].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[0].count = 1;
-  msg.fields[1].name = "y";
-  msg.fields[1].offset = 8;
-  msg.fields[1].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[1].count = 1;
-  msg.fields[2].name = "x";
-  msg.fields[2].offset = 12;
-  msg.fields[2].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[2].count = 1;
-  msg.fields[3].name = "intensity";
-  msg.fields[3].offset = 0;
-  msg.fields[3].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[3].count = 1;
-  msg.fields[4].name = "ring";
-  msg.fields[4].offset = 16;
-  msg.fields[4].datatype = sensor_msgs::PointField::UINT16;
-  msg.fields[4].count = 1;
-  msg.data.resize(std::max((size_t)1, cloud.points.size()) * POINT_STEP, 0x00);
-  msg.point_step = POINT_STEP;
-  msg.row_step = msg.data.size();
-  msg.height = 1;
-  msg.width = msg.row_step / POINT_STEP;
-  msg.is_bigendian = false;
-  msg.is_dense = true;
-  uint8_t *ptr = msg.data.data();
-  for (size_t i = 0; i &lt; cloud.points.size(); i++) {
-    *((float*)(ptr +  0)) = cloud.points[i].i;
-    *((float*)(ptr +  4)) = cloud.points[i].z;
-    *((float*)(ptr +  8)) = cloud.points[i].y;
-    *((float*)(ptr + 12)) = cloud.points[i].x;
-    *((uint16_t*)(ptr + 16)) = cloud.points[i].r;
-    ptr += POINT_STEP;
-  }
-  g_pub.publish(msg);
-}
-void publishXYZR(const PointCloud &amp;cloud) {
-  g_scan_new = false;
-  const uint32_t POINT_STEP = 15;
-  sensor_msgs::PointCloud2 msg;
-  msg.header.frame_id = cloud.header.frame_id;
-  msg.header.stamp = cloud.header.stamp;
-  msg.fields.resize(4);
-  msg.fields[0].name = "x";
-  msg.fields[0].offset = 0;
-  msg.fields[0].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[0].count = 1;
-  msg.fields[1].name = "y";
-  msg.fields[1].offset = 4;
-  msg.fields[1].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[1].count = 1;
-  msg.fields[2].name = "z";
-  msg.fields[2].offset = 8;
-  msg.fields[2].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[2].count = 1;
-  msg.fields[3].name = "ring";
-  msg.fields[3].offset = 12;
-  msg.fields[3].datatype = sensor_msgs::PointField::UINT16;
-  msg.fields[3].count = 1;
-  msg.data.resize(std::max((size_t)1, cloud.points.size()) * POINT_STEP, 0x00);
-  msg.point_step = POINT_STEP;
-  msg.row_step = msg.data.size();
-  msg.height = 1;
-  msg.width = msg.row_step / POINT_STEP;
-  msg.is_bigendian = false;
-  msg.is_dense = true;
-  uint8_t *ptr = msg.data.data();
-  for (size_t i = 0; i &lt; cloud.points.size(); i++) {
-    *((float*)(ptr + 0)) = cloud.points[i].x;
-    *((float*)(ptr + 4)) = cloud.points[i].y;
-    *((float*)(ptr + 8)) = cloud.points[i].z;
-    *((uint16_t*)(ptr + 12)) = cloud.points[i].r;
-    ptr += POINT_STEP;
-  }
-  g_pub.publish(msg);
-}
-void publishR(const PointCloud &amp;cloud) {
-  g_scan_new = false;
-  const uint32_t POINT_STEP = 2;
-  sensor_msgs::PointCloud2 msg;
-  msg.header.stamp = rosTime(ros::WallTime::now());
-  msg.fields.resize(1);
-  msg.fields[0].name = "ring";
-  msg.fields[0].offset = 0;
-  msg.fields[0].datatype = sensor_msgs::PointField::UINT16;
-  msg.fields[0].count = 1;
-  msg.data.resize(std::max((size_t)1, cloud.points.size()) * POINT_STEP, 0x00);
-  msg.point_step = POINT_STEP;
-  msg.row_step = msg.data.size();
-  msg.height = 1;
-  msg.width = msg.row_step / POINT_STEP;
-  uint8_t *ptr = msg.data.data();
-  for (size_t i = 0; i &lt; cloud.points.size(); i++) {
-    *((uint16_t*)(ptr + 0)) = cloud.points[i].r;
-    ptr += POINT_STEP;
-  }
-  g_pub.publish(msg);
-}
-void publishXYZR32(const PointCloud &amp;cloud) {
-  g_scan_new = false;
-  const uint32_t POINT_STEP = 16;
-  sensor_msgs::PointCloud2 msg;
-  msg.header.frame_id = cloud.header.frame_id;
-  msg.header.stamp = cloud.header.stamp;
-  msg.fields.resize(4);
-  msg.fields[0].name = "x";
-  msg.fields[0].offset = 0;
-  msg.fields[0].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[0].count = 1;
-  msg.fields[1].name = "y";
-  msg.fields[1].offset = 4;
-  msg.fields[1].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[1].count = 1;
-  msg.fields[2].name = "z";
-  msg.fields[2].offset = 8;
-  msg.fields[2].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[2].count = 1;
-  msg.fields[3].name = "ring";
-  msg.fields[3].offset = 12;
-  msg.fields[3].datatype = sensor_msgs::PointField::UINT32;
-  msg.fields[3].count = 1;
-  msg.data.resize(std::max((size_t)1, cloud.points.size()) * POINT_STEP, 0x00);
-  msg.point_step = POINT_STEP;
-  msg.row_step = msg.data.size();
-  msg.height = 1;
-  msg.width = msg.row_step / POINT_STEP;
-  msg.is_bigendian = false;
-  msg.is_dense = true;
-  uint8_t *ptr = msg.data.data();
-  for (size_t i = 0; i &lt; cloud.points.size(); i++) {
-    *((float*)(ptr + 0)) = cloud.points[i].x;
-    *((float*)(ptr + 4)) = cloud.points[i].y;
-    *((float*)(ptr + 8)) = cloud.points[i].z;
-    *((uint32_t*)(ptr + 12)) = cloud.points[i].r;
-    ptr += POINT_STEP;
-  }
-  g_pub.publish(msg);
-}
-void publishXYZ(const PointCloud &amp;cloud) {
-  g_scan_new = false;
-  const uint32_t POINT_STEP = 12;
-  sensor_msgs::PointCloud2 msg;
-  msg.header.stamp = rosTime(ros::WallTime::now());
-  msg.fields.resize(3);
-  msg.fields[0].name = "x";
-  msg.fields[0].offset = 0;
-  msg.fields[0].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[0].count = 1;
-  msg.fields[1].name = "y";
-  msg.fields[1].offset = 4;
-  msg.fields[1].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[1].count = 1;
-  msg.fields[2].name = "z";
-  msg.fields[2].offset = 8;
-  msg.fields[2].datatype = sensor_msgs::PointField::FLOAT32;
-  msg.fields[2].count = 1;
-  msg.data.resize(std::max((size_t)1, cloud.points.size()) * POINT_STEP, 0x00);
-  msg.point_step = POINT_STEP;
-  msg.row_step = msg.data.size();
-  msg.height = 1;
-  msg.width = msg.row_step / POINT_STEP;
-  uint8_t *ptr = msg.data.data();
-  for (size_t i = 0; i &lt; cloud.points.size(); i++) {
-    *((float*)(ptr + 0)) = cloud.points[i].x;
-    *((float*)(ptr + 4)) = cloud.points[i].y;
-    *((float*)(ptr + 8)) = cloud.points[i].z;
-    ptr += POINT_STEP;
-  }
-  g_pub.publish(msg);
-}
-void publishNone() {
-  g_scan_new = false;
-  const uint32_t POINT_STEP = 16;
-  sensor_msgs::PointCloud2 msg;
-  msg.header.stamp = rosTime(ros::WallTime::now());
-  msg.data.resize(1 * POINT_STEP, 0x00);
-  msg.point_step = POINT_STEP;
-  msg.row_step = msg.data.size();
-  msg.height = 1;
-  msg.width = msg.row_step / POINT_STEP;
-  g_pub.publish(msg);
-}
-
-// Find the index of the point in the PointCloud with the shortest 2d distance to the point (x,y)
-static inline float SQUARE(float x) { return x * x; }
-size_t findClosestIndex(const PointCloud &amp;cloud, uint16_t ring, float x, float y) {
-  size_t index = SIZE_MAX;
-  float delta = INFINITY;
-  for (size_t i = 0; i &lt; cloud.points.size(); i++) {
-    if (cloud.points[i].r == ring) {
-      float dist = SQUARE(x - cloud.points[i].x) + SQUARE(y - cloud.points[i].y);
-      if (dist &lt; delta) {
-        delta = dist;
-        index = i;
-      }
-    }
-  }
-  return index;
-}
-
-// Verify that all LaserScan header values are values are passed through, and other values are default
-void verifyScanEmpty(const PointCloud &amp;cloud, bool intensity = true) {
-  ASSERT_EQ(cloud.header.stamp, g_scan.header.stamp);
-  EXPECT_EQ(cloud.header.frame_id, g_scan.header.frame_id);
-  for (size_t i = 0; i &lt; g_scan.ranges.size(); i++) {
-    EXPECT_EQ(INFINITY, g_scan.ranges[i]);
-  }
-  if (!intensity) {
-    EXPECT_EQ(0, g_scan.intensities.size());
-  } else {
-    EXPECT_EQ(g_scan.ranges.size(), g_scan.intensities.size());
-    for (size_t i = 0; i &lt; g_scan.intensities.size(); i++) {
-      EXPECT_EQ(0.0, g_scan.intensities[i]);
-    }
-  }
-}
-
-// Verify that every PointCloud point made it to the LaserScan and other values are default
-void verifyScanSparse(const PointCloud &amp;cloud, uint16_t ring, uint16_t ring_count, bool intensity = true) {
-  ASSERT_EQ(cloud.header.stamp, g_scan.header.stamp);
-  EXPECT_EQ(cloud.header.frame_id, g_scan.header.frame_id);
-  EXPECT_EQ(intensity ? g_scan.ranges.size() : 0, g_scan.intensities.size());
-  size_t count = 0;
-  for (size_t i = 0; i &lt; g_scan.ranges.size(); i++) {
-    double r = g_scan.ranges[i];
-    if (std::isfinite(r)) {
-      float a = g_scan.angle_min + i * g_scan.angle_increment;
-      float x = g_scan.ranges[i] * cosf(a);
-      float y = g_scan.ranges[i] * sinf(a);
-      float e = g_scan.ranges[i] * g_scan.angle_increment + (float)1e-3; // allowable error
-      size_t index = findClosestIndex(cloud, ring, x, y);
-      if (index &lt; cloud.points.size()) {
-        count++;
-        EXPECT_NEAR(cloud.points[index].x, x, e);
-        EXPECT_NEAR(cloud.points[index].y, y, e);
-        if (i &lt; g_scan.intensities.size()) {
-          EXPECT_EQ(cloud.points[index].i, g_scan.intensities[i]);
-        }
-      } else {
-        EXPECT_TRUE(false); // LaserScan point not found in PointCloud
-      }
-    } else {
-      EXPECT_EQ(INFINITY, r);
-    }
-  }
-  if (ring_count &gt; 0) {
-    EXPECT_EQ(cloud.points.size() / ring_count, count); // Make sure that all points were converted to ranges
-  }
-}
-
-// Verify that every LaserScan point is not default, and every point came from the PointCloud
-void verifyScanDense(const PointCloud &amp;cloud, uint16_t ring, bool intensity = true) {
-  ASSERT_EQ(cloud.header.stamp, g_scan.header.stamp);
-  EXPECT_EQ(cloud.header.frame_id, g_scan.header.frame_id);
-  EXPECT_EQ(intensity ? g_scan.ranges.size() : 0, g_scan.intensities.size());
-  for (size_t i = 0; i &lt; g_scan.ranges.size(); i++) {
-    double r = g_scan.ranges[i];
-    if (std::isfinite(r)) {
-      float a = g_scan.angle_min + i * g_scan.angle_increment;
-      float x = g_scan.ranges[i] * cosf(a);
-      float y = g_scan.ranges[i] * sinf(a);
-      float e = g_scan.ranges[i] * g_scan.angle_increment + (float)1e-3; // allowable error
-      size_t index = findClosestIndex(cloud, ring, x, y);
-      if (index &lt; cloud.points.size()) {
-        EXPECT_NEAR(cloud.points[index].x, x, e);
-        EXPECT_NEAR(cloud.points[index].y, y, e);
-        ///@TODO: Test for matching intensity
-      } else {
-        EXPECT_TRUE(false); // LaserScan point not found in PointCloud
-      }
-    } else {
-      EXPECT_TRUE(false); // Dense PointCloud should populate every range in LaserScan
-    }
-  }
-}
-
-// Verify that no LaserScan is generated when the PointCloud2 message is missing required fields
-TEST(System, missing_fields)
-{
-  // Make sure system is connected
-  ASSERT_EQ(1, g_sub.getNumPublishers());
-  ASSERT_EQ(1, g_pub.getNumSubscribers());
-
-  // Create PointCloud with 16 rings
-  PointCloud cloud;
-  cloud.points.resize(1);
-  cloud.points[0].x = 0.0;
-  cloud.points[0].y = 0.0;
-  cloud.points[0].z = 0.0;
-  cloud.points[0].i = 0.0;
-  cloud.points[0].r = 15;
-
-  // Verify no LaserScan when PointCloud2 fields are empty
-  publishNone();
-  EXPECT_FALSE(waitForScan(ros::WallDuration(0.5)));
-
-  // Verify no LaserScan when PointCloud2 fields are missing 'ring'
-  publishXYZ(cloud);
-  EXPECT_FALSE(waitForScan(ros::WallDuration(0.5)));
-
-  // Verify no LaserScan when PointCloud2 field 'ring' is the incorrect type
-  publishXYZR32(cloud);
-  EXPECT_FALSE(waitForScan(ros::WallDuration(0.5)));
-
-
-  // Verify no LaserScan when PointCloud2 fields are missing 'x' and 'y'
-  publishR(cloud);
-  EXPECT_FALSE(waitForScan(ros::WallDuration(0.5)));
-
-  // Verify that the node hasn't crashed by sending normal PointCloud2 fields
-  cloud.header.stamp = rosTime(ros::WallTime::now());
-  publishXYZIR1(cloud);
-  ASSERT_TRUE(waitForScan(ros::WallDuration(1.0)));
-  ASSERT_EQ(cloud.header.stamp, g_scan.header.stamp);
-}
-
-// Verify that non-point fields are passed through unmodified
-TEST(System, empty_data)
-{
-  // Make sure system is connected
-  ASSERT_EQ(1, g_sub.getNumPublishers());
-  ASSERT_EQ(1, g_pub.getNumSubscribers());
-
-  // Create PointCloud with 16 rings
-  PointCloud cloud;
-  cloud.header.frame_id = "abcdefghijklmnopqrstuvwxyz";
-  cloud.points.resize(1);
-  cloud.points[0].x = 0.0;
-  cloud.points[0].y = 0.0;
-  cloud.points[0].z = 0.0;
-  cloud.points[0].i = 0.0;
-  cloud.points[0].r = 15;
-
-  // Verify that all three PointCloud2 types create proper default values
-
-  // PointXYZIR (expected format)
-  cloud.header.stamp = rosTime(ros::WallTime::now());
-  publishXYZIR1(cloud);
-  ASSERT_TRUE(waitForScan(ros::WallDuration(1.0)));
-  verifyScanEmpty(cloud, true);
-
-  // PointXYZIR (unexpected format with intensity)
-  cloud.header.stamp = rosTime(ros::WallTime::now());
-  publishXYZIR2(cloud);
-  ASSERT_TRUE(waitForScan(ros::WallDuration(1.0)));
-  verifyScanEmpty(cloud, true);
-
-  // PointXYZR (unexpected format without intensity)
-  cloud.header.stamp = rosTime(ros::WallTime::now());
-  publishXYZR(cloud);
-  ASSERT_TRUE(waitForScan(ros::WallDuration(1.0)));
-  verifyScanEmpty(cloud, false);
-}
-
-// Verify that every piece of a small amount of random data is passed through
-TEST(System, random_data_sparse)
-{
-  // Make sure system is connected
-  ASSERT_EQ(1, g_sub.getNumPublishers());
-  ASSERT_EQ(1, g_pub.getNumSubscribers());
-
-  // Create PointCloud with sparse random data
-  PointCloud cloud;
-  cloud.header.frame_id = "velodyne";
-  const size_t RANGE_COUNT = 100;
-  const size_t RING_COUNT = 16;
-  const double RANGE_MAX = 20.0;
-  const double INTENSITY_MAX = 1.0;
-  for (size_t i = 0; i &lt; RANGE_COUNT; i++) {
-    double angle_y = i * 1.99 * M_PI / RANGE_COUNT; // yaw
-    for (size_t j = 0; j &lt; RING_COUNT; j++) {
-      double angle_p = j * 0.2 * M_PI / RING_COUNT - 0.1 * M_PI; // pitch
-      double range = rand() * (RANGE_MAX / RAND_MAX);
-      Point point;
-      point.x = range * cos(angle_p) * cos(angle_y);
-      point.y = range * cos(angle_p) * sin(angle_y);
-      point.z = range * sin(angle_p);
-      point.i = rand() * (INTENSITY_MAX / RAND_MAX);
-      point.r = j;
-      cloud.points.push_back(point);
-    }
-  }
-
-  // Verify that all three PointCloud2 types are handled correctly
-
-  // PointXYZIR (expected format)
-  cloud.header.stamp = rosTime(ros::WallTime::now());
-  publishXYZIR1(cloud);
-  ASSERT_TRUE(waitForScan(ros::WallDuration(1.0)));
-  verifyScanSparse(cloud, 8, RING_COUNT, true);
-
-  // PointXYZIR (unexpected format with intensity)
-  cloud.header.stamp = rosTime(ros::WallTime::now());
-  publishXYZIR2(cloud);
-  ASSERT_TRUE(waitForScan(ros::WallDuration(1.0)));
-  verifyScanSparse(cloud, 8, RING_COUNT, true);
-
-  // PointXYZR (unexpected format without intensity)
-  cloud.header.stamp = rosTime(ros::WallTime::now());
-  publishXYZR(cloud);
-  ASSERT_TRUE(waitForScan(ros::WallDuration(1.0)));
-  verifyScanSparse(cloud, 8, RING_COUNT, false);
-}
-
-// Verify that every LaserScan range is valid when given an extra large amount of random data
-TEST(System, random_data_dense)
-{
-  // Make sure system is connected
-  ASSERT_EQ(1, g_sub.getNumPublishers());
-  ASSERT_EQ(1, g_pub.getNumSubscribers());
-
-  // Create PointCloud with dense random data
-  PointCloud cloud;
-  cloud.header.frame_id = "velodyne";
-  const size_t RANGE_COUNT = 2500;
-  const size_t RING_COUNT = 16;
-  const double RANGE_MAX = 20.0;
-  const double INTENSITY_MAX = 1.0;
-  for (size_t i = 0; i &lt; RANGE_COUNT; i++) {
-    double angle_y = i * 2.0 * M_PI / RANGE_COUNT; // yaw
-    for (size_t j = 0; j &lt; RING_COUNT; j++) {
-      double angle_p = j * 0.2 * M_PI / RING_COUNT - 0.1 * M_PI; // pitch
-      double range = rand() * (RANGE_MAX / RAND_MAX);
-      Point point;
-      point.x = range * cos(angle_p) * cos(angle_y);
-      point.y = range * cos(angle_p) * sin(angle_y);
-      point.z = range * sin(angle_p);
-      point.i = rand() * (INTENSITY_MAX / RAND_MAX);
-      point.r = j;
-      cloud.points.push_back(point);
-    }
-  }
-
-  // Verify that all three PointCloud2 types are handled correctly
-
-  // PointXYZIR (expected format)
-  cloud.header.stamp = rosTime(ros::WallTime::now());
-  publishXYZIR1(cloud);
-  ASSERT_TRUE(waitForScan(ros::WallDuration(1.0)));
-  verifyScanDense(cloud, 8, true);
-
-  // PointXYZIR (unexpected format with intensity)
-  cloud.header.stamp = rosTime(ros::WallTime::now());
-  publishXYZIR2(cloud);
-  ASSERT_TRUE(waitForScan(ros::WallDuration(1.0)));
-  verifyScanDense(cloud, 8, true);
-
-  // PointXYZR (unexpected format without intensity)
-  cloud.header.stamp = rosTime(ros::WallTime::now());
-  publishXYZR(cloud);
-  ASSERT_TRUE(waitForScan(ros::WallDuration(1.0)));
-  verifyScanDense(cloud, 8, false);
-}
-
-int main(int argc, char **argv)
-{
-  testing::InitGoogleTest(&amp;argc, argv);
-
-  // Initialize ROS
-  ros::init(argc, argv, "test_lazy_subscriber");
-  ros::NodeHandle nh;
-
-  // Setup publisher and subscriber
-  g_pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;("velodyne_points", 2);
-  g_sub = nh.subscribe("scan", 2, recv);
-
-  // Wait for other nodes to startup
-  ros::WallDuration(1.0).sleep();
-  ros::spinOnce();
-
-  // Run all the tests that were declared with TEST()
-  return RUN_ALL_TESTS();
-}
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\cfg\CloudNode.cfg" new_path="" added_lines="0" deleted_lines="16">
				<diff>@@ -1,16 +0,0 @@
-#!/usr/bin/env python
-PACKAGE = "velodyne_pointcloud"
-
-from math import pi
-from dynamic_reconfigure.parameter_generator_catkin import *
-
-gen = ParameterGenerator()
-
-gen.add("min_range", double_t, 0, "min range to publish", 0.9, 0.1, 10.0)
-gen.add("max_range", double_t, 0, "max range to publish", 130, 0.1, 200)
-gen.add("view_direction", double_t, 0, "angle defining the center of view",
-        0.0, -pi, pi)
-gen.add("view_width", double_t, 0, "angle defining the view width",
-        2*pi, 0.0, 2*pi)
-
-exit(gen.generate(PACKAGE, "cloud_node", "CloudNode"))
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\cfg\TransformNode.cfg" new_path="" added_lines="0" deleted_lines="39">
				<diff>@@ -1,39 +0,0 @@
-#!/usr/bin/env python
-PACKAGE = "velodyne_pointcloud"
-
-from math import pi
-import dynamic_reconfigure.parameter_generator_catkin as pgc
-
-gen = pgc.ParameterGenerator()
-
-gen.add("min_range", 
-  pgc.double_t, 
-  0, 
-  "min range to publish", 
-  0.9, 0.1, 10.0)
-  
-gen.add("max_range", 
-  pgc.double_t, 
-  0, 
-  "max range to publish", 
-  130, 0.1, 200)
-  
-gen.add("view_direction", 
-  pgc.double_t, 
-  0, 
-  "angle defining the center of view",
-  0.0, -pi, pi)
-  
-gen.add("view_width", 
-  pgc.double_t, 
-  0, 
-  "angle defining the view width",
-  2*pi, 0.0, 2*pi)
-  
-gen.add("frame_id", 
-  pgc.str_t, 
-  0, 
-  "new frame of reference for point clouds", 
-  "odom")
-
-exit(gen.generate(PACKAGE, "transform_node", "TransformNode"))
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\include\velodyne_pointcloud\calibration.h" new_path="" added_lines="0" deleted_lines="84">
				<diff>@@ -1,84 +0,0 @@
-/**
- * \file  calibration.h 
- *
- * \author  Piyush Khandelwal (piyushk@cs.utexas.edu)
- * Copyright (C) 2012, Austin Robot Technology, University of Texas at Austin
- *
- * License: Modified BSD License
- *
- * $ Id: 02/14/2012 11:25:34 AM piyushk $
- */
-
-#ifndef __VELODYNE_CALIBRATION_H
-#define __VELODYNE_CALIBRATION_H
-
-#include &lt;map&gt;
-#include &lt;string&gt;
-
-namespace velodyne_pointcloud {
-
-  /** \brief correction values for a single laser
-   *
-   * Correction values for a single laser (as provided by db.xml from
-   * Velodyne).  Includes parameters for Velodyne HDL-64E S2.1.
-   *
-   * http://velodynelidar.com/lidar/products/manual/63-HDL64E%20S2%20Manual_Rev%20D_2011_web.pdf
-   */
-
-  /** \brief Correction information for a single laser. */
-  struct LaserCorrection {
-
-    /** parameters in db.xml */
-    float rot_correction;
-    float vert_correction;
-    float dist_correction;
-    bool two_pt_correction_available;
-    float dist_correction_x;
-    float dist_correction_y;
-    float vert_offset_correction;
-    float horiz_offset_correction;
-    int max_intensity;
-    int min_intensity;
-    float focal_distance;
-    float focal_slope;
-
-    /** cached values calculated when the calibration file is read */
-    float cos_rot_correction;              ///&lt; cosine of rot_correction
-    float sin_rot_correction;              ///&lt; sine of rot_correction
-    float cos_vert_correction;             ///&lt; cosine of vert_correction
-    float sin_vert_correction;             ///&lt; sine of vert_correction
-
-    int laser_ring;                        ///&lt; ring number for this laser
-  };
-
-  /** \brief Calibration information for the entire device. */
-  class Calibration {
-
-  public:
-
-    std::map&lt;int, LaserCorrection&gt; laser_corrections;
-    int num_lasers;
-    bool initialized;
-    bool ros_info;
-
-  public:
-
-    Calibration(bool info=true):
-      initialized(false), ros_info(info) {}
-    Calibration(const std::string&amp; calibration_file,
-                bool info=true):
-      ros_info(info)
-    {
-      read(calibration_file);
-    }
-
-    void read(const std::string&amp; calibration_file);
-    void write(const std::string&amp; calibration_file);
-  };
-  
-} /* velodyne_pointcloud */
-
-
-#endif /* end of include guard: __VELODYNE_CALIBRATION_H */
-
-
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\include\velodyne_pointcloud\point_types.h" new_path="" added_lines="0" deleted_lines="46">
				<diff>@@ -1,46 +0,0 @@
-/* -*- mode: C++ -*-
- *
- *  Copyright (C) 2011, 2012 Austin Robot Technology
- *
- *  License: Modified BSD Software License Agreement
- *
- *  $Id: data_base.h 1554 2011-06-14 22:11:17Z jack.oquin $
- */
-
-/** \file
- *
- *  Point Cloud Library point structures for Velodyne data.
- *
- *  @author Jesse Vera
- *  @author Jack O'Quin
- *  @author Piyush Khandelwal
- */
-
-#ifndef __VELODYNE_POINTCLOUD_POINT_TYPES_H
-#define __VELODYNE_POINTCLOUD_POINT_TYPES_H
-
-#include &lt;pcl/point_types.h&gt;
-
-namespace velodyne_pointcloud
-{
-  /** Euclidean Velodyne coordinate, including intensity and ring number. */
-  struct PointXYZIR
-  {
-    PCL_ADD_POINT4D;                    // quad-word XYZ
-    float    intensity;                 ///&lt; laser intensity reading
-    uint16_t ring;                      ///&lt; laser ring number
-    EIGEN_MAKE_ALIGNED_OPERATOR_NEW     // ensure proper alignment
-  } EIGEN_ALIGN16;
-
-}; // namespace velodyne_pointcloud
-
-
-POINT_CLOUD_REGISTER_POINT_STRUCT(velodyne_pointcloud::PointXYZIR,
-                                  (float, x, x)
-                                  (float, y, y)
-                                  (float, z, z)
-                                  (float, intensity, intensity)
-                                  (uint16_t, ring, ring))
-
-#endif // __VELODYNE_POINTCLOUD_POINT_TYPES_H
-
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\include\velodyne_pointcloud\rawdata.h" new_path="" added_lines="0" deleted_lines="189">
				<diff>@@ -1,189 +0,0 @@
-/* -*- mode: C++ -*-
- *
- *  Copyright (C) 2007 Austin Robot Technology, Yaxin Liu, Patrick Beeson
- *  Copyright (C) 2009, 2010, 2012 Austin Robot Technology, Jack O'Quin
- *
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
- *
- *  @brief Interfaces for interpreting raw packets from the Velodyne 3D LIDAR.
- *
- *  @author Yaxin Liu
- *  @author Patrick Beeson
- *  @author Jack O'Quin
- */
-
-#ifndef __VELODYNE_RAWDATA_H
-#define __VELODYNE_RAWDATA_H
-
-#include &lt;errno.h&gt;
-#include &lt;stdint.h&gt;
-#include &lt;string&gt;
-#include &lt;boost/format.hpp&gt;
-#include &lt;math.h&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;pcl_ros/point_cloud.h&gt;
-#include &lt;velodyne_msgs/VelodyneScan.h&gt;
-#include &lt;velodyne_pointcloud/point_types.h&gt;
-#include &lt;velodyne_pointcloud/calibration.h&gt;
-
-namespace velodyne_rawdata
-{
-  // Shorthand typedefs for point cloud representations
-  typedef velodyne_pointcloud::PointXYZIR VPoint;
-  typedef pcl::PointCloud&lt;VPoint&gt; VPointCloud;
-
-  /**
-   * Raw Velodyne packet constants and structures.
-   */
-  static const int SIZE_BLOCK = 100;
-  static const int RAW_SCAN_SIZE = 3;
-  static const int SCANS_PER_BLOCK = 32;
-  static const int BLOCK_DATA_SIZE = (SCANS_PER_BLOCK * RAW_SCAN_SIZE);
-
-  static const float ROTATION_RESOLUTION      =     0.01f;  // [deg]
-  static const uint16_t ROTATION_MAX_UNITS    = 36000u;     // [deg/100]
-  static const float DISTANCE_RESOLUTION      =     0.002f; // [m]
-
-  /** @todo make this work for both big and little-endian machines */
-  static const uint16_t UPPER_BANK = 0xeeff;
-  static const uint16_t LOWER_BANK = 0xddff;
-  
-  
-  /** Special Defines for VLP16 support **/
-  static const int    VLP16_FIRINGS_PER_BLOCK =   2;
-  static const int    VLP16_SCANS_PER_FIRING  =  16;
-  static const float  VLP16_BLOCK_TDURATION   = 110.592f;   // [s]
-  static const float  VLP16_DSR_TOFFSET       =   2.304f;   // [s]
-  static const float  VLP16_FIRING_TOFFSET    =  55.296f;   // [s]
-  
-
-  /** \brief Raw Velodyne data block.
-   *
-   *  Each block contains data from either the upper or lower laser
-   *  bank.  The device returns three times as many upper bank blocks.
-   *
-   *  use stdint.h types, so things work with both 64 and 32-bit machines
-   */
-  typedef struct raw_block
-  {
-    uint16_t header;        ///&lt; UPPER_BANK or LOWER_BANK
-    uint16_t rotation;      ///&lt; 0-35999, divide by 100 to get degrees
-    uint8_t  data[BLOCK_DATA_SIZE];
-  } raw_block_t;
-
-  /** used for unpacking the first two data bytes in a block
-   *
-   *  They are packed into the actual data stream misaligned.  I doubt
-   *  this works on big endian machines.
-   */
-  union two_bytes
-  {
-    uint16_t uint;
-    uint8_t  bytes[2];
-  };
-
-  static const int PACKET_SIZE = 1206;
-  static const int BLOCKS_PER_PACKET = 12;
-  static const int PACKET_STATUS_SIZE = 4;
-  static const int SCANS_PER_PACKET = (SCANS_PER_BLOCK * BLOCKS_PER_PACKET);
-
-  /** \brief Raw Velodyne packet.
-   *
-   *  revolution is described in the device manual as incrementing
-   *    (mod 65536) for each physical turn of the device.  Our device
-   *    seems to alternate between two different values every third
-   *    packet.  One value increases, the other decreases.
-   *
-   *  \todo figure out if revolution is only present for one of the
-   *  two types of status fields
-   *
-   *  status has either a temperature encoding or the microcode level
-   */
-  typedef struct raw_packet
-  {
-    raw_block_t blocks[BLOCKS_PER_PACKET];
-    uint16_t revolution;
-    uint8_t status[PACKET_STATUS_SIZE]; 
-  } raw_packet_t;
-
-  /** \brief Velodyne data conversion class */
-  class RawData
-  {
-  public:
-
-    RawData();
-    ~RawData() {}
-
-    /** \brief Set up for data processing.
-     *
-     *  Perform initializations needed before data processing can
-     *  begin:
-     *
-     *    - read device-specific angles calibration
-     *
-     *  @param private_nh private node handle for ROS parameters
-     *  @returns 0 if successful;
-     *           errno value for failure
-     */
-    int setup(ros::NodeHandle private_nh);
-
-    /** \brief Set up for data processing offline. 
-      * Performs the same initialization as in setup, in the abscence of a ros::NodeHandle.
-      * this method is useful if unpacking data directly from bag files, without passing 
-      * through a communication overhead.
-      * 
-      * @param calibration_file path to the calibration file
-      * @param max_range_ cutoff for maximum range
-      * @param min_range_ cutoff for minimum range
-      * @returns 0 if successful;
-      *           errno value for failure
-     */
-    int setupOffline(std::string calibration_file, double max_range_, double min_range_);
-
-    void unpack(const velodyne_msgs::VelodynePacket &amp;pkt, VPointCloud &amp;pc, int packets_num);
-    
-    void setParameters(double min_range, double max_range, double view_direction,
-                       double view_width);
-
-  private:
-
-    /** configuration parameters */
-    typedef struct {
-      std::string calibrationFile;     ///&lt; calibration file name
-      double max_range;                ///&lt; maximum range to publish
-      double min_range;                ///&lt; minimum range to publish
-      int min_angle;                   ///&lt; minimum angle to publish
-      int max_angle;                   ///&lt; maximum angle to publish
-      
-      double tmp_min_angle;
-      double tmp_max_angle;
-    } Config;
-    Config config_;
-
-    /** 
-     * Calibration file
-     */
-    velodyne_pointcloud::Calibration calibration_;
-    float sin_rot_table_[ROTATION_MAX_UNITS];
-    float cos_rot_table_[ROTATION_MAX_UNITS];
-    
-    /** add private function to handle the VLP16 **/ 
-    void unpack_vlp16(const velodyne_msgs::VelodynePacket &amp;pkt, VPointCloud &amp;pc);
-
-    /** in-line test whether a point is in range */
-    bool pointInRange(float range)
-    {
-      return (range &gt;= config_.min_range
-              &amp;&amp; range &lt;= config_.max_range);
-    }
-  };
-
-} // namespace velodyne_rawdata
-
-#endif // __VELODYNE_RAWDATA_H
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\cloud_node.cc" new_path="" added_lines="0" deleted_lines="31">
				<diff>@@ -1,31 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
-
-    This ROS node converts raw Velodyne LIDAR packets to PointCloud2.
-
-*/
-
-#include &lt;ros/ros.h&gt;
-#include "convert.h"
-
-/** Main node entry point. */
-int main(int argc, char **argv)
-{
-  ros::init(argc, argv, "cloud_node");
-  ros::NodeHandle node;
-  ros::NodeHandle priv_nh("~");
-
-  // create conversion class, which subscribes to raw data
-  velodyne_pointcloud::Convert conv(node, priv_nh);
-
-  // handle callbacks until shut down
-  ros::spin();
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\cloud_nodelet.cc" new_path="" added_lines="0" deleted_lines="48">
				<diff>@@ -1,48 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This ROS nodelet converts raw Velodyne 3D LIDAR packets to a
-    PointCloud2.
-
-*/
-
-#include &lt;ros/ros.h&gt;
-#include &lt;pluginlib/class_list_macros.h&gt;
-#include &lt;nodelet/nodelet.h&gt;
-
-#include "convert.h"
-
-namespace velodyne_pointcloud
-{
-  class CloudNodelet: public nodelet::Nodelet
-  {
-  public:
-
-    CloudNodelet() {}
-    ~CloudNodelet() {}
-
-  private:
-
-    virtual void onInit();
-    boost::shared_ptr&lt;Convert&gt; conv_;
-  };
-
-  /** @brief Nodelet initialization. */
-  void CloudNodelet::onInit()
-  {
-    conv_.reset(new Convert(getNodeHandle(), getPrivateNodeHandle()));
-  }
-
-} // namespace velodyne_pointcloud
-
-
-// Register this plugin with pluginlib.  Names must match nodelets.xml.
-//
-// parameters: class type, base class type
-PLUGINLIB_EXPORT_CLASS(velodyne_pointcloud::CloudNodelet, nodelet::Nodelet)
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\colors.cc" new_path="" added_lines="0" deleted_lines="93">
				<diff>@@ -1,93 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    Implementation for converting a Velodyne 3D LIDAR PointXYZIR cloud
-    to PointXYZRGB, assigning colors for visualization of the laser
-    rings.
-
-    @author Jack O'Quin
-*/
-
-#include "colors.h"
-#include &lt;velodyne_pointcloud/point_types.h&gt;
-
-/// @todo make sure these includes are really necessary
-#include &lt;pcl/io/pcd_io.h&gt;
-#include &lt;pcl/point_cloud.h&gt;
-
-namespace
-{
-  // RGB color values
-  const int color_red =       0xff0000;
-  const int color_orange =    0xff8800;
-  const int color_yellow =    0xffff00;
-  const int color_green =     0x00ff00;
-  const int color_blue =      0x0000ff;
-  const int color_violet =    0xff00ff;
-
-  const int N_COLORS = 6;
-  int rainbow[N_COLORS] = {color_red, color_orange, color_yellow,
-                           color_green, color_blue, color_violet};
-}
-
-namespace velodyne_pointcloud
-{
-
-  /** types of output point and cloud */
-  typedef pcl::PointXYZRGB RGBPoint;
-  typedef pcl::PointCloud&lt;RGBPoint&gt; RGBPointCloud;
-
-  /** @brief Constructor. */
-  RingColors::RingColors(ros::NodeHandle node, ros::NodeHandle private_nh)
-  {
-    // advertise output point cloud (before subscribing to input data)
-    output_ =
-      node.advertise&lt;sensor_msgs::PointCloud2&gt;("velodyne_rings", 10);
-
-    // subscribe to VelodyneScan packets
-    input_ =
-      node.subscribe("velodyne_points", 10,
-                     &amp;RingColors::convertPoints, this,
-                     ros::TransportHints().tcpNoDelay(true));
-  }
-
-
-  /** @brief Callback for Velodyne PointXYZRI messages. */
-  void
-    RingColors::convertPoints(const VPointCloud::ConstPtr &amp;inMsg)
-  {
-    if (output_.getNumSubscribers() == 0)         // no one listening?
-      return;                                     // do nothing
-
-    // allocate an PointXYZRGB message with same time and frame ID as
-    // input data
-    RGBPointCloud::Ptr outMsg(new RGBPointCloud());
-    outMsg-&gt;header.stamp = inMsg-&gt;header.stamp;
-    outMsg-&gt;header.frame_id = inMsg-&gt;header.frame_id;
-    outMsg-&gt;height = 1;
-
-    for (size_t i = 0; i &lt; inMsg-&gt;points.size(); ++i)
-      {
-        RGBPoint p;
-        p.x = inMsg-&gt;points[i].x;
-        p.y = inMsg-&gt;points[i].y;
-        p.z = inMsg-&gt;points[i].z;
-
-        // color lasers with the rainbow array
-        int color = inMsg-&gt;points[i].ring % N_COLORS;
-        p.rgb = *reinterpret_cast&lt;float*&gt;(rainbow+color);
-
-        outMsg-&gt;points.push_back(p);
-        ++outMsg-&gt;width;
-      }
-
-    output_.publish(outMsg);
-  }
-
-} // namespace velodyne_pcl
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\colors.h" new_path="" added_lines="0" deleted_lines="49">
				<diff>@@ -1,49 +0,0 @@
-/* -*- mode: C++ -*- */
-/*
- *  Copyright (C) 2012 Austin Robot Technology
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    Interface for converting a Velodyne 3D LIDAR PointXYZIR cloud to
-    PointXYZRGB, assigning colors for visualization of the laser
-    rings.
-
-    @author Jack O'Quin
-*/
-
-#ifndef _VELODYNE_POINTCLOUD_COLORS_H_
-#define _VELODYNE_POINTCLOUD_COLORS_H_
-
-#include &lt;ros/ros.h&gt;
-#include &lt;pcl_ros/point_cloud.h&gt;
-#include &lt;pcl/point_types.h&gt;
-#include &lt;velodyne_pointcloud/point_types.h&gt;
-
-namespace velodyne_pointcloud
-{
-  // shorter names for point cloud types in this namespace
-  typedef velodyne_pointcloud::PointXYZIR VPoint;
-  typedef pcl::PointCloud&lt;VPoint&gt; VPointCloud;
-
-  class RingColors
-  {
-  public:
-
-    RingColors(ros::NodeHandle node, ros::NodeHandle private_nh);
-    ~RingColors() {}
-
-  private:
-
-    void convertPoints(const VPointCloud::ConstPtr &amp;inMsg);
-
-    ros::Subscriber input_;
-    ros::Publisher output_;
-  };
-
-} // namespace velodyne_pointcloud
-
-#endif // _VELODYNE_POINTCLOUD_COLORS_H_
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\convert.cc" new_path="" added_lines="0" deleted_lines="81">
				<diff>@@ -1,81 +0,0 @@
-/*
- *  Copyright (C) 2009, 2010 Austin Robot Technology, Jack O'Quin
- *  Copyright (C) 2011 Jesse Vera
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This class converts raw Velodyne 3D LIDAR packets to PointCloud2.
-
-*/
-
-#include "convert.h"
-
-#include &lt;pcl_conversions/pcl_conversions.h&gt;
-
-namespace velodyne_pointcloud
-{
-  /** @brief Constructor. */
-  Convert::Convert(ros::NodeHandle node, ros::NodeHandle private_nh):
-    data_(new velodyne_rawdata::RawData())
-  {
-    data_-&gt;setup(private_nh);
-
-
-    // advertise output point cloud (before subscribing to input data)
-    output_ =
-      node.advertise&lt;sensor_msgs::PointCloud2&gt;("velodyne_points", 10);
-      
-    srv_ = boost::make_shared &lt;dynamic_reconfigure::Server&lt;velodyne_pointcloud::
-      CloudNodeConfig&gt; &gt; (private_nh);
-    dynamic_reconfigure::Server&lt;velodyne_pointcloud::CloudNodeConfig&gt;::
-      CallbackType f;
-    f = boost::bind (&amp;Convert::callback, this, _1, _2);
-    srv_-&gt;setCallback (f);
-
-    // subscribe to VelodyneScan packets
-    velodyne_scan_ =
-      node.subscribe("velodyne_packets", 10,
-                     &amp;Convert::processScan, (Convert *) this,
-                     ros::TransportHints().tcpNoDelay(true));
-  }
-  
-  void Convert::callback(velodyne_pointcloud::CloudNodeConfig &amp;config,
-                uint32_t level)
-  {
-  ROS_INFO("Reconfigure Request");
-  data_-&gt;setParameters(config.min_range, config.max_range, config.view_direction,
-                       config.view_width);
-  }
-
-  /** @brief Callback for raw scan messages. */
-  void Convert::processScan(const velodyne_msgs::VelodyneScan::ConstPtr &amp;scanMsg)
-  {
-    if (output_.getNumSubscribers() == 0)         // no one listening?
-      return;                                     // avoid much work
-
-    // allocate a point cloud with same time and frame ID as raw data
-    velodyne_rawdata::VPointCloud::Ptr
-      outMsg(new velodyne_rawdata::VPointCloud());
-    // outMsg's header is a pcl::PCLHeader, convert it before stamp assignment
-    outMsg-&gt;header.stamp = pcl_conversions::toPCL(scanMsg-&gt;header).stamp;
-    outMsg-&gt;header.frame_id = scanMsg-&gt;header.frame_id;
-    outMsg-&gt;height = 1;
-
-    // process each packet provided by the driver
-    for (size_t i = 0; i &lt; scanMsg-&gt;packets.size(); ++i)
-      {
-        data_-&gt;unpack(scanMsg-&gt;packets[i], *outMsg, scanMsg-&gt;packets.size());
-      }
-
-    // publish the accumulated cloud message
-    ROS_DEBUG_STREAM("Publishing " &lt;&lt; outMsg-&gt;height * outMsg-&gt;width
-                     &lt;&lt; " Velodyne points, time: " &lt;&lt; outMsg-&gt;header.stamp);
-    output_.publish(outMsg);
-  }
-
-} // namespace velodyne_pointcloud
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\convert.h" new_path="" added_lines="0" deleted_lines="60">
				<diff>@@ -1,60 +0,0 @@
-/* -*- mode: C++ -*- */
-/*
- *  Copyright (C) 2009, 2010 Austin Robot Technology, Jack O'Quin
- *  Copyright (C) 2011 Jesse Vera
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This class converts raw Velodyne 3D LIDAR packets to PointCloud2.
-
-*/
-
-#ifndef _VELODYNE_POINTCLOUD_CONVERT_H_
-#define _VELODYNE_POINTCLOUD_CONVERT_H_ 1
-
-#include &lt;ros/ros.h&gt;
-
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-#include &lt;velodyne_pointcloud/rawdata.h&gt;
-
-#include &lt;dynamic_reconfigure/server.h&gt;
-#include &lt;velodyne_pointcloud/CloudNodeConfig.h&gt;
-
-namespace velodyne_pointcloud
-{
-  class Convert
-  {
-  public:
-
-    Convert(ros::NodeHandle node, ros::NodeHandle private_nh);
-    ~Convert() {}
-
-  private:
-    
-    void callback(velodyne_pointcloud::CloudNodeConfig &amp;config,
-                uint32_t level);
-    void processScan(const velodyne_msgs::VelodyneScan::ConstPtr &amp;scanMsg);
-
-    ///Pointer to dynamic reconfigure service srv_
-    boost::shared_ptr&lt;dynamic_reconfigure::Server&lt;velodyne_pointcloud::
-      CloudNodeConfig&gt; &gt; srv_;
-    
-    boost::shared_ptr&lt;velodyne_rawdata::RawData&gt; data_;
-    ros::Subscriber velodyne_scan_;
-    ros::Publisher output_;
-
-    /// configuration parameters
-    typedef struct {
-      int npackets;                    ///&lt; number of packets to combine
-    } Config;
-    Config config_;
-  };
-
-} // namespace velodyne_pointcloud
-
-#endif // _VELODYNE_POINTCLOUD_CONVERT_H_
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\ringcolors_node.cc" new_path="" added_lines="0" deleted_lines="33">
				<diff>@@ -1,33 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This ROS node converts a Velodyne 3D LIDAR PointXYZIR cloud to
-    PointXYZRGB, assigning colors for visualization of the laser
-    rings.
-
-*/
-
-#include &lt;ros/ros.h&gt;
-#include "colors.h"
-
-/** Main node entry point. */
-int main(int argc, char **argv)
-{
-  ros::init(argc, argv, "colors_node");
-  ros::NodeHandle node;
-  ros::NodeHandle priv_nh("~");
-
-  // create conversion class, which subscribes to input messages
-  velodyne_pointcloud::RingColors colors(node, priv_nh);
-
-  // handle callbacks until shut down
-  ros::spin();
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\ringcolors_nodelet.cc" new_path="" added_lines="0" deleted_lines="49">
				<diff>@@ -1,49 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This ROS nodelet converts a Velodyne 3D LIDAR PointXYZIR cloud to
-    PointXYZRGB, assigning colors for visualization of the laser
-    rings.
-
-*/
-
-#include &lt;ros/ros.h&gt;
-#include &lt;pluginlib/class_list_macros.h&gt;
-#include &lt;nodelet/nodelet.h&gt;
-
-#include "colors.h"
-
-namespace velodyne_pointcloud
-{
-  class RingColorsNodelet: public nodelet::Nodelet
-  {
-  public:
-
-    RingColorsNodelet() {}
-    ~RingColorsNodelet() {}
-
-  private:
-
-    virtual void onInit();
-    boost::shared_ptr&lt;RingColors&gt; colors_;
-  };
-
-  /** @brief Nodelet initialization. */
-  void RingColorsNodelet::onInit()
-  {
-    colors_.reset(new RingColors(getNodeHandle(), getPrivateNodeHandle()));
-  }
-
-} // namespace velodyne_pointcloud
-
-
-// Register this plugin with pluginlib.  Names must match nodelets.xml.
-//
-// parameters: class type, base class type
-PLUGINLIB_EXPORT_CLASS(velodyne_pointcloud::RingColorsNodelet, nodelet::Nodelet)
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\transform.cc" new_path="" added_lines="0" deleted_lines="138">
				<diff>@@ -1,138 +0,0 @@
-/*
- *  Copyright (C) 2009, 2010 Austin Robot Technology, Jack O'Quin
- *  Copyright (C) 2011 Jesse Vera
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This class transforms raw Velodyne 3D LIDAR packets to PointCloud2
-    in the /odom frame of reference.
-
-    @author Jack O'Quin
-    @author Jesse Vera
-
-*/
-
-#include "transform.h"
-
-#include &lt;pcl_conversions/pcl_conversions.h&gt;
-
-namespace velodyne_pointcloud
-{
-  /** @brief Constructor. */
-  Transform::Transform(ros::NodeHandle node, ros::NodeHandle private_nh):
-    tf_prefix_(tf::getPrefixParam(private_nh)),
-    data_(new velodyne_rawdata::RawData())
-  {
-    // Read calibration.
-    data_-&gt;setup(private_nh);
-
-    // advertise output point cloud (before subscribing to input data)
-    output_ =
-      node.advertise&lt;sensor_msgs::PointCloud2&gt;("velodyne_points", 10);
-
-    srv_ = boost::make_shared &lt;dynamic_reconfigure::Server&lt;velodyne_pointcloud::
-      TransformNodeConfig&gt; &gt; (private_nh);
-    dynamic_reconfigure::Server&lt;velodyne_pointcloud::TransformNodeConfig&gt;::
-      CallbackType f;
-    f = boost::bind (&amp;Transform::reconfigure_callback, this, _1, _2);
-    srv_-&gt;setCallback (f);
-    
-    // subscribe to VelodyneScan packets using transform filter
-    velodyne_scan_.subscribe(node, "velodyne_packets", 10);
-    tf_filter_ =
-      new tf::MessageFilter&lt;velodyne_msgs::VelodyneScan&gt;(velodyne_scan_,
-                                                         listener_,
-                                                         config_.frame_id, 10);
-    tf_filter_-&gt;registerCallback(boost::bind(&amp;Transform::processScan, this, _1));
-  }
-  
-  void Transform::reconfigure_callback(
-      velodyne_pointcloud::TransformNodeConfig &amp;config, uint32_t level)
-  {
-    ROS_INFO_STREAM("Reconfigure request.");
-    data_-&gt;setParameters(config.min_range, config.max_range, 
-                         config.view_direction, config.view_width);
-    config_.frame_id = tf::resolve(tf_prefix_, config.frame_id);
-    ROS_INFO_STREAM("Target frame ID: " &lt;&lt; config_.frame_id);
-  }
-
-  /** @brief Callback for raw scan messages.
-   *
-   *  @pre TF message filter has already waited until the transform to
-   *       the configured @c frame_id can succeed.
-   */
-  void
-    Transform::processScan(const velodyne_msgs::VelodyneScan::ConstPtr &amp;scanMsg)
-  {
-    if (output_.getNumSubscribers() == 0)         // no one listening?
-      return;                                     // avoid much work
-
-    // allocate an output point cloud with same time as raw data
-    VPointCloud::Ptr outMsg(new VPointCloud());
-    outMsg-&gt;header.stamp = pcl_conversions::toPCL(scanMsg-&gt;header).stamp;
-    outMsg-&gt;header.frame_id = config_.frame_id;
-    outMsg-&gt;height = 1;
-
-    // process each packet provided by the driver
-    for (size_t next = 0; next &lt; scanMsg-&gt;packets.size(); ++next)
-      {
-        // clear input point cloud to handle this packet
-        inPc_.points.clear();
-        inPc_.width = 0;
-        inPc_.height = 1;
-        std_msgs::Header header;
-        header.stamp = scanMsg-&gt;packets[next].stamp;
-        header.frame_id = scanMsg-&gt;header.frame_id;
-        pcl_conversions::toPCL(header, inPc_.header);
-
-        // unpack the raw data
-        data_-&gt;unpack(scanMsg-&gt;packets[next], inPc_, scanMsg-&gt;packets.size());
-
-        // clear transform point cloud for this packet
-        tfPc_.points.clear();           // is this needed?
-        tfPc_.width = 0;
-        tfPc_.height = 1;
-        header.stamp = scanMsg-&gt;packets[next].stamp;
-        pcl_conversions::toPCL(header, tfPc_.header);
-        tfPc_.header.frame_id = config_.frame_id;
-
-        // transform the packet point cloud into the target frame
-        try
-          {
-            ROS_DEBUG_STREAM("transforming from " &lt;&lt; inPc_.header.frame_id
-                             &lt;&lt; " to " &lt;&lt; config_.frame_id);
-            pcl_ros::transformPointCloud(config_.frame_id, inPc_, tfPc_,
-                                         listener_);
-#if 0       // use the latest transform available, should usually work fine
-            pcl_ros::transformPointCloud(inPc_.header.frame_id,
-                                         ros::Time(0), inPc_,
-                                         config_.frame_id,
-                                         tfPc_, listener_);
-#endif
-          }
-        catch (tf::TransformException &amp;ex)
-          {
-            // only log tf error once every 100 times
-            ROS_WARN_THROTTLE(100, "%s", ex.what());
-            continue;                   // skip this packet
-          }
-
-        // append transformed packet data to end of output message
-        outMsg-&gt;points.insert(outMsg-&gt;points.end(),
-                             tfPc_.points.begin(),
-                             tfPc_.points.end());
-        outMsg-&gt;width += tfPc_.points.size();
-      }
-
-    // publish the accumulated cloud message
-    ROS_DEBUG_STREAM("Publishing " &lt;&lt; outMsg-&gt;height * outMsg-&gt;width
-                     &lt;&lt; " Velodyne points, time: " &lt;&lt; outMsg-&gt;header.stamp);
-    output_.publish(outMsg);
-  }
-
-} // namespace velodyne_pointcloud
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\transform.h" new_path="" added_lines="0" deleted_lines="87">
				<diff>@@ -1,87 +0,0 @@
-/* -*- mode: C++ -*- */
-/*
- *  Copyright (C) 2009, 2010 Austin Robot Technology, Jack O'Quin
- *  Copyright (C) 2011 Jesse Vera
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This class transforms raw Velodyne 3D LIDAR packets to PointCloud2
-    in the /odom frame of reference.
-
-*/
-
-#ifndef _VELODYNE_POINTCLOUD_TRANSFORM_H_
-#define _VELODYNE_POINTCLOUD_TRANSFORM_H_ 1
-
-#include &lt;ros/ros.h&gt;
-#include "tf/message_filter.h"
-#include "message_filters/subscriber.h"
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-
-#include &lt;velodyne_pointcloud/rawdata.h&gt;
-#include &lt;velodyne_pointcloud/point_types.h&gt;
-
-#include &lt;dynamic_reconfigure/server.h&gt;
-#include &lt;velodyne_pointcloud/TransformNodeConfig.h&gt;
-
-// include template implementations to transform a custom point cloud
-#include &lt;pcl_ros/impl/transforms.hpp&gt;
-
-/** types of point and cloud to work with */
-typedef velodyne_rawdata::VPoint VPoint;
-typedef velodyne_rawdata::VPointCloud VPointCloud;
-
-// instantiate template for transforming a VPointCloud
-template bool
-  pcl_ros::transformPointCloud&lt;VPoint&gt;(const std::string &amp;,
-                                       const VPointCloud &amp;,
-                                       VPointCloud &amp;,
-                                       const tf::TransformListener &amp;);
-
-namespace velodyne_pointcloud
-{
-  class Transform
-  {
-  public:
-
-    Transform(ros::NodeHandle node, ros::NodeHandle private_nh);
-    ~Transform() {}
-
-  private:
-
-    void processScan(const velodyne_msgs::VelodyneScan::ConstPtr &amp;scanMsg);
-
-    ///Pointer to dynamic reconfigure service srv_
-    boost::shared_ptr&lt;dynamic_reconfigure::Server&lt;velodyne_pointcloud::
-      TransformNodeConfig&gt; &gt; srv_;
-    void reconfigure_callback(velodyne_pointcloud::TransformNodeConfig &amp;config,
-                  uint32_t level);
-    
-    const std::string tf_prefix_;
-    boost::shared_ptr&lt;velodyne_rawdata::RawData&gt; data_;
-    message_filters::Subscriber&lt;velodyne_msgs::VelodyneScan&gt; velodyne_scan_;
-    tf::MessageFilter&lt;velodyne_msgs::VelodyneScan&gt; *tf_filter_;
-    ros::Publisher output_;
-    tf::TransformListener listener_;
-
-    /// configuration parameters
-    typedef struct {
-      std::string frame_id;          ///&lt; target frame ID
-    } Config;
-    Config config_;
-
-    // Point cloud buffers for collecting points within a packet.  The
-    // inPc_ and tfPc_ are class members only to avoid reallocation on
-    // every message.
-    VPointCloud inPc_;              ///&lt; input packet point cloud
-    VPointCloud tfPc_;              ///&lt; transformed packet point cloud
-  };
-
-} // namespace velodyne_pointcloud
-
-#endif // _VELODYNE_POINTCLOUD_TRANSFORM_H_
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\transform_node.cc" new_path="" added_lines="0" deleted_lines="31">
				<diff>@@ -1,31 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** \file
-
-    This ROS node transforms raw Velodyne LIDAR packets to PointCloud2
-    in the /odom frame of reference.
-
-*/
-
-#include &lt;ros/ros.h&gt;
-#include "transform.h"
-
-/** Main node entry point. */
-int main(int argc, char **argv)
-{
-  ros::init(argc, argv, "transform_node");
-
-  // create conversion class, which subscribes to raw data
-  velodyne_pointcloud::Transform transform(ros::NodeHandle(),
-                                           ros::NodeHandle("~"));
-
-  // handle callbacks until shut down
-  ros::spin();
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\conversions\transform_nodelet.cc" new_path="" added_lines="0" deleted_lines="48">
				<diff>@@ -1,48 +0,0 @@
-/*
- *  Copyright (C) 2012 Austin Robot Technology, Jack O'Quin
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/** @file
-
-    This ROS nodelet transforms raw Velodyne 3D LIDAR packets to a
-    PointCloud2 in the /odom frame.
-
-*/
-
-#include &lt;ros/ros.h&gt;
-#include &lt;pluginlib/class_list_macros.h&gt;
-#include &lt;nodelet/nodelet.h&gt;
-
-#include "transform.h"
-
-namespace velodyne_pointcloud
-{
-  class TransformNodelet: public nodelet::Nodelet
-  {
-  public:
-
-    TransformNodelet() {}
-    ~TransformNodelet() {}
-
-  private:
-
-    virtual void onInit();
-    boost::shared_ptr&lt;Transform&gt; tf_;
-  };
-
-  /** @brief Nodelet initialization. */
-  void TransformNodelet::onInit()
-  {
-    tf_.reset(new Transform(getNodeHandle(), getPrivateNodeHandle()));
-  }
-
-} // namespace velodyne_pointcloud
-
-
-// Register this plugin with pluginlib.  Names must match nodelets.xml.
-//
-// parameters: class type, base class type
-PLUGINLIB_EXPORT_CLASS(velodyne_pointcloud::TransformNodelet, nodelet::Nodelet)
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\lib\calibration.cc" new_path="" added_lines="0" deleted_lines="270">
				<diff>@@ -1,270 +0,0 @@
-/**
- * \file  calibration.cc
- * \brief  
- *
- * \author  Piyush Khandelwal (piyushk@cs.utexas.edu)
- * Copyright (C) 2012, Austin Robot Technology,
- *                     The University of Texas at Austin
- *
- * License: Modified BSD License
- *
- * $ Id: 02/14/2012 11:36:36 AM piyushk $
- */
-
-#include &lt;iostream&gt;
-#include &lt;fstream&gt;
-#include &lt;string&gt;
-#include &lt;cmath&gt;
-#include &lt;limits&gt;
-#include &lt;yaml-cpp/yaml.h&gt;
-
-#ifdef HAVE_NEW_YAMLCPP
-namespace YAML {
-
-  // The &gt;&gt; operator disappeared in yaml-cpp 0.5, so this function is
-  // added to provide support for code written under the yaml-cpp 0.3 API.
-  template&lt;typename T&gt;
-  void operator &gt;&gt; (const YAML::Node&amp; node, T&amp; i) {
-    i = node.as&lt;T&gt;();
-  }
-} /* YAML */
-#endif // HAVE_NEW_YAMLCPP
-
-#include &lt;ros/ros.h&gt;
-#include &lt;velodyne_pointcloud/calibration.h&gt;
-
-namespace velodyne_pointcloud 
-{
-
-  const std::string NUM_LASERS = "num_lasers";
-  const std::string LASERS = "lasers";
-  const std::string LASER_ID = "laser_id";
-  const std::string ROT_CORRECTION = "rot_correction";
-  const std::string VERT_CORRECTION = "vert_correction";
-   const std::string DIST_CORRECTION = "dist_correction";
-  const std::string TWO_PT_CORRECTION_AVAILABLE =
-    "two_pt_correction_available";
-  const std::string DIST_CORRECTION_X = "dist_correction_x";
-  const std::string DIST_CORRECTION_Y = "dist_correction_y";
-  const std::string VERT_OFFSET_CORRECTION = "vert_offset_correction";
-  const std::string HORIZ_OFFSET_CORRECTION = "horiz_offset_correction";
-  const std::string MAX_INTENSITY = "max_intensity";
-  const std::string MIN_INTENSITY = "min_intensity";
-  const std::string FOCAL_DISTANCE = "focal_distance";
-  const std::string FOCAL_SLOPE = "focal_slope";
-
-  /** Read calibration for a single laser. */
-  void operator &gt;&gt; (const YAML::Node&amp; node,
-                    std::pair&lt;int, LaserCorrection&gt;&amp; correction)
-  {
-    node[LASER_ID] &gt;&gt; correction.first;
-    node[ROT_CORRECTION] &gt;&gt; correction.second.rot_correction;
-    node[VERT_CORRECTION] &gt;&gt; correction.second.vert_correction;
-    node[DIST_CORRECTION] &gt;&gt; correction.second.dist_correction;
-#ifdef HAVE_NEW_YAMLCPP
-    if (node[TWO_PT_CORRECTION_AVAILABLE])
-      node[TWO_PT_CORRECTION_AVAILABLE] &gt;&gt;
-        correction.second.two_pt_correction_available;
-#else
-    if (const YAML::Node *pName = node.FindValue(TWO_PT_CORRECTION_AVAILABLE))
-      *pName &gt;&gt; correction.second.two_pt_correction_available;
-#endif
-    else
-      correction.second.two_pt_correction_available = false;
-    node[DIST_CORRECTION_X] &gt;&gt; correction.second.dist_correction_x;
-    node[DIST_CORRECTION_Y] &gt;&gt; correction.second.dist_correction_y;
-    node[VERT_OFFSET_CORRECTION] &gt;&gt; correction.second.vert_offset_correction;
-#ifdef HAVE_NEW_YAMLCPP
-    if (node[HORIZ_OFFSET_CORRECTION])
-      node[HORIZ_OFFSET_CORRECTION] &gt;&gt;
-        correction.second.horiz_offset_correction;
-#else
-    if (const YAML::Node *pName = node.FindValue(HORIZ_OFFSET_CORRECTION))
-      *pName &gt;&gt; correction.second.horiz_offset_correction;
-#endif
-    else
-      correction.second.horiz_offset_correction = 0;
-
-    const YAML::Node * max_intensity_node = NULL;
-#ifdef HAVE_NEW_YAMLCPP
-    if (node[MAX_INTENSITY]) {
-      const YAML::Node max_intensity_node_ref = node[MAX_INTENSITY];
-      max_intensity_node = &amp;max_intensity_node_ref;
-    }
-#else
-    if (const YAML::Node *pName = node.FindValue(MAX_INTENSITY))
-      max_intensity_node = pName;
-#endif
-    if (max_intensity_node) {
-      float max_intensity_float;
-      *max_intensity_node &gt;&gt; max_intensity_float;
-      correction.second.max_intensity = floor(max_intensity_float);
-    }
-    else {
-      correction.second.max_intensity = 255;
-    }
-
-    const YAML::Node * min_intensity_node = NULL;
-#ifdef HAVE_NEW_YAMLCPP
-    if (node[MIN_INTENSITY]) {
-      const YAML::Node min_intensity_node_ref = node[MIN_INTENSITY];
-      min_intensity_node = &amp;min_intensity_node_ref;
-    }
-#else
-    if (const YAML::Node *pName = node.FindValue(MIN_INTENSITY))
-      min_intensity_node = pName;
-#endif
-    if (min_intensity_node) {
-      float min_intensity_float;
-      *min_intensity_node &gt;&gt; min_intensity_float;
-      correction.second.min_intensity = floor(min_intensity_float);
-    }
-    else {
-      correction.second.min_intensity = 0;
-    }
-    node[FOCAL_DISTANCE] &gt;&gt; correction.second.focal_distance;
-    node[FOCAL_SLOPE] &gt;&gt; correction.second.focal_slope;
-
-    // Calculate cached values
-    correction.second.cos_rot_correction =
-      cosf(correction.second.rot_correction);
-    correction.second.sin_rot_correction =
-      sinf(correction.second.rot_correction);
-    correction.second.cos_vert_correction =
-      cosf(correction.second.vert_correction);
-    correction.second.sin_vert_correction =
-      sinf(correction.second.vert_correction);
-
-    correction.second.laser_ring = 0;   // clear initially (set later)
-  }
-
-  /** Read entire calibration file. */
-  void operator &gt;&gt; (const YAML::Node&amp; node, Calibration&amp; calibration) 
-  {
-    int num_lasers;
-    node[NUM_LASERS] &gt;&gt; num_lasers;
-    const YAML::Node&amp; lasers = node[LASERS];
-    calibration.laser_corrections.clear();
-    calibration.num_lasers = num_lasers;
-    for (int i = 0; i &lt; num_lasers; i++) {
-      std::pair&lt;int, LaserCorrection&gt; correction;
-      lasers[i] &gt;&gt; correction;
-      calibration.laser_corrections.insert(correction);
-    }
-
-    // For each laser ring, find the next-smallest vertical angle.
-    //
-    // This implementation is simple, but not efficient.  That is OK,
-    // since it only runs while starting up.
-    double next_angle = -std::numeric_limits&lt;double&gt;::infinity();
-    for (int ring = 0; ring &lt; num_lasers; ++ring) {
-
-      // find minimum remaining vertical offset correction
-      double min_seen = std::numeric_limits&lt;double&gt;::infinity();
-      int next_index = num_lasers;
-      for (int j = 0; j &lt; num_lasers; ++j) {
-
-        double angle = calibration.laser_corrections[j].vert_correction;
-        if (next_angle &lt; angle &amp;&amp; angle &lt; min_seen) {
-          min_seen = angle;
-          next_index = j;
-        }
-      }
-
-      if (next_index &lt; num_lasers) {    // anything found in this ring?
-
-        // store this ring number with its corresponding laser number
-        calibration.laser_corrections[next_index].laser_ring = ring;
-        next_angle = min_seen;
-        if (calibration.ros_info) {
-          ROS_INFO("laser_ring[%2u] = %2u, angle = %+.6f",
-                   next_index, ring, next_angle);
-        }
-      }
-    }
-  }
-
-  YAML::Emitter&amp; operator &lt;&lt; (YAML::Emitter&amp; out,
-                              const std::pair&lt;int, LaserCorrection&gt; correction)
-  {
-    out &lt;&lt; YAML::BeginMap;
-    out &lt;&lt; YAML::Key &lt;&lt; LASER_ID &lt;&lt; YAML::Value &lt;&lt; correction.first;
-    out &lt;&lt; YAML::Key &lt;&lt; ROT_CORRECTION &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.rot_correction;
-    out &lt;&lt; YAML::Key &lt;&lt; VERT_CORRECTION &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.vert_correction;
-    out &lt;&lt; YAML::Key &lt;&lt; DIST_CORRECTION &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.dist_correction;
-    out &lt;&lt; YAML::Key &lt;&lt; TWO_PT_CORRECTION_AVAILABLE &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.two_pt_correction_available;
-    out &lt;&lt; YAML::Key &lt;&lt; DIST_CORRECTION_X &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.dist_correction_x;
-    out &lt;&lt; YAML::Key &lt;&lt; DIST_CORRECTION_Y &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.dist_correction_y;
-    out &lt;&lt; YAML::Key &lt;&lt; VERT_OFFSET_CORRECTION &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.vert_offset_correction;
-    out &lt;&lt; YAML::Key &lt;&lt; HORIZ_OFFSET_CORRECTION &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.horiz_offset_correction;
-    out &lt;&lt; YAML::Key &lt;&lt; MAX_INTENSITY &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.max_intensity;
-    out &lt;&lt; YAML::Key &lt;&lt; MIN_INTENSITY &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.min_intensity;
-    out &lt;&lt; YAML::Key &lt;&lt; FOCAL_DISTANCE &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.focal_distance;
-    out &lt;&lt; YAML::Key &lt;&lt; FOCAL_SLOPE &lt;&lt;
-      YAML::Value &lt;&lt; correction.second.focal_slope;
-    out &lt;&lt; YAML::EndMap;
-    return out;
-  }
-
-  YAML::Emitter&amp; operator &lt;&lt;
-  (YAML::Emitter&amp; out, const Calibration&amp; calibration)
-  {
-    out &lt;&lt; YAML::BeginMap;
-    out &lt;&lt; YAML::Key &lt;&lt; NUM_LASERS &lt;&lt;
-      YAML::Value &lt;&lt; calibration.laser_corrections.size();
-    out &lt;&lt; YAML::Key &lt;&lt; LASERS &lt;&lt; YAML::Value &lt;&lt; YAML::BeginSeq;
-    for (std::map&lt;int, LaserCorrection&gt;::const_iterator
-           it = calibration.laser_corrections.begin();
-         it != calibration.laser_corrections.end(); it++)
-      {
-        out &lt;&lt; *it; 
-      }
-    out &lt;&lt; YAML::EndSeq;
-    out &lt;&lt; YAML::EndMap;
-    return out;
-  }
-
-  void Calibration::read(const std::string&amp; calibration_file) {
-    std::ifstream fin(calibration_file.c_str());
-    if (!fin.is_open()) {
-      initialized = false;
-      return;
-    }
-    initialized = true;
-    try {
-      YAML::Node doc;
-#ifdef HAVE_NEW_YAMLCPP
-      fin.close();
-      doc = YAML::LoadFile(calibration_file);
-#else
-      YAML::Parser parser(fin);
-      parser.GetNextDocument(doc);
-#endif
-      doc &gt;&gt; *this;
-    } catch (YAML::Exception &amp;e) {
-      std::cerr &lt;&lt; "YAML Exception: " &lt;&lt; e.what() &lt;&lt; std::endl;
-      initialized = false;
-    }
-    fin.close();
-  }
-
-  void Calibration::write(const std::string&amp; calibration_file) {
-    std::ofstream fout(calibration_file.c_str());
-    YAML::Emitter out;
-    out &lt;&lt; *this;
-    fout &lt;&lt; out.c_str();
-    fout.close();
-  }
-  
-} /* velodyne_pointcloud */
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\src\lib\rawdata.cc" new_path="" added_lines="0" deleted_lines="495">
				<diff>@@ -1,495 +0,0 @@
-/*
- *  Copyright (C) 2007 Austin Robot Technology, Patrick Beeson
- *  Copyright (C) 2009, 2010, 2012 Austin Robot Technology, Jack O'Quin
- *
- *  License: Modified BSD Software License Agreement
- *
- *  $Id$
- */
-
-/**
- *  @file
- *
- *  Velodyne 3D LIDAR data accessor class implementation.
- *
- *  Class for unpacking raw Velodyne LIDAR packets into useful
- *  formats.
- *
- *  Derived classes accept raw Velodyne data for either single packets
- *  or entire rotations, and provide it in various formats for either
- *  on-line or off-line processing.
- *
- *  @author Patrick Beeson
- *  @author Jack O'Quin
- *
- *  HDL-64E S2 calibration support provided by Nick Hillier
- */
-
-#include &lt;fstream&gt;
-#include &lt;math.h&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;ros/package.h&gt;
-#include &lt;angles/angles.h&gt;
-
-#include &lt;velodyne_pointcloud/rawdata.h&gt;
-
-namespace velodyne_rawdata
-{
-  ////////////////////////////////////////////////////////////////////////
-  //
-  // RawData base class implementation
-  //
-  ////////////////////////////////////////////////////////////////////////
-
-  RawData::RawData() {}
-  
-  /** Update parameters: conversions and update */
-  void RawData::setParameters(double min_range,
-                              double max_range,
-                              double view_direction,
-                              double view_width)
-  {
-    config_.min_range = min_range;
-    config_.max_range = max_range;
-
-    //converting angle parameters into the velodyne reference (rad)
-    config_.tmp_min_angle = view_direction + view_width/2;
-    config_.tmp_max_angle = view_direction - view_width/2;
-    
-    //computing positive modulo to keep theses angles into [0;2*M_PI]
-    config_.tmp_min_angle = fmod(fmod(config_.tmp_min_angle,2*M_PI) + 2*M_PI,2*M_PI);
-    config_.tmp_max_angle = fmod(fmod(config_.tmp_max_angle,2*M_PI) + 2*M_PI,2*M_PI);
-    
-    //converting into the hardware velodyne ref (negative yaml and degrees)
-    //adding 0.5 perfomrs a centered double to int conversion 
-    config_.min_angle = 100 * (2*M_PI - config_.tmp_min_angle) * 180 / M_PI + 0.5;
-    config_.max_angle = 100 * (2*M_PI - config_.tmp_max_angle) * 180 / M_PI + 0.5;
-    if (config_.min_angle == config_.max_angle)
-    {
-      //avoid returning empty cloud if min_angle = max_angle
-      config_.min_angle = 0;
-      config_.max_angle = 36000;
-    }
-  }
-
-  /** Set up for on-line operation. */
-  int RawData::setup(ros::NodeHandle private_nh)
-  {
-    // get path to angles.config file for this device
-    if (!private_nh.getParam("calibration", config_.calibrationFile))
-      {
-        ROS_ERROR_STREAM("No calibration angles specified! Using test values!");
-
-        // have to use something: grab unit test version as a default
-        std::string pkgPath = ros::package::getPath("velodyne_pointcloud");
-        config_.calibrationFile = pkgPath + "/params/64e_utexas.yaml";
-      }
-
-    ROS_INFO_STREAM("correction angles: " &lt;&lt; config_.calibrationFile);
-
-    calibration_.read(config_.calibrationFile);
-    if (!calibration_.initialized) {
-      ROS_ERROR_STREAM("Unable to open calibration file: " &lt;&lt; 
-          config_.calibrationFile);
-      return -1;
-    }
-    
-    ROS_INFO_STREAM("Number of lasers: " &lt;&lt; calibration_.num_lasers &lt;&lt; ".");
-    
-    // Set up cached values for sin and cos of all the possible headings
-    for (uint16_t rot_index = 0; rot_index &lt; ROTATION_MAX_UNITS; ++rot_index) {
-      float rotation = angles::from_degrees(ROTATION_RESOLUTION * rot_index);
-      cos_rot_table_[rot_index] = cosf(rotation);
-      sin_rot_table_[rot_index] = sinf(rotation);
-    }
-   return 0;
-  }
-
-
-  /** Set up for offline operation */
-  int RawData::setupOffline(std::string calibration_file, double max_range_, double min_range_)
-  {
-
-      config_.max_range = max_range_;
-      config_.min_range = min_range_;
-      ROS_INFO_STREAM("data ranges to publish: ["
-	      &lt;&lt; config_.min_range &lt;&lt; ", "
-	      &lt;&lt; config_.max_range &lt;&lt; "]");
-
-      config_.calibrationFile = calibration_file;
-
-      ROS_INFO_STREAM("correction angles: " &lt;&lt; config_.calibrationFile);
-
-      calibration_.read(config_.calibrationFile);
-      if (!calibration_.initialized) {
-	  ROS_ERROR_STREAM("Unable to open calibration file: " &lt;&lt;
-		  config_.calibrationFile);
-	  return -1;
-      }
-
-      // Set up cached values for sin and cos of all the possible headings
-      for (uint16_t rot_index = 0; rot_index &lt; ROTATION_MAX_UNITS; ++rot_index) {
-	  float rotation = angles::from_degrees(ROTATION_RESOLUTION * rot_index);
-	  cos_rot_table_[rot_index] = cosf(rotation);
-	  sin_rot_table_[rot_index] = sinf(rotation);
-      }
-      return 0;
-  }
-
-
-  /** @brief convert raw packet to point cloud
-   *
-   *  @param pkt raw packet to unpack
-   *  @param pc shared pointer to point cloud (points are appended)
-   */
-  void RawData::unpack(const velodyne_msgs::VelodynePacket &amp;pkt,
-                       VPointCloud &amp;pc, int packets_num)
-  {
-    ROS_DEBUG_STREAM("Received packet, time: " &lt;&lt; pkt.stamp);
-    
-    /** special parsing for the VLP16 **/
-    if (calibration_.num_lasers == 16)
-    {
-      unpack_vlp16(pkt, pc);
-      return;
-    }
-    
-    const raw_packet_t *raw = (const raw_packet_t *) &amp;pkt.data[0];
-
-    for (int i = 0; i &lt; BLOCKS_PER_PACKET; i++) {
-
-      // upper bank lasers are numbered [0..31]
-      // NOTE: this is a change from the old velodyne_common implementation
-      int bank_origin = 0;
-      if (raw-&gt;blocks[i].header == LOWER_BANK) {
-        // lower bank lasers are [32..63]
-        bank_origin = 32;
-      }
-
-      for (int j = 0, k = 0; j &lt; SCANS_PER_BLOCK; j++, k += RAW_SCAN_SIZE) {
-        
-        float x, y, z;
-        float intensity;
-        uint8_t laser_number;       ///&lt; hardware laser number
-
-        laser_number = j + bank_origin;
-        velodyne_pointcloud::LaserCorrection &amp;corrections = 
-          calibration_.laser_corrections[laser_number];
-
-        /** Position Calculation */
-
-        union two_bytes tmp;
-        tmp.bytes[0] = raw-&gt;blocks[i].data[k];
-        tmp.bytes[1] = raw-&gt;blocks[i].data[k+1];
-        /*condition added to avoid calculating points which are not
-          in the interesting defined area (min_angle &lt; area &lt; max_angle)*/
-        if ((raw-&gt;blocks[i].rotation &gt;= config_.min_angle 
-             &amp;&amp; raw-&gt;blocks[i].rotation &lt;= config_.max_angle 
-             &amp;&amp; config_.min_angle &lt; config_.max_angle)
-             ||(config_.min_angle &gt; config_.max_angle 
-             &amp;&amp; (raw-&gt;blocks[i].rotation &lt;= config_.max_angle 
-             || raw-&gt;blocks[i].rotation &gt;= config_.min_angle))){
-
-          float distance;
-          if (packets_num==(int) ceil(1507.0 / 10))
-            distance = tmp.uint * DISTANCE_RESOLUTION * 2;
-          else
-            distance = tmp.uint * DISTANCE_RESOLUTION;
-
-          distance += corrections.dist_correction;
-  
-          float cos_vert_angle = corrections.cos_vert_correction;
-          float sin_vert_angle = corrections.sin_vert_correction;
-          float cos_rot_correction = corrections.cos_rot_correction;
-          float sin_rot_correction = corrections.sin_rot_correction;
-  
-          // cos(a-b) = cos(a)*cos(b) + sin(a)*sin(b)
-          // sin(a-b) = sin(a)*cos(b) - cos(a)*sin(b)
-          float cos_rot_angle = 
-            cos_rot_table_[raw-&gt;blocks[i].rotation] * cos_rot_correction + 
-            sin_rot_table_[raw-&gt;blocks[i].rotation] * sin_rot_correction;
-          float sin_rot_angle = 
-            sin_rot_table_[raw-&gt;blocks[i].rotation] * cos_rot_correction - 
-            cos_rot_table_[raw-&gt;blocks[i].rotation] * sin_rot_correction;
-  
-          float horiz_offset = corrections.horiz_offset_correction;
-          float vert_offset = corrections.vert_offset_correction;
-  
-          // Compute the distance in the xy plane (w/o accounting for rotation)
-          /**the new term of 'vert_offset * sin_vert_angle'
-           * was added to the expression due to the mathemathical
-           * model we used.
-           */
-          float xy_distance = distance * cos_vert_angle - vert_offset * sin_vert_angle;
-  
-          // Calculate temporal X, use absolute value.
-          float xx = xy_distance * sin_rot_angle - horiz_offset * cos_rot_angle;
-          // Calculate temporal Y, use absolute value
-          float yy = xy_distance * cos_rot_angle + horiz_offset * sin_rot_angle;
-          if (xx &lt; 0) xx=-xx;
-          if (yy &lt; 0) yy=-yy;
-    
-          // Get 2points calibration values,Linear interpolation to get distance
-          // correction for X and Y, that means distance correction use
-          // different value at different distance
-          float distance_corr_x = 0;
-          float distance_corr_y = 0;
-          if (corrections.two_pt_correction_available) {
-            distance_corr_x = 
-              (corrections.dist_correction - corrections.dist_correction_x)
-                * (xx - 2.4) / (25.04 - 2.4) 
-              + corrections.dist_correction_x;
-            distance_corr_x -= corrections.dist_correction;
-            distance_corr_y = 
-              (corrections.dist_correction - corrections.dist_correction_y)
-                * (yy - 1.93) / (25.04 - 1.93)
-              + corrections.dist_correction_y;
-            distance_corr_y -= corrections.dist_correction;
-          }
-  
-          float distance_x = distance + distance_corr_x;
-          /**the new term of 'vert_offset * sin_vert_angle'
-           * was added to the expression due to the mathemathical
-           * model we used.
-           */
-          xy_distance = distance_x * cos_vert_angle - vert_offset * sin_vert_angle ;
-          ///the expression wiht '-' is proved to be better than the one with '+'
-          x = xy_distance * sin_rot_angle - horiz_offset * cos_rot_angle;
-  
-          float distance_y = distance + distance_corr_y;
-          xy_distance = distance_y * cos_vert_angle - vert_offset * sin_vert_angle ;
-          /**the new term of 'vert_offset * sin_vert_angle'
-           * was added to the expression due to the mathemathical
-           * model we used.
-           */
-          y = xy_distance * cos_rot_angle + horiz_offset * sin_rot_angle;
-  
-          // Using distance_y is not symmetric, but the velodyne manual
-          // does this.
-          /**the new term of 'vert_offset * cos_vert_angle'
-           * was added to the expression due to the mathemathical
-           * model we used.
-           */
-          z = distance_y * sin_vert_angle + vert_offset*cos_vert_angle;
-  
-          /** Use standard ROS coordinate system (right-hand rule) */
-          float x_coord = y;
-          float y_coord = -x;
-          float z_coord = z;
-  
-          /** Intensity Calculation */
-  
-          float min_intensity = corrections.min_intensity;
-          float max_intensity = corrections.max_intensity;
-  
-          intensity = raw-&gt;blocks[i].data[k+2];
-  
-          float focal_offset = 256 
-                             * (1 - corrections.focal_distance / 13100) 
-                             * (1 - corrections.focal_distance / 13100);
-          float focal_slope = corrections.focal_slope;
-          intensity += focal_slope * (std::abs(focal_offset - 256 * 
-            (1 - static_cast&lt;float&gt;(tmp.uint)/65535)*(1 - static_cast&lt;float&gt;(tmp.uint)/65535)));
-          intensity = (intensity &lt; min_intensity) ? min_intensity : intensity;
-          intensity = (intensity &gt; max_intensity) ? max_intensity : intensity;
-  
-          if (pointInRange(distance)) {
-  
-            // convert polar coordinates to Euclidean XYZ
-            VPoint point;
-            point.ring = corrections.laser_ring;
-            point.x = x_coord;
-            point.y = y_coord;
-            point.z = z_coord;
-            point.intensity = intensity;
-  
-            // append this point to the cloud
-            pc.points.push_back(point);
-            ++pc.width;
-          }
-        }
-      }
-    }
-  }
-  
-  /** @brief convert raw VLP16 packet to point cloud
-   *
-   *  @param pkt raw packet to unpack
-   *  @param pc shared pointer to point cloud (points are appended)
-   */
-  void RawData::unpack_vlp16(const velodyne_msgs::VelodynePacket &amp;pkt,
-                             VPointCloud &amp;pc)
-  {
-    float azimuth;
-    float azimuth_diff;
-    float last_azimuth_diff=0;
-    float azimuth_corrected_f;
-    int azimuth_corrected;
-    float x, y, z;
-    float intensity;
-
-    const raw_packet_t *raw = (const raw_packet_t *) &amp;pkt.data[0];
-
-    for (int block = 0; block &lt; BLOCKS_PER_PACKET; block++) {
-
-      // ignore packets with mangled or otherwise different contents
-      if (UPPER_BANK != raw-&gt;blocks[block].header) {
-        // Do not flood the log with messages, only issue at most one
-        // of these warnings per minute.
-        ROS_WARN_STREAM_THROTTLE(60, "skipping invalid VLP-16 packet: block "
-                                 &lt;&lt; block &lt;&lt; " header value is "
-                                 &lt;&lt; raw-&gt;blocks[block].header);
-        return;                         // bad packet: skip the rest
-      }
-
-      // Calculate difference between current and next block's azimuth angle.
-      azimuth = (float)(raw-&gt;blocks[block].rotation);
-      if (block &lt; (BLOCKS_PER_PACKET-1)){
-        azimuth_diff = (float)((36000 + raw-&gt;blocks[block+1].rotation - raw-&gt;blocks[block].rotation)%36000);
-        last_azimuth_diff = azimuth_diff;
-      }else{
-        azimuth_diff = last_azimuth_diff;
-      }
-
-      for (int firing=0, k=0; firing &lt; VLP16_FIRINGS_PER_BLOCK; firing++){
-        for (int dsr=0; dsr &lt; VLP16_SCANS_PER_FIRING; dsr++, k+=RAW_SCAN_SIZE){
-          velodyne_pointcloud::LaserCorrection &amp;corrections = 
-            calibration_.laser_corrections[dsr];
-
-          /** Position Calculation */
-          union two_bytes tmp;
-          tmp.bytes[0] = raw-&gt;blocks[block].data[k];
-          tmp.bytes[1] = raw-&gt;blocks[block].data[k+1];
-          
-          /** correct for the laser rotation as a function of timing during the firings **/
-          azimuth_corrected_f = azimuth + (azimuth_diff * ((dsr*VLP16_DSR_TOFFSET) + (firing*VLP16_FIRING_TOFFSET)) / VLP16_BLOCK_TDURATION);
-          azimuth_corrected = ((int)round(azimuth_corrected_f)) % 36000;
-          
-          /*condition added to avoid calculating points which are not
-            in the interesting defined area (min_angle &lt; area &lt; max_angle)*/
-          if ((azimuth_corrected &gt;= config_.min_angle 
-               &amp;&amp; azimuth_corrected &lt;= config_.max_angle 
-               &amp;&amp; config_.min_angle &lt; config_.max_angle)
-               ||(config_.min_angle &gt; config_.max_angle 
-               &amp;&amp; (azimuth_corrected &lt;= config_.max_angle 
-               || azimuth_corrected &gt;= config_.min_angle))){
-
-            // convert polar coordinates to Euclidean XYZ
-            float distance = tmp.uint * DISTANCE_RESOLUTION;
-            distance += corrections.dist_correction;
-            
-            float cos_vert_angle = corrections.cos_vert_correction;
-            float sin_vert_angle = corrections.sin_vert_correction;
-            float cos_rot_correction = corrections.cos_rot_correction;
-            float sin_rot_correction = corrections.sin_rot_correction;
-    
-            // cos(a-b) = cos(a)*cos(b) + sin(a)*sin(b)
-            // sin(a-b) = sin(a)*cos(b) - cos(a)*sin(b)
-            float cos_rot_angle = 
-              cos_rot_table_[azimuth_corrected] * cos_rot_correction + 
-              sin_rot_table_[azimuth_corrected] * sin_rot_correction;
-            float sin_rot_angle = 
-              sin_rot_table_[azimuth_corrected] * cos_rot_correction - 
-              cos_rot_table_[azimuth_corrected] * sin_rot_correction;
-    
-            float horiz_offset = corrections.horiz_offset_correction;
-            float vert_offset = corrections.vert_offset_correction;
-    
-            // Compute the distance in the xy plane (w/o accounting for rotation)
-            /**the new term of 'vert_offset * sin_vert_angle'
-             * was added to the expression due to the mathemathical
-             * model we used.
-             */
-            float xy_distance = distance * cos_vert_angle - vert_offset * sin_vert_angle;
-    
-            // Calculate temporal X, use absolute value.
-            float xx = xy_distance * sin_rot_angle - horiz_offset * cos_rot_angle;
-            // Calculate temporal Y, use absolute value
-            float yy = xy_distance * cos_rot_angle + horiz_offset * sin_rot_angle;
-            if (xx &lt; 0) xx=-xx;
-            if (yy &lt; 0) yy=-yy;
-      
-            // Get 2points calibration values,Linear interpolation to get distance
-            // correction for X and Y, that means distance correction use
-            // different value at different distance
-            float distance_corr_x = 0;
-            float distance_corr_y = 0;
-            if (corrections.two_pt_correction_available) {
-              distance_corr_x = 
-                (corrections.dist_correction - corrections.dist_correction_x)
-                  * (xx - 2.4) / (25.04 - 2.4) 
-                + corrections.dist_correction_x;
-              distance_corr_x -= corrections.dist_correction;
-              distance_corr_y = 
-                (corrections.dist_correction - corrections.dist_correction_y)
-                  * (yy - 1.93) / (25.04 - 1.93)
-                + corrections.dist_correction_y;
-              distance_corr_y -= corrections.dist_correction;
-            }
-    
-            float distance_x = distance + distance_corr_x;
-            /**the new term of 'vert_offset * sin_vert_angle'
-             * was added to the expression due to the mathemathical
-             * model we used.
-             */
-            xy_distance = distance_x * cos_vert_angle - vert_offset * sin_vert_angle ;
-            x = xy_distance * sin_rot_angle - horiz_offset * cos_rot_angle;
-    
-            float distance_y = distance + distance_corr_y;
-            /**the new term of 'vert_offset * sin_vert_angle'
-             * was added to the expression due to the mathemathical
-             * model we used.
-             */
-            xy_distance = distance_y * cos_vert_angle - vert_offset * sin_vert_angle ;
-            y = xy_distance * cos_rot_angle + horiz_offset * sin_rot_angle;
-    
-            // Using distance_y is not symmetric, but the velodyne manual
-            // does this.
-            /**the new term of 'vert_offset * cos_vert_angle'
-             * was added to the expression due to the mathemathical
-             * model we used.
-             */
-            z = distance_y * sin_vert_angle + vert_offset*cos_vert_angle;
-  
-    
-            /** Use standard ROS coordinate system (right-hand rule) */
-            float x_coord = y;
-            float y_coord = -x;
-            float z_coord = z;
-    
-            /** Intensity Calculation */
-            float min_intensity = corrections.min_intensity;
-            float max_intensity = corrections.max_intensity;
-    
-            intensity = raw-&gt;blocks[block].data[k+2];
-    
-            float focal_offset = 256 
-                               * (1 - corrections.focal_distance / 13100) 
-                               * (1 - corrections.focal_distance / 13100);
-            float focal_slope = corrections.focal_slope;
-            intensity += focal_slope * (std::abs(focal_offset - 256 * 
-              (1 - tmp.uint/65535)*(1 - tmp.uint/65535)));
-            intensity = (intensity &lt; min_intensity) ? min_intensity : intensity;
-            intensity = (intensity &gt; max_intensity) ? max_intensity : intensity;
-    
-            if (pointInRange(distance)) {
-    
-              // append this point to the cloud
-              VPoint point;
-              point.ring = corrections.laser_ring;
-              point.x = x_coord;
-              point.y = y_coord;
-              point.z = z_coord;
-              point.intensity = intensity;
-
-              pc.points.push_back(point);
-              ++pc.width;
-            }
-          }
-        }
-      }
-    }
-  }  
-
-} // namespace velodyne_rawdata
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\lidar\packages\velodyne\velodyne_pointcloud\tests\test_calibration.cpp" new_path="" added_lines="0" deleted_lines="164">
				<diff>@@ -1,164 +0,0 @@
-//
-// C++ unit tests for calibration interface.
-//
-
-#include &lt;gtest/gtest.h&gt;
-
-#include &lt;ros/package.h&gt;
-#include &lt;velodyne_pointcloud/calibration.h&gt;
-using namespace velodyne_pointcloud;
-
-// global test data
-std::string g_package_name("velodyne_pointcloud");
-std::string g_package_path;
-
-void init_global_data(void)
-{
-  g_package_path = ros::package::getPath(g_package_name);
-}
-
-///////////////////////////////////////////////////////////////
-// Test cases
-///////////////////////////////////////////////////////////////
-
-TEST(Calibration, missing_file)
-{
-  Calibration calibration(false);
-  calibration.read("./no_such_file.yaml");
-  EXPECT_FALSE(calibration.initialized);
-}
-
-TEST(Calibration, vlp16)
-{
-  Calibration calibration(g_package_path + "/params/VLP16db.yaml", false);
-  EXPECT_TRUE(calibration.initialized);
-  ASSERT_EQ(calibration.num_lasers, 16);
-
-  // check some values for the first laser:
-  LaserCorrection laser = calibration.laser_corrections[0];
-  EXPECT_FALSE(laser.two_pt_correction_available);
-  EXPECT_FLOAT_EQ(laser.vert_correction, -0.2617993877991494);
-  EXPECT_FLOAT_EQ(laser.horiz_offset_correction, 0.0);
-  EXPECT_EQ(laser.max_intensity, 255);
-  EXPECT_EQ(laser.min_intensity, 0);
-
-  // check similar values for the last laser:
-  laser = calibration.laser_corrections[15];
-  EXPECT_FALSE(laser.two_pt_correction_available);
-  EXPECT_FLOAT_EQ(laser.vert_correction, 0.2617993877991494);
-  EXPECT_FLOAT_EQ(laser.horiz_offset_correction, 0.0);
-  EXPECT_EQ(laser.max_intensity, 255);
-  EXPECT_EQ(laser.min_intensity, 0);
-}
-
-TEST(Calibration, hdl32e)
-{
-  Calibration calibration(g_package_path + "/params/32db.yaml", false);
-  EXPECT_TRUE(calibration.initialized);
-  ASSERT_EQ(calibration.num_lasers, 32);
-
-  // check some values for the first laser:
-  LaserCorrection laser = calibration.laser_corrections[0];
-  EXPECT_FALSE(laser.two_pt_correction_available);
-  EXPECT_FLOAT_EQ(laser.vert_correction, -0.5352924815866609);
-  EXPECT_FLOAT_EQ(laser.horiz_offset_correction, 0.0);
-  EXPECT_EQ(laser.max_intensity, 255);
-  EXPECT_EQ(laser.min_intensity, 0);
-
-  // check similar values for the last laser:
-  laser = calibration.laser_corrections[31];
-  EXPECT_FALSE(laser.two_pt_correction_available);
-  EXPECT_FLOAT_EQ(laser.vert_correction, 0.18622663118779495);
-  EXPECT_FLOAT_EQ(laser.horiz_offset_correction, 0.0);
-  EXPECT_EQ(laser.max_intensity, 255);
-  EXPECT_EQ(laser.min_intensity, 0);
-}
-
-TEST(Calibration, hdl64e)
-{
-  Calibration calibration(g_package_path + "/params/64e_utexas.yaml", false);
-  EXPECT_TRUE(calibration.initialized);
-  ASSERT_EQ(calibration.num_lasers, 64);
-
-  // check some values for the first laser:
-  LaserCorrection laser = calibration.laser_corrections[0];
-  EXPECT_FALSE(laser.two_pt_correction_available);
-  EXPECT_FLOAT_EQ(laser.vert_correction, -0.124932751059532);
-  EXPECT_FLOAT_EQ(laser.horiz_offset_correction, 0.0);
-  EXPECT_EQ(laser.max_intensity, 255);
-  EXPECT_EQ(laser.min_intensity, 0);
-
-  // check similar values for the last laser:
-  laser = calibration.laser_corrections[63];
-  EXPECT_FALSE(laser.two_pt_correction_available);
-  EXPECT_FLOAT_EQ(laser.vert_correction, -0.209881335496902);
-  EXPECT_FLOAT_EQ(laser.horiz_offset_correction, 0.0);
-  EXPECT_EQ(laser.max_intensity, 255);
-  EXPECT_EQ(laser.min_intensity, 0);
-}
-
-TEST(Calibration, hdl64e_s21)
-{
-  Calibration calibration(g_package_path + "/params/64e_s2.1-sztaki.yaml",
-                          false);
-  EXPECT_TRUE(calibration.initialized);
-  ASSERT_EQ(calibration.num_lasers, 64);
-
-  // check some values for the first laser:
-  LaserCorrection laser = calibration.laser_corrections[0];
-  EXPECT_FALSE(laser.two_pt_correction_available);
-  EXPECT_FLOAT_EQ(laser.vert_correction, -0.15304134919741974);
-  EXPECT_FLOAT_EQ(laser.horiz_offset_correction, 0.025999999);
-  EXPECT_EQ(laser.max_intensity, 235);
-  EXPECT_EQ(laser.min_intensity, 30);
-
-  // check similar values for the last laser:
-  laser = calibration.laser_corrections[63];
-  EXPECT_FALSE(laser.two_pt_correction_available);
-  EXPECT_FLOAT_EQ(laser.vert_correction, -0.2106649408137298);
-  EXPECT_FLOAT_EQ(laser.horiz_offset_correction, -0.025999999);
-  EXPECT_EQ(laser.max_intensity, 255);
-  EXPECT_EQ(laser.min_intensity, 0);
-}
-
-TEST(Calibration, hdl64e_s2_float_intensities)
-{
-  Calibration calibration(g_package_path +
-                          "/tests/issue_84_float_intensities.yaml",
-                          false);
-  EXPECT_TRUE(calibration.initialized);
-  ASSERT_EQ(calibration.num_lasers, 64);
-
-  // check some values for the first laser:
-  LaserCorrection laser = calibration.laser_corrections[0];
-  EXPECT_FALSE(laser.two_pt_correction_available);
-  EXPECT_FLOAT_EQ(laser.vert_correction, -0.12118950050089745);
-  EXPECT_FLOAT_EQ(laser.horiz_offset_correction, 0.025999999);
-  EXPECT_EQ(laser.max_intensity, 255);
-  EXPECT_EQ(laser.min_intensity, 40);
-
-  // check similar values for laser 26:
-  laser = calibration.laser_corrections[26];
-  EXPECT_FALSE(laser.two_pt_correction_available);
-  EXPECT_FLOAT_EQ(laser.vert_correction, -0.014916840599137901);
-  EXPECT_FLOAT_EQ(laser.horiz_offset_correction, 0.025999999);
-  EXPECT_EQ(laser.max_intensity, 245);
-  EXPECT_EQ(laser.min_intensity, 0);
-
-  // check similar values for the last laser:
-  laser = calibration.laser_corrections[63];
-  EXPECT_FALSE(laser.two_pt_correction_available);
-  EXPECT_FLOAT_EQ(laser.vert_correction, -0.20683046990039078);
-  EXPECT_FLOAT_EQ(laser.horiz_offset_correction, -0.025999999);
-  EXPECT_EQ(laser.max_intensity, 255);
-  EXPECT_EQ(laser.min_intensity, 0);
-}
-
-// Run all the tests that were declared with TEST()
-int main(int argc, char **argv)
-{
-  testing::InitGoogleTest(&amp;argc, argv);
-  init_global_data();
-  return RUN_ALL_TESTS();
-}
-
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c42a9001da383ac75f8b1665e06f937c499ab27e" author="Abraham Monrroy Cano">
		<msg>[fix] Install commands for all the packages (#1861)

* Initial fixes to detection, sensing, semantics and utils

* fixing wrong filename on install command

* Fixes to install commands

* Hokuyo fix name

* Fix obj db

* Obj db include fixes

* End of final cleaning sweep

* Incorrect command order in runtime manager

* Param tempfile not required by runtime_manager

* * Fixes to runtime manager install commands
* Remove devel directory from catkin, if any

* Updated launch files for robosense

* Updated robosense

* Fix/add missing install (#1977)

* Added launch install to lidar_kf_contour_track

* Added install to op_global_planner

* Added install to way_planner

* Added install to op_local_planner

* Added install to op_simulation_package

* Added install to op_utilities

* Added install to sync

* * Improved installation script for pointgrey packages
* Fixed nodelet error for gmsl cameras

* USe install space in catkin as well

* add install to catkin

* Fix install directives (#1990)

* Fixed installation path

* Fixed params installation path

* Fixed cfg installation path

* Delete cache on colcon_release</msg>
		<modified_files>
			<file old_path="ros\src\common\libvectormap\FindEigen.cmake" new_path="" added_lines="0" deleted_lines="87">
				<diff>@@ -1,87 +0,0 @@
-# - Try to find Eigen3 lib
-#
-# This module supports requiring a minimum version, e.g. you can do
-#   find_package(Eigen3 3.1.2)
-# to require version 3.1.2 or newer of Eigen3.
-#
-# Once done this will define
-#
-#  EIGEN3_FOUND - system has eigen lib with correct version
-#  EIGEN3_INCLUDE_DIR - the eigen include directory
-#  EIGEN3_VERSION - eigen version
-
-# Copyright (c) 2006, 2007 Montel Laurent, &lt;montel@kde.org&gt;
-# Copyright (c) 2008, 2009 Gael Guennebaud, &lt;g.gael@free.fr&gt;
-# Copyright (c) 2009 Benoit Jacob &lt;jacob.benoit.1@gmail.com&gt;
-# Redistribution and use is allowed according to the terms of the 2-clause BSD license.
-
-if(NOT Eigen3_FIND_VERSION)
-    if(NOT Eigen3_FIND_VERSION_MAJOR)
-        set(Eigen3_FIND_VERSION_MAJOR 2)
-    endif(NOT Eigen3_FIND_VERSION_MAJOR)
-    if(NOT Eigen3_FIND_VERSION_MINOR)
-        set(Eigen3_FIND_VERSION_MINOR 91)
-    endif(NOT Eigen3_FIND_VERSION_MINOR)
-    if(NOT Eigen3_FIND_VERSION_PATCH)
-        set(Eigen3_FIND_VERSION_PATCH 0)
-    endif(NOT Eigen3_FIND_VERSION_PATCH)
-
-    set(Eigen3_FIND_VERSION "${Eigen3_FIND_VERSION_MAJOR}.${Eigen3_FIND_VERSION_MINOR}.${Eigen3_FIND_VERSION_PATCH}")
-endif(NOT Eigen3_FIND_VERSION)
-
-macro(_eigen3_check_version)
-    file(READ "${EIGEN3_INCLUDE_DIR}/Eigen/src/Core/util/Macros.h" _eigen3_version_header)
-
-    string(REGEX MATCH "define[ \t]+EIGEN_WORLD_VERSION[ \t]+([0-9]+)" _eigen3_world_version_match "${_eigen3_version_header}")
-    set(EIGEN3_WORLD_VERSION "${CMAKE_MATCH_1}")
-    string(REGEX MATCH "define[ \t]+EIGEN_MAJOR_VERSION[ \t]+([0-9]+)" _eigen3_major_version_match "${_eigen3_version_header}")
-    set(EIGEN3_MAJOR_VERSION "${CMAKE_MATCH_1}")
-    string(REGEX MATCH "define[ \t]+EIGEN_MINOR_VERSION[ \t]+([0-9]+)" _eigen3_minor_version_match "${_eigen3_version_header}")
-    set(EIGEN3_MINOR_VERSION "${CMAKE_MATCH_1}")
-
-    set(EIGEN3_VERSION ${EIGEN3_WORLD_VERSION}.${EIGEN3_MAJOR_VERSION}.${EIGEN3_MINOR_VERSION})
-    if(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
-        set(EIGEN3_VERSION_OK FALSE)
-    else(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
-        set(EIGEN3_VERSION_OK TRUE)
-    endif(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
-
-    if(NOT EIGEN3_VERSION_OK)
-
-        message(STATUS "Eigen3 version ${EIGEN3_VERSION} found in ${EIGEN3_INCLUDE_DIR}, "
-                "but at least version ${Eigen3_FIND_VERSION} is required")
-    endif(NOT EIGEN3_VERSION_OK)
-endmacro(_eigen3_check_version)
-
-if (EIGEN3_INCLUDE_DIR)
-
-    # in cache already
-    _eigen3_check_version()
-    set(EIGEN3_FOUND ${EIGEN3_VERSION_OK})
-
-else (EIGEN3_INCLUDE_DIR)
-
-    # specific additional paths for some OS
-    if (WIN32)
-        set(EIGEN_ADDITIONAL_SEARCH_PATHS ${EIGEN_ADDITIONAL_SEARCH_PATHS} "C:/Program Files/Eigen/include" "C:/Program Files (x86)/Eigen/include")
-    endif(WIN32)
-
-    find_path(EIGEN3_INCLUDE_DIR NAMES signature_of_eigen3_matrix_library
-            PATHS
-            include
-            ${EIGEN_ADDITIONAL_SEARCH_PATHS}
-            ${KDE4_INCLUDE_DIR}
-            PATH_SUFFIXES eigen3 eigen
-            )
-
-    if(EIGEN3_INCLUDE_DIR)
-        _eigen3_check_version()
-    endif(EIGEN3_INCLUDE_DIR)
-
-    include(FindPackageHandleStandardArgs)
-    find_package_handle_standard_args(Eigen3 DEFAULT_MSG EIGEN3_INCLUDE_DIR EIGEN3_VERSION_OK)
-
-    mark_as_advanced(EIGEN3_INCLUDE_DIR)
-
-endif(EIGEN3_INCLUDE_DIR)
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\include\road_occupancy_processor.h" new_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\include\road_occupancy_processor\road_occupancy_processor.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\src\road_occupancy_processor.cpp" new_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\src\road_occupancy_processor.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -20,7 +20,7 @@
  *  Created on: Jan 29, 2018
  */
 
-#include "road_occupancy_processor.h"
+#include "road_occupancy_processor/road_occupancy_processor.h"
 
 void ROSRoadOccupancyProcessorApp::ConvertXYZIToRTZ(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud,
                                                     ROSRoadOccupancyProcessorApp::PointCloudXYZIRTColor &amp;out_organized_points,
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\src\road_occupancy_processor_node.cpp" new_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\src\road_occupancy_processor_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -20,7 +20,7 @@
  *  Created on: Jan 29, 2018
  */
 
-#include "road_occupancy_processor.h"
+#include "road_occupancy_processor/road_occupancy_processor.h"
 
 int main(int argc, char **argv)
 {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4a9dc5ab77e3c9f87957e67b806276ec7ad39f6f" author="Masaya Kataoka">
		<msg>Feature/autoware health analyzer (#2004)</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\default.rviz" new_path="ros\src\.config\rviz\default.rviz" added_lines="60" deleted_lines="19">
				<diff>@@ -15,6 +15,7 @@ Panels:
         - /GlobalPathAnimation1/Status1
         - /OverlayImage1
         - /OK1
+        - /WARN1
         - /ERROR1
         - /FATAL1
       Splitter Ratio: 0.695804
@@ -37,7 +38,7 @@ Panels:
     Experimental: false
     Name: Time
     SyncMode: 0
-    SyncSource: ""
+    SyncSource: Points Map
 Visualization Manager:
   Class: ""
   Displays:
@@ -64,13 +65,26 @@ Visualization Manager:
       Frame Timeout: 15
       Frames:
         All Enabled: true
+        base_link:
+          Value: true
+        gps:
+          Value: true
+        map:
+          Value: true
+        velodyne:
+          Value: true
       Marker Scale: 5
       Name: TF
       Show Arrows: true
       Show Axes: true
       Show Names: true
       Tree:
-        {}
+        map:
+          base_link:
+            velodyne:
+              {}
+          gps:
+            {}
       Update Interval: 0
       Value: true
     - Alpha: 0.0500000007
@@ -108,7 +122,9 @@ Visualization Manager:
       Marker Topic: /vector_map
       Name: Vector Map
       Namespaces:
-        {}
+        signal: true
+        stop_line: true
+        white_line: true
       Queue Size: 100
       Value: true
     - Class: rviz/Camera
@@ -127,6 +143,8 @@ Visualization Manager:
         Control Pose: true
         Current Pose: true
         Detection Range: true
+        ERROR: true
+        FATAL: true
         Global Path: true
         Global Waypoints: true
         GlobalPathAnimation: true
@@ -134,7 +152,9 @@ Visualization Manager:
         Image: true
         Local Rollouts: true
         Local Waypoints: true
+        MarkerArray: true
         Next Waypoint Mark: true
+        OK: true
         Occupancy Grid Map: true
         OverlayImage: true
         OverlayText: true
@@ -153,13 +173,14 @@ Visualization Manager:
         Vehicle Model: true
         Velocity (km/h): true
         Vscan Points: true
+        WARN: true
         Waypoint Guide: true
       Zoom Factor: 1
     - Alpha: 0.300000012
       Autocompute Intensity Bounds: true
       Autocompute Value Bounds:
-        Max Value: 30.3039417
-        Min Value: 9.71042252
+        Max Value: 11.8534737
+        Min Value: 9.73868942
         Value: true
       Axis: Z
       Channel Name: intensity
@@ -250,7 +271,10 @@ Visualization Manager:
       Marker Topic: /detection_range
       Name: Detection Range
       Namespaces:
-        {}
+        Crosswalk Detection: true
+        Decelerate Detection: true
+        Stop Detection: true
+        Stop Line: true
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -258,7 +282,7 @@ Visualization Manager:
       Marker Topic: /next_target_mark
       Name: Next Waypoint Mark
       Namespaces:
-        {}
+        next_target_marker: true
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -266,7 +290,7 @@ Visualization Manager:
       Marker Topic: /trajectory_circle_mark
       Name: PP Trajectory Mark
       Namespaces:
-        {}
+        trajectory_circle_marker: true
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -287,6 +311,11 @@ Visualization Manager:
         Expand Link Details: false
         Expand Tree: false
         Link Tree Style: Links in Alphabetic Order
+        base_link:
+          Alpha: 1
+          Show Axes: false
+          Show Trail: false
+          Value: true
       Name: Vehicle Model
       Robot Description: robot_description
       TF Prefix: ""
@@ -328,7 +357,9 @@ Visualization Manager:
       Marker Topic: /local_waypoints_mark
       Name: Local Waypoints
       Namespaces:
-        {}
+        local_path_marker: true
+        local_point_marker: true
+        local_waypoint_velocity: true
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -336,7 +367,9 @@ Visualization Manager:
       Marker Topic: /global_waypoints_mark
       Name: Global Waypoints
       Namespaces:
-        {}
+        global_change_flag_lane_1: true
+        global_lane_waypoint_orientation_marker_1: true
+        global_velocity_lane_1: true
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -508,7 +541,7 @@ Visualization Manager:
       Name: OK
       Overtake Color Properties: false
       Overtake Position Properties: false
-      Topic: /health_aggreator/ok_text
+      Topic: /health_aggregator/ok_text
       Value: true
       font: DejaVu Sans Mono
       height: 128
@@ -526,7 +559,7 @@ Visualization Manager:
       Name: WARN
       Overtake Color Properties: false
       Overtake Position Properties: false
-      Topic: /health_aggreator/warn_text
+      Topic: /health_aggregator/warn_text
       Value: true
       font: DejaVu Sans Mono
       height: 128
@@ -544,7 +577,7 @@ Visualization Manager:
       Name: ERROR
       Overtake Color Properties: false
       Overtake Position Properties: false
-      Topic: /health_aggreator/error_text
+      Topic: /health_aggregator/error_text
       Value: true
       font: DejaVu Sans Mono
       height: 128
@@ -562,7 +595,7 @@ Visualization Manager:
       Name: FATAL
       Overtake Color Properties: false
       Overtake Position Properties: false
-      Topic: /health_aggreator/fatal_text
+      Topic: /health_aggregator/fatal_text
       Value: true
       font: DejaVu Sans Mono
       height: 128
@@ -571,6 +604,14 @@ Visualization Manager:
       text size: 12
       top: 0
       width: 128
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /waypoint_saver_marker
+      Name: MarkerArray
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
   Enabled: true
   Global Options:
     Background Color: 48; 48; 48
@@ -605,8 +646,8 @@ Visualization Manager:
       Invert Z Axis: false
       Name: Current View
       Near Clip Distance: 0.00999999978
-      Scale: 10
-      Target Frame: &lt;Fixed Frame&gt;
+      Scale: 19.7382278
+      Target Frame: base_link
       Value: TopDownOrtho (rviz)
       X: 0
       Y: 0
@@ -615,13 +656,13 @@ Window Geometry:
   Camera:
     collapsed: false
   Displays:
-    collapsed: false
+    collapsed: true
   Height: 2136
-  Hide Left Dock: false
+  Hide Left Dock: true
   Hide Right Dock: false
   Image:
     collapsed: false
-  QMainWindow State: 000000ff00000000fd000000040000000000000454000007b0fc020000000efb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006100fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc00000028000007b0000000d700fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000005c00fffffffb0000000c00430061006d0065007200610000000000ffffffff0000006700fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb0000000000000000fb0000000a0049006d006100670065010000056c0000026c00000000000000000000000100000163000007b0fc0200000003fb0000000a005600690065007700730100000028000007b0000000ad00fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e1000001970000000300000ebf0000005cfc0100000002fb0000000800540069006d0065010000000000000ebf0000030000fffffffb0000000800540069006d00650100000000000004500000000000000000000008fc000007b000000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  QMainWindow State: 000000ff00000000fd000000040000000000000454000007b0fc020000000efb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006100fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc00000028000007b00000000000fffffffaffffffff0100000003fb0000000a0049006d0061006700650000000000ffffffff0000005c00fffffffb0000000c00430061006d0065007200610000000000ffffffff0000006700fffffffb000000100044006900730070006c0061007900730000000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb0000000000000000fb0000000a0049006d006100670065010000056c0000026c00000000000000000000000100000163000007b0fc0200000003fb0000000a005600690065007700730100000028000007b0000000ad00fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e1000001970000000300000ebf0000005cfc0100000002fb0000000800540069006d0065010000000000000ebf0000030000fffffffb0000000800540069006d0065010000000000000450000000000000000000000d56000007b000000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_aggregator.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_aggregator.h" added_lines="8" deleted_lines="0">
				<diff>@@ -29,6 +29,7 @@
 #include &lt;autoware_health_checker/constants.h&gt;
 #include &lt;autoware_system_msgs/NodeStatus.h&gt;
 #include &lt;autoware_system_msgs/SystemStatus.h&gt;
+#include &lt;rosgraph_msgs/TopicStatistics.h&gt;
 
 // headers in boost
 #include &lt;boost/foreach.hpp&gt;
@@ -54,10 +55,13 @@ private:
   std::map&lt;uint8_t, ros::Publisher&gt; text_pub_;
   ros::Subscriber node_status_sub_;
   ros::Subscriber diagnostic_array_sub_;
+  ros::Subscriber topic_statistics_sub_;
   void publishSystemStatus();
   void nodeStatusCallback(const autoware_system_msgs::NodeStatus::ConstPtr msg);
   void
   diagnosticArrayCallback(const diagnostic_msgs::DiagnosticArray::ConstPtr msg);
+  void
+  topicStatisticsCallback(const rosgraph_msgs::TopicStatistics::ConstPtr msg);
   std::string
   generateText(std::vector&lt;autoware_system_msgs::DiagnosticStatus&gt; status);
   jsk_rviz_plugins::OverlayText
@@ -69,5 +73,9 @@ private:
   autoware_system_msgs::SystemStatus system_status_;
   std::mutex mtx_;
   void updateConnectionStatus();
+  // key topic_name,publisher_node,subscriber_node
+  std::map&lt;std::array&lt;std::string, 3&gt;, rosgraph_msgs::TopicStatistics&gt;
+      topic_status_;
+  void updateTopicStatus();
 };
 #endif // HEALTH_AGGREGATOR_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\node_status_publisher.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\node_status_publisher.h" added_lines="1" deleted_lines="1">
				<diff>@@ -77,7 +77,7 @@ public:
     new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
     new_status.level = check_result;
     new_status.description = description;
-    new_status.description = ss.str();
+    new_status.value = ss.str();
     new_status.header.stamp = ros::Time::now();
     diag_buffers_[key]-&gt;addDiag(new_status);
     return new_status.level;
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\diag_buffer.cpp" new_path="ros\src\system\autoware_health_checker\src\diag_buffer.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -16,7 +16,7 @@
  *
  * v1.0 Masaya Kataoka
  */
- 
+
 #include &lt;autoware_health_checker/diag_buffer.h&gt;
 
 namespace autoware_health_checker {
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_aggregator.cpp" new_path="ros\src\system\autoware_health_checker\src\health_aggregator.cpp" added_lines="24" deleted_lines="1">
				<diff>@@ -16,7 +16,7 @@
  *
  * v1.0 Masaya Kataoka
  */
- 
+
 #include &lt;autoware_health_checker/health_aggregator.h&gt;
 
 HealthAggregator::HealthAggregator(ros::NodeHandle nh, ros::NodeHandle pnh) {
@@ -41,17 +41,39 @@ void HealthAggregator::run() {
                                    &amp;HealthAggregator::nodeStatusCallback, this);
   diagnostic_array_sub_ = nh_.subscribe(
       "/diagnostic_agg", 10, &amp;HealthAggregator::diagnosticArrayCallback, this);
+  topic_statistics_sub_ = nh_.subscribe(
+      "/statistics", 1, &amp;HealthAggregator::topicStatisticsCallback, this);
   boost::thread publish_thread(
       boost::bind(&amp;HealthAggregator::publishSystemStatus, this));
   return;
 }
 
+void HealthAggregator::topicStatisticsCallback(
+    const rosgraph_msgs::TopicStatistics::ConstPtr msg) {
+  std::array&lt;std::string, 3&gt; key = {msg-&gt;topic, msg-&gt;node_pub, msg-&gt;node_sub};
+  topic_status_[key] = *msg;
+  return;
+}
+
+void HealthAggregator::updateTopicStatus() {
+  ros::Time now = ros::Time::now();
+  for (std::pair&lt;std::array&lt;std::string, 3&gt;, rosgraph_msgs::TopicStatistics&gt;
+           pair : topic_status_) {
+    if ((now - ros::Duration(autoware_health_checker::BUFFER_LENGTH)) &lt;
+        pair.second.window_stop) {
+      system_status_.topic_statistics.push_back(pair.second);
+    }
+  }
+  return;
+}
+
 void HealthAggregator::publishSystemStatus() {
   ros::Rate rate = ros::Rate(autoware_health_checker::UPDATE_RATE);
   while (ros::ok()) {
     mtx_.lock();
     system_status_.header.stamp = ros::Time::now();
     updateConnectionStatus();
+    updateTopicStatus();
     system_status_pub_.publish(system_status_);
     text_pub_[autoware_health_checker::LEVEL_OK].publish(
         generateOverlayText(system_status_, autoware_health_checker::LEVEL_OK));
@@ -61,6 +83,7 @@ void HealthAggregator::publishSystemStatus() {
         system_status_, autoware_health_checker::LEVEL_ERROR));
     text_pub_[autoware_health_checker::LEVEL_FATAL].publish(generateOverlayText(
         system_status_, autoware_health_checker::LEVEL_FATAL));
+    system_status_.topic_statistics.clear();
     system_status_.node_status.clear();
     system_status_.hardware_status.clear();
     mtx_.unlock();
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_aggregator_node.cpp" new_path="ros\src\system\autoware_health_checker\src\health_aggregator_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -22,7 +22,7 @@
 #include &lt;autoware_health_checker/health_aggregator.h&gt;
 
 int main(int argc, char *argv[]) {
-  ros::init(argc, argv, "health_aggreator");
+  ros::init(argc, argv, "health_aggregator");
   ros::NodeHandle nh;
   ros::NodeHandle pnh("~");
   HealthAggregator agg(nh, pnh);
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\node_status_publisher.cpp" new_path="ros\src\system\autoware_health_checker\src\node_status_publisher.cpp" added_lines="2" deleted_lines="1">
				<diff>@@ -16,7 +16,7 @@
  *
  * v1.0 Masaya Kataoka
  */
- 
+
 #include &lt;autoware_health_checker/node_status_publisher.h&gt;
 
 namespace autoware_health_checker {
@@ -141,6 +141,7 @@ uint8_t NodeStatusPublisher::CHECK_MIN_VALUE(std::string key, double value,
   }
   new_status.description = description;
   new_status.value = doubeToJson(value);
+  new_status.header.stamp = ros::Time::now();
   diag_buffers_[key]-&gt;addDiag(new_status);
   return new_status.level;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b6ea662a0432b518448eb8a9a4a6f3f10ef0d9a7" author="Akihito Ohsato">
		<msg>[Feature] Improve AS vehicle interface (#1945)

* Rename and modify as_interface for drive-by-wire

* Fix dependences

* Rename as_interface -&gt; ssc_interface, refactored

* Fix launch

* Modify source of desired values to vehicle_cmd

* Apply clang-format

* Add vehicle_status topic based on feedback topics

* Add rear wheel speed mode, using pacmod/parsed_tx/wheel_speed_rpt instead of as/velocity_accel

* Add emergency stop mode, occured by vehicle_cmd.emergency and timeout

* Add adaptive gear ratio mode, for more accurate steering angle

* Remove unsued definition

* Updated cross-build image date

* Fix zero division</msg>
		<modified_files>
			<file old_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.cpp" new_path="" added_lines="0" deleted_lines="109">
				<diff>@@ -1,109 +0,0 @@
-/*
- * Copyright 2017-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "pacmod_interface.h"
-
-namespace pacmod
-{
-// Constructor
-PacmodInterface::PacmodInterface() :
-    private_nh_("~"),
-    control_mode_(false)
-{
-  initForROS();
-}
-
-// Destructor
-PacmodInterface::~PacmodInterface()
-{
-}
-
-void PacmodInterface::initForROS()
-{
-  // ros parameter settings
-  private_nh_.param&lt;double&gt;("acceleration_limit", acceleration_limit_, 3.0);
-  private_nh_.param&lt;double&gt;("deceleration_limit", deceleration_limit_, 3.0);
-  private_nh_.param&lt;double&gt;("max_curvature_rate", max_curvature_rate_, 0.75);
-
-  // setup subscriber
-  twist_cmd_sub_    = nh_.subscribe("twist_cmd", 10, &amp;PacmodInterface::callbackFromTwistCmd, this);
-  control_mode_sub_ = nh_.subscribe("/as/control_mode", 10, &amp;PacmodInterface::callbackFromControlMode, this);
-  speed_sub_        = nh_.subscribe("/vehicle/steering_report", 10, &amp;PacmodInterface::callbackFromSteeringReport, this);
-
-  // setup publisher
-  steer_mode_pub_    = nh_.advertise&lt;automotive_platform_msgs::SteerMode&gt;("/as/arbitrated_steering_commands", 10);
-  speed_mode_pub_    = nh_.advertise&lt;automotive_platform_msgs::SpeedMode&gt;("/as/arbitrated_speed_commands", 10);
-  current_twist_pub_ = nh_.advertise&lt;geometry_msgs::TwistStamped&gt;("as_current_twist", 10);
-}
-
-void PacmodInterface::run()
-{
-  ros::spin();
-}
-
-
-void PacmodInterface::callbackFromTwistCmd(const geometry_msgs::TwistStampedConstPtr &amp;msg)
-{
-  int mode;
-  if (control_mode_)
-  {
-    mode = 1;
-  }
-  else
-  {
-    mode = 0;
-  }
-
-  automotive_platform_msgs::SpeedMode speed_mode;
-  speed_mode.header = msg-&gt;header;
-  speed_mode.mode = mode;
-  speed_mode.speed = msg-&gt;twist.linear.x;
-  speed_mode.acceleration_limit = 3.0;
-  speed_mode.deceleration_limit = 3.0;
-
-  automotive_platform_msgs::SteerMode steer_mode;
-  steer_mode.header = msg-&gt;header;
-  steer_mode.mode = mode;
-  double curvature = msg-&gt;twist.angular.z / msg-&gt;twist.linear.x;
-  steer_mode.curvature = msg-&gt;twist.linear.x &lt;= 0 ? 0 : curvature;
-  steer_mode.max_curvature_rate = 0.75;
-
-  std::cout &lt;&lt; "mode: "  &lt;&lt; mode &lt;&lt; std::endl;
-  std::cout &lt;&lt; "speed: " &lt;&lt; speed_mode.speed &lt;&lt; std::endl;
-  std::cout &lt;&lt; "steer: " &lt;&lt; steer_mode.curvature &lt;&lt; std::endl;
-
-  speed_mode_pub_.publish(speed_mode);
-  steer_mode_pub_.publish(steer_mode);
-}
-
-void PacmodInterface::callbackFromControlMode(const std_msgs::BoolConstPtr &amp;msg)
-{
-  control_mode_ = msg-&gt;data;
-}
-
-void PacmodInterface::callbackFromSteeringReport(const dbw_mkz_msgs::SteeringReportConstPtr &amp;msg)
-{
-  geometry_msgs::TwistStamped ts;
-  std_msgs::Header header;
-  header.stamp = ros::Time::now();
-  ts.header = header;
-  ts.twist.linear.x = msg-&gt;speed; // [m/sec]
-  // Can we get angular velocity?
-
-  current_twist_pub_.publish(ts);
-}
-
-}  // pacmod
</diff>
			</file>
			<file old_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.h" new_path="" added_lines="0" deleted_lines="70">
				<diff>@@ -1,70 +0,0 @@
-/*
- * Copyright 2017-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef PACMOD_INTERFACE_H
-#define PACMOD_INTERFACE_H
-
-// ROS includes
-#include &lt;ros/ros.h&gt;
-#include &lt;std_msgs/Bool.h&gt;
-#include &lt;geometry_msgs/TwistStamped.h&gt;
-#include &lt;automotive_platform_msgs/SteerMode.h&gt;
-#include &lt;automotive_platform_msgs/SpeedMode.h&gt;
-#include &lt;dbw_mkz_msgs/SteeringReport.h&gt;
-
-namespace pacmod
-{
-class PacmodInterface
-{
-public:
-  PacmodInterface();
-  ~PacmodInterface();
-
-  void run();
-
-private:
-  // handle
-  ros::NodeHandle nh_;
-  ros::NodeHandle private_nh_;
-
-  // publisher
-  ros::Publisher steer_mode_pub_;
-  ros::Publisher speed_mode_pub_;
-  ros::Publisher current_twist_pub_;
-
-  // subscriber
-  ros::Subscriber twist_cmd_sub_;
-  ros::Subscriber control_mode_sub_;
-  ros::Subscriber speed_sub_;
-
-  // ros param
-  double acceleration_limit_;
-  double deceleration_limit_;
-  double max_curvature_rate_;
-
-  // variables
-  bool control_mode_;
-
-  // callbacks
-  void callbackFromTwistCmd(const geometry_msgs::TwistStampedConstPtr &amp;msg);
-  void callbackFromControlMode(const std_msgs::BoolConstPtr &amp;msg);
-  void callbackFromSteeringReport(const dbw_mkz_msgs::SteeringReportConstPtr &amp;msg);
-
-  // initializer
-  void initForROS();
-};
-}  // pacmod
-#endif  // PACMOD_INTERFACE_H
</diff>
			</file>
			<file old_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface_node.cpp" new_path="ros\src\actuation\vehicles\packages\as\nodes\ssc_interface\ssc_interface_node.cpp" added_lines="5" deleted_lines="7">
				<diff>@@ -14,17 +14,15 @@
  * limitations under the License.
  */
 
-// ROS Includes
 #include &lt;ros/ros.h&gt;
 
-#include "pacmod_interface.h"
+#include "ssc_interface.h"
 
-int main(int argc, char **argv)
+int main(int argc, char** argv)
 {
-  ros::init(argc, argv, "pacmod_interface");
-  pacmod::PacmodInterface pacmod_interface;
-
-  pacmod_interface.run();
+  ros::init(argc, argv, "ssc_interface");
+  SSCInterface node;
+  node.run();
 
   return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="44ce96912c6f98691093a47e74f1106667db9487" author="wep21">
		<msg>fix framerate check</msg>
		<modified_files>
			<file old_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\spinnaker\spinnaker.cpp" new_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\spinnaker\spinnaker.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -123,12 +123,12 @@ SpinnakerCamera::SpinnakerCamera()
       ///////////////////////                 FrameRate                   /////////////////////////////
       CFloatPtr ptrAcquisitionFrameRate = node_map_-&gt;GetNode("AcquisitionFrameRate");
       CBooleanPtr ptrAcquisitionFrameRateEnable = node_map_-&gt;GetNode("AcquisitionFrameRateEnable");
-
-      if (IsAvailable(ptrAcquisitionFrameRate) &amp;&amp; IsWritable(ptrAcquisitionFrameRate) &amp;&amp;
-          IsAvailable(ptrAcquisitionFrameRateEnable) &amp;&amp; IsWritable(ptrAcquisitionFrameRateEnable))
+      if (IsAvailable(ptrAcquisitionFrameRateEnable) &amp;&amp; IsWritable(ptrAcquisitionFrameRateEnable))
       {
-        // enable to change fps
         ptrAcquisitionFrameRateEnable-&gt;SetValue(true);
+      }
+      if (IsAvailable(ptrAcquisitionFrameRate) &amp;&amp; IsWritable(ptrAcquisitionFrameRate))
+      {
         ptrAcquisitionFrameRate-&gt;SetValue(fps_);
       }
       else
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="216cf5f8be63b81d46a90615caebf09d67496172" author="ChenxiTU">
		<msg>fix rosbag_controller license (#1924)

* fix rosbag_controller license

* split two licenses</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\autoware_rviz_plugins\rosbag_controller\src\core\recorder.cpp" new_path="ros\src\util\packages\autoware_rviz_plugins\rosbag_controller\src\core\recorder.cpp" added_lines="15" deleted_lines="1">
				<diff>@@ -1,4 +1,18 @@
 /*********************************************************************
+* Copyright 2015-2019 Autoware Foundation
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+**********************************************************************
 * Software License Agreement (BSD License)
 *
 *  Copyright (c) 2008, Willow Garage, Inc.
@@ -30,7 +44,7 @@
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
-********************************************************************/
+*********************************************************************/
 
 #include "recorder.h"
 
</diff>
			</file>
			<file old_path="ros\src\util\packages\autoware_rviz_plugins\rosbag_controller\src\core\recorder.h" new_path="ros\src\util\packages\autoware_rviz_plugins\rosbag_controller\src\core\recorder.h" added_lines="14" deleted_lines="0">
				<diff>@@ -1,4 +1,18 @@
 /*********************************************************************
+* Copyright 2015-2019 Autoware Foundation
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+**********************************************************************
 * Software License Agreement (BSD License)
 *
 *  Copyright (c) 2008, Willow Garage, Inc.
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ed87dfad2ead3087a1dd8a1789200bd1b4d97eab" author="amc-nu">
		<msg>To allow FPS to be set, it requires first to disable FrameRateAuto property</msg>
		<modified_files>
			<file old_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\spinnaker\spinnaker.cpp" new_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\spinnaker\spinnaker.cpp" added_lines="16" deleted_lines="0">
				<diff>@@ -123,6 +123,21 @@ SpinnakerCamera::SpinnakerCamera()
       ///////////////////////                 FrameRate                   /////////////////////////////
       CFloatPtr ptrAcquisitionFrameRate = node_map_-&gt;GetNode("AcquisitionFrameRate");
       CBooleanPtr ptrAcquisitionFrameRateEnable = node_map_-&gt;GetNode("AcquisitionFrameRateEnable");
+      CEnumerationPtr ptrAcquisitionFrameRateAuto = pCamList_[i]-&gt;GetNodeMap().GetNode("AcquisitionFrameRateAuto");
+      if (IsAvailable(ptrAcquisitionFrameRateAuto) &amp;&amp; IsWritable(ptrAcquisitionFrameRateAuto))
+      {
+        CEnumEntryPtr ptrAcquisitionFrameRateAutoOff = ptrAcquisitionFrameRateAuto-&gt;GetEntryByName("Off");
+        if (IsAvailable(ptrAcquisitionFrameRateAutoOff) &amp;&amp; IsReadable(ptrAcquisitionFrameRateAutoOff))
+        {
+          int64_t FrameRateAutoOff = ptrAcquisitionFrameRateAutoOff-&gt;GetValue();
+          ptrAcquisitionFrameRateAuto-&gt;SetIntValue(FrameRateAutoOff);
+          ROS_INFO_STREAM("[" &lt;&lt; __APP_NAME__ &lt;&lt; "] Updated FrameRateAuto to Off");
+        }
+        else
+        {
+          ROS_INFO_STREAM("[" &lt;&lt; __APP_NAME__ &lt;&lt; "] Cannot update FrameRateAuto to Off");
+        }
+      }
       if (IsAvailable(ptrAcquisitionFrameRateEnable) &amp;&amp; IsWritable(ptrAcquisitionFrameRateEnable))
       {
         ptrAcquisitionFrameRateEnable-&gt;SetValue(true);
@@ -130,6 +145,7 @@ SpinnakerCamera::SpinnakerCamera()
       if (IsAvailable(ptrAcquisitionFrameRate) &amp;&amp; IsWritable(ptrAcquisitionFrameRate))
       {
         ptrAcquisitionFrameRate-&gt;SetValue(fps_);
+        ROS_INFO_STREAM("[" &lt;&lt; __APP_NAME__ &lt;&lt; "] Set FrameRate to " &lt;&lt; fps_);
       }
       else
       {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9944c6748db8b75f2797b9397ad034e65093ef89" author="amc-nu">
		<msg>Include app name in log message</msg>
		<modified_files>
			<file old_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\spinnaker\spinnaker.cpp" new_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\spinnaker\spinnaker.cpp" added_lines="2" deleted_lines="1">
				<diff>@@ -156,7 +156,8 @@ SpinnakerCamera::SpinnakerCamera()
       CEnumerationPtr ptrPixelFormat = node_map_-&gt;GetNode("PixelFormat");
       if (IsAvailable(ptrPixelFormat) &amp;&amp; IsWritable(ptrPixelFormat))
       {
-        ROS_INFO_STREAM("Current Format" &lt;&lt; ptrPixelFormat-&gt;GetCurrentEntry()-&gt;GetSymbolic());
+        ROS_INFO_STREAM("[" &lt;&lt; __APP_NAME__ &lt;&lt; "] Current pixel Format"
+                            &lt;&lt; ptrPixelFormat-&gt;GetCurrentEntry()-&gt;GetSymbolic());
         /*gcstring pixel_format = format_.c_str();
 
         CEnumEntryPtr ptrPixelFormatSetup = ptrPixelFormat-&gt;GetEntryByName(pixel_format);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e4187a7138eb90ad6f119eb35f824b16465aefda" author="Masaya Kataoka">
		<msg>Fix/health checker (#2012)</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\default.rviz" new_path="ros\src\.config\rviz\default.rviz" added_lines="22" deleted_lines="32">
				<diff>@@ -67,24 +67,23 @@ Visualization Manager:
         All Enabled: true
         base_link:
           Value: true
-        gps:
-          Value: true
         map:
           Value: true
         velodyne:
           Value: true
+        world:
+          Value: true
       Marker Scale: 5
       Name: TF
       Show Arrows: true
       Show Axes: true
       Show Names: true
       Tree:
-        map:
-          base_link:
-            velodyne:
-              {}
-          gps:
-            {}
+        world:
+          map:
+            base_link:
+              velodyne:
+                {}
       Update Interval: 0
       Value: true
     - Alpha: 0.0500000007
@@ -122,9 +121,7 @@ Visualization Manager:
       Marker Topic: /vector_map
       Name: Vector Map
       Namespaces:
-        signal: true
-        stop_line: true
-        white_line: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Camera
@@ -179,8 +176,8 @@ Visualization Manager:
     - Alpha: 0.300000012
       Autocompute Intensity Bounds: true
       Autocompute Value Bounds:
-        Max Value: 11.8534737
-        Min Value: 9.73868942
+        Max Value: 11.6879101
+        Min Value: -11.4952602
         Value: true
       Axis: Z
       Channel Name: intensity
@@ -271,10 +268,7 @@ Visualization Manager:
       Marker Topic: /detection_range
       Name: Detection Range
       Namespaces:
-        Crosswalk Detection: true
-        Decelerate Detection: true
-        Stop Detection: true
-        Stop Line: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -282,7 +276,7 @@ Visualization Manager:
       Marker Topic: /next_target_mark
       Name: Next Waypoint Mark
       Namespaces:
-        next_target_marker: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -290,7 +284,7 @@ Visualization Manager:
       Marker Topic: /trajectory_circle_mark
       Name: PP Trajectory Mark
       Namespaces:
-        trajectory_circle_marker: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -357,9 +351,7 @@ Visualization Manager:
       Marker Topic: /local_waypoints_mark
       Name: Local Waypoints
       Namespaces:
-        local_path_marker: true
-        local_point_marker: true
-        local_waypoint_velocity: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -367,9 +359,7 @@ Visualization Manager:
       Marker Topic: /global_waypoints_mark
       Name: Global Waypoints
       Namespaces:
-        global_change_flag_lane_1: true
-        global_lane_waypoint_orientation_marker_1: true
-        global_velocity_lane_1: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -522,15 +512,15 @@ Visualization Manager:
       Unreliable: false
       Value: false
     - Class: jsk_rviz_plugin/OverlayImage
-      Enabled: false
+      Enabled: true
       Name: OverlayImage
       Topic: /image_raw
-      Value: false
+      Value: true
       alpha: 0.800000012
       height: 128
       keep aspect ratio: true
       left: 128
-      top: 128
+      top: 720
       width: 640
     - Background Alpha: 0.800000012
       Background Color: 0; 0; 0
@@ -646,11 +636,11 @@ Visualization Manager:
       Invert Z Axis: false
       Name: Current View
       Near Clip Distance: 0.00999999978
-      Scale: 19.7382278
-      Target Frame: base_link
+      Scale: 3.93164873
+      Target Frame: world
       Value: TopDownOrtho (rviz)
-      X: 0
-      Y: 0
+      X: 1027.31726
+      Y: 636.823425
     Saved: ~
 Window Geometry:
   Camera:
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="8" deleted_lines="10">
				<diff>@@ -70,7 +70,7 @@
 #include &lt;autoware_msgs/NDTStat.h&gt;
 
 //headers in Autoware Health Checker
-#include &lt;autoware_health_checker/node_status_publisher.h&gt;
+#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
 
 #define PREDICT_POSE_THRESHOLD 0.5
 
@@ -78,7 +78,7 @@
 #define Wb 0.3
 #define Wc 0.3
 
-static std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr_;
+static std::shared_ptr&lt;autoware_health_checker::HealthChecker&gt; health_checker_ptr_;
 
 struct pose
 {
@@ -921,7 +921,6 @@ static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
 
 static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 {
-  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/points_raw/slow",8,5,1,"topic points_raw subscribe rate low.");
   if (map_loaded == 1 &amp;&amp; init_pos_set == 1)
   {
     matching_start = std::chrono::system_clock::now();
@@ -1354,7 +1353,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     }
 
     predict_pose_pub.publish(predict_pose_msg);
-    node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/ndt_pose/slow",8,5,1,"topic points_raw publish rate low.");
     ndt_pose_pub.publish(ndt_pose_msg);
     // current_pose is published by vel_pose_mux
     //    current_pose_pub.publish(current_pose_msg);
@@ -1376,7 +1374,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     matching_end = std::chrono::system_clock::now();
     exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(matching_end - matching_start).count() / 1000.0;
     time_ndt_matching.data = exe_time;
-    node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/time_ndt_matching",time_ndt_matching.data,50,70,100,"value time_ndt_matching is too high.");
+    health_checker_ptr_-&gt;CHECK_MAX_VALUE("time_ndt_matching",time_ndt_matching.data,50,70,100,"value time_ndt_matching is too high.");
     time_ndt_matching_pub.publish(time_ndt_matching);
 
     // Set values for /estimate_twist
@@ -1394,8 +1392,8 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     geometry_msgs::Vector3Stamped estimate_vel_msg;
     estimate_vel_msg.header.stamp = current_scan_time;
     estimate_vel_msg.vector.x = current_velocity;
-    node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/estimate_twist/linear",current_velocity,5,10,15,"value linear estimated twist is too high.");
-    node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/estimate_twist/angular",angular_velocity,5,10,15,"value linear angular twist is too high.");
+    health_checker_ptr_-&gt;CHECK_MAX_VALUE("estimate_twist_linear",current_velocity,5,10,15,"value linear estimated twist is too high.");
+    health_checker_ptr_-&gt;CHECK_MAX_VALUE("estimate_twist_angular",angular_velocity,5,10,15,"value linear angular twist is too high.");
     estimated_vel_pub.publish(estimate_vel_msg);
 
     // Set values for /ndt_stat
@@ -1524,9 +1522,9 @@ int main(int argc, char** argv)
 
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
-  node_status_publisher_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh,private_nh);
-  node_status_publisher_ptr_-&gt;ENABLE();
-  node_status_publisher_ptr_-&gt;NODE_ACTIVATE();
+  health_checker_ptr_ = std::make_shared&lt;autoware_health_checker::HealthChecker&gt;(nh,private_nh);
+  health_checker_ptr_-&gt;ENABLE();
+  health_checker_ptr_-&gt;NODE_ACTIVATE();
 
   // Set log file name.
   private_nh.getParam("output_log_data", _output_log_data);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" added_lines="4" deleted_lines="6">
				<diff>@@ -32,8 +32,8 @@ SearchInfo::SearchInfo()
 {
   ros::NodeHandle nh;
   ros::NodeHandle private_nh_("~");
-  node_status_publisher_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh,private_nh_);
-  node_status_publisher_ptr_-&gt;ENABLE();
+  health_checker_ptr_ = std::make_shared&lt;autoware_health_checker::HealthChecker&gt;(nh,private_nh_);
+  health_checker_ptr_-&gt;ENABLE();
   private_nh_.param&lt;std::string&gt;("map_frame", map_frame_, "map");
   private_nh_.param&lt;int&gt;("obstacle_detect_count", obstacle_detect_count_, 10);
   private_nh_.param&lt;int&gt;("avoid_distance", avoid_distance_, 13);
@@ -98,14 +98,13 @@ void SearchInfo::mapCallback(const nav_msgs::OccupancyGridConstPtr &amp;msg)
 void SearchInfo::currentPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 {
   current_pose_ = *msg;
-  node_status_publisher_ptr_-&gt;NODE_ACTIVATE();
-  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/current_pose/slow",8,5,1,"topic current_pose subscribe rate low.");
+  health_checker_ptr_-&gt;NODE_ACTIVATE();
   if(closest_waypoint_index_!=-1 &amp;&amp; path_set_)
   {
     autoware_msgs::Waypoint closest_waypoint = subscribed_waypoints_.waypoints[closest_waypoint_index_];
     double dist = std::sqrt(std::pow(closest_waypoint.pose.pose.position.x-current_pose_.pose.position.x,2)
       +std::pow(closest_waypoint.pose.pose.position.y-current_pose_.pose.position.y,2));
-    node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/range/closest_waypoint_distance",dist,0.5,1.0,2.0,"distance between closest_waypoint and current_pose is too long.");
+    health_checker_ptr_-&gt;CHECK_MAX_VALUE("closest_waypoint_distance",dist,0.5,1.0,2.0,"distance between closest_waypoint and current_pose is too long.");
   }
   return;
 }
@@ -182,7 +181,6 @@ void SearchInfo::waypointsCallback(const autoware_msgs::LaneConstPtr &amp;msg)
 
 void SearchInfo::closestWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
 {
-  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/closest_waypoint/slow",8,5,1,"topic closest_waypoint subscribe rate low.");
   closest_waypoint_index_ = msg-&gt;data;
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" added_lines="2" deleted_lines="2">
				<diff>@@ -27,7 +27,7 @@
 #include &lt;std_msgs/Int32.h&gt;
 #include &lt;std_msgs/String.h&gt;
 
-#include &lt;autoware_health_checker/node_status_publisher.h&gt;
+#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
 #include &lt;memory&gt;
 
 namespace astar_planner
@@ -143,7 +143,7 @@ public:
 private:
   double calcPathLength(const autoware_msgs::Lane &amp;lane, const int start_waypoint_index,
                         const int goal_waypoint_index) const;
-  std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr_;
+  std::shared_ptr&lt;autoware_health_checker::HealthChecker&gt; health_checker_ptr_;
   nav_msgs::OccupancyGrid map_;
   geometry_msgs::PoseStamped start_pose_global_;
   geometry_msgs::PoseStamped goal_pose_global_;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" added_lines="3" deleted_lines="6">
				<diff>@@ -43,8 +43,8 @@ VelocitySetInfo::VelocitySetInfo()
   ros::NodeHandle private_nh_("~");
   ros::NodeHandle nh;
   private_nh_.param&lt;double&gt;("remove_points_upto", remove_points_upto_, 2.3);
-  node_status_publisher_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh,private_nh_);
-  node_status_publisher_ptr_-&gt;ENABLE();
+  health_checker_ptr_ = std::make_shared&lt;autoware_health_checker::HealthChecker&gt;(nh,private_nh_);
+  health_checker_ptr_-&gt;ENABLE();
 }
 
 VelocitySetInfo::~VelocitySetInfo()
@@ -73,7 +73,6 @@ void VelocitySetInfo::configCallback(const autoware_config_msgs::ConfigVelocityS
 
 void VelocitySetInfo::pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg)
 {
-  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/points_no_ground/slow",8,5,1,"topic points_no_ground subscribe rate low.");
   pcl::PointCloud&lt;pcl::PointXYZ&gt; sub_points;
   pcl::fromROSMsg(*msg, sub_points);
 
@@ -108,15 +107,13 @@ void VelocitySetInfo::detectionCallback(const std_msgs::Int32 &amp;msg)
 void VelocitySetInfo::controlPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 {
   control_pose_ = *msg;
-
+  health_checker_ptr_-&gt;NODE_ACTIVATE();
   if (!set_pose_)
     set_pose_ = true;
 }
 
 void VelocitySetInfo::localizerPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 {
-  node_status_publisher_ptr_-&gt;NODE_ACTIVATE();
-  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/current_pose/slow",8,5,1,"topic current_pose subscribe rate low.");
   localizer_pose_ = *msg;
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" added_lines="2" deleted_lines="2">
				<diff>@@ -24,7 +24,7 @@
 
 #include "autoware_config_msgs/ConfigVelocitySet.h"
 
-#include &lt;autoware_health_checker/node_status_publisher.h&gt;
+#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
 #include &lt;memory&gt;
 
 class VelocitySetInfo
@@ -54,7 +54,7 @@ class VelocitySetInfo
   bool set_pose_;
   bool use_obstacle_sim_;
 
-  std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr_;
+  std::shared_ptr&lt;autoware_health_checker::HealthChecker&gt; health_checker_ptr_;
 
  public:
   VelocitySetInfo();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="4" deleted_lines="5">
				<diff>@@ -36,8 +36,8 @@ PurePursuitNode::PurePursuitNode()
   , minimum_lookahead_distance_(6.0)
 {
   initForROS();
-  node_status_publisher_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh_,private_nh_);
-  node_status_publisher_ptr_-&gt;ENABLE();
+  health_checker_ptr_ = std::make_shared&lt;autoware_health_checker::HealthChecker&gt;(nh_,private_nh_);
+  health_checker_ptr_-&gt;ENABLE();
   // initialize for PurePursuit
   pp_.setLinearInterpolationParameter(is_linear_interpolation_);
 }
@@ -96,8 +96,7 @@ void PurePursuitNode::run()
     
     publishTwistStamped(can_get_curvature, kappa);
     publishControlCommandStamped(can_get_curvature, kappa);
-    node_status_publisher_ptr_-&gt;NODE_ACTIVATE();
-    node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/vehicle/slow",8,5,1,"topic vehicle_cmd publish rate low.");
+    health_checker_ptr_-&gt;NODE_ACTIVATE();
     // for visualization with Rviz
     pub11_.publish(displayNextWaypoint(pp_.getPoseOfNextWaypoint()));
     pub13_.publish(displaySearchRadius(pp_.getCurrentPose().position, pp_.getLookaheadDistance()));
@@ -124,7 +123,7 @@ void PurePursuitNode::publishTwistStamped(const bool &amp;can_get_curvature, const d
   ts.header.stamp = ros::Time::now();
   ts.twist.linear.x = can_get_curvature ? computeCommandVelocity() : 0;
   ts.twist.angular.z = can_get_curvature ? kappa * ts.twist.linear.x : 0;
-  node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/twist",ts.twist.linear.x,2.2,3.3,4.4,"linear twist_cmd is too high");
+  health_checker_ptr_-&gt;CHECK_MAX_VALUE("twist_cmd_linear_high",ts.twist.linear.x,2.2,3.3,4.4,"linear twist_cmd is too high");
   pub1_.publish(ts);
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -31,7 +31,7 @@
 #include "pure_pursuit.h"
 #include "pure_pursuit_viz.h"
 
-#include &lt;autoware_health_checker/node_status_publisher.h&gt;
+#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
 
 #include &lt;memory&gt;
 
@@ -64,7 +64,7 @@ private:
   ros::NodeHandle nh_;
   ros::NodeHandle private_nh_;
 
-  std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr_;
+  std::shared_ptr&lt;autoware_health_checker::HealthChecker&gt; health_checker_ptr_;
 
   // class
   PurePursuit pp_;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" added_lines="3" deleted_lines="4">
				<diff>@@ -50,7 +50,7 @@
 #include "autoware_msgs/ControlCommandStamped.h"
 
 //headers in Autowae Health Checker
-#include &lt;autoware_health_checker/node_status_publisher.h&gt;
+#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
 
 class TwistGate
 {
@@ -76,7 +76,7 @@ class TwistGate
 
     ros::NodeHandle nh_;
     ros::NodeHandle private_nh_;
-    std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_pub_ptr_;
+    std::shared_ptr&lt;autoware_health_checker::HealthChecker&gt; node_status_pub_ptr_;
     ros::Publisher emergency_stop_pub_;
     ros::Publisher control_command_pub_;
     ros::Publisher vehicle_cmd_pub_;
@@ -104,7 +104,7 @@ TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_n
     ,command_mode_(CommandMode::AUTO)
     ,previous_command_mode_(CommandMode::AUTO)
 {
-  node_status_pub_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh_,private_nh_);
+  node_status_pub_ptr_ = std::make_shared&lt;autoware_health_checker::HealthChecker&gt;(nh_,private_nh_);
   emergency_stop_pub_ = nh_.advertise&lt;std_msgs::Bool&gt;("/emergency_stop", 1, true);
   control_command_pub_ = nh_.advertise&lt;std_msgs::String&gt;("/ctrl_mode", 1);
   vehicle_cmd_pub_ = nh_.advertise&lt;vehicle_cmd_msg_t&gt;("/vehicle_cmd", 1, true);
@@ -234,7 +234,6 @@ void TwistGate::remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg)
 void TwistGate::auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::ConstPtr&amp; input_msg)
 {
   node_status_pub_ptr_-&gt;NODE_ACTIVATE();
-  node_status_pub_ptr_-&gt;CHECK_RATE("/topic/rate/twist_cmd/slow",8,5,1,"topic twist_cmd subscribe rate low.");
   if(command_mode_ == CommandMode::AUTO)
   {
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\include\ray_ground_filter.h" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\include\ray_ground_filter.h" added_lines="2" deleted_lines="2">
				<diff>@@ -34,7 +34,7 @@
 #include "autoware_config_msgs/ConfigRayGroundFilter.h"
 
 //headers in Autoware Health Checker
-#include &lt;autoware_health_checker/node_status_publisher.h&gt;
+#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
 
 #include &lt;opencv2/core/version.hpp&gt;
 #if (CV_MAJOR_VERSION == 3)
@@ -46,7 +46,7 @@
 class RayGroundFilter
 {
 private:
-	std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_pub_ptr_;
+	std::shared_ptr&lt;autoware_health_checker::HealthChecker&gt; node_status_pub_ptr_;
 	ros::NodeHandle     node_handle_;
 	ros::Subscriber     points_node_sub_;
 	ros::Subscriber     config_node_sub_;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\ray_ground_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\ray_ground_filter.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -284,7 +284,6 @@ void RayGroundFilter::RemovePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Pt
 void RayGroundFilter::CloudCallback(const sensor_msgs::PointCloud2ConstPtr &amp;in_sensor_cloud)
 {
   node_status_pub_ptr_-&gt;NODE_ACTIVATE();
-  node_status_pub_ptr_-&gt;CHECK_RATE("/topic/rate/points_raw/slow",8,5,1,"topic points_raw subscribe rate low.");
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr current_sensor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
   pcl::fromROSMsg(*in_sensor_cloud, *current_sensor_cloud_ptr);
 
@@ -331,7 +330,7 @@ RayGroundFilter::RayGroundFilter():node_handle_("~")
 {
   ros::NodeHandle nh;
   ros::NodeHandle pnh("~");
-  node_status_pub_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh,pnh);
+  node_status_pub_ptr_ = std::make_shared&lt;autoware_health_checker::HealthChecker&gt;(nh,pnh);
   node_status_pub_ptr_-&gt;ENABLE();
 }
 
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\constants.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\constants.h" added_lines="0" deleted_lines="7">
				<diff>@@ -30,13 +30,6 @@ constexpr uint8_t LEVEL_WARN = autoware_system_msgs::DiagnosticStatus::WARN;
 constexpr uint8_t LEVEL_ERROR = autoware_system_msgs::DiagnosticStatus::ERROR;
 constexpr uint8_t LEVEL_FATAL = autoware_system_msgs::DiagnosticStatus::FATAL;
 
-constexpr uint8_t TYPE_UNDEFINED =
-    autoware_system_msgs::DiagnosticStatus::UNDEFINED;
-constexpr uint8_t TYPE_OUT_OF_RANGE =
-    autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
-constexpr uint8_t TYPE_RATE_IS_SLOW =
-    autoware_system_msgs::DiagnosticStatus::RATE_IS_SLOW;
-
 constexpr double BUFFER_LENGTH = 5.0;
 constexpr double UPDATE_RATE = 10.0;
 }
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_aggregator.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_aggregator\health_aggregator.h" added_lines="12" deleted_lines="0">
				<diff>@@ -56,6 +56,9 @@ private:
   ros::Subscriber node_status_sub_;
   ros::Subscriber diagnostic_array_sub_;
   ros::Subscriber topic_statistics_sub_;
+  XmlRpc::XmlRpcValue topic_rate_params_;
+  XmlRpc::XmlRpcValue drop_rate_params_;
+  void addTopicDiag();
   void publishSystemStatus();
   void nodeStatusCallback(const autoware_system_msgs::NodeStatus::ConstPtr msg);
   void
@@ -72,10 +75,19 @@ private:
   convert(const diagnostic_msgs::DiagnosticArray::ConstPtr msg);
   autoware_system_msgs::SystemStatus system_status_;
   std::mutex mtx_;
+  bool ros_ok_;
   void updateConnectionStatus();
   // key topic_name,publisher_node,subscriber_node
   std::map&lt;std::array&lt;std::string, 3&gt;, rosgraph_msgs::TopicStatistics&gt;
       topic_status_;
   void updateTopicStatus();
+  template &lt;typename T&gt; std::string valueToJson(T value) {
+    using namespace boost::property_tree;
+    std::stringstream ss;
+    ptree pt;
+    pt.put("value", value);
+    write_json(ss, pt);
+    return ss.str();
+  }
 };
 #endif // HEALTH_AGGREGATOR_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_analyzer.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_analyzer\health_analyzer.h" added_lines="1" deleted_lines="1">
				<diff>@@ -84,7 +84,7 @@ private:
   int countWarn(autoware_system_msgs::SystemStatus msg);
   void writeDot();
   graph_t depend_graph_;
-  int warn_nodes_count_threshold_;
+  int warn_count_threshold_;
   template &lt;typename T&gt; bool isAlreadyExist(std::vector&lt;T&gt; vector, T target) {
     for (auto itr = vector.begin(); itr != vector.end(); itr++) {
       if (target == *itr) {
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\diag_buffer.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_checker\diag_buffer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\node_status_publisher.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_checker\health_checker.h" added_lines="27" deleted_lines="14">
				<diff>@@ -1,5 +1,5 @@
-#ifndef NODE_STATUS_PUBLISHER_H_INCLUDED
-#define NODE_STATUS_PUBLISHER_H_INCLUDED
+#ifndef HEALTH_CHECKER_H_INCLUDED
+#define HEALTH_CHECKER_H_INCLUDED
 
 /*
  * Copyright 2019 Autoware Foundation. All rights reserved.
@@ -25,9 +25,10 @@
 
 // headers in Autoware
 #include &lt;autoware_health_checker/constants.h&gt;
-#include &lt;autoware_health_checker/diag_buffer.h&gt;
-#include &lt;autoware_health_checker/rate_checker.h&gt;
 #include &lt;autoware_system_msgs/NodeStatus.h&gt;
+#include &lt;autoware_health_checker/health_checker/diag_buffer.h&gt;
+#include &lt;autoware_health_checker/health_checker/rate_checker.h&gt;
+#include &lt;autoware_health_checker/health_checker/value_manager.h&gt;
 
 // headers in STL
 #include &lt;functional&gt;
@@ -44,10 +45,10 @@
 #include &lt;boost/thread.hpp&gt;
 
 namespace autoware_health_checker {
-class NodeStatusPublisher {
+class HealthChecker {
 public:
-  NodeStatusPublisher(ros::NodeHandle nh, ros::NodeHandle pnh);
-  ~NodeStatusPublisher();
+  HealthChecker(ros::NodeHandle nh, ros::NodeHandle pnh);
+  ~HealthChecker();
   void ENABLE();
   uint8_t CHECK_MIN_VALUE(std::string key, double value, double warn_value,
                           double error_value, double fatal_value,
@@ -67,14 +68,14 @@ public:
       std::string key, T value, std::function&lt;uint8_t(T value)&gt; check_func,
       std::function&lt;boost::property_tree::ptree(T value)&gt; value_json_func,
       std::string description) {
-    addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,
+    addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::INVALID_VALUE,
                  description);
     uint8_t check_result = check_func(value);
     boost::property_tree::ptree pt = value_json_func(value);
     std::stringstream ss;
     write_json(ss, pt);
     autoware_system_msgs::DiagnosticStatus new_status;
-    new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
+    new_status.type = autoware_system_msgs::DiagnosticStatus::INVALID_VALUE;
     new_status.level = check_result;
     new_status.description = description;
     new_status.value = ss.str();
@@ -84,6 +85,9 @@ public:
   }
   void CHECK_RATE(std::string key, double warn_rate, double error_rate,
                   double fatal_rate, std::string description);
+  uint8_t CHECK_TRUE(std::string key, bool value, uint8_t level,
+                     std::string description);
+  uint8_t SET_DIAG_STATUS(autoware_system_msgs::DiagnosticStatus status);
   void NODE_ACTIVATE() {
     std::lock_guard&lt;std::mutex&gt; lock(mtx_);
     node_activated_ = true;
@@ -95,19 +99,28 @@ public:
   bool getNodeStatus() { return node_activated_; };
 
 private:
+  ValueManager value_manager_;
   std::vector&lt;std::string&gt; getKeys();
   std::vector&lt;std::string&gt; getRateCheckerKeys();
   ros::NodeHandle nh_;
   ros::NodeHandle pnh_;
-  std::map&lt;std::string, std::shared_ptr&lt;DiagBuffer&gt;&gt; diag_buffers_;
-  std::map&lt;std::string, std::shared_ptr&lt;RateChecker&gt;&gt; rate_checkers_;
+  std::map&lt;std::string, std::unique_ptr&lt;DiagBuffer&gt;&gt; diag_buffers_;
+  std::map&lt;std::string, std::unique_ptr&lt;RateChecker&gt;&gt; rate_checkers_;
   ros::Publisher status_pub_;
   bool keyExist(std::string key);
-  void addNewBuffer(std::string key, uint8_t type, std::string description);
-  std::string doubeToJson(double value);
+  bool addNewBuffer(std::string key, uint8_t type, std::string description);
+  template &lt;typename T&gt; std::string valueToJson(T value) {
+    using namespace boost::property_tree;
+    std::stringstream ss;
+    ptree pt;
+    pt.put("value", value);
+    write_json(ss, pt);
+    return ss.str();
+  }
   void publishStatus();
   bool node_activated_;
+  bool ros_ok_;
   std::mutex mtx_;
 };
 }
-#endif // NODE_STATUS_PUBLISHER_H_INCLUDED
\ No newline at end of file
+#endif // HEALTH_CHECKER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\rate_checker.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_checker\rate_checker.h" added_lines="5" deleted_lines="4">
				<diff>@@ -44,15 +44,16 @@ public:
   uint8_t getErrorLevel();
   boost::optional&lt;double&gt; getRate();
   const std::string description;
+  void setRate(double warn_rate, double error_rate, double fatal_rate);
 
 private:
   ros::Time start_time_;
   void update();
   std::vector&lt;ros::Time&gt; data_;
-  const double buffer_length_;
-  const double warn_rate_;
-  const double error_rate_;
-  const double fatal_rate_;
+  double buffer_length_;
+  double warn_rate_;
+  double error_rate_;
+  double fatal_rate_;
   std::mutex mtx_;
 };
 }
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\system_status_subscriber.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\system_status_subscriber\system_status_subscriber.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_aggregator.cpp" new_path="ros\src\system\autoware_health_checker\src\health_aggregator\health_aggregator.cpp" added_lines="104" deleted_lines="4">
				<diff>@@ -17,14 +17,15 @@
  * v1.0 Masaya Kataoka
  */
 
-#include &lt;autoware_health_checker/health_aggregator.h&gt;
+#include &lt;autoware_health_checker/health_aggregator/health_aggregator.h&gt;
 
 HealthAggregator::HealthAggregator(ros::NodeHandle nh, ros::NodeHandle pnh) {
   nh_ = nh;
   pnh_ = pnh;
+  ros_ok_ = true;
 }
 
-HealthAggregator::~HealthAggregator() {}
+HealthAggregator::~HealthAggregator() { ros_ok_ = false; }
 
 void HealthAggregator::run() {
   system_status_pub_ =
@@ -40,7 +41,7 @@ void HealthAggregator::run() {
   node_status_sub_ = nh_.subscribe("/node_status", 10,
                                    &amp;HealthAggregator::nodeStatusCallback, this);
   diagnostic_array_sub_ = nh_.subscribe(
-      "/diagnostic_agg", 10, &amp;HealthAggregator::diagnosticArrayCallback, this);
+      "/diagnostics_agg", 10, &amp;HealthAggregator::diagnosticArrayCallback, this);
   topic_statistics_sub_ = nh_.subscribe(
       "/statistics", 1, &amp;HealthAggregator::topicStatisticsCallback, this);
   boost::thread publish_thread(
@@ -48,6 +49,102 @@ void HealthAggregator::run() {
   return;
 }
 
+void HealthAggregator::addTopicDiag() {
+  for (auto itr = topic_rate_params_.begin(); itr != topic_rate_params_.end();
+       itr++) {
+    std::string key = itr-&gt;first;
+    XmlRpc::XmlRpcValue data = itr-&gt;second["sub_node"];
+    std::string sub_node = data;
+    data = itr-&gt;second["pub_node"];
+    std::string pub_node = data;
+    data = itr-&gt;second["topic_name"];
+    std::string topic_name = data;
+    data = itr-&gt;second["topic_rate"]["warn"];
+    double warn_topic_rate = data;
+    data = itr-&gt;second["topic_rate"]["error"];
+    double error_topic_rate = data;
+    data = itr-&gt;second["topic_rate"]["fatal"];
+    double fatal_topic_rate = data;
+    autoware_system_msgs::DiagnosticStatus diag_topic_rate;
+    diag_topic_rate.key = key;
+    diag_topic_rate.description = topic_name + " in " + sub_node + " from " +
+                                  pub_node + " topic rate is slow";
+    diag_topic_rate.type = diag_topic_rate.TOPIC_RATE_IS_SLOW;
+    std::array&lt;std::string, 3&gt; query_key = {topic_name, pub_node, sub_node};
+    if (topic_status_.count(query_key) != 0) {
+      rosgraph_msgs::TopicStatistics stat = topic_status_[query_key];
+      double topic_rate =
+          (double)stat.delivered_msgs /
+          (double)(stat.window_stop - stat.window_start).toSec();
+      diag_topic_rate.header.stamp = stat.window_stop;
+      diag_topic_rate.key = key;
+      diag_topic_rate.value = valueToJson(topic_rate);
+      if (topic_rate &lt; fatal_topic_rate) {
+        diag_topic_rate.level = autoware_health_checker::LEVEL_FATAL;
+      } else if (topic_rate &lt; error_topic_rate) {
+        diag_topic_rate.level = autoware_health_checker::LEVEL_ERROR;
+      } else if (topic_rate &lt; error_topic_rate) {
+        diag_topic_rate.level = autoware_health_checker::LEVEL_WARN;
+      } else {
+        diag_topic_rate.level = autoware_health_checker::LEVEL_OK;
+      }
+      for (auto node_status_itr = system_status_.node_status.begin();
+           node_status_itr != system_status_.node_status.end();
+           node_status_itr++) {
+        autoware_system_msgs::DiagnosticStatusArray diag;
+        diag.status.push_back(diag_topic_rate);
+        node_status_itr-&gt;status.push_back(diag);
+      }
+    }
+  }
+  for (auto itr = drop_rate_params_.begin(); itr != drop_rate_params_.end();
+       itr++) {
+    std::string key = itr-&gt;first;
+    XmlRpc::XmlRpcValue data = itr-&gt;second["sub_node"];
+    std::string sub_node = data;
+    data = itr-&gt;second["pub_node"];
+    std::string pub_node = data;
+    data = itr-&gt;second["topic_name"];
+    std::string topic_name = data;
+    data = itr-&gt;second["drop_rate"]["warn"];
+    double warn_drop_rate = data;
+    data = itr-&gt;second["drop_rate"]["error"];
+    double error_drop_rate = data;
+    data = itr-&gt;second["drop_rate"]["fatal"];
+    double fatal_drop_rate = data;
+    autoware_system_msgs::DiagnosticStatus diag_drop_rate;
+    diag_drop_rate.key = key;
+    diag_drop_rate.description = topic_name + " in " + sub_node + " from " +
+                                 pub_node + " message deop rate is too high";
+    diag_drop_rate.type = diag_drop_rate.TOPIC_DROP_RATE_IS_HIGH;
+    std::array&lt;std::string, 3&gt; query_key = {topic_name, pub_node, sub_node};
+    if (topic_status_.count(query_key) != 0) {
+      rosgraph_msgs::TopicStatistics stat = topic_status_[query_key];
+      double drop_rate = (double)stat.dropped_msgs /
+                         (double)(stat.dropped_msgs + stat.delivered_msgs);
+      diag_drop_rate.header.stamp = stat.window_stop;
+      diag_drop_rate.key = key;
+      diag_drop_rate.value = valueToJson(drop_rate);
+      if (drop_rate &gt; fatal_drop_rate) {
+        diag_drop_rate.level = autoware_health_checker::LEVEL_FATAL;
+      } else if (drop_rate &gt; error_drop_rate) {
+        diag_drop_rate.level = autoware_health_checker::LEVEL_ERROR;
+      } else if (drop_rate &gt; error_drop_rate) {
+        diag_drop_rate.level = autoware_health_checker::LEVEL_WARN;
+      } else {
+        diag_drop_rate.level = autoware_health_checker::LEVEL_OK;
+      }
+      for (auto node_status_itr = system_status_.node_status.begin();
+           node_status_itr != system_status_.node_status.end();
+           node_status_itr++) {
+        autoware_system_msgs::DiagnosticStatusArray diag;
+        diag.status.push_back(diag_drop_rate);
+        node_status_itr-&gt;status.push_back(diag);
+      }
+    }
+  }
+}
+
 void HealthAggregator::topicStatisticsCallback(
     const rosgraph_msgs::TopicStatistics::ConstPtr msg) {
   std::array&lt;std::string, 3&gt; key = {msg-&gt;topic, msg-&gt;node_pub, msg-&gt;node_sub};
@@ -64,13 +161,16 @@ void HealthAggregator::updateTopicStatus() {
       system_status_.topic_statistics.push_back(pair.second);
     }
   }
+  addTopicDiag();
   return;
 }
 
 void HealthAggregator::publishSystemStatus() {
   ros::Rate rate = ros::Rate(autoware_health_checker::UPDATE_RATE);
-  while (ros::ok()) {
+  while (ros_ok_) {
     mtx_.lock();
+    nh_.getParam("/health_checker/topic_rate", topic_rate_params_);
+    nh_.getParam("/health_checker/drop_rate", drop_rate_params_);
     system_status_.header.stamp = ros::Time::now();
     updateConnectionStatus();
     updateTopicStatus();
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_aggregator_node.cpp" new_path="ros\src\system\autoware_health_checker\src\health_aggregator\health_aggregator_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -19,7 +19,7 @@
 
 #include &lt;ros/ros.h&gt;
 
-#include &lt;autoware_health_checker/health_aggregator.h&gt;
+#include &lt;autoware_health_checker/health_aggregator/health_aggregator.h&gt;
 
 int main(int argc, char *argv[]) {
   ros::init(argc, argv, "health_aggregator");
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_analyzer.cpp" new_path="ros\src\system\autoware_health_checker\src\health_analyzer\health_analyzer.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -17,12 +17,12 @@
  * v1.0 Masaya Kataoka
  */
 
-#include &lt;autoware_health_checker/health_analyzer.h&gt;
+#include &lt;autoware_health_checker/health_analyzer/health_analyzer.h&gt;
 
 HealthAnalyzer::HealthAnalyzer(ros::NodeHandle nh, ros::NodeHandle pnh) {
   nh_ = nh;
   pnh_ = pnh;
-  pnh_.param&lt;int&gt;("warn_nodes_count_threshold", warn_nodes_count_threshold_, 30);
+  pnh_.param&lt;int&gt;("warn_count_threshold", warn_count_threshold_, 30);
   system_status_summary_pub_ =
       nh_.advertise&lt;autoware_system_msgs::SystemStatus&gt;(
           "/system_status/summary", 1);
@@ -144,7 +144,7 @@ HealthAnalyzer::filterSystemStatus(autoware_system_msgs::SystemStatus status) {
   int warn_count = countWarn(status);
   autoware_system_msgs::SystemStatus filtered_status;
   std::vector&lt;std::string&gt; target_nodes;
-  if (warn_count &gt;= warn_nodes_count_threshold_) {
+  if (warn_count &gt;= warn_count_threshold_) {
     filtered_status.detect_too_match_warning = true;
     target_nodes = findWarningNodes(status);
   } else {
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_analyzer_node.cpp" new_path="ros\src\system\autoware_health_checker\src\health_analyzer\health_analyzer_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -19,7 +19,7 @@
 
 #include &lt;ros/ros.h&gt;
 
-#include &lt;autoware_health_checker/health_analyzer.h&gt;
+#include &lt;autoware_health_checker/health_analyzer/health_analyzer.h&gt;
 
 int main(int argc, char *argv[]) {
   ros::init(argc, argv, "health_analyzer");
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\diag_buffer.cpp" new_path="ros\src\system\autoware_health_checker\src\health_checker\diag_buffer.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -17,7 +17,7 @@
  * v1.0 Masaya Kataoka
  */
 
-#include &lt;autoware_health_checker/diag_buffer.h&gt;
+#include &lt;autoware_health_checker/health_checker/diag_buffer.h&gt;
 
 namespace autoware_health_checker {
 DiagBuffer::DiagBuffer(std::string key, uint8_t type, std::string description,
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\rate_checker.cpp" new_path="ros\src\system\autoware_health_checker\src\health_checker\rate_checker.cpp" added_lines="13" deleted_lines="1">
				<diff>@@ -17,7 +17,7 @@
  * v1.0 Masaya Kataoka
  */
 
-#include &lt;autoware_health_checker/rate_checker.h&gt;
+#include &lt;autoware_health_checker/health_checker/rate_checker.h&gt;
 
 namespace autoware_health_checker {
 RateChecker::RateChecker(double buffer_length, double warn_rate,
@@ -65,11 +65,23 @@ uint8_t RateChecker::getErrorLevel() {
   return autoware_health_checker::LEVEL_OK;
 }
 
+void RateChecker::setRate(double warn_rate, double error_rate,
+                          double fatal_rate) {
+  update();
+  mtx_.lock();
+  warn_rate_ = warn_rate;
+  error_rate_ = error_rate;
+  fatal_rate_ = fatal_rate;
+  mtx_.unlock();
+  return;
+}
+
 void RateChecker::check() {
   update();
   mtx_.lock();
   data_.push_back(ros::Time::now());
   mtx_.unlock();
+  return;
 }
 
 void RateChecker::update() {
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\node_status_publisher.cpp" new_path="" added_lines="0" deleted_lines="222">
				<diff>@@ -1,222 +0,0 @@
-/*
- * Copyright 2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- *
- * v1.0 Masaya Kataoka
- */
-
-#include &lt;autoware_health_checker/node_status_publisher.h&gt;
-
-namespace autoware_health_checker {
-NodeStatusPublisher::NodeStatusPublisher(ros::NodeHandle nh,
-                                         ros::NodeHandle pnh) {
-  node_activated_ = false;
-  nh_ = nh;
-  pnh_ = pnh;
-  status_pub_ =
-      nh_.advertise&lt;autoware_system_msgs::NodeStatus&gt;("node_status", 10);
-}
-
-NodeStatusPublisher::~NodeStatusPublisher() {}
-
-void NodeStatusPublisher::publishStatus() {
-  ros::Rate rate = ros::Rate(autoware_health_checker::UPDATE_RATE);
-  while (ros::ok()) {
-    mtx_.lock();
-    autoware_system_msgs::NodeStatus status;
-    status.node_activated = node_activated_;
-    ros::Time now = ros::Time::now();
-    status.header.stamp = now;
-    status.node_name = ros::this_node::getName();
-    std::vector&lt;std::string&gt; checker_keys = getRateCheckerKeys();
-    // iterate Rate checker and publish rate_check result
-    for (auto key_itr = checker_keys.begin(); key_itr != checker_keys.end();
-         key_itr++) {
-      autoware_system_msgs::DiagnosticStatusArray diag_array;
-      autoware_system_msgs::DiagnosticStatus diag;
-      diag.type = autoware_system_msgs::DiagnosticStatus::RATE_IS_SLOW;
-      std::pair&lt;uint8_t, double&gt; result =
-          rate_checkers_[*key_itr]-&gt;getErrorLevelAndRate();
-      diag.level = result.first;
-      diag.key = *key_itr;
-      diag.value = doubeToJson(result.second);
-      diag.description = rate_checkers_[*key_itr]-&gt;description;
-      diag.header.stamp = now;
-      diag_array.status.push_back(diag);
-      status.status.push_back(diag_array);
-    }
-    // iterate Diagnostic Buffer and publish all diagnostic data
-    std::vector&lt;std::string&gt; keys = getKeys();
-    for (auto key_itr = keys.begin(); key_itr != keys.end(); key_itr++) {
-      status.status.push_back(diag_buffers_[*key_itr]-&gt;getAndClearData());
-    }
-    status_pub_.publish(status);
-    mtx_.unlock();
-    rate.sleep();
-  }
-  return;
-}
-
-void NodeStatusPublisher::ENABLE() {
-  boost::thread publish_thread(
-      boost::bind(&amp;NodeStatusPublisher::publishStatus, this));
-  return;
-}
-
-std::vector&lt;std::string&gt; NodeStatusPublisher::getKeys() {
-  std::vector&lt;std::string&gt; keys;
-  std::vector&lt;std::string&gt; checker_keys = getRateCheckerKeys();
-  std::pair&lt;std::string, std::shared_ptr&lt;DiagBuffer&gt;&gt; buf_itr;
-  BOOST_FOREACH (buf_itr, diag_buffers_) {
-    bool matched = false;
-    for (auto checker_key_itr = checker_keys.begin();
-         checker_key_itr != checker_keys.end(); checker_key_itr++) {
-      if (*checker_key_itr == buf_itr.first) {
-        matched = true;
-      }
-    }
-    if (!matched) {
-      keys.push_back(buf_itr.first);
-    }
-  }
-  return keys;
-}
-
-std::vector&lt;std::string&gt; NodeStatusPublisher::getRateCheckerKeys() {
-  std::vector&lt;std::string&gt; keys;
-  std::pair&lt;std::string, std::shared_ptr&lt;RateChecker&gt;&gt; checker_itr;
-  BOOST_FOREACH (checker_itr, rate_checkers_) {
-    keys.push_back(checker_itr.first);
-  }
-  return keys;
-}
-
-bool NodeStatusPublisher::keyExist(std::string key) {
-  if (diag_buffers_.count(key) == 0) {
-    return false;
-  }
-  return true;
-}
-
-// add New Diagnostic Buffer if the key does not exist
-void NodeStatusPublisher::addNewBuffer(std::string key, uint8_t type,
-                                       std::string description) {
-  if (!keyExist(key)) {
-    std::shared_ptr&lt;DiagBuffer&gt; buf_ptr = std::make_shared&lt;DiagBuffer&gt;(
-        key, type, description, autoware_health_checker::BUFFER_LENGTH);
-    diag_buffers_[key] = buf_ptr;
-  }
-  return;
-}
-
-uint8_t NodeStatusPublisher::CHECK_MIN_VALUE(std::string key, double value,
-                                             double warn_value,
-                                             double error_value,
-                                             double fatal_value,
-                                             std::string description) {
-  addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,
-               description);
-  autoware_system_msgs::DiagnosticStatus new_status;
-  new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
-  if (value &lt; fatal_value) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::FATAL;
-  } else if (value &lt; error_value) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::ERROR;
-  } else if (value &lt; warn_value) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::WARN;
-  } else {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::OK;
-  }
-  new_status.description = description;
-  new_status.value = doubeToJson(value);
-  new_status.header.stamp = ros::Time::now();
-  diag_buffers_[key]-&gt;addDiag(new_status);
-  return new_status.level;
-}
-
-uint8_t NodeStatusPublisher::CHECK_MAX_VALUE(std::string key, double value,
-                                             double warn_value,
-                                             double error_value,
-                                             double fatal_value,
-                                             std::string description) {
-  addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,
-               description);
-  autoware_system_msgs::DiagnosticStatus new_status;
-  new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
-  if (value &gt; fatal_value) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::FATAL;
-  } else if (value &gt; error_value) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::ERROR;
-  } else if (value &gt; warn_value) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::WARN;
-  } else {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::OK;
-  }
-  new_status.description = description;
-  new_status.value = doubeToJson(value);
-  new_status.header.stamp = ros::Time::now();
-  diag_buffers_[key]-&gt;addDiag(new_status);
-  return new_status.level;
-}
-
-uint8_t NodeStatusPublisher::CHECK_RANGE(std::string key, double value,
-                                         std::pair&lt;double, double&gt; warn_value,
-                                         std::pair&lt;double, double&gt; error_value,
-                                         std::pair&lt;double, double&gt; fatal_value,
-                                         std::string description) {
-  addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,
-               description);
-  autoware_system_msgs::DiagnosticStatus new_status;
-  new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
-  if (value &lt; fatal_value.first || value &gt; fatal_value.second) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::FATAL;
-  } else if (value &lt; error_value.first || value &gt; error_value.second) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::ERROR;
-  } else if (value &lt; warn_value.first || value &gt; warn_value.second) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::WARN;
-  } else {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::OK;
-  }
-  new_status.value = doubeToJson(value);
-  new_status.description = description;
-  new_status.header.stamp = ros::Time::now();
-  diag_buffers_[key]-&gt;addDiag(new_status);
-  return new_status.level;
-}
-
-void NodeStatusPublisher::CHECK_RATE(std::string key, double warn_rate,
-                                     double error_rate, double fatal_rate,
-                                     std::string description) {
-  if (!keyExist(key)) {
-    std::shared_ptr&lt;RateChecker&gt; checker_ptr = std::make_shared&lt;RateChecker&gt;(
-        autoware_health_checker::BUFFER_LENGTH, warn_rate, error_rate,
-        fatal_rate, description);
-    rate_checkers_[key] = checker_ptr;
-  }
-  addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::RATE_IS_SLOW,
-               description);
-  rate_checkers_[key]-&gt;check();
-  return;
-}
-
-std::string NodeStatusPublisher::doubeToJson(double value) {
-  using namespace boost::property_tree;
-  std::stringstream ss;
-  ptree pt;
-  pt.put("value.double", value);
-  write_json(ss, pt);
-  return ss.str();
-}
-}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\system_status_subscriber.cpp" new_path="ros\src\system\autoware_health_checker\src\system_status_subscriber\system_status_subscriber.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -17,7 +17,7 @@
  * v1.0 Masaya Kataoka
  */
 
-#include &lt;autoware_health_checker/system_status_subscriber.h&gt;
+#include &lt;autoware_health_checker/system_status_subscriber/system_status_subscriber.h&gt;
 
 namespace autoware_health_checker {
 SystemStatusSubscriber::SystemStatusSubscriber(ros::NodeHandle nh,
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\test\src\test_autoware_health_checker.cpp" new_path="ros\src\system\autoware_health_checker\test\src\test_autoware_health_checker.cpp" added_lines="131" deleted_lines="98">
				<diff>@@ -16,8 +16,8 @@
  *
  * v1.0 Masaya Kataoka
  */
-#include &lt;autoware_health_checker/node_status_publisher.h&gt;
 #include &lt;gtest/gtest.h&gt;
+#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
 #include &lt;ros/ros.h&gt;
 
 class AutowareHealthCheckerTestSuite : public ::testing::Test {
@@ -29,88 +29,16 @@ public:
 
 class AutowareHealthCheckerTestClass {
 public:
-  AutowareHealthCheckerTestClass() {
-    ros::NodeHandle nh;
-    ros::NodeHandle pnh("~");
-    node_status_publisher_ptr =
-        std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh, pnh);
+  AutowareHealthCheckerTestClass() : pnh("~") {
+    health_checker_ptr =
+        std::make_shared&lt;autoware_health_checker::HealthChecker&gt;(nh, pnh);
   };
-  std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt;
-      node_status_publisher_ptr;
+  std::shared_ptr&lt;autoware_health_checker::HealthChecker&gt; health_checker_ptr;
+  ros::NodeHandle pnh;
+  ros::NodeHandle nh;
+  ~AutowareHealthCheckerTestClass(){};
 };
 
-TEST(TestSuite, CHECK_MIN_VALUE) {
-  AutowareHealthCheckerTestClass test_autoware_health_checker;
-  uint8_t ret_fatal =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE(
-          "test", 1, 6, 4, 2, "test");
-  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL)
-      &lt;&lt; "The value was self-diagnosed as fatal";
-  uint8_t ret_error =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE(
-          "test", 3, 6, 4, 2, "test");
-  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR)
-      &lt;&lt; "The value was self-diagnosed as error";
-  uint8_t ret_warn =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE(
-          "test", 5, 6, 4, 2, "test");
-  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN)
-      &lt;&lt; "The value was self-diagnosed as warn";
-  uint8_t ret_ok =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE(
-          "test", 7, 6, 4, 2, "test");
-  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK)
-      &lt;&lt; "The value was self-diagnosed as ok";
-}
-
-TEST(TestSuite, CHECK_MAX_VALUE) {
-  AutowareHealthCheckerTestClass test_autoware_health_checker;
-  uint8_t ret_fatal =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE(
-          "test", 7, 2, 4, 6, "test");
-  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL)
-      &lt;&lt; "The value was self-diagnosed as fatal";
-  uint8_t ret_error =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE(
-          "test", 5, 2, 4, 6, "test");
-  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR)
-      &lt;&lt; "The value was self-diagnosed as error";
-  uint8_t ret_warn =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE(
-          "test", 3, 2, 4, 6, "test");
-  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN)
-      &lt;&lt; "The value was self-diagnosed as warn";
-  uint8_t ret_ok =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE(
-          "test", 1, 2, 4, 6, "test");
-  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK)
-      &lt;&lt; "The value was self-diagnosed as ok";
-}
-
-TEST(TestSuite, CHECK_RANGE) {
-  AutowareHealthCheckerTestClass test_autoware_health_checker;
-  uint8_t ret_fatal =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE(
-          "test", 7.0, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
-  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL)
-      &lt;&lt; "The value was self-diagnosed as fatal";
-  uint8_t ret_error =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE(
-          "test", 5.5, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
-  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR)
-      &lt;&lt; "The value was self-diagnosed as error";
-  uint8_t ret_warn =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE(
-          "test", 4.5, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
-  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN)
-      &lt;&lt; "The value was self-diagnosed as warn";
-  uint8_t ret_ok =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE(
-          "test", 3.0, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
-  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK)
-      &lt;&lt; "The value was self-diagnosed as ok";
-}
-
 uint8_t test_function(double value) {
   if (value == 0.0) {
     return autoware_health_checker::LEVEL_FATAL;
@@ -130,51 +58,156 @@ boost::property_tree::ptree test_value_json_func(double value) {
   return tree;
 };
 
-TEST(TestSuite, CHECK_VALUE) {
+TEST(TestSuite, CHECK_HEALTH_CHECK_FUNCS) {
   AutowareHealthCheckerTestClass test_autoware_health_checker;
+  /*
+    test for value check function
+  */
+
   std::function&lt;uint8_t(double value)&gt; check_func = test_function;
   std::function&lt;boost::property_tree::ptree(double value)&gt;
       check_value_json_func = test_value_json_func;
-  uint8_t ret_fatal =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE(
+  uint8_t ret_fatal_value =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_VALUE(
           "test", 0.0, check_func, check_value_json_func, "test");
-  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL)
+  ASSERT_EQ(ret_fatal_value, autoware_health_checker::LEVEL_FATAL)
       &lt;&lt; "The value was self-diagnosed as fatal";
-  uint8_t ret_error =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE(
+  uint8_t ret_error_value =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_VALUE(
           "test", 1.0, check_func, check_value_json_func, "test");
-  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR)
+  ASSERT_EQ(ret_error_value, autoware_health_checker::LEVEL_ERROR)
       &lt;&lt; "The value was self-diagnosed as fatal";
-  uint8_t ret_warn =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE(
+  uint8_t ret_warn_value =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_VALUE(
           "test", 2.0, check_func, check_value_json_func, "test");
-  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN)
+  ASSERT_EQ(ret_warn_value, autoware_health_checker::LEVEL_WARN)
       &lt;&lt; "The value was self-diagnosed as fatal";
-  uint8_t ret_ok =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE(
+  uint8_t ret_ok_value =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_VALUE(
           "test", -1.0, check_func, check_value_json_func, "test");
-  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK)
+  ASSERT_EQ(ret_ok_value, autoware_health_checker::LEVEL_OK)
       &lt;&lt; "The value was self-diagnosed as fatal";
   boost::optional&lt;double&gt; value =
       check_value_json_func(0.0).get_optional&lt;double&gt;("value");
   ASSERT_EQ(value.get(), 0.0)
       &lt;&lt; "The value must be true, failed to get json value";
+
+  /*
+    test for minimum value check function
+  */
+  uint8_t ret_fatal_min =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MIN_VALUE(
+          "test", 1, 6, 4, 2, "test");
+  ASSERT_EQ(ret_fatal_min, autoware_health_checker::LEVEL_FATAL)
+      &lt;&lt; "The value was self-diagnosed as fatal";
+  uint8_t ret_error_min =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MIN_VALUE(
+          "test", 3, 6, 4, 2, "test");
+  ASSERT_EQ(ret_error_min, autoware_health_checker::LEVEL_ERROR)
+      &lt;&lt; "The value was self-diagnosed as error";
+  uint8_t ret_warn_min =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MIN_VALUE(
+          "test", 5, 6, 4, 2, "test");
+  ASSERT_EQ(ret_warn_min, autoware_health_checker::LEVEL_WARN)
+      &lt;&lt; "The value was self-diagnosed as warn";
+  uint8_t ret_ok_min =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MIN_VALUE(
+          "test", 7, 6, 4, 2, "test");
+  ASSERT_EQ(ret_ok_min, autoware_health_checker::LEVEL_OK)
+      &lt;&lt; "The value was self-diagnosed as ok";
+
+  /*
+    test for maximum value check function
+  */
+  uint8_t ret_fatal_max =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MAX_VALUE(
+          "test", 7, 2, 4, 6, "test");
+  ASSERT_EQ(ret_fatal_max, autoware_health_checker::LEVEL_FATAL)
+      &lt;&lt; "The value was self-diagnosed as fatal";
+  uint8_t ret_error_max =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MAX_VALUE(
+          "test", 5, 2, 4, 6, "test");
+  ASSERT_EQ(ret_error_max, autoware_health_checker::LEVEL_ERROR)
+      &lt;&lt; "The value was self-diagnosed as error";
+  uint8_t ret_warn_max =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MAX_VALUE(
+          "test", 3, 2, 4, 6, "test");
+  ASSERT_EQ(ret_warn_max, autoware_health_checker::LEVEL_WARN)
+      &lt;&lt; "The value was self-diagnosed as warn";
+  uint8_t ret_ok_max =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MAX_VALUE(
+          "test", 1, 2, 4, 6, "test");
+  ASSERT_EQ(ret_ok_max, autoware_health_checker::LEVEL_OK)
+      &lt;&lt; "The value was self-diagnosed as ok";
+
+  /*
+    test for range check functions
+  */
+  uint8_t ret_fatal_range =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_RANGE(
+          "test", 7.0, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
+  ASSERT_EQ(ret_fatal_range, autoware_health_checker::LEVEL_FATAL)
+      &lt;&lt; "The value was self-diagnosed as fatal";
+  uint8_t ret_error_range =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_RANGE(
+          "test", 5.5, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
+  ASSERT_EQ(ret_error_range, autoware_health_checker::LEVEL_ERROR)
+      &lt;&lt; "The value was self-diagnosed as error";
+  uint8_t ret_warn_range =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_RANGE(
+          "test", 4.5, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
+  ASSERT_EQ(ret_warn_range, autoware_health_checker::LEVEL_WARN)
+      &lt;&lt; "The value was self-diagnosed as warn";
+  uint8_t ret_ok_range =
+      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_RANGE(
+          "test", 3.0, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
+  ASSERT_EQ(ret_ok_range, autoware_health_checker::LEVEL_OK)
+      &lt;&lt; "The value was self-diagnosed as ok";
+
+  /*
+    test for set diag function
+  */
+  autoware_system_msgs::DiagnosticStatus status;
+  status.level = status.FATAL;
+  uint8_t ret_diag_fatal =
+      test_autoware_health_checker.health_checker_ptr-&gt;SET_DIAG_STATUS(status);
+  ASSERT_EQ(ret_diag_fatal, autoware_health_checker::LEVEL_FATAL)
+      &lt;&lt; "The value was self-diagnosed as fatal";
+  status.level = status.ERROR;
+  uint8_t ret_diag_error =
+      test_autoware_health_checker.health_checker_ptr-&gt;SET_DIAG_STATUS(status);
+  ASSERT_EQ(ret_diag_error, autoware_health_checker::LEVEL_ERROR)
+      &lt;&lt; "The value was self-diagnosed as error";
+  status.level = status.WARN;
+  uint8_t ret_diag_warn =
+      test_autoware_health_checker.health_checker_ptr-&gt;SET_DIAG_STATUS(status);
+  ASSERT_EQ(ret_diag_warn, autoware_health_checker::LEVEL_WARN)
+      &lt;&lt; "The value was self-diagnosed as warn";
+  status.level = status.OK;
+  uint8_t ret_diag_ok =
+      test_autoware_health_checker.health_checker_ptr-&gt;SET_DIAG_STATUS(status);
+  ASSERT_EQ(ret_diag_ok, autoware_health_checker::LEVEL_OK)
+      &lt;&lt; "The value was self-diagnosed as ok";
 }
 
+/*
+  test for node status
+*/
 TEST(TestSuite, NODE_STATUS) {
   AutowareHealthCheckerTestClass test_autoware_health_checker;
-  test_autoware_health_checker.node_status_publisher_ptr-&gt;NODE_ACTIVATE();
+  test_autoware_health_checker.health_checker_ptr-&gt;NODE_ACTIVATE();
   uint8_t ret_active =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;getNodeStatus();
+      test_autoware_health_checker.health_checker_ptr-&gt;getNodeStatus();
   ASSERT_EQ(ret_active, true) &lt;&lt; "The value must be true";
-  test_autoware_health_checker.node_status_publisher_ptr-&gt;NODE_DEACTIVATE();
+  test_autoware_health_checker.health_checker_ptr-&gt;NODE_DEACTIVATE();
   uint8_t ret_inactive =
-      test_autoware_health_checker.node_status_publisher_ptr-&gt;getNodeStatus();
+      test_autoware_health_checker.health_checker_ptr-&gt;getNodeStatus();
   ASSERT_EQ(ret_inactive, false) &lt;&lt; "The value must be true";
 }
 
 int main(int argc, char **argv) {
   testing::InitGoogleTest(&amp;argc, argv);
   ros::init(argc, argv, "AutowareHealthCheckerTestNode");
-  return RUN_ALL_TESTS();
+  int result = RUN_ALL_TESTS();
+  return result;
 }
\ No newline at end of file
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0bd0145aea1c13a02d98740b19c87103c53eb46d" author="Geoffrey Biggs">
		<msg>Revert "Fix/health checker (#2012)" (#2037)

This reverts commit e4187a7138eb90ad6f119eb35f824b16465aefda.

Reverts #2012

Merged without adequate description of the bug or fixes made</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\default.rviz" new_path="ros\src\.config\rviz\default.rviz" added_lines="32" deleted_lines="22">
				<diff>@@ -67,23 +67,24 @@ Visualization Manager:
         All Enabled: true
         base_link:
           Value: true
+        gps:
+          Value: true
         map:
           Value: true
         velodyne:
           Value: true
-        world:
-          Value: true
       Marker Scale: 5
       Name: TF
       Show Arrows: true
       Show Axes: true
       Show Names: true
       Tree:
-        world:
-          map:
-            base_link:
-              velodyne:
-                {}
+        map:
+          base_link:
+            velodyne:
+              {}
+          gps:
+            {}
       Update Interval: 0
       Value: true
     - Alpha: 0.0500000007
@@ -121,7 +122,9 @@ Visualization Manager:
       Marker Topic: /vector_map
       Name: Vector Map
       Namespaces:
-        {}
+        signal: true
+        stop_line: true
+        white_line: true
       Queue Size: 100
       Value: true
     - Class: rviz/Camera
@@ -176,8 +179,8 @@ Visualization Manager:
     - Alpha: 0.300000012
       Autocompute Intensity Bounds: true
       Autocompute Value Bounds:
-        Max Value: 11.6879101
-        Min Value: -11.4952602
+        Max Value: 11.8534737
+        Min Value: 9.73868942
         Value: true
       Axis: Z
       Channel Name: intensity
@@ -268,7 +271,10 @@ Visualization Manager:
       Marker Topic: /detection_range
       Name: Detection Range
       Namespaces:
-        {}
+        Crosswalk Detection: true
+        Decelerate Detection: true
+        Stop Detection: true
+        Stop Line: true
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -276,7 +282,7 @@ Visualization Manager:
       Marker Topic: /next_target_mark
       Name: Next Waypoint Mark
       Namespaces:
-        {}
+        next_target_marker: true
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -284,7 +290,7 @@ Visualization Manager:
       Marker Topic: /trajectory_circle_mark
       Name: PP Trajectory Mark
       Namespaces:
-        {}
+        trajectory_circle_marker: true
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -351,7 +357,9 @@ Visualization Manager:
       Marker Topic: /local_waypoints_mark
       Name: Local Waypoints
       Namespaces:
-        {}
+        local_path_marker: true
+        local_point_marker: true
+        local_waypoint_velocity: true
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -359,7 +367,9 @@ Visualization Manager:
       Marker Topic: /global_waypoints_mark
       Name: Global Waypoints
       Namespaces:
-        {}
+        global_change_flag_lane_1: true
+        global_lane_waypoint_orientation_marker_1: true
+        global_velocity_lane_1: true
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -512,15 +522,15 @@ Visualization Manager:
       Unreliable: false
       Value: false
     - Class: jsk_rviz_plugin/OverlayImage
-      Enabled: true
+      Enabled: false
       Name: OverlayImage
       Topic: /image_raw
-      Value: true
+      Value: false
       alpha: 0.800000012
       height: 128
       keep aspect ratio: true
       left: 128
-      top: 720
+      top: 128
       width: 640
     - Background Alpha: 0.800000012
       Background Color: 0; 0; 0
@@ -636,11 +646,11 @@ Visualization Manager:
       Invert Z Axis: false
       Name: Current View
       Near Clip Distance: 0.00999999978
-      Scale: 3.93164873
-      Target Frame: world
+      Scale: 19.7382278
+      Target Frame: base_link
       Value: TopDownOrtho (rviz)
-      X: 1027.31726
-      Y: 636.823425
+      X: 0
+      Y: 0
     Saved: ~
 Window Geometry:
   Camera:
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="10" deleted_lines="8">
				<diff>@@ -70,7 +70,7 @@
 #include &lt;autoware_msgs/NDTStat.h&gt;
 
 //headers in Autoware Health Checker
-#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
+#include &lt;autoware_health_checker/node_status_publisher.h&gt;
 
 #define PREDICT_POSE_THRESHOLD 0.5
 
@@ -78,7 +78,7 @@
 #define Wb 0.3
 #define Wc 0.3
 
-static std::shared_ptr&lt;autoware_health_checker::HealthChecker&gt; health_checker_ptr_;
+static std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr_;
 
 struct pose
 {
@@ -921,6 +921,7 @@ static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
 
 static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 {
+  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/points_raw/slow",8,5,1,"topic points_raw subscribe rate low.");
   if (map_loaded == 1 &amp;&amp; init_pos_set == 1)
   {
     matching_start = std::chrono::system_clock::now();
@@ -1353,6 +1354,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     }
 
     predict_pose_pub.publish(predict_pose_msg);
+    node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/ndt_pose/slow",8,5,1,"topic points_raw publish rate low.");
     ndt_pose_pub.publish(ndt_pose_msg);
     // current_pose is published by vel_pose_mux
     //    current_pose_pub.publish(current_pose_msg);
@@ -1374,7 +1376,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     matching_end = std::chrono::system_clock::now();
     exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(matching_end - matching_start).count() / 1000.0;
     time_ndt_matching.data = exe_time;
-    health_checker_ptr_-&gt;CHECK_MAX_VALUE("time_ndt_matching",time_ndt_matching.data,50,70,100,"value time_ndt_matching is too high.");
+    node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/time_ndt_matching",time_ndt_matching.data,50,70,100,"value time_ndt_matching is too high.");
     time_ndt_matching_pub.publish(time_ndt_matching);
 
     // Set values for /estimate_twist
@@ -1392,8 +1394,8 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     geometry_msgs::Vector3Stamped estimate_vel_msg;
     estimate_vel_msg.header.stamp = current_scan_time;
     estimate_vel_msg.vector.x = current_velocity;
-    health_checker_ptr_-&gt;CHECK_MAX_VALUE("estimate_twist_linear",current_velocity,5,10,15,"value linear estimated twist is too high.");
-    health_checker_ptr_-&gt;CHECK_MAX_VALUE("estimate_twist_angular",angular_velocity,5,10,15,"value linear angular twist is too high.");
+    node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/estimate_twist/linear",current_velocity,5,10,15,"value linear estimated twist is too high.");
+    node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/estimate_twist/angular",angular_velocity,5,10,15,"value linear angular twist is too high.");
     estimated_vel_pub.publish(estimate_vel_msg);
 
     // Set values for /ndt_stat
@@ -1522,9 +1524,9 @@ int main(int argc, char** argv)
 
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
-  health_checker_ptr_ = std::make_shared&lt;autoware_health_checker::HealthChecker&gt;(nh,private_nh);
-  health_checker_ptr_-&gt;ENABLE();
-  health_checker_ptr_-&gt;NODE_ACTIVATE();
+  node_status_publisher_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh,private_nh);
+  node_status_publisher_ptr_-&gt;ENABLE();
+  node_status_publisher_ptr_-&gt;NODE_ACTIVATE();
 
   // Set log file name.
   private_nh.getParam("output_log_data", _output_log_data);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" added_lines="6" deleted_lines="4">
				<diff>@@ -32,8 +32,8 @@ SearchInfo::SearchInfo()
 {
   ros::NodeHandle nh;
   ros::NodeHandle private_nh_("~");
-  health_checker_ptr_ = std::make_shared&lt;autoware_health_checker::HealthChecker&gt;(nh,private_nh_);
-  health_checker_ptr_-&gt;ENABLE();
+  node_status_publisher_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh,private_nh_);
+  node_status_publisher_ptr_-&gt;ENABLE();
   private_nh_.param&lt;std::string&gt;("map_frame", map_frame_, "map");
   private_nh_.param&lt;int&gt;("obstacle_detect_count", obstacle_detect_count_, 10);
   private_nh_.param&lt;int&gt;("avoid_distance", avoid_distance_, 13);
@@ -98,13 +98,14 @@ void SearchInfo::mapCallback(const nav_msgs::OccupancyGridConstPtr &amp;msg)
 void SearchInfo::currentPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 {
   current_pose_ = *msg;
-  health_checker_ptr_-&gt;NODE_ACTIVATE();
+  node_status_publisher_ptr_-&gt;NODE_ACTIVATE();
+  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/current_pose/slow",8,5,1,"topic current_pose subscribe rate low.");
   if(closest_waypoint_index_!=-1 &amp;&amp; path_set_)
   {
     autoware_msgs::Waypoint closest_waypoint = subscribed_waypoints_.waypoints[closest_waypoint_index_];
     double dist = std::sqrt(std::pow(closest_waypoint.pose.pose.position.x-current_pose_.pose.position.x,2)
       +std::pow(closest_waypoint.pose.pose.position.y-current_pose_.pose.position.y,2));
-    health_checker_ptr_-&gt;CHECK_MAX_VALUE("closest_waypoint_distance",dist,0.5,1.0,2.0,"distance between closest_waypoint and current_pose is too long.");
+    node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/range/closest_waypoint_distance",dist,0.5,1.0,2.0,"distance between closest_waypoint and current_pose is too long.");
   }
   return;
 }
@@ -181,6 +182,7 @@ void SearchInfo::waypointsCallback(const autoware_msgs::LaneConstPtr &amp;msg)
 
 void SearchInfo::closestWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
 {
+  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/closest_waypoint/slow",8,5,1,"topic closest_waypoint subscribe rate low.");
   closest_waypoint_index_ = msg-&gt;data;
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" added_lines="2" deleted_lines="2">
				<diff>@@ -27,7 +27,7 @@
 #include &lt;std_msgs/Int32.h&gt;
 #include &lt;std_msgs/String.h&gt;
 
-#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
+#include &lt;autoware_health_checker/node_status_publisher.h&gt;
 #include &lt;memory&gt;
 
 namespace astar_planner
@@ -143,7 +143,7 @@ public:
 private:
   double calcPathLength(const autoware_msgs::Lane &amp;lane, const int start_waypoint_index,
                         const int goal_waypoint_index) const;
-  std::shared_ptr&lt;autoware_health_checker::HealthChecker&gt; health_checker_ptr_;
+  std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr_;
   nav_msgs::OccupancyGrid map_;
   geometry_msgs::PoseStamped start_pose_global_;
   geometry_msgs::PoseStamped goal_pose_global_;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" added_lines="6" deleted_lines="3">
				<diff>@@ -43,8 +43,8 @@ VelocitySetInfo::VelocitySetInfo()
   ros::NodeHandle private_nh_("~");
   ros::NodeHandle nh;
   private_nh_.param&lt;double&gt;("remove_points_upto", remove_points_upto_, 2.3);
-  health_checker_ptr_ = std::make_shared&lt;autoware_health_checker::HealthChecker&gt;(nh,private_nh_);
-  health_checker_ptr_-&gt;ENABLE();
+  node_status_publisher_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh,private_nh_);
+  node_status_publisher_ptr_-&gt;ENABLE();
 }
 
 VelocitySetInfo::~VelocitySetInfo()
@@ -73,6 +73,7 @@ void VelocitySetInfo::configCallback(const autoware_config_msgs::ConfigVelocityS
 
 void VelocitySetInfo::pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg)
 {
+  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/points_no_ground/slow",8,5,1,"topic points_no_ground subscribe rate low.");
   pcl::PointCloud&lt;pcl::PointXYZ&gt; sub_points;
   pcl::fromROSMsg(*msg, sub_points);
 
@@ -107,13 +108,15 @@ void VelocitySetInfo::detectionCallback(const std_msgs::Int32 &amp;msg)
 void VelocitySetInfo::controlPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 {
   control_pose_ = *msg;
-  health_checker_ptr_-&gt;NODE_ACTIVATE();
+
   if (!set_pose_)
     set_pose_ = true;
 }
 
 void VelocitySetInfo::localizerPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 {
+  node_status_publisher_ptr_-&gt;NODE_ACTIVATE();
+  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/current_pose/slow",8,5,1,"topic current_pose subscribe rate low.");
   localizer_pose_ = *msg;
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" added_lines="2" deleted_lines="2">
				<diff>@@ -24,7 +24,7 @@
 
 #include "autoware_config_msgs/ConfigVelocitySet.h"
 
-#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
+#include &lt;autoware_health_checker/node_status_publisher.h&gt;
 #include &lt;memory&gt;
 
 class VelocitySetInfo
@@ -54,7 +54,7 @@ class VelocitySetInfo
   bool set_pose_;
   bool use_obstacle_sim_;
 
-  std::shared_ptr&lt;autoware_health_checker::HealthChecker&gt; health_checker_ptr_;
+  std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr_;
 
  public:
   VelocitySetInfo();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="5" deleted_lines="4">
				<diff>@@ -36,8 +36,8 @@ PurePursuitNode::PurePursuitNode()
   , minimum_lookahead_distance_(6.0)
 {
   initForROS();
-  health_checker_ptr_ = std::make_shared&lt;autoware_health_checker::HealthChecker&gt;(nh_,private_nh_);
-  health_checker_ptr_-&gt;ENABLE();
+  node_status_publisher_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh_,private_nh_);
+  node_status_publisher_ptr_-&gt;ENABLE();
   // initialize for PurePursuit
   pp_.setLinearInterpolationParameter(is_linear_interpolation_);
 }
@@ -96,7 +96,8 @@ void PurePursuitNode::run()
     
     publishTwistStamped(can_get_curvature, kappa);
     publishControlCommandStamped(can_get_curvature, kappa);
-    health_checker_ptr_-&gt;NODE_ACTIVATE();
+    node_status_publisher_ptr_-&gt;NODE_ACTIVATE();
+    node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/vehicle/slow",8,5,1,"topic vehicle_cmd publish rate low.");
     // for visualization with Rviz
     pub11_.publish(displayNextWaypoint(pp_.getPoseOfNextWaypoint()));
     pub13_.publish(displaySearchRadius(pp_.getCurrentPose().position, pp_.getLookaheadDistance()));
@@ -123,7 +124,7 @@ void PurePursuitNode::publishTwistStamped(const bool &amp;can_get_curvature, const d
   ts.header.stamp = ros::Time::now();
   ts.twist.linear.x = can_get_curvature ? computeCommandVelocity() : 0;
   ts.twist.angular.z = can_get_curvature ? kappa * ts.twist.linear.x : 0;
-  health_checker_ptr_-&gt;CHECK_MAX_VALUE("twist_cmd_linear_high",ts.twist.linear.x,2.2,3.3,4.4,"linear twist_cmd is too high");
+  node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/twist",ts.twist.linear.x,2.2,3.3,4.4,"linear twist_cmd is too high");
   pub1_.publish(ts);
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -31,7 +31,7 @@
 #include "pure_pursuit.h"
 #include "pure_pursuit_viz.h"
 
-#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
+#include &lt;autoware_health_checker/node_status_publisher.h&gt;
 
 #include &lt;memory&gt;
 
@@ -64,7 +64,7 @@ private:
   ros::NodeHandle nh_;
   ros::NodeHandle private_nh_;
 
-  std::shared_ptr&lt;autoware_health_checker::HealthChecker&gt; health_checker_ptr_;
+  std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr_;
 
   // class
   PurePursuit pp_;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" added_lines="4" deleted_lines="3">
				<diff>@@ -50,7 +50,7 @@
 #include "autoware_msgs/ControlCommandStamped.h"
 
 //headers in Autowae Health Checker
-#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
+#include &lt;autoware_health_checker/node_status_publisher.h&gt;
 
 class TwistGate
 {
@@ -76,7 +76,7 @@ class TwistGate
 
     ros::NodeHandle nh_;
     ros::NodeHandle private_nh_;
-    std::shared_ptr&lt;autoware_health_checker::HealthChecker&gt; node_status_pub_ptr_;
+    std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_pub_ptr_;
     ros::Publisher emergency_stop_pub_;
     ros::Publisher control_command_pub_;
     ros::Publisher vehicle_cmd_pub_;
@@ -104,7 +104,7 @@ TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_n
     ,command_mode_(CommandMode::AUTO)
     ,previous_command_mode_(CommandMode::AUTO)
 {
-  node_status_pub_ptr_ = std::make_shared&lt;autoware_health_checker::HealthChecker&gt;(nh_,private_nh_);
+  node_status_pub_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh_,private_nh_);
   emergency_stop_pub_ = nh_.advertise&lt;std_msgs::Bool&gt;("/emergency_stop", 1, true);
   control_command_pub_ = nh_.advertise&lt;std_msgs::String&gt;("/ctrl_mode", 1);
   vehicle_cmd_pub_ = nh_.advertise&lt;vehicle_cmd_msg_t&gt;("/vehicle_cmd", 1, true);
@@ -234,6 +234,7 @@ void TwistGate::remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg)
 void TwistGate::auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::ConstPtr&amp; input_msg)
 {
   node_status_pub_ptr_-&gt;NODE_ACTIVATE();
+  node_status_pub_ptr_-&gt;CHECK_RATE("/topic/rate/twist_cmd/slow",8,5,1,"topic twist_cmd subscribe rate low.");
   if(command_mode_ == CommandMode::AUTO)
   {
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\include\ray_ground_filter.h" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\include\ray_ground_filter.h" added_lines="2" deleted_lines="2">
				<diff>@@ -34,7 +34,7 @@
 #include "autoware_config_msgs/ConfigRayGroundFilter.h"
 
 //headers in Autoware Health Checker
-#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
+#include &lt;autoware_health_checker/node_status_publisher.h&gt;
 
 #include &lt;opencv2/core/version.hpp&gt;
 #if (CV_MAJOR_VERSION == 3)
@@ -46,7 +46,7 @@
 class RayGroundFilter
 {
 private:
-	std::shared_ptr&lt;autoware_health_checker::HealthChecker&gt; node_status_pub_ptr_;
+	std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_pub_ptr_;
 	ros::NodeHandle     node_handle_;
 	ros::Subscriber     points_node_sub_;
 	ros::Subscriber     config_node_sub_;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\ray_ground_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\ray_ground_filter.cpp" added_lines="2" deleted_lines="1">
				<diff>@@ -284,6 +284,7 @@ void RayGroundFilter::RemovePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Pt
 void RayGroundFilter::CloudCallback(const sensor_msgs::PointCloud2ConstPtr &amp;in_sensor_cloud)
 {
   node_status_pub_ptr_-&gt;NODE_ACTIVATE();
+  node_status_pub_ptr_-&gt;CHECK_RATE("/topic/rate/points_raw/slow",8,5,1,"topic points_raw subscribe rate low.");
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr current_sensor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
   pcl::fromROSMsg(*in_sensor_cloud, *current_sensor_cloud_ptr);
 
@@ -330,7 +331,7 @@ RayGroundFilter::RayGroundFilter():node_handle_("~")
 {
   ros::NodeHandle nh;
   ros::NodeHandle pnh("~");
-  node_status_pub_ptr_ = std::make_shared&lt;autoware_health_checker::HealthChecker&gt;(nh,pnh);
+  node_status_pub_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh,pnh);
   node_status_pub_ptr_-&gt;ENABLE();
 }
 
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\constants.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\constants.h" added_lines="7" deleted_lines="0">
				<diff>@@ -30,6 +30,13 @@ constexpr uint8_t LEVEL_WARN = autoware_system_msgs::DiagnosticStatus::WARN;
 constexpr uint8_t LEVEL_ERROR = autoware_system_msgs::DiagnosticStatus::ERROR;
 constexpr uint8_t LEVEL_FATAL = autoware_system_msgs::DiagnosticStatus::FATAL;
 
+constexpr uint8_t TYPE_UNDEFINED =
+    autoware_system_msgs::DiagnosticStatus::UNDEFINED;
+constexpr uint8_t TYPE_OUT_OF_RANGE =
+    autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
+constexpr uint8_t TYPE_RATE_IS_SLOW =
+    autoware_system_msgs::DiagnosticStatus::RATE_IS_SLOW;
+
 constexpr double BUFFER_LENGTH = 5.0;
 constexpr double UPDATE_RATE = 10.0;
 }
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_checker\diag_buffer.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\diag_buffer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_aggregator\health_aggregator.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_aggregator.h" added_lines="0" deleted_lines="12">
				<diff>@@ -56,9 +56,6 @@ private:
   ros::Subscriber node_status_sub_;
   ros::Subscriber diagnostic_array_sub_;
   ros::Subscriber topic_statistics_sub_;
-  XmlRpc::XmlRpcValue topic_rate_params_;
-  XmlRpc::XmlRpcValue drop_rate_params_;
-  void addTopicDiag();
   void publishSystemStatus();
   void nodeStatusCallback(const autoware_system_msgs::NodeStatus::ConstPtr msg);
   void
@@ -75,19 +72,10 @@ private:
   convert(const diagnostic_msgs::DiagnosticArray::ConstPtr msg);
   autoware_system_msgs::SystemStatus system_status_;
   std::mutex mtx_;
-  bool ros_ok_;
   void updateConnectionStatus();
   // key topic_name,publisher_node,subscriber_node
   std::map&lt;std::array&lt;std::string, 3&gt;, rosgraph_msgs::TopicStatistics&gt;
       topic_status_;
   void updateTopicStatus();
-  template &lt;typename T&gt; std::string valueToJson(T value) {
-    using namespace boost::property_tree;
-    std::stringstream ss;
-    ptree pt;
-    pt.put("value", value);
-    write_json(ss, pt);
-    return ss.str();
-  }
 };
 #endif // HEALTH_AGGREGATOR_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_analyzer\health_analyzer.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_analyzer.h" added_lines="1" deleted_lines="1">
				<diff>@@ -84,7 +84,7 @@ private:
   int countWarn(autoware_system_msgs::SystemStatus msg);
   void writeDot();
   graph_t depend_graph_;
-  int warn_count_threshold_;
+  int warn_nodes_count_threshold_;
   template &lt;typename T&gt; bool isAlreadyExist(std::vector&lt;T&gt; vector, T target) {
     for (auto itr = vector.begin(); itr != vector.end(); itr++) {
       if (target == *itr) {
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_checker\value_manager.h" new_path="" added_lines="0" deleted_lines="59">
				<diff>@@ -1,59 +0,0 @@
-#ifndef VALUE_MANAGER_H_INCLUDED
-#define VALUE_MANAGER_H_INCLUDED
-
-/*
- * Copyright 2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- *
- * v1.0 Masaya Kataoka
- */
-
-// headers in ROS
-#include &lt;ros/ros.h&gt;
-
-// headers in Autoware
-#include &lt;autoware_health_checker/constants.h&gt;
-
-// headers in STL
-#include &lt;map&gt;
-#include &lt;mutex&gt;
-
-// headers in Boost
-#include &lt;boost/optional.hpp&gt;
-#include &lt;boost/thread.hpp&gt;
-
-class ValueManager {
-public:
-  ValueManager(ros::NodeHandle nh, ros::NodeHandle pnh);
-  ~ValueManager();
-  void run();
-  void stop() { ros_ok_ = false; };
-  void setDefaultValue(std::string key, std::string type, double warn_value,
-                       double error_value, double fatal_value);
-  double getValue(std::string key, std::string type, uint8_t level);
-
-private:
-  std::map&lt;std::pair&lt;std::pair&lt;std::string, std::string&gt;, uint8_t&gt;, double&gt;
-      data_;
-  ros::NodeHandle nh_;
-  ros::NodeHandle pnh_;
-  XmlRpc::XmlRpcValue diag_params_;
-  void updateParams();
-  bool ros_ok_;
-  bool foundParamKey(std::string key, std::string type, uint8_t level,
-                     double &amp;value);
-  std::mutex mtx_;
-};
-#endif // VALUE_MANAGER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_checker\health_checker.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\node_status_publisher.h" added_lines="14" deleted_lines="27">
				<diff>@@ -1,5 +1,5 @@
-#ifndef HEALTH_CHECKER_H_INCLUDED
-#define HEALTH_CHECKER_H_INCLUDED
+#ifndef NODE_STATUS_PUBLISHER_H_INCLUDED
+#define NODE_STATUS_PUBLISHER_H_INCLUDED
 
 /*
  * Copyright 2019 Autoware Foundation. All rights reserved.
@@ -25,10 +25,9 @@
 
 // headers in Autoware
 #include &lt;autoware_health_checker/constants.h&gt;
+#include &lt;autoware_health_checker/diag_buffer.h&gt;
+#include &lt;autoware_health_checker/rate_checker.h&gt;
 #include &lt;autoware_system_msgs/NodeStatus.h&gt;
-#include &lt;autoware_health_checker/health_checker/diag_buffer.h&gt;
-#include &lt;autoware_health_checker/health_checker/rate_checker.h&gt;
-#include &lt;autoware_health_checker/health_checker/value_manager.h&gt;
 
 // headers in STL
 #include &lt;functional&gt;
@@ -45,10 +44,10 @@
 #include &lt;boost/thread.hpp&gt;
 
 namespace autoware_health_checker {
-class HealthChecker {
+class NodeStatusPublisher {
 public:
-  HealthChecker(ros::NodeHandle nh, ros::NodeHandle pnh);
-  ~HealthChecker();
+  NodeStatusPublisher(ros::NodeHandle nh, ros::NodeHandle pnh);
+  ~NodeStatusPublisher();
   void ENABLE();
   uint8_t CHECK_MIN_VALUE(std::string key, double value, double warn_value,
                           double error_value, double fatal_value,
@@ -68,14 +67,14 @@ public:
       std::string key, T value, std::function&lt;uint8_t(T value)&gt; check_func,
       std::function&lt;boost::property_tree::ptree(T value)&gt; value_json_func,
       std::string description) {
-    addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::INVALID_VALUE,
+    addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,
                  description);
     uint8_t check_result = check_func(value);
     boost::property_tree::ptree pt = value_json_func(value);
     std::stringstream ss;
     write_json(ss, pt);
     autoware_system_msgs::DiagnosticStatus new_status;
-    new_status.type = autoware_system_msgs::DiagnosticStatus::INVALID_VALUE;
+    new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
     new_status.level = check_result;
     new_status.description = description;
     new_status.value = ss.str();
@@ -85,9 +84,6 @@ public:
   }
   void CHECK_RATE(std::string key, double warn_rate, double error_rate,
                   double fatal_rate, std::string description);
-  uint8_t CHECK_TRUE(std::string key, bool value, uint8_t level,
-                     std::string description);
-  uint8_t SET_DIAG_STATUS(autoware_system_msgs::DiagnosticStatus status);
   void NODE_ACTIVATE() {
     std::lock_guard&lt;std::mutex&gt; lock(mtx_);
     node_activated_ = true;
@@ -99,28 +95,19 @@ public:
   bool getNodeStatus() { return node_activated_; };
 
 private:
-  ValueManager value_manager_;
   std::vector&lt;std::string&gt; getKeys();
   std::vector&lt;std::string&gt; getRateCheckerKeys();
   ros::NodeHandle nh_;
   ros::NodeHandle pnh_;
-  std::map&lt;std::string, std::unique_ptr&lt;DiagBuffer&gt;&gt; diag_buffers_;
-  std::map&lt;std::string, std::unique_ptr&lt;RateChecker&gt;&gt; rate_checkers_;
+  std::map&lt;std::string, std::shared_ptr&lt;DiagBuffer&gt;&gt; diag_buffers_;
+  std::map&lt;std::string, std::shared_ptr&lt;RateChecker&gt;&gt; rate_checkers_;
   ros::Publisher status_pub_;
   bool keyExist(std::string key);
-  bool addNewBuffer(std::string key, uint8_t type, std::string description);
-  template &lt;typename T&gt; std::string valueToJson(T value) {
-    using namespace boost::property_tree;
-    std::stringstream ss;
-    ptree pt;
-    pt.put("value", value);
-    write_json(ss, pt);
-    return ss.str();
-  }
+  void addNewBuffer(std::string key, uint8_t type, std::string description);
+  std::string doubeToJson(double value);
   void publishStatus();
   bool node_activated_;
-  bool ros_ok_;
   std::mutex mtx_;
 };
 }
-#endif // HEALTH_CHECKER_H_INCLUDED
\ No newline at end of file
+#endif // NODE_STATUS_PUBLISHER_H_INCLUDED
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\health_checker\rate_checker.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\rate_checker.h" added_lines="4" deleted_lines="5">
				<diff>@@ -44,16 +44,15 @@ public:
   uint8_t getErrorLevel();
   boost::optional&lt;double&gt; getRate();
   const std::string description;
-  void setRate(double warn_rate, double error_rate, double fatal_rate);
 
 private:
   ros::Time start_time_;
   void update();
   std::vector&lt;ros::Time&gt; data_;
-  double buffer_length_;
-  double warn_rate_;
-  double error_rate_;
-  double fatal_rate_;
+  const double buffer_length_;
+  const double warn_rate_;
+  const double error_rate_;
+  const double fatal_rate_;
   std::mutex mtx_;
 };
 }
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\system_status_subscriber\system_status_subscriber.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\system_status_subscriber.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_checker\diag_buffer.cpp" new_path="ros\src\system\autoware_health_checker\src\diag_buffer.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -17,7 +17,7 @@
  * v1.0 Masaya Kataoka
  */
 
-#include &lt;autoware_health_checker/health_checker/diag_buffer.h&gt;
+#include &lt;autoware_health_checker/diag_buffer.h&gt;
 
 namespace autoware_health_checker {
 DiagBuffer::DiagBuffer(std::string key, uint8_t type, std::string description,
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_aggregator\health_aggregator.cpp" new_path="ros\src\system\autoware_health_checker\src\health_aggregator.cpp" added_lines="4" deleted_lines="104">
				<diff>@@ -17,15 +17,14 @@
  * v1.0 Masaya Kataoka
  */
 
-#include &lt;autoware_health_checker/health_aggregator/health_aggregator.h&gt;
+#include &lt;autoware_health_checker/health_aggregator.h&gt;
 
 HealthAggregator::HealthAggregator(ros::NodeHandle nh, ros::NodeHandle pnh) {
   nh_ = nh;
   pnh_ = pnh;
-  ros_ok_ = true;
 }
 
-HealthAggregator::~HealthAggregator() { ros_ok_ = false; }
+HealthAggregator::~HealthAggregator() {}
 
 void HealthAggregator::run() {
   system_status_pub_ =
@@ -41,7 +40,7 @@ void HealthAggregator::run() {
   node_status_sub_ = nh_.subscribe("/node_status", 10,
                                    &amp;HealthAggregator::nodeStatusCallback, this);
   diagnostic_array_sub_ = nh_.subscribe(
-      "/diagnostics_agg", 10, &amp;HealthAggregator::diagnosticArrayCallback, this);
+      "/diagnostic_agg", 10, &amp;HealthAggregator::diagnosticArrayCallback, this);
   topic_statistics_sub_ = nh_.subscribe(
       "/statistics", 1, &amp;HealthAggregator::topicStatisticsCallback, this);
   boost::thread publish_thread(
@@ -49,102 +48,6 @@ void HealthAggregator::run() {
   return;
 }
 
-void HealthAggregator::addTopicDiag() {
-  for (auto itr = topic_rate_params_.begin(); itr != topic_rate_params_.end();
-       itr++) {
-    std::string key = itr-&gt;first;
-    XmlRpc::XmlRpcValue data = itr-&gt;second["sub_node"];
-    std::string sub_node = data;
-    data = itr-&gt;second["pub_node"];
-    std::string pub_node = data;
-    data = itr-&gt;second["topic_name"];
-    std::string topic_name = data;
-    data = itr-&gt;second["topic_rate"]["warn"];
-    double warn_topic_rate = data;
-    data = itr-&gt;second["topic_rate"]["error"];
-    double error_topic_rate = data;
-    data = itr-&gt;second["topic_rate"]["fatal"];
-    double fatal_topic_rate = data;
-    autoware_system_msgs::DiagnosticStatus diag_topic_rate;
-    diag_topic_rate.key = key;
-    diag_topic_rate.description = topic_name + " in " + sub_node + " from " +
-                                  pub_node + " topic rate is slow";
-    diag_topic_rate.type = diag_topic_rate.TOPIC_RATE_IS_SLOW;
-    std::array&lt;std::string, 3&gt; query_key = {topic_name, pub_node, sub_node};
-    if (topic_status_.count(query_key) != 0) {
-      rosgraph_msgs::TopicStatistics stat = topic_status_[query_key];
-      double topic_rate =
-          (double)stat.delivered_msgs /
-          (double)(stat.window_stop - stat.window_start).toSec();
-      diag_topic_rate.header.stamp = stat.window_stop;
-      diag_topic_rate.key = key;
-      diag_topic_rate.value = valueToJson(topic_rate);
-      if (topic_rate &lt; fatal_topic_rate) {
-        diag_topic_rate.level = autoware_health_checker::LEVEL_FATAL;
-      } else if (topic_rate &lt; error_topic_rate) {
-        diag_topic_rate.level = autoware_health_checker::LEVEL_ERROR;
-      } else if (topic_rate &lt; error_topic_rate) {
-        diag_topic_rate.level = autoware_health_checker::LEVEL_WARN;
-      } else {
-        diag_topic_rate.level = autoware_health_checker::LEVEL_OK;
-      }
-      for (auto node_status_itr = system_status_.node_status.begin();
-           node_status_itr != system_status_.node_status.end();
-           node_status_itr++) {
-        autoware_system_msgs::DiagnosticStatusArray diag;
-        diag.status.push_back(diag_topic_rate);
-        node_status_itr-&gt;status.push_back(diag);
-      }
-    }
-  }
-  for (auto itr = drop_rate_params_.begin(); itr != drop_rate_params_.end();
-       itr++) {
-    std::string key = itr-&gt;first;
-    XmlRpc::XmlRpcValue data = itr-&gt;second["sub_node"];
-    std::string sub_node = data;
-    data = itr-&gt;second["pub_node"];
-    std::string pub_node = data;
-    data = itr-&gt;second["topic_name"];
-    std::string topic_name = data;
-    data = itr-&gt;second["drop_rate"]["warn"];
-    double warn_drop_rate = data;
-    data = itr-&gt;second["drop_rate"]["error"];
-    double error_drop_rate = data;
-    data = itr-&gt;second["drop_rate"]["fatal"];
-    double fatal_drop_rate = data;
-    autoware_system_msgs::DiagnosticStatus diag_drop_rate;
-    diag_drop_rate.key = key;
-    diag_drop_rate.description = topic_name + " in " + sub_node + " from " +
-                                 pub_node + " message deop rate is too high";
-    diag_drop_rate.type = diag_drop_rate.TOPIC_DROP_RATE_IS_HIGH;
-    std::array&lt;std::string, 3&gt; query_key = {topic_name, pub_node, sub_node};
-    if (topic_status_.count(query_key) != 0) {
-      rosgraph_msgs::TopicStatistics stat = topic_status_[query_key];
-      double drop_rate = (double)stat.dropped_msgs /
-                         (double)(stat.dropped_msgs + stat.delivered_msgs);
-      diag_drop_rate.header.stamp = stat.window_stop;
-      diag_drop_rate.key = key;
-      diag_drop_rate.value = valueToJson(drop_rate);
-      if (drop_rate &gt; fatal_drop_rate) {
-        diag_drop_rate.level = autoware_health_checker::LEVEL_FATAL;
-      } else if (drop_rate &gt; error_drop_rate) {
-        diag_drop_rate.level = autoware_health_checker::LEVEL_ERROR;
-      } else if (drop_rate &gt; error_drop_rate) {
-        diag_drop_rate.level = autoware_health_checker::LEVEL_WARN;
-      } else {
-        diag_drop_rate.level = autoware_health_checker::LEVEL_OK;
-      }
-      for (auto node_status_itr = system_status_.node_status.begin();
-           node_status_itr != system_status_.node_status.end();
-           node_status_itr++) {
-        autoware_system_msgs::DiagnosticStatusArray diag;
-        diag.status.push_back(diag_drop_rate);
-        node_status_itr-&gt;status.push_back(diag);
-      }
-    }
-  }
-}
-
 void HealthAggregator::topicStatisticsCallback(
     const rosgraph_msgs::TopicStatistics::ConstPtr msg) {
   std::array&lt;std::string, 3&gt; key = {msg-&gt;topic, msg-&gt;node_pub, msg-&gt;node_sub};
@@ -161,16 +64,13 @@ void HealthAggregator::updateTopicStatus() {
       system_status_.topic_statistics.push_back(pair.second);
     }
   }
-  addTopicDiag();
   return;
 }
 
 void HealthAggregator::publishSystemStatus() {
   ros::Rate rate = ros::Rate(autoware_health_checker::UPDATE_RATE);
-  while (ros_ok_) {
+  while (ros::ok()) {
     mtx_.lock();
-    nh_.getParam("/health_checker/topic_rate", topic_rate_params_);
-    nh_.getParam("/health_checker/drop_rate", drop_rate_params_);
     system_status_.header.stamp = ros::Time::now();
     updateConnectionStatus();
     updateTopicStatus();
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_aggregator\health_aggregator_node.cpp" new_path="ros\src\system\autoware_health_checker\src\health_aggregator_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -19,7 +19,7 @@
 
 #include &lt;ros/ros.h&gt;
 
-#include &lt;autoware_health_checker/health_aggregator/health_aggregator.h&gt;
+#include &lt;autoware_health_checker/health_aggregator.h&gt;
 
 int main(int argc, char *argv[]) {
   ros::init(argc, argv, "health_aggregator");
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_analyzer\health_analyzer.cpp" new_path="ros\src\system\autoware_health_checker\src\health_analyzer.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -17,12 +17,12 @@
  * v1.0 Masaya Kataoka
  */
 
-#include &lt;autoware_health_checker/health_analyzer/health_analyzer.h&gt;
+#include &lt;autoware_health_checker/health_analyzer.h&gt;
 
 HealthAnalyzer::HealthAnalyzer(ros::NodeHandle nh, ros::NodeHandle pnh) {
   nh_ = nh;
   pnh_ = pnh;
-  pnh_.param&lt;int&gt;("warn_count_threshold", warn_count_threshold_, 30);
+  pnh_.param&lt;int&gt;("warn_nodes_count_threshold", warn_nodes_count_threshold_, 30);
   system_status_summary_pub_ =
       nh_.advertise&lt;autoware_system_msgs::SystemStatus&gt;(
           "/system_status/summary", 1);
@@ -144,7 +144,7 @@ HealthAnalyzer::filterSystemStatus(autoware_system_msgs::SystemStatus status) {
   int warn_count = countWarn(status);
   autoware_system_msgs::SystemStatus filtered_status;
   std::vector&lt;std::string&gt; target_nodes;
-  if (warn_count &gt;= warn_count_threshold_) {
+  if (warn_count &gt;= warn_nodes_count_threshold_) {
     filtered_status.detect_too_match_warning = true;
     target_nodes = findWarningNodes(status);
   } else {
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_analyzer\health_analyzer_node.cpp" new_path="ros\src\system\autoware_health_checker\src\health_analyzer_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -19,7 +19,7 @@
 
 #include &lt;ros/ros.h&gt;
 
-#include &lt;autoware_health_checker/health_analyzer/health_analyzer.h&gt;
+#include &lt;autoware_health_checker/health_analyzer.h&gt;
 
 int main(int argc, char *argv[]) {
   ros::init(argc, argv, "health_analyzer");
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_checker\health_checker.cpp" new_path="" added_lines="0" deleted_lines="286">
				<diff>@@ -1,286 +0,0 @@
-/*
- * Copyright 2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- *
- * v1.0 Masaya Kataoka
- */
-
-#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
-
-namespace autoware_health_checker {
-HealthChecker::HealthChecker(ros::NodeHandle nh, ros::NodeHandle pnh)
-    : value_manager_(nh, pnh) {
-  node_activated_ = false;
-  ros_ok_ = true;
-  nh_ = nh;
-  pnh_ = pnh;
-  value_manager_.run();
-  status_pub_ =
-      nh_.advertise&lt;autoware_system_msgs::NodeStatus&gt;("node_status", 10);
-}
-
-HealthChecker::~HealthChecker() {
-  ros_ok_ = false;
-  value_manager_.stop();
-}
-
-void HealthChecker::publishStatus() {
-  ros::Rate rate = ros::Rate(autoware_health_checker::UPDATE_RATE);
-  while (ros_ok_) {
-    mtx_.lock();
-    autoware_system_msgs::NodeStatus status;
-    status.node_activated = node_activated_;
-    ros::Time now = ros::Time::now();
-    status.header.stamp = now;
-    status.node_name = ros::this_node::getName();
-    std::vector&lt;std::string&gt; checker_keys = getRateCheckerKeys();
-    // iterate Rate checker and publish rate_check result
-    for (auto key_itr = checker_keys.begin(); key_itr != checker_keys.end();
-         key_itr++) {
-      autoware_system_msgs::DiagnosticStatusArray diag_array;
-      autoware_system_msgs::DiagnosticStatus diag;
-      diag.type = autoware_system_msgs::DiagnosticStatus::LOOP_RATE_IS_SLOW;
-      std::pair&lt;uint8_t, double&gt; result =
-          rate_checkers_[*key_itr]-&gt;getErrorLevelAndRate();
-      diag.level = result.first;
-      diag.key = *key_itr;
-      diag.value = valueToJson(result.second);
-      diag.description = rate_checkers_[*key_itr]-&gt;description;
-      diag.header.stamp = now;
-      diag_array.status.push_back(diag);
-      status.status.push_back(diag_array);
-    }
-    // iterate Diagnostic Buffer and publish all diagnostic data
-    std::vector&lt;std::string&gt; keys = getKeys();
-    for (auto key_itr = keys.begin(); key_itr != keys.end(); key_itr++) {
-      status.status.push_back(diag_buffers_[*key_itr]-&gt;getAndClearData());
-    }
-    status_pub_.publish(status);
-    mtx_.unlock();
-    rate.sleep();
-  }
-  return;
-}
-
-uint8_t
-HealthChecker::SET_DIAG_STATUS(autoware_system_msgs::DiagnosticStatus status) {
-  using namespace autoware_health_checker;
-  if (status.level == LEVEL_OK || status.level == LEVEL_WARN ||
-      status.level == LEVEL_ERROR || status.level == LEVEL_FATAL) {
-    addNewBuffer(status.key, status.type, status.description);
-    diag_buffers_[status.key]-&gt;addDiag(status);
-    return status.level;
-  } else {
-    return LEVEL_UNDEFINED;
-  }
-}
-
-uint8_t HealthChecker::CHECK_TRUE(std::string key, bool value, uint8_t level,
-                                  std::string description) {
-  using namespace autoware_health_checker;
-  if (level == LEVEL_OK || level == LEVEL_WARN || level == LEVEL_ERROR ||
-      level == LEVEL_FATAL) {
-    autoware_system_msgs::DiagnosticStatus status;
-    status.key = key;
-    status.value = valueToJson(value);
-    status.level = level;
-    status.header.stamp = ros::Time::now();
-    addNewBuffer(key, status.INVALID_LOGICAL_VALUE, description);
-    diag_buffers_[status.key]-&gt;addDiag(status);
-    return level;
-  } else {
-    return LEVEL_UNDEFINED;
-  }
-}
-
-void HealthChecker::ENABLE() {
-  boost::thread publish_thread(
-      boost::bind(&amp;HealthChecker::publishStatus, this));
-  return;
-}
-
-std::vector&lt;std::string&gt; HealthChecker::getKeys() {
-  std::vector&lt;std::string&gt; keys;
-  std::vector&lt;std::string&gt; checker_keys = getRateCheckerKeys();
-  std::pair&lt;std::string, std::shared_ptr&lt;DiagBuffer&gt;&gt; buf_itr;
-  for (auto buf_itr = diag_buffers_.begin(); buf_itr != diag_buffers_.end();
-       buf_itr++) {
-    bool matched = false;
-    for (auto checker_key_itr = checker_keys.begin();
-         checker_key_itr != checker_keys.end(); checker_key_itr++) {
-      if (*checker_key_itr == buf_itr-&gt;first) {
-        matched = true;
-      }
-    }
-    if (!matched) {
-      keys.push_back(buf_itr-&gt;first);
-    }
-  }
-  return keys;
-}
-
-std::vector&lt;std::string&gt; HealthChecker::getRateCheckerKeys() {
-  std::vector&lt;std::string&gt; keys;
-  std::pair&lt;std::string, std::unique_ptr&lt;RateChecker&gt;&gt; checker_itr;
-  for (auto itr = rate_checkers_.begin(); itr != rate_checkers_.end(); itr++) {
-    keys.push_back(itr-&gt;first);
-  }
-  return keys;
-}
-
-bool HealthChecker::keyExist(std::string key) {
-  if (diag_buffers_.count(key) == 0) {
-    return false;
-  }
-  return true;
-}
-
-// add New Diagnostic Buffer if the key does not exist
-bool HealthChecker::addNewBuffer(std::string key, uint8_t type,
-                                 std::string description) {
-  mtx_.lock();
-  if (!keyExist(key)) {
-    std::unique_ptr&lt;DiagBuffer&gt; buf_ptr(new DiagBuffer(
-        key, type, description, autoware_health_checker::BUFFER_LENGTH));
-    diag_buffers_[key] = std::move(buf_ptr);
-    mtx_.unlock();
-    return true;
-  }
-  mtx_.unlock();
-  return false;
-}
-
-uint8_t HealthChecker::CHECK_MIN_VALUE(std::string key, double value,
-                                       double warn_value, double error_value,
-                                       double fatal_value,
-                                       std::string description) {
-  value_manager_.setDefaultValue(key, "min", warn_value, error_value,
-                                 fatal_value);
-  addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,
-               description);
-  autoware_system_msgs::DiagnosticStatus new_status;
-  new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
-  if (value &lt; value_manager_.getValue(key, "min",
-                                      autoware_health_checker::LEVEL_FATAL)) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::FATAL;
-  } else if (value &lt; value_manager_.getValue(
-                         key, "min", autoware_health_checker::LEVEL_ERROR)) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::ERROR;
-  } else if (value &lt; value_manager_.getValue(
-                         key, "min", autoware_health_checker::LEVEL_WARN)) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::WARN;
-  } else {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::OK;
-  }
-  new_status.key = key;
-  new_status.description = description;
-  new_status.value = valueToJson(value);
-  new_status.header.stamp = ros::Time::now();
-  diag_buffers_[key]-&gt;addDiag(new_status);
-  return new_status.level;
-}
-
-uint8_t HealthChecker::CHECK_MAX_VALUE(std::string key, double value,
-                                       double warn_value, double error_value,
-                                       double fatal_value,
-                                       std::string description) {
-  value_manager_.setDefaultValue(key, "max", warn_value, error_value,
-                                 fatal_value);
-  addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,
-               description);
-  autoware_system_msgs::DiagnosticStatus new_status;
-  new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
-  if (value &gt; value_manager_.getValue(key, "max",
-                                      autoware_health_checker::LEVEL_FATAL)) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::FATAL;
-  } else if (value &gt; value_manager_.getValue(
-                         key, "max", autoware_health_checker::LEVEL_ERROR)) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::ERROR;
-  } else if (value &gt; value_manager_.getValue(
-                         key, "max", autoware_health_checker::LEVEL_WARN)) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::WARN;
-  } else {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::OK;
-  }
-  new_status.key = key;
-  new_status.description = description;
-  new_status.value = valueToJson(value);
-  new_status.header.stamp = ros::Time::now();
-  diag_buffers_[key]-&gt;addDiag(new_status);
-  return new_status.level;
-}
-
-uint8_t HealthChecker::CHECK_RANGE(std::string key, double value,
-                                   std::pair&lt;double, double&gt; warn_value,
-                                   std::pair&lt;double, double&gt; error_value,
-                                   std::pair&lt;double, double&gt; fatal_value,
-                                   std::string description) {
-  value_manager_.setDefaultValue(key, "min", warn_value.first,
-                                 error_value.first, fatal_value.first);
-  value_manager_.setDefaultValue(key, "max", warn_value.second,
-                                 error_value.second, fatal_value.second);
-  addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE,
-               description);
-  autoware_system_msgs::DiagnosticStatus new_status;
-  new_status.type = autoware_system_msgs::DiagnosticStatus::OUT_OF_RANGE;
-  if (value &lt; value_manager_.getValue(key, "min",
-                                      autoware_health_checker::LEVEL_FATAL) ||
-      value &gt; value_manager_.getValue(key, "max",
-                                      autoware_health_checker::LEVEL_FATAL)) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::FATAL;
-  } else if (value &lt; value_manager_.getValue(
-                         key, "min", autoware_health_checker::LEVEL_ERROR) ||
-             value &gt; value_manager_.getValue(
-                         key, "max", autoware_health_checker::LEVEL_ERROR)) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::ERROR;
-  } else if (value &lt; value_manager_.getValue(
-                         key, "min", autoware_health_checker::LEVEL_WARN) ||
-             value &gt; value_manager_.getValue(
-                         key, "max", autoware_health_checker::LEVEL_WARN)) {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::WARN;
-  } else {
-    new_status.level = autoware_system_msgs::DiagnosticStatus::OK;
-  }
-  new_status.key = key;
-  new_status.value = valueToJson(value);
-  new_status.description = description;
-  new_status.header.stamp = ros::Time::now();
-  diag_buffers_[key]-&gt;addDiag(new_status);
-  return new_status.level;
-}
-
-void HealthChecker::CHECK_RATE(std::string key, double warn_rate,
-                               double error_rate, double fatal_rate,
-                               std::string description) {
-  if (!keyExist(key)) {
-    value_manager_.setDefaultValue(key, "rate", warn_rate, error_rate,
-                                   fatal_rate);
-    std::unique_ptr&lt;RateChecker&gt; checker_ptr(
-        new RateChecker(autoware_health_checker::BUFFER_LENGTH, warn_rate,
-                        error_rate, fatal_rate, description));
-    rate_checkers_[key] = std::move(checker_ptr);
-  }
-  addNewBuffer(key, autoware_system_msgs::DiagnosticStatus::LOOP_RATE_IS_SLOW,
-               description);
-  rate_checkers_[key]-&gt;setRate(
-      value_manager_.getValue(key, "rate", autoware_health_checker::LEVEL_WARN),
-      value_manager_.getValue(key, "rate",
-                              autoware_health_checker::LEVEL_ERROR),
-      value_manager_.getValue(key, "rate",
-                              autoware_health_checker::LEVEL_FATAL));
-  rate_checkers_[key]-&gt;check();
-  return;
-}
-}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_checker\value_manager.cpp" new_path="" added_lines="0" deleted_lines="90">
				<diff>@@ -1,90 +0,0 @@
-/*
- * Copyright 2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- *
- * v1.0 Masaya Kataoka
- */
-
-#include &lt;autoware_health_checker/health_checker/value_manager.h&gt;
-
-ValueManager::ValueManager(ros::NodeHandle nh, ros::NodeHandle pnh) {
-  nh_ = nh;
-  pnh_ = pnh;
-  nh_.getParam("/health_checker", diag_params_);
-  ros_ok_ = true;
-}
-
-ValueManager::~ValueManager() { ros_ok_ = false; }
-
-void ValueManager::run() {
-  boost::thread update_thread =
-      boost::thread(boost::bind(&amp;ValueManager::updateParams, this));
-}
-
-void ValueManager::setDefaultValue(std::string key, std::string type,
-                                   double warn_value, double error_value,
-                                   double fatal_value) {
-  data_[{{key, type}, autoware_health_checker::LEVEL_WARN}] = warn_value;
-  data_[{{key, type}, autoware_health_checker::LEVEL_ERROR}] = error_value;
-  data_[{{key, type}, autoware_health_checker::LEVEL_FATAL}] = fatal_value;
-  return;
-}
-
-bool ValueManager::foundParamKey(std::string key, std::string type,
-                                 uint8_t level, double &amp;value) {
-  for (auto itr = diag_params_.begin(); itr != diag_params_.end(); itr++) {
-    if (itr-&gt;first == key) {
-      if (level == autoware_health_checker::LEVEL_WARN) {
-        XmlRpc::XmlRpcValue data = itr-&gt;second[type]["warn"];
-        value = data;
-        return true;
-      }
-      if (level == autoware_health_checker::LEVEL_ERROR) {
-        XmlRpc::XmlRpcValue data = itr-&gt;second[type]["error"];
-        value = data;
-        return true;
-      }
-      if (level == autoware_health_checker::LEVEL_FATAL) {
-        XmlRpc::XmlRpcValue data = itr-&gt;second[type]["fatal"];
-        value = data;
-        return true;
-      }
-    }
-  }
-  return false;
-}
-
-double ValueManager::getValue(std::string key, std::string type,
-                              uint8_t level) {
-  double ret;
-  mtx_.lock();
-  if (foundParamKey(key, type, level, ret)) {
-  } else {
-    ret = data_[{{key, type}, level}];
-  }
-  mtx_.unlock();
-  return ret;
-}
-
-void ValueManager::updateParams() {
-  ros::Rate rate(1);
-  while (ros_ok_) {
-    mtx_.lock();
-    nh_.getParam("health_checker", diag_params_);
-    mtx_.unlock();
-    rate.sleep();
-  }
-  return;
-}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\health_checker\rate_checker.cpp" new_path="ros\src\system\autoware_health_checker\src\rate_checker.cpp" added_lines="1" deleted_lines="13">
				<diff>@@ -17,7 +17,7 @@
  * v1.0 Masaya Kataoka
  */
 
-#include &lt;autoware_health_checker/health_checker/rate_checker.h&gt;
+#include &lt;autoware_health_checker/rate_checker.h&gt;
 
 namespace autoware_health_checker {
 RateChecker::RateChecker(double buffer_length, double warn_rate,
@@ -65,23 +65,11 @@ uint8_t RateChecker::getErrorLevel() {
   return autoware_health_checker::LEVEL_OK;
 }
 
-void RateChecker::setRate(double warn_rate, double error_rate,
-                          double fatal_rate) {
-  update();
-  mtx_.lock();
-  warn_rate_ = warn_rate;
-  error_rate_ = error_rate;
-  fatal_rate_ = fatal_rate;
-  mtx_.unlock();
-  return;
-}
-
 void RateChecker::check() {
   update();
   mtx_.lock();
   data_.push_back(ros::Time::now());
   mtx_.unlock();
-  return;
 }
 
 void RateChecker::update() {
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\system_status_subscriber\system_status_subscriber.cpp" new_path="ros\src\system\autoware_health_checker\src\system_status_subscriber.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -17,7 +17,7 @@
  * v1.0 Masaya Kataoka
  */
 
-#include &lt;autoware_health_checker/system_status_subscriber/system_status_subscriber.h&gt;
+#include &lt;autoware_health_checker/system_status_subscriber.h&gt;
 
 namespace autoware_health_checker {
 SystemStatusSubscriber::SystemStatusSubscriber(ros::NodeHandle nh,
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\test\src\test_autoware_health_checker.cpp" new_path="ros\src\system\autoware_health_checker\test\src\test_autoware_health_checker.cpp" added_lines="98" deleted_lines="131">
				<diff>@@ -16,8 +16,8 @@
  *
  * v1.0 Masaya Kataoka
  */
+#include &lt;autoware_health_checker/node_status_publisher.h&gt;
 #include &lt;gtest/gtest.h&gt;
-#include &lt;autoware_health_checker/health_checker/health_checker.h&gt;
 #include &lt;ros/ros.h&gt;
 
 class AutowareHealthCheckerTestSuite : public ::testing::Test {
@@ -29,16 +29,88 @@ public:
 
 class AutowareHealthCheckerTestClass {
 public:
-  AutowareHealthCheckerTestClass() : pnh("~") {
-    health_checker_ptr =
-        std::make_shared&lt;autoware_health_checker::HealthChecker&gt;(nh, pnh);
+  AutowareHealthCheckerTestClass() {
+    ros::NodeHandle nh;
+    ros::NodeHandle pnh("~");
+    node_status_publisher_ptr =
+        std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh, pnh);
   };
-  std::shared_ptr&lt;autoware_health_checker::HealthChecker&gt; health_checker_ptr;
-  ros::NodeHandle pnh;
-  ros::NodeHandle nh;
-  ~AutowareHealthCheckerTestClass(){};
+  std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt;
+      node_status_publisher_ptr;
 };
 
+TEST(TestSuite, CHECK_MIN_VALUE) {
+  AutowareHealthCheckerTestClass test_autoware_health_checker;
+  uint8_t ret_fatal =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE(
+          "test", 1, 6, 4, 2, "test");
+  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL)
+      &lt;&lt; "The value was self-diagnosed as fatal";
+  uint8_t ret_error =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE(
+          "test", 3, 6, 4, 2, "test");
+  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR)
+      &lt;&lt; "The value was self-diagnosed as error";
+  uint8_t ret_warn =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE(
+          "test", 5, 6, 4, 2, "test");
+  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN)
+      &lt;&lt; "The value was self-diagnosed as warn";
+  uint8_t ret_ok =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MIN_VALUE(
+          "test", 7, 6, 4, 2, "test");
+  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK)
+      &lt;&lt; "The value was self-diagnosed as ok";
+}
+
+TEST(TestSuite, CHECK_MAX_VALUE) {
+  AutowareHealthCheckerTestClass test_autoware_health_checker;
+  uint8_t ret_fatal =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE(
+          "test", 7, 2, 4, 6, "test");
+  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL)
+      &lt;&lt; "The value was self-diagnosed as fatal";
+  uint8_t ret_error =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE(
+          "test", 5, 2, 4, 6, "test");
+  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR)
+      &lt;&lt; "The value was self-diagnosed as error";
+  uint8_t ret_warn =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE(
+          "test", 3, 2, 4, 6, "test");
+  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN)
+      &lt;&lt; "The value was self-diagnosed as warn";
+  uint8_t ret_ok =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_MAX_VALUE(
+          "test", 1, 2, 4, 6, "test");
+  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK)
+      &lt;&lt; "The value was self-diagnosed as ok";
+}
+
+TEST(TestSuite, CHECK_RANGE) {
+  AutowareHealthCheckerTestClass test_autoware_health_checker;
+  uint8_t ret_fatal =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE(
+          "test", 7.0, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
+  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL)
+      &lt;&lt; "The value was self-diagnosed as fatal";
+  uint8_t ret_error =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE(
+          "test", 5.5, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
+  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR)
+      &lt;&lt; "The value was self-diagnosed as error";
+  uint8_t ret_warn =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE(
+          "test", 4.5, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
+  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN)
+      &lt;&lt; "The value was self-diagnosed as warn";
+  uint8_t ret_ok =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_RANGE(
+          "test", 3.0, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
+  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK)
+      &lt;&lt; "The value was self-diagnosed as ok";
+}
+
 uint8_t test_function(double value) {
   if (value == 0.0) {
     return autoware_health_checker::LEVEL_FATAL;
@@ -58,156 +130,51 @@ boost::property_tree::ptree test_value_json_func(double value) {
   return tree;
 };
 
-TEST(TestSuite, CHECK_HEALTH_CHECK_FUNCS) {
+TEST(TestSuite, CHECK_VALUE) {
   AutowareHealthCheckerTestClass test_autoware_health_checker;
-  /*
-    test for value check function
-  */
-
   std::function&lt;uint8_t(double value)&gt; check_func = test_function;
   std::function&lt;boost::property_tree::ptree(double value)&gt;
       check_value_json_func = test_value_json_func;
-  uint8_t ret_fatal_value =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_VALUE(
+  uint8_t ret_fatal =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE(
           "test", 0.0, check_func, check_value_json_func, "test");
-  ASSERT_EQ(ret_fatal_value, autoware_health_checker::LEVEL_FATAL)
+  ASSERT_EQ(ret_fatal, autoware_health_checker::LEVEL_FATAL)
       &lt;&lt; "The value was self-diagnosed as fatal";
-  uint8_t ret_error_value =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_VALUE(
+  uint8_t ret_error =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE(
           "test", 1.0, check_func, check_value_json_func, "test");
-  ASSERT_EQ(ret_error_value, autoware_health_checker::LEVEL_ERROR)
+  ASSERT_EQ(ret_error, autoware_health_checker::LEVEL_ERROR)
       &lt;&lt; "The value was self-diagnosed as fatal";
-  uint8_t ret_warn_value =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_VALUE(
+  uint8_t ret_warn =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE(
           "test", 2.0, check_func, check_value_json_func, "test");
-  ASSERT_EQ(ret_warn_value, autoware_health_checker::LEVEL_WARN)
+  ASSERT_EQ(ret_warn, autoware_health_checker::LEVEL_WARN)
       &lt;&lt; "The value was self-diagnosed as fatal";
-  uint8_t ret_ok_value =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_VALUE(
+  uint8_t ret_ok =
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;CHECK_VALUE(
           "test", -1.0, check_func, check_value_json_func, "test");
-  ASSERT_EQ(ret_ok_value, autoware_health_checker::LEVEL_OK)
+  ASSERT_EQ(ret_ok, autoware_health_checker::LEVEL_OK)
       &lt;&lt; "The value was self-diagnosed as fatal";
   boost::optional&lt;double&gt; value =
       check_value_json_func(0.0).get_optional&lt;double&gt;("value");
   ASSERT_EQ(value.get(), 0.0)
       &lt;&lt; "The value must be true, failed to get json value";
-
-  /*
-    test for minimum value check function
-  */
-  uint8_t ret_fatal_min =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MIN_VALUE(
-          "test", 1, 6, 4, 2, "test");
-  ASSERT_EQ(ret_fatal_min, autoware_health_checker::LEVEL_FATAL)
-      &lt;&lt; "The value was self-diagnosed as fatal";
-  uint8_t ret_error_min =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MIN_VALUE(
-          "test", 3, 6, 4, 2, "test");
-  ASSERT_EQ(ret_error_min, autoware_health_checker::LEVEL_ERROR)
-      &lt;&lt; "The value was self-diagnosed as error";
-  uint8_t ret_warn_min =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MIN_VALUE(
-          "test", 5, 6, 4, 2, "test");
-  ASSERT_EQ(ret_warn_min, autoware_health_checker::LEVEL_WARN)
-      &lt;&lt; "The value was self-diagnosed as warn";
-  uint8_t ret_ok_min =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MIN_VALUE(
-          "test", 7, 6, 4, 2, "test");
-  ASSERT_EQ(ret_ok_min, autoware_health_checker::LEVEL_OK)
-      &lt;&lt; "The value was self-diagnosed as ok";
-
-  /*
-    test for maximum value check function
-  */
-  uint8_t ret_fatal_max =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MAX_VALUE(
-          "test", 7, 2, 4, 6, "test");
-  ASSERT_EQ(ret_fatal_max, autoware_health_checker::LEVEL_FATAL)
-      &lt;&lt; "The value was self-diagnosed as fatal";
-  uint8_t ret_error_max =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MAX_VALUE(
-          "test", 5, 2, 4, 6, "test");
-  ASSERT_EQ(ret_error_max, autoware_health_checker::LEVEL_ERROR)
-      &lt;&lt; "The value was self-diagnosed as error";
-  uint8_t ret_warn_max =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MAX_VALUE(
-          "test", 3, 2, 4, 6, "test");
-  ASSERT_EQ(ret_warn_max, autoware_health_checker::LEVEL_WARN)
-      &lt;&lt; "The value was self-diagnosed as warn";
-  uint8_t ret_ok_max =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_MAX_VALUE(
-          "test", 1, 2, 4, 6, "test");
-  ASSERT_EQ(ret_ok_max, autoware_health_checker::LEVEL_OK)
-      &lt;&lt; "The value was self-diagnosed as ok";
-
-  /*
-    test for range check functions
-  */
-  uint8_t ret_fatal_range =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_RANGE(
-          "test", 7.0, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
-  ASSERT_EQ(ret_fatal_range, autoware_health_checker::LEVEL_FATAL)
-      &lt;&lt; "The value was self-diagnosed as fatal";
-  uint8_t ret_error_range =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_RANGE(
-          "test", 5.5, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
-  ASSERT_EQ(ret_error_range, autoware_health_checker::LEVEL_ERROR)
-      &lt;&lt; "The value was self-diagnosed as error";
-  uint8_t ret_warn_range =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_RANGE(
-          "test", 4.5, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
-  ASSERT_EQ(ret_warn_range, autoware_health_checker::LEVEL_WARN)
-      &lt;&lt; "The value was self-diagnosed as warn";
-  uint8_t ret_ok_range =
-      test_autoware_health_checker.health_checker_ptr-&gt;CHECK_RANGE(
-          "test", 3.0, {2.0, 4.0}, {1.0, 5.0}, {0.0, 6.0}, "test");
-  ASSERT_EQ(ret_ok_range, autoware_health_checker::LEVEL_OK)
-      &lt;&lt; "The value was self-diagnosed as ok";
-
-  /*
-    test for set diag function
-  */
-  autoware_system_msgs::DiagnosticStatus status;
-  status.level = status.FATAL;
-  uint8_t ret_diag_fatal =
-      test_autoware_health_checker.health_checker_ptr-&gt;SET_DIAG_STATUS(status);
-  ASSERT_EQ(ret_diag_fatal, autoware_health_checker::LEVEL_FATAL)
-      &lt;&lt; "The value was self-diagnosed as fatal";
-  status.level = status.ERROR;
-  uint8_t ret_diag_error =
-      test_autoware_health_checker.health_checker_ptr-&gt;SET_DIAG_STATUS(status);
-  ASSERT_EQ(ret_diag_error, autoware_health_checker::LEVEL_ERROR)
-      &lt;&lt; "The value was self-diagnosed as error";
-  status.level = status.WARN;
-  uint8_t ret_diag_warn =
-      test_autoware_health_checker.health_checker_ptr-&gt;SET_DIAG_STATUS(status);
-  ASSERT_EQ(ret_diag_warn, autoware_health_checker::LEVEL_WARN)
-      &lt;&lt; "The value was self-diagnosed as warn";
-  status.level = status.OK;
-  uint8_t ret_diag_ok =
-      test_autoware_health_checker.health_checker_ptr-&gt;SET_DIAG_STATUS(status);
-  ASSERT_EQ(ret_diag_ok, autoware_health_checker::LEVEL_OK)
-      &lt;&lt; "The value was self-diagnosed as ok";
 }
 
-/*
-  test for node status
-*/
 TEST(TestSuite, NODE_STATUS) {
   AutowareHealthCheckerTestClass test_autoware_health_checker;
-  test_autoware_health_checker.health_checker_ptr-&gt;NODE_ACTIVATE();
+  test_autoware_health_checker.node_status_publisher_ptr-&gt;NODE_ACTIVATE();
   uint8_t ret_active =
-      test_autoware_health_checker.health_checker_ptr-&gt;getNodeStatus();
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;getNodeStatus();
   ASSERT_EQ(ret_active, true) &lt;&lt; "The value must be true";
-  test_autoware_health_checker.health_checker_ptr-&gt;NODE_DEACTIVATE();
+  test_autoware_health_checker.node_status_publisher_ptr-&gt;NODE_DEACTIVATE();
   uint8_t ret_inactive =
-      test_autoware_health_checker.health_checker_ptr-&gt;getNodeStatus();
+      test_autoware_health_checker.node_status_publisher_ptr-&gt;getNodeStatus();
   ASSERT_EQ(ret_inactive, false) &lt;&lt; "The value must be true";
 }
 
 int main(int argc, char **argv) {
   testing::InitGoogleTest(&amp;argc, argv);
   ros::init(argc, argv, "AutowareHealthCheckerTestNode");
-  int result = RUN_ALL_TESTS();
-  return result;
+  return RUN_ALL_TESTS();
 }
\ No newline at end of file
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="00d8f41a32701c6a996530a4ff9f0d65d4089962" author="s-azumi">
		<msg>fix thread handling of node_status_publisher. (#2058)</msg>
		<modified_files>
			<file old_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\node_status_publisher.h" new_path="ros\src\system\autoware_health_checker\include\autoware_health_checker\node_status_publisher.h" added_lines="3" deleted_lines="1">
				<diff>@@ -108,6 +108,8 @@ private:
   void publishStatus();
   bool node_activated_;
   std::mutex mtx_;
+  boost::thread publish_thread_;
+  bool ros_ok_;
 };
 }
-#endif // NODE_STATUS_PUBLISHER_H_INCLUDED
\ No newline at end of file
+#endif // NODE_STATUS_PUBLISHER_H_INCLUDED
</diff>
			</file>
			<file old_path="ros\src\system\autoware_health_checker\src\node_status_publisher.cpp" new_path="ros\src\system\autoware_health_checker\src\node_status_publisher.cpp" added_lines="8" deleted_lines="5">
				<diff>@@ -23,17 +23,21 @@ namespace autoware_health_checker {
 NodeStatusPublisher::NodeStatusPublisher(ros::NodeHandle nh,
                                          ros::NodeHandle pnh) {
   node_activated_ = false;
+  ros_ok_ = true;
   nh_ = nh;
   pnh_ = pnh;
   status_pub_ =
       nh_.advertise&lt;autoware_system_msgs::NodeStatus&gt;("node_status", 10);
 }
 
-NodeStatusPublisher::~NodeStatusPublisher() {}
+NodeStatusPublisher::~NodeStatusPublisher() {
+  ros_ok_ = false;
+  publish_thread_.join();
+}
 
 void NodeStatusPublisher::publishStatus() {
   ros::Rate rate = ros::Rate(autoware_health_checker::UPDATE_RATE);
-  while (ros::ok()) {
+  while (ros_ok_) {
     mtx_.lock();
     autoware_system_msgs::NodeStatus status;
     status.node_activated = node_activated_;
@@ -70,8 +74,7 @@ void NodeStatusPublisher::publishStatus() {
 }
 
 void NodeStatusPublisher::ENABLE() {
-  boost::thread publish_thread(
-      boost::bind(&amp;NodeStatusPublisher::publishStatus, this));
+  publish_thread_ = boost::thread(boost::bind(&amp;NodeStatusPublisher::publishStatus, this));
   return;
 }
 
@@ -219,4 +222,4 @@ std::string NodeStatusPublisher::doubeToJson(double value) {
   write_json(ss, pt);
   return ss.str();
 }
-}
\ No newline at end of file
+}
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2ee0c451309d3f7aa072c14ae1bff4e053758675" author="ChenxiTU">
		<msg>Feature/rosbag_controller_split (#2046)

* new feature: split and warning

* fix bugs; add absolute path with default filename</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\autoware_rviz_plugins\rosbag_controller\src\autoware_rosbag_plugin.cpp" new_path="ros\src\util\packages\autoware_rviz_plugins\rosbag_controller\src\autoware_rosbag_plugin.cpp" added_lines="127" deleted_lines="36">
				<diff>@@ -59,6 +59,8 @@ Autoware_Rosbag_Plugin::Autoware_Rosbag_Plugin(QWidget *parent) :
 {
   record_filepath_.clear();
   record_filename_.clear();
+  split_duration = 0;
+  split_size = 0;
 
   ui-&gt;setupUi(this);
   ui_timer_ = new QTimer();
@@ -67,8 +69,6 @@ Autoware_Rosbag_Plugin::Autoware_Rosbag_Plugin(QWidget *parent) :
 
   ui-&gt;button_record_start-&gt;setDisabled(true);
   ui-&gt;button_record_stop-&gt;setDisabled(true);
-
-
 }
 
 Autoware_Rosbag_Plugin::~Autoware_Rosbag_Plugin()
@@ -82,7 +82,7 @@ PLUGINLIB_EXPORT_CLASS(Autoware_Rosbag_Plugin, rviz::Panel)
 
 void Autoware_Rosbag_Plugin::on_edit_record_filename_textChanged(const QString &amp;arg1)
 {
-  if( !arg1.isEmpty() )
+  if (!arg1.isEmpty())
   {
     record_filename_ = arg1.toStdString();
     ui-&gt;button_record_start-&gt;setEnabled(true);
@@ -92,14 +92,18 @@ void Autoware_Rosbag_Plugin::on_edit_record_filename_textChanged(const QString &amp;
 
 void Autoware_Rosbag_Plugin::on_button_record_save_clicked()
 {
+  /* set default filename */
+  QDateTime now = QDateTime::currentDateTime();
+  QString timestamp = now.toString(QLatin1String("yyyyMMddhhmmss"));
+  QString initial_filename = "autoware-" + timestamp + ".bag";
+
   /* open dialog */
   QString pathInfo =
       QFileDialog::getSaveFileName(
               this,
-              tr("path of saving bag"),
-              DEFAULT_SAVE_PATH);
+              tr("path of saving bag"), DEFAULT_SAVE_PATH + initial_filename);
 
-  if( ! pathInfo.isEmpty() )
+  if (!pathInfo.isEmpty())
   {
     QString filepath, filename, strTemp;
 
@@ -124,7 +128,7 @@ void Autoware_Rosbag_Plugin::on_button_record_save_clicked()
     }
 
     record_filepath_ = filepath.toStdString();
-    ui-&gt;edit_record_filename-&gt;setText(filename);
+    ui-&gt;edit_record_filename-&gt;setText(filepath + filename);
 
   }
 }
@@ -135,25 +139,21 @@ void Autoware_Rosbag_Plugin::on_button_record_start_clicked()
 
   record_topics_.clear();
 
-  /* Set topics parameter from configure file */
-  std::vector&lt;std::string&gt;::iterator ite = conf_topics_.begin();
-  while( ite != conf_topics_.end() )
-  {
-    record_topics_.push_back(*ite);
-    ite++;
-  }
-
   /* Set topics parameter from checkboxes */
   QList&lt;QCheckBox *&gt; list_checkboxes = ui-&gt;scrollAreaWidgetContents-&gt;findChildren&lt;QCheckBox *&gt;();
+  string topic_name;
   for (int i = 0; i &lt; list_checkboxes.size(); ++i) {
-      if ((list_checkboxes.at(i)-&gt;isChecked()) &amp;&amp;
-          ((std::find(conf_topics_.begin(), conf_topics_.end(), list_checkboxes.at(i)-&gt;text().toStdString()) == conf_topics_.end())))
+      if (list_checkboxes.at(i)-&gt;isChecked())
       {
-        record_topics_.push_back(list_checkboxes.at(i)-&gt;text().toStdString());
+        topic_name = list_checkboxes.at(i)-&gt;text().toStdString();
+        if (topic_name.find("!") == string::npos)
+          record_topics_.push_back(topic_name);
+        else
+          record_topics_.push_back(topic_name.substr(0, topic_name.length() - strlen("(Not published!!)")));
       }
   }
 
-  ite = record_topics_.begin();
+  std::vector&lt;std::string&gt;::iterator ite = record_topics_.begin();
   while( ite != record_topics_.end() )
   {
     recoParam.topics.push_back(*ite);
@@ -161,7 +161,19 @@ void Autoware_Rosbag_Plugin::on_button_record_start_clicked()
   }
 
   /* Set filename parameter */
-  recoParam.filename = record_filepath_ + record_filename_;
+  recoParam.filename = record_filename_;
+
+  /* Caculate max split size */
+  if (split_size != 0 &amp;&amp; ui-&gt;checkBox_split_size-&gt;isChecked())
+    recoParam.max_size = ceil(split_size * 1048576 * 1024);
+  else
+    recoParam.max_size = 0;
+
+  /* Caculate max split size */
+  if (split_duration != 0 &amp;&amp; ui-&gt;checkBox_split_duration-&gt;isChecked())
+    recoParam.max_duration = ceil(split_duration * 60);
+  else
+    recoParam.max_duration = -1.0;
 
   /* Start record */
   recordReq(recoParam);
@@ -187,15 +199,22 @@ int Autoware_Rosbag_Plugin::recordReq( RecordParam &amp;recoParam )
   recorder_opts_-&gt;min_space     = 1 * 1073741824ull;
   recorder_opts_-&gt;min_space_str = "1G";
 
+  /* Set max split size MB */
+  if (recoParam.max_size != 0)
+  {
+    recorder_opts_-&gt;split = true;
+    recorder_opts_-&gt;max_size = recoParam.max_size;
+  }
+
   /* Set max duration Sec */
-  if( recoParam.max_duration != 0 )
+  if (recoParam.max_duration != -1.0)
   {
     recorder_opts_-&gt;split = true;
     recorder_opts_-&gt;max_duration = ros::Duration(recoParam.max_duration);
   }
 
   /* No specified topics then record all */
-  if( recoParam.topics.empty() )
+  if (recoParam.topics.empty())
   {
     recorder_opts_-&gt;record_all = true;
   }
@@ -203,7 +222,7 @@ int Autoware_Rosbag_Plugin::recordReq( RecordParam &amp;recoParam )
   {
     /* Give specified topics to request */
     std::vector&lt;std::string&gt;::iterator ite = recoParam.topics.begin();
-    while(ite &lt; recoParam.topics.end() )
+    while (ite &lt; recoParam.topics.end())
     {
       recorder_opts_-&gt;topics.push_back( *ite );
       ite++;
@@ -224,8 +243,8 @@ int Autoware_Rosbag_Plugin::recordReq( RecordParam &amp;recoParam )
   ROS_INFO("%s L.%d -   chunk_size      [%d]", __FUNCTION__, __LINE__, recorder_opts_-&gt;chunk_size);
   ROS_INFO("%s L.%d -   limit           [%d]", __FUNCTION__, __LINE__, recorder_opts_-&gt;limit);
   ROS_INFO("%s L.%d -   split           [%d]", __FUNCTION__, __LINE__, recorder_opts_-&gt;split);
-  ROS_INFO("%s L.%d -   max_size        [%d]", __FUNCTION__, __LINE__, recorder_opts_-&gt;max_size);
-  ROS_INFO("%s L.%d -   max_duration    [%lf]", __FUNCTION__, __LINE__, recorder_opts_-&gt;max_duration.toSec() );
+  ROS_INFO("%s L.%d -   max_size        [%.2fGB]", __FUNCTION__, __LINE__, recorder_opts_-&gt;max_size / 1048576.0 / 1024.0);
+  ROS_INFO("%s L.%d -   max_duration    [%.1fmin]", __FUNCTION__, __LINE__, recorder_opts_-&gt;max_duration.toSec() / 60.0 );
   ROS_INFO("%s L.%d -   node            [%s]", __FUNCTION__, __LINE__, recorder_opts_-&gt;node.c_str() );
   ROS_INFO("%s L.%d -   min_space       [%d]", __FUNCTION__, __LINE__, recorder_opts_-&gt;min_space );
   ROS_INFO("%s L.%d -   min_space_str   [%s]", __FUNCTION__, __LINE__, recorder_opts_-&gt;min_space_str.c_str() );
@@ -247,7 +266,7 @@ int Autoware_Rosbag_Plugin::doRecord( rosbag_controller::RecorderOptions &amp;opt )
 
   record_time_start_ = ros::Time::now();
 
-  if( recorder_-&gt;start() == 0 )
+  if (recorder_-&gt;start() == 0)
   {
 //    ROS_INFO("Start now!!!");
   }
@@ -320,25 +339,56 @@ void Autoware_Rosbag_Plugin::on_botton_topic_refresh_clicked()
   QVBoxLayout *lay = new QVBoxLayout(ui-&gt;scrollAreaWidgetContents);
   int topic_num = 0;
 
-  /* Scan current topics and build checkboxs */
+  /* Scan current topics */
   std::vector&lt;std::string&gt; current_topic;
   for (ros::master::V_TopicInfo::iterator it = master_topics.begin() ; it != master_topics.end(); it++) {
     const ros::master::TopicInfo&amp; info = *it;
     current_topic.push_back(info.name);
   }
 
+  /* Soft topics */
   std::sort(current_topic.begin(),current_topic.end());
 
+  /* Build checkboxs for configure file */
+  if (!conf_topics_.empty())
+  {
+    std::vector&lt;std::string&gt;::iterator ite = conf_topics_.begin();
+    while (ite != conf_topics_.end())
+    {
+      if (std::find(current_topic.begin(), current_topic.end(), *ite) == current_topic.end())
+      {
+        QCheckBox *dynamic = new QCheckBox(QString::fromStdString(*ite + "(Not published!!)"));
+        dynamic-&gt;setChecked (true);
+        dynamic-&gt;setStyleSheet("color: red;"
+                               "background-color: yellow;");
+        lay-&gt;addWidget(dynamic);
+        topic_num++;
+        ite++;
+      }
+      else
+      {
+        QCheckBox *dynamic = new QCheckBox(QString::fromStdString(*ite));
+        dynamic-&gt;setChecked (true);
+        lay-&gt;addWidget(dynamic);
+        topic_num++;
+        ite++;
+      }
+    }
+  }
+
+  /* Build checkboxs for current topics */
   std::vector&lt;std::string&gt;::iterator ite = current_topic.begin();
-  while( ite != current_topic.end() )
+  while (ite != current_topic.end())
   {
-    QCheckBox *dynamic = new QCheckBox(QString::fromStdString(*ite));
-    dynamic-&gt;setChecked (false);
-    lay-&gt;addWidget(dynamic);
-    topic_num++;
+    if (std::find(conf_topics_.begin(), conf_topics_.end(), *ite) == conf_topics_.end())
+    {
+      QCheckBox *dynamic = new QCheckBox(QString::fromStdString(*ite));
+      dynamic-&gt;setChecked (false);
+      lay-&gt;addWidget(dynamic);
+      topic_num++;
+    }
     ite++;
   }
-
   ui-&gt;scrollAreaWidgetContents-&gt;setLayout(lay);
 }
 
@@ -351,14 +401,14 @@ void Autoware_Rosbag_Plugin::on_button_record_configure_clicked()
               tr("path of record configure file"),
               DEFAULT_CONFIGURE_PATH);
 
-  if( ! configureInfo.isEmpty() )
+  if (!configureInfo.isEmpty())
   {
     QString filepath, filename, strTemp;
 
     strTemp = configureInfo;
     int idx = strTemp.lastIndexOf('/');
 
-    if( idx != -1 )
+    if (idx != -1)
     {
       filepath = strTemp.left(idx+1);
       filename = strTemp.remove(0, idx+1);
@@ -370,7 +420,7 @@ void Autoware_Rosbag_Plugin::on_button_record_configure_clicked()
     }
 
     idx = filename.lastIndexOf(".yaml");
-    if(idx == -1)
+    if (idx == -1)
     {
       ROS_ERROR("Need .yaml file!!");
       return;
@@ -393,3 +443,44 @@ void Autoware_Rosbag_Plugin::on_button_record_configure_clicked()
   }
 }
 
+void Autoware_Rosbag_Plugin::on_checkBox_split_size_stateChanged(int arg1)
+{
+  if (ui-&gt;checkBox_split_size-&gt;isChecked())
+  {
+    ui-&gt;checkBox_split_duration-&gt;setDisabled(true);
+    ui-&gt;lineEdit_duration-&gt;setDisabled(true);
+    ui-&gt;lineEdit_size-&gt;setEnabled(true);
+  }
+  else
+  {
+    ui-&gt;checkBox_split_duration-&gt;setEnabled(true);
+    ui-&gt;lineEdit_duration-&gt;setDisabled(true);
+    ui-&gt;lineEdit_size-&gt;setDisabled(true);
+  }
+}
+
+void Autoware_Rosbag_Plugin::on_checkBox_split_duration_stateChanged(int arg1)
+{
+  if (ui-&gt;checkBox_split_duration-&gt;isChecked())
+  {
+    ui-&gt;checkBox_split_size-&gt;setDisabled(true);
+    ui-&gt;lineEdit_size-&gt;setDisabled(true);
+    ui-&gt;lineEdit_duration-&gt;setEnabled(true);
+  }
+  else
+  {
+    ui-&gt;checkBox_split_size-&gt;setEnabled(true);
+    ui-&gt;lineEdit_size-&gt;setDisabled(true);
+    ui-&gt;lineEdit_duration-&gt;setDisabled(true);
+  }
+}
+
+void Autoware_Rosbag_Plugin::on_lineEdit_duration_textEdited(const QString &amp;arg1)
+{
+    split_duration = arg1.toDouble();
+}
+
+void Autoware_Rosbag_Plugin::on_lineEdit_size_textEdited(const QString &amp;arg1)
+{
+    split_size = arg1.toDouble();
+}
</diff>
			</file>
			<file old_path="ros\src\util\packages\autoware_rviz_plugins\rosbag_controller\src\autoware_rosbag_plugin.h" new_path="ros\src\util\packages\autoware_rviz_plugins\rosbag_controller\src\autoware_rosbag_plugin.h" added_lines="9" deleted_lines="0">
				<diff>@@ -69,6 +69,7 @@ public:
       std::string filename;
       std::vector&lt;std::string&gt; topics;
       int max_duration;
+      uint32_t max_size;
     } RecordParam;
 
 protected:
@@ -90,6 +91,11 @@ protected Q_SLOTS:
     void on_botton_topic_refresh_clicked();
     void on_button_record_configure_clicked();
 
+    void on_checkBox_split_size_stateChanged(int arg1);
+    void on_checkBox_split_duration_stateChanged(int arg1);
+    void on_lineEdit_duration_textEdited(const QString &amp;arg1);
+    void on_lineEdit_size_textEdited(const QString &amp;arg1);
+
 private:
 
     static const QString DEFAULT_SAVE_PATH;
@@ -102,6 +108,9 @@ private:
     std::string record_filepath_;
     std::string record_filename_;
     std::vector&lt;std::string&gt; record_topics_;
+    double split_size;
+    double split_duration;
+
     bool record_status_;
 
     ros::Time record_time_start_;
</diff>
			</file>
			<file old_path="ros\src\util\packages\autoware_rviz_plugins\rosbag_controller\src\core\recorder.cpp" new_path="ros\src\util\packages\autoware_rviz_plugins\rosbag_controller\src\core\recorder.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -518,8 +518,8 @@ void Recorder::doRecord() {
         if (checkSize())
             break;
 
-        if (checkDuration(out.time))
-            break;
+//        if (checkDuration(out.time))
+//            break;
 
         if (scheduledCheckDisk() &amp;&amp; checkLogging()) {
             try {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="37741d755e18d89699b1b7ca61516fbaac048f6d" author="s-azumi">
		<msg>[Feature] Rebuild decision maker (#1609)</msg>
		<modified_files>
			<file old_path="ros\src\common\libs\amathutils_lib\include\amathutils_lib\amathutils.hpp" new_path="ros\src\common\libs\amathutils_lib\include\amathutils_lib\amathutils.hpp" added_lines="34" deleted_lines="31">
				<diff>@@ -4,31 +4,25 @@
 #include &lt;cmath&gt;
 #include &lt;iostream&gt;
 
+// ROS Messages
+#include &lt;geometry_msgs/Point.h&gt;
+#include &lt;geometry_msgs/Pose.h&gt;
+#include &lt;tf/tf.h&gt;
+
 using namespace std;
 
 namespace amathutils
 {
-class point
-{
-private:
-public:
-  double x, y, z;
-
-  point(void)
-  {
-    x = y = z = 0.0;
-  }
+#define G_MPSS 9.80665  // m/s^2
 
-  point(double _x, double _y, double _z)
-  {
-    x = _x;
-    y = _y;
-    z = _z;
-  }
-};
-double find_distance(point *_a, point *_b);
-double find_distance(point &amp;_a, point &amp;_b);
-double find_angle(point *_a, point *_b);
+inline double rad2deg(double _angle)
+{
+  return _angle * 180 / M_PI;
+}
+inline double deg2rad(double _angle)
+{
+  return _angle / 180 * M_PI;
+}
 
 inline double mps2kmph(double _mpsval)
 {
@@ -40,25 +34,34 @@ inline double kmph2mps(double _kmphval)
   return (_kmphval * 1000 / 60 / 60);  // kmph * 1000m / 60sec / 60sec
 }
 
-#define G_MPSS 9.80665  // m/s^2
-
-inline double getGravityAcceleration(double acceleration_mpss)
+inline double getGravityAcceleration(double _acceleration_mpss)
 {
-  return acceleration_mpss / G_MPSS;
+  return _acceleration_mpss / G_MPSS;
 }
 
-inline double getAcceleration(double v0, double v, double x)
+inline double getAcceleration(double _v0, double _v, double _x)
 {
-  return (v * v - v0 * v0) / 2 / x;
+  return (_v * _v - _v0 * _v0) / 2 / _x;
 }
 
-inline double getTimefromAcceleration(double v0, double v, double a)
+inline double getTimefromAcceleration(double _v0, double _v, double _a)
 {
-  return (v - v0) / a;
+  return (_v - _v0) / _a;
 }
 
-bool isIntersectLine(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y, double p4x, double p4y);
-
-int isPointLeftFromLine(double p1x, double p1y, double line_p1x, double line_p1y, double line_p2x, double line_p2y);
+geometry_msgs::Point getNearPtOnLine(const geometry_msgs::Point &amp;_p, const geometry_msgs::Point &amp;_a,
+                                     const geometry_msgs::Point &amp;_b);
+double find_distance(const geometry_msgs::Point &amp;_from, const geometry_msgs::Point &amp;_to);
+double find_distance(const geometry_msgs::Pose &amp;_from, const geometry_msgs::Pose &amp;_to);
+double find_angle(const geometry_msgs::Point &amp;_from, const geometry_msgs::Point &amp;_to);
+bool isIntersectLine(const geometry_msgs::Point &amp;_l1_p1, const geometry_msgs::Point &amp;_l1_p2,
+                     const geometry_msgs::Point &amp;_l2_p1, const geometry_msgs::Point &amp;_l2_p2);
+int isPointLeftFromLine(const geometry_msgs::Point &amp;_target, const geometry_msgs::Point &amp;_line_p1,
+                        const geometry_msgs::Point &amp;_line_p2);
+double getPoseYawAngle(const geometry_msgs::Pose &amp;_pose);
+double calcPosesAngleDiffRaw(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;_p_to);
+double radianNormalize(double _angle);
+double calcPosesAngleDiffDeg(const geometry_msgs::Pose &amp;_p_from, const geometry_msgs::Pose &amp;_p_to);
+double calcPosesAngleDiffRad(const geometry_msgs::Pose &amp;_p_from, const geometry_msgs::Pose &amp;_p_to);
 }
 #endif
</diff>
			</file>
			<file old_path="ros\src\common\libs\amathutils_lib\src\Amathutils.cpp" new_path="ros\src\common\libs\amathutils_lib\src\Amathutils.cpp" added_lines="91" deleted_lines="18">
				<diff>@@ -1,45 +1,118 @@
-#include "amathutils_lib/amathutils.hpp"
+#include &lt;amathutils_lib/amathutils.hpp&gt;
 
 namespace amathutils
 {
-double find_distance(point *_a, point *_b)
+geometry_msgs::Point getNearPtOnLine(const geometry_msgs::Point &amp;_p, const geometry_msgs::Point &amp;_a,
+                                     const geometry_msgs::Point &amp;_b)
 {
-  return std::hypot(std::hypot(_a-&gt;x - _b-&gt;x, _a-&gt;y - _b-&gt;y), _a-&gt;z - _b-&gt;z);
+  double len = find_distance(_a, _b);
+
+  geometry_msgs::Point vnab;
+  geometry_msgs::Point vap;
+  geometry_msgs::Point ret;
+
+  vnab.x = (_b.x - _a.x) / len;
+  vnab.y = (_b.y - _a.y) / len;
+  vnab.z = (_b.z - _a.z) / len;
+
+  vap.x = _p.x - _a.x;
+  vap.y = _p.y - _a.y;
+  vap.z = _p.z - _a.z;
+
+  double dist_ax = vnab.x * vap.x + vnab.y * vap.y + vnab.z * vap.z;
+
+  ret.x = _a.x + (vnab.x * dist_ax);
+  ret.y = _a.y + (vnab.y * dist_ax);
+  ret.z = _a.z + (vnab.z * dist_ax);
+
+  return ret;
 }
-double find_distance(point &amp;_a, point &amp;_b)
+double find_distance(const geometry_msgs::Point &amp;_from, const geometry_msgs::Point &amp;_to)
 {
-  return std::hypot(std::hypot(_a.x - _b.x, _a.y - _b.y), _a.z - _b.z);
+  return std::hypot(std::hypot(_from.x - _to.x, _from.y - _to.y), _from.z - _to.z);
+}
+double find_distance(const geometry_msgs::Pose &amp;_from, const geometry_msgs::Pose &amp;_to)
+{
+  return find_distance(_from.position, _to.position);
 }
 
-double find_angle(point *_a, point *_b)
+double find_angle(const geometry_msgs::Point &amp;_from, const geometry_msgs::Point &amp;_to)
 {
-  double _angle = std::atan2(_b-&gt;y - _a-&gt;y, _b-&gt;x - _a-&gt;x);
+  double _angle = std::atan2(_to.y - _from.y, _to.x - _from.x);
   if (_angle &lt; 0.0)
     _angle = _angle + 2 * M_PI;
 
   return _angle * 360 / (2 * M_PI);
 }
 
-bool isIntersectLine(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y, double p4x, double p4y)
+bool isIntersectLine(const geometry_msgs::Point &amp;_l1_p1, const geometry_msgs::Point &amp;_l1_p2,
+                     const geometry_msgs::Point &amp;_l2_p1, const geometry_msgs::Point &amp;_l2_p2)
 {
-  double ta = (p3x - p4x) * (p1y - p3y) + (p3y - p4y) * (p3x - p1x);
-  double tb = (p3x - p4x) * (p2y - p3y) + (p3y - p4y) * (p3x - p2x);
-  double tc = (p1x - p2x) * (p3y - p1y) + (p1y - p2y) * (p1x - p3x);
-  double td = (p1x - p2x) * (p4y - p1y) + (p1y - p2y) * (p1x - p4x);
+  const double ta = (_l2_p1.x - _l2_p2.x) * (_l1_p1.y - _l2_p1.y) + (_l2_p1.y - _l2_p2.y) * (_l2_p1.x - _l1_p1.x);
+  const double tb = (_l2_p1.x - _l2_p2.x) * (_l1_p2.y - _l2_p1.y) + (_l2_p1.y - _l2_p2.y) * (_l2_p1.x - _l1_p2.x);
+  const double tc = (_l1_p1.x - _l1_p2.x) * (_l2_p1.y - _l1_p1.y) + (_l1_p1.y - _l1_p2.y) * (_l1_p1.x - _l2_p1.x);
+  const double td = (_l1_p1.x - _l1_p2.x) * (_l2_p2.y - _l1_p1.y) + (_l1_p1.y - _l1_p2.y) * (_l1_p1.x - _l2_p2.x);
 
   if (tc * td &lt; 0 &amp;&amp; ta * tb &lt; 0)
     return true;
   else
     return false;
 }
-#define LEFT 1
-#define RIGHT -1
-#define ONLINE 0
 
-int isPointLeftFromLine(double p1x, double p1y, double line_p1x, double line_p1y, double line_p2x, double line_p2y)
+/*
+ *        |
+ *     .|       =&gt;LEFT = 1
+ *      |   .   =&gt;RIGHT = -1
+ *      |
+ */
+
+int isPointLeftFromLine(const geometry_msgs::Point &amp;_target, const geometry_msgs::Point &amp;_line_p1,
+                        const geometry_msgs::Point &amp;_line_p2)
+{
+  const int LEFT = 1;
+  const int RIGHT = -1;
+  const int ONLINE = 0;
+  const double n = _target.x * (_line_p1.y - _line_p2.y) + _line_p1.x * (_line_p2.y - _target.y) +
+                   _line_p2.x * (_target.y - _line_p1.y);
+
+  return n &gt; 0 ? LEFT : n &lt; 0 ? RIGHT : ONLINE;
+}
+
+double getPoseYawAngle(const geometry_msgs::Pose &amp;_pose)
 {
-  double n = p1x * (line_p1y - line_p2y) + line_p1x * (line_p2y - p1y) + line_p2x * (p1y - line_p1y);
+  double r, p, y;
 
-  return n &gt; 0 ? 1 : n &lt; 0 ? -1 : 0;
+  // get Quaternion
+  tf::Quaternion quat(_pose.orientation.x, _pose.orientation.y, _pose.orientation.z, _pose.orientation.w);
+  // converted to RPY[-pi : pi]
+  tf::Matrix3x3(quat).getRPY(r, p, y);
+  return y;
+}
+
+double calcPosesAngleDiffRaw(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;_p_to)
+{
+  return getPoseYawAngle(p_from) - getPoseYawAngle(_p_to);
+}
+
+double radianNormalize(double _angle)
+{
+  double n_angle = std::fmod(_angle, 2 * M_PI);
+  n_angle = n_angle &gt; M_PI ? n_angle - 2 * M_PI : n_angle &lt; -M_PI ? 2 * M_PI + n_angle : n_angle;
+
+  // another way
+  // Math.atan2(Math.sin(_angle), Math.cos(_angle));
+  return n_angle;
+}
+
+double calcPosesAngleDiffDeg(const geometry_msgs::Pose &amp;_p_from, const geometry_msgs::Pose &amp;_p_to)
+{
+  // convert to [-pi : pi]
+  return rad2deg(radianNormalize(calcPosesAngleDiffRaw(_p_from, _p_to)));
+}
+
+double calcPosesAngleDiffRad(const geometry_msgs::Pose &amp;_p_from, const geometry_msgs::Pose &amp;_p_to)
+{
+  // convert to [-pi : pi]
+  return radianNormalize(calcPosesAngleDiffRaw(_p_from, _p_to));
 }
 }
</diff>
			</file>
			<file old_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state.hpp" new_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state.hpp" added_lines="98" deleted_lines="92">
				<diff>@@ -1,145 +1,151 @@
 #ifndef __STATE_HPP__
 #define __STATE_HPP__
 
+#include &lt;cassert&gt;
 #include &lt;functional&gt;
 #include &lt;iostream&gt;
 #include &lt;memory&gt;
-#include &lt;state_machine_lib/state_flags.hpp&gt;
 #include &lt;vector&gt;
 
+#include &lt;yaml-cpp/yaml.h&gt;
+#include &lt;state_machine_lib/state_common.hpp&gt;
+#include &lt;state_machine_lib/state_flags.hpp&gt;
+
 namespace state_machine
 {
-class StartState;
-class InitialState;
-class LocateVehicleState;
-
-class DriveState;
-// Accel/Brake subState
-class DriveAccAccelerationState;
-class DriveAccDecelerationState;
-class DriveAccKeepState;
-class DriveAccStopState;
-// Steering subState
-class DriveStrStraightState;
-class DriveStrLeftTurnState;
-class DriveStrRightTurnState;
-
-// Behavior subState
-class DriveBehaviorLaneChangeLeftState;
-class DriveBehaviorLaneChangeRightState;
-class DriveBehaviorObstacleAvoidanceState;
-
-// Perception subState
-class DriveDetectObstacleState;
-class DriveDetectStoplineState;
-class DriveDetectTrafficlightRedState;
-
-class MissionCompleteState;
-class EmergencyState;
-
-// base class
-class BaseState
+class State
 {
-protected:
-  BaseState()
-  {
-  }
+private:
+  std::shared_ptr&lt;State&gt; child_state_;
 
-public:
-  virtual void update(void) = 0;
-  virtual void inState(void) = 0;
-  virtual void outState(void) = 0;
-  virtual void showStateName(void) = 0;
-  virtual uint64_t getStateTransMask(void) = 0;
-  virtual uint64_t getStateNum(void) = 0;
-  virtual std::string getStateName(void) = 0;
-  virtual uint8_t getStateKind(void) = 0;
-  virtual void setCallbackUpdateFunc(std::function&lt;void(void)&gt; _f) = 0;
-  virtual void setCallbackInFunc(std::function&lt;void(void)&gt; _f) = 0;
-  virtual void setCallbackOutFunc(std::function&lt;void(void)&gt; _f) = 0;
-};
+  std::string state_name_;
+  uint64_t state_id_;
 
-// Interface
-template &lt;class T&gt;
-class State : public BaseState
-{
-protected:
-  std::string StateName = "Base";
-  uint64_t StateNum;
-  uint64_t StateTransMask;
-  uint8_t StateKind;
+  std::shared_ptr&lt;State&gt; parent_state_;
+
+  std::function&lt;void(const std::string&amp;)&gt; CallbackUpdateFunc;
+  std::function&lt;void(const std::string&amp;)&gt; CallbackEntryFunc;
+  std::function&lt;void(const std::string&amp;)&gt; CallbackExitFunc;
 
-  std::function&lt;void(void)&gt; StateCallbackUpdateFunc;
-  std::function&lt;void(void)&gt; StateCallbackInFunc;
-  std::function&lt;void(void)&gt; StateCallbackOutFunc;
+  std::map&lt;std::string, uint64_t&gt; transition_map_;
 
-  State()
+  std::string entered_key_;
+
+  void parseChildState(YAML::Node&amp; node);
+
+public:
+  State(std::string _state_name, uint64_t _state_id, std::shared_ptr&lt;State&gt; _parent_state = NULL)
+    : child_state_(NULL), state_name_(_state_name), state_id_(_state_id), parent_state_(_parent_state), entered_key_("")
+  {
+#if 0
+    CallbackUpdateFunc =
+        [&amp;](const std::string &amp;arg) { /*DEBUG_PRINT("[%s]:%s is not registered\n", state_name_.c_str(), "update");*/ };
+    CallbackEntryFunc =
+        [&amp;](const std::string &amp;arg) { /*DEBUG_PRINT("[%s]:%s is not registered\n", state_name_.c_str(), "entry");*/ };
+    CallbackExitFunc =
+        [&amp;](const std::string &amp;arg) { /*DEBUG_PRINT("[%s]:%s is not registered\n", state_name_.c_str(), "exit");*/ };
+#endif
+  }
+  ~State()
   {
-    StateNum = 0;
-    StateTransMask = (uint64_t)STATE_END - 1;
-    StateKind = UNKNOWN_STATE;
   }
 
-public:
-  virtual void update(void)
+  void onUpdate(void)
   {
-    if (StateCallbackUpdateFunc)
-      StateCallbackUpdateFunc();
+    if (child_state_)
+      child_state_-&gt;onUpdate();
+
+    if (CallbackUpdateFunc)
+      CallbackUpdateFunc(state_name_);
   }
 
-  virtual void inState(void)
+  void onEntry(void)
   {
-    if (StateCallbackInFunc)
-      StateCallbackInFunc();
+    DEBUG_PRINT("[%s:Entry]\n", state_name_.c_str());
+
+    if (CallbackEntryFunc)
+      CallbackEntryFunc(state_name_);
   }
-  virtual void outState(void)
+  void onExit(void)
   {
-    if (StateCallbackOutFunc)
-      StateCallbackOutFunc();
+    DEBUG_PRINT("[%s:Exit]\n", state_name_.c_str());
+    if (child_state_)
+      child_state_-&gt;onExit();
+
+    setChild(nullptr);
+
+    if (CallbackExitFunc)
+      CallbackExitFunc(state_name_);
   }
-  virtual void setCallbackUpdateFunc(std::function&lt;void(void)&gt; _f)
+  void setCallbackUpdate(std::function&lt;void(const std::string&amp;)&gt; _f)
   {
-    StateCallbackUpdateFunc = _f;
+    CallbackUpdateFunc = _f;
   }
-
-  virtual void setCallbackOutFunc(std::function&lt;void(void)&gt; _f)
+  void setCallbackEntry(std::function&lt;void(const std::string&amp;)&gt; _f)
   {
-    StateCallbackOutFunc = _f;
+    CallbackEntryFunc = _f;
   }
 
-  virtual void setCallbackInFunc(std::function&lt;void(void)&gt; _f)
+  void setCallbackExit(std::function&lt;void(const std::string&amp;)&gt; _f)
   {
-    StateCallbackInFunc = _f;
+    CallbackExitFunc = _f;
   }
 
   void showStateName(void)
   {
-    std::cout &lt;&lt; StateName &lt;&lt; "-";
+    std::cout &lt;&lt; state_name_ &lt;&lt; "-";
+  }
+  void setParent(std::shared_ptr&lt;State&gt; _parent)
+  {
+    assert(this != _parent.get());
+    parent_state_ = _parent;
   }
 
-  static T* getInstance(void)
+  void setChild(std::shared_ptr&lt;State&gt; _child)
   {
-    static T singleton;
-    return &amp;singleton;
+    assert(this != _child.get());
+    child_state_ = _child;
   }
 
+  std::shared_ptr&lt;State&gt; getParent()
+  {
+    return parent_state_;
+  }
+  std::shared_ptr&lt;State&gt; getChild()
+  {
+    return child_state_;
+  }
   std::string getStateName(void)
   {
-    return std::string(StateName);
+    return std::string(state_name_);
   }
 
-  uint8_t getStateKind(void)
+  void addTransition(const std::string key, const uint64_t val)
   {
-    return StateKind;
+    transition_map_[key] = val;
   }
 
-  uint64_t getStateTransMask(void)
+  uint64_t getTansitionVal(std::string key) const
+  {
+    return transition_map_.at(key);
+  }
+
+  const std::map&lt;std::string, uint64_t&gt;&amp; getTransitionMap(void)
+  {
+    return transition_map_;
+  }
+
+  uint64_t getStateID(void)
+  {
+    return state_id_;
+  }
+  void setEnteredKey(const std::string&amp; key)
   {
-    return StateTransMask;
+    entered_key_ = key;
   }
-  uint64_t getStateNum(void)
+  std::string getEnteredKey(void)
   {
-    return StateNum;
+    return entered_key_;
   }
 };
 }
</diff>
			</file>
			<file old_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_common.hpp" new_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_common.hpp" added_lines="4" deleted_lines="4">
				<diff>@@ -1,16 +1,16 @@
 #ifndef __COMMON_HPP__
 #define __COMMON_HPP__
 
-#define DEBUG
+//#define DEBUG
 
 #ifdef DEBUG
-#define DEBUG_PRINT(str)                                                                                               \
+#define DEBUG_PRINT(...)                                                                                               \
   do                                                                                                                   \
   {                                                                                                                    \
-    std::cout &lt;&lt; str &lt;&lt; std::endl;                                                                                     \
+    fprintf(stderr, __VA_ARGS__);                                                                                      \
   } while (false)
 #else
-#define DEBUG_PRINT(str)                                                                                               \
+#define DEBUG_PRINT(...)                                                                                               \
   do                                                                                                                   \
   {                                                                                                                    \
   } while (false)
</diff>
			</file>
			<file old_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_context.hpp" new_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_context.hpp" added_lines="40" deleted_lines="99">
				<diff>@@ -10,128 +10,69 @@
 #include &lt;unordered_map&gt;
 #include &lt;utility&gt;
 
-#include "state.hpp"
-#include "state_drive.hpp"
-#include "state_emg.hpp"
-#include "state_main.hpp"
+#include &lt;state_machine_lib/state.hpp&gt;
 
 namespace state_machine
 {
 class StateContext
 {
 private:
-  std::map&lt;uint8_t, uint64_t&gt; HolderMap;
-  std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;
+  std::shared_ptr&lt;State&gt; root_state_;
+  std::map&lt;uint64_t, std::shared_ptr&lt;State&gt;&gt; state_map_;
+  std::mutex change_state_mutex_;
 
-  bool enableForceSetState;
-  std::queue&lt;uint64_t&gt; ChangeStateFlags;
-  std::atomic&lt;bool&gt; thread_loop;
-
-  std::thread *thr_state_dec;
-  std::mutex change_state_mutex;
+  void showStateMove(uint64_t _state_id)
+  {
+    std::cout &lt;&lt; "State will be [" &lt;&lt; state_map_[_state_id]-&gt;getStateName() &lt;&lt; "]" &lt;&lt; std::endl;
+  }
+  bool setCurrentState(State* state);
 
-  void showStateMove(uint64_t _state_num)
+  void setParent(uint64_t child, uint64_t parent)
   {
-    std::cout &lt;&lt; "State will be [" &lt;&lt; StateStores[_state_num]-&gt;getStateName() &lt;&lt; "]" &lt;&lt; std::endl;
+    state_map_[child]-&gt;setParent(state_map_[parent]);
   }
-  bool setCurrentState(BaseState *state);
+  uint64_t parseChildState(const YAML::Node&amp; node, uint64_t _id_counter, uint64_t _parent_id);
+  int32_t getStateIDbyName(std::string _name);
+  void setTransitionMap(const YAML::Node&amp; node, const std::shared_ptr&lt;State&gt;&amp; _state);
+
+  std::shared_ptr&lt;State&gt; getStatePtr(const YAML::Node&amp; node);
+  std::shared_ptr&lt;State&gt; getStatePtr(const std::string&amp; _state_name);
+  std::shared_ptr&lt;State&gt; getStatePtr(const uint64_t&amp; _state_id);
+
+  bool isCurrentState(const std::string&amp; state_name);
+
+  std::string dot_output_name;
 
 public:
-  StateContext(void)
+  StateContext(const std::string&amp; file_name, const std::string&amp; msg_name)
   {
-    StateStores[START_STATE] = StartState::getInstance();
-    StateStores[INITIAL_STATE] = InitialState::getInstance();
-    StateStores[INITIAL_LOCATEVEHICLE_STATE] = LocateVehicleState::getInstance();
-    StateStores[DRIVE_STATE] = DriveState::getInstance();
-    StateStores[DRIVE_ACC_ACCELERATION_STATE] = DriveAccAccelerationState::getInstance();
-    StateStores[DRIVE_ACC_DECELERATION_STATE] = DriveAccDecelerationState::getInstance();
-    StateStores[DRIVE_ACC_KEEP_STATE] = DriveAccKeepState::getInstance();
-    StateStores[DRIVE_ACC_STOP_STATE] = DriveAccStopState::getInstance();
-    StateStores[DRIVE_ACC_STOPLINE_STATE] = DriveAccStopLineState::getInstance();
-    StateStores[DRIVE_ACC_CRAWL_STATE] = DriveAccCrawlState::getInstance();
-    StateStores[DRIVE_STR_STRAIGHT_STATE] = DriveStrStraightState::getInstance();
-    StateStores[DRIVE_STR_LEFT_STATE] = DriveStrLeftState::getInstance();
-    StateStores[DRIVE_STR_RIGHT_STATE] = DriveStrRightState::getInstance();
-    StateStores[DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE] = DriveBehaviorLaneChangeLeftState::getInstance();
-    StateStores[DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE] = DriveBehaviorLaneChangeRightState::getInstance();
-    StateStores[DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE] = DriveBehaviorTrafficLightRedState::getInstance();
-    StateStores[DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE] = DriveBehaviorTrafficLightGreenState::getInstance();
-    StateStores[DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE] = DriveBehaviorObstacleAvoidanceState::getInstance();
-    StateStores[DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE] = DriveBehaviorStoplinePlanState::getInstance();
-    StateStores[DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE] = DriveBehaviorAcceptLanechangeState::getInstance();
-    StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
-    StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();
-
-    HolderMap[MAIN_STATE] = 0ULL;
-    HolderMap[ACC_STATE] = 0ULL;
-    HolderMap[STR_STATE] = 0ULL;
-    HolderMap[BEHAVIOR_STATE] = 0ULL;
-    HolderMap[PERCEPTION_STATE] = 0ULL;
-    HolderMap[OTHER_STATE] = 0ULL;
-
-    thread_loop = true;
-
-    this-&gt;InitContext();
+    createStateMap(file_name, msg_name);
+    root_state_ = getStartState();
+    dot_output_name = "/tmp/" + msg_name + ".dot";
+    createDOTGraph(dot_output_name);
   }
 
   ~StateContext()
   {
-    thread_loop = false;
   }
 
-  void update(void);
-  void inState(uint8_t _kind, uint64_t _prev_state_num);
-  void OutState(uint8_t _kind);
-  void stateDecider(void);
-
-  bool isState(BaseState *base, uint64_t _state_num);
-  bool isCurrentState(uint64_t _state_num);
-  bool isCurrentState(uint8_t _state_kind, uint64_t _state_num);
-  bool isDifferentState(uint64_t _state_a, uint64_t _state_b);
-
-  bool setCurrentState(uint64_t flag);
-  bool disableCurrentState(uint64_t);
-
-  BaseState *getStateObject(const uint64_t &amp;_state_num);
-  std::string getStateName(const uint64_t &amp;_state_num);
-  uint8_t getStateKind(const uint64_t &amp;_state_num);
-
-  BaseState *getCurrentMainState(void);
-  BaseState *getCurrentState(void);
-  std::string getCurrentStateName(void);
-  std::string getStateName(void);
-
-  std::vector&lt;BaseState *&gt; getMultipleStates(uint64_t _state_num_set);
-
-  bool setCallbackInFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
-  bool setCallbackOutFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
-  bool setCallbackUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
-
-  BaseState **getCurrentStateHolderPtr(uint8_t _kind);
-  BaseState **getCurrentStateHolderPtr(uint64_t _state_num);
-  BaseState **getCurrentStateHolderPtr(BaseState *_state);
-  void showCurrentStateName(void);
-  std::string createStateMessageText(void);
-
-  uint64_t getStateNum(BaseState *_state);
-  uint64_t getStateTransMask(BaseState *_state);
-  bool isEmptyMainState(void);
-  uint8_t getStateKind(BaseState *_state);
-  bool isMainState(BaseState *_state);
-
-  std::string getCurrentStateName(uint8_t kind);
+  void createStateMap(std::string _state_file_name, std::string _msg_name);
+  std::shared_ptr&lt;State&gt; getStartState(void);
 
-  bool setEnableForceSetState(bool force_flag);
-  void InitContext(void);
+  void onUpdate(void);
 
-  bool TFInitialized(void);
+  bool setCallback(const CallbackType&amp; _type, const std::string&amp; _state_name,
+                   const std::function&lt;void(const std::string&amp;)&gt;&amp; _f);
 
-  void handleTrafficLight(uint32_t _light_color);
-  bool handleCurrentPose(double x, double y, double z, double roll, double pitch, double yaw);
-  bool handlePointsRaw(bool _hasLidarData);
+  // visualize
+  void createGraphTransitionList(std::ofstream&amp; outputfile, int idx,
+                                 std::map&lt;uint64_t, std::vector&lt;uint64_t&gt;&gt;&amp; sublist);
+  void createDOTGraph(std::string _file_name);
 
-  bool handleIntersection(bool _hasIntersection, double _angle);
-  bool handleTwistCmd(bool _hasTwistCmd);
+  std::string getStateText();
+  std::string getAvailableTransition(void);
+  void showStateName();
+  void nextState(const std::string&amp; transition_key);
 };
 }
 
</diff>
			</file>
			<file old_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_drive.hpp" new_path="" added_lines="0" deleted_lines="260">
				<diff>@@ -1,260 +0,0 @@
-#ifndef __STATE_DRIVE_HPP__
-#define __STATE_DRIVE_HPP__
-
-/**
- * @file state_drive.hpp
- * @brief Declaration drive state
- * @author Yusuke Fujii
- * @date 2017/07/27
- */
-
-#include "state.hpp"
-
-namespace state_machine
-{
-// DriveState
-class DriveState : public State&lt;DriveState&gt;
-{
-private:
-  friend class State&lt;DriveState&gt;;
-
-  DriveState(void)
-  {
-    StateName = "Drive";
-    StateNum = StateTransMask = DRIVE_STATE;
-    StateTransMask |= INITIAL_LOCATEVEHICLE_STATE;
-    StateKind = MAIN_STATE;
-  }
-
-public:
-};
-
-class DriveAccAccelerationState : public State&lt;DriveAccAccelerationState&gt;
-{
-private:
-  friend class State&lt;DriveAccAccelerationState&gt;;
-  DriveAccAccelerationState(void)
-  {
-    StateName = "Accelerate";
-    StateNum = DRIVE_ACC_ACCELERATION_STATE;
-    StateKind = ACC_STATE;
-  }
-
-public:
-  void ShowStateName(void)
-  {
-    std::cout &lt;&lt; StateName &lt;&lt; "-";
-  }
-};
-
-class DriveAccDecelerationState : public State&lt;DriveAccDecelerationState&gt;
-{
-private:
-  friend class State&lt;DriveAccDecelerationState&gt;;
-  DriveAccDecelerationState(void)
-  {
-    StateName = "Decelerate";
-    StateNum = DRIVE_ACC_DECELERATION_STATE;
-    StateKind = ACC_STATE;
-  }
-
-public:
-};
-
-class DriveAccKeepState : public State&lt;DriveAccKeepState&gt;
-{
-private:
-  friend class State&lt;DriveAccKeepState&gt;;
-  DriveAccKeepState(void)
-  {
-    StateName = "Keep";
-    StateNum = DRIVE_ACC_KEEP_STATE;
-    StateKind = ACC_STATE;
-  }
-
-public:
-};
-
-class DriveAccCrawlState : public State&lt;DriveAccCrawlState&gt;
-{
-private:
-  friend class State&lt;DriveAccCrawlState&gt;;
-  DriveAccCrawlState(void)
-  {
-    StateName = "Crawl";
-    StateNum = DRIVE_ACC_CRAWL_STATE;
-    StateKind = ACC_STATE;
-  }
-
-public:
-};
-
-class DriveAccStopState : public State&lt;DriveAccStopState&gt;
-{
-private:
-  friend class State&lt;DriveAccStopState&gt;;
-  DriveAccStopState(void)
-  {
-    StateName = "Stop";
-    StateNum = DRIVE_ACC_STOP_STATE;
-    StateKind = ACC_STATE;
-  }
-
-public:
-};
-
-class DriveAccStopLineState : public State&lt;DriveAccStopLineState&gt;
-{
-private:
-  friend class State&lt;DriveAccStopLineState&gt;;
-  DriveAccStopLineState(void)
-  {
-    StateName = "StopLine";
-    StateNum = DRIVE_ACC_STOPLINE_STATE;
-    StateKind = ACC_STATE;
-  }
-
-public:
-};
-
-class DriveStrLeftState : public State&lt;DriveStrLeftState&gt;
-{
-private:
-  friend class State&lt;DriveStrLeftState&gt;;
-  DriveStrLeftState(void)
-  {
-    StateName = "Left Turn";
-    StateNum = DRIVE_STR_LEFT_STATE;
-    StateKind = STR_STATE;
-  }
-
-public:
-};
-class DriveStrRightState : public State&lt;DriveStrRightState&gt;
-{
-private:
-  friend class State&lt;DriveStrRightState&gt;;
-  DriveStrRightState(void)
-  {
-    StateName = "Right Turn";
-    StateNum = DRIVE_STR_RIGHT_STATE;
-    StateKind = STR_STATE;
-  }
-
-public:
-};
-class DriveStrStraightState : public State&lt;DriveStrStraightState&gt;
-{
-private:
-  friend class State&lt;DriveStrStraightState&gt;;
-  DriveStrStraightState(void)
-  {
-    StateName = "Straight";
-    StateNum = DRIVE_STR_STRAIGHT_STATE;
-    StateKind = STR_STATE;
-  }
-
-public:
-};
-
-// Planning to change str state
-class DriveBehaviorLaneChangeLeftState : public State&lt;DriveBehaviorLaneChangeLeftState&gt;
-{
-private:
-  friend class State&lt;DriveBehaviorLaneChangeLeftState&gt;;
-  DriveBehaviorLaneChangeLeftState(void)
-  {
-    StateName = "LaneChangeLeft";
-    StateNum = DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE;
-    StateKind = BEHAVIOR_STATE;
-  }
-
-public:
-};
-
-// Planning to change str state
-class DriveBehaviorLaneChangeRightState : public State&lt;DriveBehaviorLaneChangeRightState&gt;
-{
-private:
-  friend class State&lt;DriveBehaviorLaneChangeRightState&gt;;
-  DriveBehaviorLaneChangeRightState(void)
-  {
-    StateName = "LaneChangeRight";
-    StateNum = DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE;
-    StateKind = BEHAVIOR_STATE;
-  }
-
-public:
-};
-
-class DriveBehaviorObstacleAvoidanceState : public State&lt;DriveBehaviorObstacleAvoidanceState&gt;
-{
-private:
-  friend class State&lt;DriveBehaviorObstacleAvoidanceState&gt;;
-  DriveBehaviorObstacleAvoidanceState(void)
-  {
-    StateName = "ObstacleAvoidance";
-    StateNum = DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE;
-    StateKind = BEHAVIOR_STATE;
-  }
-
-public:
-};
-
-class DriveBehaviorTrafficLightRedState : public State&lt;DriveBehaviorTrafficLightRedState&gt;
-{
-private:
-  friend class State&lt;DriveBehaviorTrafficLightRedState&gt;;
-  DriveBehaviorTrafficLightRedState(void)
-  {
-    StateName = "TrafficLightRed";
-    StateNum = DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE;
-    StateKind = BEHAVIOR_STATE;
-  }
-
-public:
-};
-
-class DriveBehaviorTrafficLightGreenState : public State&lt;DriveBehaviorTrafficLightGreenState&gt;
-{
-private:
-  friend class State&lt;DriveBehaviorTrafficLightGreenState&gt;;
-  DriveBehaviorTrafficLightGreenState(void)
-  {
-    StateName = "TrafficLightGreen";
-    StateNum = DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE;
-    StateKind = BEHAVIOR_STATE;
-  }
-
-public:
-};
-
-class DriveBehaviorStoplinePlanState : public State&lt;DriveBehaviorStoplinePlanState&gt;
-{
-private:
-  friend class State&lt;DriveBehaviorStoplinePlanState&gt;;
-  DriveBehaviorStoplinePlanState(void)
-  {
-    StateName = "STOPLINE_PLAN";
-    StateNum = DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE;
-    StateKind = BEHAVIOR_STATE;
-  }
-
-public:
-};
-
-class DriveBehaviorAcceptLanechangeState : public State&lt;DriveBehaviorAcceptLanechangeState&gt;
-{
-private:
-  friend class State&lt;DriveBehaviorAcceptLanechangeState&gt;;
-  DriveBehaviorAcceptLanechangeState(void)
-  {
-    StateName = "AcceptLane-Change";
-    StateNum = DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE;
-    StateKind = BEHAVIOR_STATE;
-  }
-
-public:
-};
-}
-#endif
</diff>
			</file>
			<file old_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_emg.hpp" new_path="" added_lines="0" deleted_lines="82">
				<diff>@@ -1,82 +0,0 @@
-#ifndef __STATE_EMG_HPP__
-#define __STATE_EMG_HPP__
-
-#include "state.hpp"
-
-namespace state_machine
-{
-class EmergencyHWState : public State&lt;EmergencyHWState&gt;
-{
-private:
-  friend class State&lt;EmergencyHWState&gt;;
-  EmergencyHWState(void)
-  {
-    StateName = "EmergencyHW";
-    StateTransMask = 0;
-  }
-
-public:
-};
-class EmergencyHWVehicleState : public State&lt;EmergencyHWVehicleState&gt;
-{
-private:
-  friend class State&lt;EmergencyHWVehicleState&gt;;
-  EmergencyHWVehicleState(void)
-  {
-    StateName = "EmergencyHWVehicle";
-    StateTransMask = 0;
-  }
-
-public:
-};
-class EmergencyHWControllerState : public State&lt;EmergencyHWControllerState&gt;
-{
-private:
-  friend class State&lt;EmergencyHWControllerState&gt;;
-  EmergencyHWControllerState(void)
-  {
-    StateName = "EmergencyHWController";
-    StateTransMask = 0;
-  }
-
-public:
-};
-class EmergencySWState : public State&lt;EmergencySWState&gt;
-{
-private:
-  friend class State&lt;EmergencySWState&gt;;
-  EmergencySWState(void)
-  {
-    StateName = "EmergencySW";
-    StateTransMask = 0;
-  }
-
-public:
-};
-class EmergencySWAutowareState : public State&lt;EmergencySWAutowareState&gt;
-{
-private:
-  friend class State&lt;EmergencySWAutowareState&gt;;
-  EmergencySWAutowareState(void)
-  {
-    StateName = "EmergencySWAutoware";
-    StateTransMask = 0;
-  }
-
-public:
-};
-class EmergencySWControllerState : public State&lt;EmergencySWControllerState&gt;
-{
-private:
-  friend class State&lt;EmergencySWControllerState&gt;;
-  EmergencySWControllerState(void)
-  {
-    StateName = "EmergencySWController";
-    StateTransMask = 0;
-  }
-
-public:
-};
-}
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_flags.hpp" new_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_flags.hpp" added_lines="4" deleted_lines="42">
				<diff>@@ -3,49 +3,11 @@
 
 namespace state_machine
 {
-enum StateFlags
+enum class CallbackType
 {
-  NULL_STATE = 1ULL &lt;&lt; 0,
-  START_STATE = 1ULL &lt;&lt; 1,
-  INITIAL_STATE = 1ULL &lt;&lt; 2,
-  INITIAL_LOCATEVEHICLE_STATE = 1ULL &lt;&lt; 3,
-  DRIVE_STATE = 1ULL &lt;&lt; 4,
-  MISSION_COMPLETE_STATE = 1ULL &lt;&lt; 5,
-  EMERGENCY_STATE = 1ULL &lt;&lt; 6,
-
-  DRIVE_SUB_STATE_START = 1ULL &lt;&lt; 10,
-
-  DRIVE_ACC_ACCELERATION_STATE = 1ULL &lt;&lt; 11,
-  DRIVE_ACC_DECELERATION_STATE = 1ULL &lt;&lt; 12,
-  DRIVE_ACC_KEEP_STATE = 1ULL &lt;&lt; 13,
-  DRIVE_ACC_STOP_STATE = 1ULL &lt;&lt; 14,
-  DRIVE_ACC_STOPLINE_STATE = 1ULL &lt;&lt; 15,
-  DRIVE_ACC_CRAWL_STATE = 1ULL &lt;&lt; 16,
-
-  DRIVE_STR_STRAIGHT_STATE = 1ULL &lt;&lt; 21,
-  DRIVE_STR_LEFT_STATE = 1ULL &lt;&lt; 22,
-  DRIVE_STR_RIGHT_STATE = 1ULL &lt;&lt; 23,
-
-  DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE = 1ULL &lt;&lt; 31,
-  DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE = 1ULL &lt;&lt; 32,
-  DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE = 1ULL &lt;&lt; 33,
-  DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE = 1ULL &lt;&lt; 34,
-  DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE = 1ULL &lt;&lt; 35,
-  DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE = 1ULL &lt;&lt; 36,
-  DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE = 1ULL &lt;&lt; 37,
-  STATE_SUB_END = 1ULL &lt;&lt; 40,
-  STATE_END = 1ULL &lt;&lt; 41,
-};
-
-enum StateKinds
-{
-  MAIN_STATE = 1,
-  ACC_STATE = 2,
-  STR_STATE = 3,
-  BEHAVIOR_STATE = 4,
-  PERCEPTION_STATE = 5,
-  OTHER_STATE = 6,
-  UNKNOWN_STATE = 7,
+  UPDATE,
+  ENTRY,
+  EXIT
 };
 
 enum TrafficLightColors
</diff>
			</file>
			<file old_path="ros\src\common\libs\state_machine_lib\include\state_machine_lib\state_main.hpp" new_path="" added_lines="0" deleted_lines="91">
				<diff>@@ -1,91 +0,0 @@
-#ifndef __STATE_MAIN_HPP__
-#define __STATE_MAIN_HPP__
-
-#include &lt;iostream&gt;
-#include &lt;memory&gt;
-#include &lt;vector&gt;
-
-#include &lt;state_machine_lib/state.hpp&gt;
-
-namespace state_machine
-{
-// StartState
-class StartState : public State&lt;StartState&gt;
-{
-private:
-  friend class State&lt;StartState&gt;;
-  StartState(void)
-  {
-    StateName = "Start";
-    StateNum = START_STATE;
-    StateTransMask = (uint64_t)STATE_END - 1;
-    StateKind = MAIN_STATE;
-  }
-
-public:
-  virtual void update(void) override
-  {
-  }
-};
-
-// InitialState
-class InitialState : public State&lt;InitialState&gt;
-{
-private:
-  friend class State&lt;InitialState&gt;;
-  InitialState(void)
-  {
-    StateName = "Initial";
-    StateNum = StateTransMask = INITIAL_STATE;
-    StateTransMask |= START_STATE | EMERGENCY_STATE | MISSION_COMPLETE_STATE;
-    StateKind = MAIN_STATE;
-  }
-
-public:
-};
-class LocateVehicleState : public State&lt;LocateVehicleState&gt;
-{
-private:
-  friend class State&lt;LocateVehicleState&gt;;
-  LocateVehicleState(void)
-  {
-    StateName = "Locate Vehicle";
-    StateNum = StateTransMask = INITIAL_LOCATEVEHICLE_STATE;
-    StateTransMask |= INITIAL_STATE;
-    StateKind = MAIN_STATE;
-  }
-
-public:
-};
-// MissionCompleteState
-class MissionCompleteState : public State&lt;MissionCompleteState&gt;
-{
-private:
-  friend class State&lt;MissionCompleteState&gt;;
-  MissionCompleteState(void)
-  {
-    StateName = "MissionComplete";
-    StateNum = MISSION_COMPLETE_STATE;
-    StateTransMask = DRIVE_STATE;
-    StateKind = MAIN_STATE;
-  }
-
-public:
-};
-
-// EmergencyState
-class EmergencyState : public State&lt;EmergencyState&gt;
-{
-private:
-  friend class State&lt;EmergencyState&gt;;
-  EmergencyState(void)
-  {
-    StateName = "Emergency";
-    StateTransMask = 0;
-  }
-
-public:
-};
-}
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\common\libs\state_machine_lib\src\state_context.cpp" new_path="ros\src\common\libs\state_machine_lib\src\state_context.cpp" added_lines="239" deleted_lines="264">
				<diff>@@ -1,16 +1,17 @@
 #include &lt;sched.h&gt;
+#include &lt;stdlib.h&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;unistd.h&gt;
-#include &lt;thread&gt;
-#include &lt;vector&gt;
-
 #include &lt;cassert&gt;
+#include &lt;memory&gt;
 #include &lt;mutex&gt;
+#include &lt;vector&gt;
+#include &lt;limits&gt;
 
-#include &lt;state_machine_lib/state_context.hpp&gt;
+#include &lt;fstream&gt;
 
 #include &lt;state_machine_lib/state.hpp&gt;
-#include &lt;state_machine_lib/state_common.hpp&gt;
+#include &lt;state_machine_lib/state_context.hpp&gt;
 
 /**
  *
@@ -23,358 +24,332 @@
 
 namespace state_machine
 {
-std::vector&lt;BaseState *&gt; StateContext::getMultipleStates(uint64_t _state_num_set)
+bool StateContext::setCallback(const CallbackType&amp; _type, const std::string&amp; _state_name,
+                               const std::function&lt;void(const std::string&amp;)&gt;&amp; _f)
 {
-  std::vector&lt;BaseState *&gt; ret;
-  for (uint64_t mask = STATE_SUB_END; _state_num_set != 0 &amp;&amp; mask != 0; mask &gt;&gt;= 1)
+  bool ret = false;
+  int32_t _state_id = getStateIDbyName(_state_name);
+  if (_state_id != -1 &amp;&amp; getStatePtr(static_cast&lt;uint64_t&gt;(_state_id)))
   {
-    if (mask &amp; _state_num_set)
+    switch (_type)
     {
-      ret.push_back(getStateObject(mask));
-      _state_num_set &amp;= ~mask;
+      case CallbackType::UPDATE:
+        getStatePtr(static_cast&lt;uint64_t&gt;(_state_id))-&gt;setCallbackUpdate(_f);
+        ret = true;
+        break;
+      case CallbackType::ENTRY:
+        getStatePtr(static_cast&lt;uint64_t&gt;(_state_id))-&gt;setCallbackEntry(_f);
+        ret = true;
+        break;
+      case CallbackType::EXIT:
+        getStatePtr(static_cast&lt;uint64_t&gt;(_state_id))-&gt;setCallbackExit(_f);
+        ret = true;
+        break;
+      default:
+        break;
     }
   }
   return ret;
 }
+/*****************************/
+/*  Callback                 */
+/*****************************/
 
-void StateContext::update(void)
+void StateContext::onUpdate(void)
 {
-  for (auto &amp;p : HolderMap)
-  {
-    if (p.first == BEHAVIOR_STATE)
-    {
-      for (auto &amp;&amp;state : getMultipleStates(p.second))
-      {
-        state-&gt;update();
-      }
-    }
-    else
-    {
-      if (p.second)
-        if (getStateObject(p.second))
-          getStateObject(p.second)-&gt;update();
-    }
-  }
+  root_state_-&gt;onUpdate();
 }
 
-void StateContext::inState(uint8_t _kind, uint64_t _prev_state_num)
+bool StateContext::isCurrentState(const std::string&amp; state_name)
 {
-  if (_kind &gt; UNKNOWN_STATE)
-  {
-    return;
-  }
-  else if (_kind == BEHAVIOR_STATE)
+  bool ret = false;
+  std::shared_ptr&lt;State&gt; state = root_state_;
+  do
   {
-    for (auto &amp;&amp;state : getMultipleStates(HolderMap[_kind]))
+    if (state-&gt;getStateName() == state_name)
     {
-      if (!(_prev_state_num &amp; getStateNum(state)))
-        state-&gt;inState();
+      ret = true;
     }
-  }
-  else
-  {
-    if (getStateObject(HolderMap[_kind]))
-      getStateObject(HolderMap[_kind])-&gt;inState();
-  }
+    state = state-&gt;getChild();
+  } while (state != nullptr);
+  return ret;
 }
 
-BaseState *StateContext::getStateObject(const uint64_t &amp;_state_num)
+void StateContext::nextState(const std::string&amp; transition_key)
 {
-  if (_state_num)
+  std::shared_ptr&lt;State&gt; state = root_state_;
+  std::string _target_state_name;
+  std::vector&lt;std::string&gt; key_list;
+
+  while (state)
   {
-    if (StateStores[_state_num])
+    if (state-&gt;getTransitionMap().count(transition_key) != 0)
     {
-      return StateStores[_state_num];
-    }
-  }
-  return nullptr;
-}
+      const uint64_t transition_state_id = state-&gt;getTransitionMap().at(transition_key);
+      _target_state_name = state_map_.at(transition_state_id)-&gt;getStateName();
 
-bool StateContext::setCallbackUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
-{
-  bool ret = false;
-  if (getStateObject(_state_num))
-  {
-    getStateObject(_state_num)-&gt;setCallbackUpdateFunc(_f);
-    ret = true;
-  }
+      if (isCurrentState(_target_state_name))
+      {
+        return;
+      }
 
-  return ret;
-}
-bool StateContext::setCallbackInFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
-{
-  bool ret = false;
-  if (getStateObject(_state_num))
-  {
-    getStateObject(_state_num)-&gt;setCallbackInFunc(_f);
-    ret = true;
-  }
-  return ret;
-}
-bool StateContext::setCallbackOutFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
-{
-  bool ret = false;
-  if (getStateObject(_state_num))
-  {
-    getStateObject(_state_num)-&gt;setCallbackOutFunc(_f);
-    ret = true;
+      if (state_map_.at(transition_state_id)-&gt;getParent())
+      {
+        DEBUG_PRINT("[Child]:TransitionState: %d -&gt; %d\n", state-&gt;getStateID(), transition_state_id);
+
+        std::shared_ptr&lt;State&gt; in_state = root_state_;
+
+        do
+        {
+          if (in_state == state_map_.at(transition_state_id)-&gt;getParent())
+          {
+            if (in_state-&gt;getChild())
+            {
+              key_list.push_back(in_state-&gt;getChild()-&gt;getEnteredKey());
+              in_state-&gt;getChild()-&gt;onExit();
+            }
+            in_state-&gt;setChild(state_map_.at(transition_state_id));
+            break;
+          }
+          in_state = in_state-&gt;getChild();
+        } while (in_state);
+
+#ifdef DEBUG
+        createDOTGraph(dot_output_name);
+#endif
+        state_map_.at(transition_state_id)-&gt;setEnteredKey(transition_key);
+        state_map_.at(transition_state_id)-&gt;onEntry();
+      }
+      else
+      {
+        DEBUG_PRINT("[Root]:TransitionState: %d -&gt; %d\n", state-&gt;getStateID(), transition_state_id);
+        state-&gt;onExit();
+
+        root_state_ = state_map_.at(transition_state_id);
+        root_state_-&gt;setChild(nullptr);
+        root_state_-&gt;setParent(nullptr);
+        root_state_-&gt;setEnteredKey(transition_key);
+#ifdef DEBUG
+        createDOTGraph(dot_output_name);
+#endif
+
+        root_state_-&gt;onEntry();
+      }
+      break;
+    }
+    state = state-&gt;getChild();
   }
-  return ret;
-}
 
-std::string StateContext::getStateName(const uint64_t &amp;_state_num)
-{
-  if (getStateObject(_state_num))
+  if (isCurrentState(_target_state_name))
   {
-    return getStateObject(_state_num)-&gt;getStateName();
+    showStateName();
   }
-  else
-    return "";
 }
 
-uint64_t StateContext::getStateNum(BaseState *_state)
+/*****************************/
+/* Getter/Setter             */
+/*****************************/
+
+void StateContext::createGraphTransitionList(std::ofstream&amp; outputfile, int idx,
+                                             std::map&lt;uint64_t, std::vector&lt;uint64_t&gt;&gt;&amp; sublist)
 {
-  if (_state)
+  if (!sublist[idx].empty() || state_map_.at(idx)-&gt;getParent() == NULL)
   {
-    return _state-&gt;getStateNum();
+    outputfile &lt;&lt; "subgraph cluster_" &lt;&lt; idx &lt;&lt; "{\n"
+               &lt;&lt; "label = \"" &lt;&lt; state_map_.at(idx)-&gt;getStateName() &lt;&lt; "\";\n";
+    if (!state_map_.at(idx)-&gt;getParent())
+    {
+      outputfile &lt;&lt; "group = 1;\n";
+    }
+
+    for (auto&amp; state : sublist[idx])
+    {
+      createGraphTransitionList(outputfile, state, sublist);
+    }
   }
-  else
-    return 0;
-}
 
-uint8_t StateContext::getStateKind(BaseState *_state)
-{
-  if (_state)
+  for (auto&amp; map : state_map_.at(idx)-&gt;getTransitionMap())
   {
-    return _state-&gt;getStateKind();
+    if ((state_map_.at(map.second)-&gt;getParent() == state_map_.at(idx)-&gt;getParent() ||
+         state_map_.at(map.second)-&gt;getParent() == state_map_.at(idx)) &amp;&amp;
+        state_map_.at(map.second)-&gt;getParent() != NULL)
+    {
+      outputfile &lt;&lt; idx &lt;&lt; "-&gt;" &lt;&lt; map.second &lt;&lt; " [label=\"" &lt;&lt; map.first &lt;&lt; "\"];\n";
+    }
   }
-  else
-    return UNKNOWN_STATE;
-}
-
-uint8_t StateContext::getStateKind(const uint64_t &amp;_state_num)
-{
-  if (_state_num)
+  if (!sublist[idx].empty() || state_map_.at(idx)-&gt;getParent() == NULL)
   {
-    return getStateKind(getStateObject(_state_num));
+    outputfile &lt;&lt; "}\n";
   }
-  return UNKNOWN_STATE;
-}
-
-void StateContext::showCurrentStateName(void)
-{
-  for (auto &amp;p : HolderMap)
+  for (auto&amp; map : state_map_.at(idx)-&gt;getTransitionMap())
   {
-    if (p.second)
-      if (getStateObject(p.second))
-        getStateObject(p.second)-&gt;showStateName();
+    if ((state_map_.at(map.second)-&gt;getParent() != state_map_.at(idx)-&gt;getParent() &amp;&amp;
+         state_map_.at(map.second)-&gt;getParent() != state_map_.at(idx)) ||
+        state_map_.at(map.second)-&gt;getParent() == NULL)
+    {
+      outputfile &lt;&lt; idx &lt;&lt; "-&gt;" &lt;&lt; map.second &lt;&lt; " [label=\"" &lt;&lt; map.first &lt;&lt; "\"];\n";
+    }
   }
 }
 
-bool StateContext::isDifferentState(uint64_t _state_a, uint64_t _state_b)
+void StateContext::createDOTGraph(std::string _file_name)
 {
-  return !(_state_a &amp; _state_b);
-}
+  std::ofstream outputfile(_file_name);
+  outputfile &lt;&lt; "digraph state_machine_graph {\n"
+             &lt;&lt; "dpi = \"192\";\n node [style=filled];\n";
+  std::vector&lt;uint64_t&gt; rootlist;
+  std::map&lt;uint64_t, std::vector&lt;uint64_t&gt;&gt; sublist;
+  std::map&lt;uint64_t, int&gt; layer_map;
 
-bool StateContext::isEmptyMainState(void)
-{
-  if (HolderMap[MAIN_STATE])
-    return false;
-  return true;
-}
-
-uint64_t StateContext::getStateTransMask(BaseState *_state)
-{
-  if (_state)
-    return _state-&gt;getStateTransMask();
-  else
-    return 0;
-}
-
-bool StateContext::isMainState(BaseState *_state)
-{
-  return getStateKind(_state) == MAIN_STATE;
-}
-
-bool StateContext::setCurrentState(BaseState *_state)
-{
-  change_state_mutex.lock();
-  bool ret = true;
-  if (_state)
+  // create child list
+  for (auto&amp; state : state_map_)
   {
-    uint64_t prev_state = HolderMap[getStateKind(_state)];
-    bool diff = isDifferentState(getStateNum(_state), HolderMap[getStateKind(_state)]);
-    if (isMainState(_state))
+    outputfile &lt;&lt; state.second-&gt;getStateID() &lt;&lt; "[label=\"" &lt;&lt; state.second-&gt;getStateName() &lt;&lt; "\"";
+
     {
-      if (isEmptyMainState() || enableForceSetState || (getStateTransMask(_state) &amp; HolderMap[MAIN_STATE]))
+      std::shared_ptr&lt;State&gt; temp = root_state_;
+      while (temp)
       {
-        for (auto &amp;state : HolderMap)
+        if (temp-&gt;getStateID() == state.second-&gt;getStateID())
         {
-          if (state.first == MAIN_STATE)
-          {
-            state.second = getStateNum(_state);
-          }
-          else
-          {
-            state.second = 0ULL;
-          }
+          outputfile &lt;&lt; ",color = \"crimson\"";
         }
-      }
-      else
-      {
-        ret = false;
+        temp = temp-&gt;getChild();
       }
     }
-    else
+    if (state.second-&gt;getParent())
     {
-      if (getStateKind(_state) == BEHAVIOR_STATE)
-      {
-        HolderMap[getStateKind(_state)] |= getStateNum(_state);
-      }
-      else
-      {
-        HolderMap[getStateKind(_state)] = getStateNum(_state);
-      }
+      sublist[state.second-&gt;getParent()-&gt;getStateID()].push_back(state.second-&gt;getStateID());
     }
-    change_state_mutex.unlock();
-    if (ret &amp;&amp; diff)
+    else
     {
-      this-&gt;inState(getStateKind(_state), prev_state);
-
-      if (getStateKind(_state) == getStateKind(prev_state) &amp;&amp; getStateKind(_state) != BEHAVIOR_STATE)
-        if (getStateObject(prev_state))
-          getStateObject(prev_state)-&gt;outState();
+      outputfile &lt;&lt; ", group = 1";
+      rootlist.push_back(state.second-&gt;getStateID());
     }
+    outputfile &lt;&lt; "];\n";
   }
-  else
+
+  for (auto&amp; root_idx : rootlist)
   {
-    change_state_mutex.unlock();
-    ret = false;
+    int idx = root_idx;
+    createGraphTransitionList(outputfile, idx, sublist);
   }
-  return ret;
-}
-
-bool StateContext::setCurrentState(uint64_t flag)
-{
-  bool ret = this-&gt;setCurrentState(getStateObject(flag));
-  return ret;
-}
 
-bool StateContext::setEnableForceSetState(bool force_flag)
-{
-  enableForceSetState = force_flag;
-  return true;
+  outputfile &lt;&lt; "}";
 }
 
-std::string StateContext::getCurrentStateName(void)
+std::shared_ptr&lt;State&gt; StateContext::getStartState()
 {
-  return this-&gt;getCurrentStateName(MAIN_STATE);
+  for (auto&amp; state : state_map_)
+  {
+    if (state.second-&gt;getStateName() == "Start")
+    {
+      return state.second;
+    }
+  }
+  return nullptr;
 }
 
-std::string StateContext::getCurrentStateName(uint8_t _kind)
+int32_t StateContext::getStateIDbyName(std::string _name)
 {
-  if (HolderMap[_kind])
+  for (const auto&amp; i : state_map_)
   {
-    if (_kind == BEHAVIOR_STATE)
+    if (i.second-&gt;getStateName() == _name)
     {
-      uint64_t _current_state = HolderMap[_kind];
-      std::string ret = "";
-      for (uint64_t mask = STATE_SUB_END; _current_state != 0 &amp;&amp; mask != 0; mask &gt;&gt;= 1)
-      {
-        if (mask &amp; _current_state)
-        {
-          ret += "\n" + getStateName(mask);
-          _current_state &amp;= ~mask;
-        }
-      }
-      return ret;
-    }
-    else
-    {
-      return getStateName(HolderMap[_kind]);
+      return static_cast&lt;int32_t&gt;(i.second-&gt;getStateID());
     }
   }
-  return std::string("");
+  return -1;
 }
 
-BaseState *StateContext::getCurrentMainState(void)
+std::string StateContext::getAvailableTransition(void)
 {
-  return getStateObject(HolderMap[MAIN_STATE]);
-}
+  std::string text;
 
-bool StateContext::disableCurrentState(uint64_t _state_num)
-{
-  if (isMainState(getStateObject(_state_num)))
-  {
-    return false;
-  }
-  if (isCurrentState(_state_num))
+  std::shared_ptr&lt;State&gt; state = root_state_;
+  do
   {
-    HolderMap[getStateKind(_state_num)] &amp;= ~_state_num;
-    getStateObject(_state_num)-&gt;outState();
-    return true;
-  }
-  else
-  {
-    return false;
-  }
-}
+    for (const auto&amp; keyval : state-&gt;getTransitionMap())
+    {
+      text += keyval.first + ":" + state_map_.at(keyval.second)-&gt;getStateName() + ",";
+    }
+    state = state-&gt;getChild();
+  } while (state != nullptr);
 
-bool StateContext::isCurrentState(uint64_t _state_num)
-{
-  if (_state_num)
-    return HolderMap[getStateKind(_state_num)] &amp; _state_num;
-  else
-    return false;
+  return text;
 }
 
-bool StateContext::isState(BaseState *base, uint64_t _state_num)
+std::string StateContext::getStateText(void)
 {
-  return base ? base-&gt;getStateNum() &amp; _state_num ? true : false : false;
+  std::string text;
+
+  std::shared_ptr&lt;State&gt; state = root_state_;
+  do
+  {
+    text += state-&gt;getStateName() + "\n";
+    state = state-&gt;getChild();
+  } while (state != nullptr);
+
+  return text;
 }
 
-bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
+void StateContext::setTransitionMap(const YAML::Node&amp; node, const std::shared_ptr&lt;State&gt;&amp; _state)
 {
-  /* deprecated */
-  return false;
+  for (unsigned int j = 0; j &lt; node.size(); j++)
+  {
+    int32_t state_id = getStateIDbyName(node[j]["Target"].as&lt;std::string&gt;());
+    if (state_id == -1)
+      continue;
+
+    _state-&gt;addTransition(node[j]["Key"].as&lt;std::string&gt;(), static_cast&lt;uint64_t&gt;(state_id));
+  }
 }
 
-std::string StateContext::createStateMessageText(void)
+void StateContext::showStateName()
 {
-  std::string ret;
-
-  for (auto &amp;p : HolderMap)
+  std::shared_ptr&lt;State&gt; state = root_state_;
+  do
   {
-    if (p.second)
-    {
-      ret = ret + "\n" + getStateName(p.second);
-    }
-  }
-  return ret;
+    state = state-&gt;getChild();
+  } while (state != nullptr);
 }
 
-bool StateContext::handleTwistCmd(bool _hasTwistCmd)
+std::shared_ptr&lt;State&gt; StateContext::getStatePtr(const YAML::Node&amp; node)
 {
-  if (_hasTwistCmd)
-    return this-&gt;setCurrentState(DRIVE_STATE);
-  else
-    return false;
+  return getStatePtr(node["StateName"].as&lt;std::string&gt;());
 }
 
-void StateContext::stateDecider(void)
+std::shared_ptr&lt;State&gt; StateContext::getStatePtr(const std::string&amp; _state_name)
 {
-  // not running
+  int32_t state_id = getStateIDbyName(_state_name);
+
+  if (_state_name == "~" || state_id == -1)
+    return nullptr;
+  else
+    return getStatePtr(static_cast&lt;uint64_t&gt;(state_id));
 }
 
-void StateContext::InitContext(void)
+std::shared_ptr&lt;State&gt; StateContext::getStatePtr(const uint64_t&amp; _state_id)
 {
-  thr_state_dec = new std::thread(&amp;StateContext::stateDecider, this);
-  thr_state_dec-&gt;detach();
-  this-&gt;setCurrentState(START_STATE);
-  return;
+  return state_map_.at(_state_id);
 }
-bool StateContext::TFInitialized(void)
+
+void StateContext::createStateMap(std::string _state_file_name, std::string _msg_name)
 {
-  return this-&gt;setCurrentState(INITIAL_STATE);
+  const YAML::Node StateYAML = YAML::LoadFile(_state_file_name)[_msg_name];
+
+  // create state
+  for (unsigned int i = 0; i &lt; StateYAML.size(); i++)
+  {
+    state_map_[i] = std::shared_ptr&lt;State&gt;(new State(StateYAML[i]["StateName"].as&lt;std::string&gt;(), i));
+  }
+
+  // set Parent
+  // set transition
+  for (unsigned int i = 0; i &lt; StateYAML.size(); i++)
+  {
+    getStatePtr(StateYAML[i])-&gt;setParent(getStatePtr(StateYAML[i]["Parent"].as&lt;std::string&gt;()));
+    setTransitionMap(StateYAML[i]["Transition"], getStatePtr(StateYAML[i]));
+  }
 }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker\cross_road_area.hpp" added_lines="6" deleted_lines="6">
				<diff>@@ -30,14 +30,14 @@ public:
     insideWaypoint_points.clear();
   }
 
-  static CrossRoadArea *findClosestCrossRoad(const autoware_msgs::Lane &amp;_finalwaypoints,
-                                             std::vector&lt;CrossRoadArea&gt; &amp;intersects);
-  static bool isInsideArea(const CrossRoadArea *_TargetArea, geometry_msgs::Point pt);
+  static CrossRoadArea* findClosestCrossRoad(const autoware_msgs::Lane&amp; _finalwaypoints,
+                                             std::vector&lt;CrossRoadArea&gt;&amp; intersects);
+  static bool isInsideArea(const CrossRoadArea* _TargetArea, geometry_msgs::Point pt);
 
-  static CrossRoadArea *getCrossRoadArea(std::vector&lt;CrossRoadArea&gt; &amp;areas, int aid)
+  static CrossRoadArea* getCrossRoadArea(std::vector&lt;CrossRoadArea&gt;&amp; areas, int aid)
   {
-    CrossRoadArea *ret = nullptr;
-    for (auto &amp;area : areas)
+    CrossRoadArea* ret = nullptr;
+    for (auto&amp; area : areas)
     {
       if (area.area_id == aid)
       {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker\decision_maker_param.hpp" added_lines="0" deleted_lines="4">
				<diff>@@ -30,10 +30,6 @@ namespace decision_maker
 
 #define TPNAME_BASED_LANE_WAYPOINTS_ARRAY "/based/lane_waypoints_array"
 #define TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY "/lane_waypoints_array"
-#define LAMP_EMPTY 0
-#define LAMP_LEFT 1
-#define LAMP_RIGHT 2
-#define LAMP_HAZARD 3
 #define LAMP_ON 1
 #define LAMP_OFF 0
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="" added_lines="0" deleted_lines="293">
				<diff>@@ -1,293 +0,0 @@
-#ifndef __DECISION_MAKER_NODE__
-#define __DECISION_MAKER_NODE__
-
-#include &lt;mutex&gt;
-#include &lt;unordered_map&gt;
-
-#include &lt;autoware_config_msgs/ConfigDecisionMaker.h&gt;
-#include &lt;autoware_msgs/CloudClusterArray.h&gt;
-#include &lt;autoware_msgs/LaneArray.h&gt;
-#include &lt;autoware_msgs/Waypoint.h&gt;
-#include &lt;autoware_msgs/Lane.h&gt;
-#include &lt;autoware_msgs/TrafficLight.h&gt;
-#include &lt;geometry_msgs/PoseStamped.h&gt;
-#include &lt;geometry_msgs/TwistStamped.h&gt;
-#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
-#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-#include &lt;std_msgs/Int32.h&gt;
-#include &lt;std_msgs/String.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-
-#include &lt;visualization_msgs/MarkerArray.h&gt;
-
-#include &lt;vector_map_msgs/AreaArray.h&gt;
-#include &lt;vector_map_msgs/CrossRoadArray.h&gt;
-#include &lt;vector_map_msgs/LineArray.h&gt;
-#include &lt;vector_map_msgs/PointArray.h&gt;
-
-#include &lt;vector_map/vector_map.h&gt;
-
-#include &lt;geometry_msgs/Point.h&gt;
-
-// lib
-#include &lt;amathutils_lib/amathutils.hpp&gt;
-#include &lt;cross_road_area.hpp&gt;
-#include &lt;decision_maker_param.hpp&gt;
-#include &lt;state_machine_lib/state.hpp&gt;
-#include &lt;state_machine_lib/state_context.hpp&gt;
-
-namespace decision_maker
-{
-using namespace vector_map;
-
-
-enum class EControl : int32_t
-{
-  KEEP = -1,
-  STOP = 1,
-  DECELERATE = 2,
-  ACCELERATE = 3,
-  OTHERS = 4,
-};
-
-enum class E_ChangeFlags : int32_t
-{
-  STRAIGHT,
-  RIGHT,
-  LEFT,
-
-  UNKNOWN = -1,
-};
-
-inline bool hasvMap(void)
-{
-  return true;
-}
-
-template &lt;class T&gt;
-typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
-{
-  return static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(t);
-}
-
-
-class DecisionMakerNode
-{
-private:
-  ros::NodeHandle nh_;
-  // Publishers
-  std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
-  // Subscribers
-  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;
-
-  // ROS Messages
-  std_msgs::String state_string_msg;
-  geometry_msgs::PoseStamped current_pose_;
-
-  jsk_rviz_plugins::OverlayText state_text_msg;
-
-  // ROS Messages(Autoware)
-  autoware_msgs::Lane current_finalwaypoints_;
-  vector_map_msgs::AreaArray vMap_Areas;
-  vector_map_msgs::PointArray vMap_Points;
-  vector_map_msgs::LineArray vMap_Lines;
-  vector_map_msgs::CrossRoadArray vMap_CrossRoads;
-
-  std::vector&lt;geometry_msgs::Point&gt; inside_points_;
-
-  autoware_msgs::LaneArray current_based_lane_array_;       // with wpstate
-  autoware_msgs::LaneArray current_shifted_lane_array_;     // with shiftedLane
-  autoware_msgs::LaneArray current_controlled_lane_array_;  // modified lane
-  autoware_msgs::LaneArray current_stopped_lane_array_;     // 0velocity
-
-  tf::TransformListener tflistener_baselink;
-
-  int closest_stopline_waypoint_;
-
-  // Current way/behavior status
-  double current_velocity_;
-  double average_velocity_;
-  int current_traffic_light_;
-  int closest_waypoint_;
-  CrossRoadArea *ClosestArea_;
-  std::string CurrentStateName;
-  std::string TextOffset;
-  std::vector&lt;CrossRoadArea&gt; intersects;
-  double displacement_from_path_;
-  autoware_msgs::Waypoint CurrentStoplineTarget_;
-
-  bool foundOtherVehicleForIntersectionStop_; // In fact this should be defined as state.
-  class DetectionArea
-  {
-    public:
-      double x1,x2;
-      double y1,y2;
-
-      DetectionArea(){
-      }
-  };
-  DetectionArea detectionArea_;
-
-  bool isManualLight;
-
-  // Param
-  bool enableDisplayMarker;
-  bool enableForceStateChange;
-  uint32_t param_convergence_count_;
-  uint32_t param_target_waypoint_;
-  double param_convergence_threshold_;
-  uint32_t param_stopline_target_waypoint_;
-  double param_stopline_target_ratio_;
-  double param_shift_width_;
-  double param_crawl_velocity_;
-  double param_detection_area_rate_;
-  std::string param_baselink_tf_;
-
-  // for vectormap server
-  // ros::ServiceClient cross_road_cli;
-  // vector_map_server::GetCrossRoad cross_road_srv;
-
-  // initialization flags for initialized by callback
-  bool vector_map_init;
-  bool vMap_Areas_flag;
-  bool vMap_Points_flag;
-  bool vMap_Lines_flag;
-  bool vMap_CrossRoads_flag;
-  bool SimulationMode;
-  std::mutex vMap_mutex;
-  bool created_shift_lane_flag_;
-
-  // initialization method
-  void initROS(int argc, char **argv);
-  void initVectorMap(void);
-  void initStateMsgs(void);
-  bool initVectorMapClient(void);
-
-  // looping method
-  void update(void);
-  void update_msgs(void);
-  void update_pubsub(void);
-  void displayMarker(void);
-
-  void publishToVelocityArray();
-  std::string createStateMessageText();
-  int createCrossRoadAreaMarker(visualization_msgs::Marker &amp;crossroad_marker, double scale);
-
-  // judge method
-  // in near future, these methods will be deprecate to decision_maker library
-  bool isCrossRoadByVectorMapServer(const autoware_msgs::Lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
-  bool isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw);
-  bool handleStateCmd(const uint64_t _state_num);
-  // double calcIntersectWayAngle(const CrossRoadArea&amp; area);
-  double calcIntersectWayAngle(const autoware_msgs::Lane &amp;laneinArea);
-
-  void insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects, autoware_msgs::LaneArray &amp;lane_array);
-
-  void setWaypointState(autoware_msgs::LaneArray &amp;lane_array);
-  double calcPosesAngleDiff(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;p_to);
-  double calcPosesAngleDiffN(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;p_to);
-  double getPoseAngle(const geometry_msgs::Pose &amp;p);
-
-  /* for planning according to state*/
-  void publishStoppedLaneArray(void);
-  void publishControlledLaneArray(void);
-  void updateLaneWaypointsArray(void);
-  void changeVelocityBasedLane(void);
-  void changeVelocityLane(int dir);
-  void createShiftLane(void);
-  void changeShiftLane(void);
-  void removeShiftLane(void);
-  void setAllStoplineStop(void);
-  void publishStoplineWaypointIdx(int wp_idx);
-
-
-  // callback by state context
-  void StoplinePlanIn(int status);
-  void StoplinePlanOut(int status);
-  void publishLightColor(int status);
-  void callbackInStateObstacleAvoid(int status);
-  void callbackOutStateObstacleAvoid(int status);
-  void updateStateObstacleAvoid(int status);
-  void updateStateSTR(int status);
-  void updateStateStop(int status);
-  void callbackOutStateStop(int status);
-  void callbackInStateStop(int status);
-  void callbackInStateAcc(int status);
-  void callbackInStateDec(int status);
-  void callbackInStateKeep(int status);
-  void callbackOutStateLaneChange(int status);
-  void setupStateCallback(void);
-  
-  // callback by topic subscribing
-  void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
-  void callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg);
-  void callbackFromClosestWaypoint(const std_msgs::Int32 &amp;msg);
-  void callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::TrafficLight const&gt; &amp;event);
-  void callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg);
-  void callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg);
-  void callbackFromFinalWaypoint(const autoware_msgs::Lane &amp;msg);
-  void callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg);
-  void callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg);
-  void callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg);
-  void callbackFromStateCmd(const std_msgs::Int32 &amp;msg);
-  void callbackFromConfig(const autoware_config_msgs::ConfigDecisionMaker &amp;msg);
-  void callbackFromObjectDetector(const autoware_msgs::CloudClusterArray &amp;msg);
-
-  void callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg);
-  void callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg);
-  void callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg);
-  void callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg);
-
-public:
-  state_machine::StateContext *ctx;
-  VectorMap g_vmap;
-
-  DecisionMakerNode(int argc, char **argv)
-  {
-    SimulationMode = false;
-    enableDisplayMarker = DEFAULT_DISPLAY_FLAG;
-    param_convergence_threshold_ = DEFAULT_CONVERGENCE_THRESHOLD;
-    param_convergence_count_ = DEFAULT_CONVERGENCE_COUNT;
-    param_target_waypoint_ = DEFAULT_TARGET_WAYPOINT;
-    param_shift_width_ = DEFAULT_SHIFT_WIDTH;
-    param_stopline_target_waypoint_ = DEFAULT_STOPLINE_TARGET_WAYPOINT;
-    param_stopline_target_ratio_ = 0.0;
-    param_crawl_velocity_ = DEFAULT_CRAWL_VELOCITY;
-    param_detection_area_rate_ = DEFAULT_DETECTION_AREA_RATE;
-    param_baselink_tf_ = "base_link";
-    detectionArea_.x1 = DEFAULT_DETECTION_AREA_X1;
-    detectionArea_.x2 = DEFAULT_DETECTION_AREA_X2;
-    detectionArea_.y1 = DEFAULT_DETECTION_AREA_Y1;
-    detectionArea_.y2 = DEFAULT_DETECTION_AREA_Y2;
-
-    ctx = new state_machine::StateContext();
-    this-&gt;initROS(argc, argv);
-
-    vector_map_init = false;
-    created_shift_lane_flag_ = false;
-    closest_waypoint_ = 0;
-    
-    foundOtherVehicleForIntersectionStop_ = false; 
-
-    ClosestArea_ = nullptr;
-    displacement_from_path_ = 0.0;
-    isManualLight = false;
-    closest_stopline_waypoint_ = -1;
-  }
-
-  void run(void);
-  geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
-  {
-	  geometry_msgs::Point gp;
-	  gp.x = vp.ly;
-	  gp.y = vp.bx;
-	  gp.z = vp.h;
-	  return gp;
-  }
-
-};
-
-}  // namespace decision_maker
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\planner_selector.hpp" new_path="" added_lines="0" deleted_lines="69">
				<diff>@@ -1,69 +0,0 @@
-#ifndef __PLANNER_SELECTOR_HPP__
-#define __PLANNER_SELECTOR_HPP__
-
-#include &lt;autoware_config_msgs/ConfigPlannerSelector.h&gt;
-#include &lt;autoware_msgs/Lane.h&gt;
-#include &lt;ros/ros.h&gt;
-#include &lt;std_msgs/Int32.h&gt;
-
-#include &lt;mutex&gt;
-#include &lt;thread&gt;
-#include &lt;unordered_map&gt;
-
-#include &lt;amathutils_lib/amathutils.hpp&gt;
-
-namespace decision_maker
-{
-#define DEFAULT_LATENCY_NUM 5
-#define DEFAULT_WAYPOINTS_NUM 3
-#define DEFAULT_CONVERGENCE_NUM 2.0
-class PlannerSelector
-{
-private:
-  ros::NodeHandle nh_;
-
-  std::unordered_map&lt;std::string, autoware_msgs::Lane&gt; waypoints_;
-  std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
-  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;
-
-  autoware_msgs::Lane final_waypoints_dp_;
-  autoware_msgs::Lane final_waypoints_astar_;
-
-  std::unordered_map&lt;std::string, int&gt; closest_waypoints_;
-  int closest_waypoint_astar_;
-  int closest_waypoint_dp_;
-
-  unsigned int way_offset;
-
-  std::mutex _mutex;
-
-  int enableLattice_;
-  bool pastWaypoint;
-  unsigned int config_latency_num_;
-  unsigned int config_waypoints_num_;
-  double config_convergence_num_;
-  double current_velocity_;
-
-  bool existWaypoints(const int _config_waypoints_num);
-
-public:
-  PlannerSelector()
-  {
-    this-&gt;initROS();
-    enableLattice_ = 0;
-    pastWaypoint = false;
-    config_latency_num_ = DEFAULT_LATENCY_NUM;
-    config_waypoints_num_ = DEFAULT_WAYPOINTS_NUM;
-    config_convergence_num_ = DEFAULT_CONVERGENCE_NUM;
-  }
-
-  void initROS();
-
-  void callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event);
-  void callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::Lane const&gt; &amp;event);
-  void callbackFromLattice(const std_msgs::Int32 &amp;msg);
-  void callbackFromConfig(const autoware_config_msgs::ConfigPlannerSelector &amp;msg);
-  void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
-};
-}
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" added_lines="15" deleted_lines="20">
				<diff>@@ -5,37 +5,32 @@
 namespace decision_maker
 {
 #define TARGET_WAYPOINTS_NUM 15  // need to change rosparam
-CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::Lane &amp;_finalwaypoints,
-                                                   std::vector&lt;CrossRoadArea&gt; &amp;intersects)
+CrossRoadArea* CrossRoadArea::findClosestCrossRoad(const autoware_msgs::Lane&amp; _finalwaypoints,
+                                                   std::vector&lt;CrossRoadArea&gt;&amp; intersects)
 {
-  CrossRoadArea *_area = nullptr;
+  CrossRoadArea* _area = nullptr;
 
-  amathutils::point _pa;
-  amathutils::point _pb;
+  geometry_msgs::Point pa;
+  geometry_msgs::Point pb;
 
   double _min_distance = DBL_MAX;
 
   if (!_finalwaypoints.waypoints.empty())
   {
-    _pa.x = _finalwaypoints.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.x;
-    _pa.y = _finalwaypoints.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.y;
-    _pa.z = 0.0;
+    pa = _finalwaypoints.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position;
   }
 
   for (size_t i = 0; i &lt; intersects.size(); i++)
   {
-    _pb.x = intersects[i].bbox.pose.position.x;
-    _pb.y = intersects[i].bbox.pose.position.y;
+    pb = intersects[i].bbox.pose.position;
 
-    _pb.z = 0.0;
-
-    double __temp_dis = amathutils::find_distance(&amp;_pa, &amp;_pb);
+    const double range_of_waypoint_and_intersection = amathutils::find_distance(pa, pb);
 
     intersects[i].bbox.label = 0;
-    if (_min_distance &gt;= __temp_dis)
+    if (_min_distance &gt;= range_of_waypoint_and_intersection)
     {
       _area = &amp;intersects[i];
-      _min_distance = __temp_dis;  //
+      _min_distance = range_of_waypoint_and_intersection;  //
     }
   }
 
@@ -47,12 +42,12 @@ CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::Lane &amp;_f
   return _area;
 }
 
-std::vector&lt;geometry_msgs::Point&gt; convhull(const CrossRoadArea *_TargetArea)
+std::vector&lt;geometry_msgs::Point&gt; convhull(const CrossRoadArea* _TargetArea)
 {
   std::vector&lt;int&gt; enablePoints;
 
-  if(_TargetArea-&gt;points.size() &lt; 3)
-	  return {};
+  if (_TargetArea-&gt;points.size() &lt; 3)
+    return {};
 
   // Jarvis's March algorithm
   size_t l = 0;
@@ -87,7 +82,7 @@ std::vector&lt;geometry_msgs::Point&gt; convhull(const CrossRoadArea *_TargetArea)
   std::vector&lt;geometry_msgs::Point&gt; point_arrays;
   for (auto p = begin(_TargetArea-&gt;points); p != end(_TargetArea-&gt;points); p++)
   {
-    for (auto &amp;en : enablePoints)
+    for (auto&amp; en : enablePoints)
     {
       if (std::distance(begin(_TargetArea-&gt;points), p) == en)
       {
@@ -98,7 +93,7 @@ std::vector&lt;geometry_msgs::Point&gt; convhull(const CrossRoadArea *_TargetArea)
   return point_arrays;
 }
 
-bool CrossRoadArea::isInsideArea(const CrossRoadArea *_TargetArea, geometry_msgs::Point pt)
+bool CrossRoadArea::isInsideArea(const CrossRoadArea* _TargetArea, geometry_msgs::Point pt)
 {
   std::vector&lt;geometry_msgs::Point&gt; point_arrays = convhull(_TargetArea);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -1,7 +1,6 @@
 #include &lt;decision_maker_node.hpp&gt;
-#include &lt;ros/ros.h&gt;
 
-int main(int argc, char **argv)
+int main(int argc, char** argv)
 {
   ros::init(argc, argv, "decision_maker");
   decision_maker::DecisionMakerNode smn(argc, argv);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="154" deleted_lines="278">
				<diff>@@ -1,5 +1,5 @@
-#include &lt;cmath&gt;
 #include &lt;stdio.h&gt;
+#include &lt;cmath&gt;
 
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
@@ -19,182 +19,61 @@
 
 namespace decision_maker
 {
-void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
-{
-  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
-  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
-  if (initLocalizationFlag &amp;&amp;
-      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
-                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
-  {
-    ROS_INFO("Localization was convergence");
-  }
-}
-
-bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
+void DecisionMakerNode::callbackFromFilteredPoints(const sensor_msgs::PointCloud2::ConstPtr&amp; msg)
 {
-  bool _ret;
-  ctx-&gt;setEnableForceSetState(true);
-  if (!ctx-&gt;isCurrentState(_state_num))
-  {
-    _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
-    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
-		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
-	    isManualLight = true;
-    }
-  }
-  else
-  {
-    _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
-    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
-		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
-	    isManualLight = false;
-    }
-  }
-  ctx-&gt;setEnableForceSetState(false);
-
-
-  return _ret;
+  setEventFlag("received_pointcloud_for_NDT", true);
 }
 
-void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg)
+void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped&amp; msg)
 {
   ROS_INFO("Received system is going to simulation mode");
-  handleStateCmd(state_machine::DRIVE_STATE);
   Subs["sim_pose"].shutdown();
 }
 
-void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
+void DecisionMakerNode::callbackFromStateCmd(const std_msgs::String&amp; msg)
 {
-  ROS_INFO("Received forcing state changing request: %llx", 1ULL &lt;&lt; (uint64_t)msg.data);
-  handleStateCmd((uint64_t)1ULL &lt;&lt; (uint64_t)msg.data);
+  //  ROS_INFO("Received State Command");
+  tryNextState(msg.data);
 }
 
-void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
+void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32&amp; msg)
 {
-  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT) &amp;&amp; ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE))
-  {
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-  }
-  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT) &amp;&amp; ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE))
-  {
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-  }
-  else
-  {
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-  }
+  current_status_.change_flag = msg.data;
 }
 
-void DecisionMakerNode::callbackFromConfig(const autoware_config_msgs::ConfigDecisionMaker &amp;msg)
+void DecisionMakerNode::callbackFromConfig(const autoware_config_msgs::ConfigDecisionMaker&amp; msg)
 {
   ROS_INFO("Param setted by Runtime Manager");
-  enableDisplayMarker = msg.enable_display_marker;
-  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
-
-  param_target_waypoint_ = msg.target_waypoint;
-  param_stopline_target_waypoint_ = msg.stopline_target_waypoint;
-  param_stopline_target_ratio_ = msg.stopline_target_ratio;
-  param_shift_width_ = msg.shift_width;
-
-  param_crawl_velocity_ = msg.crawl_velocity;
-  param_detection_area_rate_ = msg.detection_area_rate;
-  param_baselink_tf_ = msg.baselink_tf;
-
-  detectionArea_.x1 = msg.detection_area_x1;
-  detectionArea_.x2 = msg.detection_area_x2;
-  detectionArea_.y1 = msg.detection_area_y1;
-  detectionArea_.y2 = msg.detection_area_y2;
-}
-
-void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::TrafficLight const&gt; &amp;event)
-{    
-  const autoware_msgs::TrafficLight *light = event.getMessage().get();
-//  const ros::M_string &amp;header = event.getConnectionHeader();
-//  std::string topic = header.at("topic"); 
-  
-  if(!isManualLight){// &amp;&amp; topic.find("manage") == std::string::npos){
-	  current_traffic_light_ = light-&gt;traffic_light;
-	  if (current_traffic_light_ == state_machine::E_RED || current_traffic_light_ == state_machine::E_YELLOW)
-	  {
-		  ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
-		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
-	  }
-	  else
-	  {
-		  ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
-		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
-	  }
-  }
+  auto_mission_reload_ = msg.auto_mission_reload;
+  auto_engage_ = msg.auto_engage;
+  auto_mission_change_ = msg.auto_mission_change;
+  use_fms_ = msg.use_fms;
+  param_num_of_steer_behind_ = msg.num_of_steer_behind;
+  change_threshold_dist_ = msg.change_threshold_dist;
+  change_threshold_angle_ = msg.change_threshold_angle;
+  goal_threshold_dist_ = msg.goal_threshold_dist;
+  goal_threshold_vel_ = msg.goal_threshold_vel;
+  disuse_vector_map_ = msg.disuse_vector_map;
 }
 
-void DecisionMakerNode::callbackFromObjectDetector(const autoware_msgs::CloudClusterArray &amp;msg)
+void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::TrafficLight const&gt;&amp; event)
 {
-  // This function is a quick hack implementation.
-  // If detection result exists in DetectionArea, decisionmaker sets object
-  // detection
-  // flag(foundOthervehicleforintersectionstop).
-  // The flag is referenced in the stopline state, and if it is true it will
-  // continue to stop.
-
-  static double setFlagTime = 0.0;
-  bool l_detection_flag = false;
-  if (ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
-  {
-    if (msg.clusters.size())
-    {
-      // if euclidean_cluster does not use wayarea, it may always founded.
-      for (const auto cluster : msg.clusters)
-      {
-        geometry_msgs::PoseStamped cluster_pose;
-        geometry_msgs::PoseStamped baselink_pose;
-        cluster_pose.pose = cluster.bounding_box.pose;
-        cluster_pose.header = cluster.header;
-
-        tflistener_baselink.transformPose(cluster.header.frame_id, cluster.header.stamp, cluster_pose, "base_link",
-                                          baselink_pose);
-
-        if (detectionArea_.x1 * param_detection_area_rate_ &gt;= baselink_pose.pose.position.x &amp;&amp;
-            baselink_pose.pose.position.x &gt;= detectionArea_.x2 * param_detection_area_rate_ &amp;&amp;
-            detectionArea_.y1 * param_detection_area_rate_ &gt;= baselink_pose.pose.position.y &amp;&amp;
-            baselink_pose.pose.position.y &gt;= detectionArea_.y2 * param_detection_area_rate_)
-        {
-          l_detection_flag = true;
-          setFlagTime = ros::Time::now().toSec();
-	  break;
-        }
-      }
-    }
-  }
-  /* The true state continues for more than 1 second. */
-  if(l_detection_flag || (ros::Time::now().toSec() - setFlagTime) &gt;= 1.0/*1.0sec*/){
-	  foundOtherVehicleForIntersectionStop_ = l_detection_flag;
-  }
-}
-
-void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
-{
-  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
-    Subs["points_raw"].shutdown();
+  ROS_WARN("%s is not implemented", __func__);
 }
 
-void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects,
-                                                   autoware_msgs::LaneArray &amp;lane_array)
+void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt;&amp; _intersects,
+                                                   autoware_msgs::LaneArray&amp; lane_array)
 {
-
-  for (auto &amp;lane : lane_array.lanes)
+  for (auto&amp; lane : lane_array.lanes)
   {
-    for (auto &amp;wp : lane.waypoints)
+    for (auto&amp; wp : lane.waypoints)
     {
       geometry_msgs::Point pp;
       pp.x = wp.pose.pose.position.x;
       pp.y = wp.pose.pose.position.y;
       pp.z = wp.pose.pose.position.z;
 
-      for (auto &amp;area : intersects)
+      for (auto&amp; area : intersects)
       {
         if (CrossRoadArea::isInsideArea(&amp;area, pp))
         {
@@ -203,7 +82,7 @@ void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadAr
           {
             autoware_msgs::Lane nlane;
             area.insideLanes.push_back(nlane);
-	    area.bbox.pose.orientation = wp.pose.pose.orientation;
+            area.bbox.pose.orientation = wp.pose.pose.orientation;
           }
           area.insideLanes.back().waypoints.push_back(wp);
           area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
@@ -216,18 +95,13 @@ void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadAr
   }
 }
 
-inline double getDistance(double ax, double ay, double bx, double by)
-{
-  return std::hypot(ax - bx, ay - by);
-}
-
 void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray&amp; lane_array)
 {
   insertPointWithinCrossRoad(intersects, lane_array);
   // STR
-  for (auto &amp;area : intersects)
+  for (auto&amp; area : intersects)
   {
-    for (auto &amp;laneinArea : area.insideLanes)
+    for (auto&amp; laneinArea : area.insideLanes)
     {
       // To straight/left/right recognition by using angle
       // between first-waypoint and end-waypoint in intersection area.
@@ -241,200 +115,202 @@ void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray&amp; lane_array)
       else
         steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;
 
-      for (auto &amp;wp_lane : laneinArea.waypoints)
-        for (auto &amp;lane : lane_array.lanes)
-          for (auto &amp;wp : lane.waypoints)
+      for (auto&amp; wp_lane : laneinArea.waypoints)
+      {
+        for (auto&amp; lane : lane_array.lanes)
+        {
+          for (auto&amp; wp : lane.waypoints)
+          {
             if (wp.gid == wp_lane.gid &amp;&amp; wp.wpstate.aid == area.area_id)
             {
               wp.wpstate.steering_state = steering_state;
             }
+          }
+        }
+      }
     }
   }
+  for (auto&amp; lane : lane_array.lanes)
+  {
+    for (auto&amp; wp : lane.waypoints)
+    {
+      if (wp.wpstate.steering_state == 0)
+      {
+        wp.wpstate.steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;
+      }
+    }
+  }
+
   // STOP
   std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine&amp; stopline) {
     return ((g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type &amp;
              (autoware_msgs::WaypointState::TYPE_STOP | autoware_msgs::WaypointState::TYPE_STOPLINE)) != 0);
   });
 
-  for (auto &amp;lane : lane_array.lanes)
+  for (auto&amp; lane : lane_array.lanes)
   {
     for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
     {
-      for (auto &amp;stopline : stoplines)
+      for (auto&amp; stopline : stoplines)
       {
         geometry_msgs::Point bp =
-            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
+            VMPoint2GeoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
         geometry_msgs::Point fp =
-            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));
+            VMPoint2GeoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));
 
-#define INTERSECT_CHECK_THRESHOLD 5.0
-        if (getDistance(bp.x, bp.y, lane.waypoints.at(wp_idx).pose.pose.position.x,
-                        lane.waypoints.at(wp_idx).pose.pose.position.y) &lt;= INTERSECT_CHECK_THRESHOLD)
+        if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position,
+                                        lane.waypoints.at(wp_idx + 1).pose.pose.position, bp, fp))
         {
-          if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
-                                          lane.waypoints.at(wp_idx).pose.pose.position.y,
-                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
-                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
+          geometry_msgs::Point center_point;
+          center_point.x = (bp.x * 2 + fp.x) / 3;
+          center_point.y = (bp.y * 2 + fp.y) / 3;
+          center_point.z = (bp.z + fp.z) / 2;
+          if (amathutils::isPointLeftFromLine(center_point, lane.waypoints.at(wp_idx).pose.pose.position,
+                                              lane.waypoints.at(wp_idx + 1).pose.pose.position) &gt;= 0)
           {
-            geometry_msgs::Point center_point;
-            center_point.x = (bp.x * 2 + fp.x) / 3;
-            center_point.y = (bp.y * 2 + fp.y) / 3;
-            if (amathutils::isPointLeftFromLine(
-                    center_point.x, center_point.y, lane.waypoints.at(wp_idx).pose.pose.position.x,
-                    lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
-                    lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
-            {
-              lane.waypoints.at(wp_idx).wpstate.stop_state = g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type;
-              // lane.waypoints.at(wp_idx + 1).wpstate.stop_state = 1;
-            }
+            center_point.x = (bp.x + fp.x) / 2;
+            center_point.y = (bp.y + fp.y) / 2;
+            geometry_msgs::Point interpolation_point =
+                amathutils::getNearPtOnLine(center_point, lane.waypoints.at(wp_idx).pose.pose.position,
+                                            lane.waypoints.at(wp_idx + 1).pose.pose.position);
+
+            autoware_msgs::Waypoint wp = lane.waypoints.at(wp_idx);
+            wp.wpstate.stop_state = g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type;
+            wp.pose.pose.position.x = interpolation_point.x;
+            wp.pose.pose.position.y = interpolation_point.y;
+            wp.pose.pose.position.z =
+                (wp.pose.pose.position.z + lane.waypoints.at(wp_idx + 1).pose.pose.position.z) / 2;
+            wp.twist.twist.linear.x =
+                (wp.twist.twist.linear.x + lane.waypoints.at(wp_idx + 1).twist.twist.linear.x) / 2;
+
+            ROS_INFO("Inserting stopline_interpolation_wp: #%zu(%f, %f, %f)\n", wp_idx + 1, interpolation_point.x,
+                     interpolation_point.y, interpolation_point.z);
+
+            lane.waypoints.insert(lane.waypoints.begin() + wp_idx + 1, wp);
+            wp_idx++;
+
+            //  lane.waypoints.at(wp_idx).wpstate.stop_state = g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type;
           }
         }
       }
     }
+
+// MISSION COMPLETE FLAG
+#define NUM_OF_SET_MISSION_COMPLETE_FLAG 3
+    size_t wp_idx = lane.waypoints.size();
+    unsigned counter = 0;
+    for (counter = 0;
+         counter &lt;= (wp_idx &lt;= NUM_OF_SET_MISSION_COMPLETE_FLAG ? wp_idx : NUM_OF_SET_MISSION_COMPLETE_FLAG); counter++)
+    {
+      lane.waypoints.at(--wp_idx).wpstate.event_state = autoware_msgs::WaypointState::TYPE_EVENT_GOAL;
+    }
   }
 }
 
-// for based waypoint
-void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
+bool DecisionMakerNode::drivingMissionCheck()
 {
-  ROS_INFO("[%s]:LoadedWaypointLaneArray\n", __func__);
-  current_based_lane_array_ = msg;  // cached based path
-  // indexing
+  publishOperatorHelpMessage("Received new mission, checking now...");
+  setEventFlag("received_back_state_waypoint", false);
+
   int gid = 0;
-  for (auto &amp;lane : current_based_lane_array_.lanes)
+  for (auto&amp; lane : current_status_.based_lane_array.lanes)
   {
     int lid = 0;
-    for (auto &amp;wp : lane.waypoints)
+    for (auto&amp; wp : lane.waypoints)
     {
-      wp.gid = gid++;
-      wp.lid = lid++;
       wp.wpstate.aid = 0;
       wp.wpstate.steering_state = autoware_msgs::WaypointState::NULLSTATE;
       wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
       wp.wpstate.stop_state = autoware_msgs::WaypointState::NULLSTATE;
       wp.wpstate.lanechange_state = autoware_msgs::WaypointState::NULLSTATE;
       wp.wpstate.event_state = 0;
+      wp.gid = gid++;
+      wp.lid = lid++;
+      if (!isEventFlagTrue("received_back_state_waypoint") &amp;&amp; wp.twist.twist.linear.x &lt; 0.0)
+      {
+        setEventFlag("received_back_state_waypoint", true);
+        publishOperatorHelpMessage("Received back waypoint.");
+      }
     }
   }
-  setWaypointState(current_based_lane_array_);
-  current_controlled_lane_array_ = current_shifted_lane_array_ = current_based_lane_array_;  // controlled path
-
-  publishControlledLaneArray();
-  updateLaneWaypointsArray();
-}
-
-state_machine::StateFlags getStateFlags(uint8_t msg_state)
-{
-  if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
-    return state_machine::DRIVE_STR_LEFT_STATE;
-  else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
-    return state_machine::DRIVE_STR_RIGHT_STATE;
-  else
-    return state_machine::DRIVE_STR_STRAIGHT_STATE;
-}
-
-void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::Lane &amp;msg)
-{
-  if (!hasvMap())
-  {
-    std::cerr &lt;&lt; "Not found vmap subscribe" &lt;&lt; std::endl;
-    return;
-  }
-
-  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
-  {
-    std::cerr &lt;&lt; "State is not DRIVE_STATE[" &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; "]" &lt;&lt; std::endl;
-    return;
-  }
-  // cached
-  current_finalwaypoints_ = msg;
-
-  // stopline
-  static size_t previous_idx = 0;
 
-  size_t idx = param_stopline_target_waypoint_ + (current_velocity_ * param_stopline_target_ratio_);
-  idx = current_finalwaypoints_.waypoints.size() - 1 &gt; idx ? idx : current_finalwaypoints_.waypoints.size() - 1;
+  // waypoint-state set and insert interpolation waypoint for stopline
+  setWaypointState(current_status_.based_lane_array);
 
-  CurrentStoplineTarget_ = current_finalwaypoints_.waypoints.at(idx);
-
-  for (size_t i = (previous_idx &gt; idx) ? idx : previous_idx; i &lt;= idx; i++)
+  // reindexing and calculate new closest_waypoint distance
+  gid = 0;
+  double min_dist = 100;
+  geometry_msgs::Pose nearest_wp_pose;
+  for (auto&amp; lane : current_status_.based_lane_array.lanes)
   {
-    if (i &lt; current_finalwaypoints_.waypoints.size())
+    int lid = 0;
+    std::vector&lt;double&gt; dist_vec;
+    dist_vec.reserve(lane.waypoints.size());
+    for (auto&amp; wp : lane.waypoints)
     {
-      if (current_finalwaypoints_.waypoints.at(i).wpstate.stop_state == autoware_msgs::WaypointState::TYPE_STOPLINE)
+      wp.gid = gid++;
+      wp.lid = lid++;
+      double dst = amathutils::find_distance(current_status_.pose.position, wp.pose.pose.position);
+      if (min_dist &gt; dst)
       {
-        ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
-        closest_stopline_waypoint_ = CurrentStoplineTarget_.gid;
+        min_dist = dst;
+        nearest_wp_pose = wp.pose.pose;
       }
-      if (current_finalwaypoints_.waypoints.at(i).wpstate.stop_state == autoware_msgs::WaypointState::TYPE_STOP)
-        ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOP_STATE);
     }
   }
-  previous_idx = idx;
-
-  // steering
-  idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_target_waypoint_ ?
-            param_target_waypoint_ :
-            current_finalwaypoints_.waypoints.size() - 1;
 
-  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE))
+  double angle_diff_degree =
+      fabs(amathutils::calcPosesAngleDiffDeg(current_status_.pose, nearest_wp_pose));
+  if (min_dist &gt; change_threshold_dist_ || angle_diff_degree &gt; change_threshold_angle_)
   {
-    ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
-  }
-  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE))
-  {
-    ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
+    return false;
   }
   else
   {
-    state_machine::StateFlags _TargetStateFlag;
-    for (size_t i = idx; i &gt; 0; i--)
+    current_status_.using_lane_array = current_status_.based_lane_array;
+    Pubs["lane_waypoints_array"].publish(current_status_.using_lane_array);
+    if (!isSubscriberRegistered("final_waypoints"))
     {
-      _TargetStateFlag = getStateFlags(current_finalwaypoints_.waypoints.at(i).wpstate.steering_state);
-      if (_TargetStateFlag != state_machine::DRIVE_STR_STRAIGHT_STATE)
-      {
-        break;
-      }
+      Subs["final_waypoints"] =
+          nh_.subscribe("final_waypoints", 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
     }
-    ctx-&gt;setCurrentState(_TargetStateFlag);
+
+    return true;
   }
-  // for publish plan of velocity
-  publishToVelocityArray();
 }
-void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
+
+// for based waypoint
+void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray&amp; msg)
 {
-  static bool Twistflag = false;
+  ROS_INFO("[%s]:LoadedWaypointLaneArray\n", __func__);
 
-  if (Twistflag)
-    ctx-&gt;handleTwistCmd(false);
-  else
-    Twistflag = true;
+  current_status_.based_lane_array = msg;
+  setEventFlag("received_based_lane_waypoint", true);
 }
 
-void DecisionMakerNode::callbackFromClosestWaypoint(const std_msgs::Int32 &amp;msg)
+void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::Lane&amp; msg)
 {
-  closest_waypoint_ = msg.data;
+  current_status_.finalwaypoints = msg;
+  setEventFlag("received_finalwaypoints", true);
 }
 
-void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
-{
-  initVectorMap();
-}
-void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
+void DecisionMakerNode::callbackFromClosestWaypoint(const std_msgs::Int32&amp; msg)
 {
-  initVectorMap();
+  current_status_.closest_waypoint = msg.data;
 }
-void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
+
+void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped&amp; msg)
 {
-  initVectorMap();
+  current_status_.pose = msg.pose;
 }
-void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
+
+void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped&amp; msg)
 {
-  initVectorMap();
+  current_status_.velocity = amathutils::mps2kmph(msg.twist.linear.x);
 }
 
-void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
+void DecisionMakerNode::callbackFromObstacleWaypoint(const std_msgs::Int32&amp; msg)
 {
-  current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
+  current_status_.obstacle_waypoint = msg.data;
 }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" added_lines="15" deleted_lines="18">
				<diff>@@ -14,8 +14,8 @@
 
 #include &lt;autoware_msgs/Lane.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-#include &lt;random&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
+#include &lt;random&gt;
 
 #include &lt;geometry_msgs/Point.h&gt;
 #include &lt;geometry_msgs/Pose.h&gt;
@@ -23,34 +23,31 @@
 
 namespace decision_maker
 {
+void DecisionMakerNode::tryNextState(const std::string&amp; key)
+{
+  ctx_vehicle-&gt;nextState(key);
+  ctx_mission-&gt;nextState(key);
+  ctx_drive-&gt;nextState(key);
+}
+
 void DecisionMakerNode::update(void)
 {
   update_msgs();
-  if (ctx)
-    ctx-&gt;update();
+  if (ctx_vehicle)
+    ctx_vehicle-&gt;onUpdate();
+  if (ctx_mission)
+    ctx_mission-&gt;onUpdate();
+  if (ctx_drive)
+    ctx_drive-&gt;onUpdate();
 }
 
 void DecisionMakerNode::run(void)
 {
-  ros::Rate loop_rate(1);
+  ros::Rate loop_rate(5);
 
-  // for subscribe callback function
-  ros::AsyncSpinner spinner(3);
-  spinner.start();
   while (ros::ok())
   {
-    ros::Time begin = ros::Time::now();
     update();
-    if (enableDisplayMarker)
-      displayMarker();
-
-#ifdef DEBUG_PRINT
-    // debug status
-    ros::Duration exec_time = ros::Time::now() - begin;
-    std_msgs::Float64 exec_time_sec;
-    exec_time_sec.data = exec_time.toSec();
-    Pubs["exectime"].publish(exec_time_sec);
-#endif
 
     loop_rate.sleep();
   }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="63" deleted_lines="40">
				<diff>@@ -1,6 +1,6 @@
-#include &lt;numeric&gt;
 #include &lt;stdio.h&gt;
 #include &lt;numeric&gt;
+#include &lt;numeric&gt;
 
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;jsk_rviz_plugins/OverlayText.h&gt;
@@ -18,33 +18,45 @@
 
 namespace decision_maker
 {
-double DecisionMakerNode::getPoseAngle(const geometry_msgs::Pose &amp;pose)
+/* do not use this within callback */
+bool DecisionMakerNode::waitForEvent(cstring_t&amp; key, const bool&amp; flag)
 {
-  double r, p, y;
+  const uint32_t monitoring_rate = 20;  // Hz
 
-  tf::Quaternion quat(pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w);
-  tf::Matrix3x3(quat).getRPY(r, p, y);
-
-  // convert to [-pi : pi]
-  return y;
+  ros::Rate loop_rate(monitoring_rate);
+  while (ros::ok())
+  {
+    if (isEventFlagTrue(key) == flag)
+    {
+      break;
+    }
+    loop_rate.sleep();
+  }
+  return true;
 }
 
-double DecisionMakerNode::calcPosesAngleDiffN(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;p_to)
+bool DecisionMakerNode::waitForEvent(cstring_t&amp; key, const bool&amp; flag, const double&amp; timeout_sec)
 {
-  // convert to [-pi : pi]
-  return getPoseAngle(p_from) - getPoseAngle(p_to);
-}
+  const uint32_t monitoring_rate = 20;  // Hz
+  ros::Rate loop_rate(monitoring_rate);
 
-double DecisionMakerNode::calcPosesAngleDiff(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;p_to)
-{
-  // convert to [-pi : pi]
-  double diff = std::fmod(calcPosesAngleDiffN(p_from, p_to), 2 * M_PI);
-  diff = diff &gt; M_PI ? diff - 2 * M_PI : diff &lt; -M_PI ? 2 * M_PI + diff : diff;
-  diff = diff * 180 / M_PI;
-  return diff;
-}
+  ros::Time entry_time = ros::Time::now();
 
-double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::Lane &amp;laneinArea)
+  while (ros::ok())
+  {
+    if (isEventFlagTrue(key) == flag)
+    {
+      return true;
+    }
+    if ((ros::Time::now() - entry_time).toSec() &gt;= timeout_sec)
+    {
+      break;
+    }
+    loop_rate.sleep();
+  }
+  return false;
+}
+double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::Lane&amp; laneinArea)
 {
   double diff = 0.0;
   if (laneinArea.waypoints.empty())
@@ -56,43 +68,54 @@ double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::Lane &amp;lanei
     const geometry_msgs::Pose InPose = laneinArea.waypoints.front().pose.pose;
     const geometry_msgs::Pose OutPose = laneinArea.waypoints.back().pose.pose;
 
-    diff = calcPosesAngleDiff(InPose, OutPose);
+    diff = amathutils::calcPosesAngleDiffDeg(InPose, OutPose);
   }
 
   return diff;
 }
 
-bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch,
-                                                  double _yaw)
+bool DecisionMakerNode::isLocalizationConvergence(const geometry_msgs::Point&amp; _current_point)
 {
-  static amathutils::point a;
-  static amathutils::point b;
-
   static std::vector&lt;double&gt; distances;
   static uint32_t distances_count = 0;
+  static geometry_msgs::Point prev_point;
+  static const int param_convergence_count = 10;
 
   bool ret = false;
 
-  a.x = b.x;
-  a.y = b.y;
-  a.z = b.z;
-
-  b.x = _x;
-  b.y = _y;
-  b.z = _z;
+  // if current point is not set, localization is failure
+  if (_current_point.x == 0 &amp;&amp; _current_point.y == 0 &amp;&amp; _current_point.z == 0 &amp;&amp; prev_point.x == 0 &amp;&amp;
+      prev_point.y == 0 &amp;&amp; prev_point.z == 0)
+  {
+    return ret;
+  }
 
-  distances.push_back(amathutils::find_distance(&amp;a, &amp;b));
-  if (++distances_count &gt; param_convergence_count_)
+  distances.push_back(amathutils::find_distance(prev_point, _current_point));
+  if (++distances_count &gt; param_convergence_count) /* num of count to judge convergence*/
   {
     distances.erase(distances.begin());
     distances_count--;
-    double avg_distances = std::accumulate(distances.begin(), distances.end(), 0) / distances.size();
-    if (avg_distances &lt;= param_convergence_threshold_)
+    double avg_distances = std::accumulate(distances.begin(), distances.end(), 0.0) / (double)distances.size();
+    if (avg_distances &lt;= 2) /*meter*/
     {
-      ret =  ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
+      ret = true;
     }
   }
-  
+
+  prev_point = _current_point;
   return ret;
 }
+bool DecisionMakerNode::isArrivedGoal()
+{
+  const auto goal_point = current_status_.finalwaypoints.waypoints.back().pose.pose.position;
+
+  if (amathutils::find_distance(goal_point, current_status_.pose.position) &lt; goal_threshold_dist_)
+  {
+    if (current_status_.velocity &lt;= goal_threshold_vel_)
+    {
+      return true;
+    }
+  }
+  return false;
+}
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="267" deleted_lines="107">
				<diff>@@ -1,141 +1,301 @@
-#include &lt;mutex&gt;
-#include &lt;ros/ros.h&gt;
-#include &lt;ros/spinner.h&gt;
-#include &lt;std_msgs/Float64.h&gt;
-#include &lt;std_msgs/Float64MultiArray.h&gt;
-#include &lt;std_msgs/Int32.h&gt;
-#include &lt;std_msgs/String.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-
-// lib
-#include &lt;state_machine_lib/state.hpp&gt;
-#include &lt;state_machine_lib/state_context.hpp&gt;
-
 #include &lt;decision_maker_node.hpp&gt;
-//#include &lt;vector_map/vector_map.h&gt;
-
-#include &lt;autoware_msgs/LampCmd.h&gt;
-#include &lt;autoware_msgs/Lane.h&gt;
-#include &lt;autoware_msgs/State.h&gt;
-#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-#include &lt;random&gt;
-#include &lt;visualization_msgs/MarkerArray.h&gt;
-
-#include &lt;geometry_msgs/Point.h&gt;
-#include &lt;geometry_msgs/Pose.h&gt;
-#include &lt;geometry_msgs/PoseStamped.h&gt;
 
 namespace decision_maker
 {
-void DecisionMakerNode::initROS(int argc, char **argv)
+void DecisionMakerNode::init(void)
+{
+  initROS();
+}
+
+void DecisionMakerNode::setupStateCallback(void)
 {
-  ctx-&gt;setCurrentState(state_machine::INITIAL_STATE);
+  /*INIT*/
+  /*** state vehicle ***/
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::ENTRY, "Init",
+                           std::bind(&amp;DecisionMakerNode::entryInitState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::UPDATE, "Init",
+                           std::bind(&amp;DecisionMakerNode::updateInitState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::ENTRY, "SensorInit",
+                           std::bind(&amp;DecisionMakerNode::entrySensorInitState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::UPDATE, "SensorInit",
+                           std::bind(&amp;DecisionMakerNode::updateSensorInitState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::ENTRY, "MapInit",
+                           std::bind(&amp;DecisionMakerNode::entryMapInitState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::UPDATE, "MapInit",
+                           std::bind(&amp;DecisionMakerNode::updateMapInitState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::ENTRY, "LocalizationInit",
+                           std::bind(&amp;DecisionMakerNode::entryLocalizationInitState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::UPDATE, "LocalizationInit",
+                           std::bind(&amp;DecisionMakerNode::updateLocalizationInitState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::ENTRY, "PlanningInit",
+                           std::bind(&amp;DecisionMakerNode::entryPlanningInitState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::UPDATE, "PlanningInit",
+                           std::bind(&amp;DecisionMakerNode::updatePlanningInitState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::ENTRY, "VehicleInit",
+                           std::bind(&amp;DecisionMakerNode::entryVehicleInitState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::UPDATE, "VehicleInit",
+                           std::bind(&amp;DecisionMakerNode::updateVehicleInitState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::ENTRY, "VehicleReady",
+                           std::bind(&amp;DecisionMakerNode::entryVehicleReadyState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::UPDATE, "VehicleReady",
+                           std::bind(&amp;DecisionMakerNode::updateVehicleReadyState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::ENTRY, "VehicleEmergency",
+                           std::bind(&amp;DecisionMakerNode::entryVehicleEmergencyState, this, std::placeholders::_1, 0));
+  ctx_vehicle-&gt;setCallback(state_machine::CallbackType::UPDATE, "VehicleEmergency",
+                           std::bind(&amp;DecisionMakerNode::updateVehicleEmergencyState, this, std::placeholders::_1, 0));
 
-  // status subscriber
-  Subs["sim_pose"] = nh_.subscribe("sim_pose", 20, &amp;DecisionMakerNode::callbackFromSimPose, this);
-  Subs["current_pose"] = nh_.subscribe("current_pose", 20, &amp;DecisionMakerNode::callbackFromCurrentPose, this);
-  Subs["current_velocity"] =
-      nh_.subscribe("current_velocity", 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
-  Subs["light_color"] = nh_.subscribe("light_color", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
-  Subs["points_raw"] = nh_.subscribe("filtered_points", 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
-  Subs["final_waypoints"] = nh_.subscribe("final_waypoints", 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
-  Subs["twist_cmd"] = nh_.subscribe("twist_cmd", 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
-  Subs["change_flag"] = nh_.subscribe("change_flag", 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
-  Subs["state_cmd"] = nh_.subscribe("state_cmd", 1, &amp;DecisionMakerNode::callbackFromStateCmd, this);
-  Subs["closest_waypoint"] =
-      nh_.subscribe("closest_waypoint", 1, &amp;DecisionMakerNode::callbackFromClosestWaypoint, this);
-  Subs["cloud_clusters"] =
-      nh_.subscribe("cloud_clusters", 1, &amp;DecisionMakerNode::callbackFromObjectDetector, this);
+  /*** state mission ***/
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::ENTRY, "WaitVehicleReady",
+                           std::bind(&amp;DecisionMakerNode::entryWaitVehicleReadyState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::UPDATE, "WaitVehicleReady",
+                           std::bind(&amp;DecisionMakerNode::updateWaitVehicleReadyState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::ENTRY, "WaitOrder",
+                           std::bind(&amp;DecisionMakerNode::entryWaitOrderState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::UPDATE, "WaitOrder",
+                           std::bind(&amp;DecisionMakerNode::updateWaitOrderState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::EXIT, "WaitOrder",
+                           std::bind(&amp;DecisionMakerNode::exitWaitOrderState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::ENTRY, "MissionCheck",
+                           std::bind(&amp;DecisionMakerNode::entryMissionCheckState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::UPDATE, "MissionCheck",
+                           std::bind(&amp;DecisionMakerNode::updateMissionCheckState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::ENTRY, "DriveReady",
+                           std::bind(&amp;DecisionMakerNode::entryDriveReadyState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::UPDATE, "DriveReady",
+                           std::bind(&amp;DecisionMakerNode::updateDriveReadyState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::ENTRY, "Driving",
+                           std::bind(&amp;DecisionMakerNode::entryDrivingState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::UPDATE, "Driving",
+                           std::bind(&amp;DecisionMakerNode::updateDrivingState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::EXIT, "Driving",
+                           std::bind(&amp;DecisionMakerNode::exitDrivingState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(
+      state_machine::CallbackType::ENTRY, "DrivingMissionChange",
+      std::bind(&amp;DecisionMakerNode::entryDrivingMissionChangeState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(
+      state_machine::CallbackType::UPDATE, "DrivingMissionChange",
+      std::bind(&amp;DecisionMakerNode::updateDrivingMissionChangeState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(
+      state_machine::CallbackType::UPDATE, "MissionChangeSucceeded",
+      std::bind(&amp;DecisionMakerNode::updateMissionChangeSucceededState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(
+      state_machine::CallbackType::UPDATE, "MissionChangeFailed",
+      std::bind(&amp;DecisionMakerNode::updateMissionChangeFailedState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::ENTRY, "MissionComplete",
+                           std::bind(&amp;DecisionMakerNode::entryMissionCompleteState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::UPDATE, "MissionComplete",
+                           std::bind(&amp;DecisionMakerNode::updateMissionCompleteState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::ENTRY, "MissionAborted",
+                           std::bind(&amp;DecisionMakerNode::entryMissionAbortedState, this, std::placeholders::_1, 0));
+  ctx_mission-&gt;setCallback(state_machine::CallbackType::UPDATE, "MissionAborted",
+                           std::bind(&amp;DecisionMakerNode::updateMissionAbortedState, this, std::placeholders::_1, 0));
+
+  /*** state drive ***/
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "WaitEngage",
+                         std::bind(&amp;DecisionMakerNode::updateWaitEngageState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "Drive",
+                         std::bind(&amp;DecisionMakerNode::entryDriveState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "Drive",
+                         std::bind(&amp;DecisionMakerNode::updateDriveState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "LaneArea",
+                         std::bind(&amp;DecisionMakerNode::updateLaneAreaState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "FreeArea",
+                         std::bind(&amp;DecisionMakerNode::updateFreeAreaState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "Cruise",
+                         std::bind(&amp;DecisionMakerNode::updateCruiseState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "BusStop",
+                         std::bind(&amp;DecisionMakerNode::updateBusStopState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "Parking",
+                         std::bind(&amp;DecisionMakerNode::updateParkingState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "DriveEmergency",
+                         std::bind(&amp;DecisionMakerNode::entryDriveEmergencyState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "DriveEmergency",
+                         std::bind(&amp;DecisionMakerNode::updateDriveEmergencyState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::EXIT, "DriveEmergency",
+                         std::bind(&amp;DecisionMakerNode::exitDriveEmergencyState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "LeftTurn",
+                         std::bind(&amp;DecisionMakerNode::entryTurnState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "LeftTurn",
+                         std::bind(&amp;DecisionMakerNode::updateLeftTurnState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "RightTurn",
+                         std::bind(&amp;DecisionMakerNode::entryTurnState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "RightTurn",
+                         std::bind(&amp;DecisionMakerNode::updateRightTurnState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "Straight",
+                         std::bind(&amp;DecisionMakerNode::entryTurnState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "Straight",
+                         std::bind(&amp;DecisionMakerNode::updateStraightState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "Back",
+                         std::bind(&amp;DecisionMakerNode::entryTurnState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "Back",
+                         std::bind(&amp;DecisionMakerNode::updateBackState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "LeftLaneChange",
+                         std::bind(&amp;DecisionMakerNode::entryLaneChangeState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "LeftLaneChange",
+                         std::bind(&amp;DecisionMakerNode::updateLeftLaneChangeState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "RightLaneChange",
+                         std::bind(&amp;DecisionMakerNode::entryLaneChangeState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "RightLaneChange",
+                         std::bind(&amp;DecisionMakerNode::updateRightLaneChangeState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "PullIn",
+                         std::bind(&amp;DecisionMakerNode::updatePullInState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "PullOut",
+                         std::bind(&amp;DecisionMakerNode::updatePullOutState, this, std::placeholders::_1, 0));
+
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "CheckLeftLane",
+                         std::bind(&amp;DecisionMakerNode::updateCheckLeftLaneState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "CheckRightLane",
+                         std::bind(&amp;DecisionMakerNode::updateCheckRightLaneState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "ChangeToLeft",
+                         std::bind(&amp;DecisionMakerNode::updateChangeToLeftState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "ChangeToRight",
+                         std::bind(&amp;DecisionMakerNode::updateChangeToRightState, this, std::placeholders::_1, 0));
+
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "Go",
+                         std::bind(&amp;DecisionMakerNode::entryGoState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "L_Go",
+                         std::bind(&amp;DecisionMakerNode::entryGoState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "R_Go",
+                         std::bind(&amp;DecisionMakerNode::entryGoState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "B_Go",
+                         std::bind(&amp;DecisionMakerNode::entryGoState, this, std::placeholders::_1, 0));
+
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "Go",
+                         std::bind(&amp;DecisionMakerNode::updateGoState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "L_Go",
+                         std::bind(&amp;DecisionMakerNode::updateGoState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "R_Go",
+                         std::bind(&amp;DecisionMakerNode::updateGoState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "B_Go",
+                         std::bind(&amp;DecisionMakerNode::updateGoState, this, std::placeholders::_1, 0));
+
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "Wait",
+                         std::bind(&amp;DecisionMakerNode::updateWaitState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "L_Wait",
+                         std::bind(&amp;DecisionMakerNode::updateWaitState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "R_Wait",
+                         std::bind(&amp;DecisionMakerNode::updateWaitState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "B_Wait",
+                         std::bind(&amp;DecisionMakerNode::updateWaitState, this, std::placeholders::_1, 0));
+
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "StopLine",
+                         std::bind(&amp;DecisionMakerNode::updateStoplineState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "L_StopLine",
+                         std::bind(&amp;DecisionMakerNode::updateStoplineState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "R_StopLine",
+                         std::bind(&amp;DecisionMakerNode::updateStoplineState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "B_StopLine",
+                         std::bind(&amp;DecisionMakerNode::updateStoplineState, this, std::placeholders::_1, 0));
+
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "Stop",
+                         std::bind(&amp;DecisionMakerNode::entryStopState, this, std::placeholders::_1, 1));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "L_Stop",
+                         std::bind(&amp;DecisionMakerNode::entryStopState, this, std::placeholders::_1, 1));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "R_Stop",
+                         std::bind(&amp;DecisionMakerNode::entryStopState, this, std::placeholders::_1, 1));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::ENTRY, "B_Stop",
+                         std::bind(&amp;DecisionMakerNode::entryStopState, this, std::placeholders::_1, 1));
+
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "Stop",
+                         std::bind(&amp;DecisionMakerNode::updateStopState, this, std::placeholders::_1, 1));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "L_Stop",
+                         std::bind(&amp;DecisionMakerNode::updateStopState, this, std::placeholders::_1, 1));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "R_Stop",
+                         std::bind(&amp;DecisionMakerNode::updateStopState, this, std::placeholders::_1, 1));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::UPDATE, "B_Stop",
+                         std::bind(&amp;DecisionMakerNode::updateStopState, this, std::placeholders::_1, 1));
 
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::EXIT, "Wait",
+                         std::bind(&amp;DecisionMakerNode::exitStopState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::EXIT, "L_Wait",
+                         std::bind(&amp;DecisionMakerNode::exitStopState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::EXIT, "R_Wait",
+                         std::bind(&amp;DecisionMakerNode::exitStopState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::EXIT, "B_Wait",
+                         std::bind(&amp;DecisionMakerNode::exitStopState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::EXIT, "StopLine",
+                         std::bind(&amp;DecisionMakerNode::exitStopState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::EXIT, "L_StopLine",
+                         std::bind(&amp;DecisionMakerNode::exitStopState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::EXIT, "R_StopLine",
+                         std::bind(&amp;DecisionMakerNode::exitStopState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::EXIT, "B_StopLine",
+                         std::bind(&amp;DecisionMakerNode::exitStopState, this, std::placeholders::_1, 0));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::EXIT, "Stop",
+                         std::bind(&amp;DecisionMakerNode::exitStopState, this, std::placeholders::_1, 1));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::EXIT, "L_Stop",
+                         std::bind(&amp;DecisionMakerNode::exitStopState, this, std::placeholders::_1, 1));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::EXIT, "R_Stop",
+                         std::bind(&amp;DecisionMakerNode::exitStopState, this, std::placeholders::_1, 1));
+  ctx_drive-&gt;setCallback(state_machine::CallbackType::EXIT, "B_Stop",
+                         std::bind(&amp;DecisionMakerNode::exitStopState, this, std::placeholders::_1, 1));
+
+  ctx_vehicle-&gt;nextState("started");
+  ctx_mission-&gt;nextState("started");
+  ctx_drive-&gt;nextState("started");
+}
+
+void DecisionMakerNode::createSubscriber(void)
+{
   // Config subscriber
   Subs["config/decision_maker"] =
       nh_.subscribe("/config/decision_maker", 3, &amp;DecisionMakerNode::callbackFromConfig, this);
 
-
+  Subs["state_cmd"] = nh_.subscribe("/state_cmd", 1, &amp;DecisionMakerNode::callbackFromStateCmd, this);
+  Subs["current_velocity"] =
+      nh_.subscribe("/current_velocity", 1, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
+  Subs["obstacle_waypoint"] =
+      nh_.subscribe("/obstacle_waypoint", 1, &amp;DecisionMakerNode::callbackFromObstacleWaypoint, this);
+  Subs["change_flag"] = nh_.subscribe("/change_flag", 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
+}
+void DecisionMakerNode::createPublisher(void)
+{
   // pub
-  //
-  Pubs["state/stopline_wpidx"] = nh_.advertise&lt;std_msgs::Int32&gt;("/state/stopline_wpidx", 1, true);
+  Pubs["state/stopline_wpidx"] = nh_.advertise&lt;std_msgs::Int32&gt;("/state/stopline_wpidx", 1, false);
 
   // for controlling other planner
-  Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
   Pubs["lane_waypoints_array"] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
-  Pubs["states"] = nh_.advertise&lt;autoware_msgs::State&gt;("/decisionmaker/states", 1, true);
   Pubs["light_color"] = nh_.advertise&lt;autoware_msgs::TrafficLight&gt;("/light_color_managed", 1);
 
   // for controlling vehicle
   Pubs["lamp_cmd"] = nh_.advertise&lt;autoware_msgs::LampCmd&gt;("/lamp_cmd", 1);
 
   // for visualize status
-  Pubs["state_overlay"] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("/state/overlay_text", 1);
-  Pubs["crossroad_marker"] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("/state/cross_road_marker", 1);
-  Pubs["crossroad_inside_marker"] = nh_.advertise&lt;visualization_msgs::Marker&gt;("/state/cross_inside_marker", 1);
-  Pubs["crossroad_bbox"] = nh_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/state/crossroad_bbox", 10);
-  Pubs["detection_area"] = nh_.advertise&lt;visualization_msgs::Marker&gt;("/state/detection_area",1);
-  Pubs["stopline_target"] = nh_.advertise&lt;visualization_msgs::Marker&gt;("/state/stopline_target",1);
+  Pubs["state"] = private_nh_.advertise&lt;std_msgs::String&gt;("state", 1, true);
+  Pubs["state_msg"] = private_nh_.advertise&lt;autoware_msgs::State&gt;("state_msg", 1, true);
+  Pubs["state_overlay"] = private_nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("state_overlay", 1);
+  Pubs["available_transition"] = private_nh_.advertise&lt;std_msgs::String&gt;("available_transition", 1, true);
 
   // for debug
-  Pubs["target_velocity_array"] = nh_.advertise&lt;std_msgs::Float64MultiArray&gt;("/target_velocity_array", 1);
-  Pubs["state_local_diffdistance"] = nh_.advertise&lt;std_msgs::Float64&gt;("/state/val_diff_distance", 1);
-  Pubs["exectime"] = nh_.advertise&lt;std_msgs::Float64&gt;("/state/exectime", 1);
-
-  // message setup
-  state_text_msg.width = 400;
-  state_text_msg.height = 500;
-  state_text_msg.top = 10;
-  state_text_msg.left = 10;
-  state_text_msg.bg_color.r = 0;
-  state_text_msg.bg_color.g = 0;
-  state_text_msg.bg_color.b = 0;
-  state_text_msg.bg_color.a = 0.8;
-
-  state_text_msg.line_width = 2;
-  state_text_msg.text_size = 18;
-  state_text_msg.font = "DejaVu Sans Mono";
-  state_text_msg.fg_color.r = 0.1;
-  state_text_msg.fg_color.g = 1.0;
-  state_text_msg.fg_color.b = 0.94;
-  state_text_msg.fg_color.a = 0.8;
-  state_text_msg.text = "UNDEFINED";
-
-  // initial publishing state message
-  update_msgs();
+  Pubs["target_velocity_array"] = nh_.advertise&lt;std_msgs::Float64MultiArray&gt;("target_velocity_array", 1);
+  Pubs["operator_help_text"] = private_nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("operator_help_text", 1, true);
+}
 
-  // setup a callback for state update();
-  setupStateCallback();
+void DecisionMakerNode::initROS()
+{
+  // for subscribe callback function
 
-  g_vmap.subscribe(nh_,
-                   Category::POINT | Category::LINE | Category::VECTOR | Category::AREA |
-                       Category::POLE |  // basic class
-                       Category::DTLANE | Category::STOP_LINE | Category::ROAD_SIGN | Category::CROSS_ROAD);
-  initVectorMap();
+  createSubscriber();
+  createPublisher();
 
-  {
-    if (enableDisplayMarker)
-      displayMarker();
-  }
+  spinners = std::shared_ptr&lt;ros::AsyncSpinner&gt;(new ros::AsyncSpinner(3));
+  spinners-&gt;start();
 
-  ROS_INFO("Initialized OUT\n");
-  ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
-  
-  Subs["lane_waypoints_array"] =
-      nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
+  update_msgs();
 }
 
 void DecisionMakerNode::initVectorMap(void)
 {
   int _index = 0;
-  // if(vector_map_init)
-  //      return;
-  std::vector&lt;CrossRoad&gt; crossroads = g_vmap.findByFilter([](const CrossRoad &amp;crossroad) { return true; });
+
+  const std::vector&lt;CrossRoad&gt; crossroads = g_vmap.findByFilter([](const CrossRoad&amp; crossroad) { return true; });
   if (crossroads.empty())
   {
     ROS_INFO("crossroads have not found\n");
     return;
   }
 
-  vector_map_init = true;  // loaded flag
-  for (const auto &amp;cross_road : crossroads)
+  for (const auto&amp; cross_road : crossroads)
   {
     geometry_msgs::Point _prev_point;
     Area area = g_vmap.findByKey(Key&lt;Area&gt;(cross_road.aid));
@@ -148,13 +308,13 @@ void DecisionMakerNode::initVectorMap(void)
     double z = 0.0;
     int points_count = 0;
 
-    std::vector&lt;Line&gt; lines =
-        g_vmap.findByFilter([&amp;area](const Line &amp;line) { return area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid; });
-    for (const auto &amp;line : lines)
+    const std::vector&lt;Line&gt; lines =
+        g_vmap.findByFilter([&amp;area](const Line&amp; line) { return area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid; });
+    for (const auto&amp; line : lines)
     {
-      std::vector&lt;Point&gt; points =
-          g_vmap.findByFilter([&amp;line](const Point &amp;point) { return line.bpid == point.pid;});
-      for (const auto &amp;point : points)
+      const std::vector&lt;Point&gt; points =
+          g_vmap.findByFilter([&amp;line](const Point&amp; point) { return line.bpid == point.pid; });
+      for (const auto&amp; point : points)
       {
         geometry_msgs::Point _point;
         _point.x = point.ly;
@@ -178,7 +338,7 @@ void DecisionMakerNode::initVectorMap(void)
         z = _point.z;
       }  // points iter
     }    // line iter
-    carea.bbox.pose.position.x = x_avg / (double)points_count * 1.5/* expanding rate */;
+    carea.bbox.pose.position.x = x_avg / (double)points_count * 1.5 /* expanding rate */;
     carea.bbox.pose.position.y = y_avg / (double)points_count * 1.5;
     carea.bbox.pose.position.z = z;
     carea.bbox.dimensions.x = x_max - x_min;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="101" deleted_lines="199">
				<diff>@@ -1,227 +1,129 @@
-#include &lt;ros/ros.h&gt;
-#include &lt;ros/spinner.h&gt;
-#include &lt;std_msgs/Float64.h&gt;
-#include &lt;std_msgs/Float64MultiArray.h&gt;
-#include &lt;std_msgs/String.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-
-// lib
-#include &lt;state_machine_lib/state.hpp&gt;
-#include &lt;state_machine_lib/state_context.hpp&gt;
-
 #include &lt;decision_maker_node.hpp&gt;
 
-#include &lt;autoware_msgs/Lane.h&gt;
-#include &lt;autoware_msgs/State.h&gt;
-#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-#include &lt;random&gt;
-#include &lt;visualization_msgs/MarkerArray.h&gt;
-
-#include &lt;geometry_msgs/Point.h&gt;
-#include &lt;geometry_msgs/Pose.h&gt;
-#include &lt;geometry_msgs/PoseStamped.h&gt;
-
 namespace decision_maker
 {
-void DecisionMakerNode::update_pubsub(void)
+void DecisionMakerNode::publishLampCmd(const E_Lamp&amp; status)
 {
-  // if state machine require to re-subscribe topic,
-  // this function will re-definition subscriber.
+  autoware_msgs::LampCmd lamp_msg;
+  lamp_msg.header.stamp = ros::Time::now();
+
+  switch (status)
+  {
+    case E_Lamp::LAMP_LEFT:
+      lamp_msg.l = LAMP_ON;
+      lamp_msg.r = LAMP_OFF;
+      break;
+    case E_Lamp::LAMP_RIGHT:
+      lamp_msg.l = LAMP_OFF;
+      lamp_msg.r = LAMP_ON;
+      break;
+    case E_Lamp::LAMP_HAZARD:
+      lamp_msg.l = LAMP_ON;
+      lamp_msg.r = LAMP_ON;
+      break;
+    case E_Lamp::LAMP_EMPTY:
+    default:
+      lamp_msg.l = LAMP_OFF;
+      lamp_msg.r = LAMP_OFF;
+      break;
+  }
+  Pubs["lamp_cmd"].publish(lamp_msg);
 }
 
-int DecisionMakerNode::createCrossRoadAreaMarker(visualization_msgs::Marker &amp;crossroad_marker, double scale)
+jsk_rviz_plugins::OverlayText createOverlayText(cstring_t&amp; data, const int column)
 {
-  crossroad_marker.header.frame_id = "/map";
-  crossroad_marker.header.stamp = ros::Time();
-  crossroad_marker.id = 1;
-  crossroad_marker.type = visualization_msgs::Marker::SPHERE_LIST;
-  crossroad_marker.action = visualization_msgs::Marker::ADD;
-  crossroad_marker.ns = "crossroad";
-
-  crossroad_marker.scale.x = scale;
-  crossroad_marker.scale.y = scale;
-  crossroad_marker.scale.z = 0.5;
-  crossroad_marker.color.a = 0.15;
-  crossroad_marker.color.r = 1.0;
-  crossroad_marker.color.g = 0.0;
-  crossroad_marker.color.b = 0.0;
-  crossroad_marker.frame_locked = true;
-  crossroad_marker.lifetime = ros::Duration(0.3);
-
-  return 0;
+  jsk_rviz_plugins::OverlayText ret;
+
+  // message setup
+  ret.width = 500;
+  ret.height = 500;
+  ret.top = 10 + (column * 500);
+  ret.left = 10;
+  ret.bg_color.r = 0;
+  ret.bg_color.g = 0;
+  ret.bg_color.b = 0;
+  ret.bg_color.a = 0.8;
+
+  ret.line_width = 2;
+  ret.text_size = 9;
+  ret.font = "DejaVu Sans Mono";
+  ret.fg_color.r = 1.0;
+  ret.fg_color.g = 1.0;
+  ret.fg_color.b = 0.5;
+  ret.fg_color.a = 0.9;
+
+  ret.text = data;
+
+  return ret;
 }
 
-void DecisionMakerNode::displayMarker(void)
+void DecisionMakerNode::publishOperatorHelpMessage(cstring_t&amp; message)
 {
-  // vector_map init
-  // parse vectormap
-  jsk_recognition_msgs::BoundingBoxArray bbox_array;
-  visualization_msgs::MarkerArray marker_array;
-  visualization_msgs::Marker crossroad_marker;
-  visualization_msgs::Marker stopline_target_marker;
-  visualization_msgs::Marker inside_marker;
-  visualization_msgs::Marker inside_line_marker;
-  visualization_msgs::Marker detection_area_marker;
-
-  double scale = 3.0;
-  createCrossRoadAreaMarker(crossroad_marker, scale);
-  
-  detection_area_marker = crossroad_marker;
-  detection_area_marker.header.frame_id = param_baselink_tf_;
-  detection_area_marker.scale.x = (detectionArea_.x1 - detectionArea_.x2) * param_detection_area_rate_;
-  detection_area_marker.scale.y = (detectionArea_.y1 - detectionArea_.y2) * param_detection_area_rate_;
-  detection_area_marker.color.r = foundOtherVehicleForIntersectionStop_?0.0:1.0;
-  detection_area_marker.pose.position.x =  detection_area_marker.scale.x/2;
-  detection_area_marker.color.g = 1;
-  detection_area_marker.color.b = 0.3;
-  detection_area_marker.color.a = 0.3;
-  detection_area_marker.type = visualization_msgs::Marker::CUBE;
-  detection_area_marker.lifetime=ros::Duration();
-
-  stopline_target_marker = crossroad_marker;
-  stopline_target_marker.type = visualization_msgs::Marker::SPHERE;
-  stopline_target_marker.scale.x = 1;
-  stopline_target_marker.scale.y = 1;
-  stopline_target_marker.scale.z = 1;
-  stopline_target_marker.color.a = 1;
-  stopline_target_marker.color.r = 1.0;
-  stopline_target_marker.color.g = 0.0;
-  stopline_target_marker.color.b = 0.0;
-  stopline_target_marker.ns = "stopline_target";
-  stopline_target_marker.lifetime = ros::Duration();
-  stopline_target_marker.pose.position.x = CurrentStoplineTarget_.pose.pose.position.x;
-  stopline_target_marker.pose.position.y = CurrentStoplineTarget_.pose.pose.position.y;
-  stopline_target_marker.pose.position.z = CurrentStoplineTarget_.pose.pose.position.z;
-  
-  inside_marker = crossroad_marker;
-  inside_marker.scale.x = scale / 3;
-  inside_marker.scale.y = scale / 3;
-  inside_marker.scale.z = 0.4;
-  inside_marker.scale.z = 0.5;
-  inside_marker.color.a = 0.5;
-  inside_marker.color.r = 1.0;
-  inside_marker.color.g = 0.0;
-  inside_marker.color.b = 0.0;
-  inside_marker.ns = "inside";
-  inside_marker.lifetime = ros::Duration();
-   
-
-  inside_marker = crossroad_marker;
-  inside_marker.scale.x = scale / 3;
-  inside_marker.scale.y = scale / 3;
-  inside_marker.scale.z = 0.4;
-  inside_marker.scale.z = 0.5;
-  inside_marker.color.a = 0.5;
-  inside_marker.color.r = 1.0;
-  inside_marker.color.g = 0.0;
-  inside_marker.color.b = 0.0;
-  inside_marker.ns = "inside";
-  inside_marker.lifetime = ros::Duration();
-
-  bbox_array.header = crossroad_marker.header;
-  inside_marker.points.clear();
-
-  inside_line_marker = inside_marker;
-  inside_line_marker.type = visualization_msgs::Marker::LINE_STRIP;
-
-  for (auto &amp;area : intersects)
-  {
-    area.bbox.header = crossroad_marker.header;
-    bbox_array.boxes.push_back(area.bbox);
-    for (const auto &amp;p : area.insideWaypoint_points)
-    {
-      inside_marker.points.push_back(p);
-    }
-
-    for (const auto &amp;lane : area.insideLanes)
-    {
-      inside_line_marker.points.clear();
-      int id = inside_line_marker.id;
-      inside_line_marker.id += 1;
-      inside_marker.scale.x = scale / 3;
-      inside_marker.scale.y = scale / 3;
-      inside_line_marker.color.r = std::fmod(0.12345 * (id), 1.0);
-      inside_line_marker.color.g = std::fmod(0.32345 * (5 - (id % 5)), 1.0);
-      inside_line_marker.color.b = std::fmod(0.52345 * (10 - (id % 10)), 1.0);
-      for (const auto &amp;wp : lane.waypoints)
-      {
-        inside_line_marker.points.push_back(wp.pose.pose.position);
-      }
-      marker_array.markers.push_back(inside_line_marker);
-    }
-  }
-  inside_line_marker.scale.x = 0.2;  // 0.3;
-  inside_line_marker.scale.y = 0.2;  // 0.3;
-  inside_line_marker.color.r = 0;
-  inside_line_marker.color.g = 1;
-  inside_line_marker.color.b = 0.3;
-  inside_line_marker.color.a = 1;
-  inside_line_marker.ns = "shiftline";
-  for (const auto &amp;lane : current_controlled_lane_array_.lanes)
-  {
-    inside_line_marker.points.clear();
-    for (size_t idx = 0; idx &lt; lane.waypoints.size(); idx++)
-    {
-      inside_line_marker.id += 1;
-
-      geometry_msgs::Pose shift_p = lane.waypoints.at(idx).pose.pose;
-
-      double current_angle = getPoseAngle(shift_p);
+  static std::vector&lt;std::string&gt; msg_log;
+  static const size_t log_size = 10;
 
-      shift_p.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
-      shift_p.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
+  msg_log.push_back(message);
 
-      inside_line_marker.points.push_back(shift_p.position);
-    }
-    marker_array.markers.push_back(inside_line_marker);
+  if (msg_log.size() &gt;= log_size)
+  {
+    msg_log.erase(msg_log.begin());
   }
 
-
-  Pubs["detection_area"].publish(detection_area_marker);
-  Pubs["crossroad_bbox"].publish(bbox_array);
-  Pubs["crossroad_marker"].publish(marker_array);
-  Pubs["stopline_target"].publish(stopline_target_marker);
-  bbox_array.boxes.clear();
-  // Pubs["crossroad_inside_marker"].publish(inside_marker);
-  Pubs["crossroad_inside_marker"].publish(inside_line_marker);
+  std::string joined_msg;
+  for (const auto&amp; i : msg_log)
+  {
+    joined_msg += "&gt; " + i + "\n";
+  }
+  Pubs["operator_help_text"].publish(createOverlayText(joined_msg, 0));
 }
 
 void DecisionMakerNode::update_msgs(void)
 {
-  if (ctx)
+#if 1
+  if (ctx_vehicle &amp;&amp; ctx_mission &amp;&amp; ctx_drive)
   {
-    static std::string prevStateName;
-    CurrentStateName = ctx-&gt;getCurrentStateName();
-
-    if (prevStateName != CurrentStateName)
-    {
-      prevStateName = CurrentStateName;
-      update_pubsub();
-    }
-
-    autoware_msgs::State state_msg;
-    state_msg.main_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::MAIN_STATE);
-    state_msg.acc_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::ACC_STATE);
-    state_msg.str_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::STR_STATE);
-    state_msg.behavior_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::BEHAVIOR_STATE);
-
-    state_string_msg.data = CurrentStateName;
-    // state_text_msg.text = createStateMessageText();
-    state_text_msg.text = state_msg.main_state + "\n" + state_msg.acc_state + "\n" + state_msg.str_state + "\n" +
-                          state_msg.behavior_state + "\n";
-
-    Pubs["states"].publish(state_msg);
-    // Pubs["state"].publish(state_string_msg);
-    Pubs["state_overlay"].publish(state_text_msg);
+    static std::string text_vehicle_state, text_mission_state, text_drive_state;
+    text_vehicle_state = ctx_vehicle-&gt;getStateText();
+    text_mission_state = ctx_mission-&gt;getStateText();
+    text_drive_state = ctx_drive-&gt;getStateText();
+
+    static std_msgs::String state_msg;
+    state_msg.data = text_vehicle_state + text_mission_state + text_drive_state;
+    Pubs["state"].publish(state_msg);
+    Pubs["state_overlay"].publish(createOverlayText(state_msg.data, 1));
+
+    static autoware_msgs::State state_array_msg;
+    state_array_msg.header.stamp = ros::Time::now();
+    state_array_msg.vehicle_state = text_vehicle_state;
+    state_array_msg.mission_state = text_mission_state;
+    state_array_msg.drive_state = text_drive_state;
+    Pubs["state_msg"].publish(state_array_msg);
+
+    static std_msgs::String transition_msg;
+    transition_msg.data = ctx_vehicle-&gt;getAvailableTransition() + ctx_mission-&gt;getAvailableTransition() +
+                          ctx_drive-&gt;getAvailableTransition();
+
+    Pubs["available_transition"].publish(transition_msg);
   }
   else
+  {
     std::cerr &lt;&lt; "ctx is not found " &lt;&lt; std::endl;
+  }
+#endif
+}
+
+void DecisionMakerNode::publishLightColor(int status)
+{
+  autoware_msgs::TrafficLight msg;
+  msg.traffic_light = status;
+  Pubs["light_color"].publish(msg);
 }
 
-std::string DecisionMakerNode::createStateMessageText()
+void DecisionMakerNode::publishStoplineWaypointIdx(int wp_idx)
 {
-  return ctx-&gt;createStateMessageText();
+  std_msgs::Int32 msg;
+  msg.data = wp_idx;
+  Pubs["state/stopline_wpidx"].publish(msg);
 }
 
 void DecisionMakerNode::publishToVelocityArray()
@@ -229,7 +131,7 @@ void DecisionMakerNode::publishToVelocityArray()
   int count = 0;
   std_msgs::Float64MultiArray msg;
 
-  for (const auto &amp;i : current_finalwaypoints_.waypoints)
+  for (const auto&amp; i : current_status_.finalwaypoints.waypoints)
   {
     msg.data.push_back(amathutils::mps2kmph(i.twist.twist.linear.x));
     if (++count &gt;= 10)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="" added_lines="0" deleted_lines="463">
				<diff>@@ -1,463 +0,0 @@
-#include &lt;ros/ros.h&gt;
-
-#include &lt;state_machine_lib/state.hpp&gt;
-#include &lt;state_machine_lib/state_context.hpp&gt;
-
-#include &lt;autoware_msgs/LampCmd.h&gt;
-#include &lt;decision_maker_node.hpp&gt;
-
-namespace decision_maker
-{
-void DecisionMakerNode::setupStateCallback(void)
-{
-  // steering state. these state's update function change lamp
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE,
-                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE,
-                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE,
-                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
-
-  // stopline stop state
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
-                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
-                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 1));
-  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
-                          std::bind(&amp;DecisionMakerNode::callbackOutStateStop, this, 1));
-
-  // stopping state
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE,
-                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE,
-                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));
-
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE,
-                         std::bind(&amp;DecisionMakerNode::StoplinePlanIn, this, 1));
-  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE,
-                          std::bind(&amp;DecisionMakerNode::StoplinePlanOut, this, 1));
-
-  // speed keep(original speed) state
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE,
-                         std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));
-
-  // crawl
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_CRAWL_STATE,
-                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 0));
-
-  // acceleration
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
-                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));
-
-  // deceleration
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
-                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));
-
-  // LaneChange
-  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE,
-                          std::bind(&amp;DecisionMakerNode::callbackOutStateLaneChange, this, 1));
-  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE,
-                          std::bind(&amp;DecisionMakerNode::callbackOutStateLaneChange, this, 1));
-
-  // obstacle avoidance
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
-                             std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
-                         std::bind(&amp;DecisionMakerNode::callbackInStateObstacleAvoid, this, -1));
-  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
-                          std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));
-
-  // trraficlight
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE, [&amp;]() {
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
-    publishLightColor((int)state_machine::E_RED);
-  });
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE, [&amp;]() {
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
-    publishLightColor((int)state_machine::E_GREEN);
-  });
-
-#if 0
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
-                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_RED));
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
-                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
-                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
-                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
-#endif
-}
-
-void DecisionMakerNode::callbackOutStateLaneChange(int status)
-{
-  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE))
-  {
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE);
-  }
-}
-
-void DecisionMakerNode::publishLightColor(int status)
-{
-  autoware_msgs::TrafficLight msg;
-  msg.traffic_light = status;
-  Pubs["light_color"].publish(msg);
-}
-
-void DecisionMakerNode::publishStoplineWaypointIdx(int wp_idx)
-{
-  std_msgs::Int32 msg;
-  msg.data = wp_idx;
-  Pubs["state/stopline_wpidx"].publish(msg);
-}
-
-#define SHIFTED_LANE_FLAG -99999
-void DecisionMakerNode::createShiftLane(void)
-{
-  bool isRightShift = param_shift_width_ &gt;= 0;
-
-  autoware_msgs::LaneArray shift_lanes = current_shifted_lane_array_ = current_based_lane_array_;
-  if (!current_shifted_lane_array_.lanes.empty())
-  {
-    size_t lane_idx = 0;
-    for (auto&amp; lane : shift_lanes.lanes)
-    {
-      lane.increment = SHIFTED_LANE_FLAG;
-      size_t wp_idx = 0;
-      for (auto&amp; wp : lane.waypoints)
-      {
-        double angle = getPoseAngle(wp.pose.pose);
-        wp.pose.pose.position.x -= param_shift_width_ * cos(angle + M_PI / 2);
-        wp.pose.pose.position.y -= param_shift_width_ * sin(angle + M_PI / 2);
-        wp.change_flag = current_based_lane_array_.lanes.at(lane_idx).waypoints.at(wp_idx++).change_flag;
-      }
-      lane_idx++;
-    }
-  }
-  int insert_lane_idx_offset = isRightShift ? 1 : 0;
-  auto it_shift = begin(shift_lanes.lanes);
-  try
-  {
-    for (auto it = begin(current_shifted_lane_array_.lanes);
-         it != end(current_shifted_lane_array_.lanes) &amp;&amp; it_shift != end(shift_lanes.lanes);)
-    {
-      for (auto&amp; wp : it-&gt;waypoints)
-      {
-        wp.change_flag = isRightShift ? 1 : 2;
-      }
-      it = current_shifted_lane_array_.lanes.insert(it + insert_lane_idx_offset, *(it_shift++));
-      it++;
-      if (!isRightShift)
-      {
-        it++;
-      }
-    }
-  }
-  catch (std::length_error)
-  {
-  }
-}
-
-void DecisionMakerNode::changeShiftLane(void)
-{
-  auto based_it = begin(current_shifted_lane_array_.lanes);
-
-  for (auto&amp; lane : current_shifted_lane_array_.lanes)
-  {
-    if (lane.increment == SHIFTED_LANE_FLAG)
-    {
-      for (auto&amp; wp : lane.waypoints)
-      {
-        wp.change_flag = param_shift_width_ &gt;= 0 ? 2 : 1;
-      }
-    }
-    else
-    {
-      auto based_wp_it = begin(based_it++-&gt;waypoints);
-      for (auto&amp; wp : lane.waypoints)
-      {
-        wp.change_flag = based_wp_it++-&gt;change_flag;
-      }
-    }
-  }
-}
-
-void DecisionMakerNode::removeShiftLane(void)
-{
-  current_shifted_lane_array_ = current_based_lane_array_;
-}
-
-void DecisionMakerNode::updateLaneWaypointsArray(void)
-{
-  current_stopped_lane_array_ = current_controlled_lane_array_;
-
-  for (auto&amp; lane : current_stopped_lane_array_.lanes)
-  {
-    for (auto&amp; wp : lane.waypoints)
-    {
-      wp.twist.twist.linear.x = 0.0;
-      wp.wpstate.stop_state = 0;
-    }
-  }
-  for (auto&amp; lane : current_shifted_lane_array_.lanes)
-  {
-    for (auto&amp; wp : lane.waypoints)
-    {
-      // if stopped at stopline, to delete flags already used.
-      if (CurrentStoplineTarget_.gid - 2 &lt;= wp.gid &amp;&amp; wp.gid &lt;= CurrentStoplineTarget_.gid + 2)
-      {
-        wp.wpstate.stop_state = 0;
-      }
-    }
-  }
-}
-
-void DecisionMakerNode::publishControlledLaneArray(void)
-{
-  Pubs["lane_waypoints_array"].publish(current_controlled_lane_array_);
-}
-void DecisionMakerNode::publishStoppedLaneArray(void)
-{
-  updateLaneWaypointsArray();
-  Pubs["lane_waypoints_array"].publish(current_stopped_lane_array_);
-}
-
-void DecisionMakerNode::changeVelocityBasedLane(void)
-{
-  current_controlled_lane_array_ = current_shifted_lane_array_;
-}
-
-void DecisionMakerNode::setAllStoplineStop(void)
-{
-  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine&amp; stopline) { return true; });
-
-  for (auto&amp; lane : current_shifted_lane_array_.lanes)
-  {
-    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
-    {
-      for (auto&amp; stopline : stoplines)
-      {
-        geometry_msgs::Point bp =
-            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
-        geometry_msgs::Point fp =
-            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));
-
-        if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
-                                        lane.waypoints.at(wp_idx).pose.pose.position.y,
-                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
-                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
-        {
-          geometry_msgs::Point center_point;
-          center_point.x = (bp.x * 2 + fp.x) / 3;
-          center_point.y = (bp.y * 2 + fp.y) / 3;
-          if (amathutils::isPointLeftFromLine(
-                  center_point.x, center_point.y, lane.waypoints.at(wp_idx).pose.pose.position.x,
-                  lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
-                  lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
-          {
-            amathutils::point* a = new amathutils::point();
-            amathutils::point* b = new amathutils::point();
-            a-&gt;x = center_point.x;
-            a-&gt;y = center_point.y;
-            b-&gt;x = lane.waypoints.at(wp_idx).pose.pose.position.x;
-            b-&gt;y = lane.waypoints.at(wp_idx).pose.pose.position.y;
-            if (amathutils::find_distance(a, b) &lt;= 4)  //
-              lane.waypoints.at(wp_idx).wpstate.stop_state = 1;
-          }
-        }
-      }
-    }
-  }
-}
-
-void DecisionMakerNode::StoplinePlanIn(int status)
-{
-  setAllStoplineStop();
-  changeVelocityBasedLane();
-  publishControlledLaneArray();
-}
-void DecisionMakerNode::StoplinePlanOut(int status)
-{
-  current_shifted_lane_array_ = current_based_lane_array_;
-  changeVelocityBasedLane();
-  publishControlledLaneArray();
-}
-
-void DecisionMakerNode::changeVelocityLane(int dir)
-{
-  if (dir != 0)
-  {
-    for (auto&amp; lane : current_controlled_lane_array_.lanes)
-    {
-      autoware_msgs::Lane temp_lane = lane;
-      for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
-      {
-        amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
-                             temp_lane.waypoints.at(wpi).pose.pose.position.y,
-                             temp_lane.waypoints.at(wpi).pose.pose.position.z);
-        amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
-                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
-                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);
-
-        double distance = amathutils::find_distance(&amp;p0, &amp;p1);
-        double _rate = 0.2;                       // accelerated/decelerated rate
-        double _weight = distance * _rate * dir;  //
-        lane.waypoints.at(wpi).twist.twist.linear.x =
-            lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
-      }
-    }
-  }
-  else
-  {
-    for (auto&amp; lane : current_controlled_lane_array_.lanes)
-    {
-      for (auto&amp; wp : lane.waypoints)
-      {
-        wp.twist.twist.linear.x = amathutils::kmph2mps(param_crawl_velocity_);
-      }
-    }
-  }
-}
-
-void DecisionMakerNode::callbackInStateKeep(int status)
-{
-  changeVelocityBasedLane();
-  publishControlledLaneArray();
-}
-
-void DecisionMakerNode::callbackInStateAcc(int status)
-{
-  changeVelocityLane(status);
-  publishControlledLaneArray();
-}
-
-// for stopping state(stopline/stop)
-void DecisionMakerNode::updateStateStop(int status)
-{
-  static bool timerflag;
-  static ros::Timer stopping_timer;
-
-  if (status)
-  {
-    if (current_velocity_ == 0.0 &amp;&amp; !foundOtherVehicleForIntersectionStop_ &amp;&amp; !timerflag)
-    {
-      stopping_timer = nh_.createTimer(ros::Duration(1),
-                                       [&amp;](const ros::TimerEvent&amp;) {
-                                         ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
-                                         ROS_INFO("Change state to [KEEP] from [STOP]\n");
-                                         timerflag = false;
-                                       },
-                                       this, true);
-      timerflag = true;
-    }
-    else
-    {
-      if (foundOtherVehicleForIntersectionStop_ &amp;&amp; timerflag)
-      {
-        stopping_timer.stop();
-        timerflag = false;
-      }
-      publishStoplineWaypointIdx(closest_stopline_waypoint_);
-    }
-  }
-}
-void DecisionMakerNode::callbackInStateStop(int status)
-{
-  if (!status) /*not a stopline*/
-  {
-    publishStoppedLaneArray();
-  }
-  else /* handling stopline */
-  {
-    publishStoplineWaypointIdx(closest_stopline_waypoint_);
-  }
-}
-void DecisionMakerNode::callbackOutStateStop(int status)
-{
-  if (status)
-  {
-    closest_stopline_waypoint_ = -1;
-    publishStoplineWaypointIdx(closest_stopline_waypoint_);
-  }
-}
-
-void DecisionMakerNode::updateStateObstacleAvoid(int status)
-{
-}
-
-void DecisionMakerNode::callbackOutStateObstacleAvoid(int status)
-{
-  changeShiftLane();
-  changeVelocityBasedLane();
-  publishControlledLaneArray();
-  ros::Rate loop_rate(1);
-
-  // wait for the start of lane change to the original lane
-  if (created_shift_lane_flag_)
-  {
-    do
-    {
-      ros::spinOnce();
-      loop_rate.sleep();
-    } while (!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
-             !ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
-    // wait for the end of lane change
-    do
-    {
-      ros::spinOnce();
-      loop_rate.sleep();
-    } while ((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
-              ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
-              ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE)) &amp;&amp;
-             ros::ok());
-    removeShiftLane();
-    created_shift_lane_flag_ = false;
-  }
-  changeVelocityBasedLane();  // rebased controlled lane
-  publishControlledLaneArray();
-  return;
-}
-
-void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
-{
-  // this state is temporary implementation.
-  // It means this state is desirable to use a way which enables the avoidance
-  // plannner such as astar, state lattice.
-
-  // if car shoud stop before avoidance,
-  if (!created_shift_lane_flag_)
-  {
-    created_shift_lane_flag_ = true;
-    ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
-    createShiftLane();
-  }
-
-  changeVelocityBasedLane();
-}
-void DecisionMakerNode::updateStateSTR(int status)
-{
-  autoware_msgs::LampCmd lamp_msg;
-
-  switch (status)
-  {
-    case LAMP_LEFT:
-      lamp_msg.l = LAMP_ON;
-      lamp_msg.r = LAMP_OFF;
-      break;
-    case LAMP_RIGHT:
-      lamp_msg.l = LAMP_OFF;
-      lamp_msg.r = LAMP_ON;
-      break;
-    case LAMP_HAZARD:
-      lamp_msg.l = LAMP_ON;
-      lamp_msg.r = LAMP_ON;
-      break;
-    case LAMP_EMPTY:
-    default:
-      lamp_msg.l = LAMP_OFF;
-      lamp_msg.r = LAMP_OFF;
-      break;
-  }
-  Pubs["lamp_cmd"].publish(lamp_msg);
-}
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" new_path="" added_lines="0" deleted_lines="234">
				<diff>@@ -1,234 +0,0 @@
-#include &lt;autoware_config_msgs/ConfigPlannerSelector.h&gt;
-#include &lt;autoware_msgs/Lane.h&gt;
-#include &lt;ros/ros.h&gt;
-#include &lt;std_msgs/Int32.h&gt;
-
-#include &lt;mutex&gt;
-#include &lt;thread&gt;
-#include &lt;unordered_map&gt;
-
-#include &lt;amathutils_lib/amathutils.hpp&gt;
-#include &lt;planner_selector.hpp&gt;
-
-namespace decision_maker
-{
-void PlannerSelector::initROS()
-{
-  Subs["/dp/final_waypoints"] = nh_.subscribe("/dp/final_waypoints", 1, &amp;PlannerSelector::callbackFromWaypoints, this);
-  Subs["/astar/final_waypoints"] =
-      nh_.subscribe("/astar/final_waypoints", 1, &amp;PlannerSelector::callbackFromWaypoints, this);
-  Subs["/enableLattice"] = nh_.subscribe("/enableLattice", 10, &amp;PlannerSelector::callbackFromLattice, this);
-
-  Subs["/dp/closest_waypoint"] = nh_.subscribe("/dp/closest_waypoint", 1, &amp;PlannerSelector::callbackFromClosest, this);
-  Subs["/astar/closest_waypoint"] =
-      nh_.subscribe("/astar/closest_waypoint", 1, &amp;PlannerSelector::callbackFromClosest, this);
-
-  Subs["/config/planner_selector"] =
-      nh_.subscribe("/config/PlannerSelector", 1, &amp;PlannerSelector::callbackFromConfig, this);
-
-  Subs["current_velocity"] = nh_.subscribe("current_velocity", 3, &amp;PlannerSelector::callbackFromCurrentVelocity, this);
-
-  Pubs["final_waypoints"] = nh_.advertise&lt;autoware_msgs::Lane&gt;("/final_waypoints", 1);
-  Pubs["closest_waypoint"] = nh_.advertise&lt;std_msgs::Int32&gt;("/closest_waypoint", 1);
-}
-
-inline bool PlannerSelector::existWaypoints(const int _config_waypoints_num)
-{
-  bool ret;
-  ret = (_config_waypoints_num &lt; final_waypoints_dp_.waypoints.size()) &amp;&amp;
-        (_config_waypoints_num &lt; final_waypoints_dp_.waypoints.size());
-  return ret;
-}
-
-void PlannerSelector::callbackFromLattice(const std_msgs::Int32 &amp;msg)
-{
-  // static int prev[LATENCY_NUM] = { 1 };
-  static int counter = 0;
-  double _distance = 100.0;
-
-  try
-  {
-    autoware_msgs::Waypoint dp_point = final_waypoints_dp_.waypoints.at(config_waypoints_num_);
-    autoware_msgs::Waypoint astar_point = final_waypoints_astar_.waypoints.at(config_waypoints_num_);
-
-    amathutils::point p_dp, p_astar;
-    p_dp.x = dp_point.pose.pose.position.x;
-    p_dp.x = dp_point.pose.pose.position.y;
-    p_dp.z = 0.0;
-
-    p_astar.x = astar_point.pose.pose.position.x;
-    p_astar.x = astar_point.pose.pose.position.y;
-    p_astar.z = 0.0;
-
-    _distance = amathutils::find_distance(&amp;p_dp, &amp;p_astar);
-    //  ROS_INFO("distance=%f. %d:%d", _distance, dp_point.dtlane.dist,astar_point.dtlane.dist);
-  }
-  catch (const std::out_of_range &amp;ex)
-  {
-    ROS_ERROR("Out of Range:%s", ex.what());
-  }
-
-#if 0  // delay switch
-  _mutex.lock();
-  if(enableLattice_){
-	  if (msg.data == 0){
-		  if(counter++ &gt;= config_latency_num_){
-			  enableLattice_ = 0;
-			  counter = 0;
-		  }
-	  }
-  }else{
-	  enableLattice_ = msg.data;
-  }
-  ROS_INFO("msg.data=%d, enableLattice_ = %d", msg.data, enableLattice_);
-  _mutex.unlock();
-#else
-  _mutex.lock();
-  if (msg.data != enableLattice_)
-  {
-    if (enableLattice_ == 1 &amp;&amp; msg.data == 0)
-    {
-      if (pastWaypoint == false)
-      {
-        pastWaypoint = true;
-        counter = 0;
-        way_offset = config_waypoints_num_;
-      }
-    }
-    enableLattice_ = msg.data;
-  }
-  if (counter++ &gt;= config_latency_num_)
-  {
-    counter = 0;
-    if (way_offset &gt; 0)
-    {
-      way_offset--;
-    }
-    else
-    {
-      pastWaypoint = false;
-    }
-  }
-
-  // ROS_INFO("msg.data=%d, enableLattice_ = %d", msg.data, enableLattice_);
-  _mutex.unlock();
-#endif
-  // for debug
-  //	ROS_INFO("\n***** EnableLattice = %d  **** \n",enableLattice_,msg.data);
-}
-
-void PlannerSelector::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::Lane const&gt; &amp;event)
-{
-  const ros::M_string &amp;header = event.getConnectionHeader();
-  std::string topic = header.at("topic");
-  const autoware_msgs::Lane *waypoints = event.getMessage().get();
-
-  _mutex.lock();
-
-  if (this-&gt;enableLattice_ &amp;&amp; topic.find("dp") != std::string::npos)
-  {
-    Pubs["final_waypoints"].publish(*waypoints);
-    final_waypoints_dp_ = *waypoints;
-  }
-  else if (!this-&gt;enableLattice_ &amp;&amp; topic.find("astar") != std::string::npos)
-  {
-    if (pastWaypoint)
-    {
-      for (int i = 0; i &lt; config_waypoints_num_; i++)
-      {
-        if (!final_waypoints_astar_.waypoints.empty())
-          final_waypoints_astar_.waypoints.erase(final_waypoints_astar_.waypoints.begin());
-        else
-        {
-          pastWaypoint = false;
-          way_offset = 0;
-        }
-      }
-#if 0
-	    if(final_waypoints_astar_.waypoints.empty()){
-		    int _size = final_waypoints_astar_.waypoints.size();
-		    _size = _size&gt;=5?5:_size;
-		    auto itr = final_waypoints_astar_.waypoints.begin();
-		    for(int i=0; i &lt; 5;  i++){
-			    itr-&gt;twist.twist.linear.x =  (current_velocity_*2 + itr-&gt;twist.twist.linear.x) / 3;
-			    std::cout &lt;&lt; "set linear velocity:" &lt;&lt;  mps2kmph(itr-&gt;twist.twist.linear.x)  &lt;&lt; std::endl; 
-			    itr++;
-		    }
-	    }
-#endif
-      Pubs["final_waypoints"].publish(final_waypoints_astar_);
-    }
-    else
-    {
-      Pubs["final_waypoints"].publish(*waypoints);
-    }
-    final_waypoints_astar_ = *waypoints;
-  }
-
-  // for debug
-  // ROS_INFO("%s, %d-%d-%d", topic.c_str(), closest_waypoint_dp_, closest_waypoint_astar_, this-&gt;enableLattice_);
-  _mutex.unlock();
-}
-
-void PlannerSelector::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
-{
-  current_velocity_ = msg.twist.linear.x;
-}
-
-void PlannerSelector::callbackFromConfig(const autoware_config_msgs::ConfigPlannerSelector &amp;msg)
-{
-  config_latency_num_ = msg.latency_num;
-  config_waypoints_num_ = msg.waypoints_num;
-  config_convergence_num_ = msg.convergence_num;
-
-  ROS_INFO("PARAM_SET-latency:%d, waypoints:%d, convergence:%f", config_latency_num_, config_waypoints_num_,
-           config_convergence_num_);
-}
-
-void PlannerSelector::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event)
-{
-  const ros::M_string &amp;header = event.getConnectionHeader();
-  std::string topic = header.at("topic");
-
-  int temp = event.getMessage().get()-&gt;data;
-  std_msgs::Int32 msg;
-
-#if 1
-  if (topic.find("/dp") == 0)
-  {
-    closest_waypoints_["dp"] = temp;
-
-    if (closest_waypoints_["astar"])
-    {
-      msg.data = closest_waypoint_astar_;
-    }
-    closest_waypoint_dp_ = temp;
-  }
-  else if (topic.find("/astar") == 0)
-  {
-    closest_waypoints_["astar"] = temp;
-    closest_waypoint_astar_ = temp;
-  }
-
-  //  ROS_INFO("PastWaypoint:%s-offset:%d, latency:%d, closest:%d", pastWaypoint?"true":"false", way_offset,
-  //  config_latency_num_,closest_waypoint_astar);
-  if (pastWaypoint &amp;&amp; final_waypoints_astar_.waypoints.size() &gt; closest_waypoint_astar_ + way_offset)
-  {
-    msg.data = closest_waypoint_astar_ + way_offset;
-  }
-  else
-  {
-    msg.data = closest_waypoint_astar_;
-  }
-#endif
-  Pubs["closest_waypoint"].publish(msg);
-}
-}
-
-int main(int argc, char **argv)
-{
-  ros::init(argc, argv, "planner_selector");
-
-  decision_maker::PlannerSelector _psn;
-  ros::spin();
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\include\hermite_curve.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\include\lane_select_core.h" added_lines="30" deleted_lines="19">
				<diff>@@ -33,6 +33,7 @@
 #include "autoware_config_msgs/ConfigLaneSelect.h"
 #include "autoware_msgs/LaneArray.h"
 #include "autoware_msgs/State.h"
+#include "autoware_msgs/VehicleLocation.h"
 #include "hermite_curve.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 
@@ -55,6 +56,8 @@ typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
 
 class LaneSelectNode
 {
+friend class LaneSelectTestClass;
+
 public:
   LaneSelectNode();
   ~LaneSelectNode();
@@ -67,13 +70,14 @@ private:
   ros::NodeHandle private_nh_;
 
   // publisher
-  ros::Publisher pub1_, pub2_, pub3_, pub4_;
+  ros::Publisher pub1_, pub2_, pub3_, pub4_, pub5_;
   ros::Publisher vis_pub1_;
 
   // subscriber
   ros::Subscriber sub1_, sub2_, sub3_, sub4_, sub5_, sub6_;
 
   // variables
+  int32_t lane_array_id_;
   int32_t current_lane_idx_;  // the index of the lane we are driving
   int32_t right_lane_idx_;
   int32_t left_lane_idx_;
@@ -93,12 +97,12 @@ private:
   std::string current_state_;
 
   // callbacks
-  void callbackFromLaneArray(const autoware_msgs::LaneArrayConstPtr &amp;msg);
-  void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg);
-  void callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr &amp;msg);
-  void callbackFromState(const std_msgs::StringConstPtr &amp;msg);
-  void callbackFromStates(const autoware_msgs::StateConstPtr &amp;msg);
-  void callbackFromConfig(const autoware_config_msgs::ConfigLaneSelectConstPtr &amp;msg);
+  void callbackFromLaneArray(const autoware_msgs::LaneArrayConstPtr&amp; msg);
+  void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr&amp; msg);
+  void callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr&amp; msg);
+  void callbackFromState(const std_msgs::StringConstPtr&amp; msg);
+  void callbackFromDecisionMakerState(const std_msgs::StringConstPtr&amp; msg);
+  void callbackFromConfig(const autoware_config_msgs::ConfigLaneSelectConstPtr&amp; msg);
 
   // initializer
   void initForROS();
@@ -117,10 +121,11 @@ private:
   void resetSubscriptionFlag();
   bool isAllTopicsSubscribed();
   void processing();
-  void publishLane(const autoware_msgs::Lane &amp;lane);
-  void publishLaneID(const autoware_msgs::Lane &amp;lane);
+  void publishLane(const autoware_msgs::Lane&amp; lane);
+  void publishLaneID(const autoware_msgs::Lane&amp; lane);
   void publishClosestWaypoint(const int32_t clst_wp);
   void publishChangeFlag(const ChangeFlag flag);
+  void publishVehicleLocation(const int32_t clst_wp, const int32_t larray_id);
   bool getClosestWaypointNumberForEachLanes();
   int32_t findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec, const geometry_msgs::Point p);
   void findCurrentLane();
@@ -128,22 +133,28 @@ private:
   void changeLane();
   void updateChangeFlag();
   void createLaneForChange();
-  int32_t getClosestLaneChangeWaypointNumber(const std::vector&lt;autoware_msgs::Waypoint&gt; &amp;wps, int32_t cl_wp);
+  int32_t getClosestLaneChangeWaypointNumber(const std::vector&lt;autoware_msgs::Waypoint&gt;&amp; wps, int32_t cl_wp);
+
+  // spinOnce for test
+  void spinOnce()
+  {
+    ros::spinOnce();
+  }
 };
 
-int32_t getClosestWaypointNumber(const autoware_msgs::Lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
-                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number,
+int32_t getClosestWaypointNumber(const autoware_msgs::Lane&amp; current_lane, const geometry_msgs::Pose&amp; current_pose,
+                                 const geometry_msgs::Twist&amp; current_velocity, const int32_t previous_number,
                                  const double distance_threshold);
 
-double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geometry_msgs::Point &amp;target2);
+double getTwoDimensionalDistance(const geometry_msgs::Point&amp; target1, const geometry_msgs::Point&amp; target2);
 
-geometry_msgs::Point convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point,
-                                                        const geometry_msgs::Pose &amp;pose);
+geometry_msgs::Point convertPointIntoRelativeCoordinate(const geometry_msgs::Point&amp; input_point,
+                                                        const geometry_msgs::Pose&amp; pose);
 
-geometry_msgs::Point convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point,
-                                                     const geometry_msgs::Pose &amp;pose);
-double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry_msgs::Pose &amp;current_pose);
-bool getLinearEquation(geometry_msgs::Point start, geometry_msgs::Point end, double *a, double *b, double *c);
+geometry_msgs::Point convertPointIntoWorldCoordinate(const geometry_msgs::Point&amp; input_point,
+                                                     const geometry_msgs::Pose&amp; pose);
+double getRelativeAngle(const geometry_msgs::Pose&amp; waypoint_pose, const geometry_msgs::Pose&amp; current_pose);
+bool getLinearEquation(geometry_msgs::Point start, geometry_msgs::Point end, double* a, double* b, double* c);
 double getDistanceBetweenLineAndPoint(geometry_msgs::Point point, double sa, double b, double c);
 }
 #endif  // LANE_SELECT_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" added_lines="479" deleted_lines="443">
				<diff>@@ -18,7 +18,7 @@
 
 #ifdef DEBUG
 #include &lt;sstream&gt;
-#endif // DEBUG
+#endif  // DEBUG
 
 #include &lt;ros/console.h&gt;
 
@@ -28,16 +28,16 @@
 
 #include &lt;lane_planner/lane_planner_vmap.hpp&gt;
 
-namespace {
-
-double config_acceleration = 1; // m/s^2
-double config_stopline_search_radius = 1; // meter
+namespace
+{
+double config_acceleration = 1;            // m/s^2
+double config_stopline_search_radius = 1;  // meter
 int config_number_of_zeros_ahead = 0;
 int config_number_of_zeros_behind = 0;
 int config_number_of_smoothing_count = 0;
 
 int waypoint_max;
-double search_radius; // meter
+double search_radius;  // meter
 double curve_weight;
 double crossroad_weight;
 double clothoid_weight;
@@ -58,549 +58,585 @@ autoware_msgs::LaneArray cached_waypoint;
 visualization_msgs::Marker debug_marker;
 ros::Publisher marker_pub;
 int marker_cnt;
-#endif // DEBUG
+#endif  // DEBUG
 
 autoware_msgs::Lane create_new_lane(const autoware_msgs::Lane&amp; lane, const std_msgs::Header&amp; header)
 {
-	autoware_msgs::Lane l = lane;
-	l.header = header;
+  autoware_msgs::Lane l = lane;
+  l.header = header;
 
-	for (autoware_msgs::Waypoint&amp; w : l.waypoints) {
-		w.pose.header = header;
-		w.twist.header = header;
-	}
+  for (autoware_msgs::Waypoint&amp; w : l.waypoints)
+  {
+    w.pose.header = header;
+    w.twist.header = header;
+  }
 
-	return l;
+  return l;
 }
 
-autoware_msgs::Lane apply_acceleration(const autoware_msgs::Lane&amp; lane, double acceleration,
-					   size_t start_index, size_t fixed_cnt, double fixed_vel)
+autoware_msgs::Lane apply_acceleration(const autoware_msgs::Lane&amp; lane, double acceleration, size_t start_index,
+                                       size_t fixed_cnt, double fixed_vel)
 {
-	autoware_msgs::Lane l = lane;
-
-	if (fixed_cnt == 0)
-		return l;
-
-	double square_vel = fixed_vel * fixed_vel;
-	double distance = 0;
-	for (size_t i = start_index; i &lt; l.waypoints.size(); ++i) {
-		if (i - start_index &lt; fixed_cnt) {
-			l.waypoints[i].twist.twist.linear.x = fixed_vel;
-			continue;
-		}
-
-		geometry_msgs::Point a = l.waypoints[i - 1].pose.pose.position;
-		geometry_msgs::Point b = l.waypoints[i].pose.pose.position;
-		distance += hypot(b.x - a.x, b.y - a.y);
-
-		double v = sqrt(square_vel + 2 * acceleration * distance);
-		if (v &lt; l.waypoints[i].twist.twist.linear.x)
-			l.waypoints[i].twist.twist.linear.x = v;
-		else
-			break;
-	}
-
-	return l;
+  autoware_msgs::Lane l = lane;
+
+  if (fixed_cnt == 0)
+    return l;
+
+  double square_vel = fixed_vel * fixed_vel;
+  double distance = 0;
+  for (size_t i = start_index; i &lt; l.waypoints.size(); ++i)
+  {
+    if (i - start_index &lt; fixed_cnt)
+    {
+      l.waypoints[i].twist.twist.linear.x = fixed_vel;
+      continue;
+    }
+
+    geometry_msgs::Point a = l.waypoints[i - 1].pose.pose.position;
+    geometry_msgs::Point b = l.waypoints[i].pose.pose.position;
+    distance += hypot(b.x - a.x, b.y - a.y);
+
+    double v = sqrt(square_vel + 2 * acceleration * distance);
+    if (v &lt; l.waypoints[i].twist.twist.linear.x)
+      l.waypoints[i].twist.twist.linear.x = v;
+    else
+      break;
+  }
+
+  return l;
 }
 
 autoware_msgs::Lane apply_crossroad_acceleration(const autoware_msgs::Lane&amp; lane, double acceleration)
 {
-	autoware_msgs::Lane l = lane;
-
-	bool crossroad = false;
-	std::vector&lt;size_t&gt; start_indexes;
-	std::vector&lt;size_t&gt; end_indexes;
-	for (size_t i = 0; i &lt; l.waypoints.size(); ++i) {
-		vector_map::DTLane dtlane = lane_planner::vmap::create_vector_map_dtlane(l.waypoints[i].dtlane);
-		if (i == 0) {
-			crossroad = lane_planner::vmap::is_crossroad_dtlane(dtlane);
-			continue;
-		}
-		if (crossroad) {
-			if (!lane_planner::vmap::is_crossroad_dtlane(dtlane)) {
-				end_indexes.push_back(i - 1);
-				crossroad = false;
-			}
-		} else {
-			if (lane_planner::vmap::is_crossroad_dtlane(dtlane)) {
-				start_indexes.push_back(i);
-				crossroad = true;
-			}
-		}
-	}
-	if (start_indexes.empty() &amp;&amp; end_indexes.empty())
-		return l;
-
-	for (const size_t i : end_indexes)
-		l = apply_acceleration(l, acceleration, i, 1, l.waypoints[i].twist.twist.linear.x);
-
-	std::reverse(l.waypoints.begin(), l.waypoints.end());
-
-	std::vector&lt;size_t&gt; reverse_start_indexes;
-	for (const size_t i : start_indexes)
-		reverse_start_indexes.push_back(l.waypoints.size() - i - 1);
-	std::reverse(reverse_start_indexes.begin(), reverse_start_indexes.end());
-
-	for (const size_t i : reverse_start_indexes)
-		l = apply_acceleration(l, acceleration, i, 1, l.waypoints[i].twist.twist.linear.x);
-
-	std::reverse(l.waypoints.begin(), l.waypoints.end());
-
-	return l;
+  autoware_msgs::Lane l = lane;
+
+  bool crossroad = false;
+  std::vector&lt;size_t&gt; start_indexes;
+  std::vector&lt;size_t&gt; end_indexes;
+  for (size_t i = 0; i &lt; l.waypoints.size(); ++i)
+  {
+    vector_map::DTLane dtlane = lane_planner::vmap::create_vector_map_dtlane(l.waypoints[i].dtlane);
+    if (i == 0)
+    {
+      crossroad = lane_planner::vmap::is_crossroad_dtlane(dtlane);
+      continue;
+    }
+    if (crossroad)
+    {
+      if (!lane_planner::vmap::is_crossroad_dtlane(dtlane))
+      {
+        end_indexes.push_back(i - 1);
+        crossroad = false;
+      }
+    }
+    else
+    {
+      if (lane_planner::vmap::is_crossroad_dtlane(dtlane))
+      {
+        start_indexes.push_back(i);
+        crossroad = true;
+      }
+    }
+  }
+  if (start_indexes.empty() &amp;&amp; end_indexes.empty())
+    return l;
+
+  for (const size_t i : end_indexes)
+    l = apply_acceleration(l, acceleration, i, 1, l.waypoints[i].twist.twist.linear.x);
+
+  std::reverse(l.waypoints.begin(), l.waypoints.end());
+
+  std::vector&lt;size_t&gt; reverse_start_indexes;
+  for (const size_t i : start_indexes)
+    reverse_start_indexes.push_back(l.waypoints.size() - i - 1);
+  std::reverse(reverse_start_indexes.begin(), reverse_start_indexes.end());
+
+  for (const size_t i : reverse_start_indexes)
+    l = apply_acceleration(l, acceleration, i, 1, l.waypoints[i].twist.twist.linear.x);
+
+  std::reverse(l.waypoints.begin(), l.waypoints.end());
+
+  return l;
 }
 
 autoware_msgs::Lane apply_stopline_acceleration(const autoware_msgs::Lane&amp; lane, double acceleration,
-						    const lane_planner::vmap::VectorMap&amp; fine_vmap, size_t ahead_cnt,
-						    size_t behind_cnt)
+                                                const lane_planner::vmap::VectorMap&amp; fine_vmap, size_t ahead_cnt,
+                                                size_t behind_cnt)
 {
-	autoware_msgs::Lane l = lane;
+  autoware_msgs::Lane l = lane;
 
-	std::vector&lt;size_t&gt; indexes;
-	for (size_t i = 0; i &lt; fine_vmap.stoplines.size(); ++i) {
-		if (fine_vmap.stoplines[i].id &gt;= 0)
-			indexes.push_back(i);
-	}
-	if (indexes.empty())
-		return l;
+  std::vector&lt;size_t&gt; indexes;
+  for (size_t i = 0; i &lt; fine_vmap.stoplines.size(); ++i)
+  {
+    if (fine_vmap.stoplines[i].id &gt;= 0)
+      indexes.push_back(i);
+  }
+  if (indexes.empty())
+    return l;
 
-	for (const size_t i : indexes)
-		l = apply_acceleration(l, acceleration, i, behind_cnt + 1, 0);
+  for (const size_t i : indexes)
+    l = apply_acceleration(l, acceleration, i, behind_cnt + 1, 0);
 
-	std::reverse(l.waypoints.begin(), l.waypoints.end());
+  std::reverse(l.waypoints.begin(), l.waypoints.end());
 
-	std::vector&lt;size_t&gt; reverse_indexes;
-	for (const size_t i : indexes)
-		reverse_indexes.push_back(l.waypoints.size() - i - 1);
-	std::reverse(reverse_indexes.begin(), reverse_indexes.end());
+  std::vector&lt;size_t&gt; reverse_indexes;
+  for (const size_t i : indexes)
+    reverse_indexes.push_back(l.waypoints.size() - i - 1);
+  std::reverse(reverse_indexes.begin(), reverse_indexes.end());
 
-	for (const size_t i : reverse_indexes)
-		l = apply_acceleration(l, acceleration, i, ahead_cnt + 1, 0);
+  for (const size_t i : reverse_indexes)
+    l = apply_acceleration(l, acceleration, i, ahead_cnt + 1, 0);
 
-	std::reverse(l.waypoints.begin(), l.waypoints.end());
+  std::reverse(l.waypoints.begin(), l.waypoints.end());
 
-	return l;
+  return l;
 }
 
 std::vector&lt;vector_map::Point&gt; create_stop_points(const lane_planner::vmap::VectorMap&amp; vmap)
 {
-	std::vector&lt;vector_map::Point&gt; stop_points;
-	for (const vector_map::StopLine&amp; s : vmap.stoplines) {
-		for (const vector_map::Lane&amp; l : vmap.lanes) {
-			if (l.lnid != s.linkid)
-				continue;
-			for (const vector_map::Node&amp; n : vmap.nodes) {
-				if (n.nid != l.bnid)
-					continue;
-				for (const vector_map::Point&amp; p : vmap.points) {
-					if (p.pid != n.pid)
-						continue;
-					bool hit = false;
-					for (const vector_map::Point&amp; sp : stop_points) {
-						if (sp.pid == p.pid) {
-							hit = true;
-							break;
-						}
-					}
-					if (!hit)
-						stop_points.push_back(p);
-				}
-			}
-		}
-	}
-
-	return stop_points;
+  std::vector&lt;vector_map::Point&gt; stop_points;
+  for (const vector_map::StopLine&amp; s : vmap.stoplines)
+  {
+    for (const vector_map::Lane&amp; l : vmap.lanes)
+    {
+      if (l.lnid != s.linkid)
+        continue;
+      for (const vector_map::Node&amp; n : vmap.nodes)
+      {
+        if (n.nid != l.bnid)
+          continue;
+        for (const vector_map::Point&amp; p : vmap.points)
+        {
+          if (p.pid != n.pid)
+            continue;
+          bool hit = false;
+          for (const vector_map::Point&amp; sp : stop_points)
+          {
+            if (sp.pid == p.pid)
+            {
+              hit = true;
+              break;
+            }
+          }
+          if (!hit)
+            stop_points.push_back(p);
+        }
+      }
+    }
+  }
+
+  return stop_points;
 }
 
-std::vector&lt;size_t&gt; create_stop_indexes(const lane_planner::vmap::VectorMap&amp; vmap,
-					const autoware_msgs::Lane&amp; lane, double stopline_search_radius)
+std::vector&lt;size_t&gt; create_stop_indexes(const lane_planner::vmap::VectorMap&amp; vmap, const autoware_msgs::Lane&amp; lane,
+                                        double stopline_search_radius)
 {
-	std::vector&lt;size_t&gt; stop_indexes;
-	for (const vector_map::Point&amp; p : create_stop_points(vmap)) {
-		size_t index = SIZE_MAX;
-		double distance = DBL_MAX;
-		for (size_t i = 0; i &lt; lane.waypoints.size(); ++i) {
-			vector_map::Point point =
-				lane_planner::vmap::create_vector_map_point(lane.waypoints[i].pose.pose.position);
-			double d = hypot(p.bx - point.bx, p.ly - point.ly);
-			if (d &lt;= distance) {
-				index = i;
-				distance = d;
-			}
-		}
-		if (index != SIZE_MAX &amp;&amp; distance &lt;= stopline_search_radius) {
-			stop_indexes.push_back(index);
-		}
-	}
-	std::sort(stop_indexes.begin(), stop_indexes.end());
-
-	return stop_indexes;
+  std::vector&lt;size_t&gt; stop_indexes;
+  for (const vector_map::Point&amp; p : create_stop_points(vmap))
+  {
+    size_t index = SIZE_MAX;
+    double distance = DBL_MAX;
+    for (size_t i = 0; i &lt; lane.waypoints.size(); ++i)
+    {
+      vector_map::Point point = lane_planner::vmap::create_vector_map_point(lane.waypoints[i].pose.pose.position);
+      double d = hypot(p.bx - point.bx, p.ly - point.ly);
+      if (d &lt;= distance)
+      {
+        index = i;
+        distance = d;
+      }
+    }
+    if (index != SIZE_MAX &amp;&amp; distance &lt;= stopline_search_radius)
+    {
+      stop_indexes.push_back(index);
+    }
+  }
+  std::sort(stop_indexes.begin(), stop_indexes.end());
+
+  return stop_indexes;
 }
 
 autoware_msgs::Lane apply_stopline_acceleration(const autoware_msgs::Lane&amp; lane, double acceleration,
-						    double stopline_search_radius, size_t ahead_cnt, size_t behind_cnt)
+                                                double stopline_search_radius, size_t ahead_cnt, size_t behind_cnt)
 {
-	autoware_msgs::Lane l = lane;
+  autoware_msgs::Lane l = lane;
 
-	std::vector&lt;size_t&gt; indexes = create_stop_indexes(lane_vmap, l, stopline_search_radius);
-	if (indexes.empty())
-		return l;
+  std::vector&lt;size_t&gt; indexes = create_stop_indexes(lane_vmap, l, stopline_search_radius);
+  if (indexes.empty())
+    return l;
 
-	for (const size_t i : indexes)
-		l = apply_acceleration(l, acceleration, i, behind_cnt + 1, 0);
+  for (const size_t i : indexes)
+    l = apply_acceleration(l, acceleration, i, behind_cnt + 1, 0);
 
-	std::reverse(l.waypoints.begin(), l.waypoints.end());
+  std::reverse(l.waypoints.begin(), l.waypoints.end());
 
-	std::vector&lt;size_t&gt; reverse_indexes;
-	for (const size_t i : indexes)
-		reverse_indexes.push_back(l.waypoints.size() - i - 1);
-	std::reverse(reverse_indexes.begin(), reverse_indexes.end());
+  std::vector&lt;size_t&gt; reverse_indexes;
+  for (const size_t i : indexes)
+    reverse_indexes.push_back(l.waypoints.size() - i - 1);
+  std::reverse(reverse_indexes.begin(), reverse_indexes.end());
 
-	for (const size_t i : reverse_indexes)
-		l = apply_acceleration(l, acceleration, i, ahead_cnt + 1, 0);
+  for (const size_t i : reverse_indexes)
+    l = apply_acceleration(l, acceleration, i, ahead_cnt + 1, 0);
 
-	std::reverse(l.waypoints.begin(), l.waypoints.end());
+  std::reverse(l.waypoints.begin(), l.waypoints.end());
 
-	return l;
+  return l;
 }
 
 bool is_fine_vmap(const lane_planner::vmap::VectorMap&amp; fine_vmap, const autoware_msgs::Lane&amp; lane)
 {
-	if (fine_vmap.points.size() != lane.waypoints.size())
-		return false;
-
-	for (size_t i = 0; i &lt; fine_vmap.points.size(); ++i) {
-		vector_map::Point point =
-			lane_planner::vmap::create_vector_map_point(lane.waypoints[i].pose.pose.position);
-		double distance = hypot(fine_vmap.points[i].bx - point.bx, fine_vmap.points[i].ly - point.ly);
-		if (distance &gt; 0.1)
-			return false;
-	}
-
-	return true;
+  if (fine_vmap.points.size() != lane.waypoints.size())
+    return false;
+
+  for (size_t i = 0; i &lt; fine_vmap.points.size(); ++i)
+  {
+    vector_map::Point point = lane_planner::vmap::create_vector_map_point(lane.waypoints[i].pose.pose.position);
+    double distance = hypot(fine_vmap.points[i].bx - point.bx, fine_vmap.points[i].ly - point.ly);
+    if (distance &gt; 0.1)
+      return false;
+  }
+
+  return true;
 }
 
 double create_reduction(const lane_planner::vmap::VectorMap&amp; fine_vmap, int index)
 {
-	const vector_map::DTLane&amp; dtlane = fine_vmap.dtlanes[index];
+  const vector_map::DTLane&amp; dtlane = fine_vmap.dtlanes[index];
 
-	if (lane_planner::vmap::is_straight_dtlane(dtlane))
-		return 1;
+  if (lane_planner::vmap::is_straight_dtlane(dtlane))
+    return 1;
 
-	if (lane_planner::vmap::is_curve_dtlane(dtlane)) {
-		if (lane_planner::vmap::is_crossroad_dtlane(dtlane))
-			return lane_planner::vmap::compute_reduction(dtlane, crossroad_radius_min * crossroad_weight);
+  if (lane_planner::vmap::is_curve_dtlane(dtlane))
+  {
+    if (lane_planner::vmap::is_crossroad_dtlane(dtlane))
+      return lane_planner::vmap::compute_reduction(dtlane, crossroad_radius_min * crossroad_weight);
 
-		if (lane_planner::vmap::is_connection_dtlane(fine_vmap, index))
-			return 1;
+    if (lane_planner::vmap::is_connection_dtlane(fine_vmap, index))
+      return 1;
 
-		return lane_planner::vmap::compute_reduction(dtlane, curve_radius_min * curve_weight);
-	}
+    return lane_planner::vmap::compute_reduction(dtlane, curve_radius_min * curve_weight);
+  }
 
-	if (lane_planner::vmap::is_clothoid_dtlane(dtlane))
-		return lane_planner::vmap::compute_reduction(dtlane, clothoid_radius_min * clothoid_weight);
+  if (lane_planner::vmap::is_clothoid_dtlane(dtlane))
+    return lane_planner::vmap::compute_reduction(dtlane, clothoid_radius_min * clothoid_weight);
 
-	return 1;
+  return 1;
 }
 
 #ifdef DEBUG
 std_msgs::ColorRGBA create_color(int index)
 {
-	std_msgs::ColorRGBA color;
-	switch (index) {
-	case 0:
-		color.r = 0;
-		color.g = 0;
-		color.b = 0;
-		break;
-	case 1:
-		color.r = 0;
-		color.g = 0;
-		color.b = 1;
-		break;
-	case 2:
-		color.r = 0;
-		color.g = 1;
-		color.b = 0;
-		break;
-	case 3:
-		color.r = 0;
-		color.g = 1;
-		color.b = 1;
-		break;
-	case 4:
-		color.r = 1;
-		color.g = 0;
-		color.b = 0;
-		break;
-	case 5:
-		color.r = 1;
-		color.g = 0;
-		color.b = 1;
-		break;
-	case 6:
-		color.r = 1;
-		color.g = 1;
-		color.b = 0;
-		break;
-	default:
-		color.r = 1;
-		color.g = 1;
-		color.b = 1;
-	}
-	color.a = 1;
-
-	return color;
+  std_msgs::ColorRGBA color;
+  switch (index)
+  {
+    case 0:
+      color.r = 0;
+      color.g = 0;
+      color.b = 0;
+      break;
+    case 1:
+      color.r = 0;
+      color.g = 0;
+      color.b = 1;
+      break;
+    case 2:
+      color.r = 0;
+      color.g = 1;
+      color.b = 0;
+      break;
+    case 3:
+      color.r = 0;
+      color.g = 1;
+      color.b = 1;
+      break;
+    case 4:
+      color.r = 1;
+      color.g = 0;
+      color.b = 0;
+      break;
+    case 5:
+      color.r = 1;
+      color.g = 0;
+      color.b = 1;
+      break;
+    case 6:
+      color.r = 1;
+      color.g = 1;
+      color.b = 0;
+      break;
+    default:
+      color.r = 1;
+      color.g = 1;
+      color.b = 1;
+  }
+  color.a = 1;
+
+  return color;
 }
-#endif // DEBUG
+#endif  // DEBUG
 
 void create_waypoint(const autoware_msgs::LaneArray&amp; msg)
 {
-	std_msgs::Header header;
-	header.stamp = ros::Time::now();
-	header.frame_id = frame_id;
-
-	cached_waypoint.lanes.clear();
-	cached_waypoint.lanes.shrink_to_fit();
-	for (const autoware_msgs::Lane&amp; l : msg.lanes)
-		cached_waypoint.lanes.push_back(create_new_lane(l, header));
-	if (all_vmap.points.empty() || all_vmap.lanes.empty() || all_vmap.nodes.empty() ||
-	    all_vmap.stoplines.empty() || all_vmap.dtlanes.empty()) {
-		traffic_pub.publish(cached_waypoint);
-		return;
-	}
+  std_msgs::Header header;
+  header.stamp = ros::Time::now();
+  header.frame_id = frame_id;
+
+  cached_waypoint.lanes.clear();
+  cached_waypoint.lanes.shrink_to_fit();
+  cached_waypoint.id = msg.id;
+  for (const autoware_msgs::Lane&amp; l : msg.lanes)
+    cached_waypoint.lanes.push_back(create_new_lane(l, header));
+  if (all_vmap.points.empty() || all_vmap.lanes.empty() || all_vmap.nodes.empty() || all_vmap.stoplines.empty() ||
+      all_vmap.dtlanes.empty())
+  {
+    traffic_pub.publish(cached_waypoint);
+    return;
+  }
 
 #ifdef DEBUG
-	marker_cnt = msg.lanes.size();
-#endif // DEBUG
-
-	autoware_msgs::LaneArray traffic_waypoint;
-	autoware_msgs::LaneArray red_waypoint;
-	autoware_msgs::LaneArray green_waypoint;
-	for (size_t i = 0; i &lt; msg.lanes.size(); ++i) {
-		autoware_msgs::Lane lane = create_new_lane(msg.lanes[i], header);
-
-		lane_planner::vmap::VectorMap coarse_vmap =
-			lane_planner::vmap::create_coarse_vmap_from_lane(lane);
-		if (coarse_vmap.points.size() &lt; 2) {
-			traffic_waypoint.lanes.push_back(lane);
-			continue;
-		}
-
-		lane_planner::vmap::VectorMap fine_vmap =
-			lane_planner::vmap::create_fine_vmap(lane_vmap, lane_planner::vmap::LNO_ALL, coarse_vmap,
-							     search_radius, waypoint_max);
-		if (fine_vmap.points.size() &lt; 2 || !is_fine_vmap(fine_vmap, lane)) {
-			traffic_waypoint.lanes.push_back(lane);
-			green_waypoint.lanes.push_back(lane);
-			lane = apply_stopline_acceleration(lane, config_acceleration, config_stopline_search_radius,
-							   config_number_of_zeros_ahead,
-							   config_number_of_zeros_behind);
-			red_waypoint.lanes.push_back(lane);
-			continue;
-		}
-
-		for (size_t j = 0; j &lt; lane.waypoints.size(); ++j) {
-			lane.waypoints[j].twist.twist.linear.x *= create_reduction(fine_vmap, j);
-			if (fine_vmap.dtlanes[j].did &gt;= 0) {
-				lane.waypoints[j].dtlane =
-					lane_planner::vmap::create_waypoint_follower_dtlane(fine_vmap.dtlanes[j]);
-			}
-		}
-
-		/* velocity smoothing */
-		for(int k = 0; k &lt; config_number_of_smoothing_count; ++k){
-			autoware_msgs::Lane temp_lane = lane;
-			if(lane.waypoints.size() &gt;= 3){
-				for (size_t j = 1; j &lt; lane.waypoints.size()-1; ++j) {
-					if(lane.waypoints.at(j).twist.twist.linear.x != 0)
-					{
-						lane.waypoints[j].twist.twist.linear.x = 
-							(temp_lane.waypoints.at(j-1).twist.twist.linear.x + 
-							 temp_lane.waypoints.at(j).twist.twist.linear.x + 
-							 temp_lane.waypoints.at(j+1).twist.twist.linear.x) / 3 ;
-					}
-				}
-			}
-		}
-
-
-		lane = apply_crossroad_acceleration(lane, config_acceleration);
-
-		traffic_waypoint.lanes.push_back(lane);
-		green_waypoint.lanes.push_back(lane);
-
-		lane = apply_stopline_acceleration(lane, config_acceleration, fine_vmap, config_number_of_zeros_ahead,
-						   config_number_of_zeros_behind);
-
-		red_waypoint.lanes.push_back(lane);
+  marker_cnt = msg.lanes.size();
+#endif  // DEBUG
+
+  autoware_msgs::LaneArray traffic_waypoint;
+  autoware_msgs::LaneArray red_waypoint;
+  autoware_msgs::LaneArray green_waypoint;
+  traffic_waypoint.id = red_waypoint.id = green_waypoint.id = msg.id;
+  for (size_t i = 0; i &lt; msg.lanes.size(); ++i)
+  {
+    autoware_msgs::Lane lane = create_new_lane(msg.lanes[i], header);
+
+    lane_planner::vmap::VectorMap coarse_vmap = lane_planner::vmap::create_coarse_vmap_from_lane(lane);
+    if (coarse_vmap.points.size() &lt; 2)
+    {
+      traffic_waypoint.lanes.push_back(lane);
+      continue;
+    }
+
+    lane_planner::vmap::VectorMap fine_vmap = lane_planner::vmap::create_fine_vmap(
+        lane_vmap, lane_planner::vmap::LNO_ALL, coarse_vmap, search_radius, waypoint_max);
+    if (fine_vmap.points.size() &lt; 2 || !is_fine_vmap(fine_vmap, lane))
+    {
+      traffic_waypoint.lanes.push_back(lane);
+      green_waypoint.lanes.push_back(lane);
+      lane = apply_stopline_acceleration(lane, config_acceleration, config_stopline_search_radius,
+                                         config_number_of_zeros_ahead, config_number_of_zeros_behind);
+      red_waypoint.lanes.push_back(lane);
+      continue;
+    }
+
+    for (size_t j = 0; j &lt; lane.waypoints.size(); ++j)
+    {
+      lane.waypoints[j].twist.twist.linear.x *= create_reduction(fine_vmap, j);
+      if (fine_vmap.dtlanes[j].did &gt;= 0)
+      {
+        lane.waypoints[j].dtlane = lane_planner::vmap::create_waypoint_follower_dtlane(fine_vmap.dtlanes[j]);
+      }
+    }
+
+    /* velocity smoothing */
+    for (int k = 0; k &lt; config_number_of_smoothing_count; ++k)
+    {
+      autoware_msgs::Lane temp_lane = lane;
+      if (lane.waypoints.size() &gt;= 3)
+      {
+        for (size_t j = 1; j &lt; lane.waypoints.size() - 1; ++j)
+        {
+          if (lane.waypoints.at(j).twist.twist.linear.x != 0)
+          {
+            lane.waypoints[j].twist.twist.linear.x =
+                (temp_lane.waypoints.at(j - 1).twist.twist.linear.x + temp_lane.waypoints.at(j).twist.twist.linear.x +
+                 temp_lane.waypoints.at(j + 1).twist.twist.linear.x) /
+                3;
+          }
+        }
+      }
+    }
+
+    lane = apply_crossroad_acceleration(lane, config_acceleration);
+
+    traffic_waypoint.lanes.push_back(lane);
+    green_waypoint.lanes.push_back(lane);
+
+    lane = apply_stopline_acceleration(lane, config_acceleration, fine_vmap, config_number_of_zeros_ahead,
+                                       config_number_of_zeros_behind);
+
+    red_waypoint.lanes.push_back(lane);
 
 #ifdef DEBUG
-		std::stringstream ss;
-		ss &lt;&lt; "_" &lt;&lt; i;
+    std::stringstream ss;
+    ss &lt;&lt; "_" &lt;&lt; i;
 
-		visualization_msgs::Marker m = debug_marker;
-		m.ns = "lane" + ss.str();
-		m.color = create_color(i);
+    visualization_msgs::Marker m = debug_marker;
+    m.ns = "lane" + ss.str();
+    m.color = create_color(i);
 
-		lane_planner::vmap::publish_add_marker(marker_pub, m, fine_vmap.points);
-#endif // DEBUG
-	}
+    lane_planner::vmap::publish_add_marker(marker_pub, m, fine_vmap.points);
+#endif  // DEBUG
+  }
 
-	traffic_pub.publish(traffic_waypoint);
-	red_pub.publish(red_waypoint);
-	green_pub.publish(green_waypoint);
+  traffic_pub.publish(traffic_waypoint);
+  red_pub.publish(red_waypoint);
+  green_pub.publish(green_waypoint);
 }
 
 void update_values()
 {
-	if (all_vmap.points.empty() || all_vmap.lanes.empty() || all_vmap.nodes.empty() ||
-	    all_vmap.stoplines.empty() || all_vmap.dtlanes.empty())
-		return;
-
-	lane_vmap = lane_planner::vmap::create_lane_vmap(all_vmap, lane_planner::vmap::LNO_ALL);
-
-	curve_radius_min = lane_planner::vmap::RADIUS_MAX;
-	crossroad_radius_min = lane_planner::vmap::RADIUS_MAX;
-	clothoid_radius_min = lane_planner::vmap::RADIUS_MAX;
-	for (const vector_map::DTLane&amp; d : lane_vmap.dtlanes) {
-		double radius_min = fabs(d.r);
-		if (lane_planner::vmap::is_curve_dtlane(d)) {
-			if (lane_planner::vmap::is_crossroad_dtlane(d)) {
-				if (radius_min &lt; crossroad_radius_min)
-					crossroad_radius_min = radius_min;
-			} else {
-				if (radius_min &lt; curve_radius_min)
-					curve_radius_min = radius_min;
-			}
-		} else if (lane_planner::vmap::is_clothoid_dtlane(d)) {
-			if (radius_min &lt; clothoid_radius_min)
-				clothoid_radius_min = radius_min;
-		}
-	}
+  if (all_vmap.points.empty() || all_vmap.lanes.empty() || all_vmap.nodes.empty() || all_vmap.stoplines.empty() ||
+      all_vmap.dtlanes.empty())
+    return;
+
+  lane_vmap = lane_planner::vmap::create_lane_vmap(all_vmap, lane_planner::vmap::LNO_ALL);
+
+  curve_radius_min = lane_planner::vmap::RADIUS_MAX;
+  crossroad_radius_min = lane_planner::vmap::RADIUS_MAX;
+  clothoid_radius_min = lane_planner::vmap::RADIUS_MAX;
+  for (const vector_map::DTLane&amp; d : lane_vmap.dtlanes)
+  {
+    double radius_min = fabs(d.r);
+    if (lane_planner::vmap::is_curve_dtlane(d))
+    {
+      if (lane_planner::vmap::is_crossroad_dtlane(d))
+      {
+        if (radius_min &lt; crossroad_radius_min)
+          crossroad_radius_min = radius_min;
+      }
+      else
+      {
+        if (radius_min &lt; curve_radius_min)
+          curve_radius_min = radius_min;
+      }
+    }
+    else if (lane_planner::vmap::is_clothoid_dtlane(d))
+    {
+      if (radius_min &lt; clothoid_radius_min)
+        clothoid_radius_min = radius_min;
+    }
+  }
 
 #ifdef DEBUG
-	for (int i = 0; i &lt; marker_cnt; ++i) {
-		std::stringstream ss;
-		ss &lt;&lt; "_" &lt;&lt; i;
-
-		visualization_msgs::Marker m = debug_marker;
-		m.ns = "lane" + ss.str();
-
-		lane_planner::vmap::publish_delete_marker(marker_pub, m);
-	}
-	marker_cnt = 0;
-#endif // DEBUG
-
-	if (!cached_waypoint.lanes.empty()) {
-		autoware_msgs::LaneArray update_waypoint = cached_waypoint;
-		create_waypoint(update_waypoint);
-	}
+  for (int i = 0; i &lt; marker_cnt; ++i)
+  {
+    std::stringstream ss;
+    ss &lt;&lt; "_" &lt;&lt; i;
+
+    visualization_msgs::Marker m = debug_marker;
+    m.ns = "lane" + ss.str();
+
+    lane_planner::vmap::publish_delete_marker(marker_pub, m);
+  }
+  marker_cnt = 0;
+#endif  // DEBUG
+
+  if (!cached_waypoint.lanes.empty())
+  {
+    autoware_msgs::LaneArray update_waypoint = cached_waypoint;
+    create_waypoint(update_waypoint);
+  }
 }
 
 void cache_point(const vector_map::PointArray&amp; msg)
 {
-	all_vmap.points = msg.data;
-	update_values();
+  all_vmap.points = msg.data;
+  update_values();
 }
 
 void cache_lane(const vector_map::LaneArray&amp; msg)
 {
-	all_vmap.lanes = msg.data;
-	update_values();
+  all_vmap.lanes = msg.data;
+  update_values();
 }
 
 void cache_node(const vector_map::NodeArray&amp; msg)
 {
-	all_vmap.nodes = msg.data;
-	update_values();
+  all_vmap.nodes = msg.data;
+  update_values();
 }
 
 void cache_stopline(const vector_map::StopLineArray&amp; msg)
 {
-	all_vmap.stoplines = msg.data;
-	update_values();
+  all_vmap.stoplines = msg.data;
+  update_values();
 }
 
 void cache_dtlane(const vector_map::DTLaneArray&amp; msg)
 {
-	all_vmap.dtlanes = msg.data;
-	update_values();
+  all_vmap.dtlanes = msg.data;
+  update_values();
 }
 
 void config_parameter(const autoware_config_msgs::ConfigLaneRule&amp; msg)
 {
-	config_acceleration = msg.acceleration;
-	config_stopline_search_radius = msg.stopline_search_radius;
-	config_number_of_zeros_ahead = msg.number_of_zeros_ahead;
-	config_number_of_zeros_behind = msg.number_of_zeros_behind;
-	config_number_of_smoothing_count = msg.number_of_smoothing_count;
-
-	if (!cached_waypoint.lanes.empty()) {
-		autoware_msgs::LaneArray update_waypoint = cached_waypoint;
-		create_waypoint(update_waypoint);
-	}
+  config_acceleration = msg.acceleration;
+  config_stopline_search_radius = msg.stopline_search_radius;
+  config_number_of_zeros_ahead = msg.number_of_zeros_ahead;
+  config_number_of_zeros_behind = msg.number_of_zeros_behind;
+  config_number_of_smoothing_count = msg.number_of_smoothing_count;
+
+  if (!cached_waypoint.lanes.empty())
+  {
+    autoware_msgs::LaneArray update_waypoint = cached_waypoint;
+    create_waypoint(update_waypoint);
+  }
 }
 
-} // namespace
+}  // namespace
 
-int main(int argc, char **argv)
+int main(int argc, char** argv)
 {
-	ros::init(argc, argv, "lane_rule");
-
-	ros::NodeHandle n;
-
-	int sub_vmap_queue_size;
-	n.param&lt;int&gt;("/lane_rule/sub_vmap_queue_size", sub_vmap_queue_size, 1);
-	int sub_waypoint_queue_size;
-	n.param&lt;int&gt;("/lane_rule/sub_waypoint_queue_size", sub_waypoint_queue_size, 1);
-	int sub_config_queue_size;
-	n.param&lt;int&gt;("/lane_rule/sub_config_queue_size", sub_config_queue_size, 1);
-	int pub_waypoint_queue_size;
-	n.param&lt;int&gt;("/lane_rule/pub_waypoint_queue_size", pub_waypoint_queue_size, 1);
-	bool pub_waypoint_latch;
-	n.param&lt;bool&gt;("/lane_rule/pub_waypoint_latch", pub_waypoint_latch, true);
+  ros::init(argc, argv, "lane_rule");
+
+  ros::NodeHandle n;
+
+  int sub_vmap_queue_size;
+  n.param&lt;int&gt;("/lane_rule/sub_vmap_queue_size", sub_vmap_queue_size, 1);
+  int sub_waypoint_queue_size;
+  n.param&lt;int&gt;("/lane_rule/sub_waypoint_queue_size", sub_waypoint_queue_size, 1);
+  int sub_config_queue_size;
+  n.param&lt;int&gt;("/lane_rule/sub_config_queue_size", sub_config_queue_size, 1);
+  int pub_waypoint_queue_size;
+  n.param&lt;int&gt;("/lane_rule/pub_waypoint_queue_size", pub_waypoint_queue_size, 1);
+  bool pub_waypoint_latch;
+  n.param&lt;bool&gt;("/lane_rule/pub_waypoint_latch", pub_waypoint_latch, true);
 #ifdef DEBUG
-	int pub_marker_queue_size;
-	n.param&lt;int&gt;("/lane_rule/pub_marker_queue_size", pub_marker_queue_size, 10);
-	bool pub_marker_latch;
-	n.param&lt;bool&gt;("/lane_rule/pub_marker_latch", pub_marker_latch, true);
-#endif // DEBUG
-
-	n.param&lt;int&gt;("/lane_rule/waypoint_max", waypoint_max, 10000);
-	n.param&lt;double&gt;("/lane_rule/search_radius", search_radius, 10);
-	n.param&lt;double&gt;("/lane_rule/curve_weight", curve_weight, 0.6);
-	n.param&lt;double&gt;("/lane_rule/crossroad_weight", crossroad_weight, 0.9);
-	n.param&lt;double&gt;("/lane_rule/clothoid_weight", clothoid_weight, 0.215);
-	n.param&lt;std::string&gt;("/lane_rule/frame_id", frame_id, "map");
-
-	traffic_pub = n.advertise&lt;autoware_msgs::LaneArray&gt;("/traffic_waypoints_array", pub_waypoint_queue_size,
-								pub_waypoint_latch);
-	red_pub = n.advertise&lt;autoware_msgs::LaneArray&gt;("/red_waypoints_array", pub_waypoint_queue_size,
-							    pub_waypoint_latch);
-	green_pub = n.advertise&lt;autoware_msgs::LaneArray&gt;("/green_waypoints_array", pub_waypoint_queue_size,
-							      pub_waypoint_latch);
+  int pub_marker_queue_size;
+  n.param&lt;int&gt;("/lane_rule/pub_marker_queue_size", pub_marker_queue_size, 10);
+  bool pub_marker_latch;
+  n.param&lt;bool&gt;("/lane_rule/pub_marker_latch", pub_marker_latch, true);
+#endif  // DEBUG
+
+  n.param&lt;int&gt;("/lane_rule/waypoint_max", waypoint_max, 10000);
+  n.param&lt;double&gt;("/lane_rule/search_radius", search_radius, 10);
+  n.param&lt;double&gt;("/lane_rule/curve_weight", curve_weight, 0.6);
+  n.param&lt;double&gt;("/lane_rule/crossroad_weight", crossroad_weight, 0.9);
+  n.param&lt;double&gt;("/lane_rule/clothoid_weight", clothoid_weight, 0.215);
+  n.param&lt;std::string&gt;("/lane_rule/frame_id", frame_id, "map");
+
+  traffic_pub =
+      n.advertise&lt;autoware_msgs::LaneArray&gt;("/traffic_waypoints_array", pub_waypoint_queue_size, pub_waypoint_latch);
+  red_pub = n.advertise&lt;autoware_msgs::LaneArray&gt;("/red_waypoints_array", pub_waypoint_queue_size, pub_waypoint_latch);
+  green_pub =
+      n.advertise&lt;autoware_msgs::LaneArray&gt;("/green_waypoints_array", pub_waypoint_queue_size, pub_waypoint_latch);
 
 #ifdef DEBUG
-	debug_marker.header.frame_id = frame_id;
-	debug_marker.id = 0;
-	debug_marker.type = visualization_msgs::Marker::LINE_STRIP;
-	debug_marker.scale.x = 0.2;
-	debug_marker.scale.y = 0.2;
-	debug_marker.frame_locked = true;
-
-	marker_pub = n.advertise&lt;visualization_msgs::Marker&gt;("/waypoint_debug", pub_marker_queue_size,
-							     pub_marker_latch);
-#endif // DEBUG
-
-	ros::Subscriber waypoint_sub = n.subscribe("/lane_waypoints_array", sub_waypoint_queue_size, create_waypoint);
-	ros::Subscriber point_sub = n.subscribe("/vector_map_info/point", sub_vmap_queue_size, cache_point);
-	ros::Subscriber lane_sub = n.subscribe("/vector_map_info/lane", sub_vmap_queue_size, cache_lane);
-	ros::Subscriber node_sub = n.subscribe("/vector_map_info/node", sub_vmap_queue_size, cache_node);
-	ros::Subscriber stopline_sub = n.subscribe("/vector_map_info/stop_line", sub_vmap_queue_size, cache_stopline);
-	ros::Subscriber dtlane_sub = n.subscribe("/vector_map_info/dtlane", sub_vmap_queue_size, cache_dtlane);
-	ros::Subscriber config_sub = n.subscribe("/config/lane_rule", sub_config_queue_size, config_parameter);
-
-	ros::spin();
-
-	return EXIT_SUCCESS;
+  debug_marker.header.frame_id = frame_id;
+  debug_marker.id = 0;
+  debug_marker.type = visualization_msgs::Marker::LINE_STRIP;
+  debug_marker.scale.x = 0.2;
+  debug_marker.scale.y = 0.2;
+  debug_marker.frame_locked = true;
+
+  marker_pub = n.advertise&lt;visualization_msgs::Marker&gt;("/waypoint_debug", pub_marker_queue_size, pub_marker_latch);
+#endif  // DEBUG
+
+  ros::Subscriber waypoint_sub = n.subscribe("/lane_waypoints_array", sub_waypoint_queue_size, create_waypoint);
+  ros::Subscriber point_sub = n.subscribe("/vector_map_info/point", sub_vmap_queue_size, cache_point);
+  ros::Subscriber lane_sub = n.subscribe("/vector_map_info/lane", sub_vmap_queue_size, cache_lane);
+  ros::Subscriber node_sub = n.subscribe("/vector_map_info/node", sub_vmap_queue_size, cache_node);
+  ros::Subscriber stopline_sub = n.subscribe("/vector_map_info/stop_line", sub_vmap_queue_size, cache_stopline);
+  ros::Subscriber dtlane_sub = n.subscribe("/vector_map_info/dtlane", sub_vmap_queue_size, cache_dtlane);
+  ros::Subscriber config_sub = n.subscribe("/config/lane_rule", sub_config_queue_size, config_parameter);
+
+  ros::spin();
+
+  return EXIT_SUCCESS;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="24" deleted_lines="16">
				<diff>@@ -21,6 +21,7 @@ namespace lane_planner
 // Constructor
 LaneSelectNode::LaneSelectNode()
   : private_nh_("~")
+  , lane_array_id_(-1)
   , current_lane_idx_(-1)
   , right_lane_idx_(-1)
   , left_lane_idx_(-1)
@@ -52,25 +53,16 @@ void LaneSelectNode::initForROS()
   sub3_ = nh_.subscribe("current_velocity", 1, &amp;LaneSelectNode::callbackFromTwistStamped, this);
   sub4_ = nh_.subscribe("state", 1, &amp;LaneSelectNode::callbackFromState, this);
   sub5_ = nh_.subscribe("/config/lane_select", 1, &amp;LaneSelectNode::callbackFromConfig, this);
-  sub6_ = nh_.subscribe("/decisionmaker/states", 1, &amp;LaneSelectNode::callbackFromStates, this);
+  sub6_ = nh_.subscribe("/decision_maker/state", 1, &amp;LaneSelectNode::callbackFromDecisionMakerState, this);
 
-  bool enablePlannerDynamicSwitch;
-  private_nh_.param&lt;bool&gt;("enablePlannerDynamicSwitch", enablePlannerDynamicSwitch, false);
   // setup publisher
 
   pub1_ = nh_.advertise&lt;autoware_msgs::Lane&gt;("base_waypoints", 1);
-
-  if (enablePlannerDynamicSwitch)
-  {
-    pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("/astar/closest_waypoint", 1);
-  }
-  else
-  {
-    pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1);
-  }
+  pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1);
 
   pub3_ = nh_.advertise&lt;std_msgs::Int32&gt;("change_flag", 1);
-  pub4_ = nh_.advertise&lt;std_msgs::Int32&gt;("/current_lane_id",1);
+  pub4_ = nh_.advertise&lt;std_msgs::Int32&gt;("/current_lane_id", 1);
+  pub5_ = nh_.advertise&lt;autoware_msgs::VehicleLocation&gt;("vehicle_location", 1);
 
   vis_pub1_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("lane_select_marker", 1);
 
@@ -98,6 +90,7 @@ void LaneSelectNode::initForLaneSelect()
   if (!getClosestWaypointNumberForEachLanes())
   {
     publishClosestWaypoint(-1);
+    publishVehicleLocation(-1, lane_array_id_);
     resetLaneIdx();
     return;
   }
@@ -110,6 +103,7 @@ void LaneSelectNode::initForLaneSelect()
   publishLane(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)));
   publishClosestWaypoint(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)));
   publishChangeFlag(std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)));
+  publishVehicleLocation(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)), lane_array_id_);
   publishVisualizer();
 
   resetSubscriptionFlag();
@@ -140,6 +134,7 @@ void LaneSelectNode::processing()
   if (!getClosestWaypointNumberForEachLanes())
   {
     publishClosestWaypoint(-1);
+    publishVehicleLocation(-1, lane_array_id_);
     resetLaneIdx();
     return;
   }
@@ -148,6 +143,7 @@ void LaneSelectNode::processing()
   if (std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)) == -1)
   {
     publishClosestWaypoint(-1);
+    publishVehicleLocation(-1, lane_array_id_);
     resetLaneIdx();
     return;
   }
@@ -172,6 +168,7 @@ void LaneSelectNode::processing()
       publishLaneID(std::get&lt;0&gt;(lane_for_change_));
       publishClosestWaypoint(std::get&lt;1&gt;(lane_for_change_));
       publishChangeFlag(std::get&lt;2&gt;(lane_for_change_));
+      publishVehicleLocation(std::get&lt;1&gt;(lane_for_change_), lane_array_id_);
     }
     catch (std::out_of_range)
     {
@@ -186,6 +183,7 @@ void LaneSelectNode::processing()
     publishLane(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)));
     publishClosestWaypoint(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)));
     publishChangeFlag(std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)));
+    publishVehicleLocation(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)), lane_array_id_);
   }
   publishVisualizer();
   resetSubscriptionFlag();
@@ -618,6 +616,15 @@ void LaneSelectNode::publishChangeFlag(const ChangeFlag flag)
   pub3_.publish(change_flag);
 }
 
+void LaneSelectNode::publishVehicleLocation(const int32_t clst_wp, const int32_t larray_id)
+{
+  autoware_msgs::VehicleLocation vehicle_location;
+  vehicle_location.header.stamp = ros::Time::now();
+  vehicle_location.waypoint_index = clst_wp;
+  vehicle_location.lane_array_id = larray_id;
+  pub5_.publish(vehicle_location);
+}
+
 void LaneSelectNode::callbackFromLaneArray(const autoware_msgs::LaneArrayConstPtr &amp;msg)
 {
   tuple_vec_.clear();
@@ -629,6 +636,7 @@ void LaneSelectNode::callbackFromLaneArray(const autoware_msgs::LaneArrayConstPt
     tuple_vec_.push_back(t);
   }
 
+  lane_array_id_ = msg-&gt;id;
   current_lane_idx_ = -1;
   right_lane_idx_ = -1;
   left_lane_idx_ = -1;
@@ -672,18 +680,18 @@ void LaneSelectNode::callbackFromState(const std_msgs::StringConstPtr &amp;msg)
   else
     processing();
 }
-void LaneSelectNode::callbackFromStates(const autoware_msgs::StateConstPtr &amp;msg)
+void LaneSelectNode::callbackFromDecisionMakerState(const std_msgs::StringConstPtr &amp;msg)
 {
   is_current_state_subscribed_ = true;
 
-  if (msg-&gt;behavior_state.find("LaneChange") != std::string::npos)
+  if (msg-&gt;data.find("ChangeTo") != std::string::npos)
   {
     current_state_ = std::string("LANE_CHANGE");
     ;
   }
   else
   {
-    current_state_ = msg-&gt;main_state;
+    current_state_ = msg-&gt;data;
   }
 
   if (current_lane_idx_ == -1)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" added_lines="121" deleted_lines="119">
				<diff>@@ -28,87 +28,22 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include &lt;iostream&gt;
-#include &lt;thread&gt;
+#include "twist_gate.h"
+
 #include &lt;chrono&gt;
-#include &lt;map&gt;
-#include &lt;memory&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;std_msgs/Int32.h&gt;
-#include &lt;std_msgs/Bool.h&gt;
-#include &lt;std_msgs/String.h&gt;
-#include &lt;geometry_msgs/TwistStamped.h&gt;
-
-#include "autoware_msgs/RemoteCmd.h"
-#include "autoware_msgs/VehicleCmd.h"
-#include "tablet_socket_msgs/mode_cmd.h"
-#include "tablet_socket_msgs/gear_cmd.h"
-#include "autoware_msgs/AccelCmd.h"
-#include "autoware_msgs/BrakeCmd.h"
-#include "autoware_msgs/SteerCmd.h"
-#include "autoware_msgs/ControlCommandStamped.h"
-
-//headers in Autowae Health Checker
-#include &lt;autoware_health_checker/node_status_publisher.h&gt;
-
-class TwistGate
-{
-  using remote_msgs_t = autoware_msgs::RemoteCmd;
-  using vehicle_cmd_msg_t = autoware_msgs::VehicleCmd;
-
-  public:
-    TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_nh);
-    ~TwistGate();
-  private:
-    void watchdog_timer();
-    void remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg);
-    void auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::ConstPtr&amp; input_msg);
-    void mode_cmd_callback(const tablet_socket_msgs::mode_cmd::ConstPtr&amp; input_msg);
-    void gear_cmd_callback(const tablet_socket_msgs::gear_cmd::ConstPtr&amp; input_msg);
-    void accel_cmd_callback(const autoware_msgs::AccelCmd::ConstPtr&amp; input_msg);
-    void steer_cmd_callback(const autoware_msgs::SteerCmd::ConstPtr&amp; input_msg);
-    void brake_cmd_callback(const autoware_msgs::BrakeCmd::ConstPtr&amp; input_msg);
-    void lamp_cmd_callback(const autoware_msgs::LampCmd::ConstPtr&amp; input_msg);
-    void ctrl_cmd_callback(const autoware_msgs::ControlCommandStamped::ConstPtr&amp; input_msg);
-
-    void reset_vehicle_cmd_msg();
-
-    ros::NodeHandle nh_;
-    ros::NodeHandle private_nh_;
-    std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_pub_ptr_;
-    ros::Publisher emergency_stop_pub_;
-    ros::Publisher control_command_pub_;
-    ros::Publisher vehicle_cmd_pub_;
-    ros::Publisher state_cmd_pub_;
-    ros::Subscriber remote_cmd_sub_;
-    std::map&lt;std::string , ros::Subscriber&gt; auto_cmd_sub_stdmap_;
-
-    vehicle_cmd_msg_t twist_gate_msg_;
-    std_msgs::Bool emergency_stop_msg_;
-    ros::Time remote_cmd_time_;
-    ros::Duration timeout_period_;
-
-    std::thread watchdog_timer_thread_;
-    enum class CommandMode{AUTO=1, REMOTE=2} command_mode_, previous_command_mode_;
-    std_msgs::String command_mode_topic_;
-
-    // still send is true
-    bool send_emergency_cmd = false;
-};
-
-TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_nh) :
-     nh_(nh)
-    ,private_nh_(private_nh)
-    ,timeout_period_(1.0)
-    ,command_mode_(CommandMode::AUTO)
-    ,previous_command_mode_(CommandMode::AUTO)
+
+TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_nh)
+  : nh_(nh)
+  , private_nh_(private_nh)
+  , timeout_period_(1.0)
+  , command_mode_(CommandMode::AUTO)
+  , previous_command_mode_(CommandMode::AUTO)
 {
   node_status_pub_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh_,private_nh_);
   emergency_stop_pub_ = nh_.advertise&lt;std_msgs::Bool&gt;("/emergency_stop", 1, true);
   control_command_pub_ = nh_.advertise&lt;std_msgs::String&gt;("/ctrl_mode", 1);
   vehicle_cmd_pub_ = nh_.advertise&lt;vehicle_cmd_msg_t&gt;("/vehicle_cmd", 1, true);
-  state_cmd_pub_ = nh_.advertise&lt;std_msgs::Int32&gt;("/state_cmd", 1, true);
+  state_cmd_pub_ = nh_.advertise&lt;std_msgs::String&gt;("/state_cmd", 1, true);
 
   remote_cmd_sub_ = nh_.subscribe("/remote_cmd", 1, &amp;TwistGate::remote_cmd_callback, this);
 
@@ -120,6 +55,7 @@ TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_n
   auto_cmd_sub_stdmap_["brake_cmd"] = nh_.subscribe("/brake_cmd", 1, &amp;TwistGate::brake_cmd_callback, this);
   auto_cmd_sub_stdmap_["lamp_cmd"] = nh_.subscribe("/lamp_cmd", 1, &amp;TwistGate::lamp_cmd_callback, this);
   auto_cmd_sub_stdmap_["ctrl_cmd"] = nh_.subscribe("/ctrl_cmd", 1, &amp;TwistGate::ctrl_cmd_callback, this);
+  auto_cmd_sub_stdmap_["state"] = nh_.subscribe("/decision_maker/state", 1, &amp;TwistGate::state_callback, this);
 
   twist_gate_msg_.header.seq = 0;
   emergency_stop_msg_.data = false;
@@ -128,44 +64,76 @@ TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_n
 
   remote_cmd_time_ = ros::Time::now();
   watchdog_timer_thread_ = std::thread(&amp;TwistGate::watchdog_timer, this);
-  watchdog_timer_thread_.detach();
+  is_alive = true;
 }
 
 TwistGate::~TwistGate()
 {
+  is_alive = false;
+  watchdog_timer_thread_.join();
 }
 
 void TwistGate::reset_vehicle_cmd_msg()
 {
-  twist_gate_msg_.twist_cmd.twist.linear.x  = 0;
+  twist_gate_msg_.twist_cmd.twist.linear.x = 0;
   twist_gate_msg_.twist_cmd.twist.angular.z = 0;
-  twist_gate_msg_.mode                      = 0;
-  twist_gate_msg_.gear                      = 0;
-  twist_gate_msg_.lamp_cmd.l                = 0;
-  twist_gate_msg_.lamp_cmd.r                = 0;
-  twist_gate_msg_.accel_cmd.accel           = 0;
-  twist_gate_msg_.brake_cmd.brake           = 0;
-  twist_gate_msg_.steer_cmd.steer           = 0;
-  twist_gate_msg_.ctrl_cmd.linear_velocity  = -1;
-  twist_gate_msg_.ctrl_cmd.steering_angle   = 0;
+  twist_gate_msg_.mode = 0;
+  twist_gate_msg_.gear = 0;
+  twist_gate_msg_.lamp_cmd.l = 0;
+  twist_gate_msg_.lamp_cmd.r = 0;
+  twist_gate_msg_.accel_cmd.accel = 0;
+  twist_gate_msg_.brake_cmd.brake = 0;
+  twist_gate_msg_.steer_cmd.steer = 0;
+  twist_gate_msg_.ctrl_cmd.linear_velocity = -1;
+  twist_gate_msg_.ctrl_cmd.steering_angle = 0;
+}
+
+bool TwistGate::is_using_decisionmaker()
+{
+  bool using_decision_maker_flag = false;
+  std::vector&lt;std::string&gt; node_list;
+  ros::master::getNodes(node_list);
+
+  for (const auto&amp; i : node_list)
+  {
+    if (i == "/decision_maker")
+    {
+      using_decision_maker_flag = true;
+      break;
+    }
+  }
+  return using_decision_maker_flag;
+}
+
+void TwistGate::check_state()
+{
+  if (is_using_decisionmaker() &amp;&amp; !is_state_drive_)
+  {
+    twist_gate_msg_.twist_cmd.twist = geometry_msgs::Twist();
+    twist_gate_msg_.ctrl_cmd = autoware_msgs::ControlCommand();
+  }
 }
 
 void TwistGate::watchdog_timer()
 {
-  while(1)
+  while (is_alive)
   {
     ros::Time now_time = ros::Time::now();
     bool emergency_flag = false;
 
     // check command mode
-    if(previous_command_mode_ != command_mode_) {
-      if(command_mode_ == CommandMode::AUTO) {
+    if (previous_command_mode_ != command_mode_)
+    {
+      if (command_mode_ == CommandMode::AUTO)
+      {
         command_mode_topic_.data = "AUTO";
       }
-      else if(command_mode_ == CommandMode::REMOTE) {
+      else if (command_mode_ == CommandMode::REMOTE)
+      {
         command_mode_topic_.data = "REMOTE";
       }
-      else{
+      else
+      {
         command_mode_topic_.data = "UNDEFINED";
       }
 
@@ -174,34 +142,39 @@ void TwistGate::watchdog_timer()
     }
 
     // if lost Communication
-    if(command_mode_ == CommandMode::REMOTE &amp;&amp; now_time - remote_cmd_time_ &gt;  timeout_period_) {
+    if (command_mode_ == CommandMode::REMOTE &amp;&amp; now_time - remote_cmd_time_ &gt; timeout_period_)
+    {
       emergency_flag = true;
       ROS_WARN("Lost Communication!");
     }
 
     // if push emergency stop button
-    if(emergency_stop_msg_.data == true)
+    if (emergency_stop_msg_.data == true)
     {
       emergency_flag = true;
       ROS_WARN("Emergency Mode!");
     }
 
     // Emergency
-    if(emergency_flag) {
+    if (emergency_flag)
+    {
       // Change Auto Mode
       command_mode_ = CommandMode::AUTO;
-      if(send_emergency_cmd == false) {
+      if (send_emergency_cmd == false)
+      {
         // Change State to Stop
-        std_msgs::Int32 state_cmd;
-        state_cmd.data = 14;
+        std_msgs::String state_cmd;
+        state_cmd.data = "emergency";
         state_cmd_pub_.publish(state_cmd);
         send_emergency_cmd = true;
       }
       // Set Emergency Stop
-      emergency_stop_msg_.data = true;
       emergency_stop_pub_.publish(emergency_stop_msg_);
       ROS_WARN("Emergency Stop!");
     }
+    else {
+      send_emergency_cmd = false;
+    }
 
     std::this_thread::sleep_for(std::chrono::milliseconds(10));
   }
@@ -209,24 +182,26 @@ void TwistGate::watchdog_timer()
 
 void TwistGate::remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg)
 {
+  remote_cmd_time_ = ros::Time::now();
   command_mode_ = static_cast&lt;CommandMode&gt;(input_msg-&gt;control_mode);
   emergency_stop_msg_.data = static_cast&lt;bool&gt;(input_msg-&gt;vehicle_cmd.emergency);
-  remote_cmd_time_ = ros::Time::now();
 
-  if(command_mode_ == CommandMode::REMOTE)
+  // Update Emergency Mode
+  twist_gate_msg_.emergency = input_msg-&gt;vehicle_cmd.emergency;
+
+  if (command_mode_ == CommandMode::REMOTE &amp;&amp; emergency_stop_msg_.data == false)
   {
     twist_gate_msg_.header.frame_id = input_msg-&gt;vehicle_cmd.header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;vehicle_cmd.header.stamp;
     twist_gate_msg_.header.seq++;
     twist_gate_msg_.twist_cmd.twist = input_msg-&gt;vehicle_cmd.twist_cmd.twist;
-    twist_gate_msg_.ctrl_cmd  = input_msg-&gt;vehicle_cmd.ctrl_cmd;
+    twist_gate_msg_.ctrl_cmd = input_msg-&gt;vehicle_cmd.ctrl_cmd;
     twist_gate_msg_.accel_cmd = input_msg-&gt;vehicle_cmd.accel_cmd;
     twist_gate_msg_.brake_cmd = input_msg-&gt;vehicle_cmd.brake_cmd;
     twist_gate_msg_.steer_cmd = input_msg-&gt;vehicle_cmd.steer_cmd;
     twist_gate_msg_.gear = input_msg-&gt;vehicle_cmd.gear;
     twist_gate_msg_.lamp_cmd = input_msg-&gt;vehicle_cmd.lamp_cmd;
     twist_gate_msg_.mode = input_msg-&gt;vehicle_cmd.mode;
-    twist_gate_msg_.emergency = input_msg-&gt;vehicle_cmd.emergency;
     vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
@@ -241,16 +216,19 @@ void TwistGate::auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::C
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
     twist_gate_msg_.twist_cmd.twist = input_msg-&gt;twist;
+
+    check_state();
     vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
 
 void TwistGate::mode_cmd_callback(const tablet_socket_msgs::mode_cmd::ConstPtr&amp; input_msg)
 {
-  if(command_mode_ == CommandMode::AUTO)
+  if (command_mode_ == CommandMode::AUTO)
   {
-    //TODO:check this if statement
-    if(input_msg-&gt;mode == -1 || input_msg-&gt;mode == 0){
+    // TODO:check this if statement
+    if (input_msg-&gt;mode == -1 || input_msg-&gt;mode == 0)
+    {
       reset_vehicle_cmd_msg();
     }
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
@@ -263,7 +241,7 @@ void TwistGate::mode_cmd_callback(const tablet_socket_msgs::mode_cmd::ConstPtr&amp;
 
 void TwistGate::gear_cmd_callback(const tablet_socket_msgs::gear_cmd::ConstPtr&amp; input_msg)
 {
-  if(command_mode_ == CommandMode::AUTO)
+  if (command_mode_ == CommandMode::AUTO)
   {
     twist_gate_msg_.gear = input_msg-&gt;gear;
     vehicle_cmd_pub_.publish(twist_gate_msg_);
@@ -272,7 +250,7 @@ void TwistGate::gear_cmd_callback(const tablet_socket_msgs::gear_cmd::ConstPtr&amp;
 
 void TwistGate::accel_cmd_callback(const autoware_msgs::AccelCmd::ConstPtr&amp; input_msg)
 {
-  if(command_mode_ == CommandMode::AUTO)
+  if (command_mode_ == CommandMode::AUTO)
   {
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
@@ -284,7 +262,7 @@ void TwistGate::accel_cmd_callback(const autoware_msgs::AccelCmd::ConstPtr&amp; inpu
 
 void TwistGate::steer_cmd_callback(const autoware_msgs::SteerCmd::ConstPtr&amp; input_msg)
 {
-  if(command_mode_ == CommandMode::AUTO)
+  if (command_mode_ == CommandMode::AUTO)
   {
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
@@ -296,7 +274,7 @@ void TwistGate::steer_cmd_callback(const autoware_msgs::SteerCmd::ConstPtr&amp; inpu
 
 void TwistGate::brake_cmd_callback(const autoware_msgs::BrakeCmd::ConstPtr&amp; input_msg)
 {
-  if(command_mode_ == CommandMode::AUTO)
+  if (command_mode_ == CommandMode::AUTO)
   {
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
@@ -308,7 +286,7 @@ void TwistGate::brake_cmd_callback(const autoware_msgs::BrakeCmd::ConstPtr&amp; inpu
 
 void TwistGate::lamp_cmd_callback(const autoware_msgs::LampCmd::ConstPtr&amp; input_msg)
 {
-  if(command_mode_ == CommandMode::AUTO)
+  if (command_mode_ == CommandMode::AUTO)
   {
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
@@ -321,25 +299,49 @@ void TwistGate::lamp_cmd_callback(const autoware_msgs::LampCmd::ConstPtr&amp; input_
 
 void TwistGate::ctrl_cmd_callback(const autoware_msgs::ControlCommandStamped::ConstPtr&amp; input_msg)
 {
-  if(command_mode_ == CommandMode::AUTO)
+  if (command_mode_ == CommandMode::AUTO)
   {
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
     twist_gate_msg_.ctrl_cmd = input_msg-&gt;cmd;
+
+    check_state();
     vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
 
-
-int main(int argc, char** argv)
+void TwistGate::state_callback(const std_msgs::StringConstPtr&amp; input_msg)
 {
-  ros::init(argc, argv, "twist_gate");
-  ros::NodeHandle nh;
-  ros::NodeHandle private_nh("~");
+  if (command_mode_ == CommandMode::AUTO)
+  {
+    // Set Parking Gear
+    if (input_msg-&gt;data.find("WaitOrder") != std::string::npos)
+    {
+      twist_gate_msg_.gear = CMD_GEAR_P;
+    }
+    // Set Drive Gear
+    else
+    {
+      twist_gate_msg_.gear = CMD_GEAR_D;
+    }
 
-  TwistGate twist_gate(nh, private_nh);
+    // get drive state
+    if (input_msg-&gt;data.find("Drive\n") != std::string::npos &amp;&amp; input_msg-&gt;data.find("VehicleReady\n") != std::string::npos)
+    {
+      is_state_drive_ = true;
+    }
+    else
+    {
+      is_state_drive_ = false;
+    }
+    vehicle_cmd_pub_.publish(twist_gate_msg_);
 
-  ros::spin();
-  return 0;
+    // reset emergency flags
+    if (input_msg-&gt;data.find("VehicleReady") != std::string::npos)
+    {
+      emergency_stop_msg_.data = false;
+      send_emergency_cmd = false;
+    }
+  }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" added_lines="29" deleted_lines="34">
				<diff>@@ -14,19 +14,19 @@
  * limitations under the License.
  */
 
+#include &lt;geometry_msgs/PoseStamped.h&gt;
+#include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
 #include &lt;ros/ros.h&gt;
+#include &lt;std_msgs/Int32.h&gt;
 #include &lt;std_msgs/String.h&gt;
-#include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
-#include &lt;geometry_msgs/PoseStamped.h&gt;
+#include &lt;tf/tf.h&gt;
 #include &lt;tf/transform_broadcaster.h&gt;
 #include &lt;tf/transform_listener.h&gt;
-#include &lt;tf/tf.h&gt;
 #include &lt;iostream&gt;
-#include &lt;std_msgs/Int32.h&gt;
 #include &lt;random&gt;
 
+#include "autoware_msgs/VehicleCmd.h"
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "autoware_msgs/ControlCommandStamped.h"
 
 namespace
 {
@@ -57,46 +57,42 @@ double wheel_base_ = 2.7;
 
 constexpr int LOOP_RATE = 50;  // 50Hz
 
-void CmdCallBack(const geometry_msgs::TwistStampedConstPtr&amp; msg, double accel_rate)
+void CmdCallBack(const autoware_msgs::VehicleCmdConstPtr&amp; msg, double accel_rate)
 {
   if (use_ctrl_cmd == true)
-    return;
-
-  static double previous_linear_velocity = 0;
-
-  if (current_velocity_.linear.x &lt; msg-&gt;twist.linear.x)
   {
-    current_velocity_.linear.x = previous_linear_velocity + accel_rate / (double)LOOP_RATE;
-
-    if (current_velocity_.linear.x &gt; msg-&gt;twist.linear.x)
-    {
-      current_velocity_.linear.x = msg-&gt;twist.linear.x;
-    }
+    linear_acceleration_ = msg-&gt;ctrl_cmd.linear_acceleration;
+    steering_angle_ = msg-&gt;ctrl_cmd.steering_angle;
   }
   else
   {
-    current_velocity_.linear.x = previous_linear_velocity - accel_rate / (double)LOOP_RATE;
+    static double previous_linear_velocity = 0;
 
-    if (current_velocity_.linear.x &lt; msg-&gt;twist.linear.x)
+    if (current_velocity_.linear.x &lt; msg-&gt;twist_cmd.twist.linear.x)
     {
-      current_velocity_.linear.x = msg-&gt;twist.linear.x;
-    }
-  }
+      current_velocity_.linear.x = previous_linear_velocity + accel_rate / (double)LOOP_RATE;
 
-  previous_linear_velocity = current_velocity_.linear.x;
+      if (current_velocity_.linear.x &gt; msg-&gt;twist_cmd.twist.linear.x)
+      {
+        current_velocity_.linear.x = msg-&gt;twist_cmd.twist.linear.x;
+      }
+    }
+    else
+    {
+      current_velocity_.linear.x = previous_linear_velocity - accel_rate / (double)LOOP_RATE;
 
-  current_velocity_.angular.z = msg-&gt;twist.angular.z;
+      if (current_velocity_.linear.x &lt; msg-&gt;twist_cmd.twist.linear.x)
+      {
+        current_velocity_.linear.x = msg-&gt;twist_cmd.twist.linear.x;
+      }
+    }
 
-  //current_velocity_ = msg-&gt;twist;
-}
+    previous_linear_velocity = current_velocity_.linear.x;
 
-void controlCmdCallBack(const autoware_msgs::ControlCommandStampedConstPtr&amp; msg)
-{
-  if (use_ctrl_cmd == false)
-    return;
+    current_velocity_.angular.z = msg-&gt;twist_cmd.twist.angular.z;
 
-  linear_acceleration_ = msg-&gt;cmd.linear_acceleration;
-  steering_angle_ = msg-&gt;cmd.steering_angle;
+    //current_velocity_ = msg-&gt;twist;
+  }
 }
 
 void getTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform&amp; transform)
@@ -274,8 +270,7 @@ int main(int argc, char** argv)
 
   // subscribe topic
   ros::Subscriber cmd_subscriber =
-      nh.subscribe&lt;geometry_msgs::TwistStamped&gt;("twist_cmd", 10, boost::bind(CmdCallBack, _1, accel_rate));
-  ros::Subscriber control_cmd_subscriber = nh.subscribe("ctrl_cmd", 10, controlCmdCallBack);
+      nh.subscribe&lt;autoware_msgs::VehicleCmd&gt;("vehicle_cmd", 10, boost::bind(CmdCallBack, _1, accel_rate));
   ros::Subscriber waypoint_subcscriber = nh.subscribe("base_waypoints", 10, waypointCallback);
   ros::Subscriber closest_sub = nh.subscribe("closest_waypoint", 10, callbackFromClosestWaypoint);
   ros::Subscriber initialpose_subscriber;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d37ec2ebe9d5db69028a670a8d556e75cfa76707" author="Kosuke Murakami">
		<msg>[Feature] costmap generator (#1774)

* * Initial commit for visualization package
* Removal of all visualization messages from perception nodes
* Visualization dependency removal
* Launch file modification

* * Fixes to visualization
* Error on Clustering CPU

* Reduce verbosity on markers

* Publish acceleration and velocity from ukf tracker

* Remove hardcoded path

* Updated README

* updated prototype

* Prototype update for header and usage

* Removed unknown label from being reported

* Updated publishing orientation to match develop

* * Published all the trackers
* Added valid field for visualization and future compatibility with ADAS ROI filtering

* Add simple functions

* * Reversed back UKF node to develop
* Formatted speed

* Refactor codes

* Make tracking visualization work

* Relay class info in tracker node

* Remove dependency to jskbbox and rosmarker in ukf tracker

* apply rosclang to ukf tracker

* Refactor codes

* Revert "apply rosclang to ukf tracker"

* Revert "Remove dependency to jskbbox and rosmarker in ukf tracker"

* Revert "Relay class info in tracker node"

* delete dependency to jsk and remove pointcloud_frame

* get direction nis

* set velocity_reliable true in tracker node

* Add divided function

* add function

* Sanity checks

* Relay all the data from input DetectedObject

* Divided function work both for immukf and sukf

* Add comment

* Refactor codes

* Pass immukf test

* make direction assisted tracking work

* Visualization fixes

* Refactor codes

* Tracker Merging step added

* Added launch file support for merging phase

* lane assisted with sukf

* * change only static objects
* keep label of the oldest tracker

* Static Object discrimination

* Non rotating bouding box

* no disappear if detector works

* Modify removeRedundant a bit

* initial commit for costmap generator

* add vague stucture

* add brief structure fot points2costmap

* refactor codes

* add sensor points costmap

* add waypoint costmap

* bug fix for wayarea2costmap

* add simple structure for objects2costmap

* add vague structure for waypoints2costmap

* Replacement of JSK visualization for RViz Native Markers

* add occupancy grid visualization

* add objects costmap

* add minimum height threshold for pointcloud

* debug computing.yaml from objects_topic to objects_input

* Add blurred costmap

* Add comment on computing.yml

* visualizing bug fix

* Make sure object's cost is 100 and blurred outside of objects

* add costmap_generator package

* add unit tests

* delete test launch file

* Apply autoware ros clang

* Add README

* sync develop's readme

* sync develop's code

* add convex hull costmap

* Relay ros header appropriately

* change interaface for generating costmap from points

* add test for points2costmap

* Modify for how to pick up convex-hull points

* add test

* add test for objects2costmap

* Added missing include

* Added missing grid_map_ros dependency

* Updated include

* Re-strutured include folders

* Generic folder name

* Fix/costmap generator (#2077)

* segmentation fault in  CheckAssignPoints2GridCell

* Remove redundant codes in test

* Add some variables in SetUp

* rename class

* rename files

* modify tests

* Add scription in SetUp

* Remove unnecesary in_object

* Refactor test codes</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\include\naive_motion_predict.h" new_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\include\naive_motion_predict.h" added_lines="3" deleted_lines="0">
				<diff>@@ -40,6 +40,9 @@ private:
   ros::NodeHandle nh_;
   ros::NodeHandle private_nh_;
 
+  // max prediction score
+  const double MAX_PREDICTION_SCORE_;
+
   // ros publisher
   ros::Publisher predicted_objects_pub_;
   ros::Publisher predicted_paths_pub_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\nodes\naive_motion_predict\naive_motion_predict.cpp" new_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\nodes\naive_motion_predict\naive_motion_predict.cpp" added_lines="11" deleted_lines="5">
				<diff>@@ -16,7 +16,10 @@
 
 #include "naive_motion_predict.h"
 
-NaiveMotionPredict::NaiveMotionPredict() : nh_(), private_nh_("~")
+NaiveMotionPredict::NaiveMotionPredict() :
+  nh_(),
+  private_nh_("~"),
+  MAX_PREDICTION_SCORE_(1.0)
 {
   private_nh_.param&lt;double&gt;("interval_sec", interval_sec_, 0.1);
   private_nh_.param&lt;int&gt;("num_prediction", num_prediction_, 10);
@@ -56,14 +59,17 @@ void NaiveMotionPredict::initializeROSmarker(const std_msgs::Header&amp; header, con
 }
 
 void NaiveMotionPredict::makePrediction(const autoware_msgs::DetectedObject&amp; object,
-                                        std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; predicted_objects,
+                                        std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; predicted_objects_vec,
                                         visualization_msgs::Marker&amp; predicted_line)
 {
   autoware_msgs::DetectedObject target_object = object;
+  target_object.score = MAX_PREDICTION_SCORE_;
   initializeROSmarker(object.header, object.pose.position, object.id, predicted_line);
-  for (int i = 0; i &lt; num_prediction_; i++)
+  for (int ith_prediction = 0; ith_prediction &lt; num_prediction_; ith_prediction++)
   {
     autoware_msgs::DetectedObject predicted_object = generatePredictedObject(target_object);
+    predicted_object.score = (-1/(interval_sec_*num_prediction_))*ith_prediction*interval_sec_ + MAX_PREDICTION_SCORE_;
+    predicted_objects_vec.push_back(predicted_object);
     target_object = predicted_object;
 
     geometry_msgs::Point p;
@@ -174,7 +180,7 @@ void NaiveMotionPredict::objectsCallback(const autoware_msgs::DetectedObjectArra
 {
   autoware_msgs::DetectedObjectArray output;
   visualization_msgs::MarkerArray predicted_lines;
-  output.header = input.header;
+  output = input;
 
   for (const auto &amp;object : input.objects)
   {
@@ -219,4 +225,4 @@ bool NaiveMotionPredict::isObjectValid(const autoware_msgs::DetectedObject &amp;in_o
     return false;
   }
   return true;
-}//end IsObjectValid
\ No newline at end of file
+}//end IsObjectValid
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\include\object_map_utils.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\include\object_map\object_map_utils.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -16,7 +16,7 @@
  *
  */
 
-#include "object_map_utils.hpp"
+#include "object_map/object_map_utils.hpp"
 
 namespace object_map
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\include\object_map_utils.hpp" new_path="ros\src\computing\perception\semantics\packages\object_map\include\object_map\object_map_utils.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\grid_map_filter\grid_map_filter.h" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\grid_map_filter\grid_map_filter.h" added_lines="1" deleted_lines="1">
				<diff>@@ -34,7 +34,7 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 
-#include "object_map_utils.hpp"
+#include "object_map/object_map_utils.hpp"
 
 namespace object_map
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid.h" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid.h" added_lines="1" deleted_lines="1">
				<diff>@@ -35,7 +35,7 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 
-#include "object_map_utils.hpp"
+#include "object_map/object_map_utils.hpp"
 
 namespace object_map
 {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8381c4466d38f8bdbb1c9076ff0619b3e1c474e0" author="Akihito Ohsato">
		<msg>[Feature] Improve Hybrid A* planner (#1594)

* Delete obstacle_sim from astar_planner package, replaced to lidar_fake_perception

* Modify package name, astar_planner -&gt; waypoint_planner, and create astar_planner library package

* Delete obstacle_avoid/astar* and modify its dependency to astar_planner library

* Fix astar_navi with astar_planner library

* Refactor astar_navi by separating HAstar library and fixing coodinate system

* Rename obstacle_avoid -&gt; astar_avoid and under refactoring

* Fix cost function and configures

* Fix backward search and refactor configurations

* Apply clang-format

* Refactor include

* Fix typo and so on

* Improve astar_avoid by incremental goal search

* Apply clang-format

* Revert package names

* Fix package/code names

* Update runtime_manager

* Improve astar_avoid to execute avoidance behavior by state transition (by rebuild decision maker)

* Fix PascalCase message names by #1408

* Remove obstacle_avoid directory

* Fix default parameter for costmap topic

* Fix warning and initialize condition

* Remove use_avoidance_state mode (TODO: after merging rebuild decision maker)

* Improve astar_avoid behavior by simple state transition and multi-threading

* Apply clang-format

* Fix replan_interval in astar_avoid

* Add descriptions for paramters

* Rename pkg name, astar_planner -&gt; waypoint_planner

* Fix param name

* Fix avoid waypoints height

* Fix parameter and formalize code

* Add README for freespace/waypoint_planner

* Add License terms

Co-Authored-By: aohsato &lt;aohsato@gmail.com&gt;

Add License terms

Co-Authored-By: aohsato &lt;aohsato@gmail.com&gt;

Add License terms

Co-Authored-By: aohsato &lt;aohsato@gmail.com&gt;

Add License terms

Co-Authored-By: aohsato &lt;aohsato@gmail.com&gt;

Add License terms

Co-Authored-By: aohsato &lt;aohsato@gmail.com&gt;

Fix CHANGELOG

Co-Authored-By: aohsato &lt;aohsato@gmail.com&gt;

Add License terms

Co-Authored-By: aohsato &lt;aohsato@gmail.com&gt;

Add License terms

Co-Authored-By: aohsato &lt;aohsato@gmail.com&gt;

* Fix astar_navi/README.md

* Add License terms

* Fix const pointer

* Added unit test base

* Restructured folders

* Fix bug by adding AstarSearch reset

* Fix WaveFrontNode initialization

Co-Authored-By: aohsato &lt;aohsato@gmail.com&gt;

* Fix variable name

* Refactor threading

* Re-adding lidar_fake_perception

* Fix the condition to judge reaching goal

* Add 'use_decision state' mode to transit avoidance state by decision_maker

* Fix calcDiffOfRadian (if diff &gt; 2pi)

* Feature/test astar planner (#1753)

* Restructured folders

* Added unit test base

* Removed remaining folder

* Test WIP

* Added astar_util tests and base file for astar_search tests

* Updated to ROS Cpp Style guidelines

* Added test for SimpleNode constructor

* Updated Copyright date

* Added tests for astar algorithm

* Added default constructor to WaveFront struct

* Revert use_state_decision mode (94af7b6)

* Fix costmap topic names by merging costmap_generator</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\default.rviz" new_path="ros\src\.config\rviz\default.rviz" added_lines="1" deleted_lines="1">
				<diff>@@ -394,7 +394,7 @@ Visualization Manager:
       Draw Behind: true
       Enabled: true
       Name: Occupancy Grid Map
-      Topic: /grid_map_visualization/distance_transform
+      Topic: /grid_map_filter_visualization/distance_transform
       Unreliable: false
       Use Timestamp: false
       Value: true
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_util.h" new_path="ros\src\computing\planning\common\lib\astar_search\include\astar_search\astar_util.h" added_lines="10" deleted_lines="14">
				<diff>@@ -17,10 +17,8 @@
 #ifndef ASTAR_UTIL_H
 #define ASTAR_UTIL_H
 
-#include &lt;tf/transform_listener.h&gt;
+#include &lt;tf/tf.h&gt;
 
-namespace astar_planner
-{
 enum class STATUS : uint8_t
 {
   NONE,
@@ -37,7 +35,7 @@ struct AstarNode
   double hc = 0;                 // heuristic cost
   double move_distance = 0;      // actual move distance
   bool back;                     // true if the current direction of the vehicle is back
-  AstarNode *parent = NULL;      // parent node
+  AstarNode* parent = NULL;      // parent node
 };
 
 struct WaveFrontNode
@@ -69,7 +67,7 @@ struct SimpleNode
   int index_theta;
   double cost;
 
-  bool operator&gt;(const SimpleNode &amp;right) const
+  bool operator&gt;(const SimpleNode&amp; right) const
   {
     return cost &gt; right.cost;
   }
@@ -85,15 +83,15 @@ inline double calcDistance(double x1, double y1, double x2, double y2)
 
 inline double modifyTheta(double theta)
 {
-  if (theta &lt; 0)
-    return theta + 2 * M_PI;
-  if (theta &gt;= 2 * M_PI)
-    return theta - 2 * M_PI;
+  if (theta &lt; 0.0)
+    return theta + 2.0 * M_PI;
+  if (theta &gt;= 2.0 * M_PI)
+    return theta - 2.0 * M_PI;
 
   return theta;
 }
 
-inline geometry_msgs::Pose transformPose(geometry_msgs::Pose &amp;pose, tf::Transform &amp;tf)
+inline geometry_msgs::Pose transformPose(const geometry_msgs::Pose&amp; pose, const tf::Transform&amp; tf)
 {
   // Convert ROS pose to TF pose
   tf::Pose tf_pose;
@@ -131,11 +129,11 @@ inline geometry_msgs::Point calcRelativeCoordinate(geometry_msgs::Pose pose, tf:
 
 inline double calcDiffOfRadian(double a, double b)
 {
-  double diff = std::fabs(a - b);
+  double diff = std::fmod(std::fabs(a - b), 2.0 * M_PI);
   if (diff &lt; M_PI)
     return diff;
   else
-    return 2 * M_PI - diff;
+    return 2.0 * M_PI - diff;
 }
 
 inline geometry_msgs::Pose xytToPoseMsg(double x, double y, double theta)
@@ -148,6 +146,4 @@ inline geometry_msgs::Pose xytToPoseMsg(double x, double y, double theta)
   return p;
 }
 
-}  // namespace astar_planner
-
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_util.cpp" new_path="ros\src\computing\planning\common\lib\astar_search\src\astar_util.cpp" added_lines="3" deleted_lines="7">
				<diff>@@ -1,5 +1,5 @@
 /*
- * Copyright 2015-2019 Autoware Foundation. All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,11 +14,9 @@
  * limitations under the License.
  */
 
-#include "astar_util.h"
+#include "astar_search/astar_util.h"
 
-namespace astar_planner
-{
-WaveFrontNode::WaveFrontNode()
+WaveFrontNode::WaveFrontNode() : index_x(0), index_y(0), hc(0)
 {
 }
 
@@ -34,5 +32,3 @@ SimpleNode::SimpleNode(int x, int y, int theta, double gc, double hc)
   : index_x(x), index_y(y), index_theta(theta), cost(gc + hc)
 {
 }
-
-}  // namespace astar_planner
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\freespace_planner\include\astar_util.cpp" new_path="" added_lines="0" deleted_lines="25">
				<diff>@@ -1,25 +0,0 @@
-#include "astar_util.h"
-
-
-WaveFrontNode::WaveFrontNode()
-{
-}
-
-WaveFrontNode::WaveFrontNode(int x, int y, double cost)
-  : index_x(x)
-  , index_y(y)
-  , hc(cost)
-{
-}
-
-SimpleNode::SimpleNode()
-{
-}
-
-SimpleNode::SimpleNode(int x, int y, int theta, double gc, double hc)
-  : index_x(x)
-  , index_y(y)
-  , index_theta(theta)
-  , cost(gc + hc)
-{
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\freespace_planner\include\astar_util.h" new_path="" added_lines="0" deleted_lines="128">
				<diff>@@ -1,128 +0,0 @@
-#ifndef ASTAR_UTIL_H
-#define ASTAR_UTIL_H
-
-#include &lt;tf/transform_listener.h&gt;
-
-enum class STATUS : uint8_t
-{
-  NONE,
-  OPEN,
-  CLOSED,
-  OBS
-};
-
-struct AstarNode
-{
-  double x, y, theta;                // Coordinate of each node
-  STATUS status     = STATUS::NONE;  // NONE, OPEN, CLOSED or OBS
-  double gc         = 0;             // Actual cost
-  double hc         = 0;             // heuristic cost
-  bool back;                         // true if the current direction of the vehicle is back
-  uint8_t steering;                  // steering action of this node
-  AstarNode *parent = NULL;          // parent node
-};
-
-struct WaveFrontNode
-{
-  int index_x;
-  int index_y;
-  double hc;
-
-  WaveFrontNode();
-  WaveFrontNode(int x, int y, double cost);
-};
-
-struct NodeUpdate
-{
-  double shift_x;
-  double shift_y;
-  double rotation;
-  double step;
-  int index_theta;
-  bool curve;
-  bool back;
-};
-
-// For open list and goal list
-struct SimpleNode
-{
-  int index_x;
-  int index_y;
-  int index_theta;
-  double cost;
-
-  bool operator&gt;(const SimpleNode&amp; right) const {
-    return cost &gt; right.cost;
-  }
-
-  SimpleNode();
-  SimpleNode(int x, int y, int theta, double gc, double hc);
-};
-
-
-namespace astar
-{
-
-inline double calcDistance(double x1, double y1, double x2, double y2)
-{
-  return std::hypot(x2 - x1, y2 - y1);
-}
-
-inline double modifyTheta(double theta)
-{
-  if (theta &lt; 0)
-    return theta + 2 * M_PI;
-  if (theta &gt;= 2 * M_PI)
-    return theta - 2 * M_PI;
-
-  return theta;
-}
-
-inline geometry_msgs::Pose transformPose(geometry_msgs::Pose &amp;pose, tf::Transform &amp;tf)
-{
-  // Convert ROS pose to TF pose
-  tf::Pose tf_pose;
-  tf::poseMsgToTF(pose, tf_pose);
-
-  // Transform pose
-  tf_pose = tf * tf_pose;
-
-  // Convert TF pose to ROS pose
-  geometry_msgs::Pose ros_pose;
-  tf::poseTFToMsg(tf_pose, ros_pose);
-
-  return ros_pose;
-}
-
-inline WaveFrontNode getWaveFrontNode(int x, int y, double cost)
-{
-  WaveFrontNode node(x, y, cost);
-
-  return node;
-}
-
-inline geometry_msgs::Point calcRelativeCoordinate(geometry_msgs::Pose pose, tf::Point point)
-{
-  tf::Transform transform;
-  tf::poseMsgToTF(pose, transform);
-  transform = transform.inverse();
-
-  point = transform * point;
-  geometry_msgs::Point point_msg;
-  tf::pointTFToMsg(point, point_msg);
-
-  return point_msg;
-}
-
-inline double calcDiffOfRadian(double a, double b)
-{
-  double diff = std::fabs(a - b);
-  if (diff &lt; M_PI)
-    return diff;
-  else
-    return 2 * M_PI - diff;
-}
-
-} // namespace astar
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\freespace_planner\nodes\astar_navi\astar_navi.cpp" new_path="" added_lines="0" deleted_lines="103">
				<diff>@@ -1,103 +0,0 @@
-#include "astar_search.h"
-#include "search_info_ros.h"
-#include "autoware_msgs/LaneArray.h"
-
-namespace
-{
-
-void publishPathAsWaypoints(const ros::Publisher&amp; pub, const nav_msgs::Path&amp; path, const double waypoint_velocity_kmph)
-{
-  autoware_msgs::Lane lane;
-
-  lane.header = path.header;
-  lane.increment = 0;
-  for (const auto&amp; pose : path.poses) {
-    autoware_msgs::Waypoint wp;
-    wp.pose = pose;
-    wp.twist.twist.linear.x = waypoint_velocity_kmph / 3.6;
-
-    lane.waypoints.push_back(wp);
-  }
-
-  autoware_msgs::LaneArray lane_array;
-  lane_array.lanes.push_back(lane);
-  pub.publish(lane_array);
-
-  return;
-}
-
-}
-
-int main(int argc, char **argv)
-{
-  ros::init(argc, argv, "astar_navi");
-  ros::NodeHandle n;
-  ros::NodeHandle private_nh_("~");
-
-  double waypoint_velocity_kmph;
-  std::string map_topic;
-  private_nh_.param&lt;double&gt;("waypoint_velocity_kmph", waypoint_velocity_kmph, 5.0);
-  private_nh_.param&lt;std::string&gt;("map_topic", map_topic, "ring_ogm");
-
-  AstarSearch astar;
-  SearchInfo search_info;
-
-  // ROS subscribers
-  ros::Subscriber map_sub = n.subscribe(map_topic, 1, &amp;SearchInfo::mapCallback, &amp;search_info);
-  ros::Subscriber start_sub = n.subscribe("/current_pose", 1, &amp;SearchInfo::currentPoseCallback, &amp;search_info);
-  ros::Subscriber goal_sub  = n.subscribe("/move_base_simple/goal", 1, &amp;SearchInfo::goalCallback, &amp;search_info);
-
-  // ROS publishers
-  ros::Publisher path_pub       = n.advertise&lt;nav_msgs::Path&gt;("astar_path", 1, true);
-  ros::Publisher waypoints_pub  = n.advertise&lt;autoware_msgs::LaneArray&gt;("lane_waypoints_array", 1, true);
-  ros::Publisher debug_pose_pub = n.advertise&lt;geometry_msgs::PoseArray&gt;("debug_pose_array", 1, true);
-
-  ros::Rate loop_rate(10);
-  while (ros::ok()) {
-    ros::spinOnce();
-
-    if (!search_info.getMapSet() || !search_info.getStartSet() || !search_info.getGoalSet()) {
-      loop_rate.sleep();
-      continue;
-    }
-
-    // Reset flag
-    search_info.reset();
-
-    auto start = std::chrono::system_clock::now();
-
-    // Execute astar search
-    bool result = astar.makePlan(search_info.getStartPose().pose, search_info.getGoalPose().pose, search_info.getMap());
-
-    auto end = std::chrono::system_clock::now();
-    auto usec = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count();
-    //std::cout &lt;&lt; "astar msec: " &lt;&lt; usec / 1000.0 &lt;&lt; std::endl;
-    ROS_INFO("astar msec: %lf", usec / 1000.0);
-
-    if(result) {
-      ROS_INFO("Found GOAL!");
-      publishPathAsWaypoints(waypoints_pub, astar.getPath(), waypoint_velocity_kmph);
-
-#if DEBUG
-      astar.publishPoseArray(debug_pose_pub, "/map");
-      path_pub.publish(astar.getPath());
-      astar.broadcastPathTF();
-#endif
-
-    } else {
-      ROS_INFO("can't find goal...");
-
-#if DEBUG
-      astar.publishPoseArray(debug_pose_pub, "/map"); // debug
-      path_pub.publish(astar.getPath());
-#endif
-
-    }
-
-    astar.reset();
-
-    loop_rate.sleep();
-  }
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\freespace_planner\nodes\astar_navi\astar_search.cpp" new_path="" added_lines="0" deleted_lines="664">
				<diff>@@ -1,664 +0,0 @@
-#include "astar_search.h"
-
-AstarSearch::AstarSearch()
-  : node_initialized_(false)
-{
-  ros::NodeHandle private_nh_("~");
-  private_nh_.param&lt;bool&gt;("use_2dnav_goal", use_2dnav_goal_, true);
-  private_nh_.param&lt;std::string&gt;("path_frame", path_frame_, "map");
-  private_nh_.param&lt;int&gt;("angle_size", angle_size_, 40);
-  private_nh_.param&lt;double&gt;("minimum_turning_radius", minimum_turning_radius_, 5.1);
-  private_nh_.param&lt;int&gt;("obstacle_threshold", obstacle_threshold_, 15);
-  private_nh_.param&lt;double&gt;("goal_radius", goal_radius_, 0.15);
-  private_nh_.param&lt;double&gt;("goal_angle", goal_angle_, 6.0);
-  private_nh_.param&lt;bool&gt;("use_back", use_back_, true);
-  private_nh_.param&lt;double&gt;("robot_length", robot_length_, 4.5);
-  private_nh_.param&lt;double&gt;("robot_width", robot_width_, 1.75);
-  private_nh_.param&lt;double&gt;("base2back", base2back_, 0.8);
-  private_nh_.param&lt;double&gt;("curve_weight", curve_weight_, 1.05);
-  private_nh_.param&lt;double&gt;("reverse_weight", reverse_weight_, 2.00);
-  private_nh_.param&lt;bool&gt;("use_wavefront_heuristic", use_wavefront_heuristic_, true);
-  private_nh_.param&lt;double&gt;("reverse_weight", reverse_weight_, 2.00);
-
-  createStateUpdateTable(angle_size_);
-}
-
-AstarSearch::~AstarSearch()
-{
-}
-
-void AstarSearch::resizeNode(int width, int height, int angle_size)
-{
-  nodes_.resize(height);
-
-  for (int i = 0; i &lt; height; i++)
-    nodes_[i].resize(width);
-
-  for (int i = 0; i &lt; height; i++)
-    for (int j = 0; j &lt; width; j++)
-      nodes_[i][j].resize(angle_size);
-}
-
-void AstarSearch::poseToIndex(const geometry_msgs::Pose &amp;pose, int *index_x, int *index_y, int *index_theta)
-{
-  *index_x = pose.position.x / map_info_.resolution;
-  *index_y = pose.position.y / map_info_.resolution;
-
-  tf::Quaternion quat;
-  tf::quaternionMsgToTF(pose.orientation, quat);
-  double yaw = tf::getYaw(quat);
-  if (yaw &lt; 0)
-    yaw += 2 * M_PI;
-
-  // Descretize angle
-  static double one_angle_range = 2 * M_PI / angle_size_;
-  *index_theta = yaw / one_angle_range;
-  *index_theta %= angle_size_;
-}
-
-
-void AstarSearch::createStateUpdateTable(int angle_size)
-{
-  // Vehicle moving for each angle
-  state_update_table_.resize(angle_size);
-
-  // 6 is the number of steering actions
-  // max-left, no-turn, and max-right of forward and backward
-  if (use_back_) {
-    for (int i = 0; i &lt; angle_size; i++)
-      state_update_table_[i].resize(6);
-  } else {
-    for (int i = 0; i &lt; angle_size; i++)
-      state_update_table_[i].resize(3);
-  }
-
-  // Minimum moving distance with one state update
-  //     arc  = r                       * theta
-  double step = minimum_turning_radius_ * (2.0 * M_PI / angle_size_);
-
-  for (int i = 0; i &lt; angle_size; i++) {
-    double descretized_angle = 2.0 * M_PI / angle_size;
-    double robot_angle = descretized_angle * i;
-
-    // Calculate right and left circle
-    // Robot moves along these circles
-    double right_circle_center_x = minimum_turning_radius_ * std::sin(robot_angle);
-    double right_circle_center_y = minimum_turning_radius_ * std::cos(robot_angle) * -1.0;
-    double left_circle_center_x  = right_circle_center_x * -1.0;
-    double left_circle_center_y  = right_circle_center_y * -1.0;
-
-    // Calculate x and y shift to next state
-    NodeUpdate nu;
-    // forward
-    nu.shift_x     = step * std::cos(robot_angle);
-    nu.shift_y     = step * std::sin(robot_angle);
-    nu.rotation    = 0;
-    nu.index_theta = 0;
-    nu.step        = step;
-    nu.curve       = false;
-    nu.back        = false;
-    state_update_table_[i][0] = nu;
-
-    // forward right
-    nu.shift_x     = right_circle_center_x + minimum_turning_radius_ * std::cos(M_PI_2 + robot_angle - descretized_angle);
-    nu.shift_y     = right_circle_center_y + minimum_turning_radius_ * std::sin(M_PI_2 + robot_angle - descretized_angle);
-    nu.rotation    = descretized_angle * -1.0;
-    nu.index_theta = -1;
-    nu.step        = step;
-    nu.curve       = true;
-    nu.back        = false;
-    state_update_table_[i][1] = nu;
-
-    // forward left
-    nu.shift_x     = left_circle_center_x + minimum_turning_radius_ * std::cos(-1.0 * M_PI_2 + robot_angle + descretized_angle);
-    nu.shift_y     = left_circle_center_y + minimum_turning_radius_ * std::sin(-1.0 * M_PI_2 + robot_angle + descretized_angle);
-    nu.rotation    = descretized_angle;
-    nu.index_theta = 1;
-    nu.step        = step;
-    nu.curve       = true;
-    nu.back        = false;
-    state_update_table_[i][2] = nu;
-
-    // We don't use back move
-    if (!use_back_)
-      continue;
-
-    // backward
-    nu.shift_x     = step * std::cos(robot_angle) * -1.0;
-    nu.shift_y     = step * std::sin(robot_angle) * -1.0;
-    nu.rotation    = 0;
-    nu.index_theta = 0;
-    nu.step        = step;
-    nu.curve       = false;
-    nu.back        = true;
-    state_update_table_[i][3] = nu;
-
-    // backward right
-    nu.shift_x     = right_circle_center_x + minimum_turning_radius_ * std::cos(M_PI_2 + robot_angle + descretized_angle);
-    nu.shift_y     = right_circle_center_y + minimum_turning_radius_ * std::sin(M_PI_2 + robot_angle + descretized_angle);
-    nu.rotation    = descretized_angle;
-    nu.index_theta = 1;
-    nu.step        = step;
-    nu.curve       = true;
-    nu.back        = true;
-    state_update_table_[i][4] = nu;
-
-    // backward left
-    nu.shift_x     = left_circle_center_x + minimum_turning_radius_ * std::cos(-1.0 * M_PI_2 + robot_angle - descretized_angle);
-    nu.shift_y     = left_circle_center_y + minimum_turning_radius_ * std::sin(-1.0 * M_PI_2 + robot_angle - descretized_angle);
-    nu.rotation    = descretized_angle * -1.0;
-    nu.index_theta = -1;
-    nu.step        = step;
-    nu.curve       = true;
-    nu.back        = true;
-    state_update_table_[i][5] = nu;
-  }
-
-}
-
-bool AstarSearch::isOutOfRange(int index_x, int index_y)
-{
-  if (index_x &lt; 0 || index_x &gt;= static_cast&lt;int&gt;(map_info_.width) || index_y &lt; 0 || index_y &gt;= static_cast&lt;int&gt;(map_info_.height))
-    return true;
-
-  return false;
-}
-
-void AstarSearch::setPath(const SimpleNode &amp;goal)
-{
-  std_msgs::Header header;
-  header.stamp = ros::Time::now();
-  header.frame_id = path_frame_;
-  path_.header = header;
-
-  // From the goal node to the start node
-  AstarNode *node = &amp;nodes_[goal.index_y][goal.index_x][goal.index_theta];
-
-  while (node != NULL) {
-    // Set tf pose
-    tf::Vector3 origin(node-&gt;x, node-&gt;y, 0);
-    tf::Pose tf_pose;
-    tf_pose.setOrigin(origin);
-    tf_pose.setRotation(tf::createQuaternionFromYaw(node-&gt;theta));
-
-    // Transform path to global frame
-    tf_pose = map2ogm_ * tf_pose;
-
-    // Set path as ros message
-    geometry_msgs::PoseStamped ros_pose;
-    tf::poseTFToMsg(tf_pose, ros_pose.pose);
-    ros_pose.header = header;
-    path_.poses.push_back(ros_pose);
-
-    //----DEBUG-------
-    /*
-    debug_pose_array_.poses.push_back(ros_pose.pose);
-    int index_theta = node-&gt;theta / (2.0 * M_PI / angle_size_);
-    int index_x = node-&gt;x / map_info_.resolution;
-    int index_y = node-&gt;y / map_info_.resolution;
-    SimpleNode sn(index_x, index_y, index_theta, 0, 0);
-    */
-    //detectCollisionPose(sn);
-    //--------------
-
-    // To the next node
-    node = node-&gt;parent;
-  }
-
-  // Reverse the vector to be start to goal order
-  std::reverse(path_.poses.begin(), path_.poses.end());
-}
-
-// theta is 0 ~ 2pi
-bool AstarSearch::isGoal(double x, double y, double theta)
-{
-  // To reduce computation time, we use square value
-  static const double goal_radius = goal_radius_ * goal_radius_; // meter
-  static const double goal_angle  = M_PI * goal_angle_ / 180.0; // degrees -&gt; radian
-
-  // Check the pose of goal
-  if (std::pow(goal_pose_local_.pose.position.x - x, 2) + std::pow(goal_pose_local_.pose.position.y - y, 2) &lt; goal_radius) {
-    // Get goal yaw in 0 ~ 2pi
-    double goal_yaw = astar::modifyTheta(tf::getYaw(goal_pose_local_.pose.orientation));
-
-    // Check the orientation of goal
-    if (astar::calcDiffOfRadian(goal_yaw, theta) &lt; goal_angle)
-      return true;
-  }
-
-  return false;
-}
-
-bool AstarSearch::detectCollision(const SimpleNode &amp;sn)
-{
-  // Define the robot as rectangle
-  static double left   = -1.0 * base2back_;
-  static double right  = robot_length_ - base2back_;
-  static double top    = robot_width_ / 2.0;
-  static double bottom = -1.0 * robot_width_ / 2.0;
-  static double resolution = map_info_.resolution;
-
-  // Coordinate of base_link in OccupancyGrid frame
-  static double one_angle_range = 2.0 * M_PI / angle_size_;
-  double base_x     = sn.index_x * resolution;
-  double base_y     = sn.index_y * resolution;
-  double base_theta = sn.index_theta * one_angle_range;
-
-  // Calculate cos and sin in advance
-  double cos_theta = std::cos(base_theta);
-  double sin_theta = std::sin(base_theta);
-
-  // Convert each point to index and check if the node is Obstacle
-  for (double x = left; x &lt; right; x += resolution) {
-    for (double y = top; y &gt; bottom; y -= resolution) {
-      // 2D point rotation
-      int index_x = (x * cos_theta - y * sin_theta + base_x) / resolution;
-      int index_y = (x * sin_theta + y * cos_theta + base_y) / resolution;
-
-      if (isOutOfRange(index_x, index_y))
-        return true;
-      if (nodes_[index_y][index_x][0].status == STATUS::OBS)
-        return true;
-    }
-  }
-
-  return false;
-}
-
-bool AstarSearch::calcWaveFrontHeuristic(const SimpleNode &amp;sn)
-{
-  // Set start point for wavefront search
-  // This is goal for Astar search
-  nodes_[sn.index_y][sn.index_x][0].hc = 0;
-  WaveFrontNode wf_node(sn.index_x, sn.index_y, 1e-10);
-  std::queue&lt;WaveFrontNode&gt; qu;
-  qu.push(wf_node);
-
-  // State update table for wavefront search
-  // Nodes are expanded for each neighborhood cells (moore neighborhood)
-  double resolution = map_info_.resolution;
-  static std::vector&lt;WaveFrontNode&gt; updates = {
-    astar::getWaveFrontNode( 0,  1, resolution),
-    astar::getWaveFrontNode(-1,  0, resolution),
-    astar::getWaveFrontNode( 1,  0, resolution),
-    astar::getWaveFrontNode( 0, -1, resolution),
-    astar::getWaveFrontNode(-1,  1, std::hypot(resolution, resolution)),
-    astar::getWaveFrontNode( 1,  1, std::hypot(resolution, resolution)),
-    astar::getWaveFrontNode(-1, -1, std::hypot(resolution, resolution)),
-    astar::getWaveFrontNode( 1, -1, std::hypot(resolution, resolution)),
-  };
-
-  // Get start index
-  int start_index_x;
-  int start_index_y;
-  int start_index_theta;
-  poseToIndex(start_pose_local_.pose, &amp;start_index_x, &amp;start_index_y, &amp;start_index_theta);
-
-  // Whether the robot can reach goal
-  bool reachable = false;
-
-  // Start wavefront search
-  while (!qu.empty()) {
-    WaveFrontNode ref = qu.front();
-    qu.pop();
-
-    WaveFrontNode next;
-    for (const auto &amp;u : updates) {
-      next.index_x = ref.index_x + u.index_x;
-      next.index_y = ref.index_y + u.index_y;
-
-      // out of range OR already visited OR obstacle node
-      if (isOutOfRange(next.index_x, next.index_y) ||
-          nodes_[next.index_y][next.index_x][0].hc &gt; 0 ||
-          nodes_[next.index_y][next.index_x][0].status == STATUS::OBS)
-        continue;
-
-      // Take the size of robot into account
-      if (detectCollisionWaveFront(next))
-        continue;
-
-      // Check if we can reach from start to goal
-      if (next.index_x == start_index_x &amp;&amp; next.index_y == start_index_y)
-        reachable = true;
-
-      // Set wavefront heuristic cost
-      next.hc = ref.hc + u.hc;
-      nodes_[next.index_y][next.index_x][0].hc = next.hc;
-
-      qu.push(next);
-    }
-  }
-
-  // End of search
-  return reachable;
-}
-
-// Simple collidion detection for wavefront search
-bool AstarSearch::detectCollisionWaveFront(const WaveFrontNode &amp;ref)
-{
-  // Define the robot as square
-  static double half = robot_width_ / 2;
-  double robot_x = ref.index_x * map_info_.resolution;
-  double robot_y = ref.index_y * map_info_.resolution;
-
-  for (double y = half; y &gt; -1.0 * half; y -= map_info_.resolution) {
-    for (double x = -1.0 * half; x &lt; half; x += map_info_.resolution) {
-      int index_x = (robot_x + x) / map_info_.resolution;
-      int index_y = (robot_y + y) / map_info_.resolution;
-
-      if (isOutOfRange(index_x, index_y))
-        return true;
-
-      if (nodes_[index_y][index_x][0].status == STATUS::OBS)
-        return true;
-    }
-  }
-
-  return false;
-}
-
-void AstarSearch::reset()
-{
-  // Clear path
-  path_.poses.clear();
-
-  // Clear queue
-  std::priority_queue&lt;SimpleNode, std::vector&lt;SimpleNode&gt;, std::greater&lt;SimpleNode&gt;&gt; empty;
-  std::swap(openlist_, empty);
-}
-
-void AstarSearch::setMap(const nav_msgs::OccupancyGrid &amp;map)
-{
-  map_info_ = map.info;
-
-  // TODO: what frame do we use?
-  std::string map_frame = "map";
-  std::string ogm_frame = map.header.frame_id;
-  // Set transform
-  tf::StampedTransform map2ogm_frame;
-  try
-  {
-    tf_listener_.lookupTransform(map_frame, ogm_frame, ros::Time(0), map2ogm_frame);
-  }
-  catch (tf::TransformException ex)
-  {
-    ROS_ERROR("%s", ex.what());
-    return;
-  }
-
-  tf::Transform map2ogm;
-  geometry_msgs::Pose ogm_in_map = astar::transformPose(map_info_.origin, map2ogm_frame);
-  tf::poseMsgToTF(ogm_in_map, map2ogm_);
-
-  // Initialize node according to map size
-  if (!node_initialized_) {
-    resizeNode(map.info.width, map.info.height, angle_size_);
-    node_initialized_ = true;
-  }
-
-  for (size_t i = 0; i &lt; map.info.height; i++) {
-    for (size_t j = 0; j &lt; map.info.width; j++) {
-      // Index of subscribing OccupancyGrid message
-      size_t og_index = i * map.info.width + j;
-      int cost = map.data[og_index];
-
-      // more than threshold or unknown area
-      if (cost &gt; obstacle_threshold_/* || cost &lt; 0 */) {
-        nodes_[i][j][0].status = STATUS::OBS;
-      }
-      else
-      {
-        for (int k = 0; k &lt; angle_size_; k++) {
-          //nodes_[i][j][k].gc     = 0;
-          nodes_[i][j][k].hc     = 0;
-          nodes_[i][j][k].status = STATUS::NONE;
-          nodes_[i][j][k].parent = NULL;
-        }
-      }
-
-    }
-  }
-
-}
-
-bool AstarSearch::setStartNode()
-{
-  // Get index of start pose
-  int index_x;
-  int index_y;
-  int index_theta;
-  poseToIndex(start_pose_local_.pose, &amp;index_x, &amp;index_y, &amp;index_theta);
-  SimpleNode start_sn(index_x, index_y, index_theta, 0, 0);
-
-  // Check if start is valid
-  if (isOutOfRange(index_x, index_y) || detectCollision(start_sn))
-    return false;
-
-  // Set start node
-  AstarNode &amp;start_node = nodes_[index_y][index_x][index_theta];
-  start_node.x      = start_pose_local_.pose.position.x;
-  start_node.y      = start_pose_local_.pose.position.y;
-  start_node.theta  = 2.0 * M_PI / angle_size_ * index_theta;
-  start_node.gc     = 0;
-  start_node.back   = false;
-  start_node.status = STATUS::OPEN;
-  if (!use_wavefront_heuristic_)
-    start_node.hc = astar::calcDistance(start_pose_local_.pose.position.x, start_pose_local_.pose.position.y, goal_pose_local_.pose.position.x, goal_pose_local_.pose.position.y);
-
-  // Push start node to openlist
-  start_sn.cost = start_node.gc + start_node.hc;
-  openlist_.push(start_sn);
-  return true;
-}
-
-bool AstarSearch::setGoalNode()
-{
-  // Get index of goal pose
-  int index_x;
-  int index_y;
-  int index_theta;
-  poseToIndex(goal_pose_local_.pose, &amp;index_x, &amp;index_y, &amp;index_theta);
-
-  SimpleNode goal_sn(index_x, index_y, index_theta, 0, 0);
-
-  // Check if goal is valid
-  if (isOutOfRange(index_x, index_y) || detectCollision(goal_sn))
-    return false;
-
-  // Calculate wavefront heuristic cost
-  if (use_wavefront_heuristic_) {
-    bool wavefront_result = calcWaveFrontHeuristic(goal_sn);
-    if (!wavefront_result) {
-      ROS_WARN("Goal is not reachable...");
-      return false;
-    }
-  }
-
-  return true;
-}
-
-bool AstarSearch::search()
-{
-  // -- Start Astar search ----------
-  // If the openlist is empty, search failed
-  while (!openlist_.empty()) {
-
-    // Terminate the search if the count reaches a certain value
-    static int search_count = 0;
-    search_count++;
-    if (search_count &gt; 300000) {
-      ROS_WARN("Exceed time limit");
-      search_count = 0;
-      return false;
-    }
-
-    // Pop minimum cost node from openlist
-    SimpleNode sn;
-    sn = openlist_.top();
-    openlist_.pop();
-    nodes_[sn.index_y][sn.index_x][sn.index_theta].status = STATUS::CLOSED;
-
-    // Expand nodes from this node
-    AstarNode *current_node = &amp;nodes_[sn.index_y][sn.index_x][sn.index_theta];
-
-    // for each update
-    for (const auto &amp;state : state_update_table_[sn.index_theta]) {
-      // Next state
-      double next_x     = current_node-&gt;x + state.shift_x;
-      double next_y     = current_node-&gt;y + state.shift_y;
-      double next_theta = astar::modifyTheta(current_node-&gt;theta + state.rotation);
-      double move_cost  = state.step;
-
-#if DEBUG
-      // Display search process
-      geometry_msgs::Pose p;
-      p.position.x = next_x;
-      p.position.y = next_y;
-      tf::quaternionTFToMsg(tf::createQuaternionFromYaw(next_theta), p.orientation);
-      p = astar::transformPose(p, map2ogm_);
-      debug_pose_array_.poses.push_back(p);
-#endif
-
-      // Increase curve cost
-      if (state.curve)
-        move_cost *= curve_weight_;
-
-      // Increase reverse cost
-      if (current_node-&gt;back != state.back)
-        move_cost *= reverse_weight_;
-
-      // Calculate index of the next state
-      SimpleNode next;
-      next.index_x     = next_x / map_info_.resolution;
-      next.index_y     = next_y / map_info_.resolution;
-      next.index_theta = sn.index_theta + state.index_theta;
-      // Avoid invalid index
-      next.index_theta = (next.index_theta + angle_size_) % angle_size_;
-
-      // Check if the index is valid
-      if (isOutOfRange(next.index_x, next.index_y) || detectCollision(next))
-        continue;
-
-      AstarNode *next_node = &amp;nodes_[next.index_y][next.index_x][next.index_theta];
-      double next_hc       =  nodes_[next.index_y][next.index_x][0].hc;
-
-      // Calculate euclid distance heuristic cost
-      if (!use_wavefront_heuristic_)
-        next_hc = astar::calcDistance(next_x, next_y, goal_pose_local_.pose.position.x, goal_pose_local_.pose.position.y);
-
-      // GOAL CHECK
-      if (isGoal(next_x, next_y, next_theta)) {
-        search_count = 0;
-        next_node-&gt;status = STATUS::OPEN;
-        next_node-&gt;x      = next_x;
-        next_node-&gt;y      = next_y;
-        next_node-&gt;theta  = next_theta;
-        next_node-&gt;gc     = current_node-&gt;gc + move_cost;
-        next_node-&gt;hc     = next_hc;
-        next_node-&gt;back   = state.back;
-        next_node-&gt;parent = current_node;
-
-        setPath(next);
-        return true;
-      }
-
-      // NONE
-      if (next_node-&gt;status == STATUS::NONE) {
-        next_node-&gt;status = STATUS::OPEN;
-        next_node-&gt;x      = next_x;
-        next_node-&gt;y      = next_y;
-        next_node-&gt;theta  = next_theta;
-        next_node-&gt;gc     = current_node-&gt;gc + move_cost;
-        next_node-&gt;hc     = next_hc;
-        next_node-&gt;back   = state.back;
-        next_node-&gt;parent = current_node;
-
-        next.cost = next_node-&gt;gc + next_node-&gt;hc;
-        openlist_.push(next);
-        continue;
-      }
-
-      // OPEN or CLOSED
-      if (next_node-&gt;status == STATUS::OPEN || next_node-&gt;status == STATUS::CLOSED) {
-        if (current_node-&gt;gc + move_cost + next_hc &lt; next_node-&gt;gc + next_hc) {
-          next_node-&gt;status = STATUS::OPEN;
-          next_node-&gt;x      = next_x;
-          next_node-&gt;y      = next_y;
-          next_node-&gt;theta  = next_theta;
-          next_node-&gt;gc     = current_node-&gt;gc + move_cost;
-          next_node-&gt;hc     = next_hc;
-          next_node-&gt;back   = state.back;
-          next_node-&gt;parent = current_node;
-
-          next.cost = next_node-&gt;gc + next_node-&gt;hc;
-          openlist_.push(next);
-          continue;
-        }
-      }
-
-      if (search_count == 0)
-        break;
-
-    } // state update
-
-  }
-
-  // Failed to find path
-  ROS_WARN("Openlist is Empty!");
-  return false;
-}
-
-bool AstarSearch::makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry_msgs::Pose &amp;goal_pose, const nav_msgs::OccupancyGrid &amp;map)
-{
-  start_pose_local_.pose = start_pose;
-  goal_pose_local_.pose  = goal_pose;
-
-  setMap(map);
-
-  if (!setStartNode()) {
-    ROS_WARN("Invalid start pose!");
-    return false;
-  }
-
-  if (!setGoalNode()) {
-    ROS_WARN("Invalid goal pose!");
-    return false;
-  }
-
-  bool result = search();
-
-  return result;
-}
-
-// for debug
-void AstarSearch::publishPoseArray(const ros::Publisher &amp;pub, const std::string &amp;frame)
-{
-  debug_pose_array_.header.frame_id = frame;
-  //debug_pose_array_.poses.push_back(map_info_.origin);
-  debug_pose_array_.poses.push_back(start_pose_.pose);
-  debug_pose_array_.poses.push_back(goal_pose_.pose);
-
-  pub.publish(debug_pose_array_);
-
-  debug_pose_array_.poses.clear();
-}
-
-// for demo
-void AstarSearch::broadcastPathTF()
-{
-  tf::Transform transform;
-
-  // Broadcast from start pose to goal pose
-  for (unsigned int i = 0; i &lt; path_.poses.size(); i++) {
-    tf::Quaternion quat;
-    tf::quaternionMsgToTF(path_.poses[i].pose.orientation, quat);
-    transform.setOrigin(tf::Vector3(path_.poses[i].pose.position.x, path_.poses[i].pose.position.y, path_.poses[i].pose.position.z));
-    transform.setRotation(quat);
-
-    tf_broadcaster_.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "/map", "/astar_path"));
-
-    // sleep 0.1 [sec]
-    usleep(100000);
-  }
-
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\freespace_planner\nodes\astar_navi\astar_search.h" new_path="" added_lines="0" deleted_lines="93">
				<diff>@@ -1,93 +0,0 @@
-#ifndef ASTAR_NAVI_NODE_H
-#define ASTAR_NAVI_NODE_H
-
-#define DEBUG 0
-
-#include "astar_util.h"
-#include &lt;ros/ros.h&gt;
-#include &lt;nav_msgs/OccupancyGrid.h&gt;
-#include &lt;geometry_msgs/PoseArray.h&gt;
-#include &lt;nav_msgs/Path.h&gt;
-#include &lt;tf/transform_broadcaster.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-
-#include &lt;iostream&gt;
-#include &lt;vector&gt;
-#include &lt;queue&gt;
-#include &lt;string&gt;
-#include &lt;chrono&gt;
-
-class AstarSearch
-{
- public:
-  AstarSearch();
-  ~AstarSearch();
-
-  //-- FOR DEBUG -------------------------
-  void publishPoseArray(const ros::Publisher &amp;pub, const std::string &amp;frame);
-  geometry_msgs::PoseArray debug_pose_array_;
-  //--------------------------------------
-
-  bool makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry_msgs::Pose &amp;goal_pose, const nav_msgs::OccupancyGrid &amp;map);
-  void reset();
-  void broadcastPathTF();
-  nav_msgs::Path getPath() {return path_;}
-
- private:
-  bool search();
-  void resizeNode(int width, int height, int angle_size);
-  void createStateUpdateTable(int angle_size);
-  void createStateUpdateTableLocal(int angle_size); //
-  void poseToIndex(const geometry_msgs::Pose &amp;pose, int *index_x, int *index_y, int *index_theta);
-  bool isOutOfRange(int index_x, int index_y);
-  void setPath(const SimpleNode &amp;goal);
-  void setMap(const nav_msgs::OccupancyGrid &amp;map);
-  bool setStartNode();
-  bool setGoalNode();
-  bool isGoal(double x, double y, double theta);
-  bool detectCollision(const SimpleNode &amp;sn);
-  bool calcWaveFrontHeuristic(const SimpleNode &amp;sn);
-  bool detectCollisionWaveFront(const WaveFrontNode &amp;sn);
-
-  // ROS param
-  std::string path_frame_;        // publishing path frame
-  int angle_size_;                // descritized angle size
-  double minimum_turning_radius_; // varying by vehicles
-  int obstacle_threshold_;        // more than this value is regarded as obstacles
-  double goal_radius_;            // meter
-  double goal_angle_;             // degree
-  bool use_back_;                 // use backward driving
-  double robot_length_;
-  double robot_width_;
-  double base2back_;
-  double curve_weight_;
-  double reverse_weight_;
-  bool use_wavefront_heuristic_;
-  bool use_2dnav_goal_;
-
-  bool node_initialized_;
-  std::vector&lt;std::vector&lt;NodeUpdate&gt;&gt; state_update_table_;
-  nav_msgs::MapMetaData map_info_;
-  std::vector&lt;std::vector&lt;std::vector&lt;AstarNode&gt;&gt;&gt; nodes_;
-  std::priority_queue&lt;SimpleNode, std::vector&lt;SimpleNode&gt;, std::greater&lt;SimpleNode&gt;&gt; openlist_;
-  std::vector&lt;SimpleNode&gt; goallist_;
-
-  // Pose in global(/map) frame
-  geometry_msgs::PoseStamped start_pose_;
-  geometry_msgs::PoseStamped goal_pose_;
-
-  // Pose in OccupancyGrid frame
-  geometry_msgs::PoseStamped start_pose_local_;
-  geometry_msgs::PoseStamped goal_pose_local_;
-
-  // Transform which converts OccupancyGrid frame to global frame
-  tf::Transform map2ogm_;
-
-  tf::TransformListener tf_listener_;
-  tf::TransformBroadcaster tf_broadcaster_;
-
-  // Searched path
-  nav_msgs::Path path_;
-};
-
-#endif // ASTAR_NAVI_NODE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\freespace_planner\nodes\astar_navi\search_info_ros.cpp" new_path="" added_lines="0" deleted_lines="106">
				<diff>@@ -1,106 +0,0 @@
-#include "search_info_ros.h"
-
-SearchInfo::SearchInfo()
-  : map_set_(false)
-  , start_set_(false)
-  , goal_set_(false)
-{
-}
-
-SearchInfo::~SearchInfo()
-{
-}
-
-void SearchInfo::mapCallback(const nav_msgs::OccupancyGridConstPtr &amp;msg)
-{
-  map_ = *msg;
-
-  // TODO: what frame do we use?
-  std::string map_frame = "map";
-  std::string ogm_frame = msg-&gt;header.frame_id;
-  // Set transform
-  tf::StampedTransform map2ogm_frame;
-  try
-  {
-    tf_listener_.lookupTransform(map_frame, ogm_frame, ros::Time(0), map2ogm_frame);
-  }
-  catch (tf::TransformException ex)
-  {
-    ROS_ERROR("%s", ex.what());
-    return;
-  }
-
-  tf::Transform map2ogm;
-  geometry_msgs::Pose ogm_in_map = astar::transformPose(map_.info.origin, map2ogm_frame);
-  tf::poseMsgToTF(ogm_in_map, map2ogm);
-  ogm2map_ = map2ogm.inverse();
-
-  map_set_ = true;
-}
-
-
-void SearchInfo::startCallback(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;msg)
-{
-  if (!map_set_)
-    return;
-
-  start_pose_global_.header = msg-&gt;header;
-  start_pose_global_.pose   = msg-&gt;pose.pose;
-  start_pose_local_.pose    = astar::transformPose(start_pose_global_.pose, ogm2map_);
-  start_pose_local_.header  = start_pose_global_.header;
-
-  start_set_ = true;
-}
-
-
-void SearchInfo::currentPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
-{
-  if (!map_set_)
-    return;
-
-  start_pose_global_ = *msg;
-  start_pose_local_.pose = astar::transformPose(start_pose_global_.pose, ogm2map_);
-
-  start_set_ = true;
-}
-
-
-void SearchInfo::goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
-{
-  if (!map_set_)
-    return;
-
-  ROS_INFO("Subcscribed goal pose!");
-
-  // TODO: what frame do we use?
-  std::string global_frame  = "map";
-  std::string goal_frame  = msg-&gt;header.frame_id;
-
-  // Get transform (map to world in Autoware)
-  tf::StampedTransform map2world;
-  try
-  {
-    tf_listener_.lookupTransform(global_frame, goal_frame, ros::Time(0), map2world);
-  }
-  catch (tf::TransformException ex)
-  {
-    ROS_ERROR("%s", ex.what());
-    return;
-  }
-
-  // Set pose in Global frame
-  geometry_msgs::Pose msg_pose = msg-&gt;pose;
-  goal_pose_global_.pose   = astar::transformPose(msg_pose, map2world);
-  goal_pose_global_.header = msg-&gt;header;
-  goal_pose_local_.pose    = astar::transformPose(goal_pose_global_.pose, ogm2map_);
-  goal_pose_local_.header = goal_pose_global_.header;
-
-  goal_set_ = true;
-}
-
-void SearchInfo::reset()
-{
-  map_set_   = false;
-  start_set_ = false;
-  goal_set_  = false;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\freespace_planner\nodes\astar_navi\search_info_ros.h" new_path="" added_lines="0" deleted_lines="52">
				<diff>@@ -1,52 +0,0 @@
-#ifndef SEARCH_INFO_ROS_H
-#define SEARCH_INFO_ROS_H
-
-#include "astar_util.h"
-
-#include &lt;nav_msgs/OccupancyGrid.h&gt;
-#include &lt;geometry_msgs/PoseStamped.h&gt;
-#include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-#include &lt;std_msgs/Int32.h&gt;
-
-class SearchInfo
-{
- public:
-  SearchInfo();
-  ~SearchInfo();
-
-  // ROS Callback
-  void mapCallback(const nav_msgs::OccupancyGridConstPtr &amp;msg);
-  void startCallback(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;msg);
-  void goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
-  void currentPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
-
-  // get method
-  bool getMapSet() {return map_set_;}
-  bool getStartSet() {return start_set_;}
-  bool getGoalSet() {return goal_set_;}
-  nav_msgs::OccupancyGrid getMap() {return map_;}
-  geometry_msgs::PoseStamped getStartPose() {return start_pose_local_;}
-  geometry_msgs::PoseStamped getGoalPose() {return goal_pose_local_;}
-
-  // Reset flags
-  void reset();
-
- private:
-  nav_msgs::OccupancyGrid map_;
-  geometry_msgs::PoseStamped start_pose_global_;
-  geometry_msgs::PoseStamped goal_pose_global_;
-  geometry_msgs::PoseStamped start_pose_local_;
-  geometry_msgs::PoseStamped goal_pose_local_;
-  // Transform which converts global frame (/map in Autoware) to OccupancyGrid frame
-  tf::Transform ogm2map_;
-  tf::TransformListener tf_listener_;
-  geometry_msgs::Pose current_pose_;
-
-  // set data flag
-  bool map_set_;
-  bool start_set_;
-  bool goal_set_;
-};
-
-#endif // SEARCH_INFO_ROS_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_search.cpp" new_path="" added_lines="0" deleted_lines="881">
				<diff>@@ -1,881 +0,0 @@
-/*
- * Copyright 2015-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "astar_search.h"
-
-namespace astar_planner
-{
-AstarSearch::AstarSearch() : node_initialized_(false), upper_bound_distance_(-1)
-{
-  ros::NodeHandle private_nh_("~");
-  private_nh_.param&lt;bool&gt;("use_2dnav_goal", use_2dnav_goal_, true);
-  private_nh_.param&lt;std::string&gt;("map_frame", map_frame_, "map");
-  private_nh_.param&lt;int&gt;("angle_size", angle_size_, 48);
-  private_nh_.param&lt;double&gt;("minimum_turning_radius", minimum_turning_radius_, 5.1);
-  private_nh_.param&lt;int&gt;("obstacle_threshold", obstacle_threshold_, 80);
-  private_nh_.param&lt;bool&gt;("use_back", use_back_, true);
-  private_nh_.param&lt;double&gt;("robot_length", robot_length_, 4.5);
-  private_nh_.param&lt;double&gt;("robot_width", robot_width_, 1.75);
-  private_nh_.param&lt;double&gt;("base2back", base2back_, 0.8);
-  private_nh_.param&lt;double&gt;("curve_weight", curve_weight_, 1.05);
-  private_nh_.param&lt;double&gt;("reverse_weight", reverse_weight_, 2.00);
-  private_nh_.param&lt;double&gt;("distance_heuristic_weight", distance_heuristic_weight_, 1.00);
-  private_nh_.param&lt;double&gt;("potential_weight", potential_weight_, 10.0);
-  private_nh_.param&lt;bool&gt;("use_wavefront_heuristic", use_wavefront_heuristic_, false);
-  private_nh_.param&lt;bool&gt;("use_potential_heuristic", use_potential_heuristic_, true);
-  private_nh_.param&lt;double&gt;("time_limit", time_limit_, 10.0);
-  private_nh_.param&lt;double&gt;("lateral_goal_range", lateral_goal_range_, 0.5);
-  private_nh_.param&lt;double&gt;("longitudinal_goal_range", longitudinal_goal_range_, 2.0);
-  private_nh_.param&lt;double&gt;("goal_angle_range", goal_angle_range_, 24.0);
-  private_nh_.param&lt;bool&gt;("publish_marker", publish_marker_, false);
-
-  createStateUpdateTableLocal(angle_size_);
-}
-
-AstarSearch::~AstarSearch()
-{
-}
-
-void AstarSearch::initializeNode(const nav_msgs::OccupancyGrid &amp;map)
-{
-  int height = map.info.height;
-  int width = map.info.width;
-
-  nodes_.resize(height);
-
-  for (int i = 0; i &lt; height; i++)
-    nodes_[i].resize(width);
-
-  for (int i = 0; i &lt; height; i++)
-    for (int j = 0; j &lt; width; j++)
-      nodes_[i][j].resize(angle_size_);
-
-  node_initialized_ = true;
-}
-
-void AstarSearch::poseToIndex(const geometry_msgs::Pose &amp;pose, int *index_x, int *index_y, int *index_theta)
-{
-  *index_x = pose.position.x / map_info_.resolution;
-  *index_y = pose.position.y / map_info_.resolution;
-
-  tf::Quaternion quat;
-  tf::quaternionMsgToTF(pose.orientation, quat);
-  double yaw = tf::getYaw(quat);
-  if (yaw &lt; 0)
-    yaw += 2 * M_PI;
-
-  // Descretize angle
-  static double one_angle_range = 2 * M_PI / angle_size_;
-  *index_theta = yaw / one_angle_range;
-  *index_theta %= angle_size_;
-}
-
-// state update table for local hybrid astar
-// five (for now) expansion to forward for each update
-void AstarSearch::createStateUpdateTableLocal(int angle_size)
-{
-  // Vehicle moving for each angle
-  state_update_table_.resize(angle_size);
-
-  // the number of steering actions
-  int max_action_num = 9;
-  for (int i = 0; i &lt; angle_size; i++)
-    state_update_table_[i].reserve(max_action_num);
-
-  // Minimum moving distance with one state update
-  //     arc  = r                       * theta
-  double step = minimum_turning_radius_ * (2.0 * M_PI / angle_size_);
-
-  for (int i = 0; i &lt; angle_size; i++)
-  {
-    double descretized_angle = 2.0 * M_PI / angle_size;
-    double robot_angle = descretized_angle * i;
-
-    // Calculate right and left circle
-    // Robot moves along these circles
-    double right_circle_center_x = minimum_turning_radius_ * std::sin(robot_angle);
-    double right_circle_center_y = minimum_turning_radius_ * std::cos(robot_angle) * -1.0;
-    double left_circle_center_x = right_circle_center_x * -1.0;
-    double left_circle_center_y = right_circle_center_y * -1.0;
-
-    NodeUpdate nu;
-
-    // Calculate x and y shift to next state
-    // forward
-    nu.shift_x = step * std::cos(robot_angle);
-    nu.shift_y = step * std::sin(robot_angle);
-    nu.rotation = 0;
-    nu.index_theta = 0;
-    nu.step = step;
-    nu.curve = false;
-    nu.back = false;
-    state_update_table_[i].emplace_back(nu);
-
-    /*
-    // forward right max
-    nu.shift_x     = right_circle_center_x + minimum_turning_radius_ * std::cos(M_PI_2 + robot_angle -
-    descretized_angle);
-    nu.shift_y     = right_circle_center_y + minimum_turning_radius_ * std::sin(M_PI_2 + robot_angle -
-    descretized_angle);
-    nu.rotation    = descretized_angle * -1.0;
-    nu.index_theta = -1;
-    nu.step        = step;
-    nu.curve       = true;
-    nu.back        = false;
-    state_update_table_[i].emplace_back(nu);
-
-    // forward left max
-    nu.shift_x     = left_circle_center_x + minimum_turning_radius_ * std::cos(-1.0 * M_PI_2 + robot_angle +
-    descretized_angle);
-    nu.shift_y     = left_circle_center_y + minimum_turning_radius_ * std::sin(-1.0 * M_PI_2 + robot_angle +
-    descretized_angle);
-    nu.rotation    = descretized_angle;
-    nu.index_theta = 1;
-    nu.step        = step;
-    nu.curve       = true;
-    nu.back        = false;
-    state_update_table_[i].emplace_back(nu);
-    */
-
-    // forward right medium
-    nu.shift_x =
-        right_circle_center_x * 2 + minimum_turning_radius_ * 2 * std::cos(M_PI_2 + robot_angle - descretized_angle);
-    nu.shift_y =
-        right_circle_center_y * 2 + minimum_turning_radius_ * 2 * std::sin(M_PI_2 + robot_angle - descretized_angle);
-    nu.rotation = descretized_angle * -1.0;
-    nu.index_theta = -1;
-    nu.step = step * 2;
-    nu.curve = true;
-    nu.back = false;
-    state_update_table_[i].emplace_back(nu);
-
-    // forward left medium
-    nu.shift_x = left_circle_center_x * 2 +
-                 minimum_turning_radius_ * 2 * std::cos(-1.0 * M_PI_2 + robot_angle + descretized_angle);
-    nu.shift_y = left_circle_center_y * 2 +
-                 minimum_turning_radius_ * 2 * std::sin(-1.0 * M_PI_2 + robot_angle + descretized_angle);
-    nu.rotation = descretized_angle;
-    nu.index_theta = 1;
-    nu.step = step * 2;
-    nu.curve = true;
-    nu.back = false;
-    state_update_table_[i].emplace_back(nu);
-
-    /*
-    // forward right max
-    nu.shift_x     = right_circle_center_x + minimum_turning_radius_ * std::cos(M_PI_2 + robot_angle - descretized_angle
-    * 2);
-    nu.shift_y     = right_circle_center_y + minimum_turning_radius_ * std::sin(M_PI_2 + robot_angle - descretized_angle
-    * 2);
-    nu.rotation    = descretized_angle * 2 * -1.0;
-    nu.index_theta = -2;
-    nu.step        = step * 2;
-    nu.curve       = true;
-    nu.back        = false;
-    state_update_table_[i].emplace_back(nu);
-
-    // forward left max
-    nu.shift_x     = left_circle_center_x + minimum_turning_radius_ * std::cos(-1.0 * M_PI_2 + robot_angle +
-    descretized_angle * 2);
-    nu.shift_y     = left_circle_center_y + minimum_turning_radius_ * std::sin(-1.0 * M_PI_2 + robot_angle +
-    descretized_angle * 2);
-    nu.rotation    = descretized_angle * 2;
-    nu.index_theta = 2;
-    nu.step        = step * 2;
-    nu.curve       = true;
-    nu.back        = false;
-    state_update_table_[i].emplace_back(nu);
-    */
-  }
-}
-//---
-
-bool AstarSearch::isOutOfRange(int index_x, int index_y)
-{
-  if (index_x &lt; 0 || index_x &gt;= static_cast&lt;int&gt;(map_info_.width) || index_y &lt; 0 ||
-      index_y &gt;= static_cast&lt;int&gt;(map_info_.height))
-    return true;
-
-  return false;
-}
-
-void AstarSearch::displayFootprint(const nav_msgs::Path &amp;path)
-{
-  visualization_msgs::Marker marker;
-  marker.header.frame_id = "/map";
-  marker.header.stamp = ros::Time();
-  marker.ns = "footprint";
-  marker.id = 0;
-  marker.type = visualization_msgs::Marker::CUBE;
-  marker.action = visualization_msgs::Marker::ADD;
-
-  marker.scale.x = robot_length_;
-  marker.scale.y = robot_width_;
-  marker.scale.z = 2.0;
-  marker.color.a = 0.3;
-  marker.color.r = 0.0;
-  marker.color.g = 1.0;
-  marker.color.b = 0.0;
-  marker.frame_locked = true;
-
-  visualization_msgs::MarkerArray marker_array;
-  for (const auto &amp;p : path.poses)
-  {
-    marker.pose = p.pose;
-    marker_array.markers.push_back(marker);
-    marker.id += 1;
-  }
-
-  footprint_pub_.publish(marker_array);
-}
-
-void AstarSearch::setPath(const SimpleNode &amp;goal)
-{
-  std_msgs::Header header;
-  header.stamp = ros::Time::now();
-  header.frame_id = map_frame_;
-  path_.header = header;
-
-  // From the goal node to the start node
-  AstarNode *node = &amp;nodes_[goal.index_y][goal.index_x][goal.index_theta];
-
-  while (node != NULL)
-  {
-    // Set tf pose
-    tf::Vector3 origin(node-&gt;x, node-&gt;y, 0);
-    tf::Pose tf_pose;
-    tf_pose.setOrigin(origin);
-    tf_pose.setRotation(tf::createQuaternionFromYaw(node-&gt;theta));
-
-    // Transform path to global frame
-    tf_pose = map2ogm_ * tf_pose;
-
-    // Set path as ros message
-    geometry_msgs::PoseStamped ros_pose;
-    tf::poseTFToMsg(tf_pose, ros_pose.pose);
-    ros_pose.header = header;
-    path_.poses.push_back(ros_pose);
-
-    // To the next node
-    node = node-&gt;parent;
-  }
-
-  // Reverse the vector to be start to goal order
-  std::reverse(path_.poses.begin(), path_.poses.end());
-
-  if (publish_marker_)
-    displayFootprint(path_);
-}
-
-// Check if the next state is the goal
-// Check lateral offset, longitudinal offset and angle
-bool AstarSearch::isGoal(double x, double y, double theta)
-{
-  // To reduce computation time, we use square value for distance
-  static const double lateral_goal_range =
-      lateral_goal_range_ / 2.0;  // [meter], divide by 2 means we check left and right
-  static const double longitudinal_goal_range =
-      longitudinal_goal_range_ / 2.0;                                         // [meter], check only behind of the goal
-  static const double goal_angle = M_PI * (goal_angle_range_ / 2.0) / 180.0;  // degrees -&gt; radian
-
-  // Calculate the node coordinate seen from the goal point
-  tf::Point p(x, y, 0);
-  geometry_msgs::Point relative_node_point = astar_planner::calcRelativeCoordinate(goal_pose_local_.pose, p);
-
-  // Check Pose of goal
-  if (relative_node_point.x &lt; 0 &amp;&amp;  // shoud be behind of goal
-      std::fabs(relative_node_point.x) &lt; longitudinal_goal_range &amp;&amp;
-      std::fabs(relative_node_point.y) &lt; lateral_goal_range)
-  {
-    // Check the orientation of goal
-    if (astar_planner::calcDiffOfRadian(goal_yaw_, theta) &lt; goal_angle)
-      return true;
-  }
-
-  return false;
-}
-
-bool AstarSearch::isObs(int index_x, int index_y)
-{
-  if (nodes_[index_y][index_x][0].status == STATUS::OBS)
-    return true;
-
-  return false;
-}
-
-bool AstarSearch::detectCollision(const SimpleNode &amp;sn)
-{
-  // Define the robot as rectangle
-  static double left = -1.0 * base2back_;
-  static double right = robot_length_ - base2back_;
-  static double top = robot_width_ / 2.0;
-  static double bottom = -1.0 * robot_width_ / 2.0;
-  static double resolution = map_info_.resolution;
-
-  // Coordinate of base_link in OccupancyGrid frame
-  static double one_angle_range = 2.0 * M_PI / angle_size_;
-  double base_x = sn.index_x * resolution;
-  double base_y = sn.index_y * resolution;
-  double base_theta = sn.index_theta * one_angle_range;
-
-  // Calculate cos and sin in advance
-  double cos_theta = std::cos(base_theta);
-  double sin_theta = std::sin(base_theta);
-
-  // Convert each point to index and check if the node is Obstacle
-  for (double x = left; x &lt; right; x += resolution)
-  {
-    for (double y = top; y &gt; bottom; y -= resolution)
-    {
-      // 2D point rotation
-      int index_x = (x * cos_theta - y * sin_theta + base_x) / resolution;
-      int index_y = (x * sin_theta + y * cos_theta + base_y) / resolution;
-
-      if (isOutOfRange(index_x, index_y))
-        return true;
-      if (nodes_[index_y][index_x][0].status == STATUS::OBS)
-        return true;
-    }
-  }
-
-  return false;
-}
-
-bool AstarSearch::calcWaveFrontHeuristic(const SimpleNode &amp;sn)
-{
-  // Set start point for wavefront search
-  // This is goal for Astar search
-  nodes_[sn.index_y][sn.index_x][0].hc = 0;
-  WaveFrontNode wf_node(sn.index_x, sn.index_y, 1e-10);
-  std::queue&lt;WaveFrontNode&gt; qu;
-  qu.push(wf_node);
-
-  // State update table for wavefront search
-  // Nodes are expanded for each neighborhood cells (moore neighborhood)
-  double resolution = map_info_.resolution;
-  static std::vector&lt;WaveFrontNode&gt; updates = {
-    astar_planner::getWaveFrontNode(0, 1, resolution), astar_planner::getWaveFrontNode(-1, 0, resolution),
-    astar_planner::getWaveFrontNode(1, 0, resolution), astar_planner::getWaveFrontNode(0, -1, resolution),
-    astar_planner::getWaveFrontNode(-1, 1, std::hypot(resolution, resolution)),
-    astar_planner::getWaveFrontNode(1, 1, std::hypot(resolution, resolution)),
-    astar_planner::getWaveFrontNode(-1, -1, std::hypot(resolution, resolution)),
-    astar_planner::getWaveFrontNode(1, -1, std::hypot(resolution, resolution)),
-  };
-
-  // Get start index
-  int start_index_x;
-  int start_index_y;
-  int start_index_theta;
-  poseToIndex(start_pose_local_.pose, &amp;start_index_x, &amp;start_index_y, &amp;start_index_theta);
-
-  // Whether the robot can reach goal
-  bool reachable = false;
-
-  // Start wavefront search
-  while (!qu.empty())
-  {
-    WaveFrontNode ref = qu.front();
-    qu.pop();
-
-    WaveFrontNode next;
-    for (const auto &amp;u : updates)
-    {
-      next.index_x = ref.index_x + u.index_x;
-      next.index_y = ref.index_y + u.index_y;
-
-      // out of range OR already visited OR obstacle node
-      if (isOutOfRange(next.index_x, next.index_y) || nodes_[next.index_y][next.index_x][0].hc &gt; 0 ||
-          nodes_[next.index_y][next.index_x][0].status == STATUS::OBS)
-        continue;
-
-      // Take the size of robot into account
-      if (detectCollisionWaveFront(next))
-        continue;
-
-      // Check if we can reach from start to goal
-      if (next.index_x == start_index_x &amp;&amp; next.index_y == start_index_y)
-        reachable = true;
-
-      // Set wavefront heuristic cost
-      next.hc = ref.hc + u.hc;
-      nodes_[next.index_y][next.index_x][0].hc = next.hc;
-
-      qu.push(next);
-    }
-  }
-
-  // End of search
-  return reachable;
-}
-
-// Simple collidion detection for wavefront search
-bool AstarSearch::detectCollisionWaveFront(const WaveFrontNode &amp;ref)
-{
-  // Define the robot as square
-  static double half = robot_width_ / 2;
-  double robot_x = ref.index_x * map_info_.resolution;
-  double robot_y = ref.index_y * map_info_.resolution;
-
-  for (double y = half; y &gt; -1.0 * half; y -= map_info_.resolution)
-  {
-    for (double x = -1.0 * half; x &lt; half; x += map_info_.resolution)
-    {
-      int index_x = (robot_x + x) / map_info_.resolution;
-      int index_y = (robot_y + y) / map_info_.resolution;
-
-      if (isOutOfRange(index_x, index_y))
-        return true;
-
-      if (nodes_[index_y][index_x][0].status == STATUS::OBS)
-        return true;
-    }
-  }
-
-  return false;
-}
-
-void AstarSearch::reset()
-{
-  path_.poses.clear();
-  debug_poses_.poses.clear();
-
-  // Clear queue
-  std::priority_queue&lt;SimpleNode, std::vector&lt;SimpleNode&gt;, std::greater&lt;SimpleNode&gt;&gt; empty;
-  std::swap(openlist_, empty);
-
-  ros::WallTime begin = ros::WallTime::now();
-
-  // Reset node info here ...?
-  for (size_t i = 0; i &lt; map_info_.height; i++)
-  {
-    for (size_t j = 0; j &lt; map_info_.width; j++)
-    {
-      for (int k = 0; k &lt; angle_size_; k++)
-      {
-        // other values will be updated during the search
-        nodes_[i][j][k].status = STATUS::NONE;
-        nodes_[i][j][k].hc = 0;
-      }
-    }
-  }
-
-  ros::WallTime end = ros::WallTime::now();
-
-  ROS_INFO("reset time: %lf [ms]", (end - begin).toSec() * 1000);
-}
-
-void AstarSearch::setMap(const nav_msgs::OccupancyGrid &amp;map)
-{
-  map_info_ = map.info;
-
-  std::string map_frame = map_frame_;
-  std::string ogm_frame = map.header.frame_id;
-  // Set transform
-  tf::StampedTransform map2ogm_frame;
-  try
-  {
-    tf_listener_.lookupTransform(map_frame, ogm_frame, ros::Time(0), map2ogm_frame);
-  }
-  catch (tf::TransformException ex)
-  {
-    ROS_ERROR("%s", ex.what());
-    return;
-  }
-
-  tf::Transform map2ogm;
-  geometry_msgs::Pose ogm_in_map = astar_planner::transformPose(map_info_.origin, map2ogm_frame);
-  tf::poseMsgToTF(ogm_in_map, map2ogm_);
-
-  for (size_t i = 0; i &lt; map.info.height; i++)
-  {
-    for (size_t j = 0; j &lt; map.info.width; j++)
-    {
-      // Index of subscribing OccupancyGrid message
-      size_t og_index = i * map.info.width + j;
-      int cost = map.data[og_index];
-
-      // hc is set to be 0 when reset()
-      if (cost == 0)
-        continue;
-
-      if (use_potential_heuristic_)
-      {
-        // the cost more than threshold is regarded almost same as an obstacle
-        // because of its very high cost
-        if (cost &gt; obstacle_threshold_)
-          nodes_[i][j][0].status = STATUS::OBS;
-        else
-          nodes_[i][j][0].hc = cost * potential_weight_;
-      }
-
-      // obstacle or unknown area
-      if (cost == 100 || cost &lt; 0)
-        nodes_[i][j][0].status = STATUS::OBS;
-    }
-  }
-}
-
-bool AstarSearch::setStartNode()
-{
-  // Get index of start pose
-  int index_x;
-  int index_y;
-  int index_theta;
-  poseToIndex(start_pose_local_.pose, &amp;index_x, &amp;index_y, &amp;index_theta);
-  SimpleNode start_sn(index_x, index_y, index_theta, 0, 0);
-
-  // Check if start is valid
-  if (isOutOfRange(index_x, index_y) || detectCollision(start_sn))
-    return false;
-
-  // Set start node
-  AstarNode &amp;start_node = nodes_[index_y][index_x][index_theta];
-  start_node.x = start_pose_local_.pose.position.x;
-  start_node.y = start_pose_local_.pose.position.y;
-  start_node.theta = 2.0 * M_PI / angle_size_ * index_theta;
-  start_node.gc = 0;
-  start_node.move_distance = 0;
-  start_node.back = false;
-  start_node.status = STATUS::OPEN;
-  start_node.parent = NULL;
-
-  // set euclidean distance heuristic cost
-  if (!use_wavefront_heuristic_ &amp;&amp; !use_potential_heuristic_)
-    start_node.hc = astar_planner::calcDistance(start_pose_local_.pose.position.x, start_pose_local_.pose.position.y,
-                                                goal_pose_local_.pose.position.x, goal_pose_local_.pose.position.y) *
-                    distance_heuristic_weight_;
-
-  if (use_potential_heuristic_)
-  {
-    start_node.gc += start_node.hc;
-    start_node.hc += astar_planner::calcDistance(start_pose_local_.pose.position.x, start_pose_local_.pose.position.y,
-                                                 goal_pose_local_.pose.position.x, goal_pose_local_.pose.position.y) +
-                     distance_heuristic_weight_;
-  }
-
-  // Push start node to openlist
-  start_sn.cost = start_node.gc + start_node.hc;
-  openlist_.push(start_sn);
-  return true;
-}
-
-bool AstarSearch::setGoalNode()
-{
-  goal_yaw_ = astar_planner::modifyTheta(tf::getYaw(goal_pose_local_.pose.orientation));
-
-  // Get index of goal pose
-  int index_x;
-  int index_y;
-  int index_theta;
-  poseToIndex(goal_pose_local_.pose, &amp;index_x, &amp;index_y, &amp;index_theta);
-
-  debug_poses_.header.frame_id = map_frame_;
-  debug_poses_.poses.push_back(astar_planner::transformPose(goal_pose_local_.pose, map2ogm_));
-  debug_pose_pub_.publish(debug_poses_);
-
-  SimpleNode goal_sn(index_x, index_y, index_theta, 0, 0);
-
-  // Check if goal is valid
-  if (isOutOfRange(index_x, index_y) || detectCollision(goal_sn))
-    return false;
-
-  // Make multiple cells goals
-  // createGoalList(goal_sn);
-
-  // Calculate wavefront heuristic cost
-  if (use_wavefront_heuristic_)
-  {
-    auto start = std::chrono::system_clock::now();
-
-    bool wavefront_result = calcWaveFrontHeuristic(goal_sn);
-
-    auto end = std::chrono::system_clock::now();
-    auto usec = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count();
-    std::cout &lt;&lt; "wavefront : " &lt;&lt; usec / 1000.0 &lt;&lt; "[msec]" &lt;&lt; std::endl;
-
-    if (!wavefront_result)
-    {
-      ROS_WARN("reachable is false...");
-      return false;
-    }
-  }
-
-  return true;
-}
-
-bool AstarSearch::search()
-{
-  ros::WallTime timer_begin = ros::WallTime::now();
-
-  // Start A* search
-  // If the openlist is empty, search failed
-  while (!openlist_.empty())
-  {
-    // Check time and terminate if the search reaches the time limit
-    ros::WallTime timer_end = ros::WallTime::now();
-    double msec = (timer_end - timer_begin).toSec() * 1000.0;
-    if (msec &gt; time_limit_)
-    {
-      ROS_WARN("Exceed time limit of %lf [ms]", time_limit_);
-      return false;
-    }
-
-    // Pop minimum cost node from openlist
-    SimpleNode sn;
-    sn = openlist_.top();
-    openlist_.pop();
-
-    // Expand nodes from this node
-    AstarNode *current_node = &amp;nodes_[sn.index_y][sn.index_x][sn.index_theta];
-    current_node-&gt;status = STATUS::CLOSED;
-
-    // Goal check
-    if (isGoal(current_node-&gt;x, current_node-&gt;y, current_node-&gt;theta))
-    {
-      ROS_INFO("Search time: %lf [msec]", (timer_end - timer_begin).toSec() * 1000.0);
-
-      setPath(sn);
-      return true;
-    }
-
-    if (publish_marker_)
-    {
-      geometry_msgs::Pose p = astar_planner::xytToPoseMsg(current_node-&gt;x, current_node-&gt;y, current_node-&gt;theta);
-      p = astar_planner::transformPose(p, map2ogm_);
-      debug_poses_.poses.push_back(p);
-    }
-
-    // Expand nodes
-    for (const auto &amp;state : state_update_table_[sn.index_theta])
-    {
-      // Next state
-      double next_x = current_node-&gt;x + state.shift_x;
-      double next_y = current_node-&gt;y + state.shift_y;
-      double next_theta = astar_planner::modifyTheta(current_node-&gt;theta + state.rotation);
-      double move_cost = state.step;
-      double move_distance = current_node-&gt;move_distance + state.step;
-
-      // Increase reverse cost
-      if (state.back != current_node-&gt;back)
-        move_cost *= reverse_weight_;
-
-      // Calculate index of the next state
-      SimpleNode next;
-      next.index_x = next_x / map_info_.resolution;
-      next.index_y = next_y / map_info_.resolution;
-      next.index_theta = sn.index_theta + state.index_theta;
-
-      // Avoid invalid index
-      next.index_theta = (next.index_theta + angle_size_) % angle_size_;
-
-      // Check if the index is valid
-      if (isOutOfRange(next.index_x, next.index_y) || isObs(next.index_x, next.index_y))
-        continue;
-
-      // prunning with upper bound
-      if (upper_bound_distance_ &gt; 0 &amp;&amp; move_distance &gt; upper_bound_distance_)
-      {
-        continue;
-      }
-
-      AstarNode *next_node = &amp;nodes_[next.index_y][next.index_x][next.index_theta];
-      double next_gc = current_node-&gt;gc + move_cost;
-      double next_hc = nodes_[next.index_y][next.index_x][0].hc;  // wavefront or distance transform heuristic
-
-      // increase the cost with euclidean distance
-      if (use_potential_heuristic_)
-      {
-        next_gc += nodes_[next.index_y][next.index_x][0].hc;
-        next_hc += astar_planner::calcDistance(next_x, next_y, goal_pose_local_.pose.position.x,
-                                               goal_pose_local_.pose.position.y) *
-                   distance_heuristic_weight_;
-      }
-
-      // increase the cost with euclidean distance
-      if (!use_wavefront_heuristic_ &amp;&amp; !use_potential_heuristic_)
-        next_hc = astar_planner::calcDistance(next_x, next_y, goal_pose_local_.pose.position.x,
-                                              goal_pose_local_.pose.position.y) *
-                  distance_heuristic_weight_;
-
-      // NONE
-      if (next_node-&gt;status == STATUS::NONE)
-      {
-        next_node-&gt;status = STATUS::OPEN;
-        next_node-&gt;x = next_x;
-        next_node-&gt;y = next_y;
-        next_node-&gt;theta = next_theta;
-        next_node-&gt;gc = next_gc;
-        next_node-&gt;hc = next_hc;
-        next_node-&gt;move_distance = move_distance;
-        next_node-&gt;back = state.back;
-        next_node-&gt;parent = current_node;
-
-        next.cost = next_node-&gt;gc + next_node-&gt;hc;
-        openlist_.push(next);
-        continue;
-      }
-
-      // OPEN or CLOSED
-      if (next_node-&gt;status == STATUS::OPEN || next_node-&gt;status == STATUS::CLOSED)
-      {
-        if (next_gc &lt; next_node-&gt;gc)
-        {
-          next_node-&gt;status = STATUS::OPEN;
-          next_node-&gt;x = next_x;
-          next_node-&gt;y = next_y;
-          next_node-&gt;theta = next_theta;
-          next_node-&gt;gc = next_gc;
-          next_node-&gt;hc = next_hc;  // already calculated ?
-          next_node-&gt;move_distance = move_distance;
-          next_node-&gt;back = state.back;
-          next_node-&gt;parent = current_node;
-
-          next.cost = next_node-&gt;gc + next_node-&gt;hc;
-          openlist_.push(next);
-          continue;
-        }
-      }
-
-    }  // state update
-  }
-
-  // Failed to find path
-  ROS_INFO("Open list is empty...");
-  return false;
-}
-
-bool AstarSearch::makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry_msgs::Pose &amp;goal_pose,
-                           const nav_msgs::OccupancyGrid &amp;map, double upper_bound_distance)
-{
-  start_pose_local_.pose = start_pose;
-  goal_pose_local_.pose = goal_pose;
-  upper_bound_distance_ = upper_bound_distance;
-
-  ROS_INFO("Prunning with upper bound %lf", upper_bound_distance_);
-
-  ros::WallTime begin = ros::WallTime::now();
-  setMap(map);
-  ros::WallTime end = ros::WallTime::now();
-  std::cout &lt;&lt; "set map time: " &lt;&lt; (end - begin).toSec() * 1000 &lt;&lt; "[ms]" &lt;&lt; std::endl;
-
-  if (!setStartNode())
-  {
-    ROS_WARN("Invalid start pose!");
-    return false;
-  }
-
-  if (!setGoalNode())
-  {
-    ROS_WARN("Invalid goal pose!");
-    return false;
-  }
-
-  bool result = search();
-
-  if (publish_marker_)
-    debug_pose_pub_.publish(debug_poses_);
-
-  return result;
-}
-
-// Allow two goals (reach goal2 via goal1)
-bool AstarSearch::makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry_msgs::Pose &amp;transit_pose,
-                           const geometry_msgs::Pose &amp;goal_pose, const nav_msgs::OccupancyGrid &amp;map,
-                           double upper_bound_distance)
-{
-  start_pose_local_.pose = start_pose;
-  goal_pose_local_.pose = transit_pose;
-
-  auto start = std::chrono::system_clock::now();
-  setMap(map);
-  auto end = std::chrono::system_clock::now();
-  auto usec = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count();
-  std::cout &lt;&lt; "set map: " &lt;&lt; usec / 1000.0 &lt;&lt; std::endl;
-
-  if (!setStartNode())
-  {
-    ROS_WARN("Invalid start pose!");
-    return false;
-  }
-
-  if (!setGoalNode())
-  {
-    ROS_WARN("Invalid goal pose!");
-    return false;
-  }
-
-  // First search from start to a transit point
-  bool result = search();
-
-  if (publish_marker_)
-    debug_pose_pub_.publish(debug_poses_);
-
-  if (!result)
-    return false;
-
-  // Prepare for the second search
-  nav_msgs::Path start2transit = path_;
-  reset();
-
-  start_pose_local_.pose = transit_pose;
-  goal_pose_local_.pose = goal_pose;
-
-  if (!setStartNode())
-  {
-    ROS_WARN("Invalid start pose!");
-    return false;
-  }
-
-  if (!setGoalNode())
-  {
-    ROS_WARN("Invalid goal pose!");
-    return false;
-  }
-
-  // second search from a transit point to goal
-  result = search();
-
-  // join two paths
-  path_.poses.reserve(start2transit.poses.size() + path_.poses.size());
-  path_.poses.insert(path_.poses.begin(), start2transit.poses.begin(), start2transit.poses.end());
-
-  if (publish_marker_)
-    debug_pose_pub_.publish(debug_poses_);
-
-  return result;
-}
-
-void AstarSearch::broadcastPathTF()
-{
-  tf::Transform transform;
-
-  // Broadcast from start pose to goal pose
-  for (int i = path_.poses.size() - 1; i &gt;= 0; i--)
-  {
-    tf::Quaternion quat;
-    tf::quaternionMsgToTF(path_.poses[i].pose.orientation, quat);
-    transform.setOrigin(
-        tf::Vector3(path_.poses[i].pose.position.x, path_.poses[i].pose.position.y, path_.poses[i].pose.position.z));
-    transform.setRotation(quat);
-
-    tf_broadcaster_.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "/map", "/astar_path"));
-
-    // sleep 0.1 [sec]
-    usleep(100000);
-  }
-}
-
-}  // namespace astar_planner
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_search.h" new_path="" added_lines="0" deleted_lines="137">
				<diff>@@ -1,137 +0,0 @@
-/*
- * Copyright 2015-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ASTAR_NAVI_NODE_H
-#define ASTAR_NAVI_NODE_H
-
-#include "astar_util.h"
-#include &lt;ros/ros.h&gt;
-#include &lt;nav_msgs/OccupancyGrid.h&gt;
-#include &lt;geometry_msgs/PoseArray.h&gt;
-#include &lt;nav_msgs/Path.h&gt;
-#include &lt;tf/transform_broadcaster.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-
-#include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;iostream&gt;
-#include &lt;vector&gt;
-#include &lt;queue&gt;
-#include &lt;string&gt;
-#include &lt;chrono&gt;
-
-namespace astar_planner
-{
-class AstarSearch
-{
-public:
-  AstarSearch();
-  ~AstarSearch();
-
-  bool makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry_msgs::Pose &amp;goal_pose,
-                const nav_msgs::OccupancyGrid &amp;map, const double upper_bound_distance = -1);
-  bool makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry_msgs::Pose &amp;transit_pose,
-                const geometry_msgs::Pose &amp;goal_pose, const nav_msgs::OccupancyGrid &amp;map,
-                const double upper_bound_distance = -1);
-  void reset();
-  // void initializeNode(int width, int height, int angle_size);
-  void initializeNode(const nav_msgs::OccupancyGrid &amp;map);
-  void broadcastPathTF();
-  bool getNodeInitialized() const
-  {
-    return node_initialized_;
-  }
-  nav_msgs::Path getPath() const
-  {
-    return path_;
-  }
-
-private:
-  bool search();
-  // void createStateUpdateTable(int angle_size);
-  void createStateUpdateTableLocal(int angle_size);  //
-  void poseToIndex(const geometry_msgs::Pose &amp;pose, int *index_x, int *index_y, int *index_theta);
-  bool isOutOfRange(int index_x, int index_y);
-  void setPath(const SimpleNode &amp;goal);
-  void setMap(const nav_msgs::OccupancyGrid &amp;map);
-  bool setStartNode();
-  bool setGoalNode();
-  bool isGoal(double x, double y, double theta);
-  bool isObs(int index_x, int index_y);
-  bool detectCollision(const SimpleNode &amp;sn);
-  bool calcWaveFrontHeuristic(const SimpleNode &amp;sn);
-  bool detectCollisionWaveFront(const WaveFrontNode &amp;sn);
-
-  // for debug
-  ros::NodeHandle n_;
-  geometry_msgs::PoseArray debug_poses_;
-  ros::Publisher debug_pose_pub_ = n_.advertise&lt;geometry_msgs::PoseArray&gt;("astar_debug_poses", 1, true);
-  ros::Publisher footprint_pub_ = n_.advertise&lt;visualization_msgs::MarkerArray&gt;("astar_footprint", 1, true);
-  void displayFootprint(const nav_msgs::Path &amp;path);
-
-  // ROS param
-  std::string map_frame_;          // publishing path frame
-  int angle_size_;                 // descritized angle size
-  double minimum_turning_radius_;  // varying by vehicles
-  int obstacle_threshold_;         // more than this value is regarded as obstacles
-  bool use_back_;                  // use backward driving
-  double robot_length_;
-  double robot_width_;
-  double base2back_;
-  double curve_weight_;
-  double reverse_weight_;
-  double distance_heuristic_weight_;
-  double potential_weight_;
-  bool use_wavefront_heuristic_;
-  bool use_potential_heuristic_;
-  bool use_2dnav_goal_;
-  double time_limit_;  // msec
-  double lateral_goal_range_;
-  double longitudinal_goal_range_;
-  double goal_angle_range_;
-  bool publish_marker_;
-
-  bool node_initialized_;
-  std::vector&lt;std::vector&lt;NodeUpdate&gt;&gt; state_update_table_;
-  nav_msgs::MapMetaData map_info_;
-  std::vector&lt;std::vector&lt;std::vector&lt;AstarNode&gt;&gt;&gt; nodes_;
-  std::priority_queue&lt;SimpleNode, std::vector&lt;SimpleNode&gt;, std::greater&lt;SimpleNode&gt;&gt; openlist_;
-  std::vector&lt;SimpleNode&gt; goallist_;
-
-  // Pose in global(/map) frame
-  geometry_msgs::PoseStamped start_pose_;
-  geometry_msgs::PoseStamped goal_pose_;
-  double goal_yaw_;
-
-  // Pose in OccupancyGrid frame
-  geometry_msgs::PoseStamped start_pose_local_;
-  geometry_msgs::PoseStamped goal_pose_local_;
-
-  // Transform which converts OccupancyGrid frame to global frame
-  tf::Transform map2ogm_;
-
-  tf::TransformListener tf_listener_;
-  tf::TransformBroadcaster tf_broadcaster_;
-
-  // for prunning
-  double upper_bound_distance_;
-
-  // Searched path
-  nav_msgs::Path path_;
-};
-
-}  // namespace astar_planner
-
-#endif  // ASTAR_NAVI_NODE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_avoid.cpp" new_path="" added_lines="0" deleted_lines="230">
				<diff>@@ -1,230 +0,0 @@
-/*
- * Copyright 2015-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "astar_search.h"
-#include "search_info_ros.h"
-
-#include &lt;autoware_msgs/LaneArray.h&gt;
-
-namespace
-{
-autoware_msgs::Lane createPublishWaypoints(const autoware_msgs::Lane&amp; ref_lane, int closest_waypoint,
-                                                    int size)
-{
-  autoware_msgs::Lane follow_lane;
-
-  follow_lane.header = ref_lane.header;
-  follow_lane.increment = ref_lane.increment;
-
-  // Push "size" waypoints from closest
-  for (int i = 0; i &lt; size; i++)
-  {
-    if (closest_waypoint + i &gt;= static_cast&lt;int&gt;(ref_lane.waypoints.size()))
-      break;
-
-    follow_lane.waypoints.push_back(ref_lane.waypoints[closest_waypoint + i]);
-  }
-
-  return follow_lane;
-}
-
-void createAvoidWaypoints(const nav_msgs::Path&amp; astar_path, const astar_planner::SearchInfo&amp; search_info, int size,
-                          autoware_msgs::Lane* avoid_lane, int* end_of_avoid_index)
-{
-  int closest_waypoint_index = search_info.getClosestWaypointIndex();
-
-  avoid_lane-&gt;waypoints.clear();
-
-  // Get global lane
-  const autoware_msgs::Lane&amp; current_lane = search_info.getCurrentWaypoints();
-  avoid_lane-&gt;header = current_lane.header;
-  avoid_lane-&gt;increment = current_lane.increment;
-
-  // Set waypoints from closest to beginning of avoiding
-  for (int i = closest_waypoint_index; i &lt; search_info.getStartWaypointIndex(); i++)
-  {
-    avoid_lane-&gt;waypoints.push_back(current_lane.waypoints.at(i));
-  }
-
-  double avoid_velocity = avoid_lane-&gt;waypoints.back().twist.twist.linear.x;
-
-  if (avoid_velocity &gt; search_info.getAvoidVelocityLimitMPS())
-    avoid_velocity = search_info.getAvoidVelocityLimitMPS();
-
-  // Set waypoints for avoiding
-  for (const auto&amp; pose : astar_path.poses)
-  {
-    autoware_msgs::Waypoint wp;
-    wp.pose = pose;
-    wp.twist.twist.linear.x = avoid_velocity;
-
-    avoid_lane-&gt;waypoints.push_back(wp);
-  }
-
-  // To know here is the end of avoiding
-  *end_of_avoid_index = avoid_lane-&gt;waypoints.size();
-
-  // Set waypoints from the end of avoiding
-  for (int i = search_info.getGoalWaypointIndex() + 1; i &lt; search_info.getGoalWaypointIndex() + size; i++)
-  {
-    if (i &gt;= static_cast&lt;int&gt;(current_lane.waypoints.size()))
-      break;
-
-    avoid_lane-&gt;waypoints.push_back(current_lane.waypoints.at(i));
-  }
-}
-
-}  // namespace
-
-int main(int argc, char** argv)
-{
-  ros::init(argc, argv, "obstacle_avoid");
-  ros::NodeHandle n;
-
-  astar_planner::AstarSearch astar;
-  astar_planner::SearchInfo search_info;
-
-  // ROS subscribers
-  ros::Subscriber map_sub = n.subscribe("grid_map_visualization/distance_transform", 1,
-                                        &amp;astar_planner::SearchInfo::mapCallback, &amp;search_info);
-  ros::Subscriber start_sub =
-      n.subscribe("current_pose", 1, &amp;astar_planner::SearchInfo::currentPoseCallback, &amp;search_info);
-  ros::Subscriber waypoints_sub =
-      n.subscribe("base_waypoints", 1, &amp;astar_planner::SearchInfo::waypointsCallback, &amp;search_info);
-  ros::Subscriber obstacle_waypoint_sub =
-      n.subscribe("obstacle_waypoint", 1, &amp;astar_planner::SearchInfo::obstacleWaypointCallback, &amp;search_info);
-  ros::Subscriber closest_waypoint_sub =
-      n.subscribe("closest_waypoint", 1, &amp;astar_planner::SearchInfo::closestWaypointCallback, &amp;search_info);
-  // TODO: optional
-  // ros::Subscriber goal_sub = n.subscribe("/move_base_simple/goal", 1, &amp;astar_planner::SearchInfo::goalCallback,
-  // &amp;search_info);
-  ros::Subscriber current_velocity_sub =
-      n.subscribe("current_velocity", 1, &amp;astar_planner::SearchInfo::currentVelocityCallback, &amp;search_info);
-  ros::Subscriber state_sub = n.subscribe("state", 1, &amp;astar_planner::SearchInfo::stateCallback, &amp;search_info);
-
-  // ROS publishers
-  ros::Publisher path_pub = n.advertise&lt;nav_msgs::Path&gt;("astar_path", 1, true);
-  ros::Publisher waypoints_pub = n.advertise&lt;autoware_msgs::Lane&gt;("safety_waypoints", 1, true);
-
-  ros::Rate loop_rate(10);
-
-  // variables for avoidance
-  autoware_msgs::Lane avoid_lane;
-  int end_of_avoid_index = -1;
-  bool avoidance = false;
-  while (ros::ok())
-  {
-    ros::spinOnce();
-
-    int closest_waypoint;
-
-    // We switch 2 waypoints, original path and avoiding path
-    if (avoidance)
-      closest_waypoint = getClosestWaypoint(avoid_lane, search_info.getCurrentPose().pose);
-    else
-      closest_waypoint = search_info.getClosestWaypointIndex();
-
-    // there are no waypoints we can follow
-    if (closest_waypoint &lt; 0 || !search_info.getPathSet())
-    {
-      loop_rate.sleep();
-      continue;
-    }
-
-    // Follow the original waypoints
-    if (!avoidance)
-    {
-      autoware_msgs::Lane publish_lane;
-      publish_lane = createPublishWaypoints(search_info.getSubscribedWaypoints(), closest_waypoint, 100);
-      waypoints_pub.publish(publish_lane);
-    }
-    // Follow the avoiding waypoints
-    else
-    {
-      // create waypoints from closest on avoid_lane
-      autoware_msgs::Lane publish_lane;
-      publish_lane = createPublishWaypoints(avoid_lane, closest_waypoint, 100);
-      waypoints_pub.publish(publish_lane);
-
-      // End of avoidance
-      if (closest_waypoint &gt; end_of_avoid_index)
-      {
-        avoidance = false;
-
-        // Return to the original waypoints
-        search_info.setCurrentWaypoints(search_info.getSubscribedWaypoints());
-
-        loop_rate.sleep();
-        continue;
-      }
-    }
-
-    // Initialize vector for A* search, this runs only once
-    if (search_info.getMapSet() &amp;&amp; !astar.getNodeInitialized())
-      astar.initializeNode(search_info.getMap());
-
-    // Waiting for the call for avoidance ...
-    if (!search_info.getMapSet() || !search_info.getStartSet() || !search_info.getGoalSet())
-    {
-      search_info.reset();
-      loop_rate.sleep();
-      continue;
-    }
-
-    // Run astar search
-    ros::WallTime timer_begin = ros::WallTime::now();
-
-    bool result = astar.makePlan(search_info.getStartPose().pose, search_info.getGoalPose().pose, search_info.getMap(),
-                                 search_info.getUpperBoundDistance());
-
-    ros::WallTime timer_end = ros::WallTime::now();
-    double time_ms = (timer_end - timer_begin).toSec() * 1000;
-    ROS_INFO("planning time: %lf [ms]", time_ms);
-
-    // debug mode
-    if (!search_info.getChangePath())
-    {
-      static double msec_sum = 0;
-      static int plan_count = 0;
-      plan_count++;
-      msec_sum += time_ms;
-      std::cout &lt;&lt; "average time so far: " &lt;&lt; msec_sum / plan_count &lt;&lt; std::endl;
-    }
-
-    if (result)
-    {
-      std::cout &lt;&lt; "Found goal!" &lt;&lt; std::endl;
-      path_pub.publish(astar.getPath());
-
-      createAvoidWaypoints(astar.getPath(), search_info, 100, &amp;avoid_lane, &amp;end_of_avoid_index);
-
-      if (search_info.getChangePath())
-        avoidance = true;
-    }
-    else
-    {
-      std::cout &lt;&lt; "can't find goal..." &lt;&lt; std::endl;
-    }
-
-    // Reset flags
-    search_info.reset();
-    astar.reset();
-
-    loop_rate.sleep();
-  }
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_sim\obstacle_sim.cpp" new_path="" added_lines="0" deleted_lines="234">
				<diff>@@ -1,234 +0,0 @@
-#include "obstacle_sim.h"
-
-namespace astar_planner
-{
-
-void convertToPointCloud2(const std::vector&lt;geometry_msgs::Point&gt;&amp; points, sensor_msgs::PointCloud2* ros_pointcloud)
-{
-  pcl::PointCloud&lt;pcl::PointXYZ&gt; pcl_points;
-
-  for (const auto&amp; p : points)
-  {
-    pcl::PointXYZ pcl_p;
-    pcl_p.x = p.x;
-    pcl_p.y = p.y;
-    pcl_p.z = p.z;
-
-    pcl_points.push_back(pcl_p);
-  }
-
-  //sensor_msgs::PointCloud2 ros_pointcloud;
-  pcl::toROSMsg(pcl_points, *ros_pointcloud);
-}
-
-geometry_msgs::Point transformPoint(const geometry_msgs::Point&amp; p, const tf::Transform&amp; tf)
-{
-  // convert to tf msg
-  tf::Point tf_point;
-  tf::pointMsgToTF(p, tf_point);
-
-  // apply transform
-  tf_point = tf * tf_point;
-
-  // convert to ros msg
-  geometry_msgs::Point ros_point;
-  tf::pointTFToMsg(tf_point, ros_point);
-
-  return ros_point;
-}
-
-ObstacleSim::ObstacleSim()
-    : private_nh_("~"),
-      sub_navgoal(false)
-{
-  initForROS();
-}
-
-ObstacleSim::~ObstacleSim()
-{
-}
-
-void ObstacleSim::initForROS()
-{
-  // ros parameter settings
-  private_nh_.param&lt;double&gt;("obstacle_height", obstacle_height_, 1.0);
-  private_nh_.param&lt;double&gt;("obstacle_width", obstacle_width_, 1.0);
-  private_nh_.param&lt;double&gt;("points_interval", points_interval_, 0.1);
-  private_nh_.param&lt;std::string&gt;("obstacle_frame", obstacle_frame_, "/velodyne");
-
-  // setup subscriber
-  nav_goal_sub_ = nh_.subscribe("move_base_simple/goal", 1, &amp;ObstacleSim::callbackFromNavGoal, this);
-
-  // setup publisher
-  obstacle_sim_points_pub_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("obstacle_sim_points", 1, true);
-  obstacle_sim_pointcloud_pub_ = nh_.advertise&lt;sensor_msgs::PointCloud2&gt;("obstacle_sim_pointcloud", 1, true);
-  obstacle_marker_pub_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("astar_sim_obstacle", 1, true);
-}
-
-void ObstacleSim::callbackFromNavGoal(const geometry_msgs::PoseStampedConstPtr&amp; msg)
-{
-  sub_navgoal = true;
-
-  // frame of using in RViz
-  world_frame_ = msg-&gt;header.frame_id;
-
-  // reset points
-  obstacle_points_.clear();
-
-  // points at each vertex of rectangle
-  geometry_msgs::Point upper_left, upper_right, lower_left, lower_right;
-  upper_left.x  = msg-&gt;pose.position.x - obstacle_width_ / 2.0;
-  upper_left.y  = msg-&gt;pose.position.y + obstacle_height_ / 2.0;
-  upper_right.x = upper_left.x + obstacle_width_;
-  upper_right.y = upper_left.y;
-  lower_left.x  = upper_left.x;
-  lower_left.y  = upper_left.y - obstacle_height_;
-  lower_right.x = upper_right.x;
-  lower_right.y = lower_left.y;
-
-  // points along each side
-  for (double x = upper_left.x; x &lt; upper_right.x; x += points_interval_)
-  {
-    geometry_msgs::Point up, down;
-    up.x = x;
-    up.y = upper_left.y;
-    down.x = x;
-    down.y = lower_left.y;
-
-    obstacle_points_.emplace_back(up);
-    obstacle_points_.emplace_back(down);
-  }
-  for (double y = upper_left.y; y &gt; lower_left.y; y -= points_interval_)
-  {
-    geometry_msgs::Point left, right;
-    left.x = upper_left.x;
-    left.y = y;
-    right.x = upper_right.x;
-    right.y = y;
-
-    obstacle_points_.emplace_back(left);
-    obstacle_points_.emplace_back(right);
-  }
-
-  displayObstacleMarker(upper_left, upper_right, lower_left, lower_right, world_frame_);
-  
-  // debug
-  //displayObstaclePoints();
-}
-
-// debug
-void ObstacleSim::displayObstaclePoints()
-{
-  visualization_msgs::Marker marker;
-  marker.header.frame_id = "/world";
-  marker.header.stamp = ros::Time();
-  marker.ns = "obstacle_sim";
-  marker.id = 0;
-  marker.type = visualization_msgs::Marker::POINTS;
-  marker.action = visualization_msgs::Marker::ADD;
-  for (const auto &amp;p : obstacle_points_)
-  {
-    marker.points.push_back(p);
-  }
-
-  marker.scale.x = 0.05;
-  marker.scale.y = 0.05;
-  marker.color.a = 1.0;
-  marker.color.r = 0.0;
-  marker.color.g = 1.0;
-  marker.color.b = 0.0;
-  //marker.lifetime = ros::Duration(0.1);
-  marker.frame_locked = true;
-
-
-  obstacle_sim_points_pub_.publish(marker);
-}
-
-void ObstacleSim::displayObstacleMarker(const geometry_msgs::Point&amp; p1, const geometry_msgs::Point&amp; p2, const geometry_msgs::Point&amp; p3, const geometry_msgs::Point&amp; p4, const std::string&amp; frame)
-{
-  visualization_msgs::Marker marker;
-  marker.header.frame_id = frame;
-  marker.header.stamp = ros::Time();
-  marker.ns = "obstacle_sim";
-  marker.id = 0;
-  marker.type = visualization_msgs::Marker::LINE_STRIP;
-  marker.action = visualization_msgs::Marker::ADD;
-
-  // 1 -- 2
-  // |    |
-  // 3 -- 4
-  marker.points.push_back(p1);
-  marker.points.push_back(p2);
-  marker.points.push_back(p4);
-  marker.points.push_back(p3);
-  marker.points.push_back(p1);
-  marker.points.push_back(p4);
-  marker.points.push_back(p3);
-  marker.points.push_back(p2);
-
-  marker.scale.x = 0.1;
-  marker.color.a = 1.0;
-  marker.color.r = 1.0;
-  marker.color.g = 1.0;
-  marker.color.b = 0.0;
-  //marker.lifetime = ros::Duration(0.1);
-  marker.frame_locked = true;
-
-  obstacle_marker_pub_.publish(marker);
-}
-
-void ObstacleSim::publishPoints()
-{
-  // transform points to sensor frame to be detected as an obstacle
-  tf::StampedTransform world2sensor;
-  try
-  {
-    tf_listener_.lookupTransform(world_frame_, obstacle_frame_, ros::Time(0), world2sensor);
-  }
-  catch (tf::TransformException ex)
-  {
-    ROS_ERROR("%s", ex.what());
-    return;
-  }
-
-  tf::Transform sensor2world = world2sensor.inverse();
-
-  std::vector&lt;geometry_msgs::Point&gt; obstacle_points_tf;
-  for (const auto&amp; p : obstacle_points_)
-  {
-    geometry_msgs::Point tf_p = transformPoint(p, sensor2world);
-    tf_p.z = 0.0;
-
-    obstacle_points_tf.emplace_back(tf_p);
-  }
-
-  sensor_msgs::PointCloud2 ros_pointcloud;
-  convertToPointCloud2(obstacle_points_tf, &amp;ros_pointcloud);
-  ros_pointcloud.header.frame_id = obstacle_frame_;
-  ros_pointcloud.header.stamp = ros::Time();
-
-  obstacle_sim_pointcloud_pub_.publish(ros_pointcloud);
-}
-
-void ObstacleSim::run()
-{
-  ros::Rate loop_rate(10);
-  while (ros::ok())
-  {
-    ros::spinOnce();
-
-    // not subscribed obstacle pose yet
-    if (!sub_navgoal)
-    {
-      loop_rate.sleep();
-      continue;
-    }
-
-    // publish obstacle points
-    publishPoints();
-
-    loop_rate.sleep();
-  }
-}
-
-} // namespace astar_planner
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_sim\obstacle_sim.h" new_path="" added_lines="0" deleted_lines="74">
				<diff>@@ -1,74 +0,0 @@
-/*
-
-*/
-
-#ifndef OBSTACLE_SIM_H
-#define OBSTACLE_SIM_H
-
-// ROS includes
-#include &lt;ros/ros.h&gt;
-#include &lt;geometry_msgs/PoseStamped.h&gt;
-#include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;pcl_conversions/pcl_conversions.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-#include &lt;geometry_msgs/Polygon.h&gt;
-
-// C++ includes
-#include &lt;iostream&gt;
-#include &lt;vector&gt;
-
-namespace astar_planner
-{
-
-class ObstacleSim
-{
-public:
-  ObstacleSim();
-  ~ObstacleSim();
-
-  void run();
-  
-private:
-  // handle
-  ros::NodeHandle nh_;
-  ros::NodeHandle private_nh_;
-
-  // ros publisher
-  ros::Publisher lane_array_pub_;
-  ros::Publisher obstacle_sim_points_pub_;
-  ros::Publisher obstacle_sim_pointcloud_pub_;
-  ros::Publisher obstacle_marker_pub_;
-
-  // ros subscriver
-  ros::Subscriber nav_goal_sub_;
-
-  // callbacks
-  void callbackFromNavGoal(const geometry_msgs::PoseStampedConstPtr&amp; msg);
-
-  // initializer
-  void initForROS();
-
-  void publishPoints();
-
-  // debug
-  void displayObstaclePoints();
-  void displayObstacleMarker(const geometry_msgs::Point&amp; p1, const geometry_msgs::Point&amp; p2, const geometry_msgs::Point&amp; p3, const geometry_msgs::Point&amp; p4, const std::string&amp; frame);
-
-  // ros param
-  double obstacle_height_;
-  double obstacle_width_;
-  double points_interval_;
-  std::string obstacle_frame_;
-
-  std::vector&lt;geometry_msgs::Point&gt; obstacle_points_;
-  tf::TransformListener tf_listener_;
-  std::string world_frame_;
-
-  // flag
-  bool sub_navgoal;
-
-}; // class ObstacleSim
-
-} // namespace astar_planner
-
-#endif  /* ifndef COMMAND_SENDER_H */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_sim\obstacle_sim_node.cpp" new_path="" added_lines="0" deleted_lines="17">
				<diff>@@ -1,17 +0,0 @@
-/*
- */
-
-// ROS Includes
-#include &lt;ros/ros.h&gt;
-
-#include "obstacle_sim.h"
-
-int main(int argc, char **argv)
-{
-  ros::init(argc, argv, "udon_translator");
-
-  astar_planner::ObstacleSim obstacle_sim;
-  obstacle_sim.run();
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" new_path="" added_lines="0" deleted_lines="298">
				<diff>@@ -1,298 +0,0 @@
-/*
- * Copyright 2015-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "search_info_ros.h"
-
-namespace astar_planner
-{
-SearchInfo::SearchInfo()
-  : map_set_(false)
-  , start_set_(false)
-  , goal_set_(false)
-  , path_set_(false)
-  , closest_waypoint_index_(-1)
-  , obstacle_waypoint_index_(-1)
-  , start_waypoint_index_(-1)
-  , goal_waypoint_index_(-1)
-  , state_("")
-  , upper_bound_distance_(-1)
-{
-  ros::NodeHandle nh;
-  ros::NodeHandle private_nh_("~");
-  node_status_publisher_ptr_ = std::make_shared&lt;autoware_health_checker::NodeStatusPublisher&gt;(nh,private_nh_);
-  node_status_publisher_ptr_-&gt;ENABLE();
-  private_nh_.param&lt;std::string&gt;("map_frame", map_frame_, "map");
-  private_nh_.param&lt;int&gt;("obstacle_detect_count", obstacle_detect_count_, 10);
-  private_nh_.param&lt;int&gt;("avoid_distance", avoid_distance_, 13);
-  private_nh_.param&lt;double&gt;("avoid_velocity_limit_mps", avoid_velocity_limit_mps_, 4.166);
-  private_nh_.param&lt;double&gt;("upper_bound_ratio", upper_bound_ratio_, 1.04);
-  private_nh_.param&lt;bool&gt;("avoidance", avoidance_, false);
-  private_nh_.param&lt;bool&gt;("change_path", change_path_, true);
-}
-
-SearchInfo::~SearchInfo()
-{
-}
-
-double SearchInfo::calcPathLength(const autoware_msgs::Lane &amp;lane, const int start_waypoint_index,
-                                  const int goal_waypoint_index) const
-{
-  if (lane.waypoints.size() &lt;= 1)
-    return 0;
-
-  // calulate the length of the path
-  double dist_sum = 0;
-  for (int i = start_waypoint_index; i &lt; goal_waypoint_index; i++)
-  {
-    geometry_msgs::Pose p1 = lane.waypoints[i].pose.pose;
-    geometry_msgs::Pose p2 = lane.waypoints[i + 1].pose.pose;
-
-    dist_sum += astar_planner::calcDistance(p1.position.x, p1.position.y, p2.position.x, p2.position.y);
-  }
-
-  // return the path lengh
-  return dist_sum;
-}
-
-void SearchInfo::mapCallback(const nav_msgs::OccupancyGridConstPtr &amp;msg)
-{
-  map_ = *msg;
-
-  std::string map_frame = map_frame_;
-  std::string ogm_frame = msg-&gt;header.frame_id;
-
-  // Set transform between map frame and OccupancyGrid frame
-  tf::StampedTransform map2ogm_frame;
-  try
-  {
-    tf_listener_.lookupTransform(map_frame, ogm_frame, ros::Time(0), map2ogm_frame);
-  }
-  catch (tf::TransformException ex)
-  {
-    ROS_ERROR("%s", ex.what());
-    return;
-  }
-
-  // Set transform between map frame and the origin of OccupancyGrid
-  tf::Transform map2ogm;
-  geometry_msgs::Pose ogm_in_map = astar_planner::transformPose(map_.info.origin, map2ogm_frame);
-  tf::poseMsgToTF(ogm_in_map, map2ogm);
-  ogm2map_ = map2ogm.inverse();
-
-  map_set_ = true;
-}
-
-void SearchInfo::currentPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
-{
-  current_pose_ = *msg;
-  node_status_publisher_ptr_-&gt;NODE_ACTIVATE();
-  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/current_pose/slow",8,5,1,"topic current_pose subscribe rate low.");
-  if(closest_waypoint_index_!=-1 &amp;&amp; path_set_)
-  {
-    autoware_msgs::Waypoint closest_waypoint = subscribed_waypoints_.waypoints[closest_waypoint_index_];
-    double dist = std::sqrt(std::pow(closest_waypoint.pose.pose.position.x-current_pose_.pose.position.x,2)
-      +std::pow(closest_waypoint.pose.pose.position.y-current_pose_.pose.position.y,2));
-    node_status_publisher_ptr_-&gt;CHECK_MAX_VALUE("/value/range/closest_waypoint_distance",dist,0.5,1.0,2.0,"distance between closest_waypoint and current_pose is too long.");
-  }
-  return;
-}
-
-void SearchInfo::currentVelocityCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg)
-{
-  current_velocity_mps_ = msg-&gt;twist.linear.x;
-}
-
-void SearchInfo::goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
-{
-  if (!map_set_)
-    return;
-
-  ROS_INFO("Subcscribed goal pose!");
-
-  std::string map_frame = map_frame_;
-  std::string goal_frame = msg-&gt;header.frame_id;
-
-  // Get transform of map to the frame of goal pose
-  tf::StampedTransform map2world;
-  try
-  {
-    tf_listener_.lookupTransform(map_frame, goal_frame, ros::Time(0), map2world);
-  }
-  catch (tf::TransformException ex)
-  {
-    ROS_ERROR("%s", ex.what());
-    return;
-  }
-
-  // Set goal pose
-  geometry_msgs::Pose pose_msg = msg-&gt;pose;
-  goal_pose_global_.pose = astar_planner::transformPose(pose_msg, map2world);
-  goal_pose_global_.header = msg-&gt;header;
-  goal_pose_local_.pose = astar_planner::transformPose(goal_pose_global_.pose, ogm2map_);
-  goal_pose_local_.header = goal_pose_global_.header;
-
-  goal_set_ = true;
-
-  // Get transform of map to the frame of start pose
-  std::string start_frame = current_pose_.header.frame_id;
-  tf::StampedTransform map2start_frame;
-  try
-  {
-    tf_listener_.lookupTransform(map_frame_, start_frame, ros::Time(0), map2start_frame);
-  }
-  catch (tf::TransformException ex)
-  {
-    ROS_ERROR("%s", ex.what());
-    return;
-  }
-
-  // Set start pose
-  start_pose_global_.pose = astar_planner::transformPose(current_pose_.pose, map2start_frame);
-  start_pose_global_.header = current_pose_.header;
-  start_pose_local_.pose = astar_planner::transformPose(start_pose_global_.pose, ogm2map_);
-  start_pose_local_.header = start_pose_global_.header;
-
-  start_set_ = true;
-}
-
-// get waypoints
-void SearchInfo::waypointsCallback(const autoware_msgs::LaneConstPtr &amp;msg)
-{
-  subscribed_waypoints_ = *msg;
-
-  if (!path_set_)
-  {
-    current_waypoints_ = *msg;
-    path_set_ = true;
-  }
-}
-
-void SearchInfo::closestWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
-{
-  node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/closest_waypoint/slow",8,5,1,"topic closest_waypoint subscribe rate low.");
-  closest_waypoint_index_ = msg-&gt;data;
-}
-
-void SearchInfo::obstacleWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
-{
-  // not always avoid AND current state is not avoidance
-  if (!avoidance_ &amp;&amp; state_ != "OBSTACLE_AVOIDANCE")
-  {
-    ROS_WARN("current state is not OBSTACLE_AVOIDANCE");
-    return;
-  }
-
-  // there are no obstacles
-  if (msg-&gt;data &lt; 0 || closest_waypoint_index_ &lt; 0 || current_waypoints_.waypoints.empty())
-  {
-    return;
-  }
-
-  // msg-&gt;data : local index
-  // closest   : global index
-  // Conver local index to global index
-  obstacle_waypoint_index_ = msg-&gt;data + closest_waypoint_index_;
-
-  // Handle when detecting sensor noise as an obstacle
-  static int prev_obstacle_waypoint_index = -1;
-  static int obstacle_count = 0;
-  int same_obstacle_threshold = 2;
-  if (obstacle_waypoint_index_ &gt;= prev_obstacle_waypoint_index - same_obstacle_threshold &amp;&amp;
-      obstacle_waypoint_index_ &lt;= prev_obstacle_waypoint_index + same_obstacle_threshold)
-  {
-    obstacle_count++;
-  }
-  else
-  {
-    obstacle_count = 1;
-  }
-
-  prev_obstacle_waypoint_index = obstacle_waypoint_index_;
-
-  if (obstacle_count &lt; obstacle_detect_count_)
-    return;
-
-  // not debug mode
-  if (change_path_)
-    obstacle_count = 0;
-
-  // Decide start and goal waypoints for planning
-  start_waypoint_index_ = obstacle_waypoint_index_ - avoid_distance_;
-  goal_waypoint_index_ = obstacle_waypoint_index_ + avoid_distance_;
-
-  // Handle out of range
-  if (start_waypoint_index_ &lt; 0)
-    start_waypoint_index_ = 0;
-
-  // Handle out of range
-  if (goal_waypoint_index_ &gt;= static_cast&lt;int&gt;(getCurrentWaypoints().waypoints.size()))
-    goal_waypoint_index_ = getCurrentWaypoints().waypoints.size() - 1;
-
-  double original_path_length = calcPathLength(current_waypoints_, start_waypoint_index_, goal_waypoint_index_);
-  upper_bound_distance_ = original_path_length * upper_bound_ratio_;
-
-  // Do not avoid if (the obstacle is too close || current velocity is too fast)
-  if (closest_waypoint_index_ + 1 &gt; start_waypoint_index_)
-  {
-    ROS_WARN("The obstacle is too close!");
-    return;
-  }
-
-  // apply velocity limit for avoiding
-  if (current_velocity_mps_ &gt; avoid_velocity_limit_mps_)
-  {
-    ROS_WARN("Velocity of the vehicle exceeds the avoid velocity limit");
-    return;
-  }
-
-  // Set start pose
-  start_pose_global_ = current_waypoints_.waypoints[start_waypoint_index_].pose;
-  start_pose_local_.pose = astar_planner::transformPose(start_pose_global_.pose, ogm2map_);
-  start_set_ = true;
-
-  // Set transit pose
-  // TODO:
-  double actual_car_width = 2.5;  // [m]
-  geometry_msgs::Pose relative_transit_pose;
-  // TODO: always right avoidance ???
-  relative_transit_pose.position.y -= actual_car_width;
-  relative_transit_pose.orientation = current_waypoints_.waypoints[obstacle_waypoint_index_].pose.pose.orientation;
-  tf::Pose obstacle_pose_tf;
-  tf::poseMsgToTF(current_waypoints_.waypoints[obstacle_waypoint_index_].pose.pose, obstacle_pose_tf);
-
-  transit_pose_global_.pose = astar_planner::transformPose(relative_transit_pose, obstacle_pose_tf);
-  transit_pose_local_.pose = astar_planner::transformPose(transit_pose_global_.pose, ogm2map_);
-
-  // Set goal pose
-  goal_pose_global_ = current_waypoints_.waypoints[goal_waypoint_index_].pose;
-  goal_pose_local_.pose = astar_planner::transformPose(goal_pose_global_.pose, ogm2map_);
-
-  goal_set_ = true;
-}
-
-void SearchInfo::stateCallback(const std_msgs::StringConstPtr &amp;msg)
-{
-  state_ = msg-&gt;data;
-}
-
-void SearchInfo::reset()
-{
-  map_set_ = false;
-  start_set_ = false;
-  goal_set_ = false;
-  obstacle_waypoint_index_ = -1;
-}
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" new_path="" added_lines="0" deleted_lines="190">
				<diff>@@ -1,190 +0,0 @@
-/*
- * Copyright 2015-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef SEARCH_INFO_ROS_H
-#define SEARCH_INFO_ROS_H
-
-#include "astar_util.h"
-#include "autoware_msgs/Lane.h"
-#include "waypoint_follower/libwaypoint_follower.h"
-
-#include &lt;nav_msgs/OccupancyGrid.h&gt;
-#include &lt;geometry_msgs/PoseStamped.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-#include &lt;std_msgs/Int32.h&gt;
-#include &lt;std_msgs/String.h&gt;
-
-#include &lt;autoware_health_checker/node_status_publisher.h&gt;
-#include &lt;memory&gt;
-
-namespace astar_planner
-{
-class SearchInfo
-{
-public:
-  SearchInfo();
-  ~SearchInfo();
-
-  // ROS Callback
-  void mapCallback(const nav_msgs::OccupancyGridConstPtr &amp;msg);
-  // void startCallback(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;msg);
-  void goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
-  void currentPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
-  void currentVelocityCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg);
-  void waypointsCallback(const autoware_msgs::LaneConstPtr &amp;msg);
-  void closestWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg);
-  void obstacleWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg);
-  void stateCallback(const std_msgs::StringConstPtr &amp;msg);
-
-  // get method
-  bool getMapSet() const
-  {
-    return map_set_;
-  }
-  bool getStartSet() const
-  {
-    return start_set_;
-  }
-  bool getGoalSet() const
-  {
-    return goal_set_;
-  }
-  bool getPathSet() const
-  {
-    return path_set_;
-  }
-  nav_msgs::OccupancyGrid getMap() const
-  {
-    return map_;
-  }
-  geometry_msgs::PoseStamped getStartPose() const
-  {
-    return start_pose_local_;
-  }
-  geometry_msgs::PoseStamped getGoalPose() const
-  {
-    return goal_pose_local_;
-  }
-  geometry_msgs::PoseStamped getTransitPose() const
-  {
-    return transit_pose_local_;
-  }
-  geometry_msgs::PoseStamped getCurrentPose() const
-  {
-    return current_pose_;
-  }
-  double getCurrentVelocity() const
-  {
-    return current_velocity_mps_;
-  }
-  autoware_msgs::Lane getSubscribedWaypoints() const
-  {
-    return subscribed_waypoints_;
-  }
-  autoware_msgs::Lane getCurrentWaypoints() const
-  {
-    return current_waypoints_;
-  }
-  int getObstacleWaypointIndex() const
-  {
-    return obstacle_waypoint_index_;
-  }
-  int getClosestWaypointIndex() const
-  {
-    return closest_waypoint_index_;
-  }
-  int getStartWaypointIndex() const
-  {
-    return start_waypoint_index_;
-  }
-  int getGoalWaypointIndex() const
-  {
-    return goal_waypoint_index_;
-  }
-  double getUpperBoundDistance() const
-  {
-    return upper_bound_distance_;
-  }
-  double getAvoidVelocityLimitMPS() const
-  {
-    return avoid_velocity_limit_mps_;
-  }
-  bool getAvoidance() const
-  {
-    return avoidance_;
-  }
-  bool getChangePath() const
-  {
-    return change_path_;
-  }
-
-  // set method
-  void setCurrentWaypoints(const autoware_msgs::Lane &amp;waypoints)
-  {
-    current_waypoints_ = waypoints;
-  }
-
-  // Reset flag
-  void reset();
-
-private:
-  double calcPathLength(const autoware_msgs::Lane &amp;lane, const int start_waypoint_index,
-                        const int goal_waypoint_index) const;
-  std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr_;
-  nav_msgs::OccupancyGrid map_;
-  geometry_msgs::PoseStamped start_pose_global_;
-  geometry_msgs::PoseStamped goal_pose_global_;
-  geometry_msgs::PoseStamped transit_pose_global_;
-  geometry_msgs::PoseStamped start_pose_local_;
-  geometry_msgs::PoseStamped goal_pose_local_;
-  geometry_msgs::PoseStamped transit_pose_local_;
-  // Transform which converts global frame (/map in Autoware) to OccupancyGrid frame
-  tf::Transform ogm2map_;
-  tf::TransformListener tf_listener_;
-
-  // set data flag
-  bool map_set_;
-  bool start_set_;
-  bool goal_set_;
-  bool path_set_;
-
-  // ROS param
-  std::string map_frame_;
-  int obstacle_detect_count_;        // 1 increment means 100ms
-  int avoid_distance_;               // the number of waypoint
-  double avoid_velocity_limit_mps_;  // m/s
-  double upper_bound_ratio_;
-  bool avoidance_;
-  bool change_path_;
-
-  // subscribed imformation
-  int closest_waypoint_index_;
-  int obstacle_waypoint_index_;
-  int start_waypoint_index_;
-  int goal_waypoint_index_;
-  autoware_msgs::Lane subscribed_waypoints_;
-  autoware_msgs::Lane current_waypoints_;
-  geometry_msgs::PoseStamped current_pose_;
-  double current_velocity_mps_;
-  std::string state_;
-
-  // for prunning
-  double upper_bound_distance_;
-};
-
-}  // namespace astar_planner
-
-#endif  // SEARCH_INFO_ROS_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_planner\src\velocity_set\libvelocity_set.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,4 +1,4 @@
-#include "libvelocity_set.h"
+#include "../../src/velocity_set/libvelocity_set.h"
 
 // extract edge points from zebra zone
 std::vector&lt;geometry_msgs::Point&gt; removeNeedlessPoints(std::vector&lt;geometry_msgs::Point&gt; &amp;area_points)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" new_path="ros\src\computing\planning\motion\packages\waypoint_planner\src\velocity_set\libvelocity_set.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_planner\src\velocity_set\velocity_set.cpp" added_lines="3" deleted_lines="4">
				<diff>@@ -19,9 +19,9 @@
 #include &lt;std_msgs/ColorRGBA.h&gt;
 #include &lt;iostream&gt;
 
-#include "libvelocity_set.h"
-#include "velocity_set_info.h"
-#include "velocity_set_path.h"
+#include "../../src/velocity_set/libvelocity_set.h"
+#include "../../src/velocity_set/velocity_set_info.h"
+#include "../../src/velocity_set/velocity_set_path.h"
 
 namespace
 {
@@ -556,7 +556,6 @@ int main(int argc, char** argv)
   ros::Subscriber points_sub = nh.subscribe(points_topic, 1, &amp;VelocitySetInfo::pointsCallback, &amp;vs_info);
   ros::Subscriber localizer_sub = nh.subscribe("localizer_pose", 1, &amp;VelocitySetInfo::localizerPoseCallback, &amp;vs_info);
   ros::Subscriber control_pose_sub = nh.subscribe("current_pose", 1, &amp;VelocitySetInfo::controlPoseCallback, &amp;vs_info);
-  ros::Subscriber obstacle_sim_points_sub = nh.subscribe("obstacle_sim_pointcloud", 1, &amp;VelocitySetInfo::obstacleSimCallback, &amp;vs_info);
   ros::Subscriber detectionresult_sub = nh.subscribe("/state/stopline_wpidx", 1, &amp;VelocitySetInfo::detectionCallback, &amp;vs_info);
 
   // vector map subscriber
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_planner\src\velocity_set\velocity_set_info.cpp" added_lines="1" deleted_lines="14">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#include "velocity_set_info.h"
+#include "../../src/velocity_set/velocity_set_info.h"
 
 void joinPoints(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points1, pcl::PointCloud&lt;pcl::PointXYZ&gt;* points2)
 {
@@ -37,7 +37,6 @@ VelocitySetInfo::VelocitySetInfo()
     velocity_change_limit_(2.77),
     temporal_waypoints_size_(100),
     set_pose_(false),
-    use_obstacle_sim_(false),
     wpidx_detectionResultByOtherNodes_(-1)
 {
   ros::NodeHandle private_nh_("~");
@@ -93,11 +92,6 @@ void VelocitySetInfo::pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg
     points_.push_back(v);
   }
 
-  if (use_obstacle_sim_)
-  {
-    joinPoints(obstacle_sim_points_, &amp;points_);
-    obstacle_sim_points_.clear();
-  }
 }
 
 void VelocitySetInfo::detectionCallback(const std_msgs::Int32 &amp;msg)
@@ -119,10 +113,3 @@ void VelocitySetInfo::localizerPoseCallback(const geometry_msgs::PoseStampedCons
   node_status_publisher_ptr_-&gt;CHECK_RATE("/topic/rate/current_pose/slow",8,5,1,"topic current_pose subscribe rate low.");
   localizer_pose_ = *msg;
 }
-
-void VelocitySetInfo::obstacleSimCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg)
-{
-  pcl::fromROSMsg(*msg, obstacle_sim_points_);
-
-  use_obstacle_sim_ = true;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" new_path="ros\src\computing\planning\motion\packages\waypoint_planner\src\velocity_set\velocity_set_info.h" added_lines="0" deleted_lines="3">
				<diff>@@ -48,11 +48,9 @@ class VelocitySetInfo
   double remove_points_upto_;
 
   pcl::PointCloud&lt;pcl::PointXYZ&gt; points_;
-  pcl::PointCloud&lt;pcl::PointXYZ&gt; obstacle_sim_points_;
   geometry_msgs::PoseStamped localizer_pose_;  // pose of sensor
   geometry_msgs::PoseStamped control_pose_;    // pose of base_link
   bool set_pose_;
-  bool use_obstacle_sim_;
 
   std::shared_ptr&lt;autoware_health_checker::NodeStatusPublisher&gt; node_status_publisher_ptr_;
 
@@ -65,7 +63,6 @@ class VelocitySetInfo
   void pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg);
   void controlPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void localizerPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
-  void obstacleSimCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg);
   void detectionCallback(const std_msgs::Int32 &amp;msg);
 
   void clearPoints();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_planner\src\velocity_set\velocity_set_path.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#include "velocity_set_path.h"
+#include "../../src/velocity_set/velocity_set_path.h"
 
 VelocitySetPath::VelocitySetPath()
   : set_path_(false),
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" new_path="ros\src\computing\planning\motion\packages\waypoint_planner\src\velocity_set\velocity_set_path.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="52a2ba34f234215ca973d79e1bc7f72d0985b768" author="Kosuke Murakami">
		<msg>[fix] not predicting objects at x&lt;=0 or y&lt;=0 (#2122)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\include\naive_motion_predict.h" new_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\include\naive_motion_predict.h" added_lines="1" deleted_lines="0">
				<diff>@@ -54,6 +54,7 @@ private:
   double interval_sec_;
   int num_prediction_;
   double sensor_height_;
+  double filter_out_close_object_threshold_;
 
   void objectsCallback(const autoware_msgs::DetectedObjectArray&amp; input);
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\nodes\naive_motion_predict\naive_motion_predict.cpp" new_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\nodes\naive_motion_predict\naive_motion_predict.cpp" added_lines="4" deleted_lines="2">
				<diff>@@ -24,6 +24,7 @@ NaiveMotionPredict::NaiveMotionPredict() :
   private_nh_.param&lt;double&gt;("interval_sec", interval_sec_, 0.1);
   private_nh_.param&lt;int&gt;("num_prediction", num_prediction_, 10);
   private_nh_.param&lt;double&gt;("sensor_height_", sensor_height_, 2.0);
+  private_nh_.param&lt;double&gt;("filter_out_close_object_threshold", filter_out_close_object_threshold_, 1.5);
 
   predicted_objects_pub_ = nh_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/prediction/motion_predictor/objects", 1);
   predicted_paths_pub_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("/prediction/motion_predictor/path_markers", 1);
@@ -207,6 +208,8 @@ void NaiveMotionPredict::objectsCallback(const autoware_msgs::DetectedObjectArra
 
 bool NaiveMotionPredict::isObjectValid(const autoware_msgs::DetectedObject &amp;in_object)
 {
+  double distance = std::sqrt(std::pow(in_object.pose.position.x,2)+
+                              std::pow(in_object.pose.position.y,2));
   if (!in_object.valid ||
       std::isnan(in_object.pose.orientation.x) ||
       std::isnan(in_object.pose.orientation.y) ||
@@ -215,8 +218,7 @@ bool NaiveMotionPredict::isObjectValid(const autoware_msgs::DetectedObject &amp;in_o
       std::isnan(in_object.pose.position.x) ||
       std::isnan(in_object.pose.position.y) ||
       std::isnan(in_object.pose.position.z) ||
-      (in_object.pose.position.x &lt;= 0) ||
-      (in_object.pose.position.y &lt;= 0) ||
+      (distance &lt;=  filter_out_close_object_threshold_)||
       (in_object.dimensions.x &lt;= 0) ||
       (in_object.dimensions.y &lt;= 0) ||
       (in_object.dimensions.z &lt;= 0)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b98cf4b3dbd5a4ff9220170ebd084718051718dc" author="isamu-takagi">
		<msg>Feature/update autoware launcher (#2056)

* Add prototype of plugin file editor

* Change logger level

* Support command line options

* Update gazebo simulator panel

* Add plugin edit tool and update plugins

* Fix a bug of transform edit

* Fix setup.py to install all packages

* Update the code for compatibility with python3

* Update the code for colcon build

* updated plugin for lane_rule, lane_stop, and voxel_grid_filter

* Fix that the plugin_description is not installed

* Fix launch file error

* Fix test failed

* Skip test of unbuilt packages

* Add run script

* Add profile description

* Fix launch file install path of point_downsampler

* Update README file

* Update README file for plugin file

* Fix README file

* Add notice to run script</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\autoware_launcher\resources\skins\default.css" new_path="" added_lines="0" deleted_lines="18">
				<diff>@@ -1,18 +0,0 @@
-QCheckBox::indicator
-{
-    width:  20px;
-    height: 20px;
-}
-
-#FrameHeader
-{
-    border-top: 1px solid #223A70;
-}
-
-#FrameHeader, #FrameWidget
-{
-    padding: 5px;
-    border-bottom: 1px solid #223A70;
-    border-left:   1px solid #223A70;
-    border-right:  1px solid #223A70;
-}
</diff>
			</file>
		</modified_files>
	</commit>
</Root>
