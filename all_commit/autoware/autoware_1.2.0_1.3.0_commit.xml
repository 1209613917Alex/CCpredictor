<?xml version="1.0" encoding="utf-8"?>
<Root>
	<commit hash="9f6a98196f34529136e36bae97e5105c3133c6d4" author="AMC">
		<msg>Added GPU support for Euclidean Clustering</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" added_lines="66" deleted_lines="1">
				<diff>@@ -77,6 +77,10 @@
 //#include &lt;vector_map/vector_map.h&gt;
 //#include &lt;vector_map_server/GetSignal.h&gt;
 
+#ifdef GPU_CLUSTERING
+	#include "gpu_euclidean_clustering.h"
+#endif
+
 using namespace cv;
 
 std::vector&lt;cv::Scalar&gt; _colors;
@@ -290,6 +294,64 @@ void keepLanePoints(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 	extract.filter(*out_cloud_ptr);
 }
 
+#ifdef GPU_CLUSTERING
+std::vector&lt;ClusterPtr&gt; clusterAndColorGpu(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
+											pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
+											jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
+											lidar_tracker::centroids&amp; in_out_centroids,
+											double in_max_cluster_distance=0.5)
+{
+	std::vector&lt;ClusterPtr&gt; clusters;
+
+	//Convert input point cloud to vectors of x, y, and z
+
+	int size = in_cloud_ptr-&gt;points.size();
+
+	if (size == 0)
+		return clusters;
+
+	float *tmp_x, *tmp_y, *tmp_z;
+
+	tmp_x = (float *)malloc(sizeof(float) * size);
+	tmp_y = (float *)malloc(sizeof(float) * size);
+	tmp_z = (float *)malloc(sizeof(float) * size);
+
+	for (int i = 0; i &lt; size; i++) {
+		pcl::PointXYZ tmp_point = in_cloud_ptr-&gt;at(i);
+
+		tmp_x[i] = tmp_point.x;
+		tmp_y[i] = tmp_point.y;
+		tmp_z[i] = tmp_point.z;
+	}
+
+	GpuEuclideanCluster gecl_cluster;
+
+	gecl_cluster.setInputPoints(tmp_x, tmp_y, tmp_z, size);
+	gecl_cluster.setThreshold(in_max_cluster_distance);
+	gecl_cluster.setMinClusterPts (_cluster_size_min);
+	gecl_cluster.setMaxClusterPts (_cluster_size_max);
+	gecl_cluster.extractClusters();
+	std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; cluster_indices = gecl_cluster.getOutput();
+
+	unsigned int k = 0;
+
+	for (auto it = cluster_indices.begin(); it != cluster_indices.end(); it++)
+	{
+		ClusterPtr cluster(new Cluster());
+		cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;points_in_cluster, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1], (int)_colors[k].val[2], "", _pose_estimation);
+		clusters.push_back(cluster);
+
+		k++;
+	}
+
+	free(tmp_x);
+	free(tmp_y);
+	free(tmp_z);
+
+	return clusters;
+}
+#endif
+
 std::vector&lt;ClusterPtr&gt; clusterAndColor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 		pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
 		jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
@@ -471,8 +533,11 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 	std::vector &lt;ClusterPtr&gt; all_clusters;
 	for(unsigned int i=0; i&lt;cloud_segments_array.size(); i++)
 	{
+#ifdef GPU_CLUSTERING
+		std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
+#else
 		std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
-
+#endif
 		all_clusters.insert(all_clusters.end(), local_clusters.begin(), local_clusters.end());
 	}
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="402c287db33b509945aa7bcbbcecf6a90629d640" author="AMC">
		<msg>Removed the chance of a deadlock on extreme cases when points are far from each other</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\gpu_euclidean_clustering.cu" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\gpu_euclidean_clustering.cu" added_lines="395" deleted_lines="71">
				<diff>@@ -16,13 +16,17 @@
 #include &lt;thrust/scan.h&gt;
 #include &lt;thrust/fill.h&gt;
 
+#include &lt;time.h&gt;
+#include &lt;sys/time.h&gt;
+
 #define MAX_SHARED_SIZE 2048
 #define BLOCK_SIZE_X 1024
 
+//#define SERIAL 1
+
 inline void gassert(cudaError_t err_code, const char *file, int line)
 {
-	if(err_code!= cudaSuccess)
-	{
+	if (err_code != cudaSuccess) {
 		fprintf(stderr, "Error: %s %s %d\n", cudaGetErrorString(err_code), file, line);
 		cudaDeviceReset();
 		exit(EXIT_FAILURE);
@@ -41,7 +45,9 @@ GpuEuclideanCluster::GpuEuclideanCluster()
 	threshold_ = 0;
 	cluster_indices_ = NULL;
 	cluster_indices_host_ = NULL;
-	min_cluster_pts_ = max_cluster_pts_ = 0;
+	min_cluster_pts_ = 0;
+	max_cluster_pts_ = 1000000000;
+	cluster_num_ = 0;
 }
 
 void GpuEuclideanCluster::setInputPoints(float *x, float *y, float *z, int size)
@@ -207,7 +213,7 @@ extern "C" __global__ void buildClusterMatrix(float *x, float *y, float *z, int
 
 		__syncthreads();
 
-		for (int row = column + 1; row &lt; size; row++) {
+		for (int row = 0; row &lt; column; row++) {
 			float tmp_x = x[row] - local_x[threadIdx.x];
 			float tmp_y = y[row] - local_y[threadIdx.x];
 			float tmp_z = z[row] - local_z[threadIdx.x];
@@ -219,7 +225,6 @@ extern "C" __global__ void buildClusterMatrix(float *x, float *y, float *z, int
 			if (row_cluster != column_cluster &amp;&amp; norm3df(tmp_x, tmp_y, tmp_z) &lt; threshold)
 				cluster_matrix[rc_offset * cluster_num + cc_offset] = 1;
 		}
-
 	}
 }
 
@@ -240,42 +245,45 @@ extern "C" __global__ void buildClusterMatrix(float *x, float *y, float *z, int
  */
 extern "C" __global__ void mergeClusters(int *cluster_matrix, int *cluster_list, int cluster_num)
 {
-	int block_start = blockIdx.x * blockDim.x;
-	int block_end = (block_start + blockDim.x &lt;= cluster_num) ? block_start + blockDim.x : cluster_num;
-	int row = block_start + threadIdx.x;
-	__shared__ int local_cluster_changed[BLOCK_SIZE_X];
+	int row_start = blockIdx.x * blockDim.x;
+	int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
+	int col = row_start + threadIdx.x;
+	__shared__ int local_changed[BLOCK_SIZE_X];
 	__shared__ int local_offset[BLOCK_SIZE_X];
 
-	if (row &lt; block_end) {
+	/* The cluster matrix is symmetric, so the
+	 * number of rows and columns are the same
+	 */
+	if (col &lt; row_end) {
 		local_offset[threadIdx.x] = threadIdx.x;
 
 		__syncthreads();
 
-		for (int column = block_start; column &lt; block_end; column++) {
-			int row_offset = local_offset[threadIdx.x];
-			int column_offset = local_offset[column - block_start];
+		for (int row = row_start; row &lt; row_end; row++) {
+			int col_offset = local_offset[threadIdx.x];
+			int row_offset = local_offset[row - row_start];
 
-			local_cluster_changed[threadIdx.x] = 0;
+			local_changed[threadIdx.x] = 0;
 			__syncthreads();
 
-			if (row &gt; column &amp;&amp; row_offset != column_offset &amp;&amp; (cluster_matrix[row * cluster_num + column] == 1))
-				local_cluster_changed[row_offset] = 1;
+			if (row &lt; col &amp;&amp; row_offset != col_offset &amp;&amp; (cluster_matrix[row * cluster_num + col] == 1))
+				local_changed[col_offset] = 1;
 			__syncthreads();
 
-			local_offset[threadIdx.x] = (local_cluster_changed[row_offset] == 1) ? column_offset : row_offset;
+			local_offset[threadIdx.x] = (local_changed[col_offset] == 1) ? row_offset : col_offset;
 			__syncthreads();
 		}
 
 		__syncthreads();
 
-		int new_cluster = cluster_list[block_start + local_offset[threadIdx.x]];
+		int new_cluster = cluster_list[row_start + local_offset[threadIdx.x]];
 
 		__syncthreads();
-		cluster_list[row] = new_cluster;
+		cluster_list[col] = new_cluster;
 	}
 }
 
-/* This kernel is to reflex the change in the cluster merging step
+/* Reflex the change in the cluster merging step
  * to cluster indices of all input points.
  *
  * Clusters of input points are changed to the target clusters
@@ -300,7 +308,7 @@ extern "C" __global__ void reflexClusterChanges(int *cluster_indices, int *clust
 extern "C" __global__ void rebuildClusterMatrix(int *old_cluster_matrix, int *new_clusters, int *new_cluster_matrix, int *new_cluster_offset, int old_size, int new_size)
 {
 	for (int column = threadIdx.x + blockIdx.x * blockDim.x; column &lt; old_size; column += blockDim.x * gridDim.x) {
-		for (int row = column + 1; row &lt; old_size; row++) {
+		for (int row = 0; row &lt; column; row++) {
 			int new_row = new_cluster_offset[new_clusters[row]];
 			int new_column = new_cluster_offset[new_clusters[column]];
 
@@ -326,6 +334,23 @@ void GpuEuclideanCluster::exclusiveScan(int *input, int ele_num, int *sum)
 	*sum = *(dev_ptr + ele_num - 1);
 }
 
+/* Reset the cluster indexes in the point cloud from 0.
+ *
+ * After merging, the cluster indexes of points are still large. Collecting
+ * those large indexes is either time-consuming (without using hash) or
+ * wasting memory space (using hash). By reset the cluster indexes from 0,
+ * we can use hashing to collect those indexes with the space complexity equal
+ * to the number of clusters.
+ */
+extern "C" __global__ void resetClusterIndexes(int *cluster_indices, int *cluster_offset, int size)
+{
+	for (int i = threadIdx.x + blockIdx.x * blockDim.x; i &lt; size; i += blockDim.x * gridDim.x) {
+		int old_cluster = cluster_indices[i];
+
+		cluster_indices[i] = cluster_offset[old_cluster];
+	}
+}
+
 
 /* Calculate the cluster indices of input points.
  *
@@ -392,7 +417,7 @@ void GpuEuclideanCluster::extractClusters()
 		if (grid_x2 == 1 &amp;&amp; cluster_num == old_cluster_num)
 			break;
 
-		clusterCollector&lt;&lt;&lt;grid_x, block_x2&gt;&gt;&gt;(cluster_list, new_cluster_list, cluster_offset, old_cluster_num);
+		clusterCollector&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_list, new_cluster_list, cluster_offset, old_cluster_num);
 		checkCudaErrors(cudaDeviceSynchronize());
 
 		checkCudaErrors(cudaMalloc(&amp;new_cluster_matrix, cluster_num * cluster_num * sizeof(int)));
@@ -407,6 +432,11 @@ void GpuEuclideanCluster::extractClusters()
 		new_cluster_list = tmp;
 	} while (1);
 
+	cluster_num_ = cluster_num;
+
+	resetClusterIndexes&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_offset, size_);
+	checkCudaErrors(cudaDeviceSynchronize());
+
 	checkCudaErrors(cudaMemcpy(cluster_indices_host_, cluster_indices_, size_ * sizeof(int), cudaMemcpyDeviceToHost));
 
 
@@ -416,37 +446,335 @@ void GpuEuclideanCluster::extractClusters()
 	checkCudaErrors(cudaFree(cluster_offset));
 }
 
+extern "C" __global__ void mergeSelfClusters(int *cluster_matrix, int *cluster_list, int cluster_num, bool *changed)
+{
+	int row_start = blockIdx.x * blockDim.x;
+	int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
+	int col = row_start + threadIdx.x;
+	__shared__ int local_changed[BLOCK_SIZE_X];
+	__shared__ int local_offset[BLOCK_SIZE_X];
+	bool block_changed = false;
 
-/* Collect points that belong to same clusters and put them together.
+	if (col &lt; row_end) {
+		local_offset[threadIdx.x] = threadIdx.x;
+
+		__syncthreads();
+
+		for (int row = row_start; row &lt; row_end; row++) {
+			int col_offset = local_offset[threadIdx.x];
+			int row_offset = local_offset[row - row_start];
+
+			local_changed[threadIdx.x] = 0;
+			__syncthreads();
+
+			if (row &lt; col &amp;&amp; row_offset != col_offset &amp;&amp; (cluster_matrix[row * cluster_num + col] == 1)) {
+				local_changed[col_offset] = 1;
+				block_changed = true;
+			}
+			__syncthreads();
+
+			local_offset[threadIdx.x] = (local_changed[col_offset] == 1) ? row_offset : col_offset;
+			__syncthreads();
+		}
+
+		__syncthreads();
+
+		int new_cluster = cluster_list[row_start + local_offset[threadIdx.x]];
+
+		__syncthreads();
+
+		cluster_list[col] = new_cluster;
+
+
+		__syncthreads();
+		if (block_changed)
+			*changed = true;
+	}
+}
+
+/* Merge clusters from different blocks of points.
  *
- * The output is a vector whose each element contains indexes of points
- * that belong to a same clusters.
+ * The relationship of those clusters are expressed by a cluster matrix.
+ * The merge is done by assigning each thread in a block of GPU threads
+ * to move from top to bottom of the matrix and check if there are any
+ * 1 element in the matrix.
+ *
+ * This kernel only merge matrices that staying in a same diagonal of a
+ * group of matrix. The index of the diagonal is indicated by shift_level.
  */
-std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; GpuEuclideanCluster::getOutput()
+
+extern "C" __global__ void mergeInterClusters(int *cluster_matrix, int *cluster_list,
+												int shift_level,
+												int base_row, int base_column,
+												int sub_matrix_row, int sub_matrix_col,
+												int sub_matrix_offset_row, int sub_matrix_offset_col,
+												int cluster_num, bool *changed)
 {
-	std::vector&lt;GClusterIndex&gt; cluster_indices;
+	int col_start = (base_column + (blockIdx.x/sub_matrix_col) * sub_matrix_offset_col + (blockIdx.x + shift_level - sub_matrix_col * ((blockIdx.x + shift_level)/sub_matrix_col))) * blockDim.x;
+	int col_end = (col_start + blockDim.x &lt;= cluster_num) ? col_start + blockDim.x : cluster_num;
+	int row_start = (base_row + (blockIdx.x/sub_matrix_row) * sub_matrix_offset_row + (blockIdx.x - sub_matrix_row * (blockIdx.x/sub_matrix_row))) * blockDim.x;
+	int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
+	int col = col_start + threadIdx.x;
 
-	for (int i = 0; i &lt; size_; i++) {
-		bool found = false;
+	__shared__ int local_changed[BLOCK_SIZE_X];
+	__shared__ int local_offset[BLOCK_SIZE_X];
+	bool block_changed = false;
+
+	if (col &lt; col_end) {
+		local_offset[threadIdx.x] = threadIdx.x;
+		__syncthreads();
+
+		for (int row = row_start; row &lt; row_end; row++) {
+			int col_offset = local_offset[threadIdx.x];
+			int row_offset = local_offset[row - row_start];
+
+			local_changed[threadIdx.x] = 0;
+			__syncthreads();
+
+			if (row_offset != col_offset &amp;&amp; cluster_matrix[row * cluster_num + col] == 1) {
+				local_changed[col_offset] = 1;
+				block_changed = true;
+			}
+			__syncthreads();
+
+			local_offset[threadIdx.x] = (local_changed[col_offset] == 1) ? row_offset : col_offset;
+			__syncthreads();
+		}
+
+		__syncthreads();
+		int new_cluster = cluster_list[col_start + local_offset[threadIdx.x]];
 
-		for (unsigned int j = 0; j &lt; cluster_indices.size(); j++) {
-			if (cluster_indices_host_[i] == cluster_indices[j].index_value) {
-				(cluster_indices[j].points_in_cluster).push_back(i);
-				found = true;
+		__syncthreads();
+		cluster_list[col] = new_cluster;
+
+		if (block_changed)
+			*changed = true;
+	}
+}
+
+/* Checking if two individual blocks have any clusters that intersect.
+ *
+ * If there are, then the diagonal index that the block belongs to is
+ * recorded in changed_diag. All blocks in the same diagonal are merged
+ * in the next step.
+ */
+extern "C" __global__ void clustersIntersecCheck(int *cluster_matrix, int *changed_diag,
+													int base_row, int base_column,
+													int sub_matrix_row, int sub_matrix_col,
+													int sub_matrix_offset_row, int sub_matrix_offset_col,
+													int cluster_num)
+{
+	//Thinking about using % or not
+	int col_idx = (blockIdx.x / sub_matrix_col) * sub_matrix_offset_col + (blockIdx.x % sub_matrix_col);
+	int row_idx = (blockIdx.x / sub_matrix_row) * sub_matrix_offset_row + (blockIdx.y % sub_matrix_col);
+
+	int col_start = (base_column + col_idx) * blockDim.x;
+	int col_end = (col_start + blockDim.x &lt;= cluster_num) ? col_start + blockDim.x : cluster_num;
+	int row_start = (base_row + row_idx) * blockDim.x;
+	int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
+	int col = col_start + threadIdx.x;
+	int diag_offset = (col_idx &gt; row_idx) ? col_idx - row_idx : col_idx + row_idx;
+
+	if (col &lt; col_end &amp;&amp; col_start &lt;= col_end &amp;&amp; row_start &lt;= row_end) {
+		for (int row = row_start; row &lt; row_end; row++) {
+			if (cluster_matrix[row * cluster_num + col] == 1) {
+				*changed_diag = diag_offset;
 				break;
 			}
 		}
+	}
+}
 
-		if (!found) {
-			GClusterIndex new_cluster;
+/* Extract clusters of points.
+ *
+ * This method can handle the case with sparse points (distance between points
+ * are larger than threshold), which may lead to infinite loop in the first method.
+ */
 
-			new_cluster.index_value = cluster_indices_host_[i];
-			(new_cluster.points_in_cluster).push_back(i);
-			cluster_indices.push_back(new_cluster);
+void GpuEuclideanCluster::extractClusters2()
+{
+	int block_x, grid_x;
+
+	block_x = (size_ &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : size_;
+	grid_x = (size_ - 1) / block_x + 1;
+
+	int *cluster_offset;
+	int cluster_num, old_cluster_num;
+
+	pclEuclideanInitialize&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, size_);
+	checkCudaErrors(cudaDeviceSynchronize());
+
+	old_cluster_num = cluster_num = size_;
+
+	checkCudaErrors(cudaMalloc(&amp;cluster_offset, (size_ + 1) * sizeof(int)));
+	checkCudaErrors(cudaMemset(cluster_offset, 0, (size_ + 1) * sizeof(int)));
+	blockLabelling&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, cluster_indices_, size_, threshold_);
+	clusterMark&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_offset, size_);
+	exclusiveScan(cluster_offset, size_ + 1, &amp;cluster_num);
+
+	int *cluster_list, *new_cluster_list, *tmp;
+
+	checkCudaErrors(cudaMalloc(&amp;cluster_list, cluster_num * sizeof(int)));
+	clusterCollector&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_list, cluster_offset, size_);
+	checkCudaErrors(cudaDeviceSynchronize());
+
+	int *cluster_matrix;
+	int *new_cluster_matrix;
+
+	checkCudaErrors(cudaMalloc(&amp;cluster_matrix, cluster_num * cluster_num * sizeof(int)));
+	checkCudaErrors(cudaMemset(cluster_matrix, 0, cluster_num * cluster_num * sizeof(int)));
+	checkCudaErrors(cudaDeviceSynchronize());
+
+	checkCudaErrors(cudaMalloc(&amp;new_cluster_list, cluster_num * sizeof(int)));
+
+	buildClusterMatrix&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, cluster_indices_, cluster_matrix, cluster_offset, size_, cluster_num, threshold_);
+	checkCudaErrors(cudaDeviceSynchronize());
+
+	int block_x2 = 0, grid_x2 = 0;
+
+	bool *changed;
+
+	checkCudaErrors(cudaMallocHost(&amp;changed, sizeof(bool)));
+
+#ifndef SERIAL
+	int *changed_diag;
+
+	checkCudaErrors(cudaMallocHost(&amp;changed_diag, sizeof(int)));
+#endif
+
+	int max_base_row = 0;
+
+	do {
+		*changed = false;
+		block_x2 = (cluster_num &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : cluster_num;
+		grid_x2 = (cluster_num - 1)/block_x2 + 1;
+
+		mergeSelfClusters&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list, cluster_num, changed);
+		checkCudaErrors(cudaDeviceSynchronize());
+
+		int base_row = 1, base_column = 0;
+		int sub_matrix_offset_row = 2, sub_matrix_offset_col = 2;
+		int sub_matrix_row = 1, sub_matrix_col = 1;
+		int sub_matrix_num;
+		int max_rows = grid_x2;
+
+		max_base_row = base_row;
+
+		while (!(*changed) &amp;&amp; cluster_num &gt; BLOCK_SIZE_X &amp;&amp; base_row * BLOCK_SIZE_X &lt; cluster_num &amp;&amp; base_column &lt; cluster_num) {
+
+			sub_matrix_num = (cluster_num - base_row - 1)/sub_matrix_offset_row + 1;
+			block_x2 = BLOCK_SIZE_X;
+			grid_x2 = sub_matrix_num * sub_matrix_col;
+
+#ifdef SERIAL
+			//Merge clusters in each sub-matrix by moving from top to bottom of the similarity sub-matrix
+			for (int shift_level = 0; !(*changed) &amp;&amp; shift_level &lt; sub_matrix_col; shift_level++) {
+				mergeInterClusters&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list,
+																shift_level,
+																base_row, base_column,
+																sub_matrix_row, sub_matrix_col,
+																sub_matrix_offset_row, sub_matrix_offset_col,
+																cluster_num, changed);
+				checkCudaErrors(cudaDeviceSynchronize());
+			}
+#else
+			int grid_y2 = sub_matrix_row;
+
+			dim3 block_size(block_x2, 1, 1);
+			dim3 grid_size(grid_x2, grid_y2, 1);
+
+			*changed_diag = -1;
+
+			clustersIntersecCheck&lt;&lt;&lt;grid_size, block_size&gt;&gt;&gt;(cluster_matrix, changed_diag,
+																base_row, base_column,
+																sub_matrix_row, sub_matrix_col,
+																sub_matrix_offset_row, sub_matrix_offset_col,
+																cluster_num);
+			checkCudaErrors(cudaDeviceSynchronize());
+
+			if (*changed_diag &gt; 0) {
+				//Merge clusters in sub-matrix that stay in the changed_diag diagonal by moving from top to bottom of the matrix.
+				mergeInterClusters&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list, *changed_diag,
+															base_row, base_column,
+															sub_matrix_row, sub_matrix_col,
+															sub_matrix_offset_row, sub_matrix_offset_col,
+															cluster_num, changed);
+				checkCudaErrors(cudaDeviceSynchronize());
+			}
+
+#endif
+			base_row += sub_matrix_row;
+			sub_matrix_row = (sub_matrix_row * 2 + base_row &lt;  max_rows) ? sub_matrix_row * 2 : max_rows - base_row;
+			sub_matrix_col *= 2;
+			sub_matrix_offset_row *= 2;
+			sub_matrix_offset_col *= 2;
+		}
+
+		max_base_row = base_row;
+
+		if (*changed) {
+			reflexClusterChanges&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_offset, cluster_list, size_);
+			checkCudaErrors(cudaMemset(cluster_offset, 0, (size_ + 1) * sizeof(int)));
+
+			block_x2 = (cluster_num &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : cluster_num;
+			grid_x2 = (cluster_num - 1) / block_x2 + 1;
+
+			clusterMark&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_list, cluster_offset, cluster_num);
+
+			old_cluster_num = cluster_num;
+			exclusiveScan(cluster_offset, size_ + 1, &amp;cluster_num);
+			clusterCollector&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_list, new_cluster_list, cluster_offset, old_cluster_num);
+			checkCudaErrors(cudaDeviceSynchronize());
+
+			checkCudaErrors(cudaMalloc(&amp;new_cluster_matrix, cluster_num * cluster_num * sizeof(int)));
+			checkCudaErrors(cudaMemset(new_cluster_matrix, 0, cluster_num * cluster_num * sizeof(int)));
+			rebuildClusterMatrix&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list, new_cluster_matrix, cluster_offset, old_cluster_num, cluster_num);
+			checkCudaErrors(cudaDeviceSynchronize());
+
+			checkCudaErrors(cudaFree(cluster_matrix));
+			cluster_matrix = new_cluster_matrix;
+			tmp = cluster_list;
+			cluster_list = new_cluster_list;
+			new_cluster_list = tmp;
 		}
+	} while (*changed &amp;&amp; max_base_row &lt; cluster_num);
+
+	cluster_num_ = cluster_num;
+
+	//Reset all cluster indexes to make them start from 0
+	resetClusterIndexes&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_offset, size_);
+	checkCudaErrors(cudaDeviceSynchronize());
+
+	checkCudaErrors(cudaMemcpy(cluster_indices_host_, cluster_indices_, size_ * sizeof(int), cudaMemcpyDeviceToHost));
+
+	checkCudaErrors(cudaFree(cluster_matrix));
+	checkCudaErrors(cudaFree(cluster_list));
+	checkCudaErrors(cudaFree(new_cluster_list));
+	checkCudaErrors(cudaFree(cluster_offset));
+	checkCudaErrors(cudaFreeHost(changed));
+#ifndef SERIAL
+	checkCudaErrors(cudaFreeHost(changed_diag));
+#endif
+}
+
+/* Collect points that belong to same clusters and put them together.
+ *
+ * The output is a vector whose each element contains indexes of points
+ * that belong to a same clusters.
+ */
+std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; GpuEuclideanCluster::getOutput()
+{
+	std::vector&lt;GClusterIndex&gt; cluster_indices(cluster_num_);
+
+	for (unsigned int i = 0; i &lt; cluster_indices.size(); i++)
+		cluster_indices[i].index_value = -1;
+
+	for (int i = 0; i &lt; size_; i++) {
+		cluster_indices[cluster_indices_host_[i]].points_in_cluster.push_back(i);
+		cluster_indices[cluster_indices_host_[i]].index_value = cluster_indices_host_[i];
 	}
 
-	for (unsigned int i = 0; i &lt; cluster_indices.size(); ) {
+	for (unsigned int i = 0; i &lt; cluster_indices.size();) {
 		int number_of_pts = cluster_indices[i].points_in_cluster.size();
 
 		if (number_of_pts &lt; min_cluster_pts_ || number_of_pts &gt; max_cluster_pts_)
@@ -455,41 +783,37 @@ std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; GpuEuclideanCluster::getOutput()
 			i++;
 	}
 
-	//For testing
-//	float *x = (float*)malloc(sizeof(float) * size_);
-//	float *y = (float*)malloc(sizeof(float) * size_);
-//	float *z = (float*)malloc(sizeof(float) * size_);
-//
-//	cudaMemcpy(x, x_, sizeof(float) * size_, cudaMemcpyDeviceToHost);
-//	cudaMemcpy(y, y_, sizeof(float) * size_, cudaMemcpyDeviceToHost);
-//	cudaMemcpy(z, z_, sizeof(float) * size_, cudaMemcpyDeviceToHost);
-//
-//	for (int i = 0; i &lt; cluster_indices.size(); i++) {
-//		for (int j = 0; j &lt; cluster_indices[i].points_in_cluster.size(); j++) {
-//			for (int k = i + 1; k &lt; cluster_indices.size(); k++) {
-//				for (int p = 0; p &lt; cluster_indices[k].points_in_cluster.size(); p++) {
-//					int left = cluster_indices[i].points_in_cluster[j];
-//					int right = cluster_indices[k].points_in_cluster[p];
-//					float tmp_x = x[left] - x[right];
-//					float tmp_y = y[left] - y[right];
-//					float tmp_z = z[left] - z[right];
-//
-//					if (sqrt(tmp_x * tmp_x + tmp_y * tmp_y + tmp_z * tmp_z) &lt; threshold_)
-//						std::cout &lt;&lt; "Cluster " &lt;&lt; i &lt;&lt; " and " &lt;&lt; k &lt;&lt; " are the same" &lt;&lt; std::cout;
-//				}
-//			}
-//		}
-//	}
-//
-//	free(x);
-//	free(y);
-//	free(z);
-
-	//std::cout &lt;&lt; "Number of clusters in GPU is****************** " &lt;&lt; cluster_indices.size() &lt;&lt; std::endl;
-
 	return cluster_indices;
 }
 
+/* Generate sparse points.
+ * The number of points is fixed at 10000.
+ * Cannot afford more (e.g. 100 000 points) since
+ * GPU memory is not enough for a matrix with 10 billions cells.
+ */
+GpuEuclideanCluster::SamplePointListXYZ GpuEuclideanCluster::generateSample()
+{
+	GpuEuclideanCluster::SamplePointListXYZ output;
+
+	output.size = 10000;
+
+	output.x = (float*)malloc(sizeof(float) * output.size);
+	output.y = (float*)malloc(sizeof(float) * output.size);
+	output.z = (float*)malloc(sizeof(float) * output.size);
+
+	output.x[0] = 0;
+	output.y[0] = 0;
+	output.z[0] = 0;
+
+	for (int i = 1; i &lt; output.size; i++) {
+		output.x[i] = (i % 3 == 0) ? output.x[i - 1] + threshold_ + 1 : output.x[i - 1];
+		output.y[i] = (i % 3 == 1) ? output.y[i - 1] + threshold_ + 1: output.y[i - 1];
+		output.z[i] = (i % 3 == 2) ? output.z[i - 1] + threshold_ + 1: output.z[i - 1];
+	}
+
+	return output;
+}
+
 GpuEuclideanCluster::~GpuEuclideanCluster()
 {
 	checkCudaErrors(cudaFree(x_));
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\includes\gpu_euclidean_clustering.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\includes\gpu_euclidean_clustering.h" added_lines="12" deleted_lines="0">
				<diff>@@ -11,6 +11,13 @@ public:
 		std::vector&lt;int&gt; points_in_cluster;
 	} GClusterIndex;
 
+	typedef struct {
+		float *x;
+		float *y;
+		float *z;
+		int size;
+	} SamplePointListXYZ;
+
 	GpuEuclideanCluster();
 
 	void setInputPoints(float *x, float *y, float *z, int size);
@@ -18,8 +25,11 @@ public:
 	void setMinClusterPts(int min_cluster_pts);
 	void setMaxClusterPts(int max_cluster_pts);
 	void extractClusters();
+	void extractClusters2();
 	std::vector&lt;GClusterIndex&gt; getOutput();
 
+	SamplePointListXYZ generateSample();
+
 	~GpuEuclideanCluster();
 
 private:
@@ -30,6 +40,8 @@ private:
 	int *cluster_indices_host_;
 	int min_cluster_pts_;
 	int max_cluster_pts_;
+	int cluster_num_;
+
 
 	void exclusiveScan(int *input, int ele_num, int *sum);
 };
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e9f72e6e206df0fc5cc901f4a3a798948e78928d" author="AMC">
		<msg>Removed the chance of a deadlock on extreme cases when points are far from each other</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\gpu_euclidean_clustering.cu" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\gpu_euclidean_clustering.cu" added_lines="395" deleted_lines="71">
				<diff>@@ -16,13 +16,17 @@
 #include &lt;thrust/scan.h&gt;
 #include &lt;thrust/fill.h&gt;
 
+#include &lt;time.h&gt;
+#include &lt;sys/time.h&gt;
+
 #define MAX_SHARED_SIZE 2048
 #define BLOCK_SIZE_X 1024
 
+//#define SERIAL 1
+
 inline void gassert(cudaError_t err_code, const char *file, int line)
 {
-	if(err_code!= cudaSuccess)
-	{
+	if (err_code != cudaSuccess) {
 		fprintf(stderr, "Error: %s %s %d\n", cudaGetErrorString(err_code), file, line);
 		cudaDeviceReset();
 		exit(EXIT_FAILURE);
@@ -41,7 +45,9 @@ GpuEuclideanCluster::GpuEuclideanCluster()
 	threshold_ = 0;
 	cluster_indices_ = NULL;
 	cluster_indices_host_ = NULL;
-	min_cluster_pts_ = max_cluster_pts_ = 0;
+	min_cluster_pts_ = 0;
+	max_cluster_pts_ = 1000000000;
+	cluster_num_ = 0;
 }
 
 void GpuEuclideanCluster::setInputPoints(float *x, float *y, float *z, int size)
@@ -207,7 +213,7 @@ extern "C" __global__ void buildClusterMatrix(float *x, float *y, float *z, int
 
 		__syncthreads();
 
-		for (int row = column + 1; row &lt; size; row++) {
+		for (int row = 0; row &lt; column; row++) {
 			float tmp_x = x[row] - local_x[threadIdx.x];
 			float tmp_y = y[row] - local_y[threadIdx.x];
 			float tmp_z = z[row] - local_z[threadIdx.x];
@@ -219,7 +225,6 @@ extern "C" __global__ void buildClusterMatrix(float *x, float *y, float *z, int
 			if (row_cluster != column_cluster &amp;&amp; norm3df(tmp_x, tmp_y, tmp_z) &lt; threshold)
 				cluster_matrix[rc_offset * cluster_num + cc_offset] = 1;
 		}
-
 	}
 }
 
@@ -240,42 +245,45 @@ extern "C" __global__ void buildClusterMatrix(float *x, float *y, float *z, int
  */
 extern "C" __global__ void mergeClusters(int *cluster_matrix, int *cluster_list, int cluster_num)
 {
-	int block_start = blockIdx.x * blockDim.x;
-	int block_end = (block_start + blockDim.x &lt;= cluster_num) ? block_start + blockDim.x : cluster_num;
-	int row = block_start + threadIdx.x;
-	__shared__ int local_cluster_changed[BLOCK_SIZE_X];
+	int row_start = blockIdx.x * blockDim.x;
+	int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
+	int col = row_start + threadIdx.x;
+	__shared__ int local_changed[BLOCK_SIZE_X];
 	__shared__ int local_offset[BLOCK_SIZE_X];
 
-	if (row &lt; block_end) {
+	/* The cluster matrix is symmetric, so the
+	 * number of rows and columns are the same
+	 */
+	if (col &lt; row_end) {
 		local_offset[threadIdx.x] = threadIdx.x;
 
 		__syncthreads();
 
-		for (int column = block_start; column &lt; block_end; column++) {
-			int row_offset = local_offset[threadIdx.x];
-			int column_offset = local_offset[column - block_start];
+		for (int row = row_start; row &lt; row_end; row++) {
+			int col_offset = local_offset[threadIdx.x];
+			int row_offset = local_offset[row - row_start];
 
-			local_cluster_changed[threadIdx.x] = 0;
+			local_changed[threadIdx.x] = 0;
 			__syncthreads();
 
-			if (row &gt; column &amp;&amp; row_offset != column_offset &amp;&amp; (cluster_matrix[row * cluster_num + column] == 1))
-				local_cluster_changed[row_offset] = 1;
+			if (row &lt; col &amp;&amp; row_offset != col_offset &amp;&amp; (cluster_matrix[row * cluster_num + col] == 1))
+				local_changed[col_offset] = 1;
 			__syncthreads();
 
-			local_offset[threadIdx.x] = (local_cluster_changed[row_offset] == 1) ? column_offset : row_offset;
+			local_offset[threadIdx.x] = (local_changed[col_offset] == 1) ? row_offset : col_offset;
 			__syncthreads();
 		}
 
 		__syncthreads();
 
-		int new_cluster = cluster_list[block_start + local_offset[threadIdx.x]];
+		int new_cluster = cluster_list[row_start + local_offset[threadIdx.x]];
 
 		__syncthreads();
-		cluster_list[row] = new_cluster;
+		cluster_list[col] = new_cluster;
 	}
 }
 
-/* This kernel is to reflex the change in the cluster merging step
+/* Reflex the change in the cluster merging step
  * to cluster indices of all input points.
  *
  * Clusters of input points are changed to the target clusters
@@ -300,7 +308,7 @@ extern "C" __global__ void reflexClusterChanges(int *cluster_indices, int *clust
 extern "C" __global__ void rebuildClusterMatrix(int *old_cluster_matrix, int *new_clusters, int *new_cluster_matrix, int *new_cluster_offset, int old_size, int new_size)
 {
 	for (int column = threadIdx.x + blockIdx.x * blockDim.x; column &lt; old_size; column += blockDim.x * gridDim.x) {
-		for (int row = column + 1; row &lt; old_size; row++) {
+		for (int row = 0; row &lt; column; row++) {
 			int new_row = new_cluster_offset[new_clusters[row]];
 			int new_column = new_cluster_offset[new_clusters[column]];
 
@@ -326,6 +334,23 @@ void GpuEuclideanCluster::exclusiveScan(int *input, int ele_num, int *sum)
 	*sum = *(dev_ptr + ele_num - 1);
 }
 
+/* Reset the cluster indexes in the point cloud from 0.
+ *
+ * After merging, the cluster indexes of points are still large. Collecting
+ * those large indexes is either time-consuming (without using hash) or
+ * wasting memory space (using hash). By reset the cluster indexes from 0,
+ * we can use hashing to collect those indexes with the space complexity equal
+ * to the number of clusters.
+ */
+extern "C" __global__ void resetClusterIndexes(int *cluster_indices, int *cluster_offset, int size)
+{
+	for (int i = threadIdx.x + blockIdx.x * blockDim.x; i &lt; size; i += blockDim.x * gridDim.x) {
+		int old_cluster = cluster_indices[i];
+
+		cluster_indices[i] = cluster_offset[old_cluster];
+	}
+}
+
 
 /* Calculate the cluster indices of input points.
  *
@@ -392,7 +417,7 @@ void GpuEuclideanCluster::extractClusters()
 		if (grid_x2 == 1 &amp;&amp; cluster_num == old_cluster_num)
 			break;
 
-		clusterCollector&lt;&lt;&lt;grid_x, block_x2&gt;&gt;&gt;(cluster_list, new_cluster_list, cluster_offset, old_cluster_num);
+		clusterCollector&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_list, new_cluster_list, cluster_offset, old_cluster_num);
 		checkCudaErrors(cudaDeviceSynchronize());
 
 		checkCudaErrors(cudaMalloc(&amp;new_cluster_matrix, cluster_num * cluster_num * sizeof(int)));
@@ -407,6 +432,11 @@ void GpuEuclideanCluster::extractClusters()
 		new_cluster_list = tmp;
 	} while (1);
 
+	cluster_num_ = cluster_num;
+
+	resetClusterIndexes&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_offset, size_);
+	checkCudaErrors(cudaDeviceSynchronize());
+
 	checkCudaErrors(cudaMemcpy(cluster_indices_host_, cluster_indices_, size_ * sizeof(int), cudaMemcpyDeviceToHost));
 
 
@@ -416,37 +446,335 @@ void GpuEuclideanCluster::extractClusters()
 	checkCudaErrors(cudaFree(cluster_offset));
 }
 
+extern "C" __global__ void mergeSelfClusters(int *cluster_matrix, int *cluster_list, int cluster_num, bool *changed)
+{
+	int row_start = blockIdx.x * blockDim.x;
+	int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
+	int col = row_start + threadIdx.x;
+	__shared__ int local_changed[BLOCK_SIZE_X];
+	__shared__ int local_offset[BLOCK_SIZE_X];
+	bool block_changed = false;
 
-/* Collect points that belong to same clusters and put them together.
+	if (col &lt; row_end) {
+		local_offset[threadIdx.x] = threadIdx.x;
+
+		__syncthreads();
+
+		for (int row = row_start; row &lt; row_end; row++) {
+			int col_offset = local_offset[threadIdx.x];
+			int row_offset = local_offset[row - row_start];
+
+			local_changed[threadIdx.x] = 0;
+			__syncthreads();
+
+			if (row &lt; col &amp;&amp; row_offset != col_offset &amp;&amp; (cluster_matrix[row * cluster_num + col] == 1)) {
+				local_changed[col_offset] = 1;
+				block_changed = true;
+			}
+			__syncthreads();
+
+			local_offset[threadIdx.x] = (local_changed[col_offset] == 1) ? row_offset : col_offset;
+			__syncthreads();
+		}
+
+		__syncthreads();
+
+		int new_cluster = cluster_list[row_start + local_offset[threadIdx.x]];
+
+		__syncthreads();
+
+		cluster_list[col] = new_cluster;
+
+
+		__syncthreads();
+		if (block_changed)
+			*changed = true;
+	}
+}
+
+/* Merge clusters from different blocks of points.
  *
- * The output is a vector whose each element contains indexes of points
- * that belong to a same clusters.
+ * The relationship of those clusters are expressed by a cluster matrix.
+ * The merge is done by assigning each thread in a block of GPU threads
+ * to move from top to bottom of the matrix and check if there are any
+ * 1 element in the matrix.
+ *
+ * This kernel only merge matrices that staying in a same diagonal of a
+ * group of matrix. The index of the diagonal is indicated by shift_level.
  */
-std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; GpuEuclideanCluster::getOutput()
+
+extern "C" __global__ void mergeInterClusters(int *cluster_matrix, int *cluster_list,
+												int shift_level,
+												int base_row, int base_column,
+												int sub_matrix_row, int sub_matrix_col,
+												int sub_matrix_offset_row, int sub_matrix_offset_col,
+												int cluster_num, bool *changed)
 {
-	std::vector&lt;GClusterIndex&gt; cluster_indices;
+	int col_start = (base_column + (blockIdx.x/sub_matrix_col) * sub_matrix_offset_col + (blockIdx.x + shift_level - sub_matrix_col * ((blockIdx.x + shift_level)/sub_matrix_col))) * blockDim.x;
+	int col_end = (col_start + blockDim.x &lt;= cluster_num) ? col_start + blockDim.x : cluster_num;
+	int row_start = (base_row + (blockIdx.x/sub_matrix_row) * sub_matrix_offset_row + (blockIdx.x - sub_matrix_row * (blockIdx.x/sub_matrix_row))) * blockDim.x;
+	int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
+	int col = col_start + threadIdx.x;
 
-	for (int i = 0; i &lt; size_; i++) {
-		bool found = false;
+	__shared__ int local_changed[BLOCK_SIZE_X];
+	__shared__ int local_offset[BLOCK_SIZE_X];
+	bool block_changed = false;
+
+	if (col &lt; col_end) {
+		local_offset[threadIdx.x] = threadIdx.x;
+		__syncthreads();
+
+		for (int row = row_start; row &lt; row_end; row++) {
+			int col_offset = local_offset[threadIdx.x];
+			int row_offset = local_offset[row - row_start];
+
+			local_changed[threadIdx.x] = 0;
+			__syncthreads();
+
+			if (row_offset != col_offset &amp;&amp; cluster_matrix[row * cluster_num + col] == 1) {
+				local_changed[col_offset] = 1;
+				block_changed = true;
+			}
+			__syncthreads();
+
+			local_offset[threadIdx.x] = (local_changed[col_offset] == 1) ? row_offset : col_offset;
+			__syncthreads();
+		}
+
+		__syncthreads();
+		int new_cluster = cluster_list[col_start + local_offset[threadIdx.x]];
 
-		for (unsigned int j = 0; j &lt; cluster_indices.size(); j++) {
-			if (cluster_indices_host_[i] == cluster_indices[j].index_value) {
-				(cluster_indices[j].points_in_cluster).push_back(i);
-				found = true;
+		__syncthreads();
+		cluster_list[col] = new_cluster;
+
+		if (block_changed)
+			*changed = true;
+	}
+}
+
+/* Checking if two individual blocks have any clusters that intersect.
+ *
+ * If there are, then the diagonal index that the block belongs to is
+ * recorded in changed_diag. All blocks in the same diagonal are merged
+ * in the next step.
+ */
+extern "C" __global__ void clustersIntersecCheck(int *cluster_matrix, int *changed_diag,
+													int base_row, int base_column,
+													int sub_matrix_row, int sub_matrix_col,
+													int sub_matrix_offset_row, int sub_matrix_offset_col,
+													int cluster_num)
+{
+	//Thinking about using % or not
+	int col_idx = (blockIdx.x / sub_matrix_col) * sub_matrix_offset_col + (blockIdx.x % sub_matrix_col);
+	int row_idx = (blockIdx.x / sub_matrix_row) * sub_matrix_offset_row + (blockIdx.y % sub_matrix_col);
+
+	int col_start = (base_column + col_idx) * blockDim.x;
+	int col_end = (col_start + blockDim.x &lt;= cluster_num) ? col_start + blockDim.x : cluster_num;
+	int row_start = (base_row + row_idx) * blockDim.x;
+	int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
+	int col = col_start + threadIdx.x;
+	int diag_offset = (col_idx &gt; row_idx) ? col_idx - row_idx : col_idx + row_idx;
+
+	if (col &lt; col_end &amp;&amp; col_start &lt;= col_end &amp;&amp; row_start &lt;= row_end) {
+		for (int row = row_start; row &lt; row_end; row++) {
+			if (cluster_matrix[row * cluster_num + col] == 1) {
+				*changed_diag = diag_offset;
 				break;
 			}
 		}
+	}
+}
 
-		if (!found) {
-			GClusterIndex new_cluster;
+/* Extract clusters of points.
+ *
+ * This method can handle the case with sparse points (distance between points
+ * are larger than threshold), which may lead to infinite loop in the first method.
+ */
 
-			new_cluster.index_value = cluster_indices_host_[i];
-			(new_cluster.points_in_cluster).push_back(i);
-			cluster_indices.push_back(new_cluster);
+void GpuEuclideanCluster::extractClusters2()
+{
+	int block_x, grid_x;
+
+	block_x = (size_ &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : size_;
+	grid_x = (size_ - 1) / block_x + 1;
+
+	int *cluster_offset;
+	int cluster_num, old_cluster_num;
+
+	pclEuclideanInitialize&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, size_);
+	checkCudaErrors(cudaDeviceSynchronize());
+
+	old_cluster_num = cluster_num = size_;
+
+	checkCudaErrors(cudaMalloc(&amp;cluster_offset, (size_ + 1) * sizeof(int)));
+	checkCudaErrors(cudaMemset(cluster_offset, 0, (size_ + 1) * sizeof(int)));
+	blockLabelling&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, cluster_indices_, size_, threshold_);
+	clusterMark&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_offset, size_);
+	exclusiveScan(cluster_offset, size_ + 1, &amp;cluster_num);
+
+	int *cluster_list, *new_cluster_list, *tmp;
+
+	checkCudaErrors(cudaMalloc(&amp;cluster_list, cluster_num * sizeof(int)));
+	clusterCollector&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_list, cluster_offset, size_);
+	checkCudaErrors(cudaDeviceSynchronize());
+
+	int *cluster_matrix;
+	int *new_cluster_matrix;
+
+	checkCudaErrors(cudaMalloc(&amp;cluster_matrix, cluster_num * cluster_num * sizeof(int)));
+	checkCudaErrors(cudaMemset(cluster_matrix, 0, cluster_num * cluster_num * sizeof(int)));
+	checkCudaErrors(cudaDeviceSynchronize());
+
+	checkCudaErrors(cudaMalloc(&amp;new_cluster_list, cluster_num * sizeof(int)));
+
+	buildClusterMatrix&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, cluster_indices_, cluster_matrix, cluster_offset, size_, cluster_num, threshold_);
+	checkCudaErrors(cudaDeviceSynchronize());
+
+	int block_x2 = 0, grid_x2 = 0;
+
+	bool *changed;
+
+	checkCudaErrors(cudaMallocHost(&amp;changed, sizeof(bool)));
+
+#ifndef SERIAL
+	int *changed_diag;
+
+	checkCudaErrors(cudaMallocHost(&amp;changed_diag, sizeof(int)));
+#endif
+
+	int max_base_row = 0;
+
+	do {
+		*changed = false;
+		block_x2 = (cluster_num &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : cluster_num;
+		grid_x2 = (cluster_num - 1)/block_x2 + 1;
+
+		mergeSelfClusters&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list, cluster_num, changed);
+		checkCudaErrors(cudaDeviceSynchronize());
+
+		int base_row = 1, base_column = 0;
+		int sub_matrix_offset_row = 2, sub_matrix_offset_col = 2;
+		int sub_matrix_row = 1, sub_matrix_col = 1;
+		int sub_matrix_num;
+		int max_rows = grid_x2;
+
+		max_base_row = base_row;
+
+		while (!(*changed) &amp;&amp; cluster_num &gt; BLOCK_SIZE_X &amp;&amp; base_row * BLOCK_SIZE_X &lt; cluster_num &amp;&amp; base_column &lt; cluster_num) {
+
+			sub_matrix_num = (cluster_num - base_row - 1)/sub_matrix_offset_row + 1;
+			block_x2 = BLOCK_SIZE_X;
+			grid_x2 = sub_matrix_num * sub_matrix_col;
+
+#ifdef SERIAL
+			//Merge clusters in each sub-matrix by moving from top to bottom of the similarity sub-matrix
+			for (int shift_level = 0; !(*changed) &amp;&amp; shift_level &lt; sub_matrix_col; shift_level++) {
+				mergeInterClusters&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list,
+																shift_level,
+																base_row, base_column,
+																sub_matrix_row, sub_matrix_col,
+																sub_matrix_offset_row, sub_matrix_offset_col,
+																cluster_num, changed);
+				checkCudaErrors(cudaDeviceSynchronize());
+			}
+#else
+			int grid_y2 = sub_matrix_row;
+
+			dim3 block_size(block_x2, 1, 1);
+			dim3 grid_size(grid_x2, grid_y2, 1);
+
+			*changed_diag = -1;
+
+			clustersIntersecCheck&lt;&lt;&lt;grid_size, block_size&gt;&gt;&gt;(cluster_matrix, changed_diag,
+																base_row, base_column,
+																sub_matrix_row, sub_matrix_col,
+																sub_matrix_offset_row, sub_matrix_offset_col,
+																cluster_num);
+			checkCudaErrors(cudaDeviceSynchronize());
+
+			if (*changed_diag &gt; 0) {
+				//Merge clusters in sub-matrix that stay in the changed_diag diagonal by moving from top to bottom of the matrix.
+				mergeInterClusters&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list, *changed_diag,
+															base_row, base_column,
+															sub_matrix_row, sub_matrix_col,
+															sub_matrix_offset_row, sub_matrix_offset_col,
+															cluster_num, changed);
+				checkCudaErrors(cudaDeviceSynchronize());
+			}
+
+#endif
+			base_row += sub_matrix_row;
+			sub_matrix_row = (sub_matrix_row * 2 + base_row &lt;  max_rows) ? sub_matrix_row * 2 : max_rows - base_row;
+			sub_matrix_col *= 2;
+			sub_matrix_offset_row *= 2;
+			sub_matrix_offset_col *= 2;
+		}
+
+		max_base_row = base_row;
+
+		if (*changed) {
+			reflexClusterChanges&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_offset, cluster_list, size_);
+			checkCudaErrors(cudaMemset(cluster_offset, 0, (size_ + 1) * sizeof(int)));
+
+			block_x2 = (cluster_num &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : cluster_num;
+			grid_x2 = (cluster_num - 1) / block_x2 + 1;
+
+			clusterMark&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_list, cluster_offset, cluster_num);
+
+			old_cluster_num = cluster_num;
+			exclusiveScan(cluster_offset, size_ + 1, &amp;cluster_num);
+			clusterCollector&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_list, new_cluster_list, cluster_offset, old_cluster_num);
+			checkCudaErrors(cudaDeviceSynchronize());
+
+			checkCudaErrors(cudaMalloc(&amp;new_cluster_matrix, cluster_num * cluster_num * sizeof(int)));
+			checkCudaErrors(cudaMemset(new_cluster_matrix, 0, cluster_num * cluster_num * sizeof(int)));
+			rebuildClusterMatrix&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list, new_cluster_matrix, cluster_offset, old_cluster_num, cluster_num);
+			checkCudaErrors(cudaDeviceSynchronize());
+
+			checkCudaErrors(cudaFree(cluster_matrix));
+			cluster_matrix = new_cluster_matrix;
+			tmp = cluster_list;
+			cluster_list = new_cluster_list;
+			new_cluster_list = tmp;
 		}
+	} while (*changed &amp;&amp; max_base_row &lt; cluster_num);
+
+	cluster_num_ = cluster_num;
+
+	//Reset all cluster indexes to make them start from 0
+	resetClusterIndexes&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_offset, size_);
+	checkCudaErrors(cudaDeviceSynchronize());
+
+	checkCudaErrors(cudaMemcpy(cluster_indices_host_, cluster_indices_, size_ * sizeof(int), cudaMemcpyDeviceToHost));
+
+	checkCudaErrors(cudaFree(cluster_matrix));
+	checkCudaErrors(cudaFree(cluster_list));
+	checkCudaErrors(cudaFree(new_cluster_list));
+	checkCudaErrors(cudaFree(cluster_offset));
+	checkCudaErrors(cudaFreeHost(changed));
+#ifndef SERIAL
+	checkCudaErrors(cudaFreeHost(changed_diag));
+#endif
+}
+
+/* Collect points that belong to same clusters and put them together.
+ *
+ * The output is a vector whose each element contains indexes of points
+ * that belong to a same clusters.
+ */
+std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; GpuEuclideanCluster::getOutput()
+{
+	std::vector&lt;GClusterIndex&gt; cluster_indices(cluster_num_);
+
+	for (unsigned int i = 0; i &lt; cluster_indices.size(); i++)
+		cluster_indices[i].index_value = -1;
+
+	for (int i = 0; i &lt; size_; i++) {
+		cluster_indices[cluster_indices_host_[i]].points_in_cluster.push_back(i);
+		cluster_indices[cluster_indices_host_[i]].index_value = cluster_indices_host_[i];
 	}
 
-	for (unsigned int i = 0; i &lt; cluster_indices.size(); ) {
+	for (unsigned int i = 0; i &lt; cluster_indices.size();) {
 		int number_of_pts = cluster_indices[i].points_in_cluster.size();
 
 		if (number_of_pts &lt; min_cluster_pts_ || number_of_pts &gt; max_cluster_pts_)
@@ -455,41 +783,37 @@ std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; GpuEuclideanCluster::getOutput()
 			i++;
 	}
 
-	//For testing
-//	float *x = (float*)malloc(sizeof(float) * size_);
-//	float *y = (float*)malloc(sizeof(float) * size_);
-//	float *z = (float*)malloc(sizeof(float) * size_);
-//
-//	cudaMemcpy(x, x_, sizeof(float) * size_, cudaMemcpyDeviceToHost);
-//	cudaMemcpy(y, y_, sizeof(float) * size_, cudaMemcpyDeviceToHost);
-//	cudaMemcpy(z, z_, sizeof(float) * size_, cudaMemcpyDeviceToHost);
-//
-//	for (int i = 0; i &lt; cluster_indices.size(); i++) {
-//		for (int j = 0; j &lt; cluster_indices[i].points_in_cluster.size(); j++) {
-//			for (int k = i + 1; k &lt; cluster_indices.size(); k++) {
-//				for (int p = 0; p &lt; cluster_indices[k].points_in_cluster.size(); p++) {
-//					int left = cluster_indices[i].points_in_cluster[j];
-//					int right = cluster_indices[k].points_in_cluster[p];
-//					float tmp_x = x[left] - x[right];
-//					float tmp_y = y[left] - y[right];
-//					float tmp_z = z[left] - z[right];
-//
-//					if (sqrt(tmp_x * tmp_x + tmp_y * tmp_y + tmp_z * tmp_z) &lt; threshold_)
-//						std::cout &lt;&lt; "Cluster " &lt;&lt; i &lt;&lt; " and " &lt;&lt; k &lt;&lt; " are the same" &lt;&lt; std::cout;
-//				}
-//			}
-//		}
-//	}
-//
-//	free(x);
-//	free(y);
-//	free(z);
-
-	//std::cout &lt;&lt; "Number of clusters in GPU is****************** " &lt;&lt; cluster_indices.size() &lt;&lt; std::endl;
-
 	return cluster_indices;
 }
 
+/* Generate sparse points.
+ * The number of points is fixed at 10000.
+ * Cannot afford more (e.g. 100 000 points) since
+ * GPU memory is not enough for a matrix with 10 billions cells.
+ */
+GpuEuclideanCluster::SamplePointListXYZ GpuEuclideanCluster::generateSample()
+{
+	GpuEuclideanCluster::SamplePointListXYZ output;
+
+	output.size = 10000;
+
+	output.x = (float*)malloc(sizeof(float) * output.size);
+	output.y = (float*)malloc(sizeof(float) * output.size);
+	output.z = (float*)malloc(sizeof(float) * output.size);
+
+	output.x[0] = 0;
+	output.y[0] = 0;
+	output.z[0] = 0;
+
+	for (int i = 1; i &lt; output.size; i++) {
+		output.x[i] = (i % 3 == 0) ? output.x[i - 1] + threshold_ + 1 : output.x[i - 1];
+		output.y[i] = (i % 3 == 1) ? output.y[i - 1] + threshold_ + 1: output.y[i - 1];
+		output.z[i] = (i % 3 == 2) ? output.z[i - 1] + threshold_ + 1: output.z[i - 1];
+	}
+
+	return output;
+}
+
 GpuEuclideanCluster::~GpuEuclideanCluster()
 {
 	checkCudaErrors(cudaFree(x_));
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\includes\gpu_euclidean_clustering.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\includes\gpu_euclidean_clustering.h" added_lines="12" deleted_lines="0">
				<diff>@@ -11,6 +11,13 @@ public:
 		std::vector&lt;int&gt; points_in_cluster;
 	} GClusterIndex;
 
+	typedef struct {
+		float *x;
+		float *y;
+		float *z;
+		int size;
+	} SamplePointListXYZ;
+
 	GpuEuclideanCluster();
 
 	void setInputPoints(float *x, float *y, float *z, int size);
@@ -18,8 +25,11 @@ public:
 	void setMinClusterPts(int min_cluster_pts);
 	void setMaxClusterPts(int max_cluster_pts);
 	void extractClusters();
+	void extractClusters2();
 	std::vector&lt;GClusterIndex&gt; getOutput();
 
+	SamplePointListXYZ generateSample();
+
 	~GpuEuclideanCluster();
 
 private:
@@ -30,6 +40,8 @@ private:
 	int *cluster_indices_host_;
 	int min_cluster_pts_;
 	int max_cluster_pts_;
+	int cluster_num_;
+
 
 	void exclusiveScan(int *input, int ele_num, int *sum);
 };
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1f97f48a45b4f107ac36236d079dd1eff61cbbf0" author="YamatoAndo">
		<msg>convert to autoware_msgs</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lib\fusion\fusion.cpp" new_path="ros\src\computing\perception\detection\lib\fusion\fusion.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -61,7 +61,7 @@ static std::vector&lt;float&gt; filtered_distances;
 static std::vector&lt;float&gt; filtered_min_heights;//stores the min height of the object
 static std::vector&lt;float&gt; filtered_max_heights;//stores the max height of the object
 
-static points2image::PointsImage points_msg;
+static autoware_msgs::PointsImage points_msg;
 
 static bool objectsStored = false, pointsStored = false;
 
@@ -265,7 +265,7 @@ static void showRects(IplImage *image, int object_num, const std::vector&lt;int&gt;&amp; c
 }
 #endif
 
-void setDetectedObjects(const cv_tracker_msgs::image_obj&amp; detected_objects)
+void setDetectedObjects(const autoware_msgs::image_obj&amp; detected_objects)
 {
 	objectsStored = false;
 	obj_type = detected_objects.type;
@@ -283,7 +283,7 @@ void setDetectedObjects(const cv_tracker_msgs::image_obj&amp; detected_objects)
 	objectsStored = true;
 }
 
-/*void setScanImage(const scan2image::ScanImage&amp; scan_image)
+/*void setScanImage(const autoware_msgs::ScanImage&amp; scan_image)
 {
 #if _DEBUG
 	if(image == nullptr){
@@ -303,7 +303,7 @@ void setDetectedObjects(const cv_tracker_msgs::image_obj&amp; detected_objects)
 	g_scan_image.min_y = scan_image.min_y;
 }*/
 
-void setPointsImage(const points2image::PointsImage&amp; points_image)
+void setPointsImage(const autoware_msgs::PointsImage&amp; points_image)
 {
 #if _DEBUG
 	if(image == nullptr){
@@ -446,13 +446,13 @@ std::vector&lt;float&gt; getMaxHeights()
 	return filtered_max_heights;
 }
 
-std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; getObjectsRectRanged()
+std::vector&lt;autoware_msgs::image_rect_ranged&gt; getObjectsRectRanged()
 {
-	std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; fused_objects;
+	std::vector&lt;autoware_msgs::image_rect_ranged&gt; fused_objects;
 	for (int i=0; i&lt;filtered_objects_num; i++)
 	{
 		int base = i * 4;
-		cv_tracker_msgs::image_rect_ranged obj_ranged;
+		autoware_msgs::image_rect_ranged obj_ranged;
 		obj_ranged.rect.x      = filtered_corner_points.at(base);
 		obj_ranged.rect.y      = filtered_corner_points.at(base + 1);
 		obj_ranged.rect.width  = filtered_corner_points.at(base + 2);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\fusion\include\fusion_func.h" new_path="ros\src\computing\perception\detection\lib\fusion\include\fusion_func.h" added_lines="9" deleted_lines="9">
				<diff>@@ -38,11 +38,11 @@
 #include &lt;vector&gt;
 
 #include &lt;ros/ros.h&gt;
-#include &lt;cv_tracker_msgs/image_obj.h&gt;
-#include &lt;cv_tracker_msgs/image_rect_ranged.h&gt;
-#include &lt;scan2image/ScanImage.h&gt;
-#include &lt;points2image/PointsImage.h&gt;
-#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
+#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/image_rect_ranged.h"
+#include "autoware_msgs/ScanImage.h"
+#include "autoware_msgs/PointsImage.h"
+#include "autoware_msgs/image_obj_tracked.h"
 
 #include &lt;opencv2/opencv.hpp&gt;
 
@@ -81,10 +81,10 @@ extern std::vector&lt;float&gt; getMaxHeights();
 extern void setParams(float minLowHeight, float maxLowHeight, float maxHeight, int minPoints, float disp);
 
 extern void calcDistance();
-extern void setDetectedObjects(const cv_tracker_msgs::image_obj&amp; image_objects);
-extern void setScanImage(const scan2image::ScanImage&amp; scan_image);
-extern void setPointsImage(const points2image::PointsImage&amp; points_image);
-extern std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; getObjectsRectRanged();
+extern void setDetectedObjects(const autoware_msgs::image_obj&amp; image_objects);
+extern void setScanImage(const autoware_msgs::ScanImage&amp; scan_image);
+extern void setPointsImage(const autoware_msgs::PointsImage&amp; points_image);
+extern std::vector&lt;autoware_msgs::image_rect_ranged&gt; getObjectsRectRanged();
 extern std::string getObjectsType();
 extern void init();
 extern void destroy();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ocv\dpm_ocv.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ocv\dpm_ocv.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -6,8 +6,8 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;cv_tracker_msgs/image_obj.h&gt;
-#include &lt;runtime_manager/ConfigCarDpm.h&gt;
+#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/ConfigCarDpm.h"
 
 #include &lt;dpm_ocv.hpp&gt;
 
@@ -31,7 +31,7 @@ public:
 
 private:
 	void imageCallback(const sensor_msgs::ImageConstPtr&amp; img);
-	void configCallback(const runtime_manager::ConfigCarDpm::ConstPtr&amp; param);
+	void configCallback(const autoware_msgs::ConfigCarDpm::ConstPtr&amp; param);
 
 	ros::NodeHandle nh_;
 	ros::Subscriber config_sub_;
@@ -133,9 +133,9 @@ void objectDetect::run()
 {
 	std::string config_topic("/config");
 	config_topic += ros::this_node::getNamespace() + "/dpm";
-	config_sub_ = nh_.subscribe&lt;runtime_manager::ConfigCarDpm&gt;(config_topic, 1, &amp;objectDetect::configCallback, this);
+	config_sub_ = nh_.subscribe&lt;autoware_msgs::ConfigCarDpm&gt;(config_topic, 1, &amp;objectDetect::configCallback, this);
 	img_sub_ = nh_.subscribe&lt;sensor_msgs::Image&gt;(image_topic_name, 1, &amp;objectDetect::imageCallback, this);
-	detect_pub_ = nh_.advertise&lt;cv_tracker_msgs::image_obj&gt;("image_obj", 1);
+	detect_pub_ = nh_.advertise&lt;autoware_msgs::image_obj&gt;("image_obj", 1);
 }
 
 // Callback
@@ -164,14 +164,14 @@ void objectDetect::imageCallback(const sensor_msgs::ImageConstPtr&amp; img)
 	std::vector&lt;int&gt; corner_point_array(num * 4.0);
 	std::vector&lt;int&gt; type_array(num, 0);
 
-	cv_tracker_msgs::image_obj msg;
+	autoware_msgs::image_obj msg;
 	msg.header = img-&gt;header;
 	msg.type = object_class;
 
 	for(size_t i = 0; i &lt; detections.size(); i++)
 	{
 		const cv::LatentSvmDetector::ObjectDetection&amp; od = detections[i];
-		cv_tracker_msgs::image_rect rect;
+		autoware_msgs::image_rect rect;
 
 		type_array[i] = od.classID;
 		rect.x = od.rect.x;
@@ -185,7 +185,7 @@ void objectDetect::imageCallback(const sensor_msgs::ImageConstPtr&amp; img)
 	detect_pub_.publish(msg);
 }
 
-void objectDetect::configCallback(const runtime_manager::ConfigCarDpm::ConstPtr&amp; param)
+void objectDetect::configCallback(const autoware_msgs::ConfigCarDpm::ConstPtr&amp; param)
 {
 	score_threshold_   = param-&gt;score_threshold;
 	overlap_threshold_ = param-&gt;group_threshold;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ttic\dpm_ttic.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ttic\dpm_ttic.cpp" added_lines="7" deleted_lines="8">
				<diff>@@ -36,9 +36,8 @@
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 
-#include &lt;cv_tracker_msgs/image_obj.h&gt;
-#include &lt;runtime_manager/ConfigCarDpm.h&gt;
-#include &lt;runtime_manager/ConfigPedestrianDpm.h&gt;
+#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/ConfigPedestrianDpm.h"
 
 #include &lt;dpm_ttic.hpp&gt;
 
@@ -67,10 +66,10 @@ static void set_default_param(DPMTTICParam&amp; param)
 	param.num_cells = 8;counter =0;
 }
 
-static void result_to_image_obj_message(cv_tracker_msgs::image_obj&amp; msg, const DPMTTICResult result)
+static void result_to_image_obj_message(autoware_msgs::image_obj&amp; msg, const DPMTTICResult result)
 {
 	for (int i = 0; i &lt; result.num; ++i) {
-		cv_tracker_msgs::image_rect rect;
+		autoware_msgs::image_rect rect;
 
 		int base = i * 4;
 		rect.x = result.corner_points[base];
@@ -90,7 +89,7 @@ static void image_raw_cb(const sensor_msgs::Image&amp; image_source)
 	IplImage img = cv_image-&gt;image;
 	IplImage *img_ptr = &amp;img;
 
-	cv_tracker_msgs::image_obj msg;
+	autoware_msgs::image_obj msg;
 	msg.header = image_source.header;
 	msg.type = object_class;
 
@@ -110,7 +109,7 @@ static void image_raw_cb(const sensor_msgs::Image&amp; image_source)
 	counter++;
 }
 
-static void config_cb(const runtime_manager::ConfigPedestrianDpm::ConstPtr&amp; param)
+static void config_cb(const autoware_msgs::ConfigPedestrianDpm::ConstPtr&amp; param)
 {
 	ttic_param.threshold = param-&gt;score_threshold;
 	ttic_param.overlap   = param-&gt;group_threshold;
@@ -190,7 +189,7 @@ int main(int argc, char* argv[])
 #endif
 
 	ros::Subscriber sub = n.subscribe(image_topic_name, 1, image_raw_cb);
-	image_obj_pub = n.advertise&lt;cv_tracker_msgs::image_obj&gt;("image_obj", 1);
+	image_obj_pub = n.advertise&lt;autoware_msgs::image_obj&gt;("image_obj", 1);
 
 	ros::Subscriber config_sub;
 	std::string config_topic("/config");
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dummy_track\dummy_track.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dummy_track\dummy_track.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -29,14 +29,14 @@
 */
 
 #include &lt;ros/ros.h&gt;
-#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
-#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
+#include &lt;autoware_msgs/image_obj_tracked.h&gt;
+#include &lt;autoware_msgs/image_obj_ranged.h&gt;
 
 class DummyTrack{
 public:
   DummyTrack(){
     subscriber_image_obj_ = node_handle_.subscribe("image_obj_ranged", 1, &amp;DummyTrack::detections_callback, this);
-		publisher_tracked_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj_tracked&gt;("image_obj_tracked", 1);
+		publisher_tracked_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj_tracked&gt;("image_obj_tracked", 1);
   }
   void run(){
     ros::spin();
@@ -46,9 +46,9 @@ private:
   ros::Publisher 		publisher_tracked_objects_;//ROS
   ros::NodeHandle 	node_handle_;
 
-  void detections_callback(cv_tracker_msgs::image_obj_ranged image_objects_msg)
+  void detections_callback(autoware_msgs::image_obj_ranged image_objects_msg)
   {
-    cv_tracker_msgs::image_obj_tracked pub_msg;
+    autoware_msgs::image_obj_tracked pub_msg;
     pub_msg.header = image_objects_msg.header;
     pub_msg.type = image_objects_msg.type;
     pub_msg.rect_ranged = image_objects_msg.obj;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\kf_track\kf_track.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\kf_track\kf_track.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -30,7 +30,6 @@
 
 #include &lt;string&gt;
 #include &lt;ros/ros.h&gt;
-#include &lt;cv_tracker_msgs/ImageObjects.h&gt;
 
 extern int kf_main(int argc, char* argv[]);
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\klt_track\klt_track.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\klt_track\klt_track.cpp" added_lines="12" deleted_lines="12">
				<diff>@@ -37,9 +37,9 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;cv_tracker_msgs/image_obj.h&gt;
-#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
-#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
+#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/image_obj_tracked.h"
+#include "autoware_msgs/image_obj_ranged.h"
 
 //TRACKING STUFF
 #include &lt;opencv2/core/core.hpp&gt;
@@ -85,7 +85,7 @@ class RosTrackerApp
 	std::vector&lt;float&gt; min_heights_;
 	std::vector&lt;float&gt; max_heights_;
 
-	cv_tracker_msgs::image_obj_tracked ros_objects_msg_;//sync
+	autoware_msgs::image_obj_tracked ros_objects_msg_;//sync
 
 	void Sort(const std::vector&lt;float&gt; in_scores, std::vector&lt;unsigned int&gt;&amp; in_out_indices)
 	{
@@ -260,13 +260,13 @@ public:
 
 		//copy results to ros msg
 		unsigned int num = obj_trackers_.size();
-		std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; rect_ranged_array;//tracked rectangles
+		std::vector&lt;autoware_msgs::image_rect_ranged&gt; rect_ranged_array;//tracked rectangles
 		std::vector&lt;int&gt; real_data(num,0);//boolean array to show if data in rect_ranged comes from tracking or detection
 		std::vector&lt;unsigned int&gt; obj_id(num, 0);//id number for each rect_range
 		std::vector&lt;unsigned int&gt; lifespan(num, 0);//remaining lifespan of each rectranged
 		for(i=0; i &lt; num; i++)
 		{
-			cv_tracker_msgs::image_rect_ranged rect_ranged;
+			autoware_msgs::image_rect_ranged rect_ranged;
 			LkTracker tracker_tmp = *obj_trackers_[i];
 			rect_ranged.rect.x = tracker_tmp.GetTrackedObject().rect.x;
 			rect_ranged.rect.y = tracker_tmp.GetTrackedObject().rect.y;
@@ -292,7 +292,7 @@ public:
 		obj_detections_.clear();
         ranges_.clear();
 
-		cv_tracker_msgs::image_obj_tracked tmp_objects_msg;
+		autoware_msgs::image_obj_tracked tmp_objects_msg;
 
 		tmp_objects_msg.type = tracked_type_;
 		tmp_objects_msg.total_num = num;
@@ -317,14 +317,14 @@ public:
 
 	}
 
-	void detections_callback(cv_tracker_msgs::image_obj_ranged image_objects_msg)
+	void detections_callback(autoware_msgs::image_obj_ranged image_objects_msg)
 	{
 		//if(ready_)
 		//	return;
 		if (!detect_ready_)//must NOT overwrite, data is probably being used by tracking.
 		{
 			unsigned int num = image_objects_msg.obj.size();
-			std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects = image_objects_msg.obj;
+			std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects = image_objects_msg.obj;
 			tracked_type_ = image_objects_msg.type;
 			//points are X,Y,W,H and repeat for each instance
 			obj_detections_.clear();
@@ -350,13 +350,13 @@ public:
 		publish_if_possible();
 		//ready_ = true;
 	}
-	/*void detections_callback(cv_tracker_msgs::image_obj image_objects_msg)
+	/*void detections_callback(autoware_msgs::image_obj image_objects_msg)
 	{
 		if (ready_)
 			return;
 		ready_ = false;
 		unsigned int num = image_objects_msg.obj.size();
-		std::vector&lt;cv_tracker_msgs::image_rect&gt; objects = image_objects_msg.obj;
+		std::vector&lt;autoware_msgs::image_rect&gt; objects = image_objects_msg.obj;
 		//object_type = image_objects_msg.type;
 		//points are X,Y,W,H and repeat for each instance
 		obj_detections_.clear();
@@ -406,7 +406,7 @@ public:
 		}
 
 
-		publisher_tracked_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj_tracked&gt;("image_obj_tracked", 1);
+		publisher_tracked_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj_tracked&gt;("image_obj_tracked", 1);
 
 		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
 		ROS_INFO("Subscribing to... %s", image_obj_topic_str.c_str());
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\obj_reproj.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\obj_reproj.cpp" added_lines="10" deleted_lines="11">
				<diff>@@ -51,12 +51,10 @@
 
 #include &lt;std_msgs/Float64.h&gt;
 #include &lt;std_msgs/Header.h&gt;
-#include &lt;scan2image/ScanImage.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;geometry_msgs/Pose.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
 #include &lt;tf/tf.h&gt;
 #include &lt;tf/transform_listener.h&gt;
 #include &lt;sensor_msgs/NavSatFix.h&gt;
@@ -65,8 +63,9 @@
 #include "axialMove.h"
 #include "geo_pos_conv.hh"
 #include "CalObjLoc.h"
-#include "cv_tracker_msgs/obj_label.h"
-#include "calibration_camera_lidar/projection_matrix.h"
+#include "autoware_msgs/image_obj_tracked.h"
+#include "autoware_msgs/obj_label.h"
+#include "autoware_msgs/projection_matrix.h"
 #include &lt;sensor_msgs/CameraInfo.h&gt;
 #include &lt;mutex&gt;
 
@@ -121,7 +120,7 @@ static tf::StampedTransform transformCam2Map;
 std::string camera_id_str;
 
 
-static visualization_msgs::MarkerArray convert_marker_array(const cv_tracker_msgs::obj_label&amp; src)
+static visualization_msgs::MarkerArray convert_marker_array(const autoware_msgs::obj_label&amp; src)
 {
   visualization_msgs::MarkerArray ret;
   int index = 0;
@@ -196,7 +195,7 @@ static visualization_msgs::MarkerArray convert_marker_array(const cv_tracker_msg
 }
 
 #ifdef HAVE_JSK_PLUGIN
-static jsk_recognition_msgs::BoundingBoxArray convertJskBoundingBoxArray(const cv_tracker_msgs::obj_label&amp; src)
+static jsk_recognition_msgs::BoundingBoxArray convertJskBoundingBoxArray(const autoware_msgs::obj_label&amp; src)
 {
   jsk_recognition_msgs::BoundingBoxArray ret;
   ret.header.frame_id ="map";
@@ -219,7 +218,7 @@ static jsk_recognition_msgs::BoundingBoxArray convertJskBoundingBoxArray(const c
 }
 #endif  // ifdef HAVE_JSK_PLUGIN
 
-static void projection_callback(const calibration_camera_lidar::projection_matrix&amp; msg)
+static void projection_callback(const autoware_msgs::projection_matrix&amp; msg)
 {
   for (int row=0; row&lt;4; row++) {
     for (int col=0; col&lt;4; col++) {
@@ -254,7 +253,7 @@ void GetRPY(const geometry_msgs::Pose &amp;pose,
 
 void makeSendDataDetectedObj(vector&lt;OBJPOS&gt; car_position_vector,
                              vector&lt;OBJPOS&gt;::iterator cp_iterator,
-                             cv_tracker_msgs::obj_label&amp; send_data)
+                             autoware_msgs::obj_label&amp; send_data)
 {
   geometry_msgs::Point tmpPoint;
 
@@ -298,7 +297,7 @@ void locatePublisher(void){
   //get values from sample_corner_point , convert latitude and longitude,
   //and send database server.
 
-  cv_tracker_msgs::obj_label obj_label_msg;
+  autoware_msgs::obj_label obj_label_msg;
   visualization_msgs::MarkerArray obj_label_marker_msgs;
 
   vector&lt;OBJPOS&gt;::iterator cp_iterator;
@@ -329,7 +328,7 @@ void locatePublisher(void){
 #endif  // ifdef HAVE_JSK_PLUGIN
 }
 
-static void obj_pos_xyzCallback(const cv_tracker_msgs::image_obj_tracked&amp; fused_objects)
+static void obj_pos_xyzCallback(const autoware_msgs::image_obj_tracked&amp; fused_objects)
 {
   if (!ready_)
     return;
@@ -399,7 +398,7 @@ int main(int argc, char **argv){
 
   ros::Subscriber obj_pos_xyz = n.subscribe("image_obj_tracked", 1, obj_pos_xyzCallback);
 
-  pub = n.advertise&lt;cv_tracker_msgs::obj_label&gt;("obj_label",1);
+  pub = n.advertise&lt;autoware_msgs::obj_label&gt;("obj_label",1);
   marker_pub = n.advertise&lt;visualization_msgs::MarkerArray&gt;("obj_label_marker", 1);
 
 #ifdef HAVE_JSK_PLUGIN
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\range_fusion\range_fusion.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\range_fusion\range_fusion.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -29,10 +29,10 @@
 */
 
 #include &lt;ros/ros.h&gt;
-#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
 #include &lt;std_msgs/Header.h&gt;
 #include &lt;fusion_func.h&gt;
-#include &lt;runtime_manager/ConfigCarFusion.h&gt;
+#include "autoware_msgs/image_obj_ranged.h"
+#include "autoware_msgs/ConfigCarFusion.h"
 
 static void publishTopic();
 static ros::Publisher fused_objects;
@@ -40,7 +40,7 @@ static std_msgs::Header sensor_header;
 
 bool ready_ = false;
 
-static void DetectedObjectsCallback(const cv_tracker_msgs::image_obj&amp; image_object)
+static void DetectedObjectsCallback(const autoware_msgs::image_obj&amp; image_object)
 {
     sensor_header = image_object.header;
     setDetectedObjects(image_object);
@@ -62,7 +62,7 @@ static void DetectedObjectsCallback(const cv_tracker_msgs::image_obj&amp; image_obje
 	publishTopic();
 }*/
 
-static void PointsImageCallback(const points2image::PointsImage&amp; points_image)
+static void PointsImageCallback(const autoware_msgs::PointsImage&amp; points_image)
 {
     sensor_header = points_image.header;
     setPointsImage(points_image);
@@ -80,7 +80,7 @@ static void publishTopic()
 	/*
 	 * Publish topic(obj position ranged).
 	 */
-	cv_tracker_msgs::image_obj_ranged fused_objects_msg;
+	autoware_msgs::image_obj_ranged fused_objects_msg;
 	fused_objects_msg.header = sensor_header;
 
 	fused_objects_msg.type = getObjectsType();
@@ -88,7 +88,7 @@ static void publishTopic()
 	fused_objects.publish(fused_objects_msg);
 }
 
-static void config_cb(const runtime_manager::ConfigCarFusion::ConstPtr&amp; param)
+static void config_cb(const autoware_msgs::ConfigCarFusion::ConstPtr&amp; param)
 {
 	setParams(param-&gt;min_low_height,
 			param-&gt;max_low_height,
@@ -133,7 +133,7 @@ int main(int argc, char **argv)
 #if _DEBUG
 	ros::Subscriber image_sub = n.subscribe(IMAGE_TOPIC, 1, IMAGE_CALLBACK);
 #endif
-	fused_objects = n.advertise&lt;cv_tracker_msgs::image_obj_ranged&gt;("image_obj_ranged", 1);
+	fused_objects = n.advertise&lt;autoware_msgs::image_obj_ranged&gt;("image_obj_ranged", 1);
 
 	ros::Subscriber config_subscriber;
 	std::string config_topic("/config");
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\rcnn\rcnn_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\rcnn\rcnn_node.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -30,10 +30,10 @@
 #include &lt;string&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
-#include &lt;runtime_manager/ConfigRcnn.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;cv_tracker_msgs/image_obj.h&gt;
+#include &lt;autoware_msgs/image_obj.h&gt;
+#include &lt;autoware_msgs/ConfigRcnn.h&gt;
 
 #include &lt;rcnn_detector.h&gt;
 #include &lt;rect_class_score.h&gt;
@@ -73,7 +73,7 @@ class RosRcnnApp
 	//vector of indices of the classes to search for
 	std::vector&lt;unsigned int&gt; detect_classes_;
 
-	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, cv_tracker_msgs::image_obj&amp; out_message, cv::Mat&amp; in_image, std::string in_class)
+	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, autoware_msgs::image_obj&amp; out_message, cv::Mat&amp; in_image, std::string in_class)
 	{
 		for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
 		{
@@ -85,7 +85,7 @@ class RosRcnnApp
 				)//check if the score is larger than minimum required
 			{
 				//std::cout &lt;&lt; in_objects[i].toString() &lt;&lt; std::endl;
-				cv_tracker_msgs::image_rect rect;
+				autoware_msgs::image_rect rect;
 
 				rect.x = in_objects[i].x;
 				rect.y = in_objects[i].y;
@@ -124,8 +124,8 @@ class RosRcnnApp
 		//std::cout &lt;&lt; "Detection took: " &lt;&lt; timer.getTimeMilli() &lt;&lt; std::endl;
 
 		//Prepare Output message
-		cv_tracker_msgs::image_obj output_car_message;
-		cv_tracker_msgs::image_obj output_person_message;
+		autoware_msgs::image_obj output_car_message;
+		autoware_msgs::image_obj output_person_message;
 		output_car_message.header = image_source.header;
 		output_car_message.type = "car";
 
@@ -141,7 +141,7 @@ class RosRcnnApp
 		publisher_person_objects_.publish(output_person_message);
 	}
 
-	void config_cb(const runtime_manager::ConfigRcnn::ConstPtr&amp; param)
+	void config_cb(const autoware_msgs::ConfigRcnn::ConstPtr&amp; param)
 	{
 		rcnn_detector_-&gt;SetPixelMean(cv::Scalar(param-&gt;b_mean, param-&gt;g_mean, param-&gt;r_mean));
 
@@ -216,8 +216,8 @@ public:
 			return;
 		}
 
-		publisher_car_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj&gt;("/obj_car/image_obj", 1);
-		publisher_person_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj&gt;("/obj_person/image_obj", 1);
+		publisher_car_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;("/obj_car/image_obj", 1);
+		publisher_person_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;("/obj_person/image_obj", 1);
 
 		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
 		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosRcnnApp::image_callback, this);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\ssd_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\ssd_node.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -30,10 +30,10 @@
 #include &lt;string&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
-#include &lt;runtime_manager/ConfigSsd.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;cv_tracker_msgs/image_obj.h&gt;
+#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/ConfigSsd.h"
 
 #include &lt;rect_class_score.h&gt;
 
@@ -67,7 +67,7 @@ class RosSsdApp
 	//vector of indices of the classes to search for
 	std::vector&lt;unsigned int&gt; detect_classes_;
 
-	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, cv_tracker_msgs::image_obj&amp; out_message, cv::Mat&amp; in_image, std::string in_class)
+	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, autoware_msgs::image_obj&amp; out_message, cv::Mat&amp; in_image, std::string in_class)
 	{
 		for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
 		{
@@ -79,7 +79,7 @@ class RosSsdApp
 				)//check if the score is larger than minimum required
 			{
 				//std::cout &lt;&lt; in_objects[i].toString() &lt;&lt; std::endl;
-				cv_tracker_msgs::image_rect rect;
+				autoware_msgs::image_rect rect;
 
 				rect.x = in_objects[i].x;
 				rect.y = in_objects[i].y;
@@ -118,8 +118,8 @@ class RosSsdApp
 		//std::cout &lt;&lt; "Detection took: " &lt;&lt; timer.getTimeMilli() &lt;&lt; std::endl;
 
 		//Prepare Output message
-		cv_tracker_msgs::image_obj output_car_message;
-		cv_tracker_msgs::image_obj output_person_message;
+		autoware_msgs::image_obj output_car_message;
+		autoware_msgs::image_obj output_person_message;
 		output_car_message.header = image_source.header;
 		output_car_message.type = "car";
 
@@ -136,7 +136,7 @@ class RosSsdApp
 	}
 
 
-	void config_cb(const runtime_manager::ConfigSsd::ConstPtr&amp; param)
+	void config_cb(const autoware_msgs::ConfigSsd::ConstPtr&amp; param)
 	{
 		score_threshold_ 	= param-&gt;score_threshold;
 	}
@@ -207,8 +207,8 @@ public:
 		}
 		ROS_INFO("SSD Detector initialized.");
 
-		publisher_car_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj&gt;("/obj_car/image_obj", 1);
-		publisher_person_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj&gt;("/obj_person/image_obj", 1);
+		publisher_car_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;("/obj_car/image_obj", 1);
+		publisher_person_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;("/obj_person/image_obj", 1);
 
 		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
 		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosSsdApp::image_callback, this);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -1,10 +1,10 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;image_transport/image_transport.h&gt;
-#include &lt;runtime_manager/ConfigSsd.h&gt;
+#include &lt;autoware_msgs/ConfigSsd.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 
-#include &lt;cv_tracker_msgs/image_obj.h&gt;
+#include &lt;autoware_msgs/image_obj.h&gt;
 
 #include &lt;opencv2/opencv.hpp&gt;
 
@@ -58,7 +58,7 @@ class Yolo2DetectorNode
 	uint32_t image_top_bottom_border_;//black strips added to the input image to maintain aspect ratio while resizing it to fit the network input size
 	uint32_t image_left_right_border_;
 
-	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, cv_tracker_msgs::image_obj&amp; out_message, std::string in_class)
+	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, autoware_msgs::image_obj&amp; out_message, std::string in_class)
 	{
 		for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
 		{
@@ -81,7 +81,7 @@ class Yolo2DetectorNode
 					)
 				)//check if the score is larger than minimum required
 			{
-				cv_tracker_msgs::image_rect rect;
+				autoware_msgs::image_rect rect;
 
 				rect.x = (in_objects[i].x * darknet_image.w /image_ratio_) - image_left_right_border_/image_ratio_;
 				rect.y = (in_objects[i].y * darknet_image.h /image_ratio_) - image_top_bottom_border_/image_ratio_;
@@ -200,8 +200,8 @@ class Yolo2DetectorNode
 		//ROS_INFO("Detections: %ud", (unsigned int)detections.size());
 
 		//Prepare Output message
-		cv_tracker_msgs::image_obj output_car_message;
-		cv_tracker_msgs::image_obj output_person_message;
+		autoware_msgs::image_obj output_car_message;
+		autoware_msgs::image_obj output_person_message;
 		output_car_message.header = in_image_message-&gt;header;
 		output_car_message.type = "car";
 
@@ -217,7 +217,7 @@ class Yolo2DetectorNode
 		free(darknet_image.data);
 	}
 
-	void config_cb(const runtime_manager::ConfigSsd::ConstPtr&amp; param)
+	void config_cb(const autoware_msgs::ConfigSsd::ConstPtr&amp; param)
 	{
 		score_threshold_ 	= param-&gt;score_threshold;
 	}
@@ -274,8 +274,8 @@ public:
 		yolo_detector_.load(network_definition_file, pretrained_model_file, score_threshold_, nms_threshold_);
 		ROS_INFO("Initialization complete.");
 
-		publisher_car_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj&gt;("/obj_car/image_obj", 1);
-		publisher_person_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj&gt;("/obj_person/image_obj", 1);
+		publisher_car_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;("/obj_car/image_obj", 1);
+		publisher_person_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;("/obj_person/image_obj", 1);
 
 		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
 		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;Yolo2DetectorNode::image_callback, this);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_lane.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_lane.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -15,7 +15,7 @@ namespace integrated_viewer
   DrawLane::DrawLane(void) {
   }  // DrawLane::DrawLane()
 
-  void DrawLane::Draw(const lane_detector::ImageLaneObjects::ConstPtr&amp; lane,
+  void DrawLane::Draw(const autoware_msgs::ImageLaneObjects::ConstPtr&amp; lane,
                       cv::Mat &amp;image) {
     if (lane == NULL) {
       return;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_lane.h" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_lane.h" added_lines="2" deleted_lines="2">
				<diff>@@ -1,14 +1,14 @@
 #ifndef DRAW_LANE_H
 #define DRAW_LANE_H
 #include &lt;opencv/cv.h&gt;
-#include &lt;lane_detector/ImageLaneObjects.h&gt;
+#include "autoware_msgs/ImageLaneObjects.h"
 
 namespace integrated_viewer {
   // helper class to draw detected lane line
   class DrawLane{
   public:
     explicit DrawLane(void);
-    void Draw(const lane_detector::ImageLaneObjects::ConstPtr&amp; lane, cv::Mat &amp;image);
+    void Draw(const autoware_msgs::ImageLaneObjects::ConstPtr&amp; lane, cv::Mat &amp;image);
 
   protected:
     static const int kLineThickness;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_points.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_points.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -15,7 +15,7 @@ namespace integrated_viewer
   } //   DrawPoints::DrawPoints()
 
 
-  void DrawPoints::Draw(const points2image::PointsImage::ConstPtr&amp; points,
+  void DrawPoints::Draw(const autoware_msgs::PointsImage::ConstPtr&amp; points,
                         cv::Mat &amp;image) {
     if (points == NULL) {
       return;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_points.h" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_points.h" added_lines="2" deleted_lines="2">
				<diff>@@ -2,14 +2,14 @@
 #define DRAW_POINTS_H
 
 #include &lt;opencv/cv.h&gt;
-#include &lt;points2image/PointsImage.h&gt;
+#include "autoware_msgs/PointsImage.h"
 
 namespace integrated_viewer {
   // helper class to draw points image
   class DrawPoints{
   public:
     explicit DrawPoints(void);
-    void Draw(const points2image::PointsImage::ConstPtr&amp; points, cv::Mat&amp; image);
+    void Draw(const autoware_msgs::PointsImage::ConstPtr&amp; points, cv::Mat&amp; image);
 
   private:
     cv::Mat color_map_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -28,7 +28,7 @@ namespace integrated_viewer
   } // DrawRects::DrawRects()
 
 
-  void DrawRects::DrawImageObj(const cv_tracker_msgs::image_obj::ConstPtr&amp; rect_data,
+  void DrawRects::DrawImageObj(const autoware_msgs::image_obj::ConstPtr&amp; rect_data,
                                cv::Mat &amp;image) {
     if (rect_data == NULL) {
       return;
@@ -62,7 +62,7 @@ namespace integrated_viewer
   } // DrawRects::DrawImageObj()
 
 
-  void DrawRects::DrawImageObjRanged(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; rect_data,
+  void DrawRects::DrawImageObjRanged(const autoware_msgs::image_obj_ranged::ConstPtr&amp; rect_data,
                                      cv::Mat &amp;image) {
     if (rect_data == NULL) {
       return;
@@ -96,7 +96,7 @@ namespace integrated_viewer
   } // DrawRects::DrawImageObjRanged()
 
 
-  void DrawRects::DrawImageObjTracked(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; rect_data,
+  void DrawRects::DrawImageObjTracked(const autoware_msgs::image_obj_tracked::ConstPtr&amp; rect_data,
                                       cv::Mat &amp;image) {
     if (rect_data == NULL) {
       return;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.h" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.h" added_lines="6" deleted_lines="6">
				<diff>@@ -2,18 +2,18 @@
 #define DRAW_RECTS_H
 
 #include &lt;opencv/cv.h&gt;
-#include &lt;cv_tracker_msgs/image_obj.h&gt;
-#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
-#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
+#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/image_obj_ranged.h"
+#include "autoware_msgs/image_obj_tracked.h"
 
 namespace integrated_viewer {
   // helper class to draw detection result rectangle
   class DrawRects{
   public:
     explicit DrawRects(void);
-    void DrawImageObj(const cv_tracker_msgs::image_obj::ConstPtr&amp; rect_data, cv::Mat&amp; image);
-    void DrawImageObjRanged(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; rect_data, cv::Mat&amp; image);
-    void DrawImageObjTracked(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; rect_data, cv::Mat&amp; image);
+    void DrawImageObj(const autoware_msgs::image_obj::ConstPtr&amp; rect_data, cv::Mat&amp; image);
+    void DrawImageObjRanged(const autoware_msgs::image_obj_ranged::ConstPtr&amp; rect_data, cv::Mat&amp; image);
+    void DrawImageObjTracked(const autoware_msgs::image_obj_tracked::ConstPtr&amp; rect_data, cv::Mat&amp; image);
 
   protected:
     static const int kRectangleThickness;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" added_lines="15" deleted_lines="15">
				<diff>@@ -19,12 +19,12 @@
 namespace integrated_viewer
 {
   const QString     ImageViewerPlugin::kImageDataType               = "sensor_msgs/Image";
-  const QString     ImageViewerPlugin::kRectDataTypeBase            = "cv_tracker_msgs/image_obj";
-  const QString     ImageViewerPlugin::kPointDataType               = "points2image/PointsImage";
-  const QString     ImageViewerPlugin::kLaneDataType                = "lane_detector/ImageLaneObjects";
+  const QString     ImageViewerPlugin::kRectDataTypeBase            = "autoware_msgs/image_obj";
+  const QString     ImageViewerPlugin::kPointDataType               = "autoware_msgs/PointsImage";
+  const QString     ImageViewerPlugin::kLaneDataType                = "autoware_msgs/ImageLaneObjects";
   const QString     ImageViewerPlugin::kBlankTopic                  = "-----";
-  const std::string ImageViewerPlugin::kRectDataTypeImageObjRanged  = "cv_tracker_msgs/image_obj_ranged";
-  const std::string ImageViewerPlugin::kRectDataTypeImageObjTracked = "cv_tracker_msgs/image_obj_tracked";
+  const std::string ImageViewerPlugin::kRectDataTypeImageObjRanged  = "autoware_msgs/image_obj_ranged";
+  const std::string ImageViewerPlugin::kRectDataTypeImageObjTracked = "autoware_msgs/image_obj_tracked";
 
   ImageViewerPlugin::ImageViewerPlugin(QWidget* parent)
     : rviz::Panel(parent) {
@@ -228,7 +228,7 @@ namespace integrated_viewer
       image_obj_ranged_msg_  = NULL;
       image_obj_tracked_msg_ = NULL;
       // this topic type is image_obj_ranged
-      rect_sub_ = node_handle_.subscribe&lt;cv_tracker_msgs::image_obj_ranged&gt;(selected_topic,
+      rect_sub_ = node_handle_.subscribe&lt;autoware_msgs::image_obj_ranged&gt;(selected_topic,
                                                                        1,
                                                                        &amp;ImageViewerPlugin::ImageObjRangedCallback,
                                                                        this);
@@ -238,7 +238,7 @@ namespace integrated_viewer
       image_obj_ranged_msg_  = NULL;
       image_obj_tracked_msg_ = NULL;
       // this topic type is image_obj_tracked
-      rect_sub_ = node_handle_.subscribe&lt;cv_tracker_msgs::image_obj_tracked&gt;(selected_topic,
+      rect_sub_ = node_handle_.subscribe&lt;autoware_msgs::image_obj_tracked&gt;(selected_topic,
                                                                        1,
                                                                        &amp;ImageViewerPlugin::ImageObjTrackedCallback,
                                                                        this);
@@ -247,7 +247,7 @@ namespace integrated_viewer
       image_obj_ranged_msg_  = NULL;
       image_obj_tracked_msg_ = NULL;
       // this topic type is image_obj
-      rect_sub_ = node_handle_.subscribe&lt;cv_tracker_msgs::image_obj&gt;(selected_topic,
+      rect_sub_ = node_handle_.subscribe&lt;autoware_msgs::image_obj&gt;(selected_topic,
                                                                 1,
                                                                 &amp;ImageViewerPlugin::ImageObjCallback,
                                                                 this);
@@ -257,15 +257,15 @@ namespace integrated_viewer
   } // ImageViewerPlugin::on_rect_topic_combo_box__activated()
   
 
-  void ImageViewerPlugin::ImageObjCallback(const cv_tracker_msgs::image_obj::ConstPtr&amp; msg) {
+  void ImageViewerPlugin::ImageObjCallback(const autoware_msgs::image_obj::ConstPtr&amp; msg) {
     image_obj_msg_ = msg;
   } // ImageViewerPlugin::ImageObjCallback()
 
-  void ImageViewerPlugin::ImageObjRangedCallback(const cv_tracker_msgs::image_obj_ranged::ConstPtr &amp;msg) {
+  void ImageViewerPlugin::ImageObjRangedCallback(const autoware_msgs::image_obj_ranged::ConstPtr &amp;msg) {
     image_obj_ranged_msg_ = msg;
   } // ImageViewerPlugin::ImageObjRangedCallback()
 
-  void ImageViewerPlugin::ImageObjTrackedCallback(const cv_tracker_msgs::image_obj_tracked::ConstPtr &amp;msg) {
+  void ImageViewerPlugin::ImageObjTrackedCallback(const autoware_msgs::image_obj_tracked::ConstPtr &amp;msg) {
     image_obj_tracked_msg_ = msg;
   } // ImageViewerPlugin::ImageObjTrackedCallback()
 
@@ -281,7 +281,7 @@ namespace integrated_viewer
     }
 
     // if selected topic is not blank or empty , start callback function
-    point_sub_ = node_handle_.subscribe&lt;points2image::PointsImage&gt;(selected_topic,
+    point_sub_ = node_handle_.subscribe&lt;autoware_msgs::PointsImage&gt;(selected_topic,
                                                                    1,
                                                                    &amp;ImageViewerPlugin::PointCallback,
                                                                    this);
@@ -289,7 +289,7 @@ namespace integrated_viewer
   } // ImageViewerPlugin::on_point_topic_combo_box__activated()
 
 
-  void ImageViewerPlugin::PointCallback(const points2image::PointsImage::ConstPtr &amp;msg) {
+  void ImageViewerPlugin::PointCallback(const autoware_msgs::PointsImage::ConstPtr &amp;msg) {
     points_msg_ = msg;
   } // ImageViewerPlugin::PointCallback()
 
@@ -305,14 +305,14 @@ namespace integrated_viewer
     }
 
     // if selected topic is not blank or emtpy, start callback function
-    lane_sub_ = node_handle_.subscribe&lt;lane_detector::ImageLaneObjects&gt;(selected_topic,
+    lane_sub_ = node_handle_.subscribe&lt;autoware_msgs::ImageLaneObjects&gt;(selected_topic,
                                                                         1,
                                                                         &amp;ImageViewerPlugin::LaneCallback,
                                                                         this);
   }  // void ImageViewerPlugin::on_lane_topic_combo_box__activated()
 
 
-  void ImageViewerPlugin::LaneCallback(const lane_detector::ImageLaneObjects::ConstPtr&amp; msg)  {
+  void ImageViewerPlugin::LaneCallback(const autoware_msgs::ImageLaneObjects::ConstPtr&amp; msg)  {
     lane_msg_ = msg;
   }
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" added_lines="14" deleted_lines="14">
				<diff>@@ -6,10 +6,10 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;rviz/panel.h&gt;
-#include &lt;cv_tracker_msgs/image_obj.h&gt;
-#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
-#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
-#include &lt;points2image/PointsImage.h&gt;
+#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/image_obj_ranged.h"
+#include "autoware_msgs/image_obj_tracked.h"
+#include "autoware_msgs/PointsImage.h"
 
 #include &lt;string&gt;
 #include &lt;map&gt;
@@ -48,11 +48,11 @@ namespace integrated_viewer
     
     // The Callback functions
     void ImageCallback(const sensor_msgs::Image::ConstPtr&amp; msg);
-    void ImageObjCallback(const cv_tracker_msgs::image_obj::ConstPtr&amp; msg);
-    void ImageObjRangedCallback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; msg);
-    void ImageObjTrackedCallback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; msg);
-    void PointCallback(const points2image::PointsImage::ConstPtr &amp;msg);
-    void LaneCallback(const lane_detector::ImageLaneObjects::ConstPtr&amp; msg);
+    void ImageObjCallback(const autoware_msgs::image_obj::ConstPtr&amp; msg);
+    void ImageObjRangedCallback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; msg);
+    void ImageObjTrackedCallback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; msg);
+    void PointCallback(const autoware_msgs::PointsImage::ConstPtr &amp;msg);
+    void LaneCallback(const autoware_msgs::ImageLaneObjects::ConstPtr&amp; msg);
 
    // The function to refrect modified image on UI
    void ShowImageOnUi(void);
@@ -88,11 +88,11 @@ namespace integrated_viewer
     cv::Mat default_image_;
 
     // Data pointer to hold subscribed data
-    points2image::PointsImage::ConstPtr points_msg_;
-    cv_tracker_msgs::image_obj::ConstPtr image_obj_msg_;
-    cv_tracker_msgs::image_obj_ranged::ConstPtr image_obj_ranged_msg_;
-    cv_tracker_msgs::image_obj_tracked::ConstPtr image_obj_tracked_msg_;
-    lane_detector::ImageLaneObjects::ConstPtr lane_msg_;
+    autoware_msgs::PointsImage::ConstPtr points_msg_;
+    autoware_msgs::image_obj::ConstPtr image_obj_msg_;
+    autoware_msgs::image_obj_ranged::ConstPtr image_obj_ranged_msg_;
+    autoware_msgs::image_obj_tracked::ConstPtr image_obj_tracked_msg_;
+    autoware_msgs::ImageLaneObjects::ConstPtr lane_msg_;
 
     // data structure to hold topic information for detection result
     std::map&lt;std::string, std::string&gt; rect_topic_info_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 #include &lt;ros/ros.h&gt;
-#include &lt;runtime_manager/traffic_light.h&gt;
+#include "autoware_msgs/traffic_light.h"
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 #include &lt;opencv2/imgproc/imgproc.hpp&gt;
@@ -30,7 +30,7 @@ namespace integrated_viewer
   } // TrafficLightPlugin::TrafficLightPlugin()
 
 
-  void TrafficLightPlugin::SignalStateCallback(const runtime_manager::traffic_light::ConstPtr&amp; msg) {
+  void TrafficLightPlugin::SignalStateCallback(const autoware_msgs::traffic_light::ConstPtr&amp; msg) {
     StateInfo info = {};
     GetStateInfo(static_cast&lt;StateNumber&gt;(msg-&gt;traffic_light), info);
     SetStateInfo(info);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.h" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.h" added_lines="2" deleted_lines="2">
				<diff>@@ -6,7 +6,7 @@
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
 #include &lt;rviz/panel.h&gt;
-#include &lt;runtime_manager/traffic_light.h&gt;
+#include "autoware_msgs/traffic_light.h"
 
 #include "convert_image.h"
 #include "ui_form.h"
@@ -36,7 +36,7 @@ namespace integrated_viewer
     };
 
     // The Callback function for signal state
-    void SignalStateCallback(const runtime_manager::traffic_light::ConstPtr&amp; msg);
+    void SignalStateCallback(const autoware_msgs::traffic_light::ConstPtr&amp; msg);
 
     // The function to convert recognition result to color and string information
     void GetStateInfo(const StateNumber num, StateInfo&amp; info);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lane_detector\nodes\lane_detector\lane_detector.cpp" new_path="ros\src\computing\perception\detection\packages\lane_detector\nodes\lane_detector\lane_detector.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -47,10 +47,10 @@
 /*#include "switch_release.h"*/
 
 #if !defined(USE_POSIX_SHARED_MEMORY)
-#include "ros/ros.h"
+#include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;lane_detector/ImageLaneObjects.h&gt;
+#include "autoware_msgs/ImageLaneObjects.h"
 #endif
 
 #if defined(USE_POSIX_SHARED_MEMORY)
@@ -452,7 +452,7 @@ static void processLanes(CvSeq *lines, IplImage* edges, IplImage *temp_frame, Ip
   cvLine(org_frame, cvPoint(x, laneR.k.get()*x + laneR.b.get() + org_offset),
          cvPoint(x2, laneR.k.get()*x2 + laneR.b.get() + org_offset), PURPLE, 2);
 #else
-  lane_detector::ImageLaneObjects lane_msg;
+  autoware_msgs::ImageLaneObjects lane_msg;
   lane_msg.lane_r_x1 = x;
   lane_msg.lane_r_y1 = laneR.k.get()*x + laneR.b.get() + org_offset;
   lane_msg.lane_r_x2 = x2;
@@ -585,7 +585,7 @@ int main(int argc, char *argv[])
 
   ros::Subscriber subscriber = n.subscribe(image_topic_name, 1, lane_cannyhough_callback);
 
-  image_lane_objects = n.advertise&lt;lane_detector::ImageLaneObjects&gt;("lane_pos_xy", 1);
+  image_lane_objects = n.advertise&lt;autoware_msgs::ImageLaneObjects&gt;("lane_pos_xy", 1);
 
   ros::spin();
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\Cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\Cluster.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -62,7 +62,7 @@ Eigen::Vector3f Cluster::GetEigenValues()
 	return eigen_values_;
 }
 
-void Cluster::ToRosMessage(std_msgs::Header in_ros_header, lidar_tracker::CloudCluster&amp; out_cluster_message)
+void Cluster::ToRosMessage(std_msgs::Header in_ros_header, autoware_msgs::CloudCluster&amp; out_cluster_message)
 {
 	sensor_msgs::PointCloud2 cloud_msg;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -41,9 +41,9 @@
 #include &lt;std_msgs/MultiArrayLayout.h&gt;
 #include &lt;std_msgs/MultiArrayDimension.h&gt;
 
-#include &lt;lidar_tracker/centroids.h&gt;
-#include &lt;lidar_tracker/CloudCluster.h&gt;
-#include &lt;lidar_tracker/CloudClusterArray.h&gt;
+#include "autoware_msgs/centroids.h"
+#include "autoware_msgs/CloudCluster.h"
+#include "autoware_msgs/CloudClusterArray.h"
 
 #include &lt;vector_map_server/PositionState.h&gt;
 
@@ -156,16 +156,16 @@ void transformBoundingBox(const jsk_recognition_msgs::BoundingBox&amp; in_boundingbo
 	out_boundingbox.label = in_boundingbox.label;
 }
 
-void publishCloudClusters(const ros::Publisher* in_publisher, const lidar_tracker::CloudClusterArray&amp; in_clusters, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
+void publishCloudClusters(const ros::Publisher* in_publisher, const autoware_msgs::CloudClusterArray&amp; in_clusters, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
 {
 	if (in_target_frame!=in_header.frame_id)
 	{
-		lidar_tracker::CloudClusterArray clusters_transformed;
+		autoware_msgs::CloudClusterArray clusters_transformed;
 		clusters_transformed.header = in_header;
 		clusters_transformed.header.frame_id = in_target_frame;
 		for (auto i=in_clusters.clusters.begin(); i!= in_clusters.clusters.end(); i++)
 		{
-			lidar_tracker::CloudCluster cluster_transformed;
+			autoware_msgs::CloudCluster cluster_transformed;
 			cluster_transformed.header = in_header;
 			try
 			{
@@ -198,11 +198,11 @@ void publishCloudClusters(const ros::Publisher* in_publisher, const lidar_tracke
 	}
 }
 
-void publishCentroids(const ros::Publisher* in_publisher, const lidar_tracker::centroids&amp; in_centroids, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
+void publishCentroids(const ros::Publisher* in_publisher, const autoware_msgs::centroids&amp; in_centroids, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
 {
 	if (in_target_frame!=in_header.frame_id)
 	{
-		lidar_tracker::centroids centroids_transformed;
+		autoware_msgs::centroids centroids_transformed;
 		centroids_transformed.header = in_header;
 		centroids_transformed.header.frame_id = in_target_frame;
 		for (auto i=centroids_transformed.points.begin(); i!= centroids_transformed.points.end(); i++)
@@ -355,7 +355,7 @@ std::vector&lt;ClusterPtr&gt; clusterAndColorGpu(const pcl::PointCloud&lt;pcl::PointXYZ&gt;:
 std::vector&lt;ClusterPtr&gt; clusterAndColor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 		pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
 		jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
-		lidar_tracker::centroids&amp; in_out_centroids,
+		autoware_msgs::centroids&amp; in_out_centroids,
 		double in_max_cluster_distance=0.5)
 {
 	pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree (new pcl::search::KdTree&lt;pcl::PointXYZ&gt;);
@@ -492,8 +492,8 @@ void checkAllForMerge(std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;ClusterP
 void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 		pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
 		jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
-		lidar_tracker::centroids&amp; in_out_centroids,
-		lidar_tracker::CloudClusterArray&amp; in_out_clusters,
+		autoware_msgs::centroids&amp; in_out_centroids,
+		autoware_msgs::CloudClusterArray&amp; in_out_clusters,
 		jsk_recognition_msgs::PolygonArray&amp; in_out_polygon_array,
 		jsk_rviz_plugins::PictogramArray&amp; in_out_pictogram_array)
 {
@@ -658,7 +658,7 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 			in_out_polygon_array.polygons.push_back(polygon);
 			in_out_pictogram_array.pictograms.push_back(pictogram_cluster);
 
-			lidar_tracker::CloudCluster cloud_cluster;
+			autoware_msgs::CloudCluster cloud_cluster;
 			final_clusters[i]-&gt;ToRosMessage(_velodyne_header, cloud_cluster);
 			in_out_clusters.clusters.push_back(cloud_cluster);
 		}
@@ -840,8 +840,8 @@ void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
 		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr clipped_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
 		pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr colored_clustered_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
 
-		lidar_tracker::centroids centroids;
-		lidar_tracker::CloudClusterArray cloud_clusters;
+		autoware_msgs::centroids centroids;
+		autoware_msgs::CloudClusterArray cloud_clusters;
 		jsk_recognition_msgs::BoundingBoxArray boundingbox_array;
 		jsk_recognition_msgs::PolygonArray polygon_array;
 		jsk_rviz_plugins::PictogramArray pictograms_array;
@@ -1031,13 +1031,13 @@ int main (int argc, char** argv)
 
 	_pub_cluster_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_cluster",1);
 	_pub_ground_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_ground",1);
-	_centroid_pub = h.advertise&lt;lidar_tracker::centroids&gt;("/cluster_centroids",1);
+	_centroid_pub = h.advertise&lt;autoware_msgs::centroids&gt;("/cluster_centroids",1);
 	_marker_pub = h.advertise&lt;visualization_msgs::Marker&gt;("centroid_marker",1);
 
 	_pub_points_lanes_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_lanes",1);
 	_pub_jsk_boundingboxes = h.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/bounding_boxes",1);
 	_pub_jsk_hulls = h.advertise&lt;jsk_recognition_msgs::PolygonArray&gt;("/cluster_hulls",1);
-	_pub_clusters_message = h.advertise&lt;lidar_tracker::CloudClusterArray&gt;("/cloud_clusters",1);
+	_pub_clusters_message = h.advertise&lt;autoware_msgs::CloudClusterArray&gt;("/cloud_clusters",1);
 	_pub_text_pictogram = h.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;("cluster_ids", 10); ROS_INFO("output pictograms topic: %s", "cluster_id");
 
 	std::string points_topic;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\includes\Cluster.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\includes\Cluster.h" added_lines="3" deleted_lines="3">
				<diff>@@ -45,7 +45,7 @@
 #include &lt;jsk_recognition_msgs/PolygonArray.h&gt;
 #include &lt;jsk_rviz_plugins/PictogramArray.h&gt;
 
-#include &lt;lidar_tracker/CloudCluster.h&gt;
+#include "autoware_msgs/CloudCluster.h"
 
 #include "opencv2/core/core.hpp"
 #include "opencv2/imgproc/imgproc.hpp"
@@ -86,8 +86,8 @@ public:
 	 * */
 	void SetCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_origin_cloud_ptr, const std::vector&lt;int&gt;&amp; in_cluster_indices, std_msgs::Header in_ros_header, int in_id, int in_r, int in_g, int in_b, std::string in_label, bool in_estimate_pose);
 
-	/* \brief Returns the lidar_tracker::CloudCluster message associated to this Cluster */
-	void ToRosMessage(std_msgs::Header in_ros_header, lidar_tracker::CloudCluster&amp; out_cluster_message);
+	/* \brief Returns the autoware_msgs::CloudCluster message associated to this Cluster */
+	void ToRosMessage(std_msgs::Header in_ros_header, autoware_msgs::CloudCluster&amp; out_cluster_message);
 
 	Cluster();
 	virtual ~Cluster();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_lidar_track\euclidean_lidar_track.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_lidar_track\euclidean_lidar_track.cpp" added_lines="11" deleted_lines="11">
				<diff>@@ -2,10 +2,10 @@
 #include &lt;geometry_msgs/Point.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-#include &lt;lidar_tracker/CloudCluster.h&gt;
-#include &lt;lidar_tracker/CloudClusterArray.h&gt;
-#include &lt;lidar_tracker/DetectedObject.h&gt;
-#include &lt;lidar_tracker/DetectedObjectArray.h&gt;
+#include "autoware_msgs/CloudCluster.h"
+#include "autoware_msgs/CloudClusterArray.h"
+#include "autoware_msgs/DetectedObject.h"
+#include "autoware_msgs/DetectedObjectArray.h"
 #include &lt;math.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
@@ -15,7 +15,7 @@ ros::Publisher tracked_pub;
 ros::Publisher tracked_bba_pub;
 ros::Publisher tracked_bba_textlabel_pub;
 
-static std::vector&lt;lidar_tracker::CloudCluster&gt; v_pre_cloud_cluster;
+static std::vector&lt;autoware_msgs::CloudCluster&gt; v_pre_cloud_cluster;
 static double threshold_dist;
 
 static double euclid_distance(const geometry_msgs::Point pos1,
@@ -31,9 +31,9 @@ void pos_stamped2pos(geometry_msgs::PointStamped in_pos,
 }
 
 void cluster_cb(
-    const lidar_tracker::CloudClusterArray::Ptr &amp;cloud_cluster_array_ptr) {
+    const autoware_msgs::CloudClusterArray::Ptr &amp;cloud_cluster_array_ptr) {
 
-  lidar_tracker::CloudClusterArray base_msg = *cloud_cluster_array_ptr;
+  autoware_msgs::CloudClusterArray base_msg = *cloud_cluster_array_ptr;
   static int id = 1;
 
   for (int i(0); i &lt; (int)base_msg.clusters.size(); ++i) {
@@ -62,14 +62,14 @@ void cluster_cb(
 
   v_pre_cloud_cluster.clear();
   for (int i(0); i &lt; (int)base_msg.clusters.size(); ++i) {
-    lidar_tracker::CloudCluster cloud_cluster = base_msg.clusters.at(i);
+    autoware_msgs::CloudCluster cloud_cluster = base_msg.clusters.at(i);
     v_pre_cloud_cluster.push_back(cloud_cluster);
   }
 
-  lidar_tracker::DetectedObjectArray detected_objects_msg;
+  autoware_msgs::DetectedObjectArray detected_objects_msg;
   detected_objects_msg.header = base_msg.header;
   for (auto i = base_msg.clusters.begin(); i != base_msg.clusters.end(); i++) {
-    lidar_tracker::DetectedObject detected_object;
+    autoware_msgs::DetectedObject detected_object;
     detected_object.header = i-&gt;header;
     detected_object.id = i-&gt;id;
     detected_object.label = i-&gt;label;
@@ -132,7 +132,7 @@ int main(int argc, char *argv[]) {
   ros::Subscriber cluster_centroids_sub =
       n.subscribe("/cloud_clusters_class", 1, cluster_cb);
   tracked_pub =
-      n.advertise&lt;lidar_tracker::DetectedObjectArray&gt;("/detected_objects", 1);
+      n.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detected_objects", 1);
   tracked_bba_pub = n.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(
       "/cloud_cluster_tracked_bounding_box", 1);
   tracked_bba_textlabel_pub = n.advertise&lt;visualization_msgs::MarkerArray&gt;(
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\KfLidarTracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\KfLidarTracker.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -29,7 +29,7 @@ void KfLidarTracker::CreatePolygonFromPoints(const geometry_msgs::Polygon&amp; in_po
 	boost::geometry::assign_points(out_polygon, hull_detection_points);
 }
 
-void KfLidarTracker::Update(const lidar_tracker::CloudClusterArray&amp; in_cloud_cluster_array, DistType in_match_method)
+void KfLidarTracker::Update(const autoware_msgs::CloudClusterArray&amp; in_cloud_cluster_array, DistType in_match_method)
 {
 	size_t num_detections = in_cloud_cluster_array.clusters.size();
 	size_t num_tracks = tracks.size();
@@ -103,7 +103,7 @@ void KfLidarTracker::Update(const lidar_tracker::CloudClusterArray&amp; in_cloud_clu
 				tracks[i].skipped_frames = 0;
 
 				//join all assigned detections to update the tracker
-				/*lidar_tracker::CloudClusterPtr summed_cloud_cluster(new lidar_tracker::CloudCluster());
+				/*autoware_msgs::CloudClusterPtr summed_cloud_cluster(new autoware_msgs::CloudCluster());
 				pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr summed_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
 				for (size_t j = 0; j &lt; track_assignments_vector[i].size(); j++)
 				{
@@ -128,7 +128,7 @@ void KfLidarTracker::Update(const lidar_tracker::CloudClusterArray&amp; in_cloud_clu
 			}
 			else				     // if not matched continue using predictions, and increase life
 			{
-				tracks[i].Update(lidar_tracker::CloudCluster(), //empty cluster
+				tracks[i].Update(autoware_msgs::CloudCluster(), //empty cluster
 									false, //not matched,
 									maximum_trace_length_
 								);
@@ -257,7 +257,7 @@ void KfLidarTracker::CheckAllTrackersForMerge(std::vector&lt;CTrack&gt;&amp; out_trackers)
 //
 // ---------------------------------------------------------------------------
 /*void KfLidarTracker::Update(
-	const lidar_tracker::CloudClusterArray&amp; in_cloud_cluster_array,
+	const autoware_msgs::CloudClusterArray&amp; in_cloud_cluster_array,
 	DistType distType
 	)
 {
@@ -393,7 +393,7 @@ void KfLidarTracker::CheckAllTrackersForMerge(std::vector&lt;CTrack&gt;&amp; out_trackers)
 		else				     // if not continue using predictions
 		{
 			std::cout &lt;&lt; "Not Matched. Kalman Update on " &lt;&lt; i &lt;&lt; std::endl;
-			tracks[i].Update(lidar_tracker::CloudCluster(), false, maximum_trace_length_);
+			tracks[i].Update(autoware_msgs::CloudCluster(), false, maximum_trace_length_);
 		}
 	}
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\includes\KfLidarTracker.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\includes\KfLidarTracker.h" added_lines="7" deleted_lines="7">
				<diff>@@ -9,8 +9,8 @@
 #include &lt;jsk_recognition_msgs/PolygonArray.h&gt;
 #include &lt;geometry_msgs/Polygon.h&gt;
 #include &lt;geometry_msgs/PolygonStamped.h&gt;
-#include &lt;lidar_tracker/CloudCluster.h&gt;
-#include &lt;lidar_tracker/CloudClusterArray.h&gt;
+#include "autoware_msgs/CloudCluster.h"
+#include "autoware_msgs/CloudClusterArray.h"
 #include &lt;tf/tf.h&gt;
 
 #include &lt;boost/assert.hpp&gt;
@@ -32,7 +32,7 @@ class CTrack
 	cv::Point2f prediction_point_;
 	TKalmanFilter kf_;
 public:
-	lidar_tracker::CloudCluster cluster;
+	autoware_msgs::CloudCluster cluster;
 
 	std::vector&lt;cv::Point2f&gt; trace;
 	size_t track_id;
@@ -40,7 +40,7 @@ public:
 	size_t life_span;
 	double area;
 
-	CTrack(const lidar_tracker::CloudCluster&amp; in_cluster, float in_time_delta, float in_acceleration_noise_magnitude, size_t in_track_id)
+	CTrack(const autoware_msgs::CloudCluster&amp; in_cluster, float in_time_delta, float in_acceleration_noise_magnitude, size_t in_track_id)
 		: kf_(cv::Point2f(in_cluster.centroid_point.point.x, in_cluster.centroid_point.point.y), in_time_delta, in_acceleration_noise_magnitude)
 	{
 		track_id = in_track_id;
@@ -62,7 +62,7 @@ public:
 		return 0.0f;
 	}
 
-	void Update(const lidar_tracker::CloudCluster&amp; in_cluster, bool in_data_correct, size_t in_max_trace_length)
+	void Update(const autoware_msgs::CloudCluster&amp; in_cluster, bool in_data_correct, size_t in_max_trace_length)
 	{
 		kf_.GetPrediction();
 		prediction_point_ = kf_.Update(cv::Point2f(in_cluster.centroid_point.point.x, in_cluster.centroid_point.point.y), in_data_correct);
@@ -81,7 +81,7 @@ public:
 		trace.push_back(prediction_point_);
 	}
 
-	lidar_tracker::CloudCluster GetCluster()
+	autoware_msgs::CloudCluster GetCluster()
 	{
 		return cluster;
 	}
@@ -119,7 +119,7 @@ public:
 	};
 
 	std::vector&lt; CTrack &gt; tracks;
-	void Update(const lidar_tracker::CloudClusterArray&amp; in_cloud_cluster_array, DistType in_disttype);
+	void Update(const autoware_msgs::CloudClusterArray&amp; in_cloud_cluster_array, DistType in_disttype);
 
 
 };
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\kf_lidar_track.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\kf_lidar_track.cpp" added_lines="11" deleted_lines="11">
				<diff>@@ -13,10 +13,10 @@
 #include &lt;sensor_msgs/PointCloud.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 
-#include &lt;lidar_tracker/CloudCluster.h&gt;
-#include &lt;lidar_tracker/CloudClusterArray.h&gt;
-#include &lt;lidar_tracker/DetectedObject.h&gt;
-#include &lt;lidar_tracker/DetectedObjectArray.h&gt;
+#include "autoware_msgs/CloudCluster.h"
+#include "autoware_msgs/CloudClusterArray.h"
+#include "autoware_msgs/DetectedObject.h"
+#include "autoware_msgs/DetectedObjectArray.h"
 
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
@@ -52,7 +52,7 @@ private:
 	double distance_matching_threshold_;
 	double tracker_merging_threshold_;
 
-	void CloudClustersCallback(const lidar_tracker::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr);
+	void CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr);
 };
 
 KfLidarTrackNode::KfLidarTrackNode() :
@@ -60,7 +60,7 @@ KfLidarTrackNode::KfLidarTrackNode() :
 		pose_estimation_(false)
 {
 	cloud_clusters_sub_ = node_handle_.subscribe("/cloud_clusters_class", 10, &amp;KfLidarTrackNode::CloudClustersCallback, this);
-	pub_detected_objects_ = node_handle_.advertise&lt;lidar_tracker::DetectedObjectArray&gt;( "/detected_objects", 10);
+	pub_detected_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;( "/detected_objects", 10);
 	pub_jsk_tracked_objects_ = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/bounding_boxes_tracked",1);
 	pub_jsk_hulls_ = node_handle_.advertise&lt;jsk_recognition_msgs::PolygonArray&gt;("/cluster_hulls_tracked",1);
 	pub_jsk_pictograms_ = node_handle_.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;("/cluster_ids_tracked",1);
@@ -84,11 +84,11 @@ KfLidarTrackNode::~KfLidarTrackNode()
 {
 }
 
-void KfLidarTrackNode::CloudClustersCallback(const lidar_tracker::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr)
+void KfLidarTrackNode::CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr)
 {
 
-	lidar_tracker::CloudClusterArray final_cloud_cluster_array;
-	lidar_tracker::DetectedObjectArray detected_objects;
+	autoware_msgs::CloudClusterArray final_cloud_cluster_array;
+	autoware_msgs::DetectedObjectArray detected_objects;
 	detected_objects.header = in_cloud_cluster_array_ptr-&gt;header;
 
 
@@ -148,11 +148,11 @@ void KfLidarTrackNode::CloudClustersCallback(const lidar_tracker::CloudClusterAr
 	pub_jsk_hulls_.publish(tracked_hulls);
 	pub_jsk_pictograms_.publish(tracked_ids);
 
-	//lidar_tracker::DetectedObjectArray detected_objects;
+	//autoware_msgs::DetectedObjectArray detected_objects;
 	//detected_objects.header = in_cloud_cluster_array_ptr-&gt;header;
 	//for (auto i = in_cloud_cluster_array_ptr-&gt;clusters.begin(); i != in_cloud_cluster_array_ptr-&gt;clusters.end(); i++)
 	//{
-	//	lidar_tracker::DetectedObject detected_object;
+	//	autoware_msgs::DetectedObject detected_object;
 	//	detected_object.header 		= i-&gt;header;
 	//	detected_object.id 			= i-&gt;id;
 	//	detected_object.label 		= i-&gt;label;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\obj_fusion.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\obj_fusion.cpp" added_lines="11" deleted_lines="11">
				<diff>@@ -1,10 +1,10 @@
-#include &lt;cv_tracker_msgs/obj_label.h&gt;
 #include &lt;float.h&gt;
 #include &lt;geometry_msgs/Point.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-#include &lt;lidar_tracker/CloudCluster.h&gt;
-#include &lt;lidar_tracker/CloudClusterArray.h&gt;
+#include "autoware_msgs/obj_label.h"
+#include "autoware_msgs/CloudCluster.h"
+#include "autoware_msgs/CloudClusterArray.h"
 #include &lt;math.h&gt;
 #include &lt;mutex&gt;
 #include &lt;ros/ros.h&gt;
@@ -28,7 +28,7 @@ ros::Publisher cluster_class_pub;
 static std::string object_type;
 static std::vector&lt;geometry_msgs::Point&gt; centroids;
 static std_msgs::Header sensor_header;
-static std::vector&lt;lidar_tracker::CloudCluster&gt; v_cloud_cluster;
+static std::vector&lt;autoware_msgs::CloudCluster&gt; v_cloud_cluster;
 static ros::Time obj_pose_timestamp;
 static double threshold_min_dist;
 static tf::StampedTransform transform;
@@ -58,7 +58,7 @@ static double euclid_distance(const geometry_msgs::Point pos1,
 /* fusion reprojected position and pointcloud centroids */
 static void fusion_objects(void) {
   obj_label_t obj_label_current;
-  std::vector&lt;lidar_tracker::CloudCluster&gt; v_cloud_cluster_current;
+  std::vector&lt;autoware_msgs::CloudCluster&gt; v_cloud_cluster_current;
   std_msgs::Header header = sensor_header;
   std::vector&lt;geometry_msgs::Point&gt; centroids_current;
 
@@ -83,7 +83,7 @@ static void fusion_objects(void) {
     pub_msg.header = header;
     std_msgs::Time time;
     obj_pose_pub.publish(pub_msg);
-    lidar_tracker::CloudClusterArray cloud_clusters_msg;
+    autoware_msgs::CloudClusterArray cloud_clusters_msg;
     cloud_clusters_msg.header = header;
     cluster_class_pub.publish(cloud_clusters_msg);
 
@@ -121,7 +121,7 @@ static void fusion_objects(void) {
   /* Publish marker with centroids coordinates */
   jsk_recognition_msgs::BoundingBoxArray pub_msg;
   pub_msg.header = header;
-  lidar_tracker::CloudClusterArray cloud_clusters_msg;
+  autoware_msgs::CloudClusterArray cloud_clusters_msg;
   cloud_clusters_msg.header = header;
 
   for (unsigned int i = 0; i &lt; obj_label_current.obj_id.size(); ++i) {
@@ -154,7 +154,7 @@ static void fusion_objects(void) {
   obj_pose_timestamp_pub.publish(time);
 }
 
-void obj_label_cb(const cv_tracker_msgs::obj_label &amp;obj_label_msg) {
+void obj_label_cb(const autoware_msgs::obj_label &amp;obj_label_msg) {
   object_type = obj_label_msg.type;
   obj_pose_timestamp = obj_label_msg.header.stamp;
 
@@ -192,7 +192,7 @@ void obj_label_cb(const cv_tracker_msgs::obj_label &amp;obj_label_msg) {
 } /* void obj_label_cb() */
 
 void cluster_centroids_cb(
-    const lidar_tracker::CloudClusterArray::Ptr &amp;in_cloud_cluster_array_ptr) {
+    const autoware_msgs::CloudClusterArray::Ptr &amp;in_cloud_cluster_array_ptr) {
   LOCK(mtx_centroids);
   centroids.clear();
   v_cloud_cluster.clear();
@@ -203,7 +203,7 @@ void cluster_centroids_cb(
   try {
     trf_listener.lookupTransform("map", "velodyne", ros::Time(0), transform);
     for (int i(0); i &lt; (int)in_cloud_cluster_array_ptr-&gt;clusters.size(); ++i) {
-      lidar_tracker::CloudCluster cloud_cluster =
+      autoware_msgs::CloudCluster cloud_cluster =
           in_cloud_cluster_array_ptr-&gt;clusters.at(i);
       /* convert centroids coodinate from velodyne frame to map frame */
       tf::Vector3 pt(cloud_cluster.centroid_point.point.x,
@@ -264,7 +264,7 @@ int main(int argc, char *argv[]) {
       "/cloud_clusters", SUBSCRIBE_QUEUE_SIZE, cluster_centroids_cb);
   obj_pose_pub = n.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(
       "obj_pose", ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
-  cluster_class_pub = n.advertise&lt;lidar_tracker::CloudClusterArray&gt;(
+  cluster_class_pub = n.advertise&lt;autoware_msgs::CloudClusterArray&gt;(
       "/cloud_clusters_class", ADVERTISE_QUEUE_SIZE);
   obj_pose_timestamp_pub =
       n.advertise&lt;std_msgs::Time&gt;("obj_pose_timestamp", ADVERTISE_QUEUE_SIZE);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\pf_lidar_track\pf_lidar_track.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\pf_lidar_track\pf_lidar_track.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -11,10 +11,10 @@
 #include &lt;sensor_msgs/PointCloud.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 
-#include &lt;lidar_tracker/CloudCluster.h&gt;
-#include &lt;lidar_tracker/CloudClusterArray.h&gt;
-#include &lt;lidar_tracker/DetectedObject.h&gt;
-#include &lt;lidar_tracker/DetectedObjectArray.h&gt;
+#include "autoware_msgs/CloudCluster.h"
+#include "autoware_msgs/CloudClusterArray.h"
+#include "autoware_msgs/DetectedObject.h"
+#include "autoware_msgs/DetectedObjectArray.h"
 
 
 class PfTrack
@@ -28,23 +28,23 @@ private:
 	ros::Subscriber cloud_clusters_sub_;
 	ros::Publisher detected_objects_pub_;
 
-	void CloudClustersCallback(const lidar_tracker::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr);
+	void CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr);
 };
 
 PfTrack::PfTrack() :
 		node_handle_("~")
 {
 	cloud_clusters_sub_ = node_handle_.subscribe("/cloud_clusters_class", 10, &amp;PfTrack::CloudClustersCallback, this);
-	detected_objects_pub_ = node_handle_.advertise&lt;lidar_tracker::DetectedObjectArray&gt;( "/detected_objects", 10);
+	detected_objects_pub_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;( "/detected_objects", 10);
 }
 
-void PfTrack::CloudClustersCallback(const lidar_tracker::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr)
+void PfTrack::CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr)
 {
-	lidar_tracker::DetectedObjectArray detected_objects;
+	autoware_msgs::DetectedObjectArray detected_objects;
 	detected_objects.header = in_cloud_cluster_array_ptr-&gt;header;
 	for (auto i = in_cloud_cluster_array_ptr-&gt;clusters.begin(); i != in_cloud_cluster_array_ptr-&gt;clusters.end(); i++)
 	{
-		lidar_tracker::DetectedObject detected_object;
+		autoware_msgs::DetectedObject detected_object;
 		detected_object.header 		= i-&gt;header;
 		detected_object.id 			= i-&gt;id;
 		detected_object.label 		= i-&gt;label;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\svm_lidar_detect\svm_lidar_detect.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\svm_lidar_detect\svm_lidar_detect.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -11,8 +11,8 @@
 #include &lt;sensor_msgs/PointCloud.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 
-#include &lt;lidar_tracker/CloudCluster.h&gt;
-#include &lt;lidar_tracker/CloudClusterArray.h&gt;
+#include "autoware_msgs/CloudCluster.h"
+#include "autoware_msgs/CloudClusterArray.h"
 
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
@@ -49,7 +49,7 @@ private:
 
 	FILE *model_file_handle_;
 
-	void CloudClustersCallback(const lidar_tracker::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr);
+	void CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr);
 	void ClassifyFpfhDescriptor(const std::vector&lt;float&gt;&amp; in_fpfh_descriptor, double&amp; out_label, std::vector&lt;double&gt;&amp; out_scores, double&amp; out_sum_scores);
 
 	void CloseModel();
@@ -81,7 +81,7 @@ void SvmDetect::Run()
 	private_node_handle.param&lt;std::string&gt;("clusters_node_name", clusters_node_name, "/cloud_clusters");	ROS_INFO("clusters_node_name: %s", clusters_node_name.c_str());
 
 	cloud_clusters_sub_ = node_handle_.subscribe(clusters_node_name, 10, &amp;SvmDetect::CloudClustersCallback, this);
-	cloud_clusters_pub_ = node_handle_.advertise&lt;lidar_tracker::CloudClusterArray&gt;(out_clusters_topic_name, 10); ROS_INFO("output clusters topic: %s", out_clusters_topic_name.c_str());
+	cloud_clusters_pub_ = node_handle_.advertise&lt;autoware_msgs::CloudClusterArray&gt;(out_clusters_topic_name, 10); ROS_INFO("output clusters topic: %s", out_clusters_topic_name.c_str());
 
 	/*text_pictogram_pub_ = node_handle_.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;(out_pictograms_topic_name, 10); ROS_INFO("output pictograms topic: %s", out_pictograms_topic_name.c_str());
 
@@ -100,7 +100,7 @@ void SvmDetect::Run()
 }
 
 
-void SvmDetect::CloudClustersCallback(const lidar_tracker::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr)
+void SvmDetect::CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr)
 {
 	cloud_clusters_pub_.publish(*in_cloud_cluster_array_ptr);
 	return;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\mainwindow.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\mainwindow.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -269,7 +269,7 @@ MainWindow::MainWindow(QWidget *parent) :
     ui-&gt;setupUi(this);
 
     scansub=new ROSSub&lt;sensor_msgs::LaserScanConstPtr&gt;("/scan",1000,10,this);
-    //detectionsub=new ROSSub&lt;cv_tracker_msgs::obj_label::ConstPtr&gt;("obj_label",1000,10,this);
+    //detectionsub=new ROSSub&lt;autoware_msgs::obj_label::ConstPtr&gt;("obj_label",1000,10,this);
     boxessub=new ROSSub&lt;jsk_recognition_msgs::BoundingBoxArray::ConstPtr&gt;("bounding_boxes",1000,10,this);
     tfsub=new ROSTFSub("/world","/velodyne",10,this);
     tfMap2Lidarsub=new ROSTFSub("/velodyne","/map",10,this); // obj_pose is published into "map" frame
@@ -333,7 +333,7 @@ void MainWindow::slotReceive()
 
 void MainWindow::slotReceiveDetection()
 {
-    cv_tracker_msgs::obj_label::ConstPtr msg=detectionsub-&gt;getMessage();
+    autoware_msgs::obj_label::ConstPtr msg=detectionsub-&gt;getMessage();
 
     for (const auto&amp; point : msg-&gt;reprojected_pos) {
         int msec=(msg-&gt;header.stamp.sec)%(24*60*60)*1000+(msg-&gt;header.stamp.nsec)/1000000;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\mainwindow.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\mainwindow.h" added_lines="2" deleted_lines="2">
				<diff>@@ -6,7 +6,7 @@
 #include&lt;sensor_msgs/LaserScan.h&gt;
 #include&lt;sensor_msgs/PointCloud2.h&gt;
 #include&lt;visualization_msgs/MarkerArray.h&gt;
-#include "cv_tracker_msgs/obj_label.h"
+#include "autoware_msgs/obj_label.h"
 
 #include&lt;QGraphicsView&gt;
 #include&lt;QGraphicsScene&gt;
@@ -100,7 +100,7 @@ private:
     Ui::MainWindow *ui;
 public:
     ROSSub&lt;sensor_msgs::LaserScanConstPtr&gt; * scansub;
-    ROSSub&lt;cv_tracker_msgs::obj_label::ConstPtr&gt; * detectionsub;
+    ROSSub&lt;autoware_msgs::obj_label::ConstPtr&gt; * detectionsub;
     ROSSub&lt;jsk_recognition_msgs::BoundingBoxArray::ConstPtr&gt; * boxessub;
     ROSTFSub * tfsub;
     ROSTFSub * tfMap2Lidarsub;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_info_translator\can_info_translator_core.cpp" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_info_translator\can_info_translator_core.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -82,7 +82,7 @@ void VelPoseConnectNode::run()
   ros::spin();
 }
 
-void VelPoseConnectNode::publishVelocity(const vehicle_socket::CanInfoConstPtr &amp;msg)
+void VelPoseConnectNode::publishVelocity(const autoware_msgs::CanInfoConstPtr &amp;msg)
 {
   geometry_msgs::TwistStamped tw;
   tw.header = msg-&gt;header;
@@ -97,14 +97,14 @@ void VelPoseConnectNode::publishVelocity(const vehicle_socket::CanInfoConstPtr &amp;
   pub1_.publish(tw);
 }
 
-void VelPoseConnectNode::publishVelocityViz(const vehicle_socket::CanInfoConstPtr &amp;msg)
+void VelPoseConnectNode::publishVelocityViz(const autoware_msgs::CanInfoConstPtr &amp;msg)
 {
   std_msgs::Float32 fl;
   fl.data = msg-&gt;speed;
   pub2_.publish(fl);
 }
 
-void VelPoseConnectNode::publishOdometry(const vehicle_socket::CanInfoConstPtr &amp;msg)
+void VelPoseConnectNode::publishOdometry(const autoware_msgs::CanInfoConstPtr &amp;msg)
 {
   double vx = kmph2mps(msg-&gt;speed);
   double vth = v_info_.convertSteeringAngleToAngularVelocity(kmph2mps(msg-&gt;speed), msg-&gt;angle);
@@ -147,7 +147,7 @@ void VelPoseConnectNode::publishOdometry(const vehicle_socket::CanInfoConstPtr &amp;
   pub3_.publish(odom);
 }
 
-void VelPoseConnectNode::callbackFromCanInfo(const vehicle_socket::CanInfoConstPtr &amp;msg)
+void VelPoseConnectNode::callbackFromCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
 {
   publishVelocity(msg);
   publishVelocityViz(msg);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_info_translator\can_info_translator_core.h" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_info_translator\can_info_translator_core.h" added_lines="5" deleted_lines="5">
				<diff>@@ -39,7 +39,7 @@
 #include &lt;tf/transform_broadcaster.h&gt;
 
 // User Defined Includes
-#include "vehicle_socket/CanInfo.h"
+#include "autoware_msgs/CanInfo.h"
 
 namespace autoware_connector
 {
@@ -143,15 +143,15 @@ private:
   // tf::TransformBroadcaster odom_broadcaster_;
 
   // callbacks
-  void callbackFromCanInfo(const vehicle_socket::CanInfoConstPtr &amp;msg);
+  void callbackFromCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg);
 
   // initializer
   void initForROS();
 
   // functions
-  void publishVelocity(const vehicle_socket::CanInfoConstPtr &amp;msg);
-  void publishVelocityViz(const vehicle_socket::CanInfoConstPtr &amp;msg);
-  void publishOdometry(const vehicle_socket::CanInfoConstPtr &amp;msg);
+  void publishVelocity(const autoware_msgs::CanInfoConstPtr &amp;msg);
+  void publishVelocityViz(const autoware_msgs::CanInfoConstPtr &amp;msg);
+  void publishOdometry(const autoware_msgs::CanInfoConstPtr &amp;msg);
 };
 
 inline double kmph2mps(double velocity_kmph)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\icp_localizer\nodes\icp_matching\icp_matching.cpp" new_path="ros\src\computing\perception\localization\packages\icp_localizer\nodes\icp_matching\icp_matching.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -64,9 +64,9 @@
 #include &lt;pcl/registration/icp.h&gt;
 #include &lt;pcl/filters/voxel_grid.h&gt;
 
-#include &lt;runtime_manager/ConfigICP.h&gt;
+#include "autoware_msgs/ConfigICP.h"
 
-#include &lt;icp_localizer/icp_stat.h&gt;
+#include "autoware_msgs/icp_stat.h"
 
 #define PREDICT_POSE_THRESHOLD 0.5
 
@@ -159,7 +159,7 @@ static std_msgs::Float32 time_icp_matching;
 static int _queue_size = 1000;
 
 static ros::Publisher icp_stat_pub;
-static icp_localizer::icp_stat icp_stat_msg;
+static autoware_msgs::icp_stat icp_stat_msg;
 
 static double predict_pose_error = 0.0;
 
@@ -172,7 +172,7 @@ static std::string _offset = "linear";  // linear, zero, quadratic
 static std::ofstream ofs;
 static std::string filename;
 
-static void param_callback(const runtime_manager::ConfigICP::ConstPtr&amp; input)
+static void param_callback(const autoware_msgs::ConfigICP::ConstPtr&amp; input)
 {
   if (_use_gnss != input-&gt;init_pos_gnss)
   {
@@ -755,7 +755,7 @@ int main(int argc, char** argv)
   estimated_vel_kmph_pub = nh.advertise&lt;std_msgs::Float32&gt;("/estimated_vel_kmph", 1000);
   estimated_vel_pub = nh.advertise&lt;geometry_msgs::Vector3Stamped&gt;("/estimated_vel", 1000);
   time_icp_matching_pub = nh.advertise&lt;std_msgs::Float32&gt;("/time_icp_matching", 1000);
-  icp_stat_pub = nh.advertise&lt;icp_localizer::icp_stat&gt;("/icp_stat", 1000);
+  icp_stat_pub = nh.advertise&lt;autoware_msgs::icp_stat&gt;("/icp_stat", 1000);
 //  ndt_reliability_pub = nh.advertise&lt;std_msgs::Float32&gt;("/ndt_reliability", 1000);
 
   // Subscribers
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\lazy_ndt_mapping\lazy_ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\lazy_ndt_mapping\lazy_ndt_mapping.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -65,8 +65,8 @@
 #include &lt;pcl/filters/voxel_grid.h&gt;
 #endif
 
-#include &lt;runtime_manager/ConfigNdtMapping.h&gt;
-#include &lt;runtime_manager/ConfigNdtMappingOutput.h&gt;
+#include "autoware_msgs/ConfigNdtMapping.h"
+#include "autoware_msgs/ConfigNdtMappingOutput.h"
 
 struct pose {
     double x;
@@ -125,7 +125,7 @@ static bool _use_openmp = false;
 
 static double fitness_score;
 
-static void param_callback(const runtime_manager::ConfigNdtMapping::ConstPtr&amp; input)
+static void param_callback(const autoware_msgs::ConfigNdtMapping::ConstPtr&amp; input)
 {
   ndt_res = input-&gt;resolution;
   step_size = input-&gt;step_size;
@@ -145,7 +145,7 @@ static void param_callback(const runtime_manager::ConfigNdtMapping::ConstPtr&amp; in
   std::cout &lt;&lt; "min_add_scan_shift: " &lt;&lt; min_add_scan_shift &lt;&lt; std::endl;
 }
 
-static void output_callback(const runtime_manager::ConfigNdtMappingOutput::ConstPtr&amp; input)
+static void output_callback(const autoware_msgs::ConfigNdtMappingOutput::ConstPtr&amp; input)
 {
   double filter_res = input-&gt;filter_res;
   std::string filename = input-&gt;filename;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -66,8 +66,8 @@
 #include &lt;pcl/filters/voxel_grid.h&gt;
 #endif
 
-#include &lt;runtime_manager/ConfigNdtMapping.h&gt;
-#include &lt;runtime_manager/ConfigNdtMappingOutput.h&gt;
+#include &lt;autoware_msgs/ConfigNdtMapping.h&gt;
+#include &lt;autoware_msgs/ConfigNdtMappingOutput.h&gt;
 
 struct pose
 {
@@ -148,7 +148,7 @@ static double fitness_score;
 static sensor_msgs::Imu imu;
 static nav_msgs::Odometry odom;
 
-static void param_callback(const runtime_manager::ConfigNdtMapping::ConstPtr&amp; input)
+static void param_callback(const autoware_msgs::ConfigNdtMapping::ConstPtr&amp; input)
 {
 
   ndt_res = input-&gt;resolution;
@@ -169,7 +169,7 @@ static void param_callback(const runtime_manager::ConfigNdtMapping::ConstPtr&amp; in
   std::cout &lt;&lt; "min_add_scan_shift: " &lt;&lt; min_add_scan_shift &lt;&lt; std::endl;
 }
 
-static void output_callback(const runtime_manager::ConfigNdtMappingOutput::ConstPtr&amp; input)
+static void output_callback(const autoware_msgs::ConfigNdtMappingOutput::ConstPtr&amp; input)
 {
   double filter_res = input-&gt;filter_res;
   std::string filename = input-&gt;filename;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -71,9 +71,9 @@
 #include &lt;pcl_ros/point_cloud.h&gt;
 #include &lt;pcl_ros/transforms.h&gt;
 
-#include &lt;runtime_manager/ConfigNdt.h&gt;
+#include &lt;autoware_msgs/ConfigNdt.h&gt;
 
-#include &lt;ndt_localizer/ndt_stat.h&gt;
+#include &lt;autoware_msgs/ndt_stat.h&gt;
 
 #define PREDICT_POSE_THRESHOLD 0.5
 
@@ -185,7 +185,7 @@ static std_msgs::Float32 time_ndt_matching;
 static int _queue_size = 1000;
 
 static ros::Publisher ndt_stat_pub;
-static ndt_localizer::ndt_stat ndt_stat_msg;
+static autoware_msgs::ndt_stat ndt_stat_msg;
 
 static double predict_pose_error = 0.0;
 
@@ -217,7 +217,7 @@ static nav_msgs::Odometry odom;
 // static tf::TransformListener local_transform_listener;
 static tf::StampedTransform local_transform;
 
-static void param_callback(const runtime_manager::ConfigNdt::ConstPtr&amp; input)
+static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
 {
   if (_use_gnss != input-&gt;init_pos_gnss)
   {
@@ -1363,7 +1363,7 @@ int main(int argc, char** argv)
   estimated_vel_kmph_pub = nh.advertise&lt;std_msgs::Float32&gt;("/estimated_vel_kmph", 1000);
   estimated_vel_pub = nh.advertise&lt;geometry_msgs::Vector3Stamped&gt;("/estimated_vel", 1000);
   time_ndt_matching_pub = nh.advertise&lt;std_msgs::Float32&gt;("/time_ndt_matching", 1000);
-  ndt_stat_pub = nh.advertise&lt;ndt_localizer::ndt_stat&gt;("/ndt_stat", 1000);
+  ndt_stat_pub = nh.advertise&lt;autoware_msgs::ndt_stat&gt;("/ndt_stat", 1000);
   ndt_reliability_pub = nh.advertise&lt;std_msgs::Float32&gt;("/ndt_reliability", 1000);
 
   // Subscribers
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\potential_field\potential_field.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\potential_field\potential_field.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -6,8 +6,8 @@
 #include &lt;iostream&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-#include &lt;lidar_tracker/DetectedObject.h&gt;
-#include &lt;lidar_tracker/DetectedObjectArray.h&gt;
+#include "autoware_msgs/DetectedObject.h"
+#include "autoware_msgs/DetectedObjectArray.h"
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
@@ -52,7 +52,7 @@ private:
     double around_y;
   };
 
-  void obj_callback(lidar_tracker::DetectedObjectArray::ConstPtr obj_msg);
+  void obj_callback(autoware_msgs::DetectedObjectArray::ConstPtr obj_msg);
   void target_waypoint_callback(
       visualization_msgs::Marker::ConstPtr target_point_msgs);
   void vscan_points_callback(sensor_msgs::PointCloud2::ConstPtr vscan_msg);
@@ -142,7 +142,7 @@ void PotentialField::publish_potential_field() {
                     message.info.header.stamp.toSec());
 }
 void PotentialField::obj_callback(
-    lidar_tracker::DetectedObjectArray::ConstPtr obj_msg) { // Create grid map.
+    autoware_msgs::DetectedObjectArray::ConstPtr obj_msg) { // Create grid map.
   static ObstacleFieldParameter param;
   double ver_x_p(param.ver_x_p);
   double ver_y_p(param.ver_y_p);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\freespace_planner\nodes\astar_navi\astar_navi.cpp" new_path="ros\src\computing\planning\mission\packages\freespace_planner\nodes\astar_navi\astar_navi.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -1,25 +1,25 @@
 #include "astar_search.h"
 #include "search_info_ros.h"
-#include "waypoint_follower_msgs/LaneArray.h"
+#include "autoware_msgs/LaneArray.h"
 
 namespace
 {
 
 void publishPathAsWaypoints(const ros::Publisher&amp; pub, const nav_msgs::Path&amp; path, const double waypoint_velocity_kmph)
 {
-  waypoint_follower_msgs::lane lane;
+  autoware_msgs::lane lane;
 
   lane.header = path.header;
   lane.increment = 0;
   for (const auto&amp; pose : path.poses) {
-    waypoint_follower_msgs::waypoint wp;
+    autoware_msgs::waypoint wp;
     wp.pose = pose;
     wp.twist.twist.linear.x = waypoint_velocity_kmph / 3.6;
 
     lane.waypoints.push_back(wp);
   }
 
-  waypoint_follower_msgs::LaneArray lane_array;
+  autoware_msgs::LaneArray lane_array;
   lane_array.lanes.push_back(lane);
   pub.publish(lane_array);
 
@@ -49,7 +49,7 @@ int main(int argc, char **argv)
 
   // ROS publishers
   ros::Publisher path_pub       = n.advertise&lt;nav_msgs::Path&gt;("astar_path", 1, true);
-  ros::Publisher waypoints_pub  = n.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("lane_waypoints_array", 1, true);
+  ros::Publisher waypoints_pub  = n.advertise&lt;autoware_msgs::LaneArray&gt;("lane_waypoints_array", 1, true);
   ros::Publisher debug_pose_pub = n.advertise&lt;geometry_msgs::PoseArray&gt;("debug_pose_array", 1, true);
 
   ros::Rate loop_rate(10);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\include\lane_planner\vmap.hpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\include\lane_planner\vmap.hpp" added_lines="5" deleted_lines="5">
				<diff>@@ -40,8 +40,8 @@
 
 #include &lt;vector_map/vector_map.h&gt;
 #include &lt;tablet_socket_msgs/route_cmd.h&gt;
-#include &lt;waypoint_follower_msgs/dtlane.h&gt;
-#include &lt;waypoint_follower_msgs/lane.h&gt;
+#include "autoware_msgs/dtlane.h"
+#include "autoware_msgs/lane.h"
 
 namespace lane_planner {
 
@@ -77,11 +77,11 @@ bool is_connection_dtlane(const VectorMap&amp; fine_vmap, int index);
 
 geometry_msgs::Point create_geometry_msgs_point(const vector_map::Point&amp; vp);
 vector_map::Point create_vector_map_point(const geometry_msgs::Point&amp; gp);
-waypoint_follower_msgs::dtlane create_waypoint_follower_dtlane(const vector_map::DTLane&amp; vd);
-vector_map::DTLane create_vector_map_dtlane(const waypoint_follower_msgs::dtlane&amp; wd);
+autoware_msgs::dtlane create_waypoint_follower_dtlane(const vector_map::DTLane&amp; vd);
+vector_map::DTLane create_vector_map_dtlane(const autoware_msgs::dtlane&amp; wd);
 
 VectorMap create_lane_vmap(const VectorMap&amp; vmap, int lno);
-VectorMap create_coarse_vmap_from_lane(const waypoint_follower_msgs::lane&amp; lane);
+VectorMap create_coarse_vmap_from_lane(const autoware_msgs::lane&amp; lane);
 VectorMap create_coarse_vmap_from_route(const tablet_socket_msgs::route_cmd&amp; route);
 VectorMap create_fine_vmap(const VectorMap&amp; lane_vmap, int lno, const VectorMap&amp; coarse_vmap, double search_radius,
 			   int waypoint_max);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\lib\lane_planner\vmap.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\lib\lane_planner\vmap.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -506,9 +506,9 @@ vector_map::Point create_vector_map_point(const geometry_msgs::Point&amp; gp)
 	return vp;
 }
 
-waypoint_follower_msgs::dtlane create_waypoint_follower_dtlane(const vector_map::DTLane&amp; vd)
+autoware_msgs::dtlane create_waypoint_follower_dtlane(const vector_map::DTLane&amp; vd)
 {
-	waypoint_follower_msgs::dtlane wd;
+	autoware_msgs::dtlane wd;
 	wd.dist = vd.dist;
 	wd.dir = vd.dir;
 	wd.apara = vd.apara;
@@ -521,7 +521,7 @@ waypoint_follower_msgs::dtlane create_waypoint_follower_dtlane(const vector_map:
 	return wd;
 }
 
-vector_map::DTLane create_vector_map_dtlane(const waypoint_follower_msgs::dtlane&amp; wd)
+vector_map::DTLane create_vector_map_dtlane(const autoware_msgs::dtlane&amp; wd)
 {
 	vector_map::DTLane vd;
 	vd.dist = wd.dist;
@@ -572,10 +572,10 @@ VectorMap create_lane_vmap(const VectorMap&amp; vmap, int lno)
 	return lane_vmap;
 }
 
-VectorMap create_coarse_vmap_from_lane(const waypoint_follower_msgs::lane&amp; lane)
+VectorMap create_coarse_vmap_from_lane(const autoware_msgs::lane&amp; lane)
 {
 	VectorMap coarse_vmap;
-	for (const waypoint_follower_msgs::waypoint&amp; w : lane.waypoints)
+	for (const autoware_msgs::waypoint&amp; w : lane.waypoints)
 		coarse_vmap.points.push_back(create_vector_map_point(w.pose.pose.position));
 
 	return coarse_vmap;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_navi\lane_navi.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_navi\lane_navi.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -34,9 +34,9 @@
 #include &lt;tf/transform_datatypes.h&gt;
 
 #include &lt;vector_map/vector_map.h&gt;
-#include &lt;waypoint_follower_msgs/LaneArray.h&gt;
+#include "autoware_msgs/LaneArray.h"
 
-#include &lt;lane_planner/vmap.hpp&gt;
+#include "lane_planner/vmap.hpp"
 
 namespace {
 
@@ -123,9 +123,9 @@ void create_waypoint(const tablet_socket_msgs::route_cmd&amp; msg)
 		fine_vmaps.push_back(v);
 	}
 
-	waypoint_follower_msgs::LaneArray lane_waypoint;
+	autoware_msgs::LaneArray lane_waypoint;
 	for (const lane_planner::vmap::VectorMap&amp; v : fine_vmaps) {
-		waypoint_follower_msgs::lane l;
+		autoware_msgs::lane l;
 		l.header = header;
 		l.increment = 1;
 
@@ -147,7 +147,7 @@ void create_waypoint(const tablet_socket_msgs::route_cmd&amp; msg)
 				yaw = atan2(p2.y - p1.y, p2.x - p1.x);
 			}
 
-			waypoint_follower_msgs::waypoint w;
+			autoware_msgs::waypoint w;
 			w.pose.header = header;
 			w.pose.pose.position = lane_planner::vmap::create_geometry_msgs_point(v.points[i]);
 			w.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
@@ -237,7 +237,7 @@ int main(int argc, char **argv)
 		return EXIT_FAILURE;
 	}
 
-	waypoint_pub = n.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("/lane_waypoints_array", pub_waypoint_queue_size,
+	waypoint_pub = n.advertise&lt;autoware_msgs::LaneArray&gt;("/lane_waypoints_array", pub_waypoint_queue_size,
 								 pub_waypoint_latch);
 
 	ros::Subscriber route_sub = n.subscribe("/route_cmd", sub_route_queue_size, create_waypoint);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" added_lines="28" deleted_lines="28">
				<diff>@@ -37,8 +37,8 @@
 #include &lt;ros/console.h&gt;
 
 #include &lt;vector_map/vector_map.h&gt;
-#include &lt;runtime_manager/ConfigLaneRule.h&gt;
-#include &lt;waypoint_follower_msgs/LaneArray.h&gt;
+#include "autoware_msgs/ConfigLaneRule.h"
+#include "autoware_msgs/LaneArray.h"
 
 #include &lt;lane_planner/vmap.hpp&gt;
 
@@ -65,7 +65,7 @@ lane_planner::vmap::VectorMap lane_vmap;
 double curve_radius_min;
 double crossroad_radius_min;
 double clothoid_radius_min;
-waypoint_follower_msgs::LaneArray cached_waypoint;
+autoware_msgs::LaneArray cached_waypoint;
 
 #ifdef DEBUG
 visualization_msgs::Marker debug_marker;
@@ -73,12 +73,12 @@ ros::Publisher marker_pub;
 int marker_cnt;
 #endif // DEBUG
 
-waypoint_follower_msgs::lane create_new_lane(const waypoint_follower_msgs::lane&amp; lane, const std_msgs::Header&amp; header)
+autoware_msgs::lane create_new_lane(const autoware_msgs::lane&amp; lane, const std_msgs::Header&amp; header)
 {
-	waypoint_follower_msgs::lane l = lane;
+	autoware_msgs::lane l = lane;
 	l.header = header;
 
-	for (waypoint_follower_msgs::waypoint&amp; w : l.waypoints) {
+	for (autoware_msgs::waypoint&amp; w : l.waypoints) {
 		w.pose.header = header;
 		w.twist.header = header;
 	}
@@ -86,10 +86,10 @@ waypoint_follower_msgs::lane create_new_lane(const waypoint_follower_msgs::lane&amp;
 	return l;
 }
 
-waypoint_follower_msgs::lane apply_acceleration(const waypoint_follower_msgs::lane&amp; lane, double acceleration,
+autoware_msgs::lane apply_acceleration(const autoware_msgs::lane&amp; lane, double acceleration,
 					   size_t start_index, size_t fixed_cnt, double fixed_vel)
 {
-	waypoint_follower_msgs::lane l = lane;
+	autoware_msgs::lane l = lane;
 
 	if (fixed_cnt == 0)
 		return l;
@@ -116,9 +116,9 @@ waypoint_follower_msgs::lane apply_acceleration(const waypoint_follower_msgs::la
 	return l;
 }
 
-waypoint_follower_msgs::lane apply_crossroad_acceleration(const waypoint_follower_msgs::lane&amp; lane, double acceleration)
+autoware_msgs::lane apply_crossroad_acceleration(const autoware_msgs::lane&amp; lane, double acceleration)
 {
-	waypoint_follower_msgs::lane l = lane;
+	autoware_msgs::lane l = lane;
 
 	bool crossroad = false;
 	std::vector&lt;size_t&gt; start_indexes;
@@ -162,11 +162,11 @@ waypoint_follower_msgs::lane apply_crossroad_acceleration(const waypoint_followe
 	return l;
 }
 
-waypoint_follower_msgs::lane apply_stopline_acceleration(const waypoint_follower_msgs::lane&amp; lane, double acceleration,
+autoware_msgs::lane apply_stopline_acceleration(const autoware_msgs::lane&amp; lane, double acceleration,
 						    const lane_planner::vmap::VectorMap&amp; fine_vmap, size_t ahead_cnt,
 						    size_t behind_cnt)
 {
-	waypoint_follower_msgs::lane l = lane;
+	autoware_msgs::lane l = lane;
 
 	std::vector&lt;size_t&gt; indexes;
 	for (size_t i = 0; i &lt; fine_vmap.stoplines.size(); ++i) {
@@ -225,7 +225,7 @@ std::vector&lt;vector_map::Point&gt; create_stop_points(const lane_planner::vmap::Vect
 }
 
 std::vector&lt;size_t&gt; create_stop_indexes(const lane_planner::vmap::VectorMap&amp; vmap,
-					const waypoint_follower_msgs::lane&amp; lane, double stopline_search_radius)
+					const autoware_msgs::lane&amp; lane, double stopline_search_radius)
 {
 	std::vector&lt;size_t&gt; stop_indexes;
 	for (const vector_map::Point&amp; p : create_stop_points(vmap)) {
@@ -249,10 +249,10 @@ std::vector&lt;size_t&gt; create_stop_indexes(const lane_planner::vmap::VectorMap&amp; vma
 	return stop_indexes;
 }
 
-waypoint_follower_msgs::lane apply_stopline_acceleration(const waypoint_follower_msgs::lane&amp; lane, double acceleration,
+autoware_msgs::lane apply_stopline_acceleration(const autoware_msgs::lane&amp; lane, double acceleration,
 						    double stopline_search_radius, size_t ahead_cnt, size_t behind_cnt)
 {
-	waypoint_follower_msgs::lane l = lane;
+	autoware_msgs::lane l = lane;
 
 	std::vector&lt;size_t&gt; indexes = create_stop_indexes(lane_vmap, l, stopline_search_radius);
 	if (indexes.empty())
@@ -276,7 +276,7 @@ waypoint_follower_msgs::lane apply_stopline_acceleration(const waypoint_follower
 	return l;
 }
 
-bool is_fine_vmap(const lane_planner::vmap::VectorMap&amp; fine_vmap, const waypoint_follower_msgs::lane&amp; lane)
+bool is_fine_vmap(const lane_planner::vmap::VectorMap&amp; fine_vmap, const autoware_msgs::lane&amp; lane)
 {
 	if (fine_vmap.points.size() != lane.waypoints.size())
 		return false;
@@ -366,7 +366,7 @@ std_msgs::ColorRGBA create_color(int index)
 }
 #endif // DEBUG
 
-void create_waypoint(const waypoint_follower_msgs::LaneArray&amp; msg)
+void create_waypoint(const autoware_msgs::LaneArray&amp; msg)
 {
 	std_msgs::Header header;
 	header.stamp = ros::Time::now();
@@ -374,7 +374,7 @@ void create_waypoint(const waypoint_follower_msgs::LaneArray&amp; msg)
 
 	cached_waypoint.lanes.clear();
 	cached_waypoint.lanes.shrink_to_fit();
-	for (const waypoint_follower_msgs::lane&amp; l : msg.lanes)
+	for (const autoware_msgs::lane&amp; l : msg.lanes)
 		cached_waypoint.lanes.push_back(create_new_lane(l, header));
 	if (all_vmap.points.empty() || all_vmap.lanes.empty() || all_vmap.nodes.empty() ||
 	    all_vmap.stoplines.empty() || all_vmap.dtlanes.empty()) {
@@ -386,11 +386,11 @@ void create_waypoint(const waypoint_follower_msgs::LaneArray&amp; msg)
 	marker_cnt = msg.lanes.size();
 #endif // DEBUG
 
-	waypoint_follower_msgs::LaneArray traffic_waypoint;
-	waypoint_follower_msgs::LaneArray red_waypoint;
-	waypoint_follower_msgs::LaneArray green_waypoint;
+	autoware_msgs::LaneArray traffic_waypoint;
+	autoware_msgs::LaneArray red_waypoint;
+	autoware_msgs::LaneArray green_waypoint;
 	for (size_t i = 0; i &lt; msg.lanes.size(); ++i) {
-		waypoint_follower_msgs::lane lane = create_new_lane(msg.lanes[i], header);
+		autoware_msgs::lane lane = create_new_lane(msg.lanes[i], header);
 
 		lane_planner::vmap::VectorMap coarse_vmap =
 			lane_planner::vmap::create_coarse_vmap_from_lane(lane);
@@ -488,7 +488,7 @@ void update_values()
 #endif // DEBUG
 
 	if (!cached_waypoint.lanes.empty()) {
-		waypoint_follower_msgs::LaneArray update_waypoint = cached_waypoint;
+		autoware_msgs::LaneArray update_waypoint = cached_waypoint;
 		create_waypoint(update_waypoint);
 	}
 }
@@ -523,7 +523,7 @@ void cache_dtlane(const vector_map::DTLaneArray&amp; msg)
 	update_values();
 }
 
-void config_parameter(const runtime_manager::ConfigLaneRule&amp; msg)
+void config_parameter(const autoware_msgs::ConfigLaneRule&amp; msg)
 {
 	config_acceleration = msg.acceleration;
 	config_stopline_search_radius = msg.stopline_search_radius;
@@ -531,7 +531,7 @@ void config_parameter(const runtime_manager::ConfigLaneRule&amp; msg)
 	config_number_of_zeros_behind = msg.number_of_zeros_behind;
 
 	if (!cached_waypoint.lanes.empty()) {
-		waypoint_follower_msgs::LaneArray update_waypoint = cached_waypoint;
+		autoware_msgs::LaneArray update_waypoint = cached_waypoint;
 		create_waypoint(update_waypoint);
 	}
 }
@@ -568,11 +568,11 @@ int main(int argc, char **argv)
 	n.param&lt;double&gt;("/lane_rule/clothoid_weight", clothoid_weight, 0.215);
 	n.param&lt;std::string&gt;("/lane_rule/frame_id", frame_id, "map");
 
-	traffic_pub = n.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("/traffic_waypoints_array", pub_waypoint_queue_size,
+	traffic_pub = n.advertise&lt;autoware_msgs::LaneArray&gt;("/traffic_waypoints_array", pub_waypoint_queue_size,
 								pub_waypoint_latch);
-	red_pub = n.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("/red_waypoints_array", pub_waypoint_queue_size,
+	red_pub = n.advertise&lt;autoware_msgs::LaneArray&gt;("/red_waypoints_array", pub_waypoint_queue_size,
 							    pub_waypoint_latch);
-	green_pub = n.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("/green_waypoints_array", pub_waypoint_queue_size,
+	green_pub = n.advertise&lt;autoware_msgs::LaneArray&gt;("/green_waypoints_array", pub_waypoint_queue_size,
 							      pub_waypoint_latch);
 
 #ifdef DEBUG
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -50,11 +50,11 @@ void getPointAndVectorFromPose(const geometry_msgs::Pose &amp;pose, Element2D *point
   vector-&gt;set(tmp_tf_vevtor.getX(), tmp_tf_vevtor.getY());
 }
 
-std::vector&lt;waypoint_follower_msgs::waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
+std::vector&lt;autoware_msgs::waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
                                                                     const geometry_msgs::Pose &amp;end,
                                                                     const double velocity_mps, const double vlength)
 {
-  std::vector&lt;waypoint_follower_msgs::waypoint&gt; wps;
+  std::vector&lt;autoware_msgs::waypoint&gt; wps;
   Element2D p0(0, 0), v0(0, 0), p1(0, 0), v1(0, 0);
   getPointAndVectorFromPose(start, &amp;p0, &amp;v0);
   getPointAndVectorFromPose(end, &amp;p1, &amp;v1);
@@ -64,7 +64,7 @@ std::vector&lt;waypoint_follower_msgs::waypoint&gt; generateHermiteCurveForROS(const g
   double height_d = fabs(start.position.z - end.position.z);
   for (uint32_t i = 0; i &lt; result.size(); i++)
   {
-    waypoint_follower_msgs::waypoint wp;
+    autoware_msgs::waypoint wp;
     wp.pose.pose.position.x = result.at(i).x;
     wp.pose.pose.position.y = result.at(i).y;
     wp.twist.twist.linear.x = velocity_mps;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.h" added_lines="2" deleted_lines="3">
				<diff>@@ -43,8 +43,7 @@
 #include &lt;tf/transform_datatypes.h&gt;
 #include &lt;geometry_msgs/Pose.h&gt;
 
-#include "waypoint_follower_msgs/lane.h"
-#include "waypoint_follower_msgs/waypoint.h"
+#include "autoware_msgs/waypoint.h"
 
 namespace lane_planner
 {
@@ -66,7 +65,7 @@ struct Element2D
 
 std::vector&lt;Element2D&gt; generateHermiteCurve(const Element2D &amp;p0, const Element2D &amp;v0, const Element2D &amp;p1,
                                             const Element2D &amp;v1, const double vlength = 20);
-std::vector&lt;waypoint_follower_msgs::waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
+std::vector&lt;autoware_msgs::waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
                                                                     const geometry_msgs::Pose &amp;end,
                                                                     const double velocity, const double vlength);
 void createVectorFromPose(const geometry_msgs::Pose &amp;p, tf::Vector3 *v);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -69,7 +69,7 @@ void LaneSelectNode::initForROS()
   sub5_ = nh_.subscribe("/config/lane_select", 1, &amp;LaneSelectNode::callbackFromConfig, this);
 
   // setup publisher
-  pub1_ = nh_.advertise&lt;waypoint_follower_msgs::lane&gt;("base_waypoints", 1);
+  pub1_ = nh_.advertise&lt;autoware_msgs::lane&gt;("base_waypoints", 1);
   pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1);
   pub3_ = nh_.advertise&lt;std_msgs::Int32&gt;("change_flag", 1);
   vis_pub1_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("lane_select_marker", 1);
@@ -183,7 +183,7 @@ void LaneSelectNode::processing()
   resetSubscriptionFlag();
 }
 
-int32_t LaneSelectNode::getClosestLaneChangeWaypointNumber(const std::vector&lt;waypoint_follower_msgs::waypoint&gt; &amp;wps, int32_t cl_wp)
+int32_t LaneSelectNode::getClosestLaneChangeWaypointNumber(const std::vector&lt;autoware_msgs::waypoint&gt; &amp;wps, int32_t cl_wp)
 {
 
   for (uint32_t i = cl_wp; i &lt; wps.size(); i++)
@@ -203,7 +203,7 @@ void LaneSelectNode::createLaneForChange()
   std::get&lt;0&gt;(lane_for_change_).waypoints.shrink_to_fit();
   std::get&lt;1&gt;(lane_for_change_) = -1;
 
-  const waypoint_follower_msgs::lane &amp;cur_lane = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_));
+  const autoware_msgs::lane &amp;cur_lane = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_));
   const int32_t &amp;clst_wp = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
 
   int32_t num_lane_change = getClosestLaneChangeWaypointNumber(cur_lane.waypoints, clst_wp);
@@ -229,7 +229,7 @@ void LaneSelectNode::createLaneForChange()
                          ? current_velocity_.twist.linear.x * lane_change_target_ratio_
                          : lane_change_target_minimum_;
   ROS_INFO("dt : %lf, dt_by_vel : %lf", dt, dt_by_vel);
-  waypoint_follower_msgs::lane &amp;nghbr_lane =
+  autoware_msgs::lane &amp;nghbr_lane =
       static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right
           ? std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_))
           : std::get&lt;0&gt;(tuple_vec_.at(left_lane_idx_));
@@ -255,7 +255,7 @@ void LaneSelectNode::createLaneForChange()
     return;
 
   std::get&lt;0&gt;(lane_for_change_).header.stamp = nghbr_lane.header.stamp;
-  std::vector&lt;waypoint_follower_msgs::waypoint&gt; hermite_wps = generateHermiteCurveForROS(
+  std::vector&lt;autoware_msgs::waypoint&gt; hermite_wps = generateHermiteCurveForROS(
       cur_lane.waypoints.at(num_lane_change).pose.pose, nghbr_lane.waypoints.at(target_num).pose.pose,
       cur_lane.waypoints.at(num_lane_change).twist.twist.linear.x, vlength_hermite_curve_);
 
@@ -582,7 +582,7 @@ void LaneSelectNode::publishVisualizer()
   vis_pub1_.publish(marker_array);
 }
 
-void LaneSelectNode::publishLane(const waypoint_follower_msgs::lane &amp;lane)
+void LaneSelectNode::publishLane(const autoware_msgs::lane &amp;lane)
 {
   // publish global lane
   pub1_.publish(lane);
@@ -603,7 +603,7 @@ void LaneSelectNode::publishChangeFlag(const ChangeFlag flag)
   pub3_.publish(change_flag);
 }
 
-void LaneSelectNode::callbackFromLaneArray(const waypoint_follower_msgs::LaneArrayConstPtr &amp;msg)
+void LaneSelectNode::callbackFromLaneArray(const autoware_msgs::LaneArrayConstPtr &amp;msg)
 {
   tuple_vec_.clear();
   tuple_vec_.shrink_to_fit();
@@ -658,7 +658,7 @@ void LaneSelectNode::callbackFromState(const std_msgs::StringConstPtr &amp;msg)
     processing();
 }
 
-void LaneSelectNode::callbackFromConfig(const runtime_manager::ConfigLaneSelectConstPtr &amp;msg)
+void LaneSelectNode::callbackFromConfig(const autoware_msgs::ConfigLaneSelectConstPtr &amp;msg)
 {
   distance_threshold_ = msg-&gt; distance_threshold_neighbor_lanes;
   lane_change_interval_= msg-&gt;lane_change_interval;
@@ -728,7 +728,7 @@ double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry
 }
 
 // get closest waypoint from current pose
-int32_t getClosestWaypointNumber(const waypoint_follower_msgs::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
+int32_t getClosestWaypointNumber(const autoware_msgs::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
                                  const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number,
                                  const double distance_threshold)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="9" deleted_lines="9">
				<diff>@@ -45,9 +45,9 @@
 #include &lt;tuple&gt;
 
 // User defined includes
-#include "waypoint_follower_msgs/LaneArray.h"
+#include "autoware_msgs/LaneArray.h"
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "runtime_manager/ConfigLaneSelect.h"
+#include "autoware_msgs/ConfigLaneSelect.h"
 #include "hermite_curve.h"
 
 namespace lane_planner
@@ -91,9 +91,9 @@ private:
   int32_t current_lane_idx_;  // the index of the lane we are driving
   int32_t right_lane_idx_;
   int32_t left_lane_idx_;
-  std::vector&lt;std::tuple&lt;waypoint_follower_msgs::lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint,
+  std::vector&lt;std::tuple&lt;autoware_msgs::lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint,
                                                                                      // change_flag
-  std::tuple&lt;waypoint_follower_msgs::lane, int32_t, ChangeFlag&gt; lane_for_change_;
+  std::tuple&lt;autoware_msgs::lane, int32_t, ChangeFlag&gt; lane_for_change_;
   bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_, is_current_state_subscribed_, is_config_subscribed_;
 
   // parameter from runtime manager
@@ -105,11 +105,11 @@ private:
   std::string current_state_;
 
   // callbacks
-  void callbackFromLaneArray(const waypoint_follower_msgs::LaneArrayConstPtr &amp;msg);
+  void callbackFromLaneArray(const autoware_msgs::LaneArrayConstPtr &amp;msg);
   void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr &amp;msg);
   void callbackFromState(const std_msgs::StringConstPtr &amp;msg);
-  void callbackFromConfig(const runtime_manager::ConfigLaneSelectConstPtr &amp;msg);
+  void callbackFromConfig(const autoware_msgs::ConfigLaneSelectConstPtr &amp;msg);
 
   // initializer
   void initForROS();
@@ -128,7 +128,7 @@ private:
   void resetSubscriptionFlag();
   bool isAllTopicsSubscribed();
   void processing();
-  void publishLane(const waypoint_follower_msgs::lane &amp;lane);
+  void publishLane(const autoware_msgs::lane &amp;lane);
   void publishClosestWaypoint(const int32_t clst_wp);
   void publishChangeFlag(const ChangeFlag flag);
   bool getClosestWaypointNumberForEachLanes();
@@ -138,10 +138,10 @@ private:
   void changeLane();
   void updateChangeFlag();
   void createLaneForChange();
-  int32_t getClosestLaneChangeWaypointNumber(const std::vector&lt;waypoint_follower_msgs::waypoint&gt; &amp;wps, int32_t cl_wp);
+  int32_t getClosestLaneChangeWaypointNumber(const std::vector&lt;autoware_msgs::waypoint&gt; &amp;wps, int32_t cl_wp);
 };
 
-int32_t getClosestWaypointNumber(const waypoint_follower_msgs::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
+int32_t getClosestWaypointNumber(const autoware_msgs::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
                                  const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number, const double distance_threshold);
 
 double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geometry_msgs::Point &amp;target2);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_stop\lane_stop.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_stop\lane_stop.cpp" added_lines="14" deleted_lines="14">
				<diff>@@ -30,9 +30,9 @@
 
 #include &lt;ros/console.h&gt;
 
-#include &lt;runtime_manager/ConfigLaneStop.h&gt;
-#include &lt;runtime_manager/traffic_light.h&gt;
-#include &lt;waypoint_follower_msgs/LaneArray.h&gt;
+#include "autoware_msgs/ConfigLaneStop.h"
+#include "autoware_msgs/traffic_light.h"
+#include "autoware_msgs/LaneArray.h"
 
 #include &lt;lane_planner/vmap.hpp&gt;
 
@@ -42,14 +42,14 @@ bool config_manual_detection = true;
 
 ros::Publisher traffic_pub;
 
-waypoint_follower_msgs::LaneArray current_red_lane;
-waypoint_follower_msgs::LaneArray current_green_lane;
+autoware_msgs::LaneArray current_red_lane;
+autoware_msgs::LaneArray current_green_lane;
 
-const waypoint_follower_msgs::LaneArray *previous_lane = &amp;current_red_lane;
+const autoware_msgs::LaneArray *previous_lane = &amp;current_red_lane;
 
-void select_current_lane(const runtime_manager::traffic_light&amp; msg)
+void select_current_lane(const autoware_msgs::traffic_light&amp; msg)
 {
-	const waypoint_follower_msgs::LaneArray *current;
+	const autoware_msgs::LaneArray *current;
 	switch (msg.traffic_light) {
 	case lane_planner::vmap::TRAFFIC_LIGHT_RED:
 		current = &amp;current_red_lane;
@@ -75,29 +75,29 @@ void select_current_lane(const runtime_manager::traffic_light&amp; msg)
 	previous_lane = current;
 }
 
-void receive_auto_detection(const runtime_manager::traffic_light&amp; msg)
+void receive_auto_detection(const autoware_msgs::traffic_light&amp; msg)
 {
 	if (!config_manual_detection)
 		select_current_lane(msg);
 }
 
-void receive_manual_detection(const runtime_manager::traffic_light&amp; msg)
+void receive_manual_detection(const autoware_msgs::traffic_light&amp; msg)
 {
 	if (config_manual_detection)
 		select_current_lane(msg);
 }
 
-void cache_red_lane(const waypoint_follower_msgs::LaneArray&amp; msg)
+void cache_red_lane(const autoware_msgs::LaneArray&amp; msg)
 {
 	current_red_lane = msg;
 }
 
-void cache_green_lane(const waypoint_follower_msgs::LaneArray&amp; msg)
+void cache_green_lane(const autoware_msgs::LaneArray&amp; msg)
 {
 	current_green_lane = msg;
 }
 
-void config_parameter(const runtime_manager::ConfigLaneStop&amp; msg)
+void config_parameter(const autoware_msgs::ConfigLaneStop&amp; msg)
 {
 	config_manual_detection = msg.manual_detection;
 }
@@ -121,7 +121,7 @@ int main(int argc, char **argv)
 	bool pub_waypoint_latch;
 	n.param&lt;bool&gt;("/lane_stop/pub_waypoint_latch", pub_waypoint_latch, true);
 
-	traffic_pub = n.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("/traffic_waypoints_array", pub_waypoint_queue_size,
+	traffic_pub = n.advertise&lt;autoware_msgs::LaneArray&gt;("/traffic_waypoints_array", pub_waypoint_queue_size,
 								pub_waypoint_latch);
 
 	ros::Subscriber light_sub = n.subscribe("/light_color", sub_light_queue_size, receive_auto_detection);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\RosHelpers.h" new_path="ros\src\computing\planning\mission\packages\way_planner\include\RosHelpers.h" added_lines="11" deleted_lines="11">
				<diff>@@ -10,11 +10,11 @@
 
 #include &lt;ros/ros.h&gt;
 
-#include &lt;vector_map_msgs/PointArray.h&gt;
-#include &lt;vector_map_msgs/LaneArray.h&gt;
-#include &lt;vector_map_msgs/NodeArray.h&gt;
-#include &lt;vector_map_msgs/StopLineArray.h&gt;
-#include &lt;vector_map_msgs/DTLaneArray.h&gt;
+#include "vector_map_msgs/PointArray.h"
+#include "vector_map_msgs/LaneArray.h"
+#include "vector_map_msgs/NodeArray.h"
+#include "vector_map_msgs/StopLineArray.h"
+#include "vector_map_msgs/DTLaneArray.h"
 
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
@@ -28,7 +28,7 @@
 //#include &lt;pcl/point_types.h&gt;
 
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "waypoint_follower_msgs/LaneArray.h"
+#include "autoware_msgs/LaneArray.h"
 
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
@@ -127,7 +127,7 @@ public:
 	virtual ~RosHelpers();
 	static void GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform);
 	static void ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
-				waypoint_follower_msgs::LaneArray&amp; laneArray);
+				autoware_msgs::LaneArray&amp; laneArray);
 
 	static void ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; curr_path,
 			const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths,
@@ -138,16 +138,16 @@ public:
 
 	static void ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const PlannerHNS::RoadNetwork&amp; map,	visualization_msgs::MarkerArray&amp; markerArray);
 
-	static void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray);
+	static void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const autoware_msgs::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray);
 
-	static void createGlobalLaneArrayVelocityMarker(const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array
+	static void createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
 			, visualization_msgs::MarkerArray&amp; markerArray);
 
-	static void createGlobalLaneArrayOrientationMarker(const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array
+	static void createGlobalLaneArrayOrientationMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
 			, visualization_msgs::MarkerArray&amp; markerArray);
 
 	static void ConvertFromPlannerHPointsToAutowarePathFormat(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path,
-			waypoint_follower_msgs::LaneArray&amp; laneArray);
+			autoware_msgs::LaneArray&amp; laneArray);
 
 	static void FindIncommingBranches(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; globalPaths, const PlannerHNS::WayPoint&amp; currPose, const double&amp; min_distance,
 			std::vector&lt;PlannerHNS::WayPoint*&gt;&amp; branches, PlannerHNS::WayPoint* currOptions);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\way_planner_core.h" new_path="ros\src\computing\planning\mission\packages\way_planner\include\way_planner_core.h" added_lines="12" deleted_lines="13">
				<diff>@@ -38,16 +38,16 @@
 //#include &lt;map_file/NodeArray.h&gt;
 //#include &lt;map_file/StopLineArray.h&gt;
 //#include &lt;map_file/DTLaneArray.h&gt;
-#include &lt;vector_map_msgs/PointArray.h&gt;
-#include &lt;vector_map_msgs/LaneArray.h&gt;
-#include &lt;vector_map_msgs/NodeArray.h&gt;
-#include &lt;vector_map_msgs/StopLineArray.h&gt;
-#include &lt;vector_map_msgs/DTLaneArray.h&gt;
-#include &lt;vector_map_msgs/LineArray.h&gt;
-#include &lt;vector_map_msgs/AreaArray.h&gt;
-#include &lt;vector_map_msgs/SignalArray.h&gt;
-#include &lt;vector_map_msgs/StopLine.h&gt;
-#include &lt;vector_map_msgs/VectorArray.h&gt;
+#include "vector_map_msgs/PointArray.h"
+#include "vector_map_msgs/LaneArray.h"
+#include "vector_map_msgs/NodeArray.h"
+#include "vector_map_msgs/StopLineArray.h"
+#include "vector_map_msgs/DTLaneArray.h"
+#include "vector_map_msgs/LineArray.h"
+#include "vector_map_msgs/AreaArray.h"
+#include "vector_map_msgs/SignalArray.h"
+#include "vector_map_msgs/StopLine.h"
+#include "vector_map_msgs/VectorArray.h"
 
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
@@ -60,8 +60,7 @@
 
 #include &lt;std_msgs/Int8.h&gt;
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "waypoint_follower_msgs/LaneArray.h"
-#include "vehicle_socket/CanInfo.h"
+#include "autoware_msgs/CanInfo.h"
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
 #include "MappingHelpers.h"
@@ -196,7 +195,7 @@ private:
   void callbackGetStartPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;input);
   void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg);
   void callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr&amp; msg);
-  void callbackGetCanInfo(const vehicle_socket::CanInfoConstPtr &amp;msg);
+  void callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg);
   void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg);
 
   void callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\RosHelpers.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\RosHelpers.cpp" added_lines="11" deleted_lines="11">
				<diff>@@ -42,13 +42,13 @@ void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::s
 }
 
 void RosHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path,
-		waypoint_follower_msgs::LaneArray&amp; laneArray)
+		autoware_msgs::LaneArray&amp; laneArray)
 {
-	waypoint_follower_msgs::lane l;
+	autoware_msgs::lane l;
 
 	for(unsigned int i=0; i &lt; path.size(); i++)
 	{
-		waypoint_follower_msgs::waypoint wp;
+		autoware_msgs::waypoint wp;
 		wp.pose.pose.position.x = path.at(i).x;
 		wp.pose.pose.position.y = path.at(i).y;
 		wp.pose.pose.position.z = path.at(i).z;
@@ -63,13 +63,13 @@ void RosHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(const std::vector
 }
 
 void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
-		waypoint_follower_msgs::LaneArray&amp; laneArray)
+		autoware_msgs::LaneArray&amp; laneArray)
 {
-	waypoint_follower_msgs::lane l;
+	autoware_msgs::lane l;
 
 	for(unsigned int i=0; i &lt; path.size(); i++)
 	{
-		waypoint_follower_msgs::waypoint wp;
+		autoware_msgs::waypoint wp;
 		wp.pose.pose.position.x = path.at(i).pos.x;
 		wp.pose.pose.position.y = path.at(i).pos.y;
 		wp.pose.pose.position.z = path.at(i).pos.z;
@@ -109,7 +109,7 @@ void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;Plann
 void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const PlannerHNS::RoadNetwork&amp; map,	visualization_msgs::MarkerArray&amp; markerArray)
 {
 	markerArray.markers.clear();
-	waypoint_follower_msgs::LaneArray map_lane_array;
+	autoware_msgs::LaneArray map_lane_array;
 	for(unsigned int i = 0; i&lt; map.roadSegments.size(); i++)
 		for(unsigned int j = 0; j &lt; map.roadSegments.at(i).Lanes.size(); j++)
 			RosHelpers::ConvertFromPlannerHToAutowarePathFormat(map.roadSegments.at(i).Lanes.at(j).points, map_lane_array);
@@ -173,7 +173,7 @@ void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const Planne
 			  ns_id &lt;&lt; map.stopLines.at(i).id;
 			  stop_waypoint_marker.ns =ns_id.str();
 
-			  waypoint_follower_msgs::LaneArray lane_array_2;
+			  autoware_msgs::LaneArray lane_array_2;
 			  RosHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(map.stopLines.at(i).points, lane_array_2);
 
 			  stop_waypoint_marker.points.clear();
@@ -346,7 +346,7 @@ void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vec
 }
 
 void RosHelpers::createGlobalLaneArrayMarker(std_msgs::ColorRGBA color,
-		const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray)
+		const autoware_msgs::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray)
 {
   visualization_msgs::Marker lane_waypoint_marker;
   lane_waypoint_marker.header.frame_id = "map";
@@ -377,7 +377,7 @@ void RosHelpers::createGlobalLaneArrayMarker(std_msgs::ColorRGBA color,
 
 }
 
-void RosHelpers::createGlobalLaneArrayVelocityMarker(const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array
+void RosHelpers::createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
 		, visualization_msgs::MarkerArray&amp; markerArray)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
@@ -425,7 +425,7 @@ void RosHelpers::createGlobalLaneArrayVelocityMarker(const waypoint_follower_msg
                                        tmp_marker_array.markers.end());
 }
 
-void RosHelpers::createGlobalLaneArrayOrientationMarker(const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array
+void RosHelpers::createGlobalLaneArrayOrientationMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
 		, visualization_msgs::MarkerArray&amp; markerArray)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -34,7 +34,7 @@
  * @param Start_Position in simulation environment like rviz, this node require the user to select start position using "2D Pose Estimate" button and select starting position from the global path, //
  * if localization node is working and ndt_pose or curr_pose messages are published the node will use localization as starting position instead of "2D Pose Estimate"
  * @param Goal_Position destination to generate global plan to. if "replan" option selection used can choose multiple goal positions. goal positions are selected from Rviz using "2D Nav Goal" button.
- * @return global , reference path as list of waypoints. data type is "waypoint_follower_msgs::LaneArray" , and the topic name is "lane_waypoints_array"
+ * @return global , reference path as list of waypoints. data type is "autoware_msgs::LaneArray" , and the topic name is "lane_waypoints_array"
  */
 
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -89,7 +89,7 @@ way_planner_core::way_planner_core()
 	m_OriginPos.position.y  = transform.getOrigin().y();
 	m_OriginPos.position.z  = transform.getOrigin().z();
 
-	pub_Paths = nh.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("lane_waypoints_array", 1, true);
+	pub_Paths = nh.advertise&lt;autoware_msgs::LaneArray&gt;("lane_waypoints_array", 1, true);
 	pub_PathsRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("global_waypoints_rviz", 1, true);
 	pub_StartPointRviz = nh.advertise&lt;visualization_msgs::Marker&gt;("Global_StartPoint_rviz", 1, true);
 	pub_GoalPointRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("Global_GoalPoints_rviz", 1, true);
@@ -225,7 +225,7 @@ void way_planner_core::callbackGetVehicleStatus(const geometry_msgs::TwistStampe
 	UtilityHNS::UtilityH::GetTickCount(m_VehicleState.tStamp);
 }
 
-void way_planner_core::callbackGetCanInfo(const vehicle_socket::CanInfoConstPtr &amp;msg)
+void way_planner_core::callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
 {
 	m_VehicleState.speed = msg-&gt;speed/3.6;
 	m_VehicleState.steer = msg-&gt;angle * 0.45 / 660;
@@ -436,7 +436,7 @@ if(m_params.bEnableHMI)
 
 void way_planner_core::VisualizeAndSend(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; generatedTotalPaths)
 {
-	waypoint_follower_msgs::LaneArray lane_array;
+	autoware_msgs::LaneArray lane_array;
 	visualization_msgs::MarkerArray pathsToVisualize;
 
 	for(unsigned int i=0; i &lt; generatedTotalPaths.size(); i++)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_avoid.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_avoid.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -29,12 +29,12 @@
  */
 
 #include &lt;ros/ros.h&gt;
-#include &lt;waypoint_follower_msgs/lane.h&gt;
+#include &lt;autoware_msgs/lane.h&gt;
 #include &lt;iostream&gt;
 
 static ros::Publisher _pub;
 
-void callback(const waypoint_follower_msgs::lane &amp;msg)
+void callback(const autoware_msgs::lane &amp;msg)
 {
     _pub.publish(msg);
 }
@@ -46,7 +46,7 @@ int main(int argc, char **argv)
 
     ros::NodeHandle nh;
     ros::Subscriber twist_sub = nh.subscribe("temporal_waypoints", 1, callback);
-    _pub = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("final_waypoints", 1000,true);
+    _pub = nh.advertise&lt;autoware_msgs::lane&gt;("final_waypoints", 1000,true);
 
     ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -248,7 +248,7 @@ void CrossWalk::setCrossWalkPoints()
   set_points = true;
 }
 
-int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const waypoint_follower_msgs::lane&amp; lane, const int search_distance)
+int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const autoware_msgs::lane&amp; lane, const int search_distance)
 {
   if (!set_points || closest_waypoint &lt; 0)
     return -1;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" added_lines="1" deleted_lines="1">
				<diff>@@ -63,7 +63,7 @@ public:
   geometry_msgs::Point getPoint(const int &amp;pid) const;
   void calcCenterPoints();
   void setCrossWalkPoints();
-  int findClosestCrosswalk(const int closest_waypoint, const waypoint_follower_msgs::lane&amp; lane, const int search_distance);
+  int findClosestCrosswalk(const int closest_waypoint, const autoware_msgs::lane&amp; lane, const int search_distance);
   int getSize() const
   {
     return detection_points_.size();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -89,7 +89,7 @@ void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points
   //obstacle_pub.publish(marker);
 }
 
-void displayDetectionRange(const waypoint_follower_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const int closest_waypoint, const EControl &amp;kind, const int obstacle_waypoint, const double stop_range, const double deceleration_range, const ros::Publisher&amp; detection_range_pub)
+void displayDetectionRange(const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const int closest_waypoint, const EControl &amp;kind, const int obstacle_waypoint, const double stop_range, const double deceleration_range, const ros::Publisher&amp; detection_range_pub)
 {
   // set up for marker array
   visualization_msgs::MarkerArray marker_array;
@@ -231,7 +231,7 @@ EControl crossWalkDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const
   return EControl::KEEP;  // find no obstacles
 }
 
-int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const waypoint_follower_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, double stop_range, double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose, ObstaclePoints* obstacle_points)
+int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, double stop_range, double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose, ObstaclePoints* obstacle_points)
 {
   int stop_obstacle_waypoint = -1;
   // start search from the closest waypoint
@@ -290,7 +290,7 @@ int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int c
   return stop_obstacle_waypoint;
 }
 
-int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const waypoint_follower_msgs::lane&amp; lane, const double stop_range, const double deceleration_range, const double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose, ObstaclePoints* obstacle_points)
+int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const autoware_msgs::lane&amp; lane, const double stop_range, const double deceleration_range, const double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose, ObstaclePoints* obstacle_points)
 {
   int decelerate_obstacle_waypoint = -1;
   // start search from the closest waypoint
@@ -340,7 +340,7 @@ int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const
 
 
 // Detect an obstacle by using pointcloud
-EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const waypoint_follower_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo&amp; vs_info, int* obstacle_waypoint, ObstaclePoints* obstacle_points)
+EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo&amp; vs_info, int* obstacle_waypoint, ObstaclePoints* obstacle_points)
 {
   if (points.empty() == true || closest_waypoint &lt; 0)
     return EControl::KEEP;
@@ -388,7 +388,7 @@ EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int
 
 }
 
-EControl obstacleDetection(int closest_waypoint, const waypoint_follower_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo vs_info, const ros::Publisher&amp; detection_range_pub, const ros::Publisher&amp; obstacle_pub, int* obstacle_waypoint)
+EControl obstacleDetection(int closest_waypoint, const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo vs_info, const ros::Publisher&amp; detection_range_pub, const ros::Publisher&amp; obstacle_pub, int* obstacle_waypoint)
 {
   ObstaclePoints obstacle_points;
   EControl detection_result = pointsDetection(vs_info.getPoints(), closest_waypoint, lane, crosswalk, vs_info, obstacle_waypoint, &amp;obstacle_points);
@@ -500,7 +500,7 @@ int main(int argc, char **argv)
 
   // publisher
   ros::Publisher detection_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 0);
-  ros::Publisher temporal_waypoints_pub = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("temporal_waypoints", 1000, true);
+  ros::Publisher temporal_waypoints_pub = nh.advertise&lt;autoware_msgs::lane&gt;("temporal_waypoints", 1000, true);
   ros::Publisher obstacle_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("obstacle", 0);
 
   ros::Rate loop_rate(LOOP_RATE);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -54,7 +54,7 @@ void VelocitySetInfo::clearPoints()
   points_.clear();
 }
 
-void VelocitySetInfo::configCallback(const runtime_manager::ConfigVelocitySetConstPtr &amp;config)
+void VelocitySetInfo::configCallback(const autoware_msgs::ConfigVelocitySetConstPtr &amp;config)
 {
   stop_distance_ = config-&gt;others_distance;
   stop_range_ = config-&gt;detection_range;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" added_lines="2" deleted_lines="2">
				<diff>@@ -36,7 +36,7 @@
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 
-#include "runtime_manager/ConfigVelocitySet.h"
+#include "autoware_msgs/ConfigVelocitySet.h"
 
 class VelocitySetInfo
 {
@@ -63,7 +63,7 @@ class VelocitySetInfo
   ~VelocitySetInfo();
 
   // ROS Callback
-  void configCallback(const runtime_manager::ConfigVelocitySetConstPtr &amp;msg);
+  void configCallback(const autoware_msgs::ConfigVelocitySetConstPtr &amp;msg);
   void pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg);
   void controlPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void localizerPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -63,7 +63,7 @@ void VelocitySetPath::setTemporalWaypoints(int temporal_waypoints_size, int clos
   temporal_waypoints_.header = new_waypoints_.header;
   temporal_waypoints_.increment = new_waypoints_.increment;
   // push current pose
-  waypoint_follower_msgs::waypoint current_point;
+  autoware_msgs::waypoint current_point;
 
   current_point.pose = control_pose;
   current_point.twist = new_waypoints_.waypoints[closest_waypoint].twist;
@@ -222,7 +222,7 @@ double VelocitySetPath::calcInterval(const int begin, const int end) const
 }
 
 
-void VelocitySetPath::waypointsCallback(const waypoint_follower_msgs::laneConstPtr&amp; msg)
+void VelocitySetPath::waypointsCallback(const autoware_msgs::laneConstPtr&amp; msg)
 {
   prev_waypoints_ = *msg;
   new_waypoints_ = *msg;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" added_lines="8" deleted_lines="8">
				<diff>@@ -31,14 +31,14 @@
 #ifndef VELOCITY_SET_PATH_H
 #define VELOCITY_SET_PATH_H
 
-#include &lt;waypoint_follower_msgs/lane.h&gt;
+#include "autoware_msgs/lane.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 class VelocitySetPath
 {
  private:
-  waypoint_follower_msgs::lane prev_waypoints_;
-  waypoint_follower_msgs::lane new_waypoints_;
-  waypoint_follower_msgs::lane temporal_waypoints_;
+  autoware_msgs::lane prev_waypoints_;
+  autoware_msgs::lane new_waypoints_;
+  autoware_msgs::lane temporal_waypoints_;
   bool set_path_;
   double current_vel_;
 
@@ -60,22 +60,22 @@ class VelocitySetPath
   void initializeNewWaypoints();
 
   // ROS Callbacks
-  void waypointsCallback(const waypoint_follower_msgs::laneConstPtr&amp; msg);
+  void waypointsCallback(const autoware_msgs::laneConstPtr&amp; msg);
   void currentVelocityCallback(const geometry_msgs::TwistStampedConstPtr&amp; msg);
 
   double calcInterval(const int begin, const int end) const;
 
-  waypoint_follower_msgs::lane getPrevWaypoints() const
+  autoware_msgs::lane getPrevWaypoints() const
   {
     return prev_waypoints_;
   }
 
-  waypoint_follower_msgs::lane getNewWaypoints() const
+  autoware_msgs::lane getNewWaypoints() const
   {
     return new_waypoints_;
   }
 
-  waypoint_follower_msgs::lane getTemporalWaypoints() const
+  autoware_msgs::lane getTemporalWaypoints() const
   {
     return temporal_waypoints_;
   }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\include\RosHelpers.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\RosHelpers.h" added_lines="14" deleted_lines="16">
				<diff>@@ -13,16 +13,16 @@
 #include "PlannerCommonDef.h"
 #include "LocalPlannerH.h"
 
-#include &lt;vector_map_msgs/PointArray.h&gt;
-#include &lt;vector_map_msgs/LaneArray.h&gt;
-#include &lt;vector_map_msgs/NodeArray.h&gt;
-#include &lt;vector_map_msgs/StopLineArray.h&gt;
-#include &lt;vector_map_msgs/DTLaneArray.h&gt;
-#include &lt;vector_map_msgs/LineArray.h&gt;
-#include &lt;vector_map_msgs/AreaArray.h&gt;
-#include &lt;vector_map_msgs/SignalArray.h&gt;
-#include &lt;vector_map_msgs/StopLine.h&gt;
-#include &lt;vector_map_msgs/VectorArray.h&gt;
+#include "vector_map_msgs/PointArray.h"
+#include "vector_map_msgs/LaneArray.h"
+#include "vector_map_msgs/NodeArray.h"
+#include "vector_map_msgs/StopLineArray.h"
+#include "vector_map_msgs/DTLaneArray.h"
+#include "vector_map_msgs/LineArray.h"
+#include "vector_map_msgs/AreaArray.h"
+#include "vector_map_msgs/SignalArray.h"
+#include "vector_map_msgs/StopLine.h"
+#include "vector_map_msgs/VectorArray.h"
 
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
@@ -35,12 +35,10 @@
 #include &lt;pcl/io/pcd_io.h&gt;
 #include &lt;pcl/point_types.h&gt;
 
-#include &lt;lidar_tracker/centroids.h&gt;
-#include &lt;lidar_tracker/CloudCluster.h&gt;
-#include &lt;lidar_tracker/CloudClusterArray.h&gt;
+#include "autoware_msgs/CloudClusterArray.h"
 
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "waypoint_follower_msgs/LaneArray.h"
+#include "autoware_msgs/LaneArray.h"
 
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
@@ -177,7 +175,7 @@ public:
 	virtual ~RosHelpers();
 	static void GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform);
 	static void ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
-				waypoint_follower_msgs::lane &amp; trajectory);
+				autoware_msgs::lane &amp; trajectory);
 
 	static void ConvertFromPlannerHRectangleToAutowareRviz(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; safety_rect,
 			visualization_msgs::Marker&amp; marker);
@@ -195,7 +193,7 @@ public:
 			std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; impObstacles);
 
 	static void ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::CAR_BASIC_INFO&amp; car_info,
-			const lidar_tracker::CloudClusterArray&amp; clusters,
+			const autoware_msgs::CloudClusterArray&amp; clusters,
 			std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; impObstacles, int&amp; nOriginalPoints, int&amp; nContourPoints);
 
 	static void ConvertFromPlannerObstaclesToAutoware(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" added_lines="9" deleted_lines="9">
				<diff>@@ -47,11 +47,11 @@
 #include &lt;std_msgs/Int8.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "waypoint_follower_msgs/LaneArray.h"
-#include "vehicle_socket/CanInfo.h"
+#include "autoware_msgs/LaneArray.h"
+#include "autoware_msgs/CanInfo.h"
 
-#include &lt;lidar_tracker/CloudCluster.h&gt;
-#include &lt;lidar_tracker/CloudClusterArray.h&gt;
+#include "autoware_msgs/CloudCluster.h"
+#include "autoware_msgs/CloudClusterArray.h"
 
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
@@ -212,16 +212,16 @@ protected:
 	// Callback function for subscriber.
 	void callbackGetInitPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;input);
 	void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg);
-	void callbackGetCloudClusters(const lidar_tracker::CloudClusterArrayConstPtr&amp; msg);
+	void callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr&amp; msg);
 	void callbackGetBoundingBoxes(const jsk_recognition_msgs::BoundingBoxArrayConstPtr&amp; msg);
 	void callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr&amp; msg);
-	void callbackGetCanInfo(const vehicle_socket::CanInfoConstPtr &amp;msg);
+	void callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg);
 	void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg);
 	void callbackGetEmergencyStop(const std_msgs::Int8&amp; msg);
 	void callbackGetTrafficLight(const std_msgs::Int8&amp; msg);
 	void callbackGetOutsideControl(const std_msgs::Int8&amp; msg);
-	void callbackGetAStarPath(const waypoint_follower_msgs::LaneArrayConstPtr&amp; msg);
-	void callbackGetWayPlannerPath(const waypoint_follower_msgs::LaneArrayConstPtr&amp; msg);
+	void callbackGetAStarPath(const autoware_msgs::LaneArrayConstPtr&amp; msg);
+	void callbackGetWayPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp; msg);
 	void callbackGetCostMap(const nav_msgs::OccupancyGrid&amp; msg);
 
 
@@ -245,7 +245,7 @@ protected:
   //Helper Functions
   void UpdatePlanningParams();
 
-  lidar_tracker::CloudCluster GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::PointStamped&amp; centerPose);
+  autoware_msgs::CloudCluster GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::PointStamped&amp; centerPose);
 
 #ifdef DATASET_GENERATION_BLOCK
 private:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\RosHelpers.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\RosHelpers.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -51,12 +51,12 @@ void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::s
 }
 
 void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
-		waypoint_follower_msgs::lane&amp; trajectory)
+		autoware_msgs::lane&amp; trajectory)
 {
 	trajectory.waypoints.clear();
 	for(unsigned int i=iStart; i &lt; path.size(); i++)
 	{
-		waypoint_follower_msgs::waypoint wp;
+		autoware_msgs::waypoint wp;
 		wp.pose.pose.position.x = path.at(i).pos.x;
 		wp.pose.pose.position.y = path.at(i).pos.y;
 		wp.pose.pose.position.z = path.at(i).pos.z;
@@ -609,7 +609,7 @@ void RosHelpers::ConvertFromAutowareBoundingBoxObstaclesToPlannerH(const jsk_rec
 }
 
 void RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::CAR_BASIC_INFO&amp; car_info,
-		const lidar_tracker::CloudClusterArray&amp; clusters, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list,
+		const autoware_msgs::CloudClusterArray&amp; clusters, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list,
 		int&amp; nOriginalPoints, int&amp; nContourPoints)
 {
 	PlannerHNS::Mat3 rotationMat(-currState.pos.a);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" added_lines="10" deleted_lines="10">
				<diff>@@ -95,8 +95,8 @@ PlannerX::PlannerX()
 	m_OriginPos.position.z  = transform.getOrigin().z();
 
 
-	pub_LocalPath = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("final_waypoints", 100,true);
-	pub_LocalBasePath = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("base_waypoints", 100,true);
+	pub_LocalPath = nh.advertise&lt;autoware_msgs::lane&gt;("final_waypoints", 100,true);
+	pub_LocalBasePath = nh.advertise&lt;autoware_msgs::lane&gt;("base_waypoints", 100,true);
 	pub_ClosestIndex = nh.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 100,true);
 
 	pub_BehaviorState = nh.advertise&lt;geometry_msgs::TwistStamped&gt;("current_behavior", 1);
@@ -465,7 +465,7 @@ void PlannerX::callbackGetRvizPoint(const geometry_msgs::PointStampedConstPtr&amp; m
 	point.point.y = msg-&gt;point.y+m_OriginPos.position.y;
 	point.point.z = msg-&gt;point.z+m_OriginPos.position.z;
 
-	lidar_tracker::CloudClusterArray clusters_array;
+	autoware_msgs::CloudClusterArray clusters_array;
 	clusters_array.clusters.push_back(GenerateSimulatedObstacleCluster(width, length, height, 50, point));
 	m_OriginalClusters.clear();
 	int nNum1, nNum2;
@@ -597,9 +597,9 @@ void PlannerX::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp;
 #endif
 }
 
-lidar_tracker::CloudCluster PlannerX::GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::PointStamped&amp; centerPose)
+autoware_msgs::CloudCluster PlannerX::GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::PointStamped&amp; centerPose)
 {
-	lidar_tracker::CloudCluster cluster;
+	autoware_msgs::CloudCluster cluster;
 	cluster.centroid_point.point = centerPose.point;
 	cluster.dimensions.x = x_rand;
 	cluster.dimensions.y = y_rand;
@@ -631,7 +631,7 @@ lidar_tracker::CloudCluster PlannerX::GenerateSimulatedObstacleCluster(const dou
 	return cluster;
 }
 
-void PlannerX::callbackGetCloudClusters(const lidar_tracker::CloudClusterArrayConstPtr&amp; msg)
+void PlannerX::callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr&amp; msg)
 {
 	timespec timerTemp;
 	UtilityHNS::UtilityH::GetTickCount(timerTemp);
@@ -681,7 +681,7 @@ void PlannerX::callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPt
 	//std::cout &lt;&lt; "PlannerX: Read Status Twist_cmd ("&lt;&lt; m_VehicleState.speed &lt;&lt; ", " &lt;&lt; m_VehicleState.steer&lt;&lt;")" &lt;&lt; std::endl;
 }
 
-void PlannerX::callbackGetCanInfo(const vehicle_socket::CanInfoConstPtr &amp;msg)
+void PlannerX::callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
 {
 	m_VehicleState.speed = msg-&gt;speed/3.6;
 	m_VehicleState.steer = msg-&gt;angle * m_LocalPlanner.m_CarInfo.max_steer_angle / m_LocalPlanner.m_CarInfo.max_steer_value;
@@ -730,7 +730,7 @@ void PlannerX::callbackGetOutsideControl(const std_msgs::Int8&amp; msg)
 	m_bOutsideControl  = msg.data;
 }
 
-void PlannerX::callbackGetAStarPath(const waypoint_follower_msgs::LaneArrayConstPtr&amp; msg)
+void PlannerX::callbackGetAStarPath(const autoware_msgs::LaneArrayConstPtr&amp; msg)
 {
 	if(msg-&gt;lanes.size() &gt; 0)
 	{
@@ -753,7 +753,7 @@ void PlannerX::callbackGetAStarPath(const waypoint_follower_msgs::LaneArrayConst
 	}
 }
 
-void PlannerX::callbackGetWayPlannerPath(const waypoint_follower_msgs::LaneArrayConstPtr&amp; msg)
+void PlannerX::callbackGetWayPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp; msg)
 {
 	if(msg-&gt;lanes.size() &gt; 0)
 	{
@@ -1026,7 +1026,7 @@ void PlannerX::PlannerMainLoop()
 		}
 
 
-		waypoint_follower_msgs::lane current_trajectory;
+		autoware_msgs::lane current_trajectory;
 		std_msgs::Int32 closest_waypoint;
 		PlannerHNS::RelativeInfo info;
 		PlannerHNS::PlanningHelpers::GetRelativeInfo(m_LocalPlanner.m_Path, m_LocalPlanner.state, info);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\ff_waypoint_follower_core.h" new_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\ff_waypoint_follower_core.h" added_lines="2" deleted_lines="3">
				<diff>@@ -35,7 +35,6 @@
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
-#include &lt;runtime_manager/traffic_light.h&gt;
 
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
@@ -46,7 +45,7 @@
 #include &lt;tf/tf.h&gt;
 #include &lt;std_msgs/Int8.h&gt;
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "waypoint_follower_msgs/LaneArray.h"
+#include "autoware_msgs/LaneArray.h"
 #include "TrajectoryFollower.h"
 //#include "CarState.h"
 #include "LocalPlannerH.h"
@@ -166,7 +165,7 @@ protected:
 	void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg);
 	void callbackGetCurrentVelocity(const geometry_msgs::TwistStampedConstPtr&amp; msg);
 	void callbackGetBehaviorState(const geometry_msgs::TwistStampedConstPtr&amp; msg );
-	void callbackGetCurrentTrajectory(const waypoint_follower_msgs::laneConstPtr&amp; msg);
+	void callbackGetCurrentTrajectory(const autoware_msgs::laneConstPtr&amp; msg);
 	//void callbackGetAutowareOdom(const geometry_msgs::TwistStampedConstPtr &amp;msg);
 	void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg);
 	void callbackGetOutsideControl(const std_msgs::Int8&amp; msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower_core.cpp" new_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -28,7 +28,7 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #include "ff_waypoint_follower_core.h"
-#include "waypoint_follower_msgs/LaneArray.h"
+#include "autoware_msgs/LaneArray.h"
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;visualization_msgs/InteractiveMarkerPose.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
@@ -266,7 +266,7 @@ void FFSteerControl::callbackGetBehaviorState(const geometry_msgs::TwistStampedC
 	bNewBehaviorState = true;
 }
 
-void FFSteerControl::callbackGetCurrentTrajectory(const waypoint_follower_msgs::laneConstPtr &amp;msg)
+void FFSteerControl::callbackGetCurrentTrajectory(const autoware_msgs::laneConstPtr &amp;msg)
 {
 	m_State.m_Path.clear();
 	for(unsigned int i = 0 ; i &lt; msg-&gt;waypoints.size(); i++)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_trajectory_gen\lattice_trajectory_gen.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_trajectory_gen\lattice_trajectory_gen.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -49,10 +49,10 @@
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;std_msgs/Float32.h&gt;
 #include &lt;std_msgs/Float64MultiArray.h&gt;
-#include "runtime_manager/ConfigWaypointFollower.h"
+#include "autoware_msgs/ConfigWaypointFollower.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "libtraj_gen.h"
-#include "vehicle_socket/CanInfo.h"
+#include "autoware_msgs/CanInfo.h"
 //#include &lt;dbw_mkz_msgs/SteeringReport.h&gt;
 
 
@@ -102,7 +102,7 @@ static double g_minimum_look_ahead_threshold = 6.0; // the next waypoint must be
 
 static WayPoints g_current_waypoints;
 
-static void ConfigCallback(const runtime_manager::ConfigWaypointFollowerConstPtr &amp;config)
+static void ConfigCallback(const autoware_msgs::ConfigWaypointFollowerConstPtr &amp;config)
 {
   g_param_flag = config-&gt;param_flag;
   g_lookahead_threshold = config-&gt;lookahead_distance;
@@ -124,7 +124,7 @@ static void currentVelCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg)
   g_current_velocity = msg-&gt;twist.linear.x;
 }
 
-static void WayPointCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg)
+static void WayPointCallback(const autoware_msgs::laneConstPtr &amp;msg)
 {
   g_current_waypoints.setPath(*msg);
   g_waypoint_set = true;
@@ -165,7 +165,7 @@ static double getLookAheadThreshold(int waypoint)
     return current_velocity_mps * g_look_ahead_threshold_calc_ratio;
 }
 
-static void canInfoCallback(const vehicle_socket::CanInfoConstPtr &amp;msg)
+static void canInfoCallback(const autoware_msgs::CanInfoConstPtr &amp;msg)
 {
   double steering_wheel_angle = msg-&gt;angle;
   //g_current_velocity = (msg-&gt;speed)*(1000.00/3600);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_twist_convert\lattice_twist_convert.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_twist_convert\lattice_twist_convert.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -51,7 +51,6 @@
 #include &lt;std_msgs/MultiArrayLayout.h&gt;
 #include &lt;std_msgs/MultiArrayDimension.h&gt;
 #include &lt;std_msgs/Float64MultiArray.h&gt;
-#include "runtime_manager/ConfigWaypointFollower.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "libtraj_gen.h"
 #include &lt;vector&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_velocity_set\lattice_velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_velocity_set\lattice_velocity_set.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -43,10 +43,10 @@
 #include &lt;std_msgs/String.h&gt;
 #include &lt;std_msgs/Float32.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
-#include &lt;runtime_manager/ConfigLatticeVelocitySet.h&gt;
+#include "autoware_msgs/ConfigLatticeVelocitySet.h"
 #include &lt;iostream&gt;
 
-#include "waypoint_follower_msgs/lane.h"
+#include "autoware_msgs/lane.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "libvelocity_set.h"
 
@@ -97,7 +97,7 @@ WayPoints g_path_dk;
 class PathVset : public WayPoints
 {
 private:
-  waypoint_follower_msgs::lane temporal_waypoints_;
+  autoware_msgs::lane temporal_waypoints_;
 
 public:
   void changeWaypoints(int stop_waypoint);
@@ -106,7 +106,7 @@ public:
   void setDeceleration();
   bool checkWaypoint(int num, const char *name) const;
   void setTemporalWaypoints();
-  waypoint_follower_msgs::lane getTemporalWaypoints() const
+  autoware_msgs::lane getTemporalWaypoints() const
   {
     return temporal_waypoints_;
   }
@@ -138,7 +138,7 @@ void PathVset::setTemporalWaypoints()
   temporal_waypoints_.header = current_waypoints_.header;
   temporal_waypoints_.increment = current_waypoints_.increment;
   // push current pose
-  waypoint_follower_msgs::waypoint current_point;
+  autoware_msgs::waypoint current_point;
 
   current_point.pose = g_control_pose;
   current_point.twist = current_waypoints_.waypoints[g_closest_waypoint].twist;
@@ -279,7 +279,7 @@ void PathVset::changeWaypoints(int stop_waypoint)
 
     changed_vel = sqrt(2.0 * g_decel * (interval * i));  // sqrt(2*a*x)
 
-    waypoint_follower_msgs::waypoint initial_waypoint = g_path_dk.getCurrentWaypoints().waypoints[num];
+    autoware_msgs::waypoint initial_waypoint = g_path_dk.getCurrentWaypoints().waypoints[num];
     if (changed_vel &gt; initial_waypoint.twist.twist.linear.x)
     {  // avoid acceleration
       current_waypoints_.waypoints[num].twist.twist.linear.x = initial_waypoint.twist.twist.linear.x;
@@ -312,7 +312,7 @@ void PathVset::changeWaypoints(int stop_waypoint)
 //          Callback
 //===============================
 
-void configCallback(const runtime_manager::ConfigLatticeVelocitySetConstPtr &amp;config)
+void configCallback(const autoware_msgs::ConfigLatticeVelocitySetConstPtr &amp;config)
 {
   g_others_distance = config-&gt;others_distance;
   g_detection_range = config-&gt;detection_range;
@@ -330,7 +330,7 @@ void currentVelCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg)
   g_current_vel = msg-&gt;twist.linear.x;
 }
 
-void baseWaypointCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg)
+void baseWaypointCallback(const autoware_msgs::laneConstPtr &amp;msg)
 {
   g_path_dk.setPath(*msg);
   g_path_change.setPath(*msg);
@@ -838,7 +838,7 @@ int main(int argc, char **argv)
 
   g_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 0);
   g_sound_pub = nh.advertise&lt;std_msgs::String&gt;("sound_player", 10);
-  g_temporal_waypoints_pub = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("temporal_waypoints", 1000, true);
+  g_temporal_waypoints_pub = nh.advertise&lt;autoware_msgs::lane&gt;("temporal_waypoints", 1000, true);
   ros::Publisher closest_waypoint_pub;
   closest_waypoint_pub = nh.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1000);
   g_obstacle_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("obstacle", 0);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\path_select\path_select.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\path_select\path_select.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -29,12 +29,12 @@
  */
 
 #include &lt;ros/ros.h&gt;
-#include &lt;waypoint_follower_msgs/lane.h&gt;
+#include "autoware_msgs/lane.h"
 #include &lt;iostream&gt;
 
 static ros::Publisher _pub;
 
-void callback(const waypoint_follower_msgs::lane &amp;msg)
+void callback(const autoware_msgs::lane &amp;msg)
 {
     _pub.publish(msg);
 }
@@ -46,7 +46,7 @@ int main(int argc, char **argv)
 
     ros::NodeHandle nh;
     ros::Subscriber twist_sub = nh.subscribe("temporal_waypoints", 1, callback);
-    _pub = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("final_waypoints", 1000,true);
+    _pub = nh.advertise&lt;autoware_msgs::lane&gt;("final_waypoints", 1000,true);
 
     ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\OpenPlannerSimulator_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulator\include\OpenPlannerSimulator_core.h" added_lines="5" deleted_lines="6">
				<diff>@@ -35,8 +35,7 @@
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
-#include &lt;cv_tracker_msgs/obj_label.h&gt;
-#include &lt;runtime_manager/traffic_light.h&gt;
+#include "autoware_msgs/obj_label.h"
 
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
@@ -55,8 +54,8 @@
 #include &lt;visualization_msgs/InteractiveMarkerPose.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;std_msgs/Float32.h&gt;
-#include &lt;lidar_tracker/CloudCluster.h&gt;
-#include &lt;lidar_tracker/CloudClusterArray.h&gt;
+#include "autoware_msgs/CloudCluster.h"
+#include "autoware_msgs/CloudClusterArray.h"
 #include "SimpleTracker.h"
 
 namespace OpenPlannerSimulatorNS
@@ -128,7 +127,7 @@ protected:
 
 	// Callback function for subscriber.
 	void callbackGetInitPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;msg);
-	void callbackGetCloudClusters(const lidar_tracker::CloudClusterArrayConstPtr&amp; msg);
+	void callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr&amp; msg);
 
 public:
 	OpenPlannerSimulator();
@@ -146,7 +145,7 @@ public:
   void visualizePath(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path);
 
   void ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::CAR_BASIC_INFO&amp; car_info,
-  		const lidar_tracker::CloudClusterArray&amp; clusters, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list,
+  		const autoware_msgs::CloudClusterArray&amp; clusters, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list,
   		int&amp; nOriginalPoints, int&amp; nContourPoints);
 
   PlannerHNS::WayPoint GetRealCenter(const PlannerHNS::WayPoint&amp; currState);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\OpenPlannerSimulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\OpenPlannerSimulator_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -250,7 +250,7 @@ void OpenPlannerSimulator::GetTransformFromTF(const std::string parent_frame, co
 	}
 }
 
-void OpenPlannerSimulator::callbackGetCloudClusters(const lidar_tracker::CloudClusterArrayConstPtr&amp; msg)
+void OpenPlannerSimulator::callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr&amp; msg)
 {
 	m_OriginalClusters.clear();
 	int nOriginalPoints=0, nContourPoints = 0;
@@ -380,7 +380,7 @@ void OpenPlannerSimulator::visualizePath(const std::vector&lt;PlannerHNS::WayPoint&gt;
 }
 
 void OpenPlannerSimulator::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::CAR_BASIC_INFO&amp; car_info,
-		const lidar_tracker::CloudClusterArray&amp; clusters, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list,
+		const autoware_msgs::CloudClusterArray&amp; clusters, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list,
 		int&amp; nOriginalPoints, int&amp; nContourPoints)
 {
 	PlannerHNS::Mat3 rotationMat(-currState.pos.a);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\OpenPlannerSimulatorPerception_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\OpenPlannerSimulatorPerception_core.h" added_lines="4" deleted_lines="5">
				<diff>@@ -35,7 +35,6 @@
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
-#include &lt;runtime_manager/traffic_light.h&gt;
 
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
@@ -50,8 +49,8 @@
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;std_msgs/Float32.h&gt;
 
-#include &lt;lidar_tracker/CloudCluster.h&gt;
-#include &lt;lidar_tracker/CloudClusterArray.h&gt;
+#include "autoware_msgs/CloudCluster.h"
+#include "autoware_msgs/CloudClusterArray.h"
 #include &lt;geometry_msgs/PoseArray.h&gt;
 
 
@@ -78,7 +77,7 @@ protected:
 	timespec m_Timer;
 	DetectionCommandParams m_DecParams;
 
-	lidar_tracker::CloudClusterArray m_ObjClustersArray;
+	autoware_msgs::CloudClusterArray m_ObjClustersArray;
 	std::vector&lt;std::pair&lt;int, double&gt; &gt; m_keepTime;
 
 	ros::Publisher pub_DetectedObjects;
@@ -93,7 +92,7 @@ protected:
 public:
 	OpenPlannerSimulatorPerception();
 	virtual ~OpenPlannerSimulatorPerception();
-	lidar_tracker::CloudCluster GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::Pose&amp; centerPose);
+	autoware_msgs::CloudCluster GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::Pose&amp; centerPose);
 	void MainLoop();
 };
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\nodes\OpenPlannerSimulatorPerception_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulator_perception\nodes\OpenPlannerSimulatorPerception_core.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -49,7 +49,7 @@ OpenPlannerSimulatorPerception::OpenPlannerSimulatorPerception()
 	nh.getParam("/op_simulator_perception/simObjNumber" 			, m_DecParams.nSimuObjs);
 	nh.getParam("/op_simulator_perception/GuassianErrorFactor" 	, m_DecParams.errFactor);
 
-	pub_DetectedObjects 	= nh.advertise&lt;lidar_tracker::CloudClusterArray&gt;("cloud_clusters",1);
+	pub_DetectedObjects 	= nh.advertise&lt;autoware_msgs::CloudClusterArray&gt;("cloud_clusters",1);
 
 	for(int i=1; i &lt;= m_DecParams.nSimuObjs; i++)
 	{
@@ -98,7 +98,7 @@ void OpenPlannerSimulatorPerception::callbackGetSimuData(const geometry_msgs::Po
 		}
 	}
 
-	lidar_tracker::CloudCluster c = GenerateSimulatedObstacleCluster(msg.poses.at(2).position.y, msg.poses.at(2).position.x, msg.poses.at(2).position.y, 50, msg.poses.at(1));
+	autoware_msgs::CloudCluster c = GenerateSimulatedObstacleCluster(msg.poses.at(2).position.y, msg.poses.at(2).position.x, msg.poses.at(2).position.y, 50, msg.poses.at(1));
 	c.id = obj_id;
 
 	if(index &gt;= 0) // update existing
@@ -124,9 +124,9 @@ void OpenPlannerSimulatorPerception::callbackGetSimuData(const geometry_msgs::Po
 
 }
 
-lidar_tracker::CloudCluster OpenPlannerSimulatorPerception::GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::Pose&amp; centerPose)
+autoware_msgs::CloudCluster OpenPlannerSimulatorPerception::GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::Pose&amp; centerPose)
 {
-	lidar_tracker::CloudCluster cluster;
+	autoware_msgs::CloudCluster cluster;
 
 	cluster.centroid_point.point.x = centerPose.position.x;
 	cluster.centroid_point.point.y = centerPose.position.y;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\include\waypoint_follower\libwaypoint_follower.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\include\waypoint_follower\libwaypoint_follower.h" added_lines="5" deleted_lines="5">
				<diff>@@ -39,15 +39,15 @@
 // ROS header
 #include &lt;tf/transform_broadcaster.h&gt;
 #include &lt;tf/transform_listener.h&gt;
-#include "waypoint_follower_msgs/lane.h"
+#include "autoware_msgs/lane.h"
 
 class WayPoints
 {
 protected:
-  waypoint_follower_msgs::lane current_waypoints_;
+  autoware_msgs::lane current_waypoints_;
 
 public:
-  void setPath(const waypoint_follower_msgs::lane &amp;waypoints)
+  void setPath(const autoware_msgs::lane &amp;waypoints)
   {
     current_waypoints_ = waypoints;
   }
@@ -61,7 +61,7 @@ public:
   geometry_msgs::Quaternion getWaypointOrientation(int waypoint) const;
   geometry_msgs::Pose getWaypointPose(int waypoint) const;
   double getWaypointVelocityMPS(int waypoint) const;
-  waypoint_follower_msgs::lane getCurrentWaypoints() const
+  autoware_msgs::lane getCurrentWaypoints() const
   {
     return current_waypoints_;
   }
@@ -96,7 +96,7 @@ geometry_msgs::Point calcAbsoluteCoordinate(geometry_msgs::Point point,
                                                                                 // coordinate
 double getPlaneDistance(geometry_msgs::Point target1,
                         geometry_msgs::Point target2);  // get 2 dimentional distance between target 1 and target 2
-int getClosestWaypoint(const waypoint_follower_msgs::lane &amp;current_path, geometry_msgs::Pose current_pose);
+int getClosestWaypoint(const autoware_msgs::lane &amp;current_path, geometry_msgs::Pose current_pose);
 bool getLinearEquation(geometry_msgs::Point start, geometry_msgs::Point end, double *a, double *b, double *c);
 double getDistanceBetweenLineAndPoint(geometry_msgs::Point point, double sa, double b, double c);
 double getRelativeAngle(geometry_msgs::Pose waypoint_pose, geometry_msgs::Pose vehicle_pose);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\lib\libwaypoint_follower.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\lib\libwaypoint_follower.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -172,7 +172,7 @@ double getRelativeAngle(geometry_msgs::Pose waypoint_pose, geometry_msgs::Pose v
 }
 
 // get closest waypoint from current pose
-int getClosestWaypoint(const waypoint_follower_msgs::lane &amp;current_path, geometry_msgs::Pose current_pose)
+int getClosestWaypoint(const autoware_msgs::lane &amp;current_path, geometry_msgs::Pose current_pose)
 {
   WayPoints wp;
   wp.setPath(current_path);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" added_lines="3" deleted_lines="3">
				<diff>@@ -37,7 +37,7 @@
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 
 // User defined includes
-#include "waypoint_follower_msgs/lane.h"
+#include "autoware_msgs/lane.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 
 namespace waypoint_follower
@@ -57,7 +57,7 @@ public:
   {
     current_linear_velocity_ = cur_vel;
   }
-  void setCurrentWaypoints(const std::vector&lt;waypoint_follower_msgs::waypoint&gt; &amp;wps)
+  void setCurrentWaypoints(const std::vector&lt;autoware_msgs::waypoint&gt; &amp;wps)
   {
     current_waypoints_ = wps;
   }
@@ -102,7 +102,7 @@ private:
   double lookahead_distance_;
   geometry_msgs::Pose current_pose_;
   double current_linear_velocity_;
-  std::vector&lt;waypoint_follower_msgs::waypoint&gt; current_waypoints_;
+  std::vector&lt;autoware_msgs::waypoint&gt; current_waypoints_;
 
   // functions
   double calcCurvature(geometry_msgs::Point target) const;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -76,7 +76,7 @@ void PurePursuitNode::initForROS()
 
   // setup publisher
   pub1_ = nh_.advertise&lt;geometry_msgs::TwistStamped&gt;("twist_raw", 10);
-  pub2_ = nh_.advertise&lt;waypoint_follower_msgs::ControlCommandStamped&gt;("ctrl_cmd", 10);
+  pub2_ = nh_.advertise&lt;autoware_msgs::ControlCommandStamped&gt;("ctrl_cmd", 10);
   pub11_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("next_waypoint_mark", 0);
   pub12_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("next_target_mark", 0);
   pub13_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("search_circle_mark", 0);
@@ -134,7 +134,7 @@ void PurePursuitNode::publishControlCommandStamped(const bool &amp;can_get_curvature
   if (!publishes_for_steering_robot_)
     return;
 
-  waypoint_follower_msgs::ControlCommandStamped ccs;
+  autoware_msgs::ControlCommandStamped ccs;
   ccs.header.stamp = ros::Time::now();
   ccs.cmd.linear_velocity = can_get_curvature ? computeCommandVelocity() : 0;
   ccs.cmd.steering_angle = can_get_curvature ? convertCurvatureToSteeringAngle(wheel_base_, kappa) : 0;
@@ -163,7 +163,7 @@ double PurePursuitNode::computeCommandVelocity() const
   return command_linear_velocity_;
 }
 
-void PurePursuitNode::callbackFromConfig(const runtime_manager::ConfigWaypointFollowerConstPtr &amp;config)
+void PurePursuitNode::callbackFromConfig(const autoware_msgs::ConfigWaypointFollowerConstPtr &amp;config)
 {
   param_flag_ = config-&gt;param_flag;
   const_lookahead_distance_ = config-&gt;lookahead_distance;
@@ -186,7 +186,7 @@ void PurePursuitNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStam
   is_velocity_set_ = true;
 }
 
-void PurePursuitNode::callbackFromWayPoints(const waypoint_follower_msgs::laneConstPtr &amp;msg)
+void PurePursuitNode::callbackFromWayPoints(const autoware_msgs::laneConstPtr &amp;msg)
 {
   if (!msg-&gt;waypoints.empty())
     command_linear_velocity_ = msg-&gt;waypoints.at(0).twist.twist.linear.x;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" added_lines="5" deleted_lines="5">
				<diff>@@ -38,9 +38,9 @@
 #include &lt;visualization_msgs/Marker.h&gt;
 
 // User defined includes
-#include "runtime_manager/ConfigWaypointFollower.h"
-#include "waypoint_follower_msgs/lane.h"
-#include "waypoint_follower_msgs/ControlCommandStamped.h"
+#include "autoware_msgs/ConfigWaypointFollower.h"
+#include "autoware_msgs/lane.h"
+#include "autoware_msgs/ControlCommandStamped.h"
 #include "pure_pursuit_viz.h"
 #include "pure_pursuit.h"
 
@@ -98,10 +98,10 @@ private:
   double minimum_lookahead_distance_;  // the next waypoint must be outside of this threshold.
 
   // callbacks
-  void callbackFromConfig(const runtime_manager::ConfigWaypointFollowerConstPtr &amp;config);
+  void callbackFromConfig(const autoware_msgs::ConfigWaypointFollowerConstPtr &amp;config);
   void callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStampedConstPtr &amp;msg);
-  void callbackFromWayPoints(const waypoint_follower_msgs::laneConstPtr &amp;msg);
+  void callbackFromWayPoints(const autoware_msgs::laneConstPtr &amp;msg);
 
   // initializer
   void initForROS();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_viz.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_viz.h" added_lines="0" deleted_lines="1">
				<diff>@@ -43,7 +43,6 @@
 
 // User defined includes
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "runtime_manager/ConfigWaypointFollower.h"
 
 namespace waypoint_follower
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_filter\twist_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_filter\twist_filter.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -33,7 +33,7 @@
 
 #include &lt;iostream&gt;
 
-#include "runtime_manager/ConfigTwistFilter.h"
+#include "autoware_msgs/ConfigTwistFilter.h"
 
 namespace {
 
@@ -45,7 +45,7 @@ double g_lowpass_gain_angular_z = 0.0;
 constexpr double RADIUS_MAX = 9e10;
 constexpr double ERROR = 1e-8;
 
-void configCallback(const runtime_manager::ConfigTwistFilterConstPtr &amp;config)
+void configCallback(const autoware_msgs::ConfigTwistFilterConstPtr &amp;config)
 {
   g_lateral_accel_limit = config-&gt;lateral_accel_limit;
   ROS_INFO("g_lateral_accel_limit = %lf",g_lateral_accel_limit);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -133,7 +133,7 @@ void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg)
   _initial_set = true;
 }
 
-void waypointCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg)
+void waypointCallback(const autoware_msgs::laneConstPtr &amp;msg)
 {
   // _path_og.setPath(msg);
   _current_waypoints.setPath(*msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -48,7 +48,7 @@ WaypointLoaderNode::~WaypointLoaderNode()
 void WaypointLoaderNode::initPublisher()
 {
   // setup publisher
-  lane_pub_ = nh_.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("lane_waypoints_array", 10, true);
+  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("lane_waypoints_array", 10, true);
 }
 
 void WaypointLoaderNode::initParameter()
@@ -64,23 +64,23 @@ void WaypointLoaderNode::publishLaneArray()
   // extract file paths
   std::vector&lt;std::string&gt; multi_file_path;
   parseColumns(multi_lane_csv_, &amp;multi_file_path);
-  waypoint_follower_msgs::LaneArray lane_array;
+  autoware_msgs::LaneArray lane_array;
   createLaneArray(multi_file_path, &amp;lane_array);
   lane_pub_.publish(lane_array);
 }
 
 void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt; &amp;paths,
-                                         waypoint_follower_msgs::LaneArray *lane_array)
+                                         autoware_msgs::LaneArray *lane_array)
 {
   for (auto el : paths)
   {
-    waypoint_follower_msgs::lane lane;
+    autoware_msgs::lane lane;
     createLaneWaypoint(el, &amp;lane);
     lane_array-&gt;lanes.push_back(lane);
   }
 }
 
-void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, waypoint_follower_msgs::lane *lane)
+void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, autoware_msgs::lane *lane)
 {
   if (!verifyFileConsistency(file_path.c_str()))
   {
@@ -90,7 +90,7 @@ void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, waypoi
 
   ROS_INFO("lane data is valid. publishing...");
   FileFormat format = checkFileFormat(file_path.c_str());
-  std::vector&lt;waypoint_follower_msgs::waypoint&gt; wps;
+  std::vector&lt;autoware_msgs::waypoint&gt; wps;
   if (format == FileFormat::ver1)
     loadWaypointsForVer1(file_path.c_str(), &amp;wps);
   else if (format == FileFormat::ver2)
@@ -103,7 +103,7 @@ void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, waypoi
   lane-&gt;waypoints = wps;
 }
 
-void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps)
+void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps)
 {
   std::ifstream ifs(filename);
 
@@ -115,7 +115,7 @@ void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;
 
   while (std::getline(ifs, line))
   {
-    waypoint_follower_msgs::waypoint wp;
+    autoware_msgs::waypoint wp;
     parseWaypointForVer1(line, &amp;wp);
     wps-&gt;push_back(wp);
   }
@@ -139,7 +139,7 @@ void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;
   }
 }
 
-void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line, waypoint_follower_msgs::waypoint *wp)
+void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line, autoware_msgs::waypoint *wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
@@ -150,7 +150,7 @@ void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line, waypoint_
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(columns[3]));
 }
 
-void WaypointLoaderNode::loadWaypointsForVer2(const char *filename, std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps)
+void WaypointLoaderNode::loadWaypointsForVer2(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps)
 {
   std::ifstream ifs(filename);
 
@@ -162,14 +162,14 @@ void WaypointLoaderNode::loadWaypointsForVer2(const char *filename, std::vector&lt;
 
   while (std::getline(ifs, line))
   {
-    waypoint_follower_msgs::waypoint wp;
+    autoware_msgs::waypoint wp;
     parseWaypointForVer2(line, &amp;wp);
     wps-&gt;push_back(wp);
   }
   planningVelocity(&amp;*wps);
 }
 
-void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line, waypoint_follower_msgs::waypoint *wp)
+void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line, autoware_msgs::waypoint *wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
@@ -181,7 +181,7 @@ void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line, waypoint_
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(columns[4]));
 }
 
-void WaypointLoaderNode::loadWaypoints(const char *filename, std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps)
+void WaypointLoaderNode::loadWaypoints(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps)
 {
   std::ifstream ifs(filename);
 
@@ -196,7 +196,7 @@ void WaypointLoaderNode::loadWaypoints(const char *filename, std::vector&lt;waypoin
   std::getline(ifs, line);  // remove second line
   while (std::getline(ifs, line))
   {
-    waypoint_follower_msgs::waypoint wp;
+    autoware_msgs::waypoint wp;
     parseWaypoint(line, contents, &amp;wp);
     wps-&gt;push_back(wp);
   }
@@ -204,7 +204,7 @@ void WaypointLoaderNode::loadWaypoints(const char *filename, std::vector&lt;waypoin
 }
 
 void WaypointLoaderNode::parseWaypoint(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
-                                       waypoint_follower_msgs::waypoint *wp)
+                                       autoware_msgs::waypoint *wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
@@ -255,7 +255,7 @@ FileFormat WaypointLoaderNode::checkFileFormat(const char *filename)
           );
 }
 
-void WaypointLoaderNode::planningVelocity(std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps)
+void WaypointLoaderNode::planningVelocity(std::vector&lt;autoware_msgs::waypoint&gt; *wps)
 {
   for (size_t i = 0; i &lt; wps-&gt;size(); ++i)
   {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="10" deleted_lines="10">
				<diff>@@ -41,7 +41,7 @@
 #include &lt;tf/transform_datatypes.h&gt;
 #include &lt;unordered_map&gt;
 
-#include "waypoint_follower_msgs/LaneArray.h"
+#include "autoware_msgs/LaneArray.h"
 
 namespace waypoint_maker
 {
@@ -96,19 +96,19 @@ private:
 
   // functions
 
-  void createLaneWaypoint(const std::string &amp;file_path, waypoint_follower_msgs::lane *lane);
-  void createLaneArray(const std::vector&lt;std::string&gt; &amp;paths, waypoint_follower_msgs::LaneArray *lane_array);
+  void createLaneWaypoint(const std::string &amp;file_path, autoware_msgs::lane *lane);
+  void createLaneArray(const std::vector&lt;std::string&gt; &amp;paths, autoware_msgs::LaneArray *lane_array);
 
   FileFormat checkFileFormat(const char *filename);
   bool verifyFileConsistency(const char *filename);
-  void loadWaypointsForVer1(const char *filename, std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps);
-  void parseWaypointForVer1(const std::string &amp;line, waypoint_follower_msgs::waypoint *wp);
-  void loadWaypointsForVer2(const char *filename, std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps);
-  void parseWaypointForVer2(const std::string &amp;line, waypoint_follower_msgs::waypoint *wp);
-  void loadWaypoints(const char *filename, std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps);
+  void loadWaypointsForVer1(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
+  void parseWaypointForVer1(const std::string &amp;line, autoware_msgs::waypoint *wp);
+  void loadWaypointsForVer2(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
+  void parseWaypointForVer2(const std::string &amp;line, autoware_msgs::waypoint *wp);
+  void loadWaypoints(const char *filename, std::vector&lt;autoware_msgs::waypoint&gt; *wps);
   void parseWaypoint(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
-                            waypoint_follower_msgs::waypoint *wp);
-  void planningVelocity(std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps);
+                            autoware_msgs::waypoint *wp);
+  void planningVelocity(std::vector&lt;autoware_msgs::waypoint&gt; *wps);
   double decelerate(geometry_msgs::Point p1, geometry_msgs::Point p2, double original_velocity_mps);
 
 };
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -38,10 +38,10 @@
 #include &lt;vector&gt;
 #include &lt;string&gt;
 
-#include "waypoint_follower_msgs/LaneArray.h"
+#include "autoware_msgs/LaneArray.h"
 #include "waypoint_follower/libwaypoint_follower.h"
-#include &lt;runtime_manager/ConfigLaneStop.h&gt;
-#include "runtime_manager/traffic_light.h"
+#include "autoware_msgs/ConfigLaneStop.h"
+#include "autoware_msgs/traffic_light.h"
 
 namespace
 {
@@ -96,7 +96,7 @@ void publishGlobalMarker()
   g_global_mark_pub.publish(marker_array);
 }
 
-void createGlobalLaneArrayVelocityMarker(const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array)
+void createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
   // display by markers the velocity of each waypoint.
@@ -138,7 +138,7 @@ void createGlobalLaneArrayVelocityMarker(const waypoint_follower_msgs::LaneArray
                                        tmp_marker_array.markers.end());
 }
 
-void createGlobalLaneArrayChangeFlagMarker(const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array)
+void createGlobalLaneArrayChangeFlagMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
   // display by markers the velocity of each waypoint.
@@ -198,7 +198,7 @@ void createGlobalLaneArrayChangeFlagMarker(const waypoint_follower_msgs::LaneArr
 }
 
 void createLocalWaypointVelocityMarker(std_msgs::ColorRGBA color, int closest_waypoint,
-                                       const waypoint_follower_msgs::lane &amp;lane_waypoint)
+                                       const autoware_msgs::lane &amp;lane_waypoint)
 {
 
   // display by markers the velocity of each waypoint.
@@ -231,7 +231,7 @@ void createLocalWaypointVelocityMarker(std_msgs::ColorRGBA color, int closest_wa
 
 }
 
-void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array)
+void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const autoware_msgs::LaneArray &amp;lane_waypoints_array)
 {
   visualization_msgs::Marker lane_waypoint_marker;
   lane_waypoint_marker.header.frame_id = "map";
@@ -261,7 +261,7 @@ void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const waypoint_follo
 
 }
 
-void createGlobalLaneArrayOrientationMarker(const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array)
+void createGlobalLaneArrayOrientationMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
   visualization_msgs::Marker lane_waypoint_marker;
@@ -294,7 +294,7 @@ void createGlobalLaneArrayOrientationMarker(const waypoint_follower_msgs::LaneAr
                                        tmp_marker_array.markers.end());
 }
 
-void createLocalPathMarker(std_msgs::ColorRGBA color, const waypoint_follower_msgs::lane &amp;lane_waypoint)
+void createLocalPathMarker(std_msgs::ColorRGBA color, const autoware_msgs::lane &amp;lane_waypoint)
 {
   visualization_msgs::Marker lane_waypoint_marker;
   lane_waypoint_marker.header.frame_id = "map";
@@ -317,7 +317,7 @@ void createLocalPathMarker(std_msgs::ColorRGBA color, const waypoint_follower_ms
   g_local_waypoints_marker_array.markers.push_back(lane_waypoint_marker);
 }
 
-void createLocalPointMarker(const waypoint_follower_msgs::lane &amp;lane_waypoint)
+void createLocalPointMarker(const autoware_msgs::lane &amp;lane_waypoint)
 {
   visualization_msgs::Marker lane_waypoint_marker;
   lane_waypoint_marker.header.frame_id = "map";
@@ -343,7 +343,7 @@ void createLocalPointMarker(const waypoint_follower_msgs::lane &amp;lane_waypoint)
   g_local_waypoints_marker_array.markers.push_back(lane_waypoint_marker);
 }
 
-void lightCallback(const runtime_manager::traffic_lightConstPtr&amp; msg)
+void lightCallback(const autoware_msgs::traffic_lightConstPtr&amp; msg)
 {
   std_msgs::ColorRGBA global_color;
   global_color.a = g_global_alpha;
@@ -379,24 +379,24 @@ void lightCallback(const runtime_manager::traffic_lightConstPtr&amp; msg)
   }
 }
 
-void receiveAutoDetection(const runtime_manager::traffic_lightConstPtr&amp; msg)
+void receiveAutoDetection(const autoware_msgs::traffic_lightConstPtr&amp; msg)
 {
   if (!g_config_manual_detection)
     lightCallback(msg);
 }
 
-void receiveManualDetection(const runtime_manager::traffic_lightConstPtr&amp; msg)
+void receiveManualDetection(const autoware_msgs::traffic_lightConstPtr&amp; msg)
 {
   if (g_config_manual_detection)
     lightCallback(msg);
 }
 
-void configParameter(const runtime_manager::ConfigLaneStopConstPtr&amp; msg)
+void configParameter(const autoware_msgs::ConfigLaneStopConstPtr&amp; msg)
 {
   g_config_manual_detection = msg-&gt;manual_detection;
 }
 
-void laneArrayCallback(const waypoint_follower_msgs::LaneArrayConstPtr &amp;msg)
+void laneArrayCallback(const autoware_msgs::LaneArrayConstPtr &amp;msg)
 {
   g_global_marker_array.markers.clear();
   createGlobalLaneArrayVelocityMarker(*msg);
@@ -406,7 +406,7 @@ void laneArrayCallback(const waypoint_follower_msgs::LaneArrayConstPtr &amp;msg)
   publishGlobalMarker();
 }
 
-void temporalCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg)
+void temporalCallback(const autoware_msgs::laneConstPtr &amp;msg)
 {
   g_local_waypoints_marker_array.markers.clear();
   if (_closest_waypoint != -1)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_saver\waypoint_saver.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_saver\waypoint_saver.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -40,7 +40,6 @@
 
 #include &lt;fstream&gt;
 
-#include "vehicle_socket/CanInfo.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 
 static const int SYNC_FRAMES = 50;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -79,7 +79,7 @@ void StateMachineNode::publish() const
   pub_.publish(msg);
 }
 
-void StateMachineNode::callbackFromLightColor(const runtime_manager::traffic_lightConstPtr&amp; msg)
+void StateMachineNode::callbackFromLightColor(const autoware_msgs::traffic_lightConstPtr&amp; msg)
 {
   ROS_INFO("Light color callback");
   if (is_manual_light_detection_)
@@ -90,7 +90,7 @@ void StateMachineNode::callbackFromLightColor(const runtime_manager::traffic_lig
   publish();
 }
 
-void StateMachineNode::callbackFromLightColorManaged(const runtime_manager::traffic_lightConstPtr&amp; msg)
+void StateMachineNode::callbackFromLightColorManaged(const autoware_msgs::traffic_lightConstPtr&amp; msg)
 {
   ROS_INFO("Light color managed callback");
   if (!is_manual_light_detection_)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.h" added_lines="3" deleted_lines="3">
				<diff>@@ -37,7 +37,7 @@
 #include &lt;std_msgs/Int32.h&gt;
 
 // User Defined includes
-#include "runtime_manager/traffic_light.h"
+#include "autoware_msgs/traffic_light.h"
 #include "state_machine.h"
 
 namespace state_machine
@@ -68,8 +68,8 @@ private:
   bool is_manual_light_detection_;
 
   // callbacks
-  void callbackFromLightColor(const runtime_manager::traffic_lightConstPtr &amp;msg);
-  void callbackFromLightColorManaged(const runtime_manager::traffic_lightConstPtr &amp;msg);
+  void callbackFromLightColor(const autoware_msgs::traffic_lightConstPtr &amp;msg);
+  void callbackFromLightColorManaged(const autoware_msgs::traffic_lightConstPtr &amp;msg);
   void callbackFromChangeFlag(const std_msgs::Int32ConstPtr&amp; msg);
 
   // initializer
</diff>
			</file>
			<file old_path="ros\src\data\packages\map_file\nodes\points_map_loader\points_map_loader.cpp" new_path="ros\src\data\packages\map_file\nodes\points_map_loader\points_map_loader.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -37,7 +37,7 @@
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;tf/transform_listener.h&gt;
 
-#include &lt;waypoint_follower_msgs/LaneArray.h&gt;
+#include "autoware_msgs/LaneArray.h"
 
 #include &lt;map_file/get_file.h&gt;
 
@@ -419,11 +419,11 @@ void publish_dragged_pcd(const geometry_msgs::PoseWithCovarianceStamped&amp; msg)
 	publish_pcd(create_pcd(p));
 }
 
-void request_lookahead_download(const waypoint_follower_msgs::LaneArray&amp; msg)
+void request_lookahead_download(const autoware_msgs::LaneArray&amp; msg)
 {
 	request_queue.clear_look_ahead();
 
-	for (const waypoint_follower_msgs::lane&amp; l : msg.lanes) {
+	for (const autoware_msgs::lane&amp; l : msg.lanes) {
 		size_t end = l.waypoints.size() - 1;
 		double distance = 0;
 		double threshold = (MARGIN_UNIT / 2) + margin; // XXX better way?
</diff>
			</file>
			<file old_path="ros\src\data\packages\obj_db\nodes\can_uploader\can_uploader.cpp" new_path="ros\src\data\packages\obj_db\nodes\can_uploader\can_uploader.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -48,7 +48,7 @@
 
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/String.h&gt;
-#include &lt;vehicle_socket/CanInfo.h&gt;
+#include "autoware_msgs/CanInfo.h"
 
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
@@ -113,7 +113,7 @@ static void* intervalCall(void *unused)
   return nullptr;
 }
 
-static void can_infoCallback(const vehicle_socket::CanInfo&amp; can)
+static void can_infoCallback(const autoware_msgs::CanInfo&amp; can)
 {
   ostringstream oss;
 
</diff>
			</file>
			<file old_path="ros\src\data\packages\pos_db\nodes\pos_uploader\pos_uploader.cpp" new_path="ros\src\data\packages\pos_db\nodes\pos_uploader\pos_uploader.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -48,7 +48,7 @@
 
 
 #include &lt;pos_db.h&gt;
-#include &lt;cv_tracker_msgs/obj_label.h&gt;
+#include "autoware_msgs/obj_label.h"
 
 #define MYNAME		"pos_uploader"
 #define OWN_TOPIC_NAME	"current_pose"
@@ -58,8 +58,8 @@
 using namespace std;
 
 //store subscribed value
-static std::vector &lt;cv_tracker_msgs::obj_label&gt; car_positions_array;
-static std::vector &lt;cv_tracker_msgs::obj_label&gt; person_positions_array;
+static std::vector &lt;autoware_msgs::obj_label&gt; car_positions_array;
+static std::vector &lt;autoware_msgs::obj_label&gt; person_positions_array;
 //flag for comfirming whether updating position or not
 static size_t car_num = 0;
 static size_t person_num = 0;
@@ -156,7 +156,7 @@ static std::string point_to_insert_statement(const geometry_msgs::Point&amp; point,
   return oss.str();
 }
 
-static std::string makeSendDataDetectedObj(const cv_tracker_msgs::obj_label&amp; cp_array, const char *name)
+static std::string makeSendDataDetectedObj(const autoware_msgs::obj_label&amp; cp_array, const char *name)
 {
   std::string timestamp;
   if(use_current_time  || cp_array.header.stamp.sec == 0) {
@@ -259,7 +259,7 @@ static void car_locate_cb(const jsk_recognition_msgs::BoundingBoxArray&amp; obj_pose
 {
 	if (obj_pose_msg.boxes.size() &gt; 0) {
 		geometry_msgs::Point tmpPoint;
-		cv_tracker_msgs::obj_label tmpLabel;
+		autoware_msgs::obj_label tmpLabel;
 
 		pthread_mutex_lock(&amp;pose_lock_);
 
@@ -282,7 +282,7 @@ static void person_locate_cb(const jsk_recognition_msgs::BoundingBoxArray &amp;obj_p
 {
 	if (obj_pose_msg.boxes.size() &gt; 0) {
 		geometry_msgs::Point tmpPoint;
-		cv_tracker_msgs::obj_label tmpLabel;
+		autoware_msgs::obj_label tmpLabel;
 
 		pthread_mutex_lock(&amp;pose_lock_);
 
</diff>
			</file>
			<file old_path="ros\src\data\packages\vector_map_server\nodes\vector_map_client\vector_map_client.cpp" new_path="ros\src\data\packages\vector_map_server\nodes\vector_map_client\vector_map_client.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -29,14 +29,14 @@
 */
 
 #include &lt;geometry_msgs/PoseStamped.h&gt;
-#include &lt;waypoint_follower_msgs/lane.h&gt;
+#include "autoware_msgs/lane.h"
 #include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;vector_map/vector_map.h&gt;
+#include "vector_map/vector_map.h"
 
-#include &lt;vector_map_server/GetWhiteLine.h&gt;
-#include &lt;vector_map_server/GetStopLine.h&gt;
-#include &lt;vector_map_server/GetCrossWalk.h&gt;
-#include &lt;vector_map_server/GetSignal.h&gt;
+#include "vector_map_server/GetWhiteLine.h"
+#include "vector_map_server/GetStopLine.h"
+#include "vector_map_server/GetCrossWalk.h"
+#include "vector_map_server/GetSignal.h"
 
 using vector_map::VectorMap;
 using vector_map::Category;
@@ -61,7 +61,7 @@ class VectorMapClient
 {
 private:
   geometry_msgs::PoseStamped pose_;
-  waypoint_follower_msgs::lane waypoints_;
+  autoware_msgs::lane waypoints_;
 
 public:
   VectorMapClient()
@@ -73,7 +73,7 @@ public:
     return pose_;
   }
 
-  waypoint_follower_msgs::lane getWaypoints() const
+  autoware_msgs::lane getWaypoints() const
   {
     return waypoints_;
   }
@@ -83,7 +83,7 @@ public:
     pose_ = pose;
   }
 
-  void setWaypoints(const waypoint_follower_msgs::lane&amp; waypoints)
+  void setWaypoints(const autoware_msgs::lane&amp; waypoints)
   {
     waypoints_ = waypoints;
   }
</diff>
			</file>
			<file old_path="ros\src\data\packages\vector_map_server\nodes\vector_map_server\vector_map_server.cpp" new_path="ros\src\data\packages\vector_map_server\nodes\vector_map_server\vector_map_server.cpp" added_lines="32" deleted_lines="32">
				<diff>@@ -29,37 +29,37 @@
 */
 
 #include &lt;geometry_msgs/PoseStamped.h&gt;
-#include &lt;waypoint_follower_msgs/lane.h&gt;
+#include "autoware_msgs/lane.h"
 #include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;vector_map/vector_map.h&gt;
-
-#include &lt;vector_map_server/GetDTLane.h&gt;
-#include &lt;vector_map_server/GetNode.h&gt;
-#include &lt;vector_map_server/GetLane.h&gt;
-#include &lt;vector_map_server/GetWayArea.h&gt;
-#include &lt;vector_map_server/GetRoadEdge.h&gt;
-#include &lt;vector_map_server/GetGutter.h&gt;
-#include &lt;vector_map_server/GetCurb.h&gt;
-#include &lt;vector_map_server/GetWhiteLine.h&gt;
-#include &lt;vector_map_server/GetStopLine.h&gt;
-#include &lt;vector_map_server/GetZebraZone.h&gt;
-#include &lt;vector_map_server/GetCrossWalk.h&gt;
-#include &lt;vector_map_server/GetRoadMark.h&gt;
-#include &lt;vector_map_server/GetRoadPole.h&gt;
-#include &lt;vector_map_server/GetRoadSign.h&gt;
-#include &lt;vector_map_server/GetSignal.h&gt;
-#include &lt;vector_map_server/GetStreetLight.h&gt;
-#include &lt;vector_map_server/GetUtilityPole.h&gt;
-#include &lt;vector_map_server/GetGuardRail.h&gt;
-#include &lt;vector_map_server/GetSideWalk.h&gt;
-#include &lt;vector_map_server/GetDriveOnPortion.h&gt;
-#include &lt;vector_map_server/GetCrossRoad.h&gt;
-#include &lt;vector_map_server/GetSideStrip.h&gt;
-#include &lt;vector_map_server/GetCurveMirror.h&gt;
-#include &lt;vector_map_server/GetWall.h&gt;
-#include &lt;vector_map_server/GetFence.h&gt;
-#include &lt;vector_map_server/GetRailCrossing.h&gt;
-#include &lt;vector_map_server/PositionState.h&gt;
+#include "vector_map/vector_map.h"
+
+#include "vector_map_server/GetDTLane.h"
+#include "vector_map_server/GetNode.h"
+#include "vector_map_server/GetLane.h"
+#include "vector_map_server/GetWayArea.h"
+#include "vector_map_server/GetRoadEdge.h"
+#include "vector_map_server/GetGutter.h"
+#include "vector_map_server/GetCurb.h"
+#include "vector_map_server/GetWhiteLine.h"
+#include "vector_map_server/GetStopLine.h"
+#include "vector_map_server/GetZebraZone.h"
+#include "vector_map_server/GetCrossWalk.h"
+#include "vector_map_server/GetRoadMark.h"
+#include "vector_map_server/GetRoadPole.h"
+#include "vector_map_server/GetRoadSign.h"
+#include "vector_map_server/GetSignal.h"
+#include "vector_map_server/GetStreetLight.h"
+#include "vector_map_server/GetUtilityPole.h"
+#include "vector_map_server/GetGuardRail.h"
+#include "vector_map_server/GetSideWalk.h"
+#include "vector_map_server/GetDriveOnPortion.h"
+#include "vector_map_server/GetCrossRoad.h"
+#include "vector_map_server/GetSideStrip.h"
+#include "vector_map_server/GetCurveMirror.h"
+#include "vector_map_server/GetWall.h"
+#include "vector_map_server/GetFence.h"
+#include "vector_map_server/GetRailCrossing.h"
+#include "vector_map_server/PositionState.h"
 
 using vector_map::VectorMap;
 using vector_map::Category;
@@ -345,7 +345,7 @@ std::vector&lt;Lane&gt; findNearLanes(const VectorMap&amp; vmap, const std::vector&lt;Lane&gt;&amp;
   return near_lanes;
 }
 
-std::vector&lt;Lane&gt; createFineLanes(const VectorMap&amp; vmap, const waypoint_follower_msgs::lane&amp; waypoints, double radius,
+std::vector&lt;Lane&gt; createFineLanes(const VectorMap&amp; vmap, const autoware_msgs::lane&amp; waypoints, double radius,
                                   int loops)
 {
   std::vector&lt;Lane&gt; null_lanes;
@@ -532,7 +532,7 @@ private:
   ros::Publisher marker_array_pub_;
 
   std::vector&lt;Lane&gt; createTravelingRoute(const geometry_msgs::PoseStamped&amp; pose,
-                                         const waypoint_follower_msgs::lane&amp; waypoints)
+                                         const autoware_msgs::lane&amp; waypoints)
   {
     std::vector&lt;Lane&gt; null_lanes;
 
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -35,7 +35,7 @@
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include &lt;pcl/filters/voxel_grid.h&gt;
 
-#include &lt;runtime_manager/ConfigDistanceFilter.h&gt;
+#include "autoware_msgs/ConfigDistanceFilter.h"
 
 #include &lt;points_downsampler/PointsDownsamplerInfo.h&gt;
 
@@ -62,7 +62,7 @@ static std::string filename;
 static std::string POINTS_TOPIC;
 static double measurement_range;
 
-static void config_callback(const runtime_manager::ConfigDistanceFilter::ConstPtr&amp; input)
+static void config_callback(const autoware_msgs::ConfigDistanceFilter::ConstPtr&amp; input)
 {
   sample_num = input-&gt;sample_num;
   measurement_range = input-&gt;measurement_range;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -34,7 +34,7 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#include &lt;runtime_manager/ConfigRandomFilter.h&gt;
+#include "autoware_msgs/ConfigRandomFilter.h"
 
 #include &lt;points_downsampler/PointsDownsamplerInfo.h&gt;
 
@@ -60,7 +60,7 @@ static std::string filename;
 static std::string POINTS_TOPIC;
 static double measurement_range;
 
-static void config_callback(const runtime_manager::ConfigRandomFilter::ConstPtr&amp; input)
+static void config_callback(const autoware_msgs::ConfigRandomFilter::ConstPtr&amp; input)
 {
   sample_num = input-&gt;sample_num;
   measurement_range = input-&gt;measurement_range;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\ring_filter\ring_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\ring_filter\ring_filter.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -37,7 +37,7 @@
 
 #include &lt;velodyne_pointcloud/point_types.h&gt;
 
-#include &lt;runtime_manager/ConfigRingFilter.h&gt;
+#include "autoware_msgs/ConfigRingFilter.h"
 
 #include &lt;points_downsampler/PointsDownsamplerInfo.h&gt;
 
@@ -63,7 +63,7 @@ static std::string filename;
 static std::string POINTS_TOPIC;
 static double measurement_range;
 
-static void config_callback(const runtime_manager::ConfigRingFilter::ConstPtr&amp; input)
+static void config_callback(const autoware_msgs::ConfigRingFilter::ConstPtr&amp; input)
 {
   ring_div = input-&gt;ring_div;
   voxel_leaf_size = input-&gt;voxel_leaf_size;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -35,7 +35,7 @@
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include &lt;pcl/filters/voxel_grid.h&gt;
 
-#include &lt;runtime_manager/ConfigVoxelGridFilter.h&gt;
+#include "autoware_msgs/ConfigVoxelGridFilter.h"
 
 #include &lt;points_downsampler/PointsDownsamplerInfo.h&gt;
 
@@ -62,7 +62,7 @@ static std::string filename;
 static std::string POINTS_TOPIC;
 static double measurement_range;
 
-static void config_callback(const runtime_manager::ConfigVoxelGridFilter::ConstPtr&amp; input)
+static void config_callback(const autoware_msgs::ConfigVoxelGridFilter::ConstPtr&amp; input)
 {
   voxel_leaf_size = input-&gt;voxel_leaf_size;
   measurement_range = input-&gt;measurement_range;
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_publisher\calibration_publisher.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_publisher\calibration_publisher.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -5,7 +5,7 @@
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 #include &lt;sensor_msgs/Image.h&gt;
-#include &lt;calibration_camera_lidar/projection_matrix.h&gt;
+#include "autoware_msgs/projection_matrix.h"
 
 static cv::Mat  CameraExtrinsicMat;
 static cv::Mat  CameraMat;
@@ -64,7 +64,7 @@ static void image_raw_cb(const sensor_msgs::Image&amp; image_msg)
 
 void projectionMatrix_sender(const cv::Mat  &amp;projMat)
 {
-	calibration_camera_lidar::projection_matrix projMsg;
+	autoware_msgs::projection_matrix projMsg;
 
 	projMsg.header.frame_id=camera_id_str;
 
@@ -179,7 +179,7 @@ int main(int argc, char* argv[])
   }
 
   if (isPublish_extrinsic) {
-    projection_matrix_pub = n.advertise&lt;calibration_camera_lidar::projection_matrix&gt;(projection_matrix_name, 10, true);
+    projection_matrix_pub = n.advertise&lt;autoware_msgs::projection_matrix&gt;(projection_matrix_name, 10, true);
     projectionMatrix_sender(CameraExtrinsicMat);
   }
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\include\points_image.hpp" new_path="ros\src\sensing\fusion\packages\points2image\include\points_image.hpp" added_lines="2" deleted_lines="2">
				<diff>@@ -33,9 +33,9 @@
 
 #include &lt;opencv2/opencv.hpp&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
-#include "points2image/PointsImage.h"
+#include "autoware_msgs/PointsImage.h"
 
-points2image::PointsImage
+autoware_msgs::PointsImage
 pointcloud2_to_image(const sensor_msgs::PointCloud2ConstPtr&amp; pointclound2,
 		     const cv::Mat&amp; cameraExtrinsicMat,
 		     const cv::Mat&amp; cameraMat, const cv::Mat&amp; distCoeff,
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\lib\points_image\points_image.cpp" new_path="ros\src\sensing\fusion\packages\points2image\lib\points_image\points_image.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -33,7 +33,7 @@
 #include &lt;stdint.h&gt;
 #include &lt;iostream&gt;
 
-points2image::PointsImage
+autoware_msgs::PointsImage
 pointcloud2_to_image(const sensor_msgs::PointCloud2ConstPtr&amp; pointcloud2,
 		     const cv::Mat&amp; cameraExtrinsicMat,
 		     const cv::Mat&amp; cameraMat, const cv::Mat&amp; distCoeff,
@@ -42,7 +42,7 @@ pointcloud2_to_image(const sensor_msgs::PointCloud2ConstPtr&amp; pointcloud2,
 	int w = imageSize.width;
 	int h = imageSize.height;
 
-	points2image::PointsImage msg;
+	autoware_msgs::PointsImage msg;
 
 	msg.header = pointcloud2-&gt;header;
 
@@ -126,11 +126,11 @@ pointcloud2_to_image(const sensor_msgs::PointCloud2ConstPtr&amp; pointcloud2,
 	return msg;
 }
 
-/*points2image::CameraExtrinsic
+/*autoware_msgs::CameraExtrinsic
 pointcloud2_to_3d_calibration(const sensor_msgs::PointCloud2ConstPtr&amp; pointcloud2,
 			      const cv::Mat&amp; cameraExtrinsicMat)
 {
-	points2image::CameraExtrinsic msg;
+	autoware_msgs::CameraExtrinsic msg;
 	std::vector&lt;double&gt; cali;
 	for (int y = 0; y &lt; msg.ysize ; ++y) {
 		for (int x = 0; x &lt; msg.xsize ; ++x){
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\nodes\points2image\points2image.cpp" new_path="ros\src\sensing\fusion\packages\points2image\nodes\points2image\points2image.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -31,9 +31,9 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;sensor_msgs/CameraInfo.h&gt;
-#include "points2image/PointsImage.h"
-#include "calibration_camera_lidar/projection_matrix.h"
-//#include "points2image/CameraExtrinsic.h"
+#include "autoware_msgs/PointsImage.h"
+#include "autoware_msgs/projection_matrix.h"
+//#include "autoware_msgs/CameraExtrinsic.h"
 
 #include &lt;points_image.hpp&gt;
 
@@ -49,7 +49,7 @@ static cv::Size imageSize;
 
 static ros::Publisher pub;
 
-static void projection_callback(const calibration_camera_lidar::projection_matrix&amp; msg)
+static void projection_callback(const autoware_msgs::projection_matrix&amp; msg)
 {
 	cameraExtrinsicMat = cv::Mat(4,4,CV_64F);
 	for (int row=0; row&lt;4; row++) {
@@ -85,12 +85,12 @@ static void callback(const sensor_msgs::PointCloud2ConstPtr&amp; msg)
 		return;
 	}
 
-	points2image::PointsImage pub_msg
+	autoware_msgs::PointsImage pub_msg
 		= pointcloud2_to_image(msg, cameraExtrinsicMat, cameraMat,
 				       distCoeff, imageSize);
 	pub.publish(pub_msg);
 
-	/*points2image::CameraExtrinsic cpub_msg
+	/*autoware_msgs::CameraExtrinsic cpub_msg
 		= pointcloud2_to_3d_calibration(msg, cameraExtrinsicMat);
 	cpub.publish(cpub_msg);*/
 }
@@ -118,8 +118,8 @@ int main(int argc, char *argv[])
 	//imageSize.width = IMAGE_WIDTH;
 	//imageSize.height = IMAGE_HEIGHT;
 
-	pub = n.advertise&lt;points2image::PointsImage&gt;("points_image", 10);
-	//cpub = n.advertise&lt;points2image::CameraExtrinsic&gt;("threeD_calibration", 1);
+	pub = n.advertise&lt;autoware_msgs::PointsImage&gt;("points_image", 10);
+	//cpub = n.advertise&lt;autoware_msgs::CameraExtrinsic&gt;("threeD_calibration", 1);
 	ros::NodeHandle private_nh("~");
 
 	std::string points_topic;
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\nodes\vscan2image\vscan2image.cpp" new_path="ros\src\sensing\fusion\packages\points2image\nodes\vscan2image\vscan2image.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -31,9 +31,9 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;sensor_msgs/CameraInfo.h&gt;
-#include "points2image/PointsImage.h"
-#include "calibration_camera_lidar/projection_matrix.h"
-//#include "points2image/CameraExtrinsic.h"
+#include "autoware_msgs/PointsImage.h"
+#include "autoware_msgs/projection_matrix.h"
+//#include "autoware_msgs/CameraExtrinsic.h"
 
 #include &lt;points_image.hpp&gt;
 
@@ -49,7 +49,7 @@ static cv::Mat distCoeff;
 static cv::Size imageSize;
 static ros::Publisher pub;
 
-static void projection_callback(const calibration_camera_lidar::projection_matrix&amp; msg)
+static void projection_callback(const autoware_msgs::projection_matrix&amp; msg)
 {
 	cameraExtrinsicMat = cv::Mat(4,4,CV_64F);
 	for (int row=0; row&lt;4; row++) {
@@ -84,7 +84,7 @@ static void callback(const sensor_msgs::PointCloud2ConstPtr&amp; msg)
 		ROS_INFO("Looks like /camera/camera_info or /projection_matrix are not being published.. Please check that both are running..");
 		return;
 	}
-	points2image::PointsImage pub_msg
+	autoware_msgs::PointsImage pub_msg
 		= pointcloud2_to_image(msg, cameraExtrinsicMat,
 				       cameraMat, distCoeff, imageSize);
 	pub.publish(pub_msg);
@@ -118,7 +118,7 @@ int main(int argc, char *argv[])
 	//imageSize.width = IMAGE_WIDTH;
 	//imageSize.height = IMAGE_HEIGHT;
 
-	pub = n.advertise&lt;points2image::PointsImage&gt;("vscan_image", 10);
+	pub = n.advertise&lt;autoware_msgs::PointsImage&gt;("vscan_image", 10);
 	ros::Subscriber sub = n.subscribe("vscan_points", 1, callback);
 	ros::Subscriber projection = n.subscribe(projectionMat_topic_name, 1, projection_callback);
 	ros::Subscriber intrinsic = n.subscribe(cameraInfo_topic_name, 1, intrinsic_callback);
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\scan2image\nodes\scan2image\scan2image.cpp" new_path="ros\src\sensing\fusion\packages\scan2image\nodes\scan2image\scan2image.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -3,7 +3,6 @@
 #include &lt;opencv/cxcore.h&gt;
 #include &lt;std_msgs/Float64.h&gt;
 #include &lt;std_msgs/String.h&gt;
-#include &lt;scan2image/ScanImage.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;math.h&gt;
@@ -14,7 +13,8 @@
 #include &lt;algorithm&gt;
 #include "scan2image.h"
 
-#include "calibration_camera_lidar/projection_matrix.h"
+#include "autoware_msgs/ScanImage.h"
+#include "autoware_msgs/projection_matrix.h"
 #include &lt;sensor_msgs/CameraInfo.h&gt;
 
 #if 1 // AXE
@@ -77,7 +77,7 @@ void trans_depth_points_to_image_points(Scan_points_dataset* scan_points_dataset
     }
 }
 
-static void projection_callback(const calibration_camera_lidar::projection_matrix&amp; msg)
+static void projection_callback(const autoware_msgs::projection_matrix&amp; msg)
 {
     printf("projection\n");
 
@@ -202,7 +202,7 @@ void scanCallback(const sensor_msgs::LaserScan::ConstPtr&amp; msg)
     /*
      * Create message(Topic)
      */
-    scan2image::ScanImage scan_image_msg;
+    autoware_msgs::ScanImage scan_image_msg;
     scan_image_msg.header = msg-&gt;header;
     scan_image_msg.distance.assign(scan_image.distance, scan_image.distance + imageSize.width * imageSize.height);
     scan_image_msg.intensity.assign(scan_image.intensity, scan_image.intensity + imageSize.width * imageSize.height);
@@ -232,7 +232,7 @@ int main(int argc, char **argv)
     ros::Subscriber sub = n.subscribe("scan", 1, scanCallback);
     ros::Subscriber projection_sub = n.subscribe("projection_matrix", 1, projection_callback);
     ros::Subscriber intrinsic_sub = n.subscribe("camera/camera_info", 1, intrinsic_callback);
-    transformed_point_data = n.advertise&lt;scan2image::ScanImage&gt;("scan_image", 1);
+    transformed_point_data = n.advertise&lt;autoware_msgs::ScanImage&gt;("scan_image", 1);
 
     ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\socket\packages\tablet_socket\nodes\tablet_sender\tablet_sender.cpp" new_path="ros\src\socket\packages\tablet_socket\nodes\tablet_sender\tablet_sender.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -39,8 +39,8 @@
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;tablet_socket_msgs/error_info.h&gt;
 #include &lt;tablet_socket_msgs/mode_info.h&gt;
-#include &lt;vehicle_socket/CanInfo.h&gt;
-#include &lt;ndt_localizer/ndt_stat.h&gt;
+#include "autoware_msgs/CanInfo.h"
+#include "autoware_msgs/ndt_stat.h"
 
 static constexpr int DEFAULT_PORT = 5777;
 static constexpr int LISTEN_BACKLOG = 10;
@@ -71,7 +71,7 @@ struct can_request {
 	int32_t type;
 	int32_t driveshift;
 
-	can_request(const vehicle_socket::CanInfo&amp; msg)
+	can_request(const autoware_msgs::CanInfo&amp; msg)
 	: type(CAN_INFO_TYPE), driveshift(msg.driveshift) {
 	}
 };
@@ -94,7 +94,7 @@ struct ndt_request {
 	float acceleration;
 	int32_t use_predict_pose;
 
-	ndt_request(const ndt_localizer::ndt_stat&amp; msg) {
+	ndt_request(const autoware_msgs::ndt_stat&amp; msg) {
 		type = NDT_STAT_TYPE;
 		exe_time = msg.exe_time;
 		iteration = msg.iteration;
@@ -148,7 +148,7 @@ static void subscribe_error_info(const tablet_socket_msgs::error_info&amp; msg)
 	}
 }
 
-static void subscribe_can_info(const vehicle_socket::CanInfo&amp; msg)
+static void subscribe_can_info(const autoware_msgs::CanInfo&amp; msg)
 {
 	can_request request(msg);
 	int response;
@@ -214,7 +214,7 @@ static void subscribe_mode_info(const tablet_socket_msgs::mode_info&amp; msg)
 	}
 }
 
-static void subscribe_ndt_stat(const ndt_localizer::ndt_stat&amp; msg)
+static void subscribe_ndt_stat(const autoware_msgs::ndt_stat&amp; msg)
 {
 	ndt_request request(msg);
 	int response;
</diff>
			</file>
			<file old_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_receiver\vehicle_receiver.cpp" new_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_receiver\vehicle_receiver.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -29,7 +29,7 @@
 */
 
 #include &lt;ros/ros.h&gt;
-#include &lt;vehicle_socket/CanInfo.h&gt;
+#include "autoware_msgs/CanInfo.h"
 #include &lt;tablet_socket_msgs/mode_info.h&gt;
 
 #include &lt;iostream&gt;
@@ -58,7 +58,7 @@ static ros::Publisher can_pub;
 static ros::Publisher mode_pub;
 static int mode;
 
-static bool parseCanValue(const std::string&amp; can_data, vehicle_socket::CanInfo&amp; msg)
+static bool parseCanValue(const std::string&amp; can_data, autoware_msgs::CanInfo&amp; msg)
 {
   std::istringstream ss(can_data);
   std::vector&lt;std::string&gt; columns;
@@ -141,7 +141,7 @@ static void* getCanValue(void *arg)
   if(can_data.empty())
     return nullptr;
 
-  vehicle_socket::CanInfo can_msg;
+  autoware_msgs::CanInfo can_msg;
   bool ret = parseCanValue(can_data, can_msg);
   if(!ret)
     return nullptr;
@@ -228,7 +228,7 @@ int main(int argc, char **argv)
 
   std::cout &lt;&lt; "vehicle receiver" &lt;&lt; std::endl;
 
-  can_pub = nh.advertise&lt;vehicle_socket::CanInfo&gt;("can_info", 100);
+  can_pub = nh.advertise&lt;autoware_msgs::CanInfo&gt;("can_info", 100);
   mode_pub = nh.advertise&lt;tablet_socket_msgs::mode_info&gt;("mode_info", 100);
 
   pthread_t th;
</diff>
			</file>
			<file old_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" new_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -32,10 +32,10 @@
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;tablet_socket_msgs/mode_cmd.h&gt;
 #include &lt;tablet_socket_msgs/gear_cmd.h&gt;
-#include &lt;runtime_manager/accel_cmd.h&gt;
-#include &lt;runtime_manager/brake_cmd.h&gt;
-#include &lt;runtime_manager/steer_cmd.h&gt;
-#include &lt;waypoint_follower_msgs/ControlCommandStamped.h&gt;
+#include "autoware_msgs/accel_cmd.h"
+#include "autoware_msgs/brake_cmd.h"
+#include "autoware_msgs/steer_cmd.h"
+#include "autoware_msgs/ControlCommandStamped.h"
 
 #include &lt;iostream&gt;
 #include &lt;string&gt;
@@ -96,22 +96,22 @@ static void gearCMDCallback(const tablet_socket_msgs::gear_cmd&amp; gear)
   command_data.gearValue = gear.gear;
 }
 
-static void accellCMDCallback(const runtime_manager::accel_cmd&amp; accell)
+static void accellCMDCallback(const autoware_msgs::accel_cmd&amp; accell)
 {
   command_data.accellValue = accell.accel;
 }
 
-static void steerCMDCallback(const runtime_manager::steer_cmd&amp; steer)
+static void steerCMDCallback(const autoware_msgs::steer_cmd&amp; steer)
 {
   command_data.steerValue = steer.steer;
 }
 
-static void brakeCMDCallback(const runtime_manager::brake_cmd &amp;brake)
+static void brakeCMDCallback(const autoware_msgs::brake_cmd &amp;brake)
 {
   command_data.brakeValue = brake.brake;
 }
 
-static void ctrlCMDCallback(const waypoint_follower_msgs::ControlCommandStamped&amp; msg)
+static void ctrlCMDCallback(const autoware_msgs::ControlCommandStamped&amp; msg)
 {
   command_data.linear_velocity = msg.cmd.linear_velocity;
   command_data.steering_angle = msg.cmd.steering_angle;
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\kf_track\sync_track.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\kf_track\sync_track.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -1,7 +1,7 @@
 #include "ros/ros.h"
 #include "sensor_msgs/Image.h"
-#include "cv_tracker_msgs/image_obj_tracked.h"
-#include "cv_tracker_msgs/image_obj_ranged.h"
+#include "autoware_msgs/image_obj_tracked.h"
+#include "autoware_msgs/image_obj_ranged.h"
 #include "sync.hpp"
 
 int main(int argc, char **argv) {
@@ -13,7 +13,7 @@ int main(int argc, char **argv) {
     std::string pub1("/image_obj_ranged");
     std::string pub2("/image_raw");
 
-    Synchronizer&lt;cv_tracker_msgs::image_obj_ranged, sensor_msgs::Image, cv_tracker_msgs::image_obj_tracked&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
+    Synchronizer&lt;autoware_msgs::image_obj_ranged, sensor_msgs::Image, autoware_msgs::image_obj_tracked&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
     synchronizer.run();
 
     return 0;
@@ -40,8 +40,8 @@ int main(int argc, char **argv) {
 #include "t_sync_message.h"
 /* user header */
 #include "sensor_msgs/Image.h"
-#include "cv_tracker_msgs/image_obj_tracked.h"
-#include "cv_tracker_msgs/image_obj_ranged.h"
+#include "autoware_msgs/image_obj_tracked.h"
+#include "autoware_msgs/image_obj_ranged.h"
 
 /* ----mode---- */
 #define _REQ_PUB 1
@@ -51,7 +51,7 @@ int main(int argc, char **argv) {
 bool buf_flag;
 pthread_mutex_t mutex;
 /* user var */
-boost::circular_buffer&lt;cv_tracker_msgs::image_obj_ranged&gt; image_obj_ranged_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::image_obj_ranged&gt; image_obj_ranged_ringbuf(10);
 boost::circular_buffer&lt;sensor_msgs::Image&gt; image_raw_ringbuf(10);
 ros::Publisher image_obj_ranged__pub;
 ros::Publisher image_raw__pub;
@@ -71,10 +71,10 @@ double get_time(const std_msgs::Header *timespec) {
 
 
 #if _REQ_PUB
-cv_tracker_msgs::image_obj_ranged* p_image_obj_ranged_buf;
+autoware_msgs::image_obj_ranged* p_image_obj_ranged_buf;
 sensor_msgs::Image* p_image_raw_buf;
 
-void publish_msg(cv_tracker_msgs::image_obj_ranged* p_image_obj_ranged_buf, sensor_msgs::Image* p_image_raw_buf) {
+void publish_msg(autoware_msgs::image_obj_ranged* p_image_obj_ranged_buf, sensor_msgs::Image* p_image_raw_buf) {
     ROS_INFO("publish");
     image_obj_ranged__pub.publish(*p_image_obj_ranged_buf);
     image_raw__pub.publish(*p_image_raw_buf);
@@ -97,7 +97,7 @@ bool publish() {
         // image_obj_ranged &gt; image_raw
         if (get_time(&amp;(image_obj_ranged_ringbuf.front().header)) &gt;= get_time(&amp;(image_raw_ringbuf.front().header))) {
             p_image_raw_buf = &amp;(image_raw_ringbuf.front());
-            boost::circular_buffer&lt;cv_tracker_msgs::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
             if (image_obj_ranged_ringbuf.size() == 1) {
                 p_image_obj_ranged_buf = &amp;*it;
                 publish_msg(p_image_obj_ranged_buf, p_image_raw_buf);
@@ -163,7 +163,7 @@ bool publish() {
     }
 }
 
-void image_obj_ranged_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
+void image_obj_ranged_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ranged_ringbuf.push_front(*image_obj_ranged_msg);
     //image_raw is empty
@@ -203,7 +203,7 @@ void image_raw_callback(const sensor_msgs::Image::ConstPtr&amp; image_raw_msg) {
 #else
 #endif
 
-void image_obj_tracked_callback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
+void image_obj_tracked_callback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_tracked_flag = true;
     ROS_INFO("catch publish request");
@@ -252,7 +252,7 @@ int main(int argc, char **argv) {
 
     ros::Subscriber image_obj_ranged_sub = nh.subscribe("/image_obj_ranged", 1, image_obj_ranged_callback);
     ros::Subscriber image_raw_sub = nh.subscribe("/sync_drivers/image_raw", 1, image_raw_callback);
-    image_obj_ranged__pub = nh.advertise&lt;cv_tracker_msgs::image_obj_ranged&gt;("/sync_tracking/image_obj_ranged", 5);
+    image_obj_ranged__pub = nh.advertise&lt;autoware_msgs::image_obj_ranged&gt;("/sync_tracking/image_obj_ranged", 5);
     image_raw__pub = nh.advertise&lt;sensor_msgs::Image&gt;("/sync_tracking/image_raw", 5);
 
     while ((!buf_flag) &amp;&amp; ros::ok()) {
@@ -284,10 +284,10 @@ int main(int argc, char **argv) {
 
 
 #if 0
-cv_tracker_msgs::image_obj_ranged image_obj_ranged_buf;
+autoware_msgs::image_obj_ranged image_obj_ranged_buf;
 sensor_msgs::Image image_raw_buf;
 
-void image_obj_ranged_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
+void image_obj_ranged_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ranged_ringbuf.push_front(*image_obj_ranged_msg);
 
@@ -303,7 +303,7 @@ void image_obj_ranged_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr
     // image_obj_ranged &gt; image_raw
     if (get_time(&amp;(image_obj_ranged_ringbuf.front().header)) &gt;= get_time(&amp;(image_raw_ringbuf.front().header))) {
         image_raw_buf = image_raw_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker_msgs::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
         if (image_obj_ranged_ringbuf.size() == 1) {
             image_obj_ranged_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -360,7 +360,7 @@ void image_raw_callback(const sensor_msgs::Image::ConstPtr&amp; image_raw_msg) {
     // image_obj_ranged &gt; image_raw
     if (get_time(&amp;(image_obj_ranged_ringbuf.front().header)) &gt;= get_time(&amp;(image_raw_ringbuf.front().header))) {
         image_raw_buf = image_raw_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker_msgs::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
         if (image_obj_ranged_ringbuf.size() == 1) {
             image_obj_ranged_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\sync_obj_reproj.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\sync_obj_reproj.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -1,7 +1,7 @@
 #include "ros/ros.h"
-#include "cv_tracker_msgs/image_obj_tracked.h"
+#include "autoware_msgs/image_obj_tracked.h"
 #include "geometry_msgs/PoseStamped.h"
-#include "cv_tracker_msgs/obj_label.h"
+#include "autoware_msgs/obj_label.h"
 #include "sync.hpp"
 
 int main(int argc, char **argv) {
@@ -13,7 +13,7 @@ int main(int argc, char **argv) {
     std::string pub1("/image_obj_tracked");
     std::string pub2("/current_pose");
 
-    Synchronizer&lt;cv_tracker_msgs::image_obj_tracked, geometry_msgs::PoseStamped, cv_tracker_msgs::obj_label&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
+    Synchronizer&lt;autoware_msgs::image_obj_tracked, geometry_msgs::PoseStamped, autoware_msgs::obj_label&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
     synchronizer.run();
 
     return 0;
@@ -39,9 +39,9 @@ int main(int argc, char **argv) {
 #include &lt;pthread.h&gt;
 #include "t_sync_message.h"
 /* user header */
-#include "cv_tracker_msgs/image_obj_tracked.h"
+#include "autoware_msgs/image_obj_tracked.h"
 #include "geometry_msgs/PoseStamped.h"
-#include "cv_tracker_msgs/obj_label.h"
+#include "autoware_msgs/obj_label.h"
 
 /* ----mode---- */
 #define _REQ_PUB 1
@@ -51,7 +51,7 @@ int main(int argc, char **argv) {
 bool buf_flag;
 pthread_mutex_t mutex;
 /* user var */
-boost::circular_buffer&lt;cv_tracker_msgs::image_obj_tracked&gt; image_obj_tracked_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::image_obj_tracked&gt; image_obj_tracked_ringbuf(10);
 boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt; current_pose_ringbuf(10);
 ros::Publisher image_obj_tracked__pub;
 ros::Publisher current_pose__pub;
@@ -71,10 +71,10 @@ double get_time(const std_msgs::Header *timespec) {
 
 
 #if _REQ_PUB
-cv_tracker_msgs::image_obj_tracked* p_image_obj_tracked_buf;
+autoware_msgs::image_obj_tracked* p_image_obj_tracked_buf;
 geometry_msgs::PoseStamped* p_current_pose_buf;
 
-void publish_msg(cv_tracker_msgs::image_obj_tracked* p_image_obj_tracked_buf, geometry_msgs::PoseStamped* p_current_pose_buf) {
+void publish_msg(autoware_msgs::image_obj_tracked* p_image_obj_tracked_buf, geometry_msgs::PoseStamped* p_current_pose_buf) {
     ROS_INFO("publish");
     image_obj_tracked__pub.publish(*p_image_obj_tracked_buf);
     current_pose__pub.publish(*p_current_pose_buf);
@@ -97,7 +97,7 @@ bool publish() {
         // image_obj_tracked &gt; current_pose
         if (get_time(&amp;(image_obj_tracked_ringbuf.front().header)) &gt;= get_time(&amp;(current_pose_ringbuf.front().header))) {
             p_current_pose_buf = &amp;(current_pose_ringbuf.front());
-            boost::circular_buffer&lt;cv_tracker_msgs::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
             if (image_obj_tracked_ringbuf.size() == 1) {
                 p_image_obj_tracked_buf = &amp;*it;
                 publish_msg(p_image_obj_tracked_buf, p_current_pose_buf);
@@ -163,7 +163,7 @@ bool publish() {
     }
 }
 
-void image_obj_tracked_callback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
+void image_obj_tracked_callback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_tracked_ringbuf.push_front(*image_obj_tracked_msg);
     //current_pose is empty
@@ -204,7 +204,7 @@ void current_pose_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_p
 #else
 #endif
 
-void obj_label_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
+void obj_label_callback(const autoware_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
     pthread_mutex_lock(&amp;mutex);
     obj_label_flag = true;
     ROS_INFO("catch publish request");
@@ -252,7 +252,7 @@ int main(int argc, char **argv) {
 
     ros::Subscriber image_obj_tracked_sub = nh.subscribe("/image_obj_tracked", 1, image_obj_tracked_callback);
     ros::Subscriber current_pose_sub = nh.subscribe("/current_pose", 1, current_pose_callback);
-    image_obj_tracked__pub = nh.advertise&lt;cv_tracker_msgs::image_obj_tracked&gt;("/sync_reprojection/image_obj_tracked", 5);
+    image_obj_tracked__pub = nh.advertise&lt;autoware_msgs::image_obj_tracked&gt;("/sync_reprojection/image_obj_tracked", 5);
     current_pose__pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/sync_reprojection/current_pose", 5);
 
     while (!buf_flag &amp;&amp; ros::ok()) {
@@ -281,10 +281,10 @@ int main(int argc, char **argv) {
 }
 
 #if 0
-cv_tracker_msgs::image_obj_tracked image_obj_tracked_buf;
+autoware_msgs::image_obj_tracked image_obj_tracked_buf;
 geometry_msgs::PoseStamped current_pose_buf;
 
-void image_obj_tracked_callback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
+void image_obj_tracked_callback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_tracked_ringbuf.push_front(*image_obj_tracked_msg);
 
@@ -300,7 +300,7 @@ void image_obj_tracked_callback(const cv_tracker_msgs::image_obj_tracked::ConstP
     // image_obj_tracked &gt; current_pose
     if (get_time(&amp;(image_obj_tracked_ringbuf.front().header)) &gt;= get_time(&amp;(current_pose_ringbuf.front().header))) {
         current_pose_buf = current_pose_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker_msgs::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
         if (image_obj_tracked_ringbuf.size() == 1) {
             image_obj_tracked_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -372,7 +372,7 @@ void current_pose_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_p
     // image_obj_tracked &gt; current_pose
     if (get_time(&amp;(image_obj_tracked_ringbuf.front().header)) &gt;= get_time(&amp;(current_pose_ringbuf.front().header))) {
         current_pose_buf = current_pose_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker_msgs::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
         if (image_obj_tracked_ringbuf.size() == 1) {
             image_obj_tracked_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\range_fusion\sync_range_fusion.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\range_fusion\sync_range_fusion.cpp" added_lines="27" deleted_lines="27">
				<diff>@@ -1,7 +1,7 @@
 #include "ros/ros.h"
-#include "cv_tracker_msgs/image_obj.h"
-#include "points2image/PointsImage.h"
-#include "cv_tracker_msgs/image_obj_ranged.h"
+#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/PointsImage.h"
+#include "autoware_msgs/image_obj_ranged.h"
 #include "sync.hpp"
 
 int main(int argc, char **argv) {
@@ -13,7 +13,7 @@ int main(int argc, char **argv) {
     std::string pub1("/image_obj");
     std::string pub2("/vscan_image");
 
-    Synchronizer&lt;cv_tracker_msgs::image_obj, points2image::PointsImage, cv_tracker_msgs::image_obj_ranged&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
+    Synchronizer&lt;autoware_msgs::image_obj, autoware_msgs::PointsImage, autoware_msgs::image_obj_ranged&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
     synchronizer.run();
 
     return 0;
@@ -39,9 +39,9 @@ int main(int argc, char **argv) {
 #include &lt;pthread.h&gt;
 #include "t_sync_message.h"
 /* user header */
-#include "cv_tracker_msgs/image_obj.h"
-#include "points2image/PointsImage.h"
-#include "cv_tracker_msgs/image_obj_ranged.h"
+#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/PointsImage.h"
+#include "autoware_msgs/image_obj_ranged.h"
 
 /* ----mode---- */
 #define _REQ_PUB 1
@@ -51,8 +51,8 @@ int main(int argc, char **argv) {
 bool buf_flag;
 pthread_mutex_t mutex;
 /* user var */
-boost::circular_buffer&lt;cv_tracker_msgs::image_obj&gt; image_obj_ringbuf(10);
-boost::circular_buffer&lt;points2image::PointsImage&gt; vscan_image_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::image_obj&gt; image_obj_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::PointsImage&gt; vscan_image_ringbuf(10);
 ros::Publisher image_obj__pub;
 ros::Publisher vscan_image__pub;
 bool image_obj_ranged_flag;
@@ -71,10 +71,10 @@ double get_time(const std_msgs::Header *timespec) {
 
 
 #if _REQ_PUB
-cv_tracker_msgs::image_obj* p_image_obj_buf;
-points2image::PointsImage* p_vscan_image_buf;
+autoware_msgs::image_obj* p_image_obj_buf;
+autoware_msgs::PointsImage* p_vscan_image_buf;
 
-void publish_msg(cv_tracker_msgs::image_obj* p_image_obj_buf, points2image::PointsImage* p_vscan_image_buf) {
+void publish_msg(autoware_msgs::image_obj* p_image_obj_buf, autoware_msgs::PointsImage* p_vscan_image_buf) {
     ROS_INFO("publish");
     image_obj__pub.publish(*p_image_obj_buf);
     vscan_image__pub.publish(*p_vscan_image_buf);
@@ -97,7 +97,7 @@ bool publish() {
         // image_obj &gt; vscan_image
         if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
             p_vscan_image_buf = &amp;(vscan_image_ringbuf.front());
-            boost::circular_buffer&lt;cv_tracker_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
             if (image_obj_ringbuf.size() == 1) {
                 p_image_obj_buf = &amp;*it;
                 publish_msg(p_image_obj_buf, p_vscan_image_buf);
@@ -124,7 +124,7 @@ bool publish() {
         // image_obj &lt; vscan_image
         else {
             p_image_obj_buf = &amp;(image_obj_ringbuf.front());
-            boost::circular_buffer&lt;points2image::PointsImage&gt;::iterator it = vscan_image_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::PointsImage&gt;::iterator it = vscan_image_ringbuf.begin();
             if (vscan_image_ringbuf.size() == 1) {
                 p_vscan_image_buf = &amp;*it;
                 publish_msg(p_image_obj_buf, p_vscan_image_buf);
@@ -163,7 +163,7 @@ bool publish() {
     }
 }
 
-void image_obj_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
+void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ringbuf.push_front(*image_obj_msg);
     //vscan_image is empty
@@ -182,7 +182,7 @@ void image_obj_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; image_obj_ms
     pthread_mutex_unlock(&amp;mutex);
 }
 
-void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image_msg) {
+void vscan_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; vscan_image_msg) {
     pthread_mutex_lock(&amp;mutex);
     vscan_image_ringbuf.push_front(*vscan_image_msg);
     //image_obj is empty
@@ -203,7 +203,7 @@ void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image
 #else
 #endif
 
-void image_obj_ranged_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
+void image_obj_ranged_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ranged_flag = true;
     ROS_INFO("catch publish request");
@@ -252,8 +252,8 @@ int main(int argc, char **argv) {
 
     ros::Subscriber image_obj_sub = nh.subscribe("/image_obj", 1, image_obj_callback);
     ros::Subscriber vscan_image_sub = nh.subscribe("/vscan_image", 1, vscan_image_callback);
-    image_obj__pub = nh.advertise&lt;cv_tracker_msgs::image_obj&gt;("/sync_ranging/image_obj", 5);
-    vscan_image__pub = nh.advertise&lt;points2image::PointsImage&gt;("/sync_ranging/vscan_image", 5);
+    image_obj__pub = nh.advertise&lt;autoware_msgs::image_obj&gt;("/sync_ranging/image_obj", 5);
+    vscan_image__pub = nh.advertise&lt;autoware_msgs::PointsImage&gt;("/sync_ranging/vscan_image", 5);
 
     while ((!buf_flag) &amp;&amp; ros::ok()) {
         ros::spinOnce();
@@ -284,10 +284,10 @@ int main(int argc, char **argv) {
 
 
 #if 0
-cv_tracker_msgs::image_obj image_obj_buf;
-points2image::PointsImage vscan_image_buf;
+autoware_msgs::image_obj image_obj_buf;
+autoware_msgs::PointsImage vscan_image_buf;
 
-void image_obj_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
+void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ringbuf.push_front(*image_obj_msg);
 
@@ -303,7 +303,7 @@ void image_obj_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; image_obj_ms
     // image_obj &gt; vscan_image
     if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
         vscan_image_buf = vscan_image_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
         if (image_obj_ringbuf.size() == 1) {
             image_obj_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -323,7 +323,7 @@ void image_obj_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; image_obj_ms
 
     } else {
         image_obj_buf = image_obj_ringbuf.front();
-        boost::circular_buffer&lt;points2image::PointsImage&gt;::iterator it = vscan_image_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::PointsImage&gt;::iterator it = vscan_image_ringbuf.begin();
         if (vscan_image_ringbuf.size() == 1) {
             vscan_image_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -345,7 +345,7 @@ void image_obj_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; image_obj_ms
     pthread_mutex_unlock(&amp;mutex);
 }
 
-void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image_msg) {
+void vscan_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; vscan_image_msg) {
     pthread_mutex_lock(&amp;mutex);
     vscan_image_ringbuf.push_front(*vscan_image_msg);
     //image_obj is empty
@@ -360,7 +360,7 @@ void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image
     // image_obj &gt; vscan_image
     if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
         vscan_image_buf = vscan_image_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
         if (image_obj_ringbuf.size() == 1) {
             image_obj_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -380,7 +380,7 @@ void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image
 
     } else {
         image_obj_buf = image_obj_ringbuf.front();
-        boost::circular_buffer&lt;points2image::PointsImage&gt;::iterator it = vscan_image_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::PointsImage&gt;::iterator it = vscan_image_ringbuf.begin();
         if (vscan_image_ringbuf.size() == 1) {
             vscan_image_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\car_dpm_sync.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\car_dpm_sync.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -19,8 +19,8 @@
 /* user header */
 #include "sensor_msgs/Image.h"
 #include "sensor_msgs/PointCloud2.h"
-#include "cv_tracker/image_obj.h"
-#include "points2image/PointsImage.h"
+#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/PointsImage.h"
 
 /* ----mode---- */
 #define _REQ_PUB 1
@@ -296,7 +296,7 @@ bool publish() {
 }
 #endif
 
-void image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
+void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
     if (image_obj_flag) {
         image_obj_flag = false;
         points_image_flag = false;
@@ -318,7 +318,7 @@ void image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
         points_image_flag = false;
     }
 }
-void points_image_callback(const points2image::PointsImage::ConstPtr&amp; points_image_msg) {
+void points_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; points_image_msg) {
     if (points_image_flag) {
         image_obj_flag = false;
         points_image_flag = false;
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\copy.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\copy.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -4,8 +4,8 @@
 /* user header */
 #include "sensor_msgs/Image.h"
 #include "sensor_msgs/PointCloud2.h"
-#include "cv_tracker/image_obj.h"
-#include "points2image/PointsImage.h"
+#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/PointsImage.h"
 
 /* ----mode---- */
 #define _REQ_PUB 1
@@ -283,7 +283,7 @@ bool publish() {
 }
 #endif
 
-void obj_person__image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
+void obj_person__image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
     if (obj_person__image_obj_flag) {
         obj_person__image_obj_flag = false;
         obj_car__image_obj_flag = false;
@@ -310,7 +310,7 @@ void obj_person__image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image
     }
 }
 
-void obj_car__image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
+void obj_car__image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
     if (obj_car__image_obj_flag) {
         obj_person__image_obj_flag = false;
         obj_car__image_obj_flag = false;
@@ -337,7 +337,7 @@ void obj_car__image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_ob
     }
 }
 
-void points_image_callback(const points2image::PointsImage::ConstPtr&amp; points_image_msg) {
+void points_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; points_image_msg) {
     if (points_image_flag) {
         obj_person__image_obj_flag = false;
         obj_car__image_obj_flag = false;
@@ -364,7 +364,7 @@ void points_image_callback(const points2image::PointsImage::ConstPtr&amp; points_ima
     }
 }
 
-void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; points_image_msg) {
+void vscan_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; points_image_msg) {
     if (vscan_image_flag) {
         obj_person__image_obj_flag = false;
         obj_car__image_obj_flag = false;
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\dpm_sync_2.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\dpm_sync_2.cpp" added_lines="23" deleted_lines="23">
				<diff>@@ -17,9 +17,9 @@
 #include &lt;pthread.h&gt;
 #include "t_sync_message.h"
 /* user header */
-#include "cv_tracker/image_obj.h"
-#include "points2image/PointsImage.h"
-#include "cv_tracker/image_obj_ranged.h"
+#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/PointsImage.h"
+#include "autoware_msgs/image_obj_ranged.h"
 
 /* ----mode---- */
 #define _REQ_PUB 1
@@ -30,8 +30,8 @@ bool buf_flag;
 pthread_mutex_t mutex;
 pthread_mutex_t flag_mutex;
 /* user var */
-boost::circular_buffer&lt;cv_tracker::image_obj&gt; image_obj_ringbuf(10);
-boost::circular_buffer&lt;points2image::PointsImage&gt; vscan_image_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::image_obj&gt; image_obj_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::PointsImage&gt; vscan_image_ringbuf(10);
 ros::Publisher image_obj__pub;
 ros::Publisher vscan_image__pub;
 bool image_obj_ranged_flag;
@@ -50,10 +50,10 @@ double get_time(const std_msgs::Header *timespec) {
 
 
 #if _REQ_PUB
-cv_tracker::image_obj* p_image_obj_buf;
-points2image::PointsImage* p_vscan_image_buf;
+autoware_msgs::image_obj* p_image_obj_buf;
+autoware_msgs::PointsImage* p_vscan_image_buf;
 
-void publish_msg(cv_tracker::image_obj* p_image_obj_buf, points2image::PointsImage* p_vscan_image_buf) {
+void publish_msg(autoware_msgs::image_obj* p_image_obj_buf, autoware_msgs::PointsImage* p_vscan_image_buf) {
     ROS_INFO("publish");
     image_obj__pub.publish(*p_image_obj_buf);
     vscan_image__pub.publish(*p_vscan_image_buf);
@@ -80,7 +80,7 @@ bool publish() {
         // image_obj &gt; vscan_image
         if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
             p_vscan_image_buf = &amp;(vscan_image_ringbuf.front());
-            boost::circular_buffer&lt;cv_tracker::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
             if (image_obj_ringbuf.size() == 1) {
                 p_image_obj_buf = &amp;*it;
                 publish_msg(p_image_obj_buf, p_vscan_image_buf);
@@ -102,7 +102,7 @@ bool publish() {
         // image_obj &lt; vscan_image
         else {
             p_image_obj_buf = &amp;(image_obj_ringbuf.front());
-            boost::circular_buffer&lt;points2image::PointsImage&gt;::iterator it = vscan_image_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::PointsImage&gt;::iterator it = vscan_image_ringbuf.begin();
             if (vscan_image_ringbuf.size() == 1) {
                 p_vscan_image_buf = &amp;*it;
                 publish_msg(p_image_obj_buf, p_vscan_image_buf);
@@ -136,7 +136,7 @@ bool publish() {
     }
 }
 
-void image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
+void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ringbuf.push_front(*image_obj_msg);
     //vscan_image is empty
@@ -153,7 +153,7 @@ void image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
     }
 }
 
-void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image_msg) {
+void vscan_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; vscan_image_msg) {
     pthread_mutex_lock(&amp;mutex);
     vscan_image_ringbuf.push_front(*vscan_image_msg);
     //image_obj is empty
@@ -172,7 +172,7 @@ void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image
 #else
 #endif
 
-void image_obj_ranged_callback(const cv_tracker::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
+void image_obj_ranged_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
     image_obj_ranged_flag= true;
     ROS_INFO("catch publish request");
     if (publish() == false) {
@@ -222,8 +222,8 @@ int main(int argc, char **argv) {
 
     ros::Subscriber image_obj_sub = nh.subscribe("obj_car/image_obj", 1, image_obj_callback);
     ros::Subscriber vscan_image_sub = nh.subscribe("vscan_image", 1, vscan_image_callback);
-    image_obj__pub = nh.advertise&lt;cv_tracker::image_obj&gt;("obj_car/image_obj_", 5);
-    vscan_image__pub = nh.advertise&lt;points2image::PointsImage&gt;("vscan_image_", 5);
+    image_obj__pub = nh.advertise&lt;autoware_msgs::image_obj&gt;("obj_car/image_obj_", 5);
+    vscan_image__pub = nh.advertise&lt;autoware_msgs::PointsImage&gt;("vscan_image_", 5);
 
     pthread_mutex_lock(&amp;flag_mutex);
     while ((!buf_flag) || ros::ok()) {
@@ -253,10 +253,10 @@ int main(int argc, char **argv) {
 
 
 #if 0
-cv_tracker::image_obj image_obj_buf;
-points2image::PointsImage vscan_image_buf;
+autoware_msgs::image_obj image_obj_buf;
+autoware_msgs::PointsImage vscan_image_buf;
 
-void image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
+void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ringbuf.push_front(*image_obj_msg);
 
@@ -272,7 +272,7 @@ void image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
     // image_obj &gt; vscan_image
     if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
         vscan_image_buf = vscan_image_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
         if (image_obj_ringbuf.size() == 1) {
             image_obj_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -292,7 +292,7 @@ void image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
 
     } else {
         image_obj_buf = image_obj_ringbuf.front();
-        boost::circular_buffer&lt;points2image::PointsImage&gt;::iterator it = vscan_image_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::PointsImage&gt;::iterator it = vscan_image_ringbuf.begin();
         if (vscan_image_ringbuf.size() == 1) {
             vscan_image_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -314,7 +314,7 @@ void image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
     pthread_mutex_unlock(&amp;mutex);
 }
 
-void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image_msg) {
+void vscan_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; vscan_image_msg) {
     pthread_mutex_lock(&amp;mutex);
     vscan_image_ringbuf.push_front(*vscan_image_msg);
     //image_obj is empty
@@ -329,7 +329,7 @@ void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image
     // image_obj &gt; vscan_image
     if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
         vscan_image_buf = vscan_image_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
         if (image_obj_ringbuf.size() == 1) {
             image_obj_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -349,7 +349,7 @@ void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image
 
     } else {
         image_obj_buf = image_obj_ringbuf.front();
-        boost::circular_buffer&lt;points2image::PointsImage&gt;::iterator it = vscan_image_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::PointsImage&gt;::iterator it = vscan_image_ringbuf.begin();
         if (vscan_image_ringbuf.size() == 1) {
             vscan_image_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\sync_car_dpm.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\test\sync_car_dpm.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -19,8 +19,8 @@
 /* user header */
 #include "sensor_msgs/Image.h"
 #include "sensor_msgs/PointCloud2.h"
-#include "cv_tracker/image_obj.h"
-#include "points2image/PointsImage.h"
+#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/PointsImage.h"
 
 /* ----mode---- */
 #define _REQ_PUB 1
@@ -296,7 +296,7 @@ bool publish() {
 }
 #endif
 
-void image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
+void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
     if (image_obj_flag) {
         image_obj_flag = false;
         points_image_flag = false;
@@ -318,7 +318,7 @@ void image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
         points_image_flag = false;
     }
 }
-void points_image_callback(const points2image::PointsImage::ConstPtr&amp; points_image_msg) {
+void points_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; points_image_msg) {
     if (points_image_flag) {
         image_obj_flag = false;
         points_image_flag = false;
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\sync_obj_fusion.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\sync_obj_fusion.cpp" added_lines="24" deleted_lines="24">
				<diff>@@ -1,6 +1,6 @@
 #include "ros/ros.h"
-#include "cv_tracker_msgs/obj_label.h"
-#include "lidar_tracker/centroids.h"
+#include "autoware_msgs/obj_label.h"
+#include "autoware_msgs/centroids.h"
 #include "visualization_msgs/MarkerArray.h"
 #include "sync.hpp"
 
@@ -13,7 +13,7 @@ int main(int argc, char **argv) {
     std::string pub1("/obj_label");
     std::string pub2("/cluster_centroids");
 
-    Synchronizer&lt;cv_tracker_msgs::obj_label, lidar_tracker::centroids, visualization_msgs::MarkerArray&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
+    Synchronizer&lt;autoware_msgs::obj_label, autoware_msgs::centroids, visualization_msgs::MarkerArray&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
     synchronizer.run();
 
     return 0;
@@ -39,8 +39,8 @@ int main(int argc, char **argv) {
 #include &lt;pthread.h&gt;
 #include "t_sync_message.h"
 /* user header */
-#include "cv_tracker_msgs/obj_label.h"
-#include "lidar_tracker/centroids.h"
+#include "autoware_msgs/obj_label.h"
+#include "autoware_msgs/centroids.h"
 #include "visualization_msgs/MarkerArray.h"
 
 /* ----mode---- */
@@ -51,8 +51,8 @@ int main(int argc, char **argv) {
 bool buf_flag;
 pthread_mutex_t mutex;
 /* user var */
-boost::circular_buffer&lt;cv_tracker_msgs::obj_label&gt; obj_label_ringbuf(10);
-boost::circular_buffer&lt;lidar_tracker::centroids&gt; cluster_centroids_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::obj_label&gt; obj_label_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::centroids&gt; cluster_centroids_ringbuf(10);
 ros::Publisher obj_label__pub;
 ros::Publisher cluster_centroids__pub;
 bool obj_pose_flag;
@@ -71,10 +71,10 @@ double get_time(const std_msgs::Header *timespec) {
 
 
 #if _REQ_PUB
-cv_tracker_msgs::obj_label* p_obj_label_buf;
-lidar_tracker::centroids* p_cluster_centroids_buf;
+autoware_msgs::obj_label* p_obj_label_buf;
+autoware_msgs::centroids* p_cluster_centroids_buf;
 
-void publish_msg(cv_tracker_msgs::obj_label* p_obj_label_buf, lidar_tracker::centroids* p_cluster_centroids_buf)
+void publish_msg(autoware_msgs::obj_label* p_obj_label_buf, autoware_msgs::centroids* p_cluster_centroids_buf)
 {
     ROS_INFO("publish");
     obj_label__pub.publish(*p_obj_label_buf);
@@ -98,7 +98,7 @@ bool publish() {
         // obj_label &gt; cluster_centroids
         if (get_time(&amp;(obj_label_ringbuf.front().header)) &gt;= get_time(&amp;(cluster_centroids_ringbuf.front().header))) {
             p_cluster_centroids_buf = &amp;(cluster_centroids_ringbuf.front());
-            boost::circular_buffer&lt;cv_tracker_msgs::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
             if (obj_label_ringbuf.size() == 1) {
                 p_obj_label_buf = &amp;*it;
                 publish_msg(p_obj_label_buf, p_cluster_centroids_buf);
@@ -125,7 +125,7 @@ bool publish() {
         // obj_label &lt; cluster_centroids
         else {
             p_obj_label_buf = &amp;(obj_label_ringbuf.front());
-            boost::circular_buffer&lt;lidar_tracker::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
             if (cluster_centroids_ringbuf.size() == 1) {
                 p_cluster_centroids_buf = &amp;*it;
                 publish_msg(p_obj_label_buf, p_cluster_centroids_buf);
@@ -163,7 +163,7 @@ bool publish() {
     }
 }
 
-void obj_label_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
+void obj_label_callback(const autoware_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
     pthread_mutex_lock(&amp;mutex);
     obj_label_ringbuf.push_front(*obj_label_msg);
     //cluster_centroids is empty
@@ -182,7 +182,7 @@ void obj_label_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; obj_label_ms
     pthread_mutex_unlock(&amp;mutex);
 }
 
-void cluster_centroids_callback(const lidar_tracker::centroids::ConstPtr&amp; cluster_centroids_msg) {
+void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluster_centroids_msg) {
     pthread_mutex_lock(&amp;mutex);
     cluster_centroids_ringbuf.push_front(*cluster_centroids_msg);
     //obj_label is empty
@@ -203,8 +203,8 @@ void cluster_centroids_callback(const lidar_tracker::centroids::ConstPtr&amp; cluste
 }
 
 #else
-cv_tracker_msgs::obj_label obj_label_buf;
-lidar_tracker::centroids cluster_centroids_buf;
+autoware_msgs::obj_label obj_label_buf;
+autoware_msgs::centroids cluster_centroids_buf;
 
 bool publish() {
     if (buf_flag) {
@@ -224,7 +224,7 @@ bool publish() {
     }
 }
 
-void obj_label_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
+void obj_label_callback(const autoware_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
     pthread_mutex_lock(&amp;mutex);
     obj_label_ringbuf.push_front(*obj_label_msg);
 
@@ -240,7 +240,7 @@ void obj_label_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; obj_label_ms
     // obj_label &gt; cluster_centroids
     if (get_time(&amp;(obj_label_ringbuf.front().header)) &gt;= get_time(&amp;(cluster_centroids_ringbuf.front().header))) {
         cluster_centroids_buf = cluster_centroids_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker_msgs::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
         if (obj_label_ringbuf.size() == 1) {
             obj_label_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -265,7 +265,7 @@ void obj_label_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; obj_label_ms
 
     } else {
         obj_label_buf = obj_label_ringbuf.front();
-        boost::circular_buffer&lt;lidar_tracker::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
         if (cluster_centroids_ringbuf.size() == 1) {
             cluster_centroids_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -292,7 +292,7 @@ void obj_label_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; obj_label_ms
     pthread_mutex_unlock(&amp;mutex);
 }
 
-void cluster_centroids_callback(const lidar_tracker::centroids::ConstPtr&amp; cluster_centroids_msg) {
+void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluster_centroids_msg) {
     pthread_mutex_lock(&amp;mutex);
     cluster_centroids_ringbuf.push_front(*cluster_centroids_msg);
     //obj_label is empty
@@ -307,7 +307,7 @@ void cluster_centroids_callback(const lidar_tracker::centroids::ConstPtr&amp; cluste
     // obj_label &gt; cluster_centroids
     if (get_time(&amp;(obj_label_ringbuf.front().header)) &gt;= get_time(&amp;(cluster_centroids_ringbuf.front().header))) {
         cluster_centroids_buf = cluster_centroids_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker_msgs::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
         if (obj_label_ringbuf.size() == 1) {
             obj_label_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -332,7 +332,7 @@ void cluster_centroids_callback(const lidar_tracker::centroids::ConstPtr&amp; cluste
 
     } else {
         obj_label_buf = obj_label_ringbuf.front();
-        boost::circular_buffer&lt;lidar_tracker::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
         if (cluster_centroids_ringbuf.size() == 1) {
             cluster_centroids_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -409,8 +409,8 @@ int main(int argc, char **argv) {
 
     ros::Subscriber obj_label_sub = nh.subscribe("/obj_label", 1, obj_label_callback);
     ros::Subscriber cluster_centroids_sub = nh.subscribe("/cluster_centroids", 1, cluster_centroids_callback);
-    obj_label__pub = nh.advertise&lt;cv_tracker_msgs::obj_label&gt;("/sync_obj_fusion/obj_label", 5);
-    cluster_centroids__pub = nh.advertise&lt;lidar_tracker::centroids&gt;("/sync_obj_fusion/cluster_centroids", 5);
+    obj_label__pub = nh.advertise&lt;autoware_msgs::obj_label&gt;("/sync_obj_fusion/obj_label", 5);
+    cluster_centroids__pub = nh.advertise&lt;autoware_msgs::centroids&gt;("/sync_obj_fusion/cluster_centroids", 5);
     while (!buf_flag &amp;&amp; ros::ok()) {
         ros::spinOnce();
         usleep(100000);
</diff>
			</file>
			<file old_path="ros\src\system\sync\test.cpp" new_path="ros\src\system\sync\test.cpp" added_lines="11" deleted_lines="11">
				<diff>@@ -18,7 +18,7 @@
 #include "t_sync_message.h"
 /* user header */
 #include "cv_tracker/obj_label.h"
-#include "lidar_tracker/centroids.h"
+#include "autoware_msgs/centroids.h"
 #include "visualization_msgs/MarkerArray.h"
 
 /* ----mode---- */
@@ -30,7 +30,7 @@ bool buf_flag;
 pthread_mutex_t mutex;
 /* user var */
 boost::circular_buffer&lt;cv_tracker::obj_label&gt; obj_label_ringbuf(10);
-boost::circular_buffer&lt;lidar_tracker::centroids&gt; cluster_centroids_ringbuf(10);
+boost::circular_buffer&lt;autoware_msgs::centroids&gt; cluster_centroids_ringbuf(10);
 ros::Publisher obj_label__pub;
 ros::Publisher cluster_centroids__pub;
 bool obj_pose_flag;
@@ -50,9 +50,9 @@ double get_time(const std_msgs::Header *timespec) {
 
 #if _REQ_PUB
 cv_tracker::obj_label* p_obj_label_buf;
-lidar_tracker::centroids* p_cluster_centroids_buf;
+autoware_msgs::centroids* p_cluster_centroids_buf;
 
-void publish_msg(cv_tracker::obj_label* p_obj_label_buf, lidar_tracker::centroids* p_cluster_centroids_buf)
+void publish_msg(cv_tracker::obj_label* p_obj_label_buf, autoware_msgs::centroids* p_cluster_centroids_buf)
 {
     ROS_INFO("publish");
     obj_label__pub.publish(*p_obj_label_buf);
@@ -103,7 +103,7 @@ bool publish() {
         // obj_label &lt; cluster_centroids
         else {
             p_obj_label_buf = &amp;(obj_label_ringbuf.front());
-            boost::circular_buffer&lt;lidar_tracker::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
+            boost::circular_buffer&lt;autoware_msgs::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
             if (cluster_centroids_ringbuf.size() == 1) {
                 p_cluster_centroids_buf = &amp;*it;
                 publish_msg(p_obj_label_buf, p_cluster_centroids_buf);
@@ -159,7 +159,7 @@ void obj_label_callback(const cv_tracker::obj_label::ConstPtr&amp; obj_label_msg) {
     pthread_mutex_unlock(&amp;mutex);
 }
 
-void cluster_centroids_callback(const lidar_tracker::centroids::ConstPtr&amp; cluster_centroids_msg) {
+void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluster_centroids_msg) {
     pthread_mutex_lock(&amp;mutex);
     cluster_centroids_ringbuf.push_front(*cluster_centroids_msg);
     //obj_label is empty
@@ -180,7 +180,7 @@ void cluster_centroids_callback(const lidar_tracker::centroids::ConstPtr&amp; cluste
 
 #else
 cv_tracker::obj_label obj_label_buf;
-lidar_tracker::centroids cluster_centroids_buf;
+autoware_msgs::centroids cluster_centroids_buf;
 
 bool publish() {
     if (buf_flag) {
@@ -241,7 +241,7 @@ void obj_label_callback(const cv_tracker::obj_label::ConstPtr&amp; obj_label_msg) {
 
     } else {
         obj_label_buf = obj_label_ringbuf.front();
-        boost::circular_buffer&lt;lidar_tracker::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
         if (cluster_centroids_ringbuf.size() == 1) {
             cluster_centroids_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -268,7 +268,7 @@ void obj_label_callback(const cv_tracker::obj_label::ConstPtr&amp; obj_label_msg) {
     pthread_mutex_unlock(&amp;mutex);
 }
 
-void cluster_centroids_callback(const lidar_tracker::centroids::ConstPtr&amp; cluster_centroids_msg) {
+void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluster_centroids_msg) {
     pthread_mutex_lock(&amp;mutex);
     cluster_centroids_ringbuf.push_front(*cluster_centroids_msg);
     //obj_label is empty
@@ -308,7 +308,7 @@ void cluster_centroids_callback(const lidar_tracker::centroids::ConstPtr&amp; cluste
 
     } else {
         obj_label_buf = obj_label_ringbuf.front();
-        boost::circular_buffer&lt;lidar_tracker::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
+        boost::circular_buffer&lt;autoware_msgs::centroids&gt;::iterator it = cluster_centroids_ringbuf.begin();
         if (cluster_centroids_ringbuf.size() == 1) {
             cluster_centroids_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -383,7 +383,7 @@ int main(int argc, char **argv) {
     ros::Subscriber obj_label_sub = nh.subscribe("/obj_car/obj_label", 1, obj_label_callback);
     ros::Subscriber cluster_centroids_sub = nh.subscribe("/cluster_centroids", 1, cluster_centroids_callback);
     obj_label__pub = nh.advertise&lt;cv_tracker::obj_label&gt;("/obj_car/obj_label_", 5);
-    cluster_centroids__pub = nh.advertise&lt;lidar_tracker::centroids&gt;("/cluster_centroids_", 5);
+    cluster_centroids__pub = nh.advertise&lt;autoware_msgs::centroids&gt;("/cluster_centroids_", 5);
     while (!buf_flag) {
         ros::spinOnce();
         usleep(100000);
</diff>
			</file>
			<file old_path="ros\src\system\sync\time_monitor.cpp" new_path="ros\src\system\sync\time_monitor.cpp" added_lines="28" deleted_lines="28">
				<diff>@@ -37,13 +37,13 @@
 /* user header */
 #include "sensor_msgs/Image.h"
 #include "sensor_msgs/PointCloud2.h"
-#include "cv_tracker_msgs/image_obj.h"
-#include "points2image/PointsImage.h"
-#include "cv_tracker_msgs/image_obj_ranged.h"
-#include "cv_tracker_msgs/image_obj_tracked.h"
+#include "autoware_msgs/image_obj.h"
+#include "autoware_msgs/PointsImage.h"
+#include "autoware_msgs/image_obj_ranged.h"
+#include "autoware_msgs/image_obj_tracked.h"
 #include "geometry_msgs/PoseStamped.h"
-#include "cv_tracker_msgs/obj_label.h"
-#include "lidar_tracker/centroids.h"
+#include "autoware_msgs/obj_label.h"
+#include "autoware_msgs/centroids.h"
 #include "visualization_msgs/MarkerArray.h"
 #include "synchronization/time_monitor.h"
 #include "synchronization/time_diff.h"
@@ -178,22 +178,22 @@ public:
     TimeManager(int);
     void image_raw_callback(const sensor_msgs::Image::ConstPtr&amp; image_raw_msg);
     void points_raw_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; points_raw_msg);
-    void points_image_callback(const points2image::PointsImage::ConstPtr&amp; points_image_msg);
+    void points_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; points_image_msg);
     void vscan_points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; vscan_points_msg);
-    void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image_msg);
-    void image_obj_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; image_obj_msg);
-    void image_obj_ranged_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg);
-    void image_obj_tracked_callback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg);
+    void vscan_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; vscan_image_msg);
+    void image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg);
+    void image_obj_ranged_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg);
+    void image_obj_tracked_callback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg);
     void current_pose_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg);
-    void obj_label_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; obj_label_msg) ;
-    void cluster_centroids_callback(const lidar_tracker::centroids::ConstPtr&amp; cluster_centroids_msg);
+    void obj_label_callback(const autoware_msgs::obj_label::ConstPtr&amp; obj_label_msg) ;
+    void cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluster_centroids_msg);
 //    void obj_pose_callback(const visualization_msgs::MarkerArray::ConstPtr&amp; obj_pose_msg);
     void obj_pose_callback(const std_msgs::Time::ConstPtr&amp; obj_pose_timestamp_msg);
     // sync
-    void sync_image_obj_ranged_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; sync_image_obj_msg);
-    void sync_image_obj_tracked_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; sync_image_obj_ranged_msg);
-    void sync_obj_label_callback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; sync_image_obj_tracked_msg);
-    void sync_obj_pose_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; sync_obj_label_msg);
+    void sync_image_obj_ranged_callback(const autoware_msgs::image_obj::ConstPtr&amp; sync_image_obj_msg);
+    void sync_image_obj_tracked_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; sync_image_obj_ranged_msg);
+    void sync_obj_label_callback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; sync_image_obj_tracked_msg);
+    void sync_obj_pose_callback(const autoware_msgs::obj_label::ConstPtr&amp; sync_obj_label_msg);
     // time difference
     void time_diff_callback(const synchronization::time_diff::ConstPtr&amp; time_diff_msg);
     void run();
@@ -261,7 +261,7 @@ void TimeManager::points_raw_callback(const sensor_msgs::PointCloud2::ConstPtr&amp;
     points_raw_.push_front(points_raw_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::points_image_callback(const points2image::PointsImage::ConstPtr&amp; points_image_msg) {
+void TimeManager::points_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; points_image_msg) {
 //    ROS_INFO("vscan_image: \t\t\t%d.%d", vscan_image_msg-&gt;header.stamp.sec, vscan_image_msg-&gt;header.stamp.nsec);
     points_image_.push_front(points_image_msg-&gt;header.stamp, get_walltime_now());
 }
@@ -271,22 +271,22 @@ void TimeManager::vscan_points_callback(const sensor_msgs::PointCloud2::ConstPtr
     vscan_points_.push_front(vscan_points_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image_msg) {
+void TimeManager::vscan_image_callback(const autoware_msgs::PointsImage::ConstPtr&amp; vscan_image_msg) {
 //    ROS_INFO("vscan_image: \t\t\t%d.%d", vscan_image_msg-&gt;header.stamp.sec, vscan_image_msg-&gt;header.stamp.nsec);
     vscan_image_.push_front(vscan_image_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::image_obj_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
+void TimeManager::image_obj_callback(const autoware_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
 //    ROS_INFO("image_obj: \t\t\t%d.%d", image_obj_msg-&gt;header.stamp.sec, image_obj_msg-&gt;header.stamp.nsec);
     image_obj_.push_front(image_obj_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::image_obj_ranged_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
+void TimeManager::image_obj_ranged_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
 //    ROS_INFO("image_obj_ranged: \t\t%d.%d", image_obj_ranged_msg-&gt;header.stamp.sec, image_obj_ranged_msg-&gt;header.stamp.nsec);
     image_obj_ranged_.push_front(image_obj_ranged_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::image_obj_tracked_callback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
+void TimeManager::image_obj_tracked_callback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
 //    ROS_INFO("image_obj_tracked: \t\t%d.%d", image_obj_tracked_msg-&gt;header.stamp.sec, image_obj_tracked_msg-&gt;header.stamp.nsec);
     image_obj_tracked_.push_front(image_obj_tracked_msg-&gt;header.stamp, get_walltime_now());
 }
@@ -296,33 +296,33 @@ void TimeManager::current_pose_callback(const geometry_msgs::PoseStamped::ConstP
     current_pose_.push_front(current_pose_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::obj_label_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
+void TimeManager::obj_label_callback(const autoware_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
 //    ROS_INFO("obj_label: \t\t\t%d.%d", obj_label_msg-&gt;header.stamp.sec, obj_label_msg-&gt;header.stamp.nsec);
     obj_label_.push_front(obj_label_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::cluster_centroids_callback(const lidar_tracker::centroids::ConstPtr&amp; cluster_centroids_msg) {
+void TimeManager::cluster_centroids_callback(const autoware_msgs::centroids::ConstPtr&amp; cluster_centroids_msg) {
 //    ROS_INFO("cluster_centroids: \t\t%d.%d", cluster_centroids_msg-&gt;header.stamp.sec, cluster_centroids_msg-&gt;header.stamp.nsec);
     cluster_centroids_.push_front(cluster_centroids_msg-&gt;header.stamp, get_walltime_now());
 }
 
 /* sync */
-void TimeManager::sync_image_obj_ranged_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; sync_image_obj_msg) {
+void TimeManager::sync_image_obj_ranged_callback(const autoware_msgs::image_obj::ConstPtr&amp; sync_image_obj_msg) {
 //    ROS_INFO("sync_image_obj_ranged: \t\t%d.%d", sync_image_obj_msg-&gt;header.stamp.sec, sync_image_obj_msg-&gt;header.stamp.nsec);
     sync_image_obj_ranged_.push_front(sync_image_obj_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::sync_image_obj_tracked_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; sync_image_obj_ranged_msg) {
+void TimeManager::sync_image_obj_tracked_callback(const autoware_msgs::image_obj_ranged::ConstPtr&amp; sync_image_obj_ranged_msg) {
 //    ROS_INFO("sync_image_obj_tracked: \t%d.%d", sync_image_obj_ranged_msg-&gt;header.stamp.sec, sync_image_obj_ranged_msg-&gt;header.stamp.nsec);
     sync_image_obj_tracked_.push_front(sync_image_obj_ranged_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::sync_obj_label_callback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; sync_image_obj_tracked_msg) {
+void TimeManager::sync_obj_label_callback(const autoware_msgs::image_obj_tracked::ConstPtr&amp; sync_image_obj_tracked_msg) {
 //    ROS_INFO("sync_obj_label: \t\t%d.%d", sync_image_obj_tracked_msg-&gt;header.stamp.sec, sync_image_obj_tracked_msg-&gt;header.stamp.nsec);
     sync_obj_label_.push_front(sync_image_obj_tracked_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::sync_obj_pose_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; sync_obj_label_msg) {
+void TimeManager::sync_obj_pose_callback(const autoware_msgs::obj_label::ConstPtr&amp; sync_obj_label_msg) {
 //    ROS_INFO("sync_obj_pose: \t\t\t%d.%d", sync_obj_label_msg-&gt;header.stamp.sec, sync_obj_label_msg-&gt;header.stamp.nsec);
     sync_obj_pose_.push_front(sync_obj_label_msg-&gt;header.stamp, get_walltime_now());
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="39a5250fc663475af8bb1f1cb69894fa6303f729" author="AMC">
		<msg>Fixes for GPU Euclidean clustering</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\gpu_euclidean_clustering.cu" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\gpu_euclidean_clustering.cu" added_lines="2" deleted_lines="2">
				<diff>@@ -360,7 +360,7 @@ extern "C" __global__ void resetClusterIndexes(int *cluster_indices, int *cluste
  *
  * Result of this method is stored at cluster_indices_host_.
  */
-void GpuEuclideanCluster::extractClusters()
+void GpuEuclideanCluster::extractClustersOld()
 {
 	int block_x, grid_x;
 
@@ -591,7 +591,7 @@ extern "C" __global__ void clustersIntersecCheck(int *cluster_matrix, int *chang
  * are larger than threshold), which may lead to infinite loop in the first method.
  */
 
-void GpuEuclideanCluster::extractClusters2()
+void GpuEuclideanCluster::extractClusters()
 {
 	int block_x, grid_x;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\includes\gpu_euclidean_clustering.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\includes\gpu_euclidean_clustering.h" added_lines="1" deleted_lines="1">
				<diff>@@ -24,8 +24,8 @@ public:
 	void setThreshold(double threshold);
 	void setMinClusterPts(int min_cluster_pts);
 	void setMaxClusterPts(int max_cluster_pts);
+	void extractClustersOld();
 	void extractClusters();
-	void extractClusters2();
 	std::vector&lt;GClusterIndex&gt; getOutput();
 
 	SamplePointListXYZ generateSample();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="919f07600b4cba0cb43a03f90e605bd217f59b01" author="Manato Hirabayashi">
		<msg>Extract context operations as class method for future shared-use</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\Context.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\Context.cpp" added_lines="132" deleted_lines="0">
				<diff>@@ -10,3 +10,135 @@ Context::Context(cv::Point aRedCenter, cv::Point aYellowCenter, cv::Point aGreen
 	topLeft = aTopLeft;
 	botRight = aBotRight;
 }
+
+
+/*
+  define magnitude relationship of context
+ */
+bool Context::CompareContext(const Context left, const Context right)
+{
+  /* if lampRadius is bigger, context is smaller */
+  return left.lampRadius &gt;= right.lampRadius;
+} /* static bool compareContext() */
+
+
+void Context::SetContexts(std::vector&lt;Context&gt; &amp;contexts,
+                          const road_wizard::Signals::ConstPtr &amp;extracted_pos,
+                          const int frame_row,
+                          const int frame_column) {
+  /* copy parts of data to local variable */
+  std::vector&lt;road_wizard::ExtractedPosition&gt; signals;
+  std::vector&lt;road_wizard::ExtractedPosition&gt;::iterator sig_iterator;
+  for (unsigned int i=0; i&lt;extracted_pos-&gt;Signals.size(); i++ )
+    {
+      road_wizard::ExtractedPosition tmp;
+      tmp.signalId = extracted_pos-&gt;Signals.at(i).signalId;
+      tmp.u        = extracted_pos-&gt;Signals.at(i).u;
+      tmp.v        = extracted_pos-&gt;Signals.at(i).v;
+      tmp.radius   = extracted_pos-&gt;Signals.at(i).radius;
+      tmp.x        = extracted_pos-&gt;Signals.at(i).x;
+      tmp.y        = extracted_pos-&gt;Signals.at(i).y;
+      tmp.z        = extracted_pos-&gt;Signals.at(i).z;
+      tmp.type     = extracted_pos-&gt;Signals.at(i).type;
+      tmp.linkId   = extracted_pos-&gt;Signals.at(i).linkId;
+      tmp.plId     = extracted_pos-&gt;Signals.at(i).plId;
+      signals.push_back(tmp);
+    }
+
+  std::vector&lt;int&gt; plid_vector;
+  for (sig_iterator=signals.begin(); sig_iterator&lt;signals.end(); sig_iterator++) {
+    plid_vector.push_back(sig_iterator-&gt;plId);
+  }
+
+  /* get array that has unique PLID values as its element */
+  std::sort(plid_vector.begin(), plid_vector.end());
+  std::vector&lt;int&gt;::iterator new_end = std::unique(plid_vector.begin(), plid_vector.end());
+  plid_vector.erase(new_end, plid_vector.end());
+
+  std::vector&lt;Context&gt; updatedSignals;
+
+  /* assemble fragmented signal lamp in a context */
+  for (unsigned int ctx_idx=0; ctx_idx&lt;plid_vector.size(); ctx_idx++)
+    {
+      Context ctx;
+      int min_radius  = INT_MAX;
+      int most_left   = frame_column;
+      int most_top    = frame_row;
+      int most_right  = 0;
+      int most_bottom = 0;
+
+      for (sig_iterator=signals.begin(); sig_iterator&lt;signals.end(); sig_iterator++)
+        {
+          int img_x = sig_iterator-&gt;u;
+          int img_y = sig_iterator-&gt;v;
+          double map_x = sig_iterator-&gt;x;
+          double map_y = sig_iterator-&gt;y;
+          double map_z = sig_iterator-&gt;z;
+          int radius = sig_iterator-&gt;radius;
+          if (sig_iterator-&gt;plId == plid_vector.at(ctx_idx) &amp;&amp;
+              0 &lt; img_x - radius - 1.5 * radius &amp;&amp; img_x + radius + 1.5 * radius &lt; frame_column &amp;&amp;
+              0 &lt; img_y - radius - 1.5 * radius &amp;&amp; img_y + radius + 1.5 * radius &lt; frame_row)
+            {
+              switch (sig_iterator-&gt;type) {
+              case 1:           /* RED */
+                ctx.redCenter   = cv::Point( img_x, img_y );
+                ctx.redCenter3d = cv::Point3d( map_x, map_y, map_z );
+                break;
+              case 2:           /* GREEN */
+                ctx.greenCenter   = cv::Point( img_x, img_y );
+                ctx.greenCenter3d = cv::Point3d( map_x, map_y, map_z );
+                break;
+              case 3:           /* YELLOW */
+                ctx.yellowCenter   = cv::Point( img_x, img_y );
+                ctx.yellowCenter3d = cv::Point3d( map_x, map_y, map_z );
+                ctx.signalID       = sig_iterator-&gt;signalId; // use yellow light signalID as this context's representative
+                break;
+              default:          /* this signal is not for cars (for pedestrian or something) */
+                continue;
+              }
+              min_radius    = (min_radius &gt; radius) ? radius : min_radius;
+              most_left     = (most_left &gt; img_x - radius -   1.5 * min_radius)  ? img_x - radius - 1.5 * min_radius : most_left;
+              most_top      = (most_top &gt; img_y - radius -    1.5 * min_radius)  ? img_y - radius - 1.5 * min_radius : most_top;
+              most_right    = (most_right &lt; img_x + radius +  1.5 * min_radius)  ? img_x + radius + 1.5 * min_radius : most_right;
+              most_bottom   = (most_bottom &lt; img_y + radius + 1.5 * min_radius)  ? img_y + radius + 1.5 * min_radius : most_bottom;
+            }
+        }
+
+      ctx.lampRadius = min_radius;
+      ctx.topLeft    = cv::Point(most_left, most_top);
+      ctx.botRight   = cv::Point(most_right, most_bottom);
+      ctx.lightState = UNDEFINED;
+      ctx.stateJudgeCount = 0;
+
+      /* search whether this signal has already belonged in detector.contexts */
+      bool isInserted = false;
+      std::vector&lt;int&gt; eraseCandidate;
+      for (unsigned int i = 0; i &lt; contexts.size(); i++) {
+        if (ctx.signalID == contexts.at(i).signalID &amp;&amp; ctx.lampRadius != INT_MAX)
+          {
+            /* update to new information except to lightState */
+            updatedSignals.push_back(ctx);
+            updatedSignals.back().lightState      = contexts.at(i).lightState;
+            updatedSignals.back().stateJudgeCount = contexts.at(i).stateJudgeCount;
+            isInserted = true;
+            break;
+          }
+
+      }
+
+      if (isInserted == false &amp;&amp; ctx.lampRadius != INT_MAX)
+        updatedSignals.push_back(ctx); // this ctx is new in detector.contexts
+
+    }
+
+  /* sort by lampRadius */
+  std::sort(updatedSignals.begin(), updatedSignals.end(), CompareContext);
+
+  /* reset detector.contexts */
+  contexts.clear();
+  contexts.resize(updatedSignals.size());
+  for (unsigned int i=0; i&lt;updatedSignals.size(); i++) {
+    contexts.at(i) = updatedSignals.at(i);
+  }
+
+} /* std::vector&lt;Context&gt; Context::SetContexts() */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\Context.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\Context.h" added_lines="10" deleted_lines="0">
				<diff>@@ -1,7 +1,9 @@
 #ifndef CONTEXT_H
 #define CONTEXT_H
 
+#include &lt;vector&gt;
 #include &lt;opencv2/core/core.hpp&gt;
+#include "road_wizard/Signals.h"
 
 enum LightState { GREEN, YELLOW, RED, UNDEFINED };
 
@@ -10,6 +12,11 @@ public:
 	Context(){};
 	Context(cv::Point aRedCenter, cv::Point aYellowCenter, cv::Point aGreenCenter,
 		int aLampRadius, cv::Point aTopLeft, cv::Point aBotRight);
+        static void SetContexts(std::vector&lt;Context&gt; &amp;contexts, 
+                                const road_wizard::Signals::ConstPtr &amp;extracted_pos,
+                                const int frame_row,
+                                const int frame_colmuns);
+
 	cv::Point redCenter;
 	cv::Point yellowCenter;
 	cv::Point greenCenter;
@@ -22,6 +29,9 @@ public:
 	LightState lightState;
 	int signalID;
 	int stateJudgeCount;
+
+ private:
+        static bool CompareContext(const Context left, const Context right);
 };
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" added_lines="3" deleted_lines="128">
				<diff>@@ -9,6 +9,7 @@
 #include &lt;sstream&gt;
 #include &lt;runtime_manager/traffic_light.h&gt;
 #include &lt;std_msgs/String.h&gt;
+#include "road_wizard/Signals.h"
 #include "road_wizard/TunedResult.h"
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
@@ -174,7 +175,8 @@ static void extractedPos_cb(const road_wizard::Signals::ConstPtr&amp; extractedPos)
   if (frame.empty())
     return;
 
-  setContexts(detector, extractedPos);
+  /* Set subscribed signal position into detector */
+  Context::SetContexts(detector.contexts, extractedPos, frame.rows, frame.cols);
 
   detector.brightnessDetect(frame);
 
@@ -433,130 +435,3 @@ int main(int argc, char* argv[]) {
 } /* int main() */
 
 
-/*
-  define magnitude relationship of context
- */
-static bool compareContext(const Context left, const Context right)
-{
-  /* if lampRadius is bigger, context is smaller */
-  return left.lampRadius &gt;= right.lampRadius;
-} /* static bool compareContext() */
-
-
-void setContexts(TrafficLightDetector &amp;detector,
-                 const road_wizard::Signals::ConstPtr&amp; extractedPos)
-{
-
-  /* copy parts of data to local variable */
-  std::vector&lt;road_wizard::ExtractedPosition&gt; signals;
-  std::vector&lt;road_wizard::ExtractedPosition&gt;::iterator sig_iterator;
-  for (unsigned int i=0; i&lt;extractedPos-&gt;Signals.size(); i++ )
-    {
-      road_wizard::ExtractedPosition tmp;
-      tmp.signalId = extractedPos-&gt;Signals.at(i).signalId;
-      tmp.u        = extractedPos-&gt;Signals.at(i).u;
-      tmp.v        = extractedPos-&gt;Signals.at(i).v;
-      tmp.radius   = extractedPos-&gt;Signals.at(i).radius;
-      tmp.x        = extractedPos-&gt;Signals.at(i).x;
-      tmp.y        = extractedPos-&gt;Signals.at(i).y;
-      tmp.z        = extractedPos-&gt;Signals.at(i).z;
-      tmp.type     = extractedPos-&gt;Signals.at(i).type;
-      tmp.linkId   = extractedPos-&gt;Signals.at(i).linkId;
-      tmp.plId     = extractedPos-&gt;Signals.at(i).plId;
-      signals.push_back(tmp);
-    }
-
-  std::vector&lt;int&gt; plid_vector;
-  for (sig_iterator=signals.begin(); sig_iterator&lt;signals.end(); sig_iterator++) {
-    plid_vector.push_back(sig_iterator-&gt;plId);
-  }
-
-  /* get array that has unique PLID values as its element */
-  std::sort(plid_vector.begin(), plid_vector.end());
-  std::vector&lt;int&gt;::iterator new_end = std::unique(plid_vector.begin(), plid_vector.end());
-  plid_vector.erase(new_end, plid_vector.end());
-
-  std::vector&lt;Context&gt; updatedSignals;
-
-  /* assemble fragmented signal lamp in a context */
-  for (unsigned int ctx_idx=0; ctx_idx&lt;plid_vector.size(); ctx_idx++)
-    {
-      Context ctx;
-      int min_radius  = INT_MAX;
-      int most_left   = frame.cols;
-      int most_top    = frame.rows;
-      int most_right  = 0;
-      int most_bottom = 0;
-
-      for (sig_iterator=signals.begin(); sig_iterator&lt;signals.end(); sig_iterator++)
-        {
-          int img_x = sig_iterator-&gt;u;
-          int img_y = sig_iterator-&gt;v;
-          double map_x = sig_iterator-&gt;x;
-          double map_y = sig_iterator-&gt;y;
-          double map_z = sig_iterator-&gt;z;
-          int radius = sig_iterator-&gt;radius;
-          if (sig_iterator-&gt;plId == plid_vector.at(ctx_idx) &amp;&amp;
-              0 &lt; img_x - radius - 1.5 * radius &amp;&amp; img_x + radius + 1.5 * radius &lt; frame.cols &amp;&amp;
-              0 &lt; img_y - radius - 1.5 * radius &amp;&amp; img_y + radius + 1.5 * radius &lt; frame.rows)
-            {
-              switch (sig_iterator-&gt;type) {
-              case 1:           /* RED */
-                ctx.redCenter   = cv::Point( img_x, img_y );
-                ctx.redCenter3d = cv::Point3d( map_x, map_y, map_z );
-                break;
-              case 2:           /* GREEN */
-                ctx.greenCenter   = cv::Point( img_x, img_y );
-                ctx.greenCenter3d = cv::Point3d( map_x, map_y, map_z );
-                break;
-              case 3:           /* YELLOW */
-                ctx.yellowCenter   = cv::Point( img_x, img_y );
-                ctx.yellowCenter3d = cv::Point3d( map_x, map_y, map_z );
-                ctx.signalID       = sig_iterator-&gt;signalId; // use yellow light signalID as this context's representative
-                break;
-              default:          /* this signal is not for cars (for pedestrian or something) */
-                continue;
-              }
-              min_radius    = (min_radius &gt; radius) ? radius : min_radius;
-              most_left     = (most_left &gt; img_x - radius -   1.5 * min_radius)  ? img_x - radius - 1.5 * min_radius : most_left;
-              most_top      = (most_top &gt; img_y - radius -    1.5 * min_radius)  ? img_y - radius - 1.5 * min_radius : most_top;
-              most_right    = (most_right &lt; img_x + radius +  1.5 * min_radius)  ? img_x + radius + 1.5 * min_radius : most_right;
-              most_bottom   = (most_bottom &lt; img_y + radius + 1.5 * min_radius)  ? img_y + radius + 1.5 * min_radius : most_bottom;
-            }
-        }
-
-      ctx.lampRadius = min_radius;
-      ctx.topLeft    = cv::Point(most_left, most_top);
-      ctx.botRight   = cv::Point(most_right, most_bottom);
-      ctx.lightState = UNDEFINED;
-      ctx.stateJudgeCount = 0;
-
-      /* search whether this signal has already belonged in detector.contexts */
-      bool isInserted = false;
-      std::vector&lt;int&gt; eraseCandidate;
-      for (unsigned int i=0; i&lt;detector.contexts.size(); i++) {
-        if (ctx.signalID == detector.contexts.at(i).signalID &amp;&amp; ctx.lampRadius != INT_MAX)
-          {
-            /* update to new information except to lightState */
-            updatedSignals.push_back(ctx);
-            updatedSignals.back().lightState      = detector.contexts.at(i).lightState;
-            updatedSignals.back().stateJudgeCount = detector.contexts.at(i).stateJudgeCount;
-            isInserted = true;
-            break;
-          }
-
-      }
-
-      if (isInserted == false &amp;&amp; ctx.lampRadius != INT_MAX)
-        updatedSignals.push_back(ctx); // this ctx is new in detector.contexts
-
-    }
-
-  /* reset detector.contexts */
-  detector.contexts.clear();
-  detector.contexts.resize(updatedSignals.size());
-  std::sort(updatedSignals.begin(), updatedSignals.end(), compareContext); // sort by lampRadius
-  for (unsigned int i=0; i&lt;updatedSignals.size(); i++) {
-    detector.contexts.at(i) = updatedSignals.at(i);
-  }
-} /* void setContexts() */
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="121065ee390ffd37c874b7e86d1f4709e2703dbf" author="Manato Hirabayashi">
		<msg>Move context-regarding files as package header and library</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\Context.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\include\Context.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\Context.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\lib\Context.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="658576954a941c1b7d177b9cbe8f1982771e13e5" author="Manato Hirabayashi">
		<msg>Modify output format in VOC data one

* Change the directory structure
* Output each annotation file separately in XML format
* Add position coordinate of traffic light in a image into annotation</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\custom_graphics_view.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\custom_graphics_view.cpp" added_lines="120" deleted_lines="6">
				<diff>@@ -2,12 +2,17 @@
 
 #include &lt;iostream&gt;
 #include &lt;QTimeLine&gt;
-#include &lt;QGraphicsScene&gt;
-#include &lt;QPainter&gt;
 
 
 CustomGraphicsView::CustomGraphicsView(QWidget *parent) :
-  QGraphicsView(parent) {
+  QGraphicsView(parent),
+  scheduled_scalings_(0),
+  rectangle_item_(nullptr),
+  k_initial_position_(QPoint(-1, -1)),
+  start_position_(k_initial_position_),
+  end_position_(k_initial_position_),
+  dragging_(false) {
+  // Set background color as Black
   setStyleSheet("background-color:black");
 }
 
@@ -45,7 +50,7 @@ void CustomGraphicsView::wheelEvent(QWheelEvent *event) {
 
 
 void CustomGraphicsView::ScalingTime(qreal) {
-  qreal factor = 1.0 + qreal(scheduled_scalings_) / 300;
+  qreal factor = 1.0 + qreal(scheduled_scalings_) / 300.0;
   scale(factor, factor);
 }
 
@@ -54,12 +59,16 @@ void CustomGraphicsView::FinishAnimation() {
   if (scheduled_scalings_ &gt; 0) {
     scheduled_scalings_--;
   } else {
+    scheduled_scalings_++;
     sender()-&gt;~QObject();
   }
 }
 
 
 void CustomGraphicsView::ResetDisplay() {
+  ResetSelectedArea();
+
+  // Reset all contents in the view
   resetCachedContent();
   scene_.clear();
 }
@@ -70,8 +79,8 @@ void CustomGraphicsView::SetPixmap(const QImage &amp;image) {
   ResetDisplay();
 
   // Set Specified image
-  original_image_ = image;
-  scene_.addPixmap(QPixmap::fromImage(image));
+  original_image_ = image.copy();
+  scene_.addPixmap(QPixmap::fromImage(original_image_));
   setScene(&amp;scene_);
   setAlignment(Qt::AlignCenter);
   show();
@@ -88,3 +97,108 @@ void CustomGraphicsView::SetText(const QString &amp;text) {
   setAlignment(Qt::AlignCenter);
   show();
 }
+
+
+void CustomGraphicsView::mousePressEvent(QMouseEvent *mouse_event) {
+  if (mouse_event-&gt;button() == Qt::LeftButton) {
+    // Get start position of specified region on the image coordinate
+    start_position_ = ConvertPointOnImage(mouse_event-&gt;pos());
+    dragging_ = true;
+  }
+}
+
+
+void CustomGraphicsView::mouseMoveEvent(QMouseEvent *mouse_event) {
+  // Check whether dragging
+  if (dragging_) {
+    // Delete current rectangle
+    if (rectangle_item_ != nullptr) {
+      scene_.removeItem(rectangle_item_);
+      delete rectangle_item_;
+      rectangle_item_ = nullptr;
+    }
+
+    // Draw new rectangle
+    QRectF current_selection(start_position_, mapToScene(mouse_event-&gt;pos()));
+    rectangle_item_ = new QGraphicsRectItem(current_selection);
+    rectangle_item_-&gt;setPen(QPen(Qt::NoPen)); // Show no border line
+    rectangle_item_-&gt;setBrush(QColor(0, 0, 255, 125)); // Show in transparent blue
+    scene_.addItem(rectangle_item_);
+  }
+}
+
+
+void CustomGraphicsView::mouseReleaseEvent(QMouseEvent *mouse_event) {
+  if (mouse_event-&gt;button() == Qt::LeftButton) {
+    // Get end position of specified region on the image coordinate
+    end_position_ = ConvertPointOnImage(mouse_event-&gt;pos());
+    dragging_ = false;
+  }
+}
+
+
+QPoint CustomGraphicsView::ConvertPointOnImage(QPoint point) {
+  // Convert global point coordinate value into scene (image) coordinate value
+  QPointF scene_point = mapToScene(point);
+
+  QPoint converted_point(scene_point.x(), scene_point.y());
+  QPoint limit(original_image_.size().width() - 1, original_image_.size().height() - 1);
+
+  // Check range of x
+  if (converted_point.x() &lt; 0) {
+    converted_point.setX(0);
+  } else if (limit.x() &lt; converted_point.x()) {
+    converted_point.setX(limit.x());
+  }
+
+  // Check range of y
+  if (converted_point.y() &lt; 0) {
+    converted_point.setY(0);
+  } else if (limit.y() &lt; converted_point.y()) {
+    converted_point.setY(limit.y());
+  }
+
+  return converted_point;
+}
+
+
+bool CustomGraphicsView::GetSelectedArea(QPoint *left_upper, QPoint *right_bottom) {
+  // If area specification has not been done, return false
+  if (start_position_ == k_initial_position_ ||
+      end_position_ == k_initial_position_) {
+    return false;
+  }
+
+  // Assign surely "Left-Upper" and "Right-Bottom" coordinate value of selected area
+  if (start_position_.x() &lt;= end_position_.x()) {
+    left_upper-&gt;setX(start_position_.x());
+    right_bottom-&gt;setX(end_position_.x());
+  } else {
+    left_upper-&gt;setX(end_position_.x());
+    right_bottom-&gt;setX(start_position_.x());
+  }
+
+  if (start_position_.y() &lt;= end_position_.y()) {
+    left_upper-&gt;setY(start_position_.y());
+    right_bottom-&gt;setY(end_position_.y());
+  } else {
+    left_upper-&gt;setY(end_position_.y());
+    right_bottom-&gt;setY(start_position_.y());
+  }
+
+  return true;
+}
+
+
+void CustomGraphicsView::ResetSelectedArea() {
+  // Remove displayed rectangle
+  if (rectangle_item_ != nullptr) {
+    scene_.removeItem(rectangle_item_);
+    delete rectangle_item_;
+    rectangle_item_ = nullptr;
+  }
+
+  // Reset selected coordinate
+  start_position_ = k_initial_position_;
+  end_position_ = k_initial_position_;
+}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\custom_graphics_view.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\custom_graphics_view.h" added_lines="24" deleted_lines="0">
				<diff>@@ -6,6 +6,8 @@
 #include &lt;QPixmap&gt;
 #include &lt;QImage&gt;
 #include &lt;QGraphicsScene&gt;
+#include &lt;QMouseEvent&gt;
+#include &lt;QGraphicsRectItem&gt;
 
 
 class CustomGraphicsView : public QGraphicsView
@@ -22,6 +24,12 @@ public:
   // The function to set text
   void SetText(const QString&amp; text);
 
+  // The function to return selected area
+  bool GetSelectedArea(QPoint* left_upper, QPoint* right_bottom);
+
+  // The function to reset selected area
+  void ResetSelectedArea();
+
 private slots:
   void ScalingTime(qreal /* x */);
   void FinishAnimation();
@@ -31,15 +39,31 @@ protected:
   // Ref: https://wiki.qt.io/SmoothZoomInQGraphicsView
   virtual void wheelEvent(QWheelEvent *event);
 
+  // Custom mouse event slot in order to get specified position
+  virtual void mousePressEvent(QMouseEvent* mouse_event);
+  virtual void mouseMoveEvent(QMouseEvent* mouse_event);
+  virtual void mouseReleaseEvent(QMouseEvent* mouse_event);
+
+  // How many times scaling is done
   int scheduled_scalings_;
 
 private:
   // The utility function to reset display
   void ResetDisplay();
 
+  // The utility function to convert point coordinate into valid image coordinate
+  QPoint ConvertPointOnImage(QPoint point);
+
   // Stuffs to show image on display
   QGraphicsScene scene_;
+  QGraphicsRectItem* rectangle_item_;
   QImage original_image_;
+
+  // Stuffs to specify area on an image
+  const QPoint k_initial_position_;
+  QPoint start_position_;
+  QPoint end_position_;
+  bool dragging_;
 };
 
 #endif // CUSTOMQLABEL_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\file_system_operator.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\file_system_operator.cpp" added_lines="107" deleted_lines="50">
				<diff>@@ -7,8 +7,10 @@
 #include &lt;sstream&gt;
 #include &lt;vector&gt;
 
+#include &lt;tinyxml.h&gt;
+
 FileSystemOperator::FileSystemOperator():
-  file_path_("") {
+  target_directory_path_("") {
 }
 
 
@@ -46,74 +48,129 @@ std::map&lt;int, std::string&gt; FileSystemOperator::GetImageList(const std::string di
 }  // std::map&lt;int, std::string&gt; FileSystemOperation::GetImageList()
 
 
-void FileSystemOperator::CheckFileExistance(std::string file_name) {
-  file_path_ = file_name;
+void FileSystemOperator::CheckPreSavedData(std::string target_dir_name) {
+  target_directory_path_ = target_dir_name;
 
-  // Check whether specified file already exist
-  struct stat status;
-  if (stat(file_path_.c_str(), &amp;status) == 0 &amp;&amp;
-      S_ISREG(status.st_mode)) { // specified file already exist
-    LoadFileContents();
+  // Check whether specified directory already exist
+  struct stat directory_status;
+  if (stat(target_directory_path_.c_str(), &amp;directory_status) == 0) {
+    // Specified directory already exist
+    LoadPreSavedContents();
+  } else {
+    // Newly create directory
+    mkdir(target_directory_path_.c_str(), 0755);
   }
 }
 
 
-void FileSystemOperator::LoadFileContents() {
-  // Open the file for read
-  std::ifstream file_handler_for_read;
-  file_handler_for_read.open(file_path_);
+void FileSystemOperator::LoadPreSavedContents() {
+  struct dirent *entry;
+  DIR *directory_handler = opendir(target_directory_path_.c_str());
 
-  // Load file contents line by line
-  std::string line_string;
-  while (getline(file_handler_for_read, line_string)) {
-    if (line_string.at(0) == '#') { // The line started from '#' is comment line
-      continue;
-    }
+  // Load all annotation file data in the specified directory
+  while ((entry = readdir(directory_handler)) != NULL) {
+    // Get entry's status (file name, permission...etc)
+    struct stat status;
+    std::string absolute_path = target_directory_path_ + std::string(entry-&gt;d_name);
 
-    // Divide each element by ','
-    std::string token;
-    std::vector&lt;std::string&gt; elements;
-    std::istringstream string_stream(line_string);
-    while (getline(string_stream, token, ',')) {
-      elements.push_back(token);
-    }
+    if (stat(absolute_path.c_str(), &amp;status) == 0 &amp;&amp;
+        S_ISREG(status.st_mode)) { // This entry is surely nomal file
+      LabelData loaded_data;
 
-    LabelData line_data = {elements[0],
-                           static_cast&lt;LightState&gt;(std::atoi(elements[1].c_str()))};
+      // Open this xml file
+      TiXmlDocument xml_document(absolute_path);
+      xml_document.LoadFile();
 
-    // Get image ID from file name
-    int image_id = GetFileIDFromFilePath(line_data.file_name);
+      // Parse its contents and insert into the structure
+      TiXmlElement* root = xml_document.FirstChildElement("annotation");
 
-    // Insert data into class member
-    label_data_list_[image_id] = line_data;
-  }
+      TiXmlElement* folder = root-&gt;FirstChildElement("folder");
+      loaded_data.folder_name = std::string(folder-&gt;GetText());
+
+      TiXmlElement* file = root-&gt;FirstChildElement("filename");
+      loaded_data.file_name = std::string(file-&gt;GetText());
 
-  // Close the file handler
-  file_handler_for_read.close();
+      TiXmlElement* object = root-&gt;FirstChildElement("object");
+      TiXmlElement* name = object-&gt;FirstChildElement("name");
+      loaded_data.state = static_cast&lt;LightState&gt;(std::atoi(name-&gt;GetText()));
+
+      TiXmlElement* bounding_box = object-&gt;FirstChildElement("bndbox");
+      TiXmlElement* x_min = bounding_box-&gt;FirstChildElement("xmin");
+      TiXmlElement* y_min = bounding_box-&gt;FirstChildElement("ymin");
+      TiXmlElement* x_max = bounding_box-&gt;FirstChildElement("xmax");
+      TiXmlElement* y_max = bounding_box-&gt;FirstChildElement("ymax");
+      loaded_data.x_start = std::atoi(x_min-&gt;GetText());
+      loaded_data.y_start = std::atoi(y_min-&gt;GetText());
+      loaded_data.x_end = std::atoi(x_max-&gt;GetText());
+      loaded_data.y_end = std::atoi(y_max-&gt;GetText());
+
+      // Insert loaded data into list
+      int file_id = GetFileIDFromFilePath(entry-&gt;d_name);
+      label_data_list_[file_id] = loaded_data;
+    }
+  }
 }
 
 
-void FileSystemOperator::WriteStateToFile(std::string file_name, LightState state) {
+void FileSystemOperator::WriteStateToFile(std::string folder_name,
+                                          std::string file_name,
+                                          LightState state,
+                                          int x_start,
+                                          int y_start,
+                                          int x_end,
+                                          int y_end) {
   int image_id = GetFileIDFromFilePath(file_name);
-  LabelData label_data{file_name, state};
+  LabelData label_data{folder_name,
+        file_name,
+        state,
+        x_start,
+        y_start,
+        x_end,
+        y_end};
 
   // Insert specified data into data list (if this ID's data already exist, it will be overwritten)
   label_data_list_[image_id] = label_data;
 
-  // Open the file handler with overwritten mode
-  std::ofstream file_handler_for_write;
-  file_handler_for_write.open(file_path_, std::ios::trunc);
-
-  // Write file format information as comment
-  file_handler_for_write &lt;&lt; "# format: \"&lt;file_name&gt;,&lt;state: GREEN=0 YELLOW=1 RED=2 UNKNOWN=3&gt;\"" &lt;&lt; std::endl;
-
-  // Rewrite all of the file contents
-  for (const auto&amp; data : label_data_list_) {
-    file_handler_for_write &lt;&lt; data.second.file_name &lt;&lt; "," &lt;&lt; data.second.state &lt;&lt; std::endl;
-  }
-
-  file_handler_for_write.close();
-
+  // Create XML data
+  TiXmlDocument xml_data;
+
+  TiXmlElement* root = new TiXmlElement("annotation");
+  xml_data.LinkEndChild(root);
+
+  TiXmlElement* folder = new TiXmlElement("folder");
+  folder-&gt;LinkEndChild(new TiXmlText(label_data_list_[image_id].folder_name));
+  root-&gt;LinkEndChild(folder);
+
+  TiXmlElement* file = new TiXmlElement("filename");
+  file-&gt;LinkEndChild(new TiXmlText(label_data_list_[image_id].file_name));
+  root-&gt;LinkEndChild(file);
+
+  TiXmlElement* object = new TiXmlElement("object");
+  TiXmlElement* name = new TiXmlElement("name");
+  name-&gt;LinkEndChild(new TiXmlText(std::to_string(label_data_list_[image_id].state)));
+  object-&gt;LinkEndChild(name);
+
+  TiXmlElement* bounding_box = new TiXmlElement("bndbox");
+  TiXmlElement* x_min = new TiXmlElement("xmin");
+  x_min-&gt;LinkEndChild(new TiXmlText(std::to_string(label_data_list_[image_id].x_start)));
+  TiXmlElement* y_min = new TiXmlElement("ymin");
+  y_min-&gt;LinkEndChild(new TiXmlText(std::to_string(label_data_list_[image_id].y_start)));
+  TiXmlElement* x_max = new TiXmlElement("xmax");
+  x_max-&gt;LinkEndChild(new TiXmlText(std::to_string(label_data_list_[image_id].x_end)));
+  TiXmlElement* y_max = new TiXmlElement("ymax");
+  y_max-&gt;LinkEndChild(new TiXmlText(std::to_string(label_data_list_[image_id].y_end)));
+  bounding_box-&gt;LinkEndChild(x_min);
+  bounding_box-&gt;LinkEndChild(y_min);
+  bounding_box-&gt;LinkEndChild(x_max);
+  bounding_box-&gt;LinkEndChild(y_max);
+
+  object-&gt;LinkEndChild(bounding_box);
+
+  root-&gt;LinkEndChild(object);
+
+  // Save XML data
+  std::string xml_file_name = target_directory_path_ + std::to_string(image_id) + ".xml";
+  xml_data.SaveFile(xml_file_name);
 }
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\file_system_operator.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\file_system_operator.h" added_lines="18" deleted_lines="7">
				<diff>@@ -18,27 +18,38 @@ public:
   // The function to get all image file name in the specified directory
   std::map&lt;int, std::string&gt; GetImageList(const std::string diectory_path);
 
-  // The function to check the existance of specified file
-  void CheckFileExistance(std::string file_path);
+  // The function to check the presaved annotation files
+  void CheckPreSavedData(std::string target_dir_name);
 
   // The function to write specified state into file
-  void WriteStateToFile(std::string file_name, LightState state);
+  void WriteStateToFile(std::string folder_name,
+                        std::string file_name,
+                        LightState state,
+                        int x_start,
+                        int y_start,
+                        int x_end,
+                        int y_end);
 
 private:
   // The data structure to hold label data
   struct LabelData {
+    std::string folder_name;
     std::string file_name;
     LightState state;
+    int x_start;
+    int y_start;
+    int x_end;
+    int y_end;
   };
 
-  // The function to load the contents of already exist file
-  void LoadFileContents();
+  // The function to load the contents of already exist annotation file
+  void LoadPreSavedContents();
 
   // The utility function to get image ID from image file name
   int GetFileIDFromFilePath(std::string path);
 
-  // The path to the target file
-  std::string file_path_;
+  // The path for a directory that annotation files to be saved
+  std::string target_directory_path_;
 
   // The data list to be written into the target file
   std::map&lt;int, LabelData&gt; label_data_list_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\label_maker_gui.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\label_maker_gui.cpp" added_lines="42" deleted_lines="6">
				<diff>@@ -21,12 +21,12 @@ LabelMakerGui::LabelMakerGui(QWidget *parent) :
   image_list_ = file_system_operator_.GetImageList(dataset_path_.toStdString() + "/Images/");
 
   // Open target file for saving data
-  file_system_operator_.CheckFileExistance(dataset_path_.toStdString() + "/label.csv");
+  file_system_operator_.CheckPreSavedData(dataset_path_.toStdString() + "/Annotations/");
 
   // Setup GUI
   ui_-&gt;image_id_horizontal_slider_-&gt;setMaximum(image_list_.size() - 1);
   ui_-&gt;image_id_spin_box_-&gt;setMaximum(image_list_.size() - 1);
-  ResetRadioButtons();
+  ResetRadioButtonsBackGround();
 
   // Display first image
   ShowImage();
@@ -62,6 +62,10 @@ LabelMakerGui::LabelMakerGui(QWidget *parent) :
           this,
           SLOT(SaveAndGoPrevious()));
 
+  connect(ui_-&gt;reset_push_button_,
+          SIGNAL(pressed()),
+          this,
+          SLOT(ResetSelection()));
 } // LabelMakerGui::LabelMakerGui()
 
 
@@ -105,7 +109,7 @@ QString LabelMakerGui::GetTargetDirectoryPath() {
 } // QString LabelMakerGui::GetTargetDirectoryPath() {
 
 
-void LabelMakerGui::ResetRadioButtons() {
+void LabelMakerGui::ResetRadioButtonsBackGround() {
   // Reset radio buttons' background color
   ui_-&gt;green_radio_button_-&gt;setStyleSheet("background-color:grey");
   ui_-&gt;yellow_radio_button_-&gt;setStyleSheet("background-color:grey");
@@ -132,7 +136,7 @@ void LabelMakerGui::ShowImage() {
 
 void LabelMakerGui::SetRadioButtonsColor(QAbstractButton *selected_button) {
   // Reset background
-  ResetRadioButtons();
+  ResetRadioButtonsBackGround();
 
   // Change background color of radio button to corresponding color
   QString button_name = selected_button-&gt;text();
@@ -172,10 +176,25 @@ bool LabelMakerGui::SaveCurrentState() {
   }
 
   int current_image_id = ui_-&gt;image_id_spin_box_-&gt;text().toInt();
-  std::string current_image_file = "Images/" + image_list_[current_image_id]; // Image file should be under "Image" directory
+
+  // Get selected area
+  QPoint start;
+  QPoint end;
+  if (!ui_-&gt;graphics_view_-&gt;GetSelectedArea(&amp;start, &amp;end)) {
+    QMessageBox::warning(this,
+                         "WARNING",
+                         "No Area is specified.");
+    return false;
+  }
 
   // Save specified state into file
-  file_system_operator_.WriteStateToFile(current_image_file, state);
+  file_system_operator_.WriteStateToFile("Images", // Image file should be under "Image" directory
+                                         image_list_[current_image_id],
+                                         state,
+                                         start.x(),
+                                         start.y(),
+                                         end.x(),
+                                         end.y());
   return true;
 }
 
@@ -216,3 +235,20 @@ void LabelMakerGui::SaveAndGoPrevious() {
   }
   ui_-&gt;image_id_spin_box_-&gt;setValue(image_id);
 }
+
+
+void LabelMakerGui::ResetSelection() {
+  // Reset radiobutton selection
+  ui_-&gt;radio_button_group_-&gt;setExclusive(false);
+  ui_-&gt;green_radio_button_-&gt;setChecked(false);
+  ui_-&gt;yellow_radio_button_-&gt;setChecked(false);
+  ui_-&gt;red_radio_button_-&gt;setChecked(false);
+  ui_-&gt;unknown_radio_button_-&gt;setChecked(false);
+  ui_-&gt;radio_button_group_-&gt;setExclusive(true);
+
+  // Reset radiobuttons background
+  ResetRadioButtonsBackGround();
+
+  // Reset selected area
+  ui_-&gt;graphics_view_-&gt;ResetSelectedArea();
+}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\label_maker_gui.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\label_maker_gui.h" added_lines="3" deleted_lines="1">
				<diff>@@ -34,12 +34,14 @@ private slots:
   void SaveAndGoNext();
   void SaveAndGoPrevious();
 
+  // The behavior of "Reset Selection" button
+  void ResetSelection();
 private:
   // The utility function to get directory path
   QString GetTargetDirectoryPath();
 
   // Reset radio buttons status
-  void ResetRadioButtons();
+  void ResetRadioButtonsBackGround();
 
   // Save the current status
   bool SaveCurrentState();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="eb2aec623b888c3dd84fa191ebcc8555da0c308c" author="Manato Hirabayashi">
		<msg>Add filter not to save similar images</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\roi_extractor\roi_extractor.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\roi_extractor\roi_extractor.cpp" added_lines="64" deleted_lines="1">
				<diff>@@ -46,10 +46,21 @@ void RoiExtractor::RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extra
   cv::Mat roi = frame_(cv::Rect(signal_positions.at(0).topLeft, signal_positions.at(0).botRight));
   std::string file_name = target_directory_ + std::to_string(file_count_) + ".png";
 
+  // Reject image if its height is smaller than threshold
+  if (roi.size().height &lt; k_minimum_height_) {
+    return;
+  }
+
+  // Reject image if its similarity level with previous saved ROI is higher than threshold 
+  if (k_similarity_threshold_ &lt; CalculateSimilarity(roi, previous_saved_frame_)) {
+    return;
+  }
+
   cv::imwrite(file_name.c_str(), roi);
   file_count_++;
   
   previous_timestamp_ = frame_timestamp_;
+  previous_saved_frame_ = roi.clone();
 } // void RoiExtractor::RoiSignalCallback()
 
 
@@ -114,6 +125,54 @@ void RoiExtractor::MakeDirectoryTree(const std::string &amp;target,
   }
 } // void RoiExtractor::MakeDirectoryTree()
 
+
+// calculae similarity of specified two images
+// by comparing their histogram, which is sensitive filter for color
+double RoiExtractor::CalculateSimilarity(const cv::Mat &amp;image1, const cv::Mat &amp;image2) {
+  if (image1.empty() || image2.empty()) {
+    return 0.0;
+  }
+
+  // Compare by histogram
+  cv::Mat image1_hsv, image2_hsv;
+  cv::cvtColor(image1, image1_hsv, CV_BGR2HSV);
+  cv::cvtColor(image2, image2_hsv, CV_BGR2HSV);
+
+  const int channel[] = {0};
+
+  // Hue range in OpenCV is 0 to 180
+  const float hue_ranges[] = {0, 180};
+  const float* ranges[] = {hue_ranges};
+
+  // Quantize hue value into 6
+  int hist_size[] = {6};
+
+  cv::Mat histogram1;
+  cv::calcHist(&amp;image1_hsv,
+               1,               // Use this image only to create histogram
+               channel,
+               cv::Mat(),       // No mask is used
+               histogram1,
+               1,               // The dimension of histogram is 1
+               hist_size,
+               ranges);
+
+   cv::Mat histogram2;
+   cv::calcHist(&amp;image2_hsv,
+                1,              // Use this image only to create histogram
+                channel,
+                cv::Mat(),      // No mask is used
+                histogram2,
+                1,              // The dimension of histogram is 1
+                hist_size,
+                ranges);
+
+   double similarity = cv::compareHist(histogram1, histogram2, CV_COMP_CORREL);
+
+   return similarity;
+} // void RoiExtractor::CalculateSimilarity()
+
+
 // Entry Point of this node
 int main (int argc, char *argv[]) {
   // Initialize ROS node
@@ -123,11 +182,15 @@ int main (int argc, char *argv[]) {
   ros::NodeHandle private_node_handler;
   std::string image_topic_name;
   std::string target_directory_name = std::string(getenv("HOME")) + "/.autoware";
+  int minimum_height = 32;
+  double similarity_threshold = 0.9;
   private_node_handler.param&lt;std::string&gt;("image_raw_topic", image_topic_name, "/image_raw");
   private_node_handler.param&lt;std::string&gt;("target_directory", target_directory_name, target_directory_name);
+  private_node_handler.param&lt;int&gt;("minimum_height", minimum_height, 32); // The default minimum height is 32
+  private_node_handler.param&lt;double&gt;("similarity_threshold", similarity_threshold, 0.9); // The default similarity threshold is 0.9
 
   // Get directory name which roi images will be saved
-  RoiExtractor extractor;
+  RoiExtractor extractor(minimum_height, similarity_threshold);
   extractor.CreateTargetDirectory(target_directory_name);
 
   // Launch callback function to subscribe images and signal position
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\roi_extractor\roi_extractor.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\roi_extractor\roi_extractor.h" added_lines="18" deleted_lines="1">
				<diff>@@ -14,7 +14,12 @@
 
 class RoiExtractor {
  public:
-  explicit RoiExtractor(){};
+  explicit RoiExtractor(int minimum_height, double similarity_threshold):
+    k_minimum_height_(minimum_height),
+    k_similarity_threshold_(similarity_threshold),
+    previous_saved_frame_(cv::Mat())
+  {};
+
   ~RoiExtractor(){};
 
   // Callback functions to obtain images and signal position
@@ -31,6 +36,9 @@ class RoiExtractor {
   // Utility function to create directory tree
   void MakeDirectoryTree(const std::string &amp;target, const std::string &amp;base, const mode_t &amp;mode);
 
+  // The function to calculate similarity of two image
+  double CalculateSimilarity(const cv::Mat &amp;image1, const cv::Mat &amp;image2);
+
   // Directory path that extracted ROI images will be saved
   std::string target_directory_;
 
@@ -43,6 +51,15 @@ class RoiExtractor {
 
   // The number of files contained in the target directory
   int file_count_;
+
+  // The minimum height threshold of ROI image that will be saved
+  const int k_minimum_height_;
+
+  // The threshold of the level of similarity
+  const double k_similarity_threshold_;
+
+  // The image saved last time
+  cv::Mat previous_saved_frame_;
 };
 
 #endif // ROI_EXTRACTOR_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4d106800f95372cb6fa9361c2e8a45755b530449" author="Manato Hirabayashi">
		<msg>Add image size section into annotation xml to fit VOC style</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\custom_graphics_view.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\custom_graphics_view.cpp" added_lines="5" deleted_lines="0">
				<diff>@@ -202,3 +202,8 @@ void CustomGraphicsView::ResetSelectedArea() {
   start_position_ = k_initial_position_;
   end_position_ = k_initial_position_;
 }
+
+
+QSize CustomGraphicsView::GetImageSize() {
+  return original_image_.size();
+}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\custom_graphics_view.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\custom_graphics_view.h" added_lines="3" deleted_lines="0">
				<diff>@@ -30,6 +30,9 @@ public:
   // The function to reset selected area
   void ResetSelectedArea();
 
+  // The function to return original image's size
+  QSize GetImageSize();
+
 private slots:
   void ScalingTime(qreal /* x */);
   void FinishAnimation();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\file_system_operator.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\file_system_operator.cpp" added_lines="26" deleted_lines="0">
				<diff>@@ -90,6 +90,14 @@ void FileSystemOperator::LoadPreSavedContents() {
       TiXmlElement* file = root-&gt;FirstChildElement("filename");
       loaded_data.file_name = std::string(file-&gt;GetText());
 
+      TiXmlElement* size = root-&gt;FirstChildElement("size");
+      TiXmlElement* width = size-&gt;FirstChildElement("width");
+      TiXmlElement* height = size-&gt;FirstChildElement("height");
+      TiXmlElement* depth = size-&gt;FirstChildElement("depth");
+      loaded_data.width = std::atoi(width-&gt;GetText());
+      loaded_data.height = std::atoi(height-&gt;GetText());
+      loaded_data.depth = std::atoi(depth-&gt;GetText());
+
       TiXmlElement* object = root-&gt;FirstChildElement("object");
       TiXmlElement* name = object-&gt;FirstChildElement("name");
       loaded_data.state = static_cast&lt;LightState&gt;(std::atoi(name-&gt;GetText()));
@@ -115,6 +123,9 @@ void FileSystemOperator::LoadPreSavedContents() {
 void FileSystemOperator::WriteStateToFile(std::string folder_name,
                                           std::string file_name,
                                           LightState state,
+                                          int image_height,
+                                          int image_width,
+                                          int image_depth,
                                           int x_start,
                                           int y_start,
                                           int x_end,
@@ -123,6 +134,9 @@ void FileSystemOperator::WriteStateToFile(std::string folder_name,
   LabelData label_data{folder_name,
         file_name,
         state,
+        image_height,
+        image_width,
+        image_depth,
         x_start,
         y_start,
         x_end,
@@ -145,6 +159,18 @@ void FileSystemOperator::WriteStateToFile(std::string folder_name,
   file-&gt;LinkEndChild(new TiXmlText(label_data_list_[image_id].file_name));
   root-&gt;LinkEndChild(file);
 
+  TiXmlElement* size = new TiXmlElement("size");
+  TiXmlElement* width = new TiXmlElement("width");
+  width-&gt;LinkEndChild(new TiXmlText(std::to_string(label_data_list_[image_id].width)));
+  TiXmlElement* height = new TiXmlElement("height");
+  height-&gt;LinkEndChild(new TiXmlText(std::to_string(label_data_list_[image_id].height)));
+  TiXmlElement* depth = new TiXmlElement("depth");
+  depth-&gt;LinkEndChild(new TiXmlText(std::to_string(label_data_list_[image_id].depth)));
+  size-&gt;LinkEndChild(width);
+  size-&gt;LinkEndChild(height);
+  size-&gt;LinkEndChild(depth);
+  root-&gt;LinkEndChild(size);
+
   TiXmlElement* object = new TiXmlElement("object");
   TiXmlElement* name = new TiXmlElement("name");
   name-&gt;LinkEndChild(new TiXmlText(std::to_string(label_data_list_[image_id].state)));
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\file_system_operator.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\file_system_operator.h" added_lines="6" deleted_lines="0">
				<diff>@@ -25,6 +25,9 @@ public:
   void WriteStateToFile(std::string folder_name,
                         std::string file_name,
                         LightState state,
+                        int image_height,
+                        int image_width,
+                        int image_depth,
                         int x_start,
                         int y_start,
                         int x_end,
@@ -36,6 +39,9 @@ private:
     std::string folder_name;
     std::string file_name;
     LightState state;
+    int height;
+    int width;
+    int depth;
     int x_start;
     int y_start;
     int x_end;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\label_maker_gui.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\label_maker\label_maker_gui.cpp" added_lines="7" deleted_lines="0">
				<diff>@@ -187,10 +187,17 @@ bool LabelMakerGui::SaveCurrentState() {
     return false;
   }
 
+  // Get image property
+  QSize image_size = ui_-&gt;graphics_view_-&gt;GetImageSize();
+  int image_depth = 3; // This program assume input image is color (3 channel) image
+
   // Save specified state into file
   file_system_operator_.WriteStateToFile("Images", // Image file should be under "Image" directory
                                          image_list_[current_image_id],
                                          state,
+                                         image_size.height(),
+                                         image_size.width(),
+                                         image_depth,
                                          start.x(),
                                          start.y(),
                                          end.x(),
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0fccd8175a9d42fa9d626ce29d44e964767ac1b4" author="Manato Hirabayashi">
		<msg>Add roi_extractor.launch to make handling parameter easy

And fixed small bug to get parameter from ROS private parameter server</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\roi_extractor\roi_extractor.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\roi_extractor\roi_extractor.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -179,7 +179,7 @@ int main (int argc, char *argv[]) {
   ros::init(argc, argv, "roi_extractor");
 
   // Get source topic name of image from ROS private parameter
-  ros::NodeHandle private_node_handler;
+  ros::NodeHandle private_node_handler("~");
   std::string image_topic_name;
   std::string target_directory_name = std::string(getenv("HOME")) + "/.autoware";
   int minimum_height = 32;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bd68ddf18e2e171b5c4bf12e6ef7fcd275733c04" author="Manato Hirabayashi">
		<msg>Modify State Transition Matrix of TLR for more precise recognition

* w.r.t `region_tlr`, just fixed comment
* w.r.t `region_tlr_ssd`, applied manner of erring on the side of caution</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLightDetector.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLightDetector.h" added_lines="1" deleted_lines="1">
				<diff>@@ -16,7 +16,7 @@
 #define MY_COLOR_WHITE	cv::Scalar(255,255,255)
 
 const LightState STATE_TRANSITION_MATRIX[4][8] = {
-	/* current RYG: 000, 001, 010, 011, 100, 101, 110, 111 */
+	/* current GYR: 000, 001, 010, 011, 100, 101, 110, 111 */
 	{ GREEN,     UNDEFINED, YELLOW,    YELLOW, GREEN,     GREEN,     YELLOW, UNDEFINED }, /* pre = GREEN  */
 	{ YELLOW,    RED,       YELLOW,    RED,    UNDEFINED, UNDEFINED, YELLOW, UNDEFINED }, /* pre = YELLOW */
 	{ RED,       RED,       UNDEFINED, RED,    GREEN,     RED,       GREEN,  UNDEFINED }, /* pre = RED */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.h" added_lines="5" deleted_lines="5">
				<diff>@@ -29,12 +29,12 @@ class RegionTlrSsdRosNode {
   /* Light state transition probably happen in Japanese traffic light */
   const LightState kStateTransitionMatrix[4][4] = {
     /* current: */
-    /* GREEN   , YELLOW    , RED       , UNDEFINED  */
+    /* GREEN   , YELLOW    , RED    , UNDEFINED  */
     /* -------------------------------------------  */
-    {GREEN     , YELLOW    , UNDEFINED , GREEN}  ,  /* | previous = GREEN */
-    {UNDEFINED , YELLOW    , RED       , YELLOW} ,  /* | previous = YELLOW */
-    {GREEN     , UNDEFINED , RED       , RED}    ,  /* | previous = RED */
-    {GREEN     , YELLOW    , RED       , UNDEFINED} /* | previous = UNDEFINED */
+    {GREEN     , YELLOW    , YELLOW , GREEN}  ,  /* | previous = GREEN */
+    {UNDEFINED , YELLOW    , RED    , YELLOW} ,  /* | previous = YELLOW */
+    {GREEN     , RED       , RED    , RED}    ,  /* | previous = RED */
+    {GREEN     , YELLOW    , RED    , UNDEFINED} /* | previous = UNDEFINED */
   };
 
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ea03a1e0ad34d5771af9e67d40829b82d1e1d1f2" author="Manato Hirabayashi">
		<msg>Fix usage of std::string::substr</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\roi_extractor\roi_extractor.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\roi_extractor\roi_extractor.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -117,7 +117,7 @@ void RoiExtractor::MakeDirectoryTree(const std::string &amp;target,
   size_t separator_end = sub_tree.find("/", separator_start + 1);
   std::string path = base;
   while (separator_end != std::string::npos) {
-    std::string sub_directory = sub_tree.substr(separator_start, separator_end);
+    std::string sub_directory = sub_tree.substr(separator_start, separator_end - separator_start);
     path = path + sub_directory;
     mkdir(path.c_str(), mode);
     separator_start = separator_end;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e74458fa2fad1860510a9c091c4e50efb760dcfa" author="Manato Hirabayashi">
		<msg>Apply vector_map_server function</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" added_lines="88" deleted_lines="1">
				<diff>@@ -15,12 +15,16 @@
 #include &lt;sensor_msgs/CameraInfo.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;geometry_msgs/Pose.h&gt;
+#include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;signal.h&gt;
 #include &lt;cstdio&gt;
 #include "Math.h"
 #include &lt;Eigen/Eigen&gt;
 #include "road_wizard/Signals.h"
 #include &lt;runtime_manager/adjust_xy.h&gt;
+#include &lt;vector_map/vector_map.h&gt;
+#include &lt;vector_map_server/GetSignal.h&gt;
+#include &lt;waypoint_follower/lane.h&gt;
 
 static std::string camera_id_str;
 
@@ -48,8 +52,51 @@ static  float fx,
   cy;
 static tf::StampedTransform trf;
 
+static bool g_use_vector_map_server; // Switch flag whether vecter-map-server function will be used
+static ros::ServiceClient g_ros_client;
+
 #define SignalLampRadius 0.3
 
+/* Define utility class to use vector map server */
+namespace
+{
+  class VectorMapClient
+  {
+  private:
+    geometry_msgs::PoseStamped pose_;
+    waypoint_follower::lane waypoints_;
+
+  public:
+    VectorMapClient()
+    {}
+
+    ~VectorMapClient()
+    {}
+
+    geometry_msgs::PoseStamped pose() const
+    {
+      return pose_;
+    }
+
+    waypoint_follower::lane waypoints() const
+    {
+      return waypoints_;
+    }
+
+    void set_pose(const geometry_msgs::PoseStamped&amp; pose)
+    {
+      pose_ = pose;
+    }
+
+    void set_waypoints(const waypoint_follower::lane&amp; waypoints)
+    {
+      waypoints_ = waypoints;
+    }
+  }; // Class VectorMapClient
+} // namespace
+static VectorMapClient g_vector_map_client;
+
+
 /* Callback function to shift projection result */
 void adjust_xyCallback (const runtime_manager::adjust_xy::ConstPtr&amp; config_msg)
 {
@@ -183,6 +230,35 @@ void echoSignals2 (ros::Publisher &amp;pub, bool useOpenGLCoord=false)
   int countPoint = 0;
   road_wizard::Signals signalsInFrame;
 
+  /* Get signals on the path if vecter_map_server is enabled */
+  if (g_use_vector_map_server) {
+    vector_map_server::GetSignal service;
+    /* Set server's request */
+    service.request.pose = g_vector_map_client.pose();
+    service.request.waypoints = g_vector_map_client.waypoints();
+
+    /* Get server's response*/
+    if (g_ros_client.call(service)) {
+      /* Reset signal data container */
+      vmap.signals.clear();
+
+      /* Newle insert signal data on the path */
+      for (const auto&amp; response: service.response.objects.data) {
+        if (response.id == 0)
+          continue;
+
+        Signal signal;
+        signal.id = response.id;
+        signal.vid = response.vid;
+        signal.plid = response.plid;
+        signal.type = response.type;
+        signal.linkid = response.linkid;
+
+        vmap.signals.insert(std::map&lt;int, Signal&gt;::value_type(signal.id, signal));
+      }
+    }
+  }
+
   for (unsigned int i=1; i&lt;=vmap.signals.size(); i++) {
     Signal signal = vmap.signals[i];
     int pid = vmap.vectors[signal.vid].pid;
@@ -267,6 +343,9 @@ int main (int argc, char *argv[])
     camera_id_str = "camera";
   }
   
+  /* Get Flag wheter vecter_map_server function will be used  */
+  private_nh.param&lt;bool&gt;("use_path_info", g_use_vector_map_server, false);
+
   /* load vector map */
   ros::Subscriber sub_point     = rosnode.subscribe("vector_map_info/point",
                                                     SUBSCRIBE_QUEUE_SIZE,
@@ -311,7 +390,15 @@ int main (int argc, char *argv[])
 
   ros::Subscriber cameraInfoSubscriber = rosnode.subscribe (cameraInfo_topic_name, 100, cameraInfoCallback);
   ros::Subscriber adjust_xySubscriber  = rosnode.subscribe("/config/adjust_xy", 100, adjust_xyCallback);
-  //  ros::Subscriber ndtPoseSubscriber    = rosnode.subscribe("/current_pose", 10, ndtPoseCallback);
+  if (g_use_vector_map_server) {
+    /* Create subscribers which deliver informations requested by server */
+    ros::Subscriber current_pose_subscriber = rosnode.subscribe("/current_pose", 1, &amp;VectorMapClient::set_pose, &amp;g_vector_map_client);
+    ros::Subscriber waypoint_subscriber     = rosnode.subscribe("/final_waypoints", 1, &amp;VectorMapClient::set_waypoints, &amp;g_vector_map_client);
+
+    /* Create ros client to use Server-Client communication */
+    g_ros_client = rosnode.serviceClient&lt;vector_map_server::GetSignal&gt;("vector_map_server/get_signal");
+  }
+
   ros::Publisher  signalPublisher      = rosnode.advertise &lt;road_wizard::Signals&gt; ("roi_signal", 100);
   signal (SIGINT, interrupt);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3dcc89393eb1c462c4b718a4ffac56defc60706b" author="Manato Hirabayashi">
		<msg>Re-implement filter of signal orientation

Target traffic light should face to camera.
In this modification, target light will be chosen if it faces to camera +- 50 degree in camera coordinate system</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" added_lines="38" deleted_lines="19">
				<diff>@@ -224,6 +224,38 @@ bool project2 (const Point3 &amp;pt, int &amp;u, int &amp;v, bool useOpenGLCoord=false)
   return true;
 }
 
+double ConvertDegreeToRadian(double degree)
+{
+  return degree * M_PI / 180.0f;
+}
+
+
+double ConvertRadianToDegree(double radian)
+{
+  return radian * 180.0f / M_PI;
+}
+
+
+double GetSignalAngleInCameraSystem(double hang, double vang)
+{
+  // Fit the vector map format into ROS style
+  double signal_pitch_in_map = ConvertDegreeToRadian(vang - 90);
+  double signal_yaw_in_map   = ConvertDegreeToRadian(-hang + 90);
+
+  tf::Quaternion signal_orientation_in_map_system;
+  signal_orientation_in_map_system.setRPY(0, signal_pitch_in_map, signal_yaw_in_map);
+
+  tf::Quaternion signal_orientation_in_cam_system = trf * signal_orientation_in_map_system;
+  double signal_roll_in_cam;
+  double signal_pitch_in_cam;
+  double signal_yaw_in_cam;
+  tf::Matrix3x3(signal_orientation_in_cam_system).getRPY(signal_roll_in_cam,
+                                                         signal_pitch_in_cam,
+                                                         signal_yaw_in_cam);
+
+  return ConvertRadianToDegree(signal_pitch_in_cam);   // holizontal angle of camera is represented by pitch
+}  // double GetSignalAngleInCameraSystem()
+
 
 void echoSignals2 (ros::Publisher &amp;pub, bool useOpenGLCoord=false)
 {
@@ -288,26 +320,13 @@ void echoSignals2 (ros::Publisher &amp;pub, bool useOpenGLCoord=false)
       sign.type = signal.type, sign.linkId = signal.linkid;
       sign.plId = signal.plid;
 
-      /* convert signal's horizontal angle to yaw */
-      double reversed_signalYaw = setDegree0to360(sign.hang + 180.0f);
-
-      get_cameraRollPitchYaw(&amp;cameraOrientation.thiX,
-                             &amp;cameraOrientation.thiY,
-                             &amp;cameraOrientation.thiZ);
-
-      // std::cout &lt;&lt; "signal : " &lt;&lt; reversed_signalYaw &lt;&lt; ", car : " &lt;&lt; cameraOrientation.thiZ &lt;&lt; std::endl;
-
-      /*
-        check whether this signal is oriented to the camera
-        interested signals have below condition orientation:
-        (camera_orientation - 70deg) &lt; (signal_orientation + 180deg) &lt; (camera_orientatin + 70deg)
-      */
-      double conditionRange_lower = setDegree0to360(cameraOrientation.thiZ - 70);
-      double conditionRange_upper = setDegree0to360(cameraOrientation.thiZ + 70);
-
-      // std::cout &lt;&lt; "lower: " &lt;&lt; conditionRange_lower &lt;&lt; ", upper: " &lt;&lt; conditionRange_upper &lt;&lt; std::endl;
+      // Get holizontal angle of signal in camera corrdinate system
+      double signal_angle = GetSignalAngleInCameraSystem(vmap.vectors[signal.vid].hang + 180.0f,
+                                                         vmap.vectors[signal.vid].vang + 180.0f);
 
-      if (isRange(conditionRange_lower, conditionRange_upper, reversed_signalYaw)) {
+      // signal_angle will be zero if signal faces to x-axis
+      // Target signal should be face to -50 &lt;= z-axis (= 90 degree) &lt;= +50
+      if (isRange(-50, 50, signal_angle - 90)) {
         signalsInFrame.Signals.push_back (sign);
       }
     }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c86373f03bcd290a713513901af828dd196662c3" author="Manato Hirabayashi">
		<msg>Fix bug of vector_map_server usage</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" added_lines="4" deleted_lines="2">
				<diff>@@ -409,10 +409,12 @@ int main (int argc, char *argv[])
 
   ros::Subscriber cameraInfoSubscriber = rosnode.subscribe (cameraInfo_topic_name, 100, cameraInfoCallback);
   ros::Subscriber adjust_xySubscriber  = rosnode.subscribe("/config/adjust_xy", 100, adjust_xyCallback);
+  ros::Subscriber current_pose_subscriber;
+  ros::Subscriber waypoint_subscriber;
   if (g_use_vector_map_server) {
     /* Create subscribers which deliver informations requested by server */
-    ros::Subscriber current_pose_subscriber = rosnode.subscribe("/current_pose", 1, &amp;VectorMapClient::set_pose, &amp;g_vector_map_client);
-    ros::Subscriber waypoint_subscriber     = rosnode.subscribe("/final_waypoints", 1, &amp;VectorMapClient::set_waypoints, &amp;g_vector_map_client);
+    current_pose_subscriber = rosnode.subscribe("/current_pose", 1, &amp;VectorMapClient::set_pose, &amp;g_vector_map_client);
+    waypoint_subscriber     = rosnode.subscribe("/final_waypoints", 1, &amp;VectorMapClient::set_waypoints, &amp;g_vector_map_client);
 
     /* Create ros client to use Server-Client communication */
     g_ros_client = rosnode.serviceClient&lt;vector_map_server::GetSignal&gt;("vector_map_server/get_signal");
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f954de873018167ae7497d765d9bd7a2ce7613dd" author="Manato Hirabayashi">
		<msg>Update state_transition_matrix</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.h" added_lines="4" deleted_lines="4">
				<diff>@@ -31,10 +31,10 @@ class RegionTlrSsdRosNode {
     /* current: */
     /* GREEN   , YELLOW    , RED    , UNDEFINED  */
     /* -------------------------------------------  */
-    {GREEN     , YELLOW    , YELLOW , GREEN}  ,  /* | previous = GREEN */
-    {UNDEFINED , YELLOW    , RED    , YELLOW} ,  /* | previous = YELLOW */
-    {GREEN     , RED       , RED    , RED}    ,  /* | previous = RED */
-    {GREEN     , YELLOW    , RED    , UNDEFINED} /* | previous = UNDEFINED */
+    {GREEN     , YELLOW    , YELLOW    , GREEN}  ,  /* | previous = GREEN */
+    {UNDEFINED , YELLOW    , RED       , YELLOW} ,  /* | previous = YELLOW */
+    {GREEN     , RED       , RED       , RED}    ,  /* | previous = RED */
+    {GREEN     , YELLOW    , RED       , UNDEFINED} /* | previous = UNDEFINED */
   };
 
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7b561d154bf1d7ec3a1bd41a6068fabdc0a73a4a" author="Manato Hirabayashi">
		<msg>Prepare for merge

* Fix assumed SSD path in CMakeLists.txt
* Change default path of trained model into package-internal directory
* Remove `std::cerr` statements for debug
* Add UI to boot `traffic_light_recognition_ssd.launch` from runtime-manager</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.cpp" added_lines="0" deleted_lines="50">
				<diff>@@ -95,54 +95,12 @@ void RegionTlrSsdRosNode::RoiSignalCallback(const road_wizard::Signals::ConstPtr
     // Get current state of traffic light from current frame
     LightState current_state = recognizer.RecognizeLightState(roi);
 
-    std::cerr &lt;&lt; "current_state: ";
-    switch(current_state) {
-    case GREEN:
-      std::cerr &lt;&lt; "GREEN";
-      break;
-    case YELLOW:
-      std::cerr &lt;&lt; "YELLOW";
-      break;
-    case RED:
-      std::cerr &lt;&lt; "RED";
-      break;
-    case UNDEFINED:
-      std::cerr &lt;&lt; "UNDEFINED";
-      break;
-    default:
-      std::cerr &lt;&lt; "";
-      break;
-    }
-
-    std::cerr &lt;&lt; "(saved: " &lt;&lt; context.lightState &lt;&lt; ")";
-
     // Determine the final state by referring previous state
     context.lightState = DetermineState(context.lightState, // previous state
                                         current_state,      // current state
                                         &amp;(context.stateJudgeCount)); // counter to record how many times does state recognized
-
-    std::cerr &lt;&lt; ", determined: ";
-    switch(context.lightState) {
-    case GREEN:
-      std::cerr &lt;&lt; "GREEN | ";
-      break;
-    case YELLOW:
-      std::cerr &lt;&lt; "YELLOW | ";
-      break;
-    case RED:
-      std::cerr &lt;&lt; "RED | ";
-      break;
-    case UNDEFINED:
-      std::cerr &lt;&lt; "UNDEFINED | ";
-      break;
-    default:
-      std::cerr &lt;&lt; " | ";
-      break;
-    }
   }
 
-  std::cerr &lt;&lt; std::endl;
-
   // Publish recognition result as some topic format
   PublishTrafficLight(contexts_);
   PublishString(contexts_);
@@ -213,14 +171,6 @@ LightState RegionTlrSsdRosNode::DetermineState(LightState previous_state,
   // Get a candidate which considering state transition of traffic light
   LightState transition_candidate = kStateTransitionMatrix[previous_state][current_state];
 
-  std::cerr &lt;&lt; " [count:" &lt;&lt; *(state_judge_count) &lt;&lt; "/" &lt;&lt; kChangeStateThreshold
-            &lt;&lt; ", pre:" &lt;&lt; previous_state &lt;&lt; ", cur:" &lt;&lt; current_state &lt;&lt; ", tra:" &lt;&lt; transition_candidate &lt;&lt; "]";
-
-  // if (transition_candidate == UNDEFINED) {
-  //   // If candidate is UNDEFINED, return previous state tentatively
-  //   return previous_state;
-  // }
-
   // If state change happens more than threshold times, accept that change
   if (*state_judge_count &gt; kChangeStateThreshold) {
     *state_judge_count = 0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="22ba82fa89521ef3097e5d2f35e32f744ac9f01d" author="Manato Hirabayashi">
		<msg>Fix for latest specification</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -24,7 +24,7 @@
 #include &lt;runtime_manager/adjust_xy.h&gt;
 #include &lt;vector_map/vector_map.h&gt;
 #include &lt;vector_map_server/GetSignal.h&gt;
-#include &lt;waypoint_follower/lane.h&gt;
+#include &lt;waypoint_follower_msgs/lane.h&gt;
 
 static std::string camera_id_str;
 
@@ -64,7 +64,7 @@ namespace
   {
   private:
     geometry_msgs::PoseStamped pose_;
-    waypoint_follower::lane waypoints_;
+    waypoint_follower_msgs::lane waypoints_;
 
   public:
     VectorMapClient()
@@ -78,7 +78,7 @@ namespace
       return pose_;
     }
 
-    waypoint_follower::lane waypoints() const
+    waypoint_follower_msgs::lane waypoints() const
     {
       return waypoints_;
     }
@@ -88,7 +88,7 @@ namespace
       pose_ = pose;
     }
 
-    void set_waypoints(const waypoint_follower::lane&amp; waypoints)
+    void set_waypoints(const waypoint_follower_msgs::lane&amp; waypoints)
     {
       waypoints_ = waypoints;
     }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b2015f6d5535fd507f118b909b2795d2e0223fb3" author="andoh104">
		<msg>Localization problem patch
https://github.com/CPFL/Autoware/issues/693</msg>
		<modified_files>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\include\points_downsampler.h" new_path="ros\src\sensing\filters\packages\points_downsampler\include\points_downsampler.h" added_lines="9" deleted_lines="6">
				<diff>@@ -11,19 +11,22 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::
 
   for(pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator iter = scan.begin(); iter != scan.end(); ++iter)
   {
-    pcl::PointXYZI p;
-    p.x = iter-&gt;x;
-    p.y = iter-&gt;y;
-    p.z = iter-&gt;z;
-    p.intensity = iter-&gt;intensity;
+    const pcl::PointXYZI &amp;p = *iter;
+//    p.x = iter-&gt;x;
+//    p.y = iter-&gt;y;
+//    p.z = iter-&gt;z;
+//    p.intensity = iter-&gt;intensity;
     double square_distance = p.x * p.x + p.y * p.y;
 
     if(square_min_range &lt;= square_distance &amp;&amp; square_distance &lt;= square_max_range){
       narrowed_scan.points.push_back(p);
     }
   }
-
+#if 1
   return narrowed_scan;
+#else
+  return scan;    //  This is a only tempolary patch for Localization problem.
+#endif
 }
 
 #endif // POINTS_DOWNSAMPLER_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="905da0e524a22d120358890411db8b55ddad638d" author="andoh104">
		<msg>make the commit 14f7eca unavailable.</msg>
		<modified_files>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\include\points_downsampler.h" new_path="ros\src\sensing\filters\packages\points_downsampler\include\points_downsampler.h" added_lines="1" deleted_lines="1">
				<diff>@@ -22,7 +22,7 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::
       narrowed_scan.points.push_back(p);
     }
   }
-#if 1
+#if 0
   return narrowed_scan;
 #else
   return scan;    //  This is a only tempolary patch for Localization problem.
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="90eb198d3a94c0d54dd0ab8d353231866f45da94" author="Manato Hirabayashi">
		<msg>Make drawn points_image bigger in image_viewer_plugin</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_points.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_points.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -55,7 +55,7 @@ namespace integrated_viewer
 
         // Draw a point
         cv::rectangle(image,
-                      cv::Point(x, y),
+                      cv::Point(x - 1, y - 1),
                       cv::Point(x + 1, y + 1),
                       CV_RGB(red, green, blue),
                       CV_FILLED);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3b3e616705b3be68d44616cb94300d7540d97125" author="Yusuke Fujii">
		<msg>opencv 3.0 support on ssd node</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\ssd_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\ssd_node.cpp" added_lines="5" deleted_lines="1">
				<diff>@@ -37,9 +37,13 @@
 
 #include &lt;rect_class_score.h&gt;
 
-#include &lt;opencv2/contrib/contrib.hpp&gt;
+#include &lt;opencv2/opencv.hpp&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 
+#if (CV_MAJOR_VERSION &lt;= 2)
+#include &lt;opencv2/contrib/contrib.hpp&gt;
+#endif
+
 #include "ssd_detector.h"
 
 class RosSsdApp
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="78264ad09ea36bb066d07beebd21b28c15354bac" author="Manato Hirabayashi">
		<msg>Add point-size-combo-box to image_viewer_plugin

Now drawn point size can be specified from this combo box</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_points.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_points.cpp" added_lines="11" deleted_lines="3">
				<diff>@@ -16,7 +16,8 @@ namespace integrated_viewer
 
 
   void DrawPoints::Draw(const points2image::PointsImage::ConstPtr&amp; points,
-                        cv::Mat &amp;image) {
+                        cv::Mat &amp;image,
+                        int drawn_size) {
     if (points == NULL) {
       return;
     }
@@ -54,9 +55,16 @@ namespace integrated_viewer
         int blue  = color[2];
 
         // Draw a point
+        int minus_offset = 0;
+        int plus_offset = static_cast&lt;int&gt;(drawn_size/2);
+        if (drawn_size % 2 == 0) {
+          minus_offset = static_cast&lt;int&gt;(drawn_size/2) - 1;
+        } else {
+          minus_offset = static_cast&lt;int&gt;(drawn_size/2);
+        }
         cv::rectangle(image,
-                      cv::Point(x - 1, y - 1),
-                      cv::Point(x + 1, y + 1),
+                      cv::Point(x - minus_offset, y - minus_offset),
+                      cv::Point(x + plus_offset, y + plus_offset),
                       CV_RGB(red, green, blue),
                       CV_FILLED);
       }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_points.h" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_points.h" added_lines="1" deleted_lines="1">
				<diff>@@ -9,7 +9,7 @@ namespace integrated_viewer {
   class DrawPoints{
   public:
     explicit DrawPoints(void);
-    void Draw(const points2image::PointsImage::ConstPtr&amp; points, cv::Mat&amp; image);
+    void Draw(const points2image::PointsImage::ConstPtr&amp; points, cv::Mat&amp; image, int drawn_size);
 
   private:
     cv::Mat color_map_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" added_lines="6" deleted_lines="1">
				<diff>@@ -32,6 +32,10 @@ namespace integrated_viewer
     // Initialize Form
     ui_.setupUi(this);
 
+    // Set point size parameter
+    ui_.point_size_spin_box_-&gt;setMinimum(2); // minimum point size is 2x2
+    ui_.point_size_spin_box_-&gt;setValue(3);   // Set default size to 3
+
     // Load default image
     default_image_ = cv::imread(STR(IMAGE_VIEWER_DEFAULT_IMAGE));
 
@@ -325,7 +329,8 @@ namespace integrated_viewer
       rects_drawer_.DrawImageObjTracked(image_obj_tracked_msg_, viewed_image_);
 
       // Draw points on the image
-      points_drawer_.Draw(points_msg_, viewed_image_);
+      int point_size = ui_.point_size_spin_box_-&gt;value();
+      points_drawer_.Draw(points_msg_, viewed_image_, point_size);
 
       // Draw lane on the image
       lane_drawer_.Draw(lane_msg_, viewed_image_);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3075478c5271f5eb1470d8a646aacb0f641e1253" author="yukitsuji">
		<msg>Add selecter of GPU for euclidean clustering</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" added_lines="15" deleted_lines="28">
				<diff>@@ -66,7 +66,6 @@
 #include &lt;opencv2/contrib/contrib.hpp&gt;
 #endif
 
-#include &lt;chrono&gt;
 #include &lt;iostream&gt;
 #include &lt;vector&gt;
 #include &lt;string&gt;
@@ -135,6 +134,8 @@ static double _max_boundingbox_side;
 static double _remove_points_upto;
 static double _cluster_merge_threshold;
 
+static bool _use_gpu;
+
 void transformBoundingBox(const jsk_recognition_msgs::BoundingBox&amp; in_boundingbox, jsk_recognition_msgs::BoundingBox&amp; out_boundingbox, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
 {
 	geometry_msgs::PoseStamped pose_in, pose_out;
@@ -534,7 +535,12 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 	for(unsigned int i=0; i&lt;cloud_segments_array.size(); i++)
 	{
 #ifdef GPU_CLUSTERING
-		std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
+    std::vector&lt;ClusterPtr&gt; local_clusters;
+		if (_use_gpu) {
+			std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
+		} else {
+			std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
+		}
 #else
 		std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
 #endif
@@ -826,6 +832,8 @@ void removePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pc
 
 void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
 {
+	start = std::chrono::system_clock::now(); // 
+
 	if (!_using_sensor_cloud)
 	{
 		_using_sensor_cloud = true;
@@ -850,10 +858,6 @@ void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
 
 		_velodyne_header = in_sensor_cloud-&gt;header;
 
-		cv::TickMeter timer;
-
-		timer.reset();timer.start();
-
 		if (_remove_points_upto &gt; 0.0)
 		{
 			removePointsUpTo(current_sensor_cloud_ptr, removed_points_cloud_ptr, _remove_points_upto);
@@ -861,27 +865,18 @@ void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
 		else
 			removed_points_cloud_ptr = current_sensor_cloud_ptr;
 
-		//std::cout &lt;&lt; "Downsample before: " &lt;&lt;removed_points_cloud_ptr-&gt;points.size();
 		if (_downsample_cloud)
 			downsampleCloud(removed_points_cloud_ptr, downsampled_cloud_ptr, _leaf_size);
 		else
 			downsampled_cloud_ptr =removed_points_cloud_ptr;
 
-		//std::cout &lt;&lt; " after: " &lt;&lt;downsampled_cloud_ptr-&gt;points.size();
-		timer.stop(); //std::cout &lt;&lt; "downsampleCloud:" &lt;&lt; timer.getTimeMilli() &lt;&lt; "ms" &lt;&lt; std::endl;
-
-		timer.reset();timer.start();
 		clipCloud(downsampled_cloud_ptr, clipped_cloud_ptr, _clip_min_height, _clip_max_height);
-		timer.stop(); //std::cout &lt;&lt; "clipCloud:" &lt;&lt; clipped_cloud_ptr-&gt;points.size() &lt;&lt; "time " &lt;&lt; timer.getTimeMilli() &lt;&lt; "ms" &lt;&lt; std::endl;
 
-		timer.reset();timer.start();
 		if(_keep_lanes)
 			keepLanePoints(clipped_cloud_ptr, inlanes_cloud_ptr, _keep_lane_left_distance, _keep_lane_right_distance);
 		else
 			inlanes_cloud_ptr = clipped_cloud_ptr;
-		timer.stop(); //std::cout &lt;&lt; "keepLanePoints:" &lt;&lt; timer.getTimeMilli() &lt;&lt; "ms" &lt;&lt; std::endl;
 
-		timer.reset();timer.start();
 		if(_remove_ground)
 		{
 			removeFloor(inlanes_cloud_ptr, nofloor_cloud_ptr, onlyfloor_cloud_ptr);
@@ -889,49 +884,40 @@ void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
 		}
 		else
 			nofloor_cloud_ptr = inlanes_cloud_ptr;
-		timer.stop(); //std::cout &lt;&lt; "removeFloor:" &lt;&lt; timer.getTimeMilli() &lt;&lt; "ms" &lt;&lt; std::endl;
 
 		publishCloud(&amp;_pub_points_lanes_cloud, nofloor_cloud_ptr);
 
-		timer.reset();timer.start();
 		if (_use_diffnormals)
 			differenceNormalsSegmentation(nofloor_cloud_ptr, diffnormals_cloud_ptr);
 		else
 			diffnormals_cloud_ptr = nofloor_cloud_ptr;
-		timer.stop(); //std::cout &lt;&lt; "differenceNormalsSegmentation:" &lt;&lt; timer.getTimeMilli() &lt;&lt; "ms" &lt;&lt; std::endl;
 
-		timer.reset();timer.start();
 		segmentByDistance(diffnormals_cloud_ptr, colored_clustered_cloud_ptr, boundingbox_array, centroids, cloud_clusters, polygon_array, pictograms_array);
-		//timer.stop(); std::cout &lt;&lt; "segmentByDistance:" &lt;&lt; timer.getTimeMilli() &lt;&lt; "ms" &lt;&lt; std::endl;
 
-		timer.reset();timer.start();
 		publishColorCloud(&amp;_pub_cluster_cloud, colored_clustered_cloud_ptr);
-		timer.stop(); //std::cout &lt;&lt; "publishColorCloud:" &lt;&lt; timer.getTimeMilli() &lt;&lt; "ms" &lt;&lt; std::endl;
+
 		// Publish BB
 		boundingbox_array.header = _velodyne_header;
 
 		_pub_jsk_hulls.publish(polygon_array);//publish convex hulls
 		_pub_text_pictogram.publish(pictograms_array);//publish_ids
 
-		timer.reset();timer.start();
 		publishBoundingBoxArray(&amp;_pub_jsk_boundingboxes, boundingbox_array, _output_frame, _velodyne_header);
 		centroids.header = _velodyne_header;
-		timer.stop(); //std::cout &lt;&lt; "publishBoundingBoxArray:" &lt;&lt; timer.getTimeMilli() &lt;&lt; "ms" &lt;&lt; std::endl;
 
-		timer.reset();timer.start();
 		publishCentroids(&amp;_centroid_pub, centroids, _output_frame, _velodyne_header);
-		timer.stop(); //std::cout &lt;&lt; "publishCentroids:" &lt;&lt; timer.getTimeMilli() &lt;&lt; "ms" &lt;&lt; std::endl;
 
 		_marker_pub.publish(_visualization_marker);
 		_visualization_marker.points.clear();//transform? is it used?
 		cloud_clusters.header = _velodyne_header;
 
-		timer.reset();timer.start();
 		publishCloudClusters(&amp;_pub_clusters_message, cloud_clusters, _output_frame, _velodyne_header);
-		timer.stop(); //std::cout &lt;&lt; "publishCloudClusters:" &lt;&lt; timer.getTimeMilli() &lt;&lt; "ms" &lt;&lt; std::endl &lt;&lt; std::endl;
 
 		_using_sensor_cloud = false;
 	}
+	end = std::chrono::system_clock::now();  // 
+  double elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end-start).count(); //
+  ROS_INFO("Euclidean Clustering : %f", elapsed);
 }
 
 /*
@@ -1080,6 +1066,7 @@ int main (int argc, char** argv)
 	private_nh.param("max_boundingbox_side", _max_boundingbox_side, 10.0);				ROS_INFO("max_boundingbox_side: %f", _max_boundingbox_side);
 	private_nh.param("cluster_merge_threshold", _cluster_merge_threshold, 1.5);			ROS_INFO("cluster_merge_threshold: %f", _cluster_merge_threshold);
 	private_nh.param&lt;std::string&gt;("output_frame", _output_frame, "velodyne");			ROS_INFO("output_frame: %s", _output_frame.c_str());
+	private_nh.param("use_gpu", _use_gpu, false);				ROS_INFO("use_gpu: %d", _use_gpu);
 
 	private_nh.param("use_vector_map", _use_vector_map, false);							ROS_INFO("use_vector_map: %d", _use_vector_map);
 	private_nh.param&lt;std::string&gt;("vectormap_frame", _vectormap_frame, "map");			ROS_INFO("vectormap_frame: %s", _output_frame.c_str());
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\includes\Cluster.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\includes\Cluster.h" added_lines="2" deleted_lines="0">
				<diff>@@ -52,6 +52,7 @@
 
 #include &lt;limits&gt;
 #include &lt;cmath&gt;
+#include &lt;chrono&gt;
 
 class Cluster {
 	pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr	pointcloud_;
@@ -73,6 +74,7 @@ class Cluster {
 	Eigen::Vector3f 					eigen_values_;
 
 	bool								valid_cluster_;
+	std::chrono::system_clock::time_point  start_, end_;
 public:
 	/* \brief Constructor. Creates a Cluster object using the specified points in a PointCloud
 	 * \param[in] in_origin_cloud_ptr 	Origin PointCloud
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="865ed1e2c5866b635c608fad462e8a649a285008" author="yukitsuji">
		<msg>replace ',' into &amp;&amp; at for sentence</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\Cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\Cluster.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -317,7 +317,7 @@ std::vector&lt;float&gt; Cluster::GetFpfhDescriptor(const unsigned int&amp; in_ompnum_thre
 		}
 
 		float fpfh_dif = fpfh_max - fpfh_min;
-		for(unsigned int j=0; fpfh_dif &gt; 0, j &lt; cluster_fpfh_histogram.size(); j++)//substract the min from each and normalize
+		for(unsigned int j=0; fpfh_dif &gt; 0 &amp;&amp; j &lt; cluster_fpfh_histogram.size(); j++)//substract the min from each and normalize
 		{
 			cluster_fpfh_histogram[j]= (cluster_fpfh_histogram[j] - fpfh_min)/fpfh_dif;
 		}
@@ -344,4 +344,3 @@ int Cluster::GetId()
 Cluster::~Cluster() {
 	// TODO Auto-generated destructor stub
 }
-
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="07ce8bf7df2c7be44989cd66c095c5636d022cdd" author="yukitsuji">
		<msg>Add ROS_INFO that print execution time of euclidean clustering</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" added_lines="5" deleted_lines="4">
				<diff>@@ -135,6 +135,7 @@ static double _remove_points_upto;
 static double _cluster_merge_threshold;
 
 static bool _use_gpu;
+static std::chrono::system_clock::time_point _start, _end;
 
 void transformBoundingBox(const jsk_recognition_msgs::BoundingBox&amp; in_boundingbox, jsk_recognition_msgs::BoundingBox&amp; out_boundingbox, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
 {
@@ -832,7 +833,7 @@ void removePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pc
 
 void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
 {
-	start = std::chrono::system_clock::now(); // 
+	_start = std::chrono::system_clock::now(); // 
 
 	if (!_using_sensor_cloud)
 	{
@@ -915,8 +916,8 @@ void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
 
 		_using_sensor_cloud = false;
 	}
-	end = std::chrono::system_clock::now();  // 
-  double elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end-start).count(); //
+	_end = std::chrono::system_clock::now();  // 
+  double elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(_end-_start).count(); //
   ROS_INFO("Euclidean Clustering : %f", elapsed);
 }
 
@@ -1066,13 +1067,13 @@ int main (int argc, char** argv)
 	private_nh.param("max_boundingbox_side", _max_boundingbox_side, 10.0);				ROS_INFO("max_boundingbox_side: %f", _max_boundingbox_side);
 	private_nh.param("cluster_merge_threshold", _cluster_merge_threshold, 1.5);			ROS_INFO("cluster_merge_threshold: %f", _cluster_merge_threshold);
 	private_nh.param&lt;std::string&gt;("output_frame", _output_frame, "velodyne");			ROS_INFO("output_frame: %s", _output_frame.c_str());
-	private_nh.param("use_gpu", _use_gpu, false);				ROS_INFO("use_gpu: %d", _use_gpu);
 
 	private_nh.param("use_vector_map", _use_vector_map, false);							ROS_INFO("use_vector_map: %d", _use_vector_map);
 	private_nh.param&lt;std::string&gt;("vectormap_frame", _vectormap_frame, "map");			ROS_INFO("vectormap_frame: %s", _output_frame.c_str());
 
 	private_nh.param("remove_points_upto", _remove_points_upto, 0.0);		ROS_INFO("remove_points_upto: %f", _remove_points_upto);
 
+	private_nh.param("use_gpu", _use_gpu, false);				ROS_INFO("use_gpu: %d", _use_gpu);
 
 	_velodyne_transform_available = false;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1ef1a28b72e3d1676e8c47ccf5e5bd245d78361d" author="yukitsuji">
		<msg>Remove timers</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -538,9 +538,9 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 #ifdef GPU_CLUSTERING
     std::vector&lt;ClusterPtr&gt; local_clusters;
 		if (_use_gpu) {
-			std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
+			local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
 		} else {
-			std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
+			local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
 		}
 #else
 		std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\includes\Cluster.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\includes\Cluster.h" added_lines="1" deleted_lines="1">
				<diff>@@ -74,7 +74,7 @@ class Cluster {
 	Eigen::Vector3f 					eigen_values_;
 
 	bool								valid_cluster_;
-	std::chrono::system_clock::time_point  start_, end_;
+	
 public:
 	/* \brief Constructor. Creates a Cluster object using the specified points in a PointCloud
 	 * \param[in] in_origin_cloud_ptr 	Origin PointCloud
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="92ff7941f87ab89942986e77dd08d3d7828b0f0c" author="YamatoAndo">
		<msg>ndt_mapping ndt_matching, fix typo</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -515,7 +515,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   if (_use_imu == true &amp;&amp; _use_odom == true)
     imu_odom_calc(current_scan_time);
-  if(_use_imu == true &amp;&amp; _use_odom == true)
+  if (_use_imu == true &amp;&amp; _use_odom == false)
     imu_calc(current_scan_time);
   if (_use_imu == false &amp;&amp; _use_odom == true)
     odom_calc(current_scan_time);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -759,7 +759,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
     if (_use_imu == true &amp;&amp; _use_odom == true)
       imu_odom_calc(current_scan_time);
-    if(_use_imu == true &amp;&amp; _use_odom == true)
+    if (_use_imu == true &amp;&amp; _use_odom == false)
       imu_calc(current_scan_time);
     if (_use_imu == false &amp;&amp; _use_odom == true)
       odom_calc(current_scan_time);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="62aebd43dd53ce621c9504ebd4f01c2b90c44555" author="Yusuke FUJII">
		<msg>fix to free a NULL window</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" added_lines="5" deleted_lines="2">
				<diff>@@ -373,8 +373,11 @@ static void superimpose_cb(const std_msgs::Bool::ConstPtr&amp; config_msg)
   }
 
   if (!show_superimpose_result) {
-    cv::destroyWindow(window_name);
-    cv::waitKey(1);
+	  if (cvGetWindowHandle(window_name.c_str()) != NULL)
+	  {
+		  cv::destroyWindow(window_name);
+		  cv::waitKey(1);
+	  }
   }
 
 } /* static void superimpose_cb() */
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="45e57153564ab06c0a330073ad156abd0c4529bf" author="andoh104">
		<msg>https://github.com/CPFL/Autoware/issues/693</msg>
		<modified_files>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\include\points_downsampler.h" new_path="ros\src\sensing\filters\packages\points_downsampler\include\points_downsampler.h" added_lines="2" deleted_lines="1">
				<diff>@@ -6,6 +6,7 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::
   pcl::PointCloud&lt;pcl::PointXYZI&gt; narrowed_scan;
   narrowed_scan.header = scan.header;
 
+  max_range = 100.0;    //  This is a only tempolary patch for Localization problem.
   double square_min_range = min_range * min_range;
   double square_max_range = max_range * max_range;
 
@@ -22,7 +23,7 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::
       narrowed_scan.points.push_back(p);
     }
   }
-#if 0
+#if 1
   return narrowed_scan;
 #else
   return scan;    //  This is a only tempolary patch for Localization problem.
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="46ff1d116175f5586b4c1b904bc89f00e85dc41e" author="andoh104">
		<msg>fix initializing measurement_range
https://github.com/CPFL/Autoware/issues/693</msg>
		<modified_files>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\include\points_downsampler.h" new_path="ros\src\sensing\filters\packages\points_downsampler\include\points_downsampler.h" added_lines="0" deleted_lines="2">
				<diff>@@ -5,8 +5,6 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::
 {
   pcl::PointCloud&lt;pcl::PointXYZI&gt; narrowed_scan;
   narrowed_scan.header = scan.header;
-
-  max_range = 100.0;    //  This is a only tempolary patch for Localization problem.
   double square_min_range = min_range * min_range;
   double square_max_range = max_range * max_range;
 
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -60,7 +60,7 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
-static double measurement_range;
+static double measurement_range=100.0;
 
 static void config_callback(const runtime_manager::ConfigDistanceFilter::ConstPtr&amp; input)
 {
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -58,7 +58,7 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
-static double measurement_range;
+static double measurement_range=100.0;
 
 static void config_callback(const runtime_manager::ConfigRandomFilter::ConstPtr&amp; input)
 {
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\ring_filter\ring_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\ring_filter\ring_filter.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -61,7 +61,7 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
-static double measurement_range;
+static double measurement_range=100.0;
 
 static void config_callback(const runtime_manager::ConfigRingFilter::ConstPtr&amp; input)
 {
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -60,7 +60,7 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
-static double measurement_range;
+static double measurement_range=100.0;
 
 static void config_callback(const runtime_manager::ConfigVoxelGridFilter::ConstPtr&amp; input)
 {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8a1bfeac01a2a0b93544d46f229c6716457b4af5" author="andoh104">
		<msg>Add Error handring to removePointsByRange()</msg>
		<modified_files>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\include\points_downsampler.h" new_path="ros\src\sensing\filters\packages\points_downsampler\include\points_downsampler.h" added_lines="9" deleted_lines="4">
				<diff>@@ -5,6 +5,14 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::
 {
   pcl::PointCloud&lt;pcl::PointXYZI&gt; narrowed_scan;
   narrowed_scan.header = scan.header;
+
+#if 1     //  This error handling should be detemind.
+  if( min_range&gt;=max_range ) {
+    ROS_ERROR_ONCE("min_range&gt;=max_range @(%lf, %lf)", min_range, max_range );
+    return scan;
+  }
+#endif
+
   double square_min_range = min_range * min_range;
   double square_max_range = max_range * max_range;
 
@@ -21,11 +29,8 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::
       narrowed_scan.points.push_back(p);
     }
   }
-#if 1
+
   return narrowed_scan;
-#else
-  return scan;    //  This is a only tempolary patch for Localization problem.
-#endif
 }
 
 #endif // POINTS_DOWNSAMPLER_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5f44f904433dd1abee94939afd806ce9a1271e14" author="andoh104">
		<msg>Modify measurement_range=MAX_MEASUREMENT_RANGE; (200)</msg>
		<modified_files>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -60,7 +60,7 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
-static double measurement_range=100.0;
+static double measurement_range = MAX_MEASUREMENT_RANGE;
 
 static void config_callback(const runtime_manager::ConfigDistanceFilter::ConstPtr&amp; input)
 {
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -58,7 +58,7 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
-static double measurement_range=100.0;
+static double measurement_range = MAX_MEASUREMENT_RANGE;
 
 static void config_callback(const runtime_manager::ConfigRandomFilter::ConstPtr&amp; input)
 {
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\ring_filter\ring_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\ring_filter\ring_filter.cpp" added_lines="7" deleted_lines="3">
				<diff>@@ -43,6 +43,8 @@
 
 #include &lt;chrono&gt;
 
+#define MAX_MEASUREMENT_RANGE 200.0
+
 ros::Publisher filtered_points_pub;
 
 // Leaf size of VoxelGrid filter.
@@ -61,7 +63,7 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
-static double measurement_range=100.0;
+static double measurement_range = MAX_MEASUREMENT_RANGE;
 
 static void config_callback(const runtime_manager::ConfigRingFilter::ConstPtr&amp; input)
 {
@@ -83,6 +85,8 @@ static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   scan.points.clear();
 
+  double square_measurement_range = measurement_range*measurement_range;
+
   for (pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::const_iterator item = tmp.begin(); item != tmp.end(); item++)
   {
     pcl::PointXYZI p;
@@ -91,9 +95,9 @@ static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     p.z = item-&gt;z;
     p.intensity = item-&gt;intensity;
 
-    double distance = sqrt(p.x * p.x + p.y * p.y);
+    double square_distance = p.x * p.x + p.y * p.y;
 
-    if (item-&gt;ring % ring_div == 0 &amp;&amp; distance &lt;= measurement_range)
+    if (item-&gt;ring % ring_div == 0 &amp;&amp; square_distance &lt;= square_measurement_range)
     {
       scan.points.push_back(p);
     }
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -60,7 +60,7 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
-static double measurement_range=100.0;
+static double measurement_range = MAX_MEASUREMENT_RANGE;
 
 static void config_callback(const runtime_manager::ConfigVoxelGridFilter::ConstPtr&amp; input)
 {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f72a112d5d6a5d89a443d16ecf913c6ad4bb76ea" author="TomohitoAndo">
		<msg>Add map offset parameters to points2costmap node</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\points2costmap\points2costmap.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\points2costmap\points2costmap.cpp" added_lines="67" deleted_lines="4">
				<diff>@@ -33,6 +33,8 @@
 #include &lt;nav_msgs/OccupancyGrid.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
+#include &lt;utility&gt;
+
 namespace
 {
 constexpr double HEIGHT_LIMIT = 0.1;  // from sensor
@@ -43,12 +45,15 @@ ros::Publisher g_costmap_pub;
 double g_resolution;
 int g_cell_width;
 int g_cell_height;
+double g_offset_x;
+double g_offset_y;
+double g_offset_z;
 
 std::vector&lt;int&gt; createCostMap(const pcl::PointCloud&lt;pcl::PointXYZ&gt; &amp;scan)
 {
   std::vector&lt;int&gt; cost_map(g_cell_width * g_cell_height, 0);
-  double map_center_x = (g_cell_width / 2.0) * g_resolution;
-  double map_center_y = (g_cell_height / 2.0) * g_resolution;
+  double map_center_x = (g_cell_width / 2.0) * g_resolution - g_offset_x;
+  double map_center_y = (g_cell_height / 2.0) * g_resolution - g_offset_y;
 
   // scan points are in sensor frame
   for (const auto &amp;p : scan.points)
@@ -80,14 +85,62 @@ void setOccupancyGrid(nav_msgs::OccupancyGrid *og)
   og-&gt;info.resolution = g_resolution;
   og-&gt;info.width = g_cell_width;
   og-&gt;info.height = g_cell_height;
-  og-&gt;info.origin.position.x = (-1) * (g_cell_width / 2.0) * g_resolution;
-  og-&gt;info.origin.position.y = (-1) * (g_cell_height / 2.0) * g_resolution;
+  og-&gt;info.origin.position.x = (-1) * (g_cell_width / 2.0) * g_resolution + g_offset_x;
+  og-&gt;info.origin.position.y = (-1) * (g_cell_height / 2.0) * g_resolution + g_offset_y;
+  og-&gt;info.origin.position.z = g_offset_z;
   og-&gt;info.origin.orientation.x = 0.0;
   og-&gt;info.origin.orientation.y = 0.0;
   og-&gt;info.origin.orientation.z = 0.0;
   og-&gt;info.origin.orientation.w = 1.0;
 }
 
+std::vector&lt;int&gt; filterCostMap(std::vector&lt;int&gt;&amp; cost_map)
+{
+  std::vector&lt;int&gt; filtered_cost_map(cost_map.size(), 0);
+
+  // cells around reference (x, y)
+  std::vector&lt;std::pair&lt;int, int&gt;&gt; neighborhood
+  {
+    std::make_pair(-1, -1), std::make_pair( 0, -1), std::make_pair( 1, -1),
+    std::make_pair(-1,  0), std::make_pair( 1,  0),
+    std::make_pair(-1,  1), std::make_pair( 0,  1), std::make_pair( 1,  1),
+  };
+
+  for (size_t size = cost_map.size(), i = 0; i &lt; size; i++) {
+    int ref_cost = cost_map[i];
+
+    int ref_x = i % g_cell_width;
+    int ref_y = (i - ref_x) / g_cell_width;
+
+    // we don't have to filter if the cost is 0
+    if (ref_cost &lt;= 0)
+      continue;
+
+    filtered_cost_map[i] += ref_cost;
+
+    // increase the cost for each neighborhood cell
+    for (const auto&amp; n : neighborhood) {
+      int neighbor_x = ref_x + n.first;
+      int neighbor_y = ref_y + n.second;
+
+      if (neighbor_x &lt; 0 || neighbor_x &gt;= g_cell_width || neighbor_y &lt; 0 || neighbor_y &gt;= g_cell_height)
+        continue;
+
+      int neighbor_index = neighbor_x + neighbor_y * g_cell_width;
+      filtered_cost_map[neighbor_index] += ref_cost;
+    }
+
+  }
+
+  // handle the cost over 100
+  for (auto &amp;cost : filtered_cost_map) {
+    if (cost &gt; 100)
+      cost = 100;
+  }
+
+  return filtered_cost_map;
+}
+
 void createOccupancyGrid(const sensor_msgs::PointCloud2::ConstPtr &amp;input)
 {
   static int count = 0;
@@ -102,6 +155,13 @@ void createOccupancyGrid(const sensor_msgs::PointCloud2::ConstPtr &amp;input)
 
   // create cost map with pointcloud
   std::vector&lt;int&gt; cost_map = createCostMap(scan);
+
+  /*
+  bool filter = false;
+  if (filter)
+    cost_map = filterCostMap(cost_map);
+  */
+
   og.data.insert(og.data.end(), cost_map.begin(), cost_map.end());
   g_costmap_pub.publish(og);
   og.data.clear();
@@ -123,6 +183,9 @@ int main(int argc, char **argv)
   private_nh.param&lt;int&gt;("cell_width", g_cell_width, 50);
   private_nh.param&lt;int&gt;("cell_height", g_cell_height, 50);
   private_nh.param&lt;std::string&gt;("points_topic", points_topic, "points_lanes");
+  private_nh.param&lt;double&gt;("offset_x", g_offset_x, 30.0);
+  private_nh.param&lt;double&gt;("offset_y", g_offset_y, 0.0);
+  private_nh.param&lt;double&gt;("offset_z", g_offset_z, -2.0);
 
   g_costmap_pub = nh.advertise&lt;nav_msgs::OccupancyGrid&gt;("realtime_cost_map", 10);
   ros::Subscriber points_sub = nh.subscribe(points_topic, 10, createOccupancyGrid);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f34d481e1a6e2d556138fd39f50c259d3c034a49" author="TomohitoAndo">
		<msg>Add obstacle avoid feature in astar_planner</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_avoid.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_avoid.cpp" added_lines="186" deleted_lines="13">
				<diff>@@ -26,31 +26,204 @@
  *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+*/
 
-#include &lt;ros/ros.h&gt;
-#include &lt;waypoint_follower_msgs/lane.h&gt;
-#include &lt;iostream&gt;
+#include "astar_search.h"
+#include "search_info_ros.h"
 
-static ros::Publisher _pub;
+#include "waypoint_follower_msgs/LaneArray.h"
 
-void callback(const waypoint_follower_msgs::lane &amp;msg)
+namespace
 {
-    _pub.publish(msg);
+
+waypoint_follower_msgs::lane createPublishWaypoints(const waypoint_follower_msgs::lane&amp; ref_lane, int closest_waypoint, int size)
+{
+  waypoint_follower_msgs::lane follow_lane;
+
+  follow_lane.header    = ref_lane.header;
+  follow_lane.increment = ref_lane.increment;
+
+  // Push "size" waypoints from closest
+  for (int i = 0; i &lt; size; i++) {
+    if (closest_waypoint + i &gt;= static_cast&lt;int&gt;(ref_lane.waypoints.size()))
+      break;
+
+    follow_lane.waypoints.push_back(ref_lane.waypoints[closest_waypoint + i]);
+  }
+
+  return follow_lane;
+}
+
+void createAvoidWaypoints(const nav_msgs::Path&amp; astar_path, const astar_planner::SearchInfo&amp; search_info, int size, waypoint_follower_msgs::lane* avoid_lane, int* end_of_avoid_index)
+{
+  int closest_waypoint_index = search_info.getClosestWaypointIndex();
+
+  avoid_lane-&gt;waypoints.clear();
+
+  // Get global lane
+  const waypoint_follower_msgs::lane&amp; current_lane = search_info.getCurrentWaypoints();
+  avoid_lane-&gt;header    = current_lane.header;
+  avoid_lane-&gt;increment = current_lane.increment;
+
+  // Set waypoints from closest to beginning of avoiding
+  for (int i = closest_waypoint_index; i &lt; search_info.getStartWaypointIndex(); i++)
+  {
+    avoid_lane-&gt;waypoints.push_back(current_lane.waypoints.at(i));
+  }
+
+  double avoid_velocity = avoid_lane-&gt;waypoints.back().twist.twist.linear.x;
+
+  if (avoid_velocity &gt; search_info.getAvoidVelocityLimitMPS())
+    avoid_velocity = search_info.getAvoidVelocityLimitMPS();
+
+  // Set waypoints for avoiding
+  for (const auto&amp; pose : astar_path.poses) {
+    waypoint_follower_msgs::waypoint wp;
+    wp.pose = pose;
+    wp.twist.twist.linear.x = avoid_velocity;
+
+    avoid_lane-&gt;waypoints.push_back(wp);
+  }
+
+  // To know here is the end of avoiding
+  *end_of_avoid_index = avoid_lane-&gt;waypoints.size();
+
+  // Set waypoints from the end of avoiding
+  for (int i = search_info.getGoalWaypointIndex() + 1; i &lt; search_info.getGoalWaypointIndex() + size; i++) {
+    if (i &gt;= static_cast&lt;int&gt;(current_lane.waypoints.size()))
+      break;
+
+    avoid_lane-&gt;waypoints.push_back(current_lane.waypoints.at(i));
+  }
+
 }
 
+} // namespace
 
 int main(int argc, char **argv)
 {
-    ros::init(argc, argv, "obstacle_avoid");
+  ros::init(argc, argv, "obstacle_avoid");
+  ros::NodeHandle n;
+
+  astar_planner::AstarSearch astar;
+  astar_planner::SearchInfo search_info;
+
+  // ROS subscribers
+  ros::Subscriber map_sub               = n.subscribe("grid_map_visualization/distance_transform", 1, &amp;astar_planner::SearchInfo::mapCallback, &amp;search_info);
+  ros::Subscriber start_sub             = n.subscribe("current_pose", 1, &amp;astar_planner::SearchInfo::currentPoseCallback, &amp;search_info);
+  ros::Subscriber waypoints_sub         = n.subscribe("base_waypoints", 1, &amp;astar_planner::SearchInfo::waypointsCallback, &amp;search_info);
+  ros::Subscriber obstacle_waypoint_sub = n.subscribe("obstacle_waypoint", 1, &amp;astar_planner::SearchInfo::obstacleWaypointCallback, &amp;search_info);
+  ros::Subscriber closest_waypoint_sub  = n.subscribe("closest_waypoint", 1, &amp;astar_planner::SearchInfo::closestWaypointCallback, &amp;search_info);
+  // TODO: optional
+  //ros::Subscriber goal_sub = n.subscribe("/move_base_simple/goal", 1, &amp;astar_planner::SearchInfo::goalCallback, &amp;search_info);
+  ros::Subscriber current_velocity_sub  = n.subscribe("current_velocity", 1, &amp;astar_planner::SearchInfo::currentVelocityCallback, &amp;search_info);
+  ros::Subscriber state_sub  = n.subscribe("state", 1, &amp;astar_planner::SearchInfo::stateCallback, &amp;search_info);
+
+  // ROS publishers
+  ros::Publisher path_pub = n.advertise&lt;nav_msgs::Path&gt;("astar_path", 1, true);
+  ros::Publisher waypoints_pub  = n.advertise&lt;waypoint_follower_msgs::lane&gt;("safety_waypoints", 1, true);
+
+  ros::Rate loop_rate(10);
+
+  // variables for avoidance
+  waypoint_follower_msgs::lane avoid_lane;
+  int end_of_avoid_index = -1;
+  bool avoidance = false;
+  while (ros::ok()) {
+    ros::spinOnce();
+
+    int closest_waypoint;
+
+    // We switch 2 waypoints, original path and avoiding path
+    if (avoidance)
+      closest_waypoint = getClosestWaypoint(avoid_lane, search_info.getCurrentPose().pose);
+    else
+      closest_waypoint = search_info.getClosestWaypointIndex();
+
+    // there are no waypoints we can follow
+    if (closest_waypoint &lt; 0 || !search_info.getPathSet())
+    {
+      loop_rate.sleep();
+      continue;
+    }
+
+    // Follow the original waypoints
+    if (!avoidance)
+    {
+      waypoint_follower_msgs::lane publish_lane;
+      publish_lane = createPublishWaypoints(search_info.getSubscribedWaypoints(), closest_waypoint, 100);
+      waypoints_pub.publish(publish_lane);
+    }
+    // Follow the avoiding waypoints
+    else
+    {
+      // create waypoints from closest on avoid_lane
+      waypoint_follower_msgs::lane publish_lane;
+      publish_lane = createPublishWaypoints(avoid_lane, closest_waypoint, 100);
+      waypoints_pub.publish(publish_lane);
+
+      // End of avoidance
+      if (closest_waypoint &gt; end_of_avoid_index)
+      {
+        avoidance = false;
+
+        // Return to the original waypoints
+        search_info.setCurrentWaypoints(search_info.getSubscribedWaypoints());
+
+        loop_rate.sleep();
+        continue;
+      }
+    }
+
+    // Initialize vector for A* search, this runs only once
+    if (search_info.getMapSet() &amp;&amp; !astar.getNodeInitialized())
+      astar.initializeNode(search_info.getMap());
+
+    // Waiting for the call for avoidance ...
+    if (!search_info.getMapSet() || !search_info.getStartSet() || !search_info.getGoalSet()) {
+      search_info.reset();
+      loop_rate.sleep();
+      continue;
+    }
+
+    // Run astar search
+    ros::WallTime timer_begin = ros::WallTime::now();
+
+    bool result = astar.makePlan(search_info.getStartPose().pose, search_info.getGoalPose().pose, search_info.getMap(), search_info.getUpperBoundDistance());
+
+    ros::WallTime timer_end = ros::WallTime::now();
+    double time_ms = (timer_end - timer_begin).toSec() * 1000;
+    ROS_INFO("planning time: %lf [ms]", time_ms);
+
+    // debug mode
+    if (!search_info.getChangePath())
+    {
+      static double msec_sum = 0;
+      static int plan_count = 0;
+      plan_count++;
+      msec_sum += time_ms;
+      std::cout &lt;&lt; "average time so far: " &lt;&lt; msec_sum / plan_count &lt;&lt; std::endl;
+    }
+
+    if (result) {
+      std::cout &lt;&lt; "Found goal!" &lt;&lt; std::endl;
+      path_pub.publish(astar.getPath());
+
+      createAvoidWaypoints(astar.getPath(), search_info, 100, &amp;avoid_lane, &amp;end_of_avoid_index);
 
-    ros::NodeHandle nh;
-    ros::Subscriber twist_sub = nh.subscribe("temporal_waypoints", 1, callback);
-    _pub = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("final_waypoints", 1000,true);
+      if (search_info.getChangePath())
+        avoidance = true;
 
-    ros::spin();
+    } else {
+      std::cout &lt;&lt; "can't find goal..." &lt;&lt; std::endl;
+    }
 
+    // Reset flags
+    search_info.reset();
+    astar.reset();
 
+    loop_rate.sleep();
+  }
 
-    return 0;
+  return 0;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="30" deleted_lines="14">
				<diff>@@ -428,19 +428,25 @@ EControl obstacleDetection(int closest_waypoint, const waypoint_follower_msgs::l
   return detection_result;
 }
 
-void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_result, int closest_waypoint, int obstacle_waypoint, const ros::Publisher&amp; temporal_waypoints_pub, VelocitySetPath* vs_path)
+void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_result, int closest_waypoint, int obstacle_waypoint, const ros::Publisher&amp; final_waypoints_pub, VelocitySetPath* vs_path)
 {
   if (detection_result == EControl::STOP)
   {  // STOP for obstacle
-    // stop_waypoint is about g_stop_distance meter away from obstacles
-    int stop_waypoint = obstacle_waypoint - vs_info.getStopDistance() / vs_path-&gt;calcInterval(0, 1);
+    // stop_waypoint is about stop distance meter away from obstacles
+    int stop_waypoint = 0;
+    if (vs_path-&gt;getPrevWaypointsSize() &gt; 1)
+    {
+      stop_waypoint = obstacle_waypoint - vs_info.getStopDistance() / vs_path-&gt;calcInterval(0, 1);
+    }
+    if (stop_waypoint &lt; 0)
+      stop_waypoint = 0;
 
     // change waypoints to stop by the stop_waypoint
     vs_path-&gt;changeWaypointsForStopping(stop_waypoint, obstacle_waypoint, closest_waypoint, vs_info.getDeceleration());
     vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;avoidSuddenDeceleration(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
-    temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
+    final_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
   }
   else if (detection_result == EControl::DECELERATE)
   {  // DECELERATE for obstacles
@@ -449,7 +455,7 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
     vs_path-&gt;avoidSuddenDeceleration(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
-    temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
+    final_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
   }
   else
   {  // ACCELERATE or KEEP
@@ -457,7 +463,7 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
     vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;avoidSuddenDeceleration(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
     vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
-    temporal_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
+    final_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
   }
 }
 
@@ -482,7 +488,7 @@ int main(int argc, char **argv)
   VelocitySetInfo vs_info;
 
   // velocity set subscriber
-  ros::Subscriber waypoints_sub = nh.subscribe("base_waypoints", 1, &amp;VelocitySetPath::waypointsCallback, &amp;vs_path);
+  ros::Subscriber waypoints_sub = nh.subscribe("safety_waypoints", 1, &amp;VelocitySetPath::waypointsCallback, &amp;vs_path);
   ros::Subscriber current_vel_sub = nh.subscribe("current_velocity", 1, &amp;VelocitySetPath::currentVelocityCallback, &amp;vs_path);
 
   // velocity set info subscriber
@@ -490,7 +496,7 @@ int main(int argc, char **argv)
   ros::Subscriber points_sub = nh.subscribe(points_topic, 1, &amp;VelocitySetInfo::pointsCallback, &amp;vs_info);
   ros::Subscriber localizer_sub = nh.subscribe("localizer_pose", 1, &amp;VelocitySetInfo::localizerPoseCallback, &amp;vs_info);
   ros::Subscriber control_pose_sub = nh.subscribe("current_pose", 1, &amp;VelocitySetInfo::controlPoseCallback, &amp;vs_info);
-  ros::Subscriber closest_waypoint_sub = nh.subscribe("closest_waypoint", 1, &amp;VelocitySetInfo::closestWaypointCallback, &amp;vs_info);
+  //ros::Subscriber closest_waypoint_sub = nh.subscribe("closest_waypoint", 1, &amp;VelocitySetInfo::closestWaypointCallback, &amp;vs_info);
 
   // vector map subscriber
   ros::Subscriber sub_dtlane = nh.subscribe("vector_map_info/cross_walk", 1, &amp;CrossWalk::crossWalkCallback, &amp;crosswalk);
@@ -499,15 +505,18 @@ int main(int argc, char **argv)
   ros::Subscriber sub_point = nh.subscribe("vector_map_info/point", 1, &amp;CrossWalk::pointCallback, &amp;crosswalk);
 
   // publisher
-  ros::Publisher detection_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 0);
-  ros::Publisher temporal_waypoints_pub = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("temporal_waypoints", 1000, true);
-  ros::Publisher obstacle_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("obstacle", 0);
+  ros::Publisher detection_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 1);
+  ros::Publisher final_waypoints_pub = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("final_waypoints", 1, true);
+  ros::Publisher obstacle_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("obstacle", 1);
+  ros::Publisher obstacle_waypoint_pub = nh.advertise&lt;std_msgs::Int32&gt;("obstacle_waypoint", 1, true);
 
   ros::Rate loop_rate(LOOP_RATE);
   while (ros::ok())
   {
     ros::spinOnce();
 
+    int closest_waypoint = 0;
+
     if (crosswalk.loaded_all &amp;&amp; !crosswalk.set_points)
       crosswalk.setCrossWalkPoints();
 
@@ -518,15 +527,22 @@ int main(int argc, char **argv)
     }
 
     if (use_crosswalk_detection)
-      crosswalk.setDetectionWaypoint(crosswalk.findClosestCrosswalk(vs_info.getClosestWaypoint(), vs_path.getPrevWaypoints(), STOP_SEARCH_DISTANCE));
+      crosswalk.setDetectionWaypoint(crosswalk.findClosestCrosswalk(closest_waypoint, vs_path.getPrevWaypoints(), STOP_SEARCH_DISTANCE));
 
     int obstacle_waypoint = -1;
-    EControl detection_result = obstacleDetection(vs_info.getClosestWaypoint(), vs_path.getPrevWaypoints(), crosswalk, vs_info, detection_range_pub, obstacle_pub, &amp;obstacle_waypoint);
+    EControl detection_result = obstacleDetection(closest_waypoint, vs_path.getPrevWaypoints(), crosswalk, vs_info, detection_range_pub, obstacle_pub, &amp;obstacle_waypoint);
 
-    changeWaypoints(vs_info, detection_result, vs_info.getClosestWaypoint(), obstacle_waypoint, temporal_waypoints_pub, &amp;vs_path);
+    changeWaypoints(vs_info, detection_result, closest_waypoint, obstacle_waypoint, final_waypoints_pub, &amp;vs_path);
 
     vs_info.clearPoints();
 
+    // publish obstacle waypoint index
+    std_msgs::Int32 obstacle_waypoint_index;
+    obstacle_waypoint_index.data = obstacle_waypoint;
+    obstacle_waypoint_pub.publish(obstacle_waypoint_index);
+
+    vs_path.resetFlag();
+
     loop_rate.sleep();
   }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" added_lines="0" deleted_lines="6">
				<diff>@@ -40,7 +40,6 @@ VelocitySetInfo::VelocitySetInfo()
     decel_(0.8),
     velocity_change_limit_(2.77),
     temporal_waypoints_size_(100),
-    closest_waypoint_(-1),
     set_pose_(false)
 {
 }
@@ -97,8 +96,3 @@ void VelocitySetInfo::localizerPoseCallback(const geometry_msgs::PoseStampedCons
 {
   localizer_pose_ = *msg;
 }
-
-void VelocitySetInfo::closestWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
-{
-  closest_waypoint_ = msg-&gt;data;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" added_lines="0" deleted_lines="7">
				<diff>@@ -55,7 +55,6 @@ class VelocitySetInfo
   pcl::PointCloud&lt;pcl::PointXYZ&gt; points_;
   geometry_msgs::PoseStamped localizer_pose_;  // pose of sensor
   geometry_msgs::PoseStamped control_pose_;    // pose of base_link
-  int closest_waypoint_;
   bool set_pose_;
 
  public:
@@ -67,7 +66,6 @@ class VelocitySetInfo
   void pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg);
   void controlPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void localizerPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
-  void closestWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg);
 
   void clearPoints();
 
@@ -131,11 +129,6 @@ class VelocitySetInfo
     return localizer_pose_;
   }
 
-  int getClosestWaypoint() const
-  {
-    return closest_waypoint_;
-  }
-
   bool getSetPose() const
   {
     return set_pose_;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="9" deleted_lines="4">
				<diff>@@ -62,13 +62,14 @@ void VelocitySetPath::setTemporalWaypoints(int temporal_waypoints_size, int clos
   temporal_waypoints_.waypoints.clear();
   temporal_waypoints_.header = new_waypoints_.header;
   temporal_waypoints_.increment = new_waypoints_.increment;
+
   // push current pose
   waypoint_follower_msgs::waypoint current_point;
-
   current_point.pose = control_pose;
   current_point.twist = new_waypoints_.waypoints[closest_waypoint].twist;
   current_point.dtlane = new_waypoints_.waypoints[closest_waypoint].dtlane;
   temporal_waypoints_.waypoints.push_back(current_point);
+
   for (int i = 0; i &lt; temporal_waypoints_size; i++)
   {
     if (closest_waypoint + i &gt;= getNewWaypointsSize())
@@ -202,7 +203,7 @@ double VelocitySetPath::calcInterval(const int begin, const int end) const
   if (begin &lt; 0 || begin &gt;= getPrevWaypointsSize() || end &lt; 0 || end &gt;= getPrevWaypointsSize())
   {
     ROS_WARN("Invalid index");
-    return -1;
+    return 0;
   }
 
   // Calculate the inteval of waypoints
@@ -221,14 +222,18 @@ double VelocitySetPath::calcInterval(const int begin, const int end) const
   return dist_sum;
 }
 
+void VelocitySetPath::resetFlag()
+{
+  set_path_ = false;
+}
 
 void VelocitySetPath::waypointsCallback(const waypoint_follower_msgs::laneConstPtr&amp; msg)
 {
   prev_waypoints_ = *msg;
+  // temporary, edit waypoints velocity later
   new_waypoints_ = *msg;
 
-  if (!set_path_)
-    set_path_ = true;
+  set_path_ = true;
 }
 
 void VelocitySetPath::currentVelocityCallback(const geometry_msgs::TwistStampedConstPtr&amp; msg)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" added_lines="1" deleted_lines="0">
				<diff>@@ -58,6 +58,7 @@ class VelocitySetPath
   void changeWaypointsForDeceleration(double deceleration, int closest_waypoint, int obstacle_waypoint);
   void setTemporalWaypoints(int temporal_waypoints_size, int closest_waypoint, geometry_msgs::PoseStamped control_pose);
   void initializeNewWaypoints();
+  void resetFlag();
 
   // ROS Callbacks
   void waypointsCallback(const waypoint_follower_msgs::laneConstPtr&amp; msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -406,7 +406,7 @@ void laneArrayCallback(const waypoint_follower_msgs::LaneArrayConstPtr &amp;msg)
   publishGlobalMarker();
 }
 
-void temporalCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg)
+void finalCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg)
 {
   g_local_waypoints_marker_array.markers.clear();
   if (_closest_waypoint != -1)
@@ -438,7 +438,7 @@ int main(int argc, char **argv)
   ros::Subscriber traffic_array_sub = nh.subscribe("traffic_waypoints_array", 10, laneArrayCallback);
 
   //subscribe local waypoints
-  ros::Subscriber temporal_sub = nh.subscribe("temporal_waypoints", 10, temporalCallback);
+  ros::Subscriber final_sub = nh.subscribe("final_waypoints", 10, finalCallback);
   ros::Subscriber closest_sub = nh.subscribe("closest_waypoint", 10, closestCallback);
 
   //subscribe config
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="dc491cb188a817f58242e9d0a53057b78e80baa1" author="TomohitoAndo">
		<msg>Apply clang-formt</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_search.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_search.cpp" added_lines="177" deleted_lines="133">
				<diff>@@ -32,10 +32,7 @@
 
 namespace astar_planner
 {
-
-AstarSearch::AstarSearch()
-  : node_initialized_(false),
-    upper_bound_distance_(-1)
+AstarSearch::AstarSearch() : node_initialized_(false), upper_bound_distance_(-1)
 {
   ros::NodeHandle private_nh_("~");
   private_nh_.param&lt;bool&gt;("use_2dnav_goal", use_2dnav_goal_, true);
@@ -66,8 +63,7 @@ AstarSearch::~AstarSearch()
 {
 }
 
-
-void AstarSearch::initializeNode(const nav_msgs::OccupancyGrid&amp; map)
+void AstarSearch::initializeNode(const nav_msgs::OccupancyGrid &amp;map)
 {
   int height = map.info.height;
   int width = map.info.width;
@@ -84,7 +80,6 @@ void AstarSearch::initializeNode(const nav_msgs::OccupancyGrid&amp; map)
   node_initialized_ = true;
 }
 
-
 void AstarSearch::poseToIndex(const geometry_msgs::Pose &amp;pose, int *index_x, int *index_y, int *index_theta)
 {
   *index_x = pose.position.x / map_info_.resolution;
@@ -114,11 +109,12 @@ void AstarSearch::createStateUpdateTableLocal(int angle_size)
   for (int i = 0; i &lt; angle_size; i++)
     state_update_table_[i].reserve(max_action_num);
 
-    // Minimum moving distance with one state update
-    //     arc  = r                       * theta
-    double step = minimum_turning_radius_ * (2.0 * M_PI / angle_size_);
+  // Minimum moving distance with one state update
+  //     arc  = r                       * theta
+  double step = minimum_turning_radius_ * (2.0 * M_PI / angle_size_);
 
-  for (int i = 0; i &lt; angle_size; i++) {
+  for (int i = 0; i &lt; angle_size; i++)
+  {
     double descretized_angle = 2.0 * M_PI / angle_size;
     double robot_angle = descretized_angle * i;
 
@@ -126,26 +122,28 @@ void AstarSearch::createStateUpdateTableLocal(int angle_size)
     // Robot moves along these circles
     double right_circle_center_x = minimum_turning_radius_ * std::sin(robot_angle);
     double right_circle_center_y = minimum_turning_radius_ * std::cos(robot_angle) * -1.0;
-    double left_circle_center_x  = right_circle_center_x * -1.0;
-    double left_circle_center_y  = right_circle_center_y * -1.0;
+    double left_circle_center_x = right_circle_center_x * -1.0;
+    double left_circle_center_y = right_circle_center_y * -1.0;
 
     NodeUpdate nu;
 
     // Calculate x and y shift to next state
     // forward
-    nu.shift_x     = step * std::cos(robot_angle);
-    nu.shift_y     = step * std::sin(robot_angle);
-    nu.rotation    = 0;
+    nu.shift_x = step * std::cos(robot_angle);
+    nu.shift_y = step * std::sin(robot_angle);
+    nu.rotation = 0;
     nu.index_theta = 0;
-    nu.step        = step;
-    nu.curve       = false;
-    nu.back        = false;
+    nu.step = step;
+    nu.curve = false;
+    nu.back = false;
     state_update_table_[i].emplace_back(nu);
 
     /*
     // forward right max
-    nu.shift_x     = right_circle_center_x + minimum_turning_radius_ * std::cos(M_PI_2 + robot_angle - descretized_angle);
-    nu.shift_y     = right_circle_center_y + minimum_turning_radius_ * std::sin(M_PI_2 + robot_angle - descretized_angle);
+    nu.shift_x     = right_circle_center_x + minimum_turning_radius_ * std::cos(M_PI_2 + robot_angle -
+    descretized_angle);
+    nu.shift_y     = right_circle_center_y + minimum_turning_radius_ * std::sin(M_PI_2 + robot_angle -
+    descretized_angle);
     nu.rotation    = descretized_angle * -1.0;
     nu.index_theta = -1;
     nu.step        = step;
@@ -154,8 +152,10 @@ void AstarSearch::createStateUpdateTableLocal(int angle_size)
     state_update_table_[i].emplace_back(nu);
 
     // forward left max
-    nu.shift_x     = left_circle_center_x + minimum_turning_radius_ * std::cos(-1.0 * M_PI_2 + robot_angle + descretized_angle);
-    nu.shift_y     = left_circle_center_y + minimum_turning_radius_ * std::sin(-1.0 * M_PI_2 + robot_angle + descretized_angle);
+    nu.shift_x     = left_circle_center_x + minimum_turning_radius_ * std::cos(-1.0 * M_PI_2 + robot_angle +
+    descretized_angle);
+    nu.shift_y     = left_circle_center_y + minimum_turning_radius_ * std::sin(-1.0 * M_PI_2 + robot_angle +
+    descretized_angle);
     nu.rotation    = descretized_angle;
     nu.index_theta = 1;
     nu.step        = step;
@@ -165,29 +165,35 @@ void AstarSearch::createStateUpdateTableLocal(int angle_size)
     */
 
     // forward right medium
-    nu.shift_x     = right_circle_center_x * 2 + minimum_turning_radius_ * 2 * std::cos(M_PI_2 + robot_angle - descretized_angle);
-    nu.shift_y     = right_circle_center_y * 2 + minimum_turning_radius_ * 2 * std::sin(M_PI_2 + robot_angle - descretized_angle);
-    nu.rotation    = descretized_angle * -1.0;
+    nu.shift_x =
+        right_circle_center_x * 2 + minimum_turning_radius_ * 2 * std::cos(M_PI_2 + robot_angle - descretized_angle);
+    nu.shift_y =
+        right_circle_center_y * 2 + minimum_turning_radius_ * 2 * std::sin(M_PI_2 + robot_angle - descretized_angle);
+    nu.rotation = descretized_angle * -1.0;
     nu.index_theta = -1;
-    nu.step        = step * 2;
-    nu.curve       = true;
-    nu.back        = false;
+    nu.step = step * 2;
+    nu.curve = true;
+    nu.back = false;
     state_update_table_[i].emplace_back(nu);
 
     // forward left medium
-    nu.shift_x     = left_circle_center_x * 2 + minimum_turning_radius_ * 2 * std::cos(-1.0 * M_PI_2 + robot_angle + descretized_angle);
-    nu.shift_y     = left_circle_center_y * 2 + minimum_turning_radius_ * 2 * std::sin(-1.0 * M_PI_2 + robot_angle + descretized_angle);
-    nu.rotation    = descretized_angle;
+    nu.shift_x = left_circle_center_x * 2 +
+                 minimum_turning_radius_ * 2 * std::cos(-1.0 * M_PI_2 + robot_angle + descretized_angle);
+    nu.shift_y = left_circle_center_y * 2 +
+                 minimum_turning_radius_ * 2 * std::sin(-1.0 * M_PI_2 + robot_angle + descretized_angle);
+    nu.rotation = descretized_angle;
     nu.index_theta = 1;
-    nu.step        = step * 2;
-    nu.curve       = true;
-    nu.back        = false;
+    nu.step = step * 2;
+    nu.curve = true;
+    nu.back = false;
     state_update_table_[i].emplace_back(nu);
 
     /*
     // forward right max
-    nu.shift_x     = right_circle_center_x + minimum_turning_radius_ * std::cos(M_PI_2 + robot_angle - descretized_angle * 2);
-    nu.shift_y     = right_circle_center_y + minimum_turning_radius_ * std::sin(M_PI_2 + robot_angle - descretized_angle * 2);
+    nu.shift_x     = right_circle_center_x + minimum_turning_radius_ * std::cos(M_PI_2 + robot_angle - descretized_angle
+    * 2);
+    nu.shift_y     = right_circle_center_y + minimum_turning_radius_ * std::sin(M_PI_2 + robot_angle - descretized_angle
+    * 2);
     nu.rotation    = descretized_angle * 2 * -1.0;
     nu.index_theta = -2;
     nu.step        = step * 2;
@@ -196,8 +202,10 @@ void AstarSearch::createStateUpdateTableLocal(int angle_size)
     state_update_table_[i].emplace_back(nu);
 
     // forward left max
-    nu.shift_x     = left_circle_center_x + minimum_turning_radius_ * std::cos(-1.0 * M_PI_2 + robot_angle + descretized_angle * 2);
-    nu.shift_y     = left_circle_center_y + minimum_turning_radius_ * std::sin(-1.0 * M_PI_2 + robot_angle + descretized_angle * 2);
+    nu.shift_x     = left_circle_center_x + minimum_turning_radius_ * std::cos(-1.0 * M_PI_2 + robot_angle +
+    descretized_angle * 2);
+    nu.shift_y     = left_circle_center_y + minimum_turning_radius_ * std::sin(-1.0 * M_PI_2 + robot_angle +
+    descretized_angle * 2);
     nu.rotation    = descretized_angle * 2;
     nu.index_theta = 2;
     nu.step        = step * 2;
@@ -211,13 +219,14 @@ void AstarSearch::createStateUpdateTableLocal(int angle_size)
 
 bool AstarSearch::isOutOfRange(int index_x, int index_y)
 {
-  if (index_x &lt; 0 || index_x &gt;= static_cast&lt;int&gt;(map_info_.width) || index_y &lt; 0 || index_y &gt;= static_cast&lt;int&gt;(map_info_.height))
+  if (index_x &lt; 0 || index_x &gt;= static_cast&lt;int&gt;(map_info_.width) || index_y &lt; 0 ||
+      index_y &gt;= static_cast&lt;int&gt;(map_info_.height))
     return true;
 
   return false;
 }
 
-void AstarSearch::displayFootprint(const nav_msgs::Path&amp; path)
+void AstarSearch::displayFootprint(const nav_msgs::Path &amp;path)
 {
   visualization_msgs::Marker marker;
   marker.header.frame_id = "/map";
@@ -237,7 +246,8 @@ void AstarSearch::displayFootprint(const nav_msgs::Path&amp; path)
   marker.frame_locked = true;
 
   visualization_msgs::MarkerArray marker_array;
-  for (const auto&amp; p : path.poses) {
+  for (const auto &amp;p : path.poses)
+  {
     marker.pose = p.pose;
     marker_array.markers.push_back(marker);
     marker.id += 1;
@@ -256,7 +266,8 @@ void AstarSearch::setPath(const SimpleNode &amp;goal)
   // From the goal node to the start node
   AstarNode *node = &amp;nodes_[goal.index_y][goal.index_x][goal.index_theta];
 
-  while (node != NULL) {
+  while (node != NULL)
+  {
     // Set tf pose
     tf::Vector3 origin(node-&gt;x, node-&gt;y, 0);
     tf::Pose tf_pose;
@@ -288,16 +299,18 @@ void AstarSearch::setPath(const SimpleNode &amp;goal)
 bool AstarSearch::isGoal(double x, double y, double theta)
 {
   // To reduce computation time, we use square value for distance
-  static const double lateral_goal_range      = lateral_goal_range_ / 2.0;                // [meter], divide by 2 means we check left and right
-  static const double longitudinal_goal_range = longitudinal_goal_range_ / 2.0;           // [meter], check only behind of the goal
-  static const double goal_angle              = M_PI * (goal_angle_range_ / 2.0) / 180.0; // degrees -&gt; radian
+  static const double lateral_goal_range =
+      lateral_goal_range_ / 2.0;  // [meter], divide by 2 means we check left and right
+  static const double longitudinal_goal_range =
+      longitudinal_goal_range_ / 2.0;                                         // [meter], check only behind of the goal
+  static const double goal_angle = M_PI * (goal_angle_range_ / 2.0) / 180.0;  // degrees -&gt; radian
 
   // Calculate the node coordinate seen from the goal point
   tf::Point p(x, y, 0);
   geometry_msgs::Point relative_node_point = astar_planner::calcRelativeCoordinate(goal_pose_local_.pose, p);
 
   // Check Pose of goal
-  if (relative_node_point.x            &lt; 0                       &amp;&amp; // shoud be behind of goal
+  if (relative_node_point.x &lt; 0 &amp;&amp;  // shoud be behind of goal
       std::fabs(relative_node_point.x) &lt; longitudinal_goal_range &amp;&amp;
       std::fabs(relative_node_point.y) &lt; lateral_goal_range)
   {
@@ -320,16 +333,16 @@ bool AstarSearch::isObs(int index_x, int index_y)
 bool AstarSearch::detectCollision(const SimpleNode &amp;sn)
 {
   // Define the robot as rectangle
-  static double left   = -1.0 * base2back_;
-  static double right  = robot_length_ - base2back_;
-  static double top    = robot_width_ / 2.0;
+  static double left = -1.0 * base2back_;
+  static double right = robot_length_ - base2back_;
+  static double top = robot_width_ / 2.0;
   static double bottom = -1.0 * robot_width_ / 2.0;
   static double resolution = map_info_.resolution;
 
   // Coordinate of base_link in OccupancyGrid frame
   static double one_angle_range = 2.0 * M_PI / angle_size_;
-  double base_x     = sn.index_x * resolution;
-  double base_y     = sn.index_y * resolution;
+  double base_x = sn.index_x * resolution;
+  double base_y = sn.index_y * resolution;
   double base_theta = sn.index_theta * one_angle_range;
 
   // Calculate cos and sin in advance
@@ -337,8 +350,10 @@ bool AstarSearch::detectCollision(const SimpleNode &amp;sn)
   double sin_theta = std::sin(base_theta);
 
   // Convert each point to index and check if the node is Obstacle
-  for (double x = left; x &lt; right; x += resolution) {
-    for (double y = top; y &gt; bottom; y -= resolution) {
+  for (double x = left; x &lt; right; x += resolution)
+  {
+    for (double y = top; y &gt; bottom; y -= resolution)
+    {
       // 2D point rotation
       int index_x = (x * cos_theta - y * sin_theta + base_x) / resolution;
       int index_y = (x * sin_theta + y * cos_theta + base_y) / resolution;
@@ -366,14 +381,12 @@ bool AstarSearch::calcWaveFrontHeuristic(const SimpleNode &amp;sn)
   // Nodes are expanded for each neighborhood cells (moore neighborhood)
   double resolution = map_info_.resolution;
   static std::vector&lt;WaveFrontNode&gt; updates = {
-    astar_planner::getWaveFrontNode( 0,  1, resolution),
-    astar_planner::getWaveFrontNode(-1,  0, resolution),
-    astar_planner::getWaveFrontNode( 1,  0, resolution),
-    astar_planner::getWaveFrontNode( 0, -1, resolution),
-    astar_planner::getWaveFrontNode(-1,  1, std::hypot(resolution, resolution)),
-    astar_planner::getWaveFrontNode( 1,  1, std::hypot(resolution, resolution)),
+    astar_planner::getWaveFrontNode(0, 1, resolution), astar_planner::getWaveFrontNode(-1, 0, resolution),
+    astar_planner::getWaveFrontNode(1, 0, resolution), astar_planner::getWaveFrontNode(0, -1, resolution),
+    astar_planner::getWaveFrontNode(-1, 1, std::hypot(resolution, resolution)),
+    astar_planner::getWaveFrontNode(1, 1, std::hypot(resolution, resolution)),
     astar_planner::getWaveFrontNode(-1, -1, std::hypot(resolution, resolution)),
-    astar_planner::getWaveFrontNode( 1, -1, std::hypot(resolution, resolution)),
+    astar_planner::getWaveFrontNode(1, -1, std::hypot(resolution, resolution)),
   };
 
   // Get start index
@@ -386,18 +399,19 @@ bool AstarSearch::calcWaveFrontHeuristic(const SimpleNode &amp;sn)
   bool reachable = false;
 
   // Start wavefront search
-  while (!qu.empty()) {
+  while (!qu.empty())
+  {
     WaveFrontNode ref = qu.front();
     qu.pop();
 
     WaveFrontNode next;
-    for (const auto &amp;u : updates) {
+    for (const auto &amp;u : updates)
+    {
       next.index_x = ref.index_x + u.index_x;
       next.index_y = ref.index_y + u.index_y;
 
       // out of range OR already visited OR obstacle node
-      if (isOutOfRange(next.index_x, next.index_y) ||
-          nodes_[next.index_y][next.index_x][0].hc &gt; 0 ||
+      if (isOutOfRange(next.index_x, next.index_y) || nodes_[next.index_y][next.index_x][0].hc &gt; 0 ||
           nodes_[next.index_y][next.index_x][0].status == STATUS::OBS)
         continue;
 
@@ -429,8 +443,10 @@ bool AstarSearch::detectCollisionWaveFront(const WaveFrontNode &amp;ref)
   double robot_x = ref.index_x * map_info_.resolution;
   double robot_y = ref.index_y * map_info_.resolution;
 
-  for (double y = half; y &gt; -1.0 * half; y -= map_info_.resolution) {
-    for (double x = -1.0 * half; x &lt; half; x += map_info_.resolution) {
+  for (double y = half; y &gt; -1.0 * half; y -= map_info_.resolution)
+  {
+    for (double x = -1.0 * half; x &lt; half; x += map_info_.resolution)
+    {
       int index_x = (robot_x + x) / map_info_.resolution;
       int index_y = (robot_y + y) / map_info_.resolution;
 
@@ -457,9 +473,12 @@ void AstarSearch::reset()
   ros::WallTime begin = ros::WallTime::now();
 
   // Reset node info here ...?
-  for (size_t i = 0; i &lt; map_info_.height; i++) {
-    for (size_t j = 0; j &lt; map_info_.width; j++) {
-      for (int k = 0; k &lt; angle_size_; k++) {
+  for (size_t i = 0; i &lt; map_info_.height; i++)
+  {
+    for (size_t j = 0; j &lt; map_info_.width; j++)
+    {
+      for (int k = 0; k &lt; angle_size_; k++)
+      {
         // other values will be updated during the search
         nodes_[i][j][k].status = STATUS::NONE;
         nodes_[i][j][k].hc = 0;
@@ -494,8 +513,10 @@ void AstarSearch::setMap(const nav_msgs::OccupancyGrid &amp;map)
   geometry_msgs::Pose ogm_in_map = astar_planner::transformPose(map_info_.origin, map2ogm_frame);
   tf::poseMsgToTF(ogm_in_map, map2ogm_);
 
-  for (size_t i = 0; i &lt; map.info.height; i++) {
-    for (size_t j = 0; j &lt; map.info.width; j++) {
+  for (size_t i = 0; i &lt; map.info.height; i++)
+  {
+    for (size_t j = 0; j &lt; map.info.width; j++)
+    {
       // Index of subscribing OccupancyGrid message
       size_t og_index = i * map.info.width + j;
       int cost = map.data[og_index];
@@ -517,10 +538,8 @@ void AstarSearch::setMap(const nav_msgs::OccupancyGrid &amp;map)
       // obstacle or unknown area
       if (cost == 100 || cost &lt; 0)
         nodes_[i][j][0].status = STATUS::OBS;
-
     }
   }
-
 }
 
 bool AstarSearch::setStartNode()
@@ -538,22 +557,27 @@ bool AstarSearch::setStartNode()
 
   // Set start node
   AstarNode &amp;start_node = nodes_[index_y][index_x][index_theta];
-  start_node.x      = start_pose_local_.pose.position.x;
-  start_node.y      = start_pose_local_.pose.position.y;
-  start_node.theta  = 2.0 * M_PI / angle_size_ * index_theta;
-  start_node.gc     = 0;
+  start_node.x = start_pose_local_.pose.position.x;
+  start_node.y = start_pose_local_.pose.position.y;
+  start_node.theta = 2.0 * M_PI / angle_size_ * index_theta;
+  start_node.gc = 0;
   start_node.move_distance = 0;
-  start_node.back   = false;
+  start_node.back = false;
   start_node.status = STATUS::OPEN;
   start_node.parent = NULL;
 
   // set euclidean distance heuristic cost
   if (!use_wavefront_heuristic_ &amp;&amp; !use_potential_heuristic_)
-    start_node.hc = astar_planner::calcDistance(start_pose_local_.pose.position.x, start_pose_local_.pose.position.y, goal_pose_local_.pose.position.x, goal_pose_local_.pose.position.y) * distance_heuristic_weight_;
+    start_node.hc = astar_planner::calcDistance(start_pose_local_.pose.position.x, start_pose_local_.pose.position.y,
+                                                goal_pose_local_.pose.position.x, goal_pose_local_.pose.position.y) *
+                    distance_heuristic_weight_;
 
-  if (use_potential_heuristic_) {
+  if (use_potential_heuristic_)
+  {
     start_node.gc += start_node.hc;
-    start_node.hc += astar_planner::calcDistance(start_pose_local_.pose.position.x, start_pose_local_.pose.position.y, goal_pose_local_.pose.position.x, goal_pose_local_.pose.position.y) + distance_heuristic_weight_;
+    start_node.hc += astar_planner::calcDistance(start_pose_local_.pose.position.x, start_pose_local_.pose.position.y,
+                                                 goal_pose_local_.pose.position.x, goal_pose_local_.pose.position.y) +
+                     distance_heuristic_weight_;
   }
 
   // Push start node to openlist
@@ -583,10 +607,11 @@ bool AstarSearch::setGoalNode()
     return false;
 
   // Make multiple cells goals
-  //createGoalList(goal_sn);
+  // createGoalList(goal_sn);
 
   // Calculate wavefront heuristic cost
-  if (use_wavefront_heuristic_) {
+  if (use_wavefront_heuristic_)
+  {
     auto start = std::chrono::system_clock::now();
 
     bool wavefront_result = calcWaveFrontHeuristic(goal_sn);
@@ -611,7 +636,8 @@ bool AstarSearch::search()
 
   // Start A* search
   // If the openlist is empty, search failed
-  while (!openlist_.empty()) {
+  while (!openlist_.empty())
+  {
     // Check time and terminate if the search reaches the time limit
     ros::WallTime timer_end = ros::WallTime::now();
     double msec = (timer_end - timer_begin).toSec() * 1000.0;
@@ -630,9 +656,9 @@ bool AstarSearch::search()
     AstarNode *current_node = &amp;nodes_[sn.index_y][sn.index_x][sn.index_theta];
     current_node-&gt;status = STATUS::CLOSED;
 
-
     // Goal check
-    if (isGoal(current_node-&gt;x, current_node-&gt;y, current_node-&gt;theta)) {
+    if (isGoal(current_node-&gt;x, current_node-&gt;y, current_node-&gt;theta))
+    {
       ROS_INFO("Search time: %lf [msec]", (timer_end - timer_begin).toSec() * 1000.0);
 
       setPath(sn);
@@ -647,12 +673,13 @@ bool AstarSearch::search()
     }
 
     // Expand nodes
-    for (const auto &amp;state : state_update_table_[sn.index_theta]) {
+    for (const auto &amp;state : state_update_table_[sn.index_theta])
+    {
       // Next state
-      double next_x        = current_node-&gt;x + state.shift_x;
-      double next_y        = current_node-&gt;y + state.shift_y;
-      double next_theta    = astar_planner::modifyTheta(current_node-&gt;theta + state.rotation);
-      double move_cost     = state.step;
+      double next_x = current_node-&gt;x + state.shift_x;
+      double next_y = current_node-&gt;y + state.shift_y;
+      double next_theta = astar_planner::modifyTheta(current_node-&gt;theta + state.rotation);
+      double move_cost = state.step;
       double move_distance = current_node-&gt;move_distance + state.step;
 
       // Increase reverse cost
@@ -661,8 +688,8 @@ bool AstarSearch::search()
 
       // Calculate index of the next state
       SimpleNode next;
-      next.index_x     = next_x / map_info_.resolution;
-      next.index_y     = next_y / map_info_.resolution;
+      next.index_x = next_x / map_info_.resolution;
+      next.index_y = next_y / map_info_.resolution;
       next.index_theta = sn.index_theta + state.index_theta;
 
       // Avoid invalid index
@@ -673,34 +700,41 @@ bool AstarSearch::search()
         continue;
 
       // prunning with upper bound
-      if (upper_bound_distance_ &gt; 0 &amp;&amp; move_distance &gt; upper_bound_distance_) {
+      if (upper_bound_distance_ &gt; 0 &amp;&amp; move_distance &gt; upper_bound_distance_)
+      {
         continue;
       }
 
       AstarNode *next_node = &amp;nodes_[next.index_y][next.index_x][next.index_theta];
-      double next_gc       = current_node-&gt;gc + move_cost;
-      double next_hc       =  nodes_[next.index_y][next.index_x][0].hc; // wavefront or distance transform heuristic
+      double next_gc = current_node-&gt;gc + move_cost;
+      double next_hc = nodes_[next.index_y][next.index_x][0].hc;  // wavefront or distance transform heuristic
 
       // increase the cost with euclidean distance
-      if (use_potential_heuristic_) {
+      if (use_potential_heuristic_)
+      {
         next_gc += nodes_[next.index_y][next.index_x][0].hc;
-        next_hc += astar_planner::calcDistance(next_x, next_y, goal_pose_local_.pose.position.x, goal_pose_local_.pose.position.y) * distance_heuristic_weight_;
+        next_hc += astar_planner::calcDistance(next_x, next_y, goal_pose_local_.pose.position.x,
+                                               goal_pose_local_.pose.position.y) *
+                   distance_heuristic_weight_;
       }
 
       // increase the cost with euclidean distance
       if (!use_wavefront_heuristic_ &amp;&amp; !use_potential_heuristic_)
-        next_hc = astar_planner::calcDistance(next_x, next_y, goal_pose_local_.pose.position.x, goal_pose_local_.pose.position.y) * distance_heuristic_weight_;
+        next_hc = astar_planner::calcDistance(next_x, next_y, goal_pose_local_.pose.position.x,
+                                              goal_pose_local_.pose.position.y) *
+                  distance_heuristic_weight_;
 
       // NONE
-      if (next_node-&gt;status == STATUS::NONE) {
+      if (next_node-&gt;status == STATUS::NONE)
+      {
         next_node-&gt;status = STATUS::OPEN;
-        next_node-&gt;x      = next_x;
-        next_node-&gt;y      = next_y;
-        next_node-&gt;theta  = next_theta;
-        next_node-&gt;gc     = next_gc;
-        next_node-&gt;hc     = next_hc;
+        next_node-&gt;x = next_x;
+        next_node-&gt;y = next_y;
+        next_node-&gt;theta = next_theta;
+        next_node-&gt;gc = next_gc;
+        next_node-&gt;hc = next_hc;
         next_node-&gt;move_distance = move_distance;
-        next_node-&gt;back   = state.back;
+        next_node-&gt;back = state.back;
         next_node-&gt;parent = current_node;
 
         next.cost = next_node-&gt;gc + next_node-&gt;hc;
@@ -709,16 +743,18 @@ bool AstarSearch::search()
       }
 
       // OPEN or CLOSED
-      if (next_node-&gt;status == STATUS::OPEN || next_node-&gt;status == STATUS::CLOSED) {
-        if (next_gc &lt; next_node-&gt;gc) {
+      if (next_node-&gt;status == STATUS::OPEN || next_node-&gt;status == STATUS::CLOSED)
+      {
+        if (next_gc &lt; next_node-&gt;gc)
+        {
           next_node-&gt;status = STATUS::OPEN;
-          next_node-&gt;x      = next_x;
-          next_node-&gt;y      = next_y;
-          next_node-&gt;theta  = next_theta;
-          next_node-&gt;gc     = next_gc;
-          next_node-&gt;hc     = next_hc; //already calculated ?
+          next_node-&gt;x = next_x;
+          next_node-&gt;y = next_y;
+          next_node-&gt;theta = next_theta;
+          next_node-&gt;gc = next_gc;
+          next_node-&gt;hc = next_hc;  // already calculated ?
           next_node-&gt;move_distance = move_distance;
-          next_node-&gt;back   = state.back;
+          next_node-&gt;back = state.back;
           next_node-&gt;parent = current_node;
 
           next.cost = next_node-&gt;gc + next_node-&gt;hc;
@@ -727,8 +763,7 @@ bool AstarSearch::search()
         }
       }
 
-    } // state update
-
+    }  // state update
   }
 
   // Failed to find path
@@ -736,10 +771,11 @@ bool AstarSearch::search()
   return false;
 }
 
-bool AstarSearch::makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry_msgs::Pose &amp;goal_pose, const nav_msgs::OccupancyGrid &amp;map, double upper_bound_distance)
+bool AstarSearch::makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry_msgs::Pose &amp;goal_pose,
+                           const nav_msgs::OccupancyGrid &amp;map, double upper_bound_distance)
 {
   start_pose_local_.pose = start_pose;
-  goal_pose_local_.pose  = goal_pose;
+  goal_pose_local_.pose = goal_pose;
   upper_bound_distance_ = upper_bound_distance;
 
   ROS_INFO("Prunning with upper bound %lf", upper_bound_distance_);
@@ -749,12 +785,14 @@ bool AstarSearch::makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry
   ros::WallTime end = ros::WallTime::now();
   std::cout &lt;&lt; "set map time: " &lt;&lt; (end - begin).toSec() * 1000 &lt;&lt; "[ms]" &lt;&lt; std::endl;
 
-  if (!setStartNode()) {
+  if (!setStartNode())
+  {
     ROS_WARN("Invalid start pose!");
     return false;
   }
 
-  if (!setGoalNode()) {
+  if (!setGoalNode())
+  {
     ROS_WARN("Invalid goal pose!");
     return false;
   }
@@ -768,10 +806,12 @@ bool AstarSearch::makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry
 }
 
 // Allow two goals (reach goal2 via goal1)
-bool AstarSearch::makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry_msgs::Pose &amp;transit_pose, const geometry_msgs::Pose &amp;goal_pose, const nav_msgs::OccupancyGrid &amp;map, double upper_bound_distance)
+bool AstarSearch::makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry_msgs::Pose &amp;transit_pose,
+                           const geometry_msgs::Pose &amp;goal_pose, const nav_msgs::OccupancyGrid &amp;map,
+                           double upper_bound_distance)
 {
   start_pose_local_.pose = start_pose;
-  goal_pose_local_.pose  = transit_pose;
+  goal_pose_local_.pose = transit_pose;
 
   auto start = std::chrono::system_clock::now();
   setMap(map);
@@ -779,12 +819,14 @@ bool AstarSearch::makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry
   auto usec = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count();
   std::cout &lt;&lt; "set map: " &lt;&lt; usec / 1000.0 &lt;&lt; std::endl;
 
-  if (!setStartNode()) {
+  if (!setStartNode())
+  {
     ROS_WARN("Invalid start pose!");
     return false;
   }
 
-  if (!setGoalNode()) {
+  if (!setGoalNode())
+  {
     ROS_WARN("Invalid goal pose!");
     return false;
   }
@@ -803,14 +845,16 @@ bool AstarSearch::makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry
   reset();
 
   start_pose_local_.pose = transit_pose;
-  goal_pose_local_.pose  = goal_pose;
+  goal_pose_local_.pose = goal_pose;
 
-  if (!setStartNode()) {
+  if (!setStartNode())
+  {
     ROS_WARN("Invalid start pose!");
     return false;
   }
 
-  if (!setGoalNode()) {
+  if (!setGoalNode())
+  {
     ROS_WARN("Invalid goal pose!");
     return false;
   }
@@ -828,16 +872,17 @@ bool AstarSearch::makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry
   return result;
 }
 
-
 void AstarSearch::broadcastPathTF()
 {
   tf::Transform transform;
 
   // Broadcast from start pose to goal pose
-  for (int i = path_.poses.size() - 1; i &gt;= 0; i--) {
+  for (int i = path_.poses.size() - 1; i &gt;= 0; i--)
+  {
     tf::Quaternion quat;
     tf::quaternionMsgToTF(path_.poses[i].pose.orientation, quat);
-    transform.setOrigin(tf::Vector3(path_.poses[i].pose.position.x, path_.poses[i].pose.position.y, path_.poses[i].pose.position.z));
+    transform.setOrigin(
+        tf::Vector3(path_.poses[i].pose.position.x, path_.poses[i].pose.position.y, path_.poses[i].pose.position.z));
     transform.setRotation(quat);
 
     tf_broadcaster_.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "/map", "/astar_path"));
@@ -845,7 +890,6 @@ void AstarSearch::broadcastPathTF()
     // sleep 0.1 [sec]
     usleep(100000);
   }
-
 }
 
-} // namespace astar_planner
+}  // namespace astar_planner
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_search.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_search.h" added_lines="29" deleted_lines="21">
				<diff>@@ -48,26 +48,34 @@
 
 namespace astar_planner
 {
-
 class AstarSearch
 {
- public:
+public:
   AstarSearch();
   ~AstarSearch();
 
-  bool makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry_msgs::Pose &amp;goal_pose, const nav_msgs::OccupancyGrid &amp;map, const double upper_bound_distance = -1);
-  bool makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry_msgs::Pose &amp;transit_pose, const geometry_msgs::Pose &amp;goal_pose, const nav_msgs::OccupancyGrid &amp;map, const double upper_bound_distance = -1);
+  bool makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry_msgs::Pose &amp;goal_pose,
+                const nav_msgs::OccupancyGrid &amp;map, const double upper_bound_distance = -1);
+  bool makePlan(const geometry_msgs::Pose &amp;start_pose, const geometry_msgs::Pose &amp;transit_pose,
+                const geometry_msgs::Pose &amp;goal_pose, const nav_msgs::OccupancyGrid &amp;map,
+                const double upper_bound_distance = -1);
   void reset();
-  //void initializeNode(int width, int height, int angle_size);
-  void initializeNode(const nav_msgs::OccupancyGrid&amp; map);
+  // void initializeNode(int width, int height, int angle_size);
+  void initializeNode(const nav_msgs::OccupancyGrid &amp;map);
   void broadcastPathTF();
-  bool getNodeInitialized() const {return node_initialized_;}
-  nav_msgs::Path getPath() const {return path_;}
-
- private:
+  bool getNodeInitialized() const
+  {
+    return node_initialized_;
+  }
+  nav_msgs::Path getPath() const
+  {
+    return path_;
+  }
+
+private:
   bool search();
-  //void createStateUpdateTable(int angle_size);
-  void createStateUpdateTableLocal(int angle_size); //
+  // void createStateUpdateTable(int angle_size);
+  void createStateUpdateTableLocal(int angle_size);  //
   void poseToIndex(const geometry_msgs::Pose &amp;pose, int *index_x, int *index_y, int *index_theta);
   bool isOutOfRange(int index_x, int index_y);
   void setPath(const SimpleNode &amp;goal);
@@ -88,11 +96,11 @@ class AstarSearch
   void displayFootprint(const nav_msgs::Path &amp;path);
 
   // ROS param
-  std::string map_frame_;        // publishing path frame
-  int angle_size_;                // descritized angle size
-  double minimum_turning_radius_; // varying by vehicles
-  int obstacle_threshold_;        // more than this value is regarded as obstacles
-  bool use_back_;                 // use backward driving
+  std::string map_frame_;          // publishing path frame
+  int angle_size_;                 // descritized angle size
+  double minimum_turning_radius_;  // varying by vehicles
+  int obstacle_threshold_;         // more than this value is regarded as obstacles
+  bool use_back_;                  // use backward driving
   double robot_length_;
   double robot_width_;
   double base2back_;
@@ -103,14 +111,14 @@ class AstarSearch
   bool use_wavefront_heuristic_;
   bool use_potential_heuristic_;
   bool use_2dnav_goal_;
-  double time_limit_; // msec
+  double time_limit_;  // msec
   double lateral_goal_range_;
   double longitudinal_goal_range_;
   double goal_angle_range_;
   bool publish_marker_;
 
   bool node_initialized_;
-  std::vector&lt;std::vector&lt;NodeUpdate&gt; &gt; state_update_table_;
+  std::vector&lt;std::vector&lt;NodeUpdate&gt;&gt; state_update_table_;
   nav_msgs::MapMetaData map_info_;
   std::vector&lt;std::vector&lt;std::vector&lt;AstarNode&gt;&gt;&gt; nodes_;
   std::priority_queue&lt;SimpleNode, std::vector&lt;SimpleNode&gt;, std::greater&lt;SimpleNode&gt;&gt; openlist_;
@@ -138,6 +146,6 @@ class AstarSearch
   nav_msgs::Path path_;
 };
 
-} // namespace astar_planner
+}  // namespace astar_planner
 
-#endif // ASTAR_NAVI_NODE_H
+#endif  // ASTAR_NAVI_NODE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_util.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_util.cpp" added_lines="3" deleted_lines="10">
				<diff>@@ -32,15 +32,11 @@
 
 namespace astar_planner
 {
-
 WaveFrontNode::WaveFrontNode()
 {
 }
 
-WaveFrontNode::WaveFrontNode(int x, int y, double cost)
-  : index_x(x)
-  , index_y(y)
-  , hc(cost)
+WaveFrontNode::WaveFrontNode(int x, int y, double cost) : index_x(x), index_y(y), hc(cost)
 {
 }
 
@@ -49,11 +45,8 @@ SimpleNode::SimpleNode()
 }
 
 SimpleNode::SimpleNode(int x, int y, int theta, double gc, double hc)
-  : index_x(x)
-  , index_y(y)
-  , index_theta(theta)
-  , cost(gc + hc)
+  : index_x(x), index_y(y), index_theta(theta), cost(gc + hc)
 {
 }
 
-} // namespace astar_planner
+}  // namespace astar_planner
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_util.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_util.h" added_lines="10" deleted_lines="11">
				<diff>@@ -35,7 +35,6 @@
 
 namespace astar_planner
 {
-
 enum class STATUS : uint8_t
 {
   NONE,
@@ -46,13 +45,13 @@ enum class STATUS : uint8_t
 
 struct AstarNode
 {
-  double x, y, theta;                   // Coordinate of each node
-  STATUS status        = STATUS::NONE;  // NONE, OPEN, CLOSED or OBS
-  double gc            = 0;             // Actual cost
-  double hc            = 0;             // heuristic cost
-  double move_distance = 0;             // actual move distance
-  bool back;                            // true if the current direction of the vehicle is back
-  AstarNode *parent    = NULL;          // parent node
+  double x, y, theta;            // Coordinate of each node
+  STATUS status = STATUS::NONE;  // NONE, OPEN, CLOSED or OBS
+  double gc = 0;                 // Actual cost
+  double hc = 0;                 // heuristic cost
+  double move_distance = 0;      // actual move distance
+  bool back;                     // true if the current direction of the vehicle is back
+  AstarNode *parent = NULL;      // parent node
 };
 
 struct WaveFrontNode
@@ -84,7 +83,8 @@ struct SimpleNode
   int index_theta;
   double cost;
 
-  bool operator&gt;(const SimpleNode&amp; right) const {
+  bool operator&gt;(const SimpleNode &amp;right) const
+  {
     return cost &gt; right.cost;
   }
 
@@ -92,7 +92,6 @@ struct SimpleNode
   SimpleNode(int x, int y, int theta, double gc, double hc);
 };
 
-
 inline double calcDistance(double x1, double y1, double x2, double y2)
 {
   return std::hypot(x2 - x1, y2 - y1);
@@ -163,6 +162,6 @@ inline geometry_msgs::Pose xytToPoseMsg(double x, double y, double theta)
   return p;
 }
 
-} // namespace astar_planner
+}  // namespace astar_planner
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_avoid.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_avoid.cpp" added_lines="41" deleted_lines="26">
				<diff>@@ -35,16 +35,17 @@
 
 namespace
 {
-
-waypoint_follower_msgs::lane createPublishWaypoints(const waypoint_follower_msgs::lane&amp; ref_lane, int closest_waypoint, int size)
+waypoint_follower_msgs::lane createPublishWaypoints(const waypoint_follower_msgs::lane&amp; ref_lane, int closest_waypoint,
+                                                    int size)
 {
   waypoint_follower_msgs::lane follow_lane;
 
-  follow_lane.header    = ref_lane.header;
+  follow_lane.header = ref_lane.header;
   follow_lane.increment = ref_lane.increment;
 
   // Push "size" waypoints from closest
-  for (int i = 0; i &lt; size; i++) {
+  for (int i = 0; i &lt; size; i++)
+  {
     if (closest_waypoint + i &gt;= static_cast&lt;int&gt;(ref_lane.waypoints.size()))
       break;
 
@@ -54,7 +55,8 @@ waypoint_follower_msgs::lane createPublishWaypoints(const waypoint_follower_msgs
   return follow_lane;
 }
 
-void createAvoidWaypoints(const nav_msgs::Path&amp; astar_path, const astar_planner::SearchInfo&amp; search_info, int size, waypoint_follower_msgs::lane* avoid_lane, int* end_of_avoid_index)
+void createAvoidWaypoints(const nav_msgs::Path&amp; astar_path, const astar_planner::SearchInfo&amp; search_info, int size,
+                          waypoint_follower_msgs::lane* avoid_lane, int* end_of_avoid_index)
 {
   int closest_waypoint_index = search_info.getClosestWaypointIndex();
 
@@ -62,7 +64,7 @@ void createAvoidWaypoints(const nav_msgs::Path&amp; astar_path, const astar_planner:
 
   // Get global lane
   const waypoint_follower_msgs::lane&amp; current_lane = search_info.getCurrentWaypoints();
-  avoid_lane-&gt;header    = current_lane.header;
+  avoid_lane-&gt;header = current_lane.header;
   avoid_lane-&gt;increment = current_lane.increment;
 
   // Set waypoints from closest to beginning of avoiding
@@ -77,7 +79,8 @@ void createAvoidWaypoints(const nav_msgs::Path&amp; astar_path, const astar_planner:
     avoid_velocity = search_info.getAvoidVelocityLimitMPS();
 
   // Set waypoints for avoiding
-  for (const auto&amp; pose : astar_path.poses) {
+  for (const auto&amp; pose : astar_path.poses)
+  {
     waypoint_follower_msgs::waypoint wp;
     wp.pose = pose;
     wp.twist.twist.linear.x = avoid_velocity;
@@ -89,18 +92,18 @@ void createAvoidWaypoints(const nav_msgs::Path&amp; astar_path, const astar_planner:
   *end_of_avoid_index = avoid_lane-&gt;waypoints.size();
 
   // Set waypoints from the end of avoiding
-  for (int i = search_info.getGoalWaypointIndex() + 1; i &lt; search_info.getGoalWaypointIndex() + size; i++) {
+  for (int i = search_info.getGoalWaypointIndex() + 1; i &lt; search_info.getGoalWaypointIndex() + size; i++)
+  {
     if (i &gt;= static_cast&lt;int&gt;(current_lane.waypoints.size()))
       break;
 
     avoid_lane-&gt;waypoints.push_back(current_lane.waypoints.at(i));
   }
-
 }
 
-} // namespace
+}  // namespace
 
-int main(int argc, char **argv)
+int main(int argc, char** argv)
 {
   ros::init(argc, argv, "obstacle_avoid");
   ros::NodeHandle n;
@@ -109,19 +112,26 @@ int main(int argc, char **argv)
   astar_planner::SearchInfo search_info;
 
   // ROS subscribers
-  ros::Subscriber map_sub               = n.subscribe("grid_map_visualization/distance_transform", 1, &amp;astar_planner::SearchInfo::mapCallback, &amp;search_info);
-  ros::Subscriber start_sub             = n.subscribe("current_pose", 1, &amp;astar_planner::SearchInfo::currentPoseCallback, &amp;search_info);
-  ros::Subscriber waypoints_sub         = n.subscribe("base_waypoints", 1, &amp;astar_planner::SearchInfo::waypointsCallback, &amp;search_info);
-  ros::Subscriber obstacle_waypoint_sub = n.subscribe("obstacle_waypoint", 1, &amp;astar_planner::SearchInfo::obstacleWaypointCallback, &amp;search_info);
-  ros::Subscriber closest_waypoint_sub  = n.subscribe("closest_waypoint", 1, &amp;astar_planner::SearchInfo::closestWaypointCallback, &amp;search_info);
+  ros::Subscriber map_sub = n.subscribe("grid_map_visualization/distance_transform", 1,
+                                        &amp;astar_planner::SearchInfo::mapCallback, &amp;search_info);
+  ros::Subscriber start_sub =
+      n.subscribe("current_pose", 1, &amp;astar_planner::SearchInfo::currentPoseCallback, &amp;search_info);
+  ros::Subscriber waypoints_sub =
+      n.subscribe("base_waypoints", 1, &amp;astar_planner::SearchInfo::waypointsCallback, &amp;search_info);
+  ros::Subscriber obstacle_waypoint_sub =
+      n.subscribe("obstacle_waypoint", 1, &amp;astar_planner::SearchInfo::obstacleWaypointCallback, &amp;search_info);
+  ros::Subscriber closest_waypoint_sub =
+      n.subscribe("closest_waypoint", 1, &amp;astar_planner::SearchInfo::closestWaypointCallback, &amp;search_info);
   // TODO: optional
-  //ros::Subscriber goal_sub = n.subscribe("/move_base_simple/goal", 1, &amp;astar_planner::SearchInfo::goalCallback, &amp;search_info);
-  ros::Subscriber current_velocity_sub  = n.subscribe("current_velocity", 1, &amp;astar_planner::SearchInfo::currentVelocityCallback, &amp;search_info);
-  ros::Subscriber state_sub  = n.subscribe("state", 1, &amp;astar_planner::SearchInfo::stateCallback, &amp;search_info);
+  // ros::Subscriber goal_sub = n.subscribe("/move_base_simple/goal", 1, &amp;astar_planner::SearchInfo::goalCallback,
+  // &amp;search_info);
+  ros::Subscriber current_velocity_sub =
+      n.subscribe("current_velocity", 1, &amp;astar_planner::SearchInfo::currentVelocityCallback, &amp;search_info);
+  ros::Subscriber state_sub = n.subscribe("state", 1, &amp;astar_planner::SearchInfo::stateCallback, &amp;search_info);
 
   // ROS publishers
   ros::Publisher path_pub = n.advertise&lt;nav_msgs::Path&gt;("astar_path", 1, true);
-  ros::Publisher waypoints_pub  = n.advertise&lt;waypoint_follower_msgs::lane&gt;("safety_waypoints", 1, true);
+  ros::Publisher waypoints_pub = n.advertise&lt;waypoint_follower_msgs::lane&gt;("safety_waypoints", 1, true);
 
   ros::Rate loop_rate(10);
 
@@ -129,7 +139,8 @@ int main(int argc, char **argv)
   waypoint_follower_msgs::lane avoid_lane;
   int end_of_avoid_index = -1;
   bool avoidance = false;
-  while (ros::ok()) {
+  while (ros::ok())
+  {
     ros::spinOnce();
 
     int closest_waypoint;
@@ -180,7 +191,8 @@ int main(int argc, char **argv)
       astar.initializeNode(search_info.getMap());
 
     // Waiting for the call for avoidance ...
-    if (!search_info.getMapSet() || !search_info.getStartSet() || !search_info.getGoalSet()) {
+    if (!search_info.getMapSet() || !search_info.getStartSet() || !search_info.getGoalSet())
+    {
       search_info.reset();
       loop_rate.sleep();
       continue;
@@ -189,7 +201,8 @@ int main(int argc, char **argv)
     // Run astar search
     ros::WallTime timer_begin = ros::WallTime::now();
 
-    bool result = astar.makePlan(search_info.getStartPose().pose, search_info.getGoalPose().pose, search_info.getMap(), search_info.getUpperBoundDistance());
+    bool result = astar.makePlan(search_info.getStartPose().pose, search_info.getGoalPose().pose, search_info.getMap(),
+                                 search_info.getUpperBoundDistance());
 
     ros::WallTime timer_end = ros::WallTime::now();
     double time_ms = (timer_end - timer_begin).toSec() * 1000;
@@ -205,7 +218,8 @@ int main(int argc, char **argv)
       std::cout &lt;&lt; "average time so far: " &lt;&lt; msec_sum / plan_count &lt;&lt; std::endl;
     }
 
-    if (result) {
+    if (result)
+    {
       std::cout &lt;&lt; "Found goal!" &lt;&lt; std::endl;
       path_pub.publish(astar.getPath());
 
@@ -213,8 +227,9 @@ int main(int argc, char **argv)
 
       if (search_info.getChangePath())
         avoidance = true;
-
-    } else {
+    }
+    else
+    {
       std::cout &lt;&lt; "can't find goal..." &lt;&lt; std::endl;
     }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" added_lines="20" deleted_lines="19">
				<diff>@@ -32,7 +32,6 @@
 
 namespace astar_planner
 {
-
 SearchInfo::SearchInfo()
   : map_set_(false)
   , start_set_(false)
@@ -59,14 +58,16 @@ SearchInfo::~SearchInfo()
 {
 }
 
-double SearchInfo::calcPathLength(const waypoint_follower_msgs::lane&amp; lane, const int start_waypoint_index, const int goal_waypoint_index) const
+double SearchInfo::calcPathLength(const waypoint_follower_msgs::lane &amp;lane, const int start_waypoint_index,
+                                  const int goal_waypoint_index) const
 {
   if (lane.waypoints.size() &lt;= 1)
     return 0;
 
   // calulate the length of the path
   double dist_sum = 0;
-  for (int i = start_waypoint_index; i &lt; goal_waypoint_index; i++) {
+  for (int i = start_waypoint_index; i &lt; goal_waypoint_index; i++)
+  {
     geometry_msgs::Pose p1 = lane.waypoints[i].pose.pose;
     geometry_msgs::Pose p2 = lane.waypoints[i + 1].pose.pose;
 
@@ -124,8 +125,8 @@ void SearchInfo::goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 
   ROS_INFO("Subcscribed goal pose!");
 
-  std::string map_frame  = map_frame_;
-  std::string goal_frame  = msg-&gt;header.frame_id;
+  std::string map_frame = map_frame_;
+  std::string goal_frame = msg-&gt;header.frame_id;
 
   // Get transform of map to the frame of goal pose
   tf::StampedTransform map2world;
@@ -141,9 +142,9 @@ void SearchInfo::goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 
   // Set goal pose
   geometry_msgs::Pose pose_msg = msg-&gt;pose;
-  goal_pose_global_.pose   = astar_planner::transformPose(pose_msg, map2world);
+  goal_pose_global_.pose = astar_planner::transformPose(pose_msg, map2world);
   goal_pose_global_.header = msg-&gt;header;
-  goal_pose_local_.pose    = astar_planner::transformPose(goal_pose_global_.pose, ogm2map_);
+  goal_pose_local_.pose = astar_planner::transformPose(goal_pose_global_.pose, ogm2map_);
   goal_pose_local_.header = goal_pose_global_.header;
 
   goal_set_ = true;
@@ -162,10 +163,10 @@ void SearchInfo::goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
   }
 
   // Set start pose
-  start_pose_global_.pose   = astar_planner::transformPose(current_pose_.pose, map2start_frame);
+  start_pose_global_.pose = astar_planner::transformPose(current_pose_.pose, map2start_frame);
   start_pose_global_.header = current_pose_.header;
-  start_pose_local_.pose    = astar_planner::transformPose(start_pose_global_.pose, ogm2map_);
-  start_pose_local_.header  = start_pose_global_.header;
+  start_pose_local_.pose = astar_planner::transformPose(start_pose_global_.pose, ogm2map_);
+  start_pose_local_.header = start_pose_global_.header;
 
   start_set_ = true;
 }
@@ -187,7 +188,6 @@ void SearchInfo::closestWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
   closest_waypoint_index_ = msg-&gt;data;
 }
 
-
 void SearchInfo::obstacleWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
 {
   // not always avoid AND current state is not avoidance
@@ -196,9 +196,10 @@ void SearchInfo::obstacleWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
     ROS_WARN("current state is not OBSTACLE_AVOIDANCE");
     return;
   }
-  
+
   // there are no obstacles
-  if (msg-&gt;data &lt; 0 || closest_waypoint_index_ &lt; 0 || current_waypoints_.waypoints.empty()) {
+  if (msg-&gt;data &lt; 0 || closest_waypoint_index_ &lt; 0 || current_waypoints_.waypoints.empty())
+  {
     return;
   }
 
@@ -211,7 +212,8 @@ void SearchInfo::obstacleWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
   static int prev_obstacle_waypoint_index = -1;
   static int obstacle_count = 0;
   int same_obstacle_threshold = 2;
-  if (obstacle_waypoint_index_  &gt;= prev_obstacle_waypoint_index - same_obstacle_threshold &amp;&amp; obstacle_waypoint_index_ &lt;= prev_obstacle_waypoint_index + same_obstacle_threshold)
+  if (obstacle_waypoint_index_ &gt;= prev_obstacle_waypoint_index - same_obstacle_threshold &amp;&amp;
+      obstacle_waypoint_index_ &lt;= prev_obstacle_waypoint_index + same_obstacle_threshold)
   {
     obstacle_count++;
   }
@@ -231,7 +233,7 @@ void SearchInfo::obstacleWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
 
   // Decide start and goal waypoints for planning
   start_waypoint_index_ = obstacle_waypoint_index_ - avoid_distance_;
-  goal_waypoint_index_  = obstacle_waypoint_index_ + avoid_distance_;
+  goal_waypoint_index_ = obstacle_waypoint_index_ + avoid_distance_;
 
   // Handle out of range
   if (start_waypoint_index_ &lt; 0)
@@ -265,7 +267,7 @@ void SearchInfo::obstacleWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
 
   // Set transit pose
   // TODO:
-  double actual_car_width = 2.5; // [m]
+  double actual_car_width = 2.5;  // [m]
   geometry_msgs::Pose relative_transit_pose;
   // TODO: always right avoidance ???
   relative_transit_pose.position.y -= actual_car_width;
@@ -290,10 +292,9 @@ void SearchInfo::stateCallback(const std_msgs::StringConstPtr &amp;msg)
 
 void SearchInfo::reset()
 {
-  map_set_   = false;
+  map_set_ = false;
   start_set_ = false;
-  goal_set_  = false;
+  goal_set_ = false;
   obstacle_waypoint_index_ = -1;
 }
-
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" added_lines="92" deleted_lines="29">
				<diff>@@ -43,7 +43,6 @@
 
 namespace astar_planner
 {
-
 class SearchInfo
 {
 public:
@@ -52,7 +51,7 @@ public:
 
   // ROS Callback
   void mapCallback(const nav_msgs::OccupancyGridConstPtr &amp;msg);
-  //void startCallback(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;msg);
+  // void startCallback(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;msg);
   void goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void currentPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void currentVelocityCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg);
@@ -62,35 +61,99 @@ public:
   void stateCallback(const std_msgs::StringConstPtr &amp;msg);
 
   // get method
-  bool getMapSet() const {return map_set_;}
-  bool getStartSet() const {return start_set_;}
-  bool getGoalSet() const {return goal_set_;}
-  bool getPathSet() const {return path_set_;}
-  nav_msgs::OccupancyGrid getMap() const {return map_;}
-  geometry_msgs::PoseStamped getStartPose() const {return start_pose_local_;}
-  geometry_msgs::PoseStamped getGoalPose() const {return goal_pose_local_;}
-  geometry_msgs::PoseStamped getTransitPose() const {return transit_pose_local_;}
-  geometry_msgs::PoseStamped getCurrentPose() const {return current_pose_;}
-  double getCurrentVelocity() const {return current_velocity_mps_;}
-  waypoint_follower_msgs::lane getSubscribedWaypoints() const {return subscribed_waypoints_;}
-  waypoint_follower_msgs::lane getCurrentWaypoints() const {return current_waypoints_;}
-  int getObstacleWaypointIndex() const {return obstacle_waypoint_index_;}
-  int getClosestWaypointIndex() const {return closest_waypoint_index_;}
-  int getStartWaypointIndex() const {return start_waypoint_index_;}
-  int getGoalWaypointIndex() const {return goal_waypoint_index_;}
-  double getUpperBoundDistance() const {return upper_bound_distance_;}
-  double getAvoidVelocityLimitMPS() const {return avoid_velocity_limit_mps_;}
-  bool getAvoidance() const {return avoidance_;}
-  bool getChangePath() const {return change_path_;}
+  bool getMapSet() const
+  {
+    return map_set_;
+  }
+  bool getStartSet() const
+  {
+    return start_set_;
+  }
+  bool getGoalSet() const
+  {
+    return goal_set_;
+  }
+  bool getPathSet() const
+  {
+    return path_set_;
+  }
+  nav_msgs::OccupancyGrid getMap() const
+  {
+    return map_;
+  }
+  geometry_msgs::PoseStamped getStartPose() const
+  {
+    return start_pose_local_;
+  }
+  geometry_msgs::PoseStamped getGoalPose() const
+  {
+    return goal_pose_local_;
+  }
+  geometry_msgs::PoseStamped getTransitPose() const
+  {
+    return transit_pose_local_;
+  }
+  geometry_msgs::PoseStamped getCurrentPose() const
+  {
+    return current_pose_;
+  }
+  double getCurrentVelocity() const
+  {
+    return current_velocity_mps_;
+  }
+  waypoint_follower_msgs::lane getSubscribedWaypoints() const
+  {
+    return subscribed_waypoints_;
+  }
+  waypoint_follower_msgs::lane getCurrentWaypoints() const
+  {
+    return current_waypoints_;
+  }
+  int getObstacleWaypointIndex() const
+  {
+    return obstacle_waypoint_index_;
+  }
+  int getClosestWaypointIndex() const
+  {
+    return closest_waypoint_index_;
+  }
+  int getStartWaypointIndex() const
+  {
+    return start_waypoint_index_;
+  }
+  int getGoalWaypointIndex() const
+  {
+    return goal_waypoint_index_;
+  }
+  double getUpperBoundDistance() const
+  {
+    return upper_bound_distance_;
+  }
+  double getAvoidVelocityLimitMPS() const
+  {
+    return avoid_velocity_limit_mps_;
+  }
+  bool getAvoidance() const
+  {
+    return avoidance_;
+  }
+  bool getChangePath() const
+  {
+    return change_path_;
+  }
 
   // set method
-  void setCurrentWaypoints(const waypoint_follower_msgs::lane&amp; waypoints) {current_waypoints_ = waypoints;}
+  void setCurrentWaypoints(const waypoint_follower_msgs::lane &amp;waypoints)
+  {
+    current_waypoints_ = waypoints;
+  }
 
   // Reset flag
   void reset();
 
 private:
-  double calcPathLength(const waypoint_follower_msgs::lane&amp; lane, const int start_waypoint_index, const int goal_waypoint_index) const;
+  double calcPathLength(const waypoint_follower_msgs::lane &amp;lane, const int start_waypoint_index,
+                        const int goal_waypoint_index) const;
 
   nav_msgs::OccupancyGrid map_;
   geometry_msgs::PoseStamped start_pose_global_;
@@ -111,9 +174,9 @@ private:
 
   // ROS param
   std::string map_frame_;
-  int obstacle_detect_count_; // 1 increment means 100ms
-  int avoid_distance_; // the number of waypoint
-  double avoid_velocity_limit_mps_; // m/s
+  int obstacle_detect_count_;        // 1 increment means 100ms
+  int avoid_distance_;               // the number of waypoint
+  double avoid_velocity_limit_mps_;  // m/s
   double upper_bound_ratio_;
   bool avoidance_;
   bool change_path_;
@@ -133,6 +196,6 @@ private:
   double upper_bound_distance_;
 };
 
-} // namespace astar_planner
+}  // namespace astar_planner
 
-#endif // SEARCH_INFO_ROS_H
+#endif  // SEARCH_INFO_ROS_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f51ad58499d70f7e8e26f9f758aba8d926df3ffc" author="Yusuke FUJII">
		<msg>fix build issues due to autoware_msgs</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\darknet\yolo2.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\darknet\yolo2.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -2,7 +2,6 @@
 
 #include &lt;image_transport/image_transport.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;cv_tracker_msgs/image_obj.h&gt;
 
 #include &lt;cstdint&gt;
 #include &lt;cstdlib&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,11 +1,12 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;image_transport/image_transport.h&gt;
-#include &lt;autoware_msgs/ConfigSsd.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 
+#include &lt;autoware_msgs/ConfigSsd.h&gt;
 #include &lt;autoware_msgs/image_obj.h&gt;
 
+#include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;opencv2/opencv.hpp&gt;
 
 #if (CV_MAJOR_VERSION != 3)
@@ -13,7 +14,6 @@
 #endif
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 
-#include &lt;cv_bridge/cv_bridge.h&gt;
 
 #include &lt;string&gt;
 #include &lt;vector&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -300,7 +300,7 @@ void keepLanePoints(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 std::vector&lt;ClusterPtr&gt; clusterAndColorGpu(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 											pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
 											jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
-											lidar_tracker::centroids&amp; in_out_centroids,
+											autoware_msgs::centroids&amp; in_out_centroids,
 											double in_max_cluster_distance=0.5)
 {
 	std::vector&lt;ClusterPtr&gt; clusters;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\include\Context.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\include\Context.h" added_lines="2" deleted_lines="2">
				<diff>@@ -3,7 +3,7 @@
 
 #include &lt;vector&gt;
 #include &lt;opencv2/core/core.hpp&gt;
-#include "road_wizard/Signals.h"
+#include &lt;autoware_msgs/Signals.h&gt;
 
 enum LightState { GREEN, YELLOW, RED, UNDEFINED };
 
@@ -13,7 +13,7 @@ public:
 	Context(cv::Point aRedCenter, cv::Point aYellowCenter, cv::Point aGreenCenter,
 		int aLampRadius, cv::Point aTopLeft, cv::Point aBotRight);
         static void SetContexts(std::vector&lt;Context&gt; &amp;contexts, 
-                                const road_wizard::Signals::ConstPtr &amp;extracted_pos,
+                                const autoware_msgs::Signals::ConstPtr &amp;extracted_pos,
                                 const int frame_row,
                                 const int frame_colmuns);
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\lib\Context.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\lib\Context.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -23,15 +23,15 @@ bool Context::CompareContext(const Context left, const Context right)
 
 
 void Context::SetContexts(std::vector&lt;Context&gt; &amp;contexts,
-                          const road_wizard::Signals::ConstPtr &amp;extracted_pos,
+                          const autoware_msgs::Signals::ConstPtr &amp;extracted_pos,
                           const int frame_row,
                           const int frame_column) {
   /* copy parts of data to local variable */
-  std::vector&lt;road_wizard::ExtractedPosition&gt; signals;
-  std::vector&lt;road_wizard::ExtractedPosition&gt;::iterator sig_iterator;
+  std::vector&lt;autoware_msgs::ExtractedPosition&gt; signals;
+  std::vector&lt;autoware_msgs::ExtractedPosition&gt;::iterator sig_iterator;
   for (unsigned int i=0; i&lt;extracted_pos-&gt;Signals.size(); i++ )
     {
-      road_wizard::ExtractedPosition tmp;
+      autoware_msgs::ExtractedPosition tmp;
       tmp.signalId = extracted_pos-&gt;Signals.at(i).signalId;
       tmp.u        = extracted_pos-&gt;Signals.at(i).u;
       tmp.v        = extracted_pos-&gt;Signals.at(i).v;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" added_lines="10" deleted_lines="10">
				<diff>@@ -20,11 +20,11 @@
 #include &lt;cstdio&gt;
 #include "Math.h"
 #include &lt;Eigen/Eigen&gt;
-#include "road_wizard/Signals.h"
-#include &lt;runtime_manager/adjust_xy.h&gt;
+#include &lt;autoware_msgs/Signals.h&gt;
+#include &lt;autoware_msgs/adjust_xy.h&gt;
 #include &lt;vector_map/vector_map.h&gt;
 #include &lt;vector_map_server/GetSignal.h&gt;
-#include &lt;waypoint_follower_msgs/lane.h&gt;
+#include &lt;autoware_msgs/lane.h&gt;
 
 static std::string camera_id_str;
 
@@ -64,7 +64,7 @@ namespace
   {
   private:
     geometry_msgs::PoseStamped pose_;
-    waypoint_follower_msgs::lane waypoints_;
+    autoware_msgs::lane waypoints_;
 
   public:
     VectorMapClient()
@@ -78,7 +78,7 @@ namespace
       return pose_;
     }
 
-    waypoint_follower_msgs::lane waypoints() const
+    autoware_msgs::lane waypoints() const
     {
       return waypoints_;
     }
@@ -88,7 +88,7 @@ namespace
       pose_ = pose;
     }
 
-    void set_waypoints(const waypoint_follower_msgs::lane&amp; waypoints)
+    void set_waypoints(const autoware_msgs::lane&amp; waypoints)
     {
       waypoints_ = waypoints;
     }
@@ -98,7 +98,7 @@ static VectorMapClient g_vector_map_client;
 
 
 /* Callback function to shift projection result */
-void adjust_xyCallback (const runtime_manager::adjust_xy::ConstPtr&amp; config_msg)
+void adjust_xyCallback (const autoware_msgs::adjust_xy::ConstPtr&amp; config_msg)
 {
   adjust_proj_x = config_msg-&gt;x;
   adjust_proj_y = config_msg-&gt;y;
@@ -260,7 +260,7 @@ double GetSignalAngleInCameraSystem(double hang, double vang)
 void echoSignals2 (ros::Publisher &amp;pub, bool useOpenGLCoord=false)
 {
   int countPoint = 0;
-  road_wizard::Signals signalsInFrame;
+  autoware_msgs::Signals signalsInFrame;
 
   /* Get signals on the path if vecter_map_server is enabled */
   if (g_use_vector_map_server) {
@@ -308,7 +308,7 @@ void echoSignals2 (ros::Publisher &amp;pub, bool useOpenGLCoord=false)
       project2 (signalcenterx, ux, vx, useOpenGLCoord);
       radius = (int)distance (ux, vx, u, v);
 
-      road_wizard::ExtractedPosition sign;
+      autoware_msgs::ExtractedPosition sign;
       sign.signalId = signal.id;
 
       sign.u = u + adjust_proj_x; // shift project position by configuration value from runtime manager
@@ -420,7 +420,7 @@ int main (int argc, char *argv[])
     g_ros_client = rosnode.serviceClient&lt;vector_map_server::GetSignal&gt;("vector_map_server/get_signal");
   }
 
-  ros::Publisher  signalPublisher      = rosnode.advertise &lt;road_wizard::Signals&gt; ("roi_signal", 100);
+  ros::Publisher  signalPublisher      = rosnode.advertise &lt;autoware_msgs::Signals&gt; ("roi_signal", 100);
   signal (SIGINT, interrupt);
 
   Rate loop (25);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLight.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLight.h" added_lines="2" deleted_lines="2">
				<diff>@@ -8,13 +8,13 @@
 #include "TrafficLightDetector.h"
 
 /* Extra includes */
-#include "road_wizard/Signals.h"
+#include "autoware_msgs/Signals.h"
 
 #define MAIN_WINDOW_NAME "Main"
 #define SETTINGS_WINDOW_NAME "Settings"
 
 /* Functions declarations */
-void setContexts(TrafficLightDetector &amp;detector, const road_wizard::Signals::ConstPtr&amp; extractedPos);
+void setContexts(TrafficLightDetector &amp;detector, const autoware_msgs::Signals::ConstPtr&amp; extractedPos);
 
 #define MINIMAM_RADIUS 3
 #define ROI_MARGINE 20
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -7,10 +7,10 @@
 #include &lt;float.h&gt;
 #include &lt;math.h&gt;
 #include &lt;sstream&gt;
-#include &lt;runtime_manager/traffic_light.h&gt;
 #include &lt;std_msgs/String.h&gt;
-#include "road_wizard/Signals.h"
-#include "road_wizard/TunedResult.h"
+#include &lt;autoware_msgs/traffic_light.h&gt;
+#include &lt;autoware_msgs/Signals.h&gt;
+#include &lt;autoware_msgs/TunedResult.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
@@ -170,7 +170,7 @@ static void image_raw_cb(const sensor_msgs::Image&amp; image_source)
 } /* static void image_raw_cb() */
 
 
-static void extractedPos_cb(const road_wizard::Signals::ConstPtr&amp; extractedPos)
+static void extractedPos_cb(const autoware_msgs::Signals::ConstPtr&amp; extractedPos)
 {
   if (frame.empty())
     return;
@@ -181,7 +181,7 @@ static void extractedPos_cb(const road_wizard::Signals::ConstPtr&amp; extractedPos)
   detector.brightnessDetect(frame);
 
   /* publish result */
-  runtime_manager::traffic_light state_msg;
+  autoware_msgs::traffic_light state_msg;
   std_msgs::String state_string_msg;
   const int32_t TRAFFIC_LIGHT_RED     = 0;
   const int32_t TRAFFIC_LIGHT_GREEN   = 1;
@@ -339,7 +339,7 @@ static void extractedPos_cb(const road_wizard::Signals::ConstPtr&amp; extractedPos)
 } /* static void extractedPos_cb() */
 
 
-static void tunedResult_cb(const road_wizard::TunedResult&amp; msg)
+static void tunedResult_cb(const autoware_msgs::TunedResult&amp; msg)
 {
   thSet.Red.Hue.upper = cvtInt2Double_hue(msg.Red.Hue.center, msg.Red.Hue.range);
   thSet.Red.Hue.lower = cvtInt2Double_hue(msg.Red.Hue.center, -msg.Red.Hue.range);
@@ -427,7 +427,7 @@ int main(int argc, char* argv[]) {
   ros::Subscriber tunedResult_sub = n.subscribe("/tuned_result", 1, tunedResult_cb);
   ros::Subscriber superimpose_sub = n.subscribe("/config/superimpose", 1, superimpose_cb);
 
-  signalState_pub       = n.advertise&lt;runtime_manager::traffic_light&gt;("/light_color", ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
+  signalState_pub       = n.advertise&lt;autoware_msgs::traffic_light&gt;("/light_color", ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
   signalStateString_pub = n.advertise&lt;std_msgs::String&gt;("/sound_player", ADVERTISE_QUEUE_SIZE);
   marker_pub            = n.advertise&lt;visualization_msgs::MarkerArray&gt;("tlr_result", ADVERTISE_QUEUE_SIZE);
   superimpose_image_pub= n.advertise&lt;sensor_msgs::Image&gt;("tlr_superimpose_image", ADVERTISE_QUEUE_SIZE);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -2,7 +2,7 @@
 
 #include &lt;string&gt;
 
-#include &lt;runtime_manager/traffic_light.h&gt;
+#include &lt;autoware_msgs/traffic_light.h&gt;
 #include &lt;std_msgs/String.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
@@ -70,7 +70,7 @@ void RegionTlrSsdRosNode::ImageRawCallback(const sensor_msgs::Image &amp;image) {
 // ==========================================
 // Callback function to acquire extracted_pos
 // ==========================================
-void RegionTlrSsdRosNode::RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos) {
+void RegionTlrSsdRosNode::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos) {
   static ros::Time previous_timestamp;
   // If frame has not been prepared, abort this callback
   if (frame_.empty() ||
@@ -154,7 +154,7 @@ void RegionTlrSsdRosNode::StartSubscribersAndPublishers() {
                                                 this);
 
   // Register publishers
-  signal_state_publisher        = node_handle.advertise&lt;runtime_manager::traffic_light&gt;("light_color", 1);
+  signal_state_publisher        = node_handle.advertise&lt;autoware_msgs::traffic_light&gt;("light_color", 1);
   signal_state_string_publisher = node_handle.advertise&lt;std_msgs::String&gt;("/sound_player", 1);
   marker_publisher              = node_handle.advertise&lt;visualization_msgs::MarkerArray&gt;("tlr_result", 1, kAdvertiseInLatch_);
   superimpose_image_publisher   = node_handle.advertise&lt;sensor_msgs::Image&gt;("tlr_superimpose_image", 1);
@@ -186,10 +186,10 @@ LightState RegionTlrSsdRosNode::DetermineState(LightState previous_state,
 
 
 // =================================================================
-// Publish recognition result as runtime_manager::traffic_light type
+// Publish recognition result as autoware_msgs::traffic_light type
 // =================================================================
 void RegionTlrSsdRosNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts) {
-  runtime_manager::traffic_light topic;
+  autoware_msgs::traffic_light topic;
   static int32_t previous_state = kTrafficLightUnknown;
   topic.traffic_light = kTrafficLightUnknown;
   for (const auto ctx: contexts) {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.h" added_lines="2" deleted_lines="2">
				<diff>@@ -10,7 +10,7 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 
 #include "Context.h"
-#include "road_wizard/Signals.h"
+#include "autoware_msgs/Signals.h"
 #include "traffic_light_recognizer.h"
 
 class RegionTlrSsdRosNode {
@@ -20,7 +20,7 @@ class RegionTlrSsdRosNode {
 
   void RunRecognition();
   void ImageRawCallback(const sensor_msgs::Image &amp;image);
-  void RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos);
+  void RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos);
 
   // The vector of data structure to save traffic light state, position, ...etc
   std::vector&lt;Context&gt; contexts_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\roi_extractor\roi_extractor.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\roi_extractor\roi_extractor.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -14,7 +14,7 @@
 
 
 #include "Context.h"
-#include "road_wizard/Signals.h"
+#include &lt;autoware_msgs/Signals.h&gt;
 
 
 void RoiExtractor::ImageRawCallback(const sensor_msgs::Image &amp;image) {
@@ -27,7 +27,7 @@ void RoiExtractor::ImageRawCallback(const sensor_msgs::Image &amp;image) {
 } // void RoiExtractor::ImageRawCallback()
 
 
-void RoiExtractor::RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos) {
+void RoiExtractor::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos) {
   // If frame image has not been updated, do nothing
   if (frame_timestamp_ == previous_timestamp_) {
     return;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\roi_extractor\roi_extractor.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\roi_extractor\roi_extractor.h" added_lines="2" deleted_lines="2">
				<diff>@@ -10,7 +10,7 @@
 #include &lt;opencv2/opencv.hpp&gt;
 
 #include "Context.h"
-#include "road_wizard/Signals.h"
+#include "autoware_msgs/Signals.h"
 
 class RoiExtractor {
  public:
@@ -24,7 +24,7 @@ class RoiExtractor {
 
   // Callback functions to obtain images and signal position
   void ImageRawCallback(const sensor_msgs::Image &amp;image);
-  void RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos);
+  void RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos);
   
   // Utility function to create directory which roi images will be saved
   void CreateTargetDirectory(std::string base_name);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\tunerBody.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\tunerBody.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -1,5 +1,5 @@
 #include "tunerBody.h"
-#include "road_wizard/TunedResult.h"
+#include "autoware_msgs/TunedResult.h"
 
 
 #include &lt;opencv2/core/version.hpp&gt;
@@ -152,7 +152,7 @@ void TunerBody::launch(void)
 
   ros::Subscriber image_sub = n.subscribe(image_topic_name, 1, image_raw_callBack);
 
-  ros::Publisher tunedResult_pub = n.advertise &lt;road_wizard::TunedResult&gt; ("tuned_result", ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
+  ros::Publisher tunedResult_pub = n.advertise &lt;autoware_msgs::TunedResult&gt; ("tuned_result", ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
 
   /* valiables to check status change */
   cv::Point prev_clicked = cv::Point(-1, -1);
@@ -275,7 +275,7 @@ void TunerBody::launch(void)
       prev_vw = vw;
 
       /* publish tuned result */
-      road_wizard::TunedResult res;
+      autoware_msgs::TunedResult res;
       res.Red.Hue.center = Red_set.hue.center;
       res.Red.Hue.range  = Red_set.hue.range;
       res.Red.Sat.center = Red_set.sat.center;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -58,7 +58,7 @@ SearchInfo::~SearchInfo()
 {
 }
 
-double SearchInfo::calcPathLength(const waypoint_follower_msgs::lane &amp;lane, const int start_waypoint_index,
+double SearchInfo::calcPathLength(const autoware_msgs::lane &amp;lane, const int start_waypoint_index,
                                   const int goal_waypoint_index) const
 {
   if (lane.waypoints.size() &lt;= 1)
@@ -172,7 +172,7 @@ void SearchInfo::goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 }
 
 // get waypoints
-void SearchInfo::waypointsCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg)
+void SearchInfo::waypointsCallback(const autoware_msgs::laneConstPtr &amp;msg)
 {
   subscribed_waypoints_ = *msg;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" added_lines="8" deleted_lines="8">
				<diff>@@ -32,7 +32,7 @@
 #define SEARCH_INFO_ROS_H
 
 #include "astar_util.h"
-#include "waypoint_follower_msgs/lane.h"
+#include "autoware_msgs/lane.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 
 #include &lt;nav_msgs/OccupancyGrid.h&gt;
@@ -55,7 +55,7 @@ public:
   void goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void currentPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void currentVelocityCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg);
-  void waypointsCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg);
+  void waypointsCallback(const autoware_msgs::laneConstPtr &amp;msg);
   void closestWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg);
   void obstacleWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg);
   void stateCallback(const std_msgs::StringConstPtr &amp;msg);
@@ -101,11 +101,11 @@ public:
   {
     return current_velocity_mps_;
   }
-  waypoint_follower_msgs::lane getSubscribedWaypoints() const
+  autoware_msgs::lane getSubscribedWaypoints() const
   {
     return subscribed_waypoints_;
   }
-  waypoint_follower_msgs::lane getCurrentWaypoints() const
+  autoware_msgs::lane getCurrentWaypoints() const
   {
     return current_waypoints_;
   }
@@ -143,7 +143,7 @@ public:
   }
 
   // set method
-  void setCurrentWaypoints(const waypoint_follower_msgs::lane &amp;waypoints)
+  void setCurrentWaypoints(const autoware_msgs::lane &amp;waypoints)
   {
     current_waypoints_ = waypoints;
   }
@@ -152,7 +152,7 @@ public:
   void reset();
 
 private:
-  double calcPathLength(const waypoint_follower_msgs::lane &amp;lane, const int start_waypoint_index,
+  double calcPathLength(const autoware_msgs::lane &amp;lane, const int start_waypoint_index,
                         const int goal_waypoint_index) const;
 
   nav_msgs::OccupancyGrid map_;
@@ -186,8 +186,8 @@ private:
   int obstacle_waypoint_index_;
   int start_waypoint_index_;
   int goal_waypoint_index_;
-  waypoint_follower_msgs::lane subscribed_waypoints_;
-  waypoint_follower_msgs::lane current_waypoints_;
+  autoware_msgs::lane subscribed_waypoints_;
+  autoware_msgs::lane current_waypoints_;
   geometry_msgs::PoseStamped current_pose_;
   double current_velocity_mps_;
   std::string state_;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -53,7 +53,7 @@ void VelocitySetInfo::clearPoints()
   points_.clear();
 }
 
-void VelocitySetInfo::configCallback(const runtime_manager::ConfigVelocitySetConstPtr &amp;config)
+void VelocitySetInfo::configCallback(const autoware_msgs::ConfigVelocitySetConstPtr &amp;config)
 {
   stop_distance_ = config-&gt;others_distance;
   stop_range_ = config-&gt;detection_range;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" added_lines="2" deleted_lines="2">
				<diff>@@ -36,7 +36,7 @@
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 
-#include "runtime_manager/ConfigVelocitySet.h"
+#include "autoware_msgs/ConfigVelocitySet.h"
 
 class VelocitySetInfo
 {
@@ -62,7 +62,7 @@ class VelocitySetInfo
   ~VelocitySetInfo();
 
   // ROS Callback
-  void configCallback(const runtime_manager::ConfigVelocitySetConstPtr &amp;msg);
+  void configCallback(const autoware_msgs::ConfigVelocitySetConstPtr &amp;msg);
   void pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg);
   void controlPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void localizerPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
</diff>
			</file>
			<file old_path="ros\src\system\sync\sync_drivers.cpp" new_path="ros\src\system\sync\sync_drivers.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -36,7 +36,7 @@
 /* user header */
 #include "sensor_msgs/Image.h"
 #include "sensor_msgs/PointCloud2.h"
-#include "autoware_msgs/time_diff.h"
+#include "autoware_msgs/Sync_time_diff.h"
 
 /* ----var---- */
 /* common var */
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="955c5de6a572f7b6b6cd67171db4d36f2cced2ea" author="Yusuke FUJII">
		<msg>fix a build issue due to autoware_msgs on the Indigo</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lib\image\kf\src\kf.cpp" new_path="ros\src\computing\perception\detection\lib\image\kf\src\kf.cpp" added_lines="11" deleted_lines="11">
				<diff>@@ -37,10 +37,10 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;runtime_manager/ConfigCarKf.h&gt;
-#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
+#include &lt;autoware_msgs/ConfigCarKf.h&gt;
+#include &lt;autoware_msgs/image_obj_ranged.h&gt;
 
-#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
+#include &lt;autoware_msgs/image_obj_tracked.h&gt;
 #include &lt;std_msgs/Header.h&gt;
 
 //TRACKING STUFF
@@ -92,7 +92,7 @@ static bool 		USE_ORB;
 
 static bool 		track_ready_;
 static bool 		detect_ready_;
-static cv_tracker_msgs::image_obj_tracked kf_objects_msg_;
+static autoware_msgs::image_obj_tracked kf_objects_msg_;
 
 struct kstate
 {
@@ -819,7 +819,7 @@ void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;ObjectDete
 
 	//ROS
 	int num = tracked_detections.size();
-	std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; rect_ranged_array;
+	std::vector&lt;autoware_msgs::image_rect_ranged&gt; rect_ranged_array;
 	std::vector&lt;int&gt; real_data(num,0);
 	std::vector&lt;int&gt; obj_id(num, 0);
 	std::vector&lt;int&gt; lifespan(num, 0);
@@ -828,7 +828,7 @@ void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;ObjectDete
 	for (size_t i = 0; i &lt; tracked_detections.size(); i++)
 	{
 		kstate od = tracked_detections[i];
-		cv_tracker_msgs::image_rect_ranged rect_ranged_;
+		autoware_msgs::image_rect_ranged rect_ranged_;
 
 		//od.rect contains x,y, width, height
 		rectangle(image, od.pos, od.color, 3);
@@ -850,7 +850,7 @@ void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;ObjectDete
 		//ENDROS
 	}
 	//more ros
-	cv_tracker_msgs::image_obj_tracked kf_objects_msg;
+	autoware_msgs::image_obj_tracked kf_objects_msg;
 
 	kf_objects_msg.type = object_type;
 	kf_objects_msg.total_num = num;
@@ -882,12 +882,12 @@ void image_callback(const sensor_msgs::Image&amp; image_source)
 	_counter++;
 }
 
-void detections_callback(cv_tracker_msgs::image_obj_ranged image_objects_msg)
+void detections_callback(autoware_msgs::image_obj_ranged image_objects_msg)
 {
 	if(!detect_ready_)
 	{
 		unsigned int num = image_objects_msg.obj.size();
-		std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects = image_objects_msg.obj;
+		std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects = image_objects_msg.obj;
 		object_type = image_objects_msg.type;
 		image_objects_header = image_objects_msg.header;
 		//points are X,Y,W,H and repeat for each instance
@@ -918,7 +918,7 @@ void detections_callback(cv_tracker_msgs::image_obj_ranged image_objects_msg)
 	publish_if_possible();
 }
 
-static void kf_config_cb(const runtime_manager::ConfigCarKf::ConstPtr&amp; param)
+static void kf_config_cb(const autoware_msgs::ConfigCarKf::ConstPtr&amp; param)
 {
 	if (param-&gt;initial_lifespan &gt; 0)
 		INITIAL_LIFESPAN	= param-&gt;initial_lifespan;
@@ -962,7 +962,7 @@ int kf_main(int argc, char* argv[])
 	ros::NodeHandle n;
 	ros::NodeHandle private_nh("~");
 
-	image_objects = n.advertise&lt;cv_tracker_msgs::image_obj_tracked&gt;("image_obj_tracked", 1);
+	image_objects = n.advertise&lt;autoware_msgs::image_obj_tracked&gt;("image_obj_tracked", 1);
 
 #if (CV_MAJOR_VERSION == 3)
 	generateColors(_colors, 25);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\image_d_viewer\image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\image_d_viewer\image_d_viewer.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -36,7 +36,7 @@
 #include "ros/ros.h"
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;sensor_msgs/CompressedImage.h&gt;
-#include "cv_tracker_msgs/image_obj_ranged.h"
+#include "autoware_msgs/image_obj_ranged.h"
 #include &lt;math.h&gt;
 #include &lt;float.h&gt;
 #define NO_DATA 0
@@ -49,8 +49,8 @@ static IplImage temp;
 static IplImage *image;
 static double ratio = 1;	//resize ratio
 
-static cv_tracker_msgs::image_obj_ranged car_fused_objects;
-static cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
+static autoware_msgs::image_obj_ranged car_fused_objects;
+static autoware_msgs::image_obj_ranged pedestrian_fused_objects;
 
 static const int OBJ_RECT_THICKNESS = 3;
 static void showImage();
@@ -64,7 +64,7 @@ static inline bool isNearlyNODATA(float x)
 }
 
 void showRects(IplImage *Image,
-               std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
+               std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
                double ratio,
                CvScalar col)
 {
@@ -80,7 +80,7 @@ void showRects(IplImage *Image,
     }
 }
 
-static void obj_carCallback(const cv_tracker_msgs::image_obj_ranged&amp; fused_objects)
+static void obj_carCallback(const autoware_msgs::image_obj_ranged&amp; fused_objects)
 {
     if(image == NULL){
       return;
@@ -89,7 +89,7 @@ static void obj_carCallback(const cv_tracker_msgs::image_obj_ranged&amp; fused_objec
     showImage();
 }
 
-static void obj_personCallback(const cv_tracker_msgs::image_obj_ranged&amp; fused_objects)
+static void obj_personCallback(const autoware_msgs::image_obj_ranged&amp; fused_objects)
 {
     if(image == NULL){
       return;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\image_viewer\image_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\image_viewer\image_viewer.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -44,8 +44,8 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 
-#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
-#include &lt;cv_tracker_msgs/image_obj.h&gt;
+#include &lt;autoware_msgs/image_obj_tracked.h&gt;
+#include &lt;autoware_msgs/image_obj.h&gt;
 
 //DPM related
 static std::vector&lt;cv::Rect&gt; cars;		//objects detected
@@ -215,7 +215,7 @@ static void image_viewer_callback(const sensor_msgs::Image&amp; image_source)
 	_drawing = false;
 }
 
-static void image_obj_update_cb(const cv_tracker_msgs::image_obj&amp; image_objs)
+static void image_obj_update_cb(const autoware_msgs::image_obj&amp; image_objs)
 {
 	if(_drawing)
 		return;
@@ -245,7 +245,7 @@ static void image_obj_update_cb(const cv_tracker_msgs::image_obj&amp; image_objs)
 	}
 }
 
-static void image_obj_updater_cb_tracked(const cv_tracker_msgs::image_obj_tracked&amp; image_objs_tracked_msg)
+static void image_obj_updater_cb_tracked(const autoware_msgs::image_obj_tracked&amp; image_objs_tracked_msg)
 {
 	if(_drawing)
 		return;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" added_lines="10" deleted_lines="10">
				<diff>@@ -42,9 +42,9 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;points2image/PointsImage.h&gt;
+#include &lt;autoware_msgs/PointsImage.h&gt;
 
-#include "cv_tracker_msgs/image_obj_ranged.h"
+#include "autoware_msgs/image_obj_ranged.h"
 #include &lt;vector&gt;
 #include &lt;iostream&gt;
 #include &lt;math.h&gt;
@@ -56,15 +56,15 @@ static char window_name[] = "points_image_d_viewer";
 static bool existImage = false;
 static bool existPoints = false;
 static sensor_msgs::Image image_msg;
-static points2image::PointsImageConstPtr points_msg;
+static autoware_msgs::PointsImageConstPtr points_msg;
 static cv::Mat colormap;
 
 #if 0
 static std::vector&lt;cv::Rect&gt; cars;
 static std::vector&lt;cv::Rect&gt; peds;
 #else
-static cv_tracker_msgs::image_obj_ranged car_fused_objects;
-static cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
+static autoware_msgs::image_obj_ranged car_fused_objects;
+static autoware_msgs::image_obj_ranged pedestrian_fused_objects;
 #endif
 
 /* check whether floating value x is nearly 0 or not */
@@ -83,7 +83,7 @@ static std::vector&lt;cv::Scalar&gt; _colors;
 static const int OBJ_RECT_THICKNESS = 3;
 
 static void drawRects(IplImage *Image,
-                      std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
+                      std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
                       CvScalar color,
                       int threshold_height)
 {
@@ -98,7 +98,7 @@ static void drawRects(IplImage *Image,
 }
 
 static void putDistance(IplImage *Image,
-                        std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
+                        std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
                         int threshold_height,
                         const char* objectLabel)
 {
@@ -283,7 +283,7 @@ static void car_updater_callback(dpm::ImageObjects image_objects_msg)
   }
 }
 #else
-static void car_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_car_msg)
+static void car_updater_callback(const autoware_msgs::image_obj_ranged&amp; fused_car_msg)
 {
   car_fused_objects = fused_car_msg;
   //  show();
@@ -308,7 +308,7 @@ static void ped_updater_callback(dpm::ImageObjects image_objects_msg)
   }
 }
 #else
-static void ped_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_pds_msg)
+static void ped_updater_callback(const autoware_msgs::image_obj_ranged&amp; fused_pds_msg)
 {
   pedestrian_fused_objects = fused_pds_msg;
   //  show();
@@ -322,7 +322,7 @@ static void image_cb(const sensor_msgs::Image&amp; msg)
   show();
 }
 
-static void points_cb(const points2image::PointsImageConstPtr&amp; msg)
+static void points_cb(const autoware_msgs::PointsImageConstPtr&amp; msg)
 {
   points_msg = msg;
   existPoints = true;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\points_image_viewer\points_image_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\points_image_viewer\points_image_viewer.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -35,7 +35,7 @@
 
 #include "ros/ros.h"
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include "points2image/PointsImage.h"
+#include "autoware_msgs/PointsImage.h"
 
 #define IMAGE_WIDTH 800
 #define IMAGE_HEIGHT 640
@@ -43,7 +43,7 @@
 static bool existImage = false;
 static bool existPoints = false;
 static sensor_msgs::Image image_msg;
-static points2image::PointsImageConstPtr points_msg;
+static autoware_msgs::PointsImageConstPtr points_msg;
 static cv::Mat colormap;
 
 static const char window_name_base[] = "points_image_viewer";
@@ -103,7 +103,7 @@ static void image_cb(const sensor_msgs::Image&amp; msg)
 	show();
 }
 
-static void points_cb(const points2image::PointsImageConstPtr&amp; msg)
+static void points_cb(const autoware_msgs::PointsImageConstPtr&amp; msg)
 {
 	points_msg = msg;
 	existPoints = true;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\scan_image_d_viewer\scan_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\scan_image_d_viewer\scan_image_d_viewer.cpp" added_lines="10" deleted_lines="10">
				<diff>@@ -42,8 +42,8 @@
 #include &lt;iostream&gt;
 #include &lt;math.h&gt;
 #include &lt;float.h&gt;
-#include "cv_tracker_msgs/image_obj_ranged.h"
-#include "scan2image/ScanImage.h"
+#include "autoware_msgs/image_obj_ranged.h"
+#include "autoware_msgs/ScanImage.h"
 
 #define IMAGE_WIDTH 800
 #define IMAGE_HEIGHT 600
@@ -53,13 +53,13 @@ char window_name[] = "SCAN_IMAGE_VIEWER";
 //for imageCallback
 cv_bridge::CvImagePtr cv_image;
 IplImage image;
-scan2image::ScanImage scan_image;
+autoware_msgs::ScanImage scan_image;
 bool exist_image = false;
 bool exist_scan = false;
 cv::Mat colormap;
 
-cv_tracker_msgs::image_obj_ranged car_fused_objects;
-cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
+autoware_msgs::image_obj_ranged car_fused_objects;
+autoware_msgs::image_obj_ranged pedestrian_fused_objects;
 static const int OBJ_RECT_THICKNESS = 3;
 
 /* check whether floating value x is nearly 0 or not */
@@ -71,7 +71,7 @@ static inline bool isNearlyNODATA(float x)
 }
 
 static void putDistance(IplImage *Image,
-                        std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
+                        std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
                         int threshold_height,
                         const char* objectLabel)
 {
@@ -147,7 +147,7 @@ static void putDistance(IplImage *Image,
 }
 
 static void drawRects(IplImage *Image,
-                      std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
+                      std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
                       CvScalar color,
                       int threshold_height)
 {
@@ -229,20 +229,20 @@ static void show()
     cvReleaseImage(&amp;image_view);
 }
 
-static void scan_image_callback(const scan2image::ScanImage&amp; scan_image_msg)
+static void scan_image_callback(const autoware_msgs::ScanImage&amp; scan_image_msg)
 {
     scan_image = scan_image_msg;
     exist_scan = true;
     show();
 }
 
-static void car_fusion_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_car_msg)
+static void car_fusion_callback(const autoware_msgs::image_obj_ranged&amp; fused_car_msg)
 {
   car_fused_objects = fused_car_msg;
 //  show();
 }
 
-static void ped_fusion_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_pds_msg)
+static void ped_fusion_callback(const autoware_msgs::image_obj_ranged&amp; fused_pds_msg)
 {
   pedestrian_fused_objects = fused_pds_msg;
 //  show();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\scan_image_viewer\scan_image_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\scan_image_viewer\scan_image_viewer.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -38,14 +38,14 @@
 #include "ros/ros.h"
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include "scan2image/ScanImage.h"
+#include "autoware_msgs/ScanImage.h"
 #include &lt;sensor_msgs/CameraInfo.h&gt;
 
 static char window_name[] = "SCAN_IMAGE_VIEWER";
 //for imageCallback
 static cv_bridge::CvImagePtr cv_image;
 static IplImage image;
-static scan2image::ScanImage scan_image;
+static autoware_msgs::ScanImage scan_image;
 static bool exist_image = false;
 static bool exist_scan = false;
 static cv::Mat colormap;
@@ -96,7 +96,7 @@ static void show()
     cvReleaseImage(&amp;image_view);
 }
 
-static void scan_image_callback(const scan2image::ScanImage&amp; scan_image_msg)
+static void scan_image_callback(const autoware_msgs::ScanImage&amp; scan_image_msg)
 {
     scan_image = scan_image_msg;
     exist_scan = true;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\traffic_light_viewer\traffic_light_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\traffic_light_viewer\traffic_light_viewer.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 #include &lt;ros/ros.h&gt;
-#include &lt;runtime_manager/traffic_light.h&gt;
+#include &lt;autoware_msgs/traffic_light.h&gt;
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 #include &lt;opencv2/imgproc/imgproc.hpp&gt;
@@ -13,7 +13,7 @@ static const int32_t TRAFFIC_LIGHT_RED     = 0;
 static const int32_t TRAFFIC_LIGHT_GREEN   = 1;
 static const int32_t TRAFFIC_LIGHT_UNKNOWN = 2;
 
-static void signalState_cb(const runtime_manager::traffic_light::ConstPtr&amp; msg)
+static void signalState_cb(const autoware_msgs::traffic_light::ConstPtr&amp; msg)
 {
   const int   fontFace      = cv::FONT_HERSHEY_COMPLEX;
   const float fontScale     = 1.0f;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -33,9 +33,9 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;points2image/PointsImage.h&gt;
+#include &lt;autoware_msgs/PointsImage.h&gt;
 
-#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
+#include &lt;autoware_msgs/image_obj_ranged.h&gt;
 #include &lt;vector&gt;
 #include &lt;iostream&gt;
 #include &lt;math.h&gt;
@@ -51,15 +51,15 @@ static char window_name[] = "vscan_image_d_viewer";
 static bool existImage = false;
 static bool existPoints = false;
 static sensor_msgs::Image image_msg;
-static points2image::PointsImageConstPtr points_msg;
+static autoware_msgs::PointsImageConstPtr points_msg;
 static cv::Mat colormap;
 
 #if 0
 static std::vector&lt;cv::Rect&gt; cars;
 static std::vector&lt;cv::Rect&gt; peds;
 #else
-static cv_tracker_msgs::image_obj_ranged car_fused_objects;
-static cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
+static autoware_msgs::image_obj_ranged car_fused_objects;
+static autoware_msgs::image_obj_ranged pedestrian_fused_objects;
 #endif
 
 /* check whether floating value x is nearly 0 or not */
@@ -80,7 +80,7 @@ static std::vector&lt;cv::Scalar&gt; _colors;
 static const int OBJ_RECT_THICKNESS = 3;
 
 static void drawRects(cv::Mat image,
-                    std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
+                    std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
 					CvScalar color,
 					int threshold_height,
 					std::string objectClass)
@@ -176,13 +176,13 @@ static void show(void)
 		cvWaitKey(2);
 	}
 }
-static void car_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_car_msg)
+static void car_updater_callback(const autoware_msgs::image_obj_ranged&amp; fused_car_msg)
 {
 	car_fused_objects = fused_car_msg;
 	//  show();
 }
 
-static void ped_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_pds_msg)
+static void ped_updater_callback(const autoware_msgs::image_obj_ranged&amp; fused_pds_msg)
 {
   pedestrian_fused_objects = fused_pds_msg;
   //  show();
@@ -195,7 +195,7 @@ static void image_cb(const sensor_msgs::Image&amp; msg)
 	show();
 }
 
-static void points_cb(const points2image::PointsImageConstPtr&amp; msg)
+static void points_cb(const autoware_msgs::PointsImageConstPtr&amp; msg)
 {
 	points_msg = msg;
 	existPoints = true;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\vscan_image_viewer\vscan_image_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\vscan_image_viewer\vscan_image_viewer.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -35,7 +35,7 @@
 
 #include "ros/ros.h"
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include "points2image/PointsImage.h"
+#include "autoware_msgs/PointsImage.h"
 
 #define IMAGE_WIDTH 800
 #define IMAGE_HEIGHT 640
@@ -43,7 +43,7 @@
 static bool existImage = false;
 static bool existPoints = false;
 static sensor_msgs::Image image_msg;
-static points2image::PointsImageConstPtr points_msg;
+static autoware_msgs::PointsImageConstPtr points_msg;
 static cv::Mat colormap;
 
 static const char window_name[] = "vscan_image_viewer";
@@ -102,7 +102,7 @@ static void image_cb(const sensor_msgs::Image&amp; msg)
 	show();
 }
 
-static void points_cb(const points2image::PointsImageConstPtr&amp; msg)
+static void points_cb(const autoware_msgs::PointsImageConstPtr&amp; msg)
 {
 	points_msg = msg;
 	existPoints = true;
</diff>
			</file>
			<file old_path="ros\src\sensing\polygon\packages\points2polygon\nodes\points2polygon\points2polygon.cpp" new_path="ros\src\sensing\polygon\packages\points2polygon\nodes\points2polygon\points2polygon.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -32,7 +32,7 @@
 #include &lt;ros/console.h&gt;
 
 #include &lt;sensor_msgs/PointCloud2.h&gt;
-#include &lt;runtime_manager/ConfigPoints2Polygon.h&gt;
+#include &lt;autoware_msgs/ConfigPoints2Polygon.h&gt;
 
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl/io/pcd_io.h&gt;
@@ -115,7 +115,7 @@ static void points_to_polygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr&amp; cloud)
 	pcl::io::saveVTKFile(points_polygon_vtk, triangles);
 }
 
-static void config_callback(const runtime_manager::ConfigPoints2Polygon&amp; msg)
+static void config_callback(const autoware_msgs::ConfigPoints2Polygon&amp; msg)
 {
 	config_k_search = msg.k_search;
 	config_search_radius = msg.search_radius;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="19753448d1992c19911d56abddd54cc274a062b1" author="Yusuke FUJII">
		<msg>tweak a default.rviz</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\default.rviz" new_path="ros\src\.config\rviz\default.rviz" added_lines="6" deleted_lines="163">
				<diff>@@ -157,7 +157,6 @@ Visualization Manager:
         Global Waypoints: true
         GlobalPathAnimation: true
         Grid: true
-        Image: true
         Laserscan Costmap: true
         Local Rollouts: true
         Local Waypoints: true
@@ -168,24 +167,7 @@ Visualization Manager:
         Points Map: true
         Points Raw: true
         Safety Box: true
-        SimBehavior1: true
-        SimBehavior2: true
-        SimBehavior3: true
-        SimBehavior4: true
-        SimBehavior5: true
-        SimPath1: true
-        SimPath2: true
-        SimPath3: true
-        SimPath4: true
-        SimPath5: true
-        SimuCar1: true
-        SimuCar2: true
-        SimuCar3: true
-        SimuCar4: true
-        SimuCar5: true
-        Simulated Following Point: true
         Simulated Obstacle: true
-        SimulatedCar Pose: true
         Stixel: true
         TF: false
         Tracked Contours: true
@@ -195,7 +177,6 @@ Visualization Manager:
         Vehicle Model: true
         Vscan Points: true
         Waypoint Guide: true
-        km/h: true
       Zoom Factor: 1
     - Alpha: 0.5
       Autocompute Intensity Bounds: true
@@ -239,7 +220,7 @@ Visualization Manager:
       Color: 255; 255; 0
       Color Transformer: FlatColor
       Decay Time: 0
-      Enabled: true
+      Enabled: false
       Invert Rainbow: false
       Max Color: 255; 255; 255
       Max Intensity: 255
@@ -256,13 +237,13 @@ Visualization Manager:
       Unreliable: false
       Use Fixed Frame: true
       Use rainbow: true
-      Value: true
+      Value: false
     - Alpha: 1
       Axes Length: 1
       Axes Radius: 0.1
       Class: rviz/Pose
       Color: 255; 25; 0
-      Enabled: true
+      Enabled: false
       Head Length: 2
       Head Radius: 2
       Name: Control Pose
@@ -271,7 +252,7 @@ Visualization Manager:
       Shape: Arrow
       Topic: /control_pose
       Unreliable: false
-      Value: true
+      Value: false
     - Alpha: 1
       Axes Length: 1
       Axes Radius: 0.1
@@ -412,13 +393,13 @@ Visualization Manager:
       Unreliable: false
       Value: false
     - Class: rviz/MarkerArray
-      Enabled: false
+      Enabled: true
       Marker Topic: /vector_map_center_lines_rviz
       Name: Vector Map CenterLines
       Namespaces:
         {}
       Queue Size: 100
-      Value: false
+      Value: true
     - Class: rviz/MarkerArray
       Enabled: true
       Marker Topic: /global_waypoints_rviz
@@ -445,22 +426,6 @@ Visualization Manager:
         {}
       Queue Size: 100
       Value: true
-    - Class: rviz/Marker
-      Enabled: true
-      Marker Topic: /curr_simu_pose
-      Name: SimulatedCar Pose
-      Namespaces:
-        curr_simu_pose: true
-      Queue Size: 100
-      Value: true
-    - Class: rviz/Marker
-      Enabled: true
-      Marker Topic: /follow_pose
-      Name: Simulated Following Point
-      Namespaces:
-        follow_pose: true
-      Queue Size: 100
-      Value: true
     - Class: rviz/Marker
       Enabled: true
       Marker Topic: /behavior_state
@@ -497,126 +462,6 @@ Visualization Manager:
       line width: 0.01
       only edge: false
       show coords: false
-    - Class: rviz/Marker
-      Enabled: true
-      Marker Topic: /op_simulator1/curr_simu_pose_1
-      Name: SimuCar1
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/Marker
-      Enabled: true
-      Marker Topic: /op_simulator2/curr_simu_pose_2
-      Name: SimuCar2
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/Marker
-      Enabled: true
-      Marker Topic: /op_simulator3/curr_simu_pose_3
-      Name: SimuCar3
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/Marker
-      Enabled: true
-      Marker Topic: /op_simulator4/curr_simu_pose_4
-      Name: SimuCar4
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/Marker
-      Enabled: true
-      Marker Topic: /op_simulator5/curr_simu_pose_5
-      Name: SimuCar5
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/MarkerArray
-      Enabled: true
-      Marker Topic: /op_simulator1/simu_local_trajectory_1
-      Name: SimPath1
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/MarkerArray
-      Enabled: true
-      Marker Topic: /op_simulator2/simu_local_trajectory_2
-      Name: SimPath2
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/MarkerArray
-      Enabled: true
-      Marker Topic: /op_simulator3/simu_local_trajectory_3
-      Name: SimPath3
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/MarkerArray
-      Enabled: true
-      Marker Topic: /op_simulator4/simu_local_trajectory_4
-      Name: SimPath4
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/MarkerArray
-      Enabled: true
-      Marker Topic: /op_simulator5/simu_local_trajectory_5
-      Name: SimPath5
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/Marker
-      Enabled: true
-      Marker Topic: /op_simulator1/sim_beh_txt_1
-      Name: SimBehavior1
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/Marker
-      Enabled: true
-      Marker Topic: /op_simulator2/sim_beh_txt_2
-      Name: SimBehavior2
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/Marker
-      Enabled: true
-      Marker Topic: /op_simulator3/sim_beh_txt_3
-      Name: SimBehavior3
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/Marker
-      Enabled: true
-      Marker Topic: /op_simulator4/sim_beh_txt_4
-      Name: SimBehavior4
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
-    - Class: rviz/Marker
-      Enabled: true
-      Marker Topic: /op_simulator5/sim_beh_txt_5
-      Name: SimBehavior5
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
   Enabled: true
   Global Options:
     Background Color: 48; 48; 48
@@ -663,8 +508,6 @@ Window Geometry:
   Height: 1416
   Hide Left Dock: false
   Hide Right Dock: false
-  Image:
-    collapsed: false
   QMainWindow State: 000000ff00000000fd0000000400000000000001fc000004e0fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc00000028000004e0000000dd00fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000005c00fffffffb0000000c00430061006d0065007200610000000000ffffffff0000006500fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb00000000000000000000000100000163000004e0fc0200000003fb0000000a005600690065007700730100000028000004e0000000b000fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e1000001970000000300000a000000005cfc0100000002fb0000000800540069006d0065010000000000000a00000002f600fffffffb0000000800540069006d0065010000000000000450000000000000000000000695000004e000000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
</diff>
			</file>
		</modified_files>
	</commit>
</Root>
