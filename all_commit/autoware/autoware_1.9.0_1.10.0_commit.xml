<?xml version="1.0" encoding="utf-8"?>
<Root>
	<commit hash="c0b152d2c06812efe678ebfc3326e541f28d1dcb" author="Kosuke Murakami">
		<msg>[Feature] Tracking accuracy can be measured by KITTI data (#1671)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\imm_ukf_pda.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\imm_ukf_pda.h" added_lines="10" deleted_lines="0">
				<diff>@@ -83,6 +83,14 @@ private:
   // whether if publish debug ros markers
   bool is_debug_;
 
+  // whether if benchmarking tracking result
+  bool is_benchmark_;
+  int frame_count_;
+  std::string kitti_data_dir_;
+
+  // for benchmark
+  std::string result_file_path_;
+
   // prevent explode param for ukf
   double prevent_explosion_thres_;
 
@@ -150,6 +158,8 @@ private:
 
   void pubDebugRosMarker(const autoware_msgs::DetectedObjectArray&amp; input);
 
+  void dumpResultText(autoware_msgs::DetectedObjectArray&amp; detected_objects);
+
   void tracker(const autoware_msgs::DetectedObjectArray&amp; transformed_input,
                jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda.cpp" added_lines="49" deleted_lines="1">
				<diff>@@ -37,7 +37,8 @@
 ImmUkfPda::ImmUkfPda()
   : target_id_(0)
   ,  // assign unique ukf_id_ to each tracking targets
-  init_(false)
+  init_(false),
+  frame_count_(0)
 {
   ros::NodeHandle private_nh_("~");
   private_nh_.param&lt;std::string&gt;("pointcloud_frame", pointcloud_frame_, "velodyne");
@@ -51,6 +52,15 @@ ImmUkfPda::ImmUkfPda()
   private_nh_.param&lt;double&gt;("prevent_explosion_thres", prevent_explosion_thres_, 1000);
   private_nh_.param&lt;bool&gt;("use_sukf", use_sukf_, false);
   private_nh_.param&lt;bool&gt;("is_debug", is_debug_, false);
+
+  // rosparam for benchmark
+  private_nh_.param&lt;bool&gt;("is_benchmark", is_benchmark_, false);
+  private_nh_.param&lt;std::string&gt;("kitti_data_dir", kitti_data_dir_, "/home/hoge/kitti/2011_09_26/2011_09_26_drive_0005_sync/");
+  if(is_benchmark_)
+  {
+    result_file_path_ = kitti_data_dir_ + "benchmark_results.txt";
+    std::remove(result_file_path_.c_str());
+  }
 }
 
 void ImmUkfPda::run()
@@ -80,6 +90,11 @@ void ImmUkfPda::callback(const autoware_msgs::DetectedObjectArray&amp; input)
   transformPoseToLocal(jskbboxes_output, detected_objects_output);
   pub_jskbbox_array_.publish(jskbboxes_output);
   pub_object_array_.publish(detected_objects_output);
+
+  if(is_benchmark_)
+  {
+    dumpResultText(detected_objects_output);
+  }
 }
 
 void ImmUkfPda::relayJskbbox(const autoware_msgs::DetectedObjectArray&amp; input,
@@ -752,6 +767,39 @@ void ImmUkfPda::pubDebugRosMarker(const autoware_msgs::DetectedObjectArray&amp; inpu
   pub_texts_array_.publish(texts_markers);
 }
 
+void ImmUkfPda::dumpResultText(autoware_msgs::DetectedObjectArray&amp; detected_objects)
+{
+  std::ofstream outputfile(result_file_path_, std::ofstream::out | std::ofstream::app);
+  for(size_t i = 0; i &lt; detected_objects.objects.size(); i++)
+  {
+    double yaw = tf::getYaw(detected_objects.objects[i].pose.orientation);
+
+    // KITTI tracking benchmark data format:
+    // (frame_number,tracked_id, object type, truncation, occlusion, observation angle, x1,y1,x2,y2, h, w, l, cx, cy, cz, yaw)
+    // x1, y1, x2, y2 are for 2D bounding box.
+    // h, w, l, are for height, width, length respectively
+    // cx, cy, cz are for object centroid
+
+    // Tracking benchmark is based on frame_number, tracked_id,
+    // bounding box dimentions and object pose(centroid and orientation) from bird-eye view
+    outputfile &lt;&lt; std::to_string(frame_count_)                               &lt;&lt;" "
+               &lt;&lt; std::to_string(detected_objects.objects[i].id)             &lt;&lt;" "
+               &lt;&lt; "Unknown"                                                  &lt;&lt;" "
+               &lt;&lt; "-1"                                                       &lt;&lt;" "
+               &lt;&lt; "-1"                                                       &lt;&lt;" "
+               &lt;&lt; "-1"                                                      &lt;&lt;" "
+               &lt;&lt; "-1 -1 -1 -1"                                              &lt;&lt;" "
+               &lt;&lt; std::to_string(detected_objects.objects[i].dimensions.x)   &lt;&lt;" "
+               &lt;&lt; std::to_string(detected_objects.objects[i].dimensions.y)   &lt;&lt;" "
+               &lt;&lt; "-1"                                                       &lt;&lt;" "
+               &lt;&lt; std::to_string(detected_objects.objects[i].pose.position.x)&lt;&lt;" "
+               &lt;&lt; std::to_string(detected_objects.objects[i].pose.position.y)&lt;&lt;" "
+               &lt;&lt; "-1"                                                       &lt;&lt;" "
+               &lt;&lt; std::to_string(yaw)                                        &lt;&lt;"\n";
+  }
+  frame_count_ ++;
+}
+
 void ImmUkfPda::tracker(const autoware_msgs::DetectedObjectArray&amp; input,
                         jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                         autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c45ad31f10ce86b17c64fc64b61f66eaf4b6b517" author="Esteve Fernandez">
		<msg>Fix Ssd/SSD naming convention</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.cpp" added_lines="27" deleted_lines="27">
				<diff>@@ -10,9 +10,9 @@
 #include "Context.h"
 
 // ========================================
-// Constructor of RegionTlrSsdRosNode class
+// Constructor of RegionTlrSSDRosNode class
 // ========================================
-RegionTlrSsdRosNode::RegionTlrSsdRosNode():
+RegionTlrSSDRosNode::RegionTlrSSDRosNode():
   image_topic_name_("/image_raw"),
   network_definition_file_name_(""),
   pretrained_model_file_name_(""),
@@ -26,20 +26,20 @@ RegionTlrSsdRosNode::RegionTlrSsdRosNode():
   kStringGreen("green signal"),
   kStringUnknown("") {
 
-} // RegionTlrSsdRosNode::RegionTlrSsdRosNode()
+} // RegionTlrSSDRosNode::RegionTlrSSDRosNode()
 
 
 // ========================================
-// Destructor of RegionTlrSsdRosNode class
+// Destructor of RegionTlrSSDRosNode class
 // ========================================
-RegionTlrSsdRosNode::~RegionTlrSsdRosNode() {
-} // RegionTlrSsdRosNode::~RegionTlrSsdRosNode()
+RegionTlrSSDRosNode::~RegionTlrSSDRosNode() {
+} // RegionTlrSSDRosNode::~RegionTlrSSDRosNode()
 
 
 // =========================
 // Start recognition process
 // =========================
-void RegionTlrSsdRosNode::RunRecognition() {
+void RegionTlrSSDRosNode::RunRecognition() {
   // Get execution parameters from ROS parameter server
   GetRosParam();
 
@@ -52,13 +52,13 @@ void RegionTlrSsdRosNode::RunRecognition() {
   // Start subscribing and publishing
   StartSubscribersAndPublishers();
   ros::spin();
-} // RegionTlrSsdRosNode::RunRecognition()
+} // RegionTlrSSDRosNode::RunRecognition()
 
 
 // ==================================
 // Callback function to acquire image
 // ==================================
-void RegionTlrSsdRosNode::ImageRawCallback(const sensor_msgs::Image &amp;image) {
+void RegionTlrSSDRosNode::ImageRawCallback(const sensor_msgs::Image &amp;image) {
   cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image, sensor_msgs::image_encodings::BGR8);
   frame_ = cv_image-&gt;image.clone();
 
@@ -70,7 +70,7 @@ void RegionTlrSsdRosNode::ImageRawCallback(const sensor_msgs::Image &amp;image) {
 // ==========================================
 // Callback function to acquire extracted_pos
 // ==========================================
-void RegionTlrSsdRosNode::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos) {
+void RegionTlrSSDRosNode::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos) {
   static ros::Time previous_timestamp;
   // If frame has not been prepared, abort this callback
   if (frame_.empty() ||
@@ -120,7 +120,7 @@ void RegionTlrSsdRosNode::RoiSignalCallback(const autoware_msgs::Signals::ConstP
 // =======================================
 // Get parameter from ROS parameter server
 // =======================================
-void RegionTlrSsdRosNode::GetRosParam() {
+void RegionTlrSSDRosNode::GetRosParam() {
   ros::NodeHandle private_node_handle("~");
 
   private_node_handle.param&lt;std::string&gt;("image_raw_topic", image_topic_name_, "/image_raw");
@@ -140,23 +140,23 @@ void RegionTlrSsdRosNode::GetRosParam() {
     ROS_FATAL("No Pretrained Model File was specified. Terminate program... ");
     exit(EXIT_FAILURE);
   }
-} // RegionTlrSsdRosNode::ProcessRosParam()
+} // RegionTlrSSDRosNode::ProcessRosParam()
 
 
 // ============================================================
 // Register subscriber and publisher of this node in ROS Master
 // ============================================================
-void RegionTlrSsdRosNode::StartSubscribersAndPublishers() {
+void RegionTlrSSDRosNode::StartSubscribersAndPublishers() {
   ros::NodeHandle node_handle;
   
   // Register subscribers
   image_subscriber      = node_handle.subscribe(image_topic_name_,
                                                 1,
-                                                &amp;RegionTlrSsdRosNode::ImageRawCallback,
+                                                &amp;RegionTlrSSDRosNode::ImageRawCallback,
                                                 this);
   roi_signal_subscriber = node_handle.subscribe("/roi_signal",
                                                 1,
-                                                &amp;RegionTlrSsdRosNode::RoiSignalCallback,
+                                                &amp;RegionTlrSSDRosNode::RoiSignalCallback,
                                                 this);
 
   // Register publishers
@@ -165,13 +165,13 @@ void RegionTlrSsdRosNode::StartSubscribersAndPublishers() {
   marker_publisher              = node_handle.advertise&lt;visualization_msgs::MarkerArray&gt;("tlr_result", 1, kAdvertiseInLatch_);
   superimpose_image_publisher   = node_handle.advertise&lt;sensor_msgs::Image&gt;("tlr_superimpose_image", 1);
 
-} // RegionTlrSsdRosNode::StartSubscribersAndPublishers()
+} // RegionTlrSSDRosNode::StartSubscribersAndPublishers()
 
 
 // ===============================================================================
 // Determine the final recognition result by comparing previous recognition result
 // ===============================================================================
-LightState RegionTlrSsdRosNode::DetermineState(LightState previous_state,
+LightState RegionTlrSSDRosNode::DetermineState(LightState previous_state,
                                                LightState current_state,
                                                int* state_judge_count) {
   // Get a candidate which considering state transition of traffic light
@@ -188,13 +188,13 @@ LightState RegionTlrSsdRosNode::DetermineState(LightState previous_state,
     return previous_state;
   }
 
-} // LightState RegionTlrSsdRosNode::DetermineState()
+} // LightState RegionTlrSSDRosNode::DetermineState()
 
 
 // =================================================================
 // Publish recognition result as autoware_msgs::TrafficLight type
 // =================================================================
-void RegionTlrSsdRosNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts) {
+void RegionTlrSSDRosNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts) {
   autoware_msgs::TrafficLight topic;
   static int32_t previous_state = kTrafficLightUnknown;
   topic.traffic_light = kTrafficLightUnknown;
@@ -226,13 +226,13 @@ void RegionTlrSsdRosNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts) {
     signal_state_publisher.publish(topic);
     previous_state = topic.traffic_light;
   }
-} // void RegionTlrSsdRosNode::PublishTrafficLight()
+} // void RegionTlrSSDRosNode::PublishTrafficLight()
 
 
 // =================================================================
 // Publish recognition result as std_msgs::String
 // =================================================================
-void RegionTlrSsdRosNode::PublishString(std::vector&lt;Context&gt; contexts) {
+void RegionTlrSSDRosNode::PublishString(std::vector&lt;Context&gt; contexts) {
   std_msgs::String topic;
   static std::string previous_state = kStringUnknown;
   topic.data = kStringUnknown;
@@ -264,13 +264,13 @@ void RegionTlrSsdRosNode::PublishString(std::vector&lt;Context&gt; contexts) {
     signal_state_string_publisher.publish(topic);
     previous_state = topic.data;
   }
-} // void RegionTlrSsdRosNode::PublishString()
+} // void RegionTlrSSDRosNode::PublishString()
 
 
 // =================================================================
 // Publish recognition result as visualization_msgs::MarkerArray
 // =================================================================
-void RegionTlrSsdRosNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts) {
+void RegionTlrSSDRosNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts) {
   // Define color constants
   std_msgs::ColorRGBA color_black;
   color_black.r = 0.0f;
@@ -396,13 +396,13 @@ void RegionTlrSsdRosNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts) {
     marker_publisher.publish(signal_set);
   }
 
-} // void RegionTlrSsdRosNode::PublishMarkerArray()
+} // void RegionTlrSSDRosNode::PublishMarkerArray()
 
 
 // ================================================================
 // Publish superimpose and recognition result as sensor_msgs::Image
 // ================================================================
-void RegionTlrSsdRosNode::PublishImage(std::vector&lt;Context&gt; contexts) {
+void RegionTlrSSDRosNode::PublishImage(std::vector&lt;Context&gt; contexts) {
   // Copy the frame image for output
   cv::Mat result_image = frame_.clone();
 
@@ -461,7 +461,7 @@ void RegionTlrSsdRosNode::PublishImage(std::vector&lt;Context&gt; contexts) {
   converter.image = result_image;
   superimpose_image_publisher.publish(converter.toImageMsg());
 
-} // void RegionTlrSsdRosNode::PublishImage()
+} // void RegionTlrSSDRosNode::PublishImage()
 
 // ========================
 // Entry point of this node
@@ -471,7 +471,7 @@ int main (int argc, char *argv[]) {
   ros::init(argc, argv, "region_tlr_ssd");
 
   // Create RegionTlrRosNode class object and do initialization
-  RegionTlrSsdRosNode region_tlr_ssd_ros_node;
+  RegionTlrSSDRosNode region_tlr_ssd_ros_node;
 
   // Start recognition process
   region_tlr_ssd_ros_node.RunRecognition();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.h" added_lines="3" deleted_lines="3">
				<diff>@@ -13,10 +13,10 @@
 #include "autoware_msgs/Signals.h"
 #include "traffic_light_recognizer.h"
 
-class RegionTlrSsdRosNode {
+class RegionTlrSSDRosNode {
  public:
-  RegionTlrSsdRosNode();
-  ~RegionTlrSsdRosNode();
+  RegionTlrSSDRosNode();
+  ~RegionTlrSSDRosNode();
 
   void RunRecognition();
   void ImageRawCallback(const sensor_msgs::Image &amp;image);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -284,7 +284,7 @@ void Yolo3DetectorNode::image_callback(const sensor_msgs::ImageConstPtr&amp; in_imag
     free(darknet_image_.data);
 }
 
-void Yolo3DetectorNode::config_cb(const autoware_config_msgs::ConfigSsd::ConstPtr&amp; param)
+void Yolo3DetectorNode::config_cb(const autoware_config_msgs::ConfigSSD::ConstPtr&amp; param)
 {
     score_threshold_ = param-&gt;score_threshold;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.h" added_lines="2" deleted_lines="2">
				<diff>@@ -49,7 +49,7 @@
 
 #include &lt;cv_bridge/cv_bridge.h&gt;
 
-#include &lt;autoware_config_msgs/ConfigSsd.h&gt;
+#include &lt;autoware_config_msgs/ConfigSSD.h&gt;
 #include &lt;autoware_msgs/DetectedObject.h&gt;
 #include &lt;autoware_msgs/DetectedObjectArray.h&gt;
 
@@ -125,7 +125,7 @@ class Yolo3DetectorNode {
     void                            rgbgr_image(image&amp; im);
     image                           convert_ipl_to_image(const sensor_msgs::ImageConstPtr&amp; msg);
     void                            image_callback(const sensor_msgs::ImageConstPtr&amp; in_image_message);
-    void                            config_cb(const autoware_config_msgs::ConfigSsd::ConstPtr&amp; param);
+    void                            config_cb(const autoware_config_msgs::ConfigSSD::ConstPtr&amp; param);
     std::vector&lt;std::string&gt;        read_custom_names_file(const std::string&amp; in_path);
 public:
     void    Run();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\include\vision_ssd_detect.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\include\vision_ssd_detect.h" added_lines="4" deleted_lines="4">
				<diff>@@ -15,9 +15,9 @@
 
 #include "rect_class_score.h"
 
-namespace Ssd
+namespace SSD
 {
-	enum SsdDetectorClasses
+	enum SSDDetectorClasses
 	{
 		BACKGROUND,
 		PLANE, BICYCLE, BIRD, BOAT,
@@ -28,10 +28,10 @@ namespace Ssd
 	};
 }
 
-class SsdDetector
+class SSDDetector
 {
 public:
-	SsdDetector(const std::string&amp; in_network_definition_file, const std::string&amp; in_pre_trained_model_file, const cv::Scalar&amp; in_mean_value, bool in_use_gpu, unsigned int in_gpu_id);
+	SSDDetector(const std::string&amp; in_network_definition_file, const std::string&amp; in_pre_trained_model_file, const cv::Scalar&amp; in_mean_value, bool in_use_gpu, unsigned int in_gpu_id);
 
 	std::vector &lt;  RectClassScore&lt;float&gt;  &gt; Detect(const cv::Mat&amp; img);
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -30,7 +30,7 @@
 #include "vision_ssd_detect.h"
 
 
-SsdDetector::SsdDetector(const std::string&amp; in_network_definition_file,
+SSDDetector::SSDDetector(const std::string&amp; in_network_definition_file,
 		const std::string&amp; in_pre_trained_model_file,
 		const cv::Scalar&amp; in_mean_value,
 		bool in_use_gpu, unsigned int in_gpu_id)
@@ -59,7 +59,7 @@ SsdDetector::SsdDetector(const std::string&amp; in_network_definition_file,
 	SetMean(in_mean_value);
 }
 
-std::vector &lt;  RectClassScore&lt;float&gt;  &gt; SsdDetector::Detect(const cv::Mat&amp; img)
+std::vector &lt;  RectClassScore&lt;float&gt;  &gt; SSDDetector::Detect(const cv::Mat&amp; img)
 {
 	caffe::Blob&lt;float&gt;* input_layer = net_-&gt;input_blobs()[0];
 	input_layer-&gt;Reshape(1, num_channels_, input_geometry_.height,
@@ -105,7 +105,7 @@ std::vector &lt;  RectClassScore&lt;float&gt;  &gt; SsdDetector::Detect(const cv::Mat&amp; img)
 }
 
 
-void SsdDetector::SetMean(const cv::Scalar&amp; in_mean_value)
+void SSDDetector::SetMean(const cv::Scalar&amp; in_mean_value)
 {
 	mean_ = in_mean_value;
 }
@@ -115,7 +115,7 @@ void SsdDetector::SetMean(const cv::Scalar&amp; in_mean_value)
  * don't need to rely on cudaMemcpy2D. The last preprocessing
  * operation will write the separate channels directly to the input
  * layer. */
-void SsdDetector::WrapInputLayer(std::vector&lt;cv::Mat&gt;* input_channels)
+void SSDDetector::WrapInputLayer(std::vector&lt;cv::Mat&gt;* input_channels)
 {
 	caffe::Blob&lt;float&gt;* input_layer = net_-&gt;input_blobs()[0];
 
@@ -130,7 +130,7 @@ void SsdDetector::WrapInputLayer(std::vector&lt;cv::Mat&gt;* input_channels)
 	}
 }
 
-void SsdDetector::Preprocess(const cv::Mat&amp; img,
+void SSDDetector::Preprocess(const cv::Mat&amp; img,
 		std::vector&lt;cv::Mat&gt;* input_channels)
 {
 	/* Convert the input image to the input image format of the network. */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" added_lines="11" deleted_lines="11">
				<diff>@@ -32,7 +32,7 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include "autoware_config_msgs/ConfigSsd.h"
+#include "autoware_config_msgs/ConfigSSD.h"
 #include "autoware_msgs/DetectedObject.h"
 #include "autoware_msgs/DetectedObjectArray.h"
 
@@ -49,7 +49,7 @@
 
 #include "vision_ssd_detect.h"
 
-class RosSsdApp
+class RosSSDApp
 {
 	ros::Subscriber subscriber_image_raw_;
 	ros::Subscriber subscriber_ssd_config_;
@@ -60,7 +60,7 @@ class RosSsdApp
     std::vector&lt;cv::Scalar&gt; colors_;
 
 	//Caffe based Object Detection ConvNet
-	SsdDetector* ssd_detector_;
+	SSDDetector* ssd_detector_;
 
 	//The minimum score required to filter the detected objects by the ConvNet
 	float score_threshold_;
@@ -130,7 +130,7 @@ class RosSsdApp
 	}
 
 
-	void config_cb(const autoware_config_msgs::ConfigSsd::ConstPtr&amp; param)
+	void config_cb(const autoware_config_msgs::ConfigSSD::ConstPtr&amp; param)
 	{
 		score_threshold_ 	= param-&gt;score_threshold;
 	}
@@ -192,7 +192,7 @@ public:
 		}
 
 		//SSD STUFF
-		ssd_detector_ = new SsdDetector(network_definition_file, pretrained_model_file, pixel_mean_, use_gpu_, gpu_device_id_);
+		ssd_detector_ = new SSDDetector(network_definition_file, pretrained_model_file, pixel_mean_, use_gpu_, gpu_device_id_);
 
 		if (NULL == ssd_detector_)
 		{
@@ -210,24 +210,24 @@ public:
         publisher_detected_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/vision_objects", 1);
 
 		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
-		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosSsdApp::image_callback, this);
+		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosSSDApp::image_callback, this);
 
 		std::string config_topic("/config");
 		config_topic += "/ssd";
-		subscriber_ssd_config_ = node_handle_.subscribe(config_topic, 1, &amp;RosSsdApp::config_cb, this);
+		subscriber_ssd_config_ = node_handle_.subscribe(config_topic, 1, &amp;RosSSDApp::config_cb, this);
 
 		ros::spin();
-		ROS_INFO("END Ssd");
+		ROS_INFO("END SSD");
 
 	}
 
-	~RosSsdApp()
+	~RosSSDApp()
 	{
 		if (NULL != ssd_detector_)
 			delete ssd_detector_;
 	}
 
-	RosSsdApp()
+	RosSSDApp()
 	{
 		ssd_detector_ 	= NULL;
 		score_threshold_= 0.5;
@@ -241,7 +241,7 @@ int main(int argc, char **argv)
 {
 	ros::init(argc, argv, "ssd_unc");
 
-	RosSsdApp app;
+	RosSSDApp app;
 
 	app.Run();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7347560cc1cfdaea30d2c1ec1acc35f3434d5d0d" author="Esteve Fernandez">
		<msg>Fix Ndt/NDT naming convention</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\approximate_ndt_mapping\approximate_ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\approximate_ndt_mapping\approximate_ndt_mapping.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -66,8 +66,8 @@
 #include &lt;pcl/registration/ndt.h&gt;
 #endif
 
-#include &lt;autoware_config_msgs/ConfigApproximateNdtMapping.h&gt;
-#include &lt;autoware_config_msgs/ConfigNdtMappingOutput.h&gt;
+#include &lt;autoware_config_msgs/ConfigApproximateNDTMapping.h&gt;
+#include &lt;autoware_config_msgs/ConfigNDTMappingOutput.h&gt;
 
 struct pose
 {
@@ -157,7 +157,7 @@ static nav_msgs::Odometry odom;
 static std::ofstream ofs;
 static std::string filename;
 
-static void param_callback(const autoware_config_msgs::ConfigApproximateNdtMapping::ConstPtr&amp; input)
+static void param_callback(const autoware_config_msgs::ConfigApproximateNDTMapping::ConstPtr&amp; input)
 {
   ndt_res = input-&gt;resolution;
   step_size = input-&gt;step_size;
@@ -181,7 +181,7 @@ static void param_callback(const autoware_config_msgs::ConfigApproximateNdtMappi
   std::cout &lt;&lt; "max_submap_size: " &lt;&lt; max_submap_size &lt;&lt; std::endl;
 }
 
-static void output_callback(const autoware_config_msgs::ConfigNdtMappingOutput::ConstPtr&amp; input)
+static void output_callback(const autoware_config_msgs::ConfigNDTMappingOutput::ConstPtr&amp; input)
 {
   double filter_res = input-&gt;filter_res;
   std::string filename = input-&gt;filename;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\lazy_ndt_mapping\lazy_ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\lazy_ndt_mapping\lazy_ndt_mapping.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -65,8 +65,8 @@
 #include &lt;pcl/filters/voxel_grid.h&gt;
 #endif
 
-#include "autoware_config_msgs/ConfigNdtMapping.h"
-#include "autoware_config_msgs/ConfigNdtMappingOutput.h"
+#include "autoware_config_msgs/ConfigNDTMapping.h"
+#include "autoware_config_msgs/ConfigNDTMappingOutput.h"
 
 struct pose {
     double x;
@@ -125,7 +125,7 @@ static bool _use_openmp = false;
 
 static double fitness_score;
 
-static void param_callback(const autoware_config_msgs::ConfigNdtMapping::ConstPtr&amp; input)
+static void param_callback(const autoware_config_msgs::ConfigNDTMapping::ConstPtr&amp; input)
 {
   ndt_res = input-&gt;resolution;
   step_size = input-&gt;step_size;
@@ -145,7 +145,7 @@ static void param_callback(const autoware_config_msgs::ConfigNdtMapping::ConstPt
   std::cout &lt;&lt; "min_add_scan_shift: " &lt;&lt; min_add_scan_shift &lt;&lt; std::endl;
 }
 
-static void output_callback(const autoware_config_msgs::ConfigNdtMappingOutput::ConstPtr&amp; input)
+static void output_callback(const autoware_config_msgs::ConfigNDTMappingOutput::ConstPtr&amp; input)
 {
   double filter_res = input-&gt;filter_res;
   std::string filename = input-&gt;filename;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -67,8 +67,8 @@
 #include &lt;pcl_omp_registration/ndt.h&gt;
 #endif
 
-#include &lt;autoware_config_msgs/ConfigNdtMapping.h&gt;
-#include &lt;autoware_config_msgs/ConfigNdtMappingOutput.h&gt;
+#include &lt;autoware_config_msgs/ConfigNDTMapping.h&gt;
+#include &lt;autoware_config_msgs/ConfigNDTMappingOutput.h&gt;
 
 #include &lt;time.h&gt;
 
@@ -176,7 +176,7 @@ static nav_msgs::Odometry odom;
 static std::ofstream ofs;
 static std::string filename;
 
-static void param_callback(const autoware_config_msgs::ConfigNdtMapping::ConstPtr&amp; input)
+static void param_callback(const autoware_config_msgs::ConfigNDTMapping::ConstPtr&amp; input)
 {
   ndt_res = input-&gt;resolution;
   step_size = input-&gt;step_size;
@@ -198,7 +198,7 @@ static void param_callback(const autoware_config_msgs::ConfigNdtMapping::ConstPt
   std::cout &lt;&lt; "min_add_scan_shift: " &lt;&lt; min_add_scan_shift &lt;&lt; std::endl;
 }
 
-static void output_callback(const autoware_config_msgs::ConfigNdtMappingOutput::ConstPtr&amp; input)
+static void output_callback(const autoware_config_msgs::ConfigNDTMappingOutput::ConstPtr&amp; input)
 {
   double filter_res = input-&gt;filter_res;
   std::string filename = input-&gt;filename;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -77,7 +77,7 @@
 #include &lt;pcl_ros/point_cloud.h&gt;
 #include &lt;pcl_ros/transforms.h&gt;
 
-#include &lt;autoware_config_msgs/ConfigNdt.h&gt;
+#include &lt;autoware_config_msgs/ConfigNDT.h&gt;
 
 #include &lt;autoware_msgs/NDTStat.h&gt;
 
@@ -243,7 +243,7 @@ static unsigned int points_map_num = 0;
 
 pthread_mutex_t mutex;
 
-static void param_callback(const autoware_config_msgs::ConfigNdt::ConstPtr&amp; input)
+static void param_callback(const autoware_config_msgs::ConfigNDT::ConstPtr&amp; input)
 {
   if (_use_gnss != input-&gt;init_pos_gnss)
   {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.cpp" added_lines="11" deleted_lines="11">
				<diff>@@ -35,7 +35,7 @@
 
 #include "ndt_matching_monitor.h"
 
-void RosNdtMatchingMonitor::gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
+void RosNDTMatchingMonitor::gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
 {
     gnss_pose_.header = input-&gt;header;
     gnss_pose_.pose.pose = input-&gt;pose;
@@ -43,7 +43,7 @@ void RosNdtMatchingMonitor::gnss_callback(const geometry_msgs::PoseStamped::Cons
     gnss_text_ = " - GNSS available";
 }
 
-void RosNdtMatchingMonitor::ndt_stat_callback(const autoware_msgs::NDTStat::ConstPtr&amp; input)
+void RosNDTMatchingMonitor::ndt_stat_callback(const autoware_msgs::NDTStat::ConstPtr&amp; input)
 {
     iteration_count_ = input-&gt;iteration;
 
@@ -55,7 +55,7 @@ void RosNdtMatchingMonitor::ndt_stat_callback(const autoware_msgs::NDTStat::Cons
 }
 
 geometry_msgs::PoseWithCovarianceStamped
-                RosNdtMatchingMonitor::predict_next_pose(geometry_msgs::PoseWithCovarianceStamped prev_pose,
+                RosNDTMatchingMonitor::predict_next_pose(geometry_msgs::PoseWithCovarianceStamped prev_pose,
                                                          geometry_msgs::PoseWithCovarianceStamped current_pose)
 {
     geometry_msgs::PoseWithCovarianceStamped predicted_pose;
@@ -82,7 +82,7 @@ geometry_msgs::PoseWithCovarianceStamped
 
 }
 
-void RosNdtMatchingMonitor::initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input)
+void RosNDTMatchingMonitor::initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input)
 {
     //if currently blocking reset and receiving a different blocking pose, then try to reset
     if (ndt_status::NDT_FATAL == ndt_status_
@@ -102,7 +102,7 @@ void RosNdtMatchingMonitor::initialpose_callback(const geometry_msgs::PoseWithCo
     }
 }
 
-void RosNdtMatchingMonitor::ndt_pose_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
+void RosNDTMatchingMonitor::ndt_pose_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
 {
     geometry_msgs::PoseWithCovarianceStamped initialpose_msg;
     initialpose_msg.header = input-&gt;header;
@@ -207,7 +207,7 @@ void RosNdtMatchingMonitor::ndt_pose_callback(const geometry_msgs::PoseStamped::
     last_score_ = current_score_;
 }
 
-void RosNdtMatchingMonitor::Run()
+void RosNDTMatchingMonitor::Run()
 {
     ros::NodeHandle nh;
     ros::NodeHandle private_nh("~");
@@ -228,10 +228,10 @@ void RosNdtMatchingMonitor::Run()
     }
 
     // Subscribers
-    ros::Subscriber ndt_stat_sub = nh.subscribe("/ndt_stat", 10, &amp;RosNdtMatchingMonitor::ndt_stat_callback, this);
-    ros::Subscriber ndt_pose_sub = nh.subscribe("/ndt_pose", 10, &amp;RosNdtMatchingMonitor::ndt_pose_callback, this);
-    ros::Subscriber initial_pose_sub = nh.subscribe("/initialpose", 10, &amp;RosNdtMatchingMonitor::initialpose_callback, this);
-    ros::Subscriber gnss_sub = nh.subscribe("gnss_pose", 10, &amp;RosNdtMatchingMonitor::gnss_callback, this);
+    ros::Subscriber ndt_stat_sub = nh.subscribe("/ndt_stat", 10, &amp;RosNDTMatchingMonitor::ndt_stat_callback, this);
+    ros::Subscriber ndt_pose_sub = nh.subscribe("/ndt_pose", 10, &amp;RosNDTMatchingMonitor::ndt_pose_callback, this);
+    ros::Subscriber initial_pose_sub = nh.subscribe("/initialpose", 10, &amp;RosNDTMatchingMonitor::initialpose_callback, this);
+    ros::Subscriber gnss_sub = nh.subscribe("gnss_pose", 10, &amp;RosNDTMatchingMonitor::gnss_callback, this);
 
     // Publishers
     initialpose_pub_ = nh.advertise&lt;geometry_msgs::PoseWithCovarianceStamped&gt;("/initialpose", 1);
@@ -242,7 +242,7 @@ void RosNdtMatchingMonitor::Run()
 
 }
 
-RosNdtMatchingMonitor::RosNdtMatchingMonitor()
+RosNDTMatchingMonitor::RosNDTMatchingMonitor()
 {
     gnss_pose_available_ = false;
     last_score_     = 0.0;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.h" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.h" added_lines="3" deleted_lines="3">
				<diff>@@ -67,7 +67,7 @@
 
 #include &lt;autoware_msgs/NDTStat.h&gt;
 
-#define __APP_NAME__ "RosNdtMatchingMonitor"
+#define __APP_NAME__ "RosNDTMatchingMonitor"
 
 #define NDT_THRESHOLD_ITERATION_WARN 10
 #define NDT_THRESHOLD_ITERATION_STOP 32
@@ -75,7 +75,7 @@
 #define NDT_MIN_STABLE_SAMPLES 30
 #define NDT_TIME_TO_FATAL_PREDICTIONS 2.
 
-class RosNdtMatchingMonitor
+class RosNDTMatchingMonitor
 {
 	enum ndt_status{
 		NDT_NOT_INITIALIZED,
@@ -153,7 +153,7 @@ class RosNdtMatchingMonitor
 	void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input);
 public:
 	void Run();
-	RosNdtMatchingMonitor();
+	RosNDTMatchingMonitor();
 };
 
 #endif //PROJECT_NDT_MATCHING_MONITOR_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor_node.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -40,7 +40,7 @@ int main(int argc, char **argv)
 {
 	ros::init(argc, argv, __APP_NAME__);
 
-	RosNdtMatchingMonitor app;
+	RosNDTMatchingMonitor app;
 
 	app.Run();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2776c18fcbdf01f01a846be4a5e5aae2616b08d8" author="Esteve Fernandez">
		<msg>Fix Dpm/DPM naming convention</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\nodes\vision_dpm_ttic_detect\vision_dpm_ttic_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\nodes\vision_dpm_ttic_detect\vision_dpm_ttic_detect.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -37,7 +37,7 @@
 #include &lt;sensor_msgs/image_encodings.h&gt;
 
 #include "autoware_msgs/ImageObj.h"
-#include "autoware_config_msgs/ConfigPedestrianDpm.h"
+#include "autoware_config_msgs/ConfigPedestrianDPM.h"
 
 #include &lt;libdpm_ttic/dpm_ttic.hpp&gt;
 
@@ -109,7 +109,7 @@ static void image_raw_cb(const sensor_msgs::Image&amp; image_source)
 	counter++;
 }
 
-static void config_cb(const autoware_config_msgs::ConfigPedestrianDpm::ConstPtr&amp; param)
+static void config_cb(const autoware_config_msgs::ConfigPedestrianDPM::ConstPtr&amp; param)
 {
 	ttic_param.threshold = param-&gt;score_threshold;
 	ttic_param.overlap   = param-&gt;group_threshold;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cbe06644a031611a0beee91ffc07a548de72bde0" author="Esteve Fernandez">
		<msg>Fix Kf/KF naming convention</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_track\include\lidar_kf_track.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_track\include\lidar_kf_track.h" added_lines="3" deleted_lines="3">
				<diff>@@ -82,7 +82,7 @@ public:
 };
 
 // --------------------------------------------------------------------------
-class KfLidarTracker {
+class KFLidarTracker {
   typedef boost::geometry::model::d2::point_xy&lt;double&gt; boost_point_xy;
   typedef boost::geometry::model::polygon&lt;
       boost::geometry::model::d2::point_xy&lt;double&gt;&gt;
@@ -113,12 +113,12 @@ class KfLidarTracker {
                                boost_polygon &amp;out_polygon);
 
 public:
-  KfLidarTracker(float in_time_delta, float accel_noise_mag,
+  KFLidarTracker(float in_time_delta, float accel_noise_mag,
                  float dist_thres = 3, float tracker_merging_threshold = 2,
                  size_t maximum_allowed_skipped_frames = 10,
                  size_t max_trace_length = 10, bool in_pose_estimation = false,
                  size_t maximum_track_id = 200);
-  ~KfLidarTracker(void);
+  ~KFLidarTracker(void);
 
   enum DistType { CentersDist = 0, RectsDist = 1 };
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_track\nodes\lidar_kf_track\lidar_kf_track.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_track\nodes\lidar_kf_track\lidar_kf_track.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -3,7 +3,7 @@
 // ---------------------------------------------------------------------------
 // Tracker. Manage tracks. Create, remove, update.
 // ---------------------------------------------------------------------------
-KfLidarTracker::KfLidarTracker(float in_time_delta,
+KFLidarTracker::KFLidarTracker(float in_time_delta,
 		float in_acceleration_noise_magnitude,
 		float in_distance_threshold,
 		float in_tracker_merging_threshold,
@@ -23,7 +23,7 @@ KfLidarTracker::KfLidarTracker(float in_time_delta,
 {
 }
 
-void KfLidarTracker::CreatePolygonFromPoints(const geometry_msgs::Polygon&amp; in_points, boost_polygon&amp; out_polygon)
+void KFLidarTracker::CreatePolygonFromPoints(const geometry_msgs::Polygon&amp; in_points, boost_polygon&amp; out_polygon)
 {
 	std::vector&lt; boost_point_xy &gt; hull_detection_points;
 
@@ -37,7 +37,7 @@ void KfLidarTracker::CreatePolygonFromPoints(const geometry_msgs::Polygon&amp; in_po
 	boost::geometry::assign_points(out_polygon, hull_detection_points);
 }
 
-void KfLidarTracker::Update(const autoware_msgs::CloudClusterArray&amp; in_cloud_cluster_array, DistType in_match_method)
+void KFLidarTracker::Update(const autoware_msgs::CloudClusterArray&amp; in_cloud_cluster_array, DistType in_match_method)
 {
 	size_t num_detections = in_cloud_cluster_array.clusters.size();
 	size_t num_tracks = tracks_.size();
@@ -201,7 +201,7 @@ void KfLidarTracker::Update(const autoware_msgs::CloudClusterArray&amp; in_cloud_clu
 
 }
 
-void KfLidarTracker::CheckTrackerMerge(size_t in_tracker_id, std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector&lt;bool&gt;&amp; in_out_visited_trackers, std::vector&lt;size_t&gt;&amp; out_merge_indices, double in_merge_threshold)
+void KFLidarTracker::CheckTrackerMerge(size_t in_tracker_id, std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector&lt;bool&gt;&amp; in_out_visited_trackers, std::vector&lt;size_t&gt;&amp; out_merge_indices, double in_merge_threshold)
 {
 	for(size_t i=0; i&lt; in_trackers.size(); i++)
 	{
@@ -229,7 +229,7 @@ void KfLidarTracker::CheckTrackerMerge(size_t in_tracker_id, std::vector&lt;CTrack&gt;
 	}
 }
 
-void KfLidarTracker::MergeTrackers(std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector&lt;CTrack&gt;&amp; out_trackers, std::vector&lt;size_t&gt; in_merge_indices, const size_t&amp; current_index, std::vector&lt;bool&gt;&amp; in_out_merged_trackers)
+void KFLidarTracker::MergeTrackers(std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector&lt;CTrack&gt;&amp; out_trackers, std::vector&lt;size_t&gt; in_merge_indices, const size_t&amp; current_index, std::vector&lt;bool&gt;&amp; in_out_merged_trackers)
 {
 	size_t oldest_life =0;
 	size_t oldest_index = 0;
@@ -260,7 +260,7 @@ void KfLidarTracker::MergeTrackers(std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector
 	//out_trackers.back().cluster = in_trackers[largest_index].GetCluster();
 }
 
-void KfLidarTracker::CheckAllTrackersForMerge(std::vector&lt;CTrack&gt;&amp; out_trackers)
+void KFLidarTracker::CheckAllTrackersForMerge(std::vector&lt;CTrack&gt;&amp; out_trackers)
 {
 	//std::cout &lt;&lt; "checkAllForMerge" &lt;&lt; std::endl;
 	std::vector&lt;bool&gt; visited_trackers(tracks_.size(), false);
@@ -289,7 +289,7 @@ void KfLidarTracker::CheckAllTrackersForMerge(std::vector&lt;CTrack&gt;&amp; out_trackers)
 // ---------------------------------------------------------------------------
 //
 // ---------------------------------------------------------------------------
-/*void KfLidarTracker::Update(
+/*void KFLidarTracker::Update(
 	const autoware_msgs::CloudClusterArray&amp; in_cloud_cluster_array,
 	DistType distType
 	)
@@ -434,6 +434,6 @@ void KfLidarTracker::CheckAllTrackersForMerge(std::vector&lt;CTrack&gt;&amp; out_trackers)
 // ---------------------------------------------------------------------------
 //
 // ---------------------------------------------------------------------------
-KfLidarTracker::~KfLidarTracker(void)
+KFLidarTracker::~KFLidarTracker(void)
 {
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_track\nodes\lidar_kf_track\lidar_kf_track_core.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_track\nodes\lidar_kf_track\lidar_kf_track_core.cpp" added_lines="11" deleted_lines="11">
				<diff>@@ -24,11 +24,11 @@
 
 #include "lidar_kf_track.h"
 
-class KfLidarTrackNode
+class KFLidarTrackNode
 {
 public:
-	KfLidarTrackNode();
-	~KfLidarTrackNode();
+	KFLidarTrackNode();
+	~KFLidarTrackNode();
 
 private:
 
@@ -44,7 +44,7 @@ private:
 	int keep_alive_;
 	int maximum_track_id_;
 
-	boost::shared_ptr&lt;KfLidarTracker&gt; tracker_ptr;
+	boost::shared_ptr&lt;KFLidarTracker&gt; tracker_ptr;
 
 	double distance_matching_threshold_;
 	double tracker_merging_threshold_;
@@ -52,11 +52,11 @@ private:
 	void CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr);
 };
 
-KfLidarTrackNode::KfLidarTrackNode() :
+KFLidarTrackNode::KFLidarTrackNode() :
 		node_handle_("~"),
 		pose_estimation_(false)
 {
-	cloud_clusters_sub_ = node_handle_.subscribe("/cloud_clusters_class", 10, &amp;KfLidarTrackNode::CloudClustersCallback, this);
+	cloud_clusters_sub_ = node_handle_.subscribe("/cloud_clusters_class", 10, &amp;KFLidarTrackNode::CloudClustersCallback, this);
 	pub_detected_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;( "/detected_objects", 10);
 	pub_jsk_tracked_objects_ = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/bounding_boxes_tracked",1);
 	pub_jsk_hulls_ = node_handle_.advertise&lt;jsk_recognition_msgs::PolygonArray&gt;("/cluster_hulls_tracked",1);
@@ -75,7 +75,7 @@ KfLidarTrackNode::KfLidarTrackNode() :
 
 
 
-	tracker_ptr = boost::shared_ptr&lt;KfLidarTracker&gt;(new KfLidarTracker(0.2f,  //dt
+	tracker_ptr = boost::shared_ptr&lt;KFLidarTracker&gt;(new KFLidarTracker(0.2f,  //dt
 							0.1f, 			//acceleration_noise
 							distance_matching_threshold_, 			//matching distance threshold
 							tracker_merging_threshold_, //tracker merging threshold
@@ -84,11 +84,11 @@ KfLidarTrackNode::KfLidarTrackNode() :
 							maximum_track_id_));			//trace length
 }
 
-KfLidarTrackNode::~KfLidarTrackNode()
+KFLidarTrackNode::~KFLidarTrackNode()
 {
 }
 
-void KfLidarTrackNode::CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr)
+void KFLidarTrackNode::CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr)
 {
 
 	autoware_msgs::CloudClusterArray final_cloud_cluster_array;
@@ -97,7 +97,7 @@ void KfLidarTrackNode::CloudClustersCallback(const autoware_msgs::CloudClusterAr
 
 
 	//std::cout &lt;&lt; "Update start" &lt;&lt; std::endl;
-	tracker_ptr-&gt;Update(*in_cloud_cluster_array_ptr, KfLidarTracker::CentersDist);
+	tracker_ptr-&gt;Update(*in_cloud_cluster_array_ptr, KFLidarTracker::CentersDist);
 	//std::cout &lt;&lt; "Update end" &lt;&lt; std::endl;
 
 	jsk_recognition_msgs::BoundingBoxArray tracked_boxes;
@@ -172,7 +172,7 @@ int main(int argc, char **argv)
 {
 
 	ros::init(argc, argv, "kf_lidar_track");
-	KfLidarTrackNode node;
+	KFLidarTrackNode node;
 	ros::spin();
 
 	return 0;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\libs\kf\src\kf_lib.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\libs\kf\src\kf_lib.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -37,7 +37,7 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;autoware_config_msgs/ConfigCarKf.h&gt;
+#include &lt;autoware_config_msgs/ConfigCarKF.h&gt;
 #include &lt;autoware_msgs/ImageObjRanged.h&gt;
 
 #include &lt;autoware_msgs/ImageObjTracked.h&gt;
@@ -918,7 +918,7 @@ void detections_callback(autoware_msgs::ImageObjRanged image_objects_msg)
 	publish_if_possible();
 }
 
-static void kf_config_cb(const autoware_config_msgs::ConfigCarKf::ConstPtr&amp; param)
+static void kf_config_cb(const autoware_config_msgs::ConfigCarKF::ConstPtr&amp; param)
 {
 	if (param-&gt;initial_lifespan &gt; 0)
 		INITIAL_LIFESPAN	= param-&gt;initial_lifespan;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\MapObjectSerialization.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\MapObjectSerialization.h" added_lines="6" deleted_lines="6">
				<diff>@@ -478,8 +478,8 @@ void save (Archive &amp; ar, const MapPoint &amp;mapPoint, const unsigned int version)
 		mapPoint.mNormalVector &amp;
 		mapPoint.mDescriptor;
 
-	int refKfId = (mapPoint.mpRefKF==NULL ? -1 : mapPoint.mpRefKF-&gt;mnId);
-	ar &amp; refKfId;
+	int refKFId = (mapPoint.mpRefKF==NULL ? -1 : mapPoint.mpRefKF-&gt;mnId);
+	ar &amp; refKFId;
 
 	ar &amp;
 		mapPoint.mnVisible &amp;
@@ -531,8 +531,8 @@ void load (Archive &amp; ar, MapPoint &amp;mapPoint, const unsigned int version)
 		mapPoint.mNormalVector &amp;
 		mapPoint.mDescriptor;
 
-	int refKfId;
-	ar &amp; refKfId;
+	int refKFId;
+	ar &amp; refKFId;
 
 	ar &amp;
 		mapPoint.mnVisible &amp;
@@ -550,9 +550,9 @@ void load (Archive &amp; ar, MapPoint &amp;mapPoint, const unsigned int version)
 	// saving part
 	MapPoint::mpReplacement[mapPoint.mnId] = _mpReplaced;
 	mapPoint.mObservations = createObjectList&lt;KeyFrame&gt; (kfObservation);
-	mapPoint.mpRefKF = (refKfId==-1 ?
+	mapPoint.mpRefKF = (refKFId==-1 ?
 			NULL :
-			KeyFrame::objectListLookup[refKfId]);
+			KeyFrame::objectListLookup[refKFId]);
 	MapPoint::objectListLookup[mapPoint.mnId] = &amp;mapPoint;
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="db543c0d0ec8613ede76c1b03d7779de3473822c" author="Esteve Fernandez">
		<msg>Fix Ros/ROS naming convention</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\pixel_cloud_fusion\include\pixel_cloud_fusion\pixel_cloud_fusion.h" new_path="ros\src\computing\perception\detection\fusion_tools\packages\pixel_cloud_fusion\include\pixel_cloud_fusion\pixel_cloud_fusion.h" added_lines="3" deleted_lines="3">
				<diff>@@ -82,7 +82,7 @@ namespace std {
 	};
 };
 
-class RosPixelCloudFusionApp
+class ROSPixelCloudFusionApp
 {
 	ros::NodeHandle                     node_handle_;
 	ros::Publisher                      publisher_fused_cloud_;
@@ -133,11 +133,11 @@ class RosPixelCloudFusionApp
 	 * Reads the config params from the command line
 	 * @param in_private_handle
 	 */
-	void InitializeRosIo(ros::NodeHandle &amp;in_private_handle);
+	void InitializeROSIo(ros::NodeHandle &amp;in_private_handle);
 
 public:
 	void Run();
-	RosPixelCloudFusionApp();
+	ROSPixelCloudFusionApp();
 };
 
 #endif //PROJECT_PIXEL_CLOUD_FUSION_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\pixel_cloud_fusion\src\pixel_cloud_fusion.cpp" new_path="ros\src\computing\perception\detection\fusion_tools\packages\pixel_cloud_fusion\src\pixel_cloud_fusion.cpp" added_lines="12" deleted_lines="12">
				<diff>@@ -38,14 +38,14 @@
 #include "pixel_cloud_fusion/pixel_cloud_fusion.h"
 
 pcl::PointXYZ
-RosPixelCloudFusionApp::TransformPoint(const pcl::PointXYZ &amp;in_point, const tf::StampedTransform &amp;in_transform)
+ROSPixelCloudFusionApp::TransformPoint(const pcl::PointXYZ &amp;in_point, const tf::StampedTransform &amp;in_transform)
 {
 	tf::Vector3 tf_point(in_point.x, in_point.y, in_point.z);
 	tf::Vector3 tf_point_t = in_transform * tf_point;
 	return pcl::PointXYZ(tf_point_t.x(), tf_point_t.y(), tf_point_t.z());
 }
 
-void RosPixelCloudFusionApp::ImageCallback(const sensor_msgs::Image::ConstPtr &amp;in_image_msg)
+void ROSPixelCloudFusionApp::ImageCallback(const sensor_msgs::Image::ConstPtr &amp;in_image_msg)
 {
 	if (!camera_info_ok_)
 	{
@@ -66,7 +66,7 @@ void RosPixelCloudFusionApp::ImageCallback(const sensor_msgs::Image::ConstPtr &amp;i
 	image_size_.width = current_frame_.cols;
 }
 
-void RosPixelCloudFusionApp::CloudCallback(const sensor_msgs::PointCloud2::ConstPtr &amp;in_cloud_msg)
+void ROSPixelCloudFusionApp::CloudCallback(const sensor_msgs::PointCloud2::ConstPtr &amp;in_cloud_msg)
 {
 	if (current_frame_.empty() || image_frame_id_ == "")
 	{
@@ -136,7 +136,7 @@ void RosPixelCloudFusionApp::CloudCallback(const sensor_msgs::PointCloud2::Const
 	publisher_fused_cloud_.publish(cloud_msg);
 }
 
-void RosPixelCloudFusionApp::IntrinsicsCallback(const sensor_msgs::CameraInfo &amp;in_message)
+void ROSPixelCloudFusionApp::IntrinsicsCallback(const sensor_msgs::CameraInfo &amp;in_message)
 {
 	image_size_.height = in_message.height;
 	image_size_.width = in_message.width;
@@ -167,7 +167,7 @@ void RosPixelCloudFusionApp::IntrinsicsCallback(const sensor_msgs::CameraInfo &amp;i
 }
 
 tf::StampedTransform
-RosPixelCloudFusionApp::FindTransform(const std::string &amp;in_target_frame, const std::string &amp;in_source_frame)
+ROSPixelCloudFusionApp::FindTransform(const std::string &amp;in_target_frame, const std::string &amp;in_source_frame)
 {
 	tf::StampedTransform transform;
 
@@ -186,7 +186,7 @@ RosPixelCloudFusionApp::FindTransform(const std::string &amp;in_target_frame, const
 	return transform;
 }
 
-void RosPixelCloudFusionApp::InitializeRosIo(ros::NodeHandle &amp;in_private_handle)
+void ROSPixelCloudFusionApp::InitializeROSIo(ros::NodeHandle &amp;in_private_handle)
 {
 	//get params
 	std::string points_src, image_src, camera_info_src, fused_topic_str = "/points_fused";
@@ -217,16 +217,16 @@ void RosPixelCloudFusionApp::InitializeRosIo(ros::NodeHandle &amp;in_private_handle)
 	ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, camera_info_src.c_str());
 	intrinsics_subscriber_ = in_private_handle.subscribe(camera_info_src,
 	                                                     1,
-	                                                     &amp;RosPixelCloudFusionApp::IntrinsicsCallback, this);
+	                                                     &amp;ROSPixelCloudFusionApp::IntrinsicsCallback, this);
 
 	ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, image_src.c_str());
 	cloud_subscriber_ = in_private_handle.subscribe(image_src,
 	                                                1,
-	                                                &amp;RosPixelCloudFusionApp::ImageCallback, this);
+	                                                &amp;ROSPixelCloudFusionApp::ImageCallback, this);
 	ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, points_src.c_str());
 	image_subscriber_ = in_private_handle.subscribe(points_src,
 	                                                1,
-	                                                &amp;RosPixelCloudFusionApp::CloudCallback, this);
+	                                                &amp;ROSPixelCloudFusionApp::CloudCallback, this);
 
 	publisher_fused_cloud_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(fused_topic_str, 1);
 	ROS_INFO("[%s] Publishing fused pointcloud in %s", __APP_NAME__, fused_topic_str.c_str());
@@ -234,14 +234,14 @@ void RosPixelCloudFusionApp::InitializeRosIo(ros::NodeHandle &amp;in_private_handle)
 }
 
 
-void RosPixelCloudFusionApp::Run()
+void ROSPixelCloudFusionApp::Run()
 {
 	ros::NodeHandle private_node_handle("~");
 	tf::TransformListener transform_listener;
 
 	transform_listener_ = &amp;transform_listener;
 
-	InitializeRosIo(private_node_handle);
+	InitializeROSIo(private_node_handle);
 
 	ROS_INFO("[%s] Ready. Waiting for data...", __APP_NAME__);
 
@@ -250,7 +250,7 @@ void RosPixelCloudFusionApp::Run()
 	ROS_INFO("[%s] END", __APP_NAME__);
 }
 
-RosPixelCloudFusionApp::RosPixelCloudFusionApp()
+ROSPixelCloudFusionApp::ROSPixelCloudFusionApp()
 {
 	camera_lidar_tf_ok_ = false;
 	camera_info_ok_ = false;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\pixel_cloud_fusion\src\pixel_cloud_fusion_node.cpp" new_path="ros\src\computing\perception\detection\fusion_tools\packages\pixel_cloud_fusion\src\pixel_cloud_fusion_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -40,7 +40,7 @@ int main(int argc, char **argv)
 {
 	ros::init(argc, argv, __APP_NAME__);
 
-	RosPixelCloudFusionApp app;
+	ROSPixelCloudFusionApp app;
 
 	app.Run();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\include\range_vision_fusion\range_vision_fusion.h" new_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\include\range_vision_fusion\range_vision_fusion.h" added_lines="3" deleted_lines="3">
				<diff>@@ -70,7 +70,7 @@
 
 #include "autoware_msgs/DetectedObjectArray.h"
 
-class RosRangeVisionFusionApp
+class ROSRangeVisionFusionApp
 {
     ros::NodeHandle                     node_handle_;
     ros::Publisher                      publisher_fused_objects_;
@@ -177,11 +177,11 @@ class RosRangeVisionFusionApp
      * Reads the config params from the command line
      * @param in_private_handle
      */
-    void InitializeRosIo(ros::NodeHandle &amp;in_private_handle);
+    void InitializeROSIo(ros::NodeHandle &amp;in_private_handle);
 
 public:
     void Run();
-    RosRangeVisionFusionApp();
+    ROSRangeVisionFusionApp();
 };
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\src\range_vision_fusion.cpp" new_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\src\range_vision_fusion.cpp" added_lines="27" deleted_lines="27">
				<diff>@@ -37,7 +37,7 @@
 #include "range_vision_fusion/range_vision_fusion.h"
 
 cv::Point3f
-RosRangeVisionFusionApp::TransformPoint(const geometry_msgs::Point &amp;in_point, const tf::StampedTransform &amp;in_transform)
+ROSRangeVisionFusionApp::TransformPoint(const geometry_msgs::Point &amp;in_point, const tf::StampedTransform &amp;in_transform)
 {
     tf::Vector3 tf_point(in_point.x, in_point.y, in_point.z);
     tf::Vector3 tf_point_t = in_transform * tf_point;
@@ -45,7 +45,7 @@ RosRangeVisionFusionApp::TransformPoint(const geometry_msgs::Point &amp;in_point, co
 }
 
 cv::Point2i
-RosRangeVisionFusionApp::ProjectPoint(const cv::Point3f &amp;in_point)
+ROSRangeVisionFusionApp::ProjectPoint(const cv::Point3f &amp;in_point)
 {
     auto u = int(in_point.x * fx_ / in_point.z + cx_);
     auto v = int(in_point.y * fy_ / in_point.z + cy_);
@@ -54,7 +54,7 @@ RosRangeVisionFusionApp::ProjectPoint(const cv::Point3f &amp;in_point)
 }
 
 autoware_msgs::DetectedObject
-RosRangeVisionFusionApp::TransformObject(const autoware_msgs::DetectedObject &amp;in_detection,
+ROSRangeVisionFusionApp::TransformObject(const autoware_msgs::DetectedObject &amp;in_detection,
                                                                        const tf::StampedTransform&amp; in_transform)
 {
     autoware_msgs::DetectedObject t_obj = in_detection;
@@ -83,7 +83,7 @@ RosRangeVisionFusionApp::TransformObject(const autoware_msgs::DetectedObject &amp;in
 }
 
 bool
-RosRangeVisionFusionApp::IsObjectInImage(const autoware_msgs::DetectedObject &amp;in_detection)
+ROSRangeVisionFusionApp::IsObjectInImage(const autoware_msgs::DetectedObject &amp;in_detection)
 {
     cv::Point3f image_space_point = TransformPoint(in_detection.pose.position, camera_lidar_tf_);
 
@@ -96,7 +96,7 @@ RosRangeVisionFusionApp::IsObjectInImage(const autoware_msgs::DetectedObject &amp;in
            &amp;&amp; (image_space_point.z &gt; 0);
 }
 
-cv::Rect RosRangeVisionFusionApp::ProjectDetectionToRect(const autoware_msgs::DetectedObject &amp;in_detection)
+cv::Rect ROSRangeVisionFusionApp::ProjectDetectionToRect(const autoware_msgs::DetectedObject &amp;in_detection)
 {
     cv::Rect projected_box;
 
@@ -133,7 +133,7 @@ cv::Rect RosRangeVisionFusionApp::ProjectDetectionToRect(const autoware_msgs::De
 }
 
 void
-RosRangeVisionFusionApp::TransformRangeToVision(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections,
+ROSRangeVisionFusionApp::TransformRangeToVision(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections,
                                                       autoware_msgs::DetectedObjectArray &amp;out_in_cv_range_detections,
                                                       autoware_msgs::DetectedObjectArray &amp;out_out_cv_range_detections)
 {
@@ -155,7 +155,7 @@ RosRangeVisionFusionApp::TransformRangeToVision(const autoware_msgs::DetectedObj
 }
 
 void
-RosRangeVisionFusionApp::CalculateObjectFeatures(autoware_msgs::DetectedObject &amp;in_out_object, bool in_estimate_pose)
+ROSRangeVisionFusionApp::CalculateObjectFeatures(autoware_msgs::DetectedObject &amp;in_out_object, bool in_estimate_pose)
 {
 
     float min_x=std::numeric_limits&lt;float&gt;::max();float max_x=-std::numeric_limits&lt;float&gt;::max();
@@ -255,7 +255,7 @@ RosRangeVisionFusionApp::CalculateObjectFeatures(autoware_msgs::DetectedObject &amp;
     tf::quaternionTFToMsg(quat, in_out_object.pose.orientation);
 }
 
-autoware_msgs::DetectedObject RosRangeVisionFusionApp::MergeObjects(const autoware_msgs::DetectedObject &amp;in_object_a,
+autoware_msgs::DetectedObject ROSRangeVisionFusionApp::MergeObjects(const autoware_msgs::DetectedObject &amp;in_object_a,
                                            const autoware_msgs::DetectedObject &amp; in_object_b)
 {
     autoware_msgs::DetectedObject object_merged;
@@ -280,14 +280,14 @@ autoware_msgs::DetectedObject RosRangeVisionFusionApp::MergeObjects(const autowa
 
 }
 
-double RosRangeVisionFusionApp::GetDistanceToObject(const autoware_msgs::DetectedObject &amp;in_object)
+double ROSRangeVisionFusionApp::GetDistanceToObject(const autoware_msgs::DetectedObject &amp;in_object)
 {
     return sqrt(in_object.dimensions.x*in_object.dimensions.x +
                 in_object.dimensions.y*in_object.dimensions.y +
                 in_object.dimensions.z*in_object.dimensions.z);
 }
 
-void RosRangeVisionFusionApp::CheckMinimumDimensions(autoware_msgs::DetectedObject &amp;in_out_object)
+void ROSRangeVisionFusionApp::CheckMinimumDimensions(autoware_msgs::DetectedObject &amp;in_out_object)
 {
     if (in_out_object.label == "car")
     {
@@ -320,7 +320,7 @@ void RosRangeVisionFusionApp::CheckMinimumDimensions(autoware_msgs::DetectedObje
 }
 
 autoware_msgs::DetectedObjectArray
-RosRangeVisionFusionApp::FuseRangeVisionDetections(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections,
+ROSRangeVisionFusionApp::FuseRangeVisionDetections(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections,
                                                    const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections)
 {
 
@@ -408,7 +408,7 @@ RosRangeVisionFusionApp::FuseRangeVisionDetections(const autoware_msgs::Detected
 }
 
 void
-RosRangeVisionFusionApp::SyncedDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections,
+ROSRangeVisionFusionApp::SyncedDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections,
                                                        const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections)
 {
     autoware_msgs::DetectedObjectArray fusion_objects;
@@ -479,7 +479,7 @@ RosRangeVisionFusionApp::SyncedDetectionsCallback(const autoware_msgs::DetectedO
 }
 
 visualization_msgs::MarkerArray
-RosRangeVisionFusionApp::ObjectsToMarkers(const autoware_msgs::DetectedObjectArray &amp;in_objects)
+ROSRangeVisionFusionApp::ObjectsToMarkers(const autoware_msgs::DetectedObjectArray &amp;in_objects)
 {
     visualization_msgs::MarkerArray final_markers;
 
@@ -517,7 +517,7 @@ RosRangeVisionFusionApp::ObjectsToMarkers(const autoware_msgs::DetectedObjectArr
 }
 
 jsk_recognition_msgs::BoundingBoxArray
-RosRangeVisionFusionApp::ObjectsToBoxes(const autoware_msgs::DetectedObjectArray &amp;in_objects)
+ROSRangeVisionFusionApp::ObjectsToBoxes(const autoware_msgs::DetectedObjectArray &amp;in_objects)
 {
     jsk_recognition_msgs::BoundingBoxArray final_boxes;
     final_boxes.header = in_objects.header;
@@ -541,7 +541,7 @@ RosRangeVisionFusionApp::ObjectsToBoxes(const autoware_msgs::DetectedObjectArray
 }
 
 void
-RosRangeVisionFusionApp::VisionDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections)
+ROSRangeVisionFusionApp::VisionDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections)
 {
 
     if (!processing_ &amp;&amp; !in_vision_detections-&gt;objects.empty())
@@ -554,7 +554,7 @@ RosRangeVisionFusionApp::VisionDetectionsCallback(const autoware_msgs::DetectedO
 }
 
 void
-RosRangeVisionFusionApp::RangeDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections)
+ROSRangeVisionFusionApp::RangeDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections)
 {
     if (!processing_ &amp;&amp; !in_range_detections-&gt;objects.empty())
     {
@@ -565,7 +565,7 @@ RosRangeVisionFusionApp::RangeDetectionsCallback(const autoware_msgs::DetectedOb
     }
 }
 
-void RosRangeVisionFusionApp::ImageCallback(const sensor_msgs::Image::ConstPtr &amp;in_image_msg)
+void ROSRangeVisionFusionApp::ImageCallback(const sensor_msgs::Image::ConstPtr &amp;in_image_msg)
 {
     if(!camera_info_ok_)
         return;
@@ -577,7 +577,7 @@ void RosRangeVisionFusionApp::ImageCallback(const sensor_msgs::Image::ConstPtr &amp;
 };
 
 void
-RosRangeVisionFusionApp::IntrinsicsCallback(const sensor_msgs::CameraInfo &amp;in_message)
+ROSRangeVisionFusionApp::IntrinsicsCallback(const sensor_msgs::CameraInfo &amp;in_message)
 {
     image_size_.height = in_message.height;
     image_size_.width = in_message.width;
@@ -609,7 +609,7 @@ RosRangeVisionFusionApp::IntrinsicsCallback(const sensor_msgs::CameraInfo &amp;in_me
 }
 
 tf::StampedTransform
-RosRangeVisionFusionApp::FindTransform(const std::string &amp;in_target_frame, const std::string &amp;in_source_frame)
+ROSRangeVisionFusionApp::FindTransform(const std::string &amp;in_target_frame, const std::string &amp;in_source_frame)
 {
     tf::StampedTransform transform;
 
@@ -630,7 +630,7 @@ RosRangeVisionFusionApp::FindTransform(const std::string &amp;in_target_frame, const
 }
 
 void
-RosRangeVisionFusionApp::InitializeRosIo(ros::NodeHandle &amp;in_private_handle)
+ROSRangeVisionFusionApp::InitializeROSIo(ros::NodeHandle &amp;in_private_handle)
 {
     //get params
     std::string camera_info_src, detected_objects_vision, min_car_dimensions, min_person_dimensions, min_truck_dimensions;
@@ -701,7 +701,7 @@ RosRangeVisionFusionApp::InitializeRosIo(ros::NodeHandle &amp;in_private_handle)
     ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, camera_info_src.c_str());
     intrinsics_subscriber_ = in_private_handle.subscribe(camera_info_src,
                                                          1,
-                                                         &amp;RosRangeVisionFusionApp::IntrinsicsCallback, this);
+                                                         &amp;ROSRangeVisionFusionApp::IntrinsicsCallback, this);
 
     ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, detected_objects_vision.c_str());
     ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, detected_objects_range.c_str());
@@ -709,11 +709,11 @@ RosRangeVisionFusionApp::InitializeRosIo(ros::NodeHandle &amp;in_private_handle)
     {
         detections_range_subscriber_ = in_private_handle.subscribe(detected_objects_vision,
                                                                    1,
-                                                                   &amp;RosRangeVisionFusionApp::VisionDetectionsCallback, this);
+                                                                   &amp;ROSRangeVisionFusionApp::VisionDetectionsCallback, this);
 
         detections_vision_subscriber_ = in_private_handle.subscribe(detected_objects_range,
                                                                     1,
-                                                                    &amp;RosRangeVisionFusionApp::RangeDetectionsCallback, this);
+                                                                    &amp;ROSRangeVisionFusionApp::RangeDetectionsCallback, this);
     }
     else
     {
@@ -725,7 +725,7 @@ RosRangeVisionFusionApp::InitializeRosIo(ros::NodeHandle &amp;in_private_handle)
                 new message_filters::Synchronizer&lt;SyncPolicyT&gt;(SyncPolicyT(10),
                                                                *vision_filter_subscriber_,
                                                                *range_filter_subscriber_);
-        detections_synchronizer_-&gt;registerCallback(boost::bind(&amp;RosRangeVisionFusionApp::SyncedDetectionsCallback, this, _1, _2));
+        detections_synchronizer_-&gt;registerCallback(boost::bind(&amp;ROSRangeVisionFusionApp::SyncedDetectionsCallback, this, _1, _2));
     }
 
     publisher_fused_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;(fused_topic_str, 1);
@@ -739,14 +739,14 @@ RosRangeVisionFusionApp::InitializeRosIo(ros::NodeHandle &amp;in_private_handle)
 
 
 void
-RosRangeVisionFusionApp::Run()
+ROSRangeVisionFusionApp::Run()
 {
     ros::NodeHandle private_node_handle("~");
     tf::TransformListener transform_listener;
 
     transform_listener_ = &amp;transform_listener;
 
-    InitializeRosIo(private_node_handle);
+    InitializeROSIo(private_node_handle);
 
     ROS_INFO("[%s] Ready. Waiting for data...", __APP_NAME__);
 
@@ -755,7 +755,7 @@ RosRangeVisionFusionApp::Run()
     ROS_INFO("[%s] END", __APP_NAME__);
 }
 
-RosRangeVisionFusionApp::RosRangeVisionFusionApp()
+ROSRangeVisionFusionApp::ROSRangeVisionFusionApp()
 {
     camera_lidar_tf_ok_ = false;
     camera_info_ok_ = false;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\src\range_vision_fusion_node.cpp" new_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\src\range_vision_fusion_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -40,7 +40,7 @@ int main(int argc, char **argv)
 {
     ros::init(argc, argv, __APP_NAME__);
 
-    RosRangeVisionFusionApp app;
+    ROSRangeVisionFusionApp app;
 
     app.Run();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\include\cluster.h" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\include\cluster.h" added_lines="1" deleted_lines="1">
				<diff>@@ -92,7 +92,7 @@ public:
                 int in_g, int in_b, std::string in_label, bool in_estimate_pose);
 
   /* \brief Returns the autoware_msgs::CloudCluster message associated to this Cluster */
-  void ToRosMessage(std_msgs::Header in_ros_header, autoware_msgs::CloudCluster&amp; out_cluster_message);
+  void ToROSMessage(std_msgs::Header in_ros_header, autoware_msgs::CloudCluster&amp; out_cluster_message);
 
   Cluster();
   virtual ~Cluster();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\cluster.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\cluster.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -62,7 +62,7 @@ Eigen::Vector3f Cluster::GetEigenValues()
   return eigen_values_;
 }
 
-void Cluster::ToRosMessage(std_msgs::Header in_ros_header, autoware_msgs::CloudCluster&amp; out_cluster_message)
+void Cluster::ToROSMessage(std_msgs::Header in_ros_header, autoware_msgs::CloudCluster&amp; out_cluster_message)
 {
   sensor_msgs::PointCloud2 cloud_msg;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -843,7 +843,7 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
       in_out_pictogram_array.pictograms.push_back(pictogram_cluster);
 
       autoware_msgs::CloudCluster cloud_cluster;
-      final_clusters[i]-&gt;ToRosMessage(_velodyne_header, cloud_cluster);
+      final_clusters[i]-&gt;ToROSMessage(_velodyne_header, cloud_cluster);
       in_out_clusters.clusters.push_back(cloud_cluster);
     }
   }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\imm_ukf_pda.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\imm_ukf_pda.h" added_lines="1" deleted_lines="1">
				<diff>@@ -156,7 +156,7 @@ private:
 
   void removeUnnecessaryTarget();
 
-  void pubDebugRosMarker(const autoware_msgs::DetectedObjectArray&amp; input);
+  void pubDebugROSMarker(const autoware_msgs::DetectedObjectArray&amp; input);
 
   void dumpResultText(autoware_msgs::DetectedObjectArray&amp; detected_objects);
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -659,7 +659,7 @@ void ImmUkfPda::removeUnnecessaryTarget()
   targets_ = temp_targets;
 }
 
-void ImmUkfPda::pubDebugRosMarker(const autoware_msgs::DetectedObjectArray&amp; input)
+void ImmUkfPda::pubDebugROSMarker(const autoware_msgs::DetectedObjectArray&amp; input)
 {
   visualization_msgs::MarkerArray texts_markers, points_markers;
   visualization_msgs::Marker target_points, meas_points;
@@ -873,7 +873,7 @@ void ImmUkfPda::tracker(const autoware_msgs::DetectedObjectArray&amp; input,
   // debug, green is for measurement points, red is for estimated points
   if (is_debug_)
   {
-    pubDebugRosMarker(input);
+    pubDebugROSMarker(input);
   }
 
   // making new ukf target for no data association clusters
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track_core.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track_core.cpp" added_lines="10" deleted_lines="10">
				<diff>@@ -29,7 +29,7 @@
  */
 
 #include "lidar_kf_contour_track_core.h"
-#include "op_ros_helpers/op_RosHelpers.h"
+#include "op_ros_helpers/op_ROSHelpers.h"
 #include "op_planner/MappingHelpers.h"
 #include "op_planner/PlannerH.h"
 
@@ -91,11 +91,11 @@ ContourTracker::ContourTracker()
 	m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
 	m_DetectedPolygonsDummy.push_back(visualization_msgs::MarkerArray());
 	m_DetectedPolygonsActual = m_DetectedPolygonsDummy;
-	PlannerHNS::RosHelpers::InitMarkers(m_nDummyObjPerRep, m_DetectedPolygonsDummy.at(0), m_DetectedPolygonsDummy.at(1), m_DetectedPolygonsDummy.at(2), m_DetectedPolygonsDummy.at(3), m_DetectedPolygonsDummy.at(4));
+	PlannerHNS::ROSHelpers::InitMarkers(m_nDummyObjPerRep, m_DetectedPolygonsDummy.at(0), m_DetectedPolygonsDummy.at(1), m_DetectedPolygonsDummy.at(2), m_DetectedPolygonsDummy.at(3), m_DetectedPolygonsDummy.at(4));
 
 	m_MatchingInfoDummy.push_back(visualization_msgs::MarkerArray());
 	m_MatchingInfoActual = m_MatchingInfoDummy;
-	PlannerHNS::RosHelpers::InitMatchingMarkers(m_nDummyObjPerRep, m_MatchingInfoDummy.at(0));
+	PlannerHNS::ROSHelpers::InitMatchingMarkers(m_nDummyObjPerRep, m_MatchingInfoDummy.at(0));
 }
 
 ContourTracker::~ContourTracker()
@@ -326,7 +326,7 @@ void ContourTracker::callbackGetCurrentPose(const geometry_msgs::PoseStampedCons
 
 void ContourTracker::VisualizeLocalTracking()
 {
-	PlannerHNS::RosHelpers::ConvertTrackedObjectsMarkers(m_CurrentPos, m_ObstacleTracking.m_DetectedObjects,
+	PlannerHNS::ROSHelpers::ConvertTrackedObjectsMarkers(m_CurrentPos, m_ObstacleTracking.m_DetectedObjects,
 				m_DetectedPolygonsDummy.at(0),
 				m_DetectedPolygonsDummy.at(1),
 				m_DetectedPolygonsDummy.at(2),
@@ -338,7 +338,7 @@ void ContourTracker::VisualizeLocalTracking()
 				m_DetectedPolygonsActual.at(3),
 				m_DetectedPolygonsActual.at(4));
 
-	PlannerHNS::RosHelpers::ConvertMatchingMarkers(m_ObstacleTracking.m_MatchList, m_MatchingInfoDummy.at(0), m_MatchingInfoActual.at(0), 0);
+	PlannerHNS::ROSHelpers::ConvertMatchingMarkers(m_ObstacleTracking.m_MatchList, m_MatchingInfoDummy.at(0), m_MatchingInfoActual.at(0), 0);
 
 	m_DetectedPolygonsAllMarkers.markers.clear();
 	m_DetectedPolygonsAllMarkers.markers.insert(m_DetectedPolygonsAllMarkers.markers.end(), m_DetectedPolygonsActual.at(0).markers.begin(), m_DetectedPolygonsActual.at(0).markers.end());
@@ -352,7 +352,7 @@ void ContourTracker::VisualizeLocalTracking()
 	for(unsigned int i = 0; i &lt; m_ObstacleTracking.m_InterestRegions.size(); i++)
 	{
 		visualization_msgs::Marker circle_mkrs;
-		PlannerHNS::RosHelpers::CreateCircleMarker(m_CurrentPos, m_ObstacleTracking.m_InterestRegions.at(i)-&gt;radius, i ,circle_mkrs );
+		PlannerHNS::ROSHelpers::CreateCircleMarker(m_CurrentPos, m_ObstacleTracking.m_InterestRegions.at(i)-&gt;radius, i ,circle_mkrs );
 		all_circles.markers.push_back(circle_mkrs);
 	}
 
@@ -422,7 +422,7 @@ void ContourTracker::LogAndSend()
 	autoware_msgs::DetectedObject obj;
 	for(unsigned int i = 0 ; i &lt;m_ObstacleTracking.m_DetectedObjects.size(); i++)
 	{
-		PlannerHNS::RosHelpers::ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(m_ObstacleTracking.m_DetectedObjects.at(i), m_Params.bEnableSimulation, obj);
+		PlannerHNS::ROSHelpers::ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(m_ObstacleTracking.m_DetectedObjects.at(i), m_Params.bEnableSimulation, obj);
 		m_OutPutResults.objects.push_back(obj);
 	}
 
@@ -506,7 +506,7 @@ void ContourTracker::CalculateTTC(const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp;
 	m_TTC_Path.markers.clear();
 	if(direct_paths.size() == 0)
 		direct_paths.push_back(currState);
-	PlannerHNS::RosHelpers::TTC_PathRviz(direct_paths, m_TTC_Path);
+	PlannerHNS::ROSHelpers::TTC_PathRviz(direct_paths, m_TTC_Path);
 	pub_TTC_PathRviz.publish(m_TTC_Path);
 
 
@@ -557,7 +557,7 @@ void ContourTracker::MainLoop()
 
 			if(m_MapRaw.GetVersion()==2)
 			{
-				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
@@ -572,7 +572,7 @@ void ContourTracker::MainLoop()
 			}
 			else if(m_MapRaw.GetVersion()==1)
 			{
-				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_track\nodes\lidar_kf_track\lidar_kf_track.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_track\nodes\lidar_kf_track\lidar_kf_track.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -130,7 +130,7 @@ void KFLidarTracker::Update(const autoware_msgs::CloudClusterArray&amp; in_cloud_clu
 				}
 				merged_cluster-&gt;SetCloud(summed_cloud_ptr, indices, in_cloud_cluster_array.clusters[track_assignments[i]].header, i,255, 255, 255, "", pose_estimation_);
 
-				merged_cluster-&gt;ToRosMessage(in_cloud_cluster_array.clusters[track_assignments[i]].header, *summed_cloud_cluster);*/
+				merged_cluster-&gt;ToROSMessage(in_cloud_cluster_array.clusters[track_assignments[i]].header, *summed_cloud_cluster);*/
 
 				tracks_[i].Update(in_cloud_cluster_array.clusters[track_assignments[i]],//*summed_cloud_cluster,
 								true,
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.cpp" added_lines="27" deleted_lines="27">
				<diff>@@ -12,7 +12,7 @@
 static bool show_superimpose_result = false;
 static const std::string window_name = "superimpose result";
 
-RegionTlrMxNetRosNode::RegionTlrMxNetRosNode() :
+RegionTlrMxNetROSNode::RegionTlrMxNetROSNode() :
 		image_topic_name_("/image_raw"),
 		network_definition_file_name_(""),
 		pretrained_model_file_name_(""),
@@ -30,15 +30,15 @@ RegionTlrMxNetRosNode::RegionTlrMxNetRosNode() :
 }
 
 
-RegionTlrMxNetRosNode::~RegionTlrMxNetRosNode()
+RegionTlrMxNetROSNode::~RegionTlrMxNetROSNode()
 {
 }
 
 
-void RegionTlrMxNetRosNode::RunRecognition()
+void RegionTlrMxNetROSNode::RunRecognition()
 {
 	// Get execution parameters from ROS parameter server
-	GetRosParam();
+	GetROSParam();
 
 	BufferFile json_data(network_definition_file_name_);
 	BufferFile param_data(pretrained_model_file_name_);
@@ -62,7 +62,7 @@ void RegionTlrMxNetRosNode::RunRecognition()
 }
 
 
-void RegionTlrMxNetRosNode::ImageRawCallback(const sensor_msgs::Image &amp;image)
+void RegionTlrMxNetROSNode::ImageRawCallback(const sensor_msgs::Image &amp;image)
 {
 	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image, sensor_msgs::image_encodings::BGR8);
 	frame_ = cv_image-&gt;image.clone();
@@ -71,7 +71,7 @@ void RegionTlrMxNetRosNode::ImageRawCallback(const sensor_msgs::Image &amp;image)
 
 }
 
-void RegionTlrMxNetRosNode::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos)
+void RegionTlrMxNetROSNode::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos)
 {
 	static ros::Time previous_timestamp;
 	// If frame has not been prepared, abort this callback
@@ -114,7 +114,7 @@ void RegionTlrMxNetRosNode::RoiSignalCallback(const autoware_msgs::Signals::Cons
 	previous_timestamp = frame_header_.stamp;
 }
 
-void RegionTlrMxNetRosNode::GetRosParam()
+void RegionTlrMxNetROSNode::GetROSParam()
 {
 	ros::NodeHandle private_node_handle("~");
 
@@ -146,25 +146,25 @@ void RegionTlrMxNetRosNode::GetRosParam()
 		ROS_FATAL("No Pretrained Model File was specified. Terminate program... ");
 		exit(EXIT_FAILURE);
 	}
-} // RegionTlrMxNetRosNode::ProcessRosParam()
+} // RegionTlrMxNetROSNode::ProcessROSParam()
 
 
-void RegionTlrMxNetRosNode::StartSubscribersAndPublishers()
+void RegionTlrMxNetROSNode::StartSubscribersAndPublishers()
 {
 	ros::NodeHandle node_handle;
 
 	// Register subscribers
 	image_subscriber = node_handle.subscribe(image_topic_name_,
 	                                         1,
-	                                         &amp;RegionTlrMxNetRosNode::ImageRawCallback,
+	                                         &amp;RegionTlrMxNetROSNode::ImageRawCallback,
 	                                         this);
 	roi_signal_subscriber = node_handle.subscribe("/roi_signal",
 	                                              1,
-	                                              &amp;RegionTlrMxNetRosNode::RoiSignalCallback,
+	                                              &amp;RegionTlrMxNetROSNode::RoiSignalCallback,
 	                                              this);
 	superimpose_sub = node_handle.subscribe("/config/superimpose",
                                           1,
-                                          &amp;RegionTlrMxNetRosNode::SuperimposeCb,
+                                          &amp;RegionTlrMxNetROSNode::SuperimposeCb,
                                           this);
 
 	// Register publishers
@@ -173,7 +173,7 @@ void RegionTlrMxNetRosNode::StartSubscribersAndPublishers()
 	marker_publisher = node_handle.advertise&lt;visualization_msgs::MarkerArray&gt;("tlr_result", 1, kAdvertiseInLatch_);
 	superimpose_image_publisher = node_handle.advertise&lt;sensor_msgs::Image&gt;("tlr_superimpose_image", 1);
 
-} // RegionTlrMxNetRosNode::StartSubscribersAndPublishers()
+} // RegionTlrMxNetROSNode::StartSubscribersAndPublishers()
 
 /*!
  * DetermineState works as a latch to reduce the chance of sudden changes in the state of the traffic light, caused by
@@ -182,7 +182,7 @@ void RegionTlrMxNetRosNode::StartSubscribersAndPublishers()
  * @param current_state the current state of the traffic light as reported by the classifier.
  * @param in_out_signal_context the object containing the data of the current Traffic Light instance.
  */
-void RegionTlrMxNetRosNode::DetermineState(LightState in_current_state,
+void RegionTlrMxNetROSNode::DetermineState(LightState in_current_state,
                                            Context&amp; in_out_signal_context)
 {
 	//if reported state by classifier is different than the previously stored
@@ -207,10 +207,10 @@ void RegionTlrMxNetRosNode::DetermineState(LightState in_current_state,
 		in_out_signal_context.lightState = in_current_state;
 	}
 
-} // LightState RegionTlrMxNetRosNode::DetermineState()
+} // LightState RegionTlrMxNetROSNode::DetermineState()
 
 
-void RegionTlrMxNetRosNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts)
+void RegionTlrMxNetROSNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts)
 {
 	autoware_msgs::TrafficLight topic;
 	static int32_t previous_state = kTrafficLightUnknown;
@@ -247,10 +247,10 @@ void RegionTlrMxNetRosNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts)
 		signal_state_publisher.publish(topic);
 		previous_state = topic.traffic_light;
 	}
-} // void RegionTlrMxNetRosNode::PublishTrafficLight()
+} // void RegionTlrMxNetROSNode::PublishTrafficLight()
 
 
-void RegionTlrMxNetRosNode::PublishString(std::vector&lt;Context&gt; contexts)
+void RegionTlrMxNetROSNode::PublishString(std::vector&lt;Context&gt; contexts)
 {
 	std_msgs::String topic;
 	static std::string previous_state = kStringUnknown;
@@ -287,10 +287,10 @@ void RegionTlrMxNetRosNode::PublishString(std::vector&lt;Context&gt; contexts)
 		signal_state_string_publisher.publish(topic);
 		previous_state = topic.data;
 	}
-} // void RegionTlrMxNetRosNode::PublishString()
+} // void RegionTlrMxNetROSNode::PublishString()
 
 
-void RegionTlrMxNetRosNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts)
+void RegionTlrMxNetROSNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts)
 {
 	// Define color constants
 	std_msgs::ColorRGBA color_black;
@@ -419,10 +419,10 @@ void RegionTlrMxNetRosNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts)
 		marker_publisher.publish(signal_set);
 	}
 
-} // void RegionTlrMxNetRosNode::PublishMarkerArray()
+} // void RegionTlrMxNetROSNode::PublishMarkerArray()
 
 
-void RegionTlrMxNetRosNode::PublishImage(std::vector&lt;Context&gt; contexts)
+void RegionTlrMxNetROSNode::PublishImage(std::vector&lt;Context&gt; contexts)
 {
 	// Copy the frame image for output
 	cv::Mat result_image = frame_.clone();
@@ -484,9 +484,9 @@ void RegionTlrMxNetRosNode::PublishImage(std::vector&lt;Context&gt; contexts)
 	converter.image = result_image;
 	superimpose_image_publisher.publish(converter.toImageMsg());
 
-} // void RegionTlrMxNetRosNode::PublishImage()
+} // void RegionTlrMxNetROSNode::PublishImage()
 
-void RegionTlrMxNetRosNode::SuperimposeCb(const std_msgs::Bool::ConstPtr &amp;config_msg)
+void RegionTlrMxNetROSNode::SuperimposeCb(const std_msgs::Bool::ConstPtr &amp;config_msg)
 {
 	show_superimpose_result = config_msg-&gt;data;
 
@@ -505,15 +505,15 @@ void RegionTlrMxNetRosNode::SuperimposeCb(const std_msgs::Bool::ConstPtr &amp;config
 		}
 	}
 
-} // void RegionTlrMxNetRosNode::SuperimposeCb()
+} // void RegionTlrMxNetROSNode::SuperimposeCb()
 
 int main(int argc, char *argv[])
 {
 	// Initialize ros node
 	ros::init(argc, argv, "region_tlr_mxnet");
 
-	// Create RegionTlrRosNode class object and do initialization
-	RegionTlrMxNetRosNode region_tlr_mxnet_ros_node;
+	// Create RegionTlrROSNode class object and do initialization
+	RegionTlrMxNetROSNode region_tlr_mxnet_ros_node;
 
 	// Start recognition process
 	region_tlr_mxnet_ros_node.RunRecognition();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.h" added_lines="4" deleted_lines="4">
				<diff>@@ -59,12 +59,12 @@ public :
 	}
 };
 
-class RegionTlrMxNetRosNode
+class RegionTlrMxNetROSNode
 {
 public:
-	RegionTlrMxNetRosNode();
+	RegionTlrMxNetROSNode();
 
-	~RegionTlrMxNetRosNode();
+	~RegionTlrMxNetROSNode();
 
 	void RunRecognition();
 
@@ -88,7 +88,7 @@ private:
 	};
 
 
-	void GetRosParam();
+	void GetROSParam();
 
 	void StartSubscribersAndPublishers();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.cpp" added_lines="29" deleted_lines="29">
				<diff>@@ -10,9 +10,9 @@
 #include "Context.h"
 
 // ========================================
-// Constructor of RegionTlrSSDRosNode class
+// Constructor of RegionTlrSSDROSNode class
 // ========================================
-RegionTlrSSDRosNode::RegionTlrSSDRosNode():
+RegionTlrSSDROSNode::RegionTlrSSDROSNode():
   image_topic_name_("/image_raw"),
   network_definition_file_name_(""),
   pretrained_model_file_name_(""),
@@ -26,22 +26,22 @@ RegionTlrSSDRosNode::RegionTlrSSDRosNode():
   kStringGreen("green signal"),
   kStringUnknown("") {
 
-} // RegionTlrSSDRosNode::RegionTlrSSDRosNode()
+} // RegionTlrSSDROSNode::RegionTlrSSDROSNode()
 
 
 // ========================================
-// Destructor of RegionTlrSSDRosNode class
+// Destructor of RegionTlrSSDROSNode class
 // ========================================
-RegionTlrSSDRosNode::~RegionTlrSSDRosNode() {
-} // RegionTlrSSDRosNode::~RegionTlrSSDRosNode()
+RegionTlrSSDROSNode::~RegionTlrSSDROSNode() {
+} // RegionTlrSSDROSNode::~RegionTlrSSDROSNode()
 
 
 // =========================
 // Start recognition process
 // =========================
-void RegionTlrSSDRosNode::RunRecognition() {
+void RegionTlrSSDROSNode::RunRecognition() {
   // Get execution parameters from ROS parameter server
-  GetRosParam();
+  GetROSParam();
 
   // Initialize recognizer
   recognizer.Init(network_definition_file_name_,
@@ -52,13 +52,13 @@ void RegionTlrSSDRosNode::RunRecognition() {
   // Start subscribing and publishing
   StartSubscribersAndPublishers();
   ros::spin();
-} // RegionTlrSSDRosNode::RunRecognition()
+} // RegionTlrSSDROSNode::RunRecognition()
 
 
 // ==================================
 // Callback function to acquire image
 // ==================================
-void RegionTlrSSDRosNode::ImageRawCallback(const sensor_msgs::Image &amp;image) {
+void RegionTlrSSDROSNode::ImageRawCallback(const sensor_msgs::Image &amp;image) {
   cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image, sensor_msgs::image_encodings::BGR8);
   frame_ = cv_image-&gt;image.clone();
 
@@ -70,7 +70,7 @@ void RegionTlrSSDRosNode::ImageRawCallback(const sensor_msgs::Image &amp;image) {
 // ==========================================
 // Callback function to acquire extracted_pos
 // ==========================================
-void RegionTlrSSDRosNode::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos) {
+void RegionTlrSSDROSNode::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos) {
   static ros::Time previous_timestamp;
   // If frame has not been prepared, abort this callback
   if (frame_.empty() ||
@@ -120,7 +120,7 @@ void RegionTlrSSDRosNode::RoiSignalCallback(const autoware_msgs::Signals::ConstP
 // =======================================
 // Get parameter from ROS parameter server
 // =======================================
-void RegionTlrSSDRosNode::GetRosParam() {
+void RegionTlrSSDROSNode::GetROSParam() {
   ros::NodeHandle private_node_handle("~");
 
   private_node_handle.param&lt;std::string&gt;("image_raw_topic", image_topic_name_, "/image_raw");
@@ -140,23 +140,23 @@ void RegionTlrSSDRosNode::GetRosParam() {
     ROS_FATAL("No Pretrained Model File was specified. Terminate program... ");
     exit(EXIT_FAILURE);
   }
-} // RegionTlrSSDRosNode::ProcessRosParam()
+} // RegionTlrSSDROSNode::ProcessROSParam()
 
 
 // ============================================================
 // Register subscriber and publisher of this node in ROS Master
 // ============================================================
-void RegionTlrSSDRosNode::StartSubscribersAndPublishers() {
+void RegionTlrSSDROSNode::StartSubscribersAndPublishers() {
   ros::NodeHandle node_handle;
   
   // Register subscribers
   image_subscriber      = node_handle.subscribe(image_topic_name_,
                                                 1,
-                                                &amp;RegionTlrSSDRosNode::ImageRawCallback,
+                                                &amp;RegionTlrSSDROSNode::ImageRawCallback,
                                                 this);
   roi_signal_subscriber = node_handle.subscribe("/roi_signal",
                                                 1,
-                                                &amp;RegionTlrSSDRosNode::RoiSignalCallback,
+                                                &amp;RegionTlrSSDROSNode::RoiSignalCallback,
                                                 this);
 
   // Register publishers
@@ -165,13 +165,13 @@ void RegionTlrSSDRosNode::StartSubscribersAndPublishers() {
   marker_publisher              = node_handle.advertise&lt;visualization_msgs::MarkerArray&gt;("tlr_result", 1, kAdvertiseInLatch_);
   superimpose_image_publisher   = node_handle.advertise&lt;sensor_msgs::Image&gt;("tlr_superimpose_image", 1);
 
-} // RegionTlrSSDRosNode::StartSubscribersAndPublishers()
+} // RegionTlrSSDROSNode::StartSubscribersAndPublishers()
 
 
 // ===============================================================================
 // Determine the final recognition result by comparing previous recognition result
 // ===============================================================================
-LightState RegionTlrSSDRosNode::DetermineState(LightState previous_state,
+LightState RegionTlrSSDROSNode::DetermineState(LightState previous_state,
                                                LightState current_state,
                                                int* state_judge_count) {
   // Get a candidate which considering state transition of traffic light
@@ -188,13 +188,13 @@ LightState RegionTlrSSDRosNode::DetermineState(LightState previous_state,
     return previous_state;
   }
 
-} // LightState RegionTlrSSDRosNode::DetermineState()
+} // LightState RegionTlrSSDROSNode::DetermineState()
 
 
 // =================================================================
 // Publish recognition result as autoware_msgs::TrafficLight type
 // =================================================================
-void RegionTlrSSDRosNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts) {
+void RegionTlrSSDROSNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts) {
   autoware_msgs::TrafficLight topic;
   static int32_t previous_state = kTrafficLightUnknown;
   topic.traffic_light = kTrafficLightUnknown;
@@ -226,13 +226,13 @@ void RegionTlrSSDRosNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts) {
     signal_state_publisher.publish(topic);
     previous_state = topic.traffic_light;
   }
-} // void RegionTlrSSDRosNode::PublishTrafficLight()
+} // void RegionTlrSSDROSNode::PublishTrafficLight()
 
 
 // =================================================================
 // Publish recognition result as std_msgs::String
 // =================================================================
-void RegionTlrSSDRosNode::PublishString(std::vector&lt;Context&gt; contexts) {
+void RegionTlrSSDROSNode::PublishString(std::vector&lt;Context&gt; contexts) {
   std_msgs::String topic;
   static std::string previous_state = kStringUnknown;
   topic.data = kStringUnknown;
@@ -264,13 +264,13 @@ void RegionTlrSSDRosNode::PublishString(std::vector&lt;Context&gt; contexts) {
     signal_state_string_publisher.publish(topic);
     previous_state = topic.data;
   }
-} // void RegionTlrSSDRosNode::PublishString()
+} // void RegionTlrSSDROSNode::PublishString()
 
 
 // =================================================================
 // Publish recognition result as visualization_msgs::MarkerArray
 // =================================================================
-void RegionTlrSSDRosNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts) {
+void RegionTlrSSDROSNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts) {
   // Define color constants
   std_msgs::ColorRGBA color_black;
   color_black.r = 0.0f;
@@ -396,13 +396,13 @@ void RegionTlrSSDRosNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts) {
     marker_publisher.publish(signal_set);
   }
 
-} // void RegionTlrSSDRosNode::PublishMarkerArray()
+} // void RegionTlrSSDROSNode::PublishMarkerArray()
 
 
 // ================================================================
 // Publish superimpose and recognition result as sensor_msgs::Image
 // ================================================================
-void RegionTlrSSDRosNode::PublishImage(std::vector&lt;Context&gt; contexts) {
+void RegionTlrSSDROSNode::PublishImage(std::vector&lt;Context&gt; contexts) {
   // Copy the frame image for output
   cv::Mat result_image = frame_.clone();
 
@@ -461,7 +461,7 @@ void RegionTlrSSDRosNode::PublishImage(std::vector&lt;Context&gt; contexts) {
   converter.image = result_image;
   superimpose_image_publisher.publish(converter.toImageMsg());
 
-} // void RegionTlrSSDRosNode::PublishImage()
+} // void RegionTlrSSDROSNode::PublishImage()
 
 // ========================
 // Entry point of this node
@@ -470,8 +470,8 @@ int main (int argc, char *argv[]) {
   // Initialize ros node
   ros::init(argc, argv, "region_tlr_ssd");
 
-  // Create RegionTlrRosNode class object and do initialization
-  RegionTlrSSDRosNode region_tlr_ssd_ros_node;
+  // Create RegionTlrROSNode class object and do initialization
+  RegionTlrSSDROSNode region_tlr_ssd_ros_node;
 
   // Start recognition process
   region_tlr_ssd_ros_node.RunRecognition();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.h" added_lines="4" deleted_lines="4">
				<diff>@@ -13,10 +13,10 @@
 #include "autoware_msgs/Signals.h"
 #include "traffic_light_recognizer.h"
 
-class RegionTlrSSDRosNode {
+class RegionTlrSSDROSNode {
  public:
-  RegionTlrSSDRosNode();
-  ~RegionTlrSSDRosNode();
+  RegionTlrSSDROSNode();
+  ~RegionTlrSSDROSNode();
 
   void RunRecognition();
   void ImageRawCallback(const sensor_msgs::Image &amp;image);
@@ -38,7 +38,7 @@ class RegionTlrSSDRosNode {
   };
 
 
-  void GetRosParam();
+  void GetROSParam();
   void StartSubscribersAndPublishers();
   LightState DetermineState(LightState previous_state, LightState current_state, int* state_judge_count);
   void PublishTrafficLight(std::vector&lt;Context&gt; contexts);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\stb_image.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\darknet\src\stb_image.h" added_lines="1" deleted_lines="1">
				<diff>@@ -100,7 +100,7 @@ RECENT REVISION HISTORY:
     Oriol Ferrer Mesia      Josh Tobin         Matthew Gregan     github:phprus
     Julian Raschke          Gregory Mullen     Baldur Karlsson    github:poppolopoppo
     Christian Floisand      Kevin Schmidt                         github:darealshinji
-    Blazej Dariusz Roszkowski                                     github:Michaelangel007
+    Blazej Dariusz ROSzkowski                                     github:Michaelangel007
 */
 
 #ifndef STBI_INCLUDE_STB_IMAGE_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_segment_enet_detect\nodes\vision_segment_enet_detect\vision_segment_enet_detect_node.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_segment_enet_detect\nodes\vision_segment_enet_detect\vision_segment_enet_detect_node.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -13,7 +13,7 @@
 
 #include "vision_segment_enet_detect.h"
 
-class RosENetSegmenterApp
+class ROSENetSegmenterApp
 {
 	ros::Subscriber subscriber_image_raw_;
 	ros::NodeHandle node_handle_;
@@ -110,7 +110,7 @@ public:
 		ROS_INFO("ENetSegmenter initialized.");
 
 		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
-		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosENetSegmenterApp::image_callback, this);
+		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;ROSENetSegmenterApp::image_callback, this);
 
 		publisher_image_segmented_ = node_handle_.advertise&lt;sensor_msgs::Image&gt;("/image_segmented", 1);
 		ROS_INFO("Publishing /image_segmented");
@@ -122,13 +122,13 @@ public:
 		ROS_INFO("END ENetSegmenter");
 	}
 
-	~RosENetSegmenterApp()
+	~ROSENetSegmenterApp()
 	{
 		if (NULL != enet_segmenter_)
 			delete enet_segmenter_;
 	}
 
-	RosENetSegmenterApp()
+	ROSENetSegmenterApp()
 	{
 		enet_segmenter_ = NULL;
 	}
@@ -138,7 +138,7 @@ int main(int argc, char **argv)
 {
 	ros::init(argc, argv, "image_segmenter_enet");
 
-	RosENetSegmenterApp app;
+	ROSENetSegmenterApp app;
 
 	app.Run();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -49,7 +49,7 @@
 
 #include "vision_ssd_detect.h"
 
-class RosSSDApp
+class ROSSSDApp
 {
 	ros::Subscriber subscriber_image_raw_;
 	ros::Subscriber subscriber_ssd_config_;
@@ -210,24 +210,24 @@ public:
         publisher_detected_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/vision_objects", 1);
 
 		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
-		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosSSDApp::image_callback, this);
+		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;ROSSSDApp::image_callback, this);
 
 		std::string config_topic("/config");
 		config_topic += "/ssd";
-		subscriber_ssd_config_ = node_handle_.subscribe(config_topic, 1, &amp;RosSSDApp::config_cb, this);
+		subscriber_ssd_config_ = node_handle_.subscribe(config_topic, 1, &amp;ROSSSDApp::config_cb, this);
 
 		ros::spin();
 		ROS_INFO("END SSD");
 
 	}
 
-	~RosSSDApp()
+	~ROSSSDApp()
 	{
 		if (NULL != ssd_detector_)
 			delete ssd_detector_;
 	}
 
-	RosSSDApp()
+	ROSSSDApp()
 	{
 		ssd_detector_ 	= NULL;
 		score_threshold_= 0.5;
@@ -241,7 +241,7 @@ int main(int argc, char **argv)
 {
 	ros::init(argc, argv, "ssd_unc");
 
-	RosSSDApp app;
+	ROSSSDApp app;
 
 	app.Run();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_klt_track\nodes\vision_klt_track\vision_klt_track.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_klt_track\nodes\vision_klt_track\vision_klt_track.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -64,7 +64,7 @@
 
 #include "gencolors.cpp"
 
-class RosTrackerApp {
+class ROSTrackerApp {
   ros::Subscriber subscriber_image_raw_;
   ros::Subscriber subscriber_image_obj_;
   ros::Subscriber subscriber_klt_config_;
@@ -401,20 +401,20 @@ public:
     ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
     ROS_INFO("Subscribing to... %s", image_obj_topic_str.c_str());
     subscriber_image_raw_ = node_handle_.subscribe(
-        image_raw_topic_str, 1, &amp;RosTrackerApp::image_callback, this);
+        image_raw_topic_str, 1, &amp;ROSTrackerApp::image_callback, this);
     subscriber_image_obj_ = node_handle_.subscribe(
-        image_obj_topic_str, 1, &amp;RosTrackerApp::detections_callback, this);
+        image_obj_topic_str, 1, &amp;ROSTrackerApp::detections_callback, this);
 
     std::string config_topic("/config");
     config_topic += ros::this_node::getNamespace() + "/klt";
-    // node_handle.subscribe(config_topic, 1, &amp;RosTrackerApp::klt_config_cb,
+    // node_handle.subscribe(config_topic, 1, &amp;ROSTrackerApp::klt_config_cb,
     // this);
 
     ros::spin();
     ROS_INFO("END klt");
   }
 
-  RosTrackerApp() {
+  ROSTrackerApp() {
     ready_ = true;
     num_trackers_ = 0;
     track_ready_ = false;
@@ -425,7 +425,7 @@ public:
 int main(int argc, char *argv[]) {
   ros::init(argc, argv, "klt");
 
-  RosTrackerApp app;
+  ROSTrackerApp app;
 
   app.Run();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.cpp" added_lines="11" deleted_lines="11">
				<diff>@@ -35,7 +35,7 @@
 
 #include "ndt_matching_monitor.h"
 
-void RosNDTMatchingMonitor::gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
+void ROSNDTMatchingMonitor::gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
 {
     gnss_pose_.header = input-&gt;header;
     gnss_pose_.pose.pose = input-&gt;pose;
@@ -43,7 +43,7 @@ void RosNDTMatchingMonitor::gnss_callback(const geometry_msgs::PoseStamped::Cons
     gnss_text_ = " - GNSS available";
 }
 
-void RosNDTMatchingMonitor::ndt_stat_callback(const autoware_msgs::NDTStat::ConstPtr&amp; input)
+void ROSNDTMatchingMonitor::ndt_stat_callback(const autoware_msgs::NDTStat::ConstPtr&amp; input)
 {
     iteration_count_ = input-&gt;iteration;
 
@@ -55,7 +55,7 @@ void RosNDTMatchingMonitor::ndt_stat_callback(const autoware_msgs::NDTStat::Cons
 }
 
 geometry_msgs::PoseWithCovarianceStamped
-                RosNDTMatchingMonitor::predict_next_pose(geometry_msgs::PoseWithCovarianceStamped prev_pose,
+                ROSNDTMatchingMonitor::predict_next_pose(geometry_msgs::PoseWithCovarianceStamped prev_pose,
                                                          geometry_msgs::PoseWithCovarianceStamped current_pose)
 {
     geometry_msgs::PoseWithCovarianceStamped predicted_pose;
@@ -82,7 +82,7 @@ geometry_msgs::PoseWithCovarianceStamped
 
 }
 
-void RosNDTMatchingMonitor::initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input)
+void ROSNDTMatchingMonitor::initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input)
 {
     //if currently blocking reset and receiving a different blocking pose, then try to reset
     if (ndt_status::NDT_FATAL == ndt_status_
@@ -102,7 +102,7 @@ void RosNDTMatchingMonitor::initialpose_callback(const geometry_msgs::PoseWithCo
     }
 }
 
-void RosNDTMatchingMonitor::ndt_pose_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
+void ROSNDTMatchingMonitor::ndt_pose_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
 {
     geometry_msgs::PoseWithCovarianceStamped initialpose_msg;
     initialpose_msg.header = input-&gt;header;
@@ -207,7 +207,7 @@ void RosNDTMatchingMonitor::ndt_pose_callback(const geometry_msgs::PoseStamped::
     last_score_ = current_score_;
 }
 
-void RosNDTMatchingMonitor::Run()
+void ROSNDTMatchingMonitor::Run()
 {
     ros::NodeHandle nh;
     ros::NodeHandle private_nh("~");
@@ -228,10 +228,10 @@ void RosNDTMatchingMonitor::Run()
     }
 
     // Subscribers
-    ros::Subscriber ndt_stat_sub = nh.subscribe("/ndt_stat", 10, &amp;RosNDTMatchingMonitor::ndt_stat_callback, this);
-    ros::Subscriber ndt_pose_sub = nh.subscribe("/ndt_pose", 10, &amp;RosNDTMatchingMonitor::ndt_pose_callback, this);
-    ros::Subscriber initial_pose_sub = nh.subscribe("/initialpose", 10, &amp;RosNDTMatchingMonitor::initialpose_callback, this);
-    ros::Subscriber gnss_sub = nh.subscribe("gnss_pose", 10, &amp;RosNDTMatchingMonitor::gnss_callback, this);
+    ros::Subscriber ndt_stat_sub = nh.subscribe("/ndt_stat", 10, &amp;ROSNDTMatchingMonitor::ndt_stat_callback, this);
+    ros::Subscriber ndt_pose_sub = nh.subscribe("/ndt_pose", 10, &amp;ROSNDTMatchingMonitor::ndt_pose_callback, this);
+    ros::Subscriber initial_pose_sub = nh.subscribe("/initialpose", 10, &amp;ROSNDTMatchingMonitor::initialpose_callback, this);
+    ros::Subscriber gnss_sub = nh.subscribe("gnss_pose", 10, &amp;ROSNDTMatchingMonitor::gnss_callback, this);
 
     // Publishers
     initialpose_pub_ = nh.advertise&lt;geometry_msgs::PoseWithCovarianceStamped&gt;("/initialpose", 1);
@@ -242,7 +242,7 @@ void RosNDTMatchingMonitor::Run()
 
 }
 
-RosNDTMatchingMonitor::RosNDTMatchingMonitor()
+ROSNDTMatchingMonitor::ROSNDTMatchingMonitor()
 {
     gnss_pose_available_ = false;
     last_score_     = 0.0;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.h" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.h" added_lines="3" deleted_lines="3">
				<diff>@@ -67,7 +67,7 @@
 
 #include &lt;autoware_msgs/NDTStat.h&gt;
 
-#define __APP_NAME__ "RosNDTMatchingMonitor"
+#define __APP_NAME__ "ROSNDTMatchingMonitor"
 
 #define NDT_THRESHOLD_ITERATION_WARN 10
 #define NDT_THRESHOLD_ITERATION_STOP 32
@@ -75,7 +75,7 @@
 #define NDT_MIN_STABLE_SAMPLES 30
 #define NDT_TIME_TO_FATAL_PREDICTIONS 2.
 
-class RosNDTMatchingMonitor
+class ROSNDTMatchingMonitor
 {
 	enum ndt_status{
 		NDT_NOT_INITIALIZED,
@@ -153,7 +153,7 @@ class RosNDTMatchingMonitor
 	void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input);
 public:
 	void Run();
-	RosNDTMatchingMonitor();
+	ROSNDTMatchingMonitor();
 };
 
 #endif //PROJECT_NDT_MATCHING_MONITOR_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor_node.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -40,7 +40,7 @@ int main(int argc, char **argv)
 {
 	ros::init(argc, argv, __APP_NAME__);
 
-	RosNDTMatchingMonitor app;
+	ROSNDTMatchingMonitor app;
 
 	app.Run();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\include\naive_motion_predict.h" new_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\include\naive_motion_predict.h" added_lines="1" deleted_lines="1">
				<diff>@@ -68,7 +68,7 @@ private:
 
   void objectsCallback(const autoware_msgs::DetectedObjectArray&amp; input);
 
-  void initializeRosmarker(const std_msgs::Header&amp; header, const geometry_msgs::Point&amp; position, const int object_id,
+  void initializeROSmarker(const std_msgs::Header&amp; header, const geometry_msgs::Point&amp; position, const int object_id,
                            visualization_msgs::Marker&amp; predicted_line);
 
   void makePrediction(const autoware_msgs::DetectedObject&amp; object,
</diff>
			</file>
			<file old_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\nodes\naive_motion_predict\naive_motion_predict.cpp" new_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\nodes\naive_motion_predict\naive_motion_predict.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -45,7 +45,7 @@ NaiveMotionPredict::~NaiveMotionPredict()
 {
 }
 
-void NaiveMotionPredict::initializeRosmarker(const std_msgs::Header&amp; header, const geometry_msgs::Point&amp; position,
+void NaiveMotionPredict::initializeROSmarker(const std_msgs::Header&amp; header, const geometry_msgs::Point&amp; position,
                                              const int object_id, visualization_msgs::Marker&amp; predicted_line)
 {
   predicted_line.lifetime = ros::Duration(0.2);
@@ -74,7 +74,7 @@ void NaiveMotionPredict::makePrediction(const autoware_msgs::DetectedObject&amp; obj
                                         visualization_msgs::Marker&amp; predicted_line)
 {
   autoware_msgs::DetectedObject target_object = object;
-  initializeRosmarker(object.header, object.pose.position, object.id, predicted_line);
+  initializeROSmarker(object.header, object.pose.position, object.id, predicted_line);
   for (int i = 0; i &lt; num_prediction_; i++)
   {
     autoware_msgs::DetectedObject predicted_object = generatePredictedObject(target_object);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\include\object_map_utils.hpp" new_path="ros\src\computing\perception\semantics\packages\object_map\include\object_map_utils.hpp" added_lines="2" deleted_lines="2">
				<diff>@@ -61,9 +61,9 @@ namespace object_map
 	void PublishGridMap(const grid_map::GridMap &amp;in_gridmap, const ros::Publisher &amp;in_publisher);
 
 	/*!
-	 * Convert and publishes a GridMap layer to a standard Ros OccupancyGrid
+	 * Convert and publishes a GridMap layer to a standard ROS OccupancyGrid
 	 * @param[in] in_gridmap GridMap object to extract the layer
-	 * @param[in] in_publisher Ros Publisher to use to publish the occupancy grid
+	 * @param[in] in_publisher ROS Publisher to use to publish the occupancy grid
 	 * @param[in] in_layer Name of the layer to convert
 	 * @param[in] in_min_value Minimum value in the layer
 	 * @param[in] in_max_value Maximum value in the layer
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\grid_map_filter\grid_map_filter.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\grid_map_filter\grid_map_filter.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -37,11 +37,11 @@ namespace object_map
 	GridMapFilter::GridMapFilter() :
 			private_node_handle_("~")
 	{
-		InitializeRosIo();
+		InitializeROSIo();
 		LoadRoadAreasFromVectorMap(private_node_handle_, area_points_);
 	}
 
-	void GridMapFilter::InitializeRosIo()
+	void GridMapFilter::InitializeROSIo()
 	{
 		private_node_handle_.param&lt;std::string&gt;("map_frame", map_frame_, "map");
 		private_node_handle_.param&lt;std::string&gt;("map_topic", map_topic_, "/realtime_cost_map");
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\grid_map_filter\grid_map_filter.h" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\grid_map_filter\grid_map_filter.h" added_lines="2" deleted_lines="2">
				<diff>@@ -93,9 +93,9 @@ namespace object_map
 		void OccupancyGridCallback(const nav_msgs::OccupancyGridConstPtr &amp;in_message);
 
 		/*!
-		 * Initializes Ros Publisher, Subscribers and sets the configuration parameters
+		 * Initializes ROS Publisher, Subscribers and sets the configuration parameters
 		 */
-		void InitializeRosIo();
+		void InitializeROSIo();
 
 		/*!
 		 * Applies a Distance Transform to the specified layer in in_layer contained in the GridMap
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -36,12 +36,12 @@ namespace object_map
 	WayareaToGrid::WayareaToGrid() :
 			private_node_handle_("~")
 	{
-		InitializeRosIo();
+		InitializeROSIo();
 		LoadRoadAreasFromVectorMap(private_node_handle_, area_points_);
 	}
 
 
-	void WayareaToGrid::InitializeRosIo()
+	void WayareaToGrid::InitializeROSIo()
 	{
 		private_node_handle_.param&lt;std::string&gt;("sensor_frame", sensor_frame_, "velodyne");
 		private_node_handle_.param&lt;std::string&gt;("map_frame", map_frame_, "map");
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid.h" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid.h" added_lines="2" deleted_lines="2">
				<diff>@@ -92,9 +92,9 @@ namespace object_map
 		std::vector&lt;std::vector&lt;geometry_msgs::Point&gt;&gt; area_points_;
 
 		/*!
-		 * Initializes Ros Publisher, Subscribers and sets the configuration parameters
+		 * Initializes ROS Publisher, Subscribers and sets the configuration parameters
 		 */
-		void InitializeRosIo();
+		void InitializeROSIo();
 
 
 	};
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\include\road_occupancy_processor.h" new_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\include\road_occupancy_processor.h" added_lines="4" deleted_lines="4">
				<diff>@@ -76,7 +76,7 @@
 
 #define __APP_NAME__ "road_occupancy_processor"
 
-class RosRoadOccupancyProcessorApp
+class ROSRoadOccupancyProcessorApp
 
 {
 	ros::NodeHandle                     node_handle_;
@@ -206,9 +206,9 @@ class RosRoadOccupancyProcessorApp
 
 	/*!
 	 * Obtains parameters from the command line, initializes subscribers and publishers.
-	 * @param in_private_handle Ros private handle to get parameters for this node.
+	 * @param in_private_handle ROS private handle to get parameters for this node.
 	 */
-	void InitializeRosIo(ros::NodeHandle&amp; in_private_handle);
+	void InitializeROSIo(ros::NodeHandle&amp; in_private_handle);
 
 	/*!
 	 * Searches for the transformation between in_source_frame and in_target_frame in the TF tree
@@ -238,7 +238,7 @@ class RosRoadOccupancyProcessorApp
 public:
 	void Run();
 
-	RosRoadOccupancyProcessorApp();
+	ROSRoadOccupancyProcessorApp();
 };
 
 #endif //PROJECT_ROAD_OCCUPANCY_PROCESSOR_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\src\road_occupancy_processor.cpp" new_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\src\road_occupancy_processor.cpp" added_lines="20" deleted_lines="20">
				<diff>@@ -36,10 +36,10 @@
 
 #include "road_occupancy_processor.h"
 
-void RosRoadOccupancyProcessorApp::ConvertXYZIToRTZ(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud,
-                                                    RosRoadOccupancyProcessorApp::PointCloudXYZIRTColor &amp;out_organized_points,
+void ROSRoadOccupancyProcessorApp::ConvertXYZIToRTZ(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud,
+                                                    ROSRoadOccupancyProcessorApp::PointCloudXYZIRTColor &amp;out_organized_points,
                                                     std::vector&lt;pcl::PointIndices&gt; &amp;out_radial_divided_indices,
-                                                    std::vector&lt;RosRoadOccupancyProcessorApp::PointCloudXYZIRTColor&gt; &amp;out_radial_ordered_clouds)
+                                                    std::vector&lt;ROSRoadOccupancyProcessorApp::PointCloudXYZIRTColor&gt; &amp;out_radial_ordered_clouds)
 {
 	out_organized_points.resize(in_cloud-&gt;points.size());
 	out_radial_divided_indices.clear();
@@ -84,7 +84,7 @@ void RosRoadOccupancyProcessorApp::ConvertXYZIToRTZ(const pcl::PointCloud&lt;pcl::P
 	}
 }
 
-void RosRoadOccupancyProcessorApp::PublishGridMap(grid_map::GridMap &amp;in_grid_map, const std::string&amp; in_layer_publish)
+void ROSRoadOccupancyProcessorApp::PublishGridMap(grid_map::GridMap &amp;in_grid_map, const std::string&amp; in_layer_publish)
 {
 	if (in_grid_map.exists(in_layer_publish))
 	{
@@ -105,7 +105,7 @@ void RosRoadOccupancyProcessorApp::PublishGridMap(grid_map::GridMap &amp;in_grid_map
 	}
 }
 
-bool RosRoadOccupancyProcessorApp::LoadRoadLayerFromMat(grid_map::GridMap &amp;in_grid_map, cv::Mat &amp;in_grid_image)
+bool ROSRoadOccupancyProcessorApp::LoadRoadLayerFromMat(grid_map::GridMap &amp;in_grid_map, cv::Mat &amp;in_grid_image)
 {
 	if (!in_grid_image.empty())
 	{
@@ -122,7 +122,7 @@ bool RosRoadOccupancyProcessorApp::LoadRoadLayerFromMat(grid_map::GridMap &amp;in_gr
 	return false;
 }
 
-void RosRoadOccupancyProcessorApp::Convert3dPointToOccupancy(grid_map::GridMap &amp;in_grid_map,
+void ROSRoadOccupancyProcessorApp::Convert3dPointToOccupancy(grid_map::GridMap &amp;in_grid_map,
                                                              const geometry_msgs::Point &amp;in_point, cv::Point &amp;out_point)
 {
 	// calculate position
@@ -134,7 +134,7 @@ void RosRoadOccupancyProcessorApp::Convert3dPointToOccupancy(grid_map::GridMap &amp;
 	out_point.y = (in_grid_map.getLength().x() - origin_x_offset - in_point.x) / in_grid_map.getResolution();
 }
 
-void RosRoadOccupancyProcessorApp::DrawLineInGridMap(grid_map::GridMap &amp;in_grid_map, cv::Mat &amp;in_grid_image,
+void ROSRoadOccupancyProcessorApp::DrawLineInGridMap(grid_map::GridMap &amp;in_grid_map, cv::Mat &amp;in_grid_image,
                                                      const geometry_msgs::Point &amp;in_start_point,
                                                      const geometry_msgs::Point &amp;in_end_point, uchar in_value)
 {
@@ -156,7 +156,7 @@ void RosRoadOccupancyProcessorApp::DrawLineInGridMap(grid_map::GridMap &amp;in_grid_
 	}
 }
 
-void RosRoadOccupancyProcessorApp::SetPointInGridMap(grid_map::GridMap &amp;in_grid_map, cv::Mat &amp;in_grid_image,
+void ROSRoadOccupancyProcessorApp::SetPointInGridMap(grid_map::GridMap &amp;in_grid_map, cv::Mat &amp;in_grid_image,
                                                      const geometry_msgs::Point &amp;in_point, uchar in_value)
 {
 	// calculate position
@@ -176,7 +176,7 @@ void RosRoadOccupancyProcessorApp::SetPointInGridMap(grid_map::GridMap &amp;in_grid_
 	}
 }
 
-void RosRoadOccupancyProcessorApp::GridMapCallback(const grid_map_msgs::GridMap&amp; in_message)
+void ROSRoadOccupancyProcessorApp::GridMapCallback(const grid_map_msgs::GridMap&amp; in_message)
 {
 	grid_map::GridMap input_grid;
 	grid_map::GridMapRosConverter::fromMessage(in_message, input_grid);
@@ -194,7 +194,7 @@ void RosRoadOccupancyProcessorApp::GridMapCallback(const grid_map_msgs::GridMap&amp;
 	input_gridmap_position_     = input_grid.getPosition();
 }
 
-void RosRoadOccupancyProcessorApp::ConvertPointCloud(const pcl::PointCloud&lt;pcl::PointXYZI&gt;&amp; in_pointcloud,
+void ROSRoadOccupancyProcessorApp::ConvertPointCloud(const pcl::PointCloud&lt;pcl::PointXYZI&gt;&amp; in_pointcloud,
                                                      const std::string&amp; in_targetframe,
                                                      pcl::PointCloud&lt;pcl::PointXYZI&gt;&amp; out_pointcloud)
 {
@@ -211,7 +211,7 @@ void RosRoadOccupancyProcessorApp::ConvertPointCloud(const pcl::PointCloud&lt;pcl::
 	}
 };
 
-void RosRoadOccupancyProcessorApp::PointsCallback(const sensor_msgs::PointCloud2::ConstPtr &amp;in_ground_cloud_msg,
+void ROSRoadOccupancyProcessorApp::PointsCallback(const sensor_msgs::PointCloud2::ConstPtr &amp;in_ground_cloud_msg,
                                                   const sensor_msgs::PointCloud2::ConstPtr &amp;in_no_ground_cloud_msg)
 {
 	if(road_wayarea_original_mat_.empty())
@@ -303,7 +303,7 @@ void RosRoadOccupancyProcessorApp::PointsCallback(const sensor_msgs::PointCloud2
 
 }
 
-void RosRoadOccupancyProcessorApp::InitializeRosIo(ros::NodeHandle &amp;in_private_handle)
+void ROSRoadOccupancyProcessorApp::InitializeROSIo(ros::NodeHandle &amp;in_private_handle)
 {
 	//get params
 	std::string points_ground_topic_str, points_no_ground_topic_str, wayarea_topic_str;
@@ -345,16 +345,16 @@ void RosRoadOccupancyProcessorApp::InitializeRosIo(ros::NodeHandle &amp;in_private_h
 
 	/*gridmap_subscriber_ = new message_filters::Subscriber&lt;grid_map_msgs::GridMap&gt;(node_handle_,
 	                                                                              wayarea_topic_str, 1);
-	gridmap_subscriber_-&gt;registerCallback(boost::bind(&amp;RosRoadOccupancyProcessorApp::PointsCallback, this));*/
+	gridmap_subscriber_-&gt;registerCallback(boost::bind(&amp;ROSRoadOccupancyProcessorApp::PointsCallback, this));*/
 	gridmap_subscriber_ = node_handle_.subscribe(wayarea_topic_str, 10,
-	                                                             &amp;RosRoadOccupancyProcessorApp::GridMapCallback, this);
+	                                                             &amp;ROSRoadOccupancyProcessorApp::GridMapCallback, this);
 	ROS_INFO("[%s] Subscribing to... %s",__APP_NAME__, wayarea_topic_str.c_str());
 
 	cloud_synchronizer_ =
 			new message_filters::Synchronizer&lt;SyncPolicyT&gt;(SyncPolicyT(100),
 			                                               *cloud_ground_subscriber_,
 			                                               *cloud_no_ground_subscriber_);
-	cloud_synchronizer_-&gt;registerCallback(boost::bind(&amp;RosRoadOccupancyProcessorApp::PointsCallback, this, _1, _2));
+	cloud_synchronizer_-&gt;registerCallback(boost::bind(&amp;ROSRoadOccupancyProcessorApp::PointsCallback, this, _1, _2));
 
 	//register publishers
 	publisher_grid_map_= node_handle_.advertise&lt;grid_map_msgs::GridMap&gt;("gridmap_road_status", 1);
@@ -365,7 +365,7 @@ void RosRoadOccupancyProcessorApp::InitializeRosIo(ros::NodeHandle &amp;in_private_h
 }
 
 tf::StampedTransform
-RosRoadOccupancyProcessorApp::FindTransform(const std::string &amp;in_target_frame, const std::string &amp;in_source_frame)
+ROSRoadOccupancyProcessorApp::FindTransform(const std::string &amp;in_target_frame, const std::string &amp;in_source_frame)
 {
 	tf::StampedTransform transform;
 
@@ -382,7 +382,7 @@ RosRoadOccupancyProcessorApp::FindTransform(const std::string &amp;in_target_frame,
 }
 
 geometry_msgs::Point
-RosRoadOccupancyProcessorApp::TransformPoint(const geometry_msgs::Point &amp;in_point, const tf::Transform &amp;in_transform)
+ROSRoadOccupancyProcessorApp::TransformPoint(const geometry_msgs::Point &amp;in_point, const tf::Transform &amp;in_transform)
 {
 	tf::Point tf_point;
 	tf::pointMsgToTF(in_point, tf_point);
@@ -395,14 +395,14 @@ RosRoadOccupancyProcessorApp::TransformPoint(const geometry_msgs::Point &amp;in_poin
 	return geometry_point;
 }
 
-void RosRoadOccupancyProcessorApp::Run()
+void ROSRoadOccupancyProcessorApp::Run()
 {
 	ros::NodeHandle private_node_handle("~");
 	tf::TransformListener transform_listener;
 
 	transform_listener_ = &amp;transform_listener;
 
-	InitializeRosIo(private_node_handle);
+	InitializeROSIo(private_node_handle);
 
 	ROS_INFO("[%s] Ready. Waiting for data...",__APP_NAME__);
 
@@ -411,7 +411,7 @@ void RosRoadOccupancyProcessorApp::Run()
 	ROS_INFO("[%s] END",__APP_NAME__);
 }
 
-RosRoadOccupancyProcessorApp::RosRoadOccupancyProcessorApp()
+ROSRoadOccupancyProcessorApp::ROSRoadOccupancyProcessorApp()
 {
 	radial_dividers_num_ = ceil(360 / radial_divider_angle_);
 }
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\src\road_occupancy_processor_node.cpp" new_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\src\road_occupancy_processor_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -40,7 +40,7 @@ int main(int argc, char **argv)
 {
 	ros::init(argc, argv, __APP_NAME__);
 
-	RosRoadOccupancyProcessorApp app;
+	ROSRoadOccupancyProcessorApp app;
 
 	app.Run();
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\MappingHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\op_planner\MappingHelpers.h" added_lines="2" deleted_lines="2">
				<diff>@@ -24,7 +24,7 @@ public:
 	MappingHelpers();
 	virtual ~MappingHelpers();
 
-	static void ConstructRoadNetworkFromRosMessage(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
+	static void ConstructRoadNetworkFromROSMessage(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
 			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
 			const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
 			const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
@@ -43,7 +43,7 @@ public:
 			const bool&amp; bFindLaneChangeLanes = false,
 			const bool&amp; bFindCurbsAndWayArea = false);
 
-	static void ConstructRoadNetworkFromRosMessageV2(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
+	static void ConstructRoadNetworkFromROSMessageV2(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
 			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
 				const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
 				const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -91,7 +91,7 @@ int MappingHelpers::ReplaceMyID(int&amp; id,const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp;
 	return -1;
 }
 
-void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
+void MappingHelpers::ConstructRoadNetworkFromROSMessage(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
 		const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
 		const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
 		const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
@@ -599,14 +599,14 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 	// use this to transform data to origin (0,0,0)
 	if(nodes_data.size() &gt; 0 &amp;&amp; bSpecialMap == 0)
 	{
-		ConstructRoadNetworkFromRosMessageV2(lanes_data, points_data, dt_data, intersection_data, area_data,
+		ConstructRoadNetworkFromROSMessageV2(lanes_data, points_data, dt_data, intersection_data, area_data,
 				line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data,
 				way_area_data, crosswalk_data, nodes_data, conn_data, &amp;lanes, &amp;points, &amp;nodes, &amp;lines,
 				GetTransformationOrigin(0), map, false);
 	}
 	else
 	{
-		ConstructRoadNetworkFromRosMessage(lanes_data, points_data, dt_data, intersection_data, area_data,
+		ConstructRoadNetworkFromROSMessage(lanes_data, points_data, dt_data, intersection_data, area_data,
 						line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data,
 						way_area_data, crosswalk_data, nodes_data, conn_data,
 						GetTransformationOrigin(0), map, bSpecialMap == 1);
@@ -2269,7 +2269,7 @@ void MappingHelpers::UpdateMapWithOccupancyGrid(OccupancyToGridMap&amp; map_info, co
 	}
 }
 
-void MappingHelpers::ConstructRoadNetworkFromRosMessageV2(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
+void MappingHelpers::ConstructRoadNetworkFromROSMessageV2(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
 		const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
 		const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
 		const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_ros_helpers\op_RosHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_ros_helpers\op_ROSHelpers.h" added_lines="4" deleted_lines="4">
				<diff>@@ -1,4 +1,4 @@
-/// \file  RosHelpers.h
+/// \file  ROSHelpers.h
 /// \brief Helper functions for rviz visualization
 /// \author Hatem Darweesh
 /// \date Jun 30, 2016
@@ -167,11 +167,11 @@ public:
 	}
 };
 
-class RosHelpers
+class ROSHelpers
 {
 public:
-	RosHelpers();
-	virtual ~RosHelpers();
+	ROSHelpers();
+	virtual ~ROSHelpers();
 
 	static void GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\op_RosHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\op_ROSHelpers.cpp" added_lines="51" deleted_lines="51">
				<diff>@@ -1,9 +1,9 @@
-/// \file  RosHelpers.cpp
+/// \file  ROSHelpers.cpp
 /// \brief Helper functions for rviz visualization
 /// \author Hatem Darweesh
 /// \date Jun 30, 2016
 
-#include "op_ros_helpers/op_RosHelpers.h"
+#include "op_ros_helpers/op_ROSHelpers.h"
 
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;
@@ -17,14 +17,14 @@
 namespace PlannerHNS
 {
 
-RosHelpers::RosHelpers() {
+ROSHelpers::ROSHelpers() {
 
 }
 
-RosHelpers::~RosHelpers() {
+ROSHelpers::~ROSHelpers() {
 }
 
-void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
+void ROSHelpers::GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
 {
 	static tf::TransformListener listener;
 
@@ -48,7 +48,7 @@ void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::s
 	}
 }
 
-visualization_msgs::Marker RosHelpers::CreateGenMarker(const double&amp; x, const double&amp; y, const double&amp; z,const double&amp; a,
+visualization_msgs::Marker ROSHelpers::CreateGenMarker(const double&amp; x, const double&amp; y, const double&amp; z,const double&amp; a,
 		const double&amp; r, const double&amp; g, const double&amp; b, const double&amp; scale, const int&amp; id, const std::string&amp; ns, const int&amp; type)
 {
 	visualization_msgs::Marker mkr;
@@ -72,7 +72,7 @@ visualization_msgs::Marker RosHelpers::CreateGenMarker(const double&amp; x, const do
 	return mkr;
 }
 
-void RosHelpers::InitMarkers(const int&amp; nMarkers,
+void ROSHelpers::InitMarkers(const int&amp; nMarkers,
 		visualization_msgs::MarkerArray&amp; centers,
 		visualization_msgs::MarkerArray&amp; dirs,
 		visualization_msgs::MarkerArray&amp; text_info,
@@ -116,7 +116,7 @@ void RosHelpers::InitMarkers(const int&amp; nMarkers,
 	}
 }
 
-void RosHelpers::InitMatchingMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; connections)
+void ROSHelpers::InitMatchingMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; connections)
 {
 	connections.markers.clear();
 	for(int i=0; i&lt;nMarkers; i++)
@@ -126,7 +126,7 @@ void RosHelpers::InitMatchingMarkers(const int&amp; nMarkers, visualization_msgs::Ma
 	}
 }
 
-void RosHelpers::ConvertMatchingMarkers(const std::vector&lt;std::pair&lt;PlannerHNS::WayPoint, PlannerHNS::WayPoint&gt; &gt;&amp; match_list,
+void ROSHelpers::ConvertMatchingMarkers(const std::vector&lt;std::pair&lt;PlannerHNS::WayPoint, PlannerHNS::WayPoint&gt; &gt;&amp; match_list,
 		visualization_msgs::MarkerArray&amp; tracked_traj_d, visualization_msgs::MarkerArray&amp; tracked_traj, int start_id)
 {
 
@@ -153,7 +153,7 @@ void RosHelpers::ConvertMatchingMarkers(const std::vector&lt;std::pair&lt;PlannerHNS::
 	}
 }
 
-int RosHelpers::ConvertTrackedObjectsMarkers(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
+int ROSHelpers::ConvertTrackedObjectsMarkers(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
 		visualization_msgs::MarkerArray&amp; centers_d,
 		visualization_msgs::MarkerArray&amp; dirs_d,
 		visualization_msgs::MarkerArray&amp; text_info_d,
@@ -285,7 +285,7 @@ int RosHelpers::ConvertTrackedObjectsMarkers(const PlannerHNS::WayPoint&amp; currSta
 	return i_next_id +1;
 }
 
-void RosHelpers::CreateCircleMarker(const PlannerHNS::WayPoint&amp; _center, const double&amp; radius, const int&amp; start_id, visualization_msgs::Marker&amp; circle_points)
+void ROSHelpers::CreateCircleMarker(const PlannerHNS::WayPoint&amp; _center, const double&amp; radius, const int&amp; start_id, visualization_msgs::Marker&amp; circle_points)
 {
 	circle_points = CreateGenMarker(0,0,0,0,1,1,1,0.2,start_id,"Detection_Circles", visualization_msgs::Marker::LINE_STRIP);
 	for (float i = 0; i &lt; M_PI*2.0+0.05; i+=0.05)
@@ -298,7 +298,7 @@ void RosHelpers::CreateCircleMarker(const PlannerHNS::WayPoint&amp; _center, const d
 	}
 }
 
-void RosHelpers::InitPredMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; paths)
+void ROSHelpers::InitPredMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; paths)
 {
 	paths.markers.clear();
 	for(int i=0; i&lt;nMarkers; i++)
@@ -308,7 +308,7 @@ void RosHelpers::InitPredMarkers(const int&amp; nMarkers, visualization_msgs::Marker
 	}
 }
 
-void RosHelpers::InitCurbsMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; curbs)
+void ROSHelpers::InitCurbsMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; curbs)
 {
 	curbs.markers.clear();
 	for(int i=0; i&lt;nMarkers; i++)
@@ -318,7 +318,7 @@ void RosHelpers::InitCurbsMarkers(const int&amp; nMarkers, visualization_msgs::Marke
 	}
 }
 
-void RosHelpers::ConvertPredictedTrqajectoryMarkers(std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths,visualization_msgs::MarkerArray&amp; path_markers, visualization_msgs::MarkerArray&amp; path_markers_d)
+void ROSHelpers::ConvertPredictedTrqajectoryMarkers(std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths,visualization_msgs::MarkerArray&amp; path_markers, visualization_msgs::MarkerArray&amp; path_markers_d)
 {
 
 	path_markers = path_markers_d;
@@ -394,7 +394,7 @@ void RosHelpers::ConvertPredictedTrqajectoryMarkers(std::vector&lt;std::vector&lt;Plan
 	}
 }
 
-void RosHelpers::ConvertCurbsMarkers(const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; curbs, visualization_msgs::MarkerArray&amp; curbs_markers, visualization_msgs::MarkerArray&amp; curbs_markers_d)
+void ROSHelpers::ConvertCurbsMarkers(const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; curbs, visualization_msgs::MarkerArray&amp; curbs_markers, visualization_msgs::MarkerArray&amp; curbs_markers_d)
 {
 
 	curbs_markers = curbs_markers_d;
@@ -412,7 +412,7 @@ void RosHelpers::ConvertCurbsMarkers(const std::vector&lt;PlannerHNS::DetectedObjec
 	}
 }
 
-void RosHelpers::InitCollisionPointsMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; col_points)
+void ROSHelpers::InitCollisionPointsMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; col_points)
 {
 	col_points.markers.clear();
 	for(int i=0; i&lt;nMarkers; i++)
@@ -422,7 +422,7 @@ void RosHelpers::InitCollisionPointsMarkers(const int&amp; nMarkers, visualization_m
 	}
 }
 
-void RosHelpers::ConvertCollisionPointsMarkers(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; col_points, visualization_msgs::MarkerArray&amp; collision_markers, visualization_msgs::MarkerArray&amp; collision_markers_d)
+void ROSHelpers::ConvertCollisionPointsMarkers(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; col_points, visualization_msgs::MarkerArray&amp; collision_markers, visualization_msgs::MarkerArray&amp; collision_markers_d)
 {
 	collision_markers = collision_markers_d;
 	for(unsigned int i = 0; i &lt; col_points.size(); i++)
@@ -437,7 +437,7 @@ void RosHelpers::ConvertCollisionPointsMarkers(const std::vector&lt;PlannerHNS::Way
 	}
 }
 
-void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
+void ROSHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
 		autoware_msgs::Lane&amp; trajectory)
 {
 	trajectory.waypoints.clear();
@@ -461,7 +461,7 @@ void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;Plann
 	}
 }
 
-void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const PlannerHNS::RoadNetwork&amp; map,	visualization_msgs::MarkerArray&amp; markerArray)
+void ROSHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const PlannerHNS::RoadNetwork&amp; map,	visualization_msgs::MarkerArray&amp; markerArray)
 {
 	visualization_msgs::Marker lane_waypoint_marker;
 	lane_waypoint_marker.header.frame_id = "map";
@@ -506,7 +506,7 @@ void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const Planne
 	}
 }
 
-void RosHelpers::InitPredParticlesMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; paths)
+void ROSHelpers::InitPredParticlesMarkers(const int&amp; nMarkers, visualization_msgs::MarkerArray&amp; paths)
 {
 	paths.markers.clear();
 	for(int i=0; i&lt;nMarkers; i++)
@@ -517,7 +517,7 @@ void RosHelpers::InitPredParticlesMarkers(const int&amp; nMarkers, visualization_msg
 	}
 }
 
-void RosHelpers::ConvertParticles(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; points, visualization_msgs::MarkerArray&amp; part_mkrs, visualization_msgs::MarkerArray&amp; part_markers_d)
+void ROSHelpers::ConvertParticles(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; points, visualization_msgs::MarkerArray&amp; part_mkrs, visualization_msgs::MarkerArray&amp; part_markers_d)
 {
 	part_mkrs = part_markers_d;
 	for(unsigned int i = 0; i &lt; points.size(); i++)
@@ -544,7 +544,7 @@ void RosHelpers::ConvertParticles(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; points, vis
 	}
 }
 
-void RosHelpers::ConvertFromPlannerHRectangleToAutowareRviz(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; safety_rect,
+void ROSHelpers::ConvertFromPlannerHRectangleToAutowareRviz(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; safety_rect,
 		visualization_msgs::Marker&amp; marker)
 {
 	//if(safety_rect.size() != 4) return;
@@ -609,7 +609,7 @@ void RosHelpers::ConvertFromPlannerHRectangleToAutowareRviz(const std::vector&lt;Pl
 
 }
 
-void RosHelpers::TrajectoriesToMarkers(const std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt;&amp; paths, visualization_msgs::MarkerArray&amp; markerArray)
+void ROSHelpers::TrajectoriesToMarkers(const std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt;&amp; paths, visualization_msgs::MarkerArray&amp; markerArray)
 {
 	visualization_msgs::Marker lane_waypoint_marker;
 	lane_waypoint_marker.header.frame_id = "map";
@@ -654,7 +654,7 @@ void RosHelpers::TrajectoriesToMarkers(const std::vector&lt;std::vector&lt;std::vector
 	}
 }
 
-void RosHelpers::TrajectoriesToColoredMarkers(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths, const std::vector&lt;PlannerHNS::TrajectoryCost&gt;&amp; traj_costs,const int&amp; iClosest, visualization_msgs::MarkerArray&amp; markerArray)
+void ROSHelpers::TrajectoriesToColoredMarkers(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths, const std::vector&lt;PlannerHNS::TrajectoryCost&gt;&amp; traj_costs,const int&amp; iClosest, visualization_msgs::MarkerArray&amp; markerArray)
 {
 	visualization_msgs::Marker lane_waypoint_marker;
 	lane_waypoint_marker.header.frame_id = "map";
@@ -729,7 +729,7 @@ void RosHelpers::TrajectoriesToColoredMarkers(const std::vector&lt;std::vector&lt;Plan
 	}
 }
 
-void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; curr_path,
+void ROSHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; curr_path,
 		const std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt;&amp; paths, const PlannerHNS::LocalPlannerH&amp; localPlanner,
 			visualization_msgs::MarkerArray&amp; markerArray)
 {
@@ -803,7 +803,7 @@ void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vec
 	}
 }
 
-void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; globalPaths, visualization_msgs::MarkerArray&amp; markerArray)
+void ROSHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; globalPaths, visualization_msgs::MarkerArray&amp; markerArray)
 {
 	visualization_msgs::Marker lane_waypoint_marker;
 	lane_waypoint_marker.header.frame_id = "map";
@@ -847,7 +847,7 @@ void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vec
 	}
 }
 
-void RosHelpers::ConvertFromPlannerObstaclesToAutoware(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
+void ROSHelpers::ConvertFromPlannerObstaclesToAutoware(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
 		visualization_msgs::MarkerArray&amp; detectedPolygons)
 {
 	visualization_msgs::Marker lane_waypoint_marker;
@@ -1027,7 +1027,7 @@ void RosHelpers::ConvertFromPlannerObstaclesToAutoware(const PlannerHNS::WayPoin
 	}
 }
 
-std::string RosHelpers::GetBehaviorNameFromCode(const PlannerHNS::STATE_TYPE&amp; behState)
+std::string ROSHelpers::GetBehaviorNameFromCode(const PlannerHNS::STATE_TYPE&amp; behState)
 {
 	std::string str = "Unknown";
 	switch(behState)
@@ -1073,7 +1073,7 @@ std::string RosHelpers::GetBehaviorNameFromCode(const PlannerHNS::STATE_TYPE&amp; be
 	return str;
 }
 
-void RosHelpers::VisualizeBehaviorState(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::BehaviorState&amp; beh, const bool&amp; bGreenLight, const int&amp; avoidDirection, visualization_msgs::Marker&amp; behaviorMarker, std::string ns,double size_factor)
+void ROSHelpers::VisualizeBehaviorState(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::BehaviorState&amp; beh, const bool&amp; bGreenLight, const int&amp; avoidDirection, visualization_msgs::Marker&amp; behaviorMarker, std::string ns,double size_factor)
 {
 	behaviorMarker.header.frame_id = "map";
 	behaviorMarker.header.stamp = ros::Time();
@@ -1121,7 +1121,7 @@ void RosHelpers::VisualizeBehaviorState(const PlannerHNS::WayPoint&amp; currState, c
 	behaviorMarker.text = str_out.str();
 }
 
-void RosHelpers::ConvertFromAutowareBoundingBoxObstaclesToPlannerH(const jsk_recognition_msgs::BoundingBoxArray&amp; detectedObstacles,
+void ROSHelpers::ConvertFromAutowareBoundingBoxObstaclesToPlannerH(const jsk_recognition_msgs::BoundingBoxArray&amp; detectedObstacles,
 		std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list)
 {
 	obstacles_list.clear();
@@ -1153,7 +1153,7 @@ void RosHelpers::ConvertFromAutowareBoundingBoxObstaclesToPlannerH(const jsk_rec
 	}
 }
 
-void RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const double&amp; car_width,
+void ROSHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const double&amp; car_width,
 		const double&amp; car_length, const autoware_msgs::CloudClusterArray&amp; clusters, vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list,
 		const double max_obj_size, const double&amp; min_obj_size, const double&amp; detection_radius,
 		const int&amp; n_poly_quarters,const double&amp; poly_resolution, int&amp; nOriginalPoints, int&amp; nContourPoints)
@@ -1218,7 +1218,7 @@ void RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const Planne
 	nContourPoints =  nPoints;
 }
 
-PlannerHNS::SHIFT_POS RosHelpers::ConvertShiftFromAutowareToPlannerH(const PlannerHNS::AUTOWARE_SHIFT_POS&amp; shift)
+PlannerHNS::SHIFT_POS ROSHelpers::ConvertShiftFromAutowareToPlannerH(const PlannerHNS::AUTOWARE_SHIFT_POS&amp; shift)
 {
 	if(shift == PlannerHNS::AW_SHIFT_POS_DD)
 		return PlannerHNS::SHIFT_POS_DD;
@@ -1236,7 +1236,7 @@ PlannerHNS::SHIFT_POS RosHelpers::ConvertShiftFromAutowareToPlannerH(const Plann
 		return PlannerHNS::SHIFT_POS_UU;
 }
 
-PlannerHNS::AUTOWARE_SHIFT_POS RosHelpers::ConvertShiftFromPlannerHToAutoware(const PlannerHNS::SHIFT_POS&amp; shift)
+PlannerHNS::AUTOWARE_SHIFT_POS ROSHelpers::ConvertShiftFromPlannerHToAutoware(const PlannerHNS::SHIFT_POS&amp; shift)
 {
 	if(shift == PlannerHNS::SHIFT_POS_DD)
 		return PlannerHNS::AW_SHIFT_POS_DD;
@@ -1254,7 +1254,7 @@ PlannerHNS::AUTOWARE_SHIFT_POS RosHelpers::ConvertShiftFromPlannerHToAutoware(co
 		return PlannerHNS::AW_SHIFT_POS_UU;
 }
 
-PlannerHNS::AutowareBehaviorState RosHelpers::ConvertBehaviorStateFromPlannerHToAutoware(const PlannerHNS::BehaviorState&amp; beh)
+PlannerHNS::AutowareBehaviorState ROSHelpers::ConvertBehaviorStateFromPlannerHToAutoware(const PlannerHNS::BehaviorState&amp; beh)
 {
 	PlannerHNS::AutowareBehaviorState arw_state;
 	arw_state.followDistance = beh.followDistance;
@@ -1300,7 +1300,7 @@ PlannerHNS::AutowareBehaviorState RosHelpers::ConvertBehaviorStateFromPlannerHTo
 
 }
 
-void RosHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, autoware_msgs::Lane&amp; trajectory , const unsigned int&amp; iStart)
+void ROSHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, autoware_msgs::Lane&amp; trajectory , const unsigned int&amp; iStart)
 {
 	trajectory.waypoints.clear();
 
@@ -1334,7 +1334,7 @@ void RosHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS
 	}
 }
 
-void RosHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path, autoware_msgs::Lane&amp; trajectory)
+void ROSHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path, autoware_msgs::Lane&amp; trajectory)
 {
 	trajectory.waypoints.clear();
 
@@ -1350,7 +1350,7 @@ void RosHelpers::ConvertFromLocalLaneToAutowareLane(const std::vector&lt;PlannerHNS
 	}
 }
 
-void RosHelpers::ConvertFromAutowareLaneToLocalLane(const autoware_msgs::Lane&amp; trajectory, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
+void ROSHelpers::ConvertFromAutowareLaneToLocalLane(const autoware_msgs::Lane&amp; trajectory, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
 {
 	path.clear();
 
@@ -1392,7 +1392,7 @@ void RosHelpers::ConvertFromAutowareLaneToLocalLane(const autoware_msgs::Lane&amp; t
 	}
 }
 
-void RosHelpers::createGlobalLaneArrayMarker(std_msgs::ColorRGBA color,
+void ROSHelpers::createGlobalLaneArrayMarker(std_msgs::ColorRGBA color,
 		const autoware_msgs::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray)
 {
   visualization_msgs::Marker lane_waypoint_marker;
@@ -1424,7 +1424,7 @@ void RosHelpers::createGlobalLaneArrayMarker(std_msgs::ColorRGBA color,
 
 }
 
-void RosHelpers::createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
+void ROSHelpers::createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
 		, visualization_msgs::MarkerArray&amp; markerArray)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
@@ -1472,7 +1472,7 @@ void RosHelpers::createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneAr
                                        tmp_marker_array.markers.end());
 }
 
-void RosHelpers::createGlobalLaneArrayOrientationMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
+void ROSHelpers::createGlobalLaneArrayOrientationMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
 		, visualization_msgs::MarkerArray&amp; markerArray)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
@@ -1545,7 +1545,7 @@ void RosHelpers::createGlobalLaneArrayOrientationMarker(const autoware_msgs::Lan
 										   tmp_marker_array.markers.end());
 }
 
-void RosHelpers::GetTrafficLightForVisualization(std::vector&lt;PlannerHNS::TrafficLight&gt;&amp; lights, visualization_msgs::MarkerArray&amp; markerArray)
+void ROSHelpers::GetTrafficLightForVisualization(std::vector&lt;PlannerHNS::TrafficLight&gt;&amp; lights, visualization_msgs::MarkerArray&amp; markerArray)
 {
 	markerArray.markers.clear();
 	for(unsigned int i=0; i&lt;lights.size(); i++)
@@ -1563,7 +1563,7 @@ void RosHelpers::GetTrafficLightForVisualization(std::vector&lt;PlannerHNS::Traffic
 	}
 }
 
-void RosHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(const autoware_msgs::DetectedObject&amp; det_obj, PlannerHNS::DetectedObject&amp; obj)
+void ROSHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(const autoware_msgs::DetectedObject&amp; det_obj, PlannerHNS::DetectedObject&amp; obj)
 {
 	obj.id = det_obj.id;
 	obj.label = det_obj.label;
@@ -1608,7 +1608,7 @@ void RosHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(co
 	for(unsigned int j = 0 ; j &lt; det_obj.candidate_trajectories.lanes.size(); j++)
 	{
 		std::vector&lt;PlannerHNS::WayPoint&gt; _traj;
-		PlannerHNS::RosHelpers::ConvertFromAutowareLaneToLocalLane(det_obj.candidate_trajectories.lanes.at(j), _traj);
+		PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(det_obj.candidate_trajectories.lanes.at(j), _traj);
 		for(unsigned int k=0; k &lt; _traj.size(); k++)
 			_traj.at(k).collisionCost = det_obj.candidate_trajectories.lanes.at(j).cost;
 
@@ -1616,7 +1616,7 @@ void RosHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(co
 	}
 }
 
-void RosHelpers::ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(const PlannerHNS::DetectedObject&amp; det_obj, const bool&amp; bSimulationMode, autoware_msgs::DetectedObject&amp; obj)
+void ROSHelpers::ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(const PlannerHNS::DetectedObject&amp; det_obj, const bool&amp; bSimulationMode, autoware_msgs::DetectedObject&amp; obj)
 {
 	if(bSimulationMode)
 		obj.id = det_obj.originalID;
@@ -1656,7 +1656,7 @@ void RosHelpers::ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(co
 	for(unsigned int j = 0 ; j &lt; det_obj.predTrajectories.size(); j++)
 	{
 		autoware_msgs::Lane pred_traj;
-		PlannerHNS::RosHelpers::ConvertFromLocalLaneToAutowareLane(det_obj.predTrajectories.at(j), pred_traj);
+		PlannerHNS::ROSHelpers::ConvertFromLocalLaneToAutowareLane(det_obj.predTrajectories.at(j), pred_traj);
 		if(det_obj.predTrajectories.at(j).size() &gt; 0)
 		{
 			pred_traj.cost = det_obj.predTrajectories.at(j).at(0).collisionCost;
@@ -1666,7 +1666,7 @@ void RosHelpers::ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(co
 	}
 }
 
-void RosHelpers::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::RoadNetwork&amp; out_map)
+void ROSHelpers::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::RoadNetwork&amp; out_map)
 {
 	std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt; lanes;
 	for(unsigned int i=0; i &lt; src_map.lanes.data.size();i++)
@@ -1766,10 +1766,10 @@ void RosHelpers::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::R
 	std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;
 
 	PlannerHNS::GPSPoint origin;//(m_OriginPos.position.x, m_OriginPos.position.y, m_OriginPos.position.z, 0);
-	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data,way_area, crossing, nodes_data,  conn_data, origin, out_map);
+	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data,way_area, crossing, nodes_data,  conn_data, origin, out_map);
 }
 
-void RosHelpers::GetIndicatorArrows(const PlannerHNS::WayPoint&amp; center, const double&amp; width,const double&amp; length, const PlannerHNS::LIGHT_INDICATOR&amp; indicator, const int&amp; id, visualization_msgs::MarkerArray&amp; markerArray)
+void ROSHelpers::GetIndicatorArrows(const PlannerHNS::WayPoint&amp; center, const double&amp; width,const double&amp; length, const PlannerHNS::LIGHT_INDICATOR&amp; indicator, const int&amp; id, visualization_msgs::MarkerArray&amp; markerArray)
 {
 	double critical_lateral_distance =  width/2.0 + 0.2;
 	//double critical_long_front_distance =  carInfo.length/2.0 ;
@@ -1805,17 +1805,17 @@ void RosHelpers::GetIndicatorArrows(const PlannerHNS::WayPoint&amp; center, const do
 		color_r.b = 0;
 	}
 
-	visualization_msgs::Marker mkr_l = PlannerHNS::RosHelpers::CreateGenMarker(top_left.x,top_left.y,top_left.z,top_left.a,color_l.r,color_l.g,color_l.b,1.0, id,"simu_car_indicator_left", visualization_msgs::Marker::ARROW);
+	visualization_msgs::Marker mkr_l = PlannerHNS::ROSHelpers::CreateGenMarker(top_left.x,top_left.y,top_left.z,top_left.a,color_l.r,color_l.g,color_l.b,1.0, id,"simu_car_indicator_left", visualization_msgs::Marker::ARROW);
 	mkr_l.scale.y = 0.4;
 	mkr_l.scale.z = 0.4;
-	visualization_msgs::Marker mkr_r = PlannerHNS::RosHelpers::CreateGenMarker(top_right.x,top_right.y,top_right.z,top_right.a,color_r.r,color_r.g,color_r.b,1.0, id,"simu_car_indicator_right", visualization_msgs::Marker::ARROW);
+	visualization_msgs::Marker mkr_r = PlannerHNS::ROSHelpers::CreateGenMarker(top_right.x,top_right.y,top_right.z,top_right.a,color_r.r,color_r.g,color_r.b,1.0, id,"simu_car_indicator_right", visualization_msgs::Marker::ARROW);
 	mkr_r.scale.y = 0.4;
 	mkr_r.scale.z = 0.4;
 	markerArray.markers.push_back(mkr_l);
 	markerArray.markers.push_back(mkr_r);
 }
 
-void RosHelpers::TTC_PathRviz(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, visualization_msgs::MarkerArray&amp; markerArray)
+void ROSHelpers::TTC_PathRviz(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, visualization_msgs::MarkerArray&amp; markerArray)
 {
 	visualization_msgs::Marker lane_waypoint_marker;
 	lane_waypoint_marker.header.frame_id = "map";
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" added_lines="13" deleted_lines="13">
				<diff>@@ -29,7 +29,7 @@
  */
 
 #include "op_global_planner_core.h"
-#include "op_ros_helpers/op_RosHelpers.h"
+#include "op_ros_helpers/op_ROSHelpers.h"
 
 namespace GlobalPlanningNS
 {
@@ -61,7 +61,7 @@ GlobalPlanner::GlobalPlanner()
 		m_params.mapSource = PlannerHNS::MAP_KML_FILE;
 
 	tf::StampedTransform transform;
-	PlannerHNS::RosHelpers::GetTransformFromTF("map", "world", transform);
+	PlannerHNS::ROSHelpers::GetTransformFromTF("map", "world", transform);
 	m_OriginPos.position.x  = transform.getOrigin().x();
 	m_OriginPos.position.y  = transform.getOrigin().y();
 	m_OriginPos.position.z  = transform.getOrigin().z();
@@ -151,9 +151,9 @@ void GlobalPlanner::callbackGetRoadStatusOccupancyGrid(const nav_msgs::Occupancy
 	m_ModifiedMapItemsTimes.push_back(std::make_pair(modified_nodes, t));
 
 	visualization_msgs::MarkerArray map_marker_array;
-	PlannerHNS::RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
+	PlannerHNS::ROSHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
 
-//	visualization_msgs::Marker mkr = PlannerHNS::RosHelpers::CreateGenMarker(center.pos.x, center.pos.y, center.pos.z, 0, 0,0,1,0.5, 1000, "TestCenter", visualization_msgs::Marker::SPHERE);
+//	visualization_msgs::Marker mkr = PlannerHNS::ROSHelpers::CreateGenMarker(center.pos.x, center.pos.y, center.pos.z, 0, 0,0,1,0.5, 1000, "TestCenter", visualization_msgs::Marker::SPHERE);
 //
 //	map_marker_array.markers.push_back(mkr);
 
@@ -282,7 +282,7 @@ void GlobalPlanner::VisualizeAndSend(const std::vector&lt;std::vector&lt;PlannerHNS::W
 	for(unsigned int i=0; i &lt; generatedTotalPaths.size(); i++)
 	{
 		autoware_msgs::Lane lane;
-		PlannerHNS::RosHelpers::ConvertFromLocalLaneToAutowareLane(generatedTotalPaths.at(i), lane);
+		PlannerHNS::ROSHelpers::ConvertFromLocalLaneToAutowareLane(generatedTotalPaths.at(i), lane);
 		lane_array.lanes.push_back(lane);
 	}
 
@@ -291,9 +291,9 @@ void GlobalPlanner::VisualizeAndSend(const std::vector&lt;std::vector&lt;PlannerHNS::W
 	total_color.g = 0.7;
 	total_color.b = 1.0;
 	total_color.a = 0.9;
-	PlannerHNS::RosHelpers::createGlobalLaneArrayMarker(total_color, lane_array, pathsToVisualize);
-	PlannerHNS::RosHelpers::createGlobalLaneArrayOrientationMarker(lane_array, pathsToVisualize);
-	PlannerHNS::RosHelpers::createGlobalLaneArrayVelocityMarker(lane_array, pathsToVisualize);
+	PlannerHNS::ROSHelpers::createGlobalLaneArrayMarker(total_color, lane_array, pathsToVisualize);
+	PlannerHNS::ROSHelpers::createGlobalLaneArrayOrientationMarker(lane_array, pathsToVisualize);
+	PlannerHNS::ROSHelpers::createGlobalLaneArrayVelocityMarker(lane_array, pathsToVisualize);
 	pub_PathsRviz.publish(pathsToVisualize);
 	if((m_bFirstStart &amp;&amp; m_params.bEnableHMI) || !m_params.bEnableHMI)
 		pub_Paths.publish(lane_array);
@@ -426,7 +426,7 @@ void GlobalPlanner::MainLoop()
 			m_bKmlMap = true;
 			PlannerHNS::MappingHelpers::LoadKML(m_params.KmlMapPath, m_Map);
 			visualization_msgs::MarkerArray map_marker_array;
-			PlannerHNS::RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
+			PlannerHNS::ROSHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
 			pub_MapRviz.publish(map_marker_array);
 		}
 		else if (m_params.mapSource == PlannerHNS::MAP_FOLDER &amp;&amp; !m_bKmlMap)
@@ -434,7 +434,7 @@ void GlobalPlanner::MainLoop()
 			m_bKmlMap = true;
 			PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_params.KmlMapPath, m_Map, true);
 			visualization_msgs::MarkerArray map_marker_array;
-			PlannerHNS::RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
+			PlannerHNS::ROSHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
 
 			pub_MapRviz.publish(map_marker_array);
 		}
@@ -446,7 +446,7 @@ void GlobalPlanner::MainLoop()
 			{
 				std::cout &lt;&lt; "Map Version 2" &lt;&lt; endl;
 				m_bKmlMap = true;
-				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
@@ -457,7 +457,7 @@ void GlobalPlanner::MainLoop()
 			{
 				std::cout &lt;&lt; "Map Version 1" &lt;&lt; endl;
 				m_bKmlMap = true;
-				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
@@ -467,7 +467,7 @@ void GlobalPlanner::MainLoop()
 			if(m_bKmlMap)
 			{
 				visualization_msgs::MarkerArray map_marker_array;
-				PlannerHNS::RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
+				PlannerHNS::ROSHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
 				pub_MapRviz.publish(map_marker_array);
 			}
 		}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\RosHelpers.h" new_path="ros\src\computing\planning\mission\packages\way_planner\include\ROSHelpers.h" added_lines="4" deleted_lines="4">
				<diff>@@ -1,5 +1,5 @@
 /*
- * RosHelpers.h
+ * ROSHelpers.h
  *
  *  Created on: Jun 30, 2016
  *      Author: Hatem Darweesh
@@ -113,11 +113,11 @@ public:
 	}
 };
 
-class RosHelpers
+class ROSHelpers
 {
 public:
-	RosHelpers();
-	virtual ~RosHelpers();
+	ROSHelpers();
+	virtual ~ROSHelpers();
 	static void GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform);
 	static void ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
 				autoware_msgs::LaneArray&amp; laneArray);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\SocketServer.h" new_path="ros\src\computing\planning\mission\packages\way_planner\include\SocketServer.h" added_lines="1" deleted_lines="1">
				<diff>@@ -16,7 +16,7 @@
 #include &lt;sys/types.h&gt;
 #include &lt;unistd.h&gt;
 #include &lt;pthread.h&gt;
-#include "RosHelpers.h"
+#include "ROSHelpers.h"
 
 namespace WayPlannerNS
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\way_planner_core.h" new_path="ros\src\computing\planning\mission\packages\way_planner\include\way_planner_core.h" added_lines="1" deleted_lines="1">
				<diff>@@ -61,7 +61,7 @@
 #include "op_planner/MappingHelpers.h"
 #include "op_planner/PlanningHelpers.h"
 #include "op_planner/PlannerH.h"
-#include "RosHelpers.h"
+#include "ROSHelpers.h"
 #include "SocketServer.h"
 
 namespace WayPlannerNS {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\RosHelpers.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\ROSHelpers.cpp" added_lines="18" deleted_lines="18">
				<diff>@@ -1,11 +1,11 @@
 /*
- * RosHelpers.cpp
+ * ROSHelpers.cpp
  *
  *  Created on: Jun 30, 2016
  *      Author: ai-driver
  */
 
-#include "RosHelpers.h"
+#include "ROSHelpers.h"
 
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;
@@ -15,14 +15,14 @@
 
 namespace WayPlannerNS {
 
-RosHelpers::RosHelpers() {
+ROSHelpers::ROSHelpers() {
 
 }
 
-RosHelpers::~RosHelpers() {
+ROSHelpers::~ROSHelpers() {
 }
 
-void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
+void ROSHelpers::GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
 {
 	static tf::TransformListener listener;
 
@@ -41,7 +41,7 @@ void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::s
 	}
 }
 
-void RosHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path,
+void ROSHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path,
 		autoware_msgs::LaneArray&amp; laneArray)
 {
 	autoware_msgs::Lane l;
@@ -62,7 +62,7 @@ void RosHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(const std::vector
 		laneArray.lanes.push_back(l);
 }
 
-void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
+void ROSHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
 		autoware_msgs::LaneArray&amp; laneArray)
 {
 	autoware_msgs::Lane l;
@@ -106,13 +106,13 @@ void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;Plann
 		laneArray.lanes.push_back(l);
 }
 
-void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const PlannerHNS::RoadNetwork&amp; map,	visualization_msgs::MarkerArray&amp; markerArray)
+void ROSHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const PlannerHNS::RoadNetwork&amp; map,	visualization_msgs::MarkerArray&amp; markerArray)
 {
 	markerArray.markers.clear();
 	autoware_msgs::LaneArray map_lane_array;
 	for(unsigned int i = 0; i&lt; map.roadSegments.size(); i++)
 		for(unsigned int j = 0; j &lt; map.roadSegments.at(i).Lanes.size(); j++)
-			RosHelpers::ConvertFromPlannerHToAutowarePathFormat(map.roadSegments.at(i).Lanes.at(j).points, map_lane_array);
+			ROSHelpers::ConvertFromPlannerHToAutowarePathFormat(map.roadSegments.at(i).Lanes.at(j).points, map_lane_array);
 
 	std_msgs::ColorRGBA total_color;
 	total_color.r = 1;
@@ -148,7 +148,7 @@ void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const Planne
 	    count++;
 	  }
 
-	  RosHelpers::createGlobalLaneArrayOrientationMarker(map_lane_array, markerArray);
+	  ROSHelpers::createGlobalLaneArrayOrientationMarker(map_lane_array, markerArray);
 		total_color.r = 0.99;
 		total_color.g = 0.99;
 		total_color.b = 0.99;
@@ -174,7 +174,7 @@ void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const Planne
 			  stop_waypoint_marker.ns =ns_id.str();
 
 			  autoware_msgs::LaneArray lane_array_2;
-			  RosHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(map.stopLines.at(i).points, lane_array_2);
+			  ROSHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(map.stopLines.at(i).points, lane_array_2);
 
 			  stop_waypoint_marker.points.clear();
 			  stop_waypoint_marker.id = count;
@@ -196,10 +196,10 @@ void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const Planne
 
 
 
-	  //RosHelpers::createGlobalLaneArrayOrientationMarker(map_lane_array, markerArray);
+	  //ROSHelpers::createGlobalLaneArrayOrientationMarker(map_lane_array, markerArray);
 }
 
-void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; curr_path,
+void ROSHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; curr_path,
 		const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths,
 			visualization_msgs::MarkerArray&amp; markerArray)
 {
@@ -266,7 +266,7 @@ void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vec
 	count++;
 }
 
-void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; globalPaths,
+void ROSHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; globalPaths,
 			visualization_msgs::MarkerArray&amp; markerArray)
 {
 	visualization_msgs::Marker lane_waypoint_marker;
@@ -345,7 +345,7 @@ void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vec
 	}
 }
 
-void RosHelpers::createGlobalLaneArrayMarker(std_msgs::ColorRGBA color,
+void ROSHelpers::createGlobalLaneArrayMarker(std_msgs::ColorRGBA color,
 		const autoware_msgs::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray)
 {
   visualization_msgs::Marker lane_waypoint_marker;
@@ -377,7 +377,7 @@ void RosHelpers::createGlobalLaneArrayMarker(std_msgs::ColorRGBA color,
 
 }
 
-void RosHelpers::createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
+void ROSHelpers::createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
 		, visualization_msgs::MarkerArray&amp; markerArray)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
@@ -425,7 +425,7 @@ void RosHelpers::createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneAr
                                        tmp_marker_array.markers.end());
 }
 
-void RosHelpers::createGlobalLaneArrayOrientationMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
+void ROSHelpers::createGlobalLaneArrayOrientationMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
 		, visualization_msgs::MarkerArray&amp; markerArray)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
@@ -485,7 +485,7 @@ void RosHelpers::createGlobalLaneArrayOrientationMarker(const autoware_msgs::Lan
 										   tmp_marker_array.markers.end());
 }
 
-void RosHelpers::FindIncommingBranches(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; globalPaths, const PlannerHNS::WayPoint&amp; currPose,const double&amp; min_distance,
+void ROSHelpers::FindIncommingBranches(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; globalPaths, const PlannerHNS::WayPoint&amp; currPose,const double&amp; min_distance,
 			std::vector&lt;PlannerHNS::WayPoint*&gt;&amp; branches, PlannerHNS::WayPoint* currOptions)
 {
 	static int detection_range = 30; // meter
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" added_lines="10" deleted_lines="10">
				<diff>@@ -370,7 +370,7 @@ void way_planner_core::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, Planner
 	std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;
 
 	PlannerHNS::GPSPoint origin;//(m_OriginPos.position.x, m_OriginPos.position.y, m_OriginPos.position.z, 0);
-	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data,way_area, crossing, nodes_data, conn_data, origin, out_map);
+	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data,way_area, crossing, nodes_data, conn_data, origin, out_map);
 }
 
 bool way_planner_core::GenerateGlobalPlan(PlannerHNS::WayPoint&amp; startPoint, PlannerHNS::WayPoint&amp; goalPoint, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; generatedTotalPaths)
@@ -445,17 +445,17 @@ void way_planner_core::VisualizeAndSend(const std::vector&lt;std::vector&lt;PlannerHNS
 	visualization_msgs::MarkerArray pathsToVisualize;
 
 	for(unsigned int i=0; i &lt; generatedTotalPaths.size(); i++)
-		RosHelpers::ConvertFromPlannerHToAutowarePathFormat(generatedTotalPaths.at(i), lane_array);
+		ROSHelpers::ConvertFromPlannerHToAutowarePathFormat(generatedTotalPaths.at(i), lane_array);
 
 	std_msgs::ColorRGBA total_color;
 	total_color.r = 0;
 	total_color.g = 0.7;
 	total_color.b = 1.0;
 	total_color.a = 0.9;
-	RosHelpers::createGlobalLaneArrayMarker(total_color, lane_array, pathsToVisualize);
-	RosHelpers::createGlobalLaneArrayOrientationMarker(lane_array, pathsToVisualize);
-	RosHelpers::createGlobalLaneArrayVelocityMarker(lane_array, pathsToVisualize);
-	//RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(generatedTotalPaths, pathsToVisualize);
+	ROSHelpers::createGlobalLaneArrayMarker(total_color, lane_array, pathsToVisualize);
+	ROSHelpers::createGlobalLaneArrayOrientationMarker(lane_array, pathsToVisualize);
+	ROSHelpers::createGlobalLaneArrayVelocityMarker(lane_array, pathsToVisualize);
+	//ROSHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(generatedTotalPaths, pathsToVisualize);
 	pub_PathsRviz.publish(pathsToVisualize);
 	pub_Paths.publish(lane_array);
 
@@ -568,7 +568,7 @@ bool way_planner_core::HMI_DoOneStep()
 		startPoint = m_CurrentPose;
 
 	PlannerHNS::WayPoint* currOptions = 0;
-	RosHelpers::FindIncommingBranches(m_GeneratedTotalPaths,startPoint, min_distance, branches, currOptions);
+	ROSHelpers::FindIncommingBranches(m_GeneratedTotalPaths,startPoint, min_distance, branches, currOptions);
 	if(branches.size() &gt; 0)
 	{
 		HMI_MSG msg;
@@ -685,7 +685,7 @@ void way_planner_core::PlannerMainLoop()
 			PlannerHNS::MappingHelpers::LoadKML(m_params.KmlMapPath, m_Map);
 			//PlannerHNS::MappingHelpers::WriteKML("/home/hatem/SimuLogs/KmlMaps/ToyotaMap2017.kml", "/home/hatem/SimuLogs/KmlMaps/PlannerX_MapTemplate.kml", m_Map);
 			visualization_msgs::MarkerArray map_marker_array;
-			RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
+			ROSHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
 			pub_MapRviz.publish(map_marker_array);
 		}
 		else if (m_params.mapSource == MAP_FOLDER &amp;&amp; !m_bKmlMap)
@@ -694,7 +694,7 @@ void way_planner_core::PlannerMainLoop()
 			PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_params.KmlMapPath, m_Map, true);
 			//PlannerHNS::MappingHelpers::WriteKML("/home/hatem/SimuLogs/KmlMaps/Moriyama_NoTransform_2017.kml", "/home/hatem/SimuLogs/KmlMaps/PlannerX_MapTemplate.kml", m_Map);
 			visualization_msgs::MarkerArray map_marker_array;
-			RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
+			ROSHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
 
 			pub_MapRviz.publish(map_marker_array);
 
@@ -706,7 +706,7 @@ void way_planner_core::PlannerMainLoop()
 				 m_AwMap.bDtLanes = m_AwMap.bLanes = m_AwMap.bPoints = false;
 				 UpdateRoadMap(m_AwMap,m_Map);
 				visualization_msgs::MarkerArray map_marker_array;
-				RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
+				ROSHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
 				pub_MapRviz.publish(map_marker_array);
 			 }
 		}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\include\RosHelpers.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\ROSHelpers.h" added_lines="4" deleted_lines="4">
				<diff>@@ -1,5 +1,5 @@
 /*
- * RosHelpers.h
+ * ROSHelpers.h
  *
  *  Created on: Jun 30, 2016
  *      Author: ai-driver
@@ -168,11 +168,11 @@ public:
 	}
 };
 
-class RosHelpers
+class ROSHelpers
 {
 public:
-	RosHelpers();
-	virtual ~RosHelpers();
+	ROSHelpers();
+	virtual ~ROSHelpers();
 	static void GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform);
 	static void ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
 				autoware_msgs::Lane &amp; trajectory);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" added_lines="1" deleted_lines="1">
				<diff>@@ -60,7 +60,7 @@
 #include "op_planner/MappingHelpers.h"
 #include "op_planner/PlanningHelpers.h"
 #include "op_planner/LocalPlannerH.h"
-#include "RosHelpers.h"
+#include "ROSHelpers.h"
 #include "op_simu/SimpleTracker.h"
 
 #include &lt;opencv/cv.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\RosHelpers.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\ROSHelpers.cpp" added_lines="20" deleted_lines="20">
				<diff>@@ -1,11 +1,11 @@
 /*
- * RosHelpers.cpp
+ * ROSHelpers.cpp
  *
  *  Created on: Jun 30, 2016
  *      Author: ai-driver
  */
 
-#include "RosHelpers.h"
+#include "ROSHelpers.h"
 
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;
@@ -19,14 +19,14 @@
 namespace PlannerXNS
 {
 
-RosHelpers::RosHelpers() {
+ROSHelpers::ROSHelpers() {
 
 }
 
-RosHelpers::~RosHelpers() {
+ROSHelpers::~ROSHelpers() {
 }
 
-void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
+void ROSHelpers::GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
 {
 	static tf::TransformListener listener;
 
@@ -50,7 +50,7 @@ void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::s
 	}
 }
 
-void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
+void ROSHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
 		autoware_msgs::Lane&amp; trajectory)
 {
 	trajectory.waypoints.clear();
@@ -74,7 +74,7 @@ void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;Plann
 	}
 }
 
-void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const PlannerHNS::RoadNetwork&amp; map,	visualization_msgs::MarkerArray&amp; markerArray)
+void ROSHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const PlannerHNS::RoadNetwork&amp; map,	visualization_msgs::MarkerArray&amp; markerArray)
 {
 	visualization_msgs::Marker lane_waypoint_marker;
 	lane_waypoint_marker.header.frame_id = "map";
@@ -119,7 +119,7 @@ void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const Planne
 	}
 }
 
-void RosHelpers::ConvertFromPlannerHRectangleToAutowareRviz(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; safety_rect,
+void ROSHelpers::ConvertFromPlannerHRectangleToAutowareRviz(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; safety_rect,
 		visualization_msgs::Marker&amp; marker)
 {
 	//if(safety_rect.size() != 4) return;
@@ -185,7 +185,7 @@ void RosHelpers::ConvertFromPlannerHRectangleToAutowareRviz(const std::vector&lt;Pl
 
 }
 
-void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; curr_path,
+void ROSHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; curr_path,
 		const std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt;&amp; paths, const PlannerHNS::LocalPlannerH&amp; localPlanner,
 			visualization_msgs::MarkerArray&amp; markerArray)
 {
@@ -259,7 +259,7 @@ void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vec
 	}
 }
 
-void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; globalPaths,
+void ROSHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; globalPaths,
 			visualization_msgs::MarkerArray&amp; markerArray)
 {
 	visualization_msgs::Marker lane_waypoint_marker;
@@ -304,7 +304,7 @@ void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vec
 	}
 }
 
-void RosHelpers::ConvertFromPlannerObstaclesToAutoware(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
+void ROSHelpers::ConvertFromPlannerObstaclesToAutoware(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
 		visualization_msgs::MarkerArray&amp; detectedPolygons)
 {
 	visualization_msgs::Marker lane_waypoint_marker;
@@ -484,7 +484,7 @@ void RosHelpers::ConvertFromPlannerObstaclesToAutoware(const PlannerHNS::WayPoin
 	}
 }
 
-std::string RosHelpers::GetBehaviorNameFromCode(const PlannerHNS::STATE_TYPE&amp; behState)
+std::string ROSHelpers::GetBehaviorNameFromCode(const PlannerHNS::STATE_TYPE&amp; behState)
 {
 	std::string str = "Unknown";
 	switch(behState)
@@ -530,7 +530,7 @@ std::string RosHelpers::GetBehaviorNameFromCode(const PlannerHNS::STATE_TYPE&amp; be
 	return str;
 }
 
-void RosHelpers::VisualizeBehaviorState(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::BehaviorState&amp; beh, const bool&amp; bGreenLight, const int&amp; avoidDirection, visualization_msgs::Marker&amp; behaviorMarker)
+void ROSHelpers::VisualizeBehaviorState(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::BehaviorState&amp; beh, const bool&amp; bGreenLight, const int&amp; avoidDirection, visualization_msgs::Marker&amp; behaviorMarker)
 {
 	behaviorMarker.header.frame_id = "map";
 	behaviorMarker.header.stamp = ros::Time();
@@ -576,7 +576,7 @@ void RosHelpers::VisualizeBehaviorState(const PlannerHNS::WayPoint&amp; currState, c
 	behaviorMarker.text = str_out.str();
 }
 
-void RosHelpers::ConvertFromAutowareBoundingBoxObstaclesToPlannerH(const jsk_recognition_msgs::BoundingBoxArray&amp; detectedObstacles,
+void ROSHelpers::ConvertFromAutowareBoundingBoxObstaclesToPlannerH(const jsk_recognition_msgs::BoundingBoxArray&amp; detectedObstacles,
 		std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list)
 {
 	obstacles_list.clear();
@@ -608,7 +608,7 @@ void RosHelpers::ConvertFromAutowareBoundingBoxObstaclesToPlannerH(const jsk_rec
 	}
 }
 
-void RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::CAR_BASIC_INFO&amp; car_info,
+void ROSHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::CAR_BASIC_INFO&amp; car_info,
 		const autoware_msgs::CloudClusterArray&amp; clusters, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list,
 		int&amp; nOriginalPoints, int&amp; nContourPoints)
 {
@@ -665,7 +665,7 @@ void RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const Planne
 	nContourPoints =  nPoints;
 }
 
-PlannerHNS::SHIFT_POS RosHelpers::ConvertShiftFromAutowareToPlannerH(const PlannerXNS::AUTOWARE_SHIFT_POS&amp; shift)
+PlannerHNS::SHIFT_POS ROSHelpers::ConvertShiftFromAutowareToPlannerH(const PlannerXNS::AUTOWARE_SHIFT_POS&amp; shift)
 {
 	if(shift == PlannerXNS::AW_SHIFT_POS_DD)
 		return PlannerHNS::SHIFT_POS_DD;
@@ -683,7 +683,7 @@ PlannerHNS::SHIFT_POS RosHelpers::ConvertShiftFromAutowareToPlannerH(const Plann
 		return PlannerHNS::SHIFT_POS_UU;
 }
 
-PlannerXNS::AUTOWARE_SHIFT_POS RosHelpers::ConvertShiftFromPlannerHToAutoware(const PlannerHNS::SHIFT_POS&amp; shift)
+PlannerXNS::AUTOWARE_SHIFT_POS ROSHelpers::ConvertShiftFromPlannerHToAutoware(const PlannerHNS::SHIFT_POS&amp; shift)
 {
 	if(shift == PlannerHNS::SHIFT_POS_DD)
 		return PlannerXNS::AW_SHIFT_POS_DD;
@@ -701,7 +701,7 @@ PlannerXNS::AUTOWARE_SHIFT_POS RosHelpers::ConvertShiftFromPlannerHToAutoware(co
 		return PlannerXNS::AW_SHIFT_POS_UU;
 }
 
-PlannerXNS::AutowareBehaviorState RosHelpers::ConvertBehaviorStateFromPlannerHToAutoware(const PlannerHNS::BehaviorState&amp; beh)
+PlannerXNS::AutowareBehaviorState ROSHelpers::ConvertBehaviorStateFromPlannerHToAutoware(const PlannerHNS::BehaviorState&amp; beh)
 {
 	PlannerXNS::AutowareBehaviorState arw_state;
 	arw_state.followDistance = beh.followDistance;
@@ -747,7 +747,7 @@ PlannerXNS::AutowareBehaviorState RosHelpers::ConvertBehaviorStateFromPlannerHTo
 
 }
 
-void RosHelpers::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::RoadNetwork&amp; out_map)
+void ROSHelpers::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::RoadNetwork&amp; out_map)
 {
 	std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt; lanes;
 	for(unsigned int i=0; i &lt; src_map.lanes.data.size();i++)
@@ -847,7 +847,7 @@ void RosHelpers::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::R
 	std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;
 
 	PlannerHNS::GPSPoint origin;//(m_OriginPos.position.x, m_OriginPos.position.y, m_OriginPos.position.z, 0);
-	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data,curb_data, roadedge_data, way_area, crossing, nodes_data, conn_data, origin, out_map);
+	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data,curb_data, roadedge_data, way_area, crossing, nodes_data, conn_data, origin, out_map);
 }
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" added_lines="12" deleted_lines="12">
				<diff>@@ -88,7 +88,7 @@ PlannerX::PlannerX()
 	UpdatePlanningParams();
 
 	tf::StampedTransform transform;
-	RosHelpers::GetTransformFromTF("map", "world", transform);
+	ROSHelpers::GetTransformFromTF("map", "world", transform);
 	m_OriginPos.position.x  = transform.getOrigin().x();
 	m_OriginPos.position.y  = transform.getOrigin().y();
 	m_OriginPos.position.z  = transform.getOrigin().z();
@@ -311,7 +311,7 @@ void PlannerX::callbackGetRvizPoint(const geometry_msgs::PointStampedConstPtr&amp; m
 	clusters_array.clusters.push_back(GenerateSimulatedObstacleCluster(width, length, height, 50, point));
 	m_OriginalClusters.clear();
 	int nNum1, nNum2;
-	RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(m_CurrentPos, m_LocalPlanner.m_CarInfo, clusters_array, m_OriginalClusters, nNum1, nNum2);
+	ROSHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(m_CurrentPos, m_LocalPlanner.m_CarInfo, clusters_array, m_OriginalClusters, nNum1, nNum2);
 	m_TrackedClusters = m_OriginalClusters;
 
 	pcl::PointCloud&lt;pcl::PointXYZ&gt; point_cloud;
@@ -405,7 +405,7 @@ void PlannerX::callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayCo
 	UtilityHNS::UtilityH::GetTickCount(timerTemp);
 
 	m_OriginalClusters.clear();
-	RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(m_CurrentPos, m_LocalPlanner.m_CarInfo, *msg, m_OriginalClusters, m_nOriginalPoints, m_nContourPoints);
+	ROSHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(m_CurrentPos, m_LocalPlanner.m_CarInfo, *msg, m_OriginalClusters, m_nOriginalPoints, m_nContourPoints);
 	if(m_bEnableTracking)
 	{
 		m_ObstacleTracking.DoOneStep(m_CurrentPos, m_OriginalClusters);
@@ -422,7 +422,7 @@ void PlannerX::callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayCo
 void PlannerX::callbackGetBoundingBoxes(const jsk_recognition_msgs::BoundingBoxArrayConstPtr&amp; msg)
 {
 //	std::cout &lt;&lt; " Number of Detected Boxes =" &lt;&lt; msg-&gt;boxes.size() &lt;&lt; std::endl;
-//	RosHelpers::ConvertFromAutowareBoundingBoxObstaclesToPlannerH(*msg, m_DetectedBoxes);
+//	ROSHelpers::ConvertFromAutowareBoundingBoxObstaclesToPlannerH(*msg, m_DetectedBoxes);
 //	bNewBoxes = true;
 }
 
@@ -633,7 +633,7 @@ void PlannerX::PlannerMainLoop()
 				timespec timerTemp;
 				UtilityHNS::UtilityH::GetTickCount(timerTemp);
 				 m_AwMap.bDtLanes = m_AwMap.bLanes = m_AwMap.bPoints = false;
-				 RosHelpers::UpdateRoadMap(m_AwMap,m_Map);
+				 ROSHelpers::UpdateRoadMap(m_AwMap,m_Map);
 				 std::cout &lt;&lt; "Converting Vector Map Time : " &lt;&lt;UtilityHNS::UtilityH::GetTimeDiffNow(timerTemp) &lt;&lt; std::endl;
 				 //sub_WayPlannerPaths = nh.subscribe("/lane_waypoints_array", 	10,		&amp;PlannerX::callbackGetWayPlannerPath, 	this);
 			 }
@@ -658,7 +658,7 @@ void PlannerX::PlannerMainLoop()
 			else if(m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory &lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
 				iDirection = -1;
 
-			RosHelpers::VisualizeBehaviorState(m_CurrentPos, m_CurrentBehavior, m_bGreenLight, iDirection, behavior_rviz);
+			ROSHelpers::VisualizeBehaviorState(m_CurrentPos, m_CurrentBehavior, m_bGreenLight, iDirection, behavior_rviz);
 
 			pub_BehaviorStateRviz.publish(behavior_rviz);
 
@@ -685,11 +685,11 @@ void PlannerX::PlannerMainLoop()
 			pub_BehaviorState.publish(behavior);
 
 			visualization_msgs::MarkerArray detectedPolygons;
-			RosHelpers::ConvertFromPlannerObstaclesToAutoware(m_CurrentPos, m_TrackedClusters, detectedPolygons);
+			ROSHelpers::ConvertFromPlannerObstaclesToAutoware(m_CurrentPos, m_TrackedClusters, detectedPolygons);
 			pub_DetectedPolygonsRviz.publish(detectedPolygons);
 
 			visualization_msgs::Marker safety_box;
-			RosHelpers::ConvertFromPlannerHRectangleToAutowareRviz(m_LocalPlanner.m_TrajectoryCostsCalculatotor.m_SafetyBorder.points, safety_box);
+			ROSHelpers::ConvertFromPlannerHRectangleToAutowareRviz(m_LocalPlanner.m_TrajectoryCostsCalculatotor.m_SafetyBorder.points, safety_box);
 			pub_SafetyBorderRviz.publish(safety_box);
 
 			geometry_msgs::PoseArray sim_data;
@@ -722,7 +722,7 @@ void PlannerX::PlannerMainLoop()
 			UtilityHNS::UtilityH::GetTickCount(log_t);
 			std::ostringstream dataLine;
 			std::ostringstream dataLineToOut;
-			dataLine &lt;&lt; UtilityHNS::UtilityH::GetLongTime(log_t) &lt;&lt;"," &lt;&lt; dt &lt;&lt; "," &lt;&lt; m_CurrentBehavior.state &lt;&lt; ","&lt;&lt; RosHelpers::GetBehaviorNameFromCode(m_CurrentBehavior.state) &lt;&lt; "," &lt;&lt;
+			dataLine &lt;&lt; UtilityHNS::UtilityH::GetLongTime(log_t) &lt;&lt;"," &lt;&lt; dt &lt;&lt; "," &lt;&lt; m_CurrentBehavior.state &lt;&lt; ","&lt;&lt; ROSHelpers::GetBehaviorNameFromCode(m_CurrentBehavior.state) &lt;&lt; "," &lt;&lt;
 					m_nTrackObjects &lt;&lt; "," &lt;&lt; m_nOriginalPoints &lt;&lt; "," &lt;&lt; m_nContourPoints &lt;&lt; "," &lt;&lt; m_TrackingTime &lt;&lt; "," &lt;&lt;
 					m_LocalPlanner.m_CostCalculationTime &lt;&lt; "," &lt;&lt; m_LocalPlanner.m_BehaviorGenTime &lt;&lt; "," &lt;&lt; m_LocalPlanner.m_RollOutsGenerationTime &lt;&lt; "," &lt;&lt;
 					m_LocalPlanner.m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutNumber &lt;&lt; "," &lt;&lt;
@@ -739,7 +739,7 @@ void PlannerX::PlannerMainLoop()
 					m_LocalPlanner.state.pos.x &lt;&lt; "," &lt;&lt; m_LocalPlanner.state.pos.y &lt;&lt; "," &lt;&lt; m_LocalPlanner.state.pos.z &lt;&lt; "," &lt;&lt; UtilityHNS::UtilityH::SplitPositiveAngle(m_LocalPlanner.state.pos.a)+M_PI &lt;&lt; ",";
 			m_LogData.push_back(dataLine.str());
 
-//			dataLineToOut &lt;&lt; RosHelpers::GetBehaviorNameFromCode(m_CurrentBehavior.state) &lt;&lt; ","
+//			dataLineToOut &lt;&lt; ROSHelpers::GetBehaviorNameFromCode(m_CurrentBehavior.state) &lt;&lt; ","
 //					&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bFullyBlock &lt;&lt; ","
 //					&lt;&lt; m_LocalPlanner.m_iSafeTrajectory &lt;&lt; ","
 //					&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;minStoppingDistance &lt;&lt; ","
@@ -763,7 +763,7 @@ void PlannerX::PlannerMainLoop()
 		std_msgs::Int32 closest_waypoint;
 		PlannerHNS::RelativeInfo info;
 		PlannerHNS::PlanningHelpers::GetRelativeInfo(m_LocalPlanner.m_Path, m_LocalPlanner.state, info);
-		RosHelpers::ConvertFromPlannerHToAutowarePathFormat(m_LocalPlanner.m_Path, info.iBack, current_trajectory);
+		ROSHelpers::ConvertFromPlannerHToAutowarePathFormat(m_LocalPlanner.m_Path, info.iBack, current_trajectory);
 		closest_waypoint.data = 1;
 		pub_ClosestIndex.publish(closest_waypoint);
 		pub_LocalBasePath.publish(current_trajectory);
@@ -771,7 +771,7 @@ void PlannerX::PlannerMainLoop()
 		visualization_msgs::MarkerArray all_rollOuts;
 
 	
-		RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(m_LocalPlanner.m_Path, m_LocalPlanner.m_RollOuts, m_LocalPlanner, all_rollOuts);
+		ROSHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(m_LocalPlanner.m_Path, m_LocalPlanner.m_RollOuts, m_LocalPlanner, all_rollOuts);
 		pub_LocalTrajectoriesRviz.publish(all_rollOuts);
 
 		//Publish markers that visualize only when avoiding objects
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector_core.cpp" added_lines="11" deleted_lines="11">
				<diff>@@ -29,7 +29,7 @@
 */
 
 #include "op_behavior_selector_core.h"
-#include "op_ros_helpers/op_RosHelpers.h"
+#include "op_ros_helpers/op_ROSHelpers.h"
 #include "op_planner/MappingHelpers.h"
 
 namespace BehaviorGeneratorNS
@@ -51,7 +51,7 @@ BehaviorGen::BehaviorGen()
 	UpdatePlanningParams(_nh);
 
 	tf::StampedTransform transform;
-	PlannerHNS::RosHelpers::GetTransformFromTF("map", "world", transform);
+	PlannerHNS::ROSHelpers::GetTransformFromTF("map", "world", transform);
 	m_OriginPos.position.x  = transform.getOrigin().x();
 	m_OriginPos.position.y  = transform.getOrigin().y();
 	m_OriginPos.position.z  = transform.getOrigin().z();
@@ -243,7 +243,7 @@ void BehaviorGen::callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayCon
 
 		for(unsigned int i = 0 ; i &lt; msg-&gt;lanes.size(); i++)
 		{
-			PlannerHNS::RosHelpers::ConvertFromAutowareLaneToLocalLane(msg-&gt;lanes.at(i), m_temp_path);
+			PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(msg-&gt;lanes.at(i), m_temp_path);
 			PlannerHNS::Lane* pPrevValid = 0;
 			for(unsigned int j = 0 ; j &lt; m_temp_path.size(); j++)
 			{
@@ -327,7 +327,7 @@ void BehaviorGen::callbackGetLocalPlannerPath(const autoware_msgs::LaneArrayCons
 		for(unsigned int i = 0 ; i &lt; msg-&gt;lanes.size(); i++)
 		{
 			std::vector&lt;PlannerHNS::WayPoint&gt; path;
-			PlannerHNS::RosHelpers::ConvertFromAutowareLaneToLocalLane(msg-&gt;lanes.at(i), path);
+			PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(msg-&gt;lanes.at(i), path);
 			m_RollOuts.push_back(path);
 
 			if(path.size() &gt; 0)
@@ -423,12 +423,12 @@ void BehaviorGen::VisualizeLocalPlanner()
 		iDirection = 1;
 	else if(m_BehaviorGenerator.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory &lt; m_BehaviorGenerator.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
 		iDirection = -1;
-	PlannerHNS::RosHelpers::VisualizeBehaviorState(m_CurrentPos, m_CurrentBehavior, !m_BehaviorGenerator.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bTrafficIsRed , iDirection, behavior_rviz, "beh_state");
+	PlannerHNS::ROSHelpers::VisualizeBehaviorState(m_CurrentPos, m_CurrentBehavior, !m_BehaviorGenerator.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bTrafficIsRed , iDirection, behavior_rviz, "beh_state");
 	//pub_BehaviorStateRviz.publish(behavior_rviz);
 
 	visualization_msgs::MarkerArray markerArray;
 
-	//PlannerHNS::RosHelpers::GetIndicatorArrows(m_CurrentPos, m_CarInfo.width, m_CarInfo.length, m_CurrentBehavior.indicator, 0, markerArray);
+	//PlannerHNS::ROSHelpers::GetIndicatorArrows(m_CurrentPos, m_CarInfo.width, m_CarInfo.length, m_CurrentBehavior.indicator, 0, markerArray);
 
 	markerArray.markers.push_back(behavior_rviz);
 
@@ -441,7 +441,7 @@ void BehaviorGen::VisualizeLocalPlanner()
 //	paths.at(0).push_back(m_BehaviorGenerator.m_Path);
 //	paths.push_back(m_GlobalPathsToUse);
 //	paths.push_back(m_RollOuts);
-//	PlannerHNS::RosHelpers::TrajectoriesToMarkers(paths, selected_path);
+//	PlannerHNS::ROSHelpers::TrajectoriesToMarkers(paths, selected_path);
 //	pub_SelectedPathRviz.publish(selected_path);
 }
 
@@ -486,7 +486,7 @@ void BehaviorGen::SendLocalPlanningTopics()
 	std_msgs::Int32 closest_waypoint;
 	PlannerHNS::RelativeInfo info;
 	PlannerHNS::PlanningHelpers::GetRelativeInfo(m_BehaviorGenerator.m_Path, m_BehaviorGenerator.state, info);
-	PlannerHNS::RosHelpers::ConvertFromLocalLaneToAutowareLane(m_BehaviorGenerator.m_Path, m_CurrentTrajectoryToSend, info.iBack);
+	PlannerHNS::ROSHelpers::ConvertFromLocalLaneToAutowareLane(m_BehaviorGenerator.m_Path, m_CurrentTrajectoryToSend, info.iBack);
 	//std::cout &lt;&lt; "Path Size: " &lt;&lt; m_BehaviorGenerator.m_Path.size() &lt;&lt; ", Send Size: " &lt;&lt; m_CurrentTrajectoryToSend &lt;&lt; std::endl;
 
 	closest_waypoint.data = 1;
@@ -500,7 +500,7 @@ void BehaviorGen::LogLocalPlanningInfo(double dt)
 	timespec log_t;
 	UtilityHNS::UtilityH::GetTickCount(log_t);
 	std::ostringstream dataLine;
-	dataLine &lt;&lt; UtilityHNS::UtilityH::GetLongTime(log_t) &lt;&lt;"," &lt;&lt; dt &lt;&lt; "," &lt;&lt; m_CurrentBehavior.state &lt;&lt; ","&lt;&lt; PlannerHNS::RosHelpers::GetBehaviorNameFromCode(m_CurrentBehavior.state) &lt;&lt; "," &lt;&lt;
+	dataLine &lt;&lt; UtilityHNS::UtilityH::GetLongTime(log_t) &lt;&lt;"," &lt;&lt; dt &lt;&lt; "," &lt;&lt; m_CurrentBehavior.state &lt;&lt; ","&lt;&lt; PlannerHNS::ROSHelpers::GetBehaviorNameFromCode(m_CurrentBehavior.state) &lt;&lt; "," &lt;&lt;
 			m_BehaviorGenerator.m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutNumber &lt;&lt; "," &lt;&lt;
 			m_BehaviorGenerator.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bFullyBlock &lt;&lt; "," &lt;&lt;
 			m_BehaviorGenerator.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory &lt;&lt; "," &lt;&lt;
@@ -569,7 +569,7 @@ void BehaviorGen::MainLoop()
 
 			if(m_MapRaw.GetVersion()==2)
 			{
-				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
@@ -584,7 +584,7 @@ void BehaviorGen::MainLoop()
 			}
 			else if(m_MapRaw.GetVersion()==1)
 			{
-				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor_core.cpp" added_lines="15" deleted_lines="15">
				<diff>@@ -30,7 +30,7 @@
 
 #include "op_motion_predictor_core.h"
 #include "op_planner/MappingHelpers.h"
-#include "op_ros_helpers/op_RosHelpers.h"
+#include "op_ros_helpers/op_ROSHelpers.h"
 
 namespace MotionPredictorNS
 {
@@ -50,7 +50,7 @@ MotionPrediction::MotionPrediction()
 	UpdatePlanningParams(_nh);
 
 	tf::StampedTransform transform;
-	PlannerHNS::RosHelpers::GetTransformFromTF("map", "world", transform);
+	PlannerHNS::ROSHelpers::GetTransformFromTF("map", "world", transform);
 	m_OriginPos.position.x  = transform.getOrigin().x();
 	m_OriginPos.position.y  = transform.getOrigin().y();
 	m_OriginPos.position.z  = transform.getOrigin().z();
@@ -74,9 +74,9 @@ MotionPrediction::MotionPrediction()
 		sub_can_info = nh.subscribe("/can_info", 10, &amp;MotionPrediction::callbackGetCANInfo, this);
 
 	UtilityHNS::UtilityH::GetTickCount(m_VisualizationTimer);
-	PlannerHNS::RosHelpers::InitPredMarkers(100, m_PredictedTrajectoriesDummy);
-	PlannerHNS::RosHelpers::InitCurbsMarkers(100, m_CurbsDummy);
-	PlannerHNS::RosHelpers::InitPredParticlesMarkers(500, m_PredictedParticlesDummy);
+	PlannerHNS::ROSHelpers::InitPredMarkers(100, m_PredictedTrajectoriesDummy);
+	PlannerHNS::ROSHelpers::InitCurbsMarkers(100, m_CurbsDummy);
+	PlannerHNS::ROSHelpers::InitPredParticlesMarkers(500, m_PredictedParticlesDummy);
 
 	//Mapping Section
 	sub_lanes = nh.subscribe("/vector_map_info/lane", 1, &amp;MotionPrediction::callbackGetVMLanes,  this);
@@ -223,7 +223,7 @@ void MotionPrediction::callbackGetTrackedObjects(const autoware_msgs::DetectedOb
 	{
 		if(msg-&gt;objects.at(i).id &gt; 0)
 		{
-			PlannerHNS::RosHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(msg-&gt;objects.at(i), obj);
+			PlannerHNS::ROSHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(msg-&gt;objects.at(i), obj);
 			m_TrackedObjects.push_back(obj);
 		}
 //		else
@@ -250,7 +250,7 @@ void MotionPrediction::callbackGetTrackedObjects(const autoware_msgs::DetectedOb
 		autoware_msgs::DetectedObject pred_obj;
 		for(unsigned int i = 0 ; i &lt;m_PredictBeh.m_ParticleInfo_II.size(); i++)
 		{
-			PlannerHNS::RosHelpers::ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(m_PredictBeh.m_ParticleInfo_II.at(i)-&gt;obj, false, pred_obj);
+			PlannerHNS::ROSHelpers::ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(m_PredictBeh.m_ParticleInfo_II.at(i)-&gt;obj, false, pred_obj);
 			if(m_PredictBeh.m_ParticleInfo_II.at(i)-&gt;best_beh_track)
 				pred_obj.behavior_state = m_PredictBeh.m_ParticleInfo_II.at(i)-&gt;best_beh_track-&gt;best_beh;
 			m_PredictedResultsResults.objects.push_back(pred_obj);
@@ -263,7 +263,7 @@ void MotionPrediction::callbackGetTrackedObjects(const autoware_msgs::DetectedOb
 			//std::cout &lt;&lt; "Curbs No: " &lt;&lt; curr_curbs_obstacles.size() &lt;&lt; endl;
 			for(unsigned int i = 0 ; i &lt;curr_curbs_obstacles.size(); i++)
 			{
-				PlannerHNS::RosHelpers::ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(curr_curbs_obstacles.at(i), false, pred_obj);
+				PlannerHNS::ROSHelpers::ConvertFromOpenPlannerDetectedObjectToAutowareDetectedObject(curr_curbs_obstacles.at(i), false, pred_obj);
 				m_PredictedResultsResults.objects.push_back(pred_obj);
 			}
 		}
@@ -318,10 +318,10 @@ void MotionPrediction::VisualizePrediction()
 //	for(unsigned int i=0; i&lt; m_PredictBeh.m_PredictedObjects.size(); i++)
 //		m_all_pred_paths.insert(m_all_pred_paths.begin(), m_PredictBeh.m_PredictedObjects.at(i).predTrajectories.begin(), m_PredictBeh.m_PredictedObjects.at(i).predTrajectories.end());
 //
-//	PlannerHNS::RosHelpers::ConvertPredictedTrqajectoryMarkers(m_all_pred_paths, m_PredictedTrajectoriesActual, m_PredictedTrajectoriesDummy);
+//	PlannerHNS::ROSHelpers::ConvertPredictedTrqajectoryMarkers(m_all_pred_paths, m_PredictedTrajectoriesActual, m_PredictedTrajectoriesDummy);
 //	pub_PredictedTrajectoriesRviz.publish(m_PredictedTrajectoriesActual);
 //
-	PlannerHNS::RosHelpers::ConvertCurbsMarkers(curr_curbs_obstacles, m_CurbsActual, m_CurbsDummy);
+	PlannerHNS::ROSHelpers::ConvertCurbsMarkers(curr_curbs_obstacles, m_CurbsActual, m_CurbsDummy);
 	pub_CurbsRviz.publish(m_CurbsActual);
 
 	m_all_pred_paths.clear();
@@ -390,19 +390,19 @@ void MotionPrediction::VisualizePrediction()
 //		visualization_msgs::Marker behavior_rviz;
 //		std::ostringstream ns_beh;
 //		ns_beh &lt;&lt; "pred_beh_state_" &lt;&lt; i;
-//		RosHelpers::VisualizeBehaviorState(m_PredictBeh.m_ParticleInfo_II.at(i).obj.center, m_PredictBeh.m_ParticleInfo_II.at(i).m_beh, false , 0, behavior_rviz, ns_beh.str(), 3);
+//		ROSHelpers::VisualizeBehaviorState(m_PredictBeh.m_ParticleInfo_II.at(i).obj.center, m_PredictBeh.m_ParticleInfo_II.at(i).m_beh, false , 0, behavior_rviz, ns_beh.str(), 3);
 //		behavior_rviz_arr.markers.push_back(behavior_rviz);
 
 	}
 
 //	pub_PredBehaviorStateRviz.publish(behavior_rviz_arr);
 
-	PlannerHNS::RosHelpers::ConvertParticles(m_particles_points,m_PredictedParticlesActual, m_PredictedParticlesDummy);
+	PlannerHNS::ROSHelpers::ConvertParticles(m_particles_points,m_PredictedParticlesActual, m_PredictedParticlesDummy);
 	//std::cout &lt;&lt; "Original Particles: " &lt;&lt; number_of_particles &lt;&lt;  ", Total Particles Num: " &lt;&lt; m_PredictedParticlesActual.markers.size() &lt;&lt; std::endl;
 	pub_ParticlesRviz.publish(m_PredictedParticlesActual);
 
 	//std::cout &lt;&lt; "Start Tracking of Trajectories : " &lt;&lt;  m_all_pred_paths.size() &lt;&lt; endl;
-	PlannerHNS::RosHelpers::ConvertPredictedTrqajectoryMarkers(m_all_pred_paths, m_PredictedTrajectoriesActual, m_PredictedTrajectoriesDummy);
+	PlannerHNS::ROSHelpers::ConvertPredictedTrqajectoryMarkers(m_all_pred_paths, m_PredictedTrajectoriesActual, m_PredictedTrajectoriesDummy);
 	pub_PredictedTrajectoriesRviz.publish(m_PredictedTrajectoriesActual);
 
 	UtilityHNS::UtilityH::GetTickCount(m_VisualizationTimer);
@@ -433,7 +433,7 @@ void MotionPrediction::MainLoop()
 
 			if(m_MapRaw.GetVersion()==2)
 			{
-				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
@@ -448,7 +448,7 @@ void MotionPrediction::MainLoop()
 			}
 			else if(m_MapRaw.GetVersion()==1)
 			{
-				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_evaluator\op_trajectory_evaluator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_evaluator\op_trajectory_evaluator_core.cpp" added_lines="10" deleted_lines="10">
				<diff>@@ -29,7 +29,7 @@
 */
 
 #include "op_trajectory_evaluator_core.h"
-#include "op_ros_helpers/op_RosHelpers.h"
+#include "op_ros_helpers/op_ROSHelpers.h"
 
 
 namespace TrajectoryEvaluatorNS
@@ -47,7 +47,7 @@ TrajectoryEval::TrajectoryEval()
 	UpdatePlanningParams(_nh);
 
 	tf::StampedTransform transform;
-	PlannerHNS::RosHelpers::GetTransformFromTF("map", "world", transform);
+	PlannerHNS::ROSHelpers::GetTransformFromTF("map", "world", transform);
 	m_OriginPos.position.x  = transform.getOrigin().x();
 	m_OriginPos.position.y  = transform.getOrigin().y();
 	m_OriginPos.position.z  = transform.getOrigin().z();
@@ -74,7 +74,7 @@ TrajectoryEval::TrajectoryEval()
 	sub_predicted_objects = nh.subscribe("/predicted_objects", 1, &amp;TrajectoryEval::callbackGetPredictedObjects, this);
 	sub_current_behavior = nh.subscribe("/current_behavior", 1, &amp;TrajectoryEval::callbackGetBehaviorState, this);
 
-	PlannerHNS::RosHelpers::InitCollisionPointsMarkers(50, m_CollisionsDummy);
+	PlannerHNS::ROSHelpers::InitCollisionPointsMarkers(50, m_CollisionsDummy);
 }
 
 TrajectoryEval::~TrajectoryEval()
@@ -176,7 +176,7 @@ void TrajectoryEval::callbackGetGlobalPlannerPath(const autoware_msgs::LaneArray
 
 		for(unsigned int i = 0 ; i &lt; msg-&gt;lanes.size(); i++)
 		{
-			PlannerHNS::RosHelpers::ConvertFromAutowareLaneToLocalLane(msg-&gt;lanes.at(i), m_temp_path);
+			PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(msg-&gt;lanes.at(i), m_temp_path);
 
 			PlannerHNS::PlanningHelpers::CalcAngleAndCost(m_temp_path);
 			m_GlobalPaths.push_back(m_temp_path);
@@ -209,7 +209,7 @@ void TrajectoryEval::callbackGetLocalPlannerPath(const autoware_msgs::LaneArrayC
 		for(unsigned int i = 0 ; i &lt; msg-&gt;lanes.size(); i++)
 		{
 			std::vector&lt;PlannerHNS::WayPoint&gt; path;
-			PlannerHNS::RosHelpers::ConvertFromAutowareLaneToLocalLane(msg-&gt;lanes.at(i), path);
+			PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(msg-&gt;lanes.at(i), path);
 			m_GeneratedRollOuts.push_back(path);
 			if(path.size() &gt; 0)
 				globalPathId_roll_outs = path.at(0).gid;
@@ -242,7 +242,7 @@ void TrajectoryEval::callbackGetPredictedObjects(const autoware_msgs::DetectedOb
 	{
 		if(msg-&gt;objects.at(i).id &gt; 0)
 		{
-			PlannerHNS::RosHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(msg-&gt;objects.at(i), obj);
+			PlannerHNS::ROSHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(msg-&gt;objects.at(i), obj);
 			m_PredictedObjects.push_back(obj);
 		}
 //		else
@@ -301,7 +301,7 @@ void TrajectoryEval::MainLoop()
 				for(unsigned int i=0; i &lt; m_GeneratedRollOuts.size(); i++)
 				{
 					autoware_msgs::Lane lane;
-					PlannerHNS::RosHelpers::ConvertFromLocalLaneToAutowareLane(m_GeneratedRollOuts.at(i), lane);
+					PlannerHNS::ROSHelpers::ConvertFromLocalLaneToAutowareLane(m_GeneratedRollOuts.at(i), lane);
 					lane.closest_object_distance = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).closest_obj_distance;
 					lane.closest_object_velocity = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).closest_obj_velocity;
 					lane.cost = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).cost;
@@ -320,15 +320,15 @@ void TrajectoryEval::MainLoop()
 			if(m_TrajectoryCostsCalculator.m_TrajectoryCosts.size()&gt;0)
 			{
 				visualization_msgs::MarkerArray all_rollOuts;
-				PlannerHNS::RosHelpers::TrajectoriesToColoredMarkers(m_GeneratedRollOuts, m_TrajectoryCostsCalculator.m_TrajectoryCosts, m_CurrentBehavior.iTrajectory, all_rollOuts);
+				PlannerHNS::ROSHelpers::TrajectoriesToColoredMarkers(m_GeneratedRollOuts, m_TrajectoryCostsCalculator.m_TrajectoryCosts, m_CurrentBehavior.iTrajectory, all_rollOuts);
 				pub_LocalWeightedTrajectoriesRviz.publish(all_rollOuts);
 
-				PlannerHNS::RosHelpers::ConvertCollisionPointsMarkers(m_TrajectoryCostsCalculator.m_CollisionPoints, m_CollisionsActual, m_CollisionsDummy);
+				PlannerHNS::ROSHelpers::ConvertCollisionPointsMarkers(m_TrajectoryCostsCalculator.m_CollisionPoints, m_CollisionsActual, m_CollisionsDummy);
 				pub_CollisionPointsRviz.publish(m_CollisionsActual);
 
 				//Visualize Safety Box
 				visualization_msgs::Marker safety_box;
-				PlannerHNS::RosHelpers::ConvertFromPlannerHRectangleToAutowareRviz(m_TrajectoryCostsCalculator.m_SafetyBorder.points, safety_box);
+				PlannerHNS::ROSHelpers::ConvertFromPlannerHRectangleToAutowareRviz(m_TrajectoryCostsCalculator.m_SafetyBorder.points, safety_box);
 				pub_SafetyBorderRviz.publish(safety_box);
 			}
 		}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -29,7 +29,7 @@
 */
 
 #include "op_trajectory_generator_core.h"
-#include "op_ros_helpers/op_RosHelpers.h"
+#include "op_ros_helpers/op_ROSHelpers.h"
 
 
 namespace TrajectoryGeneratorNS
@@ -46,7 +46,7 @@ TrajectoryGen::TrajectoryGen()
 	UpdatePlanningParams(_nh);
 
 	tf::StampedTransform transform;
-	PlannerHNS::RosHelpers::GetTransformFromTF("map", "world", transform);
+	PlannerHNS::ROSHelpers::GetTransformFromTF("map", "world", transform);
 	m_OriginPos.position.x  = transform.getOrigin().x();
 	m_OriginPos.position.y  = transform.getOrigin().y();
 	m_OriginPos.position.z  = transform.getOrigin().z();
@@ -184,7 +184,7 @@ void TrajectoryGen::callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayC
 
 		for(unsigned int i = 0 ; i &lt; msg-&gt;lanes.size(); i++)
 		{
-			PlannerHNS::RosHelpers::ConvertFromAutowareLaneToLocalLane(msg-&gt;lanes.at(i), m_temp_path);
+			PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(msg-&gt;lanes.at(i), m_temp_path);
 
 			PlannerHNS::PlanningHelpers::CalcAngleAndCost(m_temp_path);
 			m_GlobalPaths.push_back(m_temp_path);
@@ -258,7 +258,7 @@ void TrajectoryGen::MainLoop()
 				{
 					autoware_msgs::Lane lane;
 					PlannerHNS::PlanningHelpers::PredictConstantTimeCostForTrajectory(m_RollOuts.at(i).at(j), m_CurrentPos, m_PlanningParams.minSpeed, m_PlanningParams.microPlanDistance);
-					PlannerHNS::RosHelpers::ConvertFromLocalLaneToAutowareLane(m_RollOuts.at(i).at(j), lane);
+					PlannerHNS::ROSHelpers::ConvertFromLocalLaneToAutowareLane(m_RollOuts.at(i).at(j), lane);
 					lane.closest_object_distance = 0;
 					lane.closest_object_velocity = 0;
 					lane.cost = 0;
@@ -273,7 +273,7 @@ void TrajectoryGen::MainLoop()
 			sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 	1,		&amp;TrajectoryGen::callbackGetGlobalPlannerPath, 	this);
 
 		visualization_msgs::MarkerArray all_rollOuts;
-		PlannerHNS::RosHelpers::TrajectoriesToMarkers(m_RollOuts, all_rollOuts);
+		PlannerHNS::ROSHelpers::TrajectoriesToMarkers(m_RollOuts, all_rollOuts);
 		pub_LocalTrajectoriesRviz.publish(all_rollOuts);
 
 		loop_rate.sleep();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator_core.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -36,7 +36,7 @@
 #include &lt;geometry_msgs/PoseArray.h&gt;
 #include &lt;pcl_ros/transforms.h&gt;
 #include "op_ros_helpers/PolygonGenerator.h"
-#include "op_ros_helpers/op_RosHelpers.h"
+#include "op_ros_helpers/op_ROSHelpers.h"
 
 
 namespace CarSimulatorNS
@@ -403,7 +403,7 @@ void OpenPlannerCarSimulator::callbackGetPredictedObjects(const autoware_msgs::D
 	{
 		if(msg-&gt;objects.at(i).id != m_SimParams.id)
 		{
-			PlannerHNS::RosHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(msg-&gt;objects.at(i), obj);
+			PlannerHNS::ROSHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(msg-&gt;objects.at(i), obj);
 			m_PredictedObjects.push_back(obj);
 		}
 //		else
@@ -682,7 +682,7 @@ void OpenPlannerCarSimulator::visualizeBehaviors()
 	behaviorMarker.text = str_out.str();
 
 	visualization_msgs::MarkerArray markerArray;
-	PlannerHNS::RosHelpers::GetIndicatorArrows(m_LocalPlanner-&gt;state, m_CarInfo.width, m_CarInfo.length, m_CurrBehavior.indicator, m_SimParams.id, markerArray);
+	PlannerHNS::ROSHelpers::GetIndicatorArrows(m_LocalPlanner-&gt;state, m_CarInfo.width, m_CarInfo.length, m_CurrBehavior.indicator, m_SimParams.id, markerArray);
 
 	markerArray.markers.push_back(behaviorMarker);
 	markerArray.markers.push_back(pointerMarker);
@@ -813,7 +813,7 @@ void OpenPlannerCarSimulator::MainLoop()
 
 			if(m_MapRaw.GetVersion()==2)
 			{
-				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
@@ -829,7 +829,7 @@ void OpenPlannerCarSimulator::MainLoop()
 			}
 			else if(m_MapRaw.GetVersion()==1)
 			{
-				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
@@ -1012,7 +1012,7 @@ void OpenPlannerCarSimulator::MainLoop()
 			if(m_SimParams.bEnableLogs)
 			{
 				autoware_msgs::Lane lane;
-				PlannerHNS::RosHelpers::ConvertFromLocalLaneToAutowareLane(m_LocalPlanner-&gt;m_Path, lane);
+				PlannerHNS::ROSHelpers::ConvertFromLocalLaneToAutowareLane(m_LocalPlanner-&gt;m_Path, lane);
 				lane.lane_id = m_SimParams.id;
 				lane.lane_index = (int)m_CurrBehavior.state;
 				lane.header.stamp = sim_data.header.stamp;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_perception_simulator\op_perception_simulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_perception_simulator\op_perception_simulator_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -36,7 +36,7 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;boost/random.hpp&gt;
 #include &lt;boost/math/distributions/normal.hpp&gt;
-#include "op_ros_helpers/op_RosHelpers.h"
+#include "op_ros_helpers/op_ROSHelpers.h"
 
 #include "op_utility/UtilityH.h"
 #include "math.h"
@@ -94,7 +94,7 @@ OpenPlannerSimulatorPerception::~OpenPlannerSimulatorPerception()
 void OpenPlannerSimulatorPerception::callbackGetRvizPoint(const geometry_msgs::PointStampedConstPtr&amp; msg)
 {
 	tf::StampedTransform transform;
-	PlannerHNS::RosHelpers::GetTransformFromTF("map", "world", transform);
+	PlannerHNS::ROSHelpers::GetTransformFromTF("map", "world", transform);
 
 	geometry_msgs::Pose point;
 	point.position.x = msg-&gt;point.x + transform.getOrigin().x();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_signs_simulator\op_signs_simulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_signs_simulator\op_signs_simulator_core.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -32,7 +32,7 @@
 #include "op_utility/UtilityH.h"
 #include "math.h"
 #include "op_planner/MatrixOperations.h"
-#include "op_ros_helpers/op_RosHelpers.h"
+#include "op_ros_helpers/op_ROSHelpers.h"
 
 
 namespace SignsSimulatorNS
@@ -146,7 +146,7 @@ void OpenPlannerSimulatorSigns::VisualizeTrafficLight(autoware_msgs::Signals&amp; _s
 
 	//visualize traffic light
 	visualization_msgs::MarkerArray lights;
-	PlannerHNS::RosHelpers::GetTrafficLightForVisualization(simulatedLights, lights);
+	PlannerHNS::ROSHelpers::GetTrafficLightForVisualization(simulatedLights, lights);
 	pub_TrafficLightsRviz.publish(lights);
 }
 
@@ -175,7 +175,7 @@ void OpenPlannerSimulatorSigns::MainLoop()
 
 			if(m_MapRaw.GetVersion()==2)
 			{
-				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessageV2(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
@@ -190,7 +190,7 @@ void OpenPlannerSimulatorSigns::MainLoop()
 			}
 			else if(m_MapRaw.GetVersion()==1)
 			{
-				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
+				PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessage(m_MapRaw.pLanes-&gt;m_data_list, m_MapRaw.pPoints-&gt;m_data_list,
 						m_MapRaw.pCenterLines-&gt;m_data_list, m_MapRaw.pIntersections-&gt;m_data_list,m_MapRaw.pAreas-&gt;m_data_list,
 						m_MapRaw.pLines-&gt;m_data_list, m_MapRaw.pStopLines-&gt;m_data_list,	m_MapRaw.pSignals-&gt;m_data_list,
 						m_MapRaw.pVectors-&gt;m_data_list, m_MapRaw.pCurbs-&gt;m_data_list, m_MapRaw.pRoadedges-&gt;m_data_list, m_MapRaw.pWayAreas-&gt;m_data_list,
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\BagTopicPlayer.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\BagTopicPlayer.h" added_lines="1" deleted_lines="1">
				<diff>@@ -67,7 +67,7 @@ public:
 
 		if (bagTopics.find(topic_name) == bagTopics.end())
 		{
-			ROS_WARN_STREAM("Can't Find LIDAR Topic in RosBag File :" &lt;&lt; topic_name);
+			ROS_WARN_STREAM("Can't Find LIDAR Topic in ROSBag File :" &lt;&lt; topic_name);
 			return;
 		}
 		else
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_bag_player_core.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_bag_player_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -85,7 +85,7 @@ public:
     ros::Publisher pub_PredStepSignal;
 	TESTING_MODE m_TestMode;
 
-	//Rosbag reader
+	//ROSbag reader
 private:
 	BagReaderParams m_BagParams;
 	rosbag::Bag m_bag;
@@ -108,7 +108,7 @@ private:
 	UtilityHNS::BagTopicPlayer&lt;geometry_msgs::PoseStamped&gt; m_PoseReader;
 
 
-	bool OpenRosBag();
+	bool OpenROSBag();
 	void BagReaderModeMainLoop();
 	bool ReadNextFrame();
 	bool ReadPrevFrame();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\op_bag_player_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\op_bag_player_core.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -146,11 +146,11 @@ void TestingUI::SimulationModeMainLoop()
 	}
 }
 
-bool TestingUI::OpenRosBag()
+bool TestingUI::OpenROSBag()
 {
     try
     {
-    	cout &lt;&lt; "Openning Rosbag File: " &lt;&lt; m_BagParams.fileName &lt;&lt; endl;
+    	cout &lt;&lt; "Openning ROSbag File: " &lt;&lt; m_BagParams.fileName &lt;&lt; endl;
     	m_bag.open(m_BagParams.fileName, rosbag::bagmode::Read);
 
     	m_CloudReader.InitPlayer(m_bag, m_BagParams.lidarTopic);
@@ -161,7 +161,7 @@ bool TestingUI::OpenRosBag()
     }
     catch (rosbag::BagIOException&amp; e)
     {
-    	std::cout &lt;&lt; "Can't Open Rosbaf with path: " &lt;&lt; m_BagParams.fileName &lt;&lt; std::endl;
+    	std::cout &lt;&lt; "Can't Open ROSbaf with path: " &lt;&lt; m_BagParams.fileName &lt;&lt; std::endl;
         ROS_ERROR_STREAM(e.what());
         return false;
     }
@@ -285,7 +285,7 @@ void TestingUI::InitNode(const BagReaderParams&amp; params, const int&amp; mode)
 	ros::NodeHandle nh;
 	if(m_TestMode == ROSBAG_MODE)
 	{
-		m_bBagOpen = OpenRosBag();
+		m_bBagOpen = OpenROSBag();
 
 		pub_Point_Raw		= nh.advertise&lt;sensor_msgs::PointCloud2&gt;(m_BagParams.lidarTopic_pub, 10);
 		pub_Image_Raw		= nh.advertise&lt;sensor_msgs::Image&gt;(m_BagParams.imageTopic_pub, 10);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_data_logger\op_data_logger_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_data_logger\op_data_logger_core.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -32,7 +32,7 @@
 #include "op_utility/UtilityH.h"
 #include "math.h"
 #include "op_planner/MatrixOperations.h"
-#include "op_ros_helpers/op_RosHelpers.h"
+#include "op_ros_helpers/op_ROSHelpers.h"
 
 
 namespace DataLoggerNS
@@ -145,7 +145,7 @@ void OpenPlannerDataLogger::callbackGetSimuCarsPathAndState(const autoware_msgs:
 		if(m_SimulatedVehicle.at(i).id == msg-&gt;lane_id)
 		{
 			m_SimulatedVehicle.at(i).path.clear();
-			PlannerHNS::RosHelpers::ConvertFromAutowareLaneToLocalLane(*msg, m_SimulatedVehicle.at(i).path);
+			PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(*msg, m_SimulatedVehicle.at(i).path);
 			m_SimulatedVehicle.at(i).beh.state = GetStateFromNumber(msg-&gt;lane_index);
 			m_SimulatedVehicle.at(i).path_time = msg-&gt;header.stamp;
 			break;
@@ -167,7 +167,7 @@ void OpenPlannerDataLogger::callbackGetPredictedObjects(const autoware_msgs::Det
 	{
 		if(msg-&gt;objects.at(i).id &gt; 0)
 		{
-			PlannerHNS::RosHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(msg-&gt;objects.at(i), obj);
+			PlannerHNS::ROSHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(msg-&gt;objects.at(i), obj);
 
 
 			obj.behavior_state = GetBehStateFromNumber(msg-&gt;objects.at(i).behavior_state);
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\grasshopper3\grasshopper3.cpp" new_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\grasshopper3\grasshopper3.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -379,7 +379,7 @@ void getMatricesFromFile(const ros::NodeHandle&amp; nh, sensor_msgs::CameraInfo &amp;cam
 
 /*!
  * Reads the params from the console
- * @param private_nh[in] Private Ros node handle
+ * @param private_nh[in] Private ROS node handle
  * @param fps[out] Read value from the console double
  * @param mode[out] Read value from the console integer
  * @param format[out] Read value from the console raw or rgb
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\camera\packages\vectacam\nodes\vectacam\vectacam_node.cpp" new_path="ros\src\sensing\drivers\camera\packages\vectacam\nodes\vectacam\vectacam_node.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -40,7 +40,7 @@
 
 #include "VectaCam.h"
 
-class RosVectaCam
+class ROSVectaCam
 {
 public:
 	void Run()
@@ -133,7 +133,7 @@ int main(int argc, char* argv[])
 {
 	ros::init(argc, argv, "tier_fusion");
 
-	RosVectaCam app;
+	ROSVectaCam app;
 
 	app.Run();
 
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\imu\packages\memsic\nodes\vg440\vg440_node.cpp" new_path="ros\src\sensing\drivers\imu\packages\memsic\nodes\vg440\vg440_node.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -348,7 +348,7 @@ bool MsgToNav1(const unsigned char* data, SNAV1Msg &amp;sMsg) {
   sMsg.BITStatus = (unsigned short)MKShort(data+40);
 }
 
-void Nav1ToRosImu(const SNAV1Msg &amp;rNav1, sensor_msgs::Imu &amp;ImuData) {
+void Nav1ToROSImu(const SNAV1Msg &amp;rNav1, sensor_msgs::Imu &amp;ImuData) {
   const double gravityAccel = 9.80665;
   
   ImuData.angular_velocity.x = rNav1.dRollRate;
@@ -402,7 +402,7 @@ void RunVG440(const std::string &amp;rsPort, int nBaudRate, const std::string &amp;rsTop
             ImuData.header.seq = nCnt;
             SNAV1Msg NAV1;
             MsgToNav1((unsigned char*)packet.data, NAV1);
-            Nav1ToRosImu(NAV1, ImuData);
+            Nav1ToROSImu(NAV1, ImuData);
             Publisher.publish(ImuData);
             ++nCnt;
             if (nCnt % 100 == 0) {
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\image_processor\nodes\image_rectifier\image_rectifier_node.cpp" new_path="ros\src\sensing\filters\packages\image_processor\nodes\image_rectifier\image_rectifier_node.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -44,7 +44,7 @@
 
 #define _NODE_NAME_ "image_rectifier"
 
-class RosImageRectifierApp
+class ROSImageRectifierApp
 
 {
 	ros::Subscriber     subscriber_image_raw_;
@@ -127,10 +127,10 @@ public:
 		ROS_INFO("[%s] camera_info_src: %s", _NODE_NAME_, camera_info_topic_str.c_str());
 
 		ROS_INFO("[%s] Subscribing to... %s", _NODE_NAME_, image_raw_topic_str.c_str());
-		subscriber_image_raw_ = node_handle.subscribe(image_raw_topic_str, 1, &amp;RosImageRectifierApp::ImageCallback, this);
+		subscriber_image_raw_ = node_handle.subscribe(image_raw_topic_str, 1, &amp;ROSImageRectifierApp::ImageCallback, this);
 
 		ROS_INFO("[%s] Subscribing to... %s", _NODE_NAME_, camera_info_topic_str.c_str());
-		subscriber_intrinsics_ = node_handle.subscribe(camera_info_topic_str, 1, &amp;RosImageRectifierApp::IntrinsicsCallback, this);
+		subscriber_intrinsics_ = node_handle.subscribe(camera_info_topic_str, 1, &amp;ROSImageRectifierApp::IntrinsicsCallback, this);
 
 		publisher_image_rectified_ = node_handle.advertise&lt;sensor_msgs::Image&gt;(image_rectified_str, 1);
 		ROS_INFO("[%s] Publishing Rectified image in %s", _NODE_NAME_, image_rectified_str.c_str());
@@ -140,11 +140,11 @@ public:
 		ROS_INFO("[%s] END rect", _NODE_NAME_);
 	}
 
-	~RosImageRectifierApp()
+	~ROSImageRectifierApp()
 	{
 	}
 
-	RosImageRectifierApp()
+	ROSImageRectifierApp()
 	{
 	}
 };
@@ -153,7 +153,7 @@ int main(int argc, char **argv)
 {
 	ros::init(argc, argv, _NODE_NAME_);
 
-	RosImageRectifierApp app;
+	ROSImageRectifierApp app;
 
 	app.Run();
 
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\image_processor\nodes\image_rotator\image_rotator_node.cpp" new_path="ros\src\sensing\filters\packages\image_processor\nodes\image_rotator\image_rotator_node.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -44,7 +44,7 @@
 
 #define _NODE_NAME_ "image_rotator"
 
-class RosImageRotatorApp
+class ROSImageRotatorApp
 
 {
 	ros::Subscriber     subscriber_image_raw_;
@@ -128,7 +128,7 @@ public:
 		ROS_INFO("[%s] image_src: %s", _NODE_NAME_, image_raw_topic_str.c_str());
 
 		ROS_INFO("[%s] Subscribing to... %s", _NODE_NAME_, image_raw_topic_str.c_str());
-		subscriber_image_raw_ = node_handle.subscribe(image_raw_topic_str, 1, &amp;RosImageRotatorApp::ImageCallback, this);
+		subscriber_image_raw_ = node_handle.subscribe(image_raw_topic_str, 1, &amp;ROSImageRotatorApp::ImageCallback, this);
 
 		publisher_image_rotated_ = node_handle.advertise&lt;sensor_msgs::Image&gt;(image_rotated_str, 1);
 		ROS_INFO("[%s] Publishing Rotated image in %s", _NODE_NAME_, image_rotated_str.c_str());
@@ -138,11 +138,11 @@ public:
 		ROS_INFO("[%s] END rot", _NODE_NAME_);
 	}
 
-	~RosImageRotatorApp()
+	~ROSImageRotatorApp()
 	{
 	}
 
-	RosImageRotatorApp()
+	ROSImageRotatorApp()
 	{
 	}
 };
@@ -151,7 +151,7 @@ int main(int argc, char **argv)
 {
 	ros::init(argc, argv, _NODE_NAME_);
 
-	RosImageRotatorApp app;
+	ROSImageRotatorApp app;
 
 	app.Run();
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\autoware_camera_lidar_calibrator\src\autoware_camera_lidar_calibration\camera_lidar_calibration_node.cpp" new_path="ros\src\sensing\fusion\packages\autoware_camera_lidar_calibrator\src\autoware_camera_lidar_calibration\camera_lidar_calibration_node.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -38,7 +38,7 @@
 
 #define __APP_NAME__ "autoware_camera_lidar_calibration_node"
 
-class RosCameraLidarApp
+class ROSCameraLidarApp
 
 {
 	ros::NodeHandle 	node_handle_;
@@ -267,17 +267,17 @@ public:
 
 
 		ROS_INFO("[%s] Subscribing to... %s",__APP_NAME__, image_raw_topic_str.c_str());
-		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosCameraLidarApp::ImageCallback, this);
+		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;ROSCameraLidarApp::ImageCallback, this);
 
 
 		ROS_INFO("[%s] Subscribing to... %s",__APP_NAME__, camera_info_topic_str.c_str());
-		subscriber_intrinsics_ = node_handle_.subscribe(camera_info_topic_str, 1, &amp;RosCameraLidarApp::IntrinsicsCallback, this);
+		subscriber_intrinsics_ = node_handle_.subscribe(camera_info_topic_str, 1, &amp;ROSCameraLidarApp::IntrinsicsCallback, this);
 
 		ROS_INFO("[%s] Subscribing to PointCloud ClickedPoint from RVIZ... /clicked_point",__APP_NAME__);
-		subscriber_clicked_point_ = node_handle_.subscribe("/clicked_point", 1, &amp;RosCameraLidarApp::RvizClickedPointCallback, this);
+		subscriber_clicked_point_ = node_handle_.subscribe("/clicked_point", 1, &amp;ROSCameraLidarApp::RvizClickedPointCallback, this);
 
 		ROS_INFO("[%s] Subscribing to Image ClickedPoint from JSK ImageView2... %s/screenpoint",__APP_NAME__, image_raw_topic_str.c_str());
-		subscriber_image_point_ = node_handle_.subscribe(image_raw_topic_str+"/screenpoint", 1, &amp;RosCameraLidarApp::ImageClickedPointCallback, this);
+		subscriber_image_point_ = node_handle_.subscribe(image_raw_topic_str+"/screenpoint", 1, &amp;ROSCameraLidarApp::ImageClickedPointCallback, this);
 		ROS_INFO("[%s] ClickedPoint: %s",__APP_NAME__, (image_raw_topic_str+"/screenpoint").c_str());
 
 		ROS_INFO("[%s] Ready. Waiting for data...",__APP_NAME__);
@@ -291,7 +291,7 @@ int main(int argc, char **argv)
 {
 	ros::init(argc, argv, __APP_NAME__);
 
-	RosCameraLidarApp app;
+	ROSCameraLidarApp app;
 
 	app.Run();
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\multi_lidar_calibrator\include\multi_lidar_calibrator.h" new_path="ros\src\sensing\fusion\packages\multi_lidar_calibrator\include\multi_lidar_calibrator.h" added_lines="4" deleted_lines="4">
				<diff>@@ -62,7 +62,7 @@
 
 #define __APP_NAME__ "multi_lidar_calibrator"
 
-class RosMultiLidarCalibratorApp
+class ROSMultiLidarCalibratorApp
 
 {
 	ros::NodeHandle                     node_handle_;
@@ -113,9 +113,9 @@ class RosMultiLidarCalibratorApp
 
 	/*!
 	 * Obtains parameters from the command line, initializes subscribers and publishers.
-	 * @param in_private_handle Ros private handle to get parameters for this node.
+	 * @param in_private_handle ROS private handle to get parameters for this node.
 	 */
-	void InitializeRosIo(ros::NodeHandle&amp; in_private_handle);
+	void InitializeROSIo(ros::NodeHandle&amp; in_private_handle);
 
 	/*!
 	 * Applies a Voxel Grid filter to the point cloud
@@ -135,7 +135,7 @@ class RosMultiLidarCalibratorApp
 public:
 	void Run();
 
-	RosMultiLidarCalibratorApp();
+	ROSMultiLidarCalibratorApp();
 };
 
 #endif //PROJECT_MULTI_LIDAR_CALIBRATOR_H
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\multi_lidar_calibrator\src\multi_lidar_calibrator.cpp" new_path="ros\src\sensing\fusion\packages\multi_lidar_calibrator\src\multi_lidar_calibrator.cpp" added_lines="10" deleted_lines="10">
				<diff>@@ -37,7 +37,7 @@
 #include "multi_lidar_calibrator.h"
 
 
-void RosMultiLidarCalibratorApp::PublishCloud(const ros::Publisher&amp; in_publisher, pcl::PointCloud&lt;PointT&gt;::ConstPtr in_cloud_to_publish_ptr)
+void ROSMultiLidarCalibratorApp::PublishCloud(const ros::Publisher&amp; in_publisher, pcl::PointCloud&lt;PointT&gt;::ConstPtr in_cloud_to_publish_ptr)
 {
 	sensor_msgs::PointCloud2 cloud_msg;
 	pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
@@ -45,7 +45,7 @@ void RosMultiLidarCalibratorApp::PublishCloud(const ros::Publisher&amp; in_publisher
 	in_publisher.publish(cloud_msg);
 }
 
-void RosMultiLidarCalibratorApp::PointsCallback(const sensor_msgs::PointCloud2::ConstPtr &amp;in_parent_cloud_msg,
+void ROSMultiLidarCalibratorApp::PointsCallback(const sensor_msgs::PointCloud2::ConstPtr &amp;in_parent_cloud_msg,
                                                   const sensor_msgs::PointCloud2::ConstPtr &amp;in_child_cloud_msg)
 {
 	pcl::PointCloud&lt;PointT&gt;::Ptr in_parent_cloud(new pcl::PointCloud&lt;PointT&gt;);
@@ -117,7 +117,7 @@ void RosMultiLidarCalibratorApp::PointsCallback(const sensor_msgs::PointCloud2::
 
 }
 
-/*void RosMultiLidarCalibratorApp::InitialPoseCallback(geometry_msgs::PoseWithCovarianceStamped::ConstPtr in_initialpose)
+/*void ROSMultiLidarCalibratorApp::InitialPoseCallback(geometry_msgs::PoseWithCovarianceStamped::ConstPtr in_initialpose)
 {
 	ROS_INFO("[%s] Initial Pose received.", __APP_NAME__);
 	tf::Quaternion pose_quaternion(in_initialpose-&gt;pose.pose.orientation.x,
@@ -136,7 +136,7 @@ void RosMultiLidarCalibratorApp::PointsCallback(const sensor_msgs::PointCloud2::
 
 }*/
 
-void RosMultiLidarCalibratorApp::DownsampleCloud(pcl::PointCloud&lt;PointT&gt;::ConstPtr in_cloud_ptr,
+void ROSMultiLidarCalibratorApp::DownsampleCloud(pcl::PointCloud&lt;PointT&gt;::ConstPtr in_cloud_ptr,
                                                  pcl::PointCloud&lt;PointT&gt;::Ptr out_cloud_ptr,
                                                  double in_leaf_size)
 {
@@ -146,7 +146,7 @@ void RosMultiLidarCalibratorApp::DownsampleCloud(pcl::PointCloud&lt;PointT&gt;::ConstP
 	voxelized.filter(*out_cloud_ptr);
 }
 
-void RosMultiLidarCalibratorApp::InitializeRosIo(ros::NodeHandle &amp;in_private_handle)
+void ROSMultiLidarCalibratorApp::InitializeROSIo(ros::NodeHandle &amp;in_private_handle)
 {
 	//get params
 	std::string points_parent_topic_str, points_child_topic_str;
@@ -195,7 +195,7 @@ void RosMultiLidarCalibratorApp::InitializeRosIo(ros::NodeHandle &amp;in_private_han
 	ROS_INFO("[%s] Subscribing to... %s",__APP_NAME__, points_child_topic_str.c_str());
 
 	/*initialpose_subscriber_ = node_handle_.subscribe(initial_pose_topic_str, 10,
-	                                                          &amp;RosMultiLidarCalibratorApp::InitialPoseCallback, this);
+	                                                          &amp;ROSMultiLidarCalibratorApp::InitialPoseCallback, this);
 	ROS_INFO("[%s] Subscribing to... %s",__APP_NAME__, initial_pose_topic_str.c_str());*/
 
 	calibrated_cloud_publisher_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(calibrated_points_topic_str, 1);
@@ -205,16 +205,16 @@ void RosMultiLidarCalibratorApp::InitializeRosIo(ros::NodeHandle &amp;in_private_han
 			new message_filters::Synchronizer&lt;SyncPolicyT&gt;(SyncPolicyT(100),
 			                                               *cloud_parent_subscriber_,
 			                                               *cloud_child_subscriber_);
-	cloud_synchronizer_-&gt;registerCallback(boost::bind(&amp;RosMultiLidarCalibratorApp::PointsCallback, this, _1, _2));
+	cloud_synchronizer_-&gt;registerCallback(boost::bind(&amp;ROSMultiLidarCalibratorApp::PointsCallback, this, _1, _2));
 
 }
 
 
-void RosMultiLidarCalibratorApp::Run()
+void ROSMultiLidarCalibratorApp::Run()
 {
 	ros::NodeHandle private_node_handle("~");
 
-	InitializeRosIo(private_node_handle);
+	InitializeROSIo(private_node_handle);
 
 	ROS_INFO("[%s] Ready. Waiting for data...",__APP_NAME__);
 
@@ -223,7 +223,7 @@ void RosMultiLidarCalibratorApp::Run()
 	ROS_INFO("[%s] END",__APP_NAME__);
 }
 
-RosMultiLidarCalibratorApp::RosMultiLidarCalibratorApp()
+ROSMultiLidarCalibratorApp::ROSMultiLidarCalibratorApp()
 {
 	//initialpose_quaternion_ = tf::Quaternion::getIdentity();
 	current_guess_ = Eigen::Matrix4f::Identity();
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\multi_lidar_calibrator\src\multi_lidar_calibrator_node.cpp" new_path="ros\src\sensing\fusion\packages\multi_lidar_calibrator\src\multi_lidar_calibrator_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -40,7 +40,7 @@ int main(int argc, char **argv)
 {
 	ros::init(argc, argv, __APP_NAME__);
 
-	RosMultiLidarCalibratorApp app;
+	ROSMultiLidarCalibratorApp app;
 
 	app.Run();
 
</diff>
			</file>
			<file old_path="ros\src\util\packages\autoware_bag_tools\nodes\nmea2kml\nmea2kml.cpp" new_path="ros\src\util\packages\autoware_bag_tools\nodes\nmea2kml\nmea2kml.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -95,7 +95,7 @@ public:
 
 std::vector&lt;GPS_Point&gt; g_line_points;
 
-bool OpenRosBag(const std::string&amp; bag_Name, rosbag::Bag &amp; _bag, rosbag::View&amp; _bagView, rosbag::View::iterator&amp; _viewIterator)
+bool OpenROSBag(const std::string&amp; bag_Name, rosbag::Bag &amp; _bag, rosbag::View&amp; _bagView, rosbag::View::iterator&amp; _viewIterator)
 {
 	std::set&lt;std::string&gt; bagTopics;
 
@@ -116,7 +116,7 @@ bool OpenRosBag(const std::string&amp; bag_Name, rosbag::Bag &amp; _bag, rosbag::View&amp; _
 
 		if (bagTopics.find(nmea_topic_name) == bagTopics.end())
 		{
-			std::cout &lt;&lt; "Can't Find NMEA Sentence Topic in RosBag File :" &lt;&lt; nmea_topic_name &lt;&lt; std::endl;
+			std::cout &lt;&lt; "Can't Find NMEA Sentence Topic in ROSBag File :" &lt;&lt; nmea_topic_name &lt;&lt; std::endl;
 			return false;
 		}
 		else
@@ -131,7 +131,7 @@ bool OpenRosBag(const std::string&amp; bag_Name, rosbag::Bag &amp; _bag, rosbag::View&amp; _
     }
     catch (rosbag::BagIOException&amp; e)
     {
-    	std::cout &lt;&lt; "Can't Open Rosbag with path: " &lt;&lt; bag_Name &lt;&lt; std::endl;
+    	std::cout &lt;&lt; "Can't Open ROSbag with path: " &lt;&lt; bag_Name &lt;&lt; std::endl;
         return false;
     }
 }
@@ -367,7 +367,7 @@ void ConvertOneFile(const std::string&amp; fileName)
 	std::ofstream ofs;
 	ofs.open(output_csv.c_str(), std::ios::app);
 
-	OpenRosBag(fileName, bag, bagView, viewIterator);
+	OpenROSBag(fileName, bag, bagView, viewIterator);
 
 	while(1)
 	{
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4731bd29954c9d6e9052e913bf12b8b38607374f" author="Esteve Fernandez">
		<msg>Fix Tlr/TLR naming convention</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.cpp" added_lines="26" deleted_lines="26">
				<diff>@@ -12,7 +12,7 @@
 static bool show_superimpose_result = false;
 static const std::string window_name = "superimpose result";
 
-RegionTlrMxNetROSNode::RegionTlrMxNetROSNode() :
+RegionTLRMxNetROSNode::RegionTLRMxNetROSNode() :
 		image_topic_name_("/image_raw"),
 		network_definition_file_name_(""),
 		pretrained_model_file_name_(""),
@@ -30,12 +30,12 @@ RegionTlrMxNetROSNode::RegionTlrMxNetROSNode() :
 }
 
 
-RegionTlrMxNetROSNode::~RegionTlrMxNetROSNode()
+RegionTLRMxNetROSNode::~RegionTLRMxNetROSNode()
 {
 }
 
 
-void RegionTlrMxNetROSNode::RunRecognition()
+void RegionTLRMxNetROSNode::RunRecognition()
 {
 	// Get execution parameters from ROS parameter server
 	GetROSParam();
@@ -62,7 +62,7 @@ void RegionTlrMxNetROSNode::RunRecognition()
 }
 
 
-void RegionTlrMxNetROSNode::ImageRawCallback(const sensor_msgs::Image &amp;image)
+void RegionTLRMxNetROSNode::ImageRawCallback(const sensor_msgs::Image &amp;image)
 {
 	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image, sensor_msgs::image_encodings::BGR8);
 	frame_ = cv_image-&gt;image.clone();
@@ -71,7 +71,7 @@ void RegionTlrMxNetROSNode::ImageRawCallback(const sensor_msgs::Image &amp;image)
 
 }
 
-void RegionTlrMxNetROSNode::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos)
+void RegionTLRMxNetROSNode::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos)
 {
 	static ros::Time previous_timestamp;
 	// If frame has not been prepared, abort this callback
@@ -114,7 +114,7 @@ void RegionTlrMxNetROSNode::RoiSignalCallback(const autoware_msgs::Signals::Cons
 	previous_timestamp = frame_header_.stamp;
 }
 
-void RegionTlrMxNetROSNode::GetROSParam()
+void RegionTLRMxNetROSNode::GetROSParam()
 {
 	ros::NodeHandle private_node_handle("~");
 
@@ -146,25 +146,25 @@ void RegionTlrMxNetROSNode::GetROSParam()
 		ROS_FATAL("No Pretrained Model File was specified. Terminate program... ");
 		exit(EXIT_FAILURE);
 	}
-} // RegionTlrMxNetROSNode::ProcessROSParam()
+} // RegionTLRMxNetROSNode::ProcessROSParam()
 
 
-void RegionTlrMxNetROSNode::StartSubscribersAndPublishers()
+void RegionTLRMxNetROSNode::StartSubscribersAndPublishers()
 {
 	ros::NodeHandle node_handle;
 
 	// Register subscribers
 	image_subscriber = node_handle.subscribe(image_topic_name_,
 	                                         1,
-	                                         &amp;RegionTlrMxNetROSNode::ImageRawCallback,
+	                                         &amp;RegionTLRMxNetROSNode::ImageRawCallback,
 	                                         this);
 	roi_signal_subscriber = node_handle.subscribe("/roi_signal",
 	                                              1,
-	                                              &amp;RegionTlrMxNetROSNode::RoiSignalCallback,
+	                                              &amp;RegionTLRMxNetROSNode::RoiSignalCallback,
 	                                              this);
 	superimpose_sub = node_handle.subscribe("/config/superimpose",
                                           1,
-                                          &amp;RegionTlrMxNetROSNode::SuperimposeCb,
+                                          &amp;RegionTLRMxNetROSNode::SuperimposeCb,
                                           this);
 
 	// Register publishers
@@ -173,7 +173,7 @@ void RegionTlrMxNetROSNode::StartSubscribersAndPublishers()
 	marker_publisher = node_handle.advertise&lt;visualization_msgs::MarkerArray&gt;("tlr_result", 1, kAdvertiseInLatch_);
 	superimpose_image_publisher = node_handle.advertise&lt;sensor_msgs::Image&gt;("tlr_superimpose_image", 1);
 
-} // RegionTlrMxNetROSNode::StartSubscribersAndPublishers()
+} // RegionTLRMxNetROSNode::StartSubscribersAndPublishers()
 
 /*!
  * DetermineState works as a latch to reduce the chance of sudden changes in the state of the traffic light, caused by
@@ -182,7 +182,7 @@ void RegionTlrMxNetROSNode::StartSubscribersAndPublishers()
  * @param current_state the current state of the traffic light as reported by the classifier.
  * @param in_out_signal_context the object containing the data of the current Traffic Light instance.
  */
-void RegionTlrMxNetROSNode::DetermineState(LightState in_current_state,
+void RegionTLRMxNetROSNode::DetermineState(LightState in_current_state,
                                            Context&amp; in_out_signal_context)
 {
 	//if reported state by classifier is different than the previously stored
@@ -207,10 +207,10 @@ void RegionTlrMxNetROSNode::DetermineState(LightState in_current_state,
 		in_out_signal_context.lightState = in_current_state;
 	}
 
-} // LightState RegionTlrMxNetROSNode::DetermineState()
+} // LightState RegionTLRMxNetROSNode::DetermineState()
 
 
-void RegionTlrMxNetROSNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts)
+void RegionTLRMxNetROSNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts)
 {
 	autoware_msgs::TrafficLight topic;
 	static int32_t previous_state = kTrafficLightUnknown;
@@ -247,10 +247,10 @@ void RegionTlrMxNetROSNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts)
 		signal_state_publisher.publish(topic);
 		previous_state = topic.traffic_light;
 	}
-} // void RegionTlrMxNetROSNode::PublishTrafficLight()
+} // void RegionTLRMxNetROSNode::PublishTrafficLight()
 
 
-void RegionTlrMxNetROSNode::PublishString(std::vector&lt;Context&gt; contexts)
+void RegionTLRMxNetROSNode::PublishString(std::vector&lt;Context&gt; contexts)
 {
 	std_msgs::String topic;
 	static std::string previous_state = kStringUnknown;
@@ -287,10 +287,10 @@ void RegionTlrMxNetROSNode::PublishString(std::vector&lt;Context&gt; contexts)
 		signal_state_string_publisher.publish(topic);
 		previous_state = topic.data;
 	}
-} // void RegionTlrMxNetROSNode::PublishString()
+} // void RegionTLRMxNetROSNode::PublishString()
 
 
-void RegionTlrMxNetROSNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts)
+void RegionTLRMxNetROSNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts)
 {
 	// Define color constants
 	std_msgs::ColorRGBA color_black;
@@ -419,10 +419,10 @@ void RegionTlrMxNetROSNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts)
 		marker_publisher.publish(signal_set);
 	}
 
-} // void RegionTlrMxNetROSNode::PublishMarkerArray()
+} // void RegionTLRMxNetROSNode::PublishMarkerArray()
 
 
-void RegionTlrMxNetROSNode::PublishImage(std::vector&lt;Context&gt; contexts)
+void RegionTLRMxNetROSNode::PublishImage(std::vector&lt;Context&gt; contexts)
 {
 	// Copy the frame image for output
 	cv::Mat result_image = frame_.clone();
@@ -484,9 +484,9 @@ void RegionTlrMxNetROSNode::PublishImage(std::vector&lt;Context&gt; contexts)
 	converter.image = result_image;
 	superimpose_image_publisher.publish(converter.toImageMsg());
 
-} // void RegionTlrMxNetROSNode::PublishImage()
+} // void RegionTLRMxNetROSNode::PublishImage()
 
-void RegionTlrMxNetROSNode::SuperimposeCb(const std_msgs::Bool::ConstPtr &amp;config_msg)
+void RegionTLRMxNetROSNode::SuperimposeCb(const std_msgs::Bool::ConstPtr &amp;config_msg)
 {
 	show_superimpose_result = config_msg-&gt;data;
 
@@ -505,15 +505,15 @@ void RegionTlrMxNetROSNode::SuperimposeCb(const std_msgs::Bool::ConstPtr &amp;config
 		}
 	}
 
-} // void RegionTlrMxNetROSNode::SuperimposeCb()
+} // void RegionTLRMxNetROSNode::SuperimposeCb()
 
 int main(int argc, char *argv[])
 {
 	// Initialize ros node
 	ros::init(argc, argv, "region_tlr_mxnet");
 
-	// Create RegionTlrROSNode class object and do initialization
-	RegionTlrMxNetROSNode region_tlr_mxnet_ros_node;
+	// Create RegionTLRROSNode class object and do initialization
+	RegionTLRMxNetROSNode region_tlr_mxnet_ros_node;
 
 	// Start recognition process
 	region_tlr_mxnet_ros_node.RunRecognition();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.h" added_lines="3" deleted_lines="3">
				<diff>@@ -59,12 +59,12 @@ public :
 	}
 };
 
-class RegionTlrMxNetROSNode
+class RegionTLRMxNetROSNode
 {
 public:
-	RegionTlrMxNetROSNode();
+	RegionTLRMxNetROSNode();
 
-	~RegionTlrMxNetROSNode();
+	~RegionTLRMxNetROSNode();
 
 	void RunRecognition();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.cpp" added_lines="28" deleted_lines="28">
				<diff>@@ -10,9 +10,9 @@
 #include "Context.h"
 
 // ========================================
-// Constructor of RegionTlrSSDROSNode class
+// Constructor of RegionTLRSSDROSNode class
 // ========================================
-RegionTlrSSDROSNode::RegionTlrSSDROSNode():
+RegionTLRSSDROSNode::RegionTLRSSDROSNode():
   image_topic_name_("/image_raw"),
   network_definition_file_name_(""),
   pretrained_model_file_name_(""),
@@ -26,20 +26,20 @@ RegionTlrSSDROSNode::RegionTlrSSDROSNode():
   kStringGreen("green signal"),
   kStringUnknown("") {
 
-} // RegionTlrSSDROSNode::RegionTlrSSDROSNode()
+} // RegionTLRSSDROSNode::RegionTLRSSDROSNode()
 
 
 // ========================================
-// Destructor of RegionTlrSSDROSNode class
+// Destructor of RegionTLRSSDROSNode class
 // ========================================
-RegionTlrSSDROSNode::~RegionTlrSSDROSNode() {
-} // RegionTlrSSDROSNode::~RegionTlrSSDROSNode()
+RegionTLRSSDROSNode::~RegionTLRSSDROSNode() {
+} // RegionTLRSSDROSNode::~RegionTLRSSDROSNode()
 
 
 // =========================
 // Start recognition process
 // =========================
-void RegionTlrSSDROSNode::RunRecognition() {
+void RegionTLRSSDROSNode::RunRecognition() {
   // Get execution parameters from ROS parameter server
   GetROSParam();
 
@@ -52,13 +52,13 @@ void RegionTlrSSDROSNode::RunRecognition() {
   // Start subscribing and publishing
   StartSubscribersAndPublishers();
   ros::spin();
-} // RegionTlrSSDROSNode::RunRecognition()
+} // RegionTLRSSDROSNode::RunRecognition()
 
 
 // ==================================
 // Callback function to acquire image
 // ==================================
-void RegionTlrSSDROSNode::ImageRawCallback(const sensor_msgs::Image &amp;image) {
+void RegionTLRSSDROSNode::ImageRawCallback(const sensor_msgs::Image &amp;image) {
   cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image, sensor_msgs::image_encodings::BGR8);
   frame_ = cv_image-&gt;image.clone();
 
@@ -70,7 +70,7 @@ void RegionTlrSSDROSNode::ImageRawCallback(const sensor_msgs::Image &amp;image) {
 // ==========================================
 // Callback function to acquire extracted_pos
 // ==========================================
-void RegionTlrSSDROSNode::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos) {
+void RegionTLRSSDROSNode::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos) {
   static ros::Time previous_timestamp;
   // If frame has not been prepared, abort this callback
   if (frame_.empty() ||
@@ -120,7 +120,7 @@ void RegionTlrSSDROSNode::RoiSignalCallback(const autoware_msgs::Signals::ConstP
 // =======================================
 // Get parameter from ROS parameter server
 // =======================================
-void RegionTlrSSDROSNode::GetROSParam() {
+void RegionTLRSSDROSNode::GetROSParam() {
   ros::NodeHandle private_node_handle("~");
 
   private_node_handle.param&lt;std::string&gt;("image_raw_topic", image_topic_name_, "/image_raw");
@@ -140,23 +140,23 @@ void RegionTlrSSDROSNode::GetROSParam() {
     ROS_FATAL("No Pretrained Model File was specified. Terminate program... ");
     exit(EXIT_FAILURE);
   }
-} // RegionTlrSSDROSNode::ProcessROSParam()
+} // RegionTLRSSDROSNode::ProcessROSParam()
 
 
 // ============================================================
 // Register subscriber and publisher of this node in ROS Master
 // ============================================================
-void RegionTlrSSDROSNode::StartSubscribersAndPublishers() {
+void RegionTLRSSDROSNode::StartSubscribersAndPublishers() {
   ros::NodeHandle node_handle;
   
   // Register subscribers
   image_subscriber      = node_handle.subscribe(image_topic_name_,
                                                 1,
-                                                &amp;RegionTlrSSDROSNode::ImageRawCallback,
+                                                &amp;RegionTLRSSDROSNode::ImageRawCallback,
                                                 this);
   roi_signal_subscriber = node_handle.subscribe("/roi_signal",
                                                 1,
-                                                &amp;RegionTlrSSDROSNode::RoiSignalCallback,
+                                                &amp;RegionTLRSSDROSNode::RoiSignalCallback,
                                                 this);
 
   // Register publishers
@@ -165,13 +165,13 @@ void RegionTlrSSDROSNode::StartSubscribersAndPublishers() {
   marker_publisher              = node_handle.advertise&lt;visualization_msgs::MarkerArray&gt;("tlr_result", 1, kAdvertiseInLatch_);
   superimpose_image_publisher   = node_handle.advertise&lt;sensor_msgs::Image&gt;("tlr_superimpose_image", 1);
 
-} // RegionTlrSSDROSNode::StartSubscribersAndPublishers()
+} // RegionTLRSSDROSNode::StartSubscribersAndPublishers()
 
 
 // ===============================================================================
 // Determine the final recognition result by comparing previous recognition result
 // ===============================================================================
-LightState RegionTlrSSDROSNode::DetermineState(LightState previous_state,
+LightState RegionTLRSSDROSNode::DetermineState(LightState previous_state,
                                                LightState current_state,
                                                int* state_judge_count) {
   // Get a candidate which considering state transition of traffic light
@@ -188,13 +188,13 @@ LightState RegionTlrSSDROSNode::DetermineState(LightState previous_state,
     return previous_state;
   }
 
-} // LightState RegionTlrSSDROSNode::DetermineState()
+} // LightState RegionTLRSSDROSNode::DetermineState()
 
 
 // =================================================================
 // Publish recognition result as autoware_msgs::TrafficLight type
 // =================================================================
-void RegionTlrSSDROSNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts) {
+void RegionTLRSSDROSNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts) {
   autoware_msgs::TrafficLight topic;
   static int32_t previous_state = kTrafficLightUnknown;
   topic.traffic_light = kTrafficLightUnknown;
@@ -226,13 +226,13 @@ void RegionTlrSSDROSNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts) {
     signal_state_publisher.publish(topic);
     previous_state = topic.traffic_light;
   }
-} // void RegionTlrSSDROSNode::PublishTrafficLight()
+} // void RegionTLRSSDROSNode::PublishTrafficLight()
 
 
 // =================================================================
 // Publish recognition result as std_msgs::String
 // =================================================================
-void RegionTlrSSDROSNode::PublishString(std::vector&lt;Context&gt; contexts) {
+void RegionTLRSSDROSNode::PublishString(std::vector&lt;Context&gt; contexts) {
   std_msgs::String topic;
   static std::string previous_state = kStringUnknown;
   topic.data = kStringUnknown;
@@ -264,13 +264,13 @@ void RegionTlrSSDROSNode::PublishString(std::vector&lt;Context&gt; contexts) {
     signal_state_string_publisher.publish(topic);
     previous_state = topic.data;
   }
-} // void RegionTlrSSDROSNode::PublishString()
+} // void RegionTLRSSDROSNode::PublishString()
 
 
 // =================================================================
 // Publish recognition result as visualization_msgs::MarkerArray
 // =================================================================
-void RegionTlrSSDROSNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts) {
+void RegionTLRSSDROSNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts) {
   // Define color constants
   std_msgs::ColorRGBA color_black;
   color_black.r = 0.0f;
@@ -396,13 +396,13 @@ void RegionTlrSSDROSNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts) {
     marker_publisher.publish(signal_set);
   }
 
-} // void RegionTlrSSDROSNode::PublishMarkerArray()
+} // void RegionTLRSSDROSNode::PublishMarkerArray()
 
 
 // ================================================================
 // Publish superimpose and recognition result as sensor_msgs::Image
 // ================================================================
-void RegionTlrSSDROSNode::PublishImage(std::vector&lt;Context&gt; contexts) {
+void RegionTLRSSDROSNode::PublishImage(std::vector&lt;Context&gt; contexts) {
   // Copy the frame image for output
   cv::Mat result_image = frame_.clone();
 
@@ -461,7 +461,7 @@ void RegionTlrSSDROSNode::PublishImage(std::vector&lt;Context&gt; contexts) {
   converter.image = result_image;
   superimpose_image_publisher.publish(converter.toImageMsg());
 
-} // void RegionTlrSSDROSNode::PublishImage()
+} // void RegionTLRSSDROSNode::PublishImage()
 
 // ========================
 // Entry point of this node
@@ -470,8 +470,8 @@ int main (int argc, char *argv[]) {
   // Initialize ros node
   ros::init(argc, argv, "region_tlr_ssd");
 
-  // Create RegionTlrROSNode class object and do initialization
-  RegionTlrSSDROSNode region_tlr_ssd_ros_node;
+  // Create RegionTLRROSNode class object and do initialization
+  RegionTLRSSDROSNode region_tlr_ssd_ros_node;
 
   // Start recognition process
   region_tlr_ssd_ros_node.RunRecognition();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.h" added_lines="3" deleted_lines="3">
				<diff>@@ -13,10 +13,10 @@
 #include "autoware_msgs/Signals.h"
 #include "traffic_light_recognizer.h"
 
-class RegionTlrSSDROSNode {
+class RegionTLRSSDROSNode {
  public:
-  RegionTlrSSDROSNode();
-  ~RegionTlrSSDROSNode();
+  RegionTLRSSDROSNode();
+  ~RegionTLRSSDROSNode();
 
   void RunRecognition();
   void ImageRawCallback(const sensor_msgs::Image &amp;image);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Tracking.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Tracking.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -874,9 +874,9 @@ void Tracking::UpdateLastFrame()
 {
     // Update pose according to reference keyframe
     KeyFrame* pRef = mLastFrame.mpReferenceKF;
-    cv::Mat Tlr = mlRelativeFramePoses.back();
+    cv::Mat TLR = mlRelativeFramePoses.back();
 
-    mLastFrame.SetPose(Tlr*pRef-&gt;GetPose());
+    mLastFrame.SetPose(TLR*pRef-&gt;GetPose());
 
     if(mnLastKeyFrameId==mLastFrame.mnId || mSensor==System::MONOCULAR)
         return;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ec34ac57f96139d2bd4b6108cb8e09318c6174f9" author="Esteve Fernandez">
		<msg>Fix Roi/ROI naming convention</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -71,7 +71,7 @@ void RegionTLRMxNetROSNode::ImageRawCallback(const sensor_msgs::Image &amp;image)
 
 }
 
-void RegionTLRMxNetROSNode::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos)
+void RegionTLRMxNetROSNode::ROISignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos)
 {
 	static ros::Time previous_timestamp;
 	// If frame has not been prepared, abort this callback
@@ -160,7 +160,7 @@ void RegionTLRMxNetROSNode::StartSubscribersAndPublishers()
 	                                         this);
 	roi_signal_subscriber = node_handle.subscribe("/roi_signal",
 	                                              1,
-	                                              &amp;RegionTLRMxNetROSNode::RoiSignalCallback,
+	                                              &amp;RegionTLRMxNetROSNode::ROISignalCallback,
 	                                              this);
 	superimpose_sub = node_handle.subscribe("/config/superimpose",
                                           1,
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_mxnet\region_tlr_mxnet.h" added_lines="1" deleted_lines="1">
				<diff>@@ -70,7 +70,7 @@ public:
 
 	void ImageRawCallback(const sensor_msgs::Image &amp;image);
 
-	void RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos);
+	void ROISignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos);
 
 	// The vector of data structure to save traffic light state, position, ...etc
 	std::vector&lt;Context&gt; contexts_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -70,7 +70,7 @@ void RegionTLRSSDROSNode::ImageRawCallback(const sensor_msgs::Image &amp;image) {
 // ==========================================
 // Callback function to acquire extracted_pos
 // ==========================================
-void RegionTLRSSDROSNode::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos) {
+void RegionTLRSSDROSNode::ROISignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos) {
   static ros::Time previous_timestamp;
   // If frame has not been prepared, abort this callback
   if (frame_.empty() ||
@@ -156,7 +156,7 @@ void RegionTLRSSDROSNode::StartSubscribersAndPublishers() {
                                                 this);
   roi_signal_subscriber = node_handle.subscribe("/roi_signal",
                                                 1,
-                                                &amp;RegionTLRSSDROSNode::RoiSignalCallback,
+                                                &amp;RegionTLRSSDROSNode::ROISignalCallback,
                                                 this);
 
   // Register publishers
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\region_tlr_ssd\region_tlr_ssd.h" added_lines="1" deleted_lines="1">
				<diff>@@ -20,7 +20,7 @@ class RegionTLRSSDROSNode {
 
   void RunRecognition();
   void ImageRawCallback(const sensor_msgs::Image &amp;image);
-  void RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos);
+  void ROISignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos);
 
   // The vector of data structure to save traffic light state, position, ...etc
   std::vector&lt;Context&gt; contexts_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\roi_extractor\roi_extractor.cpp" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\roi_extractor\roi_extractor.cpp" added_lines="15" deleted_lines="15">
				<diff>@@ -17,17 +17,17 @@
 #include &lt;autoware_msgs/Signals.h&gt;
 
 
-void RoiExtractor::ImageRawCallback(const sensor_msgs::Image &amp;image) {
+void ROIExtractor::ImageRawCallback(const sensor_msgs::Image &amp;image) {
   // Acquire frame image from ros topic
   cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image, sensor_msgs::image_encodings::BGR8);
   frame_ = cv_image-&gt;image.clone();
 
   // Save this topic's time stamp so that same image will not be processed more than twice
   frame_timestamp_ = image.header.stamp;
-} // void RoiExtractor::ImageRawCallback()
+} // void ROIExtractor::ImageRawCallback()
 
 
-void RoiExtractor::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos) {
+void ROIExtractor::ROISignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos) {
   // If frame image has not been updated, do nothing
   if (frame_timestamp_ == previous_timestamp_) {
     return;
@@ -61,10 +61,10 @@ void RoiExtractor::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;ext
   
   previous_timestamp_ = frame_timestamp_;
   previous_saved_frame_ = roi.clone();
-} // void RoiExtractor::RoiSignalCallback()
+} // void ROIExtractor::ROISignalCallback()
 
 
-void RoiExtractor::CreateTargetDirectory(std::string base_name) {
+void ROIExtractor::CreateTargetDirectory(std::string base_name) {
   // Extracted ROI's images will be saved in "[base_name]/tlr_TrainingDataSet/Images"
   std::string target_directory_name = base_name + "/tlr_TrainingDataSet/Images/";
   
@@ -82,10 +82,10 @@ void RoiExtractor::CreateTargetDirectory(std::string base_name) {
   // Save directory name into class member
   target_directory_ = target_directory_name;
 
-} // void RoiExtractor::CreateTargetDirectory
+} // void ROIExtractor::CreateTargetDirectory
 
 
-int RoiExtractor::CountFileNum(std::string directory_name) {
+int ROIExtractor::CountFileNum(std::string directory_name) {
   int file_num = 0;
   struct dirent *entry;
   DIR *directory_handler = opendir(directory_name.c_str());
@@ -103,10 +103,10 @@ int RoiExtractor::CountFileNum(std::string directory_name) {
   closedir(directory_handler);
 
   return file_num;
-} //int RoiExtractor::CountFileNum()
+} //int ROIExtractor::CountFileNum()
 
 
-void RoiExtractor::MakeDirectoryTree(const std::string &amp;target,
+void ROIExtractor::MakeDirectoryTree(const std::string &amp;target,
                                      const std::string &amp;base,
                                      const mode_t &amp;mode) {
   // Extract directory subtree structure
@@ -123,12 +123,12 @@ void RoiExtractor::MakeDirectoryTree(const std::string &amp;target,
     separator_start = separator_end;
     separator_end = sub_tree.find("/", separator_start + 1);
   }
-} // void RoiExtractor::MakeDirectoryTree()
+} // void ROIExtractor::MakeDirectoryTree()
 
 
 // calculae similarity of specified two images
 // by comparing their histogram, which is sensitive filter for color
-double RoiExtractor::CalculateSimilarity(const cv::Mat &amp;image1, const cv::Mat &amp;image2) {
+double ROIExtractor::CalculateSimilarity(const cv::Mat &amp;image1, const cv::Mat &amp;image2) {
   if (image1.empty() || image2.empty()) {
     return 0.0;
   }
@@ -170,7 +170,7 @@ double RoiExtractor::CalculateSimilarity(const cv::Mat &amp;image1, const cv::Mat &amp;i
    double similarity = cv::compareHist(histogram1, histogram2, CV_COMP_CORREL);
 
    return similarity;
-} // void RoiExtractor::CalculateSimilarity()
+} // void ROIExtractor::CalculateSimilarity()
 
 
 // Entry Point of this node
@@ -190,19 +190,19 @@ int main (int argc, char *argv[]) {
   private_node_handler.param&lt;double&gt;("similarity_threshold", similarity_threshold, 0.9); // The default similarity threshold is 0.9
 
   // Get directory name which roi images will be saved
-  RoiExtractor extractor(minimum_height, similarity_threshold);
+  ROIExtractor extractor(minimum_height, similarity_threshold);
   extractor.CreateTargetDirectory(target_directory_name);
 
   // Launch callback function to subscribe images and signal position
   ros::NodeHandle node_handler;
   ros::Subscriber image_subscriber = node_handler.subscribe(image_topic_name,
                                                             1,
-                                                            &amp;RoiExtractor::ImageRawCallback,
+                                                            &amp;ROIExtractor::ImageRawCallback,
                                                             &amp;extractor);
 
   ros::Subscriber roi_signal_subscriber = node_handler.subscribe("/roi_signal",
                                                                  1,
-                                                                 &amp;RoiExtractor::RoiSignalCallback,
+                                                                 &amp;ROIExtractor::ROISignalCallback,
                                                                  &amp;extractor);
   
   ros::spin();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\roi_extractor\roi_extractor.h" new_path="ros\src\computing\perception\detection\trafficlight_recognizer\nodes\roi_extractor\roi_extractor.h" added_lines="4" deleted_lines="4">
				<diff>@@ -12,19 +12,19 @@
 #include "Context.h"
 #include "autoware_msgs/Signals.h"
 
-class RoiExtractor {
+class ROIExtractor {
  public:
-  explicit RoiExtractor(int minimum_height, double similarity_threshold):
+  explicit ROIExtractor(int minimum_height, double similarity_threshold):
     k_minimum_height_(minimum_height),
     k_similarity_threshold_(similarity_threshold),
     previous_saved_frame_(cv::Mat())
   {};
 
-  ~RoiExtractor(){};
+  ~ROIExtractor(){};
 
   // Callback functions to obtain images and signal position
   void ImageRawCallback(const sensor_msgs::Image &amp;image);
-  void RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos);
+  void ROISignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos);
   
   // Utility function to create directory which roi images will be saved
   void CreateTargetDirectory(std::string base_name);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\image\image_common.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\image\image_common.h" added_lines="3" deleted_lines="3">
				<diff>@@ -70,10 +70,10 @@ struct PANGOLIN_EXPORT ImageDim
     size_t y;
 };
 
-struct PANGOLIN_EXPORT ImageRoi
+struct PANGOLIN_EXPORT ImageROI
 {
-    inline ImageRoi() : x(0), y(0), w(0), h(0) {}
-    inline ImageRoi(size_t x, size_t y, size_t w, size_t h) : x(x), y(y), w(w), h(h) {}
+    inline ImageROI() : x(0), y(0), w(0), h(0) {}
+    inline ImageROI(size_t x, size_t y, size_t w, size_t h) : x(x), y(y), w(w), h(h) {}
     size_t x; size_t y;
     size_t w; size_t h;
 };
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="03669f9901d06b4ccec71f5d951c47fc19064fc5" author="Kosuke Murakami">
		<msg>[hotfix] include &lt;random&gt; in lidar_naive_l_shape_detect (#1681)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_naive_l_shape_detect\nodes\lidar_naive_l_shape_detect\lidar_naive_l_shape_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_naive_l_shape_detect\nodes\lidar_naive_l_shape_detect\lidar_naive_l_shape_detect.cpp" added_lines="3" deleted_lines="0">
				<diff>@@ -28,6 +28,9 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
+#include &lt;random&gt;
+
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bf888ac8ab9180572f9de1d2f29d7f3150ccb098" author="Akihito Ohsato">
		<msg>Fix origin and scale on milee urdf</msg>
		<modified_files>
			<file old_path="ros\src\.config\model\milee.urdf" new_path="ros\src\.config\model\milee.urdf" added_lines="2" deleted_lines="2">
				<diff>@@ -2,9 +2,9 @@
 &lt;robot name="car"&gt;
   &lt;link name="base_link"&gt;
     &lt;visual name="base_visual"&gt;
-      &lt;origin xyz="1 0 0.0" rpy="1.57 0 4.71" /&gt;
+      &lt;origin xyz="1.1 0 0.0" rpy="1.57 0 4.71" /&gt;
       &lt;geometry&gt;
-        &lt;mesh filename="package://model_publisher/../../../.config/model/milee.dae" scale="1.0 1.0 1.0"/&gt;
+        &lt;mesh filename="package://model_publisher/../../../.config/model/milee.dae" scale="1.5 1.5 1.5"/&gt;
       &lt;/geometry&gt;
     &lt;/visual&gt;
   &lt;/link&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="26d8912b5b4287ae88492c666b1bb5b409570056" author="Akihito Ohsato">
		<msg>Rename, Estima DAA-AHR20W</msg>
		<modified_files>
			<file old_path="ros\src\.config\vehicle_info\estima.yaml" new_path="ros\src\.config\vehicle_info\estima_daa_ahr20w.yaml" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fc3242d66614d39d5e169af80c48273559beb8cb" author="Akihito Ohsato">
		<msg>Fix maximum_steering angle 666 -&gt; 600 deg</msg>
		<modified_files>
			<file old_path="ros\src\.config\vehicle_info\estima_daa_ahr20w.yaml" new_path="ros\src\.config\vehicle_info\estima_daa_ahr20w.yaml" added_lines="2" deleted_lines="2">
				<diff>@@ -1,4 +1,4 @@
 vehicle_info:
-  maximum_steering_angle: 666.0
+  maximum_steering_angle: 600.0
   minimum_turning_radius: 5.7
-  wheel_base: 2.95
+  wheel_base: 2.950
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5db3b674e70c81a9c4eca85abe46aba5fd2a54b6" author="Esteve Fernandez">
		<msg>Added notes about Indigo being deprecated</msg>
		<modified_files>
			<file old_path="ros\src\.config\quick_start\sample_lidar_camera\sensing.launch" new_path="ros\src\.config\quick_start\sample_lidar_camera\sensing.launch" added_lines="1" deleted_lines="1">
				<diff>@@ -1,7 +1,7 @@
 &lt;launch&gt;
 
   &lt;!-- calibration file path --&gt;
-  &lt;arg name="velodyne_calib" default="/opt/ros/indigo/share/velodyne_pointcloud/params/32db.yaml"/&gt;
+  &lt;arg name="velodyne_calib" default="/opt/ros/kinetic/share/velodyne_pointcloud/params/32db.yaml"/&gt;
   &lt;arg name="camera_calib" default="~/.autoware/data/calibration/camera_lidar_3d/prius/nic_150407.yml"/&gt;
 
   &lt;!-- HDL-32e --&gt;
</diff>
			</file>
			<file old_path="ros\src\.config\rviz\cmd.sh" new_path="ros\src\.config\rviz\cmd.sh" added_lines="2" deleted_lines="2">
				<diff>@@ -28,8 +28,8 @@ else
   [ "$REMOTE_DISPLAY" = "-" ] &amp;&amp; XOPT="-X"
 
   setsid ssh -tt $XOPT $KEYOPT $REMOTE &lt;&lt;EOF
-    [ -d /opt/ros/indigo ] &amp;&amp; . /opt/ros/indigo/setup.bash
-    [ -d /opt/ros/jade ] &amp;&amp; . /opt/ros/jade/setup.bash
+    [ -d /opt/ros/indigo ] &amp;&amp; echo "Indigo is deprecated and will be removed in a future relase, please use Kinetic instead" &amp;&amp; . /opt/ros/indigo/setup.bash
+    [ -d /opt/ros/kinetic ] &amp;&amp; . /opt/ros/kinetic/setup.bash
     [ -d $DIR/../../../devel ] &amp;&amp; . $DIR/../../../devel/setup.bash || \
       echo "$REMOTE:$DIR/../../../devel: no such directory"
     ROS_IP=\$(hostname -I)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="91c5460c56c115f310ffcef879bab1b2bb55fca1" author="Akihito Ohsato">
		<msg>Add sim_lidar frame to wf_simulator</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" added_lines="17" deleted_lines="4">
				<diff>@@ -47,6 +47,7 @@ namespace
 geometry_msgs::Twist _current_velocity;
 
 const std::string SIMULATION_FRAME = "sim_base_link";
+const std::string LIDAR_FRAME = "sim_lidar";
 const std::string MAP_FRAME = "map";
 
 geometry_msgs::Pose _initial_pose;
@@ -63,6 +64,7 @@ double g_position_error;
 double g_angle_error;
 double g_linear_acceleration = 0;
 double g_steering_angle = 0;
+double g_lidar_height = 1.0;
 double g_wheel_base_m = 2.7;
 
 constexpr int LOOP_RATE = 50; // 50Hz
@@ -179,7 +181,7 @@ void publishOdometry()
   static ros::Time last_time = ros::Time::now();
   static geometry_msgs::Pose pose;
   static double th = 0;
-  static tf::TransformBroadcaster odom_broadcaster;
+  static tf::TransformBroadcaster tf_broadcaster;
 
   if (!_pose_set)
   {
@@ -242,8 +244,18 @@ void publishOdometry()
   odom_trans.transform.translation.z = pose.position.z;
   odom_trans.transform.rotation = pose.orientation;
 
-  // send the transform
-  odom_broadcaster.sendTransform(odom_trans);
+  // send odom transform
+  tf_broadcaster.sendTransform(odom_trans);
+
+  geometry_msgs::TransformStamped lidar_trans;
+  lidar_trans.header.stamp = odom_trans.header.stamp;
+  lidar_trans.header.frame_id = SIMULATION_FRAME;
+  lidar_trans.child_frame_id = LIDAR_FRAME;
+  lidar_trans.transform.translation.z += g_lidar_height;
+  lidar_trans.transform.rotation.w = 1;
+
+  // send lidar transform
+  tf_broadcaster.sendTransform(lidar_trans);
 
   // next, we'll publish the odometry message over ROS
   std_msgs::Header h;
@@ -281,9 +293,10 @@ int main(int argc, char **argv)
   private_nh.param("accel_rate",accel_rate,double(1.0));
   ROS_INFO_STREAM("accel_rate : " &lt;&lt; accel_rate);
 
-
   private_nh.param("position_error", g_position_error, double(0.0));
   private_nh.param("angle_error", g_angle_error, double(0.0));
+  private_nh.param("lidar_height", g_lidar_height, double(1.0));
+
   nh.param("vehicle_info/wheel_base", g_wheel_base_m, double(2.7));
 
   private_nh.param("use_ctrl_cmd", _use_ctrl_cmd, false);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b91cee147d7914d684866b3f65141b3f22203b65" author="Akihito Ohsato">
		<msg>Apply clang-format and unity coding rule</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" added_lines="85" deleted_lines="108">
				<diff>@@ -44,75 +44,76 @@
 
 namespace
 {
-geometry_msgs::Twist _current_velocity;
-
 const std::string SIMULATION_FRAME = "sim_base_link";
 const std::string LIDAR_FRAME = "sim_lidar";
 const std::string MAP_FRAME = "map";
 
-geometry_msgs::Pose _initial_pose;
-bool _initial_set = false;
-bool _pose_set = false;
-bool _waypoint_set = false;
-bool _use_ctrl_cmd = false;
-bool g_is_closest_waypoint_subscribed = false;
-WayPoints _current_waypoints;
-ros::Publisher g_odometry_publisher;
-ros::Publisher g_velocity_publisher;
-int32_t g_closest_waypoint = -1;
-double g_position_error;
-double g_angle_error;
-double g_linear_acceleration = 0;
-double g_steering_angle = 0;
-double g_lidar_height = 1.0;
-double g_wheel_base_m = 2.7;
-
-constexpr int LOOP_RATE = 50; // 50Hz
-
-void CmdCallBack(const geometry_msgs::TwistStampedConstPtr &amp;msg, double accel_rate)
+bool initial_set_ = false;
+bool pose_set_ = false;
+bool waypoint_set_ = false;
+bool use_ctrl_cmd = false;
+bool is_closest_waypoint_subscribed_ = false;
+
+geometry_msgs::Pose initial_pose_;
+WayPoints current_waypoints_;
+geometry_msgs::Twist current_velocity_;
+
+ros::Publisher odometry_publisher_;
+ros::Publisher velocity_publisher_;
+
+int32_t closest_waypoint_ = -1;
+double position_error_;
+double angle_error_;
+double linear_acceleration_ = 0;
+double steering_angle_ = 0;
+double lidar_height_ = 1.0;
+double wheel_base_ = 2.7;
+
+constexpr int LOOP_RATE = 50;  // 50Hz
+
+void CmdCallBack(const geometry_msgs::TwistStampedConstPtr&amp; msg, double accel_rate)
 {
-  if(_use_ctrl_cmd == true)
+  if (use_ctrl_cmd == true)
     return;
 
   static double previous_linear_velocity = 0;
 
-  if(_current_velocity.linear.x &lt; msg-&gt;twist.linear.x)
+  if (current_velocity_.linear.x &lt; msg-&gt;twist.linear.x)
   {
-    _current_velocity.linear.x = previous_linear_velocity + accel_rate / (double)LOOP_RATE;
+    current_velocity_.linear.x = previous_linear_velocity + accel_rate / (double)LOOP_RATE;
 
-    if(_current_velocity.linear.x &gt; msg-&gt;twist.linear.x)
+    if (current_velocity_.linear.x &gt; msg-&gt;twist.linear.x)
     {
-      _current_velocity.linear.x = msg-&gt;twist.linear.x;
+      current_velocity_.linear.x = msg-&gt;twist.linear.x;
     }
   }
   else
   {
-    _current_velocity.linear.x = previous_linear_velocity - accel_rate / (double)LOOP_RATE;
+    current_velocity_.linear.x = previous_linear_velocity - accel_rate / (double)LOOP_RATE;
 
-    if(_current_velocity.linear.x &lt; msg-&gt;twist.linear.x)
+    if (current_velocity_.linear.x &lt; msg-&gt;twist.linear.x)
     {
-      _current_velocity.linear.x = msg-&gt;twist.linear.x;
+      current_velocity_.linear.x = msg-&gt;twist.linear.x;
     }
   }
 
-  previous_linear_velocity = _current_velocity.linear.x;
-
-  _current_velocity.angular.z = msg-&gt;twist.angular.z;
+  previous_linear_velocity = current_velocity_.linear.x;
 
+  current_velocity_.angular.z = msg-&gt;twist.angular.z;
 
-  //_current_velocity = msg-&gt;twist;
+  //current_velocity_ = msg-&gt;twist;
 }
 
-void controlCmdCallBack(const autoware_msgs::ControlCommandStampedConstPtr &amp;msg)
+void controlCmdCallBack(const autoware_msgs::ControlCommandStampedConstPtr&amp; msg)
 {
-  if(_use_ctrl_cmd == false)
+  if (use_ctrl_cmd == false)
     return;
 
-  g_linear_acceleration = msg-&gt;cmd.linear_acceleration;
-  g_steering_angle = msg-&gt;cmd.steering_angle;
+  linear_acceleration_ = msg-&gt;cmd.linear_acceleration;
+  steering_angle_ = msg-&gt;cmd.steering_angle;
 }
 
-void getTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
+void getTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform&amp; transform)
 {
   static tf::TransformListener listener;
 
@@ -131,48 +132,45 @@ void getTransformFromTF(const std::string parent_frame, const std::string child_
   }
 }
 
-void initialposeCallback(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;input)
+void initialposeCallback(const geometry_msgs::PoseWithCovarianceStampedConstPtr&amp; input)
 {
   tf::StampedTransform transform;
   getTransformFromTF(MAP_FRAME, input-&gt;header.frame_id, transform);
 
-  _initial_pose.position.x = input-&gt;pose.pose.position.x + transform.getOrigin().x();
-  _initial_pose.position.y = input-&gt;pose.pose.position.y + transform.getOrigin().y();
-  _initial_pose.position.z = input-&gt;pose.pose.position.z + transform.getOrigin().z();
-  _initial_pose.orientation = input-&gt;pose.pose.orientation;
+  initial_pose_.position.x = input-&gt;pose.pose.position.x + transform.getOrigin().x();
+  initial_pose_.position.y = input-&gt;pose.pose.position.y + transform.getOrigin().y();
+  initial_pose_.position.z = input-&gt;pose.pose.position.z + transform.getOrigin().z();
+  initial_pose_.orientation = input-&gt;pose.pose.orientation;
 
-  _initial_set = true;
-  _pose_set = false;
+  initial_set_ = true;
+  pose_set_ = false;
 }
 
-void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg)
+void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr&amp; msg)
 {
-  _initial_pose = msg-&gt;pose;
-  _initial_set = true;
+  initial_pose_ = msg-&gt;pose;
+  initial_set_ = true;
 }
 
-void waypointCallback(const autoware_msgs::LaneConstPtr &amp;msg)
+void waypointCallback(const autoware_msgs::LaneConstPtr&amp; msg)
 {
-  // _path_og.setPath(msg);
-  _current_waypoints.setPath(*msg);
-  _waypoint_set = true;
-  //ROS_INFO_STREAM("waypoint subscribed");
+  current_waypoints_.setPath(*msg);
+  waypoint_set_ = true;
 }
 
-void callbackFromClosestWaypoint(const std_msgs::Int32ConstPtr &amp;msg)
+void callbackFromClosestWaypoint(const std_msgs::Int32ConstPtr&amp; msg)
 {
-  g_closest_waypoint = msg-&gt;data;
-  g_is_closest_waypoint_subscribed = true;
+  closest_waypoint_ = msg-&gt;data;
+  is_closest_waypoint_subscribed_ = true;
 }
 
-
 void updateVelocity()
 {
-  if(_use_ctrl_cmd == false)
+  if (use_ctrl_cmd == false)
     return;
 
-  _current_velocity.linear.x  += g_linear_acceleration / (double)LOOP_RATE;
-  _current_velocity.angular.z = _current_velocity.linear.x * std::sin(g_steering_angle) / g_wheel_base_m;
+  current_velocity_.linear.x += linear_acceleration_ / (double)LOOP_RATE;
+  current_velocity_.angular.z = current_velocity_.linear.x * std::sin(steering_angle_) / wheel_base_;
 }
 
 void publishOdometry()
@@ -183,30 +181,20 @@ void publishOdometry()
   static double th = 0;
   static tf::TransformBroadcaster tf_broadcaster;
 
-  if (!_pose_set)
+  if (!pose_set_)
   {
-    pose.position = _initial_pose.position;
-    pose.orientation = _initial_pose.orientation;
+    pose.position = initial_pose_.position;
+    pose.orientation = initial_pose_.orientation;
     th = tf::getYaw(pose.orientation);
     ROS_INFO_STREAM("pose set : (" &lt;&lt; pose.position.x &lt;&lt; " " &lt;&lt; pose.position.y &lt;&lt; " " &lt;&lt; pose.position.z &lt;&lt; " " &lt;&lt; th
                                    &lt;&lt; ")");
-    _pose_set = true;
+    pose_set_ = true;
   }
 
-  /*int closest_waypoint = getClosestWaypoint(_current_waypoints.getCurrentWaypoints(), pose);
-  if (closest_waypoint == -1)
-  {
-    ROS_INFO("cannot publish odometry because closest waypoint is -1.");
-    return;
-  }
-  else
-  {
-    pose.position.z = _current_waypoints.getWaypointPosition(closest_waypoint).z;
-  }
-*/if(_waypoint_set &amp;&amp; g_is_closest_waypoint_subscribed)
-    pose.position.z = _current_waypoints.getWaypointPosition(g_closest_waypoint).z;
-  double vx = _current_velocity.linear.x;
-  double vth = _current_velocity.angular.z;
+  if (waypoint_set_ &amp;&amp; is_closest_waypoint_subscribed_)
+    pose.position.z = current_waypoints_.getWaypointPosition(closest_waypoint_).z;
+  double vx = current_velocity_.linear.x;
+  double vth = current_velocity_.angular.z;
   current_time = ros::Time::now();
 
   // compute odometry in a typical way given the velocities of the robot
@@ -218,21 +206,15 @@ void publishOdometry()
   double rnd_value_th = rnd_dist(mt) - 1.0;
 
   double dt = (current_time - last_time).toSec();
-  double delta_x = (vx * cos(th)) * dt + rnd_value_x * g_position_error;
-  double delta_y = (vx * sin(th)) * dt + rnd_value_y * g_position_error;
-  double delta_th = vth * dt + rnd_value_th * g_angle_error * M_PI / 180;
+  double delta_x = (vx * cos(th)) * dt + rnd_value_x * position_error_;
+  double delta_y = (vx * sin(th)) * dt + rnd_value_y * position_error_;
+  double delta_th = vth * dt + rnd_value_th * angle_error_ * M_PI / 180;
 
   pose.position.x += delta_x;
   pose.position.y += delta_y;
   th += delta_th;
   pose.orientation = tf::createQuaternionMsgFromYaw(th);
 
-  // std::cout &lt;&lt; "delta (x y th) : (" &lt;&lt; delta_x &lt;&lt; " " &lt;&lt; delta_y &lt;&lt; " " &lt;&lt; delta_th &lt;&lt; ")" &lt;&lt; std::endl;
-  // std::cout &lt;&lt; "current_velocity(linear.x angular.z) : (" &lt;&lt; _current_velocity.linear.x &lt;&lt; " " &lt;&lt;
-  // _current_velocity.angular.z &lt;&lt; ")"&lt;&lt; std::endl;
-  //    std::cout &lt;&lt; "current_pose : (" &lt;&lt; pose.position.x &lt;&lt; " " &lt;&lt; pose.position.y&lt;&lt; " " &lt;&lt; pose.position.z &lt;&lt; " " &lt;&lt;
-  //    th &lt;&lt; ")" &lt;&lt; std::endl &lt;&lt; std::endl;
-
   // first, we'll publish the transform over tf
   geometry_msgs::TransformStamped odom_trans;
   odom_trans.header.stamp = current_time;
@@ -251,7 +233,7 @@ void publishOdometry()
   lidar_trans.header.stamp = odom_trans.header.stamp;
   lidar_trans.header.frame_id = SIMULATION_FRAME;
   lidar_trans.child_frame_id = LIDAR_FRAME;
-  lidar_trans.transform.translation.z += g_lidar_height;
+  lidar_trans.transform.translation.z += lidar_height_;
   lidar_trans.transform.rotation.w = 1;
 
   // send lidar transform
@@ -272,13 +254,13 @@ void publishOdometry()
   ts.twist.angular.z = vth;
 
   // publish the message
-  g_odometry_publisher.publish(ps);
-  g_velocity_publisher.publish(ts);
+  odometry_publisher_.publish(ps);
+  velocity_publisher_.publish(ts);
 
   last_time = current_time;
 }
 }
-int main(int argc, char **argv)
+int main(int argc, char** argv)
 {
   ros::init(argc, argv, "wf_simulator");
 
@@ -290,22 +272,23 @@ int main(int argc, char **argv)
   ROS_INFO_STREAM("initialize_source : " &lt;&lt; initialize_source);
 
   double accel_rate;
-  private_nh.param("accel_rate",accel_rate,double(1.0));
+  private_nh.param("accel_rate", accel_rate, double(1.0));
   ROS_INFO_STREAM("accel_rate : " &lt;&lt; accel_rate);
 
-  private_nh.param("position_error", g_position_error, double(0.0));
-  private_nh.param("angle_error", g_angle_error, double(0.0));
-  private_nh.param("lidar_height", g_lidar_height, double(1.0));
+  private_nh.param("position_error", position_error_, double(0.0));
+  private_nh.param("angle_error", angle_error_, double(0.0));
+  private_nh.param("lidar_height", lidar_height_, double(1.0));
+  private_nh.param("use_ctrl_cmd", use_ctrl_cmd, false);
 
-  nh.param("vehicle_info/wheel_base", g_wheel_base_m, double(2.7));
+  nh.param("vehicle_info/wheel_base", wheel_base_, double(2.7));
 
-  private_nh.param("use_ctrl_cmd", _use_ctrl_cmd, false);
   // publish topic
-  g_odometry_publisher = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("sim_pose", 10);
-  g_velocity_publisher = nh.advertise&lt;geometry_msgs::TwistStamped&gt;("sim_velocity", 10);
+  odometry_publisher_ = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("sim_pose", 10);
+  velocity_publisher_ = nh.advertise&lt;geometry_msgs::TwistStamped&gt;("sim_velocity", 10);
 
   // subscribe topic
-  ros::Subscriber cmd_subscriber = nh.subscribe&lt;geometry_msgs::TwistStamped&gt;("twist_cmd", 10, boost::bind(CmdCallBack, _1, accel_rate));
+  ros::Subscriber cmd_subscriber =
+      nh.subscribe&lt;geometry_msgs::TwistStamped&gt;("twist_cmd", 10, boost::bind(CmdCallBack, _1, accel_rate));
   ros::Subscriber control_cmd_subscriber = nh.subscribe("ctrl_cmd", 10, controlCmdCallBack);
   ros::Subscriber waypoint_subcscriber = nh.subscribe("base_waypoints", 10, waypointCallback);
   ros::Subscriber closest_sub = nh.subscribe("closest_waypoint", 10, callbackFromClosestWaypoint);
@@ -333,13 +316,7 @@ int main(int argc, char **argv)
   {
     ros::spinOnce();  // check subscribe topic
 
-    /*if (!_waypoint_set)
-    {
-      loop_rate.sleep();
-      continue;
-    }*/
-
-    if (!_initial_set)
+    if (!initial_set_)
     {
       loop_rate.sleep();
       continue;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b854d583986c472bacf83d014a6bf633c28c7856" author="Esteve Fernandez">
		<msg>Replace module_comm_msgs with automotive_platform_msgs</msg>
		<modified_files>
			<file old_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.cpp" new_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -58,8 +58,8 @@ void PacmodInterface::initForROS()
   speed_sub_        = nh_.subscribe("/vehicle/steering_report", 10, &amp;PacmodInterface::callbackFromSteeringReport, this);
 
   // setup publisher
-  steer_mode_pub_    = nh_.advertise&lt;module_comm_msgs::SteerMode&gt;("/as/arbitrated_steering_commands", 10);
-  speed_mode_pub_    = nh_.advertise&lt;module_comm_msgs::SpeedMode&gt;("/as/arbitrated_speed_commands", 10);
+  steer_mode_pub_    = nh_.advertise&lt;automotive_platform_msgs::SteerMode&gt;("/as/arbitrated_steering_commands", 10);
+  speed_mode_pub_    = nh_.advertise&lt;automotive_platform_msgs::SpeedMode&gt;("/as/arbitrated_speed_commands", 10);
   current_twist_pub_ = nh_.advertise&lt;geometry_msgs::TwistStamped&gt;("as_current_twist", 10);
 }
 
@@ -81,14 +81,14 @@ void PacmodInterface::callbackFromTwistCmd(const geometry_msgs::TwistStampedCons
     mode = 0;
   }
 
-  module_comm_msgs::SpeedMode speed_mode;
+  automotive_platform_msgs::SpeedMode speed_mode;
   speed_mode.header = msg-&gt;header;
   speed_mode.mode = mode;
   speed_mode.speed = msg-&gt;twist.linear.x;
   speed_mode.acceleration_limit = 3.0;
   speed_mode.deceleration_limit = 3.0;
 
-  module_comm_msgs::SteerMode steer_mode;
+  automotive_platform_msgs::SteerMode steer_mode;
   steer_mode.header = msg-&gt;header;
   steer_mode.mode = mode;
   double curvature = msg-&gt;twist.angular.z / msg-&gt;twist.linear.x;
</diff>
			</file>
			<file old_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.h" new_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.h" added_lines="2" deleted_lines="2">
				<diff>@@ -35,8 +35,8 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
-#include &lt;module_comm_msgs/SteerMode.h&gt;
-#include &lt;module_comm_msgs/SpeedMode.h&gt;
+#include &lt;automotive_platform_msgs/SteerMode.h&gt;
+#include &lt;automotive_platform_msgs/SpeedMode.h&gt;
 #include &lt;dbw_mkz_msgs/SteeringReport.h&gt;
 
 namespace pacmod
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="82b16ef305ffecfda3add9e73e45ba71ecfee25d" author="mitsudome-r">
		<msg>fixed pcd_filter.cpp to avoid loss of precision</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\map_tools\nodes\pcd_filter\pcd_filter.cpp" new_path="ros\src\util\packages\map_tools\nodes\pcd_filter\pcd_filter.cpp" added_lines="77" deleted_lines="9">
				<diff>@@ -11,6 +11,35 @@ Yuki Kitsukawa
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl/filters/voxel_grid.h&gt;
 
+template &lt;class T&gt;
+pcl::PointXYZ getReferencePoint(T input_cloud){
+    pcl::PointXYZ ref_point;
+    for(auto pt: input_cloud-&gt;points){
+        //make sure the point is a valid point
+        if(std::isfinite(pt.x) &amp;&amp; std::isfinite(pt.y) &amp;&amp; std::isfinite(pt.z)){
+            ref_point.x = pt.x;
+            ref_point.y = pt.y;
+            ref_point.z = pt.z;
+        }
+    }
+    return ref_point;
+}
+
+template &lt;class T&gt;
+void translatePointCloud(T input_cloud, T&amp; output_cloud, pcl::PointXYZ origin){
+    output_cloud-&gt;points.clear();
+    for(auto in_pt: input_cloud-&gt;points){
+        auto out_pt = in_pt;
+        out_pt.x -= origin.x;
+        out_pt.y -= origin.y;
+        out_pt.z -= origin.z;
+        output_cloud-&gt;push_back(out_pt);
+    }
+    output_cloud-&gt;height = input_cloud-&gt;height;
+    output_cloud-&gt;width = input_cloud-&gt;width;
+}
+
+
 int main (int argc, char** argv)
 {
   int i;
@@ -35,21 +64,34 @@ int main (int argc, char** argv)
       }
       std::cout &lt;&lt; "Input: " &lt;&lt; input &lt;&lt; " (" &lt;&lt; input_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
 
+      //translate pointcloud to local frame to avoid losing precision
+      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr translated_input_cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+      pcl::PointXYZ origin = getReferencePoint(input_cloud);
+      translatePointCloud(input_cloud, translated_input_cloud, origin);
+
       // Filtering input scan
       pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
       pcl::VoxelGrid&lt;pcl::PointXYZ&gt; voxel_grid_filter;
       voxel_grid_filter.setLeafSize (leaf_size, leaf_size, leaf_size);
-      voxel_grid_filter.setInputCloud (input_cloud);
+      voxel_grid_filter.setInputCloud (translated_input_cloud);
       voxel_grid_filter.filter (*filtered_cloud);
 
+      //translate pointcloud back to original frame
+      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr translated_filtered_cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+      pcl::PointXYZ inverse_origin;
+      inverse_origin.x = -origin.x;
+      inverse_origin.y = -origin.y;
+      inverse_origin.z = -origin.z;
+      translatePointCloud(filtered_cloud, translated_filtered_cloud, inverse_origin);
+
       int tmp = input.find_last_of("/");
       std::string prefix = std::to_string(leaf_size);
       prefix = prefix.substr(0, 4);
       prefix += "_";
       std::string output = input.insert(tmp+1, prefix);
 
-      pcl::io::savePCDFileBinary(output, *filtered_cloud);
-      std::cout &lt;&lt; "Output: " &lt;&lt; output &lt;&lt; " (" &lt;&lt; filtered_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
+      pcl::io::savePCDFileBinary(output, *translated_filtered_cloud);
+      std::cout &lt;&lt; "Output: " &lt;&lt; output &lt;&lt; " (" &lt;&lt; translated_filtered_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
       std::cout &lt;&lt; "Voxel Leaf Size: " &lt;&lt; leaf_size &lt;&lt; std::endl &lt;&lt; std::endl;
     }
 
@@ -61,21 +103,34 @@ int main (int argc, char** argv)
       }
       std::cout &lt;&lt; "Input: " &lt;&lt; input &lt;&lt; " (" &lt;&lt; input_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
 
+      //translate pointcloud to local frame to avoid losing precision
+      pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr translated_input_cloud (new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
+      pcl::PointXYZ origin = getReferencePoint(input_cloud);
+      translatePointCloud(input_cloud, translated_input_cloud, origin);
+
       // Filtering input scan
       pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_cloud (new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
       pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
       voxel_grid_filter.setLeafSize (leaf_size, leaf_size, leaf_size);
-      voxel_grid_filter.setInputCloud (input_cloud);
+      voxel_grid_filter.setInputCloud (translated_input_cloud);
       voxel_grid_filter.filter (*filtered_cloud);
 
+      //translate pointcloud back to original frame
+      pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr translated_filtered_cloud (new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
+      pcl::PointXYZ inverse_origin;
+      inverse_origin.x = -origin.x;
+      inverse_origin.y = -origin.y;
+      inverse_origin.z = -origin.z;
+      translatePointCloud(filtered_cloud, translated_filtered_cloud, inverse_origin);
+
       int tmp = input.find_last_of("/");
       std::string prefix = std::to_string(leaf_size);
       prefix = prefix.substr(0, 4);
       prefix += "_";
       std::string output = input.insert(tmp+1, prefix);
 
-      pcl::io::savePCDFileBinary(output, *filtered_cloud);
-      std::cout &lt;&lt; "Output: " &lt;&lt; output &lt;&lt; " (" &lt;&lt; filtered_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
+      pcl::io::savePCDFileBinary(output, *translated_filtered_cloud);
+      std::cout &lt;&lt; "Output: " &lt;&lt; output &lt;&lt; " (" &lt;&lt; translated_filtered_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
       std::cout &lt;&lt; "Voxel Leaf Size: " &lt;&lt; leaf_size &lt;&lt; std::endl &lt;&lt; std::endl;
     }
 
@@ -87,21 +142,34 @@ int main (int argc, char** argv)
       }
       std::cout &lt;&lt; "Input: " &lt;&lt; input &lt;&lt; " (" &lt;&lt; input_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
 
+      //translate pointcloud to local frame to avoid losing precision
+      pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr translated_input_cloud (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
+      pcl::PointXYZ origin = getReferencePoint(input_cloud);
+      translatePointCloud(input_cloud, translated_input_cloud, origin);
+
       // Filtering input scan
       pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr filtered_cloud (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
       pcl::VoxelGrid&lt;pcl::PointXYZRGB&gt; voxel_grid_filter;
       voxel_grid_filter.setLeafSize (leaf_size, leaf_size, leaf_size);
-      voxel_grid_filter.setInputCloud (input_cloud);
+      voxel_grid_filter.setInputCloud (translated_input_cloud);
       voxel_grid_filter.filter (*filtered_cloud);
 
+      //translate pointcloud back to original frame
+      pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr translated_filtered_cloud (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
+      pcl::PointXYZ inverse_origin;
+      inverse_origin.x = -origin.x;
+      inverse_origin.y = -origin.y;
+      inverse_origin.z = -origin.z;
+      translatePointCloud(filtered_cloud, translated_filtered_cloud, inverse_origin);
+
       int tmp = input.find_last_of("/");
       std::string prefix = std::to_string(leaf_size);
       prefix = prefix.substr(0, 4);
       prefix += "_";
       std::string output = input.insert(tmp+1, prefix);
 
-      pcl::io::savePCDFileBinary(output, *filtered_cloud);
-      std::cout &lt;&lt; "Output: " &lt;&lt; output &lt;&lt; " (" &lt;&lt; filtered_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
+      pcl::io::savePCDFileBinary(output, *translated_filtered_cloud);
+      std::cout &lt;&lt; "Output: " &lt;&lt; output &lt;&lt; " (" &lt;&lt; translated_filtered_cloud-&gt;size () &lt;&lt; " points) " &lt;&lt; std::endl;
       std::cout &lt;&lt; "Voxel Leaf Size: " &lt;&lt; leaf_size &lt;&lt; std::endl &lt;&lt; std::endl;
     }
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="70d2b1965b8c781129e6375576a13de47242f0b1" author="mitsudome-r">
		<msg>added const to function arguments</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\map_tools\nodes\pcd_filter\pcd_filter.cpp" new_path="ros\src\util\packages\map_tools\nodes\pcd_filter\pcd_filter.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -12,7 +12,7 @@ Yuki Kitsukawa
 #include &lt;pcl/filters/voxel_grid.h&gt;
 
 template &lt;class T&gt;
-pcl::PointXYZ getReferencePoint(T input_cloud){
+pcl::PointXYZ getReferencePoint(const T input_cloud){
     pcl::PointXYZ ref_point;
     for(auto pt: input_cloud-&gt;points){
         //make sure the point is a valid point
@@ -26,7 +26,7 @@ pcl::PointXYZ getReferencePoint(T input_cloud){
 }
 
 template &lt;class T&gt;
-void translatePointCloud(T input_cloud, T&amp; output_cloud, pcl::PointXYZ origin){
+void translatePointCloud(const T input_cloud, T&amp; output_cloud,const pcl::PointXYZ origin){
     output_cloud-&gt;points.clear();
     for(auto in_pt: input_cloud-&gt;points){
         auto out_pt = in_pt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1c0f579a5f80698bb53ba2bfab2ed48fad2ea94d" author="mitsudome-r">
		<msg>Update pcd_filter.cpp</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\map_tools\nodes\pcd_filter\pcd_filter.cpp" new_path="ros\src\util\packages\map_tools\nodes\pcd_filter\pcd_filter.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -20,6 +20,7 @@ pcl::PointXYZ getReferencePoint(const T input_cloud){
             ref_point.x = pt.x;
             ref_point.y = pt.y;
             ref_point.z = pt.z;
+            break;
         }
     }
     return ref_point;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="023bccedcf333d5e0e645b5ab610e8e8d8aeabd8" author="Yamato ANDO">
		<msg>set negative speed if shift is reverse</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_status_translator\can_status_translator_core.cpp" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_status_translator\can_status_translator_core.cpp" added_lines="5" deleted_lines="0">
				<diff>@@ -111,7 +111,12 @@ void CanStatusTranslatorNode::publishVehicleStatus(const autoware_can_msgs::CANI
   vs.drivemode = msg-&gt;devmode;  // I think devmode is typo in CANInfo...
   vs.steeringmode = msg-&gt;strmode;
   vs.gearshift = msg-&gt;driveshift;
+
   vs.speed = msg-&gt;speed;
+  if(vs.gearshift == static_cast&lt;int&gt;(GearShift::Reverse)) {
+      vs.speed *= -1.0;
+  }
+
   vs.drivepedal = msg-&gt;drivepedal;
   vs.brakepedal = msg-&gt;brakepedal;
   vs.angle = msg-&gt;angle;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_status_translator\can_status_translator_core.h" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_status_translator\can_status_translator_core.h" added_lines="7" deleted_lines="0">
				<diff>@@ -95,6 +95,13 @@ struct VehicleInfo
 
 class CanStatusTranslatorNode
 {
+    enum class GearShift{
+        Drive = 16,
+        Neutral = 32,
+        Reverse = 64,
+        Parking = 128,
+    };
+
 public:
   CanStatusTranslatorNode();
   ~CanStatusTranslatorNode();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="49ce2219ee3b2f6aecf7c28935ace3d132c522c9" author="Esteve Fernandez">
		<msg>Drop support for ROS Indigo</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\cmd.sh" new_path="ros\src\.config\rviz\cmd.sh" added_lines="0" deleted_lines="1">
				<diff>@@ -28,7 +28,6 @@ else
   [ "$REMOTE_DISPLAY" = "-" ] &amp;&amp; XOPT="-X"
 
   setsid ssh -tt $XOPT $KEYOPT $REMOTE &lt;&lt;EOF
-    [ -d /opt/ros/indigo ] &amp;&amp; echo "Indigo is deprecated and will be removed in a future relase, please use Kinetic instead" &amp;&amp; . /opt/ros/indigo/setup.bash
     [ -d /opt/ros/kinetic ] &amp;&amp; . /opt/ros/kinetic/setup.bash
     [ -d $DIR/../../../devel ] &amp;&amp; . $DIR/../../../devel/setup.bash || \
       echo "$REMOTE:$DIR/../../../devel: no such directory"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0edf796b885b030dc9915e8e0800e5cd533a1338" author="Esteve Fernandez">
		<msg>Feature/gmsl multiple (v2) (#1683)

Added driver for multiple GMSL cameras for the Drive PX2.</msg>
		<modified_files>
			<file old_path="ros\cross_toolchain_driveworks.cmake" new_path="ros\cross_toolchain_driveworks.cmake" added_lines="2" deleted_lines="0">
				<diff>@@ -63,6 +63,8 @@ set(NVIDIA_TENSORRT_TARGET_DIR "${NVIDIA_TENSORRT_ROOT_DIR}/targets/aarch64-linu
 set(NVIDIA_DRIVE_SDK_ROOT_DIR "$ENV{NVIDIA_DRIVE_SDK_ROOT_DIR}" CACHE STRING "" FORCE)
 set(NVIDIA_DRIVE_SDK_TARGET_DIR "${NVIDIA_DRIVE_SDK_ROOT_DIR}/targetfs" CACHE STRING "" FORCE)
 
+set(DRIVE_T186REF_LINUX_ROOT_DIR "$ENV{DRIVE_T186REF_LINUX_ROOT_DIR}" CACHE STRING "" FORCE)
+
 set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -L${CUDA_TOOLKIT_TARGET_DIR}/lib" CACHE STRING "" FORCE)
 set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -L${DRIVEWORKS_TOOLKIT_TARGET_DIR}/lib" CACHE STRING "" FORCE)
 set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -L${DRIVEWORKS_TOOLKIT_TARGET_DIR}/lib/stubs" CACHE STRING "" FORCE)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="47d36ea2c3eff9fb0161b3a14097b70450b2c1b6" author="Abraham Monrroy Cano">
		<msg>Feature/perception visualization cleanup (#1648)

* * Initial commit for visualization package
* Removal of all visualization messages from perception nodes
* Visualization dependency removal
* Launch file modification

* * Fixes to visualization
* Error on Clustering CPU

* Reduce verbosity on markers

* intial commit

* * Changed to 2 spaces indentation
* Added README

* Fixed README messages type

* 2 space indenting

* ros clang format

* Publish acceleration and velocity from ukf tracker

* Remove hardcoded path

* Updated README

* updated prototype

* Prototype update for header and usage

* Removed unknown label from being reported

* Updated publishing orientation to match develop

* * Published all the trackers
* Added valid field for visualization and future compatibility with ADAS ROI filtering

* Add simple functions

* Refacor code

* * Reversed back UKF node to develop
* Formatted speed

* Refactor codes

* Refactor codes

* Refactor codes

* Refacor codes

* Make tracking visualization work

* Relay class info in tracker node

* Remove dependency to jskbbox and rosmarker in ukf tracker

* apply rosclang to ukf tracker

* Refactor codes

* Refactor codes

* add comment

* refactor codes

* Revert "Refactor codes"

This reverts commit 135aaac46e49cb18d9b76611576747efab3caf9c.

* Revert "apply rosclang to ukf tracker"

This reverts commit 4f8d1cb5c8263a491f92ae5321e5080cb34b7b9c.

* Revert "Remove dependency to jskbbox and rosmarker in ukf tracker"

This reverts commit 4fa1dd40ba58065f7afacc5e478001078925b27d.

* Revert "Relay class info in tracker node"

This reverts commit 1637baac44c8d3d414cc069f3af12a79770439ae.

* delete dependency to jsk and remove pointcloud_frame

* get direction nis

* set velocity_reliable true in tracker node

* Add divided function

* add function

* Sanity checks

* Relay all the data from input DetectedObject

* Divided function work both for immukf and sukf

* Add comment

* Refactor codes

* Pass immukf test

* make direction assisted tracking work

* Visualization fixes

* Refacor codes

* Refactor codes

* Refactor codes

* refactor codes

* refactor codes

* Refactor codes

* refactor codes

* Tracker Merging step added

* Added launch file support for merging phase

* lane assisted with sukf

* Refactor codes

* Refactor codes

* * change only static objects
* keep label of the oldest tracker

* Static Object discrimination

* Non rotating bouding box

* no disappear if detector works

* Modify removeRedundant a bit

* Replacement of JSK visualization for RViz Native Markers

* Added Models namespace to visualization

* Naming change for matching the perception component graph

* * Added 3D Models for different classes in visualization
* 2D Rect node visualize_rects added to visualization_package</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\include\range_vision_fusion\range_vision_fusion.h" new_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\include\range_vision_fusion\range_vision_fusion.h" added_lines="73" deleted_lines="77">
				<diff>@@ -51,7 +51,6 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/CameraInfo.h&gt;
 #include &lt;geometry_msgs/Point.h&gt;
-#include &lt;visualization_msgs/MarkerArray.h&gt;
 
 #include &lt;jsk_recognition_utils/geo/cube.h&gt;
 
@@ -72,116 +71,113 @@
 
 class ROSRangeVisionFusionApp
 {
-    ros::NodeHandle                     node_handle_;
-    ros::Publisher                      publisher_fused_objects_;
-    ros::Publisher                      publisher_fused_boxes_;
-    ros::Publisher                      publisher_fused_text_;
+  ros::NodeHandle node_handle_;
+  ros::Publisher publisher_fused_objects_;
 
-    ros::Subscriber                     intrinsics_subscriber_;
-    ros::Subscriber                     detections_vision_subscriber_;
-    ros::Subscriber                     detections_range_subscriber_;
+  ros::Subscriber intrinsics_subscriber_;
+  ros::Subscriber detections_vision_subscriber_;
+  ros::Subscriber detections_range_subscriber_;
 
-    message_filters::Subscriber&lt;autoware_msgs::DetectedObjectArray&gt;
-                                        *vision_filter_subscriber_, *range_filter_subscriber_;
+  message_filters::Subscriber&lt;autoware_msgs::DetectedObjectArray&gt;
+    *vision_filter_subscriber_, *range_filter_subscriber_;
 
-    tf::TransformListener*              transform_listener_;
-    tf::StampedTransform                camera_lidar_tf_;
+  tf::TransformListener *transform_listener_;
+  tf::StampedTransform camera_lidar_tf_;
 
-    cv::Size                            image_size_;
-    cv::Mat                             camera_instrinsics_;
-    cv::Mat                             distortion_coefficients_;
+  cv::Size image_size_;
+  cv::Mat camera_instrinsics_;
+  cv::Mat distortion_coefficients_;
 
-    cv::Mat                             image_;
-    ros::Subscriber                     image_subscriber_;
-    void ImageCallback(const sensor_msgs::Image::ConstPtr &amp;in_image_msg);
+  cv::Mat image_;
+  ros::Subscriber image_subscriber_;
 
-    autoware_msgs::DetectedObjectArray::ConstPtr  vision_detections_, range_detections_;
+  void ImageCallback(const sensor_msgs::Image::ConstPtr &amp;in_image_msg);
 
-    std::string                         image_frame_id_;
-    std::string                         boxes_frame_;
+  autoware_msgs::DetectedObjectArray::ConstPtr vision_detections_, range_detections_;
 
-    bool                                processing_;
-    bool                                camera_info_ok_;
-    bool                                camera_lidar_tf_ok_;
+  std::string image_frame_id_;
+  std::string boxes_frame_;
 
-    float                               fx_, fy_, cx_, cy_;
-    double                              overlap_threshold_;
+  bool processing_;
+  bool camera_info_ok_;
+  bool camera_lidar_tf_ok_;
 
-    double                              car_width_, car_height_, car_depth_;
-    double                              person_width_, person_height_, person_depth_;
-    double                              truck_width_, truck_depth_, truck_height_;
+  float fx_, fy_, cx_, cy_;
+  double overlap_threshold_;
 
-    size_t                              empty_frames_;
+  double car_width_, car_height_, car_depth_;
+  double person_width_, person_height_, person_depth_;
+  double truck_width_, truck_depth_, truck_height_;
 
-    typedef
-    message_filters::sync_policies::ApproximateTime&lt;autoware_msgs::DetectedObjectArray,
-                                                    autoware_msgs::DetectedObjectArray&gt;  SyncPolicyT;
+  size_t empty_frames_;
 
-    ros::Subscriber                     vision_objects_subscriber_;
-    ros::Subscriber                     range_objects_subscriber_;
+  typedef
+  message_filters::sync_policies::ApproximateTime&lt;autoware_msgs::DetectedObjectArray,
+    autoware_msgs::DetectedObjectArray&gt; SyncPolicyT;
 
-    message_filters::Synchronizer&lt;SyncPolicyT&gt;
-                                        *detections_synchronizer_;
+  ros::Subscriber vision_objects_subscriber_;
+  ros::Subscriber range_objects_subscriber_;
 
-    void CheckMinimumDimensions(autoware_msgs::DetectedObject &amp;in_out_object);
+  message_filters::Synchronizer&lt;SyncPolicyT&gt;
+    *detections_synchronizer_;
 
-    jsk_recognition_msgs::BoundingBoxArray ObjectsToBoxes(const autoware_msgs::DetectedObjectArray &amp;in_objects);
+  void CheckMinimumDimensions(autoware_msgs::DetectedObject &amp;in_out_object);
 
-    void VisionDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_image_msg);
+  void VisionDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_image_msg);
 
-    void RangeDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_cloud_msg);
+  void RangeDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_cloud_msg);
 
-    void SyncedDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections,
-                             const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections);
+  void SyncedDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections,
+                                const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections);
 
-    autoware_msgs::DetectedObjectArray FuseRangeVisionDetections(const autoware_msgs::DetectedObjectArray::ConstPtr &amp; in_vision_detections,
-                                                                 const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections);
+  autoware_msgs::DetectedObjectArray
+  FuseRangeVisionDetections(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections,
+                            const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections);
 
-    cv::Point3f TransformPoint(const geometry_msgs::Point &amp;in_point, const tf::StampedTransform &amp;in_transform);
+  cv::Point3f TransformPoint(const geometry_msgs::Point &amp;in_point, const tf::StampedTransform &amp;in_transform);
 
-    cv::Point2i ProjectPoint(const cv::Point3f &amp;in_point);
+  cv::Point2i ProjectPoint(const cv::Point3f &amp;in_point);
 
-    cv::Rect ProjectDetectionToRect(const autoware_msgs::DetectedObject &amp;in_detection);
+  cv::Rect ProjectDetectionToRect(const autoware_msgs::DetectedObject &amp;in_detection);
 
-    bool IsObjectInImage(const autoware_msgs::DetectedObject &amp;in_detection);
+  bool IsObjectInImage(const autoware_msgs::DetectedObject &amp;in_detection);
 
-    void TransformRangeToVision(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections,
-                                autoware_msgs::DetectedObjectArray &amp;out_range_detections,
-                                autoware_msgs::DetectedObjectArray &amp;out_out_cv_range_detections);
+  void TransformRangeToVision(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections,
+                              autoware_msgs::DetectedObjectArray &amp;out_range_detections,
+                              autoware_msgs::DetectedObjectArray &amp;out_out_cv_range_detections);
 
-    autoware_msgs::DetectedObject TransformObject(const autoware_msgs::DetectedObject &amp;in_detection,
-                                                   const tf::StampedTransform&amp; in_transform);
+  autoware_msgs::DetectedObject TransformObject(const autoware_msgs::DetectedObject &amp;in_detection,
+                                                const tf::StampedTransform &amp;in_transform);
 
-    autoware_msgs::DetectedObject MergeObjects(const autoware_msgs::DetectedObject &amp;in_object_a,
-                                               const autoware_msgs::DetectedObject &amp; in_object_b);
+  autoware_msgs::DetectedObject MergeObjects(const autoware_msgs::DetectedObject &amp;in_object_a,
+                                             const autoware_msgs::DetectedObject &amp;in_object_b);
 
-    void CalculateObjectFeatures(autoware_msgs::DetectedObject &amp;in_out_object,
-                                 bool in_estimate_pose);
+  void CalculateObjectFeatures(autoware_msgs::DetectedObject &amp;in_out_object,
+                               bool in_estimate_pose);
 
-    visualization_msgs::MarkerArray ObjectsToMarkers(const autoware_msgs::DetectedObjectArray &amp;in_objects);
+  double GetDistanceToObject(const autoware_msgs::DetectedObject &amp;in_object);
 
-    double GetDistanceToObject(const autoware_msgs::DetectedObject &amp;in_object);
+  /*!
+   * Obtains Transformation between two transforms registered in the TF Tree
+   * @param in_target_frame
+   * @param in_source_frame
+   * @return the found transformation in the tree
+   */
+  tf::StampedTransform
+  FindTransform(const std::string &amp;in_target_frame, const std::string &amp;in_source_frame);
 
-    /*!
-     * Obtains Transformation between two transforms registered in the TF Tree
-     * @param in_target_frame
-     * @param in_source_frame
-     * @return the found transformation in the tree
-     */
-    tf::StampedTransform
-    FindTransform(const std::string &amp;in_target_frame, const std::string &amp;in_source_frame);
+  void IntrinsicsCallback(const sensor_msgs::CameraInfo &amp;in_message);
 
-    void IntrinsicsCallback(const sensor_msgs::CameraInfo&amp; in_message);
-
-    /*!
-     * Reads the config params from the command line
-     * @param in_private_handle
-     */
-    void InitializeROSIo(ros::NodeHandle &amp;in_private_handle);
+  /*!
+   * Reads the config params from the command line
+   * @param in_private_handle
+   */
+  void InitializeROSIo(ros::NodeHandle &amp;in_private_handle);
 
 public:
-    void Run();
-    ROSRangeVisionFusionApp();
+  void Run();
+
+  ROSRangeVisionFusionApp();
 };
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\src\range_vision_fusion.cpp" new_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\src\range_vision_fusion.cpp" added_lines="557" deleted_lines="593">
				<diff>@@ -39,701 +39,665 @@
 cv::Point3f
 ROSRangeVisionFusionApp::TransformPoint(const geometry_msgs::Point &amp;in_point, const tf::StampedTransform &amp;in_transform)
 {
-    tf::Vector3 tf_point(in_point.x, in_point.y, in_point.z);
-    tf::Vector3 tf_point_t = in_transform * tf_point;
-    return cv::Point3f(tf_point_t.x(), tf_point_t.y(), tf_point_t.z());
+  tf::Vector3 tf_point(in_point.x, in_point.y, in_point.z);
+  tf::Vector3 tf_point_t = in_transform * tf_point;
+  return cv::Point3f(tf_point_t.x(), tf_point_t.y(), tf_point_t.z());
 }
 
 cv::Point2i
 ROSRangeVisionFusionApp::ProjectPoint(const cv::Point3f &amp;in_point)
 {
-    auto u = int(in_point.x * fx_ / in_point.z + cx_);
-    auto v = int(in_point.y * fy_ / in_point.z + cy_);
+  auto u = int(in_point.x * fx_ / in_point.z + cx_);
+  auto v = int(in_point.y * fy_ / in_point.z + cy_);
 
-    return cv::Point2i(u, v);
+  return cv::Point2i(u, v);
 }
 
 autoware_msgs::DetectedObject
 ROSRangeVisionFusionApp::TransformObject(const autoware_msgs::DetectedObject &amp;in_detection,
-                                                                       const tf::StampedTransform&amp; in_transform)
+                                         const tf::StampedTransform &amp;in_transform)
 {
-    autoware_msgs::DetectedObject t_obj = in_detection;
+  autoware_msgs::DetectedObject t_obj = in_detection;
 
-    tf::Vector3 in_pos(in_detection.pose.position.x,
-                       in_detection.pose.position.y,
-                       in_detection.pose.position.z);
-    tf::Quaternion in_quat(in_detection.pose.orientation.x,
-                           in_detection.pose.orientation.y,
-                           in_detection.pose.orientation.w,
-                           in_detection.pose.orientation.z);
+  tf::Vector3 in_pos(in_detection.pose.position.x,
+                     in_detection.pose.position.y,
+                     in_detection.pose.position.z);
+  tf::Quaternion in_quat(in_detection.pose.orientation.x,
+                         in_detection.pose.orientation.y,
+                         in_detection.pose.orientation.w,
+                         in_detection.pose.orientation.z);
 
-    tf::Vector3 in_pos_t = in_transform * in_pos;
-    tf::Quaternion in_quat_t = in_transform * in_quat;
+  tf::Vector3 in_pos_t = in_transform * in_pos;
+  tf::Quaternion in_quat_t = in_transform * in_quat;
 
-    t_obj.pose.position.x = in_pos_t.x();
-    t_obj.pose.position.y = in_pos_t.y();
-    t_obj.pose.position.z = in_pos_t.z();
+  t_obj.pose.position.x = in_pos_t.x();
+  t_obj.pose.position.y = in_pos_t.y();
+  t_obj.pose.position.z = in_pos_t.z();
 
-    t_obj.pose.orientation.x = in_quat_t.x();
-    t_obj.pose.orientation.y = in_quat_t.y();
-    t_obj.pose.orientation.z = in_quat_t.z();
-    t_obj.pose.orientation.w = in_quat_t.w();
+  t_obj.pose.orientation.x = in_quat_t.x();
+  t_obj.pose.orientation.y = in_quat_t.y();
+  t_obj.pose.orientation.z = in_quat_t.z();
+  t_obj.pose.orientation.w = in_quat_t.w();
 
-    return t_obj;
+  return t_obj;
 }
 
 bool
 ROSRangeVisionFusionApp::IsObjectInImage(const autoware_msgs::DetectedObject &amp;in_detection)
 {
-    cv::Point3f image_space_point = TransformPoint(in_detection.pose.position, camera_lidar_tf_);
+  cv::Point3f image_space_point = TransformPoint(in_detection.pose.position, camera_lidar_tf_);
 
-    cv::Point2i image_pixel = ProjectPoint(image_space_point);
+  cv::Point2i image_pixel = ProjectPoint(image_space_point);
 
-    return (image_pixel.x &gt;= 0)
-           &amp;&amp; (image_pixel.x &lt; image_size_.width)
-           &amp;&amp; (image_pixel.y &gt;= 0)
-           &amp;&amp; (image_pixel.y &lt; image_size_.height)
-           &amp;&amp; (image_space_point.z &gt; 0);
+  return (image_pixel.x &gt;= 0)
+         &amp;&amp; (image_pixel.x &lt; image_size_.width)
+         &amp;&amp; (image_pixel.y &gt;= 0)
+         &amp;&amp; (image_pixel.y &lt; image_size_.height)
+         &amp;&amp; (image_space_point.z &gt; 0);
 }
 
 cv::Rect ROSRangeVisionFusionApp::ProjectDetectionToRect(const autoware_msgs::DetectedObject &amp;in_detection)
 {
-    cv::Rect projected_box;
+  cv::Rect projected_box;
 
-    Eigen::Vector3f pos;
-    pos &lt;&lt; in_detection.pose.position.x,
-            in_detection.pose.position.y,
-            in_detection.pose.position.z;
+  Eigen::Vector3f pos;
+  pos &lt;&lt; in_detection.pose.position.x,
+    in_detection.pose.position.y,
+    in_detection.pose.position.z;
 
-    Eigen::Quaternionf rot(in_detection.pose.orientation.w,
-                           in_detection.pose.orientation.x,
-                           in_detection.pose.orientation.y,
-                           in_detection.pose.orientation.z);
+  Eigen::Quaternionf rot(in_detection.pose.orientation.w,
+                         in_detection.pose.orientation.x,
+                         in_detection.pose.orientation.y,
+                         in_detection.pose.orientation.z);
 
-    std::vector&lt;double&gt; dims = {in_detection.dimensions.x,
-                                  in_detection.dimensions.y,
-                                  in_detection.dimensions.z};
+  std::vector&lt;double&gt; dims = {
+    in_detection.dimensions.x,
+    in_detection.dimensions.y,
+    in_detection.dimensions.z
+  };
 
-    jsk_recognition_utils::Cube cube(pos, rot, dims);
+  jsk_recognition_utils::Cube cube(pos, rot, dims);
 
-    Eigen::Affine3f range_vision_tf;
-    tf::transformTFToEigen(camera_lidar_tf_, range_vision_tf);
-    jsk_recognition_utils::Vertices vertices = cube.transformVertices(range_vision_tf);
+  Eigen::Affine3f range_vision_tf;
+  tf::transformTFToEigen(camera_lidar_tf_, range_vision_tf);
+  jsk_recognition_utils::Vertices vertices = cube.transformVertices(range_vision_tf);
 
-    std::vector&lt;cv::Point&gt; polygon;
-    for (auto &amp;vertex : vertices)
-    {
-        cv::Point p = ProjectPoint(cv::Point3f(vertex.x(), vertex.y(), vertex.z()));
-        polygon.push_back(p);
-    }
+  std::vector&lt;cv::Point&gt; polygon;
+  for (auto &amp;vertex : vertices)
+  {
+    cv::Point p = ProjectPoint(cv::Point3f(vertex.x(), vertex.y(), vertex.z()));
+    polygon.push_back(p);
+  }
 
-    projected_box = cv::boundingRect(polygon);
+  projected_box = cv::boundingRect(polygon);
 
-    return projected_box;
+  return projected_box;
 }
 
 void
 ROSRangeVisionFusionApp::TransformRangeToVision(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections,
-                                                      autoware_msgs::DetectedObjectArray &amp;out_in_cv_range_detections,
-                                                      autoware_msgs::DetectedObjectArray &amp;out_out_cv_range_detections)
+                                                autoware_msgs::DetectedObjectArray &amp;out_in_cv_range_detections,
+                                                autoware_msgs::DetectedObjectArray &amp;out_out_cv_range_detections)
 {
-    out_in_cv_range_detections.header = in_range_detections-&gt;header;
-    out_in_cv_range_detections.objects.clear();
-    out_out_cv_range_detections.header = in_range_detections-&gt;header;
-    out_out_cv_range_detections.objects.clear();
-    for (size_t i= 0; i &lt; in_range_detections-&gt;objects.size(); i++)
+  out_in_cv_range_detections.header = in_range_detections-&gt;header;
+  out_in_cv_range_detections.objects.clear();
+  out_out_cv_range_detections.header = in_range_detections-&gt;header;
+  out_out_cv_range_detections.objects.clear();
+  for (size_t i = 0; i &lt; in_range_detections-&gt;objects.size(); i++)
+  {
+    if (IsObjectInImage(in_range_detections-&gt;objects[i]))
     {
-        if(IsObjectInImage(in_range_detections-&gt;objects[i]))
-        {
-            out_in_cv_range_detections.objects.push_back(in_range_detections-&gt;objects[i]);
-        }
-        else
-        {
-            out_out_cv_range_detections.objects.push_back(in_range_detections-&gt;objects[i]);
-        }
+      out_in_cv_range_detections.objects.push_back(in_range_detections-&gt;objects[i]);
+    } else
+    {
+      out_out_cv_range_detections.objects.push_back(in_range_detections-&gt;objects[i]);
     }
+  }
 }
 
 void
 ROSRangeVisionFusionApp::CalculateObjectFeatures(autoware_msgs::DetectedObject &amp;in_out_object, bool in_estimate_pose)
 {
 
-    float min_x=std::numeric_limits&lt;float&gt;::max();float max_x=-std::numeric_limits&lt;float&gt;::max();
-    float min_y=std::numeric_limits&lt;float&gt;::max();float max_y=-std::numeric_limits&lt;float&gt;::max();
-    float min_z=std::numeric_limits&lt;float&gt;::max();float max_z=-std::numeric_limits&lt;float&gt;::max();
-    float average_x = 0, average_y = 0, average_z = 0, length, width, height;
-    pcl::PointXYZ centroid, min_point, max_point, average_point;
-
-    std::vector&lt;cv::Point2f&gt; object_2d_points;
-
-    pcl::PointCloud&lt;pcl::PointXYZ&gt; in_cloud;
-    pcl::fromROSMsg(in_out_object.pointcloud, in_cloud);
-
-    for (const auto &amp;point : in_cloud.points)
-    {
-        average_x+=point.x;		average_y+=point.y;		average_z+=point.z;
-        centroid.x += point.x; centroid.y += point.y;	centroid.z += point.z;
-
-        if(point.x&lt;min_x)	min_x = point.x;
-        if(point.y&lt;min_y)	min_y = point.y;
-        if(point.z&lt;min_z)	min_z = point.z;
-        if(point.x&gt;max_x)	max_x = point.x;
-        if(point.y&gt;max_y)	max_y = point.y;
-        if(point.z&gt;max_z)	max_z = point.z;
-
-        cv::Point2f pt;
-        pt.x = point.x;
-        pt.y = point.y;
-        object_2d_points.push_back(pt);
-    }
-    min_point.x = min_x;	min_point.y = min_y;	min_point.z = min_z;
-    max_point.x = max_x;	max_point.y = max_y;	max_point.z = max_z;
-
-    if (in_cloud.points.size() &gt; 0)
-    {
-        centroid.x /= in_cloud.points.size();
-        centroid.y /= in_cloud.points.size();
-        centroid.z /= in_cloud.points.size();
-
-        average_x /= in_cloud.points.size();
-        average_y /= in_cloud.points.size();
-        average_z /= in_cloud.points.size();
-    }
-
-    average_point.x = average_x; average_point.y = average_y;	average_point.z = average_z;
-
-    length = max_point.x - min_point.x;
-    width = max_point.y - min_point.y;
-    height = max_point.z - min_point.z;
-
-    geometry_msgs::PolygonStamped  convex_hull;
-    std::vector&lt;cv::Point2f&gt; hull_points;
-    if (object_2d_points.size() &gt; 0)
-        cv::convexHull(object_2d_points, hull_points);
-
-    convex_hull.header = in_out_object.header;
-    for (size_t i = 0; i &lt; hull_points.size() + 1 ; i++)
-    {
-        geometry_msgs::Point32 point;
-        point.x = hull_points[i%hull_points.size()].x;
-        point.y = hull_points[i%hull_points.size()].y;
-        point.z = min_point.z;
-        convex_hull.polygon.points.push_back(point);
-    }
-
-    for (size_t i = 0; i &lt; hull_points.size() + 1 ; i++)
-    {
-        geometry_msgs::Point32 point;
-        point.x = hull_points[i%hull_points.size()].x;
-        point.y = hull_points[i%hull_points.size()].y;
-        point.z = max_point.z;
-        convex_hull.polygon.points.push_back(point);
-    }
-
-    double rz = 0;
-    if (in_estimate_pose)
-    {
-        cv::RotatedRect box = cv::minAreaRect(hull_points);
-        rz = box.angle*3.14/180;
-        in_out_object.pose.position.x = box.center.x;
-        in_out_object.pose.position.y = box.center.y;
-        in_out_object.dimensions.x = box.size.width;
-        in_out_object.dimensions.y = box.size.height;
-    }
-
-    in_out_object.convex_hull = convex_hull;
-
-    in_out_object.pose.position.x = min_point.x + length/2;
-    in_out_object.pose.position.y = min_point.y + width/2;
-    in_out_object.pose.position.z = min_point.z + height/2;
-
-    in_out_object.dimensions.x = ((length&lt;0)?-1*length:length);
-    in_out_object.dimensions.y = ((width&lt;0)?-1*width:width);
-    in_out_object.dimensions.z = ((height&lt;0)?-1*height:height);
-
-    tf::Quaternion quat = tf::createQuaternionFromRPY(0.0, 0.0, rz);
-    tf::quaternionTFToMsg(quat, in_out_object.pose.orientation);
+  float min_x = std::numeric_limits&lt;float&gt;::max();
+  float max_x = -std::numeric_limits&lt;float&gt;::max();
+  float min_y = std::numeric_limits&lt;float&gt;::max();
+  float max_y = -std::numeric_limits&lt;float&gt;::max();
+  float min_z = std::numeric_limits&lt;float&gt;::max();
+  float max_z = -std::numeric_limits&lt;float&gt;::max();
+  float average_x = 0, average_y = 0, average_z = 0, length, width, height;
+  pcl::PointXYZ centroid, min_point, max_point, average_point;
+
+  std::vector&lt;cv::Point2f&gt; object_2d_points;
+
+  pcl::PointCloud&lt;pcl::PointXYZ&gt; in_cloud;
+  pcl::fromROSMsg(in_out_object.pointcloud, in_cloud);
+
+  for (const auto &amp;point : in_cloud.points)
+  {
+    average_x += point.x;
+    average_y += point.y;
+    average_z += point.z;
+    centroid.x += point.x;
+    centroid.y += point.y;
+    centroid.z += point.z;
+
+    if (point.x &lt; min_x)
+      min_x = point.x;
+    if (point.y &lt; min_y)
+      min_y = point.y;
+    if (point.z &lt; min_z)
+      min_z = point.z;
+    if (point.x &gt; max_x)
+      max_x = point.x;
+    if (point.y &gt; max_y)
+      max_y = point.y;
+    if (point.z &gt; max_z)
+      max_z = point.z;
+
+    cv::Point2f pt;
+    pt.x = point.x;
+    pt.y = point.y;
+    object_2d_points.push_back(pt);
+  }
+  min_point.x = min_x;
+  min_point.y = min_y;
+  min_point.z = min_z;
+  max_point.x = max_x;
+  max_point.y = max_y;
+  max_point.z = max_z;
+
+  if (in_cloud.points.size() &gt; 0)
+  {
+    centroid.x /= in_cloud.points.size();
+    centroid.y /= in_cloud.points.size();
+    centroid.z /= in_cloud.points.size();
+
+    average_x /= in_cloud.points.size();
+    average_y /= in_cloud.points.size();
+    average_z /= in_cloud.points.size();
+  }
+
+  average_point.x = average_x;
+  average_point.y = average_y;
+  average_point.z = average_z;
+
+  length = max_point.x - min_point.x;
+  width = max_point.y - min_point.y;
+  height = max_point.z - min_point.z;
+
+  geometry_msgs::PolygonStamped convex_hull;
+  std::vector&lt;cv::Point2f&gt; hull_points;
+  if (object_2d_points.size() &gt; 0)
+    cv::convexHull(object_2d_points, hull_points);
+
+  convex_hull.header = in_out_object.header;
+  for (size_t i = 0; i &lt; hull_points.size() + 1; i++)
+  {
+    geometry_msgs::Point32 point;
+    point.x = hull_points[i % hull_points.size()].x;
+    point.y = hull_points[i % hull_points.size()].y;
+    point.z = min_point.z;
+    convex_hull.polygon.points.push_back(point);
+  }
+
+  for (size_t i = 0; i &lt; hull_points.size() + 1; i++)
+  {
+    geometry_msgs::Point32 point;
+    point.x = hull_points[i % hull_points.size()].x;
+    point.y = hull_points[i % hull_points.size()].y;
+    point.z = max_point.z;
+    convex_hull.polygon.points.push_back(point);
+  }
+
+  double rz = 0;
+  if (in_estimate_pose)
+  {
+    cv::RotatedRect box = cv::minAreaRect(hull_points);
+    rz = box.angle * 3.14 / 180;
+    in_out_object.pose.position.x = box.center.x;
+    in_out_object.pose.position.y = box.center.y;
+    in_out_object.dimensions.x = box.size.width;
+    in_out_object.dimensions.y = box.size.height;
+  }
+
+  in_out_object.convex_hull = convex_hull;
+
+  in_out_object.pose.position.x = min_point.x + length / 2;
+  in_out_object.pose.position.y = min_point.y + width / 2;
+  in_out_object.pose.position.z = min_point.z + height / 2;
+
+  in_out_object.dimensions.x = ((length &lt; 0) ? -1 * length : length);
+  in_out_object.dimensions.y = ((width &lt; 0) ? -1 * width : width);
+  in_out_object.dimensions.z = ((height &lt; 0) ? -1 * height : height);
+
+  tf::Quaternion quat = tf::createQuaternionFromRPY(0.0, 0.0, rz);
+  tf::quaternionTFToMsg(quat, in_out_object.pose.orientation);
 }
 
 autoware_msgs::DetectedObject ROSRangeVisionFusionApp::MergeObjects(const autoware_msgs::DetectedObject &amp;in_object_a,
-                                           const autoware_msgs::DetectedObject &amp; in_object_b)
+                                                                    const autoware_msgs::DetectedObject &amp;in_object_b)
 {
-    autoware_msgs::DetectedObject object_merged;
-    object_merged = in_object_b;
+  autoware_msgs::DetectedObject object_merged;
+  object_merged = in_object_b;
 
-    pcl::PointCloud&lt;pcl::PointXYZ&gt; cloud_a, cloud_b, cloud_merged;
+  pcl::PointCloud&lt;pcl::PointXYZ&gt; cloud_a, cloud_b, cloud_merged;
 
-    if (!in_object_a.pointcloud.data.empty())
-        pcl::fromROSMsg(in_object_a.pointcloud, cloud_a);
-    if (!in_object_b.pointcloud.data.empty())
-        pcl::fromROSMsg(in_object_b.pointcloud, cloud_b);
+  if (!in_object_a.pointcloud.data.empty())
+    pcl::fromROSMsg(in_object_a.pointcloud, cloud_a);
+  if (!in_object_b.pointcloud.data.empty())
+    pcl::fromROSMsg(in_object_b.pointcloud, cloud_b);
 
-    cloud_merged = cloud_a + cloud_b;
+  cloud_merged = cloud_a + cloud_b;
 
-    sensor_msgs::PointCloud2 cloud_msg;
-    pcl::toROSMsg(cloud_merged, cloud_msg);
-    cloud_msg.header = object_merged.pointcloud.header;
+  sensor_msgs::PointCloud2 cloud_msg;
+  pcl::toROSMsg(cloud_merged, cloud_msg);
+  cloud_msg.header = object_merged.pointcloud.header;
 
-    object_merged.pointcloud = cloud_msg;
+  object_merged.pointcloud = cloud_msg;
 
-    return object_merged;
+  return object_merged;
 
 }
 
 double ROSRangeVisionFusionApp::GetDistanceToObject(const autoware_msgs::DetectedObject &amp;in_object)
 {
-    return sqrt(in_object.dimensions.x*in_object.dimensions.x +
-                in_object.dimensions.y*in_object.dimensions.y +
-                in_object.dimensions.z*in_object.dimensions.z);
+  return sqrt(in_object.dimensions.x * in_object.dimensions.x +
+              in_object.dimensions.y * in_object.dimensions.y +
+              in_object.dimensions.z * in_object.dimensions.z);
 }
 
 void ROSRangeVisionFusionApp::CheckMinimumDimensions(autoware_msgs::DetectedObject &amp;in_out_object)
 {
-    if (in_out_object.label == "car")
-    {
-        if (in_out_object.dimensions.x &lt; car_depth_)
-            in_out_object.dimensions.x = car_depth_;
-        if (in_out_object.dimensions.y &lt; car_width_)
-            in_out_object.dimensions.y = car_width_;
-        if (in_out_object.dimensions.z &lt; car_height_)
-            in_out_object.dimensions.z = car_height_;
-    }
-    if (in_out_object.label == "person")
-    {
-        if (in_out_object.dimensions.x &lt; person_depth_)
-            in_out_object.dimensions.x = person_depth_;
-        if (in_out_object.dimensions.y &lt; person_width_)
-            in_out_object.dimensions.y = person_width_;
-        if (in_out_object.dimensions.z &lt; person_height_)
-            in_out_object.dimensions.z = person_height_;
-    }
-
-    if (in_out_object.label == "truck" || in_out_object.label == "bus")
-    {
-        if (in_out_object.dimensions.x &lt; truck_depth_)
-            in_out_object.dimensions.x = truck_depth_;
-        if (in_out_object.dimensions.y &lt; truck_width_)
-            in_out_object.dimensions.y = truck_width_;
-        if (in_out_object.dimensions.z &lt; truck_height_)
-            in_out_object.dimensions.z = truck_height_;
-    }
+  if (in_out_object.label == "car")
+  {
+    if (in_out_object.dimensions.x &lt; car_depth_)
+      in_out_object.dimensions.x = car_depth_;
+    if (in_out_object.dimensions.y &lt; car_width_)
+      in_out_object.dimensions.y = car_width_;
+    if (in_out_object.dimensions.z &lt; car_height_)
+      in_out_object.dimensions.z = car_height_;
+  }
+  if (in_out_object.label == "person")
+  {
+    if (in_out_object.dimensions.x &lt; person_depth_)
+      in_out_object.dimensions.x = person_depth_;
+    if (in_out_object.dimensions.y &lt; person_width_)
+      in_out_object.dimensions.y = person_width_;
+    if (in_out_object.dimensions.z &lt; person_height_)
+      in_out_object.dimensions.z = person_height_;
+  }
+
+  if (in_out_object.label == "truck" || in_out_object.label == "bus")
+  {
+    if (in_out_object.dimensions.x &lt; truck_depth_)
+      in_out_object.dimensions.x = truck_depth_;
+    if (in_out_object.dimensions.y &lt; truck_width_)
+      in_out_object.dimensions.y = truck_width_;
+    if (in_out_object.dimensions.z &lt; truck_height_)
+      in_out_object.dimensions.z = truck_height_;
+  }
 }
 
 autoware_msgs::DetectedObjectArray
-ROSRangeVisionFusionApp::FuseRangeVisionDetections(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections,
-                                                   const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections)
+ROSRangeVisionFusionApp::FuseRangeVisionDetections(
+  const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections,
+  const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections)
 {
 
-    autoware_msgs::DetectedObjectArray range_in_cv;
-    autoware_msgs::DetectedObjectArray range_out_cv;
-    TransformRangeToVision(in_range_detections, range_in_cv, range_out_cv);
-
-    autoware_msgs::DetectedObjectArray fused_objects;
-    fused_objects.header = in_range_detections-&gt;header;
-
-    std::vector&lt; std::vector&lt;size_t&gt; &gt; vision_range_assignments (in_vision_detections-&gt;objects.size());
-    std::vector&lt;bool&gt; used_vision_detections(in_vision_detections-&gt;objects.size(), false);
-    std::vector&lt; long &gt; vision_range_closest (in_vision_detections-&gt;objects.size());
-
-    for (size_t i = 0; i &lt; in_vision_detections-&gt;objects.size(); i++)
-    {
-        auto vision_object = in_vision_detections-&gt;objects[i];
-
-        cv::Rect vision_rect(vision_object.x, vision_object.y,
-                             vision_object.width, vision_object.height);
-        int vision_rect_area = vision_rect.area();
-        long closest_index = -1;
-        double closest_distance = std::numeric_limits&lt;double&gt;::max();
-
-        for (size_t j = 0; j &lt; range_in_cv.objects.size(); j++)
-        {
-            double current_distance = GetDistanceToObject(range_in_cv.objects[j]);
-
-            cv::Rect range_rect = ProjectDetectionToRect(range_in_cv.objects[j]);
-            int range_rect_area = range_rect.area();
-
-            cv::Rect overlap = range_rect &amp; vision_rect;
-            if ( (overlap.area() &gt; range_rect_area*overlap_threshold_)
-                 || (overlap.area() &gt; vision_rect_area*overlap_threshold_)
-                    )
-            {
-                vision_range_assignments[i].push_back(j);
-                range_in_cv.objects[j].score = vision_object.score;
-                range_in_cv.objects[j].label = vision_object.label;
-                range_in_cv.objects[j].color = vision_object.color;
-                range_in_cv.objects[j].image_frame = vision_object.image_frame;
-                range_in_cv.objects[j].x = vision_object.x;
-                range_in_cv.objects[j].y = vision_object.y;
-                range_in_cv.objects[j].width = vision_object.width;
-                range_in_cv.objects[j].height = vision_object.height;
-                range_in_cv.objects[j].angle = vision_object.angle;
-                range_in_cv.objects[j].id = vision_object.id;
-                CheckMinimumDimensions(range_in_cv.objects[j]);
-                if (vision_object.pose.orientation.x &gt; 0
-                    || vision_object.pose.orientation.y &gt; 0
-                    || vision_object.pose.orientation.z &gt; 0)
-                {
-                    range_in_cv.objects[i].pose.orientation = vision_object.pose.orientation;
-                }
-                if(current_distance &lt; closest_distance)
-                {
-                    closest_index = j;
-                    closest_distance = current_distance;
-                }
-                used_vision_detections[i] = true;
-            }//end if overlap
-        }//end for range_in_cv
-        vision_range_closest[i] = closest_index;
-    }
-
-    std::vector&lt;bool&gt; used_range_detections(range_in_cv.objects.size(), false);
-    //only assign the closest
-    for(size_t i = 0; i &lt; vision_range_assignments.size(); i++)
-    {
-        if(!range_in_cv.objects.empty() &amp;&amp; vision_range_closest[i] &gt;= 0)
+  autoware_msgs::DetectedObjectArray range_in_cv;
+  autoware_msgs::DetectedObjectArray range_out_cv;
+  TransformRangeToVision(in_range_detections, range_in_cv, range_out_cv);
+
+  autoware_msgs::DetectedObjectArray fused_objects;
+  fused_objects.header = in_range_detections-&gt;header;
+
+  std::vector&lt;std::vector&lt;size_t&gt; &gt; vision_range_assignments(in_vision_detections-&gt;objects.size());
+  std::vector&lt;bool&gt; used_vision_detections(in_vision_detections-&gt;objects.size(), false);
+  std::vector&lt;long&gt; vision_range_closest(in_vision_detections-&gt;objects.size());
+
+  for (size_t i = 0; i &lt; in_vision_detections-&gt;objects.size(); i++)
+  {
+    auto vision_object = in_vision_detections-&gt;objects[i];
+
+    cv::Rect vision_rect(vision_object.x, vision_object.y,
+                         vision_object.width, vision_object.height);
+    int vision_rect_area = vision_rect.area();
+    long closest_index = -1;
+    double closest_distance = std::numeric_limits&lt;double&gt;::max();
+
+    for (size_t j = 0; j &lt; range_in_cv.objects.size(); j++)
+    {
+      double current_distance = GetDistanceToObject(range_in_cv.objects[j]);
+
+      cv::Rect range_rect = ProjectDetectionToRect(range_in_cv.objects[j]);
+      int range_rect_area = range_rect.area();
+
+      cv::Rect overlap = range_rect &amp; vision_rect;
+      if ((overlap.area() &gt; range_rect_area * overlap_threshold_)
+          || (overlap.area() &gt; vision_rect_area * overlap_threshold_)
+        )
+      {
+        vision_range_assignments[i].push_back(j);
+        range_in_cv.objects[j].score = vision_object.score;
+        range_in_cv.objects[j].label = vision_object.label;
+        range_in_cv.objects[j].color = vision_object.color;
+        range_in_cv.objects[j].image_frame = vision_object.image_frame;
+        range_in_cv.objects[j].x = vision_object.x;
+        range_in_cv.objects[j].y = vision_object.y;
+        range_in_cv.objects[j].width = vision_object.width;
+        range_in_cv.objects[j].height = vision_object.height;
+        range_in_cv.objects[j].angle = vision_object.angle;
+        range_in_cv.objects[j].id = vision_object.id;
+        CheckMinimumDimensions(range_in_cv.objects[j]);
+        if (vision_object.pose.orientation.x &gt; 0
+            || vision_object.pose.orientation.y &gt; 0
+            || vision_object.pose.orientation.z &gt; 0)
         {
-            used_range_detections[i] = true;
-            fused_objects.objects.push_back(range_in_cv.objects[vision_range_closest[i]]);
+          range_in_cv.objects[i].pose.orientation = vision_object.pose.orientation;
         }
-    }
-    for(size_t i = 0; i &lt; used_vision_detections.size(); i++)
-    {
-        if (!used_vision_detections[i])
+        if (current_distance &lt; closest_distance)
         {
-            fused_objects.objects.push_back(in_vision_detections-&gt;objects[i]);
+          closest_index = j;
+          closest_distance = current_distance;
         }
-    }
-
-    return fused_objects;
+        used_vision_detections[i] = true;
+      }//end if overlap
+    }//end for range_in_cv
+    vision_range_closest[i] = closest_index;
+  }
+
+  std::vector&lt;bool&gt; used_range_detections(range_in_cv.objects.size(), false);
+  //only assign the closest
+  for (size_t i = 0; i &lt; vision_range_assignments.size(); i++)
+  {
+    if (!range_in_cv.objects.empty() &amp;&amp; vision_range_closest[i] &gt;= 0)
+    {
+      used_range_detections[i] = true;
+      fused_objects.objects.push_back(range_in_cv.objects[vision_range_closest[i]]);
+    }
+  }
+  for (size_t i = 0; i &lt; used_vision_detections.size(); i++)
+  {
+    if (!used_vision_detections[i])
+    {
+      fused_objects.objects.push_back(in_vision_detections-&gt;objects[i]);
+    }
+  }
+  //add also objects outside the image
+  for (auto &amp;object: range_out_cv.objects)
+  {
+    fused_objects.objects.push_back(object);
+  }
+  //enable merged for visualization
+  for (auto &amp;object : fused_objects.objects)
+  {
+    object.valid = true;
+  }
+
+  return fused_objects;
 }
 
 void
-ROSRangeVisionFusionApp::SyncedDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections,
-                                                       const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections)
-{
-    autoware_msgs::DetectedObjectArray fusion_objects;
-    jsk_recognition_msgs::BoundingBoxArray fused_boxes;
-    visualization_msgs::MarkerArray fused_objects_labels;
-
-    fused_boxes.boxes.clear();
-    fusion_objects.objects.clear();
-    fused_objects_labels.markers.clear();
-
-    if (empty_frames_ &gt; 5)
-    {
-        ROS_INFO("[%s] Empty Detections. Make sure the vision and range detectors are running.", __APP_NAME__);
-    }
-
-    if (nullptr == in_vision_detections
-        &amp;&amp; nullptr == in_range_detections)
-    {
-        empty_frames_++;
-        return;
-    }
-
-    if (nullptr == in_vision_detections
-        &amp;&amp; nullptr != in_range_detections
-        &amp;&amp; !in_range_detections-&gt;objects.empty())
-    {
-        publisher_fused_boxes_.publish(fused_boxes);
-        publisher_fused_objects_.publish(in_range_detections);
-        empty_frames_++;
-        return;
-    }
-    if (nullptr == in_range_detections
-        &amp;&amp; nullptr != in_vision_detections
-        &amp;&amp; !in_vision_detections-&gt;objects.empty())
-    {
-        publisher_fused_boxes_.publish(fused_boxes);
-        publisher_fused_objects_.publish(in_vision_detections);
-        empty_frames_++;
-        return;
-    }
-
-    if (!camera_lidar_tf_ok_)
-    {
-        camera_lidar_tf_ = FindTransform(image_frame_id_,
-                                         in_range_detections-&gt;header.frame_id);
-    }
-    if(
-        !camera_lidar_tf_ok_ ||
-        !camera_info_ok_)
-    {
-        ROS_INFO("[%s] Missing Camera-LiDAR TF or CameraInfo", __APP_NAME__);
-        return;
-    }
-
-    fusion_objects = FuseRangeVisionDetections(in_vision_detections, in_range_detections);
-    fused_boxes = ObjectsToBoxes(fusion_objects);
-    fused_objects_labels = ObjectsToMarkers(fusion_objects);
-
-    publisher_fused_objects_.publish(fusion_objects);
-    publisher_fused_boxes_.publish(fused_boxes);
-    publisher_fused_text_.publish(fused_objects_labels);
-    boxes_frame_ = fused_boxes.header.frame_id;
-    empty_frames_ = 0;
-
-    vision_detections_ = nullptr;
-    range_detections_ = nullptr;
-
-}
-
-visualization_msgs::MarkerArray
-ROSRangeVisionFusionApp::ObjectsToMarkers(const autoware_msgs::DetectedObjectArray &amp;in_objects)
+ROSRangeVisionFusionApp::SyncedDetectionsCallback(
+  const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections,
+  const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections)
 {
-    visualization_msgs::MarkerArray final_markers;
+  autoware_msgs::DetectedObjectArray fusion_objects;
+  fusion_objects.objects.clear();
+
+  if (empty_frames_ &gt; 5)
+  {
+    ROS_INFO("[%s] Empty Detections. Make sure the vision and range detectors are running.", __APP_NAME__);
+  }
+
+  if (nullptr == in_vision_detections
+      &amp;&amp; nullptr == in_range_detections)
+  {
+    empty_frames_++;
+    return;
+  }
+
+  if (nullptr == in_vision_detections
+      &amp;&amp; nullptr != in_range_detections
+      &amp;&amp; !in_range_detections-&gt;objects.empty())
+  {
+    publisher_fused_objects_.publish(in_range_detections);
+    empty_frames_++;
+    return;
+  }
+  if (nullptr == in_range_detections
+      &amp;&amp; nullptr != in_vision_detections
+      &amp;&amp; !in_vision_detections-&gt;objects.empty())
+  {
+    publisher_fused_objects_.publish(in_vision_detections);
+    empty_frames_++;
+    return;
+  }
+
+  if (!camera_lidar_tf_ok_)
+  {
+    camera_lidar_tf_ = FindTransform(image_frame_id_,
+                                     in_range_detections-&gt;header.frame_id);
+  }
+  if (
+    !camera_lidar_tf_ok_ ||
+    !camera_info_ok_)
+  {
+    ROS_INFO("[%s] Missing Camera-LiDAR TF or CameraInfo", __APP_NAME__);
+    return;
+  }
+
+  fusion_objects = FuseRangeVisionDetections(in_vision_detections, in_range_detections);
+
+  publisher_fused_objects_.publish(fusion_objects);
+  empty_frames_ = 0;
+
+  vision_detections_ = nullptr;
+  range_detections_ = nullptr;
 
-    for(const autoware_msgs::DetectedObject&amp; object : in_objects.objects)
-    {
-        if (object.label != "unknown"
-            &amp;&amp; object.pose.position.x != 0
-            &amp;&amp; object.pose.position.y != 0
-            &amp;&amp; object.pose.position.z != 0)
-        {
-            visualization_msgs::Marker marker;
-            marker.header = in_objects.header;
-            marker.ns = "range_vision_fusion";
-            marker.id = object.id;
-            marker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
-            marker.scale.z = 1.0;
-            marker.text = object.label;
-            if (object.id != 0)
-                marker.text += " " + std::to_string(object.id);
-            marker.pose.position = object.pose.position;
-            marker.pose.position.z += 1.5;
-            marker.color.r = 1.0;
-            marker.color.g = 1.0;
-            marker.color.b = 1.0;
-            marker.color.a = 1.0;
-            marker.scale.x = 1.5;
-            marker.scale.y = 1.5;
-            marker.scale.z = 1.5;
-
-            marker.lifetime = ros::Duration(0.1);
-            final_markers.markers.push_back(marker);
-        }
-    }
-    return final_markers;
-}
-
-jsk_recognition_msgs::BoundingBoxArray
-ROSRangeVisionFusionApp::ObjectsToBoxes(const autoware_msgs::DetectedObjectArray &amp;in_objects)
-{
-    jsk_recognition_msgs::BoundingBoxArray final_boxes;
-    final_boxes.header = in_objects.header;
-
-    for(const autoware_msgs::DetectedObject&amp; object : in_objects.objects)
-    {
-        jsk_recognition_msgs::BoundingBox box;
-
-        box.header = in_objects.header;
-        box.label = object.id;
-        box.dimensions = object.dimensions;
-        box.pose = object.pose;
-        box.value = object.score;
-
-        if (box.dimensions.x &gt; 0 &amp;&amp; box.dimensions.y &gt; 0 &amp;&amp; box.dimensions.z &gt; 0)
-        {
-            final_boxes.boxes.push_back(box);
-        }
-    }
-    return final_boxes;
 }
 
 void
-ROSRangeVisionFusionApp::VisionDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections)
+ROSRangeVisionFusionApp::VisionDetectionsCallback(
+  const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections)
 {
-
-    if (!processing_ &amp;&amp; !in_vision_detections-&gt;objects.empty())
-    {
-        processing_ = true;
-        vision_detections_ = in_vision_detections;
-        SyncedDetectionsCallback(in_vision_detections, range_detections_);
-        processing_ = false;
-    }
+  if (!processing_ &amp;&amp; !in_vision_detections-&gt;objects.empty())
+  {
+    processing_ = true;
+    vision_detections_ = in_vision_detections;
+    SyncedDetectionsCallback(in_vision_detections, range_detections_);
+    processing_ = false;
+  }
 }
 
 void
-ROSRangeVisionFusionApp::RangeDetectionsCallback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections)
+ROSRangeVisionFusionApp::RangeDetectionsCallback(
+  const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_range_detections)
 {
-    if (!processing_ &amp;&amp; !in_range_detections-&gt;objects.empty())
-    {
-        processing_ = true;
-        range_detections_ = in_range_detections;
-        SyncedDetectionsCallback(vision_detections_, in_range_detections);
-        processing_ = false;
-    }
+  if (!processing_ &amp;&amp; !in_range_detections-&gt;objects.empty())
+  {
+    processing_ = true;
+    range_detections_ = in_range_detections;
+    SyncedDetectionsCallback(vision_detections_, in_range_detections);
+    processing_ = false;
+  }
 }
 
 void ROSRangeVisionFusionApp::ImageCallback(const sensor_msgs::Image::ConstPtr &amp;in_image_msg)
 {
-    if(!camera_info_ok_)
-        return;
-    cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(in_image_msg, "bgr8");
-    cv::Mat in_image = cv_image-&gt;image;
+  if (!camera_info_ok_)
+    return;
+  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(in_image_msg, "bgr8");
+  cv::Mat in_image = cv_image-&gt;image;
 
-    cv::Mat undistorted_image;
-    cv::undistort(in_image, image_, camera_instrinsics_, distortion_coefficients_);
+  cv::Mat undistorted_image;
+  cv::undistort(in_image, image_, camera_instrinsics_, distortion_coefficients_);
 };
 
 void
 ROSRangeVisionFusionApp::IntrinsicsCallback(const sensor_msgs::CameraInfo &amp;in_message)
 {
-    image_size_.height = in_message.height;
-    image_size_.width = in_message.width;
+  image_size_.height = in_message.height;
+  image_size_.width = in_message.width;
 
-    camera_instrinsics_ = cv::Mat(3, 3, CV_64F);
-    for (int row = 0; row &lt; 3; row++)
+  camera_instrinsics_ = cv::Mat(3, 3, CV_64F);
+  for (int row = 0; row &lt; 3; row++)
+  {
+    for (int col = 0; col &lt; 3; col++)
     {
-        for (int col = 0; col &lt; 3; col++)
-        {
-            camera_instrinsics_.at&lt;double&gt;(row, col) = in_message.K[row * 3 + col];
-        }
+      camera_instrinsics_.at&lt;double&gt;(row, col) = in_message.K[row * 3 + col];
     }
+  }
 
-    distortion_coefficients_ = cv::Mat(1, 5, CV_64F);
-    for (int col = 0; col &lt; 5; col++)
-    {
-        distortion_coefficients_.at&lt;double&gt;(col) = in_message.D[col];
-    }
+  distortion_coefficients_ = cv::Mat(1, 5, CV_64F);
+  for (int col = 0; col &lt; 5; col++)
+  {
+    distortion_coefficients_.at&lt;double&gt;(col) = in_message.D[col];
+  }
 
-    fx_ = static_cast&lt;float&gt;(in_message.P[0]);
-    fy_ = static_cast&lt;float&gt;(in_message.P[5]);
-    cx_ = static_cast&lt;float&gt;(in_message.P[2]);
-    cy_ = static_cast&lt;float&gt;(in_message.P[6]);
+  fx_ = static_cast&lt;float&gt;(in_message.P[0]);
+  fy_ = static_cast&lt;float&gt;(in_message.P[5]);
+  cx_ = static_cast&lt;float&gt;(in_message.P[2]);
+  cy_ = static_cast&lt;float&gt;(in_message.P[6]);
 
-    intrinsics_subscriber_.shutdown();
-    camera_info_ok_ = true;
-    image_frame_id_ = in_message.header.frame_id;
-    ROS_INFO("[%s] CameraIntrinsics obtained.", __APP_NAME__);
+  intrinsics_subscriber_.shutdown();
+  camera_info_ok_ = true;
+  image_frame_id_ = in_message.header.frame_id;
+  ROS_INFO("[%s] CameraIntrinsics obtained.", __APP_NAME__);
 }
 
 tf::StampedTransform
 ROSRangeVisionFusionApp::FindTransform(const std::string &amp;in_target_frame, const std::string &amp;in_source_frame)
 {
-    tf::StampedTransform transform;
-
-    ROS_INFO("%s - &gt; %s", in_source_frame.c_str(), in_target_frame.c_str());
-    camera_lidar_tf_ok_ = false;
-    try
-    {
-        transform_listener_-&gt;lookupTransform(in_target_frame, in_source_frame, ros::Time(0), transform);
-        camera_lidar_tf_ok_ = true;
-        ROS_INFO("[%s] Camera-Lidar TF obtained", __APP_NAME__);
-    }
-    catch (tf::TransformException &amp;ex)
-    {
-        ROS_ERROR("[%s] %s", __APP_NAME__, ex.what());
-    }
-
-    return transform;
+  tf::StampedTransform transform;
+
+  ROS_INFO("%s - &gt; %s", in_source_frame.c_str(), in_target_frame.c_str());
+  camera_lidar_tf_ok_ = false;
+  try
+  {
+    transform_listener_-&gt;lookupTransform(in_target_frame, in_source_frame, ros::Time(0), transform);
+    camera_lidar_tf_ok_ = true;
+    ROS_INFO("[%s] Camera-Lidar TF obtained", __APP_NAME__);
+  }
+  catch (tf::TransformException &amp;ex)
+  {
+    ROS_ERROR("[%s] %s", __APP_NAME__, ex.what());
+  }
+
+  return transform;
 }
 
 void
 ROSRangeVisionFusionApp::InitializeROSIo(ros::NodeHandle &amp;in_private_handle)
 {
-    //get params
-    std::string camera_info_src, detected_objects_vision, min_car_dimensions, min_person_dimensions, min_truck_dimensions;
-    std::string detected_objects_range, fused_topic_str = "/detection/combined_objects", fused_boxes_str = "/detection/combined_objects_boxes";
-    std::string fused_text_str = "detection/combined_objects_labels";
-    std::string name_space_str = ros::this_node::getNamespace();
-    bool sync_topics = false;
-
-    ROS_INFO("[%s] This node requires: Registered TF(Lidar-Camera), CameraInfo, Vision and Range Detections being published.", __APP_NAME__);
-    in_private_handle.param&lt;std::string&gt;("detected_objects_range", detected_objects_range, "/detection/lidar_objects");
-    ROS_INFO("[%s] detected_objects_range: %s", __APP_NAME__, detected_objects_range.c_str());
-
-    in_private_handle.param&lt;std::string&gt;("detected_objects_vision", detected_objects_vision, "/detection/vision_objects");
-    ROS_INFO("[%s] detected_objects_vision: %s", __APP_NAME__, detected_objects_vision.c_str());
-
-    in_private_handle.param&lt;std::string&gt;("camera_info_src", camera_info_src, "/camera_info");
-    ROS_INFO("[%s] camera_info_src: %s", __APP_NAME__, camera_info_src.c_str());
-
-    in_private_handle.param&lt;double&gt;("overlap_threshold", overlap_threshold_, 0.5);
-    ROS_INFO("[%s] overlap_threshold: %f", __APP_NAME__, overlap_threshold_);
-
-    in_private_handle.param&lt;std::string&gt;("min_car_dimensions", min_car_dimensions, "[2,2,4]");//w,h,d
-    ROS_INFO("[%s] min_car_dimensions: %s", __APP_NAME__, min_car_dimensions.c_str());
-
-    in_private_handle.param&lt;std::string&gt;("min_person_dimensions", min_person_dimensions, "[1,2,1]");
-    ROS_INFO("[%s] min_person_dimensions: %s", __APP_NAME__, min_person_dimensions.c_str());
-
-    in_private_handle.param&lt;std::string&gt;("min_truck_dimensions", min_truck_dimensions, "[2,2,4.5]");
-    ROS_INFO("[%s] min_truck_dimensions: %s", __APP_NAME__, min_truck_dimensions.c_str());
-
-
-    in_private_handle.param&lt;bool&gt;("sync_topics", sync_topics, false);
-    ROS_INFO("[%s] sync_topics: %d", __APP_NAME__, sync_topics);
-
-    YAML::Node car_dimensions = YAML::Load(min_car_dimensions);
-    YAML::Node person_dimensions = YAML::Load(min_person_dimensions);
-    YAML::Node truck_dimensions = YAML::Load(min_truck_dimensions);
-
-    if (car_dimensions.size() == 3)
-    {
-        car_width_ = car_dimensions[0].as&lt;double&gt;();
-        car_height_ = car_dimensions[1].as&lt;double&gt;();
-        car_depth_ = car_dimensions[2].as&lt;double&gt;();
-    }
-    if (person_dimensions.size() == 3)
-    {
-        person_width_ = person_dimensions[0].as&lt;double&gt;();
-        person_height_ = person_dimensions[1].as&lt;double&gt;();
-        person_depth_ = person_dimensions[2].as&lt;double&gt;();
-    }
-    if (truck_dimensions.size() == 3)
-    {
-        truck_width_ = truck_dimensions[0].as&lt;double&gt;();
-        truck_height_ = truck_dimensions[1].as&lt;double&gt;();
-        truck_depth_ = truck_dimensions[2].as&lt;double&gt;();
-    }
-
-    if (name_space_str != "/")
-    {
-        if (name_space_str.substr(0, 2) == "//")
-        {
-            name_space_str.erase(name_space_str.begin());
-        }
-        camera_info_src = name_space_str + camera_info_src;
-    }
-
-    //generate subscribers and sychronizers
-    ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, camera_info_src.c_str());
-    intrinsics_subscriber_ = in_private_handle.subscribe(camera_info_src,
-                                                         1,
-                                                         &amp;ROSRangeVisionFusionApp::IntrinsicsCallback, this);
-
-    ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, detected_objects_vision.c_str());
-    ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, detected_objects_range.c_str());
-    if (!sync_topics)
-    {
-        detections_range_subscriber_ = in_private_handle.subscribe(detected_objects_vision,
-                                                                   1,
-                                                                   &amp;ROSRangeVisionFusionApp::VisionDetectionsCallback, this);
-
-        detections_vision_subscriber_ = in_private_handle.subscribe(detected_objects_range,
-                                                                    1,
-                                                                    &amp;ROSRangeVisionFusionApp::RangeDetectionsCallback, this);
-    }
-    else
-    {
-        vision_filter_subscriber_ = new message_filters::Subscriber&lt;autoware_msgs::DetectedObjectArray&gt;(node_handle_,
-                                                                                                        detected_objects_vision, 1);
-        range_filter_subscriber_ = new message_filters::Subscriber&lt;autoware_msgs::DetectedObjectArray&gt;(node_handle_,
-                                                                                                        detected_objects_range, 1);
-        detections_synchronizer_ =
-                new message_filters::Synchronizer&lt;SyncPolicyT&gt;(SyncPolicyT(10),
-                                                               *vision_filter_subscriber_,
-                                                               *range_filter_subscriber_);
-        detections_synchronizer_-&gt;registerCallback(boost::bind(&amp;ROSRangeVisionFusionApp::SyncedDetectionsCallback, this, _1, _2));
-    }
-
-    publisher_fused_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;(fused_topic_str, 1);
-    publisher_fused_boxes_ = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(fused_boxes_str, 1);
-    publisher_fused_text_ = node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;(fused_text_str, 1);
-
-    ROS_INFO("[%s] Publishing fused objects in %s", __APP_NAME__, fused_topic_str.c_str());
-    ROS_INFO("[%s] Publishing fused boxes in %s", __APP_NAME__, fused_boxes_str.c_str());
+  //get params
+  std::string camera_info_src, detected_objects_vision, min_car_dimensions, min_person_dimensions, min_truck_dimensions;
+  std::string detected_objects_range, fused_topic_str = "/detection/fusion_tools/objects";
+  std::string name_space_str = ros::this_node::getNamespace();
+  bool sync_topics = false;
+
+  ROS_INFO(
+    "[%s] This node requires: Registered TF(Lidar-Camera), CameraInfo, Vision and Range Detections being published.",
+    __APP_NAME__);
+  in_private_handle.param&lt;std::string&gt;("detected_objects_range", detected_objects_range,
+                                       "/detection/lidar_detector/objects");
+  ROS_INFO("[%s] detected_objects_range: %s", __APP_NAME__, detected_objects_range.c_str());
+
+  in_private_handle.param&lt;std::string&gt;("detected_objects_vision", detected_objects_vision,
+                                       "/detection/image_detector/objects");
+  ROS_INFO("[%s] detected_objects_vision: %s", __APP_NAME__, detected_objects_vision.c_str());
+
+  in_private_handle.param&lt;std::string&gt;("camera_info_src", camera_info_src, "/camera_info");
+  ROS_INFO("[%s] camera_info_src: %s", __APP_NAME__, camera_info_src.c_str());
+
+  in_private_handle.param&lt;double&gt;("overlap_threshold", overlap_threshold_, 0.6);
+  ROS_INFO("[%s] overlap_threshold: %f", __APP_NAME__, overlap_threshold_);
+
+  in_private_handle.param&lt;std::string&gt;("min_car_dimensions", min_car_dimensions, "[3,2,2]");//w,h,d
+  ROS_INFO("[%s] min_car_dimensions: %s", __APP_NAME__, min_car_dimensions.c_str());
+
+  in_private_handle.param&lt;std::string&gt;("min_person_dimensions", min_person_dimensions, "[1,2,1]");
+  ROS_INFO("[%s] min_person_dimensions: %s", __APP_NAME__, min_person_dimensions.c_str());
+
+  in_private_handle.param&lt;std::string&gt;("min_truck_dimensions", min_truck_dimensions, "[4,2,2]");
+  ROS_INFO("[%s] min_truck_dimensions: %s", __APP_NAME__, min_truck_dimensions.c_str());
+
+
+  in_private_handle.param&lt;bool&gt;("sync_topics", sync_topics, false);
+  ROS_INFO("[%s] sync_topics: %d", __APP_NAME__, sync_topics);
+
+  YAML::Node car_dimensions = YAML::Load(min_car_dimensions);
+  YAML::Node person_dimensions = YAML::Load(min_person_dimensions);
+  YAML::Node truck_dimensions = YAML::Load(min_truck_dimensions);
+
+  if (car_dimensions.size() == 3)
+  {
+    car_width_ = car_dimensions[0].as&lt;double&gt;();
+    car_height_ = car_dimensions[1].as&lt;double&gt;();
+    car_depth_ = car_dimensions[2].as&lt;double&gt;();
+  }
+  if (person_dimensions.size() == 3)
+  {
+    person_width_ = person_dimensions[0].as&lt;double&gt;();
+    person_height_ = person_dimensions[1].as&lt;double&gt;();
+    person_depth_ = person_dimensions[2].as&lt;double&gt;();
+  }
+  if (truck_dimensions.size() == 3)
+  {
+    truck_width_ = truck_dimensions[0].as&lt;double&gt;();
+    truck_height_ = truck_dimensions[1].as&lt;double&gt;();
+    truck_depth_ = truck_dimensions[2].as&lt;double&gt;();
+  }
+
+  if (name_space_str != "/")
+  {
+    if (name_space_str.substr(0, 2) == "//")
+    {
+      name_space_str.erase(name_space_str.begin());
+    }
+    camera_info_src = name_space_str + camera_info_src;
+  }
+
+  //generate subscribers and sychronizers
+  ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, camera_info_src.c_str());
+  intrinsics_subscriber_ = in_private_handle.subscribe(camera_info_src,
+                                                       1,
+                                                       &amp;ROSRangeVisionFusionApp::IntrinsicsCallback, this);
+
+  ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, detected_objects_vision.c_str());
+  ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, detected_objects_range.c_str());
+  if (!sync_topics)
+  {
+    detections_range_subscriber_ = in_private_handle.subscribe(detected_objects_vision,
+                                                               1,
+                                                               &amp;ROSRangeVisionFusionApp::VisionDetectionsCallback,
+                                                               this);
+
+    detections_vision_subscriber_ = in_private_handle.subscribe(detected_objects_range,
+                                                                1,
+                                                                &amp;ROSRangeVisionFusionApp::RangeDetectionsCallback,
+                                                                this);
+  }
+  else
+  {
+    vision_filter_subscriber_ = new message_filters::Subscriber&lt;autoware_msgs::DetectedObjectArray&gt;(node_handle_,
+                                                                                                    detected_objects_vision,
+                                                                                                    1);
+    range_filter_subscriber_ = new message_filters::Subscriber&lt;autoware_msgs::DetectedObjectArray&gt;(node_handle_,
+                                                                                                   detected_objects_range,
+                                                                                                   1);
+    detections_synchronizer_ =
+      new message_filters::Synchronizer&lt;SyncPolicyT&gt;(SyncPolicyT(10),
+                                                     *vision_filter_subscriber_,
+                                                     *range_filter_subscriber_);
+    detections_synchronizer_-&gt;registerCallback(
+      boost::bind(&amp;ROSRangeVisionFusionApp::SyncedDetectionsCallback, this, _1, _2));
+  }
+
+  publisher_fused_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;(fused_topic_str, 1);
+
+  ROS_INFO("[%s] Publishing fused objects in %s", __APP_NAME__, fused_topic_str.c_str());
 
 }
 
@@ -741,26 +705,26 @@ ROSRangeVisionFusionApp::InitializeROSIo(ros::NodeHandle &amp;in_private_handle)
 void
 ROSRangeVisionFusionApp::Run()
 {
-    ros::NodeHandle private_node_handle("~");
-    tf::TransformListener transform_listener;
+  ros::NodeHandle private_node_handle("~");
+  tf::TransformListener transform_listener;
 
-    transform_listener_ = &amp;transform_listener;
+  transform_listener_ = &amp;transform_listener;
 
-    InitializeROSIo(private_node_handle);
+  InitializeROSIo(private_node_handle);
 
-    ROS_INFO("[%s] Ready. Waiting for data...", __APP_NAME__);
+  ROS_INFO("[%s] Ready. Waiting for data...", __APP_NAME__);
 
-    ros::spin();
+  ros::spin();
 
-    ROS_INFO("[%s] END", __APP_NAME__);
+  ROS_INFO("[%s] END", __APP_NAME__);
 }
 
 ROSRangeVisionFusionApp::ROSRangeVisionFusionApp()
 {
-    camera_lidar_tf_ok_ = false;
-    camera_info_ok_ = false;
-    processing_ = false;
-    image_frame_id_ = "";
-    overlap_threshold_ = 0.5;
-    empty_frames_ = 0;
+  camera_lidar_tf_ok_ = false;
+  camera_info_ok_ = false;
+  processing_ = false;
+  image_frame_id_ = "";
+  overlap_threshold_ = 0.5;
+  empty_frames_ = 0;
 }
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\src\range_vision_fusion_node.cpp" new_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\src\range_vision_fusion_node.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -38,11 +38,11 @@
 
 int main(int argc, char **argv)
 {
-    ros::init(argc, argv, __APP_NAME__);
+  ros::init(argc, argv, __APP_NAME__);
 
-    ROSRangeVisionFusionApp app;
+  ROSRangeVisionFusionApp app;
 
-    app.Run();
+  app.Run();
 
-    return 0;
+  return 0;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\cluster.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\cluster.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -62,7 +62,7 @@ Eigen::Vector3f Cluster::GetEigenValues()
   return eigen_values_;
 }
 
-void Cluster::ToROSMessage(std_msgs::Header in_ros_header, autoware_msgs::CloudCluster&amp; out_cluster_message)
+void Cluster::ToROSMessage(std_msgs::Header in_ros_header, autoware_msgs::CloudCluster &amp;out_cluster_message)
 {
   sensor_msgs::PointCloud2 cloud_msg;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\gpu_euclidean_clustering.cu" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\gpu_euclidean_clustering.cu" added_lines="514" deleted_lines="474">
				<diff>@@ -26,58 +26,59 @@
 
 inline void gassert(cudaError_t err_code, const char *file, int line)
 {
-	if (err_code != cudaSuccess) {
-		fprintf(stderr, "Error: %s %s %d\n", cudaGetErrorString(err_code), file, line);
-		cudaDeviceReset();
-		exit(EXIT_FAILURE);
-	}
+  if (err_code != cudaSuccess)
+  {
+    fprintf(stderr, "Error: %s %s %d\n", cudaGetErrorString(err_code), file, line);
+    cudaDeviceReset();
+    exit(EXIT_FAILURE);
+  }
 }
 
 #define checkCudaErrors(val) gassert(val, __FILE__, __LINE__)
 
 GpuEuclideanCluster::GpuEuclideanCluster()
 {
-	x_ = NULL;
-	y_ = NULL;
-	z_ = NULL;
-
-	size_ = 0;
-	threshold_ = 0;
-	cluster_indices_ = NULL;
-	cluster_indices_host_ = NULL;
-	min_cluster_pts_ = 0;
-	max_cluster_pts_ = 1000000000;
-	cluster_num_ = 0;
+  x_ = NULL;
+  y_ = NULL;
+  z_ = NULL;
+
+  size_ = 0;
+  threshold_ = 0;
+  cluster_indices_ = NULL;
+  cluster_indices_host_ = NULL;
+  min_cluster_pts_ = 0;
+  max_cluster_pts_ = 1000000000;
+  cluster_num_ = 0;
 }
 
 void GpuEuclideanCluster::setInputPoints(float *x, float *y, float *z, int size)
 {
-	size_ = size;
-	checkCudaErrors(cudaMalloc(&amp;x_, size_ * sizeof(float)));
-	checkCudaErrors(cudaMalloc(&amp;y_, size_ * sizeof(float)));
-	checkCudaErrors(cudaMalloc(&amp;z_, size_ * sizeof(float)));
+  size_ = size;
+  checkCudaErrors(cudaMalloc(&amp;x_, size_ * sizeof(float)));
+  checkCudaErrors(cudaMalloc(&amp;y_, size_ * sizeof(float)));
+  checkCudaErrors(cudaMalloc(&amp;z_, size_ * sizeof(float)));
 
-	checkCudaErrors(cudaMemcpy(x_, x, size_ * sizeof(float), cudaMemcpyHostToDevice));
-	checkCudaErrors(cudaMemcpy(y_, y, size_ * sizeof(float), cudaMemcpyHostToDevice));
-	checkCudaErrors(cudaMemcpy(z_, z, size_ * sizeof(float), cudaMemcpyHostToDevice));
+  checkCudaErrors(cudaMemcpy(x_, x, size_ * sizeof(float), cudaMemcpyHostToDevice));
+  checkCudaErrors(cudaMemcpy(y_, y, size_ * sizeof(float), cudaMemcpyHostToDevice));
+  checkCudaErrors(cudaMemcpy(z_, z, size_ * sizeof(float), cudaMemcpyHostToDevice));
 
-	checkCudaErrors(cudaMalloc(&amp;cluster_indices_, size_ * sizeof(int)));
-	cluster_indices_host_ = (int*)malloc(size_ * sizeof(int));
+  checkCudaErrors(cudaMalloc(&amp;cluster_indices_, size_ * sizeof(int)));
+  cluster_indices_host_ = (int *) malloc(size_ * sizeof(int));
 }
 
 void GpuEuclideanCluster::setThreshold(double threshold)
 {
-	threshold_ = threshold;
+  threshold_ = threshold;
 }
 
 void GpuEuclideanCluster::setMinClusterPts(int min_cluster_pts)
 {
-	min_cluster_pts_ = min_cluster_pts;
+  min_cluster_pts_ = min_cluster_pts;
 }
 
 void GpuEuclideanCluster::setMaxClusterPts(int max_cluster_pts)
 {
-	max_cluster_pts_ = max_cluster_pts;
+  max_cluster_pts_ = max_cluster_pts;
 }
 
 /* Initially, each point is assigned to an individual cluster.
@@ -86,8 +87,8 @@ void GpuEuclideanCluster::setMaxClusterPts(int max_cluster_pts)
 
 extern "C" __global__ void pclEuclideanInitialize(int *cluster_indices, int size)
 {
-	for (int index = threadIdx.x + blockIdx.x * blockDim.x; index &lt; size; index += blockDim.x * gridDim.x)
-		cluster_indices[index] = index;
+  for (int index = threadIdx.x + blockIdx.x * blockDim.x; index &lt; size; index += blockDim.x * gridDim.x)
+    cluster_indices[index] = index;
 }
 
 /* Connected component labeling points at GPU block thread level.
@@ -115,48 +116,50 @@ extern "C" __global__ void pclEuclideanInitialize(int *cluster_indices, int size
  */
 extern "C" __global__ void blockLabelling(float *x, float *y, float *z, int *cluster_indices, int size, float threshold)
 {
-	int block_start = blockIdx.x * blockDim.x;
-	int block_end = (block_start + blockDim.x &lt;= size) ? (block_start + blockDim.x) : size;
-	int row = threadIdx.x + block_start;
-	__shared__ int local_offset[BLOCK_SIZE_X];
-	__shared__ float local_x[BLOCK_SIZE_X];
-	__shared__ float local_y[BLOCK_SIZE_X];
-	__shared__ float local_z[BLOCK_SIZE_X];
-	__shared__ int local_cluster_changed[BLOCK_SIZE_X];
-
-	if (row &lt; block_end) {
-		local_offset[threadIdx.x] = threadIdx.x;
-		local_x[threadIdx.x] = x[row];
-		local_y[threadIdx.x] = y[row];
-		local_z[threadIdx.x] = z[row];
-		__syncthreads();
-
-		for (int column = block_start; column &lt; block_end; column++) {
-			float tmp_x = local_x[threadIdx.x] - local_x[column - block_start];
-			float tmp_y = local_y[threadIdx.x] - local_y[column - block_start];
-			float tmp_z = local_z[threadIdx.x] - local_z[column - block_start];
-			int column_offset = local_offset[column - block_start];
-			int row_offset = local_offset[threadIdx.x];
-
-			local_cluster_changed[threadIdx.x] = 0;
-			__syncthreads();
-
-			if (row &gt; column &amp;&amp; column_offset != row_offset &amp;&amp; norm3df(tmp_x, tmp_y, tmp_z) &lt; threshold)
-				local_cluster_changed[row_offset] = 1;
-			__syncthreads();
-
-			local_offset[threadIdx.x] = (local_cluster_changed[row_offset] == 1) ? column_offset : row_offset;
-			__syncthreads();
-		}
-
-		__syncthreads();
-
-		int new_cluster = cluster_indices[block_start + local_offset[threadIdx.x]];
-
-		__syncthreads();
-
-		cluster_indices[row] = new_cluster;
-	}
+  int block_start = blockIdx.x * blockDim.x;
+  int block_end = (block_start + blockDim.x &lt;= size) ? (block_start + blockDim.x) : size;
+  int row = threadIdx.x + block_start;
+  __shared__ int local_offset[BLOCK_SIZE_X];
+  __shared__ float local_x[BLOCK_SIZE_X];
+  __shared__ float local_y[BLOCK_SIZE_X];
+  __shared__ float local_z[BLOCK_SIZE_X];
+  __shared__ int local_cluster_changed[BLOCK_SIZE_X];
+
+  if (row &lt; block_end)
+  {
+    local_offset[threadIdx.x] = threadIdx.x;
+    local_x[threadIdx.x] = x[row];
+    local_y[threadIdx.x] = y[row];
+    local_z[threadIdx.x] = z[row];
+    __syncthreads();
+
+    for (int column = block_start; column &lt; block_end; column++)
+    {
+      float tmp_x = local_x[threadIdx.x] - local_x[column - block_start];
+      float tmp_y = local_y[threadIdx.x] - local_y[column - block_start];
+      float tmp_z = local_z[threadIdx.x] - local_z[column - block_start];
+      int column_offset = local_offset[column - block_start];
+      int row_offset = local_offset[threadIdx.x];
+
+      local_cluster_changed[threadIdx.x] = 0;
+      __syncthreads();
+
+      if (row &gt; column &amp;&amp; column_offset != row_offset &amp;&amp; norm3df(tmp_x, tmp_y, tmp_z) &lt; threshold)
+        local_cluster_changed[row_offset] = 1;
+      __syncthreads();
+
+      local_offset[threadIdx.x] = (local_cluster_changed[row_offset] == 1) ? column_offset : row_offset;
+      __syncthreads();
+    }
+
+    __syncthreads();
+
+    int new_cluster = cluster_indices[block_start + local_offset[threadIdx.x]];
+
+    __syncthreads();
+
+    cluster_indices[row] = new_cluster;
+  }
 }
 
 /* These kernels are used to collect remained clusters after each labeling phase.
@@ -173,14 +176,15 @@ extern "C" __global__ void blockLabelling(float *x, float *y, float *z, int *clu
  */
 extern "C" __global__ void clusterMark(int *cluster_list, int *cluster_mark, int size)
 {
-	for (int i = threadIdx.x + blockIdx.x * blockDim.x; i &lt; size; i += blockDim.x * gridDim.x)
-		cluster_mark[cluster_list[i]] = 1;
+  for (int i = threadIdx.x + blockIdx.x * blockDim.x; i &lt; size; i += blockDim.x * gridDim.x)
+    cluster_mark[cluster_list[i]] = 1;
 }
 
-extern "C" __global__ void clusterCollector(int *old_cluster_list, int *new_cluster_list, int *cluster_location, int size)
+extern "C" __global__ void
+clusterCollector(int *old_cluster_list, int *new_cluster_list, int *cluster_location, int size)
 {
-	for (int i = threadIdx.x + blockIdx.x * blockDim.x; i &lt; size; i += blockDim.x * gridDim.x)
-		new_cluster_list[cluster_location[old_cluster_list[i]]] = old_cluster_list[i];
+  for (int i = threadIdx.x + blockIdx.x * blockDim.x; i &lt; size; i += blockDim.x * gridDim.x)
+    new_cluster_list[cluster_location[old_cluster_list[i]]] = old_cluster_list[i];
 }
 
 /* Create a cluster matrix.
@@ -196,36 +200,40 @@ extern "C" __global__ void clusterCollector(int *old_cluster_list, int *new_clus
  * distance is less than the threshold, then the matrix element [x][y]
  * is set to 1.
  */
-extern "C" __global__ void buildClusterMatrix(float *x, float *y, float *z, int *cluster_indices, int *cluster_matrix, int *cluster_offset, int size, int cluster_num, float threshold)
+extern "C" __global__ void
+buildClusterMatrix(float *x, float *y, float *z, int *cluster_indices, int *cluster_matrix, int *cluster_offset,
+                   int size, int cluster_num, float threshold)
 {
-	int index = threadIdx.x + blockIdx.x * blockDim.x;
-	int stride = blockDim.x * gridDim.x;
-	__shared__ float local_x[BLOCK_SIZE_X];
-	__shared__ float local_y[BLOCK_SIZE_X];
-	__shared__ float local_z[BLOCK_SIZE_X];
-
-	for (int column = index; column &lt; size; column += stride) {
-		local_x[threadIdx.x] = x[column];
-		local_y[threadIdx.x] = y[column];
-		local_z[threadIdx.x] = z[column];
-		int column_cluster = cluster_indices[column];
-		int cc_offset = cluster_offset[column_cluster];
-
-		__syncthreads();
-
-		for (int row = 0; row &lt; column; row++) {
-			float tmp_x = x[row] - local_x[threadIdx.x];
-			float tmp_y = y[row] - local_y[threadIdx.x];
-			float tmp_z = z[row] - local_z[threadIdx.x];
-			int row_cluster = cluster_indices[row];
-			int rc_offset = cluster_offset[row_cluster];
-
-			__syncthreads();
-
-			if (row_cluster != column_cluster &amp;&amp; norm3df(tmp_x, tmp_y, tmp_z) &lt; threshold)
-				cluster_matrix[rc_offset * cluster_num + cc_offset] = 1;
-		}
-	}
+  int index = threadIdx.x + blockIdx.x * blockDim.x;
+  int stride = blockDim.x * gridDim.x;
+  __shared__ float local_x[BLOCK_SIZE_X];
+  __shared__ float local_y[BLOCK_SIZE_X];
+  __shared__ float local_z[BLOCK_SIZE_X];
+
+  for (int column = index; column &lt; size; column += stride)
+  {
+    local_x[threadIdx.x] = x[column];
+    local_y[threadIdx.x] = y[column];
+    local_z[threadIdx.x] = z[column];
+    int column_cluster = cluster_indices[column];
+    int cc_offset = cluster_offset[column_cluster];
+
+    __syncthreads();
+
+    for (int row = 0; row &lt; column; row++)
+    {
+      float tmp_x = x[row] - local_x[threadIdx.x];
+      float tmp_y = y[row] - local_y[threadIdx.x];
+      float tmp_z = z[row] - local_z[threadIdx.x];
+      int row_cluster = cluster_indices[row];
+      int rc_offset = cluster_offset[row_cluster];
+
+      __syncthreads();
+
+      if (row_cluster != column_cluster &amp;&amp; norm3df(tmp_x, tmp_y, tmp_z) &lt; threshold)
+        cluster_matrix[rc_offset * cluster_num + cc_offset] = 1;
+    }
+  }
 }
 
 /* Merge clusters based on the cluster_matrix.
@@ -245,42 +253,44 @@ extern "C" __global__ void buildClusterMatrix(float *x, float *y, float *z, int
  */
 extern "C" __global__ void mergeClusters(int *cluster_matrix, int *cluster_list, int cluster_num)
 {
-	int row_start = blockIdx.x * blockDim.x;
-	int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
-	int col = row_start + threadIdx.x;
-	__shared__ int local_changed[BLOCK_SIZE_X];
-	__shared__ int local_offset[BLOCK_SIZE_X];
+  int row_start = blockIdx.x * blockDim.x;
+  int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
+  int col = row_start + threadIdx.x;
+  __shared__ int local_changed[BLOCK_SIZE_X];
+  __shared__ int local_offset[BLOCK_SIZE_X];
 
-	/* The cluster matrix is symmetric, so the
-	 * number of rows and columns are the same
-	 */
-	if (col &lt; row_end) {
-		local_offset[threadIdx.x] = threadIdx.x;
+  /* The cluster matrix is symmetric, so the
+   * number of rows and columns are the same
+   */
+  if (col &lt; row_end)
+  {
+    local_offset[threadIdx.x] = threadIdx.x;
 
-		__syncthreads();
+    __syncthreads();
 
-		for (int row = row_start; row &lt; row_end; row++) {
-			int col_offset = local_offset[threadIdx.x];
-			int row_offset = local_offset[row - row_start];
+    for (int row = row_start; row &lt; row_end; row++)
+    {
+      int col_offset = local_offset[threadIdx.x];
+      int row_offset = local_offset[row - row_start];
 
-			local_changed[threadIdx.x] = 0;
-			__syncthreads();
+      local_changed[threadIdx.x] = 0;
+      __syncthreads();
 
-			if (row &lt; col &amp;&amp; row_offset != col_offset &amp;&amp; (cluster_matrix[row * cluster_num + col] == 1))
-				local_changed[col_offset] = 1;
-			__syncthreads();
+      if (row &lt; col &amp;&amp; row_offset != col_offset &amp;&amp; (cluster_matrix[row * cluster_num + col] == 1))
+        local_changed[col_offset] = 1;
+      __syncthreads();
 
-			local_offset[threadIdx.x] = (local_changed[col_offset] == 1) ? row_offset : col_offset;
-			__syncthreads();
-		}
+      local_offset[threadIdx.x] = (local_changed[col_offset] == 1) ? row_offset : col_offset;
+      __syncthreads();
+    }
 
-		__syncthreads();
+    __syncthreads();
 
-		int new_cluster = cluster_list[row_start + local_offset[threadIdx.x]];
+    int new_cluster = cluster_list[row_start + local_offset[threadIdx.x]];
 
-		__syncthreads();
-		cluster_list[col] = new_cluster;
-	}
+    __syncthreads();
+    cluster_list[col] = new_cluster;
+  }
 }
 
 /* Reflex the change in the cluster merging step
@@ -291,8 +301,8 @@ extern "C" __global__ void mergeClusters(int *cluster_matrix, int *cluster_list,
  */
 extern "C" __global__ void reflexClusterChanges(int *cluster_indices, int *cluster_offset, int *cluster_list, int size)
 {
-	for (int i = threadIdx.x + blockIdx.x * blockDim.x; i &lt; size; i += blockDim.x * gridDim.x)
-		cluster_indices[i] = cluster_list[cluster_offset[cluster_indices[i]]];
+  for (int i = threadIdx.x + blockIdx.x * blockDim.x; i &lt; size; i += blockDim.x * gridDim.x)
+    cluster_indices[i] = cluster_list[cluster_offset[cluster_indices[i]]];
 }
 
 /* Rebuild cluster matrix after merging clusters.
@@ -305,17 +315,21 @@ extern "C" __global__ void reflexClusterChanges(int *cluster_indices, int *clust
  * [m][n] of the target matrix, in which m and n are the
  * new clusters of x and y, is set to 1.
  */
-extern "C" __global__ void rebuildClusterMatrix(int *old_cluster_matrix, int *new_clusters, int *new_cluster_matrix, int *new_cluster_offset, int old_size, int new_size)
+extern "C" __global__ void
+rebuildClusterMatrix(int *old_cluster_matrix, int *new_clusters, int *new_cluster_matrix, int *new_cluster_offset,
+                     int old_size, int new_size)
 {
-	for (int column = threadIdx.x + blockIdx.x * blockDim.x; column &lt; old_size; column += blockDim.x * gridDim.x) {
-		for (int row = 0; row &lt; column; row++) {
-			int new_row = new_cluster_offset[new_clusters[row]];
-			int new_column = new_cluster_offset[new_clusters[column]];
-
-			if (old_cluster_matrix[row * old_size + column] == 1)
-				new_cluster_matrix[new_row * new_size + new_column] = 1;
-		}
-	}
+  for (int column = threadIdx.x + blockIdx.x * blockDim.x; column &lt; old_size; column += blockDim.x * gridDim.x)
+  {
+    for (int row = 0; row &lt; column; row++)
+    {
+      int new_row = new_cluster_offset[new_clusters[row]];
+      int new_column = new_cluster_offset[new_clusters[column]];
+
+      if (old_cluster_matrix[row * old_size + column] == 1)
+        new_cluster_matrix[new_row * new_size + new_column] = 1;
+    }
+  }
 }
 
 /* Perform exclusive scan on the input array using
@@ -326,12 +340,12 @@ extern "C" __global__ void rebuildClusterMatrix(int *old_cluster_matrix, int *ne
  */
 void GpuEuclideanCluster::exclusiveScan(int *input, int ele_num, int *sum)
 {
-	thrust::device_ptr&lt;int&gt; dev_ptr(input);
+  thrust::device_ptr&lt;int&gt; dev_ptr(input);
 
-	thrust::exclusive_scan(dev_ptr, dev_ptr + ele_num, dev_ptr);
-	checkCudaErrors(cudaDeviceSynchronize());
+  thrust::exclusive_scan(dev_ptr, dev_ptr + ele_num, dev_ptr);
+  checkCudaErrors(cudaDeviceSynchronize());
 
-	*sum = *(dev_ptr + ele_num - 1);
+  *sum = *(dev_ptr + ele_num - 1);
 }
 
 /* Reset the cluster indexes in the point cloud from 0.
@@ -344,11 +358,12 @@ void GpuEuclideanCluster::exclusiveScan(int *input, int ele_num, int *sum)
  */
 extern "C" __global__ void resetClusterIndexes(int *cluster_indices, int *cluster_offset, int size)
 {
-	for (int i = threadIdx.x + blockIdx.x * blockDim.x; i &lt; size; i += blockDim.x * gridDim.x) {
-		int old_cluster = cluster_indices[i];
+  for (int i = threadIdx.x + blockIdx.x * blockDim.x; i &lt; size; i += blockDim.x * gridDim.x)
+  {
+    int old_cluster = cluster_indices[i];
 
-		cluster_indices[i] = cluster_offset[old_cluster];
-	}
+    cluster_indices[i] = cluster_offset[old_cluster];
+  }
 }
 
 
@@ -362,134 +377,140 @@ extern "C" __global__ void resetClusterIndexes(int *cluster_indices, int *cluste
  */
 void GpuEuclideanCluster::extractClustersOld()
 {
-	int block_x, grid_x;
+  int block_x, grid_x;
 
-	block_x = (size_ &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : size_;
-	grid_x = (size_ - 1) / block_x + 1;
+  block_x = (size_ &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : size_;
+  grid_x = (size_ - 1) / block_x + 1;
 
-	int *cluster_offset;
-	int cluster_num, old_cluster_num;
+  int *cluster_offset;
+  int cluster_num, old_cluster_num;
 
-	pclEuclideanInitialize&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, size_);
-	checkCudaErrors(cudaDeviceSynchronize());
+  pclEuclideanInitialize &lt;&lt; &lt; grid_x, block_x &gt;&gt; &gt; (cluster_indices_, size_);
+  checkCudaErrors(cudaDeviceSynchronize());
 
-	old_cluster_num = cluster_num = size_;
+  old_cluster_num = cluster_num = size_;
 
-	checkCudaErrors(cudaMalloc(&amp;cluster_offset, (size_ + 1) * sizeof(int)));
-	checkCudaErrors(cudaMemset(cluster_offset, 0, (size_ + 1) * sizeof(int)));
-	blockLabelling&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, cluster_indices_, size_, threshold_);
-	clusterMark&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_offset, size_);
-	exclusiveScan(cluster_offset, size_ + 1, &amp;cluster_num);
+  checkCudaErrors(cudaMalloc(&amp;cluster_offset, (size_ + 1) * sizeof(int)));
+  checkCudaErrors(cudaMemset(cluster_offset, 0, (size_ + 1) * sizeof(int)));
+  blockLabelling &lt;&lt; &lt; grid_x, block_x &gt;&gt; &gt; (x_, y_, z_, cluster_indices_, size_, threshold_);
+  clusterMark &lt;&lt; &lt; grid_x, block_x &gt;&gt; &gt; (cluster_indices_, cluster_offset, size_);
+  exclusiveScan(cluster_offset, size_ + 1, &amp;cluster_num);
 
-	int *cluster_list, *new_cluster_list, *tmp;
+  int *cluster_list, *new_cluster_list, *tmp;
 
-	checkCudaErrors(cudaMalloc(&amp;cluster_list, cluster_num * sizeof(int)));
-	clusterCollector&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_list, cluster_offset, size_);
-	checkCudaErrors(cudaDeviceSynchronize());
+  checkCudaErrors(cudaMalloc(&amp;cluster_list, cluster_num * sizeof(int)));
+  clusterCollector &lt;&lt; &lt; grid_x, block_x &gt;&gt; &gt; (cluster_indices_, cluster_list, cluster_offset, size_);
+  checkCudaErrors(cudaDeviceSynchronize());
 
-	int *cluster_matrix;
-	int *new_cluster_matrix;
+  int *cluster_matrix;
+  int *new_cluster_matrix;
 
-	checkCudaErrors(cudaMalloc(&amp;cluster_matrix, cluster_num * cluster_num * sizeof(int)));
-	checkCudaErrors(cudaMemset(cluster_matrix, 0, cluster_num * cluster_num * sizeof(int)));
-	checkCudaErrors(cudaDeviceSynchronize());
+  checkCudaErrors(cudaMalloc(&amp;cluster_matrix, cluster_num * cluster_num * sizeof(int)));
+  checkCudaErrors(cudaMemset(cluster_matrix, 0, cluster_num * cluster_num * sizeof(int)));
+  checkCudaErrors(cudaDeviceSynchronize());
 
-	checkCudaErrors(cudaMalloc(&amp;new_cluster_list, cluster_num * sizeof(int)));
+  checkCudaErrors(cudaMalloc(&amp;new_cluster_list, cluster_num * sizeof(int)));
 
-	buildClusterMatrix&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, cluster_indices_, cluster_matrix, cluster_offset, size_, cluster_num, threshold_);
-	checkCudaErrors(cudaDeviceSynchronize());
+  buildClusterMatrix &lt;&lt; &lt; grid_x, block_x &gt;&gt; &gt;
+                                  (x_, y_, z_, cluster_indices_, cluster_matrix, cluster_offset, size_, cluster_num, threshold_);
+  checkCudaErrors(cudaDeviceSynchronize());
 
-	int block_x2 = 0, grid_x2 = 0;
+  int block_x2 = 0, grid_x2 = 0;
 
 
-	/* Loop until there is no change in the number of clusters */
-	do {
-		old_cluster_num = cluster_num;
-		block_x2 = (cluster_num &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : cluster_num;
-		grid_x2 = (cluster_num - 1)/block_x2 + 1;
+  /* Loop until there is no change in the number of clusters */
+  do
+  {
+    old_cluster_num = cluster_num;
+    block_x2 = (cluster_num &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : cluster_num;
+    grid_x2 = (cluster_num - 1) / block_x2 + 1;
 
-		mergeClusters&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list, cluster_num);
-		reflexClusterChanges&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_offset, cluster_list, size_);
-		checkCudaErrors(cudaMemset(cluster_offset, 0, (size_ + 1) * sizeof(int)));
-		clusterMark&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_list, cluster_offset, cluster_num);
-		exclusiveScan(cluster_offset, size_ + 1, &amp;cluster_num);
+    mergeClusters &lt;&lt; &lt; grid_x2, block_x2 &gt;&gt; &gt; (cluster_matrix, cluster_list, cluster_num);
+    reflexClusterChanges &lt;&lt; &lt; grid_x, block_x &gt;&gt; &gt; (cluster_indices_, cluster_offset, cluster_list, size_);
+    checkCudaErrors(cudaMemset(cluster_offset, 0, (size_ + 1) * sizeof(int)));
+    clusterMark &lt;&lt; &lt; grid_x2, block_x2 &gt;&gt; &gt; (cluster_list, cluster_offset, cluster_num);
+    exclusiveScan(cluster_offset, size_ + 1, &amp;cluster_num);
 
-		if (grid_x2 == 1 &amp;&amp; cluster_num == old_cluster_num)
-			break;
+    if (grid_x2 == 1 &amp;&amp; cluster_num == old_cluster_num)
+      break;
 
-		clusterCollector&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_list, new_cluster_list, cluster_offset, old_cluster_num);
-		checkCudaErrors(cudaDeviceSynchronize());
+    clusterCollector &lt;&lt; &lt; grid_x2, block_x2 &gt;&gt; &gt; (cluster_list, new_cluster_list, cluster_offset, old_cluster_num);
+    checkCudaErrors(cudaDeviceSynchronize());
 
-		checkCudaErrors(cudaMalloc(&amp;new_cluster_matrix, cluster_num * cluster_num * sizeof(int)));
-		checkCudaErrors(cudaMemset(new_cluster_matrix, 0, cluster_num * cluster_num * sizeof(int)));
-		rebuildClusterMatrix&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list, new_cluster_matrix, cluster_offset, old_cluster_num, cluster_num);
-		checkCudaErrors(cudaDeviceSynchronize());
+    checkCudaErrors(cudaMalloc(&amp;new_cluster_matrix, cluster_num * cluster_num * sizeof(int)));
+    checkCudaErrors(cudaMemset(new_cluster_matrix, 0, cluster_num * cluster_num * sizeof(int)));
+    rebuildClusterMatrix &lt;&lt; &lt; grid_x2, block_x2 &gt;&gt; &gt;
+                                       (cluster_matrix, cluster_list, new_cluster_matrix, cluster_offset, old_cluster_num, cluster_num);
+    checkCudaErrors(cudaDeviceSynchronize());
 
-		checkCudaErrors(cudaFree(cluster_matrix));
-		cluster_matrix = new_cluster_matrix;
-		tmp = cluster_list;
-		cluster_list = new_cluster_list;
-		new_cluster_list = tmp;
-	} while (1);
+    checkCudaErrors(cudaFree(cluster_matrix));
+    cluster_matrix = new_cluster_matrix;
+    tmp = cluster_list;
+    cluster_list = new_cluster_list;
+    new_cluster_list = tmp;
+  } while (1);
 
-	cluster_num_ = cluster_num;
+  cluster_num_ = cluster_num;
 
-	resetClusterIndexes&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_offset, size_);
-	checkCudaErrors(cudaDeviceSynchronize());
+  resetClusterIndexes &lt;&lt; &lt; grid_x, block_x &gt;&gt; &gt; (cluster_indices_, cluster_offset, size_);
+  checkCudaErrors(cudaDeviceSynchronize());
 
-	checkCudaErrors(cudaMemcpy(cluster_indices_host_, cluster_indices_, size_ * sizeof(int), cudaMemcpyDeviceToHost));
+  checkCudaErrors(cudaMemcpy(cluster_indices_host_, cluster_indices_, size_ * sizeof(int), cudaMemcpyDeviceToHost));
 
 
-	checkCudaErrors(cudaFree(cluster_matrix));
-	checkCudaErrors(cudaFree(cluster_list));
-	checkCudaErrors(cudaFree(new_cluster_list));
-	checkCudaErrors(cudaFree(cluster_offset));
+  checkCudaErrors(cudaFree(cluster_matrix));
+  checkCudaErrors(cudaFree(cluster_list));
+  checkCudaErrors(cudaFree(new_cluster_list));
+  checkCudaErrors(cudaFree(cluster_offset));
 }
 
 extern "C" __global__ void mergeSelfClusters(int *cluster_matrix, int *cluster_list, int cluster_num, bool *changed)
 {
-	int row_start = blockIdx.x * blockDim.x;
-	int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
-	int col = row_start + threadIdx.x;
-	__shared__ int local_changed[BLOCK_SIZE_X];
-	__shared__ int local_offset[BLOCK_SIZE_X];
-	bool block_changed = false;
+  int row_start = blockIdx.x * blockDim.x;
+  int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
+  int col = row_start + threadIdx.x;
+  __shared__ int local_changed[BLOCK_SIZE_X];
+  __shared__ int local_offset[BLOCK_SIZE_X];
+  bool block_changed = false;
 
-	if (col &lt; row_end) {
-		local_offset[threadIdx.x] = threadIdx.x;
+  if (col &lt; row_end)
+  {
+    local_offset[threadIdx.x] = threadIdx.x;
 
-		__syncthreads();
+    __syncthreads();
 
-		for (int row = row_start; row &lt; row_end; row++) {
-			int col_offset = local_offset[threadIdx.x];
-			int row_offset = local_offset[row - row_start];
+    for (int row = row_start; row &lt; row_end; row++)
+    {
+      int col_offset = local_offset[threadIdx.x];
+      int row_offset = local_offset[row - row_start];
 
-			local_changed[threadIdx.x] = 0;
-			__syncthreads();
+      local_changed[threadIdx.x] = 0;
+      __syncthreads();
 
-			if (row &lt; col &amp;&amp; row_offset != col_offset &amp;&amp; (cluster_matrix[row * cluster_num + col] == 1)) {
-				local_changed[col_offset] = 1;
-				block_changed = true;
-			}
-			__syncthreads();
+      if (row &lt; col &amp;&amp; row_offset != col_offset &amp;&amp; (cluster_matrix[row * cluster_num + col] == 1))
+      {
+        local_changed[col_offset] = 1;
+        block_changed = true;
+      }
+      __syncthreads();
 
-			local_offset[threadIdx.x] = (local_changed[col_offset] == 1) ? row_offset : col_offset;
-			__syncthreads();
-		}
+      local_offset[threadIdx.x] = (local_changed[col_offset] == 1) ? row_offset : col_offset;
+      __syncthreads();
+    }
 
-		__syncthreads();
+    __syncthreads();
 
-		int new_cluster = cluster_list[row_start + local_offset[threadIdx.x]];
+    int new_cluster = cluster_list[row_start + local_offset[threadIdx.x]];
 
-		__syncthreads();
+    __syncthreads();
 
-		cluster_list[col] = new_cluster;
+    cluster_list[col] = new_cluster;
 
 
-		__syncthreads();
-		if (block_changed)
-			*changed = true;
-	}
+    __syncthreads();
+    if (block_changed)
+      *changed = true;
+  }
 }
 
 /* Merge clusters from different blocks of points.
@@ -504,52 +525,58 @@ extern "C" __global__ void mergeSelfClusters(int *cluster_matrix, int *cluster_l
  */
 
 extern "C" __global__ void mergeInterClusters(int *cluster_matrix, int *cluster_list,
-												int shift_level,
-												int base_row, int base_column,
-												int sub_matrix_row, int sub_matrix_col,
-												int sub_matrix_offset_row, int sub_matrix_offset_col,
-												int cluster_num, bool *changed)
+                                              int shift_level,
+                                              int base_row, int base_column,
+                                              int sub_matrix_row, int sub_matrix_col,
+                                              int sub_matrix_offset_row, int sub_matrix_offset_col,
+                                              int cluster_num, bool *changed)
 {
-	int col_start = (base_column + (blockIdx.x/sub_matrix_col) * sub_matrix_offset_col + (blockIdx.x + shift_level - sub_matrix_col * ((blockIdx.x + shift_level)/sub_matrix_col))) * blockDim.x;
-	int col_end = (col_start + blockDim.x &lt;= cluster_num) ? col_start + blockDim.x : cluster_num;
-	int row_start = (base_row + (blockIdx.x/sub_matrix_row) * sub_matrix_offset_row + (blockIdx.x - sub_matrix_row * (blockIdx.x/sub_matrix_row))) * blockDim.x;
-	int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
-	int col = col_start + threadIdx.x;
-
-	__shared__ int local_changed[BLOCK_SIZE_X];
-	__shared__ int local_offset[BLOCK_SIZE_X];
-	bool block_changed = false;
-
-	if (col &lt; col_end) {
-		local_offset[threadIdx.x] = threadIdx.x;
-		__syncthreads();
-
-		for (int row = row_start; row &lt; row_end; row++) {
-			int col_offset = local_offset[threadIdx.x];
-			int row_offset = local_offset[row - row_start];
-
-			local_changed[threadIdx.x] = 0;
-			__syncthreads();
-
-			if (row_offset != col_offset &amp;&amp; cluster_matrix[row * cluster_num + col] == 1) {
-				local_changed[col_offset] = 1;
-				block_changed = true;
-			}
-			__syncthreads();
-
-			local_offset[threadIdx.x] = (local_changed[col_offset] == 1) ? row_offset : col_offset;
-			__syncthreads();
-		}
-
-		__syncthreads();
-		int new_cluster = cluster_list[col_start + local_offset[threadIdx.x]];
-
-		__syncthreads();
-		cluster_list[col] = new_cluster;
-
-		if (block_changed)
-			*changed = true;
-	}
+  int col_start = (base_column + (blockIdx.x / sub_matrix_col) * sub_matrix_offset_col +
+                   (blockIdx.x + shift_level - sub_matrix_col * ((blockIdx.x + shift_level) / sub_matrix_col))) *
+                  blockDim.x;
+  int col_end = (col_start + blockDim.x &lt;= cluster_num) ? col_start + blockDim.x : cluster_num;
+  int row_start = (base_row + (blockIdx.x / sub_matrix_row) * sub_matrix_offset_row +
+                   (blockIdx.x - sub_matrix_row * (blockIdx.x / sub_matrix_row))) * blockDim.x;
+  int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
+  int col = col_start + threadIdx.x;
+
+  __shared__ int local_changed[BLOCK_SIZE_X];
+  __shared__ int local_offset[BLOCK_SIZE_X];
+  bool block_changed = false;
+
+  if (col &lt; col_end)
+  {
+    local_offset[threadIdx.x] = threadIdx.x;
+    __syncthreads();
+
+    for (int row = row_start; row &lt; row_end; row++)
+    {
+      int col_offset = local_offset[threadIdx.x];
+      int row_offset = local_offset[row - row_start];
+
+      local_changed[threadIdx.x] = 0;
+      __syncthreads();
+
+      if (row_offset != col_offset &amp;&amp; cluster_matrix[row * cluster_num + col] == 1)
+      {
+        local_changed[col_offset] = 1;
+        block_changed = true;
+      }
+      __syncthreads();
+
+      local_offset[threadIdx.x] = (local_changed[col_offset] == 1) ? row_offset : col_offset;
+      __syncthreads();
+    }
+
+    __syncthreads();
+    int new_cluster = cluster_list[col_start + local_offset[threadIdx.x]];
+
+    __syncthreads();
+    cluster_list[col] = new_cluster;
+
+    if (block_changed)
+      *changed = true;
+  }
 }
 
 /* Checking if two individual blocks have any clusters that intersect.
@@ -559,30 +586,33 @@ extern "C" __global__ void mergeInterClusters(int *cluster_matrix, int *cluster_
  * in the next step.
  */
 extern "C" __global__ void clustersIntersecCheck(int *cluster_matrix, int *changed_diag,
-													int base_row, int base_column,
-													int sub_matrix_row, int sub_matrix_col,
-													int sub_matrix_offset_row, int sub_matrix_offset_col,
-													int cluster_num)
+                                                 int base_row, int base_column,
+                                                 int sub_matrix_row, int sub_matrix_col,
+                                                 int sub_matrix_offset_row, int sub_matrix_offset_col,
+                                                 int cluster_num)
 {
-	//Thinking about using % or not
-	int col_idx = (blockIdx.x / sub_matrix_col) * sub_matrix_offset_col + (blockIdx.x % sub_matrix_col);
-	int row_idx = (blockIdx.x / sub_matrix_row) * sub_matrix_offset_row + (blockIdx.y % sub_matrix_col);
-
-	int col_start = (base_column + col_idx) * blockDim.x;
-	int col_end = (col_start + blockDim.x &lt;= cluster_num) ? col_start + blockDim.x : cluster_num;
-	int row_start = (base_row + row_idx) * blockDim.x;
-	int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
-	int col = col_start + threadIdx.x;
-	int diag_offset = (col_idx &gt; row_idx) ? col_idx - row_idx : col_idx + row_idx;
-
-	if (col &lt; col_end &amp;&amp; col_start &lt;= col_end &amp;&amp; row_start &lt;= row_end) {
-		for (int row = row_start; row &lt; row_end; row++) {
-			if (cluster_matrix[row * cluster_num + col] == 1) {
-				*changed_diag = diag_offset;
-				break;
-			}
-		}
-	}
+  //Thinking about using % or not
+  int col_idx = (blockIdx.x / sub_matrix_col) * sub_matrix_offset_col + (blockIdx.x % sub_matrix_col);
+  int row_idx = (blockIdx.x / sub_matrix_row) * sub_matrix_offset_row + (blockIdx.y % sub_matrix_col);
+
+  int col_start = (base_column + col_idx) * blockDim.x;
+  int col_end = (col_start + blockDim.x &lt;= cluster_num) ? col_start + blockDim.x : cluster_num;
+  int row_start = (base_row + row_idx) * blockDim.x;
+  int row_end = (row_start + blockDim.x &lt;= cluster_num) ? row_start + blockDim.x : cluster_num;
+  int col = col_start + threadIdx.x;
+  int diag_offset = (col_idx &gt; row_idx) ? col_idx - row_idx : col_idx + row_idx;
+
+  if (col &lt; col_end &amp;&amp; col_start &lt;= col_end &amp;&amp; row_start &lt;= row_end)
+  {
+    for (int row = row_start; row &lt; row_end; row++)
+    {
+      if (cluster_matrix[row * cluster_num + col] == 1)
+      {
+        *changed_diag = diag_offset;
+        break;
+      }
+    }
+  }
 }
 
 /* Extract clusters of points.
@@ -593,167 +623,174 @@ extern "C" __global__ void clustersIntersecCheck(int *cluster_matrix, int *chang
 
 void GpuEuclideanCluster::extractClusters()
 {
-	int block_x, grid_x;
+  int block_x, grid_x;
 
-	block_x = (size_ &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : size_;
-	grid_x = (size_ - 1) / block_x + 1;
+  block_x = (size_ &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : size_;
+  grid_x = (size_ - 1) / block_x + 1;
 
-	int *cluster_offset;
-	int cluster_num, old_cluster_num;
+  int *cluster_offset;
+  int cluster_num, old_cluster_num;
 
-	pclEuclideanInitialize&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, size_);
-	checkCudaErrors(cudaDeviceSynchronize());
+  pclEuclideanInitialize &lt;&lt; &lt; grid_x, block_x &gt;&gt; &gt; (cluster_indices_, size_);
+  checkCudaErrors(cudaDeviceSynchronize());
 
-	old_cluster_num = cluster_num = size_;
+  old_cluster_num = cluster_num = size_;
 
-	checkCudaErrors(cudaMalloc(&amp;cluster_offset, (size_ + 1) * sizeof(int)));
-	checkCudaErrors(cudaMemset(cluster_offset, 0, (size_ + 1) * sizeof(int)));
-	blockLabelling&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, cluster_indices_, size_, threshold_);
-	clusterMark&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_offset, size_);
-	exclusiveScan(cluster_offset, size_ + 1, &amp;cluster_num);
+  checkCudaErrors(cudaMalloc(&amp;cluster_offset, (size_ + 1) * sizeof(int)));
+  checkCudaErrors(cudaMemset(cluster_offset, 0, (size_ + 1) * sizeof(int)));
+  blockLabelling &lt;&lt; &lt; grid_x, block_x &gt;&gt; &gt; (x_, y_, z_, cluster_indices_, size_, threshold_);
+  clusterMark &lt;&lt; &lt; grid_x, block_x &gt;&gt; &gt; (cluster_indices_, cluster_offset, size_);
+  exclusiveScan(cluster_offset, size_ + 1, &amp;cluster_num);
 
-	int *cluster_list, *new_cluster_list, *tmp;
+  int *cluster_list, *new_cluster_list, *tmp;
 
-	checkCudaErrors(cudaMalloc(&amp;cluster_list, cluster_num * sizeof(int)));
-	clusterCollector&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_list, cluster_offset, size_);
-	checkCudaErrors(cudaDeviceSynchronize());
+  checkCudaErrors(cudaMalloc(&amp;cluster_list, cluster_num * sizeof(int)));
+  clusterCollector &lt;&lt; &lt; grid_x, block_x &gt;&gt; &gt; (cluster_indices_, cluster_list, cluster_offset, size_);
+  checkCudaErrors(cudaDeviceSynchronize());
 
-	int *cluster_matrix;
-	int *new_cluster_matrix;
+  int *cluster_matrix;
+  int *new_cluster_matrix;
 
-	checkCudaErrors(cudaMalloc(&amp;cluster_matrix, cluster_num * cluster_num * sizeof(int)));
-	checkCudaErrors(cudaMemset(cluster_matrix, 0, cluster_num * cluster_num * sizeof(int)));
-	checkCudaErrors(cudaDeviceSynchronize());
+  checkCudaErrors(cudaMalloc(&amp;cluster_matrix, cluster_num * cluster_num * sizeof(int)));
+  checkCudaErrors(cudaMemset(cluster_matrix, 0, cluster_num * cluster_num * sizeof(int)));
+  checkCudaErrors(cudaDeviceSynchronize());
 
-	checkCudaErrors(cudaMalloc(&amp;new_cluster_list, cluster_num * sizeof(int)));
+  checkCudaErrors(cudaMalloc(&amp;new_cluster_list, cluster_num * sizeof(int)));
 
-	buildClusterMatrix&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, cluster_indices_, cluster_matrix, cluster_offset, size_, cluster_num, threshold_);
-	checkCudaErrors(cudaDeviceSynchronize());
+  buildClusterMatrix &lt;&lt; &lt; grid_x, block_x &gt;&gt; &gt;
+                                  (x_, y_, z_, cluster_indices_, cluster_matrix, cluster_offset, size_, cluster_num, threshold_);
+  checkCudaErrors(cudaDeviceSynchronize());
 
-	int block_x2 = 0, grid_x2 = 0;
+  int block_x2 = 0, grid_x2 = 0;
 
-	bool *changed;
+  bool *changed;
 
-	checkCudaErrors(cudaMallocHost(&amp;changed, sizeof(bool)));
+  checkCudaErrors(cudaMallocHost(&amp;changed, sizeof(bool)));
 
 #ifndef SERIAL
-	int *changed_diag;
+  int *changed_diag;
 
-	checkCudaErrors(cudaMallocHost(&amp;changed_diag, sizeof(int)));
+  checkCudaErrors(cudaMallocHost(&amp;changed_diag, sizeof(int)));
 #endif
 
-	int max_base_row = 0;
+  int max_base_row = 0;
 
-	do {
-		*changed = false;
-		block_x2 = (cluster_num &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : cluster_num;
-		grid_x2 = (cluster_num - 1)/block_x2 + 1;
+  do
+  {
+    *changed = false;
+    block_x2 = (cluster_num &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : cluster_num;
+    grid_x2 = (cluster_num - 1) / block_x2 + 1;
 
-		mergeSelfClusters&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list, cluster_num, changed);
-		checkCudaErrors(cudaDeviceSynchronize());
+    mergeSelfClusters &lt;&lt; &lt; grid_x2, block_x2 &gt;&gt; &gt; (cluster_matrix, cluster_list, cluster_num, changed);
+    checkCudaErrors(cudaDeviceSynchronize());
 
-		int base_row = 1, base_column = 0;
-		int sub_matrix_offset_row = 2, sub_matrix_offset_col = 2;
-		int sub_matrix_row = 1, sub_matrix_col = 1;
-		int sub_matrix_num;
-		int max_rows = grid_x2;
+    int base_row = 1, base_column = 0;
+    int sub_matrix_offset_row = 2, sub_matrix_offset_col = 2;
+    int sub_matrix_row = 1, sub_matrix_col = 1;
+    int sub_matrix_num;
+    int max_rows = grid_x2;
 
-		max_base_row = base_row;
+    max_base_row = base_row;
 
-		while (!(*changed) &amp;&amp; cluster_num &gt; BLOCK_SIZE_X &amp;&amp; base_row * BLOCK_SIZE_X &lt; cluster_num &amp;&amp; base_column &lt; cluster_num) {
+    while (!(*changed) &amp;&amp; cluster_num &gt; BLOCK_SIZE_X &amp;&amp; base_row * BLOCK_SIZE_X &lt; cluster_num &amp;&amp;
+           base_column &lt; cluster_num)
+    {
 
-			sub_matrix_num = (cluster_num - base_row - 1)/sub_matrix_offset_row + 1;
-			block_x2 = BLOCK_SIZE_X;
-			grid_x2 = sub_matrix_num * sub_matrix_col;
+      sub_matrix_num = (cluster_num - base_row - 1) / sub_matrix_offset_row + 1;
+      block_x2 = BLOCK_SIZE_X;
+      grid_x2 = sub_matrix_num * sub_matrix_col;
 
 #ifdef SERIAL
-			//Merge clusters in each sub-matrix by moving from top to bottom of the similarity sub-matrix
-			for (int shift_level = 0; !(*changed) &amp;&amp; shift_level &lt; sub_matrix_col; shift_level++) {
-				mergeInterClusters&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list,
-																shift_level,
-																base_row, base_column,
-																sub_matrix_row, sub_matrix_col,
-																sub_matrix_offset_row, sub_matrix_offset_col,
-																cluster_num, changed);
-				checkCudaErrors(cudaDeviceSynchronize());
-			}
+      //Merge clusters in each sub-matrix by moving from top to bottom of the similarity sub-matrix
+      for (int shift_level = 0; !(*changed) &amp;&amp; shift_level &lt; sub_matrix_col; shift_level++) {
+        mergeInterClusters&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list,
+                                shift_level,
+                                base_row, base_column,
+                                sub_matrix_row, sub_matrix_col,
+                                sub_matrix_offset_row, sub_matrix_offset_col,
+                                cluster_num, changed);
+        checkCudaErrors(cudaDeviceSynchronize());
+      }
 #else
-			int grid_y2 = sub_matrix_row;
-
-			dim3 block_size(block_x2, 1, 1);
-			dim3 grid_size(grid_x2, grid_y2, 1);
-
-			*changed_diag = -1;
-
-			clustersIntersecCheck&lt;&lt;&lt;grid_size, block_size&gt;&gt;&gt;(cluster_matrix, changed_diag,
-																base_row, base_column,
-																sub_matrix_row, sub_matrix_col,
-																sub_matrix_offset_row, sub_matrix_offset_col,
-																cluster_num);
-			checkCudaErrors(cudaDeviceSynchronize());
-
-			if (*changed_diag &gt; 0) {
-				//Merge clusters in sub-matrix that stay in the changed_diag diagonal by moving from top to bottom of the matrix.
-				mergeInterClusters&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list, *changed_diag,
-															base_row, base_column,
-															sub_matrix_row, sub_matrix_col,
-															sub_matrix_offset_row, sub_matrix_offset_col,
-															cluster_num, changed);
-				checkCudaErrors(cudaDeviceSynchronize());
-			}
+      int grid_y2 = sub_matrix_row;
+
+      dim3 block_size(block_x2, 1, 1);
+      dim3 grid_size(grid_x2, grid_y2, 1);
+
+      *changed_diag = -1;
+
+      clustersIntersecCheck &lt;&lt; &lt; grid_size, block_size &gt;&gt; &gt; (cluster_matrix, changed_diag,
+        base_row, base_column,
+        sub_matrix_row, sub_matrix_col,
+        sub_matrix_offset_row, sub_matrix_offset_col,
+        cluster_num);
+      checkCudaErrors(cudaDeviceSynchronize());
+
+      if (*changed_diag &gt; 0)
+      {
+        //Merge clusters in sub-matrix that stay in the changed_diag diagonal by moving from top to bottom of the matrix.
+        mergeInterClusters &lt;&lt; &lt; grid_x2, block_x2 &gt;&gt; &gt; (cluster_matrix, cluster_list, *changed_diag,
+          base_row, base_column,
+          sub_matrix_row, sub_matrix_col,
+          sub_matrix_offset_row, sub_matrix_offset_col,
+          cluster_num, changed);
+        checkCudaErrors(cudaDeviceSynchronize());
+      }
 
 #endif
-			base_row += sub_matrix_row;
-			sub_matrix_row = (sub_matrix_row * 2 + base_row &lt;  max_rows) ? sub_matrix_row * 2 : max_rows - base_row;
-			sub_matrix_col *= 2;
-			sub_matrix_offset_row *= 2;
-			sub_matrix_offset_col *= 2;
-		}
-
-		max_base_row = base_row;
-
-		if (*changed) {
-			reflexClusterChanges&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_offset, cluster_list, size_);
-			checkCudaErrors(cudaMemset(cluster_offset, 0, (size_ + 1) * sizeof(int)));
-
-			block_x2 = (cluster_num &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : cluster_num;
-			grid_x2 = (cluster_num - 1) / block_x2 + 1;
-
-			clusterMark&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_list, cluster_offset, cluster_num);
-
-			old_cluster_num = cluster_num;
-			exclusiveScan(cluster_offset, size_ + 1, &amp;cluster_num);
-			clusterCollector&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_list, new_cluster_list, cluster_offset, old_cluster_num);
-			checkCudaErrors(cudaDeviceSynchronize());
-
-			checkCudaErrors(cudaMalloc(&amp;new_cluster_matrix, cluster_num * cluster_num * sizeof(int)));
-			checkCudaErrors(cudaMemset(new_cluster_matrix, 0, cluster_num * cluster_num * sizeof(int)));
-			rebuildClusterMatrix&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(cluster_matrix, cluster_list, new_cluster_matrix, cluster_offset, old_cluster_num, cluster_num);
-			checkCudaErrors(cudaDeviceSynchronize());
-
-			checkCudaErrors(cudaFree(cluster_matrix));
-			cluster_matrix = new_cluster_matrix;
-			tmp = cluster_list;
-			cluster_list = new_cluster_list;
-			new_cluster_list = tmp;
-		}
-	} while (*changed &amp;&amp; max_base_row &lt; cluster_num);
-
-	cluster_num_ = cluster_num;
-
-	//Reset all cluster indexes to make them start from 0
-	resetClusterIndexes&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(cluster_indices_, cluster_offset, size_);
-	checkCudaErrors(cudaDeviceSynchronize());
-
-	checkCudaErrors(cudaMemcpy(cluster_indices_host_, cluster_indices_, size_ * sizeof(int), cudaMemcpyDeviceToHost));
-
-	checkCudaErrors(cudaFree(cluster_matrix));
-	checkCudaErrors(cudaFree(cluster_list));
-	checkCudaErrors(cudaFree(new_cluster_list));
-	checkCudaErrors(cudaFree(cluster_offset));
-	checkCudaErrors(cudaFreeHost(changed));
+      base_row += sub_matrix_row;
+      sub_matrix_row = (sub_matrix_row * 2 + base_row &lt; max_rows) ? sub_matrix_row * 2 : max_rows - base_row;
+      sub_matrix_col *= 2;
+      sub_matrix_offset_row *= 2;
+      sub_matrix_offset_col *= 2;
+    }
+
+    max_base_row = base_row;
+
+    if (*changed)
+    {
+      reflexClusterChanges &lt;&lt; &lt; grid_x, block_x &gt;&gt; &gt; (cluster_indices_, cluster_offset, cluster_list, size_);
+      checkCudaErrors(cudaMemset(cluster_offset, 0, (size_ + 1) * sizeof(int)));
+
+      block_x2 = (cluster_num &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : cluster_num;
+      grid_x2 = (cluster_num - 1) / block_x2 + 1;
+
+      clusterMark &lt;&lt; &lt; grid_x2, block_x2 &gt;&gt; &gt; (cluster_list, cluster_offset, cluster_num);
+
+      old_cluster_num = cluster_num;
+      exclusiveScan(cluster_offset, size_ + 1, &amp;cluster_num);
+      clusterCollector &lt;&lt; &lt; grid_x2, block_x2 &gt;&gt; &gt; (cluster_list, new_cluster_list, cluster_offset, old_cluster_num);
+      checkCudaErrors(cudaDeviceSynchronize());
+
+      checkCudaErrors(cudaMalloc(&amp;new_cluster_matrix, cluster_num * cluster_num * sizeof(int)));
+      checkCudaErrors(cudaMemset(new_cluster_matrix, 0, cluster_num * cluster_num * sizeof(int)));
+      rebuildClusterMatrix &lt;&lt; &lt; grid_x2, block_x2 &gt;&gt; &gt;
+                                         (cluster_matrix, cluster_list, new_cluster_matrix, cluster_offset, old_cluster_num, cluster_num);
+      checkCudaErrors(cudaDeviceSynchronize());
+
+      checkCudaErrors(cudaFree(cluster_matrix));
+      cluster_matrix = new_cluster_matrix;
+      tmp = cluster_list;
+      cluster_list = new_cluster_list;
+      new_cluster_list = tmp;
+    }
+  } while (*changed &amp;&amp; max_base_row &lt; cluster_num);
+
+  cluster_num_ = cluster_num;
+
+  //Reset all cluster indexes to make them start from 0
+  resetClusterIndexes &lt;&lt; &lt; grid_x, block_x &gt;&gt; &gt; (cluster_indices_, cluster_offset, size_);
+  checkCudaErrors(cudaDeviceSynchronize());
+
+  checkCudaErrors(cudaMemcpy(cluster_indices_host_, cluster_indices_, size_ * sizeof(int), cudaMemcpyDeviceToHost));
+
+  checkCudaErrors(cudaFree(cluster_matrix));
+  checkCudaErrors(cudaFree(cluster_list));
+  checkCudaErrors(cudaFree(new_cluster_list));
+  checkCudaErrors(cudaFree(cluster_offset));
+  checkCudaErrors(cudaFreeHost(changed));
 #ifndef SERIAL
-	checkCudaErrors(cudaFreeHost(changed_diag));
+  checkCudaErrors(cudaFreeHost(changed_diag));
 #endif
 }
 
@@ -762,28 +799,30 @@ void GpuEuclideanCluster::extractClusters()
  * The output is a vector whose each element contains indexes of points
  * that belong to a same clusters.
  */
-std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; GpuEuclideanCluster::getOutput()
+std::vector &lt;GpuEuclideanCluster::GClusterIndex&gt; GpuEuclideanCluster::getOutput()
 {
-	std::vector&lt;GClusterIndex&gt; cluster_indices(cluster_num_);
+  std::vector &lt;GClusterIndex&gt; cluster_indices(cluster_num_);
 
-	for (unsigned int i = 0; i &lt; cluster_indices.size(); i++)
-		cluster_indices[i].index_value = -1;
+  for (unsigned int i = 0; i &lt; cluster_indices.size(); i++)
+    cluster_indices[i].index_value = -1;
 
-	for (int i = 0; i &lt; size_; i++) {
-		cluster_indices[cluster_indices_host_[i]].points_in_cluster.push_back(i);
-		cluster_indices[cluster_indices_host_[i]].index_value = cluster_indices_host_[i];
-	}
+  for (int i = 0; i &lt; size_; i++)
+  {
+    cluster_indices[cluster_indices_host_[i]].points_in_cluster.push_back(i);
+    cluster_indices[cluster_indices_host_[i]].index_value = cluster_indices_host_[i];
+  }
 
-	for (unsigned int i = 0; i &lt; cluster_indices.size();) {
-		int number_of_pts = cluster_indices[i].points_in_cluster.size();
+  for (unsigned int i = 0; i &lt; cluster_indices.size();)
+  {
+    int number_of_pts = cluster_indices[i].points_in_cluster.size();
 
-		if (number_of_pts &lt; min_cluster_pts_ || number_of_pts &gt; max_cluster_pts_)
-			cluster_indices.erase(cluster_indices.begin() + i);
-		else
-			i++;
-	}
+    if (number_of_pts &lt; min_cluster_pts_ || number_of_pts &gt; max_cluster_pts_)
+      cluster_indices.erase(cluster_indices.begin() + i);
+    else
+      i++;
+  }
 
-	return cluster_indices;
+  return cluster_indices;
 }
 
 /* Generate sparse points.
@@ -793,33 +832,34 @@ std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; GpuEuclideanCluster::getOutput()
  */
 GpuEuclideanCluster::SamplePointListXYZ GpuEuclideanCluster::generateSample()
 {
-	GpuEuclideanCluster::SamplePointListXYZ output;
+  GpuEuclideanCluster::SamplePointListXYZ output;
 
-	output.size = 10000;
+  output.size = 10000;
 
-	output.x = (float*)malloc(sizeof(float) * output.size);
-	output.y = (float*)malloc(sizeof(float) * output.size);
-	output.z = (float*)malloc(sizeof(float) * output.size);
+  output.x = (float *) malloc(sizeof(float) * output.size);
+  output.y = (float *) malloc(sizeof(float) * output.size);
+  output.z = (float *) malloc(sizeof(float) * output.size);
 
-	output.x[0] = 0;
-	output.y[0] = 0;
-	output.z[0] = 0;
+  output.x[0] = 0;
+  output.y[0] = 0;
+  output.z[0] = 0;
 
-	for (int i = 1; i &lt; output.size; i++) {
-		output.x[i] = (i % 3 == 0) ? output.x[i - 1] + threshold_ + 1 : output.x[i - 1];
-		output.y[i] = (i % 3 == 1) ? output.y[i - 1] + threshold_ + 1: output.y[i - 1];
-		output.z[i] = (i % 3 == 2) ? output.z[i - 1] + threshold_ + 1: output.z[i - 1];
-	}
+  for (int i = 1; i &lt; output.size; i++)
+  {
+    output.x[i] = (i % 3 == 0) ? output.x[i - 1] + threshold_ + 1 : output.x[i - 1];
+    output.y[i] = (i % 3 == 1) ? output.y[i - 1] + threshold_ + 1 : output.y[i - 1];
+    output.z[i] = (i % 3 == 2) ? output.z[i - 1] + threshold_ + 1 : output.z[i - 1];
+  }
 
-	return output;
+  return output;
 }
 
 GpuEuclideanCluster::~GpuEuclideanCluster()
 {
-	checkCudaErrors(cudaFree(x_));
-	checkCudaErrors(cudaFree(y_));
-	checkCudaErrors(cudaFree(z_));
-	checkCudaErrors(cudaFree(cluster_indices_));
-	free(cluster_indices_host_);
+  checkCudaErrors(cudaFree(x_));
+  checkCudaErrors(cudaFree(y_));
+  checkCudaErrors(cudaFree(z_));
+  checkCudaErrors(cudaFree(cluster_indices_));
+  free(cluster_indices_host_);
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_euclidean_cluster_detect\nodes\lidar_euclidean_cluster_detect\lidar_euclidean_cluster_detect.cpp" added_lines="78" deleted_lines="338">
				<diff>@@ -41,9 +41,6 @@
 
 #include &lt;pcl/segmentation/extract_clusters.h&gt;
 
-#include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;visualization_msgs/Marker.h&gt;
-
 #include &lt;std_msgs/Float32MultiArray.h&gt;
 #include &lt;std_msgs/MultiArrayLayout.h&gt;
 #include &lt;std_msgs/MultiArrayDimension.h&gt;
@@ -60,11 +57,6 @@
 
 #include &lt;vector_map/vector_map.h&gt;
 
-#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
-#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-#include &lt;jsk_rviz_plugins/Pictogram.h&gt;
-#include &lt;jsk_rviz_plugins/PictogramArray.h&gt;
-
 #include &lt;tf/tf.h&gt;
 
 #include &lt;yaml-cpp/yaml.h&gt;
@@ -74,7 +66,9 @@
 #include &lt;opencv2/core/version.hpp&gt;
 
 #if (CV_MAJOR_VERSION == 3)
+
 #include "gencolors.cpp"
+
 #else
 
 #include &lt;opencv2/contrib/contrib.hpp&gt;
@@ -95,13 +89,11 @@ using namespace cv;
 ros::Publisher _pub_cluster_cloud;
 ros::Publisher _pub_ground_cloud;
 ros::Publisher _centroid_pub;
-ros::Publisher _marker_pub;
+
 ros::Publisher _pub_clusters_message;
-ros::Publisher _pub_text_pictogram;
+
 
 ros::Publisher _pub_points_lanes_cloud;
-ros::Publisher _pub_jsk_boundingboxes;
-ros::Publisher _pub_jsk_hulls;
 
 ros::Publisher _pub_grid_map;
 
@@ -158,12 +150,12 @@ static bool _use_multiple_thres;
 std::vector&lt;double&gt; _clustering_distances;
 std::vector&lt;double&gt; _clustering_ranges;
 
-tf::StampedTransform* _transform;
-tf::StampedTransform* _velodyne_output_transform;
-tf::TransformListener* _transform_listener;
-tf::TransformListener* _vectormap_transform_listener;
+tf::StampedTransform *_transform;
+tf::StampedTransform *_velodyne_output_transform;
+tf::TransformListener *_transform_listener;
+tf::TransformListener *_vectormap_transform_listener;
 
-tf::StampedTransform findTransform(const std::string&amp; in_target_frame, const std::string&amp; in_source_frame)
+tf::StampedTransform findTransform(const std::string &amp;in_target_frame, const std::string &amp;in_source_frame)
 {
   tf::StampedTransform transform;
 
@@ -181,7 +173,7 @@ tf::StampedTransform findTransform(const std::string&amp; in_target_frame, const std
   return transform;
 }
 
-geometry_msgs::Point transformPoint(const geometry_msgs::Point&amp; point, const tf::Transform&amp; tf)
+geometry_msgs::Point transformPoint(const geometry_msgs::Point &amp;point, const tf::Transform &amp;tf)
 {
   tf::Point tf_point;
   tf::pointMsgToTF(point, tf_point);
@@ -194,8 +186,8 @@ geometry_msgs::Point transformPoint(const geometry_msgs::Point&amp; point, const tf:
   return ros_point;
 }
 
-bool checkPointInGrid(const grid_map::GridMap&amp; in_grid_map, const cv::Mat&amp; in_grid_image,
-                      const geometry_msgs::Point&amp; in_point)
+bool checkPointInGrid(const grid_map::GridMap &amp;in_grid_map, const cv::Mat &amp;in_grid_image,
+                      const geometry_msgs::Point &amp;in_point)
 {
   // calculate out_grid_map position
   grid_map::Position map_pos = in_grid_map.getPosition();
@@ -220,30 +212,7 @@ bool checkPointInGrid(const grid_map::GridMap&amp; in_grid_map, const cv::Mat&amp; in_gr
   return false;
 }
 
-void transformBoundingBox(const jsk_recognition_msgs::BoundingBox&amp; in_boundingbox,
-                          jsk_recognition_msgs::BoundingBox&amp; out_boundingbox, const std::string&amp; in_target_frame,
-                          const std_msgs::Header&amp; in_header)
-{
-  geometry_msgs::PoseStamped pose_in, pose_out;
-  pose_in.header = in_header;
-  pose_in.pose = in_boundingbox.pose;
-  try
-  {
-    _transform_listener-&gt;transformPose(in_target_frame, ros::Time(), pose_in, in_header.frame_id, pose_out);
-  }
-  catch (tf::TransformException&amp; ex)
-  {
-    ROS_ERROR("transformBoundingBox: %s", ex.what());
-  }
-  out_boundingbox.pose = pose_out.pose;
-  out_boundingbox.header = in_header;
-  out_boundingbox.header.frame_id = in_target_frame;
-  out_boundingbox.dimensions = in_boundingbox.dimensions;
-  out_boundingbox.value = in_boundingbox.value;
-  out_boundingbox.label = in_boundingbox.label;
-}
-
-void publishDetectedObjects(const autoware_msgs::CloudClusterArray&amp; in_clusters)
+void publishDetectedObjects(const autoware_msgs::CloudClusterArray &amp;in_clusters)
 {
   autoware_msgs::DetectedObjectArray detected_objects;
   detected_objects.header = in_clusters.header;
@@ -259,18 +228,15 @@ void publishDetectedObjects(const autoware_msgs::CloudClusterArray&amp; in_clusters)
     detected_object.dimensions = in_clusters.clusters[i].dimensions;
     detected_object.pointcloud = in_clusters.clusters[i].cloud;
     detected_object.convex_hull = in_clusters.clusters[i].convex_hull;
-    detected_object.color.r = 0.;
-    detected_object.color.g = 1.;
-    detected_object.color.b = 0.;
-    detected_object.color.a = 1.;
+    detected_object.valid = true;
 
     detected_objects.objects.push_back(detected_object);
   }
   _pub_detected_objects.publish(detected_objects);
 }
 
-void publishCloudClusters(const ros::Publisher* in_publisher, const autoware_msgs::CloudClusterArray&amp; in_clusters,
-                          const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
+void publishCloudClusters(const ros::Publisher *in_publisher, const autoware_msgs::CloudClusterArray &amp;in_clusters,
+                          const std::string &amp;in_target_frame, const std_msgs::Header &amp;in_header)
 {
   if (in_target_frame != in_header.frame_id)
   {
@@ -283,7 +249,8 @@ void publishCloudClusters(const ros::Publisher* in_publisher, const autoware_msg
       cluster_transformed.header = in_header;
       try
       {
-        _transform_listener-&gt;lookupTransform(in_target_frame, _velodyne_header.frame_id, ros::Time(), *_transform);
+        _transform_listener-&gt;lookupTransform(in_target_frame, _velodyne_header.frame_id, ros::Time(),
+                                             *_transform);
         pcl_ros::transformPointCloud(in_target_frame, *_transform, i-&gt;cloud, cluster_transformed.cloud);
         _transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;min_point, in_header.frame_id,
                                             cluster_transformed.min_point);
@@ -298,27 +265,24 @@ void publishCloudClusters(const ros::Publisher* in_publisher, const autoware_msg
         cluster_transformed.eigen_values = i-&gt;eigen_values;
         cluster_transformed.eigen_vectors = i-&gt;eigen_vectors;
 
-        transformBoundingBox(i-&gt;bounding_box, cluster_transformed.bounding_box, in_target_frame, in_header);
-
         clusters_transformed.clusters.push_back(cluster_transformed);
       }
-      catch (tf::TransformException&amp; ex)
+      catch (tf::TransformException &amp;ex)
       {
         ROS_ERROR("publishCloudClusters: %s", ex.what());
       }
     }
     in_publisher-&gt;publish(clusters_transformed);
     publishDetectedObjects(clusters_transformed);
-  }
-  else
+  } else
   {
     in_publisher-&gt;publish(in_clusters);
     publishDetectedObjects(in_clusters);
   }
 }
 
-void publishCentroids(const ros::Publisher* in_publisher, const autoware_msgs::Centroids&amp; in_centroids,
-                      const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
+void publishCentroids(const ros::Publisher *in_publisher, const autoware_msgs::Centroids &amp;in_centroids,
+                      const std::string &amp;in_target_frame, const std_msgs::Header &amp;in_header)
 {
   if (in_target_frame != in_header.frame_id)
   {
@@ -337,43 +301,19 @@ void publishCentroids(const ros::Publisher* in_publisher, const autoware_msgs::C
 
         centroids_transformed.points.push_back(centroid_out.point);
       }
-      catch (tf::TransformException&amp; ex)
+      catch (tf::TransformException &amp;ex)
       {
         ROS_ERROR("publishCentroids: %s", ex.what());
       }
     }
     in_publisher-&gt;publish(centroids_transformed);
-  }
-  else
+  } else
   {
     in_publisher-&gt;publish(in_centroids);
   }
 }
 
-void publishBoundingBoxArray(const ros::Publisher* in_publisher,
-                             const jsk_recognition_msgs::BoundingBoxArray&amp; in_boundingbox_array,
-                             const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
-{
-  if (in_target_frame != in_header.frame_id)
-  {
-    jsk_recognition_msgs::BoundingBoxArray boundingboxes_transformed;
-    boundingboxes_transformed.header = in_header;
-    boundingboxes_transformed.header.frame_id = in_target_frame;
-    for (auto i = in_boundingbox_array.boxes.begin(); i != in_boundingbox_array.boxes.end(); i++)
-    {
-      jsk_recognition_msgs::BoundingBox boundingbox_transformed;
-      transformBoundingBox(*i, boundingbox_transformed, in_target_frame, in_header);
-      boundingboxes_transformed.boxes.push_back(boundingbox_transformed);
-    }
-    in_publisher-&gt;publish(boundingboxes_transformed);
-  }
-  else
-  {
-    in_publisher-&gt;publish(in_boundingbox_array);
-  }
-}
-
-void publishCloud(const ros::Publisher* in_publisher, const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_to_publish_ptr)
+void publishCloud(const ros::Publisher *in_publisher, const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_to_publish_ptr)
 {
   sensor_msgs::PointCloud2 cloud_msg;
   pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
@@ -381,7 +321,7 @@ void publishCloud(const ros::Publisher* in_publisher, const pcl::PointCloud&lt;pcl:
   in_publisher-&gt;publish(cloud_msg);
 }
 
-void publishColorCloud(const ros::Publisher* in_publisher,
+void publishColorCloud(const ros::Publisher *in_publisher,
                        const pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr in_cloud_to_publish_ptr)
 {
   sensor_msgs::PointCloud2 cloud_msg;
@@ -419,8 +359,7 @@ void keepLanePoints(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 
 std::vector&lt;ClusterPtr&gt; clusterAndColorGpu(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
                                            pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
-                                           jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
-                                           autoware_msgs::Centroids&amp; in_out_centroids,
+                                           autoware_msgs::Centroids &amp;in_out_centroids,
                                            double in_max_cluster_distance = 0.5)
 {
   std::vector&lt;ClusterPtr&gt; clusters;
@@ -434,9 +373,9 @@ std::vector&lt;ClusterPtr&gt; clusterAndColorGpu(const pcl::PointCloud&lt;pcl::PointXYZ&gt;:
 
   float *tmp_x, *tmp_y, *tmp_z;
 
-  tmp_x = (float*)malloc(sizeof(float) * size);
-  tmp_y = (float*)malloc(sizeof(float) * size);
-  tmp_z = (float*)malloc(sizeof(float) * size);
+  tmp_x = (float *) malloc(sizeof(float) * size);
+  tmp_y = (float *) malloc(sizeof(float) * size);
+  tmp_z = (float *) malloc(sizeof(float) * size);
 
   for (int i = 0; i &lt; size; i++)
   {
@@ -461,8 +400,8 @@ std::vector&lt;ClusterPtr&gt; clusterAndColorGpu(const pcl::PointCloud&lt;pcl::PointXYZ&gt;:
   for (auto it = cluster_indices.begin(); it != cluster_indices.end(); it++)
   {
     ClusterPtr cluster(new Cluster());
-    cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;points_in_cluster, _velodyne_header, k, (int)_colors[k].val[0],
-                      (int)_colors[k].val[1], (int)_colors[k].val[2], "", _pose_estimation);
+    cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;points_in_cluster, _velodyne_header, k, (int) _colors[k].val[0],
+                      (int) _colors[k].val[1], (int) _colors[k].val[2], "", _pose_estimation);
     clusters.push_back(cluster);
 
     k++;
@@ -479,8 +418,7 @@ std::vector&lt;ClusterPtr&gt; clusterAndColorGpu(const pcl::PointCloud&lt;pcl::PointXYZ&gt;:
 
 std::vector&lt;ClusterPtr&gt; clusterAndColor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
                                         pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
-                                        jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
-                                        autoware_msgs::Centroids&amp; in_out_centroids,
+                                        autoware_msgs::Centroids &amp;in_out_centroids,
                                         double in_max_cluster_distance = 0.5)
 {
   pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;);
@@ -509,14 +447,6 @@ std::vector&lt;ClusterPtr&gt; clusterAndColor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Pt
   ec.extract(cluster_indices);
   // use indices on 3d cloud
 
-  /*pcl::ConditionalEuclideanClustering&lt;pcl::PointXYZ&gt; cec (true);
-  cec.setInputCloud (in_cloud_ptr);
-  cec.setConditionFunction (&amp;independentDistance);
-  cec.setMinClusterSize (cluster_size_min);
-  cec.setMaxClusterSize (cluster_size_max);
-  cec.setClusterTolerance (_distance*2.0f);
-  cec.segment (cluster_indices);*/
-
   /////////////////////////////////
   //---	3. Color clustered points
   /////////////////////////////////
@@ -529,8 +459,9 @@ std::vector&lt;ClusterPtr&gt; clusterAndColor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Pt
   for (auto it = cluster_indices.begin(); it != cluster_indices.end(); ++it)
   {
     ClusterPtr cluster(new Cluster());
-    cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1],
-                      (int)_colors[k].val[2], "", _pose_estimation);
+    cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int) _colors[k].val[0],
+                      (int) _colors[k].val[1],
+                      (int) _colors[k].val[2], "", _pose_estimation);
     clusters.push_back(cluster);
 
     k++;
@@ -539,8 +470,8 @@ std::vector&lt;ClusterPtr&gt; clusterAndColor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Pt
   return clusters;
 }
 
-void checkClusterMerge(size_t in_cluster_id, std::vector&lt;ClusterPtr&gt;&amp; in_clusters,
-                       std::vector&lt;bool&gt;&amp; in_out_visited_clusters, std::vector&lt;size_t&gt;&amp; out_merge_indices,
+void checkClusterMerge(size_t in_cluster_id, std::vector&lt;ClusterPtr&gt; &amp;in_clusters,
+                       std::vector&lt;bool&gt; &amp;in_out_visited_clusters, std::vector&lt;size_t&gt; &amp;out_merge_indices,
                        double in_merge_threshold)
 {
   // std::cout &lt;&lt; "checkClusterMerge" &lt;&lt; std::endl;
@@ -562,9 +493,9 @@ void checkClusterMerge(size_t in_cluster_id, std::vector&lt;ClusterPtr&gt;&amp; in_cluster
   }
 }
 
-void mergeClusters(const std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;ClusterPtr&gt;&amp; out_clusters,
-                   std::vector&lt;size_t&gt; in_merge_indices, const size_t&amp; current_index,
-                   std::vector&lt;bool&gt;&amp; in_out_merged_clusters)
+void mergeClusters(const std::vector&lt;ClusterPtr&gt; &amp;in_clusters, std::vector&lt;ClusterPtr&gt; &amp;out_clusters,
+                   std::vector&lt;size_t&gt; in_merge_indices, const size_t &amp;current_index,
+                   std::vector&lt;bool&gt; &amp;in_out_merged_clusters)
 {
   // std::cout &lt;&lt; "mergeClusters:" &lt;&lt; in_merge_indices.size() &lt;&lt; std::endl;
   pcl::PointCloud&lt;pcl::PointXYZRGB&gt; sum_cloud;
@@ -584,17 +515,14 @@ void mergeClusters(const std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;Clust
   if (sum_cloud.points.size() &gt; 0)
   {
     pcl::copyPointCloud(sum_cloud, mono_cloud);
-    // std::cout &lt;&lt; "mergedClusters " &lt;&lt; sum_cloud.points.size() &lt;&lt; " mono:" &lt;&lt; mono_cloud.points.size() &lt;&lt; std::endl;
-    // cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1],
-    // (int)_colors[k].val[2], "", _pose_estimation);
     merged_cluster-&gt;SetCloud(mono_cloud.makeShared(), indices, _velodyne_header, current_index,
-                             (int)_colors[current_index].val[0], (int)_colors[current_index].val[1],
-                             (int)_colors[current_index].val[2], "", _pose_estimation);
+                             (int) _colors[current_index].val[0], (int) _colors[current_index].val[1],
+                             (int) _colors[current_index].val[2], "", _pose_estimation);
     out_clusters.push_back(merged_cluster);
   }
 }
 
-void checkAllForMerge(std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;ClusterPtr&gt;&amp; out_clusters,
+void checkAllForMerge(std::vector&lt;ClusterPtr&gt; &amp;in_clusters, std::vector&lt;ClusterPtr&gt; &amp;out_clusters,
                       float in_merge_threshold)
 {
   // std::cout &lt;&lt; "checkAllForMerge" &lt;&lt; std::endl;
@@ -625,10 +553,7 @@ void checkAllForMerge(std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;ClusterP
 
 void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
                        pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
-                       jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
-                       autoware_msgs::Centroids&amp; in_out_centroids, autoware_msgs::CloudClusterArray&amp; in_out_clusters,
-                       jsk_recognition_msgs::PolygonArray&amp; in_out_polygon_array,
-                       jsk_rviz_plugins::PictogramArray&amp; in_out_pictogram_array)
+                       autoware_msgs::Centroids &amp;in_out_centroids, autoware_msgs::CloudClusterArray &amp;in_out_clusters)
 {
   // cluster the pointcloud according to the distance of the points using different thresholds (not only one for the
   // entire pc)
@@ -658,20 +583,18 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 #ifdef GPU_CLUSTERING
     if (_use_gpu)
     {
-      all_clusters = clusterAndColorGpu(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids,
+      all_clusters = clusterAndColorGpu(cloud_ptr, out_cloud_ptr, in_out_centroids,
                                         _clustering_distance);
-    }
-    else
+    } else
     {
       all_clusters =
-          clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_distance);
+        clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_centroids, _clustering_distance);
     }
 #else
     all_clusters =
-        clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_distance);
+        clusterAndColor(cloud_ptr, out_cloud_ptr, in_out_centroids, _clustering_distance);
 #endif
-  }
-  else
+  } else
   {
     std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr&gt; cloud_segments_array(5);
     for (unsigned int i = 0; i &lt; cloud_segments_array.size(); i++)
@@ -692,20 +615,16 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
       if (origin_distance &lt; _clustering_ranges[0])
       {
         cloud_segments_array[0]-&gt;points.push_back(current_point);
-      }
-      else if (origin_distance &lt; _clustering_ranges[1])
+      } else if (origin_distance &lt; _clustering_ranges[1])
       {
         cloud_segments_array[1]-&gt;points.push_back(current_point);
-      }
-      else if (origin_distance &lt; _clustering_ranges[2])
+      } else if (origin_distance &lt; _clustering_ranges[2])
       {
         cloud_segments_array[2]-&gt;points.push_back(current_point);
-      }
-      else if (origin_distance &lt; _clustering_ranges[3])
+      } else if (origin_distance &lt; _clustering_ranges[3])
       {
         cloud_segments_array[3]-&gt;points.push_back(current_point);
-      }
-      else
+      } else
       {
         cloud_segments_array[4]-&gt;points.push_back(current_point);
       }
@@ -717,17 +636,16 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 #ifdef GPU_CLUSTERING
       if (_use_gpu)
       {
-        local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
+        local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr,
                                             in_out_centroids, _clustering_distances[i]);
-      }
-      else
+      } else
       {
-        local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array,
+        local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr,
                                          in_out_centroids, _clustering_distances[i]);
       }
 #else
       local_clusters = clusterAndColor(
-          cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_distances[i]);
+          cloud_segments_array[i], out_cloud_ptr, in_out_centroids, _clustering_distances[i]);
 #endif
       all_clusters.insert(all_clusters.end(), local_clusters.begin(), local_clusters.end());
     }
@@ -771,10 +689,10 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 
         if (_wayarea_gridmap.getFrameId() != _velodyne_header.frame_id)
         {
-          tf::StampedTransform grid_sensor_tf = findTransform(_wayarea_gridmap.getFrameId(), _velodyne_header.frame_id);
+          tf::StampedTransform grid_sensor_tf = findTransform(_wayarea_gridmap.getFrameId(),
+                                                              _velodyne_header.frame_id);
           final_centroid_point = transformPoint(original_centroid_point, grid_sensor_tf);
-        }
-        else
+        } else
         {
           final_centroid_point = original_centroid_point;
         }
@@ -785,73 +703,31 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
       // timer.stop();
       // std::cout &lt;&lt; "vectormap filtering took " &lt;&lt; timer.getTimeMilli() &lt;&lt; " ms to check " &lt;&lt; final_clusters.size() &lt;&lt;
       // std::endl;
-    }
-    else
+    } else
     {
       ROS_INFO("%s layer not contained in the OccupancyGrid", _gridmap_layer.c_str());
     }
   }
   // Get final PointCloud to be published
-  in_out_polygon_array.header = _velodyne_header;
-  in_out_pictogram_array.header = _velodyne_header;
   for (unsigned int i = 0; i &lt; final_clusters.size(); i++)
   {
     *out_cloud_ptr = *out_cloud_ptr + *(final_clusters[i]-&gt;GetCloud());
-
-    jsk_recognition_msgs::BoundingBox bounding_box = final_clusters[i]-&gt;GetBoundingBox();
-    geometry_msgs::PolygonStamped polygon = final_clusters[i]-&gt;GetPolygon();
-    jsk_rviz_plugins::Pictogram pictogram_cluster;
-    pictogram_cluster.header = _velodyne_header;
-
-    // PICTO
-    pictogram_cluster.mode = pictogram_cluster.STRING_MODE;
-    pictogram_cluster.pose.position.x = final_clusters[i]-&gt;GetMaxPoint().x;
-    pictogram_cluster.pose.position.y = final_clusters[i]-&gt;GetMaxPoint().y;
-    pictogram_cluster.pose.position.z = final_clusters[i]-&gt;GetMaxPoint().z;
-    tf::Quaternion quat(0.0, -0.7, 0.0, 0.7);
-    tf::quaternionTFToMsg(quat, pictogram_cluster.pose.orientation);
-    pictogram_cluster.size = 4;
-    std_msgs::ColorRGBA color;
-    color.a = 1;
-    color.r = 1;
-    color.g = 1;
-    color.b = 1;
-    pictogram_cluster.color = color;
-    pictogram_cluster.character = std::to_string(i);
-    // PICTO
-
-    // pcl::PointXYZ min_point = final_clusters[i]-&gt;GetMinPoint();
-    // pcl::PointXYZ max_point = final_clusters[i]-&gt;GetMaxPoint();
     pcl::PointXYZ center_point = final_clusters[i]-&gt;GetCentroid();
     geometry_msgs::Point centroid;
     centroid.x = center_point.x;
     centroid.y = center_point.y;
     centroid.z = center_point.z;
-    bounding_box.header = _velodyne_header;
-    polygon.header = _velodyne_header;
 
-    if (final_clusters[i]-&gt;IsValid()
-        //&amp;&amp; bounding_box.dimensions.x &gt;0 &amp;&amp; bounding_box.dimensions.y &gt;0 &amp;&amp; bounding_box.dimensions.z &gt; 0
-        //&amp;&amp;	bounding_box.dimensions.x &lt; _max_boundingbox_side &amp;&amp; bounding_box.dimensions.y &lt; _max_boundingbox_side
-        )
+    if (final_clusters[i]-&gt;IsValid())
     {
-      in_out_boundingbox_array.boxes.push_back(bounding_box);
-      in_out_centroids.points.push_back(centroid);
-      _visualization_marker.points.push_back(centroid);
 
-      in_out_polygon_array.polygons.push_back(polygon);
-      in_out_pictogram_array.pictograms.push_back(pictogram_cluster);
+      in_out_centroids.points.push_back(centroid);
 
       autoware_msgs::CloudCluster cloud_cluster;
       final_clusters[i]-&gt;ToROSMessage(_velodyne_header, cloud_cluster);
       in_out_clusters.clusters.push_back(cloud_cluster);
     }
   }
-
-  for (size_t i = 0; i &lt; in_out_polygon_array.polygons.size(); i++)
-  {
-    in_out_polygon_array.labels.push_back(i);
-  }
 }
 
 void removeFloor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
@@ -859,26 +735,6 @@ void removeFloor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
                  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_onlyfloor_cloud_ptr, float in_max_height = 0.2,
                  float in_floor_max_angle = 0.1)
 {
-  /*pcl::PointIndicesPtr ground (new pcl::PointIndices);
-  // Create the filtering object
-  pcl::ProgressiveMorphologicalFilter&lt;pcl::PointXYZ&gt; pmf;
-  pmf.setInputCloud (in_cloud_ptr);
-  pmf.setMaxWindowSize (20);
-  pmf.setSlope (1.0f);
-  pmf.setInitialDistance (0.5f);
-  pmf.setMaxDistance (3.0f);
-  pmf.extract (ground-&gt;indices);
-
-  // Create the filtering object
-  pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
-  extract.setInputCloud (in_cloud_ptr);
-  extract.setIndices (ground);
-  extract.setNegative(true);//true removes the indices, false leaves only the indices
-  extract.filter(*out_nofloor_cloud_ptr);
-
-  //EXTRACT THE FLOOR FROM THE CLOUD
-  extract.setNegative(false);//true removes the indices, false leaves only the indices
-  extract.filter(*out_onlyfloor_cloud_ptr);*/
 
   pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;
   pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
@@ -917,7 +773,7 @@ void downsampleCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 {
   pcl::VoxelGrid&lt;pcl::PointXYZ&gt; sor;
   sor.setInputCloud(in_cloud_ptr);
-  sor.setLeafSize((float)in_leaf_size, (float)in_leaf_size, (float)in_leaf_size);
+  sor.setLeafSize((float) in_leaf_size, (float) in_leaf_size, (float) in_leaf_size);
   sor.filter(*out_cloud_ptr);
 }
 
@@ -944,8 +800,7 @@ void differenceNormalsSegmentation(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_
   if (in_cloud_ptr-&gt;isOrganized())
   {
     tree.reset(new pcl::search::OrganizedNeighbor&lt;pcl::PointXYZ&gt;());
-  }
-  else
+  } else
   {
     tree.reset(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;(false));
   }
@@ -985,7 +840,7 @@ void differenceNormalsSegmentation(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_
 
   pcl::ConditionOr&lt;pcl::PointNormal&gt;::Ptr range_cond(new pcl::ConditionOr&lt;pcl::PointNormal&gt;());
   range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointNormal&gt;::ConstPtr(
-      new pcl::FieldComparison&lt;pcl::PointNormal&gt;("curvature", pcl::ComparisonOps::GT, angle_threshold)));
+    new pcl::FieldComparison&lt;pcl::PointNormal&gt;("curvature", pcl::ComparisonOps::GT, angle_threshold)));
   // Build the filter
   pcl::ConditionalRemoval&lt;pcl::PointNormal&gt; cond_removal;
   cond_removal.setCondition(range_cond);
@@ -1013,7 +868,7 @@ void removePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
   }
 }
 
-void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
+void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr &amp;in_sensor_cloud)
 {
   //_start = std::chrono::system_clock::now();
 
@@ -1033,9 +888,6 @@ void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
 
     autoware_msgs::Centroids centroids;
     autoware_msgs::CloudClusterArray cloud_clusters;
-    jsk_recognition_msgs::BoundingBoxArray boundingbox_array;
-    jsk_recognition_msgs::PolygonArray polygon_array;
-    jsk_rviz_plugins::PictogramArray pictograms_array;
 
     pcl::fromROSMsg(*in_sensor_cloud, *current_sensor_cloud_ptr);
 
@@ -1044,8 +896,7 @@ void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
     if (_remove_points_upto &gt; 0.0)
     {
       removePointsUpTo(current_sensor_cloud_ptr, removed_points_cloud_ptr, _remove_points_upto);
-    }
-    else
+    } else
       removed_points_cloud_ptr = current_sensor_cloud_ptr;
 
     if (_downsample_cloud)
@@ -1064,8 +915,7 @@ void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
     {
       removeFloor(inlanes_cloud_ptr, nofloor_cloud_ptr, onlyfloor_cloud_ptr);
       publishCloud(&amp;_pub_ground_cloud, onlyfloor_cloud_ptr);
-    }
-    else
+    } else
       nofloor_cloud_ptr = inlanes_cloud_ptr;
 
     publishCloud(&amp;_pub_points_lanes_cloud, nofloor_cloud_ptr);
@@ -1075,117 +925,29 @@ void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
     else
       diffnormals_cloud_ptr = nofloor_cloud_ptr;
 
-    segmentByDistance(diffnormals_cloud_ptr, colored_clustered_cloud_ptr, boundingbox_array, centroids, cloud_clusters,
-                      polygon_array, pictograms_array);
+    segmentByDistance(diffnormals_cloud_ptr, colored_clustered_cloud_ptr, centroids,
+                      cloud_clusters);
 
     publishColorCloud(&amp;_pub_cluster_cloud, colored_clustered_cloud_ptr);
 
-    // Publish BB
-    boundingbox_array.header = _velodyne_header;
-
-    _pub_jsk_hulls.publish(polygon_array);          // publish convex hulls
-    _pub_text_pictogram.publish(pictograms_array);  // publish_ids
-
-    publishBoundingBoxArray(&amp;_pub_jsk_boundingboxes, boundingbox_array, _output_frame, _velodyne_header);
     centroids.header = _velodyne_header;
 
     publishCentroids(&amp;_centroid_pub, centroids, _output_frame, _velodyne_header);
 
-    _marker_pub.publish(_visualization_marker);
-    _visualization_marker.points.clear();  // transform? is it used?
     cloud_clusters.header = _velodyne_header;
 
     publishCloudClusters(&amp;_pub_clusters_message, cloud_clusters, _output_frame, _velodyne_header);
 
     _using_sensor_cloud = false;
   }
-  //_end = std::chrono::system_clock::now();
-  // double elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(_end-_start).count();
-  // ROS_INFO("Euclidean Clustering : %f", elapsed);
 }
 
-/*
-void vectormap_callback(const visualization_msgs::MarkerArray::Ptr in_vectormap_markers)
-{
-  float min_x=std::numeric_limits&lt;float&gt;::max();float max_x=-std::numeric_limits&lt;float&gt;::max();
-  float min_y=std::numeric_limits&lt;float&gt;::max();float max_y=-std::numeric_limits&lt;float&gt;::max();
-  pcl::PointXYZ min_point;
-  pcl::PointXYZ max_point;
-  std::vector&lt;geometry_msgs::Point&gt; vectormap_points;
-  std::string marker_frame;
-  double map_scale = -10.0;
-  for(auto i=in_vectormap_markers-&gt;markers.begin(); i!= in_vectormap_markers-&gt;markers.end(); i++)
-  {
-    visualization_msgs::Marker current_marker = *i;
-    marker_frame = current_marker.header.frame_id;
-    if (current_marker.ns == "road_edge")
-    {
-      for (unsigned int j=0; j&lt; current_marker.points.size(); j++)
-      {
-        geometry_msgs::Point p = current_marker.points[j];
-        p.x*=map_scale;
-        p.y*=map_scale;
-        if(p.x&lt;min_x)	min_x = p.x;
-        if(p.y&lt;min_y)	min_y = p.y;
-        if(p.x&gt;max_x)	max_x = p.x;
-        if(p.y&gt;max_y)	max_y = p.y;
-        vectormap_points.push_back(p);
-      }
-    }
-  }
-  min_point.x = min_x;	min_point.y = min_y;
-  max_point.x = max_x;	max_point.y = max_y;
-
-  min_point.x*=-1.0;
-  min_point.y*=-1.0;
-  //translate the points to the minimum point
-  for (auto i=vectormap_points.begin(); i!=vectormap_points.end(); i++)
-  {
-    (*i).x+=min_point.x;
-    (*i).y+=min_point.y;
-  }
-  max_point.x+=min_point.x;
-  max_point.y+=min_point.y;
-  //get world tf
-  std::string error_transform_msg;
-  tf::Vector3 map_origin_point;
-  if(_transform_listener-&gt;waitForTransform("/map", marker_frame, ros::Time(0), ros::Duration(5), ros::Duration(0.1),
-&amp;error_transform_msg))
-  {
-    _transform_listener-&gt;lookupTransform("/map", marker_frame, ros::Time(0), *_transform);
-    map_origin_point = _transform-&gt;getOrigin();
-    map_origin_point.setX( map_origin_point.x() - min_point.x);
-    map_origin_point.setY( map_origin_point.y() - min_point.y);
-  }
-  else
-  {
-    ROS_INFO("Euclidean Cluster (vectormap_callback): %s", error_transform_msg.c_str());
-  }
-
-  cv::Mat map_image = cv::Mat::zeros(max_point.y, max_point.x, CV_8UC3);
-
-  std::cout &lt;&lt; "W,H:" &lt;&lt; max_point &lt;&lt; std::endl;
-
-  cv::Point image_start_point (vectormap_points[0].x, vectormap_points[0].y);
-  cv::Point prev_point = image_start_point;
-  for (auto i=vectormap_points.begin(); i!=vectormap_points.end(); i++)
-  {
-    cv::line(map_image, prev_point, cv::Point((int)(i-&gt;x), (int)(i-&gt;y)), cv::Scalar::all(255));
-
-    prev_point.x = (int)(i-&gt;x);
-    prev_point.y = (int)(i-&gt;y);
-  }
-  cv::circle(map_image, image_start_point, 3, cv::Scalar(255,0,0));
-  cv::imshow("vectormap", map_image);
-  cv::waitKey(0);
-}*/
-
-void wayarea_gridmap_callback(const grid_map_msgs::GridMap&amp; message)
+void wayarea_gridmap_callback(const grid_map_msgs::GridMap &amp;message)
 {
   grid_map::GridMapRosConverter::fromMessage(message, _wayarea_gridmap);
 }
 
-int main(int argc, char** argv)
+int main(int argc, char **argv)
 {
   // Initialize ROS
   ros::init(argc, argv, "euclidean_cluster");
@@ -1210,15 +972,10 @@ int main(int argc, char** argv)
   _pub_cluster_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_cluster", 1);
   _pub_ground_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_ground", 1);
   _centroid_pub = h.advertise&lt;autoware_msgs::Centroids&gt;("/cluster_centroids", 1);
-  _marker_pub = h.advertise&lt;visualization_msgs::Marker&gt;("centroid_marker", 1);
 
   _pub_points_lanes_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_lanes", 1);
-  _pub_jsk_boundingboxes = h.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/bounding_boxes", 1);
-  _pub_jsk_hulls = h.advertise&lt;jsk_recognition_msgs::PolygonArray&gt;("/cluster_hulls", 1);
-  _pub_clusters_message = h.advertise&lt;autoware_msgs::CloudClusterArray&gt;("/cloud_clusters", 1);
-  _pub_detected_objects = h.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/lidar_objects", 1);
-  _pub_text_pictogram = h.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;("cluster_ids", 10);
-  ROS_INFO("output pictograms topic: %s", "cluster_id");
+  _pub_clusters_message = h.advertise&lt;autoware_msgs::CloudClusterArray&gt;("/detection/lidar_detector/cloud_clusters", 1);
+  _pub_detected_objects = h.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/lidar_detector/objects", 1);
 
   _pub_grid_map = h.advertise&lt;grid_map_msgs::GridMap&gt;("grid_map_wayarea", 1, true);
 
@@ -1229,11 +986,10 @@ int main(int argc, char** argv)
   if (private_nh.getParam("points_node", points_topic))
   {
     ROS_INFO("euclidean_cluster &gt; Setting points node to %s", points_topic.c_str());
-  }
-  else
+  } else
   {
     ROS_INFO("euclidean_cluster &gt; No points node received, defaulting to points_raw, you can use "
-             "_points_node:=YOUR_TOPIC");
+               "_points_node:=YOUR_TOPIC");
     points_topic = "/points_raw";
   }
 
@@ -1341,22 +1097,6 @@ int main(int argc, char** argv)
   ROS_INFO("wayarea_no_road_value: %ds", _gridmap_no_road_value);
   ros::Subscriber wayarea_sub = h.subscribe(gridmap_topic, 1, wayarea_gridmap_callback);
 
-  _visualization_marker.header.frame_id = "velodyne";
-  _visualization_marker.header.stamp = ros::Time();
-  _visualization_marker.ns = "my_namespace";
-  _visualization_marker.id = 0;
-  _visualization_marker.type = visualization_msgs::Marker::SPHERE_LIST;
-  _visualization_marker.action = visualization_msgs::Marker::ADD;
-  _visualization_marker.scale.x = 1.0;
-  _visualization_marker.scale.y = 1.0;
-  _visualization_marker.scale.z = 1.0;
-  _visualization_marker.color.a = 1.0;
-  _visualization_marker.color.r = 0.0;
-  _visualization_marker.color.g = 0.0;
-  _visualization_marker.color.b = 1.0;
-  // marker.lifetime = ros::Duration(0.1);
-  _visualization_marker.frame_locked = true;
-
   // Spin
   ros::spin();
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\nodes\lidar_fake_perception.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_fake_perception\nodes\lidar_fake_perception.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -31,7 +31,7 @@ LidarFakePerception::LidarFakePerception() : nh_(), private_nh_("~")
   real_points_sub_ = nh_.subscribe("/points_raw", 1, &amp;LidarFakePerception::pointsCallback, this);
   fake_twist_sub_ = nh_.subscribe("/fake_twist", 1, &amp;LidarFakePerception::twistCallback, this);
 
-  fake_objects_pub_ = nh_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/fake_objects", 1);
+  fake_objects_pub_ = nh_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/fake_perception/objects", 1);
   fake_points_pub_ = nh_.advertise&lt;sensor_msgs::PointCloud2&gt;("/fake_points", 1);
 
   fake_object_id_ = 0;      // overwritten by real object ids
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_naive_l_shape_detect\nodes\lidar_naive_l_shape_detect\lidar_naive_l_shape_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_naive_l_shape_detect\nodes\lidar_naive_l_shape_detect\lidar_naive_l_shape_detect.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -54,7 +54,7 @@ LShapeFilter::LShapeFilter()
 
   sub_object_array_ = node_handle_.subscribe("/detection/lidar_objects", 1, &amp;LShapeFilter::callback, this);
   pub_object_array_ =
-      node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/lidar_objects/l_shaped", 1);
+      node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/l_shaped/objects", 1);
 }
 
 void LShapeFilter::callback(const autoware_msgs::DetectedObjectArray&amp; input)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\imm_ukf_pda.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\imm_ukf_pda.h" added_lines="75" deleted_lines="46">
				<diff>@@ -31,19 +31,23 @@
 #ifndef OBJECT_TRACKING_IMM_UKF_JPDAF_H
 #define OBJECT_TRACKING_IMM_UKF_JPDAF_H
 
-#include &lt;ros/ros.h&gt;
 
 #include &lt;vector&gt;
+#include &lt;chrono&gt;
+#include &lt;stdio.h&gt;
+
+
+#include &lt;ros/ros.h&gt;
+#include &lt;ros/package.h&gt;
+
 #include &lt;pcl/point_cloud.h&gt;
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl/io/pcd_io.h&gt;
+#include &lt;pcl_conversions/pcl_conversions.h&gt;
 
 #include &lt;tf/transform_listener.h&gt;
 
-#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
-#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-
-#include &lt;visualization_msgs/MarkerArray.h&gt;
+#include &lt;vector_map/vector_map.h&gt;
 
 #include "autoware_msgs/DetectedObject.h"
 #include "autoware_msgs/DetectedObjectArray.h"
@@ -64,25 +68,16 @@ private:
   double gate_probability_;
   double detection_probability_;
 
-  // bbox association param
-  double distance_thres_;
+  // object association param
   int life_time_thres_;
 
-  // bbox update params
-  double bb_yaw_change_thres_;
+  // static classification param
   double static_velocity_thres_;
-  double init_yaw_;
-
-  // Tracking state paramas
-  int stable_num_;
-  int lost_num_;
+  int static_num_history_thres_;
 
   // switch sukf and ImmUkfPda
   bool use_sukf_;
 
-  // whether if publish debug ros markers
-  bool is_debug_;
-
   // whether if benchmarking tracking result
   bool is_benchmark_;
   int frame_count_;
@@ -94,46 +89,51 @@ private:
   // prevent explode param for ukf
   double prevent_explosion_thres_;
 
+  // for vectormap assisted tarcking
+  bool use_vectormap_;
+  bool has_subscribed_vectormap_;
+  double lane_direction_chi_thres_;
+  double nearest_lane_distance_thres_;
+  std::string vectormap_frame_;
+  vector_map::VectorMap vmap_;
+  std::vector&lt;vector_map_msgs::Lane&gt; lanes_;
+
+  double merge_distance_threshold_;
+  const double CENTROID_DISTANCE = 0.2;//distance to consider centroids the same
+
   std::string input_topic_;
   std::string output_topic_;
 
-  std::string pointcloud_frame_;
   std::string tracking_frame_;
 
   tf::TransformListener tf_listener_;
   tf::StampedTransform local2global_;
+  tf::StampedTransform tracking_frame2lane_frame_;
+  tf::StampedTransform lane_frame2tracking_frame_;
 
   ros::NodeHandle node_handle_;
+  ros::NodeHandle private_nh_;
   ros::Subscriber sub_detected_array_;
   ros::Publisher pub_object_array_;
-  ros::Publisher pub_jskbbox_array_;
-  ros::Publisher pub_adas_direction_array_;
-  ros::Publisher pub_adas_prediction_array_;
-  ros::Publisher pub_points_array_;
-  ros::Publisher pub_texts_array_;
+
+  std_msgs::Header input_header_;
 
   void callback(const autoware_msgs::DetectedObjectArray&amp; input);
-  void setPredictionObject();
-  void relayJskbbox(const autoware_msgs::DetectedObjectArray&amp; input,
-                    jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output);
+
   void transformPoseToGlobal(const autoware_msgs::DetectedObjectArray&amp; input,
                              autoware_msgs::DetectedObjectArray&amp; transformed_input);
-  void transformPoseToLocal(jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
-                            autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
+  void transformPoseToLocal(autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
+
+  geometry_msgs::Pose getTransformedPose(const geometry_msgs::Pose&amp; in_pose,
+                                                const tf::StampedTransform&amp; tf_stamp);
+
+  bool updateNecessaryTransform();
+
   void measurementValidation(const autoware_msgs::DetectedObjectArray&amp; input, UKF&amp; target, const bool second_init,
                              const Eigen::VectorXd&amp; max_det_z, const Eigen::MatrixXd&amp; max_det_s,
                              std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, std::vector&lt;bool&gt;&amp; matching_vec);
-  void getNearestEuclidCluster(const UKF&amp; target, const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec,
-                               autoware_msgs::DetectedObject&amp; object, double&amp; min_dist);
-  void getRightAngleBBox(const std::vector&lt;double&gt; nearest_bbox, std::vector&lt;double&gt;&amp; rightAngle_bbox);
-  void associateBB(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, UKF&amp; target);
-  double getBBoxYaw(const UKF target);
-  double getJskBBoxArea(const jsk_recognition_msgs::BoundingBox&amp; jsk_bb);
-  double getJskBBoxYaw(const jsk_recognition_msgs::BoundingBox&amp; jsk_bb);
-  void updateBB(UKF&amp; target);
-  void mergeOverSegmentation(const std::vector&lt;UKF&gt; targets);
-
-  void updateJskLabel(const UKF&amp; target, jsk_recognition_msgs::BoundingBox&amp; bb);
+  autoware_msgs::DetectedObject getNearestObject(UKF&amp; target,
+                                                 const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec);
   void updateBehaviorState(const UKF&amp; target, autoware_msgs::DetectedObject&amp; object);
 
   void initTracker(const autoware_msgs::DetectedObjectArray&amp; input, double timestamp);
@@ -141,29 +141,58 @@ private:
 
   void updateTrackingNum(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, UKF&amp; target);
 
-  void probabilisticDataAssociation(const autoware_msgs::DetectedObjectArray&amp; input, const double dt,
+  bool probabilisticDataAssociation(const autoware_msgs::DetectedObjectArray&amp; input, const double dt,
                                     std::vector&lt;bool&gt;&amp; matching_vec,
-                                    std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; lambda_vec, UKF&amp; target,
-                                    bool&amp; is_skip_target);
+                                    std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, UKF&amp; target);
   void makeNewTargets(const double timestamp, const autoware_msgs::DetectedObjectArray&amp; input,
                       const std::vector&lt;bool&gt;&amp; matching_vec);
 
   void staticClassification();
 
   void makeOutput(const autoware_msgs::DetectedObjectArray&amp; input,
-                  jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
+                  const std::vector&lt;bool&gt;&amp; matching_vec,
                   autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
 
   void removeUnnecessaryTarget();
 
-  void pubDebugROSMarker(const autoware_msgs::DetectedObjectArray&amp; input);
-
   void dumpResultText(autoware_msgs::DetectedObjectArray&amp; detected_objects);
 
   void tracker(const autoware_msgs::DetectedObjectArray&amp; transformed_input,
-               jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                autoware_msgs::DetectedObjectArray&amp; detected_objects_output);
 
+  bool updateDirection(const double smallest_nis, const autoware_msgs::DetectedObject&amp; in_object,
+                           autoware_msgs::DetectedObject&amp; out_object, UKF&amp; target);
+
+  bool storeObjectWithNearestLaneDirection(const autoware_msgs::DetectedObject&amp; in_object,
+                                      autoware_msgs::DetectedObject&amp; out_object);
+
+  void checkVectormapSubscription();
+
+  autoware_msgs::DetectedObjectArray
+  removeRedundantObjects(const autoware_msgs::DetectedObjectArray&amp; in_detected_objects,
+                         const std::vector&lt;size_t&gt; in_tracker_indices);
+
+  autoware_msgs::DetectedObjectArray
+  forwardNonMatchedObject(const autoware_msgs::DetectedObjectArray&amp; tmp_objects,
+                          const autoware_msgs::DetectedObjectArray&amp;  input,
+                          const std::vector&lt;bool&gt;&amp; matching_vec);
+
+  bool
+  arePointsClose(const geometry_msgs::Point&amp; in_point_a,
+                 const geometry_msgs::Point&amp; in_point_b,
+                 float in_radius);
+
+  bool
+  arePointsEqual(const geometry_msgs::Point&amp; in_point_a,
+                 const geometry_msgs::Point&amp; in_point_b);
+
+  bool
+  isPointInPool(const std::vector&lt;geometry_msgs::Point&gt;&amp; in_pool,
+                const geometry_msgs::Point&amp; in_point);
+
+  void updateTargetWithAssociatedObject(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec,
+                                        UKF&amp; target);
+
 public:
   ImmUkfPda();
   void run();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\ukf.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\ukf.h" added_lines="61" deleted_lines="33">
				<diff>@@ -39,9 +39,6 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl/point_cloud.h&gt;
 
-#include &lt;geometry_msgs/PoseStamped.h&gt;
-#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
-
 #include "autoware_msgs/DetectedObject.h"
 
 enum TrackingState : int
@@ -49,6 +46,7 @@ enum TrackingState : int
   Die = 0,     // No longer tracking
   Init = 1,    // Start tracking
   Stable = 4,  // Stable tracking
+  Occlusion = 5, // Lost 1 frame possibly by occlusion
   Lost = 10,   // About to lose target
 };
 
@@ -70,8 +68,13 @@ class UKF
 public:
   int ukf_id_;
 
-  //* initially set to false, set to true in first call of ProcessMeasurement
-  bool is_initialized_;
+  int num_state_;
+
+  int num_lidar_state_;
+
+  int num_lidar_direction_state_;
+
+  int num_motion_model_;
 
   //* state vector: [pos1 pos2 vel_abs yaw_angle yaw_rate] in SI units and rad
   Eigen::MatrixXd x_merge_;
@@ -131,15 +134,9 @@ public:
   Eigen::VectorXd weights_c_;
   Eigen::VectorXd weights_s_;
 
-  //* State dimension
-  int n_x_;
-
   //* Sigma point spreading parameter
   double lambda_;
 
-  int count_;
-  int count_empty_;
-
   double mode_match_prob_cv2cv_;
   double mode_match_prob_ctrv2cv_;
   double mode_match_prob_rm2cv_;
@@ -186,28 +183,16 @@ public:
   int lifetime_;
   bool is_static_;
 
-  // bounding box params
-  bool is_vis_bb_;
-
-  jsk_recognition_msgs::BoundingBox jsk_bb_;
-  jsk_recognition_msgs::BoundingBox best_jsk_bb_;
-
-  bool is_best_jsk_bb_empty_;
-
-  double best_yaw_;
-  double bb_yaw_;
-  double bb_area_;
-  std::vector&lt;double&gt; bb_yaw_history_;
-  std::vector&lt;double&gt; bb_vel_history_;
-  std::vector&lt;double&gt; bb_area_history_;
+  // object msg information
+  bool is_stable_;
+  autoware_msgs::DetectedObject object_;
+  std::string label_;
+  double min_assiciation_distance_;
 
   // for env classification
   Eigen::VectorXd init_meas_;
   std::vector&lt;double&gt; vel_history_;
 
-  std::vector&lt;Eigen::VectorXd&gt; local2local_;
-  std::vector&lt;double&gt; local2localYawVec_;
-
   double x_merge_yaw_;
 
   int tracking_num_;
@@ -244,6 +229,29 @@ public:
   Eigen::MatrixXd new_s_ctrv_;
   Eigen::MatrixXd new_s_rm_;
 
+  // for lane direction combined filter
+  bool is_direction_cv_available_;
+  bool is_direction_ctrv_available_;
+  bool is_direction_rm_available_;
+  double std_lane_direction_;
+  Eigen::MatrixXd lidar_direction_r_cv_;
+  Eigen::MatrixXd lidar_direction_r_ctrv_;
+  Eigen::MatrixXd lidar_direction_r_rm_;
+
+  Eigen::VectorXd z_pred_lidar_direction_cv_;
+  Eigen::VectorXd z_pred_lidar_direction_ctrv_;
+  Eigen::VectorXd z_pred_lidar_direction_rm_;
+
+  Eigen::MatrixXd s_lidar_direction_cv_;
+  Eigen::MatrixXd s_lidar_direction_ctrv_;
+  Eigen::MatrixXd s_lidar_direction_rm_;
+
+  Eigen::MatrixXd k_lidar_direction_cv_;
+  Eigen::MatrixXd k_lidar_direction_ctrv_;
+  Eigen::MatrixXd k_lidar_direction_rm_;
+
+  Eigen::VectorXd lidar_direction_ctrv_meas_;
+
   /**
    * Constructor
    */
@@ -261,13 +269,15 @@ public:
 
   void interaction();
 
-  void predictionSUKF(const double dt);
+  void predictionSUKF(const double dt, const bool has_subscribed_vectormap);
 
-  void predictionIMMUKF(const double dt);
+  void predictionIMMUKF(const double dt, const bool has_subscribed_vectormap);
 
   void findMaxZandS(Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s);
 
-  void updateLikelyMeasurementForCTRV(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec);
+  void updateMeasurementForCTRV(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec);
+
+  void uppateForCTRV();
 
   void updateEachMotion(const double detection_probability, const double gate_probability, const double gating_thres,
                         const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, std::vector&lt;double&gt;&amp; lambda_vec);
@@ -288,9 +298,27 @@ public:
 
   void initCovarQs(const double dt, const double yaw);
 
-  void prediction(const double delta_t, const int model_ind);
+  void predictionMotion(const double delta_t, const int model_ind);
+
+  void checkLaneDirectionAvailability(const autoware_msgs::DetectedObject&amp; in_object,
+                                      const double lane_direction_chi_thres, const bool use_sukf);
+
+  void predictionLidarMeasurement(const int motion_ind, const int num_meas_state);
+
+  double calculateNIS(const autoware_msgs::DetectedObject&amp; in_object, const int motion_ind);
+
+  bool isLaneDirectionAvailable(const autoware_msgs::DetectedObject&amp; in_object, const int motion_ind,
+                                const double lane_direction_chi_thres);
+
+  // void updateKalmanGain(const int motion_ind, const int num_meas_state);
+  void updateKalmanGain(const int motion_ind);
+
+  double normalizeAngle(const double angle);
+
+  void update(const bool use_sukf, const double detection_probability, const double gate_probability,
+              const double gating_thres, const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec);
 
-  void updateLidar(const int model_ind);
+  void prediction(const bool use_sukf, const bool has_subscribed_vectormap, const double dt);
 };
 
 #endif /* UKF_H */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\visualize_detected_objects.h" new_path="" added_lines="0" deleted_lines="71">
				<diff>@@ -1,71 +0,0 @@
-/*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef OBJECT_TRACKING_VISUALIZEDETECTEDOBJECTS_H
-#define OBJECT_TRACKING_VISUALIZEDETECTEDOBJECTS_H
-
-#include &lt;ros/ros.h&gt;
-#include &lt;std_msgs/Header.h&gt;
-
-#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
-#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-
-#include &lt;pcl/io/io.h&gt;
-
-#include &lt;vector&gt;
-#include &lt;string&gt;
-
-#include "autoware_msgs/DetectedObject.h"
-#include "autoware_msgs/DetectedObjectArray.h"
-
-class VisualizeDetectedObjects
-{
-private:
-  const double vis_arrow_height_;
-  const double vis_id_height_;
-  double ignore_velocity_thres_;
-  double visualize_arrow_velocity_thres_;
-  std::string input_topic_;
-  std::string pointcloud_frame_;
-
-  ros::NodeHandle node_handle_;
-  ros::Subscriber sub_object_array_;
-
-  ros::Publisher pub_arrow_;
-  ros::Publisher pub_id_;
-
-  void visMarkers(const autoware_msgs::DetectedObjectArray&amp; input);
-  void callBack(const autoware_msgs::DetectedObjectArray&amp; input);
-
-public:
-  VisualizeDetectedObjects();
-};
-
-#endif  // OBJECT_TRACKING_VISUALIZEDETECTEDOBJECTS_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda.cpp" added_lines="390" deleted_lines="439">
				<diff>@@ -28,35 +28,38 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include &lt;chrono&gt;
-#include &lt;stdio.h&gt;
-#include &lt;ros/package.h&gt;
-#include &lt;pcl_conversions/pcl_conversions.h&gt;
+
 #include "imm_ukf_pda.h"
 
 ImmUkfPda::ImmUkfPda()
   : target_id_(0)
   ,  // assign unique ukf_id_ to each tracking targets
   init_(false),
-  frame_count_(0)
+  frame_count_(0),
+  has_subscribed_vectormap_(false),
+  private_nh_("~")
 {
-  ros::NodeHandle private_nh_("~");
-  private_nh_.param&lt;std::string&gt;("pointcloud_frame", pointcloud_frame_, "velodyne");
   private_nh_.param&lt;std::string&gt;("tracking_frame", tracking_frame_, "world");
   private_nh_.param&lt;int&gt;("life_time_thres", life_time_thres_, 8);
   private_nh_.param&lt;double&gt;("gating_thres", gating_thres_, 9.22);
   private_nh_.param&lt;double&gt;("gate_probability", gate_probability_, 0.99);
   private_nh_.param&lt;double&gt;("detection_probability", detection_probability_, 0.9);
-  private_nh_.param&lt;double&gt;("distance_thres", distance_thres_, 99);
   private_nh_.param&lt;double&gt;("static_velocity_thres", static_velocity_thres_, 0.5);
+  private_nh_.param&lt;int&gt;("static_velocity_history_thres", static_num_history_thres_, 3);
   private_nh_.param&lt;double&gt;("prevent_explosion_thres", prevent_explosion_thres_, 1000);
+  private_nh_.param&lt;double&gt;("merge_distance_threshold", merge_distance_threshold_, 0.5);
   private_nh_.param&lt;bool&gt;("use_sukf", use_sukf_, false);
-  private_nh_.param&lt;bool&gt;("is_debug", is_debug_, false);
+
+  // for vectormap assisted tracking
+  private_nh_.param&lt;bool&gt;("use_vectormap", use_vectormap_, false);
+  private_nh_.param&lt;double&gt;("lane_direction_chi_thres", lane_direction_chi_thres_, 2.71);
+  private_nh_.param&lt;double&gt;("nearest_lane_distance_thres", nearest_lane_distance_thres_, 1.0);
+  private_nh_.param&lt;std::string&gt;("vectormap_frame", vectormap_frame_, "map");
 
   // rosparam for benchmark
   private_nh_.param&lt;bool&gt;("is_benchmark", is_benchmark_, false);
-  private_nh_.param&lt;std::string&gt;("kitti_data_dir", kitti_data_dir_, "/home/hoge/kitti/2011_09_26/2011_09_26_drive_0005_sync/");
-  if(is_benchmark_)
+  private_nh_.param&lt;std::string&gt;("kitti_data_dir", kitti_data_dir_, "");
+  if (is_benchmark_)
   {
     result_file_path_ = kitti_data_dir_ + "benchmark_results.txt";
     std::remove(result_file_path_.c_str());
@@ -65,136 +68,135 @@ ImmUkfPda::ImmUkfPda()
 
 void ImmUkfPda::run()
 {
-  pub_jskbbox_array_ =
-      node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/detection/lidar_tracker/bounding_boxes", 1);
-  pub_object_array_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/lidar_tracker/objects", 1);
+  pub_object_array_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/objects", 1);
+  sub_detected_array_ = node_handle_.subscribe("/detection/fusion_tools/objects", 1, &amp;ImmUkfPda::callback, this);
 
-  // for debug
-  pub_points_array_ =
-      node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;("/detection/lidar_tracker/debug_points_markers", 1);
-  pub_texts_array_ =
-      node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;("/detection/lidar_tracker/debug_texts_markers", 1);
-
-  sub_detected_array_ = node_handle_.subscribe("/detection/lidar_objects", 1, &amp;ImmUkfPda::callback, this);
+  if (use_vectormap_)
+  {
+    vmap_.subscribe(private_nh_, vector_map::Category::POINT |
+                                 vector_map::Category::NODE  |
+                                 vector_map::Category::LANE, 1);
+  }
 }
 
 void ImmUkfPda::callback(const autoware_msgs::DetectedObjectArray&amp; input)
 {
+  input_header_ = input.header;
+
+  if(use_vectormap_)
+  {
+    checkVectormapSubscription();
+  }
+
+  bool success = updateNecessaryTransform();
+  if (!success)
+  {
+    ROS_INFO("Could not find coordiante transformation");
+    return;
+  }
+
   autoware_msgs::DetectedObjectArray transformed_input;
-  jsk_recognition_msgs::BoundingBoxArray jskbboxes_output;
   autoware_msgs::DetectedObjectArray detected_objects_output;
-
-  // only transform pose(clusteArray.clusters.bouding_box.pose)
   transformPoseToGlobal(input, transformed_input);
-  tracker(transformed_input, jskbboxes_output, detected_objects_output);
-  transformPoseToLocal(jskbboxes_output, detected_objects_output);
-  pub_jskbbox_array_.publish(jskbboxes_output);
+  tracker(transformed_input, detected_objects_output);
+  transformPoseToLocal(detected_objects_output);
+
   pub_object_array_.publish(detected_objects_output);
 
-  if(is_benchmark_)
+  if (is_benchmark_)
   {
     dumpResultText(detected_objects_output);
   }
 }
 
-void ImmUkfPda::relayJskbbox(const autoware_msgs::DetectedObjectArray&amp; input,
-                             jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output)
+void ImmUkfPda::checkVectormapSubscription()
 {
-  jskbboxes_output.header = input.header;
-  for (size_t i = 0; i &lt; input.objects.size(); i++)
+  if (use_vectormap_ &amp;&amp; !has_subscribed_vectormap_)
   {
-    jsk_recognition_msgs::BoundingBox bb;
-    bb.header = input.header;
-    bb.pose = input.objects[i].pose;
-    bb.dimensions = input.objects[i].dimensions;
-    jskbboxes_output.boxes.push_back(bb);
+    lanes_ = vmap_.findByFilter([](const vector_map_msgs::Lane&amp; lane) { return true; });
+    if (lanes_.empty())
+    {
+      ROS_INFO("Has not subscribed vectormap");
+    }
+    else
+    {
+      has_subscribed_vectormap_ = true;
+    }
   }
 }
 
-void ImmUkfPda::transformPoseToGlobal(const autoware_msgs::DetectedObjectArray&amp; input,
-                                      autoware_msgs::DetectedObjectArray&amp; transformed_input)
+bool ImmUkfPda::updateNecessaryTransform()
 {
+  bool success = true;
   try
   {
-    tf_listener_.waitForTransform(pointcloud_frame_, tracking_frame_, ros::Time(0), ros::Duration(1.0));
-    // get sensor -&gt; world frame
-    tf_listener_.lookupTransform(tracking_frame_, pointcloud_frame_, ros::Time(0), local2global_);
+    tf_listener_.waitForTransform(input_header_.frame_id, tracking_frame_, ros::Time(0), ros::Duration(1.0));
+    tf_listener_.lookupTransform(tracking_frame_, input_header_.frame_id, ros::Time(0), local2global_);
   }
   catch (tf::TransformException ex)
   {
     ROS_ERROR("%s", ex.what());
-    ros::Duration(1.0).sleep();
+    success = false;
   }
-
-  transformed_input.header = input.header;
-  for (size_t i = 0; i &lt; input.objects.size(); i++)
+  if (use_vectormap_ &amp;&amp; has_subscribed_vectormap_)
   {
-    geometry_msgs::PoseStamped pose_in, pose_out;
+    try
+    {
+      tf_listener_.waitForTransform(vectormap_frame_, tracking_frame_, ros::Time(0), ros::Duration(1.0));
+      tf_listener_.lookupTransform(vectormap_frame_, tracking_frame_, ros::Time(0), tracking_frame2lane_frame_);
+      tf_listener_.lookupTransform(tracking_frame_, vectormap_frame_, ros::Time(0), lane_frame2tracking_frame_);
+    }
+    catch (tf::TransformException ex)
+    {
+      ROS_ERROR("%s", ex.what());
+    }
+  }
+  return success;
+}
 
-    pose_in.header = input.header;
-    pose_in.pose = input.objects[i].pose;
-    tf::Transform input_object_pose;
-    input_object_pose.setOrigin(tf::Vector3(input.objects[i].pose.position.x, input.objects[i].pose.position.y,
-                                            input.objects[i].pose.position.z));
-    input_object_pose.setRotation(
-        tf::Quaternion(input.objects[i].pose.orientation.x, input.objects[i].pose.orientation.y,
-                       input.objects[i].pose.orientation.z, input.objects[i].pose.orientation.w));
-    tf::poseTFToMsg(local2global_ * input_object_pose, pose_out.pose);
+void ImmUkfPda::transformPoseToGlobal(const autoware_msgs::DetectedObjectArray&amp; input,
+                                      autoware_msgs::DetectedObjectArray&amp; transformed_input)
+{
+  transformed_input.header = input_header_;
+  for (auto const &amp;object: input.objects)
+  {
+    geometry_msgs::Pose out_pose = getTransformedPose(object.pose, local2global_);
 
     autoware_msgs::DetectedObject dd;
     dd.header = input.header;
-    dd = input.objects[i];
-    dd.pose = pose_out.pose;
+    dd = object;
+    dd.pose = out_pose;
 
     transformed_input.objects.push_back(dd);
   }
 }
 
-void ImmUkfPda::transformPoseToLocal(jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
-                                     autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
+void ImmUkfPda::transformPoseToLocal(autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
 {
-  for (size_t i = 0; i &lt; detected_objects_output.objects.size(); i++)
-  {
-    geometry_msgs::PoseStamped detected_pose_in, detected_pose_out;
+  detected_objects_output.header = input_header_;
 
-    detected_pose_in.header = jskbboxes_output.header;
-    detected_pose_in.header.frame_id = tracking_frame_;
-    detected_pose_in.pose = detected_objects_output.objects[i].pose;
-
-    tf::Transform output_object_pose;
-    output_object_pose.setOrigin(tf::Vector3(detected_objects_output.objects[i].pose.position.x,
-                                             detected_objects_output.objects[i].pose.position.y,
-                                             detected_objects_output.objects[i].pose.position.z));
-    output_object_pose.setRotation(tf::Quaternion(
-        detected_objects_output.objects[i].pose.orientation.x, detected_objects_output.objects[i].pose.orientation.y,
-        detected_objects_output.objects[i].pose.orientation.z, detected_objects_output.objects[i].pose.orientation.w));
-    tf::poseTFToMsg(local2global_.inverse() * output_object_pose, detected_pose_out.pose);
-
-    detected_objects_output.objects[i].header.frame_id = pointcloud_frame_;
-    detected_objects_output.objects[i].pose = detected_pose_out.pose;
-  }
-  detected_objects_output.header.frame_id = pointcloud_frame_;
-
-  for (size_t i = 0; i &lt; jskbboxes_output.boxes.size(); i++)
+  tf::Transform inv_local2global = local2global_.inverse();
+  tf::StampedTransform global2local;
+  global2local.setData(inv_local2global);
+  for (auto&amp; object : detected_objects_output.objects)
   {
-    geometry_msgs::PoseStamped jsk_pose_in, jsk_pose_out;
-    jsk_pose_in.header = jskbboxes_output.header;
-    jsk_pose_in.header.frame_id = tracking_frame_;
-    jsk_pose_in.pose = jskbboxes_output.boxes[i].pose;
-
-    tf::Transform output_bbox_pose;
-    output_bbox_pose.setOrigin(tf::Vector3(jskbboxes_output.boxes[i].pose.position.x,
-                                           jskbboxes_output.boxes[i].pose.position.y,
-                                           jskbboxes_output.boxes[i].pose.position.z));
-    output_bbox_pose.setRotation(
-        tf::Quaternion(jskbboxes_output.boxes[i].pose.orientation.x, jskbboxes_output.boxes[i].pose.orientation.y,
-                       jskbboxes_output.boxes[i].pose.orientation.z, jskbboxes_output.boxes[i].pose.orientation.w));
-    tf::poseTFToMsg(local2global_.inverse() * output_bbox_pose, jsk_pose_out.pose);
-
-    jskbboxes_output.boxes[i].header.frame_id = pointcloud_frame_;
-    jskbboxes_output.boxes[i].pose = jsk_pose_out.pose;
+    geometry_msgs::Pose out_pose = getTransformedPose(object.pose, global2local);
+    object.header = input_header_;
+    object.pose = out_pose;
   }
-  jskbboxes_output.header.frame_id = pointcloud_frame_;
+}
+
+geometry_msgs::Pose ImmUkfPda::getTransformedPose(const geometry_msgs::Pose&amp; in_pose,
+                                                  const tf::StampedTransform&amp; tf_stamp)
+{
+  tf::Transform transform;
+  geometry_msgs::PoseStamped out_pose;
+  transform.setOrigin(tf::Vector3(in_pose.position.x, in_pose.position.y, in_pose.position.z));
+  transform.setRotation(
+      tf::Quaternion(in_pose.orientation.x, in_pose.orientation.y, in_pose.orientation.z, in_pose.orientation.w));
+  geometry_msgs::PoseStamped pose_out;
+  tf::poseTFToMsg(tf_stamp * transform, out_pose.pose);
+  return out_pose.pose;
 }
 
 void ImmUkfPda::measurementValidation(const autoware_msgs::DetectedObjectArray&amp; input, UKF&amp; target,
@@ -205,9 +207,9 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::DetectedObjectArray&amp;
 {
   // alert: different from original imm-pda filter, here picking up most likely measurement
   // if making it allows to have more than one measurement, you will see non semipositive definite covariance
-  bool second_init_done = false;
+  bool exists_smallest_nis_object = false;
   double smallest_nis = std::numeric_limits&lt;double&gt;::max();
-  autoware_msgs::DetectedObject smallest_meas_object;
+  int smallest_nis_ind = 0;
   for (size_t i = 0; i &lt; input.objects.size(); i++)
   {
     double x = input.objects[i].pose.position.x;
@@ -220,170 +222,131 @@ void ImmUkfPda::measurementValidation(const autoware_msgs::DetectedObjectArray&amp;
     double nis = diff.transpose() * max_det_s.inverse() * diff;
 
     if (nis &lt; gating_thres_)
-    {  // x^2 99% range
-      if (matching_vec[i] == false)
-      {
-        target.lifetime_++;
-      }
-
+    {
       if (nis &lt; smallest_nis)
       {
         smallest_nis = nis;
-        smallest_meas_object = input.objects[i];
-        matching_vec[i] = true;
-        second_init_done = true;
+        target.object_ = input.objects[i];
+        smallest_nis_ind = i;
+        exists_smallest_nis_object = true;
       }
     }
   }
-  if (second_init_done)
+  if (exists_smallest_nis_object)
   {
-    object_vec.push_back(smallest_meas_object);
-  }
-}
-
-void ImmUkfPda::getNearestEuclidCluster(const UKF&amp; target, const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec,
-                                        autoware_msgs::DetectedObject&amp; object, double&amp; min_dist)
-{
-  int min_ind = 0;
-  double px = target.x_merge_(0);
-  double py = target.x_merge_(1);
-
-  for (size_t i = 0; i &lt; object_vec.size(); i++)
-  {
-    double meas_x = object_vec[i].pose.position.x;
-    double meas_y = object_vec[i].pose.position.y;
-
-    double dist = sqrt((px - meas_x) * (px - meas_x) + (py - meas_y) * (py - meas_y));
-    if (dist &lt; min_dist)
+    matching_vec[smallest_nis_ind] = true;
+    if (use_vectormap_ &amp;&amp; has_subscribed_vectormap_)
     {
-      min_dist = dist;
-      min_ind = i;
+      autoware_msgs::DetectedObject direction_updated_object;
+      bool use_direction_meas =
+          updateDirection(smallest_nis, target.object_, direction_updated_object, target);
+      if (use_direction_meas)
+      {
+        object_vec.push_back(direction_updated_object);
+      }
+      else
+      {
+        object_vec.push_back(target.object_);
+      }
+    }
+    else
+    {
+      object_vec.push_back(target.object_);
     }
   }
-
-  object = object_vec[min_ind];
 }
 
-void ImmUkfPda::associateBB(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, UKF&amp; target)
+bool ImmUkfPda::updateDirection(const double smallest_nis, const autoware_msgs::DetectedObject&amp; in_object,
+                                    autoware_msgs::DetectedObject&amp; out_object, UKF&amp; target)
 {
-  // skip if no validated measurement
-  if (object_vec.size() == 0)
+  bool use_lane_direction = false;
+  target.is_direction_cv_available_ = false;
+  target.is_direction_ctrv_available_ = false;
+  bool get_lane_success = storeObjectWithNearestLaneDirection(in_object, out_object);
+  if (!get_lane_success)
   {
-    return;
-  }
-  if (target.tracking_num_ == TrackingState::Stable &amp;&amp; target.lifetime_ &gt;= life_time_thres_)
-  {
-    autoware_msgs::DetectedObject nearest_object;
-    double min_dist = std::numeric_limits&lt;double&gt;::max();
-    getNearestEuclidCluster(target, object_vec, nearest_object, min_dist);
-    if (min_dist &lt; distance_thres_)
-    {
-      target.is_vis_bb_ = true;
-      target.jsk_bb_.pose = nearest_object.pose;
-      target.jsk_bb_.dimensions = nearest_object.dimensions;
-    }
+    return use_lane_direction;
   }
-  else
+  target.checkLaneDirectionAvailability(out_object, lane_direction_chi_thres_, use_sukf_);
+  if (target.is_direction_cv_available_ || target.is_direction_ctrv_available_)
   {
-    autoware_msgs::DetectedObject nearest_object;
-    double min_dist = std::numeric_limits&lt;double&gt;::max();
-    getNearestEuclidCluster(target, object_vec, nearest_object, min_dist);
-    target.jsk_bb_.pose = nearest_object.pose;
-    target.jsk_bb_.dimensions = nearest_object.dimensions;
+    use_lane_direction = true;
   }
+  return use_lane_direction;
 }
 
-double ImmUkfPda::getJskBBoxYaw(const jsk_recognition_msgs::BoundingBox&amp; jsk_bb)
+bool ImmUkfPda::storeObjectWithNearestLaneDirection(const autoware_msgs::DetectedObject&amp; in_object,
+                                                 autoware_msgs::DetectedObject&amp; out_object)
 {
-  tf::Quaternion q(jsk_bb.pose.orientation.x, jsk_bb.pose.orientation.y, jsk_bb.pose.orientation.z,
-                   jsk_bb.pose.orientation.w);
-  double roll, pitch, yaw;
-  tf::Matrix3x3(q).getRPY(roll, pitch, yaw);
-  return yaw;
-}
-
-double ImmUkfPda::getJskBBoxArea(const jsk_recognition_msgs::BoundingBox&amp; jsk_bb)
-{
-  double area = jsk_bb.dimensions.x * jsk_bb.dimensions.y;
-  return area;
-}
+  geometry_msgs::Pose lane_frame_pose = getTransformedPose(in_object.pose, tracking_frame2lane_frame_);
+  double min_dist = std::numeric_limits&lt;double&gt;::max();
 
-void ImmUkfPda::updateBB(UKF&amp; target)
-{
-  // skip to prevent memory leak by accessing empty target.bbox_
-  if (!target.is_vis_bb_)
+  double min_yaw = 0;
+  for (auto const&amp; lane : lanes_)
   {
-    return;
-  }
-  double yaw = getJskBBoxYaw(target.jsk_bb_);
-
-  // skip the rest of process if it is first bbox associaiton
-  if (target.is_best_jsk_bb_empty_ == false)
-  {
-    target.best_jsk_bb_ = target.jsk_bb_;
-    target.best_yaw_ = yaw;
-    target.is_best_jsk_bb_empty_ = true;
-    return;
+    vector_map_msgs::Node node = vmap_.findByKey(vector_map::Key&lt;vector_map_msgs::Node&gt;(lane.bnid));
+    vector_map_msgs::Point point = vmap_.findByKey(vector_map::Key&lt;vector_map_msgs::Point&gt;(node.pid));
+    double distance = std::sqrt(std::pow(point.bx - lane_frame_pose.position.y, 2) +
+                                std::pow(point.ly - lane_frame_pose.position.x, 2));
+    if (distance &lt; min_dist)
+    {
+      min_dist = distance;
+      vector_map_msgs::Node front_node = vmap_.findByKey(vector_map::Key&lt;vector_map_msgs::Node&gt;(lane.fnid));
+      vector_map_msgs::Point front_point = vmap_.findByKey(vector_map::Key&lt;vector_map_msgs::Point&gt;(front_node.pid));
+      min_yaw = std::atan2((front_point.bx - point.bx), (front_point.ly - point.ly));
+    }
   }
 
-  // restricting yaw movement
-  double diff_yaw = yaw - target.best_yaw_;
-
-  // diffYaw is within the threshold, apply the diffYaw chamge
-  if (abs(diff_yaw) &lt; bb_yaw_change_thres_)
+  bool success = false;
+  if (min_dist &lt; nearest_lane_distance_thres_)
   {
-    target.best_jsk_bb_.pose.orientation = target.jsk_bb_.pose.orientation;
-    target.best_yaw_ = yaw;
+    success = true;
   }
   else
   {
-    target.jsk_bb_.pose.orientation = target.best_jsk_bb_.pose.orientation;
+    return success;
   }
 
-  // // bbox area
-  double area = getJskBBoxArea(target.jsk_bb_);
-  double best_area = getJskBBoxArea(target.best_jsk_bb_);
+  // map yaw in rotation matrix representation
+  tf::Quaternion map_quat = tf::createQuaternionFromYaw(min_yaw);
+  tf::Matrix3x3 map_matrix(map_quat);
 
-  // start updating bbox params
-  double delta_area = area - best_area;
+  // vectormap_frame to tracking_frame rotation matrix
+  tf::Quaternion rotation_quat = lane_frame2tracking_frame_.getRotation();
+  tf::Matrix3x3 rotation_matrix(rotation_quat);
 
-  // when the delta area is under 0, keep best area and relocate(slide) it for current cp
-  if (delta_area &lt; 0)
-  {
-    // updateVisBoxArea(target, dtCP);
-    target.jsk_bb_.dimensions = target.best_jsk_bb_.dimensions;
-    // for  mergeSegmentation, area comparison
-    target.bb_area_ = best_area;
-  }
-  else if (delta_area &gt; 0)
-  {
-    // target.bestBBox_ = target.BBox_;
-    target.best_jsk_bb_.dimensions = target.jsk_bb_.dimensions;
-    // for mergeSegmentation, area comparison
-    target.bb_area_ = area;
-  }
+  // rotated yaw in matrix representation
+  tf::Matrix3x3 rotated_matrix = rotation_matrix * map_matrix;
+  double roll, pitch, yaw;
+  rotated_matrix.getRPY(roll, pitch, yaw);
+
+  out_object = in_object;
+  out_object.angle = yaw;
+  return success;
 }
 
-void ImmUkfPda::updateJskLabel(const UKF&amp; target, jsk_recognition_msgs::BoundingBox&amp; bb)
+void ImmUkfPda::updateTargetWithAssociatedObject(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec,
+                                                 UKF&amp; target)
 {
-  int tracking_num = target.tracking_num_;
-  if (target.is_static_)
+  target.lifetime_++;
+  if (!target.object_.label.empty() &amp;&amp; target.object_.label !="unknown")
   {
-    bb.label = 15;  // white color
+    target.label_ = target.object_.label;
   }
-  else if (tracking_num == TrackingState::Stable)
+  updateTrackingNum(object_vec, target);
+  if (target.tracking_num_ == TrackingState::Stable || target.tracking_num_ == TrackingState::Occlusion)
   {
-    bb.label = 2;  // orange color
+    target.is_stable_ = true;
   }
 }
 
 void ImmUkfPda::updateBehaviorState(const UKF&amp; target, autoware_msgs::DetectedObject&amp; object)
 {
-  if(target.mode_prob_cv_ &gt; target.mode_prob_ctrv_ &amp;&amp; target.mode_prob_cv_ &gt; target.mode_prob_rm_)
+  if (target.mode_prob_cv_ &gt; target.mode_prob_ctrv_ &amp;&amp; target.mode_prob_cv_ &gt; target.mode_prob_rm_)
   {
     object.behavior_state = MotionModel::CV;
   }
-  else if(target.mode_prob_ctrv_ &gt; target.mode_prob_cv_ &amp;&amp; target.mode_prob_ctrv_ &gt; target.mode_prob_rm_)
+  else if (target.mode_prob_ctrv_ &gt; target.mode_prob_cv_ &amp;&amp; target.mode_prob_ctrv_ &gt; target.mode_prob_rm_)
   {
     object.behavior_state = MotionModel::CTRV;
   }
@@ -409,7 +372,6 @@ void ImmUkfPda::initTracker(const autoware_msgs::DetectedObjectArray&amp; input, dou
   }
   timestamp_ = timestamp;
   init_ = true;
-  return;
 }
 
 void ImmUkfPda::secondInit(UKF&amp; target, const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, double dt)
@@ -441,8 +403,6 @@ void ImmUkfPda::secondInit(UKF&amp; target, const std::vector&lt;autoware_msgs::Detecte
   target.x_merge_(2) = target.x_cv_(2) = target.x_ctrv_(2) = target.x_rm_(2) = target_v;
   target.x_merge_(3) = target.x_cv_(3) = target.x_ctrv_(3) = target.x_rm_(3) = target_yaw;
 
-  // target.initCovarQs(dt, target_yaw);
-
   target.tracking_num_++;
   return;
 }
@@ -487,15 +447,14 @@ void ImmUkfPda::updateTrackingNum(const std::vector&lt;autoware_msgs::DetectedObjec
   return;
 }
 
-void ImmUkfPda::probabilisticDataAssociation(const autoware_msgs::DetectedObjectArray&amp; input, const double dt,
+bool ImmUkfPda::probabilisticDataAssociation(const autoware_msgs::DetectedObjectArray&amp; input, const double dt,
                                              std::vector&lt;bool&gt;&amp; matching_vec,
-                                             std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, UKF&amp; target,
-                                             bool&amp; is_skip_target)
+                                             std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec, UKF&amp; target)
 {
   double det_s = 0;
   Eigen::VectorXd max_det_z;
   Eigen::MatrixXd max_det_s;
-  is_skip_target = false;
+  bool success = true;
 
   if (use_sukf_)
   {
@@ -514,8 +473,8 @@ void ImmUkfPda::probabilisticDataAssociation(const autoware_msgs::DetectedObject
   if (std::isnan(det_s) || det_s &gt; prevent_explosion_thres_)
   {
     target.tracking_num_ = TrackingState::Die;
-    is_skip_target = true;
-    return;
+    success = false;
+    return success;
   }
 
   bool is_second_init;
@@ -528,29 +487,25 @@ void ImmUkfPda::probabilisticDataAssociation(const autoware_msgs::DetectedObject
     is_second_init = false;
   }
 
-  // measurement gating, get measVec, bboxVec, matchingVec through reference
+  // measurement gating
   measurementValidation(input, target, is_second_init, max_det_z, max_det_s, object_vec, matching_vec);
 
-  // bounding box association if target is stable :plus, right angle correction if its needed
-  // input: track number, bbox measurements, &amp;target
-  associateBB(object_vec, target);
-
   // second detection for a target: update v and yaw
   if (is_second_init)
   {
     secondInit(target, object_vec, dt);
-    is_skip_target = true;
-    return;
+    success = false;
+    return success;
   }
 
-  // update tracking number
-  updateTrackingNum(object_vec, target);
+  updateTargetWithAssociatedObject(object_vec, target);
 
   if (target.tracking_num_ == TrackingState::Die)
   {
-    is_skip_target = true;
-    return;
+    success = false;
+    return success;
   }
+  return success;
 }
 
 void ImmUkfPda::makeNewTargets(const double timestamp, const autoware_msgs::DetectedObjectArray&amp; input,
@@ -567,6 +522,7 @@ void ImmUkfPda::makeNewTargets(const double timestamp, const autoware_msgs::Dete
 
       UKF ukf;
       ukf.initialize(init_meas, timestamp, target_id_);
+      ukf.object_ = input.objects[i];
       targets_.push_back(ukf);
       target_id_++;
     }
@@ -577,19 +533,22 @@ void ImmUkfPda::staticClassification()
 {
   for (size_t i = 0; i &lt; targets_.size(); i++)
   {
-    targets_[i].vel_history_.push_back(targets_[i].x_merge_(2));
+    // targets_[i].x_merge_(2) is referred for estimated velocity
+    double current_velocity = std::abs(targets_[i].x_merge_(2));
+    targets_[i].vel_history_.push_back(current_velocity);
     if (targets_[i].tracking_num_ == TrackingState::Stable &amp;&amp; targets_[i].lifetime_ &gt; life_time_thres_)
     {
+      int index = 0;
       double sum_vel = 0;
       double avg_vel = 0;
-      for (int ind = 1; ind &lt; life_time_thres_; ind++)
+      for (auto rit = targets_[i].vel_history_.rbegin(); index &lt; static_num_history_thres_; ++rit)
       {
-        sum_vel += targets_[i].vel_history_.end()[-ind];
+        index++;
+        sum_vel += *rit;
       }
-      avg_vel = double(sum_vel / life_time_thres_);
+      avg_vel = double(sum_vel / static_num_history_thres_);
 
-      if ((avg_vel &lt; static_velocity_thres_) &amp;&amp; (targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_cv_ ||
-                                                 targets_[i].mode_prob_rm_ &gt; targets_[i].mode_prob_ctrv_))
+      if(avg_vel &lt; static_velocity_thres_ &amp;&amp; current_velocity &lt; static_velocity_thres_)
       {
         targets_[i].is_static_ = true;
       }
@@ -597,52 +556,176 @@ void ImmUkfPda::staticClassification()
   }
 }
 
+bool
+ImmUkfPda::arePointsClose(const geometry_msgs::Point&amp; in_point_a,
+                                const geometry_msgs::Point&amp; in_point_b,
+                                float in_radius)
+{
+  return (fabs(in_point_a.x - in_point_b.x) &lt;= in_radius) &amp;&amp; (fabs(in_point_a.y - in_point_b.y) &lt;= in_radius);
+}
+
+bool
+ImmUkfPda::arePointsEqual(const geometry_msgs::Point&amp; in_point_a,
+                               const geometry_msgs::Point&amp; in_point_b)
+{
+  return arePointsClose(in_point_a, in_point_b, CENTROID_DISTANCE);
+}
+
+bool
+ImmUkfPda::isPointInPool(const std::vector&lt;geometry_msgs::Point&gt;&amp; in_pool,
+                          const geometry_msgs::Point&amp; in_point)
+{
+  for(size_t j=0; j&lt;in_pool.size(); j++)
+  {
+    if (arePointsEqual(in_pool[j], in_point))
+    {
+      return true;
+    }
+  }
+  return false;
+}
+
+autoware_msgs::DetectedObjectArray
+ImmUkfPda::removeRedundantObjects(const autoware_msgs::DetectedObjectArray&amp; in_detected_objects,
+                            const std::vector&lt;size_t&gt; in_tracker_indices)
+{
+  if (in_detected_objects.objects.size() != in_tracker_indices.size())
+    return in_detected_objects;
+
+  autoware_msgs::DetectedObjectArray resulting_objects;
+  resulting_objects.header = in_detected_objects.header;
+
+  std::vector&lt;geometry_msgs::Point&gt; centroids;
+  //create unique points
+  for(size_t i=0; i&lt;in_detected_objects.objects.size(); i++)
+  {
+    if(!isPointInPool(centroids, in_detected_objects.objects[i].pose.position))
+    {
+      centroids.push_back(in_detected_objects.objects[i].pose.position);
+    }
+  }
+  //assign objects to the points
+  std::vector&lt;std::vector&lt;size_t&gt;&gt; matching_objects(centroids.size());
+  for(size_t k=0; k&lt;in_detected_objects.objects.size(); k++)
+  {
+    const auto&amp; object=in_detected_objects.objects[k];
+    for(size_t i=0; i&lt; centroids.size(); i++)
+    {
+      if (arePointsClose(object.pose.position, centroids[i], merge_distance_threshold_))
+      {
+        matching_objects[i].push_back(k);//store index of matched object to this point
+      }
+    }
+  }
+  //get oldest object on each point
+  for(size_t i=0; i&lt; matching_objects.size(); i++)
+  {
+    size_t oldest_object_index = 0;
+    int oldest_lifespan = -1;
+    std::string best_label;
+    for(size_t j=0; j&lt;matching_objects[i].size(); j++)
+    {
+      size_t current_index = matching_objects[i][j];
+      int current_lifespan = targets_[in_tracker_indices[current_index]].lifetime_;
+      if (current_lifespan &gt; oldest_lifespan)
+      {
+        oldest_lifespan = current_lifespan;
+        oldest_object_index = current_index;
+      }
+      if (!targets_[in_tracker_indices[current_index]].label_.empty() &amp;&amp;
+        targets_[in_tracker_indices[current_index]].label_ != "unknown")
+      {
+        best_label = targets_[in_tracker_indices[current_index]].label_;
+      }
+    }
+    // delete nearby targets except for the oldest target
+    for(size_t j=0; j&lt;matching_objects[i].size(); j++)
+    {
+      size_t current_index = matching_objects[i][j];
+      if(current_index != oldest_object_index)
+      {
+        targets_[in_tracker_indices[current_index]].tracking_num_= TrackingState::Die;
+      }
+    }
+    autoware_msgs::DetectedObject best_object;
+    best_object = in_detected_objects.objects[oldest_object_index];
+    if (best_label != "unknown"
+        &amp;&amp; !best_label.empty())
+    {
+      best_object.label = best_label;
+    }
+
+    resulting_objects.objects.push_back(best_object);
+  }
+
+  return resulting_objects;
+
+}
+
 void ImmUkfPda::makeOutput(const autoware_msgs::DetectedObjectArray&amp; input,
-                           jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
+                           const std::vector&lt;bool&gt; &amp;matching_vec,
                            autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
 {
-  jskbboxes_output.header = input.header;
-  detected_objects_output.header = input.header;
+  autoware_msgs::DetectedObjectArray tmp_objects;
+  tmp_objects.header = input.header;
+  std::vector&lt;size_t&gt; used_targets_indices;
   for (size_t i = 0; i &lt; targets_.size(); i++)
   {
+
     double tx = targets_[i].x_merge_(0);
     double ty = targets_[i].x_merge_(1);
 
     double tv = targets_[i].x_merge_(2);
     double tyaw = targets_[i].x_merge_(3);
+    double tyaw_rate = targets_[i].x_merge_(4);
+
     while (tyaw &gt; M_PI)
       tyaw -= 2. * M_PI;
     while (tyaw &lt; -M_PI)
       tyaw += 2. * M_PI;
 
-    if (targets_[i].is_vis_bb_)
-    {
-      jsk_recognition_msgs::BoundingBox bb;
-      bb.header = input.header;
-      bb = targets_[i].jsk_bb_;
-      updateJskLabel(targets_[i], bb);
-      jskbboxes_output.boxes.push_back(bb);
-    }
-    // RPY to convert: 0, 0, targets_[i].x_merge_(3)
-    tf::Quaternion q = tf::createQuaternionFromRPY(0, 0, tyaw);
+    tf::Quaternion q = tf::createQuaternionFromYaw(tyaw);
+
     autoware_msgs::DetectedObject dd;
-    dd.header = input.header;
+    dd = targets_[i].object_;
     dd.id = targets_[i].ukf_id_;
     dd.velocity.linear.x = tv;
-    dd.pose = targets_[i].jsk_bb_.pose;
-    dd.pose.position.x = tx;
-    dd.pose.position.y = ty;
-    dd.pose.orientation.x = q[0];
-    dd.pose.orientation.y = q[1];
-    dd.pose.orientation.z = q[2];
-    dd.pose.orientation.w = q[3];
-    dd.dimensions = targets_[i].jsk_bb_.dimensions;
-    dd.pose_reliable = targets_[i].is_vis_bb_;
-    //store yaw rate for motion into dd.accerelation.linear.y
-    dd.acceleration.linear.y = targets_[i].x_merge_(4);
+    dd.acceleration.linear.y = tyaw_rate;
+    dd.velocity_reliable = targets_[i].is_stable_;
+    dd.pose_reliable = targets_[i].is_stable_;
+
+
+    if (!targets_[i].is_static_ &amp;&amp; targets_[i].is_stable_)
+    {
+      // Aligh the longest side of dimentions with the estimated orientation
+      if(targets_[i].object_.dimensions.x &lt; targets_[i].object_.dimensions.y)
+      {
+        dd.dimensions.x = targets_[i].object_.dimensions.y;
+        dd.dimensions.y = targets_[i].object_.dimensions.x;
+      }
+
+      dd.pose.position.x = tx;
+      dd.pose.position.y = ty;
+
+      if (!std::isnan(q[0]))
+        dd.pose.orientation.x = q[0];
+      if (!std::isnan(q[1]))
+        dd.pose.orientation.y = q[1];
+      if (!std::isnan(q[2]))
+        dd.pose.orientation.z = q[2];
+      if (!std::isnan(q[3]))
+        dd.pose.orientation.w = q[3];
+    }
     updateBehaviorState(targets_[i], dd);
-    detected_objects_output.objects.push_back(dd);
+
+    if (targets_[i].is_stable_ || (targets_[i].tracking_num_ &gt;= TrackingState::Init &amp;&amp;
+                                   targets_[i].tracking_num_ &lt; TrackingState::Stable))
+    {
+      tmp_objects.objects.push_back(dd);
+      used_targets_indices.push_back(i);
+    }
   }
+  detected_objects_output = removeRedundantObjects(tmp_objects, used_targets_indices);
 }
 
 void ImmUkfPda::removeUnnecessaryTarget()
@@ -659,170 +742,64 @@ void ImmUkfPda::removeUnnecessaryTarget()
   targets_ = temp_targets;
 }
 
-void ImmUkfPda::pubDebugROSMarker(const autoware_msgs::DetectedObjectArray&amp; input)
-{
-  visualization_msgs::MarkerArray texts_markers, points_markers;
-  visualization_msgs::Marker target_points, meas_points;
-  target_points.header.frame_id = meas_points.header.frame_id = "/world";
-  target_points.header.stamp = meas_points.header.stamp = input.header.stamp;
-  target_points.ns = meas_points.ns = "target_points";
-  target_points.action = meas_points.action = visualization_msgs::Marker::ADD;
-  target_points.pose.orientation.w = meas_points.pose.orientation.w = 1.0;
-
-  target_points.id = 0;
-  meas_points.id = 1;
-
-  target_points.type = meas_points.type = visualization_msgs::Marker::POINTS;
-
-  // POINTS markers use x and y scale for width/height respectively
-  target_points.scale.x = 0.4;
-  target_points.scale.y = 0.4;
-  meas_points.scale.x = 0.3;
-  meas_points.scale.y = 0.3;
-
-  // Points are green
-  target_points.color.r = 1.0f;
-  target_points.color.a = 1.0;
-  meas_points.color.g = 1.0f;
-  meas_points.color.a = 1.0;
-
-  // making rosmarker fot target
-  for (size_t i = 0; i &lt; targets_.size(); i++)
-  {
-    geometry_msgs::Point p;
-    p.x = targets_[i].x_merge_(0);
-    p.y = targets_[i].x_merge_(1);
-    p.z = 1.0;
-
-    target_points.points.push_back(p);
-
-    visualization_msgs::Marker id;
-    id.header.frame_id = "/world";
-    id.header.stamp = input.header.stamp;
-    id.ns = "target_points";
-    id.action = visualization_msgs::Marker::ADD;
-    id.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
-    id.id = targets_[i].ukf_id_ * 100;
-    id.lifetime = ros::Duration(0.1);
-
-    id.color.g = 1.0f;
-    id.color.a = 1.0;
-
-    // Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
-    id.pose.position.x = targets_[i].x_merge_(0);
-    id.pose.position.y = targets_[i].x_merge_(1);
-    id.pose.position.z = 2.5;
-
-    id.scale.z = 0.5;
-
-    double tv = targets_[i].x_merge_(2);
-    std::string s_velocity = std::to_string(tv * 3.6);
-    std::string modified_sv = s_velocity.substr(0, s_velocity.find(".") + 3);
-
-    std::string text = "&lt;" + std::to_string(targets_[i].ukf_id_) + "&gt;" + " " + std::to_string(targets_[i].x_merge_(2)) +
-                       " m/s " + "(" + std::to_string(targets_[i].x_merge_(0)) + ", " +
-                       std::to_string(targets_[i].x_merge_(1)) + ")";
-    id.text = text;
-    texts_markers.markers.push_back(id);
-  }
-
-  // making rosmarker fot measurement
-  for (size_t i = 0; i &lt; input.objects.size(); i++)
-  {
-    geometry_msgs::Point p;
-    p.x = input.objects[i].pose.position.x;
-    p.y = input.objects[i].pose.position.y;
-    p.z = 1.0;
-    meas_points.points.push_back(p);
-
-    visualization_msgs::Marker id;
-    id.header.frame_id = "/world";
-    id.header.stamp = input.header.stamp;
-    id.ns = "target_points";
-    id.action = visualization_msgs::Marker::ADD;
-    id.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
-    id.id = i;
-    id.lifetime = ros::Duration(0.1);
-
-    id.color.g = 1.0f;
-    id.color.a = 1.0;
-
-    id.pose.position.x = input.objects[i].pose.position.x;
-    id.pose.position.y = input.objects[i].pose.position.y;
-    id.pose.position.z = 1.5;
-
-    id.scale.z = 0.5;
-
-    std::string s_px = std::to_string(input.objects[i].pose.position.x);
-    std::string s_py = std::to_string(input.objects[i].pose.position.y);
-
-    std::string text = "(" + s_px + ", " + s_py + ")";
-    id.text = text;
-    texts_markers.markers.push_back(id);
-  }
-  points_markers.markers.push_back(target_points);
-  points_markers.markers.push_back(meas_points);
-
-  pub_points_array_.publish(points_markers);
-  pub_texts_array_.publish(texts_markers);
-}
-
 void ImmUkfPda::dumpResultText(autoware_msgs::DetectedObjectArray&amp; detected_objects)
 {
   std::ofstream outputfile(result_file_path_, std::ofstream::out | std::ofstream::app);
-  for(size_t i = 0; i &lt; detected_objects.objects.size(); i++)
+  for (size_t i = 0; i &lt; detected_objects.objects.size(); i++)
   {
     double yaw = tf::getYaw(detected_objects.objects[i].pose.orientation);
 
     // KITTI tracking benchmark data format:
-    // (frame_number,tracked_id, object type, truncation, occlusion, observation angle, x1,y1,x2,y2, h, w, l, cx, cy, cz, yaw)
+    // (frame_number,tracked_id, object type, truncation, occlusion, observation angle, x1,y1,x2,y2, h, w, l, cx, cy,
+    // cz, yaw)
     // x1, y1, x2, y2 are for 2D bounding box.
     // h, w, l, are for height, width, length respectively
     // cx, cy, cz are for object centroid
 
     // Tracking benchmark is based on frame_number, tracked_id,
     // bounding box dimentions and object pose(centroid and orientation) from bird-eye view
-    outputfile &lt;&lt; std::to_string(frame_count_)                               &lt;&lt;" "
-               &lt;&lt; std::to_string(detected_objects.objects[i].id)             &lt;&lt;" "
-               &lt;&lt; "Unknown"                                                  &lt;&lt;" "
-               &lt;&lt; "-1"                                                       &lt;&lt;" "
-               &lt;&lt; "-1"                                                       &lt;&lt;" "
-               &lt;&lt; "-1"                                                      &lt;&lt;" "
-               &lt;&lt; "-1 -1 -1 -1"                                              &lt;&lt;" "
-               &lt;&lt; std::to_string(detected_objects.objects[i].dimensions.x)   &lt;&lt;" "
-               &lt;&lt; std::to_string(detected_objects.objects[i].dimensions.y)   &lt;&lt;" "
-               &lt;&lt; "-1"                                                       &lt;&lt;" "
-               &lt;&lt; std::to_string(detected_objects.objects[i].pose.position.x)&lt;&lt;" "
-               &lt;&lt; std::to_string(detected_objects.objects[i].pose.position.y)&lt;&lt;" "
-               &lt;&lt; "-1"                                                       &lt;&lt;" "
-               &lt;&lt; std::to_string(yaw)                                        &lt;&lt;"\n";
-  }
-  frame_count_ ++;
+    outputfile &lt;&lt; std::to_string(frame_count_) &lt;&lt; " " &lt;&lt; std::to_string(detected_objects.objects[i].id) &lt;&lt; " "
+               &lt;&lt; "Unknown"
+               &lt;&lt; " "
+               &lt;&lt; "-1"
+               &lt;&lt; " "
+               &lt;&lt; "-1"
+               &lt;&lt; " "
+               &lt;&lt; "-1"
+               &lt;&lt; " "
+               &lt;&lt; "-1 -1 -1 -1"
+               &lt;&lt; " " &lt;&lt; std::to_string(detected_objects.objects[i].dimensions.x) &lt;&lt; " "
+               &lt;&lt; std::to_string(detected_objects.objects[i].dimensions.y) &lt;&lt; " "
+               &lt;&lt; "-1"
+               &lt;&lt; " " &lt;&lt; std::to_string(detected_objects.objects[i].pose.position.x) &lt;&lt; " "
+               &lt;&lt; std::to_string(detected_objects.objects[i].pose.position.y) &lt;&lt; " "
+               &lt;&lt; "-1"
+               &lt;&lt; " " &lt;&lt; std::to_string(yaw) &lt;&lt; "\n";
+  }
+  frame_count_++;
 }
 
 void ImmUkfPda::tracker(const autoware_msgs::DetectedObjectArray&amp; input,
-                        jsk_recognition_msgs::BoundingBoxArray&amp; jskbboxes_output,
                         autoware_msgs::DetectedObjectArray&amp; detected_objects_output)
 {
   double timestamp = input.header.stamp.toSec();
+  std::vector&lt;bool&gt; matching_vec(input.objects.size(), false);
 
   if (!init_)
   {
     initTracker(input, timestamp);
-    makeOutput(input, jskbboxes_output, detected_objects_output);
+    makeOutput(input, matching_vec, detected_objects_output);
     return;
   }
 
   double dt = (timestamp - timestamp_);
   timestamp_ = timestamp;
-  // making new target with no data association
-  std::vector&lt;bool&gt; matching_vec(input.objects.size(), false);
+
 
   // start UKF process
   for (size_t i = 0; i &lt; targets_.size(); i++)
   {
-    // reset is_vis_bb_ to false
-    targets_[i].is_vis_bb_ = false;
+    targets_[i].is_stable_ = false;
     targets_[i].is_static_ = false;
 
     if (targets_[i].tracking_num_ == TrackingState::Die)
@@ -837,53 +814,27 @@ void ImmUkfPda::tracker(const autoware_msgs::DetectedObjectArray&amp; input,
       continue;
     }
 
-    if (use_sukf_)
-    {
-      // standard ukf prediction step
-      targets_[i].predictionSUKF(dt);
-      // data association
-      bool is_skip_target;
-      std::vector&lt;autoware_msgs::DetectedObject&gt; object_vec;
-      probabilisticDataAssociation(input, dt, matching_vec, object_vec, targets_[i], is_skip_target);
-      if (is_skip_target)
-      {
-        continue;
-      }
-      // standard ukf update step
-      targets_[i].updateSUKF(object_vec);
-    }
-    else  // immukfpda filter
+    targets_[i].prediction(use_sukf_, has_subscribed_vectormap_, dt);
+
+    std::vector&lt;autoware_msgs::DetectedObject&gt; object_vec;
+    bool success = probabilisticDataAssociation(input, dt, matching_vec, object_vec, targets_[i]);
+    if (!success)
     {
-      // immukf prediction step
-      targets_[i].predictionIMMUKF(dt);
-      // data association
-      bool is_skip_target;
-      std::vector&lt;autoware_msgs::DetectedObject&gt; object_vec;
-      probabilisticDataAssociation(input, dt, matching_vec, object_vec, targets_[i], is_skip_target);
-      if (is_skip_target)
-      {
-        continue;
-      }
-      // immukf update step
-      targets_[i].updateIMMUKF(detection_probability_, gate_probability_, gating_thres_, object_vec);
+      continue;
     }
-  }
-  // end UKF process
 
-  // debug, green is for measurement points, red is for estimated points
-  if (is_debug_)
-  {
-    pubDebugROSMarker(input);
+    targets_[i].update(use_sukf_, detection_probability_, gate_probability_, gating_thres_, object_vec);
   }
+  // end UKF process
 
-  // making new ukf target for no data association clusters
+  // making new ukf target for no data association objects
   makeNewTargets(timestamp, input, matching_vec);
 
   // static dynamic classification
   staticClassification();
 
   // making output for visualization
-  makeOutput(input, jskbboxes_output, detected_objects_output);
+  makeOutput(input, matching_vec, detected_objects_output);
 
   // remove unnecessary ukf object
   removeUnnecessaryTarget();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\ukf.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\ukf.cpp" added_lines="604" deleted_lines="316">
				<diff>@@ -34,6 +34,14 @@
 * Initializes Unscented Kalman filter
 */
 UKF::UKF()
+  : num_state_(5)
+  , num_lidar_state_(2)
+  , num_lidar_direction_state_(3)
+  , num_motion_model_(3)
+  , is_direction_cv_available_(false)
+  , is_direction_ctrv_available_(false)
+  , is_direction_rm_available_(false)
+  , std_lane_direction_(0.15)
 {
   // initial state vector
   x_merge_ = Eigen::MatrixXd(5, 1);
@@ -60,11 +68,11 @@ UKF::UKF()
   p_rm_ = Eigen::MatrixXd(5, 5);
 
   // Process noise standard deviation longitudinal acceleration in m/s^2
-  std_a_cv_ = 2;
-  std_a_ctrv_ = 2;
+  std_a_cv_ = 1.5;
+  std_a_ctrv_ = 1.5;
   std_a_rm_ = 3;
-  std_ctrv_yawdd_ = 2;
-  std_cv_yawdd_ = 2;
+  std_ctrv_yawdd_ = 1.5;
+  std_cv_yawdd_ = 1.5;
   std_rm_yawdd_ = 3;
 
   // Laser measurement noise standard deviation position1 in m
@@ -72,27 +80,21 @@ UKF::UKF()
   // Laser measurement noise standard deviation position2 in m
   std_laspy_ = 0.15;
 
-  // initially set to false, set to true in first call of ProcessMeasurement
-  is_initialized_ = false;
-
   // time when the state is true, in us
   time_ = 0.0;
 
-  // state dimension
-  n_x_ = 5;
-
   // predicted sigma points matrix
-  x_sig_pred_cv_ = Eigen::MatrixXd(n_x_, 2 * n_x_ + 1);
+  x_sig_pred_cv_ = Eigen::MatrixXd(num_state_, 2 * num_state_ + 1);
 
   // predicted sigma points matrix
-  x_sig_pred_ctrv_ = Eigen::MatrixXd(n_x_, 2 * n_x_ + 1);
+  x_sig_pred_ctrv_ = Eigen::MatrixXd(num_state_, 2 * num_state_ + 1);
 
   // predicted sigma points matrix
-  x_sig_pred_rm_ = Eigen::MatrixXd(n_x_, 2 * n_x_ + 1);
+  x_sig_pred_rm_ = Eigen::MatrixXd(num_state_, 2 * num_state_ + 1);
 
   // create vector for weights
-  weights_c_ = Eigen::VectorXd(2 * n_x_ + 1);
-  weights_s_ = Eigen::VectorXd(2 * n_x_ + 1);
+  weights_c_ = Eigen::VectorXd(2 * num_state_ + 1);
+  weights_s_ = Eigen::VectorXd(2 * num_state_ + 1);
 
   // transition probability
   p1_.push_back(0.9);
@@ -143,13 +145,9 @@ UKF::UKF()
   is_static_ = false;
 
   // bounding box params
-  is_best_jsk_bb_empty_ = false;
-  is_vis_bb_ = false;
-  jsk_bb_.dimensions.x = 1.0;
-  jsk_bb_.dimensions.y = 1.0;
-  best_yaw_ = 100;
-  bb_yaw_ = 0;
-  bb_area_ = 0;
+  is_stable_ = false;
+  object_.dimensions.x = 1.0;
+  object_.dimensions.y = 1.0;
 
   // for static classification
   init_meas_ = Eigen::VectorXd(2);
@@ -173,13 +171,13 @@ UKF::UKF()
   nis_ctrv_ = 0;
   nis_rm_ = 0;
 
-  new_x_sig_cv_ = Eigen::MatrixXd(n_x_, 2 * n_x_ + 1);
-  new_x_sig_ctrv_ = Eigen::MatrixXd(n_x_, 2 * n_x_ + 1);
-  new_x_sig_rm_ = Eigen::MatrixXd(n_x_, 2 * n_x_ + 1);
+  new_x_sig_cv_ = Eigen::MatrixXd(num_state_, 2 * num_state_ + 1);
+  new_x_sig_ctrv_ = Eigen::MatrixXd(num_state_, 2 * num_state_ + 1);
+  new_x_sig_rm_ = Eigen::MatrixXd(num_state_, 2 * num_state_ + 1);
 
-  new_z_sig_cv_ = Eigen::MatrixXd(2, 2 * n_x_ + 1);
-  new_z_sig_ctrv_ = Eigen::MatrixXd(2, 2 * n_x_ + 1);
-  new_z_sig_rm_ = Eigen::MatrixXd(2, 2 * n_x_ + 1);
+  new_z_sig_cv_ = Eigen::MatrixXd(2, 2 * num_state_ + 1);
+  new_z_sig_ctrv_ = Eigen::MatrixXd(2, 2 * num_state_ + 1);
+  new_z_sig_rm_ = Eigen::MatrixXd(2, 2 * num_state_ + 1);
 
   new_z_pred_cv_ = Eigen::VectorXd(2);
   new_z_pred_ctrv_ = Eigen::VectorXd(2);
@@ -188,6 +186,27 @@ UKF::UKF()
   new_s_cv_ = Eigen::MatrixXd(2, 2);
   new_s_ctrv_ = Eigen::MatrixXd(2, 2);
   new_s_rm_ = Eigen::MatrixXd(2, 2);
+
+  // for lane direction combined filter
+  lidar_direction_r_cv_ = Eigen::MatrixXd(num_lidar_direction_state_, num_lidar_direction_state_);
+  lidar_direction_r_ctrv_ = Eigen::MatrixXd(num_lidar_direction_state_, num_lidar_direction_state_);
+  lidar_direction_r_rm_ = Eigen::MatrixXd(num_lidar_direction_state_, num_lidar_direction_state_);
+
+  k_lidar_direction_cv_ = Eigen::MatrixXd(num_state_, num_lidar_direction_state_);
+  k_lidar_direction_ctrv_ = Eigen::MatrixXd(num_state_, num_lidar_direction_state_);
+  k_lidar_direction_rm_ = Eigen::MatrixXd(num_state_, num_lidar_direction_state_);
+
+  lidar_direction_ctrv_meas_ = Eigen::VectorXd(num_lidar_direction_state_);
+}
+
+double UKF::normalizeAngle(const double angle)
+{
+  double normalized_angle = angle;
+  while (normalized_angle &gt; M_PI)
+    normalized_angle -= 2. * M_PI;
+  while (normalized_angle &lt; -M_PI)
+    normalized_angle += 2. * M_PI;
+  return normalized_angle;
 }
 
 void UKF::initialize(const Eigen::VectorXd&amp; z, const double timestamp, const int target_id)
@@ -206,14 +225,14 @@ void UKF::initialize(const Eigen::VectorXd&amp; z, const double timestamp, const int
   double alpha = 0.0025;
   double beta = 2;
   double k = 0;
-  lambda_ = alpha * alpha * (n_x_ + k) - n_x_;
-  double weight_s_0 = lambda_ / (lambda_ + n_x_);
-  double weight_c_0 = lambda_ / (lambda_ + n_x_) + (1 - alpha * alpha + beta);
+  lambda_ = alpha * alpha * (num_state_ + k) - num_state_;
+  double weight_s_0 = lambda_ / (lambda_ + num_state_);
+  double weight_c_0 = lambda_ / (lambda_ + num_state_) + (1 - alpha * alpha + beta);
   weights_s_(0) = weight_s_0;
   weights_c_(0) = weight_c_0;
-  for (int i = 1; i &lt; 2 * n_x_ + 1; i++)
+  for (int i = 1; i &lt; 2 * num_state_ + 1; i++)
   {  // 2n+1 weights
-    double weight = 0.5 / (n_x_ + lambda_);
+    double weight = 0.5 / (num_state_ + lambda_);
     weights_s_(i) = weight;
     weights_c_(i) = weight;
   }
@@ -245,6 +264,19 @@ void UKF::initialize(const Eigen::VectorXd&amp; z, const double timestamp, const int
   r_ctrv_ &lt;&lt; std_laspx_ * std_laspx_, 0, 0, std_laspy_ * std_laspy_;
   r_rm_ &lt;&lt; std_laspx_ * std_laspx_, 0, 0, std_laspy_ * std_laspy_;
 
+  // initialize lidar-lane R covariance
+  // clang-format off
+  lidar_direction_r_cv_ &lt;&lt; std_laspx_ * std_laspx_,                       0,                                       0,
+                                            0, std_laspy_ * std_laspy_,                                       0,
+                                            0,                       0, std_lane_direction_*std_lane_direction_;
+  lidar_direction_r_ctrv_ &lt;&lt; std_laspx_ * std_laspx_,                       0,                                       0,
+                                              0, std_laspy_ * std_laspy_,                                       0,
+                                              0,                       0, std_lane_direction_*std_lane_direction_;
+  lidar_direction_r_rm_ &lt;&lt; std_laspx_ * std_laspx_,                       0,                                       0,
+                                            0, std_laspy_ * std_laspy_,                                       0,
+                                            0,                       0, std_lane_direction_*std_lane_direction_;
+  // clang-format on
+
   // init tracking num
   tracking_num_ = 1;
 }
@@ -371,23 +403,27 @@ void UKF::interaction()
           mode_match_prob_rm2rm_ * (p_pre_rm + (x_pre_rm - x_rm_) * (x_pre_rm - x_rm_).transpose());
 }
 
-void UKF::predictionSUKF(const double dt)
+void UKF::predictionSUKF(const double dt, const bool has_subscribed_vectormap)
 {
   /*****************************************************************************
   *  Init covariance Q if it is necessary
   ****************************************************************************/
   initCovarQs(dt, x_merge_(3));
   /*****************************************************************************
-  *  Prediction
+  *  Prediction Motion Model
   ****************************************************************************/
-  prediction(dt, MotionModel::CTRV);
+  predictionMotion(dt, MotionModel::CTRV);
   /*****************************************************************************
-  *  Update
+  *  Prediction Measurement
   ****************************************************************************/
-  updateLidar(MotionModel::CTRV);
+  predictionLidarMeasurement(MotionModel::CTRV, num_lidar_state_);
+  if (has_subscribed_vectormap)
+  {
+    predictionLidarMeasurement(MotionModel::CTRV, num_lidar_direction_state_);
+  }
 }
 
-void UKF::predictionIMMUKF(const double dt)
+void UKF::predictionIMMUKF(const double dt, const bool has_subscribed_vectormap)
 {
   /*****************************************************************************
   *  Init covariance Q if it is needed
@@ -399,17 +435,24 @@ void UKF::predictionIMMUKF(const double dt)
   mixingProbability();
   interaction();
   /*****************************************************************************
-  *  Prediction
+  *  Prediction Motion Model
   ****************************************************************************/
-  prediction(dt, MotionModel::CV);
-  prediction(dt, MotionModel::CTRV);
-  prediction(dt, MotionModel::RM);
+  predictionMotion(dt, MotionModel::CV);
+  predictionMotion(dt, MotionModel::CTRV);
+  predictionMotion(dt, MotionModel::RM);
   /*****************************************************************************
-  *  Update
+  *  Prediction Measurement
   ****************************************************************************/
-  updateLidar(MotionModel::CV);
-  updateLidar(MotionModel::CTRV);
-  updateLidar(MotionModel::RM);
+  predictionLidarMeasurement(MotionModel::CV, num_lidar_state_);
+  predictionLidarMeasurement(MotionModel::CTRV, num_lidar_state_);
+  predictionLidarMeasurement(MotionModel::RM, num_lidar_state_);
+
+  if (has_subscribed_vectormap)
+  {
+    predictionLidarMeasurement(MotionModel::CV, num_lidar_direction_state_);
+    predictionLidarMeasurement(MotionModel::CTRV, num_lidar_direction_state_);
+    predictionLidarMeasurement(MotionModel::RM, num_lidar_direction_state_);
+  }
 }
 
 void UKF::findMaxZandS(Eigen::VectorXd&amp; max_det_z, Eigen::MatrixXd&amp; max_det_s)
@@ -453,224 +496,268 @@ void UKF::updateEachMotion(const double detection_probability, const double gate
   // calculating association probability
   double num_meas = object_vec.size();
   double b = 2 * num_meas * (1 - detection_probability * gate_probability) / (gating_thres * detection_probability);
-  double e_cv_sum = 0;
-  double e_ctrv_sum = 0;
-  double e_rm_sum = 0;
 
-  std::vector&lt;double&gt; e_cv_vec;
-  std::vector&lt;double&gt; e_ctrv_vec;
-  std::vector&lt;double&gt; e_rm_vec;
+  Eigen::VectorXd max_det_z;
+  Eigen::MatrixXd max_det_s;
+  findMaxZandS(max_det_z, max_det_s);
+  double Vk = M_PI * sqrt(gating_thres * max_det_s.determinant());
 
-  std::vector&lt;Eigen::VectorXd&gt; diff_cv_vec;
-  std::vector&lt;Eigen::VectorXd&gt; diff_ctrv_vec;
-  std::vector&lt;Eigen::VectorXd&gt; diff_rm_vec;
+  for (int motion_ind = 0; motion_ind &lt; num_motion_model_; motion_ind++)
+  {
+    Eigen::MatrixXd x(x_cv_.rows(), x_cv_.cols());
+    Eigen::MatrixXd p(p_cv_.rows(), p_cv_.cols());
+    bool is_direction_available = false;
+    int num_meas_state = 0;
+    Eigen::VectorXd z_pred;
+    Eigen::MatrixXd s_pred;
+    Eigen::MatrixXd kalman_gain;
+    Eigen::VectorXd likely_meas;
+    double e_sum = 0;
+    std::vector&lt;double&gt; e_vec;
+    std::vector&lt;Eigen::VectorXd&gt; diff_vec;
+    std::vector&lt;Eigen::VectorXd&gt; meas_vec;
+
+    if (motion_ind == MotionModel::CV)
+    {
+      x = x_cv_;
+      p = p_cv_;
+      if (is_direction_cv_available_)
+      {
+        is_direction_available = true;
+        num_meas_state = num_lidar_direction_state_;
+        z_pred = Eigen::VectorXd(num_meas_state);
+        s_pred = Eigen::MatrixXd(num_meas_state, num_meas_state);
+        kalman_gain = Eigen::MatrixXd(num_state_, num_meas_state);
+        z_pred = z_pred_lidar_direction_cv_;
+        s_pred = s_lidar_direction_cv_;
+        kalman_gain = k_lidar_direction_cv_;
+      }
+      else
+      {
+        num_meas_state = num_lidar_state_;
+        z_pred = Eigen::VectorXd(num_meas_state);
+        s_pred = Eigen::MatrixXd(num_meas_state, num_meas_state);
+        kalman_gain = Eigen::MatrixXd(num_state_, num_meas_state);
+        z_pred = z_pred_cv_;
+        s_pred = s_cv_;
+        kalman_gain = k_cv_;
+      }
+    }
+    else if (motion_ind == MotionModel::CTRV)
+    {
+      x = x_ctrv_;
+      p = p_ctrv_;
+      if (is_direction_ctrv_available_)
+      {
+        is_direction_available = true;
+        num_meas_state = num_lidar_direction_state_;
+        z_pred = Eigen::VectorXd(num_meas_state);
+        s_pred = Eigen::MatrixXd(num_meas_state, num_meas_state);
+        kalman_gain = Eigen::MatrixXd(num_state_, num_meas_state);
+        z_pred = z_pred_lidar_direction_ctrv_;
+        s_pred = s_lidar_direction_ctrv_;
+        kalman_gain = k_lidar_direction_ctrv_;
+      }
+      else
+      {
+        num_meas_state = num_lidar_state_;
+        z_pred = Eigen::VectorXd(num_meas_state);
+        s_pred = Eigen::MatrixXd(num_meas_state, num_meas_state);
+        kalman_gain = Eigen::MatrixXd(num_state_, num_meas_state);
+        z_pred = z_pred_ctrv_;
+        s_pred = s_ctrv_;
+        kalman_gain = k_ctrv_;
+      }
+    }
+    else
+    {
+      x = x_rm_;
+      p = p_rm_;
+      if (is_direction_rm_available_)
+      {
+        is_direction_available = true;
+        num_meas_state = num_lidar_direction_state_;
+        z_pred = Eigen::VectorXd(num_meas_state);
+        s_pred = Eigen::MatrixXd(num_meas_state, num_meas_state);
+        kalman_gain = Eigen::MatrixXd(num_state_, num_meas_state);
+        z_pred = z_pred_lidar_direction_rm_;
+        s_pred = s_lidar_direction_rm_;
+        kalman_gain = k_lidar_direction_rm_;
+      }
+      else
+      {
+        num_meas_state = num_lidar_state_;
+        z_pred = Eigen::VectorXd(num_meas_state);
+        s_pred = Eigen::MatrixXd(num_meas_state, num_meas_state);
+        kalman_gain = Eigen::MatrixXd(num_state_, num_meas_state);
+        z_pred = z_pred_rm_;
+        s_pred = s_rm_;
+        kalman_gain = k_rm_;
+      }
+    }
 
-  std::vector&lt;Eigen::VectorXd&gt; meas_vec;
+    for (size_t i = 0; i &lt; num_meas; i++)
+    {
+      Eigen::VectorXd meas = Eigen::VectorXd(num_meas_state);
+      meas(0) = object_vec[i].pose.position.x;
+      meas(1) = object_vec[i].pose.position.y;
+      if (is_direction_available)
+        meas(2) = object_vec[i].angle;
+      meas_vec.push_back(meas);
+      Eigen::VectorXd diff = meas - z_pred;
+      diff_vec.push_back(diff);
+      double e = exp(-0.5 * diff.transpose() * s_pred.inverse() * diff);
+      e_vec.push_back(e);
+      e_sum += e;
+    }
+    double beta_zero = b / (b + e_sum);
 
-  for (size_t i = 0; i &lt; num_meas; i++)
-  {
-    Eigen::VectorXd meas = Eigen::VectorXd(2);
-    meas(0) = object_vec[i].pose.position.x;
-    meas(1) = object_vec[i].pose.position.y;
-    meas_vec.push_back(meas);
-
-    Eigen::VectorXd diff_cv = meas - z_pred_cv_;
-    Eigen::VectorXd diff_ctrv = meas - z_pred_ctrv_;
-    Eigen::VectorXd diff_rm = meas - z_pred_rm_;
-
-    diff_cv_vec.push_back(diff_cv);
-    diff_ctrv_vec.push_back(diff_ctrv);
-    diff_rm_vec.push_back(diff_rm);
-
-    double e_cv = exp(-0.5 * diff_cv.transpose() * s_cv_.inverse() * diff_cv);
-    double e_ctrv = exp(-0.5 * diff_ctrv.transpose() * s_ctrv_.inverse() * diff_ctrv);
-    double e_rm = exp(-0.5 * diff_rm.transpose() * s_rm_.inverse() * diff_rm);
-
-    e_cv_vec.push_back(e_cv);
-    e_ctrv_vec.push_back(e_ctrv);
-    e_rm_vec.push_back(e_rm);
-
-    e_cv_sum += e_cv;
-    e_ctrv_sum += e_ctrv;
-    e_rm_sum += e_rm;
-  }
-  double beta_cv_zero = b / (b + e_cv_sum);
-  double beta_ctrv_zero = b / (b + e_ctrv_sum);
-  double beta_rm_zero = b / (b + e_rm_sum);
+    std::vector&lt;double&gt; beta_vec;
 
-  std::vector&lt;double&gt; beta_cv;
-  std::vector&lt;double&gt; beta_ctrv;
-  std::vector&lt;double&gt; beta_rm;
+    if (num_meas != 0)
+    {
+      std::vector&lt;double&gt;::iterator max_iter = std::max_element(e_vec.begin(), e_vec.end());
+      int max_ind = std::distance(e_vec.begin(), max_iter);
+      likely_meas = meas_vec[max_ind];
+    }
 
-  if (num_meas != 0)
-  {
-    std::vector&lt;double&gt;::iterator max_cv_iter = std::max_element(e_cv_vec.begin(), e_cv_vec.end());
-    std::vector&lt;double&gt;::iterator max_ctrv_iter = std::max_element(e_ctrv_vec.begin(), e_ctrv_vec.end());
-    std::vector&lt;double&gt;::iterator max_rm_iter = std::max_element(e_rm_vec.begin(), e_rm_vec.end());
-    int max_cv_ind = std::distance(e_cv_vec.begin(), max_cv_iter);
-    int max_ctrv_ind = std::distance(e_ctrv_vec.begin(), max_ctrv_iter);
-    int max_rm_ind = std::distance(e_rm_vec.begin(), max_rm_iter);
-    cv_meas_ = meas_vec[max_cv_ind];
-    ctrv_meas_ = meas_vec[max_ctrv_ind];
-    rm_meas_ = meas_vec[max_rm_ind];
-  }
+    for (size_t i = 0; i &lt; num_meas; i++)
+    {
+      double temp = e_vec[i] / (b + e_sum);
+      beta_vec.push_back(temp);
+    }
+    Eigen::VectorXd sigma_x;
+    sigma_x.setZero(num_meas_state);
 
-  for (size_t i = 0; i &lt; num_meas; i++)
-  {
-    double temp_cv = e_cv_vec[i] / (b + e_cv_sum);
-    double temp_ctrv = e_ctrv_vec[i] / (b + e_ctrv_sum);
-    double temp_rm = e_rm_vec[i] / (b + e_rm_sum);
+    for (size_t i = 0; i &lt; num_meas; i++)
+    {
+      sigma_x += beta_vec[i] * diff_vec[i];
+    }
 
-    beta_cv.push_back(temp_cv);
-    beta_ctrv.push_back(temp_ctrv);
-    beta_rm.push_back(temp_rm);
-  }
-  Eigen::VectorXd sigma_x_cv;
-  Eigen::VectorXd sigma_x_ctrv;
-  Eigen::VectorXd sigma_x_rm;
-  sigma_x_cv.setZero(2);
-  sigma_x_ctrv.setZero(2);
-  sigma_x_rm.setZero(2);
-
-  for (size_t i = 0; i &lt; num_meas; i++)
-  {
-    sigma_x_cv += beta_cv[i] * diff_cv_vec[i];
-    sigma_x_ctrv += beta_ctrv[i] * diff_ctrv_vec[i];
-    sigma_x_rm += beta_rm[i] * diff_rm_vec[i];
-  }
+    Eigen::MatrixXd sigma_p;
+    sigma_p.setZero(num_meas_state, num_meas_state);
 
-  Eigen::MatrixXd sigma_p_cv;
-  Eigen::MatrixXd sigma_p_ctrv;
-  Eigen::MatrixXd sigma_p_rm;
-  sigma_p_cv.setZero(2, 2);
-  sigma_p_ctrv.setZero(2, 2);
-  sigma_p_rm.setZero(2, 2);
+    for (size_t i = 0; i &lt; num_meas; i++)
+    {
+      sigma_p += (beta_vec[i] * diff_vec[i] * diff_vec[i].transpose() - sigma_x * sigma_x.transpose());
+    }
 
-  for (size_t i = 0; i &lt; num_meas; i++)
-  {
-    sigma_p_cv += (beta_cv[i] * diff_cv_vec[i] * diff_cv_vec[i].transpose() - sigma_x_cv * sigma_x_cv.transpose());
-    sigma_p_ctrv +=
-        (beta_ctrv[i] * diff_ctrv_vec[i] * diff_ctrv_vec[i].transpose() - sigma_x_ctrv * sigma_x_ctrv.transpose());
-    sigma_p_rm += (beta_rm[i] * diff_rm_vec[i] * diff_rm_vec[i].transpose() - sigma_x_rm * sigma_x_rm.transpose());
-  }
+    // update x and P
+    Eigen::MatrixXd updated_x(x_cv_.rows(), x_cv_.cols());
+    updated_x = x + kalman_gain * sigma_x;
 
-  // update x and P
-  x_cv_ = x_cv_ + k_cv_ * sigma_x_cv;
-  x_ctrv_ = x_ctrv_ + k_ctrv_ * sigma_x_ctrv;
-  x_rm_ = x_rm_ + k_rm_ * sigma_x_rm;
+    updated_x(3) = normalizeAngle(updated_x(3));
 
-  while (x_cv_(3) &gt; M_PI)
-    x_cv_(3) -= 2. * M_PI;
-  while (x_cv_(3) &lt; -M_PI)
-    x_cv_(3) += 2. * M_PI;
-  while (x_ctrv_(3) &gt; M_PI)
-    x_ctrv_(3) -= 2. * M_PI;
-  while (x_ctrv_(3) &lt; -M_PI)
-    x_ctrv_(3) += 2. * M_PI;
-  while (x_rm_(3) &gt; M_PI)
-    x_rm_(3) -= 2. * M_PI;
-  while (x_rm_(3) &lt; -M_PI)
-    x_rm_(3) += 2. * M_PI;
+    Eigen::MatrixXd updated_p(p_cv_.rows(), p_cv_.cols());
+    if (num_meas != 0)
+    {
+      updated_p = beta_zero * p + (1 - beta_zero) * (p - kalman_gain * s_pred * kalman_gain.transpose()) +
+                  kalman_gain * sigma_p * kalman_gain.transpose();
+    }
+    else
+    {
+      updated_p = p - kalman_gain * s_pred * kalman_gain.transpose();
+    }
 
-  Eigen::MatrixXd p_pre_cv = p_cv_;
-  Eigen::MatrixXd p_pre_ctrv = p_ctrv_;
-  Eigen::MatrixXd p_pre_rm = p_rm_;
+    double lambda;
+    if (num_meas != 0)
+    {
+      lambda =
+          (1 - gate_probability * detection_probability) / pow(Vk, num_meas) +
+          detection_probability * pow(Vk, 1 - num_meas) * e_sum / (num_meas * sqrt(2 * M_PI * s_pred.determinant()));
+    }
+    else
+    {
+      lambda = (1 - gate_probability * detection_probability);
+    }
 
-  if (num_meas != 0)
-  {
-    p_cv_ = beta_cv_zero * p_pre_cv + (1 - beta_cv_zero) * (p_pre_cv - k_cv_ * s_cv_ * k_cv_.transpose()) +
-            k_cv_ * sigma_p_cv * k_cv_.transpose();
-    p_ctrv_ = beta_ctrv_zero * p_pre_ctrv +
-              (1 - beta_ctrv_zero) * (p_pre_ctrv - k_ctrv_ * s_ctrv_ * k_ctrv_.transpose()) +
-              k_ctrv_ * sigma_p_ctrv * k_ctrv_.transpose();
-    p_rm_ = beta_rm_zero * p_pre_rm + (1 - beta_rm_zero) * (p_pre_rm - k_rm_ * s_rm_ * k_rm_.transpose()) +
-            k_rm_ * sigma_p_rm * k_rm_.transpose();
+    lambda_vec.push_back(lambda);
+
+    if (motion_ind == MotionModel::CV)
+    {
+      x_cv_ = updated_x;
+      p_cv_ = updated_p;
+    }
+    else if (motion_ind == MotionModel::CTRV)
+    {
+      x_ctrv_ = updated_x;
+      p_ctrv_ = updated_p;
+    }
+    else
+    {
+      x_rm_ = updated_x;
+      p_rm_ = updated_p;
+    }
   }
-  else
+}
+
+void UKF::updateMeasurementForCTRV(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec)
+{
+  std::vector&lt;double&gt; e_ctrv_vec;
+  std::vector&lt;Eigen::VectorXd&gt; meas_vec;
+  for (auto const&amp; object : object_vec)
   {
-    p_cv_ = p_pre_cv - k_cv_ * s_cv_ * k_cv_.transpose();
-    p_ctrv_ = p_pre_ctrv - k_ctrv_ * s_ctrv_ * k_ctrv_.transpose();
-    p_rm_ = p_pre_rm - k_rm_ * s_rm_ * k_rm_.transpose();
+    Eigen::VectorXd meas;
+    if (is_direction_ctrv_available_)
+    {
+      meas = Eigen::VectorXd(num_lidar_direction_state_);
+      meas &lt;&lt; object.pose.position.x, object.pose.position.y, object.angle;
+      meas_vec.push_back(meas);
+      Eigen::VectorXd diff_ctrv = meas - z_pred_lidar_direction_ctrv_;
+      double e_ctrv = exp(-0.5 * diff_ctrv.transpose() * s_lidar_direction_ctrv_.inverse() * diff_ctrv);
+      e_ctrv_vec.push_back(e_ctrv);
+    }
+    else
+    {
+      meas = Eigen::VectorXd(num_lidar_state_);
+      meas &lt;&lt; object.pose.position.x, object.pose.position.y;
+      meas_vec.push_back(meas);
+      Eigen::VectorXd diff_ctrv = meas - z_pred_ctrv_;
+      double e_ctrv = exp(-0.5 * diff_ctrv.transpose() * s_ctrv_.inverse() * diff_ctrv);
+      e_ctrv_vec.push_back(e_ctrv);
+    }
   }
-
-  Eigen::VectorXd max_det_z;
-  Eigen::MatrixXd max_det_s;
-
-  findMaxZandS(max_det_z, max_det_s);
-  double Vk = M_PI * sqrt(gating_thres * max_det_s.determinant());
-
-  double lambda_cv, lambda_ctrv, lambda_rm;
-  if (num_meas != 0)
+  std::vector&lt;double&gt;::iterator max_ctrv_iter = std::max_element(e_ctrv_vec.begin(), e_ctrv_vec.end());
+  int max_ctrv_ind = std::distance(e_ctrv_vec.begin(), max_ctrv_iter);
+  if (is_direction_ctrv_available_)
   {
-    lambda_cv =
-        (1 - gate_probability * detection_probability) / pow(Vk, num_meas) +
-        detection_probability * pow(Vk, 1 - num_meas) * e_cv_sum / (num_meas * sqrt(2 * M_PI * s_cv_.determinant()));
-    lambda_ctrv = (1 - gate_probability * detection_probability) / pow(Vk, num_meas) +
-                  detection_probability * pow(Vk, 1 - num_meas) * e_ctrv_sum /
-                      (num_meas * sqrt(2 * M_PI * s_ctrv_.determinant()));
-    lambda_rm =
-        (1 - gate_probability * detection_probability) / pow(Vk, num_meas) +
-        detection_probability * pow(Vk, 1 - num_meas) * e_rm_sum / (num_meas * sqrt(2 * M_PI * s_rm_.determinant()));
+    lidar_direction_ctrv_meas_ = meas_vec[max_ctrv_ind];
   }
   else
   {
-    lambda_cv = (1 - gate_probability * detection_probability);
-    lambda_ctrv = (1 - gate_probability * detection_probability);
-    lambda_rm = (1 - gate_probability * detection_probability);
+    ctrv_meas_ = meas_vec[max_ctrv_ind];
   }
-
-  lambda_vec.push_back(lambda_cv);
-  lambda_vec.push_back(lambda_ctrv);
-  lambda_vec.push_back(lambda_rm);
 }
 
-void UKF::updateLikelyMeasurementForCTRV(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec)
+void UKF::uppateForCTRV()
 {
-  double num_meas = object_vec.size();
-  std::vector&lt;double&gt; e_ctrv_vec;
-  std::vector&lt;Eigen::VectorXd&gt; meas_vec;
+  Eigen::VectorXd x = x_ctrv_.col(0);
 
-  for (size_t i = 0; i &lt; num_meas; i++)
+  if (is_direction_ctrv_available_)
   {
-    Eigen::VectorXd meas = Eigen::VectorXd(2);
-    meas(0) = object_vec[i].pose.position.x;
-    meas(1) = object_vec[i].pose.position.y;
-    meas_vec.push_back(meas);
-    Eigen::VectorXd diff_ctrv = meas - z_pred_ctrv_;
-    double e_ctrv = exp(-0.5 * diff_ctrv.transpose() * s_ctrv_.inverse() * diff_ctrv);
-    e_ctrv_vec.push_back(e_ctrv);
+    x_ctrv_.col(0) = x + k_lidar_direction_ctrv_ * (lidar_direction_ctrv_meas_ - z_pred_lidar_direction_ctrv_);
+    p_ctrv_ = p_ctrv_ - k_lidar_direction_ctrv_ * s_lidar_direction_ctrv_ * k_lidar_direction_ctrv_.transpose();
+    x_merge_.col(0) = x_ctrv_.col(0);
   }
-  // for noise estimation
-  if (num_meas != 0)
+  else
   {
-    std::vector&lt;double&gt;::iterator max_ctrv_iter = std::max_element(e_ctrv_vec.begin(), e_ctrv_vec.end());
-    int max_ctrv_ind = std::distance(e_ctrv_vec.begin(), max_ctrv_iter);
-    ctrv_meas_ = meas_vec[max_ctrv_ind];
+    x_ctrv_.col(0) = x + k_ctrv_ * (ctrv_meas_ - z_pred_ctrv_);
+    p_ctrv_ = p_ctrv_ - k_ctrv_ * s_ctrv_ * k_ctrv_.transpose();
+    x_merge_.col(0) = x_ctrv_.col(0);
   }
 }
 
 void UKF::updateSUKF(const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec)
 {
+  // Applying this skip process only to updateSUKF
+  // since updateIMMUKF update covariance even if there is no measurement.
   if (object_vec.size() == 0)
   {
     return;
   }
-
-  // get most likely measurement ctrv_meas_
-  updateLikelyMeasurementForCTRV(object_vec);
-
-  Eigen::VectorXd z = Eigen::VectorXd(2);
-  z &lt;&lt; ctrv_meas_(0), ctrv_meas_(1);
-
-  Eigen::VectorXd x = x_ctrv_.col(0);
-  Eigen::VectorXd z_pred = z_pred_ctrv_;
-  Eigen::MatrixXd k = k_ctrv_;
-  Eigen::MatrixXd p = p_ctrv_;
-  Eigen::MatrixXd s = s_ctrv_;
-
-  x_ctrv_.col(0) = x + k * (z - z_pred);
-  p_ctrv_ = p - k * s_ctrv_ * k.transpose();
-  x_merge_.col(0) = x_ctrv_.col(0);
+  updateKalmanGain(MotionModel::CTRV);
+  updateMeasurementForCTRV(object_vec);
+  uppateForCTRV();
 }
 
 void UKF::updateIMMUKF(const double detection_probability, const double gate_probability, const double gating_thres,
@@ -679,7 +766,12 @@ void UKF::updateIMMUKF(const double detection_probability, const double gate_pro
   /*****************************************************************************
   *  IMM Update
   ****************************************************************************/
-  // update each motion's x and p
+  // update kalman gain
+  updateKalmanGain(MotionModel::CV);
+  updateKalmanGain(MotionModel::CTRV);
+  updateKalmanGain(MotionModel::RM);
+
+  // update state varibale x and state covariance p
   std::vector&lt;double&gt; lambda_vec;
   updateEachMotion(detection_probability, gate_probability, gating_thres, object_vec, lambda_vec);
   /*****************************************************************************
@@ -725,15 +817,13 @@ void UKF::ctrv(const double p_x, const double p_y, const double v, const double
 void UKF::cv(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
              const double delta_t, std::vector&lt;double&gt;&amp; state)
 {
-  // predicted state values
+  // Reference: Bayesian Environment Representation, Prediction, and Criticality Assessment for Driver Assistance
+  // Systems, 2016
   double px_p = p_x + v * cos(yaw) * delta_t;
   double py_p = p_y + v * sin(yaw) * delta_t;
-
   double v_p = v;
-  // not sure which one, works better in curve by using yaw
   double yaw_p = yaw;
-
-  double yawd_p = yawd;
+  double yawd_p = 0;
 
   state[0] = px_p;
   state[1] = py_p;
@@ -745,13 +835,13 @@ void UKF::cv(const double p_x, const double p_y, const double v, const double ya
 void UKF::randomMotion(const double p_x, const double p_y, const double v, const double yaw, const double yawd,
                        const double delta_t, std::vector&lt;double&gt;&amp; state)
 {
+  // Reference: Bayesian Environment Representation, Prediction, and Criticality Assessment for Driver Assistance
+  // Systems, 2016
   double px_p = p_x;
   double py_p = p_y;
-  double v_p = v * 0.9;  // aim to converge velocity for static objects
-  // double v_p = 0.0;
-
+  double v_p = 0.0;
   double yaw_p = yaw;
-  double yawd_p = yawd;
+  double yawd_p = 0;
 
   state[0] = px_p;
   state[1] = py_p;
@@ -802,7 +892,7 @@ void UKF::initCovarQs(const double dt, const double yaw)
       0.5 * dt_3 * rm_var_yawdd, 0, 0, 0, 0.5 * dt_3 * rm_var_yawdd, dt_2 * rm_var_yawdd;
 }
 
-void UKF::prediction(const double delta_t, const int model_ind)
+void UKF::predictionMotion(const double delta_t, const int model_ind)
 {
   /*****************************************************************************
  *  Initialize model parameters
@@ -837,17 +927,17 @@ void UKF::prediction(const double delta_t, const int model_ind)
   *  Create Sigma Points
   ****************************************************************************/
 
-  Eigen::MatrixXd x_sig = Eigen::MatrixXd(n_x_, 2 * n_x_ + 1);
+  Eigen::MatrixXd x_sig = Eigen::MatrixXd(num_state_, 2 * num_state_ + 1);
 
   // create square root matrix
   Eigen::MatrixXd L = p.llt().matrixL();
 
   // create augmented sigma points
   x_sig.col(0) = x;
-  for (int i = 0; i &lt; n_x_; i++)
+  for (int i = 0; i &lt; num_state_; i++)
   {
-    Eigen::VectorXd pred1 = x + sqrt(lambda_ + n_x_) * L.col(i);
-    Eigen::VectorXd pred2 = x - sqrt(lambda_ + n_x_) * L.col(i);
+    Eigen::VectorXd pred1 = x + sqrt(lambda_ + num_state_) * L.col(i);
+    Eigen::VectorXd pred2 = x - sqrt(lambda_ + num_state_) * L.col(i);
 
     while (pred1(3) &gt; M_PI)
       pred1(3) -= 2. * M_PI;
@@ -860,14 +950,14 @@ void UKF::prediction(const double delta_t, const int model_ind)
       pred2(3) += 2. * M_PI;
 
     x_sig.col(i + 1) = pred1;
-    x_sig.col(i + 1 + n_x_) = pred2;
+    x_sig.col(i + 1 + num_state_) = pred2;
   }
 
   /*****************************************************************************
   *  Predict Sigma Points
   ****************************************************************************/
   // predict sigma points
-  for (int i = 0; i &lt; 2 * n_x_ + 1; i++)
+  for (int i = 0; i &lt; 2 * num_state_ + 1; i++)
   {
     // extract values for better readability
     double p_x = x_sig(0, i);
@@ -897,7 +987,7 @@ void UKF::prediction(const double delta_t, const int model_ind)
   ****************************************************************************/
   // predicted state mean
   x.fill(0.0);
-  for (int i = 0; i &lt; 2 * n_x_ + 1; i++)
+  for (int i = 0; i &lt; 2 * num_state_ + 1; i++)
   {  // iterate over sigma points
     x = x + weights_s_(i) * x_sig_pred.col(i);
   }
@@ -908,7 +998,7 @@ void UKF::prediction(const double delta_t, const int model_ind)
     x(3) += 2. * M_PI;
   // predicted state covariance matrix
   p.fill(0.0);
-  for (int i = 0; i &lt; 2 * n_x_ + 1; i++)
+  for (int i = 0; i &lt; 2 * num_state_ + 1; i++)
   {  // iterate over sigma points
     // state difference
     Eigen::VectorXd x_diff = x_sig_pred.col(i) - x;
@@ -945,123 +1035,321 @@ void UKF::prediction(const double delta_t, const int model_ind)
   }
 }
 
-void UKF::updateLidar(const int model_ind)
+void UKF::updateKalmanGain(const int motion_ind)
 {
-  /*****************************************************************************
- *  Initialize model parameters
- ****************************************************************************/
   Eigen::VectorXd x(x_cv_.rows());
-  Eigen::MatrixXd P(p_cv_.rows(), p_cv_.cols());
-  Eigen::MatrixXd r(2, 2);
   Eigen::MatrixXd x_sig_pred(x_sig_pred_cv_.rows(), x_sig_pred_cv_.cols());
-  if (model_ind == MotionModel::CV)
+  Eigen::VectorXd z_pred;
+  Eigen::MatrixXd s_pred;
+  int num_meas_state = 0;
+  if (motion_ind == MotionModel::CV)
   {
     x = x_cv_.col(0);
-    r = r_cv_;
     x_sig_pred = x_sig_pred_cv_;
+    if (is_direction_cv_available_)
+    {
+      num_meas_state = num_lidar_direction_state_;
+      z_pred = Eigen::VectorXd(num_meas_state);
+      z_pred = z_pred_lidar_direction_cv_;
+      s_pred = Eigen::MatrixXd(num_meas_state, num_meas_state);
+      s_pred = s_lidar_direction_cv_;
+    }
+    else
+    {
+      num_meas_state = num_lidar_state_;
+      z_pred = Eigen::VectorXd(num_meas_state);
+      z_pred = z_pred_cv_;
+      s_pred = Eigen::MatrixXd(num_meas_state, num_meas_state);
+      s_pred = s_cv_;
+    }
   }
-  else if (model_ind == MotionModel::CTRV)
+  else if (motion_ind == MotionModel::CTRV)
   {
     x = x_ctrv_.col(0);
-    r = r_ctrv_;
     x_sig_pred = x_sig_pred_ctrv_;
+    if (is_direction_ctrv_available_)
+    {
+      num_meas_state = num_lidar_direction_state_;
+      z_pred = Eigen::VectorXd(num_meas_state);
+      z_pred = z_pred_lidar_direction_ctrv_;
+      s_pred = Eigen::MatrixXd(num_meas_state, num_meas_state);
+      s_pred = s_lidar_direction_ctrv_;
+    }
+    else
+    {
+      num_meas_state = num_lidar_state_;
+      z_pred = Eigen::VectorXd(num_meas_state);
+      z_pred = z_pred_ctrv_;
+      s_pred = Eigen::MatrixXd(num_meas_state, num_meas_state);
+      s_pred = s_ctrv_;
+    }
   }
   else
   {
     x = x_rm_.col(0);
-    r = r_rm_;
     x_sig_pred = x_sig_pred_rm_;
+    if (is_direction_rm_available_)
+    {
+      num_meas_state = num_lidar_direction_state_;
+      z_pred = Eigen::VectorXd(num_meas_state);
+      z_pred = z_pred_lidar_direction_rm_;
+      s_pred = Eigen::MatrixXd(num_meas_state, num_meas_state);
+      s_pred = s_lidar_direction_rm_;
+    }
+    else
+    {
+      num_meas_state = num_lidar_state_;
+      z_pred = Eigen::VectorXd(num_meas_state);
+      z_pred = z_pred_rm_;
+      s_pred = Eigen::MatrixXd(num_meas_state, num_meas_state);
+      s_pred = s_rm_;
+    }
   }
 
-  // set measurement dimension, lidar can measure p_x and p_y
-  int n_z = 2;
+  Eigen::MatrixXd cross_covariance = Eigen::MatrixXd(num_state_, num_meas_state);
+  cross_covariance.fill(0.0);
+  for (int i = 0; i &lt; 2 * num_state_ + 1; i++)
+  {
+    Eigen::VectorXd z_sig_point(num_meas_state);
+    if (num_meas_state == num_lidar_direction_state_)
+    {
+      z_sig_point &lt;&lt; x_sig_pred(0, i), x_sig_pred(1, i), x_sig_pred(3, i);
+    }
+    else
+    {
+      z_sig_point &lt;&lt; x_sig_pred(0, i), x_sig_pred(1, i);
+    }
+    Eigen::VectorXd z_diff = z_sig_point - z_pred;
+    Eigen::VectorXd x_diff = x_sig_pred.col(i) - x;
+
+    x_diff(3) = normalizeAngle(x_diff(3));
+
+    if (num_meas_state == num_lidar_direction_state_)
+    {
+      z_diff(2) = normalizeAngle(z_diff(2));
+    }
+
+    cross_covariance = cross_covariance + weights_c_(i) * x_diff * z_diff.transpose();
+  }
 
-  // create matrix for sigma points in measurement space
-  Eigen::MatrixXd z_sig = Eigen::MatrixXd(n_z, 2 * n_x_ + 1);
+  Eigen::MatrixXd kalman_gain = cross_covariance * s_pred.inverse();
 
-  // transform sigma points into measurement space
-  for (int i = 0; i &lt; 2 * n_x_ + 1; i++)
-  {  // 2n+1 simga points
-    // extract values for better readibility
+  if (num_meas_state == num_lidar_direction_state_)
+  {
+    if (motion_ind == MotionModel::CV)
+    {
+      k_lidar_direction_cv_ = kalman_gain;
+    }
+    else if (motion_ind == MotionModel::CTRV)
+    {
+      k_lidar_direction_ctrv_ = kalman_gain;
+    }
+    else
+    {
+      k_lidar_direction_rm_ = kalman_gain;
+    }
+  }
+  else
+  {
+    if (motion_ind == MotionModel::CV)
+    {
+      k_cv_ = kalman_gain;
+    }
+    else if (motion_ind == MotionModel::CTRV)
+    {
+      k_ctrv_ = kalman_gain;
+    }
+    else
+    {
+      k_rm_ = kalman_gain;
+    }
+  }
+}
+
+void UKF::predictionLidarMeasurement(const int motion_ind, const int num_meas_state)
+{
+  Eigen::MatrixXd x_sig_pred(x_sig_pred_cv_.rows(), x_sig_pred_cv_.cols());
+  Eigen::MatrixXd covariance_r(num_meas_state, num_meas_state);
+  if (motion_ind == MotionModel::CV)
+  {
+    x_sig_pred = x_sig_pred_cv_;
+    if (num_meas_state == num_lidar_direction_state_)
+      covariance_r = lidar_direction_r_cv_;
+    else
+      covariance_r = r_cv_;
+  }
+  else if (motion_ind == MotionModel::CTRV)
+  {
+    x_sig_pred = x_sig_pred_ctrv_;
+    if (num_meas_state == num_lidar_direction_state_)
+      covariance_r = lidar_direction_r_ctrv_;
+    else
+      covariance_r = r_ctrv_;
+  }
+  else
+  {
+    x_sig_pred = x_sig_pred_rm_;
+    if (num_meas_state == num_lidar_direction_state_)
+      covariance_r = lidar_direction_r_rm_;
+    else
+      covariance_r = r_rm_;
+  }
+
+  Eigen::MatrixXd z_sig = Eigen::MatrixXd(num_meas_state, 2 * num_state_ + 1);
+
+  for (int i = 0; i &lt; 2 * num_state_ + 1; i++)
+  {
     double p_x = x_sig_pred(0, i);
     double p_y = x_sig_pred(1, i);
 
-    // measurement model
     z_sig(0, i) = p_x;
     z_sig(1, i) = p_y;
+
+    if (num_meas_state == num_lidar_direction_state_)
+    {
+      double p_yaw = x_sig_pred(3, i);
+      z_sig(2, i) = p_yaw;
+    }
   }
 
-  // mean predicted measurement
-  Eigen::VectorXd z_pred = Eigen::VectorXd(n_z);
+  Eigen::VectorXd z_pred = Eigen::VectorXd(num_meas_state);
   z_pred.fill(0.0);
-  for (int i = 0; i &lt; 2 * n_x_ + 1; i++)
+  for (int i = 0; i &lt; 2 * num_state_ + 1; i++)
   {
     z_pred = z_pred + weights_s_(i) * z_sig.col(i);
   }
 
-  // measurement covariance matrix S
-  Eigen::MatrixXd S = Eigen::MatrixXd(n_z, n_z);
-  S.fill(0.0);
-  for (int i = 0; i &lt; 2 * n_x_ + 1; i++)
-  {  // 2n+1 simga points
-    // residual
+  if (num_meas_state == num_lidar_direction_state_)
+    z_pred(2) = normalizeAngle(z_pred(2));
+
+  Eigen::MatrixXd s_pred = Eigen::MatrixXd(num_meas_state, num_meas_state);
+  s_pred.fill(0.0);
+  for (int i = 0; i &lt; 2 * num_state_ + 1; i++)
+  {
     Eigen::VectorXd z_diff = z_sig.col(i) - z_pred;
-    S = S + weights_c_(i) * z_diff * z_diff.transpose();
+    if (num_meas_state == num_lidar_direction_state_)
+      z_diff(2) = normalizeAngle(z_diff(2));
+    s_pred = s_pred + weights_c_(i) * z_diff * z_diff.transpose();
   }
 
   // add measurement noise covariance matrix
-  S = S + r;
+  s_pred += covariance_r;
 
-  // create matrix for cross correlation Tc
-  Eigen::MatrixXd Tc = Eigen::MatrixXd(n_x_, n_z);
+  if (num_meas_state == num_lidar_direction_state_)
+  {
+    if (motion_ind == MotionModel::CV)
+    {
+      z_pred_lidar_direction_cv_ = z_pred;
+      s_lidar_direction_cv_ = s_pred;
+    }
+    else if (motion_ind == MotionModel::CTRV)
+    {
+      z_pred_lidar_direction_ctrv_ = z_pred;
+      s_lidar_direction_ctrv_ = s_pred;
+    }
+    else
+    {
+      z_pred_lidar_direction_rm_ = z_pred;
+      s_lidar_direction_rm_ = s_pred;
+    }
+  }
+  else
+  {
+    if (motion_ind == MotionModel::CV)
+    {
+      z_pred_cv_ = z_pred;
+      s_cv_ = s_pred;
+    }
+    else if (motion_ind == MotionModel::CTRV)
+    {
+      z_pred_ctrv_ = z_pred;
+      s_ctrv_ = s_pred;
+    }
+    else
+    {
+      z_pred_rm_ = z_pred;
+      s_rm_ = s_pred;
+    }
+  }
+}
 
-  /*****************************************************************************
-  *  UKF Update for Lidar
-  ****************************************************************************/
-  // calculate cross correlation matrix
-  Tc.fill(0.0);
-  for (int i = 0; i &lt; 2 * n_x_ + 1; i++)
-  {  // 2n+1 simga points
-    // residual
-    Eigen::VectorXd z_diff = z_sig.col(i) - z_pred;
-    // state difference
-    Eigen::VectorXd x_diff = x_sig_pred.col(i) - x;
+double UKF::calculateNIS(const autoware_msgs::DetectedObject&amp; in_object, const int motion_ind)
+{
+  Eigen::VectorXd z_pred = Eigen::VectorXd(num_lidar_direction_state_);
+  Eigen::MatrixXd s_pred = Eigen::MatrixXd(num_lidar_direction_state_, num_lidar_direction_state_);
+  if (motion_ind == MotionModel::CV)
+  {
+    z_pred = z_pred_lidar_direction_cv_;
+    s_pred = s_lidar_direction_cv_;
+  }
+  else if (motion_ind == MotionModel::CTRV)
+  {
+    z_pred = z_pred_lidar_direction_ctrv_;
+    s_pred = s_lidar_direction_ctrv_;
+  }
+  else
+  {
+    z_pred = z_pred_lidar_direction_rm_;
+    s_pred = s_lidar_direction_rm_;
+  }
 
-    while (x_diff(3) &gt; M_PI)
-      x_diff(3) -= 2. * M_PI;
-    while (x_diff(3) &lt; -M_PI)
-      x_diff(3) += 2. * M_PI;
+  // Pick up yaw estimation and yaw variance
+  double diff = in_object.angle - z_pred(2);
+  double nis = diff * s_pred(2, 2) * diff;
+
+  return nis;
+}
+
+bool UKF::isLaneDirectionAvailable(const autoware_msgs::DetectedObject&amp; in_object, const int motion_ind,
+                                   const double lane_direction_chi_thres)
+{
+  predictionLidarMeasurement(motion_ind, num_lidar_direction_state_);
 
-    Tc = Tc + weights_c_(i) * x_diff * z_diff.transpose();
+  double lidar_direction_nis = calculateNIS(in_object, motion_ind);
+
+  bool is_direction_available = false;
+  if (lidar_direction_nis &lt; lane_direction_chi_thres)
+  {
+    is_direction_available = true;
   }
+  return is_direction_available;
+}
 
-  Eigen::MatrixXd K = Tc * S.inverse();
+void UKF::checkLaneDirectionAvailability(const autoware_msgs::DetectedObject&amp; in_object,
+                                         const double lane_direction_chi_thres, const bool use_sukf)
+{
+  if (use_sukf)
+  {
+    is_direction_ctrv_available_ = isLaneDirectionAvailable(in_object, MotionModel::CTRV, lane_direction_chi_thres);
+  }
+  else
+  {
+    is_direction_cv_available_ = isLaneDirectionAvailable(in_object, MotionModel::CV, lane_direction_chi_thres);
+    is_direction_ctrv_available_ = isLaneDirectionAvailable(in_object, MotionModel::CTRV, lane_direction_chi_thres);
+  }
+}
 
-  /*****************************************************************************
-  *  Update model parameters
-  ****************************************************************************/
-  if (model_ind == MotionModel::CV)
+void UKF::prediction(const bool use_sukf, const bool has_subscribed_vectormap, const double dt)
+{
+  if (use_sukf)
   {
-    x_cv_.col(0) = x;
-    x_sig_pred_cv_ = x_sig_pred;
-    z_pred_cv_ = z_pred;
-    s_cv_ = S;
-    k_cv_ = K;
+    predictionSUKF(dt, has_subscribed_vectormap);
   }
-  else if (model_ind == MotionModel::CTRV)
+  else
   {
-    x_ctrv_.col(0) = x;
-    x_sig_pred_ctrv_ = x_sig_pred;
-    z_pred_ctrv_ = z_pred;
-    s_ctrv_ = S;
-    k_ctrv_ = K;
+    predictionIMMUKF(dt, has_subscribed_vectormap);
+  }
+}
+
+void UKF::update(const bool use_sukf, const double detection_probability, const double gate_probability,
+                 const double gating_thres, const std::vector&lt;autoware_msgs::DetectedObject&gt;&amp; object_vec)
+{
+  if (use_sukf)
+  {
+    updateSUKF(object_vec);
   }
   else
   {
-    x_rm_.col(0) = x;
-    x_sig_pred_rm_ = x_sig_pred;
-    z_pred_rm_ = z_pred;
-    s_rm_ = S;
-    k_rm_ = K;
+    updateIMMUKF(detection_probability, gate_probability, gating_thres, object_vec);
   }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\visualize_detected_objects\visualize_detected_objects.cpp" new_path="" added_lines="0" deleted_lines="174">
				<diff>@@ -1,174 +0,0 @@
-/*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "visualize_detected_objects.h"
-
-#include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;tf/transform_datatypes.h&gt;
-#include &lt;cmath&gt;
-
-VisualizeDetectedObjects::VisualizeDetectedObjects() : vis_arrow_height_(0.5), vis_id_height_(1.5)
-{
-  ros::NodeHandle private_nh_("~");
-  private_nh_.param&lt;std::string&gt;("pointcloud_frame", pointcloud_frame_, "velodyne");
-  private_nh_.param&lt;double&gt;("ignore_velocity_thres", ignore_velocity_thres_, 0.1);
-  private_nh_.param&lt;double&gt;("visualize_arrow_velocity_thres", visualize_arrow_velocity_thres_, 0.25);
-
-  sub_object_array_ =
-      node_handle_.subscribe("/detection/lidar_tracker/objects", 1, &amp;VisualizeDetectedObjects::callBack, this);
-  pub_arrow_ = node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;("/detection/lidar_tracker/arrow_markers", 10);
-  pub_id_ = node_handle_.advertise&lt;visualization_msgs::MarkerArray&gt;("/detection/lidar_tracker/id_markes", 10);
-}
-
-void VisualizeDetectedObjects::callBack(const autoware_msgs::DetectedObjectArray&amp; input)
-{
-  visMarkers(input);
-}
-
-void VisualizeDetectedObjects::visMarkers(const autoware_msgs::DetectedObjectArray&amp; input)
-{
-  visualization_msgs::MarkerArray marker_ids, marker_arows;
-
-  for (size_t i = 0; i &lt; input.objects.size(); i++)
-  {
-    // pose_reliable == true if tracking state is stable
-    // skip vizualizing if tracking state is unstable
-    if (!input.objects[i].pose_reliable)
-    {
-      continue;
-    }
-
-    double velocity = input.objects[i].velocity.linear.x;
-
-    tf::Quaternion q(input.objects[i].pose.orientation.x, input.objects[i].pose.orientation.y,
-                     input.objects[i].pose.orientation.z, input.objects[i].pose.orientation.w);
-    double roll, pitch, yaw;
-    tf::Matrix3x3(q).getRPY(roll, pitch, yaw);
-
-    // in the case motion model fit opposite direction
-    if (velocity &lt; -0.1)
-    {
-      velocity *= -1;
-      yaw += M_PI;
-      // normalize angle
-      while (yaw &gt; M_PI)
-        yaw -= 2. * M_PI;
-      while (yaw &lt; -M_PI)
-        yaw += 2. * M_PI;
-    }
-
-    visualization_msgs::Marker id;
-
-    id.lifetime = ros::Duration(0.2);
-    id.header.frame_id = pointcloud_frame_;
-    id.header.stamp = input.header.stamp;
-    id.ns = "id";
-    id.action = visualization_msgs::Marker::ADD;
-    id.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
-    // green
-    id.color.g = 1.0f;
-    id.color.a = 1.0;
-    id.id = input.objects[i].id;
-
-    // Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
-    id.pose.position.x = input.objects[i].pose.position.x;
-    id.pose.position.y = input.objects[i].pose.position.y;
-    id.pose.position.z = vis_id_height_;
-
-    // convert from RPY to quartenion
-    tf::Matrix3x3 obs_mat;
-    obs_mat.setEulerYPR(yaw, 0, 0);  // yaw, pitch, roll
-    tf::Quaternion q_tf;
-    obs_mat.getRotation(q_tf);
-    id.pose.orientation.x = q_tf.getX();
-    id.pose.orientation.y = q_tf.getY();
-    id.pose.orientation.z = q_tf.getZ();
-    id.pose.orientation.w = q_tf.getW();
-
-    id.scale.z = 1.0;
-
-    if (abs(velocity) &lt; ignore_velocity_thres_)
-    {
-      velocity = 0.0;
-    }
-
-    // convert unit m/s to km/h
-    std::string s_velocity = std::to_string(velocity * 3.6);
-    std::string modified_sv = s_velocity.substr(0, s_velocity.find(".") + 3);
-    std::string text = "&lt;" + std::to_string(input.objects[i].id) + "&gt; " + modified_sv + " km/h";
-
-    id.text = text;
-
-    marker_ids.markers.push_back(id);
-
-    visualization_msgs::Marker arrow;
-    arrow.lifetime = ros::Duration(0.2);
-
-    // visualize velocity arrow only if its status is Stable
-    std::string label = input.objects[i].label;
-    if (label == "None" || label == "Initialized" || label == "Lost" || label == "Static")
-    {
-      continue;
-    }
-    if (abs(velocity) &lt; visualize_arrow_velocity_thres_)
-    {
-      continue;
-    }
-
-    arrow.header.frame_id = pointcloud_frame_;
-    arrow.header.stamp = input.header.stamp;
-    arrow.ns = "arrow";
-    arrow.action = visualization_msgs::Marker::ADD;
-    arrow.type = visualization_msgs::Marker::ARROW;
-    // green
-    arrow.color.g = 1.0f;
-    arrow.color.a = 1.0;
-    arrow.id = input.objects[i].id;
-
-    // Set the pose of the marker.  This is a full 6DOF pose relative to the frame/time specified in the header
-    arrow.pose.position.x = input.objects[i].pose.position.x;
-    arrow.pose.position.y = input.objects[i].pose.position.y;
-    arrow.pose.position.z = vis_arrow_height_;
-
-    arrow.pose.orientation.x = q_tf.getX();
-    arrow.pose.orientation.y = q_tf.getY();
-    arrow.pose.orientation.z = q_tf.getZ();
-    arrow.pose.orientation.w = q_tf.getW();
-
-    // Set the scale of the arrow -- 1x1x1 here means 1m on a side
-    arrow.scale.x = 3;
-    arrow.scale.y = 0.1;
-    arrow.scale.z = 0.1;
-
-    marker_arows.markers.push_back(arrow);
-  }  // end input.objects loop
-  pub_id_.publish(marker_ids);
-  pub_arrow_.publish(marker_arows);
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\visualize_detected_objects\visualize_detected_objects_main.cpp" new_path="" added_lines="0" deleted_lines="40">
				<diff>@@ -1,40 +0,0 @@
-/*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "visualize_detected_objects.h"
-
-int main(int argc, char** argv)
-{
-  ros::init(argc, argv, "visualize_detected_objects");
-  VisualizeDetectedObjects app;
-  ros::spin();
-
-  return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.cpp" added_lines="3" deleted_lines="7">
				<diff>@@ -177,11 +177,6 @@ void Yolo3DetectorNode::convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;fl
             if (in_objects[i].h &lt; 0)
                 obj.height = 0;
 
-            obj.color.r = colors_[in_objects[i].class_type].val[0];
-            obj.color.g = colors_[in_objects[i].class_type].val[1];
-            obj.color.b = colors_[in_objects[i].class_type].val[2];
-            obj.color.a = 1.0f;
-
             obj.score = in_objects[i].score;
             if (use_coco_names_)
             {
@@ -192,8 +187,9 @@ void Yolo3DetectorNode::convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;fl
                 if (in_objects[i].class_type &lt; custom_names_.size())
                     obj.label = custom_names_[in_objects[i].class_type];
                 else
-                    obj.label = "unknown label";
+                    obj.label = "unknown";
             }
+            obj.valid = true;
 
             out_message.objects.push_back(obj);
 
@@ -369,7 +365,7 @@ void Yolo3DetectorNode::Run()
         generateColors(colors_, 80);
     #endif
 
-    publisher_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/vision_objects", 1);
+    publisher_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/image_detector/objects", 1);
 
     ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
     subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;Yolo3DetectorNode::image_callback, this);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\include\rect_class_score.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\include\rect_class_score.h" added_lines="64" deleted_lines="39">
				<diff>@@ -4,48 +4,73 @@
 #include &lt;sstream&gt;
 #include &lt;string&gt;
 
-template&lt;typename _Tp&gt; class RectClassScore
+template&lt;typename _Tp&gt;
+class RectClassScore
 {
 public:
-	_Tp x, y, w, h;
-	_Tp score;
-	unsigned int class_type;
-	bool enabled;
+  _Tp x, y, w, h;
+  _Tp score;
+  unsigned int class_type;
+  bool enabled;
 
-	inline std::string toString()
-	{
-		std::ostringstream out;
-		out &lt;&lt; "P(" &lt;&lt; GetClassString() &lt;&lt; ") at " &lt;&lt; "(x:" &lt;&lt; x &lt;&lt; ", y:" &lt;&lt; y &lt;&lt; ", w:" &lt;&lt; w &lt;&lt; ", h:" &lt;&lt; h &lt;&lt; ") =" &lt;&lt; score;
-		return out.str();
-	}
-	inline std::string GetClassString()
-	{
-		switch (class_type)
-		{
-			case 0: return "nothing";
-			case 1: return "plane";
-			case 2: return "bicycle";
-			case 3: return "bird";
-			case 4: return "boat";
-			case 5: return "bottle";
-			case 6: return "bus";
-			case 7: return "car";
-			case 8: return "cat";
-			case 9: return "chair";
-			case 10:return "cow";
-			case 11:return "table";
-			case 12:return "dog";
-			case 13:return "horse";
-			case 14:return "motorbike";
-			case 15:return "person";
-			case 16:return "plant";
-			case 17:return "sheep";
-			case 18:return "sofa";
-			case 19:return "train";
-			case 20:return "tv";
-			default:return "error";
-		}
-	}
+  inline std::string toString()
+  {
+    std::ostringstream out;
+    out &lt;&lt; "P(" &lt;&lt; GetClassString() &lt;&lt; ") at " &lt;&lt; "(x:" &lt;&lt; x &lt;&lt; ", y:" &lt;&lt; y &lt;&lt; ", w:" &lt;&lt; w &lt;&lt; ", h:" &lt;&lt; h &lt;&lt; ") ="
+        &lt;&lt; score;
+    return out.str();
+  }
+
+  inline std::string GetClassString()
+  {
+    switch (class_type)
+    {
+      case 0:
+        return "nothing";
+      case 1:
+        return "plane";
+      case 2:
+        return "bicycle";
+      case 3:
+        return "bird";
+      case 4:
+        return "boat";
+      case 5:
+        return "bottle";
+      case 6:
+        return "bus";
+      case 7:
+        return "car";
+      case 8:
+        return "cat";
+      case 9:
+        return "chair";
+      case 10:
+        return "cow";
+      case 11:
+        return "table";
+      case 12:
+        return "dog";
+      case 13:
+        return "horse";
+      case 14:
+        return "motorbike";
+      case 15:
+        return "person";
+      case 16:
+        return "plant";
+      case 17:
+        return "sheep";
+      case 18:
+        return "sofa";
+      case 19:
+        return "train";
+      case 20:
+        return "tv";
+      default:
+        return "error";
+    }
+  }
 };
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\include\vision_ssd_detect.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\include\vision_ssd_detect.h" added_lines="14" deleted_lines="11">
				<diff>@@ -1,10 +1,6 @@
 #ifndef SSD_DETECTOR_H_
 #define SSD_DETECTOR_H_
 
-#include &lt;caffe/caffe.hpp&gt;
-#include &lt;opencv2/core/core.hpp&gt;
-#include &lt;opencv2/highgui/highgui.hpp&gt;
-#include &lt;opencv2/imgproc/imgproc.hpp&gt;
 #include &lt;algorithm&gt;
 #include &lt;iomanip&gt;
 #include &lt;iosfwd&gt;
@@ -13,6 +9,11 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
+#include &lt;caffe/caffe.hpp&gt;
+#include &lt;opencv2/core/core.hpp&gt;
+#include &lt;opencv2/highgui/highgui.hpp&gt;
+#include &lt;opencv2/imgproc/imgproc.hpp&gt;
+
 #include "rect_class_score.h"
 
 namespace SSD
@@ -36,15 +37,17 @@ public:
 	std::vector &lt;  RectClassScore&lt;float&gt;  &gt; Detect(const cv::Mat&amp; img);
 
 private:
-	void SetMean(const cv::Scalar&amp; in_mean_value);
-	void WrapInputLayer(std::vector&lt;cv::Mat&gt;* input_channels);
-	void Preprocess(const cv::Mat&amp; img, std::vector&lt;cv::Mat&gt;* input_channels);
+  void SetMean(const cv::Scalar &amp;in_mean_value);
+
+  void WrapInputLayer(std::vector&lt;cv::Mat&gt; *input_channels);
+
+  void Preprocess(const cv::Mat &amp;img, std::vector&lt;cv::Mat&gt; *input_channels);
 
 private:
-	boost::shared_ptr&lt;caffe::Net&lt;float&gt; &gt; net_;
-	cv::Size input_geometry_;
-	int num_channels_;
-	cv::Scalar mean_;
+  boost::shared_ptr &lt;caffe::Net&lt;float&gt;&gt; net_;
+  cv::Size input_geometry_;
+  int num_channels_;
+  cv::Scalar mean_;
 };
 
 #endif //SSD_DETECTOR_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect.cpp" added_lines="117" deleted_lines="119">
				<diff>@@ -35,79 +35,78 @@ SSDDetector::SSDDetector(const std::string&amp; in_network_definition_file,
 		const cv::Scalar&amp; in_mean_value,
 		bool in_use_gpu, unsigned int in_gpu_id)
 {
-	if(in_use_gpu)
-	{
-		caffe::Caffe::set_mode(caffe::Caffe::GPU);
-		caffe::Caffe::SetDevice(in_gpu_id);
-	}
-	else
-		caffe::Caffe::set_mode(caffe::Caffe::CPU);
-
-	/* Load the network. */
-	net_.reset(new caffe::Net&lt;float&gt;(in_network_definition_file, caffe::Phase::TEST));
-	net_-&gt;CopyTrainedLayersFrom(in_pre_trained_model_file);
-
-	CHECK_EQ(net_-&gt;num_inputs(), 1)&lt;&lt; "Network should have exactly one input.";
-	CHECK_EQ(net_-&gt;num_outputs(), 1)&lt;&lt; "Network should have exactly one output.";
-
-	caffe::Blob&lt;float&gt;* input_layer = net_-&gt;input_blobs()[0];
-	num_channels_ = input_layer-&gt;channels();
-	CHECK(num_channels_ == 3 || num_channels_ == 1)
-																&lt;&lt; "Input layer should have 1 or 3 channels.";
-	input_geometry_ = cv::Size(input_layer-&gt;width(), input_layer-&gt;height());
-
-	SetMean(in_mean_value);
+  if (in_use_gpu)
+  {
+    caffe::Caffe::set_mode(caffe::Caffe::GPU);
+    caffe::Caffe::SetDevice(in_gpu_id);
+  } else
+    caffe::Caffe::set_mode(caffe::Caffe::CPU);
+
+  /* Load the network. */
+  net_.reset(new caffe::Net&lt;float&gt;(in_network_definition_file, caffe::Phase::TEST));
+  net_-&gt;CopyTrainedLayersFrom(in_pre_trained_model_file);
+
+  CHECK_EQ(net_-&gt;num_inputs(), 1) &lt;&lt; "Network should have exactly one input.";
+  CHECK_EQ(net_-&gt;num_outputs(), 1) &lt;&lt; "Network should have exactly one output.";
+
+  caffe::Blob&lt;float&gt; *input_layer = net_-&gt;input_blobs()[0];
+  num_channels_ = input_layer-&gt;channels();
+  CHECK(num_channels_ == 3 || num_channels_ == 1)
+    &lt;&lt; "Input layer should have 1 or 3 channels.";
+  input_geometry_ = cv::Size(input_layer-&gt;width(), input_layer-&gt;height());
+
+  SetMean(in_mean_value);
 }
 
 std::vector &lt;  RectClassScore&lt;float&gt;  &gt; SSDDetector::Detect(const cv::Mat&amp; img)
 {
-	caffe::Blob&lt;float&gt;* input_layer = net_-&gt;input_blobs()[0];
-	input_layer-&gt;Reshape(1, num_channels_, input_geometry_.height,
-			input_geometry_.width);
-	/* Forward dimension change to all layers. */
-	net_-&gt;Reshape();
-
-	std::vector&lt;cv::Mat&gt; input_channels;
-	WrapInputLayer(&amp;input_channels);
-
-	Preprocess(img, &amp;input_channels);
-
-	net_-&gt;Forward();
-
-	/* Copy the output layer to a std::vector */
-	caffe::Blob&lt;float&gt;* result_blob = net_-&gt;output_blobs()[0];
-	const float* result = result_blob-&gt;cpu_data();
-	const int num_det = result_blob-&gt;height();
-	std::vector &lt;  RectClassScore&lt;float&gt;  &gt; detections;
-	for (int k = 0; k &lt; num_det; ++k)
-	{
-		if (result[0] == -1)
-		{
-			// Skip invalid detection.
-			result += 7;
-			continue;
-		}
-		// Detection format: [image_id (0), label(1), score(2), xmin(3), ymin(4), xmax(5), ymax(6)].
-		RectClassScore&lt;float&gt; detection;
-		detection.class_type = static_cast&lt;int&gt;(result[1]);
-		detection.score = result[2];
-		detection.x 	= result[3] * img.cols;
-		detection.y 	= result[4] * img.rows;
-		detection.w 	= result[5] * img.cols - detection.x;
-		detection.h 	= result[6] * img.rows - detection.y;
-
-		detection.enabled = true;
-
-		detections.push_back(detection);
-		result += 7;
-	}
-	return detections;
+  caffe::Blob&lt;float&gt; *input_layer = net_-&gt;input_blobs()[0];
+  input_layer-&gt;Reshape(1, num_channels_, input_geometry_.height,
+                       input_geometry_.width);
+  /* Forward dimension change to all layers. */
+  net_-&gt;Reshape();
+
+  std::vector &lt;cv::Mat&gt; input_channels;
+  WrapInputLayer(&amp;input_channels);
+
+  Preprocess(img, &amp;input_channels);
+
+  net_-&gt;Forward();
+
+  /* Copy the output layer to a std::vector */
+  caffe::Blob&lt;float&gt; *result_blob = net_-&gt;output_blobs()[0];
+  const float *result = result_blob-&gt;cpu_data();
+  const int num_det = result_blob-&gt;height();
+  std::vector &lt;RectClassScore&lt;float&gt;&gt; detections;
+  for (int k = 0; k &lt; num_det; ++k)
+  {
+    if (result[0] == -1)
+    {
+      // Skip invalid detection.
+      result += 7;
+      continue;
+    }
+    // Detection format: [image_id (0), label(1), score(2), xmin(3), ymin(4), xmax(5), ymax(6)].
+    RectClassScore&lt;float&gt; detection;
+    detection.class_type = static_cast&lt;int&gt;(result[1]);
+    detection.score = result[2];
+    detection.x = result[3] * img.cols;
+    detection.y = result[4] * img.rows;
+    detection.w = result[5] * img.cols - detection.x;
+    detection.h = result[6] * img.rows - detection.y;
+
+    detection.enabled = true;
+
+    detections.push_back(detection);
+    result += 7;
+  }
+  return detections;
 }
 
 
 void SSDDetector::SetMean(const cv::Scalar&amp; in_mean_value)
 {
-	mean_ = in_mean_value;
+  mean_ = in_mean_value;
 }
 
 /* Wrap the input layer of the network in separate cv::Mat objects
@@ -117,64 +116,63 @@ void SSDDetector::SetMean(const cv::Scalar&amp; in_mean_value)
  * layer. */
 void SSDDetector::WrapInputLayer(std::vector&lt;cv::Mat&gt;* input_channels)
 {
-	caffe::Blob&lt;float&gt;* input_layer = net_-&gt;input_blobs()[0];
-
-	int width = input_layer-&gt;width();
-	int height = input_layer-&gt;height();
-	float* input_data = input_layer-&gt;mutable_cpu_data();
-	for (int i = 0; i &lt; input_layer-&gt;channels(); ++i)
-	{
-		cv::Mat channel(height, width, CV_32FC1, input_data);
-		input_channels-&gt;push_back(channel);
-		input_data += width * height;
-	}
+  caffe::Blob&lt;float&gt; *input_layer = net_-&gt;input_blobs()[0];
+
+  int width = input_layer-&gt;width();
+  int height = input_layer-&gt;height();
+  float *input_data = input_layer-&gt;mutable_cpu_data();
+  for (int i = 0; i &lt; input_layer-&gt;channels(); ++i)
+  {
+    cv::Mat channel(height, width, CV_32FC1, input_data);
+    input_channels-&gt;push_back(channel);
+    input_data += width * height;
+  }
 }
 
 void SSDDetector::Preprocess(const cv::Mat&amp; img,
 		std::vector&lt;cv::Mat&gt;* input_channels)
 {
-	/* Convert the input image to the input image format of the network. */
-	cv::Mat sample;
-	if (img.channels() == 3 &amp;&amp; num_channels_ == 1)
-		cv::cvtColor(img, sample, cv::COLOR_BGR2GRAY);
-	else if (img.channels() == 4 &amp;&amp; num_channels_ == 1)
-		cv::cvtColor(img, sample, cv::COLOR_BGRA2GRAY);
-	else if (img.channels() == 4 &amp;&amp; num_channels_ == 3)
-		cv::cvtColor(img, sample, cv::COLOR_BGRA2BGR);
-	else if (img.channels() == 1 &amp;&amp; num_channels_ == 3)
-		cv::cvtColor(img, sample, cv::COLOR_GRAY2BGR);
-	else
-		sample = img;
-
-	cv::Mat sample_resized;
-	if (sample.size() != input_geometry_)
-		cv::resize(sample, sample_resized, input_geometry_);
-	else
-		sample_resized = sample;
-
-	cv::Mat sample_float;
-	cv::Mat mean_img;
-	if (num_channels_ == 3)
-	{
-		sample_resized.convertTo(sample_float, CV_32FC3);
-		mean_img = cv::Mat(input_geometry_,CV_32FC3, mean_);
-	}
-	else
-	{
-		sample_resized.convertTo(sample_float, CV_32FC1);
-		mean_img = cv::Mat(input_geometry_,CV_32FC1, mean_);
-	}
-
-	cv::Mat sample_normalized;
-
-	cv::subtract(sample_float, mean_img, sample_normalized);
-
-	/* This operation will write the separate BGR planes directly to the
-	 * input layer of the network because it is wrapped by the cv::Mat
-	 * objects in input_channels. */
-	cv::split(sample_normalized, *input_channels);
-
-	CHECK(reinterpret_cast&lt;float*&gt;(input_channels-&gt;at(0).data)
-			== net_-&gt;input_blobs()[0]-&gt;cpu_data())
-															&lt;&lt; "Input channels are not wrapping the input layer of the network.";
+  /* Convert the input image to the input image format of the network. */
+  cv::Mat sample;
+  if (img.channels() == 3 &amp;&amp; num_channels_ == 1)
+    cv::cvtColor(img, sample, cv::COLOR_BGR2GRAY);
+  else if (img.channels() == 4 &amp;&amp; num_channels_ == 1)
+    cv::cvtColor(img, sample, cv::COLOR_BGRA2GRAY);
+  else if (img.channels() == 4 &amp;&amp; num_channels_ == 3)
+    cv::cvtColor(img, sample, cv::COLOR_BGRA2BGR);
+  else if (img.channels() == 1 &amp;&amp; num_channels_ == 3)
+    cv::cvtColor(img, sample, cv::COLOR_GRAY2BGR);
+  else
+    sample = img;
+
+  cv::Mat sample_resized;
+  if (sample.size() != input_geometry_)
+    cv::resize(sample, sample_resized, input_geometry_);
+  else
+    sample_resized = sample;
+
+  cv::Mat sample_float;
+  cv::Mat mean_img;
+  if (num_channels_ == 3)
+  {
+    sample_resized.convertTo(sample_float, CV_32FC3);
+    mean_img = cv::Mat(input_geometry_, CV_32FC3, mean_);
+  } else
+  {
+    sample_resized.convertTo(sample_float, CV_32FC1);
+    mean_img = cv::Mat(input_geometry_, CV_32FC1, mean_);
+  }
+
+  cv::Mat sample_normalized;
+
+  cv::subtract(sample_float, mean_img, sample_normalized);
+
+  /* This operation will write the separate BGR planes directly to the
+   * input layer of the network because it is wrapped by the cv::Mat
+   * objects in input_channels. */
+  cv::split(sample_normalized, *input_channels);
+
+  CHECK(reinterpret_cast&lt;float *&gt;(input_channels-&gt;at(0).data)
+        == net_-&gt;input_blobs()[0]-&gt;cpu_data())
+    &lt;&lt; "Input channels are not wrapping the input layer of the network.";
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" added_lines="175" deleted_lines="173">
				<diff>@@ -42,208 +42,210 @@
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 
 #if (CV_MAJOR_VERSION &lt;= 2)
-    #include &lt;opencv2/contrib/contrib.hpp&gt;
+
+#include &lt;opencv2/contrib/contrib.hpp&gt;
+
 #else
-    #include "gencolors.cpp"
+#include "gencolors.cpp"
 #endif
 
 #include "vision_ssd_detect.h"
 
 class ROSSSDApp
 {
-	ros::Subscriber subscriber_image_raw_;
-	ros::Subscriber subscriber_ssd_config_;
-    ros::Publisher publisher_detected_objects_;
-	ros::NodeHandle node_handle_;
+  ros::Subscriber subscriber_image_raw_;
+  ros::Subscriber subscriber_ssd_config_;
+  ros::Publisher publisher_detected_objects_;
+  ros::NodeHandle node_handle_;
 
-	cv::Scalar pixel_mean_;
-    std::vector&lt;cv::Scalar&gt; colors_;
+  cv::Scalar pixel_mean_;
+  std::vector&lt;cv::Scalar&gt; colors_;
 
-	//Caffe based Object Detection ConvNet
-	SSDDetector* ssd_detector_;
+  //Caffe based Object Detection ConvNet
+  SSDDetector* ssd_detector_;
 
-	//The minimum score required to filter the detected objects by the ConvNet
-	float score_threshold_;
+  //The minimum score required to filter the detected objects by the ConvNet
+  float score_threshold_;
 
-	//If GPU is enabled, stores the GPU Device to use
-	unsigned int gpu_device_id_;
+  //If GPU is enabled, stores the GPU Device to use
+  unsigned int gpu_device_id_;
 
-	//Sets whether or not use GPU acceleration
-	bool use_gpu_;
+  //Sets whether or not use GPU acceleration
+  bool use_gpu_;
 
-	//vector of indices of the classes to search for
-	std::vector&lt;unsigned int&gt; detect_classes_;
+  //vector of indices of the classes to search for
+  std::vector&lt;unsigned int&gt; detect_classes_;
 
-	void convert_rect_to_detected_object(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects,
-                                         autoware_msgs::DetectedObjectArray&amp; out_message,
-                                         cv::Mat&amp; in_image)
+  void convert_rect_to_detected_object(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects,
+                                       autoware_msgs::DetectedObjectArray &amp;out_message,
+                                       cv::Mat&amp; in_image)
+  {
+    for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
     {
-        for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
-        {
-            if (in_objects[i].score &gt;= score_threshold_)
-            {
-                autoware_msgs::DetectedObject obj;
-                obj.header = out_message.header;
-                obj.label = in_objects[i].GetClassString();
-                obj.score = in_objects[i].score;
-
-                obj.color.r = colors_[in_objects[i].class_type].val[0];
-                obj.color.g = colors_[in_objects[i].class_type].val[1];
-                obj.color.b = colors_[in_objects[i].class_type].val[2];
-                obj.color.a = 1.0f;
-
-                obj.image_frame = out_message.header.frame_id;
-                obj.x = in_objects[i].x;
-                obj.y = in_objects[i].y;
-                obj.width = in_objects[i].w;
-                obj.height = in_objects[i].h;
-
-                //obj.roi_image = in_image(cv::Rect(obj.x, obj.y, obj.width, obj.height));
-
-                out_message.objects.push_back(obj);
-            }
-        }
+      if (in_objects[i].score &gt;= score_threshold_)
+      {
+        autoware_msgs::DetectedObject obj;
+        obj.header = out_message.header;
+        obj.label = in_objects[i].GetClassString();
+        obj.score = in_objects[i].score;
+
+        obj.color.r = colors_[in_objects[i].class_type].val[0];
+        obj.color.g = colors_[in_objects[i].class_type].val[1];
+        obj.color.b = colors_[in_objects[i].class_type].val[2];
+        obj.color.a = 1.0f;
+
+        obj.image_frame = out_message.header.frame_id;
+        obj.x = in_objects[i].x;
+        obj.y = in_objects[i].y;
+        obj.width = in_objects[i].w;
+        obj.height = in_objects[i].h;
+        obj.valid = true;
+
+        //obj.roi_image = in_image(cv::Rect(obj.x, obj.y, obj.width, obj.height));
+
+        out_message.objects.push_back(obj);
+      }
     }
+  }
+
+  void image_callback(const sensor_msgs::Image &amp;image_source)
+  {
+    //Receive Image, convert it to OpenCV Mat
+    cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source,
+                                                         "bgr8");//toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
+    cv::Mat image = cv_image-&gt;image;
+
+    //Detect Object in image
+    std::vector&lt;RectClassScore &lt; float&gt; &gt; detections;
+    //cv::TickMeter timer; timer.start();
+    //std::cout &lt;&lt; "score:" &lt;&lt; score_threshold_ &lt;&lt; " slices:" &lt;&lt; image_slices_ &lt;&lt; " slices overlap:" &lt;&lt; slices_overlap_ &lt;&lt; "nms" &lt;&lt; group_threshold_ &lt;&lt; std::endl;
+    detections = ssd_detector_-&gt;Detect(image);
+    //timer.stop();
+    //std::cout &lt;&lt; "Detection took: " &lt;&lt; timer.getTimeMilli() &lt;&lt; std::endl;
+
+    //Prepare Output message
+    //Convert Objects to Message type
+    //timer.reset(); timer.start();
+    autoware_msgs::DetectedObjectArray output_detected_message;
+    output_detected_message.header = image_source.header;
+    convert_rect_to_detected_object(detections, output_detected_message, image);
+
+    publisher_detected_objects_.publish(output_detected_message);
+  }
+
+
+  void config_cb(const autoware_config_msgs::ConfigSSD::ConstPtr&amp; param)
+  {
+    score_threshold_ 	= param-&gt;score_threshold;
+  }
 
-	void image_callback(const sensor_msgs::Image&amp; image_source)
-	{
-		//Receive Image, convert it to OpenCV Mat
-		cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source, "bgr8");//toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
-		cv::Mat image = cv_image-&gt;image;
+public:
+  void Run()
+  {
+    //ROS STUFF
+    ros::NodeHandle private_node_handle("~");//to receive args
+
+    //RECEIVE IMAGE TOPIC NAME
+    std::string image_raw_topic_str;
+    if (private_node_handle.getParam("image_raw_node", image_raw_topic_str))
+    {
+      ROS_INFO("Setting image node to %s", image_raw_topic_str.c_str());
+    } else
+    {
+      ROS_INFO("No image node received, defaulting to /image_raw, you can use _image_raw_node:=YOUR_TOPIC");
+      image_raw_topic_str = "/image_raw";
+    }
 
-		//Detect Object in image
-		std::vector&lt; RectClassScore&lt;float&gt; &gt; detections;
-		//cv::TickMeter timer; timer.start();
-		//std::cout &lt;&lt; "score:" &lt;&lt; score_threshold_ &lt;&lt; " slices:" &lt;&lt; image_slices_ &lt;&lt; " slices overlap:" &lt;&lt; slices_overlap_ &lt;&lt; "nms" &lt;&lt; group_threshold_ &lt;&lt; std::endl;
-		detections = ssd_detector_-&gt;Detect(image);
-		//timer.stop();
-		//std::cout &lt;&lt; "Detection took: " &lt;&lt; timer.getTimeMilli() &lt;&lt; std::endl;
+    //RECEIVE CONVNET FILENAMES
+    std::string network_definition_file;
+    std::string pretrained_model_file;
+    if (private_node_handle.getParam("network_definition_file", network_definition_file))
+    {
+      ROS_INFO("Network Definition File: %s", network_definition_file.c_str());
+    } else
+    {
+      ROS_INFO("No Network Definition File was received. Finishing execution.");
+      return;
+    }
+    if (private_node_handle.getParam("pretrained_model_file", pretrained_model_file))
+    {
+      ROS_INFO("Pretrained Model File: %s", pretrained_model_file.c_str());
+    } else
+    {
+      ROS_INFO("No Pretrained Model File was received. Finishing execution.");
+      return;
+    }
 
-		//Prepare Output message
-		//Convert Objects to Message type
-		//timer.reset(); timer.start();
-        autoware_msgs::DetectedObjectArray output_detected_message;
-        output_detected_message.header = image_source.header;
-        convert_rect_to_detected_object(detections, output_detected_message, image);
+    if (private_node_handle.getParam("score_threshold", score_threshold_))
+    {
+      ROS_INFO("Score Threshold: %f", score_threshold_);
+    }
 
-		publisher_detected_objects_.publish(output_detected_message);
-	}
+    if (private_node_handle.getParam("use_gpu", use_gpu_))
+    {
+      ROS_INFO("GPU Mode: %d", use_gpu_);
+    }
+    int gpu_id;
+    if (private_node_handle.getParam("gpu_device_id", gpu_id))
+    {
+      ROS_INFO("GPU Device ID: %d", gpu_id);
+      gpu_device_id_ = (unsigned int) gpu_id;
+    }
 
+    //SSD STUFF
+    ssd_detector_ = new SSDDetector(network_definition_file, pretrained_model_file, pixel_mean_, use_gpu_, gpu_device_id_);
 
-	void config_cb(const autoware_config_msgs::ConfigSSD::ConstPtr&amp; param)
-	{
-		score_threshold_ 	= param-&gt;score_threshold;
-	}
+    if (NULL == ssd_detector_)
+    {
+      ROS_INFO("Error while creating SSD Object");
+      return;
+    }
+    ROS_INFO("SSD Detector initialized.");
 
-public:
-	void Run()
-	{
-		//ROS STUFF
-		ros::NodeHandle private_node_handle("~");//to receive args
-
-		//RECEIVE IMAGE TOPIC NAME
-		std::string image_raw_topic_str;
-		if (private_node_handle.getParam("image_raw_node", image_raw_topic_str))
-		{
-			ROS_INFO("Setting image node to %s", image_raw_topic_str.c_str());
-		}
-		else
-		{
-			ROS_INFO("No image node received, defaulting to /image_raw, you can use _image_raw_node:=YOUR_TOPIC");
-			image_raw_topic_str = "/image_raw";
-		}
-
-		//RECEIVE CONVNET FILENAMES
-		std::string network_definition_file;
-		std::string pretrained_model_file;
-		if (private_node_handle.getParam("network_definition_file", network_definition_file))
-		{
-			ROS_INFO("Network Definition File: %s", network_definition_file.c_str());
-		}
-		else
-		{
-			ROS_INFO("No Network Definition File was received. Finishing execution.");
-			return;
-		}
-		if (private_node_handle.getParam("pretrained_model_file", pretrained_model_file))
-		{
-			ROS_INFO("Pretrained Model File: %s", pretrained_model_file.c_str());
-		}
-		else
-		{
-			ROS_INFO("No Pretrained Model File was received. Finishing execution.");
-			return;
-		}
-
-		if (private_node_handle.getParam("score_threshold", score_threshold_))
-		{
-			ROS_INFO("Score Threshold: %f", score_threshold_);
-		}
-
-		if (private_node_handle.getParam("use_gpu", use_gpu_))
-		{
-			ROS_INFO("GPU Mode: %d", use_gpu_);
-		}
-		int gpu_id;
-		if (private_node_handle.getParam("gpu_device_id", gpu_id ))
-		{
-			ROS_INFO("GPU Device ID: %d", gpu_id);
-			gpu_device_id_ = (unsigned int) gpu_id;
-		}
-
-		//SSD STUFF
-		ssd_detector_ = new SSDDetector(network_definition_file, pretrained_model_file, pixel_mean_, use_gpu_, gpu_device_id_);
-
-		if (NULL == ssd_detector_)
-		{
-			ROS_INFO("Error while creating SSD Object");
-			return;
-		}
-		ROS_INFO("SSD Detector initialized.");
-
-        #if (CV_MAJOR_VERSION &lt;= 2)
-            cv::generateColors(colors_, 20);
-        #else
-            generateColors(colors_, 20);
-        #endif
-
-        publisher_detected_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/vision_objects", 1);
-
-		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
-		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;ROSSSDApp::image_callback, this);
-
-		std::string config_topic("/config");
-		config_topic += "/ssd";
-		subscriber_ssd_config_ = node_handle_.subscribe(config_topic, 1, &amp;ROSSSDApp::config_cb, this);
-
-		ros::spin();
-		ROS_INFO("END SSD");
-
-	}
-
-	~ROSSSDApp()
-	{
-		if (NULL != ssd_detector_)
-			delete ssd_detector_;
-	}
-
-	ROSSSDApp()
-	{
-		ssd_detector_ 	= NULL;
-		score_threshold_= 0.5;
-		use_gpu_ 		= false;
-		gpu_device_id_ 	= 0;
-		pixel_mean_		= cv::Scalar(102.9801, 115.9465, 122.7717);
-	}
+#if (CV_MAJOR_VERSION &lt;= 2)
+    cv::generateColors(colors_, 20);
+#else
+    generateColors(colors_, 20);
+#endif
+
+    publisher_detected_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;(
+      "/detection/image_detector/objects", 1);
+
+    ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
+    subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;ROSSSDApp::image_callback, this);
+
+    std::string config_topic("/config");
+    config_topic += "/ssd";
+    subscriber_ssd_config_ = node_handle_.subscribe(config_topic, 1, &amp;ROSSSDApp::config_cb, this);
+
+    ros::spin();
+    ROS_INFO("END SSD");
+
+  }
+
+  ~ROSSSDApp()
+  {
+    if (NULL != ssd_detector_)
+      delete ssd_detector_;
+  }
+
+  ROSSSDApp()
+  {
+    ssd_detector_ 	= NULL;
+    score_threshold_= 0.5;
+    use_gpu_ 		= false;
+    gpu_device_id_ 	= 0;
+    pixel_mean_		= cv::Scalar(102.9801, 115.9465, 122.7717);
+  }
 };
 
 int main(int argc, char **argv)
 {
-	ros::init(argc, argv, "ssd_unc");
+  ros::init(argc, argv, "ssd_unc");
 
-	ROSSSDApp app;
+  ROSSSDApp app;
 
 	app.Run();
 
-	return 0;
+  return 0;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\include\detection.h" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\include\detection.h" added_lines="244" deleted_lines="244">
				<diff>@@ -50,253 +50,253 @@ using namespace ClipperLib;
 
 namespace beyondtrack
 {
-    typedef struct ObjectCuboid_
+  typedef struct ObjectCuboid_
+  {
+    double avg_l, avg_h, avg_w;
+    double sz_ub_l, sz_ub_h, sz_ub_w;
+    double sz_lb_l, sz_lb_h, sz_lb_w;
+
+    ObjectCuboid_(double avg_car_sz[3], double sz_ub[3], double sz_lb[3])
+    {
+      avg_l = avg_car_sz[0];
+      avg_h = avg_car_sz[1];
+      avg_w = avg_car_sz[2];
+      sz_ub_l = sz_ub[0];
+      sz_ub_h = sz_ub[1];
+      sz_ub_w = sz_ub[2];
+      sz_lb_l = sz_lb[0];
+      sz_lb_h = sz_lb[1];
+      sz_lb_w = sz_lb[2];
+    }
+
+  } ObjectCuboid;
+
+  class Detection
+  {
+
+  public:
+    // average car parameters in meters [l, h, w];
+    static ObjectCuboid params_car_cuboid_;
+    // static ObjectCuboid params_PersonCuboid;
+
+    int object_id_;
+    double bbox_[4];
+    double yaw_;
+    std::string class_type_;
+    cv::Mat sigma_3D;
+    cv::Mat B1Q;
+    cv::Mat origin_;
+    cv::Mat bvolume_;
+    cv::Mat bvolume_proj_;
+
+    double cd_area_;
+    cv::Mat cd_2d_;
+    std::vector&lt;cv::Point&gt; pd_2d_convhull_;
+    Paths pd_2d_convhull_clip_;
+    Paths cd_2d_convhull_clip_;
+
+    std::vector&lt;cv::Point&gt; pd_3d_convhull_;
+    std::vector&lt;cv::Point&gt; cd_3d_convhull_;
+    Paths pd_3d_convhull_clip_;
+    Paths cd_3d_convhull_clip_;
+
+    Detection(int x, int y, int width, int height, std::string class_type)
+    {
+      object_id_ = -1;
+      bbox_[0] = (double) x;
+      bbox_[1] = (double) y;
+      bbox_[2] = (double) (x + width);
+      bbox_[3] = (double) (y + height);
+      //std::cout &lt;&lt; "bbox_: " &lt;&lt; bbox_[0] &lt;&lt; '\t' &lt;&lt; bbox_[1] &lt;&lt; '\t' &lt;&lt; bbox_[2] &lt;&lt; '\t' &lt;&lt; bbox_[3] &lt;&lt; '\n';
+      yaw_ = deg2rad(-90);
+      sigma_3D = (cv::Mat_&lt;double&gt;(4, 4) &lt;&lt;
+                                         1.3, 0, 0, 0, 0, 1.1, 0, 0, 0, 0, 1.1, 0, 0, 0, 0, deg2rad(0));
+      class_type_ = class_type;
+    }
+
+    Detection(std::vector&lt;double&gt; det, std::string class_type)
+    {
+      object_id_ = -1;
+      bbox_[0] = det[0];
+      bbox_[1] = det[1];
+      bbox_[2] = det[2];
+      bbox_[3] = det[3];
+      yaw_ = deg2rad(-90);
+      sigma_3D = (cv::Mat_&lt;double&gt;(4, 4) &lt;&lt;
+                                         1.3, 0, 0, 0, 0, 1.1, 0, 0, 0, 0, 1.1, 0, 0, 0, 0, deg2rad(0));
+      class_type_ = class_type;
+    }
+
+    void propagate_prev_det(cv::Mat k, cv::Mat motion)
+    {
+      // std::cout &lt;&lt; "### Propagate previous detection###\n";
+      B1Q = origin_;
+      cv::Mat bvolume = bvolume_;
+      B1Q = B1Q + motion.colRange(0, 3).t();
+      bvolume += repeat(motion.colRange(0, 3), bvolume.size().height, 1);
+      bvolume -= repeat(B1Q.t(), bvolume.size().height, 1);
+      bvolume = get_boundingbox_volume(bvolume, motion.at&lt;double&gt;(0, 3)); //translated_cuboid);
+      origin_ = B1Q;
+      bvolume_ = bvolume;
+      bvolume_proj_ = bvolume_ * k.t();
+      bvolume_proj_.colRange(0, 3) /= repeat(bvolume_proj_.col(2), 1, 3);
+
+      // Pre-calculate the convexhull -- 3d --
+      cv::Mat pd_3d_xz = cv::Mat(bvolume_.size().height, 2, CV_64FC1);
+      bvolume_.col(0).copyTo(pd_3d_xz.col(0));
+      bvolume_.col(2).copyTo(pd_3d_xz.col(1));
+      pd_3d_xz.convertTo(pd_3d_xz, CV_32FC1);
+
+      pd_3d_convhull_ = get_convhull(pd_3d_xz * 100); // due to cast
+
+      Paths pd_3d_convhull_clip(1);
+      for (const auto &amp;e: pd_3d_convhull_)
+      {
+        pd_3d_convhull_clip[0] &lt;&lt; IntPoint(e.x, e.y);
+      }
+      pd_3d_convhull_clip_ = pd_3d_convhull_clip;
+
+      // Pre-calculate the convexhull -- 2d --
+      cv::Mat pd_2d = bvolume_proj_.colRange(0, 2);
+      pd_2d.convertTo(pd_2d, CV_32FC1);
+
+      pd_2d_convhull_ = get_convhull(pd_2d);
+
+      Paths pd_2d_convhull_clip(1);
+      for (const auto &amp;e: pd_2d_convhull_)
+      {
+        pd_2d_convhull_clip[0] &lt;&lt; IntPoint(e.x, e.y);
+      }
+      pd_2d_convhull_clip_ = pd_2d_convhull_clip;
+    }
+
+    void propagate_cur_det(cv::Mat cuboid, double h, cv::Mat k, cv::Mat inv_k, cv::Mat n)
+    {
+      // std::cout &lt;&lt; "Propagate current detection\n";
+      cv::Mat b1Q = (cv::Mat_&lt;double&gt;(3, 1) &lt;&lt; bbox_[0] + (bbox_[2] - bbox_[0]) / 2, bbox_[3], 1.0);
+      B1Q = (h * inv_k * b1Q) / (n * inv_k * b1Q);
+      // apply offset which is a function of yaw and get car's origin.
+      double offset_z = calc_offset_base_yaw();
+      B1Q.at&lt;double&gt;(0, 2) += offset_z;
+      cv::Mat bvolume = get_boundingbox_volume(cuboid, yaw_); //translated_cuboid);
+      origin_ = B1Q;
+      cv::Mat offset = (cv::Mat_&lt;double&gt;(1, 3) &lt;&lt; 0, params_car_cuboid_.avg_w / 2., 0);
+      bvolume_ = bvolume - repeat(offset, bvolume.size().height, 1);
+      bvolume_proj_ = bvolume_ * k.t();
+      bvolume_proj_.colRange(0, 3) /= repeat(bvolume_proj_.col(2), 1, 3);
+
+      // Pre-calculate the convexhull -- 3d --
+      cv::Mat bvolume_xy = cv::Mat(bvolume_.size().height, 2, CV_64FC1);
+      bvolume_.col(0).copyTo(bvolume_xy.col(0));
+      bvolume_.col(2).copyTo(bvolume_xy.col(1));
+      bvolume_xy.convertTo(bvolume_xy, CV_32FC1);
+
+      cd_3d_convhull_ = get_convhull(bvolume_xy * 100); // due to cast
+
+      Paths cd_3d_convhull_clip(1);
+      for (const auto &amp;e: cd_3d_convhull_)
+      {
+        cd_3d_convhull_clip[0] &lt;&lt; IntPoint(e.x, e.y);
+      }
+      cd_3d_convhull_clip_ = cd_3d_convhull_clip;
+
+      // Pre-calculate the convexhull -- 2d --
+      cd_2d_ = (cv::Mat_&lt;double&gt;(4, 2) &lt;&lt;
+                                       bbox_[0], bbox_[1], bbox_[2], bbox_[1], bbox_[2], bbox_[3], bbox_[0], bbox_[3]);
+
+      Paths cd_2d_convhull_clip(1);
+      for (int i = 0; i &lt; 4; ++i)
+      {
+        cd_2d_convhull_clip[0] &lt;&lt; IntPoint((int) cd_2d_.at&lt;double&gt;(i, 0), (int) cd_2d_.at&lt;double&gt;(i, 1));
+      }
+      cd_2d_convhull_clip_ = cd_2d_convhull_clip;
+
+      cd_area_ = (bbox_[3] - bbox_[1]) * (bbox_[2] - bbox_[0]);
+    }
+
+  private:
+
+    double calc_offset_base_yaw()
     {
-        double avg_l, avg_h, avg_w;
-        double sz_ub_l, sz_ub_h, sz_ub_w;
-        double sz_lb_l, sz_lb_h, sz_lb_w;
-
-        ObjectCuboid_(double avg_car_sz[3], double sz_ub[3], double sz_lb[3])
-        {
-            avg_l = avg_car_sz[0];
-            avg_h = avg_car_sz[1];
-            avg_w = avg_car_sz[2];
-            sz_ub_l = sz_ub[0];
-            sz_ub_h = sz_ub[1];
-            sz_ub_w = sz_ub[2];
-            sz_lb_l = sz_lb[0];
-            sz_lb_h = sz_lb[1];
-            sz_lb_w = sz_lb[2];
-        }
-
-    } ObjectCuboid;
-
-    class Detection
+      double offset;
+      double l = params_car_cuboid_.avg_l / 2.;
+      double w = params_car_cuboid_.avg_w / 2.;
+      cv::Mat car_bottom_plane = (cv::Mat_&lt;double&gt;(4, 2) &lt;&lt; -l, -w, l, -w, l, w, -l, w);
+      car_bottom_plane = car_bottom_plane.t();
+
+      cv::Mat rot = (cv::Mat_&lt;double&gt;(2, 2) &lt;&lt; cos(yaw_), -sin(yaw_), sin(yaw_), cos(yaw_));
+      cv::Mat car_bottom_plane_rot = (rot * car_bottom_plane).t();
+      cv::Mat sum_mat;
+      cv::reduce(car_bottom_plane_rot, sum_mat, 1, CV_REDUCE_SUM);
+      double min_val, max_val;
+      CvPoint min_loc = cvPoint(0, 0);
+      CvPoint max_loc = cvPoint(0, 0);
+      CvMat cvmat = sum_mat;
+      cvMinMaxLoc(&amp;cvmat, &amp;min_val, &amp;max_val, &amp;min_loc, &amp;max_loc);
+      offset =
+        abs(car_bottom_plane_rot.at&lt;double&gt;(max_loc.y, 1) - car_bottom_plane_rot.at&lt;double&gt;(min_loc.y, 1)) /
+        2.;
+      return offset;
+    }
+
+    cv::Mat get_boundingbox_volume(cv::Mat cuboid, double ry)
     {
+      double ry_n = sigma_3D.at&lt;double&gt;(3, 3);
+      cv::Mat centered_pts = cuboid; //cuboid - repeat(B1Q.t(), 8, 1);
+      // ry_n = 0.5;
+      cv::Mat rot_pts_plus_yaw = centered_pts * rot_mat_y(ry_n).t();
+      cv::Mat rot_pts_minus_yaw = centered_pts * rot_mat_y(-ry_n).t();
+      cv::Mat pts;
+      vconcat(centered_pts, rot_pts_plus_yaw, pts);
+      vconcat(pts, rot_pts_minus_yaw, pts);
+
+      cv::Mat scale_mat = sigma_3D(cv::Range(0, 3), cv::Range(0, 3));
+      cv::Mat bvolume = pts * scale_mat;
+      // cv::Mat m_bvolume = -bvolume;
+      // cv::cvThreshold(bvolume, bvolume);
+
+      bvolume = bvolume * rot_mat_y(ry).t();
+      bvolume = bvolume + repeat(B1Q.t(), bvolume.size().height, 1);
+      return bvolume;
+    }
+
+    std::vector&lt;cv::Point&gt; get_convhull(cv::Mat mat_2d)
+    {
+      int size_pd = mat_2d.size().height;
+      std::vector&lt;cv::Point&gt; mat_2d_convhull(1);
+      std::vector&lt;cv::Point&gt; mat_2d_vec;
+      for (int i = 0; i &lt; size_pd; ++i)
+      {
+        cv::Mat a = mat_2d.row(i);
+        cv::Point b = (cv::Point) a;
+        mat_2d_vec.push_back(b);
+      }
+
+      cv::convexHull(mat_2d_vec, mat_2d_convhull, false);
+      return mat_2d_convhull;
+    }
+
+    cv::Mat rot_mat_x(double r)
+    {
+      return (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; 1.0, 0.0, 0.0,
+        0.0, cos(r), -sin(r),
+        0.0, sin(r), cos(r));
+    }
 
-    public:
-        // average car parameters in meters [l, h, w];
-        static ObjectCuboid params_car_cuboid_;
-        // static ObjectCuboid params_PersonCuboid;
-
-        int object_id_;
-        double bbox_[4];
-        double yaw_;
-        std::string class_type_;
-        cv::Mat sigma_3D;
-        cv::Mat B1Q;
-        cv::Mat origin_;
-        cv::Mat bvolume_;
-        cv::Mat bvolume_proj_;
-
-        double cd_area_;
-        cv::Mat cd_2d_;
-        std::vector&lt;cv::Point&gt; pd_2d_convhull_;
-        Paths pd_2d_convhull_clip_;
-        Paths cd_2d_convhull_clip_;
-
-        std::vector&lt;cv::Point&gt; pd_3d_convhull_;
-        std::vector&lt;cv::Point&gt; cd_3d_convhull_;
-        Paths pd_3d_convhull_clip_;
-        Paths cd_3d_convhull_clip_;
-
-        Detection(int x, int y, int width, int height, std::string class_type)
-        {
-            object_id_ = -1;
-            bbox_[0] = (double) x;
-            bbox_[1] = (double) y;
-            bbox_[2] = (double) (x + width);
-            bbox_[3] = (double) (y + height);
-            //std::cout &lt;&lt; "bbox_: " &lt;&lt; bbox_[0] &lt;&lt; '\t' &lt;&lt; bbox_[1] &lt;&lt; '\t' &lt;&lt; bbox_[2] &lt;&lt; '\t' &lt;&lt; bbox_[3] &lt;&lt; '\n';
-            yaw_ = deg2rad(-90);
-            sigma_3D = (cv::Mat_&lt;double&gt;(4, 4) &lt;&lt;
-                                               1.3, 0, 0, 0, 0, 1.1, 0, 0, 0, 0, 1.1, 0, 0, 0, 0, deg2rad(0));
-            class_type_ = class_type;
-        }
-
-        Detection(std::vector&lt;double&gt; det, std::string class_type)
-        {
-            object_id_ = -1;
-            bbox_[0] = det[0];
-            bbox_[1] = det[1];
-            bbox_[2] = det[2];
-            bbox_[3] = det[3];
-            yaw_ = deg2rad(-90);
-            sigma_3D = (cv::Mat_&lt;double&gt;(4, 4) &lt;&lt;
-                                               1.3, 0, 0, 0, 0, 1.1, 0, 0, 0, 0, 1.1, 0, 0, 0, 0, deg2rad(0));
-            class_type_ = class_type;
-        }
-
-        void propagate_prev_det(cv::Mat k, cv::Mat motion)
-        {
-            // std::cout &lt;&lt; "### Propagate previous detection###\n";
-            B1Q = origin_;
-            cv::Mat bvolume = bvolume_;
-            B1Q = B1Q + motion.colRange(0, 3).t();
-            bvolume += repeat(motion.colRange(0, 3), bvolume.size().height, 1);
-            bvolume -= repeat(B1Q.t(), bvolume.size().height, 1);
-            bvolume = get_boundingbox_volume(bvolume, motion.at&lt;double&gt;(0, 3)); //translated_cuboid);
-            origin_ = B1Q;
-            bvolume_ = bvolume;
-            bvolume_proj_ = bvolume_ * k.t();
-            bvolume_proj_.colRange(0, 3) /= repeat(bvolume_proj_.col(2), 1, 3);
-
-            // Pre-calculate the convexhull -- 3d --
-            cv::Mat pd_3d_xz = cv::Mat(bvolume_.size().height, 2, CV_64FC1);
-            bvolume_.col(0).copyTo(pd_3d_xz.col(0));
-            bvolume_.col(2).copyTo(pd_3d_xz.col(1));
-            pd_3d_xz.convertTo(pd_3d_xz, CV_32FC1);
-
-            pd_3d_convhull_ = get_convhull(pd_3d_xz * 100); // due to cast
-
-            Paths pd_3d_convhull_clip(1);
-            for (const auto &amp;e: pd_3d_convhull_)
-            {
-                pd_3d_convhull_clip[0] &lt;&lt; IntPoint(e.x, e.y);
-            }
-            pd_3d_convhull_clip_ = pd_3d_convhull_clip;
-
-            // Pre-calculate the convexhull -- 2d --
-            cv::Mat pd_2d = bvolume_proj_.colRange(0, 2);
-            pd_2d.convertTo(pd_2d, CV_32FC1);
-
-            pd_2d_convhull_ = get_convhull(pd_2d);
-
-            Paths pd_2d_convhull_clip(1);
-            for (const auto &amp;e: pd_2d_convhull_)
-            {
-                pd_2d_convhull_clip[0] &lt;&lt; IntPoint(e.x, e.y);
-            }
-            pd_2d_convhull_clip_ = pd_2d_convhull_clip;
-        }
-
-        void propagate_cur_det(cv::Mat cuboid, double h, cv::Mat k, cv::Mat inv_k, cv::Mat n)
-        {
-            // std::cout &lt;&lt; "Propagate current detection\n";
-            cv::Mat b1Q = (cv::Mat_&lt;double&gt;(3, 1) &lt;&lt; bbox_[0] + (bbox_[2] - bbox_[0]) / 2, bbox_[3], 1.0);
-            B1Q = (h * inv_k * b1Q) / (n * inv_k * b1Q);
-            // apply offset which is a function of yaw and get car's origin.
-            double offset_z = calc_offset_base_yaw();
-            B1Q.at&lt;double&gt;(0, 2) += offset_z;
-            cv::Mat bvolume = get_boundingbox_volume(cuboid, yaw_); //translated_cuboid);
-            origin_ = B1Q;
-            cv::Mat offset = (cv::Mat_&lt;double&gt;(1, 3) &lt;&lt; 0, params_car_cuboid_.avg_w / 2., 0);
-            bvolume_ = bvolume - repeat(offset, bvolume.size().height, 1);
-            bvolume_proj_ = bvolume_ * k.t();
-            bvolume_proj_.colRange(0, 3) /= repeat(bvolume_proj_.col(2), 1, 3);
-
-            // Pre-calculate the convexhull -- 3d --
-            cv::Mat bvolume_xy = cv::Mat(bvolume_.size().height, 2, CV_64FC1);
-            bvolume_.col(0).copyTo(bvolume_xy.col(0));
-            bvolume_.col(2).copyTo(bvolume_xy.col(1));
-            bvolume_xy.convertTo(bvolume_xy, CV_32FC1);
-
-            cd_3d_convhull_ = get_convhull(bvolume_xy * 100); // due to cast
-
-            Paths cd_3d_convhull_clip(1);
-            for (const auto &amp;e: cd_3d_convhull_)
-            {
-                cd_3d_convhull_clip[0] &lt;&lt; IntPoint(e.x, e.y);
-            }
-            cd_3d_convhull_clip_ = cd_3d_convhull_clip;
-
-            // Pre-calculate the convexhull -- 2d --
-            cd_2d_ = (cv::Mat_&lt;double&gt;(4, 2) &lt;&lt;
-                                             bbox_[0], bbox_[1], bbox_[2], bbox_[1], bbox_[2], bbox_[3], bbox_[0], bbox_[3]);
-
-            Paths cd_2d_convhull_clip(1);
-            for (int i = 0; i &lt; 4; ++i)
-            {
-                cd_2d_convhull_clip[0] &lt;&lt; IntPoint((int) cd_2d_.at&lt;double&gt;(i, 0), (int) cd_2d_.at&lt;double&gt;(i, 1));
-            }
-            cd_2d_convhull_clip_ = cd_2d_convhull_clip;
-
-            cd_area_ = (bbox_[3] - bbox_[1]) * (bbox_[2] - bbox_[0]);
-        }
-
-    private:
-
-        double calc_offset_base_yaw()
-        {
-            double offset;
-            double l = params_car_cuboid_.avg_l / 2.;
-            double w = params_car_cuboid_.avg_w / 2.;
-            cv::Mat car_bottom_plane = (cv::Mat_&lt;double&gt;(4, 2) &lt;&lt; -l, -w, l, -w, l, w, -l, w);
-            car_bottom_plane = car_bottom_plane.t();
-
-            cv::Mat rot = (cv::Mat_&lt;double&gt;(2, 2) &lt;&lt; cos(yaw_), -sin(yaw_), sin(yaw_), cos(yaw_));
-            cv::Mat car_bottom_plane_rot = (rot * car_bottom_plane).t();
-            cv::Mat sum_mat;
-            cv::reduce(car_bottom_plane_rot, sum_mat, 1, CV_REDUCE_SUM);
-            double min_val, max_val;
-            CvPoint min_loc = cvPoint(0, 0);
-            CvPoint max_loc = cvPoint(0, 0);
-            CvMat cvmat = sum_mat;
-            cvMinMaxLoc(&amp;cvmat, &amp;min_val, &amp;max_val, &amp;min_loc, &amp;max_loc);
-            offset =
-                    abs(car_bottom_plane_rot.at&lt;double&gt;(max_loc.y, 1) - car_bottom_plane_rot.at&lt;double&gt;(min_loc.y, 1)) /
-                    2.;
-            return offset;
-        }
-
-        cv::Mat get_boundingbox_volume(cv::Mat cuboid, double ry)
-        {
-            double ry_n = sigma_3D.at&lt;double&gt;(3, 3);
-            cv::Mat centered_pts = cuboid; //cuboid - repeat(B1Q.t(), 8, 1);
-            // ry_n = 0.5;
-            cv::Mat rot_pts_plus_yaw = centered_pts * rot_mat_y(ry_n).t();
-            cv::Mat rot_pts_minus_yaw = centered_pts * rot_mat_y(-ry_n).t();
-            cv::Mat pts;
-            vconcat(centered_pts, rot_pts_plus_yaw, pts);
-            vconcat(pts, rot_pts_minus_yaw, pts);
-
-            cv::Mat scale_mat = sigma_3D(cv::Range(0, 3), cv::Range(0, 3));
-            cv::Mat bvolume = pts * scale_mat;
-            // cv::Mat m_bvolume = -bvolume;
-            // cv::cvThreshold(bvolume, bvolume);
-
-            bvolume = bvolume * rot_mat_y(ry).t();
-            bvolume = bvolume + repeat(B1Q.t(), bvolume.size().height, 1);
-            return bvolume;
-        }
-
-        std::vector&lt;cv::Point&gt; get_convhull(cv::Mat mat_2d)
-        {
-            int size_pd = mat_2d.size().height;
-            std::vector&lt;cv::Point&gt; mat_2d_convhull(1);
-            std::vector&lt;cv::Point&gt; mat_2d_vec;
-            for (int i = 0; i &lt; size_pd; ++i)
-            {
-                cv::Mat a = mat_2d.row(i);
-                cv::Point b = (cv::Point) a;
-                mat_2d_vec.push_back(b);
-            }
-
-            cv::convexHull(mat_2d_vec, mat_2d_convhull, false);
-            return mat_2d_convhull;
-        }
-
-        cv::Mat rot_mat_x(double r)
-        {
-            return (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; 1.0, 0.0, 0.0,
-                    0.0, cos(r), -sin(r),
-                    0.0, sin(r), cos(r));
-        }
-
-        cv::Mat rot_mat_y(double r)
-        {
-            return (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; cos(r), 0.0, sin(r),
-                    0.0, 1.0, 0.0,
-                    -sin(r), 0.0, cos(r));
-        }
-
-        cv::Mat rot_mat_z(double r)
-        {
-            return (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; cos(r), -sin(r), 0.0,
-                    sin(r), cos(r), 0.0,
-                    0.0, 0.0, 1.0);
-        }
-    };
+    cv::Mat rot_mat_y(double r)
+    {
+      return (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; cos(r), 0.0, sin(r),
+        0.0, 1.0, 0.0,
+        -sin(r), 0.0, cos(r));
+    }
+
+    cv::Mat rot_mat_z(double r)
+    {
+      return (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; cos(r), -sin(r), 0.0,
+        sin(r), cos(r), 0.0,
+        0.0, 0.0, 1.0);
+    }
+  };
 }
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\include\vision_beyond_track.h" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\include\vision_beyond_track.h" added_lines="61" deleted_lines="57">
				<diff>@@ -59,91 +59,95 @@
 
 namespace beyondtrack
 {
-    class BeyondTracker
-    {
-    private:
-        int global_id_ = 1;
-        bool initialized_ = false;
-        std::vector&lt;Detection&gt; cur_detections_;
-        std::vector&lt;Detection&gt; prev_detections_;
-        cv::Mat cur_pose_;
-        cv::Mat prev_pose_;
-        double all_wts_[4] = {0.6, 0.4, 0.2, 0.0};
+  class BeyondTracker
+  {
+  private:
+    int global_id_ = 1;
+    bool initialized_ = false;
+    std::vector&lt;Detection&gt; cur_detections_;
+    std::vector&lt;Detection&gt; prev_detections_;
+    cv::Mat cur_pose_;
+    cv::Mat prev_pose_;
+    double all_wts_[4] = {0.6, 0.4, 0.2, 0.0};
 
-        cv::Mat camera_k_;
-        cv::Mat camera_inv_k_;
-        cv::Mat motion_;
-        cv::Mat canonical_cuboid_ = create_cuboid();
+    cv::Mat camera_k_;
+    cv::Mat camera_inv_k_;
+    cv::Mat motion_;
+    cv::Mat canonical_cuboid_ = create_cuboid();
 
-        void initialize(cv::Mat n, double h);
+    void initialize(cv::Mat n, double h);
 
-        cv::Mat create_cuboid();
+    cv::Mat create_cuboid();
 
-        void propagate_detections(cv::Mat n, double h);
+    void propagate_detections(cv::Mat n, double h);
 
-        std::vector&lt;vector&lt;double&gt;&gt; generate_score_matrices();
+    std::vector&lt;vector&lt;double&gt;&gt; generate_score_matrices();
 
-    public:
+  public:
 
-        BeyondTracker()
-        {
-        };
+    BeyondTracker()
+    {
+    };
 
-        BeyondTracker(cv::Mat k_);
+    BeyondTracker(cv::Mat k_);
 
-        ~BeyondTracker()
-        {
-        };
+    ~BeyondTracker()
+    {
+    };
 
-        void process(std::vector&lt;Detection&gt; in_detections, cv::Mat in_pose, cv::Mat in_angle, double in_height);
+    void process(std::vector&lt;Detection&gt; in_detections, cv::Mat in_pose, cv::Mat in_angle, double in_height);
 
-        std::vector&lt;Detection&gt; get_results();
+    std::vector&lt;Detection&gt; get_results();
 
-        void set_intrinsic(cv::Mat k_);
+    void set_intrinsic(cv::Mat k_);
 
-        double get_3d2d_score(Detection cd, Detection pd);
+    double get_3d2d_score(Detection cd, Detection pd);
 
-        double get_3d3d_score(Detection cd, Detection pd);
+    double get_3d3d_score(Detection cd, Detection pd);
 
-    };
+  };
 }
 
 class BeyondTrackerNode
 {
-    ros::Subscriber rect_image_subscriber_;
-    ros::Subscriber intrinsics_subscriber_;
-    ros::Subscriber detections_vision_subscriber_;
-    ros::Subscriber ego_motion_subscriber_;
+  ros::Subscriber rect_image_subscriber_;
+  ros::Subscriber intrinsics_subscriber_;
+  ros::Subscriber detections_vision_subscriber_;
+  ros::Subscriber ego_motion_subscriber_;
+
+  ros::Publisher objects_publisher_;
+  ros::NodeHandle node_handle_;
+
+  beyondtrack::BeyondTracker tracker_;
+
+  double image_ratio_;//resize ratio used to fit input image to network input size
+  uint32_t image_top_bottom_border_;//black strips added to the input image to maintain aspect ratio while resizing it to fit the network input size
+  uint32_t image_left_right_border_;
+  std::vector&lt;cv::Scalar&gt; colors_;
 
-    ros::Publisher objects_publisher_;
-    ros::NodeHandle node_handle_;
+  cv::Size image_size_;
+  cv::Mat camera_instrinsics_;
+  bool camera_info_ok_;
 
-    beyondtrack::BeyondTracker tracker_;
+  bool use_motion_ = false;
 
-    double image_ratio_;//resize ratio used to fit input image to network input size
-    uint32_t image_top_bottom_border_;//black strips added to the input image to maintain aspect ratio while resizing it to fit the network input size
-    uint32_t image_left_right_border_;
-    std::vector&lt;cv::Scalar&gt; colors_;
+  //std::vector&lt;beyondtrack::Detection&gt; detections_;
+  cv::Mat pose_;
+  cv::Mat ground_angle_;
+  double camera_height_;
 
-    cv::Size image_size_;
-    cv::Mat camera_instrinsics_;
-    bool camera_info_ok_;
+  std::vector&lt;beyondtrack::Detection&gt;
+  parse_detected_object(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections);
 
-    bool use_motion_ = false;
+  void vision_detection_callback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections);
 
-    //std::vector&lt;beyondtrack::Detection&gt; detections_;
-    cv::Mat pose_;
-    cv::Mat ground_angle_;
-    double camera_height_;
+  void intrinsics_callback(const sensor_msgs::CameraInfo &amp;in_message);
 
-    std::vector&lt;beyondtrack::Detection&gt;  parse_detected_object(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections);
-    void vision_detection_callback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections);
-    void intrinsics_callback(const sensor_msgs::CameraInfo &amp;in_message);
-    void detection_to_objects(const std::vector&lt;beyondtrack::Detection&gt; &amp;in_objects,
-                              autoware_msgs::DetectedObjectArray&amp; out_message);
+  void detection_to_objects(const std::vector&lt;beyondtrack::Detection&gt; &amp;in_objects,
+                            autoware_msgs::DetectedObjectArray &amp;out_message);
 
 public:
-    void Run();
+  void Run();
 };
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\lib\clipper.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\lib\clipper.cpp" added_lines="3833" deleted_lines="3548">
				<diff>@@ -48,194 +48,207 @@
 #include &lt;ostream&gt;
 #include &lt;functional&gt;
 
-namespace ClipperLib {
+namespace ClipperLib
+{
 
-static double const pi = 3.141592653589793238;
-static double const two_pi = pi *2;
-static double const def_arc_tolerance = 0.25;
+  static double const pi = 3.141592653589793238;
+  static double const two_pi = pi * 2;
+  static double const def_arc_tolerance = 0.25;
 
-enum Direction { dRightToLeft, dLeftToRight };
+  enum Direction
+  {
+    dRightToLeft, dLeftToRight
+  };
 
-static int const Unassigned = -1;  //edge not currently 'owning' a solution
-static int const Skip = -2;        //edge that would otherwise close a path
+  static int const Unassigned = -1;  //edge not currently 'owning' a solution
+  static int const Skip = -2;        //edge that would otherwise close a path
 
 #define HORIZONTAL (-1.0E+40)
 #define TOLERANCE (1.0e-20)
 #define NEAR_ZERO(val) (((val) &gt; -TOLERANCE) &amp;&amp; ((val) &lt; TOLERANCE))
 
-struct TEdge {
-  IntPoint Bot;
-  IntPoint Curr; //current (updated for every new scanbeam)
-  IntPoint Top;
-  double Dx;
-  PolyType PolyTyp;
-  EdgeSide Side; //side only refers to current side of solution poly
-  int WindDelta; //1 or -1 depending on winding direction
-  int WindCnt;
-  int WindCnt2; //winding count of the opposite polytype
-  int OutIdx;
-  TEdge *Next;
-  TEdge *Prev;
-  TEdge *NextInLML;
-  TEdge *NextInAEL;
-  TEdge *PrevInAEL;
-  TEdge *NextInSEL;
-  TEdge *PrevInSEL;
-};
-
-struct IntersectNode {
-  TEdge          *Edge1;
-  TEdge          *Edge2;
-  IntPoint        Pt;
-};
-
-struct LocalMinimum {
-  cInt          Y;
-  TEdge        *LeftBound;
-  TEdge        *RightBound;
-};
-
-struct OutPt;
+  struct TEdge
+  {
+    IntPoint Bot;
+    IntPoint Curr; //current (updated for every new scanbeam)
+    IntPoint Top;
+    double Dx;
+    PolyType PolyTyp;
+    EdgeSide Side; //side only refers to current side of solution poly
+    int WindDelta; //1 or -1 depending on winding direction
+    int WindCnt;
+    int WindCnt2; //winding count of the opposite polytype
+    int OutIdx;
+    TEdge *Next;
+    TEdge *Prev;
+    TEdge *NextInLML;
+    TEdge *NextInAEL;
+    TEdge *PrevInAEL;
+    TEdge *NextInSEL;
+    TEdge *PrevInSEL;
+  };
+
+  struct IntersectNode
+  {
+    TEdge *Edge1;
+    TEdge *Edge2;
+    IntPoint Pt;
+  };
+
+  struct LocalMinimum
+  {
+    cInt Y;
+    TEdge *LeftBound;
+    TEdge *RightBound;
+  };
+
+  struct OutPt;
 
 //OutRec: contains a path in the clipping solution. Edges in the AEL will
 //carry a pointer to an OutRec when they are part of the clipping solution.
-struct OutRec {
-  int       Idx;
-  bool      IsHole;
-  bool      IsOpen;
-  OutRec   *FirstLeft;  //see comments in clipper.pas
-  PolyNode *PolyNd;
-  OutPt    *Pts;
-  OutPt    *BottomPt;
-};
-
-struct OutPt {
-  int       Idx;
-  IntPoint  Pt;
-  OutPt    *Next;
-  OutPt    *Prev;
-};
-
-struct Join {
-  OutPt    *OutPt1;
-  OutPt    *OutPt2;
-  IntPoint  OffPt;
-};
-
-struct LocMinSorter
-{
-  inline bool operator()(const LocalMinimum&amp; locMin1, const LocalMinimum&amp; locMin2)
+  struct OutRec
+  {
+    int Idx;
+    bool IsHole;
+    bool IsOpen;
+    OutRec *FirstLeft;  //see comments in clipper.pas
+    PolyNode *PolyNd;
+    OutPt *Pts;
+    OutPt *BottomPt;
+  };
+
+  struct OutPt
   {
-    return locMin2.Y &lt; locMin1.Y;
-  }
-};
+    int Idx;
+    IntPoint Pt;
+    OutPt *Next;
+    OutPt *Prev;
+  };
+
+  struct Join
+  {
+    OutPt *OutPt1;
+    OutPt *OutPt2;
+    IntPoint OffPt;
+  };
+
+  struct LocMinSorter
+  {
+    inline bool operator()(const LocalMinimum &amp;locMin1, const LocalMinimum &amp;locMin2)
+    {
+      return locMin2.Y &lt; locMin1.Y;
+    }
+  };
 
 //------------------------------------------------------------------------------
 //------------------------------------------------------------------------------
 
-inline cInt Round(double val)
-{
-  if ((val &lt; 0)) return static_cast&lt;cInt&gt;(val - 0.5); 
-  else return static_cast&lt;cInt&gt;(val + 0.5);
-}
+  inline cInt Round(double val)
+  {
+    if ((val &lt; 0))
+      return static_cast&lt;cInt&gt;(val - 0.5);
+    else
+      return static_cast&lt;cInt&gt;(val + 0.5);
+  }
 //------------------------------------------------------------------------------
 
-inline cInt Abs(cInt val)
-{
-  return val &lt; 0 ? -val : val;
-}
+  inline cInt Abs(cInt val)
+  {
+    return val &lt; 0 ? -val : val;
+  }
 
 //------------------------------------------------------------------------------
 // PolyTree methods ...
 //------------------------------------------------------------------------------
 
-void PolyTree::Clear()
-{
+  void PolyTree::Clear()
+  {
     for (PolyNodes::size_type i = 0; i &lt; AllNodes.size(); ++i)
       delete AllNodes[i];
-    AllNodes.resize(0); 
+    AllNodes.resize(0);
     Childs.resize(0);
-}
+  }
 //------------------------------------------------------------------------------
 
-PolyNode* PolyTree::GetFirst() const
-{
-  if (!Childs.empty())
+  PolyNode *PolyTree::GetFirst() const
+  {
+    if (!Childs.empty())
       return Childs[0];
-  else
+    else
       return 0;
-}
+  }
 //------------------------------------------------------------------------------
 
-int PolyTree::Total() const
-{
-  int result = (int)AllNodes.size();
-  //with negative offsets, ignore the hidden outer polygon ...
-  if (result &gt; 0 &amp;&amp; Childs[0] != AllNodes[0]) result--;
-  return result;
-}
+  int PolyTree::Total() const
+  {
+    int result = (int) AllNodes.size();
+    //with negative offsets, ignore the hidden outer polygon ...
+    if (result &gt; 0 &amp;&amp; Childs[0] != AllNodes[0])
+      result--;
+    return result;
+  }
 
 //------------------------------------------------------------------------------
 // PolyNode methods ...
 //------------------------------------------------------------------------------
 
-PolyNode::PolyNode(): Parent(0), Index(0), m_IsOpen(false)
-{
-}
+  PolyNode::PolyNode() : Parent(0), Index(0), m_IsOpen(false)
+  {
+  }
 //------------------------------------------------------------------------------
 
-int PolyNode::ChildCount() const
-{
-  return (int)Childs.size();
-}
+  int PolyNode::ChildCount() const
+  {
+    return (int) Childs.size();
+  }
 //------------------------------------------------------------------------------
 
-void PolyNode::AddChild(PolyNode&amp; child)
-{
-  unsigned cnt = (unsigned)Childs.size();
-  Childs.push_back(&amp;child);
-  child.Parent = this;
-  child.Index = cnt;
-}
+  void PolyNode::AddChild(PolyNode &amp;child)
+  {
+    unsigned cnt = (unsigned) Childs.size();
+    Childs.push_back(&amp;child);
+    child.Parent = this;
+    child.Index = cnt;
+  }
 //------------------------------------------------------------------------------
 
-PolyNode* PolyNode::GetNext() const
-{ 
-  if (!Childs.empty()) 
-      return Childs[0]; 
-  else
-      return GetNextSiblingUp();    
-}  
+  PolyNode *PolyNode::GetNext() const
+  {
+    if (!Childs.empty())
+      return Childs[0];
+    else
+      return GetNextSiblingUp();
+  }
 //------------------------------------------------------------------------------
 
-PolyNode* PolyNode::GetNextSiblingUp() const
-{ 
-  if (!Parent) //protects against PolyTree.GetNextSiblingUp()
+  PolyNode *PolyNode::GetNextSiblingUp() const
+  {
+    if (!Parent) //protects against PolyTree.GetNextSiblingUp()
       return 0;
-  else if (Index == Parent-&gt;Childs.size() - 1)
+    else if (Index == Parent-&gt;Childs.size() - 1)
       return Parent-&gt;GetNextSiblingUp();
-  else
+    else
       return Parent-&gt;Childs[Index + 1];
-}  
+  }
 //------------------------------------------------------------------------------
 
-bool PolyNode::IsHole() const
-{ 
-  bool result = true;
-  PolyNode* node = Parent;
-  while (node)
+  bool PolyNode::IsHole() const
   {
+    bool result = true;
+    PolyNode *node = Parent;
+    while (node)
+    {
       result = !result;
       node = node-&gt;Parent;
+    }
+    return result;
   }
-  return result;
-}  
 //------------------------------------------------------------------------------
 
-bool PolyNode::IsOpen() const
-{ 
-  return m_IsOpen;
-}  
+  bool PolyNode::IsOpen() const
+  {
+    return m_IsOpen;
+  }
 //------------------------------------------------------------------------------
 
 #ifndef use_int32
@@ -248,37 +261,51 @@ bool PolyNode::IsOpen() const
 //    val3.AsString =&gt; "85070591730234615847396907784232501249" (8.5e+37)
 //------------------------------------------------------------------------------
 
-class Int128
-{
+  class Int128
+  {
   public:
     ulong64 lo;
     long64 hi;
 
     Int128(long64 _lo = 0)
     {
-      lo = (ulong64)_lo;   
-      if (_lo &lt; 0)  hi = -1; else hi = 0; 
+      lo = (ulong64) _lo;
+      if (_lo &lt; 0)
+        hi = -1;
+      else
+        hi = 0;
     }
 
 
-    Int128(const Int128 &amp;val): lo(val.lo), hi(val.hi){}
+    Int128(const Int128 &amp;val) : lo(val.lo), hi(val.hi)
+    {
+    }
+
+    Int128(const long64 &amp;_hi, const ulong64 &amp;_lo) : lo(_lo), hi(_hi)
+    {
+    }
 
-    Int128(const long64&amp; _hi, const ulong64&amp; _lo): lo(_lo), hi(_hi){}
-    
-    Int128&amp; operator = (const long64 &amp;val)
+    Int128 &amp;operator=(const long64 &amp;val)
     {
-      lo = (ulong64)val;
-      if (val &lt; 0) hi = -1; else hi = 0;
+      lo = (ulong64) val;
+      if (val &lt; 0)
+        hi = -1;
+      else
+        hi = 0;
       return *this;
     }
 
-    bool operator == (const Int128 &amp;val) const
-      {return (hi == val.hi &amp;&amp; lo == val.lo);}
+    bool operator==(const Int128 &amp;val) const
+    {
+      return (hi == val.hi &amp;&amp; lo == val.lo);
+    }
 
-    bool operator != (const Int128 &amp;val) const
-      { return !(*this == val);}
+    bool operator!=(const Int128 &amp;val) const
+    {
+      return !(*this == val);
+    }
 
-    bool operator &gt; (const Int128 &amp;val) const
+    bool operator&gt;(const Int128 &amp;val) const
     {
       if (hi != val.hi)
         return hi &gt; val.hi;
@@ -286,7 +313,7 @@ class Int128
         return lo &gt; val.lo;
     }
 
-    bool operator &lt; (const Int128 &amp;val) const
+    bool operator&lt;(const Int128 &amp;val) const
     {
       if (hi != val.hi)
         return hi &lt; val.hi;
@@ -294,34 +321,39 @@ class Int128
         return lo &lt; val.lo;
     }
 
-    bool operator &gt;= (const Int128 &amp;val) const
-      { return !(*this &lt; val);}
+    bool operator&gt;=(const Int128 &amp;val) const
+    {
+      return !(*this &lt; val);
+    }
 
-    bool operator &lt;= (const Int128 &amp;val) const
-      { return !(*this &gt; val);}
+    bool operator&lt;=(const Int128 &amp;val) const
+    {
+      return !(*this &gt; val);
+    }
 
-    Int128&amp; operator += (const Int128 &amp;rhs)
+    Int128 &amp;operator+=(const Int128 &amp;rhs)
     {
       hi += rhs.hi;
       lo += rhs.lo;
-      if (lo &lt; rhs.lo) hi++;
+      if (lo &lt; rhs.lo)
+        hi++;
       return *this;
     }
 
-    Int128 operator + (const Int128 &amp;rhs) const
+    Int128 operator+(const Int128 &amp;rhs) const
     {
       Int128 result(*this);
-      result+= rhs;
+      result += rhs;
       return result;
     }
 
-    Int128&amp; operator -= (const Int128 &amp;rhs)
+    Int128 &amp;operator-=(const Int128 &amp;rhs)
     {
       *this += -rhs;
       return *this;
     }
 
-    Int128 operator - (const Int128 &amp;rhs) const
+    Int128 operator-(const Int128 &amp;rhs) const
     {
       Int128 result(*this);
       result -= rhs;
@@ -341,2286 +373,2467 @@ class Int128
       const double shift64 = 18446744073709551616.0; //2^64
       if (hi &lt; 0)
       {
-        if (lo == 0) return (double)hi * shift64;
-        else return -(double)(~lo + ~hi * shift64);
-      }
-      else
-        return (double)(lo + hi * shift64);
+        if (lo == 0)
+          return (double) hi * shift64;
+        else
+          return -(double) (~lo + ~hi * shift64);
+      } else
+        return (double) (lo + hi * shift64);
     }
 
-};
+  };
 //------------------------------------------------------------------------------
 
-Int128 Int128Mul (long64 lhs, long64 rhs)
-{
-  bool negate = (lhs &lt; 0) != (rhs &lt; 0);
-
-  if (lhs &lt; 0) lhs = -lhs;
-  ulong64 int1Hi = ulong64(lhs) &gt;&gt; 32;
-  ulong64 int1Lo = ulong64(lhs &amp; 0xFFFFFFFF);
-
-  if (rhs &lt; 0) rhs = -rhs;
-  ulong64 int2Hi = ulong64(rhs) &gt;&gt; 32;
-  ulong64 int2Lo = ulong64(rhs &amp; 0xFFFFFFFF);
-
-  //nb: see comments in clipper.pas
-  ulong64 a = int1Hi * int2Hi;
-  ulong64 b = int1Lo * int2Lo;
-  ulong64 c = int1Hi * int2Lo + int1Lo * int2Hi;
-
-  Int128 tmp;
-  tmp.hi = long64(a + (c &gt;&gt; 32));
-  tmp.lo = long64(c &lt;&lt; 32);
-  tmp.lo += long64(b);
-  if (tmp.lo &lt; b) tmp.hi++;
-  if (negate) tmp = -tmp;
-  return tmp;
-};
+  Int128 Int128Mul(long64 lhs, long64 rhs)
+  {
+    bool negate = (lhs &lt; 0) != (rhs &lt; 0);
+
+    if (lhs &lt; 0)
+      lhs = -lhs;
+    ulong64 int1Hi = ulong64(lhs) &gt;&gt; 32;
+    ulong64 int1Lo = ulong64(lhs &amp; 0xFFFFFFFF);
+
+    if (rhs &lt; 0)
+      rhs = -rhs;
+    ulong64 int2Hi = ulong64(rhs) &gt;&gt; 32;
+    ulong64 int2Lo = ulong64(rhs &amp; 0xFFFFFFFF);
+
+    //nb: see comments in clipper.pas
+    ulong64 a = int1Hi * int2Hi;
+    ulong64 b = int1Lo * int2Lo;
+    ulong64 c = int1Hi * int2Lo + int1Lo * int2Hi;
+
+    Int128 tmp;
+    tmp.hi = long64(a + (c &gt;&gt; 32));
+    tmp.lo = long64(c &lt;&lt; 32);
+    tmp.lo += long64(b);
+    if (tmp.lo &lt; b)
+      tmp.hi++;
+    if (negate)
+      tmp = -tmp;
+    return tmp;
+  };
 #endif
 
 //------------------------------------------------------------------------------
 // Miscellaneous global functions
 //------------------------------------------------------------------------------
 
-bool Orientation(const Path &amp;poly)
-{
+  bool Orientation(const Path &amp;poly)
+  {
     return Area(poly) &gt;= 0;
-}
+  }
 //------------------------------------------------------------------------------
 
-double Area(const Path &amp;poly)
-{
-  int size = (int)poly.size();
-  if (size &lt; 3) return 0;
-
-  double a = 0;
-  for (int i = 0, j = size -1; i &lt; size; ++i)
+  double Area(const Path &amp;poly)
   {
-    a += ((double)poly[j].X + poly[i].X) * ((double)poly[j].Y - poly[i].Y);
-    j = i;
+    int size = (int) poly.size();
+    if (size &lt; 3)
+      return 0;
+
+    double a = 0;
+    for (int i = 0, j = size - 1; i &lt; size; ++i)
+    {
+      a += ((double) poly[j].X + poly[i].X) * ((double) poly[j].Y - poly[i].Y);
+      j = i;
+    }
+    return -a * 0.5;
   }
-  return -a * 0.5;
-}
 //------------------------------------------------------------------------------
 
-double Area(const OutPt *op)
-{
-  const OutPt *startOp = op;
-  if (!op) return 0;
-  double a = 0;
-  do {
-    a +=  (double)(op-&gt;Prev-&gt;Pt.X + op-&gt;Pt.X) * (double)(op-&gt;Prev-&gt;Pt.Y - op-&gt;Pt.Y);
-    op = op-&gt;Next;
-  } while (op != startOp);
-  return a * 0.5;
-}
+  double Area(const OutPt *op)
+  {
+    const OutPt *startOp = op;
+    if (!op)
+      return 0;
+    double a = 0;
+    do
+    {
+      a += (double) (op-&gt;Prev-&gt;Pt.X + op-&gt;Pt.X) * (double) (op-&gt;Prev-&gt;Pt.Y - op-&gt;Pt.Y);
+      op = op-&gt;Next;
+    } while (op != startOp);
+    return a * 0.5;
+  }
 //------------------------------------------------------------------------------
 
-double Area(const OutRec &amp;outRec)
-{
-  return Area(outRec.Pts);
-}
+  double Area(const OutRec &amp;outRec)
+  {
+    return Area(outRec.Pts);
+  }
 //------------------------------------------------------------------------------
 
-bool PointIsVertex(const IntPoint &amp;Pt, OutPt *pp)
-{
-  OutPt *pp2 = pp;
-  do
+  bool PointIsVertex(const IntPoint &amp;Pt, OutPt *pp)
   {
-    if (pp2-&gt;Pt == Pt) return true;
-    pp2 = pp2-&gt;Next;
+    OutPt *pp2 = pp;
+    do
+    {
+      if (pp2-&gt;Pt == Pt)
+        return true;
+      pp2 = pp2-&gt;Next;
+    } while (pp2 != pp);
+    return false;
   }
-  while (pp2 != pp);
-  return false;
-}
 //------------------------------------------------------------------------------
 
 //See "The Point in Polygon Problem for Arbitrary Polygons" by Hormann &amp; Agathos
 //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&amp;rep=rep1&amp;type=pdf
-int PointInPolygon(const IntPoint &amp;pt, const Path &amp;path)
-{
-  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary
-  int result = 0;
-  size_t cnt = path.size();
-  if (cnt &lt; 3) return 0;
-  IntPoint ip = path[0];
-  for(size_t i = 1; i &lt;= cnt; ++i)
-  {
-    IntPoint ipNext = (i == cnt ? path[0] : path[i]);
-    if (ipNext.Y == pt.Y)
-    {
-        if ((ipNext.X == pt.X) || (ip.Y == pt.Y &amp;&amp; 
-          ((ipNext.X &gt; pt.X) == (ip.X &lt; pt.X)))) return -1;
-    }
-    if ((ip.Y &lt; pt.Y) != (ipNext.Y &lt; pt.Y))
+  int PointInPolygon(const IntPoint &amp;pt, const Path &amp;path)
+  {
+    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary
+    int result = 0;
+    size_t cnt = path.size();
+    if (cnt &lt; 3)
+      return 0;
+    IntPoint ip = path[0];
+    for (size_t i = 1; i &lt;= cnt; ++i)
     {
-      if (ip.X &gt;= pt.X)
+      IntPoint ipNext = (i == cnt ? path[0] : path[i]);
+      if (ipNext.Y == pt.Y)
       {
-        if (ipNext.X &gt; pt.X) result = 1 - result;
-        else
-        {
-          double d = (double)(ip.X - pt.X) * (ipNext.Y - pt.Y) - 
-            (double)(ipNext.X - pt.X) * (ip.Y - pt.Y);
-          if (!d) return -1;
-          if ((d &gt; 0) == (ipNext.Y &gt; ip.Y)) result = 1 - result;
-        }
-      } else
+        if ((ipNext.X == pt.X) || (ip.Y == pt.Y &amp;&amp;
+                                   ((ipNext.X &gt; pt.X) == (ip.X &lt; pt.X))))
+          return -1;
+      }
+      if ((ip.Y &lt; pt.Y) != (ipNext.Y &lt; pt.Y))
       {
-        if (ipNext.X &gt; pt.X)
+        if (ip.X &gt;= pt.X)
+        {
+          if (ipNext.X &gt; pt.X)
+            result = 1 - result;
+          else
+          {
+            double d = (double) (ip.X - pt.X) * (ipNext.Y - pt.Y) -
+                       (double) (ipNext.X - pt.X) * (ip.Y - pt.Y);
+            if (!d)
+              return -1;
+            if ((d &gt; 0) == (ipNext.Y &gt; ip.Y))
+              result = 1 - result;
+          }
+        } else
         {
-          double d = (double)(ip.X - pt.X) * (ipNext.Y - pt.Y) - 
-            (double)(ipNext.X - pt.X) * (ip.Y - pt.Y);
-          if (!d) return -1;
-          if ((d &gt; 0) == (ipNext.Y &gt; ip.Y)) result = 1 - result;
+          if (ipNext.X &gt; pt.X)
+          {
+            double d = (double) (ip.X - pt.X) * (ipNext.Y - pt.Y) -
+                       (double) (ipNext.X - pt.X) * (ip.Y - pt.Y);
+            if (!d)
+              return -1;
+            if ((d &gt; 0) == (ipNext.Y &gt; ip.Y))
+              result = 1 - result;
+          }
         }
       }
+      ip = ipNext;
     }
-    ip = ipNext;
-  } 
-  return result;
-}
+    return result;
+  }
 //------------------------------------------------------------------------------
 
-int PointInPolygon (const IntPoint &amp;pt, OutPt *op)
-{
-  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary
-  int result = 0;
-  OutPt* startOp = op;
-  for(;;)
+  int PointInPolygon(const IntPoint &amp;pt, OutPt *op)
   {
-    if (op-&gt;Next-&gt;Pt.Y == pt.Y)
-    {
-        if ((op-&gt;Next-&gt;Pt.X == pt.X) || (op-&gt;Pt.Y == pt.Y &amp;&amp; 
-          ((op-&gt;Next-&gt;Pt.X &gt; pt.X) == (op-&gt;Pt.X &lt; pt.X)))) return -1;
-    }
-    if ((op-&gt;Pt.Y &lt; pt.Y) != (op-&gt;Next-&gt;Pt.Y &lt; pt.Y))
+    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary
+    int result = 0;
+    OutPt *startOp = op;
+    for (;;)
     {
-      if (op-&gt;Pt.X &gt;= pt.X)
+      if (op-&gt;Next-&gt;Pt.Y == pt.Y)
       {
-        if (op-&gt;Next-&gt;Pt.X &gt; pt.X) result = 1 - result;
-        else
-        {
-          double d = (double)(op-&gt;Pt.X - pt.X) * (op-&gt;Next-&gt;Pt.Y - pt.Y) - 
-            (double)(op-&gt;Next-&gt;Pt.X - pt.X) * (op-&gt;Pt.Y - pt.Y);
-          if (!d) return -1;
-          if ((d &gt; 0) == (op-&gt;Next-&gt;Pt.Y &gt; op-&gt;Pt.Y)) result = 1 - result;
-        }
-      } else
+        if ((op-&gt;Next-&gt;Pt.X == pt.X) || (op-&gt;Pt.Y == pt.Y &amp;&amp;
+                                         ((op-&gt;Next-&gt;Pt.X &gt; pt.X) == (op-&gt;Pt.X &lt; pt.X))))
+          return -1;
+      }
+      if ((op-&gt;Pt.Y &lt; pt.Y) != (op-&gt;Next-&gt;Pt.Y &lt; pt.Y))
       {
-        if (op-&gt;Next-&gt;Pt.X &gt; pt.X)
+        if (op-&gt;Pt.X &gt;= pt.X)
         {
-          double d = (double)(op-&gt;Pt.X - pt.X) * (op-&gt;Next-&gt;Pt.Y - pt.Y) - 
-            (double)(op-&gt;Next-&gt;Pt.X - pt.X) * (op-&gt;Pt.Y - pt.Y);
-          if (!d) return -1;
-          if ((d &gt; 0) == (op-&gt;Next-&gt;Pt.Y &gt; op-&gt;Pt.Y)) result = 1 - result;
+          if (op-&gt;Next-&gt;Pt.X &gt; pt.X)
+            result = 1 - result;
+          else
+          {
+            double d = (double) (op-&gt;Pt.X - pt.X) * (op-&gt;Next-&gt;Pt.Y - pt.Y) -
+                       (double) (op-&gt;Next-&gt;Pt.X - pt.X) * (op-&gt;Pt.Y - pt.Y);
+            if (!d)
+              return -1;
+            if ((d &gt; 0) == (op-&gt;Next-&gt;Pt.Y &gt; op-&gt;Pt.Y))
+              result = 1 - result;
+          }
+        } else
+        {
+          if (op-&gt;Next-&gt;Pt.X &gt; pt.X)
+          {
+            double d = (double) (op-&gt;Pt.X - pt.X) * (op-&gt;Next-&gt;Pt.Y - pt.Y) -
+                       (double) (op-&gt;Next-&gt;Pt.X - pt.X) * (op-&gt;Pt.Y - pt.Y);
+            if (!d)
+              return -1;
+            if ((d &gt; 0) == (op-&gt;Next-&gt;Pt.Y &gt; op-&gt;Pt.Y))
+              result = 1 - result;
+          }
         }
       }
-    } 
-    op = op-&gt;Next;
-    if (startOp == op) break;
-  } 
-  return result;
-}
+      op = op-&gt;Next;
+      if (startOp == op)
+        break;
+    }
+    return result;
+  }
 //------------------------------------------------------------------------------
 
-bool Poly2ContainsPoly1(OutPt *OutPt1, OutPt *OutPt2)
-{
-  OutPt* op = OutPt1;
-  do
+  bool Poly2ContainsPoly1(OutPt *OutPt1, OutPt *OutPt2)
   {
-    //nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon
-    int res = PointInPolygon(op-&gt;Pt, OutPt2);
-    if (res &gt;= 0) return res &gt; 0;
-    op = op-&gt;Next; 
+    OutPt *op = OutPt1;
+    do
+    {
+      //nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon
+      int res = PointInPolygon(op-&gt;Pt, OutPt2);
+      if (res &gt;= 0)
+        return res &gt; 0;
+      op = op-&gt;Next;
+    } while (op != OutPt1);
+    return true;
   }
-  while (op != OutPt1);
-  return true; 
-}
 //----------------------------------------------------------------------
 
-bool SlopesEqual(const TEdge &amp;e1, const TEdge &amp;e2, bool UseFullInt64Range)
-{
+  bool SlopesEqual(const TEdge &amp;e1, const TEdge &amp;e2, bool UseFullInt64Range)
+  {
 #ifndef use_int32
-  if (UseFullInt64Range)
-    return Int128Mul(e1.Top.Y - e1.Bot.Y, e2.Top.X - e2.Bot.X) == 
-    Int128Mul(e1.Top.X - e1.Bot.X, e2.Top.Y - e2.Bot.Y);
-  else 
+    if (UseFullInt64Range)
+      return Int128Mul(e1.Top.Y - e1.Bot.Y, e2.Top.X - e2.Bot.X) ==
+             Int128Mul(e1.Top.X - e1.Bot.X, e2.Top.Y - e2.Bot.Y);
+    else
 #endif
-    return (e1.Top.Y - e1.Bot.Y) * (e2.Top.X - e2.Bot.X) == 
-    (e1.Top.X - e1.Bot.X) * (e2.Top.Y - e2.Bot.Y);
-}
+      return (e1.Top.Y - e1.Bot.Y) * (e2.Top.X - e2.Bot.X) ==
+             (e1.Top.X - e1.Bot.X) * (e2.Top.Y - e2.Bot.Y);
+  }
 //------------------------------------------------------------------------------
 
-bool SlopesEqual(const IntPoint pt1, const IntPoint pt2,
-  const IntPoint pt3, bool UseFullInt64Range)
-{
+  bool SlopesEqual(const IntPoint pt1, const IntPoint pt2,
+                   const IntPoint pt3, bool UseFullInt64Range)
+  {
 #ifndef use_int32
-  if (UseFullInt64Range)
-    return Int128Mul(pt1.Y-pt2.Y, pt2.X-pt3.X) == Int128Mul(pt1.X-pt2.X, pt2.Y-pt3.Y);
-  else 
+    if (UseFullInt64Range)
+      return Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X) == Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y);
+    else
 #endif
-    return (pt1.Y-pt2.Y)*(pt2.X-pt3.X) == (pt1.X-pt2.X)*(pt2.Y-pt3.Y);
-}
+      return (pt1.Y - pt2.Y) * (pt2.X - pt3.X) == (pt1.X - pt2.X) * (pt2.Y - pt3.Y);
+  }
 //------------------------------------------------------------------------------
 
-bool SlopesEqual(const IntPoint pt1, const IntPoint pt2,
-  const IntPoint pt3, const IntPoint pt4, bool UseFullInt64Range)
-{
+  bool SlopesEqual(const IntPoint pt1, const IntPoint pt2,
+                   const IntPoint pt3, const IntPoint pt4, bool UseFullInt64Range)
+  {
 #ifndef use_int32
-  if (UseFullInt64Range)
-    return Int128Mul(pt1.Y-pt2.Y, pt3.X-pt4.X) == Int128Mul(pt1.X-pt2.X, pt3.Y-pt4.Y);
-  else 
+    if (UseFullInt64Range)
+      return Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X) == Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y);
+    else
 #endif
-    return (pt1.Y-pt2.Y)*(pt3.X-pt4.X) == (pt1.X-pt2.X)*(pt3.Y-pt4.Y);
-}
+      return (pt1.Y - pt2.Y) * (pt3.X - pt4.X) == (pt1.X - pt2.X) * (pt3.Y - pt4.Y);
+  }
 //------------------------------------------------------------------------------
 
-inline bool IsHorizontal(TEdge &amp;e)
-{
-  return e.Dx == HORIZONTAL;
-}
+  inline bool IsHorizontal(TEdge &amp;e)
+  {
+    return e.Dx == HORIZONTAL;
+  }
 //------------------------------------------------------------------------------
 
-inline double GetDx(const IntPoint pt1, const IntPoint pt2)
-{
-  return (pt1.Y == pt2.Y) ?
-    HORIZONTAL : (double)(pt2.X - pt1.X) / (pt2.Y - pt1.Y);
-}
+  inline double GetDx(const IntPoint pt1, const IntPoint pt2)
+  {
+    return (pt1.Y == pt2.Y) ?
+           HORIZONTAL : (double) (pt2.X - pt1.X) / (pt2.Y - pt1.Y);
+  }
 //---------------------------------------------------------------------------
 
-inline void SetDx(TEdge &amp;e)
-{
-  cInt dy  = (e.Top.Y - e.Bot.Y);
-  if (dy == 0) e.Dx = HORIZONTAL;
-  else e.Dx = (double)(e.Top.X - e.Bot.X) / dy;
-}
+  inline void SetDx(TEdge &amp;e)
+  {
+    cInt dy = (e.Top.Y - e.Bot.Y);
+    if (dy == 0)
+      e.Dx = HORIZONTAL;
+    else
+      e.Dx = (double) (e.Top.X - e.Bot.X) / dy;
+  }
 //---------------------------------------------------------------------------
 
-inline void SwapSides(TEdge &amp;Edge1, TEdge &amp;Edge2)
-{
-  EdgeSide Side =  Edge1.Side;
-  Edge1.Side = Edge2.Side;
-  Edge2.Side = Side;
-}
+  inline void SwapSides(TEdge &amp;Edge1, TEdge &amp;Edge2)
+  {
+    EdgeSide Side = Edge1.Side;
+    Edge1.Side = Edge2.Side;
+    Edge2.Side = Side;
+  }
 //------------------------------------------------------------------------------
 
-inline void SwapPolyIndexes(TEdge &amp;Edge1, TEdge &amp;Edge2)
-{
-  int OutIdx =  Edge1.OutIdx;
-  Edge1.OutIdx = Edge2.OutIdx;
-  Edge2.OutIdx = OutIdx;
-}
+  inline void SwapPolyIndexes(TEdge &amp;Edge1, TEdge &amp;Edge2)
+  {
+    int OutIdx = Edge1.OutIdx;
+    Edge1.OutIdx = Edge2.OutIdx;
+    Edge2.OutIdx = OutIdx;
+  }
 //------------------------------------------------------------------------------
 
-inline cInt TopX(TEdge &amp;edge, const cInt currentY)
-{
-  return ( currentY == edge.Top.Y ) ?
-    edge.Top.X : edge.Bot.X + Round(edge.Dx *(currentY - edge.Bot.Y));
-}
+  inline cInt TopX(TEdge &amp;edge, const cInt currentY)
+  {
+    return (currentY == edge.Top.Y) ?
+           edge.Top.X : edge.Bot.X + Round(edge.Dx * (currentY - edge.Bot.Y));
+  }
 //------------------------------------------------------------------------------
 
-void IntersectPoint(TEdge &amp;Edge1, TEdge &amp;Edge2, IntPoint &amp;ip)
-{
-#ifdef use_xyz  
-  ip.Z = 0;
+  void IntersectPoint(TEdge &amp;Edge1, TEdge &amp;Edge2, IntPoint &amp;ip)
+  {
+#ifdef use_xyz
+    ip.Z = 0;
 #endif
 
-  double b1, b2;
-  if (Edge1.Dx == Edge2.Dx)
-  {
-    ip.Y = Edge1.Curr.Y;
-    ip.X = TopX(Edge1, ip.Y);
-    return;
+    double b1, b2;
+    if (Edge1.Dx == Edge2.Dx)
+    {
+      ip.Y = Edge1.Curr.Y;
+      ip.X = TopX(Edge1, ip.Y);
+      return;
+    } else if (Edge1.Dx == 0)
+    {
+      ip.X = Edge1.Bot.X;
+      if (IsHorizontal(Edge2))
+        ip.Y = Edge2.Bot.Y;
+      else
+      {
+        b2 = Edge2.Bot.Y - (Edge2.Bot.X / Edge2.Dx);
+        ip.Y = Round(ip.X / Edge2.Dx + b2);
+      }
+    } else if (Edge2.Dx == 0)
+    {
+      ip.X = Edge2.Bot.X;
+      if (IsHorizontal(Edge1))
+        ip.Y = Edge1.Bot.Y;
+      else
+      {
+        b1 = Edge1.Bot.Y - (Edge1.Bot.X / Edge1.Dx);
+        ip.Y = Round(ip.X / Edge1.Dx + b1);
+      }
+    } else
+    {
+      b1 = Edge1.Bot.X - Edge1.Bot.Y * Edge1.Dx;
+      b2 = Edge2.Bot.X - Edge2.Bot.Y * Edge2.Dx;
+      double q = (b2 - b1) / (Edge1.Dx - Edge2.Dx);
+      ip.Y = Round(q);
+      if (std::fabs(Edge1.Dx) &lt; std::fabs(Edge2.Dx))
+        ip.X = Round(Edge1.Dx * q + b1);
+      else
+        ip.X = Round(Edge2.Dx * q + b2);
+    }
+
+    if (ip.Y &lt; Edge1.Top.Y || ip.Y &lt; Edge2.Top.Y)
+    {
+      if (Edge1.Top.Y &gt; Edge2.Top.Y)
+        ip.Y = Edge1.Top.Y;
+      else
+        ip.Y = Edge2.Top.Y;
+      if (std::fabs(Edge1.Dx) &lt; std::fabs(Edge2.Dx))
+        ip.X = TopX(Edge1, ip.Y);
+      else
+        ip.X = TopX(Edge2, ip.Y);
+    }
+    //finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...
+    if (ip.Y &gt; Edge1.Curr.Y)
+    {
+      ip.Y = Edge1.Curr.Y;
+      //use the more vertical edge to derive X ...
+      if (std::fabs(Edge1.Dx) &gt; std::fabs(Edge2.Dx))
+        ip.X = TopX(Edge2, ip.Y);
+      else
+        ip.X = TopX(Edge1, ip.Y);
+    }
   }
-  else if (Edge1.Dx == 0)
+//------------------------------------------------------------------------------
+
+  void ReversePolyPtLinks(OutPt *pp)
   {
-    ip.X = Edge1.Bot.X;
-    if (IsHorizontal(Edge2))
-      ip.Y = Edge2.Bot.Y;
-    else
+    if (!pp)
+      return;
+    OutPt *pp1, *pp2;
+    pp1 = pp;
+    do
     {
-      b2 = Edge2.Bot.Y - (Edge2.Bot.X / Edge2.Dx);
-      ip.Y = Round(ip.X / Edge2.Dx + b2);
-    }
+      pp2 = pp1-&gt;Next;
+      pp1-&gt;Next = pp1-&gt;Prev;
+      pp1-&gt;Prev = pp2;
+      pp1 = pp2;
+    } while (pp1 != pp);
   }
-  else if (Edge2.Dx == 0)
+//------------------------------------------------------------------------------
+
+  void DisposeOutPts(OutPt *&amp;pp)
   {
-    ip.X = Edge2.Bot.X;
-    if (IsHorizontal(Edge1))
-      ip.Y = Edge1.Bot.Y;
-    else
+    if (pp == 0)
+      return;
+    pp-&gt;Prev-&gt;Next = 0;
+    while (pp)
     {
-      b1 = Edge1.Bot.Y - (Edge1.Bot.X / Edge1.Dx);
-      ip.Y = Round(ip.X / Edge1.Dx + b1);
+      OutPt *tmpPp = pp;
+      pp = pp-&gt;Next;
+      delete tmpPp;
     }
-  } 
-  else 
+  }
+//------------------------------------------------------------------------------
+
+  inline void InitEdge(TEdge *e, TEdge *eNext, TEdge *ePrev, const IntPoint &amp;Pt)
   {
-    b1 = Edge1.Bot.X - Edge1.Bot.Y * Edge1.Dx;
-    b2 = Edge2.Bot.X - Edge2.Bot.Y * Edge2.Dx;
-    double q = (b2-b1) / (Edge1.Dx - Edge2.Dx);
-    ip.Y = Round(q);
-    if (std::fabs(Edge1.Dx) &lt; std::fabs(Edge2.Dx))
-      ip.X = Round(Edge1.Dx * q + b1);
-    else 
-      ip.X = Round(Edge2.Dx * q + b2);
+    std::memset(e, 0, sizeof(TEdge));
+    e-&gt;Next = eNext;
+    e-&gt;Prev = ePrev;
+    e-&gt;Curr = Pt;
+    e-&gt;OutIdx = Unassigned;
   }
+//------------------------------------------------------------------------------
 
-  if (ip.Y &lt; Edge1.Top.Y || ip.Y &lt; Edge2.Top.Y) 
+  void InitEdge2(TEdge &amp;e, PolyType Pt)
   {
-    if (Edge1.Top.Y &gt; Edge2.Top.Y)
-      ip.Y = Edge1.Top.Y;
-    else
-      ip.Y = Edge2.Top.Y;
-    if (std::fabs(Edge1.Dx) &lt; std::fabs(Edge2.Dx))
-      ip.X = TopX(Edge1, ip.Y);
-    else
-      ip.X = TopX(Edge2, ip.Y);
-  } 
-  //finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...
-  if (ip.Y &gt; Edge1.Curr.Y)
-  {
-    ip.Y = Edge1.Curr.Y;
-    //use the more vertical edge to derive X ...
-    if (std::fabs(Edge1.Dx) &gt; std::fabs(Edge2.Dx))
-      ip.X = TopX(Edge2, ip.Y); else
-      ip.X = TopX(Edge1, ip.Y);
+    if (e.Curr.Y &gt;= e.Next-&gt;Curr.Y)
+    {
+      e.Bot = e.Curr;
+      e.Top = e.Next-&gt;Curr;
+    } else
+    {
+      e.Top = e.Curr;
+      e.Bot = e.Next-&gt;Curr;
+    }
+    SetDx(e);
+    e.PolyTyp = Pt;
   }
-}
 //------------------------------------------------------------------------------
 
-void ReversePolyPtLinks(OutPt *pp)
-{
-  if (!pp) return;
-  OutPt *pp1, *pp2;
-  pp1 = pp;
-  do {
-  pp2 = pp1-&gt;Next;
-  pp1-&gt;Next = pp1-&gt;Prev;
-  pp1-&gt;Prev = pp2;
-  pp1 = pp2;
-  } while( pp1 != pp );
-}
-//------------------------------------------------------------------------------
-
-void DisposeOutPts(OutPt*&amp; pp)
-{
-  if (pp == 0) return;
-    pp-&gt;Prev-&gt;Next = 0;
-  while( pp )
+  TEdge *RemoveEdge(TEdge *e)
   {
-    OutPt *tmpPp = pp;
-    pp = pp-&gt;Next;
-    delete tmpPp;
+    //removes e from double_linked_list (but without removing from memory)
+    e-&gt;Prev-&gt;Next = e-&gt;Next;
+    e-&gt;Next-&gt;Prev = e-&gt;Prev;
+    TEdge *result = e-&gt;Next;
+    e-&gt;Prev = 0; //flag as removed (see ClipperBase.Clear)
+    return result;
   }
-}
-//------------------------------------------------------------------------------
-
-inline void InitEdge(TEdge* e, TEdge* eNext, TEdge* ePrev, const IntPoint&amp; Pt)
-{
-  std::memset(e, 0, sizeof(TEdge));
-  e-&gt;Next = eNext;
-  e-&gt;Prev = ePrev;
-  e-&gt;Curr = Pt;
-  e-&gt;OutIdx = Unassigned;
-}
 //------------------------------------------------------------------------------
 
-void InitEdge2(TEdge&amp; e, PolyType Pt)
-{
-  if (e.Curr.Y &gt;= e.Next-&gt;Curr.Y)
-  {
-    e.Bot = e.Curr;
-    e.Top = e.Next-&gt;Curr;
-  } else
+  inline void ReverseHorizontal(TEdge &amp;e)
   {
-    e.Top = e.Curr;
-    e.Bot = e.Next-&gt;Curr;
-  }
-  SetDx(e);
-  e.PolyTyp = Pt;
-}
-//------------------------------------------------------------------------------
-
-TEdge* RemoveEdge(TEdge* e)
-{
-  //removes e from double_linked_list (but without removing from memory)
-  e-&gt;Prev-&gt;Next = e-&gt;Next;
-  e-&gt;Next-&gt;Prev = e-&gt;Prev;
-  TEdge* result = e-&gt;Next;
-  e-&gt;Prev = 0; //flag as removed (see ClipperBase.Clear)
-  return result;
-}
-//------------------------------------------------------------------------------
-
-inline void ReverseHorizontal(TEdge &amp;e)
-{
-  //swap horizontal edges' Top and Bottom x's so they follow the natural
-  //progression of the bounds - ie so their xbots will align with the
-  //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]
-  std::swap(e.Top.X, e.Bot.X);
-#ifdef use_xyz  
-  std::swap(e.Top.Z, e.Bot.Z);
+    //swap horizontal edges' Top and Bottom x's so they follow the natural
+    //progression of the bounds - ie so their xbots will align with the
+    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]
+    std::swap(e.Top.X, e.Bot.X);
+#ifdef use_xyz
+    std::swap(e.Top.Z, e.Bot.Z);
 #endif
-}
+  }
 //------------------------------------------------------------------------------
 
-void SwapPoints(IntPoint &amp;pt1, IntPoint &amp;pt2)
-{
-  IntPoint tmp = pt1;
-  pt1 = pt2;
-  pt2 = tmp;
-}
+  void SwapPoints(IntPoint &amp;pt1, IntPoint &amp;pt2)
+  {
+    IntPoint tmp = pt1;
+    pt1 = pt2;
+    pt2 = tmp;
+  }
 //------------------------------------------------------------------------------
 
-bool GetOverlapSegment(IntPoint pt1a, IntPoint pt1b, IntPoint pt2a,
-  IntPoint pt2b, IntPoint &amp;pt1, IntPoint &amp;pt2)
-{
-  //precondition: segments are Collinear.
-  if (Abs(pt1a.X - pt1b.X) &gt; Abs(pt1a.Y - pt1b.Y))
-  {
-    if (pt1a.X &gt; pt1b.X) SwapPoints(pt1a, pt1b);
-    if (pt2a.X &gt; pt2b.X) SwapPoints(pt2a, pt2b);
-    if (pt1a.X &gt; pt2a.X) pt1 = pt1a; else pt1 = pt2a;
-    if (pt1b.X &lt; pt2b.X) pt2 = pt1b; else pt2 = pt2b;
-    return pt1.X &lt; pt2.X;
-  } else
-  {
-    if (pt1a.Y &lt; pt1b.Y) SwapPoints(pt1a, pt1b);
-    if (pt2a.Y &lt; pt2b.Y) SwapPoints(pt2a, pt2b);
-    if (pt1a.Y &lt; pt2a.Y) pt1 = pt1a; else pt1 = pt2a;
-    if (pt1b.Y &gt; pt2b.Y) pt2 = pt1b; else pt2 = pt2b;
-    return pt1.Y &gt; pt2.Y;
+  bool GetOverlapSegment(IntPoint pt1a, IntPoint pt1b, IntPoint pt2a,
+                         IntPoint pt2b, IntPoint &amp;pt1, IntPoint &amp;pt2)
+  {
+    //precondition: segments are Collinear.
+    if (Abs(pt1a.X - pt1b.X) &gt; Abs(pt1a.Y - pt1b.Y))
+    {
+      if (pt1a.X &gt; pt1b.X)
+        SwapPoints(pt1a, pt1b);
+      if (pt2a.X &gt; pt2b.X)
+        SwapPoints(pt2a, pt2b);
+      if (pt1a.X &gt; pt2a.X)
+        pt1 = pt1a;
+      else
+        pt1 = pt2a;
+      if (pt1b.X &lt; pt2b.X)
+        pt2 = pt1b;
+      else
+        pt2 = pt2b;
+      return pt1.X &lt; pt2.X;
+    } else
+    {
+      if (pt1a.Y &lt; pt1b.Y)
+        SwapPoints(pt1a, pt1b);
+      if (pt2a.Y &lt; pt2b.Y)
+        SwapPoints(pt2a, pt2b);
+      if (pt1a.Y &lt; pt2a.Y)
+        pt1 = pt1a;
+      else
+        pt1 = pt2a;
+      if (pt1b.Y &gt; pt2b.Y)
+        pt2 = pt1b;
+      else
+        pt2 = pt2b;
+      return pt1.Y &gt; pt2.Y;
+    }
   }
-}
 //------------------------------------------------------------------------------
 
-bool FirstIsBottomPt(const OutPt* btmPt1, const OutPt* btmPt2)
-{
-  OutPt *p = btmPt1-&gt;Prev;
-  while ((p-&gt;Pt == btmPt1-&gt;Pt) &amp;&amp; (p != btmPt1)) p = p-&gt;Prev;
-  double dx1p = std::fabs(GetDx(btmPt1-&gt;Pt, p-&gt;Pt));
-  p = btmPt1-&gt;Next;
-  while ((p-&gt;Pt == btmPt1-&gt;Pt) &amp;&amp; (p != btmPt1)) p = p-&gt;Next;
-  double dx1n = std::fabs(GetDx(btmPt1-&gt;Pt, p-&gt;Pt));
-
-  p = btmPt2-&gt;Prev;
-  while ((p-&gt;Pt == btmPt2-&gt;Pt) &amp;&amp; (p != btmPt2)) p = p-&gt;Prev;
-  double dx2p = std::fabs(GetDx(btmPt2-&gt;Pt, p-&gt;Pt));
-  p = btmPt2-&gt;Next;
-  while ((p-&gt;Pt == btmPt2-&gt;Pt) &amp;&amp; (p != btmPt2)) p = p-&gt;Next;
-  double dx2n = std::fabs(GetDx(btmPt2-&gt;Pt, p-&gt;Pt));
-
-  if (std::max(dx1p, dx1n) == std::max(dx2p, dx2n) &amp;&amp;
-    std::min(dx1p, dx1n) == std::min(dx2p, dx2n))
+  bool FirstIsBottomPt(const OutPt *btmPt1, const OutPt *btmPt2)
+  {
+    OutPt *p = btmPt1-&gt;Prev;
+    while ((p-&gt;Pt == btmPt1-&gt;Pt) &amp;&amp; (p != btmPt1))
+      p = p-&gt;Prev;
+    double dx1p = std::fabs(GetDx(btmPt1-&gt;Pt, p-&gt;Pt));
+    p = btmPt1-&gt;Next;
+    while ((p-&gt;Pt == btmPt1-&gt;Pt) &amp;&amp; (p != btmPt1))
+      p = p-&gt;Next;
+    double dx1n = std::fabs(GetDx(btmPt1-&gt;Pt, p-&gt;Pt));
+
+    p = btmPt2-&gt;Prev;
+    while ((p-&gt;Pt == btmPt2-&gt;Pt) &amp;&amp; (p != btmPt2))
+      p = p-&gt;Prev;
+    double dx2p = std::fabs(GetDx(btmPt2-&gt;Pt, p-&gt;Pt));
+    p = btmPt2-&gt;Next;
+    while ((p-&gt;Pt == btmPt2-&gt;Pt) &amp;&amp; (p != btmPt2))
+      p = p-&gt;Next;
+    double dx2n = std::fabs(GetDx(btmPt2-&gt;Pt, p-&gt;Pt));
+
+    if (std::max(dx1p, dx1n) == std::max(dx2p, dx2n) &amp;&amp;
+        std::min(dx1p, dx1n) == std::min(dx2p, dx2n))
       return Area(btmPt1) &gt; 0; //if otherwise identical use orientation
-  else
-    return (dx1p &gt;= dx2p &amp;&amp; dx1p &gt;= dx2n) || (dx1n &gt;= dx2p &amp;&amp; dx1n &gt;= dx2n);
-}
+    else
+      return (dx1p &gt;= dx2p &amp;&amp; dx1p &gt;= dx2n) || (dx1n &gt;= dx2p &amp;&amp; dx1n &gt;= dx2n);
+  }
 //------------------------------------------------------------------------------
 
-OutPt* GetBottomPt(OutPt *pp)
-{
-  OutPt* dups = 0;
-  OutPt* p = pp-&gt;Next;
-  while (p != pp)
+  OutPt *GetBottomPt(OutPt *pp)
   {
-    if (p-&gt;Pt.Y &gt; pp-&gt;Pt.Y)
+    OutPt *dups = 0;
+    OutPt *p = pp-&gt;Next;
+    while (p != pp)
     {
-      pp = p;
-      dups = 0;
-    }
-    else if (p-&gt;Pt.Y == pp-&gt;Pt.Y &amp;&amp; p-&gt;Pt.X &lt;= pp-&gt;Pt.X)
-    {
-      if (p-&gt;Pt.X &lt; pp-&gt;Pt.X)
+      if (p-&gt;Pt.Y &gt; pp-&gt;Pt.Y)
       {
-        dups = 0;
         pp = p;
-      } else
+        dups = 0;
+      } else if (p-&gt;Pt.Y == pp-&gt;Pt.Y &amp;&amp; p-&gt;Pt.X &lt;= pp-&gt;Pt.X)
       {
-        if (p-&gt;Next != pp &amp;&amp; p-&gt;Prev != pp) dups = p;
+        if (p-&gt;Pt.X &lt; pp-&gt;Pt.X)
+        {
+          dups = 0;
+          pp = p;
+        } else
+        {
+          if (p-&gt;Next != pp &amp;&amp; p-&gt;Prev != pp)
+            dups = p;
+        }
       }
+      p = p-&gt;Next;
     }
-    p = p-&gt;Next;
-  }
-  if (dups)
-  {
-    //there appears to be at least 2 vertices at BottomPt so ...
-    while (dups != p)
+    if (dups)
     {
-      if (!FirstIsBottomPt(p, dups)) pp = dups;
-      dups = dups-&gt;Next;
-      while (dups-&gt;Pt != pp-&gt;Pt) dups = dups-&gt;Next;
+      //there appears to be at least 2 vertices at BottomPt so ...
+      while (dups != p)
+      {
+        if (!FirstIsBottomPt(p, dups))
+          pp = dups;
+        dups = dups-&gt;Next;
+        while (dups-&gt;Pt != pp-&gt;Pt)
+          dups = dups-&gt;Next;
+      }
     }
+    return pp;
   }
-  return pp;
-}
 //------------------------------------------------------------------------------
 
-bool Pt2IsBetweenPt1AndPt3(const IntPoint pt1,
-  const IntPoint pt2, const IntPoint pt3)
-{
-  if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))
-    return false;
-  else if (pt1.X != pt3.X)
-    return (pt2.X &gt; pt1.X) == (pt2.X &lt; pt3.X);
-  else
-    return (pt2.Y &gt; pt1.Y) == (pt2.Y &lt; pt3.Y);
-}
+  bool Pt2IsBetweenPt1AndPt3(const IntPoint pt1,
+                             const IntPoint pt2, const IntPoint pt3)
+  {
+    if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))
+      return false;
+    else if (pt1.X != pt3.X)
+      return (pt2.X &gt; pt1.X) == (pt2.X &lt; pt3.X);
+    else
+      return (pt2.Y &gt; pt1.Y) == (pt2.Y &lt; pt3.Y);
+  }
 //------------------------------------------------------------------------------
 
-bool HorzSegmentsOverlap(cInt seg1a, cInt seg1b, cInt seg2a, cInt seg2b)
-{
-  if (seg1a &gt; seg1b) std::swap(seg1a, seg1b);
-  if (seg2a &gt; seg2b) std::swap(seg2a, seg2b);
-  return (seg1a &lt; seg2b) &amp;&amp; (seg2a &lt; seg1b);
-}
+  bool HorzSegmentsOverlap(cInt seg1a, cInt seg1b, cInt seg2a, cInt seg2b)
+  {
+    if (seg1a &gt; seg1b)
+      std::swap(seg1a, seg1b);
+    if (seg2a &gt; seg2b)
+      std::swap(seg2a, seg2b);
+    return (seg1a &lt; seg2b) &amp;&amp; (seg2a &lt; seg1b);
+  }
 
 //------------------------------------------------------------------------------
 // ClipperBase class methods ...
 //------------------------------------------------------------------------------
 
-ClipperBase::ClipperBase() //constructor
-{
-  m_CurrentLM = m_MinimaList.begin(); //begin() == end() here
-  m_UseFullRange = false;
-}
-//------------------------------------------------------------------------------
-
-ClipperBase::~ClipperBase() //destructor
-{
-  Clear();
-}
-//------------------------------------------------------------------------------
-
-void RangeTest(const IntPoint&amp; Pt, bool&amp; useFullRange)
-{
-  if (useFullRange)
+  ClipperBase::ClipperBase() //constructor
   {
-    if (Pt.X &gt; hiRange || Pt.Y &gt; hiRange || -Pt.X &gt; hiRange || -Pt.Y &gt; hiRange) 
-      throw clipperException("Coordinate outside allowed range");
+    m_CurrentLM = m_MinimaList.begin(); //begin() == end() here
+    m_UseFullRange = false;
   }
-  else if (Pt.X &gt; loRange|| Pt.Y &gt; loRange || -Pt.X &gt; loRange || -Pt.Y &gt; loRange) 
-  {
-    useFullRange = true;
-    RangeTest(Pt, useFullRange);
-  }
-}
 //------------------------------------------------------------------------------
 
-TEdge* FindNextLocMin(TEdge* E)
-{
-  for (;;)
-  {
-    while (E-&gt;Bot != E-&gt;Prev-&gt;Bot || E-&gt;Curr == E-&gt;Top) E = E-&gt;Next;
-    if (!IsHorizontal(*E) &amp;&amp; !IsHorizontal(*E-&gt;Prev)) break;
-    while (IsHorizontal(*E-&gt;Prev)) E = E-&gt;Prev;
-    TEdge* E2 = E;
-    while (IsHorizontal(*E)) E = E-&gt;Next;
-    if (E-&gt;Top.Y == E-&gt;Prev-&gt;Bot.Y) continue; //ie just an intermediate horz.
-    if (E2-&gt;Prev-&gt;Bot.X &lt; E-&gt;Bot.X) E = E2;
-    break;
-  }
-  return E;
-}
+  ClipperBase::~ClipperBase() //destructor
+  {
+    Clear();
+  }
 //------------------------------------------------------------------------------
 
-TEdge* ClipperBase::ProcessBound(TEdge* E, bool NextIsForward)
-{
-  TEdge *Result = E;
-  TEdge *Horz = 0;
-
-  if (E-&gt;OutIdx == Skip)
+  void RangeTest(const IntPoint &amp;Pt, bool &amp;useFullRange)
   {
-    //if edges still remain in the current bound beyond the skip edge then
-    //create another LocMin and call ProcessBound once more
-    if (NextIsForward)
+    if (useFullRange)
+    {
+      if (Pt.X &gt; hiRange || Pt.Y &gt; hiRange || -Pt.X &gt; hiRange || -Pt.Y &gt; hiRange)
+        throw clipperException("Coordinate outside allowed range");
+    } else if (Pt.X &gt; loRange || Pt.Y &gt; loRange || -Pt.X &gt; loRange || -Pt.Y &gt; loRange)
     {
-      while (E-&gt;Top.Y == E-&gt;Next-&gt;Bot.Y) E = E-&gt;Next;
-      //don't include top horizontals when parsing a bound a second time,
-      //they will be contained in the opposite bound ...
-      while (E != Result &amp;&amp; IsHorizontal(*E)) E = E-&gt;Prev;
+      useFullRange = true;
+      RangeTest(Pt, useFullRange);
     }
-    else
+  }
+//------------------------------------------------------------------------------
+
+  TEdge *FindNextLocMin(TEdge *E)
+  {
+    for (;;)
     {
-      while (E-&gt;Top.Y == E-&gt;Prev-&gt;Bot.Y) E = E-&gt;Prev;
-      while (E != Result &amp;&amp; IsHorizontal(*E)) E = E-&gt;Next;
+      while (E-&gt;Bot != E-&gt;Prev-&gt;Bot || E-&gt;Curr == E-&gt;Top)
+        E = E-&gt;Next;
+      if (!IsHorizontal(*E) &amp;&amp; !IsHorizontal(*E-&gt;Prev))
+        break;
+      while (IsHorizontal(*E-&gt;Prev))
+        E = E-&gt;Prev;
+      TEdge *E2 = E;
+      while (IsHorizontal(*E))
+        E = E-&gt;Next;
+      if (E-&gt;Top.Y == E-&gt;Prev-&gt;Bot.Y)
+        continue; //ie just an intermediate horz.
+      if (E2-&gt;Prev-&gt;Bot.X &lt; E-&gt;Bot.X)
+        E = E2;
+      break;
     }
+    return E;
+  }
+//------------------------------------------------------------------------------
+
+  TEdge *ClipperBase::ProcessBound(TEdge *E, bool NextIsForward)
+  {
+    TEdge *Result = E;
+    TEdge *Horz = 0;
 
-    if (E == Result)
+    if (E-&gt;OutIdx == Skip)
     {
-      if (NextIsForward) Result = E-&gt;Next;
-      else Result = E-&gt;Prev;
+      //if edges still remain in the current bound beyond the skip edge then
+      //create another LocMin and call ProcessBound once more
+      if (NextIsForward)
+      {
+        while (E-&gt;Top.Y == E-&gt;Next-&gt;Bot.Y)
+          E = E-&gt;Next;
+        //don't include top horizontals when parsing a bound a second time,
+        //they will be contained in the opposite bound ...
+        while (E != Result &amp;&amp; IsHorizontal(*E))
+          E = E-&gt;Prev;
+      } else
+      {
+        while (E-&gt;Top.Y == E-&gt;Prev-&gt;Bot.Y)
+          E = E-&gt;Prev;
+        while (E != Result &amp;&amp; IsHorizontal(*E))
+          E = E-&gt;Next;
+      }
+
+      if (E == Result)
+      {
+        if (NextIsForward)
+          Result = E-&gt;Next;
+        else
+          Result = E-&gt;Prev;
+      } else
+      {
+        //there are more edges in the bound beyond result starting with E
+        if (NextIsForward)
+          E = Result-&gt;Next;
+        else
+          E = Result-&gt;Prev;
+        MinimaList::value_type locMin;
+        locMin.Y = E-&gt;Bot.Y;
+        locMin.LeftBound = 0;
+        locMin.RightBound = E;
+        E-&gt;WindDelta = 0;
+        Result = ProcessBound(E, NextIsForward);
+        m_MinimaList.push_back(locMin);
+      }
+      return Result;
     }
-    else
+
+    TEdge *EStart;
+
+    if (IsHorizontal(*E))
     {
-      //there are more edges in the bound beyond result starting with E
+      //We need to be careful with open paths because this may not be a
+      //true local minima (ie E may be following a skip edge).
+      //Also, consecutive horz. edges may start heading left before going right.
       if (NextIsForward)
-        E = Result-&gt;Next;
+        EStart = E-&gt;Prev;
       else
-        E = Result-&gt;Prev;
-      MinimaList::value_type locMin;
-      locMin.Y = E-&gt;Bot.Y;
-      locMin.LeftBound = 0;
-      locMin.RightBound = E;
-      E-&gt;WindDelta = 0;
-      Result = ProcessBound(E, NextIsForward);
-      m_MinimaList.push_back(locMin);
+        EStart = E-&gt;Next;
+      if (IsHorizontal(*EStart)) //ie an adjoining horizontal skip edge
+      {
+        if (EStart-&gt;Bot.X != E-&gt;Bot.X &amp;&amp; EStart-&gt;Top.X != E-&gt;Bot.X)
+          ReverseHorizontal(*E);
+      } else if (EStart-&gt;Bot.X != E-&gt;Bot.X)
+        ReverseHorizontal(*E);
     }
-    return Result;
-  }
 
-  TEdge *EStart;
+    EStart = E;
+    if (NextIsForward)
+    {
+      while (Result-&gt;Top.Y == Result-&gt;Next-&gt;Bot.Y &amp;&amp; Result-&gt;Next-&gt;OutIdx != Skip)
+        Result = Result-&gt;Next;
+      if (IsHorizontal(*Result) &amp;&amp; Result-&gt;Next-&gt;OutIdx != Skip)
+      {
+        //nb: at the top of a bound, horizontals are added to the bound
+        //only when the preceding edge attaches to the horizontal's left vertex
+        //unless a Skip edge is encountered when that becomes the top divide
+        Horz = Result;
+        while (IsHorizontal(*Horz-&gt;Prev))
+          Horz = Horz-&gt;Prev;
+        if (Horz-&gt;Prev-&gt;Top.X &gt; Result-&gt;Next-&gt;Top.X)
+          Result = Horz-&gt;Prev;
+      }
+      while (E != Result)
+      {
+        E-&gt;NextInLML = E-&gt;Next;
+        if (IsHorizontal(*E) &amp;&amp; E != EStart &amp;&amp;
+            E-&gt;Bot.X != E-&gt;Prev-&gt;Top.X)
+          ReverseHorizontal(*E);
+        E = E-&gt;Next;
+      }
+      if (IsHorizontal(*E) &amp;&amp; E != EStart &amp;&amp; E-&gt;Bot.X != E-&gt;Prev-&gt;Top.X)
+        ReverseHorizontal(*E);
+      Result = Result-&gt;Next; //move to the edge just beyond current bound
+    } else
+    {
+      while (Result-&gt;Top.Y == Result-&gt;Prev-&gt;Bot.Y &amp;&amp; Result-&gt;Prev-&gt;OutIdx != Skip)
+        Result = Result-&gt;Prev;
+      if (IsHorizontal(*Result) &amp;&amp; Result-&gt;Prev-&gt;OutIdx != Skip)
+      {
+        Horz = Result;
+        while (IsHorizontal(*Horz-&gt;Next))
+          Horz = Horz-&gt;Next;
+        if (Horz-&gt;Next-&gt;Top.X == Result-&gt;Prev-&gt;Top.X ||
+            Horz-&gt;Next-&gt;Top.X &gt; Result-&gt;Prev-&gt;Top.X)
+          Result = Horz-&gt;Next;
+      }
 
-  if (IsHorizontal(*E))
-  {
-    //We need to be careful with open paths because this may not be a
-    //true local minima (ie E may be following a skip edge).
-    //Also, consecutive horz. edges may start heading left before going right.
-    if (NextIsForward) 
-      EStart = E-&gt;Prev;
-    else 
-      EStart = E-&gt;Next;
-    if (IsHorizontal(*EStart)) //ie an adjoining horizontal skip edge
+      while (E != Result)
       {
-        if (EStart-&gt;Bot.X != E-&gt;Bot.X &amp;&amp; EStart-&gt;Top.X != E-&gt;Bot.X)
+        E-&gt;NextInLML = E-&gt;Prev;
+        if (IsHorizontal(*E) &amp;&amp; E != EStart &amp;&amp; E-&gt;Bot.X != E-&gt;Next-&gt;Top.X)
           ReverseHorizontal(*E);
+        E = E-&gt;Prev;
       }
-      else if (EStart-&gt;Bot.X != E-&gt;Bot.X)
+      if (IsHorizontal(*E) &amp;&amp; E != EStart &amp;&amp; E-&gt;Bot.X != E-&gt;Next-&gt;Top.X)
         ReverseHorizontal(*E);
+      Result = Result-&gt;Prev; //move to the edge just beyond current bound
+    }
+
+    return Result;
   }
-  
-  EStart = E;
-  if (NextIsForward)
+//------------------------------------------------------------------------------
+
+  bool ClipperBase::AddPath(const Path &amp;pg, PolyType PolyTyp, bool Closed)
   {
-    while (Result-&gt;Top.Y == Result-&gt;Next-&gt;Bot.Y &amp;&amp; Result-&gt;Next-&gt;OutIdx != Skip)
-      Result = Result-&gt;Next;
-    if (IsHorizontal(*Result) &amp;&amp; Result-&gt;Next-&gt;OutIdx != Skip)
+#ifdef use_lines
+    if (!Closed &amp;&amp; PolyTyp == ptClip)
+      throw clipperException("AddPath: Open paths must be subject.");
+#else
+                                                                                                                            if (!Closed)
+    throw clipperException("AddPath: Open paths have been disabled.");
+#endif
+
+    int highI = (int) pg.size() - 1;
+    if (Closed)
+      while (highI &gt; 0 &amp;&amp; (pg[highI] == pg[0]))
+        --highI;
+    while (highI &gt; 0 &amp;&amp; (pg[highI] == pg[highI - 1]))
+      --highI;
+    if ((Closed &amp;&amp; highI &lt; 2) || (!Closed &amp;&amp; highI &lt; 1))
+      return false;
+
+    //create a new edge array ...
+    TEdge *edges = new TEdge[highI + 1];
+
+    bool IsFlat = true;
+    //1. Basic (first) edge initialization ...
+    try
+    {
+      edges[1].Curr = pg[1];
+      RangeTest(pg[0], m_UseFullRange);
+      RangeTest(pg[highI], m_UseFullRange);
+      InitEdge(&amp;edges[0], &amp;edges[1], &amp;edges[highI], pg[0]);
+      InitEdge(&amp;edges[highI], &amp;edges[0], &amp;edges[highI - 1], pg[highI]);
+      for (int i = highI - 1; i &gt;= 1; --i)
+      {
+        RangeTest(pg[i], m_UseFullRange);
+        InitEdge(&amp;edges[i], &amp;edges[i + 1], &amp;edges[i - 1], pg[i]);
+      }
+    }
+    catch (...)
     {
-      //nb: at the top of a bound, horizontals are added to the bound
-      //only when the preceding edge attaches to the horizontal's left vertex
-      //unless a Skip edge is encountered when that becomes the top divide
-      Horz = Result;
-      while (IsHorizontal(*Horz-&gt;Prev)) Horz = Horz-&gt;Prev;
-      if (Horz-&gt;Prev-&gt;Top.X &gt; Result-&gt;Next-&gt;Top.X) Result = Horz-&gt;Prev;
+      delete[] edges;
+      throw; //range test fails
     }
-    while (E != Result) 
+    TEdge *eStart = &amp;edges[0];
+
+    //2. Remove duplicate vertices, and (when closed) collinear edges ...
+    TEdge *E = eStart, *eLoopStop = eStart;
+    for (;;)
     {
-      E-&gt;NextInLML = E-&gt;Next;
-      if (IsHorizontal(*E) &amp;&amp; E != EStart &amp;&amp;
-        E-&gt;Bot.X != E-&gt;Prev-&gt;Top.X) ReverseHorizontal(*E);
+      //nb: allows matching start and end points when not Closed ...
+      if (E-&gt;Curr == E-&gt;Next-&gt;Curr &amp;&amp; (Closed || E-&gt;Next != eStart))
+      {
+        if (E == E-&gt;Next)
+          break;
+        if (E == eStart)
+          eStart = E-&gt;Next;
+        E = RemoveEdge(E);
+        eLoopStop = E;
+        continue;
+      }
+      if (E-&gt;Prev == E-&gt;Next)
+        break; //only two vertices
+      else if (Closed &amp;&amp;
+               SlopesEqual(E-&gt;Prev-&gt;Curr, E-&gt;Curr, E-&gt;Next-&gt;Curr, m_UseFullRange) &amp;&amp;
+               (!m_PreserveCollinear ||
+                !Pt2IsBetweenPt1AndPt3(E-&gt;Prev-&gt;Curr, E-&gt;Curr, E-&gt;Next-&gt;Curr)))
+      {
+        //Collinear edges are allowed for open paths but in closed paths
+        //the default is to merge adjacent collinear edges into a single edge.
+        //However, if the PreserveCollinear property is enabled, only overlapping
+        //collinear edges (ie spikes) will be removed from closed paths.
+        if (E == eStart)
+          eStart = E-&gt;Next;
+        E = RemoveEdge(E);
+        E = E-&gt;Prev;
+        eLoopStop = E;
+        continue;
+      }
       E = E-&gt;Next;
+      if ((E == eLoopStop) || (!Closed &amp;&amp; E-&gt;Next == eStart))
+        break;
     }
-    if (IsHorizontal(*E) &amp;&amp; E != EStart &amp;&amp; E-&gt;Bot.X != E-&gt;Prev-&gt;Top.X) 
-      ReverseHorizontal(*E);
-    Result = Result-&gt;Next; //move to the edge just beyond current bound
-  } else
-  {
-    while (Result-&gt;Top.Y == Result-&gt;Prev-&gt;Bot.Y &amp;&amp; Result-&gt;Prev-&gt;OutIdx != Skip) 
-      Result = Result-&gt;Prev;
-    if (IsHorizontal(*Result) &amp;&amp; Result-&gt;Prev-&gt;OutIdx != Skip)
-    {
-      Horz = Result;
-      while (IsHorizontal(*Horz-&gt;Next)) Horz = Horz-&gt;Next;
-      if (Horz-&gt;Next-&gt;Top.X == Result-&gt;Prev-&gt;Top.X ||
-          Horz-&gt;Next-&gt;Top.X &gt; Result-&gt;Prev-&gt;Top.X) Result = Horz-&gt;Next;
+
+    if ((!Closed &amp;&amp; (E == E-&gt;Next)) || (Closed &amp;&amp; (E-&gt;Prev == E-&gt;Next)))
+    {
+      delete[] edges;
+      return false;
     }
 
-    while (E != Result)
+    if (!Closed)
     {
-      E-&gt;NextInLML = E-&gt;Prev;
-      if (IsHorizontal(*E) &amp;&amp; E != EStart &amp;&amp; E-&gt;Bot.X != E-&gt;Next-&gt;Top.X) 
-        ReverseHorizontal(*E);
-      E = E-&gt;Prev;
+      m_HasOpenPaths = true;
+      eStart-&gt;Prev-&gt;OutIdx = Skip;
     }
-    if (IsHorizontal(*E) &amp;&amp; E != EStart &amp;&amp; E-&gt;Bot.X != E-&gt;Next-&gt;Top.X) 
-      ReverseHorizontal(*E);
-    Result = Result-&gt;Prev; //move to the edge just beyond current bound
-  }
 
-  return Result;
-}
-//------------------------------------------------------------------------------
+    //3. Do second stage of edge initialization ...
+    E = eStart;
+    do
+    {
+      InitEdge2(*E, PolyTyp);
+      E = E-&gt;Next;
+      if (IsFlat &amp;&amp; E-&gt;Curr.Y != eStart-&gt;Curr.Y)
+        IsFlat = false;
+    } while (E != eStart);
 
-bool ClipperBase::AddPath(const Path &amp;pg, PolyType PolyTyp, bool Closed)
-{
-#ifdef use_lines
-  if (!Closed &amp;&amp; PolyTyp == ptClip)
-    throw clipperException("AddPath: Open paths must be subject.");
-#else
-  if (!Closed)
-    throw clipperException("AddPath: Open paths have been disabled.");
-#endif
+    //4. Finally, add edge bounds to LocalMinima list ...
 
-  int highI = (int)pg.size() -1;
-  if (Closed) while (highI &gt; 0 &amp;&amp; (pg[highI] == pg[0])) --highI;
-  while (highI &gt; 0 &amp;&amp; (pg[highI] == pg[highI -1])) --highI;
-  if ((Closed &amp;&amp; highI &lt; 2) || (!Closed &amp;&amp; highI &lt; 1)) return false;
+    //Totally flat paths must be handled differently when adding them
+    //to LocalMinima list to avoid endless loops etc ...
+    if (IsFlat)
+    {
+      if (Closed)
+      {
+        delete[] edges;
+        return false;
+      }
+      E-&gt;Prev-&gt;OutIdx = Skip;
+      MinimaList::value_type locMin;
+      locMin.Y = E-&gt;Bot.Y;
+      locMin.LeftBound = 0;
+      locMin.RightBound = E;
+      locMin.RightBound-&gt;Side = esRight;
+      locMin.RightBound-&gt;WindDelta = 0;
+      for (;;)
+      {
+        if (E-&gt;Bot.X != E-&gt;Prev-&gt;Top.X)
+          ReverseHorizontal(*E);
+        if (E-&gt;Next-&gt;OutIdx == Skip)
+          break;
+        E-&gt;NextInLML = E-&gt;Next;
+        E = E-&gt;Next;
+      }
+      m_MinimaList.push_back(locMin);
+      m_edges.push_back(edges);
+      return true;
+    }
 
-  //create a new edge array ...
-  TEdge *edges = new TEdge [highI +1];
+    m_edges.push_back(edges);
+    bool leftBoundIsForward;
+    TEdge *EMin = 0;
 
-  bool IsFlat = true;
-  //1. Basic (first) edge initialization ...
-  try
-  {
-    edges[1].Curr = pg[1];
-    RangeTest(pg[0], m_UseFullRange);
-    RangeTest(pg[highI], m_UseFullRange);
-    InitEdge(&amp;edges[0], &amp;edges[1], &amp;edges[highI], pg[0]);
-    InitEdge(&amp;edges[highI], &amp;edges[0], &amp;edges[highI-1], pg[highI]);
-    for (int i = highI - 1; i &gt;= 1; --i)
+    //workaround to avoid an endless loop in the while loop below when
+    //open paths have matching start and end points ...
+    if (E-&gt;Prev-&gt;Bot == E-&gt;Prev-&gt;Top)
+      E = E-&gt;Next;
+
+    for (;;)
     {
-      RangeTest(pg[i], m_UseFullRange);
-      InitEdge(&amp;edges[i], &amp;edges[i+1], &amp;edges[i-1], pg[i]);
+      E = FindNextLocMin(E);
+      if (E == EMin)
+        break;
+      else if (!EMin)
+        EMin = E;
+
+      //E and E.Prev now share a local minima (left aligned if horizontal).
+      //Compare their slopes to find which starts which bound ...
+      MinimaList::value_type locMin;
+      locMin.Y = E-&gt;Bot.Y;
+      if (E-&gt;Dx &lt; E-&gt;Prev-&gt;Dx)
+      {
+        locMin.LeftBound = E-&gt;Prev;
+        locMin.RightBound = E;
+        leftBoundIsForward = false; //Q.nextInLML = Q.prev
+      } else
+      {
+        locMin.LeftBound = E;
+        locMin.RightBound = E-&gt;Prev;
+        leftBoundIsForward = true; //Q.nextInLML = Q.next
+      }
+
+      if (!Closed)
+        locMin.LeftBound-&gt;WindDelta = 0;
+      else if (locMin.LeftBound-&gt;Next == locMin.RightBound)
+        locMin.LeftBound-&gt;WindDelta = -1;
+      else
+        locMin.LeftBound-&gt;WindDelta = 1;
+      locMin.RightBound-&gt;WindDelta = -locMin.LeftBound-&gt;WindDelta;
+
+      E = ProcessBound(locMin.LeftBound, leftBoundIsForward);
+      if (E-&gt;OutIdx == Skip)
+        E = ProcessBound(E, leftBoundIsForward);
+
+      TEdge *E2 = ProcessBound(locMin.RightBound, !leftBoundIsForward);
+      if (E2-&gt;OutIdx == Skip)
+        E2 = ProcessBound(E2, !leftBoundIsForward);
+
+      if (locMin.LeftBound-&gt;OutIdx == Skip)
+        locMin.LeftBound = 0;
+      else if (locMin.RightBound-&gt;OutIdx == Skip)
+        locMin.RightBound = 0;
+      m_MinimaList.push_back(locMin);
+      if (!leftBoundIsForward)
+        E = E2;
     }
+    return true;
   }
-  catch(...)
+//------------------------------------------------------------------------------
+
+  bool ClipperBase::AddPaths(const Paths &amp;ppg, PolyType PolyTyp, bool Closed)
   {
-    delete [] edges;
-    throw; //range test fails
+    bool result = false;
+    for (Paths::size_type i = 0; i &lt; ppg.size(); ++i)
+      if (AddPath(ppg[i], PolyTyp, Closed))
+        result = true;
+    return result;
   }
-  TEdge *eStart = &amp;edges[0];
+//------------------------------------------------------------------------------
 
-  //2. Remove duplicate vertices, and (when closed) collinear edges ...
-  TEdge *E = eStart, *eLoopStop = eStart;
-  for (;;)
+  void ClipperBase::Clear()
   {
-    //nb: allows matching start and end points when not Closed ...
-    if (E-&gt;Curr == E-&gt;Next-&gt;Curr &amp;&amp; (Closed || E-&gt;Next != eStart))
+    DisposeLocalMinimaList();
+    for (EdgeList::size_type i = 0; i &lt; m_edges.size(); ++i)
     {
-      if (E == E-&gt;Next) break;
-      if (E == eStart) eStart = E-&gt;Next;
-      E = RemoveEdge(E);
-      eLoopStop = E;
-      continue;
+      TEdge *edges = m_edges[i];
+      delete[] edges;
     }
-    if (E-&gt;Prev == E-&gt;Next) 
-      break; //only two vertices
-    else if (Closed &amp;&amp;
-      SlopesEqual(E-&gt;Prev-&gt;Curr, E-&gt;Curr, E-&gt;Next-&gt;Curr, m_UseFullRange) &amp;&amp; 
-      (!m_PreserveCollinear ||
-      !Pt2IsBetweenPt1AndPt3(E-&gt;Prev-&gt;Curr, E-&gt;Curr, E-&gt;Next-&gt;Curr)))
-    {
-      //Collinear edges are allowed for open paths but in closed paths
-      //the default is to merge adjacent collinear edges into a single edge.
-      //However, if the PreserveCollinear property is enabled, only overlapping
-      //collinear edges (ie spikes) will be removed from closed paths.
-      if (E == eStart) eStart = E-&gt;Next;
-      E = RemoveEdge(E);
-      E = E-&gt;Prev;
-      eLoopStop = E;
-      continue;
-    }
-    E = E-&gt;Next;
-    if ((E == eLoopStop) || (!Closed &amp;&amp; E-&gt;Next == eStart)) break;
+    m_edges.clear();
+    m_UseFullRange = false;
+    m_HasOpenPaths = false;
   }
+//------------------------------------------------------------------------------
 
-  if ((!Closed &amp;&amp; (E == E-&gt;Next)) || (Closed &amp;&amp; (E-&gt;Prev == E-&gt;Next)))
+  void ClipperBase::Reset()
   {
-    delete [] edges;
-    return false;
-  }
+    m_CurrentLM = m_MinimaList.begin();
+    if (m_CurrentLM == m_MinimaList.end())
+      return; //ie nothing to process
+    std::sort(m_MinimaList.begin(), m_MinimaList.end(), LocMinSorter());
 
-  if (!Closed)
-  { 
-    m_HasOpenPaths = true;
-    eStart-&gt;Prev-&gt;OutIdx = Skip;
+    m_Scanbeam = ScanbeamList(); //clears/resets priority_queue
+    //reset all edges ...
+    for (MinimaList::iterator lm = m_MinimaList.begin(); lm != m_MinimaList.end(); ++lm)
+    {
+      InsertScanbeam(lm-&gt;Y);
+      TEdge *e = lm-&gt;LeftBound;
+      if (e)
+      {
+        e-&gt;Curr = e-&gt;Bot;
+        e-&gt;Side = esLeft;
+        e-&gt;OutIdx = Unassigned;
+      }
+
+      e = lm-&gt;RightBound;
+      if (e)
+      {
+        e-&gt;Curr = e-&gt;Bot;
+        e-&gt;Side = esRight;
+        e-&gt;OutIdx = Unassigned;
+      }
+    }
+    m_ActiveEdges = 0;
+    m_CurrentLM = m_MinimaList.begin();
   }
+//------------------------------------------------------------------------------
 
-  //3. Do second stage of edge initialization ...
-  E = eStart;
-  do
+  void ClipperBase::DisposeLocalMinimaList()
   {
-    InitEdge2(*E, PolyTyp);
-    E = E-&gt;Next;
-    if (IsFlat &amp;&amp; E-&gt;Curr.Y != eStart-&gt;Curr.Y) IsFlat = false;
+    m_MinimaList.clear();
+    m_CurrentLM = m_MinimaList.begin();
   }
-  while (E != eStart);
-
-  //4. Finally, add edge bounds to LocalMinima list ...
+//------------------------------------------------------------------------------
 
-  //Totally flat paths must be handled differently when adding them
-  //to LocalMinima list to avoid endless loops etc ...
-  if (IsFlat) 
+  bool ClipperBase::PopLocalMinima(cInt Y, const LocalMinimum *&amp;locMin)
   {
-    if (Closed) 
-    {
-      delete [] edges;
+    if (m_CurrentLM == m_MinimaList.end() || (*m_CurrentLM).Y != Y)
       return false;
-    }
-    E-&gt;Prev-&gt;OutIdx = Skip;
-    MinimaList::value_type locMin;
-    locMin.Y = E-&gt;Bot.Y;
-    locMin.LeftBound = 0;
-    locMin.RightBound = E;
-    locMin.RightBound-&gt;Side = esRight;
-    locMin.RightBound-&gt;WindDelta = 0;
-    for (;;)
-    {
-      if (E-&gt;Bot.X != E-&gt;Prev-&gt;Top.X) ReverseHorizontal(*E);
-      if (E-&gt;Next-&gt;OutIdx == Skip) break;
-      E-&gt;NextInLML = E-&gt;Next;
-      E = E-&gt;Next;
-    }
-    m_MinimaList.push_back(locMin);
-    m_edges.push_back(edges);
-	  return true;
+    locMin = &amp;(*m_CurrentLM);
+    ++m_CurrentLM;
+    return true;
   }
+//------------------------------------------------------------------------------
 
-  m_edges.push_back(edges);
-  bool leftBoundIsForward;
-  TEdge* EMin = 0;
-
-  //workaround to avoid an endless loop in the while loop below when
-  //open paths have matching start and end points ...
-  if (E-&gt;Prev-&gt;Bot == E-&gt;Prev-&gt;Top) E = E-&gt;Next;
-
-  for (;;)
+  IntRect ClipperBase::GetBounds()
   {
-    E = FindNextLocMin(E);
-    if (E == EMin) break;
-    else if (!EMin) EMin = E;
-
-    //E and E.Prev now share a local minima (left aligned if horizontal).
-    //Compare their slopes to find which starts which bound ...
-    MinimaList::value_type locMin;
-    locMin.Y = E-&gt;Bot.Y;
-    if (E-&gt;Dx &lt; E-&gt;Prev-&gt;Dx) 
+    IntRect result;
+    MinimaList::iterator lm = m_MinimaList.begin();
+    if (lm == m_MinimaList.end())
     {
-      locMin.LeftBound = E-&gt;Prev;
-      locMin.RightBound = E;
-      leftBoundIsForward = false; //Q.nextInLML = Q.prev
-    } else
+      result.left = result.top = result.right = result.bottom = 0;
+      return result;
+    }
+    result.left = lm-&gt;LeftBound-&gt;Bot.X;
+    result.top = lm-&gt;LeftBound-&gt;Bot.Y;
+    result.right = lm-&gt;LeftBound-&gt;Bot.X;
+    result.bottom = lm-&gt;LeftBound-&gt;Bot.Y;
+    while (lm != m_MinimaList.end())
     {
-      locMin.LeftBound = E;
-      locMin.RightBound = E-&gt;Prev;
-      leftBoundIsForward = true; //Q.nextInLML = Q.next
+      //todo - needs fixing for open paths
+      result.bottom = std::max(result.bottom, lm-&gt;LeftBound-&gt;Bot.Y);
+      TEdge *e = lm-&gt;LeftBound;
+      for (;;)
+      {
+        TEdge *bottomE = e;
+        while (e-&gt;NextInLML)
+        {
+          if (e-&gt;Bot.X &lt; result.left)
+            result.left = e-&gt;Bot.X;
+          if (e-&gt;Bot.X &gt; result.right)
+            result.right = e-&gt;Bot.X;
+          e = e-&gt;NextInLML;
+        }
+        result.left = std::min(result.left, e-&gt;Bot.X);
+        result.right = std::max(result.right, e-&gt;Bot.X);
+        result.left = std::min(result.left, e-&gt;Top.X);
+        result.right = std::max(result.right, e-&gt;Top.X);
+        result.top = std::min(result.top, e-&gt;Top.Y);
+        if (bottomE == lm-&gt;LeftBound)
+          e = lm-&gt;RightBound;
+        else
+          break;
+      }
+      ++lm;
     }
-
-    if (!Closed) locMin.LeftBound-&gt;WindDelta = 0;
-    else if (locMin.LeftBound-&gt;Next == locMin.RightBound)
-      locMin.LeftBound-&gt;WindDelta = -1;
-    else locMin.LeftBound-&gt;WindDelta = 1;
-    locMin.RightBound-&gt;WindDelta = -locMin.LeftBound-&gt;WindDelta;
-
-    E = ProcessBound(locMin.LeftBound, leftBoundIsForward);
-    if (E-&gt;OutIdx == Skip) E = ProcessBound(E, leftBoundIsForward);
-
-    TEdge* E2 = ProcessBound(locMin.RightBound, !leftBoundIsForward);
-    if (E2-&gt;OutIdx == Skip) E2 = ProcessBound(E2, !leftBoundIsForward);
-
-    if (locMin.LeftBound-&gt;OutIdx == Skip)
-      locMin.LeftBound = 0;
-    else if (locMin.RightBound-&gt;OutIdx == Skip)
-      locMin.RightBound = 0;
-    m_MinimaList.push_back(locMin);
-    if (!leftBoundIsForward) E = E2;
-  }
-  return true;
-}
-//------------------------------------------------------------------------------
-
-bool ClipperBase::AddPaths(const Paths &amp;ppg, PolyType PolyTyp, bool Closed)
-{
-  bool result = false;
-  for (Paths::size_type i = 0; i &lt; ppg.size(); ++i)
-    if (AddPath(ppg[i], PolyTyp, Closed)) result = true;
-  return result;
-}
+    return result;
+  }
 //------------------------------------------------------------------------------
 
-void ClipperBase::Clear()
-{
-  DisposeLocalMinimaList();
-  for (EdgeList::size_type i = 0; i &lt; m_edges.size(); ++i)
+  void ClipperBase::InsertScanbeam(const cInt Y)
   {
-    TEdge* edges = m_edges[i];
-    delete [] edges;
+    m_Scanbeam.push(Y);
   }
-  m_edges.clear();
-  m_UseFullRange = false;
-  m_HasOpenPaths = false;
-}
 //------------------------------------------------------------------------------
 
-void ClipperBase::Reset()
-{
-  m_CurrentLM = m_MinimaList.begin();
-  if (m_CurrentLM == m_MinimaList.end()) return; //ie nothing to process
-  std::sort(m_MinimaList.begin(), m_MinimaList.end(), LocMinSorter());
-
-  m_Scanbeam = ScanbeamList(); //clears/resets priority_queue
-  //reset all edges ...
-  for (MinimaList::iterator lm = m_MinimaList.begin(); lm != m_MinimaList.end(); ++lm)
+  bool ClipperBase::PopScanbeam(cInt &amp;Y)
   {
-    InsertScanbeam(lm-&gt;Y);
-    TEdge* e = lm-&gt;LeftBound;
-    if (e)
-    {
-      e-&gt;Curr = e-&gt;Bot;
-      e-&gt;Side = esLeft;
-      e-&gt;OutIdx = Unassigned;
-    }
-
-    e = lm-&gt;RightBound;
-    if (e)
+    if (m_Scanbeam.empty())
+      return false;
+    Y = m_Scanbeam.top();
+    m_Scanbeam.pop();
+    while (!m_Scanbeam.empty() &amp;&amp; Y == m_Scanbeam.top())
     {
-      e-&gt;Curr = e-&gt;Bot;
-      e-&gt;Side = esRight;
-      e-&gt;OutIdx = Unassigned;
-    }
+      m_Scanbeam.pop();
+    } // Pop duplicates.
+    return true;
   }
-  m_ActiveEdges = 0;
-  m_CurrentLM = m_MinimaList.begin();
-}
-//------------------------------------------------------------------------------
-
-void ClipperBase::DisposeLocalMinimaList()
-{
-  m_MinimaList.clear();
-  m_CurrentLM = m_MinimaList.begin();
-}
-//------------------------------------------------------------------------------
-
-bool ClipperBase::PopLocalMinima(cInt Y, const LocalMinimum *&amp;locMin)
-{
-  if (m_CurrentLM == m_MinimaList.end() || (*m_CurrentLM).Y != Y) return false;
-  locMin = &amp;(*m_CurrentLM);
-  ++m_CurrentLM;
-  return true;
-}
 //------------------------------------------------------------------------------
 
-IntRect ClipperBase::GetBounds()
-{
-  IntRect result;
-  MinimaList::iterator lm = m_MinimaList.begin();
-  if (lm == m_MinimaList.end())
+  void ClipperBase::DisposeAllOutRecs()
   {
-    result.left = result.top = result.right = result.bottom = 0;
-    return result;
-  }
-  result.left = lm-&gt;LeftBound-&gt;Bot.X;
-  result.top = lm-&gt;LeftBound-&gt;Bot.Y;
-  result.right = lm-&gt;LeftBound-&gt;Bot.X;
-  result.bottom = lm-&gt;LeftBound-&gt;Bot.Y;
-  while (lm != m_MinimaList.end())
-  {
-    //todo - needs fixing for open paths
-    result.bottom = std::max(result.bottom, lm-&gt;LeftBound-&gt;Bot.Y);
-    TEdge* e = lm-&gt;LeftBound;
-    for (;;) {
-      TEdge* bottomE = e;
-      while (e-&gt;NextInLML)
-      {
-        if (e-&gt;Bot.X &lt; result.left) result.left = e-&gt;Bot.X;
-        if (e-&gt;Bot.X &gt; result.right) result.right = e-&gt;Bot.X;
-        e = e-&gt;NextInLML;
-      }
-      result.left = std::min(result.left, e-&gt;Bot.X);
-      result.right = std::max(result.right, e-&gt;Bot.X);
-      result.left = std::min(result.left, e-&gt;Top.X);
-      result.right = std::max(result.right, e-&gt;Top.X);
-      result.top = std::min(result.top, e-&gt;Top.Y);
-      if (bottomE == lm-&gt;LeftBound) e = lm-&gt;RightBound;
-      else break;
-    }
-    ++lm;
+    for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); ++i)
+      DisposeOutRec(i);
+    m_PolyOuts.clear();
   }
-  return result;
-}
 //------------------------------------------------------------------------------
 
-void ClipperBase::InsertScanbeam(const cInt Y)
-{
-  m_Scanbeam.push(Y);
-}
+  void ClipperBase::DisposeOutRec(PolyOutList::size_type index)
+  {
+    OutRec *outRec = m_PolyOuts[index];
+    if (outRec-&gt;Pts)
+      DisposeOutPts(outRec-&gt;Pts);
+    delete outRec;
+    m_PolyOuts[index] = 0;
+  }
 //------------------------------------------------------------------------------
 
-bool ClipperBase::PopScanbeam(cInt &amp;Y)
-{
-  if (m_Scanbeam.empty()) return false;
-  Y = m_Scanbeam.top();
-  m_Scanbeam.pop();
-  while (!m_Scanbeam.empty() &amp;&amp; Y == m_Scanbeam.top()) { m_Scanbeam.pop(); } // Pop duplicates.
-  return true;
-}
+  void ClipperBase::DeleteFromAEL(TEdge *e)
+  {
+    TEdge *AelPrev = e-&gt;PrevInAEL;
+    TEdge *AelNext = e-&gt;NextInAEL;
+    if (!AelPrev &amp;&amp; !AelNext &amp;&amp; (e != m_ActiveEdges))
+      return; //already deleted
+    if (AelPrev)
+      AelPrev-&gt;NextInAEL = AelNext;
+    else
+      m_ActiveEdges = AelNext;
+    if (AelNext)
+      AelNext-&gt;PrevInAEL = AelPrev;
+    e-&gt;NextInAEL = 0;
+    e-&gt;PrevInAEL = 0;
+  }
 //------------------------------------------------------------------------------
 
-void ClipperBase::DisposeAllOutRecs(){
-  for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); ++i)
-    DisposeOutRec(i);
-  m_PolyOuts.clear();
-}
+  OutRec *ClipperBase::CreateOutRec()
+  {
+    OutRec *result = new OutRec;
+    result-&gt;IsHole = false;
+    result-&gt;IsOpen = false;
+    result-&gt;FirstLeft = 0;
+    result-&gt;Pts = 0;
+    result-&gt;BottomPt = 0;
+    result-&gt;PolyNd = 0;
+    m_PolyOuts.push_back(result);
+    result-&gt;Idx = (int) m_PolyOuts.size() - 1;
+    return result;
+  }
 //------------------------------------------------------------------------------
 
-void ClipperBase::DisposeOutRec(PolyOutList::size_type index)
-{
-  OutRec *outRec = m_PolyOuts[index];
-  if (outRec-&gt;Pts) DisposeOutPts(outRec-&gt;Pts);
-  delete outRec;
-  m_PolyOuts[index] = 0;
-}
-//------------------------------------------------------------------------------
+  void ClipperBase::SwapPositionsInAEL(TEdge *Edge1, TEdge *Edge2)
+  {
+    //check that one or other edge hasn't already been removed from AEL ...
+    if (Edge1-&gt;NextInAEL == Edge1-&gt;PrevInAEL ||
+        Edge2-&gt;NextInAEL == Edge2-&gt;PrevInAEL)
+      return;
 
-void ClipperBase::DeleteFromAEL(TEdge *e)
-{
-  TEdge* AelPrev = e-&gt;PrevInAEL;
-  TEdge* AelNext = e-&gt;NextInAEL;
-  if (!AelPrev &amp;&amp;  !AelNext &amp;&amp; (e != m_ActiveEdges)) return; //already deleted
-  if (AelPrev) AelPrev-&gt;NextInAEL = AelNext;
-  else m_ActiveEdges = AelNext;
-  if (AelNext) AelNext-&gt;PrevInAEL = AelPrev;
-  e-&gt;NextInAEL = 0;
-  e-&gt;PrevInAEL = 0;
-}
-//------------------------------------------------------------------------------
+    if (Edge1-&gt;NextInAEL == Edge2)
+    {
+      TEdge *Next = Edge2-&gt;NextInAEL;
+      if (Next)
+        Next-&gt;PrevInAEL = Edge1;
+      TEdge *Prev = Edge1-&gt;PrevInAEL;
+      if (Prev)
+        Prev-&gt;NextInAEL = Edge2;
+      Edge2-&gt;PrevInAEL = Prev;
+      Edge2-&gt;NextInAEL = Edge1;
+      Edge1-&gt;PrevInAEL = Edge2;
+      Edge1-&gt;NextInAEL = Next;
+    } else if (Edge2-&gt;NextInAEL == Edge1)
+    {
+      TEdge *Next = Edge1-&gt;NextInAEL;
+      if (Next)
+        Next-&gt;PrevInAEL = Edge2;
+      TEdge *Prev = Edge2-&gt;PrevInAEL;
+      if (Prev)
+        Prev-&gt;NextInAEL = Edge1;
+      Edge1-&gt;PrevInAEL = Prev;
+      Edge1-&gt;NextInAEL = Edge2;
+      Edge2-&gt;PrevInAEL = Edge1;
+      Edge2-&gt;NextInAEL = Next;
+    } else
+    {
+      TEdge *Next = Edge1-&gt;NextInAEL;
+      TEdge *Prev = Edge1-&gt;PrevInAEL;
+      Edge1-&gt;NextInAEL = Edge2-&gt;NextInAEL;
+      if (Edge1-&gt;NextInAEL)
+        Edge1-&gt;NextInAEL-&gt;PrevInAEL = Edge1;
+      Edge1-&gt;PrevInAEL = Edge2-&gt;PrevInAEL;
+      if (Edge1-&gt;PrevInAEL)
+        Edge1-&gt;PrevInAEL-&gt;NextInAEL = Edge1;
+      Edge2-&gt;NextInAEL = Next;
+      if (Edge2-&gt;NextInAEL)
+        Edge2-&gt;NextInAEL-&gt;PrevInAEL = Edge2;
+      Edge2-&gt;PrevInAEL = Prev;
+      if (Edge2-&gt;PrevInAEL)
+        Edge2-&gt;PrevInAEL-&gt;NextInAEL = Edge2;
+    }
 
-OutRec* ClipperBase::CreateOutRec()
-{
-  OutRec* result = new OutRec;
-  result-&gt;IsHole = false;
-  result-&gt;IsOpen = false;
-  result-&gt;FirstLeft = 0;
-  result-&gt;Pts = 0;
-  result-&gt;BottomPt = 0;
-  result-&gt;PolyNd = 0;
-  m_PolyOuts.push_back(result);
-  result-&gt;Idx = (int)m_PolyOuts.size() - 1;
-  return result;
-}
+    if (!Edge1-&gt;PrevInAEL)
+      m_ActiveEdges = Edge1;
+    else if (!Edge2-&gt;PrevInAEL)
+      m_ActiveEdges = Edge2;
+  }
 //------------------------------------------------------------------------------
 
-void ClipperBase::SwapPositionsInAEL(TEdge *Edge1, TEdge *Edge2)
-{
-  //check that one or other edge hasn't already been removed from AEL ...
-  if (Edge1-&gt;NextInAEL == Edge1-&gt;PrevInAEL ||
-    Edge2-&gt;NextInAEL == Edge2-&gt;PrevInAEL) return;
-
-  if (Edge1-&gt;NextInAEL == Edge2)
-  {
-    TEdge* Next = Edge2-&gt;NextInAEL;
-    if (Next) Next-&gt;PrevInAEL = Edge1;
-    TEdge* Prev = Edge1-&gt;PrevInAEL;
-    if (Prev) Prev-&gt;NextInAEL = Edge2;
-    Edge2-&gt;PrevInAEL = Prev;
-    Edge2-&gt;NextInAEL = Edge1;
-    Edge1-&gt;PrevInAEL = Edge2;
-    Edge1-&gt;NextInAEL = Next;
-  }
-  else if (Edge2-&gt;NextInAEL == Edge1)
-  {
-    TEdge* Next = Edge1-&gt;NextInAEL;
-    if (Next) Next-&gt;PrevInAEL = Edge2;
-    TEdge* Prev = Edge2-&gt;PrevInAEL;
-    if (Prev) Prev-&gt;NextInAEL = Edge1;
-    Edge1-&gt;PrevInAEL = Prev;
-    Edge1-&gt;NextInAEL = Edge2;
-    Edge2-&gt;PrevInAEL = Edge1;
-    Edge2-&gt;NextInAEL = Next;
-  }
-  else
-  {
-    TEdge* Next = Edge1-&gt;NextInAEL;
-    TEdge* Prev = Edge1-&gt;PrevInAEL;
-    Edge1-&gt;NextInAEL = Edge2-&gt;NextInAEL;
-    if (Edge1-&gt;NextInAEL) Edge1-&gt;NextInAEL-&gt;PrevInAEL = Edge1;
-    Edge1-&gt;PrevInAEL = Edge2-&gt;PrevInAEL;
-    if (Edge1-&gt;PrevInAEL) Edge1-&gt;PrevInAEL-&gt;NextInAEL = Edge1;
-    Edge2-&gt;NextInAEL = Next;
-    if (Edge2-&gt;NextInAEL) Edge2-&gt;NextInAEL-&gt;PrevInAEL = Edge2;
-    Edge2-&gt;PrevInAEL = Prev;
-    if (Edge2-&gt;PrevInAEL) Edge2-&gt;PrevInAEL-&gt;NextInAEL = Edge2;
-  }
-
-  if (!Edge1-&gt;PrevInAEL) m_ActiveEdges = Edge1;
-  else if (!Edge2-&gt;PrevInAEL) m_ActiveEdges = Edge2;
-}
-//------------------------------------------------------------------------------
+  void ClipperBase::UpdateEdgeIntoAEL(TEdge *&amp;e)
+  {
+    if (!e-&gt;NextInLML)
+      throw clipperException("UpdateEdgeIntoAEL: invalid call");
 
-void ClipperBase::UpdateEdgeIntoAEL(TEdge *&amp;e)
-{
-  if (!e-&gt;NextInLML) 
-    throw clipperException("UpdateEdgeIntoAEL: invalid call");
-
-  e-&gt;NextInLML-&gt;OutIdx = e-&gt;OutIdx;
-  TEdge* AelPrev = e-&gt;PrevInAEL;
-  TEdge* AelNext = e-&gt;NextInAEL;
-  if (AelPrev) AelPrev-&gt;NextInAEL = e-&gt;NextInLML;
-  else m_ActiveEdges = e-&gt;NextInLML;
-  if (AelNext) AelNext-&gt;PrevInAEL = e-&gt;NextInLML;
-  e-&gt;NextInLML-&gt;Side = e-&gt;Side;
-  e-&gt;NextInLML-&gt;WindDelta = e-&gt;WindDelta;
-  e-&gt;NextInLML-&gt;WindCnt = e-&gt;WindCnt;
-  e-&gt;NextInLML-&gt;WindCnt2 = e-&gt;WindCnt2;
-  e = e-&gt;NextInLML;
-  e-&gt;Curr = e-&gt;Bot;
-  e-&gt;PrevInAEL = AelPrev;
-  e-&gt;NextInAEL = AelNext;
-  if (!IsHorizontal(*e)) InsertScanbeam(e-&gt;Top.Y);
-}
+    e-&gt;NextInLML-&gt;OutIdx = e-&gt;OutIdx;
+    TEdge *AelPrev = e-&gt;PrevInAEL;
+    TEdge *AelNext = e-&gt;NextInAEL;
+    if (AelPrev)
+      AelPrev-&gt;NextInAEL = e-&gt;NextInLML;
+    else
+      m_ActiveEdges = e-&gt;NextInLML;
+    if (AelNext)
+      AelNext-&gt;PrevInAEL = e-&gt;NextInLML;
+    e-&gt;NextInLML-&gt;Side = e-&gt;Side;
+    e-&gt;NextInLML-&gt;WindDelta = e-&gt;WindDelta;
+    e-&gt;NextInLML-&gt;WindCnt = e-&gt;WindCnt;
+    e-&gt;NextInLML-&gt;WindCnt2 = e-&gt;WindCnt2;
+    e = e-&gt;NextInLML;
+    e-&gt;Curr = e-&gt;Bot;
+    e-&gt;PrevInAEL = AelPrev;
+    e-&gt;NextInAEL = AelNext;
+    if (!IsHorizontal(*e))
+      InsertScanbeam(e-&gt;Top.Y);
+  }
 //------------------------------------------------------------------------------
 
-bool ClipperBase::LocalMinimaPending()
-{
-  return (m_CurrentLM != m_MinimaList.end());
-}
+  bool ClipperBase::LocalMinimaPending()
+  {
+    return (m_CurrentLM != m_MinimaList.end());
+  }
 
 //------------------------------------------------------------------------------
 // TClipper methods ...
 //------------------------------------------------------------------------------
 
-Clipper::Clipper(int initOptions) : ClipperBase() //constructor
-{
-  m_ExecuteLocked = false;
-  m_UseFullRange = false;
-  m_ReverseOutput = ((initOptions &amp; ioReverseSolution) != 0);
-  m_StrictSimple = ((initOptions &amp; ioStrictlySimple) != 0);
-  m_PreserveCollinear = ((initOptions &amp; ioPreserveCollinear) != 0);
-  m_HasOpenPaths = false;
-#ifdef use_xyz  
-  m_ZFill = 0;
+  Clipper::Clipper(int initOptions) : ClipperBase() //constructor
+  {
+    m_ExecuteLocked = false;
+    m_UseFullRange = false;
+    m_ReverseOutput = ((initOptions &amp; ioReverseSolution) != 0);
+    m_StrictSimple = ((initOptions &amp; ioStrictlySimple) != 0);
+    m_PreserveCollinear = ((initOptions &amp; ioPreserveCollinear) != 0);
+    m_HasOpenPaths = false;
+#ifdef use_xyz
+    m_ZFill = 0;
 #endif
-}
+  }
 //------------------------------------------------------------------------------
 
-#ifdef use_xyz  
-void Clipper::ZFillFunction(ZFillCallback zFillFunc)
-{  
+#ifdef use_xyz
+                                                                                                                          void Clipper::ZFillFunction(ZFillCallback zFillFunc)
+{
   m_ZFill = zFillFunc;
 }
 //------------------------------------------------------------------------------
 #endif
 
-bool Clipper::Execute(ClipType clipType, Paths &amp;solution, PolyFillType fillType)
-{
+  bool Clipper::Execute(ClipType clipType, Paths &amp;solution, PolyFillType fillType)
+  {
     return Execute(clipType, solution, fillType, fillType);
-}
+  }
 //------------------------------------------------------------------------------
 
-bool Clipper::Execute(ClipType clipType, PolyTree &amp;polytree, PolyFillType fillType)
-{
+  bool Clipper::Execute(ClipType clipType, PolyTree &amp;polytree, PolyFillType fillType)
+  {
     return Execute(clipType, polytree, fillType, fillType);
-}
+  }
 //------------------------------------------------------------------------------
 
-bool Clipper::Execute(ClipType clipType, Paths &amp;solution,
-    PolyFillType subjFillType, PolyFillType clipFillType)
-{
-  if( m_ExecuteLocked ) return false;
-  if (m_HasOpenPaths)
-    throw clipperException("Error: PolyTree struct is needed for open path clipping.");
-  m_ExecuteLocked = true;
-  solution.resize(0);
-  m_SubjFillType = subjFillType;
-  m_ClipFillType = clipFillType;
-  m_ClipType = clipType;
-  m_UsingPolyTree = false;
-  bool succeeded = ExecuteInternal();
-  if (succeeded) BuildResult(solution);
-  DisposeAllOutRecs();
-  m_ExecuteLocked = false;
-  return succeeded;
-}
+  bool Clipper::Execute(ClipType clipType, Paths &amp;solution,
+                        PolyFillType subjFillType, PolyFillType clipFillType)
+  {
+    if (m_ExecuteLocked)
+      return false;
+    if (m_HasOpenPaths)
+      throw clipperException("Error: PolyTree struct is needed for open path clipping.");
+    m_ExecuteLocked = true;
+    solution.resize(0);
+    m_SubjFillType = subjFillType;
+    m_ClipFillType = clipFillType;
+    m_ClipType = clipType;
+    m_UsingPolyTree = false;
+    bool succeeded = ExecuteInternal();
+    if (succeeded)
+      BuildResult(solution);
+    DisposeAllOutRecs();
+    m_ExecuteLocked = false;
+    return succeeded;
+  }
 //------------------------------------------------------------------------------
 
-bool Clipper::Execute(ClipType clipType, PolyTree&amp; polytree,
-    PolyFillType subjFillType, PolyFillType clipFillType)
-{
-  if( m_ExecuteLocked ) return false;
-  m_ExecuteLocked = true;
-  m_SubjFillType = subjFillType;
-  m_ClipFillType = clipFillType;
-  m_ClipType = clipType;
-  m_UsingPolyTree = true;
-  bool succeeded = ExecuteInternal();
-  if (succeeded) BuildResult2(polytree);
-  DisposeAllOutRecs();
-  m_ExecuteLocked = false;
-  return succeeded;
-}
+  bool Clipper::Execute(ClipType clipType, PolyTree &amp;polytree,
+                        PolyFillType subjFillType, PolyFillType clipFillType)
+  {
+    if (m_ExecuteLocked)
+      return false;
+    m_ExecuteLocked = true;
+    m_SubjFillType = subjFillType;
+    m_ClipFillType = clipFillType;
+    m_ClipType = clipType;
+    m_UsingPolyTree = true;
+    bool succeeded = ExecuteInternal();
+    if (succeeded)
+      BuildResult2(polytree);
+    DisposeAllOutRecs();
+    m_ExecuteLocked = false;
+    return succeeded;
+  }
 //------------------------------------------------------------------------------
 
-void Clipper::FixHoleLinkage(OutRec &amp;outrec)
-{
-  //skip OutRecs that (a) contain outermost polygons or
-  //(b) already have the correct owner/child linkage ...
-  if (!outrec.FirstLeft ||                
-      (outrec.IsHole != outrec.FirstLeft-&gt;IsHole &amp;&amp;
-      outrec.FirstLeft-&gt;Pts)) return;
-
-  OutRec* orfl = outrec.FirstLeft;
-  while (orfl &amp;&amp; ((orfl-&gt;IsHole == outrec.IsHole) || !orfl-&gt;Pts))
+  void Clipper::FixHoleLinkage(OutRec &amp;outrec)
+  {
+    //skip OutRecs that (a) contain outermost polygons or
+    //(b) already have the correct owner/child linkage ...
+    if (!outrec.FirstLeft ||
+        (outrec.IsHole != outrec.FirstLeft-&gt;IsHole &amp;&amp;
+         outrec.FirstLeft-&gt;Pts))
+      return;
+
+    OutRec *orfl = outrec.FirstLeft;
+    while (orfl &amp;&amp; ((orfl-&gt;IsHole == outrec.IsHole) || !orfl-&gt;Pts))
       orfl = orfl-&gt;FirstLeft;
-  outrec.FirstLeft = orfl;
-}
+    outrec.FirstLeft = orfl;
+  }
 //------------------------------------------------------------------------------
 
-bool Clipper::ExecuteInternal()
-{
-  bool succeeded = true;
-  try {
-    Reset();
-    m_Maxima = MaximaList();
-    m_SortedEdges = 0;
-
-    succeeded = true;
-    cInt botY, topY;
-    if (!PopScanbeam(botY)) return false;
-    InsertLocalMinimaIntoAEL(botY);
-    while (PopScanbeam(topY) || LocalMinimaPending())
+  bool Clipper::ExecuteInternal()
+  {
+    bool succeeded = true;
+    try
     {
-      ProcessHorizontals();
-	    ClearGhostJoins();
-      if (!ProcessIntersections(topY))
+      Reset();
+      m_Maxima = MaximaList();
+      m_SortedEdges = 0;
+
+      succeeded = true;
+      cInt botY, topY;
+      if (!PopScanbeam(botY))
+        return false;
+      InsertLocalMinimaIntoAEL(botY);
+      while (PopScanbeam(topY) || LocalMinimaPending())
       {
-        succeeded = false;
-        break;
+        ProcessHorizontals();
+        ClearGhostJoins();
+        if (!ProcessIntersections(topY))
+        {
+          succeeded = false;
+          break;
+        }
+        ProcessEdgesAtTopOfScanbeam(topY);
+        botY = topY;
+        InsertLocalMinimaIntoAEL(botY);
       }
-      ProcessEdgesAtTopOfScanbeam(topY);
-      botY = topY;
-      InsertLocalMinimaIntoAEL(botY);
     }
-  }
-  catch(...) 
-  {
-    succeeded = false;
-  }
-
-  if (succeeded)
-  {
-    //fix orientations ...
-    for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); ++i)
+    catch (...)
     {
-      OutRec *outRec = m_PolyOuts[i];
-      if (!outRec-&gt;Pts || outRec-&gt;IsOpen) continue;
-      if ((outRec-&gt;IsHole ^ m_ReverseOutput) == (Area(*outRec) &gt; 0))
-        ReversePolyPtLinks(outRec-&gt;Pts);
+      succeeded = false;
     }
 
-    if (!m_Joins.empty()) JoinCommonEdges();
-
-    //unfortunately FixupOutPolygon() must be done after JoinCommonEdges()
-    for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); ++i)
+    if (succeeded)
     {
-      OutRec *outRec = m_PolyOuts[i];
-      if (!outRec-&gt;Pts) continue;
-      if (outRec-&gt;IsOpen)
-        FixupOutPolyline(*outRec);
-      else
-        FixupOutPolygon(*outRec);
-    }
+      //fix orientations ...
+      for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); ++i)
+      {
+        OutRec *outRec = m_PolyOuts[i];
+        if (!outRec-&gt;Pts || outRec-&gt;IsOpen)
+          continue;
+        if ((outRec-&gt;IsHole ^ m_ReverseOutput) == (Area(*outRec) &gt; 0))
+          ReversePolyPtLinks(outRec-&gt;Pts);
+      }
 
-    if (m_StrictSimple) DoSimplePolygons();
-  }
+      if (!m_Joins.empty())
+        JoinCommonEdges();
 
-  ClearJoins();
-  ClearGhostJoins();
-  return succeeded;
-}
-//------------------------------------------------------------------------------
+      //unfortunately FixupOutPolygon() must be done after JoinCommonEdges()
+      for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); ++i)
+      {
+        OutRec *outRec = m_PolyOuts[i];
+        if (!outRec-&gt;Pts)
+          continue;
+        if (outRec-&gt;IsOpen)
+          FixupOutPolyline(*outRec);
+        else
+          FixupOutPolygon(*outRec);
+      }
 
-void Clipper::SetWindingCount(TEdge &amp;edge)
-{
-  TEdge *e = edge.PrevInAEL;
-  //find the edge of the same polytype that immediately preceeds 'edge' in AEL
-  while (e  &amp;&amp; ((e-&gt;PolyTyp != edge.PolyTyp) || (e-&gt;WindDelta == 0))) e = e-&gt;PrevInAEL;
-  if (!e)
-  {
-    if (edge.WindDelta == 0)
-    {
-      PolyFillType pft = (edge.PolyTyp == ptSubject ? m_SubjFillType : m_ClipFillType);
-      edge.WindCnt = (pft == pftNegative ? -1 : 1);
+      if (m_StrictSimple)
+        DoSimplePolygons();
     }
-    else
-      edge.WindCnt = edge.WindDelta;
-    edge.WindCnt2 = 0;
-    e = m_ActiveEdges; //ie get ready to calc WindCnt2
-  }   
-  else if (edge.WindDelta == 0 &amp;&amp; m_ClipType != ctUnion)
-  {
-    edge.WindCnt = 1;
-    edge.WindCnt2 = e-&gt;WindCnt2;
-    e = e-&gt;NextInAEL; //ie get ready to calc WindCnt2
+
+    ClearJoins();
+    ClearGhostJoins();
+    return succeeded;
   }
-  else if (IsEvenOddFillType(edge))
+//------------------------------------------------------------------------------
+
+  void Clipper::SetWindingCount(TEdge &amp;edge)
   {
-    //EvenOdd filling ...
-    if (edge.WindDelta == 0)
+    TEdge *e = edge.PrevInAEL;
+    //find the edge of the same polytype that immediately preceeds 'edge' in AEL
+    while (e &amp;&amp; ((e-&gt;PolyTyp != edge.PolyTyp) || (e-&gt;WindDelta == 0)))
+      e = e-&gt;PrevInAEL;
+    if (!e)
     {
-      //are we inside a subj polygon ...
-      bool Inside = true;
-      TEdge *e2 = e-&gt;PrevInAEL;
-      while (e2)
+      if (edge.WindDelta == 0)
       {
-        if (e2-&gt;PolyTyp == e-&gt;PolyTyp &amp;&amp; e2-&gt;WindDelta != 0) 
-          Inside = !Inside;
-        e2 = e2-&gt;PrevInAEL;
-      }
-      edge.WindCnt = (Inside ? 0 : 1);
-    }
-    else
+        PolyFillType pft = (edge.PolyTyp == ptSubject ? m_SubjFillType : m_ClipFillType);
+        edge.WindCnt = (pft == pftNegative ? -1 : 1);
+      } else
+        edge.WindCnt = edge.WindDelta;
+      edge.WindCnt2 = 0;
+      e = m_ActiveEdges; //ie get ready to calc WindCnt2
+    } else if (edge.WindDelta == 0 &amp;&amp; m_ClipType != ctUnion)
     {
-      edge.WindCnt = edge.WindDelta;
-    }
-    edge.WindCnt2 = e-&gt;WindCnt2;
-    e = e-&gt;NextInAEL; //ie get ready to calc WindCnt2
-  } 
-  else
-  {
-    //nonZero, Positive or Negative filling ...
-    if (e-&gt;WindCnt * e-&gt;WindDelta &lt; 0)
+      edge.WindCnt = 1;
+      edge.WindCnt2 = e-&gt;WindCnt2;
+      e = e-&gt;NextInAEL; //ie get ready to calc WindCnt2
+    } else if (IsEvenOddFillType(edge))
     {
-      //prev edge is 'decreasing' WindCount (WC) toward zero
-      //so we're outside the previous polygon ...
-      if (Abs(e-&gt;WindCnt) &gt; 1)
+      //EvenOdd filling ...
+      if (edge.WindDelta == 0)
       {
-        //outside prev poly but still inside another.
-        //when reversing direction of prev poly use the same WC 
-        if (e-&gt;WindDelta * edge.WindDelta &lt; 0) edge.WindCnt = e-&gt;WindCnt;
-        //otherwise continue to 'decrease' WC ...
-        else edge.WindCnt = e-&gt;WindCnt + edge.WindDelta;
-      } 
-      else
-        //now outside all polys of same polytype so set own WC ...
-        edge.WindCnt = (edge.WindDelta == 0 ? 1 : edge.WindDelta);
+        //are we inside a subj polygon ...
+        bool Inside = true;
+        TEdge *e2 = e-&gt;PrevInAEL;
+        while (e2)
+        {
+          if (e2-&gt;PolyTyp == e-&gt;PolyTyp &amp;&amp; e2-&gt;WindDelta != 0)
+            Inside = !Inside;
+          e2 = e2-&gt;PrevInAEL;
+        }
+        edge.WindCnt = (Inside ? 0 : 1);
+      } else
+      {
+        edge.WindCnt = edge.WindDelta;
+      }
+      edge.WindCnt2 = e-&gt;WindCnt2;
+      e = e-&gt;NextInAEL; //ie get ready to calc WindCnt2
     } else
     {
-      //prev edge is 'increasing' WindCount (WC) away from zero
-      //so we're inside the previous polygon ...
-      if (edge.WindDelta == 0) 
-        edge.WindCnt = (e-&gt;WindCnt &lt; 0 ? e-&gt;WindCnt - 1 : e-&gt;WindCnt + 1);
-      //if wind direction is reversing prev then use same WC
-      else if (e-&gt;WindDelta * edge.WindDelta &lt; 0) edge.WindCnt = e-&gt;WindCnt;
-      //otherwise add to WC ...
-      else edge.WindCnt = e-&gt;WindCnt + edge.WindDelta;
+      //nonZero, Positive or Negative filling ...
+      if (e-&gt;WindCnt * e-&gt;WindDelta &lt; 0)
+      {
+        //prev edge is 'decreasing' WindCount (WC) toward zero
+        //so we're outside the previous polygon ...
+        if (Abs(e-&gt;WindCnt) &gt; 1)
+        {
+          //outside prev poly but still inside another.
+          //when reversing direction of prev poly use the same WC
+          if (e-&gt;WindDelta * edge.WindDelta &lt; 0)
+            edge.WindCnt = e-&gt;WindCnt;
+            //otherwise continue to 'decrease' WC ...
+          else
+            edge.WindCnt = e-&gt;WindCnt + edge.WindDelta;
+        } else
+          //now outside all polys of same polytype so set own WC ...
+          edge.WindCnt = (edge.WindDelta == 0 ? 1 : edge.WindDelta);
+      } else
+      {
+        //prev edge is 'increasing' WindCount (WC) away from zero
+        //so we're inside the previous polygon ...
+        if (edge.WindDelta == 0)
+          edge.WindCnt = (e-&gt;WindCnt &lt; 0 ? e-&gt;WindCnt - 1 : e-&gt;WindCnt + 1);
+          //if wind direction is reversing prev then use same WC
+        else if (e-&gt;WindDelta * edge.WindDelta &lt; 0)
+          edge.WindCnt = e-&gt;WindCnt;
+          //otherwise add to WC ...
+        else
+          edge.WindCnt = e-&gt;WindCnt + edge.WindDelta;
+      }
+      edge.WindCnt2 = e-&gt;WindCnt2;
+      e = e-&gt;NextInAEL; //ie get ready to calc WindCnt2
     }
-    edge.WindCnt2 = e-&gt;WindCnt2;
-    e = e-&gt;NextInAEL; //ie get ready to calc WindCnt2
-  }
 
-  //update WindCnt2 ...
-  if (IsEvenOddAltFillType(edge))
-  {
-    //EvenOdd filling ...
-    while (e != &amp;edge)
+    //update WindCnt2 ...
+    if (IsEvenOddAltFillType(edge))
     {
-      if (e-&gt;WindDelta != 0)
-        edge.WindCnt2 = (edge.WindCnt2 == 0 ? 1 : 0);
-      e = e-&gt;NextInAEL;
-    }
-  } else
-  {
-    //nonZero, Positive or Negative filling ...
-    while ( e != &amp;edge )
+      //EvenOdd filling ...
+      while (e != &amp;edge)
+      {
+        if (e-&gt;WindDelta != 0)
+          edge.WindCnt2 = (edge.WindCnt2 == 0 ? 1 : 0);
+        e = e-&gt;NextInAEL;
+      }
+    } else
     {
-      edge.WindCnt2 += e-&gt;WindDelta;
-      e = e-&gt;NextInAEL;
+      //nonZero, Positive or Negative filling ...
+      while (e != &amp;edge)
+      {
+        edge.WindCnt2 += e-&gt;WindDelta;
+        e = e-&gt;NextInAEL;
+      }
     }
   }
-}
-//------------------------------------------------------------------------------
-
-bool Clipper::IsEvenOddFillType(const TEdge&amp; edge) const
-{
-  if (edge.PolyTyp == ptSubject)
-    return m_SubjFillType == pftEvenOdd; else
-    return m_ClipFillType == pftEvenOdd;
-}
-//------------------------------------------------------------------------------
-
-bool Clipper::IsEvenOddAltFillType(const TEdge&amp; edge) const
-{
-  if (edge.PolyTyp == ptSubject)
-    return m_ClipFillType == pftEvenOdd; else
-    return m_SubjFillType == pftEvenOdd;
-}
 //------------------------------------------------------------------------------
 
-bool Clipper::IsContributing(const TEdge&amp; edge) const
-{
-  PolyFillType pft, pft2;
-  if (edge.PolyTyp == ptSubject)
-  {
-    pft = m_SubjFillType;
-    pft2 = m_ClipFillType;
-  } else
+  bool Clipper::IsEvenOddFillType(const TEdge &amp;edge) const
   {
-    pft = m_ClipFillType;
-    pft2 = m_SubjFillType;
+    if (edge.PolyTyp == ptSubject)
+      return m_SubjFillType == pftEvenOdd;
+    else
+      return m_ClipFillType == pftEvenOdd;
   }
+//------------------------------------------------------------------------------
 
-  switch(pft)
+  bool Clipper::IsEvenOddAltFillType(const TEdge &amp;edge) const
   {
-    case pftEvenOdd: 
-      //return false if a subj line has been flagged as inside a subj polygon
-      if (edge.WindDelta == 0 &amp;&amp; edge.WindCnt != 1) return false;
-      break;
-    case pftNonZero:
-      if (Abs(edge.WindCnt) != 1) return false;
-      break;
-    case pftPositive: 
-      if (edge.WindCnt != 1) return false;
-      break;
-    default: //pftNegative
-      if (edge.WindCnt != -1) return false;
+    if (edge.PolyTyp == ptSubject)
+      return m_ClipFillType == pftEvenOdd;
+    else
+      return m_SubjFillType == pftEvenOdd;
   }
+//------------------------------------------------------------------------------
 
-  switch(m_ClipType)
+  bool Clipper::IsContributing(const TEdge &amp;edge) const
   {
-    case ctIntersection:
-      switch(pft2)
-      {
-        case pftEvenOdd: 
-        case pftNonZero: 
-          return (edge.WindCnt2 != 0);
-        case pftPositive: 
-          return (edge.WindCnt2 &gt; 0);
-        default: 
-          return (edge.WindCnt2 &lt; 0);
-      }
-      break;
-    case ctUnion:
-      switch(pft2)
-      {
-        case pftEvenOdd: 
-        case pftNonZero: 
-          return (edge.WindCnt2 == 0);
-        case pftPositive: 
-          return (edge.WindCnt2 &lt;= 0);
-        default: 
-          return (edge.WindCnt2 &gt;= 0);
-      }
-      break;
-    case ctDifference:
-      if (edge.PolyTyp == ptSubject)
-        switch(pft2)
-        {
-          case pftEvenOdd: 
-          case pftNonZero: 
-            return (edge.WindCnt2 == 0);
-          case pftPositive: 
-            return (edge.WindCnt2 &lt;= 0);
-          default: 
-            return (edge.WindCnt2 &gt;= 0);
-        }
-      else
-        switch(pft2)
+    PolyFillType pft, pft2;
+    if (edge.PolyTyp == ptSubject)
+    {
+      pft = m_SubjFillType;
+      pft2 = m_ClipFillType;
+    } else
+    {
+      pft = m_ClipFillType;
+      pft2 = m_SubjFillType;
+    }
+
+    switch (pft)
+    {
+      case pftEvenOdd:
+        //return false if a subj line has been flagged as inside a subj polygon
+        if (edge.WindDelta == 0 &amp;&amp; edge.WindCnt != 1)
+          return false;
+        break;
+      case pftNonZero:
+        if (Abs(edge.WindCnt) != 1)
+          return false;
+        break;
+      case pftPositive:
+        if (edge.WindCnt != 1)
+          return false;
+        break;
+      default: //pftNegative
+        if (edge.WindCnt != -1)
+          return false;
+    }
+
+    switch (m_ClipType)
+    {
+      case ctIntersection:
+        switch (pft2)
         {
-          case pftEvenOdd: 
-          case pftNonZero: 
+          case pftEvenOdd:
+          case pftNonZero:
             return (edge.WindCnt2 != 0);
-          case pftPositive: 
+          case pftPositive:
             return (edge.WindCnt2 &gt; 0);
-          default: 
+          default:
             return (edge.WindCnt2 &lt; 0);
         }
-      break;
-    case ctXor:
-      if (edge.WindDelta == 0) //XOr always contributing unless open
-        switch(pft2)
+        break;
+      case ctUnion:
+        switch (pft2)
         {
-          case pftEvenOdd: 
-          case pftNonZero: 
+          case pftEvenOdd:
+          case pftNonZero:
             return (edge.WindCnt2 == 0);
-          case pftPositive: 
+          case pftPositive:
             return (edge.WindCnt2 &lt;= 0);
-          default: 
+          default:
             return (edge.WindCnt2 &gt;= 0);
         }
-      else 
+        break;
+      case ctDifference:
+        if (edge.PolyTyp == ptSubject)
+          switch (pft2)
+          {
+            case pftEvenOdd:
+            case pftNonZero:
+              return (edge.WindCnt2 == 0);
+            case pftPositive:
+              return (edge.WindCnt2 &lt;= 0);
+            default:
+              return (edge.WindCnt2 &gt;= 0);
+          }
+        else
+          switch (pft2)
+          {
+            case pftEvenOdd:
+            case pftNonZero:
+              return (edge.WindCnt2 != 0);
+            case pftPositive:
+              return (edge.WindCnt2 &gt; 0);
+            default:
+              return (edge.WindCnt2 &lt; 0);
+          }
+        break;
+      case ctXor:
+        if (edge.WindDelta == 0) //XOr always contributing unless open
+          switch (pft2)
+          {
+            case pftEvenOdd:
+            case pftNonZero:
+              return (edge.WindCnt2 == 0);
+            case pftPositive:
+              return (edge.WindCnt2 &lt;= 0);
+            default:
+              return (edge.WindCnt2 &gt;= 0);
+          }
+        else
+          return true;
+        break;
+      default:
         return true;
-      break;
-    default:
-      return true;
+    }
   }
-}
 //------------------------------------------------------------------------------
 
-OutPt* Clipper::AddLocalMinPoly(TEdge *e1, TEdge *e2, const IntPoint &amp;Pt)
-{
-  OutPt* result;
-  TEdge *e, *prevE;
-  if (IsHorizontal(*e2) || ( e1-&gt;Dx &gt; e2-&gt;Dx ))
-  {
-    result = AddOutPt(e1, Pt);
-    e2-&gt;OutIdx = e1-&gt;OutIdx;
-    e1-&gt;Side = esLeft;
-    e2-&gt;Side = esRight;
-    e = e1;
-    if (e-&gt;PrevInAEL == e2)
-      prevE = e2-&gt;PrevInAEL; 
-    else
-      prevE = e-&gt;PrevInAEL;
-  } else
-  {
-    result = AddOutPt(e2, Pt);
-    e1-&gt;OutIdx = e2-&gt;OutIdx;
-    e1-&gt;Side = esRight;
-    e2-&gt;Side = esLeft;
-    e = e2;
-    if (e-&gt;PrevInAEL == e1)
+  OutPt *Clipper::AddLocalMinPoly(TEdge *e1, TEdge *e2, const IntPoint &amp;Pt)
+  {
+    OutPt *result;
+    TEdge *e, *prevE;
+    if (IsHorizontal(*e2) || (e1-&gt;Dx &gt; e2-&gt;Dx))
+    {
+      result = AddOutPt(e1, Pt);
+      e2-&gt;OutIdx = e1-&gt;OutIdx;
+      e1-&gt;Side = esLeft;
+      e2-&gt;Side = esRight;
+      e = e1;
+      if (e-&gt;PrevInAEL == e2)
+        prevE = e2-&gt;PrevInAEL;
+      else
+        prevE = e-&gt;PrevInAEL;
+    } else
+    {
+      result = AddOutPt(e2, Pt);
+      e1-&gt;OutIdx = e2-&gt;OutIdx;
+      e1-&gt;Side = esRight;
+      e2-&gt;Side = esLeft;
+      e = e2;
+      if (e-&gt;PrevInAEL == e1)
         prevE = e1-&gt;PrevInAEL;
-    else
+      else
         prevE = e-&gt;PrevInAEL;
-  }
+    }
 
-  if (prevE &amp;&amp; prevE-&gt;OutIdx &gt;= 0 &amp;&amp; prevE-&gt;Top.Y &lt; Pt.Y &amp;&amp; e-&gt;Top.Y &lt; Pt.Y) 
-  {
-    cInt xPrev = TopX(*prevE, Pt.Y);
-    cInt xE = TopX(*e, Pt.Y);
-    if (xPrev == xE &amp;&amp; (e-&gt;WindDelta != 0) &amp;&amp; (prevE-&gt;WindDelta != 0) &amp;&amp;
-      SlopesEqual(IntPoint(xPrev, Pt.Y), prevE-&gt;Top, IntPoint(xE, Pt.Y), e-&gt;Top, m_UseFullRange))
+    if (prevE &amp;&amp; prevE-&gt;OutIdx &gt;= 0 &amp;&amp; prevE-&gt;Top.Y &lt; Pt.Y &amp;&amp; e-&gt;Top.Y &lt; Pt.Y)
     {
-      OutPt* outPt = AddOutPt(prevE, Pt);
-      AddJoin(result, outPt, e-&gt;Top);
+      cInt xPrev = TopX(*prevE, Pt.Y);
+      cInt xE = TopX(*e, Pt.Y);
+      if (xPrev == xE &amp;&amp; (e-&gt;WindDelta != 0) &amp;&amp; (prevE-&gt;WindDelta != 0) &amp;&amp;
+          SlopesEqual(IntPoint(xPrev, Pt.Y), prevE-&gt;Top, IntPoint(xE, Pt.Y), e-&gt;Top, m_UseFullRange))
+      {
+        OutPt *outPt = AddOutPt(prevE, Pt);
+        AddJoin(result, outPt, e-&gt;Top);
+      }
     }
+    return result;
   }
-  return result;
-}
 //------------------------------------------------------------------------------
 
-void Clipper::AddLocalMaxPoly(TEdge *e1, TEdge *e2, const IntPoint &amp;Pt)
-{
-  AddOutPt( e1, Pt );
-  if (e2-&gt;WindDelta == 0) AddOutPt(e2, Pt);
-  if( e1-&gt;OutIdx == e2-&gt;OutIdx )
+  void Clipper::AddLocalMaxPoly(TEdge *e1, TEdge *e2, const IntPoint &amp;Pt)
   {
-    e1-&gt;OutIdx = Unassigned;
-    e2-&gt;OutIdx = Unassigned;
+    AddOutPt(e1, Pt);
+    if (e2-&gt;WindDelta == 0)
+      AddOutPt(e2, Pt);
+    if (e1-&gt;OutIdx == e2-&gt;OutIdx)
+    {
+      e1-&gt;OutIdx = Unassigned;
+      e2-&gt;OutIdx = Unassigned;
+    } else if (e1-&gt;OutIdx &lt; e2-&gt;OutIdx)
+      AppendPolygon(e1, e2);
+    else
+      AppendPolygon(e2, e1);
   }
-  else if (e1-&gt;OutIdx &lt; e2-&gt;OutIdx) 
-    AppendPolygon(e1, e2); 
-  else 
-    AppendPolygon(e2, e1);
-}
 //------------------------------------------------------------------------------
 
-void Clipper::AddEdgeToSEL(TEdge *edge)
-{
-  //SEL pointers in PEdge are reused to build a list of horizontal edges.
-  //However, we don't need to worry about order with horizontal edge processing.
-  if( !m_SortedEdges )
-  {
-    m_SortedEdges = edge;
-    edge-&gt;PrevInSEL = 0;
-    edge-&gt;NextInSEL = 0;
-  }
-  else
+  void Clipper::AddEdgeToSEL(TEdge *edge)
   {
-    edge-&gt;NextInSEL = m_SortedEdges;
-    edge-&gt;PrevInSEL = 0;
-    m_SortedEdges-&gt;PrevInSEL = edge;
-    m_SortedEdges = edge;
+    //SEL pointers in PEdge are reused to build a list of horizontal edges.
+    //However, we don't need to worry about order with horizontal edge processing.
+    if (!m_SortedEdges)
+    {
+      m_SortedEdges = edge;
+      edge-&gt;PrevInSEL = 0;
+      edge-&gt;NextInSEL = 0;
+    } else
+    {
+      edge-&gt;NextInSEL = m_SortedEdges;
+      edge-&gt;PrevInSEL = 0;
+      m_SortedEdges-&gt;PrevInSEL = edge;
+      m_SortedEdges = edge;
+    }
   }
-}
 //------------------------------------------------------------------------------
 
-bool Clipper::PopEdgeFromSEL(TEdge *&amp;edge)
-{
-  if (!m_SortedEdges) return false;
-  edge = m_SortedEdges;
-  DeleteFromSEL(m_SortedEdges);
-  return true;
-}
+  bool Clipper::PopEdgeFromSEL(TEdge *&amp;edge)
+  {
+    if (!m_SortedEdges)
+      return false;
+    edge = m_SortedEdges;
+    DeleteFromSEL(m_SortedEdges);
+    return true;
+  }
 //------------------------------------------------------------------------------
 
-void Clipper::CopyAELToSEL()
-{
-  TEdge* e = m_ActiveEdges;
-  m_SortedEdges = e;
-  while ( e )
+  void Clipper::CopyAELToSEL()
   {
-    e-&gt;PrevInSEL = e-&gt;PrevInAEL;
-    e-&gt;NextInSEL = e-&gt;NextInAEL;
-    e = e-&gt;NextInAEL;
+    TEdge *e = m_ActiveEdges;
+    m_SortedEdges = e;
+    while (e)
+    {
+      e-&gt;PrevInSEL = e-&gt;PrevInAEL;
+      e-&gt;NextInSEL = e-&gt;NextInAEL;
+      e = e-&gt;NextInAEL;
+    }
   }
-}
 //------------------------------------------------------------------------------
 
-void Clipper::AddJoin(OutPt *op1, OutPt *op2, const IntPoint OffPt)
-{
-  Join* j = new Join;
-  j-&gt;OutPt1 = op1;
-  j-&gt;OutPt2 = op2;
-  j-&gt;OffPt = OffPt;
-  m_Joins.push_back(j);
-}
+  void Clipper::AddJoin(OutPt *op1, OutPt *op2, const IntPoint OffPt)
+  {
+    Join *j = new Join;
+    j-&gt;OutPt1 = op1;
+    j-&gt;OutPt2 = op2;
+    j-&gt;OffPt = OffPt;
+    m_Joins.push_back(j);
+  }
 //------------------------------------------------------------------------------
 
-void Clipper::ClearJoins()
-{
-  for (JoinList::size_type i = 0; i &lt; m_Joins.size(); i++)
-    delete m_Joins[i];
-  m_Joins.resize(0);
-}
+  void Clipper::ClearJoins()
+  {
+    for (JoinList::size_type i = 0; i &lt; m_Joins.size(); i++)
+      delete m_Joins[i];
+    m_Joins.resize(0);
+  }
 //------------------------------------------------------------------------------
 
-void Clipper::ClearGhostJoins()
-{
-  for (JoinList::size_type i = 0; i &lt; m_GhostJoins.size(); i++)
-    delete m_GhostJoins[i];
-  m_GhostJoins.resize(0);
-}
+  void Clipper::ClearGhostJoins()
+  {
+    for (JoinList::size_type i = 0; i &lt; m_GhostJoins.size(); i++)
+      delete m_GhostJoins[i];
+    m_GhostJoins.resize(0);
+  }
 //------------------------------------------------------------------------------
 
-void Clipper::AddGhostJoin(OutPt *op, const IntPoint OffPt)
-{
-  Join* j = new Join;
-  j-&gt;OutPt1 = op;
-  j-&gt;OutPt2 = 0;
-  j-&gt;OffPt = OffPt;
-  m_GhostJoins.push_back(j);
-}
+  void Clipper::AddGhostJoin(OutPt *op, const IntPoint OffPt)
+  {
+    Join *j = new Join;
+    j-&gt;OutPt1 = op;
+    j-&gt;OutPt2 = 0;
+    j-&gt;OffPt = OffPt;
+    m_GhostJoins.push_back(j);
+  }
 //------------------------------------------------------------------------------
 
-void Clipper::InsertLocalMinimaIntoAEL(const cInt botY)
-{
-  const LocalMinimum *lm;
-  while (PopLocalMinima(botY, lm))
-  {
-    TEdge* lb = lm-&gt;LeftBound;
-    TEdge* rb = lm-&gt;RightBound;
-    
-    OutPt *Op1 = 0;
-    if (!lb)
-    {
-      //nb: don't insert LB into either AEL or SEL
-      InsertEdgeIntoAEL(rb, 0);
-      SetWindingCount(*rb);
-      if (IsContributing(*rb))
-        Op1 = AddOutPt(rb, rb-&gt;Bot); 
-    } 
-    else if (!rb)
-    {
-      InsertEdgeIntoAEL(lb, 0);
-      SetWindingCount(*lb);
-      if (IsContributing(*lb))
-        Op1 = AddOutPt(lb, lb-&gt;Bot);
-      InsertScanbeam(lb-&gt;Top.Y);
-    }
-    else
+  void Clipper::InsertLocalMinimaIntoAEL(const cInt botY)
+  {
+    const LocalMinimum *lm;
+    while (PopLocalMinima(botY, lm))
     {
-      InsertEdgeIntoAEL(lb, 0);
-      InsertEdgeIntoAEL(rb, lb);
-      SetWindingCount( *lb );
-      rb-&gt;WindCnt = lb-&gt;WindCnt;
-      rb-&gt;WindCnt2 = lb-&gt;WindCnt2;
-      if (IsContributing(*lb))
-        Op1 = AddLocalMinPoly(lb, rb, lb-&gt;Bot);      
-      InsertScanbeam(lb-&gt;Top.Y);
-    }
+      TEdge *lb = lm-&gt;LeftBound;
+      TEdge *rb = lm-&gt;RightBound;
 
-     if (rb)
-     {
-		 if (IsHorizontal(*rb))
-		 {
-			 AddEdgeToSEL(rb);
-			 if (rb-&gt;NextInLML) 
-				 InsertScanbeam(rb-&gt;NextInLML-&gt;Top.Y);
-		 }
-		 else InsertScanbeam( rb-&gt;Top.Y );
-     }
+      OutPt *Op1 = 0;
+      if (!lb)
+      {
+        //nb: don't insert LB into either AEL or SEL
+        InsertEdgeIntoAEL(rb, 0);
+        SetWindingCount(*rb);
+        if (IsContributing(*rb))
+          Op1 = AddOutPt(rb, rb-&gt;Bot);
+      } else if (!rb)
+      {
+        InsertEdgeIntoAEL(lb, 0);
+        SetWindingCount(*lb);
+        if (IsContributing(*lb))
+          Op1 = AddOutPt(lb, lb-&gt;Bot);
+        InsertScanbeam(lb-&gt;Top.Y);
+      } else
+      {
+        InsertEdgeIntoAEL(lb, 0);
+        InsertEdgeIntoAEL(rb, lb);
+        SetWindingCount(*lb);
+        rb-&gt;WindCnt = lb-&gt;WindCnt;
+        rb-&gt;WindCnt2 = lb-&gt;WindCnt2;
+        if (IsContributing(*lb))
+          Op1 = AddLocalMinPoly(lb, rb, lb-&gt;Bot);
+        InsertScanbeam(lb-&gt;Top.Y);
+      }
+
+      if (rb)
+      {
+        if (IsHorizontal(*rb))
+        {
+          AddEdgeToSEL(rb);
+          if (rb-&gt;NextInLML)
+            InsertScanbeam(rb-&gt;NextInLML-&gt;Top.Y);
+        } else
+          InsertScanbeam(rb-&gt;Top.Y);
+      }
 
-    if (!lb || !rb) continue;
+      if (!lb || !rb)
+        continue;
 
-    //if any output polygons share an edge, they'll need joining later ...
-    if (Op1 &amp;&amp; IsHorizontal(*rb) &amp;&amp; 
-      m_GhostJoins.size() &gt; 0 &amp;&amp; (rb-&gt;WindDelta != 0))
-    {
-      for (JoinList::size_type i = 0; i &lt; m_GhostJoins.size(); ++i)
+      //if any output polygons share an edge, they'll need joining later ...
+      if (Op1 &amp;&amp; IsHorizontal(*rb) &amp;&amp;
+          m_GhostJoins.size() &gt; 0 &amp;&amp; (rb-&gt;WindDelta != 0))
       {
-        Join* jr = m_GhostJoins[i];
-        //if the horizontal Rb and a 'ghost' horizontal overlap, then convert
-        //the 'ghost' join to a real join ready for later ...
-        if (HorzSegmentsOverlap(jr-&gt;OutPt1-&gt;Pt.X, jr-&gt;OffPt.X, rb-&gt;Bot.X, rb-&gt;Top.X))
-          AddJoin(jr-&gt;OutPt1, Op1, jr-&gt;OffPt);
+        for (JoinList::size_type i = 0; i &lt; m_GhostJoins.size(); ++i)
+        {
+          Join *jr = m_GhostJoins[i];
+          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert
+          //the 'ghost' join to a real join ready for later ...
+          if (HorzSegmentsOverlap(jr-&gt;OutPt1-&gt;Pt.X, jr-&gt;OffPt.X, rb-&gt;Bot.X, rb-&gt;Top.X))
+            AddJoin(jr-&gt;OutPt1, Op1, jr-&gt;OffPt);
+        }
       }
-    }
 
-    if (lb-&gt;OutIdx &gt;= 0 &amp;&amp; lb-&gt;PrevInAEL &amp;&amp; 
-      lb-&gt;PrevInAEL-&gt;Curr.X == lb-&gt;Bot.X &amp;&amp;
-      lb-&gt;PrevInAEL-&gt;OutIdx &gt;= 0 &amp;&amp;
-      SlopesEqual(lb-&gt;PrevInAEL-&gt;Bot, lb-&gt;PrevInAEL-&gt;Top, lb-&gt;Curr, lb-&gt;Top, m_UseFullRange) &amp;&amp;
-      (lb-&gt;WindDelta != 0) &amp;&amp; (lb-&gt;PrevInAEL-&gt;WindDelta != 0))
-    {
+      if (lb-&gt;OutIdx &gt;= 0 &amp;&amp; lb-&gt;PrevInAEL &amp;&amp;
+          lb-&gt;PrevInAEL-&gt;Curr.X == lb-&gt;Bot.X &amp;&amp;
+          lb-&gt;PrevInAEL-&gt;OutIdx &gt;= 0 &amp;&amp;
+          SlopesEqual(lb-&gt;PrevInAEL-&gt;Bot, lb-&gt;PrevInAEL-&gt;Top, lb-&gt;Curr, lb-&gt;Top, m_UseFullRange) &amp;&amp;
+          (lb-&gt;WindDelta != 0) &amp;&amp; (lb-&gt;PrevInAEL-&gt;WindDelta != 0))
+      {
         OutPt *Op2 = AddOutPt(lb-&gt;PrevInAEL, lb-&gt;Bot);
         AddJoin(Op1, Op2, lb-&gt;Top);
-    }
-
-    if(lb-&gt;NextInAEL != rb)
-    {
+      }
 
-      if (rb-&gt;OutIdx &gt;= 0 &amp;&amp; rb-&gt;PrevInAEL-&gt;OutIdx &gt;= 0 &amp;&amp;
-        SlopesEqual(rb-&gt;PrevInAEL-&gt;Curr, rb-&gt;PrevInAEL-&gt;Top, rb-&gt;Curr, rb-&gt;Top, m_UseFullRange) &amp;&amp;
-        (rb-&gt;WindDelta != 0) &amp;&amp; (rb-&gt;PrevInAEL-&gt;WindDelta != 0))
+      if (lb-&gt;NextInAEL != rb)
       {
+
+        if (rb-&gt;OutIdx &gt;= 0 &amp;&amp; rb-&gt;PrevInAEL-&gt;OutIdx &gt;= 0 &amp;&amp;
+            SlopesEqual(rb-&gt;PrevInAEL-&gt;Curr, rb-&gt;PrevInAEL-&gt;Top, rb-&gt;Curr, rb-&gt;Top, m_UseFullRange) &amp;&amp;
+            (rb-&gt;WindDelta != 0) &amp;&amp; (rb-&gt;PrevInAEL-&gt;WindDelta != 0))
+        {
           OutPt *Op2 = AddOutPt(rb-&gt;PrevInAEL, rb-&gt;Bot);
           AddJoin(Op1, Op2, rb-&gt;Top);
-      }
+        }
 
-      TEdge* e = lb-&gt;NextInAEL;
-      if (e)
-      {
-        while( e != rb )
+        TEdge *e = lb-&gt;NextInAEL;
+        if (e)
         {
-          //nb: For calculating winding counts etc, IntersectEdges() assumes
-          //that param1 will be to the Right of param2 ABOVE the intersection ...
-          IntersectEdges(rb , e , lb-&gt;Curr); //order important here
-          e = e-&gt;NextInAEL;
+          while (e != rb)
+          {
+            //nb: For calculating winding counts etc, IntersectEdges() assumes
+            //that param1 will be to the Right of param2 ABOVE the intersection ...
+            IntersectEdges(rb, e, lb-&gt;Curr); //order important here
+            e = e-&gt;NextInAEL;
+          }
         }
       }
+
     }
-    
   }
-}
 //------------------------------------------------------------------------------
 
-void Clipper::DeleteFromSEL(TEdge *e)
-{
-  TEdge* SelPrev = e-&gt;PrevInSEL;
-  TEdge* SelNext = e-&gt;NextInSEL;
-  if( !SelPrev &amp;&amp;  !SelNext &amp;&amp; (e != m_SortedEdges) ) return; //already deleted
-  if( SelPrev ) SelPrev-&gt;NextInSEL = SelNext;
-  else m_SortedEdges = SelNext;
-  if( SelNext ) SelNext-&gt;PrevInSEL = SelPrev;
-  e-&gt;NextInSEL = 0;
-  e-&gt;PrevInSEL = 0;
-}
+  void Clipper::DeleteFromSEL(TEdge *e)
+  {
+    TEdge *SelPrev = e-&gt;PrevInSEL;
+    TEdge *SelNext = e-&gt;NextInSEL;
+    if (!SelPrev &amp;&amp; !SelNext &amp;&amp; (e != m_SortedEdges))
+      return; //already deleted
+    if (SelPrev)
+      SelPrev-&gt;NextInSEL = SelNext;
+    else
+      m_SortedEdges = SelNext;
+    if (SelNext)
+      SelNext-&gt;PrevInSEL = SelPrev;
+    e-&gt;NextInSEL = 0;
+    e-&gt;PrevInSEL = 0;
+  }
 //------------------------------------------------------------------------------
 
 #ifdef use_xyz
-void Clipper::SetZ(IntPoint&amp; pt, TEdge&amp; e1, TEdge&amp; e2)
+                                                                                                                          void Clipper::SetZ(IntPoint&amp; pt, TEdge&amp; e1, TEdge&amp; e2)
 {
   if (pt.Z != 0 || !m_ZFill) return;
   else if (pt == e1.Bot) pt.Z = e1.Bot.Z;
   else if (pt == e1.Top) pt.Z = e1.Top.Z;
   else if (pt == e2.Bot) pt.Z = e2.Bot.Z;
   else if (pt == e2.Top) pt.Z = e2.Top.Z;
-  else (*m_ZFill)(e1.Bot, e1.Top, e2.Bot, e2.Top, pt); 
+  else (*m_ZFill)(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);
 }
 //------------------------------------------------------------------------------
 #endif
 
-void Clipper::IntersectEdges(TEdge *e1, TEdge *e2, IntPoint &amp;Pt)
-{
-  bool e1Contributing = ( e1-&gt;OutIdx &gt;= 0 );
-  bool e2Contributing = ( e2-&gt;OutIdx &gt;= 0 );
+  void Clipper::IntersectEdges(TEdge *e1, TEdge *e2, IntPoint &amp;Pt)
+  {
+    bool e1Contributing = (e1-&gt;OutIdx &gt;= 0);
+    bool e2Contributing = (e2-&gt;OutIdx &gt;= 0);
 
 #ifdef use_xyz
-        SetZ(Pt, *e1, *e2);
+    SetZ(Pt, *e1, *e2);
 #endif
 
 #ifdef use_lines
-  //if either edge is on an OPEN path ...
-  if (e1-&gt;WindDelta == 0 || e2-&gt;WindDelta == 0)
-  {
-    //ignore subject-subject open path intersections UNLESS they
-    //are both open paths, AND they are both 'contributing maximas' ...
-	if (e1-&gt;WindDelta == 0 &amp;&amp; e2-&gt;WindDelta == 0) return;
-
-    //if intersecting a subj line with a subj poly ...
-    else if (e1-&gt;PolyTyp == e2-&gt;PolyTyp &amp;&amp; 
-      e1-&gt;WindDelta != e2-&gt;WindDelta &amp;&amp; m_ClipType == ctUnion)
+    //if either edge is on an OPEN path ...
+    if (e1-&gt;WindDelta == 0 || e2-&gt;WindDelta == 0)
     {
-      if (e1-&gt;WindDelta == 0)
+      //ignore subject-subject open path intersections UNLESS they
+      //are both open paths, AND they are both 'contributing maximas' ...
+      if (e1-&gt;WindDelta == 0 &amp;&amp; e2-&gt;WindDelta == 0)
+        return;
+
+        //if intersecting a subj line with a subj poly ...
+      else if (e1-&gt;PolyTyp == e2-&gt;PolyTyp &amp;&amp;
+               e1-&gt;WindDelta != e2-&gt;WindDelta &amp;&amp; m_ClipType == ctUnion)
       {
-        if (e2Contributing)
+        if (e1-&gt;WindDelta == 0)
         {
-          AddOutPt(e1, Pt);
-          if (e1Contributing) e1-&gt;OutIdx = Unassigned;
+          if (e2Contributing)
+          {
+            AddOutPt(e1, Pt);
+            if (e1Contributing)
+              e1-&gt;OutIdx = Unassigned;
+          }
+        } else
+        {
+          if (e1Contributing)
+          {
+            AddOutPt(e2, Pt);
+            if (e2Contributing)
+              e2-&gt;OutIdx = Unassigned;
+          }
         }
-      }
-      else
+      } else if (e1-&gt;PolyTyp != e2-&gt;PolyTyp)
       {
-        if (e1Contributing)
+        //toggle subj open path OutIdx on/off when Abs(clip.WndCnt) == 1 ...
+        if ((e1-&gt;WindDelta == 0) &amp;&amp; abs(e2-&gt;WindCnt) == 1 &amp;&amp;
+            (m_ClipType != ctUnion || e2-&gt;WindCnt2 == 0))
+        {
+          AddOutPt(e1, Pt);
+          if (e1Contributing)
+            e1-&gt;OutIdx = Unassigned;
+        } else if ((e2-&gt;WindDelta == 0) &amp;&amp; (abs(e1-&gt;WindCnt) == 1) &amp;&amp;
+                   (m_ClipType != ctUnion || e1-&gt;WindCnt2 == 0))
         {
           AddOutPt(e2, Pt);
-          if (e2Contributing) e2-&gt;OutIdx = Unassigned;
+          if (e2Contributing)
+            e2-&gt;OutIdx = Unassigned;
         }
       }
+      return;
     }
-    else if (e1-&gt;PolyTyp != e2-&gt;PolyTyp)
+#endif
+
+    //update winding counts...
+    //assumes that e1 will be to the Right of e2 ABOVE the intersection
+    if (e1-&gt;PolyTyp == e2-&gt;PolyTyp)
     {
-      //toggle subj open path OutIdx on/off when Abs(clip.WndCnt) == 1 ...
-      if ((e1-&gt;WindDelta == 0) &amp;&amp; abs(e2-&gt;WindCnt) == 1 &amp;&amp; 
-        (m_ClipType != ctUnion || e2-&gt;WindCnt2 == 0))
+      if (IsEvenOddFillType(*e1))
       {
-        AddOutPt(e1, Pt);
-        if (e1Contributing) e1-&gt;OutIdx = Unassigned;
-      }
-      else if ((e2-&gt;WindDelta == 0) &amp;&amp; (abs(e1-&gt;WindCnt) == 1) &amp;&amp; 
-        (m_ClipType != ctUnion || e1-&gt;WindCnt2 == 0))
+        int oldE1WindCnt = e1-&gt;WindCnt;
+        e1-&gt;WindCnt = e2-&gt;WindCnt;
+        e2-&gt;WindCnt = oldE1WindCnt;
+      } else
       {
-        AddOutPt(e2, Pt);
-        if (e2Contributing) e2-&gt;OutIdx = Unassigned;
+        if (e1-&gt;WindCnt + e2-&gt;WindDelta == 0)
+          e1-&gt;WindCnt = -e1-&gt;WindCnt;
+        else
+          e1-&gt;WindCnt += e2-&gt;WindDelta;
+        if (e2-&gt;WindCnt - e1-&gt;WindDelta == 0)
+          e2-&gt;WindCnt = -e2-&gt;WindCnt;
+        else
+          e2-&gt;WindCnt -= e1-&gt;WindDelta;
       }
-    }
-    return;
-  }
-#endif
-
-  //update winding counts...
-  //assumes that e1 will be to the Right of e2 ABOVE the intersection
-  if ( e1-&gt;PolyTyp == e2-&gt;PolyTyp )
-  {
-    if ( IsEvenOddFillType( *e1) )
-    {
-      int oldE1WindCnt = e1-&gt;WindCnt;
-      e1-&gt;WindCnt = e2-&gt;WindCnt;
-      e2-&gt;WindCnt = oldE1WindCnt;
     } else
     {
-      if (e1-&gt;WindCnt + e2-&gt;WindDelta == 0 ) e1-&gt;WindCnt = -e1-&gt;WindCnt;
-      else e1-&gt;WindCnt += e2-&gt;WindDelta;
-      if ( e2-&gt;WindCnt - e1-&gt;WindDelta == 0 ) e2-&gt;WindCnt = -e2-&gt;WindCnt;
-      else e2-&gt;WindCnt -= e1-&gt;WindDelta;
+      if (!IsEvenOddFillType(*e2))
+        e1-&gt;WindCnt2 += e2-&gt;WindDelta;
+      else
+        e1-&gt;WindCnt2 = (e1-&gt;WindCnt2 == 0) ? 1 : 0;
+      if (!IsEvenOddFillType(*e1))
+        e2-&gt;WindCnt2 -= e1-&gt;WindDelta;
+      else
+        e2-&gt;WindCnt2 = (e2-&gt;WindCnt2 == 0) ? 1 : 0;
     }
-  } else
-  {
-    if (!IsEvenOddFillType(*e2)) e1-&gt;WindCnt2 += e2-&gt;WindDelta;
-    else e1-&gt;WindCnt2 = ( e1-&gt;WindCnt2 == 0 ) ? 1 : 0;
-    if (!IsEvenOddFillType(*e1)) e2-&gt;WindCnt2 -= e1-&gt;WindDelta;
-    else e2-&gt;WindCnt2 = ( e2-&gt;WindCnt2 == 0 ) ? 1 : 0;
-  }
-
-  PolyFillType e1FillType, e2FillType, e1FillType2, e2FillType2;
-  if (e1-&gt;PolyTyp == ptSubject)
-  {
-    e1FillType = m_SubjFillType;
-    e1FillType2 = m_ClipFillType;
-  } else
-  {
-    e1FillType = m_ClipFillType;
-    e1FillType2 = m_SubjFillType;
-  }
-  if (e2-&gt;PolyTyp == ptSubject)
-  {
-    e2FillType = m_SubjFillType;
-    e2FillType2 = m_ClipFillType;
-  } else
-  {
-    e2FillType = m_ClipFillType;
-    e2FillType2 = m_SubjFillType;
-  }
-
-  cInt e1Wc, e2Wc;
-  switch (e1FillType)
-  {
-    case pftPositive: e1Wc = e1-&gt;WindCnt; break;
-    case pftNegative: e1Wc = -e1-&gt;WindCnt; break;
-    default: e1Wc = Abs(e1-&gt;WindCnt);
-  }
-  switch(e2FillType)
-  {
-    case pftPositive: e2Wc = e2-&gt;WindCnt; break;
-    case pftNegative: e2Wc = -e2-&gt;WindCnt; break;
-    default: e2Wc = Abs(e2-&gt;WindCnt);
-  }
 
-  if ( e1Contributing &amp;&amp; e2Contributing )
-  {
-    if ((e1Wc != 0 &amp;&amp; e1Wc != 1) || (e2Wc != 0 &amp;&amp; e2Wc != 1) ||
-      (e1-&gt;PolyTyp != e2-&gt;PolyTyp &amp;&amp; m_ClipType != ctXor) )
+    PolyFillType e1FillType, e2FillType, e1FillType2, e2FillType2;
+    if (e1-&gt;PolyTyp == ptSubject)
     {
-      AddLocalMaxPoly(e1, e2, Pt); 
-    }
-    else
+      e1FillType = m_SubjFillType;
+      e1FillType2 = m_ClipFillType;
+    } else
     {
-      AddOutPt(e1, Pt);
-      AddOutPt(e2, Pt);
-      SwapSides( *e1 , *e2 );
-      SwapPolyIndexes( *e1 , *e2 );
+      e1FillType = m_ClipFillType;
+      e1FillType2 = m_SubjFillType;
     }
-  }
-  else if ( e1Contributing )
-  {
-    if (e2Wc == 0 || e2Wc == 1) 
+    if (e2-&gt;PolyTyp == ptSubject)
     {
-      AddOutPt(e1, Pt);
-      SwapSides(*e1, *e2);
-      SwapPolyIndexes(*e1, *e2);
-    }
-  }
-  else if ( e2Contributing )
-  {
-    if (e1Wc == 0 || e1Wc == 1) 
+      e2FillType = m_SubjFillType;
+      e2FillType2 = m_ClipFillType;
+    } else
     {
-      AddOutPt(e2, Pt);
-      SwapSides(*e1, *e2);
-      SwapPolyIndexes(*e1, *e2);
+      e2FillType = m_ClipFillType;
+      e2FillType2 = m_SubjFillType;
     }
-  } 
-  else if ( (e1Wc == 0 || e1Wc == 1) &amp;&amp; (e2Wc == 0 || e2Wc == 1))
-  {
-    //neither edge is currently contributing ...
 
-    cInt e1Wc2, e2Wc2;
-    switch (e1FillType2)
+    cInt e1Wc, e2Wc;
+    switch (e1FillType)
     {
-      case pftPositive: e1Wc2 = e1-&gt;WindCnt2; break;
-      case pftNegative : e1Wc2 = -e1-&gt;WindCnt2; break;
-      default: e1Wc2 = Abs(e1-&gt;WindCnt2);
+      case pftPositive:
+        e1Wc = e1-&gt;WindCnt;
+        break;
+      case pftNegative:
+        e1Wc = -e1-&gt;WindCnt;
+        break;
+      default:
+        e1Wc = Abs(e1-&gt;WindCnt);
     }
-    switch (e2FillType2)
+    switch (e2FillType)
     {
-      case pftPositive: e2Wc2 = e2-&gt;WindCnt2; break;
-      case pftNegative: e2Wc2 = -e2-&gt;WindCnt2; break;
-      default: e2Wc2 = Abs(e2-&gt;WindCnt2);
+      case pftPositive:
+        e2Wc = e2-&gt;WindCnt;
+        break;
+      case pftNegative:
+        e2Wc = -e2-&gt;WindCnt;
+        break;
+      default:
+        e2Wc = Abs(e2-&gt;WindCnt);
     }
 
-    if (e1-&gt;PolyTyp != e2-&gt;PolyTyp)
+    if (e1Contributing &amp;&amp; e2Contributing)
     {
-      AddLocalMinPoly(e1, e2, Pt);
-    }
-    else if (e1Wc == 1 &amp;&amp; e2Wc == 1)
-      switch( m_ClipType ) {
-        case ctIntersection:
-          if (e1Wc2 &gt; 0 &amp;&amp; e2Wc2 &gt; 0)
-            AddLocalMinPoly(e1, e2, Pt);
+      if ((e1Wc != 0 &amp;&amp; e1Wc != 1) || (e2Wc != 0 &amp;&amp; e2Wc != 1) ||
+          (e1-&gt;PolyTyp != e2-&gt;PolyTyp &amp;&amp; m_ClipType != ctXor))
+      {
+        AddLocalMaxPoly(e1, e2, Pt);
+      } else
+      {
+        AddOutPt(e1, Pt);
+        AddOutPt(e2, Pt);
+        SwapSides(*e1, *e2);
+        SwapPolyIndexes(*e1, *e2);
+      }
+    } else if (e1Contributing)
+    {
+      if (e2Wc == 0 || e2Wc == 1)
+      {
+        AddOutPt(e1, Pt);
+        SwapSides(*e1, *e2);
+        SwapPolyIndexes(*e1, *e2);
+      }
+    } else if (e2Contributing)
+    {
+      if (e1Wc == 0 || e1Wc == 1)
+      {
+        AddOutPt(e2, Pt);
+        SwapSides(*e1, *e2);
+        SwapPolyIndexes(*e1, *e2);
+      }
+    } else if ((e1Wc == 0 || e1Wc == 1) &amp;&amp; (e2Wc == 0 || e2Wc == 1))
+    {
+      //neither edge is currently contributing ...
+
+      cInt e1Wc2, e2Wc2;
+      switch (e1FillType2)
+      {
+        case pftPositive:
+          e1Wc2 = e1-&gt;WindCnt2;
           break;
-        case ctUnion:
-          if ( e1Wc2 &lt;= 0 &amp;&amp; e2Wc2 &lt;= 0 )
-            AddLocalMinPoly(e1, e2, Pt);
+        case pftNegative :
+          e1Wc2 = -e1-&gt;WindCnt2;
           break;
-        case ctDifference:
-          if (((e1-&gt;PolyTyp == ptClip) &amp;&amp; (e1Wc2 &gt; 0) &amp;&amp; (e2Wc2 &gt; 0)) ||
-              ((e1-&gt;PolyTyp == ptSubject) &amp;&amp; (e1Wc2 &lt;= 0) &amp;&amp; (e2Wc2 &lt;= 0)))
-                AddLocalMinPoly(e1, e2, Pt);
+        default:
+          e1Wc2 = Abs(e1-&gt;WindCnt2);
+      }
+      switch (e2FillType2)
+      {
+        case pftPositive:
+          e2Wc2 = e2-&gt;WindCnt2;
           break;
-        case ctXor:
-          AddLocalMinPoly(e1, e2, Pt);
+        case pftNegative:
+          e2Wc2 = -e2-&gt;WindCnt2;
+          break;
+        default:
+          e2Wc2 = Abs(e2-&gt;WindCnt2);
       }
-    else
-      SwapSides( *e1, *e2 );
+
+      if (e1-&gt;PolyTyp != e2-&gt;PolyTyp)
+      {
+        AddLocalMinPoly(e1, e2, Pt);
+      } else if (e1Wc == 1 &amp;&amp; e2Wc == 1)
+        switch (m_ClipType)
+        {
+          case ctIntersection:
+            if (e1Wc2 &gt; 0 &amp;&amp; e2Wc2 &gt; 0)
+              AddLocalMinPoly(e1, e2, Pt);
+            break;
+          case ctUnion:
+            if (e1Wc2 &lt;= 0 &amp;&amp; e2Wc2 &lt;= 0)
+              AddLocalMinPoly(e1, e2, Pt);
+            break;
+          case ctDifference:
+            if (((e1-&gt;PolyTyp == ptClip) &amp;&amp; (e1Wc2 &gt; 0) &amp;&amp; (e2Wc2 &gt; 0)) ||
+                ((e1-&gt;PolyTyp == ptSubject) &amp;&amp; (e1Wc2 &lt;= 0) &amp;&amp; (e2Wc2 &lt;= 0)))
+              AddLocalMinPoly(e1, e2, Pt);
+            break;
+          case ctXor:
+            AddLocalMinPoly(e1, e2, Pt);
+        }
+      else
+        SwapSides(*e1, *e2);
+    }
   }
-}
 //------------------------------------------------------------------------------
 
-void Clipper::SetHoleState(TEdge *e, OutRec *outrec)
-{
-  TEdge *e2 = e-&gt;PrevInAEL;
-  TEdge *eTmp = 0;
-  while (e2)
+  void Clipper::SetHoleState(TEdge *e, OutRec *outrec)
   {
-    if (e2-&gt;OutIdx &gt;= 0 &amp;&amp; e2-&gt;WindDelta != 0)
+    TEdge *e2 = e-&gt;PrevInAEL;
+    TEdge *eTmp = 0;
+    while (e2)
+    {
+      if (e2-&gt;OutIdx &gt;= 0 &amp;&amp; e2-&gt;WindDelta != 0)
+      {
+        if (!eTmp)
+          eTmp = e2;
+        else if (eTmp-&gt;OutIdx == e2-&gt;OutIdx)
+          eTmp = 0;
+      }
+      e2 = e2-&gt;PrevInAEL;
+    }
+    if (!eTmp)
+    {
+      outrec-&gt;FirstLeft = 0;
+      outrec-&gt;IsHole = false;
+    } else
     {
-      if (!eTmp) eTmp = e2;
-      else if (eTmp-&gt;OutIdx == e2-&gt;OutIdx) eTmp = 0;        
+      outrec-&gt;FirstLeft = m_PolyOuts[eTmp-&gt;OutIdx];
+      outrec-&gt;IsHole = !outrec-&gt;FirstLeft-&gt;IsHole;
     }
-    e2 = e2-&gt;PrevInAEL;
   }
-  if (!eTmp)
-  {
-    outrec-&gt;FirstLeft = 0;
-    outrec-&gt;IsHole = false;
+//------------------------------------------------------------------------------
+
+  OutRec *GetLowermostRec(OutRec *outRec1, OutRec *outRec2)
+  {
+    //work out which polygon fragment has the correct hole state ...
+    if (!outRec1-&gt;BottomPt)
+      outRec1-&gt;BottomPt = GetBottomPt(outRec1-&gt;Pts);
+    if (!outRec2-&gt;BottomPt)
+      outRec2-&gt;BottomPt = GetBottomPt(outRec2-&gt;Pts);
+    OutPt *OutPt1 = outRec1-&gt;BottomPt;
+    OutPt *OutPt2 = outRec2-&gt;BottomPt;
+    if (OutPt1-&gt;Pt.Y &gt; OutPt2-&gt;Pt.Y)
+      return outRec1;
+    else if (OutPt1-&gt;Pt.Y &lt; OutPt2-&gt;Pt.Y)
+      return outRec2;
+    else if (OutPt1-&gt;Pt.X &lt; OutPt2-&gt;Pt.X)
+      return outRec1;
+    else if (OutPt1-&gt;Pt.X &gt; OutPt2-&gt;Pt.X)
+      return outRec2;
+    else if (OutPt1-&gt;Next == OutPt1)
+      return outRec2;
+    else if (OutPt2-&gt;Next == OutPt2)
+      return outRec1;
+    else if (FirstIsBottomPt(OutPt1, OutPt2))
+      return outRec1;
+    else
+      return outRec2;
   }
-  else
+//------------------------------------------------------------------------------
+
+  bool OutRec1RightOfOutRec2(OutRec *outRec1, OutRec *outRec2)
   {
-    outrec-&gt;FirstLeft = m_PolyOuts[eTmp-&gt;OutIdx];
-    outrec-&gt;IsHole = !outrec-&gt;FirstLeft-&gt;IsHole;
+    do
+    {
+      outRec1 = outRec1-&gt;FirstLeft;
+      if (outRec1 == outRec2)
+        return true;
+    } while (outRec1);
+    return false;
   }
-}
 //------------------------------------------------------------------------------
 
-OutRec* GetLowermostRec(OutRec *outRec1, OutRec *outRec2)
-{
-  //work out which polygon fragment has the correct hole state ...
-  if (!outRec1-&gt;BottomPt) 
-    outRec1-&gt;BottomPt = GetBottomPt(outRec1-&gt;Pts);
-  if (!outRec2-&gt;BottomPt) 
-    outRec2-&gt;BottomPt = GetBottomPt(outRec2-&gt;Pts);
-  OutPt *OutPt1 = outRec1-&gt;BottomPt;
-  OutPt *OutPt2 = outRec2-&gt;BottomPt;
-  if (OutPt1-&gt;Pt.Y &gt; OutPt2-&gt;Pt.Y) return outRec1;
-  else if (OutPt1-&gt;Pt.Y &lt; OutPt2-&gt;Pt.Y) return outRec2;
-  else if (OutPt1-&gt;Pt.X &lt; OutPt2-&gt;Pt.X) return outRec1;
-  else if (OutPt1-&gt;Pt.X &gt; OutPt2-&gt;Pt.X) return outRec2;
-  else if (OutPt1-&gt;Next == OutPt1) return outRec2;
-  else if (OutPt2-&gt;Next == OutPt2) return outRec1;
-  else if (FirstIsBottomPt(OutPt1, OutPt2)) return outRec1;
-  else return outRec2;
-}
+  OutRec *Clipper::GetOutRec(int Idx)
+  {
+    OutRec *outrec = m_PolyOuts[Idx];
+    while (outrec != m_PolyOuts[outrec-&gt;Idx])
+      outrec = m_PolyOuts[outrec-&gt;Idx];
+    return outrec;
+  }
 //------------------------------------------------------------------------------
 
-bool OutRec1RightOfOutRec2(OutRec* outRec1, OutRec* outRec2)
-{
-  do
+  void Clipper::AppendPolygon(TEdge *e1, TEdge *e2)
   {
-    outRec1 = outRec1-&gt;FirstLeft;
-    if (outRec1 == outRec2) return true;
-  } while (outRec1);
-  return false;
-}
-//------------------------------------------------------------------------------
+    //get the start and ends of both output polygons ...
+    OutRec *outRec1 = m_PolyOuts[e1-&gt;OutIdx];
+    OutRec *outRec2 = m_PolyOuts[e2-&gt;OutIdx];
 
-OutRec* Clipper::GetOutRec(int Idx)
-{
-  OutRec* outrec = m_PolyOuts[Idx];
-  while (outrec != m_PolyOuts[outrec-&gt;Idx])
-    outrec = m_PolyOuts[outrec-&gt;Idx];
-  return outrec;
-}
-//------------------------------------------------------------------------------
+    OutRec *holeStateRec;
+    if (OutRec1RightOfOutRec2(outRec1, outRec2))
+      holeStateRec = outRec2;
+    else if (OutRec1RightOfOutRec2(outRec2, outRec1))
+      holeStateRec = outRec1;
+    else
+      holeStateRec = GetLowermostRec(outRec1, outRec2);
 
-void Clipper::AppendPolygon(TEdge *e1, TEdge *e2)
-{
-  //get the start and ends of both output polygons ...
-  OutRec *outRec1 = m_PolyOuts[e1-&gt;OutIdx];
-  OutRec *outRec2 = m_PolyOuts[e2-&gt;OutIdx];
-
-  OutRec *holeStateRec;
-  if (OutRec1RightOfOutRec2(outRec1, outRec2))
-    holeStateRec = outRec2;
-  else if (OutRec1RightOfOutRec2(outRec2, outRec1))
-    holeStateRec = outRec1;
-  else 
-    holeStateRec = GetLowermostRec(outRec1, outRec2);
-
-  //get the start and ends of both output polygons and
-  //join e2 poly onto e1 poly and delete pointers to e2 ...
-
-  OutPt* p1_lft = outRec1-&gt;Pts;
-  OutPt* p1_rt = p1_lft-&gt;Prev;
-  OutPt* p2_lft = outRec2-&gt;Pts;
-  OutPt* p2_rt = p2_lft-&gt;Prev;
-
-  //join e2 poly onto e1 poly and delete pointers to e2 ...
-  if(  e1-&gt;Side == esLeft )
-  {
-    if(  e2-&gt;Side == esLeft )
-    {
-      //z y x a b c
-      ReversePolyPtLinks(p2_lft);
-      p2_lft-&gt;Next = p1_lft;
-      p1_lft-&gt;Prev = p2_lft;
-      p1_rt-&gt;Next = p2_rt;
-      p2_rt-&gt;Prev = p1_rt;
-      outRec1-&gt;Pts = p2_rt;
+    //get the start and ends of both output polygons and
+    //join e2 poly onto e1 poly and delete pointers to e2 ...
+
+    OutPt *p1_lft = outRec1-&gt;Pts;
+    OutPt *p1_rt = p1_lft-&gt;Prev;
+    OutPt *p2_lft = outRec2-&gt;Pts;
+    OutPt *p2_rt = p2_lft-&gt;Prev;
+
+    //join e2 poly onto e1 poly and delete pointers to e2 ...
+    if (e1-&gt;Side == esLeft)
+    {
+      if (e2-&gt;Side == esLeft)
+      {
+        //z y x a b c
+        ReversePolyPtLinks(p2_lft);
+        p2_lft-&gt;Next = p1_lft;
+        p1_lft-&gt;Prev = p2_lft;
+        p1_rt-&gt;Next = p2_rt;
+        p2_rt-&gt;Prev = p1_rt;
+        outRec1-&gt;Pts = p2_rt;
+      } else
+      {
+        //x y z a b c
+        p2_rt-&gt;Next = p1_lft;
+        p1_lft-&gt;Prev = p2_rt;
+        p2_lft-&gt;Prev = p1_rt;
+        p1_rt-&gt;Next = p2_lft;
+        outRec1-&gt;Pts = p2_lft;
+      }
     } else
     {
-      //x y z a b c
-      p2_rt-&gt;Next = p1_lft;
-      p1_lft-&gt;Prev = p2_rt;
-      p2_lft-&gt;Prev = p1_rt;
-      p1_rt-&gt;Next = p2_lft;
-      outRec1-&gt;Pts = p2_lft;
+      if (e2-&gt;Side == esRight)
+      {
+        //a b c z y x
+        ReversePolyPtLinks(p2_lft);
+        p1_rt-&gt;Next = p2_rt;
+        p2_rt-&gt;Prev = p1_rt;
+        p2_lft-&gt;Next = p1_lft;
+        p1_lft-&gt;Prev = p2_lft;
+      } else
+      {
+        //a b c x y z
+        p1_rt-&gt;Next = p2_lft;
+        p2_lft-&gt;Prev = p1_rt;
+        p1_lft-&gt;Prev = p2_rt;
+        p2_rt-&gt;Next = p1_lft;
+      }
     }
-  } else
-  {
-    if(  e2-&gt;Side == esRight )
-    {
-      //a b c z y x
-      ReversePolyPtLinks(p2_lft);
-      p1_rt-&gt;Next = p2_rt;
-      p2_rt-&gt;Prev = p1_rt;
-      p2_lft-&gt;Next = p1_lft;
-      p1_lft-&gt;Prev = p2_lft;
-    } else
+
+    outRec1-&gt;BottomPt = 0;
+    if (holeStateRec == outRec2)
     {
-      //a b c x y z
-      p1_rt-&gt;Next = p2_lft;
-      p2_lft-&gt;Prev = p1_rt;
-      p1_lft-&gt;Prev = p2_rt;
-      p2_rt-&gt;Next = p1_lft;
+      if (outRec2-&gt;FirstLeft != outRec1)
+        outRec1-&gt;FirstLeft = outRec2-&gt;FirstLeft;
+      outRec1-&gt;IsHole = outRec2-&gt;IsHole;
     }
-  }
+    outRec2-&gt;Pts = 0;
+    outRec2-&gt;BottomPt = 0;
+    outRec2-&gt;FirstLeft = outRec1;
 
-  outRec1-&gt;BottomPt = 0;
-  if (holeStateRec == outRec2)
-  {
-    if (outRec2-&gt;FirstLeft != outRec1)
-      outRec1-&gt;FirstLeft = outRec2-&gt;FirstLeft;
-    outRec1-&gt;IsHole = outRec2-&gt;IsHole;
-  }
-  outRec2-&gt;Pts = 0;
-  outRec2-&gt;BottomPt = 0;
-  outRec2-&gt;FirstLeft = outRec1;
+    int OKIdx = e1-&gt;OutIdx;
+    int ObsoleteIdx = e2-&gt;OutIdx;
+
+    e1-&gt;OutIdx = Unassigned; //nb: safe because we only get here via AddLocalMaxPoly
+    e2-&gt;OutIdx = Unassigned;
 
-  int OKIdx = e1-&gt;OutIdx;
-  int ObsoleteIdx = e2-&gt;OutIdx;
+    TEdge *e = m_ActiveEdges;
+    while (e)
+    {
+      if (e-&gt;OutIdx == ObsoleteIdx)
+      {
+        e-&gt;OutIdx = OKIdx;
+        e-&gt;Side = e1-&gt;Side;
+        break;
+      }
+      e = e-&gt;NextInAEL;
+    }
 
-  e1-&gt;OutIdx = Unassigned; //nb: safe because we only get here via AddLocalMaxPoly
-  e2-&gt;OutIdx = Unassigned;
+    outRec2-&gt;Idx = outRec1-&gt;Idx;
+  }
+//------------------------------------------------------------------------------
 
-  TEdge* e = m_ActiveEdges;
-  while( e )
+  OutPt *Clipper::AddOutPt(TEdge *e, const IntPoint &amp;pt)
   {
-    if( e-&gt;OutIdx == ObsoleteIdx )
+    if (e-&gt;OutIdx &lt; 0)
     {
-      e-&gt;OutIdx = OKIdx;
-      e-&gt;Side = e1-&gt;Side;
-      break;
+      OutRec *outRec = CreateOutRec();
+      outRec-&gt;IsOpen = (e-&gt;WindDelta == 0);
+      OutPt *newOp = new OutPt;
+      outRec-&gt;Pts = newOp;
+      newOp-&gt;Idx = outRec-&gt;Idx;
+      newOp-&gt;Pt = pt;
+      newOp-&gt;Next = newOp;
+      newOp-&gt;Prev = newOp;
+      if (!outRec-&gt;IsOpen)
+        SetHoleState(e, outRec);
+      e-&gt;OutIdx = outRec-&gt;Idx;
+      return newOp;
+    } else
+    {
+      OutRec *outRec = m_PolyOuts[e-&gt;OutIdx];
+      //OutRec.Pts is the 'Left-most' point &amp; OutRec.Pts.Prev is the 'Right-most'
+      OutPt *op = outRec-&gt;Pts;
+
+      bool ToFront = (e-&gt;Side == esLeft);
+      if (ToFront &amp;&amp; (pt == op-&gt;Pt))
+        return op;
+      else if (!ToFront &amp;&amp; (pt == op-&gt;Prev-&gt;Pt))
+        return op-&gt;Prev;
+
+      OutPt *newOp = new OutPt;
+      newOp-&gt;Idx = outRec-&gt;Idx;
+      newOp-&gt;Pt = pt;
+      newOp-&gt;Next = op;
+      newOp-&gt;Prev = op-&gt;Prev;
+      newOp-&gt;Prev-&gt;Next = newOp;
+      op-&gt;Prev = newOp;
+      if (ToFront)
+        outRec-&gt;Pts = newOp;
+      return newOp;
     }
-    e = e-&gt;NextInAEL;
   }
-
-  outRec2-&gt;Idx = outRec1-&gt;Idx;
-}
 //------------------------------------------------------------------------------
 
-OutPt* Clipper::AddOutPt(TEdge *e, const IntPoint &amp;pt)
-{
-  if(  e-&gt;OutIdx &lt; 0 )
-  {
-    OutRec *outRec = CreateOutRec();
-    outRec-&gt;IsOpen = (e-&gt;WindDelta == 0);
-    OutPt* newOp = new OutPt;
-    outRec-&gt;Pts = newOp;
-    newOp-&gt;Idx = outRec-&gt;Idx;
-    newOp-&gt;Pt = pt;
-    newOp-&gt;Next = newOp;
-    newOp-&gt;Prev = newOp;
-    if (!outRec-&gt;IsOpen)
-      SetHoleState(e, outRec);
-    e-&gt;OutIdx = outRec-&gt;Idx;
-    return newOp;
-  } else
+  OutPt *Clipper::GetLastOutPt(TEdge *e)
   {
     OutRec *outRec = m_PolyOuts[e-&gt;OutIdx];
-    //OutRec.Pts is the 'Left-most' point &amp; OutRec.Pts.Prev is the 'Right-most'
-    OutPt* op = outRec-&gt;Pts;
-
-	bool ToFront = (e-&gt;Side == esLeft);
-	if (ToFront &amp;&amp; (pt == op-&gt;Pt)) return op;
-    else if (!ToFront &amp;&amp; (pt == op-&gt;Prev-&gt;Pt)) return op-&gt;Prev;
-
-    OutPt* newOp = new OutPt;
-    newOp-&gt;Idx = outRec-&gt;Idx;
-    newOp-&gt;Pt = pt;
-    newOp-&gt;Next = op;
-    newOp-&gt;Prev = op-&gt;Prev;
-    newOp-&gt;Prev-&gt;Next = newOp;
-    op-&gt;Prev = newOp;
-    if (ToFront) outRec-&gt;Pts = newOp;
-    return newOp;
+    if (e-&gt;Side == esLeft)
+      return outRec-&gt;Pts;
+    else
+      return outRec-&gt;Pts-&gt;Prev;
   }
-}
 //------------------------------------------------------------------------------
 
-OutPt* Clipper::GetLastOutPt(TEdge *e)
-{
-	OutRec *outRec = m_PolyOuts[e-&gt;OutIdx];
-	if (e-&gt;Side == esLeft)
-		return outRec-&gt;Pts;
-	else
-		return outRec-&gt;Pts-&gt;Prev;
-}
+  void Clipper::ProcessHorizontals()
+  {
+    TEdge *horzEdge;
+    while (PopEdgeFromSEL(horzEdge))
+      ProcessHorizontal(horzEdge);
+  }
 //------------------------------------------------------------------------------
 
-void Clipper::ProcessHorizontals()
-{
-  TEdge* horzEdge;
-  while (PopEdgeFromSEL(horzEdge))
-    ProcessHorizontal(horzEdge);
-}
+  inline bool IsMinima(TEdge *e)
+  {
+    return e &amp;&amp; (e-&gt;Prev-&gt;NextInLML != e) &amp;&amp; (e-&gt;Next-&gt;NextInLML != e);
+  }
 //------------------------------------------------------------------------------
 
-inline bool IsMinima(TEdge *e)
-{
-  return e  &amp;&amp; (e-&gt;Prev-&gt;NextInLML != e) &amp;&amp; (e-&gt;Next-&gt;NextInLML != e);
-}
+  inline bool IsMaxima(TEdge *e, const cInt Y)
+  {
+    return e &amp;&amp; e-&gt;Top.Y == Y &amp;&amp; !e-&gt;NextInLML;
+  }
 //------------------------------------------------------------------------------
 
-inline bool IsMaxima(TEdge *e, const cInt Y)
-{
-  return e &amp;&amp; e-&gt;Top.Y == Y &amp;&amp; !e-&gt;NextInLML;
-}
+  inline bool IsIntermediate(TEdge *e, const cInt Y)
+  {
+    return e-&gt;Top.Y == Y &amp;&amp; e-&gt;NextInLML;
+  }
 //------------------------------------------------------------------------------
 
-inline bool IsIntermediate(TEdge *e, const cInt Y)
-{
-  return e-&gt;Top.Y == Y &amp;&amp; e-&gt;NextInLML;
-}
+  TEdge *GetMaximaPair(TEdge *e)
+  {
+    if ((e-&gt;Next-&gt;Top == e-&gt;Top) &amp;&amp; !e-&gt;Next-&gt;NextInLML)
+      return e-&gt;Next;
+    else if ((e-&gt;Prev-&gt;Top == e-&gt;Top) &amp;&amp; !e-&gt;Prev-&gt;NextInLML)
+      return e-&gt;Prev;
+    else
+      return 0;
+  }
 //------------------------------------------------------------------------------
 
-TEdge *GetMaximaPair(TEdge *e)
-{
-  if ((e-&gt;Next-&gt;Top == e-&gt;Top) &amp;&amp; !e-&gt;Next-&gt;NextInLML)
-    return e-&gt;Next;
-  else if ((e-&gt;Prev-&gt;Top == e-&gt;Top) &amp;&amp; !e-&gt;Prev-&gt;NextInLML)
-    return e-&gt;Prev;
-  else return 0;
-}
+  TEdge *GetMaximaPairEx(TEdge *e)
+  {
+    //as GetMaximaPair() but returns 0 if MaxPair isn't in AEL (unless it's horizontal)
+    TEdge *result = GetMaximaPair(e);
+    if (result &amp;&amp; (result-&gt;OutIdx == Skip ||
+                   (result-&gt;NextInAEL == result-&gt;PrevInAEL &amp;&amp; !IsHorizontal(*result))))
+      return 0;
+    return result;
+  }
 //------------------------------------------------------------------------------
 
-TEdge *GetMaximaPairEx(TEdge *e)
-{
-  //as GetMaximaPair() but returns 0 if MaxPair isn't in AEL (unless it's horizontal)
-  TEdge* result = GetMaximaPair(e);
-  if (result &amp;&amp; (result-&gt;OutIdx == Skip ||
-    (result-&gt;NextInAEL == result-&gt;PrevInAEL &amp;&amp; !IsHorizontal(*result)))) return 0;
-  return result;
-}
-//------------------------------------------------------------------------------
+  void Clipper::SwapPositionsInSEL(TEdge *Edge1, TEdge *Edge2)
+  {
+    if (!(Edge1-&gt;NextInSEL) &amp;&amp; !(Edge1-&gt;PrevInSEL))
+      return;
+    if (!(Edge2-&gt;NextInSEL) &amp;&amp; !(Edge2-&gt;PrevInSEL))
+      return;
 
-void Clipper::SwapPositionsInSEL(TEdge *Edge1, TEdge *Edge2)
-{
-  if(  !( Edge1-&gt;NextInSEL ) &amp;&amp;  !( Edge1-&gt;PrevInSEL ) ) return;
-  if(  !( Edge2-&gt;NextInSEL ) &amp;&amp;  !( Edge2-&gt;PrevInSEL ) ) return;
-
-  if(  Edge1-&gt;NextInSEL == Edge2 )
-  {
-    TEdge* Next = Edge2-&gt;NextInSEL;
-    if( Next ) Next-&gt;PrevInSEL = Edge1;
-    TEdge* Prev = Edge1-&gt;PrevInSEL;
-    if( Prev ) Prev-&gt;NextInSEL = Edge2;
-    Edge2-&gt;PrevInSEL = Prev;
-    Edge2-&gt;NextInSEL = Edge1;
-    Edge1-&gt;PrevInSEL = Edge2;
-    Edge1-&gt;NextInSEL = Next;
-  }
-  else if(  Edge2-&gt;NextInSEL == Edge1 )
-  {
-    TEdge* Next = Edge1-&gt;NextInSEL;
-    if( Next ) Next-&gt;PrevInSEL = Edge2;
-    TEdge* Prev = Edge2-&gt;PrevInSEL;
-    if( Prev ) Prev-&gt;NextInSEL = Edge1;
-    Edge1-&gt;PrevInSEL = Prev;
-    Edge1-&gt;NextInSEL = Edge2;
-    Edge2-&gt;PrevInSEL = Edge1;
-    Edge2-&gt;NextInSEL = Next;
-  }
-  else
-  {
-    TEdge* Next = Edge1-&gt;NextInSEL;
-    TEdge* Prev = Edge1-&gt;PrevInSEL;
-    Edge1-&gt;NextInSEL = Edge2-&gt;NextInSEL;
-    if( Edge1-&gt;NextInSEL ) Edge1-&gt;NextInSEL-&gt;PrevInSEL = Edge1;
-    Edge1-&gt;PrevInSEL = Edge2-&gt;PrevInSEL;
-    if( Edge1-&gt;PrevInSEL ) Edge1-&gt;PrevInSEL-&gt;NextInSEL = Edge1;
-    Edge2-&gt;NextInSEL = Next;
-    if( Edge2-&gt;NextInSEL ) Edge2-&gt;NextInSEL-&gt;PrevInSEL = Edge2;
-    Edge2-&gt;PrevInSEL = Prev;
-    if( Edge2-&gt;PrevInSEL ) Edge2-&gt;PrevInSEL-&gt;NextInSEL = Edge2;
-  }
-
-  if( !Edge1-&gt;PrevInSEL ) m_SortedEdges = Edge1;
-  else if( !Edge2-&gt;PrevInSEL ) m_SortedEdges = Edge2;
-}
-//------------------------------------------------------------------------------
+    if (Edge1-&gt;NextInSEL == Edge2)
+    {
+      TEdge *Next = Edge2-&gt;NextInSEL;
+      if (Next)
+        Next-&gt;PrevInSEL = Edge1;
+      TEdge *Prev = Edge1-&gt;PrevInSEL;
+      if (Prev)
+        Prev-&gt;NextInSEL = Edge2;
+      Edge2-&gt;PrevInSEL = Prev;
+      Edge2-&gt;NextInSEL = Edge1;
+      Edge1-&gt;PrevInSEL = Edge2;
+      Edge1-&gt;NextInSEL = Next;
+    } else if (Edge2-&gt;NextInSEL == Edge1)
+    {
+      TEdge *Next = Edge1-&gt;NextInSEL;
+      if (Next)
+        Next-&gt;PrevInSEL = Edge2;
+      TEdge *Prev = Edge2-&gt;PrevInSEL;
+      if (Prev)
+        Prev-&gt;NextInSEL = Edge1;
+      Edge1-&gt;PrevInSEL = Prev;
+      Edge1-&gt;NextInSEL = Edge2;
+      Edge2-&gt;PrevInSEL = Edge1;
+      Edge2-&gt;NextInSEL = Next;
+    } else
+    {
+      TEdge *Next = Edge1-&gt;NextInSEL;
+      TEdge *Prev = Edge1-&gt;PrevInSEL;
+      Edge1-&gt;NextInSEL = Edge2-&gt;NextInSEL;
+      if (Edge1-&gt;NextInSEL)
+        Edge1-&gt;NextInSEL-&gt;PrevInSEL = Edge1;
+      Edge1-&gt;PrevInSEL = Edge2-&gt;PrevInSEL;
+      if (Edge1-&gt;PrevInSEL)
+        Edge1-&gt;PrevInSEL-&gt;NextInSEL = Edge1;
+      Edge2-&gt;NextInSEL = Next;
+      if (Edge2-&gt;NextInSEL)
+        Edge2-&gt;NextInSEL-&gt;PrevInSEL = Edge2;
+      Edge2-&gt;PrevInSEL = Prev;
+      if (Edge2-&gt;PrevInSEL)
+        Edge2-&gt;PrevInSEL-&gt;NextInSEL = Edge2;
+    }
 
-TEdge* GetNextInAEL(TEdge *e, Direction dir)
-{
-  return dir == dLeftToRight ? e-&gt;NextInAEL : e-&gt;PrevInAEL;
-}
+    if (!Edge1-&gt;PrevInSEL)
+      m_SortedEdges = Edge1;
+    else if (!Edge2-&gt;PrevInSEL)
+      m_SortedEdges = Edge2;
+  }
 //------------------------------------------------------------------------------
 
-void GetHorzDirection(TEdge&amp; HorzEdge, Direction&amp; Dir, cInt&amp; Left, cInt&amp; Right)
-{
-  if (HorzEdge.Bot.X &lt; HorzEdge.Top.X)
+  TEdge *GetNextInAEL(TEdge *e, Direction dir)
   {
-    Left = HorzEdge.Bot.X;
-    Right = HorzEdge.Top.X;
-    Dir = dLeftToRight;
-  } else
+    return dir == dLeftToRight ? e-&gt;NextInAEL : e-&gt;PrevInAEL;
+  }
+//------------------------------------------------------------------------------
+
+  void GetHorzDirection(TEdge &amp;HorzEdge, Direction &amp;Dir, cInt &amp;Left, cInt &amp;Right)
   {
-    Left = HorzEdge.Top.X;
-    Right = HorzEdge.Bot.X;
-    Dir = dRightToLeft;
+    if (HorzEdge.Bot.X &lt; HorzEdge.Top.X)
+    {
+      Left = HorzEdge.Bot.X;
+      Right = HorzEdge.Top.X;
+      Dir = dLeftToRight;
+    } else
+    {
+      Left = HorzEdge.Top.X;
+      Right = HorzEdge.Bot.X;
+      Dir = dRightToLeft;
+    }
   }
-}
 //------------------------------------------------------------------------
 
 /*******************************************************************************
@@ -2633,109 +2846,111 @@ void GetHorzDirection(TEdge&amp; HorzEdge, Direction&amp; Dir, cInt&amp; Left, cInt&amp; Right)
 * the AEL. These 'promoted' edges may in turn intersect [%] with other HEs.    *
 *******************************************************************************/
 
-void Clipper::ProcessHorizontal(TEdge *horzEdge)
-{
-  Direction dir;
-  cInt horzLeft, horzRight;
-  bool IsOpen = (horzEdge-&gt;WindDelta == 0);
+  void Clipper::ProcessHorizontal(TEdge *horzEdge)
+  {
+    Direction dir;
+    cInt horzLeft, horzRight;
+    bool IsOpen = (horzEdge-&gt;WindDelta == 0);
 
-  GetHorzDirection(*horzEdge, dir, horzLeft, horzRight);
+    GetHorzDirection(*horzEdge, dir, horzLeft, horzRight);
 
-  TEdge* eLastHorz = horzEdge, *eMaxPair = 0;
-  while (eLastHorz-&gt;NextInLML &amp;&amp; IsHorizontal(*eLastHorz-&gt;NextInLML)) 
-    eLastHorz = eLastHorz-&gt;NextInLML;
-  if (!eLastHorz-&gt;NextInLML)
-    eMaxPair = GetMaximaPair(eLastHorz);
+    TEdge *eLastHorz = horzEdge, *eMaxPair = 0;
+    while (eLastHorz-&gt;NextInLML &amp;&amp; IsHorizontal(*eLastHorz-&gt;NextInLML))
+      eLastHorz = eLastHorz-&gt;NextInLML;
+    if (!eLastHorz-&gt;NextInLML)
+      eMaxPair = GetMaximaPair(eLastHorz);
 
-  MaximaList::const_iterator maxIt;
-  MaximaList::const_reverse_iterator maxRit;
-  if (m_Maxima.size() &gt; 0)
-  {
+    MaximaList::const_iterator maxIt;
+    MaximaList::const_reverse_iterator maxRit;
+    if (m_Maxima.size() &gt; 0)
+    {
       //get the first maxima in range (X) ...
       if (dir == dLeftToRight)
       {
-          maxIt = m_Maxima.begin();
-          while (maxIt != m_Maxima.end() &amp;&amp; *maxIt &lt;= horzEdge-&gt;Bot.X) maxIt++;
-          if (maxIt != m_Maxima.end() &amp;&amp; *maxIt &gt;= eLastHorz-&gt;Top.X)
-              maxIt = m_Maxima.end();
-      }
-      else
+        maxIt = m_Maxima.begin();
+        while (maxIt != m_Maxima.end() &amp;&amp; *maxIt &lt;= horzEdge-&gt;Bot.X)
+          maxIt++;
+        if (maxIt != m_Maxima.end() &amp;&amp; *maxIt &gt;= eLastHorz-&gt;Top.X)
+          maxIt = m_Maxima.end();
+      } else
       {
-          maxRit = m_Maxima.rbegin();
-          while (maxRit != m_Maxima.rend() &amp;&amp; *maxRit &gt; horzEdge-&gt;Bot.X) maxRit++;
-          if (maxRit != m_Maxima.rend() &amp;&amp; *maxRit &lt;= eLastHorz-&gt;Top.X)
-              maxRit = m_Maxima.rend();
+        maxRit = m_Maxima.rbegin();
+        while (maxRit != m_Maxima.rend() &amp;&amp; *maxRit &gt; horzEdge-&gt;Bot.X)
+          maxRit++;
+        if (maxRit != m_Maxima.rend() &amp;&amp; *maxRit &lt;= eLastHorz-&gt;Top.X)
+          maxRit = m_Maxima.rend();
       }
-  }
+    }
 
-  OutPt* op1 = 0;
+    OutPt *op1 = 0;
 
-  for (;;) //loop through consec. horizontal edges
-  {
-		  
-    bool IsLastHorz = (horzEdge == eLastHorz);
-    TEdge* e = GetNextInAEL(horzEdge, dir);
-    while(e)
+    for (;;) //loop through consec. horizontal edges
     {
 
+      bool IsLastHorz = (horzEdge == eLastHorz);
+      TEdge *e = GetNextInAEL(horzEdge, dir);
+      while (e)
+      {
+
         //this code block inserts extra coords into horizontal edges (in output
         //polygons) whereever maxima touch these horizontal edges. This helps
         //'simplifying' polygons (ie if the Simplify property is set).
         if (m_Maxima.size() &gt; 0)
         {
-            if (dir == dLeftToRight)
+          if (dir == dLeftToRight)
+          {
+            while (maxIt != m_Maxima.end() &amp;&amp; *maxIt &lt; e-&gt;Curr.X)
             {
-                while (maxIt != m_Maxima.end() &amp;&amp; *maxIt &lt; e-&gt;Curr.X) 
-                {
-                  if (horzEdge-&gt;OutIdx &gt;= 0 &amp;&amp; !IsOpen)
-                    AddOutPt(horzEdge, IntPoint(*maxIt, horzEdge-&gt;Bot.Y));
-                  maxIt++;
-                }
+              if (horzEdge-&gt;OutIdx &gt;= 0 &amp;&amp; !IsOpen)
+                AddOutPt(horzEdge, IntPoint(*maxIt, horzEdge-&gt;Bot.Y));
+              maxIt++;
             }
-            else
+          } else
+          {
+            while (maxRit != m_Maxima.rend() &amp;&amp; *maxRit &gt; e-&gt;Curr.X)
             {
-                while (maxRit != m_Maxima.rend() &amp;&amp; *maxRit &gt; e-&gt;Curr.X)
-                {
-                  if (horzEdge-&gt;OutIdx &gt;= 0 &amp;&amp; !IsOpen)
-                    AddOutPt(horzEdge, IntPoint(*maxRit, horzEdge-&gt;Bot.Y));
-                  maxRit++;
-                }
+              if (horzEdge-&gt;OutIdx &gt;= 0 &amp;&amp; !IsOpen)
+                AddOutPt(horzEdge, IntPoint(*maxRit, horzEdge-&gt;Bot.Y));
+              maxRit++;
             }
+          }
         };
 
         if ((dir == dLeftToRight &amp;&amp; e-&gt;Curr.X &gt; horzRight) ||
-			(dir == dRightToLeft &amp;&amp; e-&gt;Curr.X &lt; horzLeft)) break;
+            (dir == dRightToLeft &amp;&amp; e-&gt;Curr.X &lt; horzLeft))
+          break;
 
-		//Also break if we've got to the end of an intermediate horizontal edge ...
-		//nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.
-		if (e-&gt;Curr.X == horzEdge-&gt;Top.X &amp;&amp; horzEdge-&gt;NextInLML &amp;&amp; 
-			e-&gt;Dx &lt; horzEdge-&gt;NextInLML-&gt;Dx) break;
+        //Also break if we've got to the end of an intermediate horizontal edge ...
+        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.
+        if (e-&gt;Curr.X == horzEdge-&gt;Top.X &amp;&amp; horzEdge-&gt;NextInLML &amp;&amp;
+            e-&gt;Dx &lt; horzEdge-&gt;NextInLML-&gt;Dx)
+          break;
 
-    if (horzEdge-&gt;OutIdx &gt;= 0 &amp;&amp; !IsOpen)  //note: may be done multiple times
-		{
+        if (horzEdge-&gt;OutIdx &gt;= 0 &amp;&amp; !IsOpen)  //note: may be done multiple times
+        {
 #ifdef use_xyz
-			if (dir == dLeftToRight) SetZ(e-&gt;Curr, *horzEdge, *e);
+                                                                                                                                  if (dir == dLeftToRight) SetZ(e-&gt;Curr, *horzEdge, *e);
 			else SetZ(e-&gt;Curr, *e, *horzEdge);
-#endif      
-			op1 = AddOutPt(horzEdge, e-&gt;Curr);
-			TEdge* eNextHorz = m_SortedEdges;
-			while (eNextHorz)
-			{
-				if (eNextHorz-&gt;OutIdx &gt;= 0 &amp;&amp;
-					HorzSegmentsOverlap(horzEdge-&gt;Bot.X,
-					horzEdge-&gt;Top.X, eNextHorz-&gt;Bot.X, eNextHorz-&gt;Top.X))
-				{
-                    OutPt* op2 = GetLastOutPt(eNextHorz);
-                    AddJoin(op2, op1, eNextHorz-&gt;Top);
-				}
-				eNextHorz = eNextHorz-&gt;NextInSEL;
-			}
-			AddGhostJoin(op1, horzEdge-&gt;Bot);
-		}
-		
-		//OK, so far we're still in range of the horizontal Edge  but make sure
+#endif
+          op1 = AddOutPt(horzEdge, e-&gt;Curr);
+          TEdge *eNextHorz = m_SortedEdges;
+          while (eNextHorz)
+          {
+            if (eNextHorz-&gt;OutIdx &gt;= 0 &amp;&amp;
+                HorzSegmentsOverlap(horzEdge-&gt;Bot.X,
+                                    horzEdge-&gt;Top.X, eNextHorz-&gt;Bot.X, eNextHorz-&gt;Top.X))
+            {
+              OutPt *op2 = GetLastOutPt(eNextHorz);
+              AddJoin(op2, op1, eNextHorz-&gt;Top);
+            }
+            eNextHorz = eNextHorz-&gt;NextInSEL;
+          }
+          AddGhostJoin(op1, horzEdge-&gt;Bot);
+        }
+
+        //OK, so far we're still in range of the horizontal Edge  but make sure
         //we're at the last of consec. horizontals when matching with eMaxPair
-        if(e == eMaxPair &amp;&amp; IsLastHorz)
+        if (e == eMaxPair &amp;&amp; IsLastHorz)
         {
           if (horzEdge-&gt;OutIdx &gt;= 0)
             AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge-&gt;Top);
@@ -2743,405 +2958,416 @@ void Clipper::ProcessHorizontal(TEdge *horzEdge)
           DeleteFromAEL(eMaxPair);
           return;
         }
-        
-		if(dir == dLeftToRight)
+
+        if (dir == dLeftToRight)
         {
           IntPoint Pt = IntPoint(e-&gt;Curr.X, horzEdge-&gt;Curr.Y);
           IntersectEdges(horzEdge, e, Pt);
-        }
-        else
+        } else
         {
           IntPoint Pt = IntPoint(e-&gt;Curr.X, horzEdge-&gt;Curr.Y);
-          IntersectEdges( e, horzEdge, Pt);
+          IntersectEdges(e, horzEdge, Pt);
         }
-        TEdge* eNext = GetNextInAEL(e, dir);
-        SwapPositionsInAEL( horzEdge, e );
+        TEdge *eNext = GetNextInAEL(e, dir);
+        SwapPositionsInAEL(horzEdge, e);
         e = eNext;
-    } //end while(e)
+      } //end while(e)
 
-	//Break out of loop if HorzEdge.NextInLML is not also horizontal ...
-	if (!horzEdge-&gt;NextInLML || !IsHorizontal(*horzEdge-&gt;NextInLML)) break;
+      //Break out of loop if HorzEdge.NextInLML is not also horizontal ...
+      if (!horzEdge-&gt;NextInLML || !IsHorizontal(*horzEdge-&gt;NextInLML))
+        break;
 
-	UpdateEdgeIntoAEL(horzEdge);
-    if (horzEdge-&gt;OutIdx &gt;= 0) AddOutPt(horzEdge, horzEdge-&gt;Bot);
-    GetHorzDirection(*horzEdge, dir, horzLeft, horzRight);
+      UpdateEdgeIntoAEL(horzEdge);
+      if (horzEdge-&gt;OutIdx &gt;= 0)
+        AddOutPt(horzEdge, horzEdge-&gt;Bot);
+      GetHorzDirection(*horzEdge, dir, horzLeft, horzRight);
 
-  } //end for (;;)
+    } //end for (;;)
 
-  if (horzEdge-&gt;OutIdx &gt;= 0 &amp;&amp; !op1)
-  {
+    if (horzEdge-&gt;OutIdx &gt;= 0 &amp;&amp; !op1)
+    {
       op1 = GetLastOutPt(horzEdge);
-      TEdge* eNextHorz = m_SortedEdges;
+      TEdge *eNextHorz = m_SortedEdges;
       while (eNextHorz)
       {
-          if (eNextHorz-&gt;OutIdx &gt;= 0 &amp;&amp;
-              HorzSegmentsOverlap(horzEdge-&gt;Bot.X,
-              horzEdge-&gt;Top.X, eNextHorz-&gt;Bot.X, eNextHorz-&gt;Top.X))
-          {
-              OutPt* op2 = GetLastOutPt(eNextHorz);
-              AddJoin(op2, op1, eNextHorz-&gt;Top);
-          }
-          eNextHorz = eNextHorz-&gt;NextInSEL;
+        if (eNextHorz-&gt;OutIdx &gt;= 0 &amp;&amp;
+            HorzSegmentsOverlap(horzEdge-&gt;Bot.X,
+                                horzEdge-&gt;Top.X, eNextHorz-&gt;Bot.X, eNextHorz-&gt;Top.X))
+        {
+          OutPt *op2 = GetLastOutPt(eNextHorz);
+          AddJoin(op2, op1, eNextHorz-&gt;Top);
+        }
+        eNextHorz = eNextHorz-&gt;NextInSEL;
       }
       AddGhostJoin(op1, horzEdge-&gt;Top);
-  }
+    }
 
-  if (horzEdge-&gt;NextInLML)
-  {
-    if(horzEdge-&gt;OutIdx &gt;= 0)
+    if (horzEdge-&gt;NextInLML)
     {
-      op1 = AddOutPt( horzEdge, horzEdge-&gt;Top);
-      UpdateEdgeIntoAEL(horzEdge);
-      if (horzEdge-&gt;WindDelta == 0) return;
-      //nb: HorzEdge is no longer horizontal here
-      TEdge* ePrev = horzEdge-&gt;PrevInAEL;
-      TEdge* eNext = horzEdge-&gt;NextInAEL;
-      if (ePrev &amp;&amp; ePrev-&gt;Curr.X == horzEdge-&gt;Bot.X &amp;&amp;
-        ePrev-&gt;Curr.Y == horzEdge-&gt;Bot.Y &amp;&amp; ePrev-&gt;WindDelta != 0 &amp;&amp;
-        (ePrev-&gt;OutIdx &gt;= 0 &amp;&amp; ePrev-&gt;Curr.Y &gt; ePrev-&gt;Top.Y &amp;&amp;
-        SlopesEqual(*horzEdge, *ePrev, m_UseFullRange)))
-      {
-        OutPt* op2 = AddOutPt(ePrev, horzEdge-&gt;Bot);
-        AddJoin(op1, op2, horzEdge-&gt;Top);
-      }
-      else if (eNext &amp;&amp; eNext-&gt;Curr.X == horzEdge-&gt;Bot.X &amp;&amp;
-        eNext-&gt;Curr.Y == horzEdge-&gt;Bot.Y &amp;&amp; eNext-&gt;WindDelta != 0 &amp;&amp;
-        eNext-&gt;OutIdx &gt;= 0 &amp;&amp; eNext-&gt;Curr.Y &gt; eNext-&gt;Top.Y &amp;&amp;
-        SlopesEqual(*horzEdge, *eNext, m_UseFullRange))
+      if (horzEdge-&gt;OutIdx &gt;= 0)
       {
-        OutPt* op2 = AddOutPt(eNext, horzEdge-&gt;Bot);
-        AddJoin(op1, op2, horzEdge-&gt;Top);
-      }
+        op1 = AddOutPt(horzEdge, horzEdge-&gt;Top);
+        UpdateEdgeIntoAEL(horzEdge);
+        if (horzEdge-&gt;WindDelta == 0)
+          return;
+        //nb: HorzEdge is no longer horizontal here
+        TEdge *ePrev = horzEdge-&gt;PrevInAEL;
+        TEdge *eNext = horzEdge-&gt;NextInAEL;
+        if (ePrev &amp;&amp; ePrev-&gt;Curr.X == horzEdge-&gt;Bot.X &amp;&amp;
+            ePrev-&gt;Curr.Y == horzEdge-&gt;Bot.Y &amp;&amp; ePrev-&gt;WindDelta != 0 &amp;&amp;
+            (ePrev-&gt;OutIdx &gt;= 0 &amp;&amp; ePrev-&gt;Curr.Y &gt; ePrev-&gt;Top.Y &amp;&amp;
+             SlopesEqual(*horzEdge, *ePrev, m_UseFullRange)))
+        {
+          OutPt *op2 = AddOutPt(ePrev, horzEdge-&gt;Bot);
+          AddJoin(op1, op2, horzEdge-&gt;Top);
+        } else if (eNext &amp;&amp; eNext-&gt;Curr.X == horzEdge-&gt;Bot.X &amp;&amp;
+                   eNext-&gt;Curr.Y == horzEdge-&gt;Bot.Y &amp;&amp; eNext-&gt;WindDelta != 0 &amp;&amp;
+                   eNext-&gt;OutIdx &gt;= 0 &amp;&amp; eNext-&gt;Curr.Y &gt; eNext-&gt;Top.Y &amp;&amp;
+                   SlopesEqual(*horzEdge, *eNext, m_UseFullRange))
+        {
+          OutPt *op2 = AddOutPt(eNext, horzEdge-&gt;Bot);
+          AddJoin(op1, op2, horzEdge-&gt;Top);
+        }
+      } else
+        UpdateEdgeIntoAEL(horzEdge);
+    } else
+    {
+      if (horzEdge-&gt;OutIdx &gt;= 0)
+        AddOutPt(horzEdge, horzEdge-&gt;Top);
+      DeleteFromAEL(horzEdge);
     }
-    else
-      UpdateEdgeIntoAEL(horzEdge); 
   }
-  else
-  {
-    if (horzEdge-&gt;OutIdx &gt;= 0) AddOutPt(horzEdge, horzEdge-&gt;Top);
-    DeleteFromAEL(horzEdge);
-  }
-}
 //------------------------------------------------------------------------------
 
-bool Clipper::ProcessIntersections(const cInt topY)
-{
-  if( !m_ActiveEdges ) return true;
-  try {
-    BuildIntersectList(topY);
-    size_t IlSize = m_IntersectList.size();
-    if (IlSize == 0) return true;
-    if (IlSize == 1 || FixupIntersectionOrder()) ProcessIntersectList();
-    else return false;
-  }
-  catch(...) 
+  bool Clipper::ProcessIntersections(const cInt topY)
   {
+    if (!m_ActiveEdges)
+      return true;
+    try
+    {
+      BuildIntersectList(topY);
+      size_t IlSize = m_IntersectList.size();
+      if (IlSize == 0)
+        return true;
+      if (IlSize == 1 || FixupIntersectionOrder())
+        ProcessIntersectList();
+      else
+        return false;
+    }
+    catch (...)
+    {
+      m_SortedEdges = 0;
+      DisposeIntersectNodes();
+      throw clipperException("ProcessIntersections error");
+    }
     m_SortedEdges = 0;
-    DisposeIntersectNodes();
-    throw clipperException("ProcessIntersections error");
+    return true;
   }
-  m_SortedEdges = 0;
-  return true;
-}
-//------------------------------------------------------------------------------
-
-void Clipper::DisposeIntersectNodes()
-{
-  for (size_t i = 0; i &lt; m_IntersectList.size(); ++i )
-    delete m_IntersectList[i];
-  m_IntersectList.clear();
-}
 //------------------------------------------------------------------------------
 
-void Clipper::BuildIntersectList(const cInt topY)
-{
-  if ( !m_ActiveEdges ) return;
-
-  //prepare for sorting ...
-  TEdge* e = m_ActiveEdges;
-  m_SortedEdges = e;
-  while( e )
+  void Clipper::DisposeIntersectNodes()
   {
-    e-&gt;PrevInSEL = e-&gt;PrevInAEL;
-    e-&gt;NextInSEL = e-&gt;NextInAEL;
-    e-&gt;Curr.X = TopX( *e, topY );
-    e = e-&gt;NextInAEL;
+    for (size_t i = 0; i &lt; m_IntersectList.size(); ++i)
+      delete m_IntersectList[i];
+    m_IntersectList.clear();
   }
+//------------------------------------------------------------------------------
 
-  //bubblesort ...
-  bool isModified;
-  do
+  void Clipper::BuildIntersectList(const cInt topY)
   {
-    isModified = false;
-    e = m_SortedEdges;
-    while( e-&gt;NextInSEL )
+    if (!m_ActiveEdges)
+      return;
+
+    //prepare for sorting ...
+    TEdge *e = m_ActiveEdges;
+    m_SortedEdges = e;
+    while (e)
     {
-      TEdge *eNext = e-&gt;NextInSEL;
-      IntPoint Pt;
-      if(e-&gt;Curr.X &gt; eNext-&gt;Curr.X)
+      e-&gt;PrevInSEL = e-&gt;PrevInAEL;
+      e-&gt;NextInSEL = e-&gt;NextInAEL;
+      e-&gt;Curr.X = TopX(*e, topY);
+      e = e-&gt;NextInAEL;
+    }
+
+    //bubblesort ...
+    bool isModified;
+    do
+    {
+      isModified = false;
+      e = m_SortedEdges;
+      while (e-&gt;NextInSEL)
       {
-        IntersectPoint(*e, *eNext, Pt);
-        if (Pt.Y &lt; topY) Pt = IntPoint(TopX(*e, topY), topY);
-        IntersectNode * newNode = new IntersectNode;
-        newNode-&gt;Edge1 = e;
-        newNode-&gt;Edge2 = eNext;
-        newNode-&gt;Pt = Pt;
-        m_IntersectList.push_back(newNode);
-
-        SwapPositionsInSEL(e, eNext);
-        isModified = true;
+        TEdge *eNext = e-&gt;NextInSEL;
+        IntPoint Pt;
+        if (e-&gt;Curr.X &gt; eNext-&gt;Curr.X)
+        {
+          IntersectPoint(*e, *eNext, Pt);
+          if (Pt.Y &lt; topY)
+            Pt = IntPoint(TopX(*e, topY), topY);
+          IntersectNode *newNode = new IntersectNode;
+          newNode-&gt;Edge1 = e;
+          newNode-&gt;Edge2 = eNext;
+          newNode-&gt;Pt = Pt;
+          m_IntersectList.push_back(newNode);
+
+          SwapPositionsInSEL(e, eNext);
+          isModified = true;
+        } else
+          e = eNext;
       }
+      if (e-&gt;PrevInSEL)
+        e-&gt;PrevInSEL-&gt;NextInSEL = 0;
       else
-        e = eNext;
-    }
-    if( e-&gt;PrevInSEL ) e-&gt;PrevInSEL-&gt;NextInSEL = 0;
-    else break;
+        break;
+    } while (isModified);
+    m_SortedEdges = 0; //important
   }
-  while ( isModified );
-  m_SortedEdges = 0; //important
-}
 //------------------------------------------------------------------------------
 
 
-void Clipper::ProcessIntersectList()
-{
-  for (size_t i = 0; i &lt; m_IntersectList.size(); ++i)
+  void Clipper::ProcessIntersectList()
   {
-    IntersectNode* iNode = m_IntersectList[i];
+    for (size_t i = 0; i &lt; m_IntersectList.size(); ++i)
     {
-      IntersectEdges( iNode-&gt;Edge1, iNode-&gt;Edge2, iNode-&gt;Pt);
-      SwapPositionsInAEL( iNode-&gt;Edge1 , iNode-&gt;Edge2 );
+      IntersectNode *iNode = m_IntersectList[i];
+      {
+        IntersectEdges(iNode-&gt;Edge1, iNode-&gt;Edge2, iNode-&gt;Pt);
+        SwapPositionsInAEL(iNode-&gt;Edge1, iNode-&gt;Edge2);
+      }
+      delete iNode;
     }
-    delete iNode;
+    m_IntersectList.clear();
   }
-  m_IntersectList.clear();
-}
-//------------------------------------------------------------------------------
-
-bool IntersectListSort(IntersectNode* node1, IntersectNode* node2)
-{
-  return node2-&gt;Pt.Y &lt; node1-&gt;Pt.Y;
-}
 //------------------------------------------------------------------------------
 
-inline bool EdgesAdjacent(const IntersectNode &amp;inode)
-{
-  return (inode.Edge1-&gt;NextInSEL == inode.Edge2) ||
-    (inode.Edge1-&gt;PrevInSEL == inode.Edge2);
-}
-//------------------------------------------------------------------------------
-
-bool Clipper::FixupIntersectionOrder()
-{
-  //pre-condition: intersections are sorted Bottom-most first.
-  //Now it's crucial that intersections are made only between adjacent edges,
-  //so to ensure this the order of intersections may need adjusting ...
-  CopyAELToSEL();
-  std::sort(m_IntersectList.begin(), m_IntersectList.end(), IntersectListSort);
-  size_t cnt = m_IntersectList.size();
-  for (size_t i = 0; i &lt; cnt; ++i) 
-  {
-    if (!EdgesAdjacent(*m_IntersectList[i]))
-    {
-      size_t j = i + 1;
-      while (j &lt; cnt &amp;&amp; !EdgesAdjacent(*m_IntersectList[j])) j++;
-      if (j == cnt)  return false;
-      std::swap(m_IntersectList[i], m_IntersectList[j]);
-    }
-    SwapPositionsInSEL(m_IntersectList[i]-&gt;Edge1, m_IntersectList[i]-&gt;Edge2);
+  bool IntersectListSort(IntersectNode *node1, IntersectNode *node2)
+  {
+    return node2-&gt;Pt.Y &lt; node1-&gt;Pt.Y;
   }
-  return true;
-}
 //------------------------------------------------------------------------------
 
-void Clipper::DoMaxima(TEdge *e)
-{
-  TEdge* eMaxPair = GetMaximaPairEx(e);
-  if (!eMaxPair)
+  inline bool EdgesAdjacent(const IntersectNode &amp;inode)
   {
-    if (e-&gt;OutIdx &gt;= 0)
-      AddOutPt(e, e-&gt;Top);
-    DeleteFromAEL(e);
-    return;
+    return (inode.Edge1-&gt;NextInSEL == inode.Edge2) ||
+           (inode.Edge1-&gt;PrevInSEL == inode.Edge2);
   }
+//------------------------------------------------------------------------------
 
-  TEdge* eNext = e-&gt;NextInAEL;
-  while(eNext &amp;&amp; eNext != eMaxPair)
+  bool Clipper::FixupIntersectionOrder()
   {
-    IntersectEdges(e, eNext, e-&gt;Top);
-    SwapPositionsInAEL(e, eNext);
-    eNext = e-&gt;NextInAEL;
+    //pre-condition: intersections are sorted Bottom-most first.
+    //Now it's crucial that intersections are made only between adjacent edges,
+    //so to ensure this the order of intersections may need adjusting ...
+    CopyAELToSEL();
+    std::sort(m_IntersectList.begin(), m_IntersectList.end(), IntersectListSort);
+    size_t cnt = m_IntersectList.size();
+    for (size_t i = 0; i &lt; cnt; ++i)
+    {
+      if (!EdgesAdjacent(*m_IntersectList[i]))
+      {
+        size_t j = i + 1;
+        while (j &lt; cnt &amp;&amp; !EdgesAdjacent(*m_IntersectList[j]))
+          j++;
+        if (j == cnt)
+          return false;
+        std::swap(m_IntersectList[i], m_IntersectList[j]);
+      }
+      SwapPositionsInSEL(m_IntersectList[i]-&gt;Edge1, m_IntersectList[i]-&gt;Edge2);
+    }
+    return true;
   }
+//------------------------------------------------------------------------------
 
-  if(e-&gt;OutIdx == Unassigned &amp;&amp; eMaxPair-&gt;OutIdx == Unassigned)
-  {
-    DeleteFromAEL(e);
-    DeleteFromAEL(eMaxPair);
-  }
-  else if( e-&gt;OutIdx &gt;= 0 &amp;&amp; eMaxPair-&gt;OutIdx &gt;= 0 )
-  {
-    if (e-&gt;OutIdx &gt;= 0) AddLocalMaxPoly(e, eMaxPair, e-&gt;Top);
-    DeleteFromAEL(e);
-    DeleteFromAEL(eMaxPair);
-  }
-#ifdef use_lines
-  else if (e-&gt;WindDelta == 0)
+  void Clipper::DoMaxima(TEdge *e)
   {
-    if (e-&gt;OutIdx &gt;= 0) 
+    TEdge *eMaxPair = GetMaximaPairEx(e);
+    if (!eMaxPair)
     {
-      AddOutPt(e, e-&gt;Top);
-      e-&gt;OutIdx = Unassigned;
+      if (e-&gt;OutIdx &gt;= 0)
+        AddOutPt(e, e-&gt;Top);
+      DeleteFromAEL(e);
+      return;
     }
-    DeleteFromAEL(e);
 
-    if (eMaxPair-&gt;OutIdx &gt;= 0)
+    TEdge *eNext = e-&gt;NextInAEL;
+    while (eNext &amp;&amp; eNext != eMaxPair)
     {
-      AddOutPt(eMaxPair, e-&gt;Top);
-      eMaxPair-&gt;OutIdx = Unassigned;
+      IntersectEdges(e, eNext, e-&gt;Top);
+      SwapPositionsInAEL(e, eNext);
+      eNext = e-&gt;NextInAEL;
     }
-    DeleteFromAEL(eMaxPair);
-  } 
-#endif
-  else throw clipperException("DoMaxima error");
-}
-//------------------------------------------------------------------------------
-
-void Clipper::ProcessEdgesAtTopOfScanbeam(const cInt topY)
-{
-  TEdge* e = m_ActiveEdges;
-  while( e )
-  {
-    //1. process maxima, treating them as if they're 'bent' horizontal edges,
-    //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.
-    bool IsMaximaEdge = IsMaxima(e, topY);
 
-    if(IsMaximaEdge)
+    if (e-&gt;OutIdx == Unassigned &amp;&amp; eMaxPair-&gt;OutIdx == Unassigned)
     {
-      TEdge* eMaxPair = GetMaximaPairEx(e);
-      IsMaximaEdge = (!eMaxPair || !IsHorizontal(*eMaxPair));
+      DeleteFromAEL(e);
+      DeleteFromAEL(eMaxPair);
+    } else if (e-&gt;OutIdx &gt;= 0 &amp;&amp; eMaxPair-&gt;OutIdx &gt;= 0)
+    {
+      if (e-&gt;OutIdx &gt;= 0)
+        AddLocalMaxPoly(e, eMaxPair, e-&gt;Top);
+      DeleteFromAEL(e);
+      DeleteFromAEL(eMaxPair);
     }
-
-    if(IsMaximaEdge)
+#ifdef use_lines
+    else if (e-&gt;WindDelta == 0)
     {
-      if (m_StrictSimple) m_Maxima.push_back(e-&gt;Top.X);
-      TEdge* ePrev = e-&gt;PrevInAEL;
-      DoMaxima(e);
-      if( !ePrev ) e = m_ActiveEdges;
-      else e = ePrev-&gt;NextInAEL;
+      if (e-&gt;OutIdx &gt;= 0)
+      {
+        AddOutPt(e, e-&gt;Top);
+        e-&gt;OutIdx = Unassigned;
+      }
+      DeleteFromAEL(e);
+
+      if (eMaxPair-&gt;OutIdx &gt;= 0)
+      {
+        AddOutPt(eMaxPair, e-&gt;Top);
+        eMaxPair-&gt;OutIdx = Unassigned;
+      }
+      DeleteFromAEL(eMaxPair);
     }
+#endif
     else
+      throw clipperException("DoMaxima error");
+  }
+//------------------------------------------------------------------------------
+
+  void Clipper::ProcessEdgesAtTopOfScanbeam(const cInt topY)
+  {
+    TEdge *e = m_ActiveEdges;
+    while (e)
     {
-      //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...
-      if (IsIntermediate(e, topY) &amp;&amp; IsHorizontal(*e-&gt;NextInLML))
+      //1. process maxima, treating them as if they're 'bent' horizontal edges,
+      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.
+      bool IsMaximaEdge = IsMaxima(e, topY);
+
+      if (IsMaximaEdge)
       {
-        UpdateEdgeIntoAEL(e);
-        if (e-&gt;OutIdx &gt;= 0)
-          AddOutPt(e, e-&gt;Bot);
-        AddEdgeToSEL(e);
-      } 
-      else
+        TEdge *eMaxPair = GetMaximaPairEx(e);
+        IsMaximaEdge = (!eMaxPair || !IsHorizontal(*eMaxPair));
+      }
+
+      if (IsMaximaEdge)
+      {
+        if (m_StrictSimple)
+          m_Maxima.push_back(e-&gt;Top.X);
+        TEdge *ePrev = e-&gt;PrevInAEL;
+        DoMaxima(e);
+        if (!ePrev)
+          e = m_ActiveEdges;
+        else
+          e = ePrev-&gt;NextInAEL;
+      } else
       {
-        e-&gt;Curr.X = TopX( *e, topY );
-        e-&gt;Curr.Y = topY;
+        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...
+        if (IsIntermediate(e, topY) &amp;&amp; IsHorizontal(*e-&gt;NextInLML))
+        {
+          UpdateEdgeIntoAEL(e);
+          if (e-&gt;OutIdx &gt;= 0)
+            AddOutPt(e, e-&gt;Bot);
+          AddEdgeToSEL(e);
+        } else
+        {
+          e-&gt;Curr.X = TopX(*e, topY);
+          e-&gt;Curr.Y = topY;
 #ifdef use_xyz
-		e-&gt;Curr.Z = topY == e-&gt;Top.Y ? e-&gt;Top.Z : (topY == e-&gt;Bot.Y ? e-&gt;Bot.Z : 0);
+          e-&gt;Curr.Z = topY == e-&gt;Top.Y ? e-&gt;Top.Z : (topY == e-&gt;Bot.Y ? e-&gt;Bot.Z : 0);
 #endif
-	  }
+        }
 
-      //When StrictlySimple and 'e' is being touched by another edge, then
-      //make sure both edges have a vertex here ...
-      if (m_StrictSimple)
-      {  
-        TEdge* ePrev = e-&gt;PrevInAEL;
-        if ((e-&gt;OutIdx &gt;= 0) &amp;&amp; (e-&gt;WindDelta != 0) &amp;&amp; ePrev &amp;&amp; (ePrev-&gt;OutIdx &gt;= 0) &amp;&amp;
-          (ePrev-&gt;Curr.X == e-&gt;Curr.X) &amp;&amp; (ePrev-&gt;WindDelta != 0))
+        //When StrictlySimple and 'e' is being touched by another edge, then
+        //make sure both edges have a vertex here ...
+        if (m_StrictSimple)
         {
-          IntPoint pt = e-&gt;Curr;
+          TEdge *ePrev = e-&gt;PrevInAEL;
+          if ((e-&gt;OutIdx &gt;= 0) &amp;&amp; (e-&gt;WindDelta != 0) &amp;&amp; ePrev &amp;&amp; (ePrev-&gt;OutIdx &gt;= 0) &amp;&amp;
+              (ePrev-&gt;Curr.X == e-&gt;Curr.X) &amp;&amp; (ePrev-&gt;WindDelta != 0))
+          {
+            IntPoint pt = e-&gt;Curr;
 #ifdef use_xyz
-          SetZ(pt, *ePrev, *e);
+            SetZ(pt, *ePrev, *e);
 #endif
-          OutPt* op = AddOutPt(ePrev, pt);
-          OutPt* op2 = AddOutPt(e, pt);
-          AddJoin(op, op2, pt); //StrictlySimple (type-3) join
+            OutPt *op = AddOutPt(ePrev, pt);
+            OutPt *op2 = AddOutPt(e, pt);
+            AddJoin(op, op2, pt); //StrictlySimple (type-3) join
+          }
         }
-      }
 
-      e = e-&gt;NextInAEL;
+        e = e-&gt;NextInAEL;
+      }
     }
-  }
 
-  //3. Process horizontals at the Top of the scanbeam ...
-  m_Maxima.sort();
-  ProcessHorizontals();
-  m_Maxima.clear();
+    //3. Process horizontals at the Top of the scanbeam ...
+    m_Maxima.sort();
+    ProcessHorizontals();
+    m_Maxima.clear();
 
-  //4. Promote intermediate vertices ...
-  e = m_ActiveEdges;
-  while(e)
-  {
-    if(IsIntermediate(e, topY))
+    //4. Promote intermediate vertices ...
+    e = m_ActiveEdges;
+    while (e)
     {
-      OutPt* op = 0;
-      if( e-&gt;OutIdx &gt;= 0 ) 
-        op = AddOutPt(e, e-&gt;Top);
-      UpdateEdgeIntoAEL(e);
-
-      //if output polygons share an edge, they'll need joining later ...
-      TEdge* ePrev = e-&gt;PrevInAEL;
-      TEdge* eNext = e-&gt;NextInAEL;
-      if (ePrev &amp;&amp; ePrev-&gt;Curr.X == e-&gt;Bot.X &amp;&amp;
-        ePrev-&gt;Curr.Y == e-&gt;Bot.Y &amp;&amp; op &amp;&amp;
-        ePrev-&gt;OutIdx &gt;= 0 &amp;&amp; ePrev-&gt;Curr.Y &gt; ePrev-&gt;Top.Y &amp;&amp;
-        SlopesEqual(e-&gt;Curr, e-&gt;Top, ePrev-&gt;Curr, ePrev-&gt;Top, m_UseFullRange) &amp;&amp;
-        (e-&gt;WindDelta != 0) &amp;&amp; (ePrev-&gt;WindDelta != 0))
+      if (IsIntermediate(e, topY))
       {
-        OutPt* op2 = AddOutPt(ePrev, e-&gt;Bot);
-        AddJoin(op, op2, e-&gt;Top);
-      }
-      else if (eNext &amp;&amp; eNext-&gt;Curr.X == e-&gt;Bot.X &amp;&amp;
-        eNext-&gt;Curr.Y == e-&gt;Bot.Y &amp;&amp; op &amp;&amp;
-        eNext-&gt;OutIdx &gt;= 0 &amp;&amp; eNext-&gt;Curr.Y &gt; eNext-&gt;Top.Y &amp;&amp;
-        SlopesEqual(e-&gt;Curr, e-&gt;Top, eNext-&gt;Curr, eNext-&gt;Top, m_UseFullRange) &amp;&amp;
-        (e-&gt;WindDelta != 0) &amp;&amp; (eNext-&gt;WindDelta != 0))
-      {
-        OutPt* op2 = AddOutPt(eNext, e-&gt;Bot);
-        AddJoin(op, op2, e-&gt;Top);
+        OutPt *op = 0;
+        if (e-&gt;OutIdx &gt;= 0)
+          op = AddOutPt(e, e-&gt;Top);
+        UpdateEdgeIntoAEL(e);
+
+        //if output polygons share an edge, they'll need joining later ...
+        TEdge *ePrev = e-&gt;PrevInAEL;
+        TEdge *eNext = e-&gt;NextInAEL;
+        if (ePrev &amp;&amp; ePrev-&gt;Curr.X == e-&gt;Bot.X &amp;&amp;
+            ePrev-&gt;Curr.Y == e-&gt;Bot.Y &amp;&amp; op &amp;&amp;
+            ePrev-&gt;OutIdx &gt;= 0 &amp;&amp; ePrev-&gt;Curr.Y &gt; ePrev-&gt;Top.Y &amp;&amp;
+            SlopesEqual(e-&gt;Curr, e-&gt;Top, ePrev-&gt;Curr, ePrev-&gt;Top, m_UseFullRange) &amp;&amp;
+            (e-&gt;WindDelta != 0) &amp;&amp; (ePrev-&gt;WindDelta != 0))
+        {
+          OutPt *op2 = AddOutPt(ePrev, e-&gt;Bot);
+          AddJoin(op, op2, e-&gt;Top);
+        } else if (eNext &amp;&amp; eNext-&gt;Curr.X == e-&gt;Bot.X &amp;&amp;
+                   eNext-&gt;Curr.Y == e-&gt;Bot.Y &amp;&amp; op &amp;&amp;
+                   eNext-&gt;OutIdx &gt;= 0 &amp;&amp; eNext-&gt;Curr.Y &gt; eNext-&gt;Top.Y &amp;&amp;
+                   SlopesEqual(e-&gt;Curr, e-&gt;Top, eNext-&gt;Curr, eNext-&gt;Top, m_UseFullRange) &amp;&amp;
+                   (e-&gt;WindDelta != 0) &amp;&amp; (eNext-&gt;WindDelta != 0))
+        {
+          OutPt *op2 = AddOutPt(eNext, e-&gt;Bot);
+          AddJoin(op, op2, e-&gt;Top);
+        }
       }
+      e = e-&gt;NextInAEL;
     }
-    e = e-&gt;NextInAEL;
   }
-}
 //------------------------------------------------------------------------------
 
-void Clipper::FixupOutPolyline(OutRec &amp;outrec)
-{
-  OutPt *pp = outrec.Pts;
-  OutPt *lastPP = pp-&gt;Prev;
-  while (pp != lastPP)
-  {
-    pp = pp-&gt;Next;
-    if (pp-&gt;Pt == pp-&gt;Prev-&gt;Pt)
-    {
-      if (pp == lastPP) lastPP = pp-&gt;Prev;
-      OutPt *tmpPP = pp-&gt;Prev;
-      tmpPP-&gt;Next = pp-&gt;Next;
-      pp-&gt;Next-&gt;Prev = tmpPP;
-      delete pp;
-      pp = tmpPP;
+  void Clipper::FixupOutPolyline(OutRec &amp;outrec)
+  {
+    OutPt *pp = outrec.Pts;
+    OutPt *lastPP = pp-&gt;Prev;
+    while (pp != lastPP)
+    {
+      pp = pp-&gt;Next;
+      if (pp-&gt;Pt == pp-&gt;Prev-&gt;Pt)
+      {
+        if (pp == lastPP)
+          lastPP = pp-&gt;Prev;
+        OutPt *tmpPP = pp-&gt;Prev;
+        tmpPP-&gt;Next = pp-&gt;Next;
+        pp-&gt;Next-&gt;Prev = tmpPP;
+        delete pp;
+        pp = tmpPP;
+      }
     }
-  }
 
-  if (pp == pp-&gt;Prev)
-  {
-    DisposeOutPts(pp);
-    outrec.Pts = 0;
-    return;
+    if (pp == pp-&gt;Prev)
+    {
+      DisposeOutPts(pp);
+      outrec.Pts = 0;
+      return;
+    }
   }
-}
 //------------------------------------------------------------------------------
 
-void Clipper::FixupOutPolygon(OutRec &amp;outrec)
-{
+  void Clipper::FixupOutPolygon(OutRec &amp;outrec)
+  {
     //FixupOutPolygon() - removes duplicate points and simplifies consecutive
     //parallel edges by removing the middle vertex.
     OutPt *lastOK = 0;
@@ -3151,1479 +3377,1538 @@ void Clipper::FixupOutPolygon(OutRec &amp;outrec)
 
     for (;;)
     {
-        if (pp-&gt;Prev == pp || pp-&gt;Prev == pp-&gt;Next)
-        {
-            DisposeOutPts(pp);
-            outrec.Pts = 0;
-            return;
-        }
+      if (pp-&gt;Prev == pp || pp-&gt;Prev == pp-&gt;Next)
+      {
+        DisposeOutPts(pp);
+        outrec.Pts = 0;
+        return;
+      }
 
-        //test for duplicate points and collinear edges ...
-        if ((pp-&gt;Pt == pp-&gt;Next-&gt;Pt) || (pp-&gt;Pt == pp-&gt;Prev-&gt;Pt) ||
-            (SlopesEqual(pp-&gt;Prev-&gt;Pt, pp-&gt;Pt, pp-&gt;Next-&gt;Pt, m_UseFullRange) &amp;&amp;
-            (!preserveCol || !Pt2IsBetweenPt1AndPt3(pp-&gt;Prev-&gt;Pt, pp-&gt;Pt, pp-&gt;Next-&gt;Pt))))
-        {
-            lastOK = 0;
-            OutPt *tmp = pp;
-            pp-&gt;Prev-&gt;Next = pp-&gt;Next;
-            pp-&gt;Next-&gt;Prev = pp-&gt;Prev;
-            pp = pp-&gt;Prev;
-            delete tmp;
-        }
-        else if (pp == lastOK) break;
-        else
-        {
-            if (!lastOK) lastOK = pp;
-            pp = pp-&gt;Next;
-        }
+      //test for duplicate points and collinear edges ...
+      if ((pp-&gt;Pt == pp-&gt;Next-&gt;Pt) || (pp-&gt;Pt == pp-&gt;Prev-&gt;Pt) ||
+          (SlopesEqual(pp-&gt;Prev-&gt;Pt, pp-&gt;Pt, pp-&gt;Next-&gt;Pt, m_UseFullRange) &amp;&amp;
+           (!preserveCol || !Pt2IsBetweenPt1AndPt3(pp-&gt;Prev-&gt;Pt, pp-&gt;Pt, pp-&gt;Next-&gt;Pt))))
+      {
+        lastOK = 0;
+        OutPt *tmp = pp;
+        pp-&gt;Prev-&gt;Next = pp-&gt;Next;
+        pp-&gt;Next-&gt;Prev = pp-&gt;Prev;
+        pp = pp-&gt;Prev;
+        delete tmp;
+      } else if (pp == lastOK)
+        break;
+      else
+      {
+        if (!lastOK)
+          lastOK = pp;
+        pp = pp-&gt;Next;
+      }
     }
     outrec.Pts = pp;
-}
+  }
 //------------------------------------------------------------------------------
 
-int PointCount(OutPt *Pts)
-{
-    if (!Pts) return 0;
+  int PointCount(OutPt *Pts)
+  {
+    if (!Pts)
+      return 0;
     int result = 0;
-    OutPt* p = Pts;
+    OutPt *p = Pts;
     do
     {
-        result++;
-        p = p-&gt;Next;
-    }
-    while (p != Pts);
+      result++;
+      p = p-&gt;Next;
+    } while (p != Pts);
     return result;
-}
+  }
 //------------------------------------------------------------------------------
 
-void Clipper::BuildResult(Paths &amp;polys)
-{
-  polys.reserve(m_PolyOuts.size());
-  for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); ++i)
-  {
-    if (!m_PolyOuts[i]-&gt;Pts) continue;
-    Path pg;
-    OutPt* p = m_PolyOuts[i]-&gt;Pts-&gt;Prev;
-    int cnt = PointCount(p);
-    if (cnt &lt; 2) continue;
-    pg.reserve(cnt);
-    for (int i = 0; i &lt; cnt; ++i)
-    {
-      pg.push_back(p-&gt;Pt);
-      p = p-&gt;Prev;
+  void Clipper::BuildResult(Paths &amp;polys)
+  {
+    polys.reserve(m_PolyOuts.size());
+    for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); ++i)
+    {
+      if (!m_PolyOuts[i]-&gt;Pts)
+        continue;
+      Path pg;
+      OutPt *p = m_PolyOuts[i]-&gt;Pts-&gt;Prev;
+      int cnt = PointCount(p);
+      if (cnt &lt; 2)
+        continue;
+      pg.reserve(cnt);
+      for (int i = 0; i &lt; cnt; ++i)
+      {
+        pg.push_back(p-&gt;Pt);
+        p = p-&gt;Prev;
+      }
+      polys.push_back(pg);
     }
-    polys.push_back(pg);
   }
-}
 //------------------------------------------------------------------------------
 
-void Clipper::BuildResult2(PolyTree&amp; polytree)
-{
+  void Clipper::BuildResult2(PolyTree &amp;polytree)
+  {
     polytree.Clear();
     polytree.AllNodes.reserve(m_PolyOuts.size());
     //add each output polygon/contour to polytree ...
     for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); i++)
     {
-        OutRec* outRec = m_PolyOuts[i];
-        int cnt = PointCount(outRec-&gt;Pts);
-        if ((outRec-&gt;IsOpen &amp;&amp; cnt &lt; 2) || (!outRec-&gt;IsOpen &amp;&amp; cnt &lt; 3)) continue;
-        FixHoleLinkage(*outRec);
-        PolyNode* pn = new PolyNode();
-        //nb: polytree takes ownership of all the PolyNodes
-        polytree.AllNodes.push_back(pn);
-        outRec-&gt;PolyNd = pn;
-        pn-&gt;Parent = 0;
-        pn-&gt;Index = 0;
-        pn-&gt;Contour.reserve(cnt);
-        OutPt *op = outRec-&gt;Pts-&gt;Prev;
-        for (int j = 0; j &lt; cnt; j++)
-        {
-            pn-&gt;Contour.push_back(op-&gt;Pt);
-            op = op-&gt;Prev;
-        }
+      OutRec *outRec = m_PolyOuts[i];
+      int cnt = PointCount(outRec-&gt;Pts);
+      if ((outRec-&gt;IsOpen &amp;&amp; cnt &lt; 2) || (!outRec-&gt;IsOpen &amp;&amp; cnt &lt; 3))
+        continue;
+      FixHoleLinkage(*outRec);
+      PolyNode *pn = new PolyNode();
+      //nb: polytree takes ownership of all the PolyNodes
+      polytree.AllNodes.push_back(pn);
+      outRec-&gt;PolyNd = pn;
+      pn-&gt;Parent = 0;
+      pn-&gt;Index = 0;
+      pn-&gt;Contour.reserve(cnt);
+      OutPt *op = outRec-&gt;Pts-&gt;Prev;
+      for (int j = 0; j &lt; cnt; j++)
+      {
+        pn-&gt;Contour.push_back(op-&gt;Pt);
+        op = op-&gt;Prev;
+      }
     }
 
     //fixup PolyNode links etc ...
     polytree.Childs.reserve(m_PolyOuts.size());
     for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); i++)
     {
-        OutRec* outRec = m_PolyOuts[i];
-        if (!outRec-&gt;PolyNd) continue;
-        if (outRec-&gt;IsOpen) 
-        {
-          outRec-&gt;PolyNd-&gt;m_IsOpen = true;
-          polytree.AddChild(*outRec-&gt;PolyNd);
-        }
-        else if (outRec-&gt;FirstLeft &amp;&amp; outRec-&gt;FirstLeft-&gt;PolyNd) 
-          outRec-&gt;FirstLeft-&gt;PolyNd-&gt;AddChild(*outRec-&gt;PolyNd);
-        else
-          polytree.AddChild(*outRec-&gt;PolyNd);
+      OutRec *outRec = m_PolyOuts[i];
+      if (!outRec-&gt;PolyNd)
+        continue;
+      if (outRec-&gt;IsOpen)
+      {
+        outRec-&gt;PolyNd-&gt;m_IsOpen = true;
+        polytree.AddChild(*outRec-&gt;PolyNd);
+      } else if (outRec-&gt;FirstLeft &amp;&amp; outRec-&gt;FirstLeft-&gt;PolyNd)
+        outRec-&gt;FirstLeft-&gt;PolyNd-&gt;AddChild(*outRec-&gt;PolyNd);
+      else
+        polytree.AddChild(*outRec-&gt;PolyNd);
     }
-}
-//------------------------------------------------------------------------------
-
-void SwapIntersectNodes(IntersectNode &amp;int1, IntersectNode &amp;int2)
-{
-  //just swap the contents (because fIntersectNodes is a single-linked-list)
-  IntersectNode inode = int1; //gets a copy of Int1
-  int1.Edge1 = int2.Edge1;
-  int1.Edge2 = int2.Edge2;
-  int1.Pt = int2.Pt;
-  int2.Edge1 = inode.Edge1;
-  int2.Edge2 = inode.Edge2;
-  int2.Pt = inode.Pt;
-}
+  }
 //------------------------------------------------------------------------------
 
-inline bool E2InsertsBeforeE1(TEdge &amp;e1, TEdge &amp;e2)
-{
-  if (e2.Curr.X == e1.Curr.X) 
+  void SwapIntersectNodes(IntersectNode &amp;int1, IntersectNode &amp;int2)
   {
-    if (e2.Top.Y &gt; e1.Top.Y)
-      return e2.Top.X &lt; TopX(e1, e2.Top.Y); 
-      else return e1.Top.X &gt; TopX(e2, e1.Top.Y);
-  } 
-  else return e2.Curr.X &lt; e1.Curr.X;
-}
+    //just swap the contents (because fIntersectNodes is a single-linked-list)
+    IntersectNode inode = int1; //gets a copy of Int1
+    int1.Edge1 = int2.Edge1;
+    int1.Edge2 = int2.Edge2;
+    int1.Pt = int2.Pt;
+    int2.Edge1 = inode.Edge1;
+    int2.Edge2 = inode.Edge2;
+    int2.Pt = inode.Pt;
+  }
 //------------------------------------------------------------------------------
 
-bool GetOverlap(const cInt a1, const cInt a2, const cInt b1, const cInt b2, 
-    cInt&amp; Left, cInt&amp; Right)
-{
-  if (a1 &lt; a2)
-  {
-    if (b1 &lt; b2) {Left = std::max(a1,b1); Right = std::min(a2,b2);}
-    else {Left = std::max(a1,b2); Right = std::min(a2,b1);}
-  } 
-  else
+  inline bool E2InsertsBeforeE1(TEdge &amp;e1, TEdge &amp;e2)
   {
-    if (b1 &lt; b2) {Left = std::max(a2,b1); Right = std::min(a1,b2);}
-    else {Left = std::max(a2,b2); Right = std::min(a1,b1);}
+    if (e2.Curr.X == e1.Curr.X)
+    {
+      if (e2.Top.Y &gt; e1.Top.Y)
+        return e2.Top.X &lt; TopX(e1, e2.Top.Y);
+      else
+        return e1.Top.X &gt; TopX(e2, e1.Top.Y);
+    } else
+      return e2.Curr.X &lt; e1.Curr.X;
   }
-  return Left &lt; Right;
-}
 //------------------------------------------------------------------------------
 
-inline void UpdateOutPtIdxs(OutRec&amp; outrec)
-{  
-  OutPt* op = outrec.Pts;
-  do
+  bool GetOverlap(const cInt a1, const cInt a2, const cInt b1, const cInt b2,
+                  cInt &amp;Left, cInt &amp;Right)
   {
-    op-&gt;Idx = outrec.Idx;
-    op = op-&gt;Prev;
+    if (a1 &lt; a2)
+    {
+      if (b1 &lt; b2)
+      {
+        Left = std::max(a1, b1);
+        Right = std::min(a2, b2);
+      } else
+      {
+        Left = std::max(a1, b2);
+        Right = std::min(a2, b1);
+      }
+    } else
+    {
+      if (b1 &lt; b2)
+      {
+        Left = std::max(a2, b1);
+        Right = std::min(a1, b2);
+      } else
+      {
+        Left = std::max(a2, b2);
+        Right = std::min(a1, b1);
+      }
+    }
+    return Left &lt; Right;
   }
-  while(op != outrec.Pts);
-}
 //------------------------------------------------------------------------------
 
-void Clipper::InsertEdgeIntoAEL(TEdge *edge, TEdge* startEdge)
-{
-  if(!m_ActiveEdges)
+  inline void UpdateOutPtIdxs(OutRec &amp;outrec)
   {
-    edge-&gt;PrevInAEL = 0;
-    edge-&gt;NextInAEL = 0;
-    m_ActiveEdges = edge;
+    OutPt *op = outrec.Pts;
+    do
+    {
+      op-&gt;Idx = outrec.Idx;
+      op = op-&gt;Prev;
+    } while (op != outrec.Pts);
   }
-  else if(!startEdge &amp;&amp; E2InsertsBeforeE1(*m_ActiveEdges, *edge))
+//------------------------------------------------------------------------------
+
+  void Clipper::InsertEdgeIntoAEL(TEdge *edge, TEdge *startEdge)
   {
+    if (!m_ActiveEdges)
+    {
+      edge-&gt;PrevInAEL = 0;
+      edge-&gt;NextInAEL = 0;
+      m_ActiveEdges = edge;
+    } else if (!startEdge &amp;&amp; E2InsertsBeforeE1(*m_ActiveEdges, *edge))
+    {
       edge-&gt;PrevInAEL = 0;
       edge-&gt;NextInAEL = m_ActiveEdges;
       m_ActiveEdges-&gt;PrevInAEL = edge;
       m_ActiveEdges = edge;
-  } 
-  else
-  {
-    if(!startEdge) startEdge = m_ActiveEdges;
-    while(startEdge-&gt;NextInAEL  &amp;&amp; 
-      !E2InsertsBeforeE1(*startEdge-&gt;NextInAEL , *edge))
+    } else
+    {
+      if (!startEdge)
+        startEdge = m_ActiveEdges;
+      while (startEdge-&gt;NextInAEL &amp;&amp;
+             !E2InsertsBeforeE1(*startEdge-&gt;NextInAEL, *edge))
         startEdge = startEdge-&gt;NextInAEL;
-    edge-&gt;NextInAEL = startEdge-&gt;NextInAEL;
-    if(startEdge-&gt;NextInAEL) startEdge-&gt;NextInAEL-&gt;PrevInAEL = edge;
-    edge-&gt;PrevInAEL = startEdge;
-    startEdge-&gt;NextInAEL = edge;
+      edge-&gt;NextInAEL = startEdge-&gt;NextInAEL;
+      if (startEdge-&gt;NextInAEL)
+        startEdge-&gt;NextInAEL-&gt;PrevInAEL = edge;
+      edge-&gt;PrevInAEL = startEdge;
+      startEdge-&gt;NextInAEL = edge;
+    }
   }
-}
 //----------------------------------------------------------------------
 
-OutPt* DupOutPt(OutPt* outPt, bool InsertAfter)
-{
-  OutPt* result = new OutPt;
-  result-&gt;Pt = outPt-&gt;Pt;
-  result-&gt;Idx = outPt-&gt;Idx;
-  if (InsertAfter)
-  {
-    result-&gt;Next = outPt-&gt;Next;
-    result-&gt;Prev = outPt;
-    outPt-&gt;Next-&gt;Prev = result;
-    outPt-&gt;Next = result;
-  } 
-  else
-  {
-    result-&gt;Prev = outPt-&gt;Prev;
-    result-&gt;Next = outPt;
-    outPt-&gt;Prev-&gt;Next = result;
-    outPt-&gt;Prev = result;
-  }
-  return result;
-}
-//------------------------------------------------------------------------------
-
-bool JoinHorz(OutPt* op1, OutPt* op1b, OutPt* op2, OutPt* op2b,
-  const IntPoint Pt, bool DiscardLeft)
-{
-  Direction Dir1 = (op1-&gt;Pt.X &gt; op1b-&gt;Pt.X ? dRightToLeft : dLeftToRight);
-  Direction Dir2 = (op2-&gt;Pt.X &gt; op2b-&gt;Pt.X ? dRightToLeft : dLeftToRight);
-  if (Dir1 == Dir2) return false;
-
-  //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we
-  //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)
-  //So, to facilitate this while inserting Op1b and Op2b ...
-  //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,
-  //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)
-  if (Dir1 == dLeftToRight) 
-  {
-    while (op1-&gt;Next-&gt;Pt.X &lt;= Pt.X &amp;&amp; 
-      op1-&gt;Next-&gt;Pt.X &gt;= op1-&gt;Pt.X &amp;&amp; op1-&gt;Next-&gt;Pt.Y == Pt.Y)  
-        op1 = op1-&gt;Next;
-    if (DiscardLeft &amp;&amp; (op1-&gt;Pt.X != Pt.X)) op1 = op1-&gt;Next;
-    op1b = DupOutPt(op1, !DiscardLeft);
-    if (op1b-&gt;Pt != Pt) 
+  OutPt *DupOutPt(OutPt *outPt, bool InsertAfter)
+  {
+    OutPt *result = new OutPt;
+    result-&gt;Pt = outPt-&gt;Pt;
+    result-&gt;Idx = outPt-&gt;Idx;
+    if (InsertAfter)
     {
-      op1 = op1b;
-      op1-&gt;Pt = Pt;
-      op1b = DupOutPt(op1, !DiscardLeft);
+      result-&gt;Next = outPt-&gt;Next;
+      result-&gt;Prev = outPt;
+      outPt-&gt;Next-&gt;Prev = result;
+      outPt-&gt;Next = result;
+    } else
+    {
+      result-&gt;Prev = outPt-&gt;Prev;
+      result-&gt;Next = outPt;
+      outPt-&gt;Prev-&gt;Next = result;
+      outPt-&gt;Prev = result;
     }
-  } 
-  else
+    return result;
+  }
+//------------------------------------------------------------------------------
+
+  bool JoinHorz(OutPt *op1, OutPt *op1b, OutPt *op2, OutPt *op2b,
+                const IntPoint Pt, bool DiscardLeft)
   {
-    while (op1-&gt;Next-&gt;Pt.X &gt;= Pt.X &amp;&amp; 
-      op1-&gt;Next-&gt;Pt.X &lt;= op1-&gt;Pt.X &amp;&amp; op1-&gt;Next-&gt;Pt.Y == Pt.Y) 
+    Direction Dir1 = (op1-&gt;Pt.X &gt; op1b-&gt;Pt.X ? dRightToLeft : dLeftToRight);
+    Direction Dir2 = (op2-&gt;Pt.X &gt; op2b-&gt;Pt.X ? dRightToLeft : dLeftToRight);
+    if (Dir1 == Dir2)
+      return false;
+
+    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we
+    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)
+    //So, to facilitate this while inserting Op1b and Op2b ...
+    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,
+    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)
+    if (Dir1 == dLeftToRight)
+    {
+      while (op1-&gt;Next-&gt;Pt.X &lt;= Pt.X &amp;&amp;
+             op1-&gt;Next-&gt;Pt.X &gt;= op1-&gt;Pt.X &amp;&amp; op1-&gt;Next-&gt;Pt.Y == Pt.Y)
         op1 = op1-&gt;Next;
-    if (!DiscardLeft &amp;&amp; (op1-&gt;Pt.X != Pt.X)) op1 = op1-&gt;Next;
-    op1b = DupOutPt(op1, DiscardLeft);
-    if (op1b-&gt;Pt != Pt)
+      if (DiscardLeft &amp;&amp; (op1-&gt;Pt.X != Pt.X))
+        op1 = op1-&gt;Next;
+      op1b = DupOutPt(op1, !DiscardLeft);
+      if (op1b-&gt;Pt != Pt)
+      {
+        op1 = op1b;
+        op1-&gt;Pt = Pt;
+        op1b = DupOutPt(op1, !DiscardLeft);
+      }
+    } else
     {
-      op1 = op1b;
-      op1-&gt;Pt = Pt;
+      while (op1-&gt;Next-&gt;Pt.X &gt;= Pt.X &amp;&amp;
+             op1-&gt;Next-&gt;Pt.X &lt;= op1-&gt;Pt.X &amp;&amp; op1-&gt;Next-&gt;Pt.Y == Pt.Y)
+        op1 = op1-&gt;Next;
+      if (!DiscardLeft &amp;&amp; (op1-&gt;Pt.X != Pt.X))
+        op1 = op1-&gt;Next;
       op1b = DupOutPt(op1, DiscardLeft);
+      if (op1b-&gt;Pt != Pt)
+      {
+        op1 = op1b;
+        op1-&gt;Pt = Pt;
+        op1b = DupOutPt(op1, DiscardLeft);
+      }
     }
-  }
 
-  if (Dir2 == dLeftToRight)
-  {
-    while (op2-&gt;Next-&gt;Pt.X &lt;= Pt.X &amp;&amp; 
-      op2-&gt;Next-&gt;Pt.X &gt;= op2-&gt;Pt.X &amp;&amp; op2-&gt;Next-&gt;Pt.Y == Pt.Y)
-        op2 = op2-&gt;Next;
-    if (DiscardLeft &amp;&amp; (op2-&gt;Pt.X != Pt.X)) op2 = op2-&gt;Next;
-    op2b = DupOutPt(op2, !DiscardLeft);
-    if (op2b-&gt;Pt != Pt)
+    if (Dir2 == dLeftToRight)
     {
-      op2 = op2b;
-      op2-&gt;Pt = Pt;
-      op2b = DupOutPt(op2, !DiscardLeft);
-    };
-  } else
-  {
-    while (op2-&gt;Next-&gt;Pt.X &gt;= Pt.X &amp;&amp; 
-      op2-&gt;Next-&gt;Pt.X &lt;= op2-&gt;Pt.X &amp;&amp; op2-&gt;Next-&gt;Pt.Y == Pt.Y) 
+      while (op2-&gt;Next-&gt;Pt.X &lt;= Pt.X &amp;&amp;
+             op2-&gt;Next-&gt;Pt.X &gt;= op2-&gt;Pt.X &amp;&amp; op2-&gt;Next-&gt;Pt.Y == Pt.Y)
+        op2 = op2-&gt;Next;
+      if (DiscardLeft &amp;&amp; (op2-&gt;Pt.X != Pt.X))
         op2 = op2-&gt;Next;
-    if (!DiscardLeft &amp;&amp; (op2-&gt;Pt.X != Pt.X)) op2 = op2-&gt;Next;
-    op2b = DupOutPt(op2, DiscardLeft);
-    if (op2b-&gt;Pt != Pt)
+      op2b = DupOutPt(op2, !DiscardLeft);
+      if (op2b-&gt;Pt != Pt)
+      {
+        op2 = op2b;
+        op2-&gt;Pt = Pt;
+        op2b = DupOutPt(op2, !DiscardLeft);
+      };
+    } else
     {
-      op2 = op2b;
-      op2-&gt;Pt = Pt;
+      while (op2-&gt;Next-&gt;Pt.X &gt;= Pt.X &amp;&amp;
+             op2-&gt;Next-&gt;Pt.X &lt;= op2-&gt;Pt.X &amp;&amp; op2-&gt;Next-&gt;Pt.Y == Pt.Y)
+        op2 = op2-&gt;Next;
+      if (!DiscardLeft &amp;&amp; (op2-&gt;Pt.X != Pt.X))
+        op2 = op2-&gt;Next;
       op2b = DupOutPt(op2, DiscardLeft);
+      if (op2b-&gt;Pt != Pt)
+      {
+        op2 = op2b;
+        op2-&gt;Pt = Pt;
+        op2b = DupOutPt(op2, DiscardLeft);
+      };
     };
-  };
-
-  if ((Dir1 == dLeftToRight) == DiscardLeft)
-  {
-    op1-&gt;Prev = op2;
-    op2-&gt;Next = op1;
-    op1b-&gt;Next = op2b;
-    op2b-&gt;Prev = op1b;
-  }
-  else
-  {
-    op1-&gt;Next = op2;
-    op2-&gt;Prev = op1;
-    op1b-&gt;Prev = op2b;
-    op2b-&gt;Next = op1b;
-  }
-  return true;
-}
-//------------------------------------------------------------------------------
 
-bool Clipper::JoinPoints(Join *j, OutRec* outRec1, OutRec* outRec2)
-{
-  OutPt *op1 = j-&gt;OutPt1, *op1b;
-  OutPt *op2 = j-&gt;OutPt2, *op2b;
-
-  //There are 3 kinds of joins for output polygons ...
-  //1. Horizontal joins where Join.OutPt1 &amp; Join.OutPt2 are vertices anywhere
-  //along (horizontal) collinear edges (&amp; Join.OffPt is on the same horizontal).
-  //2. Non-horizontal joins where Join.OutPt1 &amp; Join.OutPt2 are at the same
-  //location at the Bottom of the overlapping segment (&amp; Join.OffPt is above).
-  //3. StrictSimple joins where edges touch but are not collinear and where
-  //Join.OutPt1, Join.OutPt2 &amp; Join.OffPt all share the same point.
-  bool isHorizontal = (j-&gt;OutPt1-&gt;Pt.Y == j-&gt;OffPt.Y);
-
-  if (isHorizontal  &amp;&amp; (j-&gt;OffPt == j-&gt;OutPt1-&gt;Pt) &amp;&amp;
-  (j-&gt;OffPt == j-&gt;OutPt2-&gt;Pt))
-  {
-    //Strictly Simple join ...
-    if (outRec1 != outRec2) return false;
-    op1b = j-&gt;OutPt1-&gt;Next;
-    while (op1b != op1 &amp;&amp; (op1b-&gt;Pt == j-&gt;OffPt)) 
-      op1b = op1b-&gt;Next;
-    bool reverse1 = (op1b-&gt;Pt.Y &gt; j-&gt;OffPt.Y);
-    op2b = j-&gt;OutPt2-&gt;Next;
-    while (op2b != op2 &amp;&amp; (op2b-&gt;Pt == j-&gt;OffPt)) 
-      op2b = op2b-&gt;Next;
-    bool reverse2 = (op2b-&gt;Pt.Y &gt; j-&gt;OffPt.Y);
-    if (reverse1 == reverse2) return false;
-    if (reverse1)
-    {
-      op1b = DupOutPt(op1, false);
-      op2b = DupOutPt(op2, true);
+    if ((Dir1 == dLeftToRight) == DiscardLeft)
+    {
       op1-&gt;Prev = op2;
       op2-&gt;Next = op1;
       op1b-&gt;Next = op2b;
       op2b-&gt;Prev = op1b;
-      j-&gt;OutPt1 = op1;
-      j-&gt;OutPt2 = op1b;
-      return true;
     } else
     {
-      op1b = DupOutPt(op1, true);
-      op2b = DupOutPt(op2, false);
       op1-&gt;Next = op2;
       op2-&gt;Prev = op1;
       op1b-&gt;Prev = op2b;
       op2b-&gt;Next = op1b;
-      j-&gt;OutPt1 = op1;
-      j-&gt;OutPt2 = op1b;
-      return true;
     }
-  } 
-  else if (isHorizontal)
-  {
-    //treat horizontal joins differently to non-horizontal joins since with
-    //them we're not yet sure where the overlapping is. OutPt1.Pt &amp; OutPt2.Pt
-    //may be anywhere along the horizontal edge.
-    op1b = op1;
-    while (op1-&gt;Prev-&gt;Pt.Y == op1-&gt;Pt.Y &amp;&amp; op1-&gt;Prev != op1b &amp;&amp; op1-&gt;Prev != op2)
-      op1 = op1-&gt;Prev;
-    while (op1b-&gt;Next-&gt;Pt.Y == op1b-&gt;Pt.Y &amp;&amp; op1b-&gt;Next != op1 &amp;&amp; op1b-&gt;Next != op2)
-      op1b = op1b-&gt;Next;
-    if (op1b-&gt;Next == op1 || op1b-&gt;Next == op2) return false; //a flat 'polygon'
-
-    op2b = op2;
-    while (op2-&gt;Prev-&gt;Pt.Y == op2-&gt;Pt.Y &amp;&amp; op2-&gt;Prev != op2b &amp;&amp; op2-&gt;Prev != op1b)
-      op2 = op2-&gt;Prev;
-    while (op2b-&gt;Next-&gt;Pt.Y == op2b-&gt;Pt.Y &amp;&amp; op2b-&gt;Next != op2 &amp;&amp; op2b-&gt;Next != op1)
-      op2b = op2b-&gt;Next;
-    if (op2b-&gt;Next == op2 || op2b-&gt;Next == op1) return false; //a flat 'polygon'
-
-    cInt Left, Right;
-    //Op1 --&gt; Op1b &amp; Op2 --&gt; Op2b are the extremites of the horizontal edges
-    if (!GetOverlap(op1-&gt;Pt.X, op1b-&gt;Pt.X, op2-&gt;Pt.X, op2b-&gt;Pt.X, Left, Right))
-      return false;
+    return true;
+  }
+//------------------------------------------------------------------------------
 
-    //DiscardLeftSide: when overlapping edges are joined, a spike will created
-    //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up
-    //on the discard Side as either may still be needed for other joins ...
-    IntPoint Pt;
-    bool DiscardLeftSide;
-    if (op1-&gt;Pt.X &gt;= Left &amp;&amp; op1-&gt;Pt.X &lt;= Right) 
-    {
-      Pt = op1-&gt;Pt; DiscardLeftSide = (op1-&gt;Pt.X &gt; op1b-&gt;Pt.X);
-    } 
-    else if (op2-&gt;Pt.X &gt;= Left&amp;&amp; op2-&gt;Pt.X &lt;= Right) 
-    {
-      Pt = op2-&gt;Pt; DiscardLeftSide = (op2-&gt;Pt.X &gt; op2b-&gt;Pt.X);
-    } 
-    else if (op1b-&gt;Pt.X &gt;= Left &amp;&amp; op1b-&gt;Pt.X &lt;= Right)
-    {
-      Pt = op1b-&gt;Pt; DiscardLeftSide = op1b-&gt;Pt.X &gt; op1-&gt;Pt.X;
-    } 
-    else
-    {
-      Pt = op2b-&gt;Pt; DiscardLeftSide = (op2b-&gt;Pt.X &gt; op2-&gt;Pt.X);
-    }
-    j-&gt;OutPt1 = op1; j-&gt;OutPt2 = op2;
-    return JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);
-  } else
-  {
-    //nb: For non-horizontal joins ...
-    //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y
-    //    2. Jr.OutPt1.Pt &gt; Jr.OffPt.Y
-
-    //make sure the polygons are correctly oriented ...
-    op1b = op1-&gt;Next;
-    while ((op1b-&gt;Pt == op1-&gt;Pt) &amp;&amp; (op1b != op1)) op1b = op1b-&gt;Next;
-    bool Reverse1 = ((op1b-&gt;Pt.Y &gt; op1-&gt;Pt.Y) ||
-      !SlopesEqual(op1-&gt;Pt, op1b-&gt;Pt, j-&gt;OffPt, m_UseFullRange));
-    if (Reverse1)
-    {
-      op1b = op1-&gt;Prev;
-      while ((op1b-&gt;Pt == op1-&gt;Pt) &amp;&amp; (op1b != op1)) op1b = op1b-&gt;Prev;
-      if ((op1b-&gt;Pt.Y &gt; op1-&gt;Pt.Y) ||
-        !SlopesEqual(op1-&gt;Pt, op1b-&gt;Pt, j-&gt;OffPt, m_UseFullRange)) return false;
-    };
-    op2b = op2-&gt;Next;
-    while ((op2b-&gt;Pt == op2-&gt;Pt) &amp;&amp; (op2b != op2))op2b = op2b-&gt;Next;
-    bool Reverse2 = ((op2b-&gt;Pt.Y &gt; op2-&gt;Pt.Y) ||
-      !SlopesEqual(op2-&gt;Pt, op2b-&gt;Pt, j-&gt;OffPt, m_UseFullRange));
-    if (Reverse2)
-    {
-      op2b = op2-&gt;Prev;
-      while ((op2b-&gt;Pt == op2-&gt;Pt) &amp;&amp; (op2b != op2)) op2b = op2b-&gt;Prev;
-      if ((op2b-&gt;Pt.Y &gt; op2-&gt;Pt.Y) ||
-        !SlopesEqual(op2-&gt;Pt, op2b-&gt;Pt, j-&gt;OffPt, m_UseFullRange)) return false;
-    }
+  bool Clipper::JoinPoints(Join *j, OutRec *outRec1, OutRec *outRec2)
+  {
+    OutPt *op1 = j-&gt;OutPt1, *op1b;
+    OutPt *op2 = j-&gt;OutPt2, *op2b;
 
-    if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||
-      ((outRec1 == outRec2) &amp;&amp; (Reverse1 == Reverse2))) return false;
+    //There are 3 kinds of joins for output polygons ...
+    //1. Horizontal joins where Join.OutPt1 &amp; Join.OutPt2 are vertices anywhere
+    //along (horizontal) collinear edges (&amp; Join.OffPt is on the same horizontal).
+    //2. Non-horizontal joins where Join.OutPt1 &amp; Join.OutPt2 are at the same
+    //location at the Bottom of the overlapping segment (&amp; Join.OffPt is above).
+    //3. StrictSimple joins where edges touch but are not collinear and where
+    //Join.OutPt1, Join.OutPt2 &amp; Join.OffPt all share the same point.
+    bool isHorizontal = (j-&gt;OutPt1-&gt;Pt.Y == j-&gt;OffPt.Y);
 
-    if (Reverse1)
+    if (isHorizontal &amp;&amp; (j-&gt;OffPt == j-&gt;OutPt1-&gt;Pt) &amp;&amp;
+        (j-&gt;OffPt == j-&gt;OutPt2-&gt;Pt))
     {
-      op1b = DupOutPt(op1, false);
-      op2b = DupOutPt(op2, true);
-      op1-&gt;Prev = op2;
-      op2-&gt;Next = op1;
-      op1b-&gt;Next = op2b;
-      op2b-&gt;Prev = op1b;
+      //Strictly Simple join ...
+      if (outRec1 != outRec2)
+        return false;
+      op1b = j-&gt;OutPt1-&gt;Next;
+      while (op1b != op1 &amp;&amp; (op1b-&gt;Pt == j-&gt;OffPt))
+        op1b = op1b-&gt;Next;
+      bool reverse1 = (op1b-&gt;Pt.Y &gt; j-&gt;OffPt.Y);
+      op2b = j-&gt;OutPt2-&gt;Next;
+      while (op2b != op2 &amp;&amp; (op2b-&gt;Pt == j-&gt;OffPt))
+        op2b = op2b-&gt;Next;
+      bool reverse2 = (op2b-&gt;Pt.Y &gt; j-&gt;OffPt.Y);
+      if (reverse1 == reverse2)
+        return false;
+      if (reverse1)
+      {
+        op1b = DupOutPt(op1, false);
+        op2b = DupOutPt(op2, true);
+        op1-&gt;Prev = op2;
+        op2-&gt;Next = op1;
+        op1b-&gt;Next = op2b;
+        op2b-&gt;Prev = op1b;
+        j-&gt;OutPt1 = op1;
+        j-&gt;OutPt2 = op1b;
+        return true;
+      } else
+      {
+        op1b = DupOutPt(op1, true);
+        op2b = DupOutPt(op2, false);
+        op1-&gt;Next = op2;
+        op2-&gt;Prev = op1;
+        op1b-&gt;Prev = op2b;
+        op2b-&gt;Next = op1b;
+        j-&gt;OutPt1 = op1;
+        j-&gt;OutPt2 = op1b;
+        return true;
+      }
+    } else if (isHorizontal)
+    {
+      //treat horizontal joins differently to non-horizontal joins since with
+      //them we're not yet sure where the overlapping is. OutPt1.Pt &amp; OutPt2.Pt
+      //may be anywhere along the horizontal edge.
+      op1b = op1;
+      while (op1-&gt;Prev-&gt;Pt.Y == op1-&gt;Pt.Y &amp;&amp; op1-&gt;Prev != op1b &amp;&amp; op1-&gt;Prev != op2)
+        op1 = op1-&gt;Prev;
+      while (op1b-&gt;Next-&gt;Pt.Y == op1b-&gt;Pt.Y &amp;&amp; op1b-&gt;Next != op1 &amp;&amp; op1b-&gt;Next != op2)
+        op1b = op1b-&gt;Next;
+      if (op1b-&gt;Next == op1 || op1b-&gt;Next == op2)
+        return false; //a flat 'polygon'
+
+      op2b = op2;
+      while (op2-&gt;Prev-&gt;Pt.Y == op2-&gt;Pt.Y &amp;&amp; op2-&gt;Prev != op2b &amp;&amp; op2-&gt;Prev != op1b)
+        op2 = op2-&gt;Prev;
+      while (op2b-&gt;Next-&gt;Pt.Y == op2b-&gt;Pt.Y &amp;&amp; op2b-&gt;Next != op2 &amp;&amp; op2b-&gt;Next != op1)
+        op2b = op2b-&gt;Next;
+      if (op2b-&gt;Next == op2 || op2b-&gt;Next == op1)
+        return false; //a flat 'polygon'
+
+      cInt Left, Right;
+      //Op1 --&gt; Op1b &amp; Op2 --&gt; Op2b are the extremites of the horizontal edges
+      if (!GetOverlap(op1-&gt;Pt.X, op1b-&gt;Pt.X, op2-&gt;Pt.X, op2b-&gt;Pt.X, Left, Right))
+        return false;
+
+      //DiscardLeftSide: when overlapping edges are joined, a spike will created
+      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up
+      //on the discard Side as either may still be needed for other joins ...
+      IntPoint Pt;
+      bool DiscardLeftSide;
+      if (op1-&gt;Pt.X &gt;= Left &amp;&amp; op1-&gt;Pt.X &lt;= Right)
+      {
+        Pt = op1-&gt;Pt;
+        DiscardLeftSide = (op1-&gt;Pt.X &gt; op1b-&gt;Pt.X);
+      } else if (op2-&gt;Pt.X &gt;= Left &amp;&amp; op2-&gt;Pt.X &lt;= Right)
+      {
+        Pt = op2-&gt;Pt;
+        DiscardLeftSide = (op2-&gt;Pt.X &gt; op2b-&gt;Pt.X);
+      } else if (op1b-&gt;Pt.X &gt;= Left &amp;&amp; op1b-&gt;Pt.X &lt;= Right)
+      {
+        Pt = op1b-&gt;Pt;
+        DiscardLeftSide = op1b-&gt;Pt.X &gt; op1-&gt;Pt.X;
+      } else
+      {
+        Pt = op2b-&gt;Pt;
+        DiscardLeftSide = (op2b-&gt;Pt.X &gt; op2-&gt;Pt.X);
+      }
       j-&gt;OutPt1 = op1;
-      j-&gt;OutPt2 = op1b;
-      return true;
+      j-&gt;OutPt2 = op2;
+      return JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);
     } else
     {
-      op1b = DupOutPt(op1, true);
-      op2b = DupOutPt(op2, false);
-      op1-&gt;Next = op2;
-      op2-&gt;Prev = op1;
-      op1b-&gt;Prev = op2b;
-      op2b-&gt;Next = op1b;
-      j-&gt;OutPt1 = op1;
-      j-&gt;OutPt2 = op1b;
-      return true;
+      //nb: For non-horizontal joins ...
+      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y
+      //    2. Jr.OutPt1.Pt &gt; Jr.OffPt.Y
+
+      //make sure the polygons are correctly oriented ...
+      op1b = op1-&gt;Next;
+      while ((op1b-&gt;Pt == op1-&gt;Pt) &amp;&amp; (op1b != op1))
+        op1b = op1b-&gt;Next;
+      bool Reverse1 = ((op1b-&gt;Pt.Y &gt; op1-&gt;Pt.Y) ||
+                       !SlopesEqual(op1-&gt;Pt, op1b-&gt;Pt, j-&gt;OffPt, m_UseFullRange));
+      if (Reverse1)
+      {
+        op1b = op1-&gt;Prev;
+        while ((op1b-&gt;Pt == op1-&gt;Pt) &amp;&amp; (op1b != op1))
+          op1b = op1b-&gt;Prev;
+        if ((op1b-&gt;Pt.Y &gt; op1-&gt;Pt.Y) ||
+            !SlopesEqual(op1-&gt;Pt, op1b-&gt;Pt, j-&gt;OffPt, m_UseFullRange))
+          return false;
+      };
+      op2b = op2-&gt;Next;
+      while ((op2b-&gt;Pt == op2-&gt;Pt) &amp;&amp; (op2b != op2))
+        op2b = op2b-&gt;Next;
+      bool Reverse2 = ((op2b-&gt;Pt.Y &gt; op2-&gt;Pt.Y) ||
+                       !SlopesEqual(op2-&gt;Pt, op2b-&gt;Pt, j-&gt;OffPt, m_UseFullRange));
+      if (Reverse2)
+      {
+        op2b = op2-&gt;Prev;
+        while ((op2b-&gt;Pt == op2-&gt;Pt) &amp;&amp; (op2b != op2))
+          op2b = op2b-&gt;Prev;
+        if ((op2b-&gt;Pt.Y &gt; op2-&gt;Pt.Y) ||
+            !SlopesEqual(op2-&gt;Pt, op2b-&gt;Pt, j-&gt;OffPt, m_UseFullRange))
+          return false;
+      }
+
+      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||
+          ((outRec1 == outRec2) &amp;&amp; (Reverse1 == Reverse2)))
+        return false;
+
+      if (Reverse1)
+      {
+        op1b = DupOutPt(op1, false);
+        op2b = DupOutPt(op2, true);
+        op1-&gt;Prev = op2;
+        op2-&gt;Next = op1;
+        op1b-&gt;Next = op2b;
+        op2b-&gt;Prev = op1b;
+        j-&gt;OutPt1 = op1;
+        j-&gt;OutPt2 = op1b;
+        return true;
+      } else
+      {
+        op1b = DupOutPt(op1, true);
+        op2b = DupOutPt(op2, false);
+        op1-&gt;Next = op2;
+        op2-&gt;Prev = op1;
+        op1b-&gt;Prev = op2b;
+        op2b-&gt;Next = op1b;
+        j-&gt;OutPt1 = op1;
+        j-&gt;OutPt2 = op1b;
+        return true;
+      }
     }
   }
-}
 //----------------------------------------------------------------------
 
-static OutRec* ParseFirstLeft(OutRec* FirstLeft)
-{
-  while (FirstLeft &amp;&amp; !FirstLeft-&gt;Pts)
-    FirstLeft = FirstLeft-&gt;FirstLeft;
-  return FirstLeft;
-}
+  static OutRec *ParseFirstLeft(OutRec *FirstLeft)
+  {
+    while (FirstLeft &amp;&amp; !FirstLeft-&gt;Pts)
+      FirstLeft = FirstLeft-&gt;FirstLeft;
+    return FirstLeft;
+  }
 //------------------------------------------------------------------------------
 
-void Clipper::FixupFirstLefts1(OutRec* OldOutRec, OutRec* NewOutRec)
-{ 
-  //tests if NewOutRec contains the polygon before reassigning FirstLeft
-  for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); ++i)
+  void Clipper::FixupFirstLefts1(OutRec *OldOutRec, OutRec *NewOutRec)
   {
-    OutRec* outRec = m_PolyOuts[i];
-    OutRec* firstLeft = ParseFirstLeft(outRec-&gt;FirstLeft);
-    if (outRec-&gt;Pts  &amp;&amp; firstLeft == OldOutRec)
+    //tests if NewOutRec contains the polygon before reassigning FirstLeft
+    for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); ++i)
     {
-      if (Poly2ContainsPoly1(outRec-&gt;Pts, NewOutRec-&gt;Pts))
-        outRec-&gt;FirstLeft = NewOutRec;
+      OutRec *outRec = m_PolyOuts[i];
+      OutRec *firstLeft = ParseFirstLeft(outRec-&gt;FirstLeft);
+      if (outRec-&gt;Pts &amp;&amp; firstLeft == OldOutRec)
+      {
+        if (Poly2ContainsPoly1(outRec-&gt;Pts, NewOutRec-&gt;Pts))
+          outRec-&gt;FirstLeft = NewOutRec;
+      }
     }
   }
-}
 //----------------------------------------------------------------------
 
-void Clipper::FixupFirstLefts2(OutRec* InnerOutRec, OutRec* OuterOutRec)
-{
-  //A polygon has split into two such that one is now the inner of the other.
-  //It's possible that these polygons now wrap around other polygons, so check
-  //every polygon that's also contained by OuterOutRec's FirstLeft container
-  //(including 0) to see if they've become inner to the new inner polygon ...
-  OutRec* orfl = OuterOutRec-&gt;FirstLeft;
-  for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); ++i)
-  {
-    OutRec* outRec = m_PolyOuts[i];
-
-    if (!outRec-&gt;Pts || outRec == OuterOutRec || outRec == InnerOutRec)
-      continue;
-    OutRec* firstLeft = ParseFirstLeft(outRec-&gt;FirstLeft);
-    if (firstLeft != orfl &amp;&amp; firstLeft != InnerOutRec &amp;&amp; firstLeft != OuterOutRec)
-      continue;
-    if (Poly2ContainsPoly1(outRec-&gt;Pts, InnerOutRec-&gt;Pts))
-      outRec-&gt;FirstLeft = InnerOutRec;
-    else if (Poly2ContainsPoly1(outRec-&gt;Pts, OuterOutRec-&gt;Pts))
-      outRec-&gt;FirstLeft = OuterOutRec;
-    else if (outRec-&gt;FirstLeft == InnerOutRec || outRec-&gt;FirstLeft == OuterOutRec)
-      outRec-&gt;FirstLeft = orfl;
+  void Clipper::FixupFirstLefts2(OutRec *InnerOutRec, OutRec *OuterOutRec)
+  {
+    //A polygon has split into two such that one is now the inner of the other.
+    //It's possible that these polygons now wrap around other polygons, so check
+    //every polygon that's also contained by OuterOutRec's FirstLeft container
+    //(including 0) to see if they've become inner to the new inner polygon ...
+    OutRec *orfl = OuterOutRec-&gt;FirstLeft;
+    for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); ++i)
+    {
+      OutRec *outRec = m_PolyOuts[i];
+
+      if (!outRec-&gt;Pts || outRec == OuterOutRec || outRec == InnerOutRec)
+        continue;
+      OutRec *firstLeft = ParseFirstLeft(outRec-&gt;FirstLeft);
+      if (firstLeft != orfl &amp;&amp; firstLeft != InnerOutRec &amp;&amp; firstLeft != OuterOutRec)
+        continue;
+      if (Poly2ContainsPoly1(outRec-&gt;Pts, InnerOutRec-&gt;Pts))
+        outRec-&gt;FirstLeft = InnerOutRec;
+      else if (Poly2ContainsPoly1(outRec-&gt;Pts, OuterOutRec-&gt;Pts))
+        outRec-&gt;FirstLeft = OuterOutRec;
+      else if (outRec-&gt;FirstLeft == InnerOutRec || outRec-&gt;FirstLeft == OuterOutRec)
+        outRec-&gt;FirstLeft = orfl;
+    }
   }
-}
+
 //----------------------------------------------------------------------
-void Clipper::FixupFirstLefts3(OutRec* OldOutRec, OutRec* NewOutRec)
-{
-  //reassigns FirstLeft WITHOUT testing if NewOutRec contains the polygon
-  for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); ++i)
+  void Clipper::FixupFirstLefts3(OutRec *OldOutRec, OutRec *NewOutRec)
   {
-    OutRec* outRec = m_PolyOuts[i];
-    OutRec* firstLeft = ParseFirstLeft(outRec-&gt;FirstLeft);
-    if (outRec-&gt;Pts &amp;&amp; firstLeft == OldOutRec)
-      outRec-&gt;FirstLeft = NewOutRec;
+    //reassigns FirstLeft WITHOUT testing if NewOutRec contains the polygon
+    for (PolyOutList::size_type i = 0; i &lt; m_PolyOuts.size(); ++i)
+    {
+      OutRec *outRec = m_PolyOuts[i];
+      OutRec *firstLeft = ParseFirstLeft(outRec-&gt;FirstLeft);
+      if (outRec-&gt;Pts &amp;&amp; firstLeft == OldOutRec)
+        outRec-&gt;FirstLeft = NewOutRec;
+    }
   }
-}
 //----------------------------------------------------------------------
 
-void Clipper::JoinCommonEdges()
-{
-  for (JoinList::size_type i = 0; i &lt; m_Joins.size(); i++)
+  void Clipper::JoinCommonEdges()
   {
-    Join* join = m_Joins[i];
+    for (JoinList::size_type i = 0; i &lt; m_Joins.size(); i++)
+    {
+      Join *join = m_Joins[i];
 
-    OutRec *outRec1 = GetOutRec(join-&gt;OutPt1-&gt;Idx);
-    OutRec *outRec2 = GetOutRec(join-&gt;OutPt2-&gt;Idx);
+      OutRec *outRec1 = GetOutRec(join-&gt;OutPt1-&gt;Idx);
+      OutRec *outRec2 = GetOutRec(join-&gt;OutPt2-&gt;Idx);
 
-    if (!outRec1-&gt;Pts || !outRec2-&gt;Pts) continue;
-    if (outRec1-&gt;IsOpen || outRec2-&gt;IsOpen) continue;
+      if (!outRec1-&gt;Pts || !outRec2-&gt;Pts)
+        continue;
+      if (outRec1-&gt;IsOpen || outRec2-&gt;IsOpen)
+        continue;
 
-    //get the polygon fragment with the correct hole state (FirstLeft)
-    //before calling JoinPoints() ...
-    OutRec *holeStateRec;
-    if (outRec1 == outRec2) holeStateRec = outRec1;
-    else if (OutRec1RightOfOutRec2(outRec1, outRec2)) holeStateRec = outRec2;
-    else if (OutRec1RightOfOutRec2(outRec2, outRec1)) holeStateRec = outRec1;
-    else holeStateRec = GetLowermostRec(outRec1, outRec2);
+      //get the polygon fragment with the correct hole state (FirstLeft)
+      //before calling JoinPoints() ...
+      OutRec *holeStateRec;
+      if (outRec1 == outRec2)
+        holeStateRec = outRec1;
+      else if (OutRec1RightOfOutRec2(outRec1, outRec2))
+        holeStateRec = outRec2;
+      else if (OutRec1RightOfOutRec2(outRec2, outRec1))
+        holeStateRec = outRec1;
+      else
+        holeStateRec = GetLowermostRec(outRec1, outRec2);
 
-    if (!JoinPoints(join, outRec1, outRec2)) continue;
+      if (!JoinPoints(join, outRec1, outRec2))
+        continue;
 
-    if (outRec1 == outRec2)
-    {
-      //instead of joining two polygons, we've just created a new one by
-      //splitting one polygon into two.
-      outRec1-&gt;Pts = join-&gt;OutPt1;
-      outRec1-&gt;BottomPt = 0;
-      outRec2 = CreateOutRec();
-      outRec2-&gt;Pts = join-&gt;OutPt2;
+      if (outRec1 == outRec2)
+      {
+        //instead of joining two polygons, we've just created a new one by
+        //splitting one polygon into two.
+        outRec1-&gt;Pts = join-&gt;OutPt1;
+        outRec1-&gt;BottomPt = 0;
+        outRec2 = CreateOutRec();
+        outRec2-&gt;Pts = join-&gt;OutPt2;
 
-      //update all OutRec2.Pts Idx's ...
-      UpdateOutPtIdxs(*outRec2);
+        //update all OutRec2.Pts Idx's ...
+        UpdateOutPtIdxs(*outRec2);
 
-      if (Poly2ContainsPoly1(outRec2-&gt;Pts, outRec1-&gt;Pts))
-      {
-        //outRec1 contains outRec2 ...
-        outRec2-&gt;IsHole = !outRec1-&gt;IsHole;
-        outRec2-&gt;FirstLeft = outRec1;
+        if (Poly2ContainsPoly1(outRec2-&gt;Pts, outRec1-&gt;Pts))
+        {
+          //outRec1 contains outRec2 ...
+          outRec2-&gt;IsHole = !outRec1-&gt;IsHole;
+          outRec2-&gt;FirstLeft = outRec1;
 
-        if (m_UsingPolyTree) FixupFirstLefts2(outRec2, outRec1);
+          if (m_UsingPolyTree)
+            FixupFirstLefts2(outRec2, outRec1);
 
-        if ((outRec2-&gt;IsHole ^ m_ReverseOutput) == (Area(*outRec2) &gt; 0))
-          ReversePolyPtLinks(outRec2-&gt;Pts);
-            
-      } else if (Poly2ContainsPoly1(outRec1-&gt;Pts, outRec2-&gt;Pts))
-      {
-        //outRec2 contains outRec1 ...
-        outRec2-&gt;IsHole = outRec1-&gt;IsHole;
-        outRec1-&gt;IsHole = !outRec2-&gt;IsHole;
-        outRec2-&gt;FirstLeft = outRec1-&gt;FirstLeft;
-        outRec1-&gt;FirstLeft = outRec2;
+          if ((outRec2-&gt;IsHole ^ m_ReverseOutput) == (Area(*outRec2) &gt; 0))
+            ReversePolyPtLinks(outRec2-&gt;Pts);
 
-        if (m_UsingPolyTree) FixupFirstLefts2(outRec1, outRec2);
+        } else if (Poly2ContainsPoly1(outRec1-&gt;Pts, outRec2-&gt;Pts))
+        {
+          //outRec2 contains outRec1 ...
+          outRec2-&gt;IsHole = outRec1-&gt;IsHole;
+          outRec1-&gt;IsHole = !outRec2-&gt;IsHole;
+          outRec2-&gt;FirstLeft = outRec1-&gt;FirstLeft;
+          outRec1-&gt;FirstLeft = outRec2;
+
+          if (m_UsingPolyTree)
+            FixupFirstLefts2(outRec1, outRec2);
+
+          if ((outRec1-&gt;IsHole ^ m_ReverseOutput) == (Area(*outRec1) &gt; 0))
+            ReversePolyPtLinks(outRec1-&gt;Pts);
+        } else
+        {
+          //the 2 polygons are completely separate ...
+          outRec2-&gt;IsHole = outRec1-&gt;IsHole;
+          outRec2-&gt;FirstLeft = outRec1-&gt;FirstLeft;
 
-        if ((outRec1-&gt;IsHole ^ m_ReverseOutput) == (Area(*outRec1) &gt; 0))
-          ReversePolyPtLinks(outRec1-&gt;Pts);
-      } 
-      else
-      {
-        //the 2 polygons are completely separate ...
-        outRec2-&gt;IsHole = outRec1-&gt;IsHole;
-        outRec2-&gt;FirstLeft = outRec1-&gt;FirstLeft;
+          //fixup FirstLeft pointers that may need reassigning to OutRec2
+          if (m_UsingPolyTree)
+            FixupFirstLefts1(outRec1, outRec2);
+        }
 
-        //fixup FirstLeft pointers that may need reassigning to OutRec2
-        if (m_UsingPolyTree) FixupFirstLefts1(outRec1, outRec2);
-      }
-     
-    } else
-    {
-      //joined 2 polygons together ...
+      } else
+      {
+        //joined 2 polygons together ...
 
-      outRec2-&gt;Pts = 0;
-      outRec2-&gt;BottomPt = 0;
-      outRec2-&gt;Idx = outRec1-&gt;Idx;
+        outRec2-&gt;Pts = 0;
+        outRec2-&gt;BottomPt = 0;
+        outRec2-&gt;Idx = outRec1-&gt;Idx;
 
-      outRec1-&gt;IsHole = holeStateRec-&gt;IsHole;
-      if (holeStateRec == outRec2) 
-        outRec1-&gt;FirstLeft = outRec2-&gt;FirstLeft;
-      outRec2-&gt;FirstLeft = outRec1;
+        outRec1-&gt;IsHole = holeStateRec-&gt;IsHole;
+        if (holeStateRec == outRec2)
+          outRec1-&gt;FirstLeft = outRec2-&gt;FirstLeft;
+        outRec2-&gt;FirstLeft = outRec1;
 
-      if (m_UsingPolyTree) FixupFirstLefts3(outRec2, outRec1);
+        if (m_UsingPolyTree)
+          FixupFirstLefts3(outRec2, outRec1);
+      }
     }
   }
-}
 
 //------------------------------------------------------------------------------
 // ClipperOffset support functions ...
 //------------------------------------------------------------------------------
 
-DoublePoint GetUnitNormal(const IntPoint &amp;pt1, const IntPoint &amp;pt2)
-{
-  if(pt2.X == pt1.X &amp;&amp; pt2.Y == pt1.Y) 
-    return DoublePoint(0, 0);
-
-  double Dx = (double)(pt2.X - pt1.X);
-  double dy = (double)(pt2.Y - pt1.Y);
-  double f = 1 *1.0/ std::sqrt( Dx*Dx + dy*dy );
-  Dx *= f;
-  dy *= f;
-  return DoublePoint(dy, -Dx);
-}
+  DoublePoint GetUnitNormal(const IntPoint &amp;pt1, const IntPoint &amp;pt2)
+  {
+    if (pt2.X == pt1.X &amp;&amp; pt2.Y == pt1.Y)
+      return DoublePoint(0, 0);
+
+    double Dx = (double) (pt2.X - pt1.X);
+    double dy = (double) (pt2.Y - pt1.Y);
+    double f = 1 * 1.0 / std::sqrt(Dx * Dx + dy * dy);
+    Dx *= f;
+    dy *= f;
+    return DoublePoint(dy, -Dx);
+  }
 
 //------------------------------------------------------------------------------
 // ClipperOffset class
 //------------------------------------------------------------------------------
 
-ClipperOffset::ClipperOffset(double miterLimit, double arcTolerance)
-{
-  this-&gt;MiterLimit = miterLimit;
-  this-&gt;ArcTolerance = arcTolerance;
-  m_lowest.X = -1;
-}
+  ClipperOffset::ClipperOffset(double miterLimit, double arcTolerance)
+  {
+    this-&gt;MiterLimit = miterLimit;
+    this-&gt;ArcTolerance = arcTolerance;
+    m_lowest.X = -1;
+  }
 //------------------------------------------------------------------------------
 
-ClipperOffset::~ClipperOffset()
-{
-  Clear();
-}
+  ClipperOffset::~ClipperOffset()
+  {
+    Clear();
+  }
 //------------------------------------------------------------------------------
 
-void ClipperOffset::Clear()
-{
-  for (int i = 0; i &lt; m_polyNodes.ChildCount(); ++i)
-    delete m_polyNodes.Childs[i];
-  m_polyNodes.Childs.clear();
-  m_lowest.X = -1;
-}
+  void ClipperOffset::Clear()
+  {
+    for (int i = 0; i &lt; m_polyNodes.ChildCount(); ++i)
+      delete m_polyNodes.Childs[i];
+    m_polyNodes.Childs.clear();
+    m_lowest.X = -1;
+  }
 //------------------------------------------------------------------------------
 
-void ClipperOffset::AddPath(const Path&amp; path, JoinType joinType, EndType endType)
-{
-  int highI = (int)path.size() - 1;
-  if (highI &lt; 0) return;
-  PolyNode* newNode = new PolyNode();
-  newNode-&gt;m_jointype = joinType;
-  newNode-&gt;m_endtype = endType;
-
-  //strip duplicate points from path and also get index to the lowest point ...
-  if (endType == etClosedLine || endType == etClosedPolygon)
-    while (highI &gt; 0 &amp;&amp; path[0] == path[highI]) highI--;
-  newNode-&gt;Contour.reserve(highI + 1);
-  newNode-&gt;Contour.push_back(path[0]);
-  int j = 0, k = 0;
-  for (int i = 1; i &lt;= highI; i++)
-    if (newNode-&gt;Contour[j] != path[i])
-    {
-      j++;
-      newNode-&gt;Contour.push_back(path[i]);
-      if (path[i].Y &gt; newNode-&gt;Contour[k].Y ||
-        (path[i].Y == newNode-&gt;Contour[k].Y &amp;&amp;
-        path[i].X &lt; newNode-&gt;Contour[k].X)) k = j;
+  void ClipperOffset::AddPath(const Path &amp;path, JoinType joinType, EndType endType)
+  {
+    int highI = (int) path.size() - 1;
+    if (highI &lt; 0)
+      return;
+    PolyNode *newNode = new PolyNode();
+    newNode-&gt;m_jointype = joinType;
+    newNode-&gt;m_endtype = endType;
+
+    //strip duplicate points from path and also get index to the lowest point ...
+    if (endType == etClosedLine || endType == etClosedPolygon)
+      while (highI &gt; 0 &amp;&amp; path[0] == path[highI])
+        highI--;
+    newNode-&gt;Contour.reserve(highI + 1);
+    newNode-&gt;Contour.push_back(path[0]);
+    int j = 0, k = 0;
+    for (int i = 1; i &lt;= highI; i++)
+      if (newNode-&gt;Contour[j] != path[i])
+      {
+        j++;
+        newNode-&gt;Contour.push_back(path[i]);
+        if (path[i].Y &gt; newNode-&gt;Contour[k].Y ||
+            (path[i].Y == newNode-&gt;Contour[k].Y &amp;&amp;
+             path[i].X &lt; newNode-&gt;Contour[k].X))
+          k = j;
+      }
+    if (endType == etClosedPolygon &amp;&amp; j &lt; 2)
+    {
+      delete newNode;
+      return;
     }
-  if (endType == etClosedPolygon &amp;&amp; j &lt; 2)
-  {
-    delete newNode;
-    return;
-  }
-  m_polyNodes.AddChild(*newNode);
+    m_polyNodes.AddChild(*newNode);
 
-  //if this path's lowest pt is lower than all the others then update m_lowest
-  if (endType != etClosedPolygon) return;
-  if (m_lowest.X &lt; 0)
-    m_lowest = IntPoint(m_polyNodes.ChildCount() - 1, k);
-  else
-  {
-    IntPoint ip = m_polyNodes.Childs[(int)m_lowest.X]-&gt;Contour[(int)m_lowest.Y];
-    if (newNode-&gt;Contour[k].Y &gt; ip.Y ||
-      (newNode-&gt;Contour[k].Y == ip.Y &amp;&amp;
-      newNode-&gt;Contour[k].X &lt; ip.X))
+    //if this path's lowest pt is lower than all the others then update m_lowest
+    if (endType != etClosedPolygon)
+      return;
+    if (m_lowest.X &lt; 0)
       m_lowest = IntPoint(m_polyNodes.ChildCount() - 1, k);
+    else
+    {
+      IntPoint ip = m_polyNodes.Childs[(int) m_lowest.X]-&gt;Contour[(int) m_lowest.Y];
+      if (newNode-&gt;Contour[k].Y &gt; ip.Y ||
+          (newNode-&gt;Contour[k].Y == ip.Y &amp;&amp;
+           newNode-&gt;Contour[k].X &lt; ip.X))
+        m_lowest = IntPoint(m_polyNodes.ChildCount() - 1, k);
+    }
   }
-}
 //------------------------------------------------------------------------------
 
-void ClipperOffset::AddPaths(const Paths&amp; paths, JoinType joinType, EndType endType)
-{
-  for (Paths::size_type i = 0; i &lt; paths.size(); ++i)
-    AddPath(paths[i], joinType, endType);
-}
+  void ClipperOffset::AddPaths(const Paths &amp;paths, JoinType joinType, EndType endType)
+  {
+    for (Paths::size_type i = 0; i &lt; paths.size(); ++i)
+      AddPath(paths[i], joinType, endType);
+  }
 //------------------------------------------------------------------------------
 
-void ClipperOffset::FixOrientations()
-{
-  //fixup orientations of all closed paths if the orientation of the
-  //closed path with the lowermost vertex is wrong ...
-  if (m_lowest.X &gt;= 0 &amp;&amp; 
-    !Orientation(m_polyNodes.Childs[(int)m_lowest.X]-&gt;Contour))
+  void ClipperOffset::FixOrientations()
   {
-    for (int i = 0; i &lt; m_polyNodes.ChildCount(); ++i)
+    //fixup orientations of all closed paths if the orientation of the
+    //closed path with the lowermost vertex is wrong ...
+    if (m_lowest.X &gt;= 0 &amp;&amp;
+        !Orientation(m_polyNodes.Childs[(int) m_lowest.X]-&gt;Contour))
     {
-      PolyNode&amp; node = *m_polyNodes.Childs[i];
-      if (node.m_endtype == etClosedPolygon ||
-        (node.m_endtype == etClosedLine &amp;&amp; Orientation(node.Contour)))
+      for (int i = 0; i &lt; m_polyNodes.ChildCount(); ++i)
+      {
+        PolyNode &amp;node = *m_polyNodes.Childs[i];
+        if (node.m_endtype == etClosedPolygon ||
+            (node.m_endtype == etClosedLine &amp;&amp; Orientation(node.Contour)))
           ReversePath(node.Contour);
-    }
-  } else
-  {
-    for (int i = 0; i &lt; m_polyNodes.ChildCount(); ++i)
+      }
+    } else
     {
-      PolyNode&amp; node = *m_polyNodes.Childs[i];
-      if (node.m_endtype == etClosedLine &amp;&amp; !Orientation(node.Contour))
-        ReversePath(node.Contour);
+      for (int i = 0; i &lt; m_polyNodes.ChildCount(); ++i)
+      {
+        PolyNode &amp;node = *m_polyNodes.Childs[i];
+        if (node.m_endtype == etClosedLine &amp;&amp; !Orientation(node.Contour))
+          ReversePath(node.Contour);
+      }
     }
   }
-}
 //------------------------------------------------------------------------------
 
-void ClipperOffset::Execute(Paths&amp; solution, double delta)
-{
-  solution.clear();
-  FixOrientations();
-  DoOffset(delta);
-  
-  //now clean up 'corners' ...
-  Clipper clpr;
-  clpr.AddPaths(m_destPolys, ptSubject, true);
-  if (delta &gt; 0)
-  {
-    clpr.Execute(ctUnion, solution, pftPositive, pftPositive);
-  }
-  else
-  {
-    IntRect r = clpr.GetBounds();
-    Path outer(4);
-    outer[0] = IntPoint(r.left - 10, r.bottom + 10);
-    outer[1] = IntPoint(r.right + 10, r.bottom + 10);
-    outer[2] = IntPoint(r.right + 10, r.top - 10);
-    outer[3] = IntPoint(r.left - 10, r.top - 10);
-
-    clpr.AddPath(outer, ptSubject, true);
-    clpr.ReverseSolution(true);
-    clpr.Execute(ctUnion, solution, pftNegative, pftNegative);
-    if (solution.size() &gt; 0) solution.erase(solution.begin());
+  void ClipperOffset::Execute(Paths &amp;solution, double delta)
+  {
+    solution.clear();
+    FixOrientations();
+    DoOffset(delta);
+
+    //now clean up 'corners' ...
+    Clipper clpr;
+    clpr.AddPaths(m_destPolys, ptSubject, true);
+    if (delta &gt; 0)
+    {
+      clpr.Execute(ctUnion, solution, pftPositive, pftPositive);
+    } else
+    {
+      IntRect r = clpr.GetBounds();
+      Path outer(4);
+      outer[0] = IntPoint(r.left - 10, r.bottom + 10);
+      outer[1] = IntPoint(r.right + 10, r.bottom + 10);
+      outer[2] = IntPoint(r.right + 10, r.top - 10);
+      outer[3] = IntPoint(r.left - 10, r.top - 10);
+
+      clpr.AddPath(outer, ptSubject, true);
+      clpr.ReverseSolution(true);
+      clpr.Execute(ctUnion, solution, pftNegative, pftNegative);
+      if (solution.size() &gt; 0)
+        solution.erase(solution.begin());
+    }
   }
-}
 //------------------------------------------------------------------------------
 
-void ClipperOffset::Execute(PolyTree&amp; solution, double delta)
-{
-  solution.Clear();
-  FixOrientations();
-  DoOffset(delta);
-
-  //now clean up 'corners' ...
-  Clipper clpr;
-  clpr.AddPaths(m_destPolys, ptSubject, true);
-  if (delta &gt; 0)
-  {
-    clpr.Execute(ctUnion, solution, pftPositive, pftPositive);
-  }
-  else
-  {
-    IntRect r = clpr.GetBounds();
-    Path outer(4);
-    outer[0] = IntPoint(r.left - 10, r.bottom + 10);
-    outer[1] = IntPoint(r.right + 10, r.bottom + 10);
-    outer[2] = IntPoint(r.right + 10, r.top - 10);
-    outer[3] = IntPoint(r.left - 10, r.top - 10);
-
-    clpr.AddPath(outer, ptSubject, true);
-    clpr.ReverseSolution(true);
-    clpr.Execute(ctUnion, solution, pftNegative, pftNegative);
-    //remove the outer PolyNode rectangle ...
-    if (solution.ChildCount() == 1 &amp;&amp; solution.Childs[0]-&gt;ChildCount() &gt; 0)
-    {
-      PolyNode* outerNode = solution.Childs[0];
-      solution.Childs.reserve(outerNode-&gt;ChildCount());
-      solution.Childs[0] = outerNode-&gt;Childs[0];
-      solution.Childs[0]-&gt;Parent = outerNode-&gt;Parent;
-      for (int i = 1; i &lt; outerNode-&gt;ChildCount(); ++i)
-        solution.AddChild(*outerNode-&gt;Childs[i]);
+  void ClipperOffset::Execute(PolyTree &amp;solution, double delta)
+  {
+    solution.Clear();
+    FixOrientations();
+    DoOffset(delta);
+
+    //now clean up 'corners' ...
+    Clipper clpr;
+    clpr.AddPaths(m_destPolys, ptSubject, true);
+    if (delta &gt; 0)
+    {
+      clpr.Execute(ctUnion, solution, pftPositive, pftPositive);
+    } else
+    {
+      IntRect r = clpr.GetBounds();
+      Path outer(4);
+      outer[0] = IntPoint(r.left - 10, r.bottom + 10);
+      outer[1] = IntPoint(r.right + 10, r.bottom + 10);
+      outer[2] = IntPoint(r.right + 10, r.top - 10);
+      outer[3] = IntPoint(r.left - 10, r.top - 10);
+
+      clpr.AddPath(outer, ptSubject, true);
+      clpr.ReverseSolution(true);
+      clpr.Execute(ctUnion, solution, pftNegative, pftNegative);
+      //remove the outer PolyNode rectangle ...
+      if (solution.ChildCount() == 1 &amp;&amp; solution.Childs[0]-&gt;ChildCount() &gt; 0)
+      {
+        PolyNode *outerNode = solution.Childs[0];
+        solution.Childs.reserve(outerNode-&gt;ChildCount());
+        solution.Childs[0] = outerNode-&gt;Childs[0];
+        solution.Childs[0]-&gt;Parent = outerNode-&gt;Parent;
+        for (int i = 1; i &lt; outerNode-&gt;ChildCount(); ++i)
+          solution.AddChild(*outerNode-&gt;Childs[i]);
+      } else
+        solution.Clear();
     }
-    else
-      solution.Clear();
   }
-}
 //------------------------------------------------------------------------------
 
-void ClipperOffset::DoOffset(double delta)
-{
-  m_destPolys.clear();
-  m_delta = delta;
-
-  //if Zero offset, just copy any CLOSED polygons to m_p and return ...
-  if (NEAR_ZERO(delta)) 
+  void ClipperOffset::DoOffset(double delta)
   {
-    m_destPolys.reserve(m_polyNodes.ChildCount());
-    for (int i = 0; i &lt; m_polyNodes.ChildCount(); i++)
-    {
-      PolyNode&amp; node = *m_polyNodes.Childs[i];
-      if (node.m_endtype == etClosedPolygon)
-        m_destPolys.push_back(node.Contour);
-    }
-    return;
-  }
-
-  //see offset_triginometry3.svg in the documentation folder ...
-  if (MiterLimit &gt; 2) m_miterLim = 2/(MiterLimit * MiterLimit);
-  else m_miterLim = 0.5;
-
-  double y;
-  if (ArcTolerance &lt;= 0.0) y = def_arc_tolerance;
-  else if (ArcTolerance &gt; std::fabs(delta) * def_arc_tolerance) 
-    y = std::fabs(delta) * def_arc_tolerance;
-  else y = ArcTolerance;
-  //see offset_triginometry2.svg in the documentation folder ...
-  double steps = pi / std::acos(1 - y / std::fabs(delta));
-  if (steps &gt; std::fabs(delta) * pi) 
-    steps = std::fabs(delta) * pi;  //ie excessive precision check
-  m_sin = std::sin(two_pi / steps);
-  m_cos = std::cos(two_pi / steps);
-  m_StepsPerRad = steps / two_pi;
-  if (delta &lt; 0.0) m_sin = -m_sin;
-
-  m_destPolys.reserve(m_polyNodes.ChildCount() * 2);
-  for (int i = 0; i &lt; m_polyNodes.ChildCount(); i++)
-  {
-    PolyNode&amp; node = *m_polyNodes.Childs[i];
-    m_srcPoly = node.Contour;
-
-    int len = (int)m_srcPoly.size();
-    if (len == 0 || (delta &lt;= 0 &amp;&amp; (len &lt; 3 || node.m_endtype != etClosedPolygon)))
-        continue;
+    m_destPolys.clear();
+    m_delta = delta;
 
-    m_destPoly.clear();
-    if (len == 1)
+    //if Zero offset, just copy any CLOSED polygons to m_p and return ...
+    if (NEAR_ZERO(delta))
     {
-      if (node.m_jointype == jtRound)
-      {
-        double X = 1.0, Y = 0.0;
-        for (cInt j = 1; j &lt;= steps; j++)
-        {
-          m_destPoly.push_back(IntPoint(
-            Round(m_srcPoly[0].X + X * delta),
-            Round(m_srcPoly[0].Y + Y * delta)));
-          double X2 = X;
-          X = X * m_cos - m_sin * Y;
-          Y = X2 * m_sin + Y * m_cos;
-        }
-      }
-      else
+      m_destPolys.reserve(m_polyNodes.ChildCount());
+      for (int i = 0; i &lt; m_polyNodes.ChildCount(); i++)
       {
-        double X = -1.0, Y = -1.0;
-        for (int j = 0; j &lt; 4; ++j)
-        {
-          m_destPoly.push_back(IntPoint(
-            Round(m_srcPoly[0].X + X * delta),
-            Round(m_srcPoly[0].Y + Y * delta)));
-          if (X &lt; 0) X = 1;
-          else if (Y &lt; 0) Y = 1;
-          else X = -1;
-        }
+        PolyNode &amp;node = *m_polyNodes.Childs[i];
+        if (node.m_endtype == etClosedPolygon)
+          m_destPolys.push_back(node.Contour);
       }
-      m_destPolys.push_back(m_destPoly);
-      continue;
+      return;
     }
-    //build m_normals ...
-    m_normals.clear();
-    m_normals.reserve(len);
-    for (int j = 0; j &lt; len - 1; ++j)
-      m_normals.push_back(GetUnitNormal(m_srcPoly[j], m_srcPoly[j + 1]));
-    if (node.m_endtype == etClosedLine || node.m_endtype == etClosedPolygon)
-      m_normals.push_back(GetUnitNormal(m_srcPoly[len - 1], m_srcPoly[0]));
+
+    //see offset_triginometry3.svg in the documentation folder ...
+    if (MiterLimit &gt; 2)
+      m_miterLim = 2 / (MiterLimit * MiterLimit);
     else
-      m_normals.push_back(DoublePoint(m_normals[len - 2]));
+      m_miterLim = 0.5;
 
-    if (node.m_endtype == etClosedPolygon)
-    {
-      int k = len - 1;
-      for (int j = 0; j &lt; len; ++j)
-        OffsetPoint(j, k, node.m_jointype);
-      m_destPolys.push_back(m_destPoly);
-    }
-    else if (node.m_endtype == etClosedLine)
-    {
-      int k = len - 1;
-      for (int j = 0; j &lt; len; ++j)
-        OffsetPoint(j, k, node.m_jointype);
-      m_destPolys.push_back(m_destPoly);
-      m_destPoly.clear();
-      //re-build m_normals ...
-      DoublePoint n = m_normals[len -1];
-      for (int j = len - 1; j &gt; 0; j--)
-        m_normals[j] = DoublePoint(-m_normals[j - 1].X, -m_normals[j - 1].Y);
-      m_normals[0] = DoublePoint(-n.X, -n.Y);
-      k = 0;
-      for (int j = len - 1; j &gt;= 0; j--)
-        OffsetPoint(j, k, node.m_jointype);
-      m_destPolys.push_back(m_destPoly);
-    }
+    double y;
+    if (ArcTolerance &lt;= 0.0)
+      y = def_arc_tolerance;
+    else if (ArcTolerance &gt; std::fabs(delta) * def_arc_tolerance)
+      y = std::fabs(delta) * def_arc_tolerance;
     else
+      y = ArcTolerance;
+    //see offset_triginometry2.svg in the documentation folder ...
+    double steps = pi / std::acos(1 - y / std::fabs(delta));
+    if (steps &gt; std::fabs(delta) * pi)
+      steps = std::fabs(delta) * pi;  //ie excessive precision check
+    m_sin = std::sin(two_pi / steps);
+    m_cos = std::cos(two_pi / steps);
+    m_StepsPerRad = steps / two_pi;
+    if (delta &lt; 0.0)
+      m_sin = -m_sin;
+
+    m_destPolys.reserve(m_polyNodes.ChildCount() * 2);
+    for (int i = 0; i &lt; m_polyNodes.ChildCount(); i++)
     {
-      int k = 0;
-      for (int j = 1; j &lt; len - 1; ++j)
-        OffsetPoint(j, k, node.m_jointype);
+      PolyNode &amp;node = *m_polyNodes.Childs[i];
+      m_srcPoly = node.Contour;
+
+      int len = (int) m_srcPoly.size();
+      if (len == 0 || (delta &lt;= 0 &amp;&amp; (len &lt; 3 || node.m_endtype != etClosedPolygon)))
+        continue;
 
-      IntPoint pt1;
-      if (node.m_endtype == etOpenButt)
+      m_destPoly.clear();
+      if (len == 1)
       {
-        int j = len - 1;
-        pt1 = IntPoint((cInt)Round(m_srcPoly[j].X + m_normals[j].X *
-          delta), (cInt)Round(m_srcPoly[j].Y + m_normals[j].Y * delta));
-        m_destPoly.push_back(pt1);
-        pt1 = IntPoint((cInt)Round(m_srcPoly[j].X - m_normals[j].X *
-          delta), (cInt)Round(m_srcPoly[j].Y - m_normals[j].Y * delta));
-        m_destPoly.push_back(pt1);
+        if (node.m_jointype == jtRound)
+        {
+          double X = 1.0, Y = 0.0;
+          for (cInt j = 1; j &lt;= steps; j++)
+          {
+            m_destPoly.push_back(IntPoint(
+              Round(m_srcPoly[0].X + X * delta),
+              Round(m_srcPoly[0].Y + Y * delta)));
+            double X2 = X;
+            X = X * m_cos - m_sin * Y;
+            Y = X2 * m_sin + Y * m_cos;
+          }
+        } else
+        {
+          double X = -1.0, Y = -1.0;
+          for (int j = 0; j &lt; 4; ++j)
+          {
+            m_destPoly.push_back(IntPoint(
+              Round(m_srcPoly[0].X + X * delta),
+              Round(m_srcPoly[0].Y + Y * delta)));
+            if (X &lt; 0)
+              X = 1;
+            else if (Y &lt; 0)
+              Y = 1;
+            else
+              X = -1;
+          }
+        }
+        m_destPolys.push_back(m_destPoly);
+        continue;
       }
+      //build m_normals ...
+      m_normals.clear();
+      m_normals.reserve(len);
+      for (int j = 0; j &lt; len - 1; ++j)
+        m_normals.push_back(GetUnitNormal(m_srcPoly[j], m_srcPoly[j + 1]));
+      if (node.m_endtype == etClosedLine || node.m_endtype == etClosedPolygon)
+        m_normals.push_back(GetUnitNormal(m_srcPoly[len - 1], m_srcPoly[0]));
       else
+        m_normals.push_back(DoublePoint(m_normals[len - 2]));
+
+      if (node.m_endtype == etClosedPolygon)
       {
-        int j = len - 1;
-        k = len - 2;
-        m_sinA = 0;
-        m_normals[j] = DoublePoint(-m_normals[j].X, -m_normals[j].Y);
-        if (node.m_endtype == etOpenSquare)
-          DoSquare(j, k);
-        else
-          DoRound(j, k);
-      }
+        int k = len - 1;
+        for (int j = 0; j &lt; len; ++j)
+          OffsetPoint(j, k, node.m_jointype);
+        m_destPolys.push_back(m_destPoly);
+      } else if (node.m_endtype == etClosedLine)
+      {
+        int k = len - 1;
+        for (int j = 0; j &lt; len; ++j)
+          OffsetPoint(j, k, node.m_jointype);
+        m_destPolys.push_back(m_destPoly);
+        m_destPoly.clear();
+        //re-build m_normals ...
+        DoublePoint n = m_normals[len - 1];
+        for (int j = len - 1; j &gt; 0; j--)
+          m_normals[j] = DoublePoint(-m_normals[j - 1].X, -m_normals[j - 1].Y);
+        m_normals[0] = DoublePoint(-n.X, -n.Y);
+        k = 0;
+        for (int j = len - 1; j &gt;= 0; j--)
+          OffsetPoint(j, k, node.m_jointype);
+        m_destPolys.push_back(m_destPoly);
+      } else
+      {
+        int k = 0;
+        for (int j = 1; j &lt; len - 1; ++j)
+          OffsetPoint(j, k, node.m_jointype);
+
+        IntPoint pt1;
+        if (node.m_endtype == etOpenButt)
+        {
+          int j = len - 1;
+          pt1 = IntPoint((cInt) Round(m_srcPoly[j].X + m_normals[j].X *
+                                                       delta), (cInt) Round(m_srcPoly[j].Y + m_normals[j].Y * delta));
+          m_destPoly.push_back(pt1);
+          pt1 = IntPoint((cInt) Round(m_srcPoly[j].X - m_normals[j].X *
+                                                       delta), (cInt) Round(m_srcPoly[j].Y - m_normals[j].Y * delta));
+          m_destPoly.push_back(pt1);
+        } else
+        {
+          int j = len - 1;
+          k = len - 2;
+          m_sinA = 0;
+          m_normals[j] = DoublePoint(-m_normals[j].X, -m_normals[j].Y);
+          if (node.m_endtype == etOpenSquare)
+            DoSquare(j, k);
+          else
+            DoRound(j, k);
+        }
 
-      //re-build m_normals ...
-      for (int j = len - 1; j &gt; 0; j--)
-        m_normals[j] = DoublePoint(-m_normals[j - 1].X, -m_normals[j - 1].Y);
-      m_normals[0] = DoublePoint(-m_normals[1].X, -m_normals[1].Y);
+        //re-build m_normals ...
+        for (int j = len - 1; j &gt; 0; j--)
+          m_normals[j] = DoublePoint(-m_normals[j - 1].X, -m_normals[j - 1].Y);
+        m_normals[0] = DoublePoint(-m_normals[1].X, -m_normals[1].Y);
 
-      k = len - 1;
-      for (int j = k - 1; j &gt; 0; --j) OffsetPoint(j, k, node.m_jointype);
+        k = len - 1;
+        for (int j = k - 1; j &gt; 0; --j)
+          OffsetPoint(j, k, node.m_jointype);
 
-      if (node.m_endtype == etOpenButt)
-      {
-        pt1 = IntPoint((cInt)Round(m_srcPoly[0].X - m_normals[0].X * delta),
-          (cInt)Round(m_srcPoly[0].Y - m_normals[0].Y * delta));
-        m_destPoly.push_back(pt1);
-        pt1 = IntPoint((cInt)Round(m_srcPoly[0].X + m_normals[0].X * delta),
-          (cInt)Round(m_srcPoly[0].Y + m_normals[0].Y * delta));
-        m_destPoly.push_back(pt1);
-      }
-      else
-      {
-        k = 1;
-        m_sinA = 0;
-        if (node.m_endtype == etOpenSquare)
-          DoSquare(0, 1);
-        else
-          DoRound(0, 1);
+        if (node.m_endtype == etOpenButt)
+        {
+          pt1 = IntPoint((cInt) Round(m_srcPoly[0].X - m_normals[0].X * delta),
+                         (cInt) Round(m_srcPoly[0].Y - m_normals[0].Y * delta));
+          m_destPoly.push_back(pt1);
+          pt1 = IntPoint((cInt) Round(m_srcPoly[0].X + m_normals[0].X * delta),
+                         (cInt) Round(m_srcPoly[0].Y + m_normals[0].Y * delta));
+          m_destPoly.push_back(pt1);
+        } else
+        {
+          k = 1;
+          m_sinA = 0;
+          if (node.m_endtype == etOpenSquare)
+            DoSquare(0, 1);
+          else
+            DoRound(0, 1);
+        }
+        m_destPolys.push_back(m_destPoly);
       }
-      m_destPolys.push_back(m_destPoly);
     }
   }
-}
 //------------------------------------------------------------------------------
 
-void ClipperOffset::OffsetPoint(int j, int&amp; k, JoinType jointype)
-{
-  //cross product ...
-  m_sinA = (m_normals[k].X * m_normals[j].Y - m_normals[j].X * m_normals[k].Y);
-  if (std::fabs(m_sinA * m_delta) &lt; 1.0) 
+  void ClipperOffset::OffsetPoint(int j, int &amp;k, JoinType jointype)
   {
-    //dot product ...
-    double cosA = (m_normals[k].X * m_normals[j].X + m_normals[j].Y * m_normals[k].Y ); 
-    if (cosA &gt; 0) // angle =&gt; 0 degrees
+    //cross product ...
+    m_sinA = (m_normals[k].X * m_normals[j].Y - m_normals[j].X * m_normals[k].Y);
+    if (std::fabs(m_sinA * m_delta) &lt; 1.0)
     {
-      m_destPoly.push_back(IntPoint(Round(m_srcPoly[j].X + m_normals[k].X * m_delta),
-        Round(m_srcPoly[j].Y + m_normals[k].Y * m_delta)));
-      return; 
-    }
-    //else angle =&gt; 180 degrees   
-  }
-  else if (m_sinA &gt; 1.0) m_sinA = 1.0;
-  else if (m_sinA &lt; -1.0) m_sinA = -1.0;
+      //dot product ...
+      double cosA = (m_normals[k].X * m_normals[j].X + m_normals[j].Y * m_normals[k].Y);
+      if (cosA &gt; 0) // angle =&gt; 0 degrees
+      {
+        m_destPoly.push_back(IntPoint(Round(m_srcPoly[j].X + m_normals[k].X * m_delta),
+                                      Round(m_srcPoly[j].Y + m_normals[k].Y * m_delta)));
+        return;
+      }
+      //else angle =&gt; 180 degrees
+    } else if (m_sinA &gt; 1.0)
+      m_sinA = 1.0;
+    else if (m_sinA &lt; -1.0)
+      m_sinA = -1.0;
 
-  if (m_sinA * m_delta &lt; 0)
-  {
-    m_destPoly.push_back(IntPoint(Round(m_srcPoly[j].X + m_normals[k].X * m_delta),
-      Round(m_srcPoly[j].Y + m_normals[k].Y * m_delta)));
-    m_destPoly.push_back(m_srcPoly[j]);
-    m_destPoly.push_back(IntPoint(Round(m_srcPoly[j].X + m_normals[j].X * m_delta),
-      Round(m_srcPoly[j].Y + m_normals[j].Y * m_delta)));
-  }
-  else
-    switch (jointype)
+    if (m_sinA * m_delta &lt; 0)
     {
-      case jtMiter:
+      m_destPoly.push_back(IntPoint(Round(m_srcPoly[j].X + m_normals[k].X * m_delta),
+                                    Round(m_srcPoly[j].Y + m_normals[k].Y * m_delta)));
+      m_destPoly.push_back(m_srcPoly[j]);
+      m_destPoly.push_back(IntPoint(Round(m_srcPoly[j].X + m_normals[j].X * m_delta),
+                                    Round(m_srcPoly[j].Y + m_normals[j].Y * m_delta)));
+    } else
+      switch (jointype)
+      {
+        case jtMiter:
         {
           double r = 1 + (m_normals[j].X * m_normals[k].X +
-            m_normals[j].Y * m_normals[k].Y);
-          if (r &gt;= m_miterLim) DoMiter(j, k, r); else DoSquare(j, k);
+                          m_normals[j].Y * m_normals[k].Y);
+          if (r &gt;= m_miterLim)
+            DoMiter(j, k, r);
+          else
+            DoSquare(j, k);
           break;
         }
-      case jtSquare: DoSquare(j, k); break;
-      case jtRound: DoRound(j, k); break;
-    }
-  k = j;
-}
+        case jtSquare:
+          DoSquare(j, k);
+          break;
+        case jtRound:
+          DoRound(j, k);
+          break;
+      }
+    k = j;
+  }
 //------------------------------------------------------------------------------
 
-void ClipperOffset::DoSquare(int j, int k)
-{
-  double dx = std::tan(std::atan2(m_sinA,
-      m_normals[k].X * m_normals[j].X + m_normals[k].Y * m_normals[j].Y) / 4);
-  m_destPoly.push_back(IntPoint(
+  void ClipperOffset::DoSquare(int j, int k)
+  {
+    double dx = std::tan(std::atan2(m_sinA,
+                                    m_normals[k].X * m_normals[j].X + m_normals[k].Y * m_normals[j].Y) / 4);
+    m_destPoly.push_back(IntPoint(
       Round(m_srcPoly[j].X + m_delta * (m_normals[k].X - m_normals[k].Y * dx)),
       Round(m_srcPoly[j].Y + m_delta * (m_normals[k].Y + m_normals[k].X * dx))));
-  m_destPoly.push_back(IntPoint(
+    m_destPoly.push_back(IntPoint(
       Round(m_srcPoly[j].X + m_delta * (m_normals[j].X + m_normals[j].Y * dx)),
       Round(m_srcPoly[j].Y + m_delta * (m_normals[j].Y - m_normals[j].X * dx))));
-}
+  }
 //------------------------------------------------------------------------------
 
-void ClipperOffset::DoMiter(int j, int k, double r)
-{
-  double q = m_delta / r;
-  m_destPoly.push_back(IntPoint(Round(m_srcPoly[j].X + (m_normals[k].X + m_normals[j].X) * q),
-      Round(m_srcPoly[j].Y + (m_normals[k].Y + m_normals[j].Y) * q)));
-}
+  void ClipperOffset::DoMiter(int j, int k, double r)
+  {
+    double q = m_delta / r;
+    m_destPoly.push_back(IntPoint(Round(m_srcPoly[j].X + (m_normals[k].X + m_normals[j].X) * q),
+                                  Round(m_srcPoly[j].Y + (m_normals[k].Y + m_normals[j].Y) * q)));
+  }
 //------------------------------------------------------------------------------
 
-void ClipperOffset::DoRound(int j, int k)
-{
-  double a = std::atan2(m_sinA,
-  m_normals[k].X * m_normals[j].X + m_normals[k].Y * m_normals[j].Y);
-  int steps = std::max((int)Round(m_StepsPerRad * std::fabs(a)), 1);
-
-  double X = m_normals[k].X, Y = m_normals[k].Y, X2;
-  for (int i = 0; i &lt; steps; ++i)
+  void ClipperOffset::DoRound(int j, int k)
   {
-    m_destPoly.push_back(IntPoint(
+    double a = std::atan2(m_sinA,
+                          m_normals[k].X * m_normals[j].X + m_normals[k].Y * m_normals[j].Y);
+    int steps = std::max((int) Round(m_StepsPerRad * std::fabs(a)), 1);
+
+    double X = m_normals[k].X, Y = m_normals[k].Y, X2;
+    for (int i = 0; i &lt; steps; ++i)
+    {
+      m_destPoly.push_back(IntPoint(
         Round(m_srcPoly[j].X + X * m_delta),
         Round(m_srcPoly[j].Y + Y * m_delta)));
-    X2 = X;
-    X = X * m_cos - m_sin * Y;
-    Y = X2 * m_sin + Y * m_cos;
+      X2 = X;
+      X = X * m_cos - m_sin * Y;
+      Y = X2 * m_sin + Y * m_cos;
+    }
+    m_destPoly.push_back(IntPoint(
+      Round(m_srcPoly[j].X + m_normals[j].X * m_delta),
+      Round(m_srcPoly[j].Y + m_normals[j].Y * m_delta)));
   }
-  m_destPoly.push_back(IntPoint(
-  Round(m_srcPoly[j].X + m_normals[j].X * m_delta),
-  Round(m_srcPoly[j].Y + m_normals[j].Y * m_delta)));
-}
 
 //------------------------------------------------------------------------------
 // Miscellaneous public functions
 //------------------------------------------------------------------------------
 
-void Clipper::DoSimplePolygons()
-{
-  PolyOutList::size_type i = 0;
-  while (i &lt; m_PolyOuts.size()) 
+  void Clipper::DoSimplePolygons()
   {
-    OutRec* outrec = m_PolyOuts[i++];
-    OutPt* op = outrec-&gt;Pts;
-    if (!op || outrec-&gt;IsOpen) continue;
-    do //for each Pt in Polygon until duplicate found do ...
+    PolyOutList::size_type i = 0;
+    while (i &lt; m_PolyOuts.size())
     {
-      OutPt* op2 = op-&gt;Next;
-      while (op2 != outrec-&gt;Pts) 
+      OutRec *outrec = m_PolyOuts[i++];
+      OutPt *op = outrec-&gt;Pts;
+      if (!op || outrec-&gt;IsOpen)
+        continue;
+      do //for each Pt in Polygon until duplicate found do ...
       {
-        if ((op-&gt;Pt == op2-&gt;Pt) &amp;&amp; op2-&gt;Next != op &amp;&amp; op2-&gt;Prev != op) 
+        OutPt *op2 = op-&gt;Next;
+        while (op2 != outrec-&gt;Pts)
         {
-          //split the polygon into two ...
-          OutPt* op3 = op-&gt;Prev;
-          OutPt* op4 = op2-&gt;Prev;
-          op-&gt;Prev = op4;
-          op4-&gt;Next = op;
-          op2-&gt;Prev = op3;
-          op3-&gt;Next = op2;
-
-          outrec-&gt;Pts = op;
-          OutRec* outrec2 = CreateOutRec();
-          outrec2-&gt;Pts = op2;
-          UpdateOutPtIdxs(*outrec2);
-          if (Poly2ContainsPoly1(outrec2-&gt;Pts, outrec-&gt;Pts))
-          {
-            //OutRec2 is contained by OutRec1 ...
-            outrec2-&gt;IsHole = !outrec-&gt;IsHole;
-            outrec2-&gt;FirstLeft = outrec;
-            if (m_UsingPolyTree) FixupFirstLefts2(outrec2, outrec);
-          }
-          else
-            if (Poly2ContainsPoly1(outrec-&gt;Pts, outrec2-&gt;Pts))
+          if ((op-&gt;Pt == op2-&gt;Pt) &amp;&amp; op2-&gt;Next != op &amp;&amp; op2-&gt;Prev != op)
           {
-            //OutRec1 is contained by OutRec2 ...
-            outrec2-&gt;IsHole = outrec-&gt;IsHole;
-            outrec-&gt;IsHole = !outrec2-&gt;IsHole;
-            outrec2-&gt;FirstLeft = outrec-&gt;FirstLeft;
-            outrec-&gt;FirstLeft = outrec2;
-            if (m_UsingPolyTree) FixupFirstLefts2(outrec, outrec2);
-            }
-            else
-          {
-            //the 2 polygons are separate ...
-            outrec2-&gt;IsHole = outrec-&gt;IsHole;
-            outrec2-&gt;FirstLeft = outrec-&gt;FirstLeft;
-            if (m_UsingPolyTree) FixupFirstLefts1(outrec, outrec2);
+            //split the polygon into two ...
+            OutPt *op3 = op-&gt;Prev;
+            OutPt *op4 = op2-&gt;Prev;
+            op-&gt;Prev = op4;
+            op4-&gt;Next = op;
+            op2-&gt;Prev = op3;
+            op3-&gt;Next = op2;
+
+            outrec-&gt;Pts = op;
+            OutRec *outrec2 = CreateOutRec();
+            outrec2-&gt;Pts = op2;
+            UpdateOutPtIdxs(*outrec2);
+            if (Poly2ContainsPoly1(outrec2-&gt;Pts, outrec-&gt;Pts))
+            {
+              //OutRec2 is contained by OutRec1 ...
+              outrec2-&gt;IsHole = !outrec-&gt;IsHole;
+              outrec2-&gt;FirstLeft = outrec;
+              if (m_UsingPolyTree)
+                FixupFirstLefts2(outrec2, outrec);
+            } else if (Poly2ContainsPoly1(outrec-&gt;Pts, outrec2-&gt;Pts))
+            {
+              //OutRec1 is contained by OutRec2 ...
+              outrec2-&gt;IsHole = outrec-&gt;IsHole;
+              outrec-&gt;IsHole = !outrec2-&gt;IsHole;
+              outrec2-&gt;FirstLeft = outrec-&gt;FirstLeft;
+              outrec-&gt;FirstLeft = outrec2;
+              if (m_UsingPolyTree)
+                FixupFirstLefts2(outrec, outrec2);
+            } else
+            {
+              //the 2 polygons are separate ...
+              outrec2-&gt;IsHole = outrec-&gt;IsHole;
+              outrec2-&gt;FirstLeft = outrec-&gt;FirstLeft;
+              if (m_UsingPolyTree)
+                FixupFirstLefts1(outrec, outrec2);
             }
-          op2 = op; //ie get ready for the Next iteration
+            op2 = op; //ie get ready for the Next iteration
+          }
+          op2 = op2-&gt;Next;
         }
-        op2 = op2-&gt;Next;
-      }
-      op = op-&gt;Next;
+        op = op-&gt;Next;
+      } while (op != outrec-&gt;Pts);
     }
-    while (op != outrec-&gt;Pts);
   }
-}
 //------------------------------------------------------------------------------
 
-void ReversePath(Path&amp; p)
-{
-  std::reverse(p.begin(), p.end());
-}
+  void ReversePath(Path &amp;p)
+  {
+    std::reverse(p.begin(), p.end());
+  }
 //------------------------------------------------------------------------------
 
-void ReversePaths(Paths&amp; p)
-{
-  for (Paths::size_type i = 0; i &lt; p.size(); ++i)
-    ReversePath(p[i]);
-}
+  void ReversePaths(Paths &amp;p)
+  {
+    for (Paths::size_type i = 0; i &lt; p.size(); ++i)
+      ReversePath(p[i]);
+  }
 //------------------------------------------------------------------------------
 
-void SimplifyPolygon(const Path &amp;in_poly, Paths &amp;out_polys, PolyFillType fillType)
-{
-  Clipper c;
-  c.StrictlySimple(true);
-  c.AddPath(in_poly, ptSubject, true);
-  c.Execute(ctUnion, out_polys, fillType, fillType);
-}
+  void SimplifyPolygon(const Path &amp;in_poly, Paths &amp;out_polys, PolyFillType fillType)
+  {
+    Clipper c;
+    c.StrictlySimple(true);
+    c.AddPath(in_poly, ptSubject, true);
+    c.Execute(ctUnion, out_polys, fillType, fillType);
+  }
 //------------------------------------------------------------------------------
 
-void SimplifyPolygons(const Paths &amp;in_polys, Paths &amp;out_polys, PolyFillType fillType)
-{
-  Clipper c;
-  c.StrictlySimple(true);
-  c.AddPaths(in_polys, ptSubject, true);
-  c.Execute(ctUnion, out_polys, fillType, fillType);
-}
+  void SimplifyPolygons(const Paths &amp;in_polys, Paths &amp;out_polys, PolyFillType fillType)
+  {
+    Clipper c;
+    c.StrictlySimple(true);
+    c.AddPaths(in_polys, ptSubject, true);
+    c.Execute(ctUnion, out_polys, fillType, fillType);
+  }
 //------------------------------------------------------------------------------
 
-void SimplifyPolygons(Paths &amp;polys, PolyFillType fillType)
-{
-  SimplifyPolygons(polys, polys, fillType);
-}
+  void SimplifyPolygons(Paths &amp;polys, PolyFillType fillType)
+  {
+    SimplifyPolygons(polys, polys, fillType);
+  }
 //------------------------------------------------------------------------------
 
-inline double DistanceSqrd(const IntPoint&amp; pt1, const IntPoint&amp; pt2)
-{
-  double Dx = ((double)pt1.X - pt2.X);
-  double dy = ((double)pt1.Y - pt2.Y);
-  return (Dx*Dx + dy*dy);
-}
+  inline double DistanceSqrd(const IntPoint &amp;pt1, const IntPoint &amp;pt2)
+  {
+    double Dx = ((double) pt1.X - pt2.X);
+    double dy = ((double) pt1.Y - pt2.Y);
+    return (Dx * Dx + dy * dy);
+  }
 //------------------------------------------------------------------------------
 
-double DistanceFromLineSqrd(
-  const IntPoint&amp; pt, const IntPoint&amp; ln1, const IntPoint&amp; ln2)
-{
-  //The equation of a line in general form (Ax + By + C = 0)
-  //given 2 points (x,y) &amp; (x,y) is ...
-  //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0
-  //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y
-  //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)
-  //see http://en.wikipedia.org/wiki/Perpendicular_distance
-  double A = double(ln1.Y - ln2.Y);
-  double B = double(ln2.X - ln1.X);
-  double C = A * ln1.X  + B * ln1.Y;
-  C = A * pt.X + B * pt.Y - C;
-  return (C * C) / (A * A + B * B);
-}
+  double DistanceFromLineSqrd(
+    const IntPoint &amp;pt, const IntPoint &amp;ln1, const IntPoint &amp;ln2)
+  {
+    //The equation of a line in general form (Ax + By + C = 0)
+    //given 2 points (x,y) &amp; (x,y) is ...
+    //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0
+    //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y
+    //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)
+    //see http://en.wikipedia.org/wiki/Perpendicular_distance
+    double A = double(ln1.Y - ln2.Y);
+    double B = double(ln2.X - ln1.X);
+    double C = A * ln1.X + B * ln1.Y;
+    C = A * pt.X + B * pt.Y - C;
+    return (C * C) / (A * A + B * B);
+  }
 //---------------------------------------------------------------------------
 
-bool SlopesNearCollinear(const IntPoint&amp; pt1, 
-    const IntPoint&amp; pt2, const IntPoint&amp; pt3, double distSqrd)
-{
-  //this function is more accurate when the point that's geometrically
-  //between the other 2 points is the one that's tested for distance.
-  //ie makes it more likely to pick up 'spikes' ...
-	if (Abs(pt1.X - pt2.X) &gt; Abs(pt1.Y - pt2.Y))
-	{
-    if ((pt1.X &gt; pt2.X) == (pt1.X &lt; pt3.X))
-      return DistanceFromLineSqrd(pt1, pt2, pt3) &lt; distSqrd;
-    else if ((pt2.X &gt; pt1.X) == (pt2.X &lt; pt3.X))
-      return DistanceFromLineSqrd(pt2, pt1, pt3) &lt; distSqrd;
-		else
-	    return DistanceFromLineSqrd(pt3, pt1, pt2) &lt; distSqrd;
-	}
-	else
-	{
-    if ((pt1.Y &gt; pt2.Y) == (pt1.Y &lt; pt3.Y))
-      return DistanceFromLineSqrd(pt1, pt2, pt3) &lt; distSqrd;
-    else if ((pt2.Y &gt; pt1.Y) == (pt2.Y &lt; pt3.Y))
-      return DistanceFromLineSqrd(pt2, pt1, pt3) &lt; distSqrd;
-		else
-      return DistanceFromLineSqrd(pt3, pt1, pt2) &lt; distSqrd;
-	}
-}
+  bool SlopesNearCollinear(const IntPoint &amp;pt1,
+                           const IntPoint &amp;pt2, const IntPoint &amp;pt3, double distSqrd)
+  {
+    //this function is more accurate when the point that's geometrically
+    //between the other 2 points is the one that's tested for distance.
+    //ie makes it more likely to pick up 'spikes' ...
+    if (Abs(pt1.X - pt2.X) &gt; Abs(pt1.Y - pt2.Y))
+    {
+      if ((pt1.X &gt; pt2.X) == (pt1.X &lt; pt3.X))
+        return DistanceFromLineSqrd(pt1, pt2, pt3) &lt; distSqrd;
+      else if ((pt2.X &gt; pt1.X) == (pt2.X &lt; pt3.X))
+        return DistanceFromLineSqrd(pt2, pt1, pt3) &lt; distSqrd;
+      else
+        return DistanceFromLineSqrd(pt3, pt1, pt2) &lt; distSqrd;
+    } else
+    {
+      if ((pt1.Y &gt; pt2.Y) == (pt1.Y &lt; pt3.Y))
+        return DistanceFromLineSqrd(pt1, pt2, pt3) &lt; distSqrd;
+      else if ((pt2.Y &gt; pt1.Y) == (pt2.Y &lt; pt3.Y))
+        return DistanceFromLineSqrd(pt2, pt1, pt3) &lt; distSqrd;
+      else
+        return DistanceFromLineSqrd(pt3, pt1, pt2) &lt; distSqrd;
+    }
+  }
 //------------------------------------------------------------------------------
 
-bool PointsAreClose(IntPoint pt1, IntPoint pt2, double distSqrd)
-{
-    double Dx = (double)pt1.X - pt2.X;
-    double dy = (double)pt1.Y - pt2.Y;
+  bool PointsAreClose(IntPoint pt1, IntPoint pt2, double distSqrd)
+  {
+    double Dx = (double) pt1.X - pt2.X;
+    double dy = (double) pt1.Y - pt2.Y;
     return ((Dx * Dx) + (dy * dy) &lt;= distSqrd);
-}
-//------------------------------------------------------------------------------
-
-OutPt* ExcludeOp(OutPt* op)
-{
-  OutPt* result = op-&gt;Prev;
-  result-&gt;Next = op-&gt;Next;
-  op-&gt;Next-&gt;Prev = result;
-  result-&gt;Idx = 0;
-  return result;
-}
+  }
 //------------------------------------------------------------------------------
 
-void CleanPolygon(const Path&amp; in_poly, Path&amp; out_poly, double distance)
-{
-  //distance = proximity in units/pixels below which vertices
-  //will be stripped. Default ~= sqrt(2).
-  
-  size_t size = in_poly.size();
-  
-  if (size == 0) 
+  OutPt *ExcludeOp(OutPt *op)
   {
-    out_poly.clear();
-    return;
+    OutPt *result = op-&gt;Prev;
+    result-&gt;Next = op-&gt;Next;
+    op-&gt;Next-&gt;Prev = result;
+    result-&gt;Idx = 0;
+    return result;
   }
+//------------------------------------------------------------------------------
 
-  OutPt* outPts = new OutPt[size];
-  for (size_t i = 0; i &lt; size; ++i)
+  void CleanPolygon(const Path &amp;in_poly, Path &amp;out_poly, double distance)
   {
-    outPts[i].Pt = in_poly[i];
-    outPts[i].Next = &amp;outPts[(i + 1) % size];
-    outPts[i].Next-&gt;Prev = &amp;outPts[i];
-    outPts[i].Idx = 0;
-  }
+    //distance = proximity in units/pixels below which vertices
+    //will be stripped. Default ~= sqrt(2).
 
-  double distSqrd = distance * distance;
-  OutPt* op = &amp;outPts[0];
-  while (op-&gt;Idx == 0 &amp;&amp; op-&gt;Next != op-&gt;Prev) 
-  {
-    if (PointsAreClose(op-&gt;Pt, op-&gt;Prev-&gt;Pt, distSqrd))
+    size_t size = in_poly.size();
+
+    if (size == 0)
     {
-      op = ExcludeOp(op);
-      size--;
-    } 
-    else if (PointsAreClose(op-&gt;Prev-&gt;Pt, op-&gt;Next-&gt;Pt, distSqrd))
+      out_poly.clear();
+      return;
+    }
+
+    OutPt *outPts = new OutPt[size];
+    for (size_t i = 0; i &lt; size; ++i)
     {
-      ExcludeOp(op-&gt;Next);
-      op = ExcludeOp(op);
-      size -= 2;
+      outPts[i].Pt = in_poly[i];
+      outPts[i].Next = &amp;outPts[(i + 1) % size];
+      outPts[i].Next-&gt;Prev = &amp;outPts[i];
+      outPts[i].Idx = 0;
     }
-    else if (SlopesNearCollinear(op-&gt;Prev-&gt;Pt, op-&gt;Pt, op-&gt;Next-&gt;Pt, distSqrd))
+
+    double distSqrd = distance * distance;
+    OutPt *op = &amp;outPts[0];
+    while (op-&gt;Idx == 0 &amp;&amp; op-&gt;Next != op-&gt;Prev)
     {
-      op = ExcludeOp(op);
-      size--;
+      if (PointsAreClose(op-&gt;Pt, op-&gt;Prev-&gt;Pt, distSqrd))
+      {
+        op = ExcludeOp(op);
+        size--;
+      } else if (PointsAreClose(op-&gt;Prev-&gt;Pt, op-&gt;Next-&gt;Pt, distSqrd))
+      {
+        ExcludeOp(op-&gt;Next);
+        op = ExcludeOp(op);
+        size -= 2;
+      } else if (SlopesNearCollinear(op-&gt;Prev-&gt;Pt, op-&gt;Pt, op-&gt;Next-&gt;Pt, distSqrd))
+      {
+        op = ExcludeOp(op);
+        size--;
+      } else
+      {
+        op-&gt;Idx = 1;
+        op = op-&gt;Next;
+      }
     }
-    else
+
+    if (size &lt; 3)
+      size = 0;
+    out_poly.resize(size);
+    for (size_t i = 0; i &lt; size; ++i)
     {
-      op-&gt;Idx = 1;
+      out_poly[i] = op-&gt;Pt;
       op = op-&gt;Next;
     }
+    delete[] outPts;
   }
+//------------------------------------------------------------------------------
 
-  if (size &lt; 3) size = 0;
-  out_poly.resize(size);
-  for (size_t i = 0; i &lt; size; ++i)
+  void CleanPolygon(Path &amp;poly, double distance)
   {
-    out_poly[i] = op-&gt;Pt;
-    op = op-&gt;Next;
+    CleanPolygon(poly, poly, distance);
   }
-  delete [] outPts;
-}
-//------------------------------------------------------------------------------
-
-void CleanPolygon(Path&amp; poly, double distance)
-{
-  CleanPolygon(poly, poly, distance);
-}
 //------------------------------------------------------------------------------
 
-void CleanPolygons(const Paths&amp; in_polys, Paths&amp; out_polys, double distance)
-{
-  out_polys.resize(in_polys.size());
-  for (Paths::size_type i = 0; i &lt; in_polys.size(); ++i)
-    CleanPolygon(in_polys[i], out_polys[i], distance);
-}
+  void CleanPolygons(const Paths &amp;in_polys, Paths &amp;out_polys, double distance)
+  {
+    out_polys.resize(in_polys.size());
+    for (Paths::size_type i = 0; i &lt; in_polys.size(); ++i)
+      CleanPolygon(in_polys[i], out_polys[i], distance);
+  }
 //------------------------------------------------------------------------------
 
-void CleanPolygons(Paths&amp; polys, double distance)
-{
-  CleanPolygons(polys, polys, distance);
-}
+  void CleanPolygons(Paths &amp;polys, double distance)
+  {
+    CleanPolygons(polys, polys, distance);
+  }
 //------------------------------------------------------------------------------
 
-void Minkowski(const Path&amp; poly, const Path&amp; path, 
-  Paths&amp; solution, bool isSum, bool isClosed)
-{
-  int delta = (isClosed ? 1 : 0);
-  size_t polyCnt = poly.size();
-  size_t pathCnt = path.size();
-  Paths pp;
-  pp.reserve(pathCnt);
-  if (isSum)
-    for (size_t i = 0; i &lt; pathCnt; ++i)
-    {
-      Path p;
-      p.reserve(polyCnt);
-      for (size_t j = 0; j &lt; poly.size(); ++j)
-        p.push_back(IntPoint(path[i].X + poly[j].X, path[i].Y + poly[j].Y));
-      pp.push_back(p);
-    }
-  else
-    for (size_t i = 0; i &lt; pathCnt; ++i)
-    {
-      Path p;
-      p.reserve(polyCnt);
-      for (size_t j = 0; j &lt; poly.size(); ++j)
-        p.push_back(IntPoint(path[i].X - poly[j].X, path[i].Y - poly[j].Y));
-      pp.push_back(p);
-    }
+  void Minkowski(const Path &amp;poly, const Path &amp;path,
+                 Paths &amp;solution, bool isSum, bool isClosed)
+  {
+    int delta = (isClosed ? 1 : 0);
+    size_t polyCnt = poly.size();
+    size_t pathCnt = path.size();
+    Paths pp;
+    pp.reserve(pathCnt);
+    if (isSum)
+      for (size_t i = 0; i &lt; pathCnt; ++i)
+      {
+        Path p;
+        p.reserve(polyCnt);
+        for (size_t j = 0; j &lt; poly.size(); ++j)
+          p.push_back(IntPoint(path[i].X + poly[j].X, path[i].Y + poly[j].Y));
+        pp.push_back(p);
+      }
+    else
+      for (size_t i = 0; i &lt; pathCnt; ++i)
+      {
+        Path p;
+        p.reserve(polyCnt);
+        for (size_t j = 0; j &lt; poly.size(); ++j)
+          p.push_back(IntPoint(path[i].X - poly[j].X, path[i].Y - poly[j].Y));
+        pp.push_back(p);
+      }
 
-  solution.clear();
-  solution.reserve((pathCnt + delta) * (polyCnt + 1));
-  for (size_t i = 0; i &lt; pathCnt - 1 + delta; ++i)
-    for (size_t j = 0; j &lt; polyCnt; ++j)
-    {
-      Path quad;
-      quad.reserve(4);
-      quad.push_back(pp[i % pathCnt][j % polyCnt]);
-      quad.push_back(pp[(i + 1) % pathCnt][j % polyCnt]);
-      quad.push_back(pp[(i + 1) % pathCnt][(j + 1) % polyCnt]);
-      quad.push_back(pp[i % pathCnt][(j + 1) % polyCnt]);
-      if (!Orientation(quad)) ReversePath(quad);
-      solution.push_back(quad);
-    }
-}
+    solution.clear();
+    solution.reserve((pathCnt + delta) * (polyCnt + 1));
+    for (size_t i = 0; i &lt; pathCnt - 1 + delta; ++i)
+      for (size_t j = 0; j &lt; polyCnt; ++j)
+      {
+        Path quad;
+        quad.reserve(4);
+        quad.push_back(pp[i % pathCnt][j % polyCnt]);
+        quad.push_back(pp[(i + 1) % pathCnt][j % polyCnt]);
+        quad.push_back(pp[(i + 1) % pathCnt][(j + 1) % polyCnt]);
+        quad.push_back(pp[i % pathCnt][(j + 1) % polyCnt]);
+        if (!Orientation(quad))
+          ReversePath(quad);
+        solution.push_back(quad);
+      }
+  }
 //------------------------------------------------------------------------------
 
-void MinkowskiSum(const Path&amp; pattern, const Path&amp; path, Paths&amp; solution, bool pathIsClosed)
-{
-  Minkowski(pattern, path, solution, true, pathIsClosed);
-  Clipper c;
-  c.AddPaths(solution, ptSubject, true);
-  c.Execute(ctUnion, solution, pftNonZero, pftNonZero);
-}
+  void MinkowskiSum(const Path &amp;pattern, const Path &amp;path, Paths &amp;solution, bool pathIsClosed)
+  {
+    Minkowski(pattern, path, solution, true, pathIsClosed);
+    Clipper c;
+    c.AddPaths(solution, ptSubject, true);
+    c.Execute(ctUnion, solution, pftNonZero, pftNonZero);
+  }
 //------------------------------------------------------------------------------
 
-void TranslatePath(const Path&amp; input, Path&amp; output, const IntPoint delta)
-{
-  //precondition: input != output
-  output.resize(input.size());
-  for (size_t i = 0; i &lt; input.size(); ++i)
-    output[i] = IntPoint(input[i].X + delta.X, input[i].Y + delta.Y);
-}
+  void TranslatePath(const Path &amp;input, Path &amp;output, const IntPoint delta)
+  {
+    //precondition: input != output
+    output.resize(input.size());
+    for (size_t i = 0; i &lt; input.size(); ++i)
+      output[i] = IntPoint(input[i].X + delta.X, input[i].Y + delta.Y);
+  }
 //------------------------------------------------------------------------------
 
-void MinkowskiSum(const Path&amp; pattern, const Paths&amp; paths, Paths&amp; solution, bool pathIsClosed)
-{
-  Clipper c;
-  for (size_t i = 0; i &lt; paths.size(); ++i)
+  void MinkowskiSum(const Path &amp;pattern, const Paths &amp;paths, Paths &amp;solution, bool pathIsClosed)
   {
-    Paths tmp;
-    Minkowski(pattern, paths[i], tmp, true, pathIsClosed);
-    c.AddPaths(tmp, ptSubject, true);
-    if (pathIsClosed)
+    Clipper c;
+    for (size_t i = 0; i &lt; paths.size(); ++i)
     {
-      Path tmp2;
-      TranslatePath(paths[i], tmp2, pattern[0]);
-      c.AddPath(tmp2, ptClip, true);
+      Paths tmp;
+      Minkowski(pattern, paths[i], tmp, true, pathIsClosed);
+      c.AddPaths(tmp, ptSubject, true);
+      if (pathIsClosed)
+      {
+        Path tmp2;
+        TranslatePath(paths[i], tmp2, pattern[0]);
+        c.AddPath(tmp2, ptClip, true);
+      }
     }
-  }
     c.Execute(ctUnion, solution, pftNonZero, pftNonZero);
-}
+  }
 //------------------------------------------------------------------------------
 
-void MinkowskiDiff(const Path&amp; poly1, const Path&amp; poly2, Paths&amp; solution)
-{
-  Minkowski(poly1, poly2, solution, false, true);
-  Clipper c;
-  c.AddPaths(solution, ptSubject, true);
-  c.Execute(ctUnion, solution, pftNonZero, pftNonZero);
-}
+  void MinkowskiDiff(const Path &amp;poly1, const Path &amp;poly2, Paths &amp;solution)
+  {
+    Minkowski(poly1, poly2, solution, false, true);
+    Clipper c;
+    c.AddPaths(solution, ptSubject, true);
+    c.Execute(ctUnion, solution, pftNonZero, pftNonZero);
+  }
 //------------------------------------------------------------------------------
 
-enum NodeType {ntAny, ntOpen, ntClosed};
+  enum NodeType
+  {
+    ntAny, ntOpen, ntClosed
+  };
 
-void AddPolyNodeToPaths(const PolyNode&amp; polynode, NodeType nodetype, Paths&amp; paths)
-{
-  bool match = true;
-  if (nodetype == ntClosed) match = !polynode.IsOpen();
-  else if (nodetype == ntOpen) return;
-
-  if (!polynode.Contour.empty() &amp;&amp; match)
-    paths.push_back(polynode.Contour);
-  for (int i = 0; i &lt; polynode.ChildCount(); ++i)
-    AddPolyNodeToPaths(*polynode.Childs[i], nodetype, paths);
-}
+  void AddPolyNodeToPaths(const PolyNode &amp;polynode, NodeType nodetype, Paths &amp;paths)
+  {
+    bool match = true;
+    if (nodetype == ntClosed)
+      match = !polynode.IsOpen();
+    else if (nodetype == ntOpen)
+      return;
+
+    if (!polynode.Contour.empty() &amp;&amp; match)
+      paths.push_back(polynode.Contour);
+    for (int i = 0; i &lt; polynode.ChildCount(); ++i)
+      AddPolyNodeToPaths(*polynode.Childs[i], nodetype, paths);
+  }
 //------------------------------------------------------------------------------
 
-void PolyTreeToPaths(const PolyTree&amp; polytree, Paths&amp; paths)
-{
-  paths.resize(0); 
-  paths.reserve(polytree.Total());
-  AddPolyNodeToPaths(polytree, ntAny, paths);
-}
+  void PolyTreeToPaths(const PolyTree &amp;polytree, Paths &amp;paths)
+  {
+    paths.resize(0);
+    paths.reserve(polytree.Total());
+    AddPolyNodeToPaths(polytree, ntAny, paths);
+  }
 //------------------------------------------------------------------------------
 
-void ClosedPathsFromPolyTree(const PolyTree&amp; polytree, Paths&amp; paths)
-{
-  paths.resize(0); 
-  paths.reserve(polytree.Total());
-  AddPolyNodeToPaths(polytree, ntClosed, paths);
-}
+  void ClosedPathsFromPolyTree(const PolyTree &amp;polytree, Paths &amp;paths)
+  {
+    paths.resize(0);
+    paths.reserve(polytree.Total());
+    AddPolyNodeToPaths(polytree, ntClosed, paths);
+  }
 //------------------------------------------------------------------------------
 
-void OpenPathsFromPolyTree(PolyTree&amp; polytree, Paths&amp; paths)
-{
-  paths.resize(0); 
-  paths.reserve(polytree.Total());
-  //Open paths are top level only, so ...
-  for (int i = 0; i &lt; polytree.ChildCount(); ++i)
-    if (polytree.Childs[i]-&gt;IsOpen())
-      paths.push_back(polytree.Childs[i]-&gt;Contour);
-}
+  void OpenPathsFromPolyTree(PolyTree &amp;polytree, Paths &amp;paths)
+  {
+    paths.resize(0);
+    paths.reserve(polytree.Total());
+    //Open paths are top level only, so ...
+    for (int i = 0; i &lt; polytree.ChildCount(); ++i)
+      if (polytree.Childs[i]-&gt;IsOpen())
+        paths.push_back(polytree.Childs[i]-&gt;Contour);
+  }
 //------------------------------------------------------------------------------
 
-std::ostream&amp; operator &lt;&lt;(std::ostream &amp;s, const IntPoint &amp;p)
-{
-  s &lt;&lt; "(" &lt;&lt; p.X &lt;&lt; "," &lt;&lt; p.Y &lt;&lt; ")";
-  return s;
-}
+  std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, const IntPoint &amp;p)
+  {
+    s &lt;&lt; "(" &lt;&lt; p.X &lt;&lt; "," &lt;&lt; p.Y &lt;&lt; ")";
+    return s;
+  }
 //------------------------------------------------------------------------------
 
-std::ostream&amp; operator &lt;&lt;(std::ostream &amp;s, const Path &amp;p)
-{
-  if (p.empty()) return s;
-  Path::size_type last = p.size() -1;
-  for (Path::size_type i = 0; i &lt; last; i++)
-    s &lt;&lt; "(" &lt;&lt; p[i].X &lt;&lt; "," &lt;&lt; p[i].Y &lt;&lt; "), ";
-  s &lt;&lt; "(" &lt;&lt; p[last].X &lt;&lt; "," &lt;&lt; p[last].Y &lt;&lt; ")\n";
-  return s;
-}
+  std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, const Path &amp;p)
+  {
+    if (p.empty())
+      return s;
+    Path::size_type last = p.size() - 1;
+    for (Path::size_type i = 0; i &lt; last; i++)
+      s &lt;&lt; "(" &lt;&lt; p[i].X &lt;&lt; "," &lt;&lt; p[i].Y &lt;&lt; "), ";
+    s &lt;&lt; "(" &lt;&lt; p[last].X &lt;&lt; "," &lt;&lt; p[last].Y &lt;&lt; ")\n";
+    return s;
+  }
 //------------------------------------------------------------------------------
 
-std::ostream&amp; operator &lt;&lt;(std::ostream &amp;s, const Paths &amp;p)
-{
-  for (Paths::size_type i = 0; i &lt; p.size(); i++)
-    s &lt;&lt; p[i];
-  s &lt;&lt; "\n";
-  return s;
-}
+  std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, const Paths &amp;p)
+  {
+    for (Paths::size_type i = 0; i &lt; p.size(); i++)
+      s &lt;&lt; p[i];
+    s &lt;&lt; "\n";
+    return s;
+  }
 //------------------------------------------------------------------------------
 
 } //ClipperLib namespace
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\lib\clipper.hpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\lib\clipper.hpp" added_lines="452" deleted_lines="254">
				<diff>@@ -45,7 +45,7 @@
 
 //use_lines: Enables line clipping. Adds a very minor cost to performance.
 #define use_lines
-  
+
 //use_deprecated: Enables temporary support for the obsolete functions
 //#define use_deprecated  
 
@@ -59,15 +59,25 @@
 #include &lt;functional&gt;
 #include &lt;queue&gt;
 
-namespace ClipperLib {
+namespace ClipperLib
+{
 
-enum ClipType { ctIntersection, ctUnion, ctDifference, ctXor };
-enum PolyType { ptSubject, ptClip };
+  enum ClipType
+  {
+    ctIntersection, ctUnion, ctDifference, ctXor
+  };
+  enum PolyType
+  {
+    ptSubject, ptClip
+  };
 //By far the most widely used winding rules for polygon filling are
 //EvenOdd &amp; NonZero (GDI, GDI+, XLib, OpenGL, Cairo, AGG, Quartz, SVG, Gr32)
 //Others rules include Positive, Negative and ABS_GTR_EQ_TWO (only in OpenGL)
 //see http://glprogramming.com/red/chapter11.html
-enum PolyFillType { pftEvenOdd, pftNonZero, pftPositive, pftNegative };
+  enum PolyFillType
+  {
+    pftEvenOdd, pftNonZero, pftPositive, pftNegative
+  };
 
 #ifdef use_int32
   typedef int cInt;
@@ -82,321 +92,509 @@ enum PolyFillType { pftEvenOdd, pftNonZero, pftPositive, pftNegative };
 
 #endif
 
-struct IntPoint {
-  cInt X;
-  cInt Y;
+  struct IntPoint
+  {
+    cInt X;
+    cInt Y;
 #ifdef use_xyz
-  cInt Z;
-  IntPoint(cInt x = 0, cInt y = 0, cInt z = 0): X(x), Y(y), Z(z) {};
+    cInt Z;
+    IntPoint(cInt x = 0, cInt y = 0, cInt z = 0): X(x), Y(y), Z(z) {};
 #else
-  IntPoint(cInt x = 0, cInt y = 0): X(x), Y(y) {};
+
+    IntPoint(cInt x = 0, cInt y = 0) : X(x), Y(y)
+    {
+    };
 #endif
 
-  friend inline bool operator== (const IntPoint&amp; a, const IntPoint&amp; b)
+    friend inline bool operator==(const IntPoint &amp;a, const IntPoint &amp;b)
+    {
+      return a.X == b.X &amp;&amp; a.Y == b.Y;
+    }
+
+    friend inline bool operator!=(const IntPoint &amp;a, const IntPoint &amp;b)
+    {
+      return a.X != b.X || a.Y != b.Y;
+    }
+  };
+//------------------------------------------------------------------------------
+
+  typedef std::vector&lt;IntPoint&gt; Path;
+  typedef std::vector&lt;Path&gt; Paths;
+
+  inline Path &amp;operator&lt;&lt;(Path &amp;poly, const IntPoint &amp;p)
   {
-    return a.X == b.X &amp;&amp; a.Y == b.Y;
+    poly.push_back(p);
+    return poly;
   }
-  friend inline bool operator!= (const IntPoint&amp; a, const IntPoint&amp; b)
+
+  inline Paths &amp;operator&lt;&lt;(Paths &amp;polys, const Path &amp;p)
   {
-    return a.X != b.X  || a.Y != b.Y; 
+    polys.push_back(p);
+    return polys;
   }
-};
-//------------------------------------------------------------------------------
 
-typedef std::vector&lt; IntPoint &gt; Path;
-typedef std::vector&lt; Path &gt; Paths;
+  std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, const IntPoint &amp;p);
 
-inline Path&amp; operator &lt;&lt;(Path&amp; poly, const IntPoint&amp; p) {poly.push_back(p); return poly;}
-inline Paths&amp; operator &lt;&lt;(Paths&amp; polys, const Path&amp; p) {polys.push_back(p); return polys;}
+  std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, const Path &amp;p);
 
-std::ostream&amp; operator &lt;&lt;(std::ostream &amp;s, const IntPoint &amp;p);
-std::ostream&amp; operator &lt;&lt;(std::ostream &amp;s, const Path &amp;p);
-std::ostream&amp; operator &lt;&lt;(std::ostream &amp;s, const Paths &amp;p);
+  std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, const Paths &amp;p);
 
-struct DoublePoint
-{
-  double X;
-  double Y;
-  DoublePoint(double x = 0, double y = 0) : X(x), Y(y) {}
-  DoublePoint(IntPoint ip) : X((double)ip.X), Y((double)ip.Y) {}
-};
+  struct DoublePoint
+  {
+    double X;
+    double Y;
+
+    DoublePoint(double x = 0, double y = 0) : X(x), Y(y)
+    {
+    }
+
+    DoublePoint(IntPoint ip) : X((double) ip.X), Y((double) ip.Y)
+    {
+    }
+  };
 //------------------------------------------------------------------------------
 
 #ifdef use_xyz
-typedef void (*ZFillCallback)(IntPoint&amp; e1bot, IntPoint&amp; e1top, IntPoint&amp; e2bot, IntPoint&amp; e2top, IntPoint&amp; pt);
+  typedef void (*ZFillCallback)(IntPoint&amp; e1bot, IntPoint&amp; e1top, IntPoint&amp; e2bot, IntPoint&amp; e2top, IntPoint&amp; pt);
 #endif
 
-enum InitOptions {ioReverseSolution = 1, ioStrictlySimple = 2, ioPreserveCollinear = 4};
-enum JoinType {jtSquare, jtRound, jtMiter};
-enum EndType {etClosedPolygon, etClosedLine, etOpenButt, etOpenSquare, etOpenRound};
+  enum InitOptions
+  {
+    ioReverseSolution = 1, ioStrictlySimple = 2, ioPreserveCollinear = 4
+  };
+  enum JoinType
+  {
+    jtSquare, jtRound, jtMiter
+  };
+  enum EndType
+  {
+    etClosedPolygon, etClosedLine, etOpenButt, etOpenSquare, etOpenRound
+  };
+
+  class PolyNode;
 
-class PolyNode;
-typedef std::vector&lt; PolyNode* &gt; PolyNodes;
+  typedef std::vector&lt;PolyNode *&gt; PolyNodes;
 
-class PolyNode 
-{ 
-public:
+  class PolyNode
+  {
+  public:
     PolyNode();
-    virtual ~PolyNode(){};
+
+    virtual ~PolyNode()
+    {
+    };
     Path Contour;
     PolyNodes Childs;
-    PolyNode* Parent;
-    PolyNode* GetNext() const;
+    PolyNode *Parent;
+
+    PolyNode *GetNext() const;
+
     bool IsHole() const;
+
     bool IsOpen() const;
+
     int ChildCount() const;
-private:
+
+  private:
     //PolyNode&amp; operator =(PolyNode&amp; other); 
     unsigned Index; //node index in Parent.Childs
     bool m_IsOpen;
     JoinType m_jointype;
     EndType m_endtype;
-    PolyNode* GetNextSiblingUp() const;
-    void AddChild(PolyNode&amp; child);
+
+    PolyNode *GetNextSiblingUp() const;
+
+    void AddChild(PolyNode &amp;child);
+
     friend class Clipper; //to access Index
-    friend class ClipperOffset; 
-};
-
-class PolyTree: public PolyNode
-{ 
-public:
-    ~PolyTree(){ Clear(); };
-    PolyNode* GetFirst() const;
+    friend class ClipperOffset;
+  };
+
+  class PolyTree : public PolyNode
+  {
+  public:
+    ~PolyTree()
+    {
+      Clear();
+    };
+
+    PolyNode *GetFirst() const;
+
     void Clear();
+
     int Total() const;
-private:
-  //PolyTree&amp; operator =(PolyTree&amp; other);
-  PolyNodes AllNodes;
+
+  private:
+    //PolyTree&amp; operator =(PolyTree&amp; other);
+    PolyNodes AllNodes;
+
     friend class Clipper; //to access AllNodes
-};
+  };
+
+  bool Orientation(const Path &amp;poly);
+
+  double Area(const Path &amp;poly);
+
+  int PointInPolygon(const IntPoint &amp;pt, const Path &amp;path);
+
+  void SimplifyPolygon(const Path &amp;in_poly, Paths &amp;out_polys, PolyFillType fillType = pftEvenOdd);
+
+  void SimplifyPolygons(const Paths &amp;in_polys, Paths &amp;out_polys, PolyFillType fillType = pftEvenOdd);
+
+  void SimplifyPolygons(Paths &amp;polys, PolyFillType fillType = pftEvenOdd);
+
+  void CleanPolygon(const Path &amp;in_poly, Path &amp;out_poly, double distance = 1.415);
+
+  void CleanPolygon(Path &amp;poly, double distance = 1.415);
 
-bool Orientation(const Path &amp;poly);
-double Area(const Path &amp;poly);
-int PointInPolygon(const IntPoint &amp;pt, const Path &amp;path);
+  void CleanPolygons(const Paths &amp;in_polys, Paths &amp;out_polys, double distance = 1.415);
 
-void SimplifyPolygon(const Path &amp;in_poly, Paths &amp;out_polys, PolyFillType fillType = pftEvenOdd);
-void SimplifyPolygons(const Paths &amp;in_polys, Paths &amp;out_polys, PolyFillType fillType = pftEvenOdd);
-void SimplifyPolygons(Paths &amp;polys, PolyFillType fillType = pftEvenOdd);
+  void CleanPolygons(Paths &amp;polys, double distance = 1.415);
 
-void CleanPolygon(const Path&amp; in_poly, Path&amp; out_poly, double distance = 1.415);
-void CleanPolygon(Path&amp; poly, double distance = 1.415);
-void CleanPolygons(const Paths&amp; in_polys, Paths&amp; out_polys, double distance = 1.415);
-void CleanPolygons(Paths&amp; polys, double distance = 1.415);
+  void MinkowskiSum(const Path &amp;pattern, const Path &amp;path, Paths &amp;solution, bool pathIsClosed);
 
-void MinkowskiSum(const Path&amp; pattern, const Path&amp; path, Paths&amp; solution, bool pathIsClosed);
-void MinkowskiSum(const Path&amp; pattern, const Paths&amp; paths, Paths&amp; solution, bool pathIsClosed);
-void MinkowskiDiff(const Path&amp; poly1, const Path&amp; poly2, Paths&amp; solution);
+  void MinkowskiSum(const Path &amp;pattern, const Paths &amp;paths, Paths &amp;solution, bool pathIsClosed);
 
-void PolyTreeToPaths(const PolyTree&amp; polytree, Paths&amp; paths);
-void ClosedPathsFromPolyTree(const PolyTree&amp; polytree, Paths&amp; paths);
-void OpenPathsFromPolyTree(PolyTree&amp; polytree, Paths&amp; paths);
+  void MinkowskiDiff(const Path &amp;poly1, const Path &amp;poly2, Paths &amp;solution);
 
-void ReversePath(Path&amp; p);
-void ReversePaths(Paths&amp; p);
+  void PolyTreeToPaths(const PolyTree &amp;polytree, Paths &amp;paths);
 
-struct IntRect { cInt left; cInt top; cInt right; cInt bottom; };
+  void ClosedPathsFromPolyTree(const PolyTree &amp;polytree, Paths &amp;paths);
+
+  void OpenPathsFromPolyTree(PolyTree &amp;polytree, Paths &amp;paths);
+
+  void ReversePath(Path &amp;p);
+
+  void ReversePaths(Paths &amp;p);
+
+  struct IntRect
+  {
+    cInt left;
+    cInt top;
+    cInt right;
+    cInt bottom;
+  };
 
 //enums that are used internally ...
-enum EdgeSide { esLeft = 1, esRight = 2};
+  enum EdgeSide
+  {
+    esLeft = 1, esRight = 2
+  };
 
 //forward declarations (for stuff used internally) ...
-struct TEdge;
-struct IntersectNode;
-struct LocalMinimum;
-struct OutPt;
-struct OutRec;
-struct Join;
-
-typedef std::vector &lt; OutRec* &gt; PolyOutList;
-typedef std::vector &lt; TEdge* &gt; EdgeList;
-typedef std::vector &lt; Join* &gt; JoinList;
-typedef std::vector &lt; IntersectNode* &gt; IntersectList;
+  struct TEdge;
+  struct IntersectNode;
+  struct LocalMinimum;
+  struct OutPt;
+  struct OutRec;
+  struct Join;
+
+  typedef std::vector&lt;OutRec *&gt; PolyOutList;
+  typedef std::vector&lt;TEdge *&gt; EdgeList;
+  typedef std::vector&lt;Join *&gt; JoinList;
+  typedef std::vector&lt;IntersectNode *&gt; IntersectList;
 
 //------------------------------------------------------------------------------
 
 //ClipperBase is the ancestor to the Clipper class. It should not be
 //instantiated directly. This class simply abstracts the conversion of sets of
 //polygon coordinates into edge objects that are stored in a LocalMinima list.
-class ClipperBase
-{
-public:
-  ClipperBase();
-  virtual ~ClipperBase();
-  virtual bool AddPath(const Path &amp;pg, PolyType PolyTyp, bool Closed);
-  bool AddPaths(const Paths &amp;ppg, PolyType PolyTyp, bool Closed);
-  virtual void Clear();
-  IntRect GetBounds();
-  bool PreserveCollinear() {return m_PreserveCollinear;};
-  void PreserveCollinear(bool value) {m_PreserveCollinear = value;};
-protected:
-  void DisposeLocalMinimaList();
-  TEdge* AddBoundsToLML(TEdge *e, bool IsClosed);
-  virtual void Reset();
-  TEdge* ProcessBound(TEdge* E, bool IsClockwise);
-  void InsertScanbeam(const cInt Y);
-  bool PopScanbeam(cInt &amp;Y);
-  bool LocalMinimaPending();
-  bool PopLocalMinima(cInt Y, const LocalMinimum *&amp;locMin);
-  OutRec* CreateOutRec();
-  void DisposeAllOutRecs();
-  void DisposeOutRec(PolyOutList::size_type index);
-  void SwapPositionsInAEL(TEdge *edge1, TEdge *edge2);
-  void DeleteFromAEL(TEdge *e);
-  void UpdateEdgeIntoAEL(TEdge *&amp;e);
-
-  typedef std::vector&lt;LocalMinimum&gt; MinimaList;
-  MinimaList::iterator m_CurrentLM;
-  MinimaList           m_MinimaList;
-
-  bool              m_UseFullRange;
-  EdgeList          m_edges;
-  bool              m_PreserveCollinear;
-  bool              m_HasOpenPaths;
-  PolyOutList       m_PolyOuts;
-  TEdge           *m_ActiveEdges;
-
-  typedef std::priority_queue&lt;cInt&gt; ScanbeamList;
-  ScanbeamList     m_Scanbeam;
-};
+  class ClipperBase
+  {
+  public:
+    ClipperBase();
+
+    virtual ~ClipperBase();
+
+    virtual bool AddPath(const Path &amp;pg, PolyType PolyTyp, bool Closed);
+
+    bool AddPaths(const Paths &amp;ppg, PolyType PolyTyp, bool Closed);
+
+    virtual void Clear();
+
+    IntRect GetBounds();
+
+    bool PreserveCollinear()
+    {
+      return m_PreserveCollinear;
+    };
+
+    void PreserveCollinear(bool value)
+    {
+      m_PreserveCollinear = value;
+    };
+  protected:
+    void DisposeLocalMinimaList();
+
+    TEdge *AddBoundsToLML(TEdge *e, bool IsClosed);
+
+    virtual void Reset();
+
+    TEdge *ProcessBound(TEdge *E, bool IsClockwise);
+
+    void InsertScanbeam(const cInt Y);
+
+    bool PopScanbeam(cInt &amp;Y);
+
+    bool LocalMinimaPending();
+
+    bool PopLocalMinima(cInt Y, const LocalMinimum *&amp;locMin);
+
+    OutRec *CreateOutRec();
+
+    void DisposeAllOutRecs();
+
+    void DisposeOutRec(PolyOutList::size_type index);
+
+    void SwapPositionsInAEL(TEdge *edge1, TEdge *edge2);
+
+    void DeleteFromAEL(TEdge *e);
+
+    void UpdateEdgeIntoAEL(TEdge *&amp;e);
+
+    typedef std::vector&lt;LocalMinimum&gt; MinimaList;
+    MinimaList::iterator m_CurrentLM;
+    MinimaList m_MinimaList;
+
+    bool m_UseFullRange;
+    EdgeList m_edges;
+    bool m_PreserveCollinear;
+    bool m_HasOpenPaths;
+    PolyOutList m_PolyOuts;
+    TEdge *m_ActiveEdges;
+
+    typedef std::priority_queue&lt;cInt&gt; ScanbeamList;
+    ScanbeamList m_Scanbeam;
+  };
 //------------------------------------------------------------------------------
 
-class Clipper : public virtual ClipperBase
-{
-public:
-  Clipper(int initOptions = 0);
-  bool Execute(ClipType clipType,
-      Paths &amp;solution,
-      PolyFillType fillType = pftEvenOdd);
-  bool Execute(ClipType clipType,
-      Paths &amp;solution,
-      PolyFillType subjFillType,
-      PolyFillType clipFillType);
-  bool Execute(ClipType clipType,
-      PolyTree &amp;polytree,
-      PolyFillType fillType = pftEvenOdd);
-  bool Execute(ClipType clipType,
-      PolyTree &amp;polytree,
-      PolyFillType subjFillType,
-      PolyFillType clipFillType);
-  bool ReverseSolution() { return m_ReverseOutput; };
-  void ReverseSolution(bool value) {m_ReverseOutput = value;};
-  bool StrictlySimple() {return m_StrictSimple;};
-  void StrictlySimple(bool value) {m_StrictSimple = value;};
-  //set the callback function for z value filling on intersections (otherwise Z is 0)
+  class Clipper : public virtual ClipperBase
+  {
+  public:
+    Clipper(int initOptions = 0);
+
+    bool Execute(ClipType clipType,
+                 Paths &amp;solution,
+                 PolyFillType fillType = pftEvenOdd);
+
+    bool Execute(ClipType clipType,
+                 Paths &amp;solution,
+                 PolyFillType subjFillType,
+                 PolyFillType clipFillType);
+
+    bool Execute(ClipType clipType,
+                 PolyTree &amp;polytree,
+                 PolyFillType fillType = pftEvenOdd);
+
+    bool Execute(ClipType clipType,
+                 PolyTree &amp;polytree,
+                 PolyFillType subjFillType,
+                 PolyFillType clipFillType);
+
+    bool ReverseSolution()
+    {
+      return m_ReverseOutput;
+    };
+
+    void ReverseSolution(bool value)
+    {
+      m_ReverseOutput = value;
+    };
+
+    bool StrictlySimple()
+    {
+      return m_StrictSimple;
+    };
+
+    void StrictlySimple(bool value)
+    {
+      m_StrictSimple = value;
+    };
+    //set the callback function for z value filling on intersections (otherwise Z is 0)
 #ifdef use_xyz
-  void ZFillFunction(ZFillCallback zFillFunc);
+    void ZFillFunction(ZFillCallback zFillFunc);
 #endif
-protected:
-  virtual bool ExecuteInternal();
-private:
-  JoinList         m_Joins;
-  JoinList         m_GhostJoins;
-  IntersectList    m_IntersectList;
-  ClipType         m_ClipType;
-  typedef std::list&lt;cInt&gt; MaximaList;
-  MaximaList       m_Maxima;
-  TEdge           *m_SortedEdges;
-  bool             m_ExecuteLocked;
-  PolyFillType     m_ClipFillType;
-  PolyFillType     m_SubjFillType;
-  bool             m_ReverseOutput;
-  bool             m_UsingPolyTree; 
-  bool             m_StrictSimple;
+  protected:
+    virtual bool ExecuteInternal();
+
+  private:
+    JoinList m_Joins;
+    JoinList m_GhostJoins;
+    IntersectList m_IntersectList;
+    ClipType m_ClipType;
+    typedef std::list&lt;cInt&gt; MaximaList;
+    MaximaList m_Maxima;
+    TEdge *m_SortedEdges;
+    bool m_ExecuteLocked;
+    PolyFillType m_ClipFillType;
+    PolyFillType m_SubjFillType;
+    bool m_ReverseOutput;
+    bool m_UsingPolyTree;
+    bool m_StrictSimple;
 #ifdef use_xyz
-  ZFillCallback   m_ZFill; //custom callback 
+    ZFillCallback   m_ZFill; //custom callback
 #endif
-  void SetWindingCount(TEdge&amp; edge);
-  bool IsEvenOddFillType(const TEdge&amp; edge) const;
-  bool IsEvenOddAltFillType(const TEdge&amp; edge) const;
-  void InsertLocalMinimaIntoAEL(const cInt botY);
-  void InsertEdgeIntoAEL(TEdge *edge, TEdge* startEdge);
-  void AddEdgeToSEL(TEdge *edge);
-  bool PopEdgeFromSEL(TEdge *&amp;edge);
-  void CopyAELToSEL();
-  void DeleteFromSEL(TEdge *e);
-  void SwapPositionsInSEL(TEdge *edge1, TEdge *edge2);
-  bool IsContributing(const TEdge&amp; edge) const;
-  bool IsTopHorz(const cInt XPos);
-  void DoMaxima(TEdge *e);
-  void ProcessHorizontals();
-  void ProcessHorizontal(TEdge *horzEdge);
-  void AddLocalMaxPoly(TEdge *e1, TEdge *e2, const IntPoint &amp;pt);
-  OutPt* AddLocalMinPoly(TEdge *e1, TEdge *e2, const IntPoint &amp;pt);
-  OutRec* GetOutRec(int idx);
-  void AppendPolygon(TEdge *e1, TEdge *e2);
-  void IntersectEdges(TEdge *e1, TEdge *e2, IntPoint &amp;pt);
-  OutPt* AddOutPt(TEdge *e, const IntPoint &amp;pt);
-  OutPt* GetLastOutPt(TEdge *e);
-  bool ProcessIntersections(const cInt topY);
-  void BuildIntersectList(const cInt topY);
-  void ProcessIntersectList();
-  void ProcessEdgesAtTopOfScanbeam(const cInt topY);
-  void BuildResult(Paths&amp; polys);
-  void BuildResult2(PolyTree&amp; polytree);
-  void SetHoleState(TEdge *e, OutRec *outrec);
-  void DisposeIntersectNodes();
-  bool FixupIntersectionOrder();
-  void FixupOutPolygon(OutRec &amp;outrec);
-  void FixupOutPolyline(OutRec &amp;outrec);
-  bool IsHole(TEdge *e);
-  bool FindOwnerFromSplitRecs(OutRec &amp;outRec, OutRec *&amp;currOrfl);
-  void FixHoleLinkage(OutRec &amp;outrec);
-  void AddJoin(OutPt *op1, OutPt *op2, const IntPoint offPt);
-  void ClearJoins();
-  void ClearGhostJoins();
-  void AddGhostJoin(OutPt *op, const IntPoint offPt);
-  bool JoinPoints(Join *j, OutRec* outRec1, OutRec* outRec2);
-  void JoinCommonEdges();
-  void DoSimplePolygons();
-  void FixupFirstLefts1(OutRec* OldOutRec, OutRec* NewOutRec);
-  void FixupFirstLefts2(OutRec* InnerOutRec, OutRec* OuterOutRec);
-  void FixupFirstLefts3(OutRec* OldOutRec, OutRec* NewOutRec);
+
+    void SetWindingCount(TEdge &amp;edge);
+
+    bool IsEvenOddFillType(const TEdge &amp;edge) const;
+
+    bool IsEvenOddAltFillType(const TEdge &amp;edge) const;
+
+    void InsertLocalMinimaIntoAEL(const cInt botY);
+
+    void InsertEdgeIntoAEL(TEdge *edge, TEdge *startEdge);
+
+    void AddEdgeToSEL(TEdge *edge);
+
+    bool PopEdgeFromSEL(TEdge *&amp;edge);
+
+    void CopyAELToSEL();
+
+    void DeleteFromSEL(TEdge *e);
+
+    void SwapPositionsInSEL(TEdge *edge1, TEdge *edge2);
+
+    bool IsContributing(const TEdge &amp;edge) const;
+
+    bool IsTopHorz(const cInt XPos);
+
+    void DoMaxima(TEdge *e);
+
+    void ProcessHorizontals();
+
+    void ProcessHorizontal(TEdge *horzEdge);
+
+    void AddLocalMaxPoly(TEdge *e1, TEdge *e2, const IntPoint &amp;pt);
+
+    OutPt *AddLocalMinPoly(TEdge *e1, TEdge *e2, const IntPoint &amp;pt);
+
+    OutRec *GetOutRec(int idx);
+
+    void AppendPolygon(TEdge *e1, TEdge *e2);
+
+    void IntersectEdges(TEdge *e1, TEdge *e2, IntPoint &amp;pt);
+
+    OutPt *AddOutPt(TEdge *e, const IntPoint &amp;pt);
+
+    OutPt *GetLastOutPt(TEdge *e);
+
+    bool ProcessIntersections(const cInt topY);
+
+    void BuildIntersectList(const cInt topY);
+
+    void ProcessIntersectList();
+
+    void ProcessEdgesAtTopOfScanbeam(const cInt topY);
+
+    void BuildResult(Paths &amp;polys);
+
+    void BuildResult2(PolyTree &amp;polytree);
+
+    void SetHoleState(TEdge *e, OutRec *outrec);
+
+    void DisposeIntersectNodes();
+
+    bool FixupIntersectionOrder();
+
+    void FixupOutPolygon(OutRec &amp;outrec);
+
+    void FixupOutPolyline(OutRec &amp;outrec);
+
+    bool IsHole(TEdge *e);
+
+    bool FindOwnerFromSplitRecs(OutRec &amp;outRec, OutRec *&amp;currOrfl);
+
+    void FixHoleLinkage(OutRec &amp;outrec);
+
+    void AddJoin(OutPt *op1, OutPt *op2, const IntPoint offPt);
+
+    void ClearJoins();
+
+    void ClearGhostJoins();
+
+    void AddGhostJoin(OutPt *op, const IntPoint offPt);
+
+    bool JoinPoints(Join *j, OutRec *outRec1, OutRec *outRec2);
+
+    void JoinCommonEdges();
+
+    void DoSimplePolygons();
+
+    void FixupFirstLefts1(OutRec *OldOutRec, OutRec *NewOutRec);
+
+    void FixupFirstLefts2(OutRec *InnerOutRec, OutRec *OuterOutRec);
+
+    void FixupFirstLefts3(OutRec *OldOutRec, OutRec *NewOutRec);
+
 #ifdef use_xyz
-  void SetZ(IntPoint&amp; pt, TEdge&amp; e1, TEdge&amp; e2);
+    void SetZ(IntPoint&amp; pt, TEdge&amp; e1, TEdge&amp; e2);
 #endif
-};
+  };
 //------------------------------------------------------------------------------
 
-class ClipperOffset 
-{
-public:
-  ClipperOffset(double miterLimit = 2.0, double roundPrecision = 0.25);
-  ~ClipperOffset();
-  void AddPath(const Path&amp; path, JoinType joinType, EndType endType);
-  void AddPaths(const Paths&amp; paths, JoinType joinType, EndType endType);
-  void Execute(Paths&amp; solution, double delta);
-  void Execute(PolyTree&amp; solution, double delta);
-  void Clear();
-  double MiterLimit;
-  double ArcTolerance;
-private:
-  Paths m_destPolys;
-  Path m_srcPoly;
-  Path m_destPoly;
-  std::vector&lt;DoublePoint&gt; m_normals;
-  double m_delta, m_sinA, m_sin, m_cos;
-  double m_miterLim, m_StepsPerRad;
-  IntPoint m_lowest;
-  PolyNode m_polyNodes;
-
-  void FixOrientations();
-  void DoOffset(double delta);
-  void OffsetPoint(int j, int&amp; k, JoinType jointype);
-  void DoSquare(int j, int k);
-  void DoMiter(int j, int k, double r);
-  void DoRound(int j, int k);
-};
+  class ClipperOffset
+  {
+  public:
+    ClipperOffset(double miterLimit = 2.0, double roundPrecision = 0.25);
+
+    ~ClipperOffset();
+
+    void AddPath(const Path &amp;path, JoinType joinType, EndType endType);
+
+    void AddPaths(const Paths &amp;paths, JoinType joinType, EndType endType);
+
+    void Execute(Paths &amp;solution, double delta);
+
+    void Execute(PolyTree &amp;solution, double delta);
+
+    void Clear();
+
+    double MiterLimit;
+    double ArcTolerance;
+  private:
+    Paths m_destPolys;
+    Path m_srcPoly;
+    Path m_destPoly;
+    std::vector&lt;DoublePoint&gt; m_normals;
+    double m_delta, m_sinA, m_sin, m_cos;
+    double m_miterLim, m_StepsPerRad;
+    IntPoint m_lowest;
+    PolyNode m_polyNodes;
+
+    void FixOrientations();
+
+    void DoOffset(double delta);
+
+    void OffsetPoint(int j, int &amp;k, JoinType jointype);
+
+    void DoSquare(int j, int k);
+
+    void DoMiter(int j, int k, double r);
+
+    void DoRound(int j, int k);
+  };
 //------------------------------------------------------------------------------
 
-class clipperException : public std::exception
-{
+  class clipperException : public std::exception
+  {
   public:
-    clipperException(const char* description): m_descr(description) {}
-    virtual ~clipperException() throw() {}
-    virtual const char* what() const throw() {return m_descr.c_str();}
+    clipperException(const char *description) : m_descr(description)
+    {
+    }
+
+    virtual ~clipperException() throw()
+    {
+    }
+
+    virtual const char *what() const throw()
+    {
+      return m_descr.c_str();
+    }
+
   private:
     std::string m_descr;
-};
+  };
 //------------------------------------------------------------------------------
 
 } //ClipperLib namespace
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\lib\hungarian.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\lib\hungarian.cpp" added_lines="351" deleted_lines="329">
				<diff>@@ -15,381 +15,403 @@
 #include "hungarian.h"
 
 
-HungarianAlgorithm::HungarianAlgorithm(){}
-HungarianAlgorithm::~HungarianAlgorithm(){}
+HungarianAlgorithm::HungarianAlgorithm()
+{
+}
+
+HungarianAlgorithm::~HungarianAlgorithm()
+{
+}
 
 
 //********************************************************//
 // A single function wrapper for solving assignment problem.
 //********************************************************//
-double HungarianAlgorithm::Solve(vector &lt;vector&lt;double&gt; &gt;&amp; DistMatrix, vector&lt;int&gt;&amp; Assignment)
+double HungarianAlgorithm::Solve(vector&lt;vector&lt;double&gt; &gt; &amp;DistMatrix, vector&lt;int&gt; &amp;Assignment)
 {
-	unsigned int nRows = DistMatrix.size();
-	unsigned int nCols = DistMatrix[0].size();
-
-	double *distMatrixIn = new double[nRows * nCols];
-	int *assignment = new int[nRows];
-	double cost = 0.0;
-
-	// Fill in the distMatrixIn. Mind the index is "i + nRows * j".
-	// Here the cost matrix of size MxN is defined as a double precision array of N*M elements.
-	// In the solving functions matrices are seen to be saved MATLAB-internally in row-order.
-	// (i.e. the matrix [1 2; 3 4] will be stored as a vector [1 3 2 4], NOT [1 2 3 4]).
-	for (unsigned int i = 0; i &lt; nRows; i++)
-		for (unsigned int j = 0; j &lt; nCols; j++)
-			distMatrixIn[i + nRows * j] = DistMatrix[i][j];
-
-	// call solving function
-	assignmentoptimal(assignment, &amp;cost, distMatrixIn, nRows, nCols);
-
-	Assignment.clear();
-	for (unsigned int r = 0; r &lt; nRows; r++)
-		Assignment.push_back(assignment[r]);
-
-	delete[] distMatrixIn;
-	delete[] assignment;
-	return cost;
+  unsigned int nRows = DistMatrix.size();
+  unsigned int nCols = DistMatrix[0].size();
+
+  double *distMatrixIn = new double[nRows * nCols];
+  int *assignment = new int[nRows];
+  double cost = 0.0;
+
+  // Fill in the distMatrixIn. Mind the index is "i + nRows * j".
+  // Here the cost matrix of size MxN is defined as a double precision array of N*M elements.
+  // In the solving functions matrices are seen to be saved MATLAB-internally in row-order.
+  // (i.e. the matrix [1 2; 3 4] will be stored as a vector [1 3 2 4], NOT [1 2 3 4]).
+  for (unsigned int i = 0; i &lt; nRows; i++)
+    for (unsigned int j = 0; j &lt; nCols; j++)
+      distMatrixIn[i + nRows * j] = DistMatrix[i][j];
+
+  // call solving function
+  assignmentoptimal(assignment, &amp;cost, distMatrixIn, nRows, nCols);
+
+  Assignment.clear();
+  for (unsigned int r = 0; r &lt; nRows; r++)
+    Assignment.push_back(assignment[r]);
+
+  delete[] distMatrixIn;
+  delete[] assignment;
+  return cost;
 }
 
 
 //********************************************************//
 // Solve optimal solution for assignment problem using Munkres algorithm, also known as Hungarian Algorithm.
 //********************************************************//
-void HungarianAlgorithm::assignmentoptimal(int *assignment, double *cost, double *distMatrixIn, int nOfRows, int nOfColumns)
+void
+HungarianAlgorithm::assignmentoptimal(int *assignment, double *cost, double *distMatrixIn, int nOfRows, int nOfColumns)
 {
-	double *distMatrix, *distMatrixTemp, *distMatrixEnd, *columnEnd, value, minValue;
-	bool *coveredColumns, *coveredRows, *starMatrix, *newStarMatrix, *primeMatrix;
-	int nOfElements, minDim, row, col;
-
-	/* initialization */
-	*cost = 0;
-	for (row = 0; row&lt;nOfRows; row++)
-		assignment[row] = -1;
-
-	/* generate working copy of distance Matrix */
-	/* check if all matrix elements are positive */
-	nOfElements = nOfRows * nOfColumns;
-	distMatrix = (double *)malloc(nOfElements * sizeof(double));
-	distMatrixEnd = distMatrix + nOfElements;
-
-	for (row = 0; row&lt;nOfElements; row++)
-	{
-		value = distMatrixIn[row];
-		if (value &lt; 0)
-			cerr &lt;&lt; "All matrix elements have to be non-negative." &lt;&lt; endl;
-		distMatrix[row] = value;
-	}
-
-
-	/* memory allocation */
-	coveredColumns = (bool *)calloc(nOfColumns, sizeof(bool));
-	coveredRows = (bool *)calloc(nOfRows, sizeof(bool));
-	starMatrix = (bool *)calloc(nOfElements, sizeof(bool));
-	primeMatrix = (bool *)calloc(nOfElements, sizeof(bool));
-	newStarMatrix = (bool *)calloc(nOfElements, sizeof(bool)); /* used in step4 */
-
-	/* preliminary steps */
-	if (nOfRows &lt;= nOfColumns)
-	{
-		minDim = nOfRows;
-
-		for (row = 0; row&lt;nOfRows; row++)
-		{
-			/* find the smallest element in the row */
-			distMatrixTemp = distMatrix + row;
-			minValue = *distMatrixTemp;
-			distMatrixTemp += nOfRows;
-			while (distMatrixTemp &lt; distMatrixEnd)
-			{
-				value = *distMatrixTemp;
-				if (value &lt; minValue)
-					minValue = value;
-				distMatrixTemp += nOfRows;
-			}
-
-			/* subtract the smallest element from each element of the row */
-			distMatrixTemp = distMatrix + row;
-			while (distMatrixTemp &lt; distMatrixEnd)
-			{
-				*distMatrixTemp -= minValue;
-				distMatrixTemp += nOfRows;
-			}
-		}
-
-		/* Steps 1 and 2a */
-		for (row = 0; row&lt;nOfRows; row++)
-			for (col = 0; col&lt;nOfColumns; col++)
-				if (fabs(distMatrix[row + nOfRows*col]) &lt; DBL_EPSILON)
-					if (!coveredColumns[col])
-					{
-						starMatrix[row + nOfRows*col] = true;
-						coveredColumns[col] = true;
-						break;
-					}
-	}
-	else /* if(nOfRows &gt; nOfColumns) */
-	{
-		minDim = nOfColumns;
-
-		for (col = 0; col&lt;nOfColumns; col++)
-		{
-			/* find the smallest element in the column */
-			distMatrixTemp = distMatrix + nOfRows*col;
-			columnEnd = distMatrixTemp + nOfRows;
-
-			minValue = *distMatrixTemp++;
-			while (distMatrixTemp &lt; columnEnd)
-			{
-				value = *distMatrixTemp++;
-				if (value &lt; minValue)
-					minValue = value;
-			}
-
-			/* subtract the smallest element from each element of the column */
-			distMatrixTemp = distMatrix + nOfRows*col;
-			while (distMatrixTemp &lt; columnEnd)
-				*distMatrixTemp++ -= minValue;
-		}
-
-		/* Steps 1 and 2a */
-		for (col = 0; col&lt;nOfColumns; col++)
-			for (row = 0; row&lt;nOfRows; row++)
-				if (fabs(distMatrix[row + nOfRows*col]) &lt; DBL_EPSILON)
-					if (!coveredRows[row])
-					{
-						starMatrix[row + nOfRows*col] = true;
-						coveredColumns[col] = true;
-						coveredRows[row] = true;
-						break;
-					}
-		for (row = 0; row&lt;nOfRows; row++)
-			coveredRows[row] = false;
-
-	}
-
-	/* move to step 2b */
-	step2b(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows, nOfColumns, minDim);
-
-	/* compute cost and remove invalid assignments */
-	computeassignmentcost(assignment, cost, distMatrixIn, nOfRows);
-
-	/* free allocated memory */
-	free(distMatrix);
-	free(coveredColumns);
-	free(coveredRows);
-	free(starMatrix);
-	free(primeMatrix);
-	free(newStarMatrix);
-
-	return;
+  double *distMatrix, *distMatrixTemp, *distMatrixEnd, *columnEnd, value, minValue;
+  bool *coveredColumns, *coveredRows, *starMatrix, *newStarMatrix, *primeMatrix;
+  int nOfElements, minDim, row, col;
+
+  /* initialization */
+  *cost = 0;
+  for (row = 0; row &lt; nOfRows; row++)
+    assignment[row] = -1;
+
+  /* generate working copy of distance Matrix */
+  /* check if all matrix elements are positive */
+  nOfElements = nOfRows * nOfColumns;
+  distMatrix = (double *) malloc(nOfElements * sizeof(double));
+  distMatrixEnd = distMatrix + nOfElements;
+
+  for (row = 0; row &lt; nOfElements; row++)
+  {
+    value = distMatrixIn[row];
+    if (value &lt; 0)
+      cerr &lt;&lt; "All matrix elements have to be non-negative." &lt;&lt; endl;
+    distMatrix[row] = value;
+  }
+
+
+  /* memory allocation */
+  coveredColumns = (bool *) calloc(nOfColumns, sizeof(bool));
+  coveredRows = (bool *) calloc(nOfRows, sizeof(bool));
+  starMatrix = (bool *) calloc(nOfElements, sizeof(bool));
+  primeMatrix = (bool *) calloc(nOfElements, sizeof(bool));
+  newStarMatrix = (bool *) calloc(nOfElements, sizeof(bool)); /* used in step4 */
+
+  /* preliminary steps */
+  if (nOfRows &lt;= nOfColumns)
+  {
+    minDim = nOfRows;
+
+    for (row = 0; row &lt; nOfRows; row++)
+    {
+      /* find the smallest element in the row */
+      distMatrixTemp = distMatrix + row;
+      minValue = *distMatrixTemp;
+      distMatrixTemp += nOfRows;
+      while (distMatrixTemp &lt; distMatrixEnd)
+      {
+        value = *distMatrixTemp;
+        if (value &lt; minValue)
+          minValue = value;
+        distMatrixTemp += nOfRows;
+      }
+
+      /* subtract the smallest element from each element of the row */
+      distMatrixTemp = distMatrix + row;
+      while (distMatrixTemp &lt; distMatrixEnd)
+      {
+        *distMatrixTemp -= minValue;
+        distMatrixTemp += nOfRows;
+      }
+    }
+
+    /* Steps 1 and 2a */
+    for (row = 0; row &lt; nOfRows; row++)
+      for (col = 0; col &lt; nOfColumns; col++)
+        if (fabs(distMatrix[row + nOfRows * col]) &lt; DBL_EPSILON)
+          if (!coveredColumns[col])
+          {
+            starMatrix[row + nOfRows * col] = true;
+            coveredColumns[col] = true;
+            break;
+          }
+  } else /* if(nOfRows &gt; nOfColumns) */
+  {
+    minDim = nOfColumns;
+
+    for (col = 0; col &lt; nOfColumns; col++)
+    {
+      /* find the smallest element in the column */
+      distMatrixTemp = distMatrix + nOfRows * col;
+      columnEnd = distMatrixTemp + nOfRows;
+
+      minValue = *distMatrixTemp++;
+      while (distMatrixTemp &lt; columnEnd)
+      {
+        value = *distMatrixTemp++;
+        if (value &lt; minValue)
+          minValue = value;
+      }
+
+      /* subtract the smallest element from each element of the column */
+      distMatrixTemp = distMatrix + nOfRows * col;
+      while (distMatrixTemp &lt; columnEnd)
+        *distMatrixTemp++ -= minValue;
+    }
+
+    /* Steps 1 and 2a */
+    for (col = 0; col &lt; nOfColumns; col++)
+      for (row = 0; row &lt; nOfRows; row++)
+        if (fabs(distMatrix[row + nOfRows * col]) &lt; DBL_EPSILON)
+          if (!coveredRows[row])
+          {
+            starMatrix[row + nOfRows * col] = true;
+            coveredColumns[col] = true;
+            coveredRows[row] = true;
+            break;
+          }
+    for (row = 0; row &lt; nOfRows; row++)
+      coveredRows[row] = false;
+
+  }
+
+  /* move to step 2b */
+  step2b(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows,
+         nOfColumns, minDim);
+
+  /* compute cost and remove invalid assignments */
+  computeassignmentcost(assignment, cost, distMatrixIn, nOfRows);
+
+  /* free allocated memory */
+  free(distMatrix);
+  free(coveredColumns);
+  free(coveredRows);
+  free(starMatrix);
+  free(primeMatrix);
+  free(newStarMatrix);
+
+  return;
 }
 
 /********************************************************/
 void HungarianAlgorithm::buildassignmentvector(int *assignment, bool *starMatrix, int nOfRows, int nOfColumns)
 {
-	int row, col;
+  int row, col;
 
-	for (row = 0; row&lt;nOfRows; row++)
-		for (col = 0; col&lt;nOfColumns; col++)
-			if (starMatrix[row + nOfRows*col])
-			{
+  for (row = 0; row &lt; nOfRows; row++)
+    for (col = 0; col &lt; nOfColumns; col++)
+      if (starMatrix[row + nOfRows * col])
+      {
 #ifdef ONE_INDEXING
-				assignment[row] = col + 1; /* MATLAB-Indexing */
+        assignment[row] = col + 1; /* MATLAB-Indexing */
 #else
-				assignment[row] = col;
+        assignment[row] = col;
 #endif
-				break;
-			}
+        break;
+      }
 }
 
 /********************************************************/
 void HungarianAlgorithm::computeassignmentcost(int *assignment, double *cost, double *distMatrix, int nOfRows)
 {
-	int row, col;
-
-	for (row = 0; row&lt;nOfRows; row++)
-	{
-		col = assignment[row];
-		if (col &gt;= 0)
-			*cost += distMatrix[row + nOfRows*col];
-	}
+  int row, col;
+
+  for (row = 0; row &lt; nOfRows; row++)
+  {
+    col = assignment[row];
+    if (col &gt;= 0)
+      *cost += distMatrix[row + nOfRows * col];
+  }
 }
 
 /********************************************************/
-void HungarianAlgorithm::step2a(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim)
+void HungarianAlgorithm::step2a(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix,
+                                bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns,
+                                int minDim)
 {
-	bool *starMatrixTemp, *columnEnd;
-	int col;
-
-	/* cover every column containing a starred zero */
-	for (col = 0; col&lt;nOfColumns; col++)
-	{
-		starMatrixTemp = starMatrix + nOfRows*col;
-		columnEnd = starMatrixTemp + nOfRows;
-		while (starMatrixTemp &lt; columnEnd){
-			if (*starMatrixTemp++)
-			{
-				coveredColumns[col] = true;
-				break;
-			}
-		}
-	}
-
-	/* move to step 3 */
-	step2b(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows, nOfColumns, minDim);
+  bool *starMatrixTemp, *columnEnd;
+  int col;
+
+  /* cover every column containing a starred zero */
+  for (col = 0; col &lt; nOfColumns; col++)
+  {
+    starMatrixTemp = starMatrix + nOfRows * col;
+    columnEnd = starMatrixTemp + nOfRows;
+    while (starMatrixTemp &lt; columnEnd)
+    {
+      if (*starMatrixTemp++)
+      {
+        coveredColumns[col] = true;
+        break;
+      }
+    }
+  }
+
+  /* move to step 3 */
+  step2b(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows,
+         nOfColumns, minDim);
 }
 
 /********************************************************/
-void HungarianAlgorithm::step2b(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim)
+void HungarianAlgorithm::step2b(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix,
+                                bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns,
+                                int minDim)
 {
-	int col, nOfCoveredColumns;
-
-	/* count covered columns */
-	nOfCoveredColumns = 0;
-	for (col = 0; col&lt;nOfColumns; col++)
-		if (coveredColumns[col])
-			nOfCoveredColumns++;
-
-	if (nOfCoveredColumns == minDim)
-	{
-		/* algorithm finished */
-		buildassignmentvector(assignment, starMatrix, nOfRows, nOfColumns);
-	}
-	else
-	{
-		/* move to step 3 */
-		step3(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows, nOfColumns, minDim);
-	}
+  int col, nOfCoveredColumns;
+
+  /* count covered columns */
+  nOfCoveredColumns = 0;
+  for (col = 0; col &lt; nOfColumns; col++)
+    if (coveredColumns[col])
+      nOfCoveredColumns++;
+
+  if (nOfCoveredColumns == minDim)
+  {
+    /* algorithm finished */
+    buildassignmentvector(assignment, starMatrix, nOfRows, nOfColumns);
+  } else
+  {
+    /* move to step 3 */
+    step3(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows,
+          nOfColumns, minDim);
+  }
 
 }
 
 /********************************************************/
-void HungarianAlgorithm::step3(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim)
+void
+HungarianAlgorithm::step3(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix,
+                          bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim)
 {
-	bool zerosFound;
-	int row, col, starCol;
-
-	zerosFound = true;
-	while (zerosFound)
-	{
-		zerosFound = false;
-		for (col = 0; col&lt;nOfColumns; col++)
-			if (!coveredColumns[col])
-				for (row = 0; row&lt;nOfRows; row++)
-					if ((!coveredRows[row]) &amp;&amp; (fabs(distMatrix[row + nOfRows*col]) &lt; DBL_EPSILON))
-					{
-						/* prime zero */
-						primeMatrix[row + nOfRows*col] = true;
-
-						/* find starred zero in current row */
-						for (starCol = 0; starCol&lt;nOfColumns; starCol++)
-							if (starMatrix[row + nOfRows*starCol])
-								break;
-
-						if (starCol == nOfColumns) /* no starred zero found */
-						{
-							/* move to step 4 */
-							step4(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows, nOfColumns, minDim, row, col);
-							return;
-						}
-						else
-						{
-							coveredRows[row] = true;
-							coveredColumns[starCol] = false;
-							zerosFound = true;
-							break;
-						}
-					}
-	}
-
-	/* move to step 5 */
-	step5(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows, nOfColumns, minDim);
+  bool zerosFound;
+  int row, col, starCol;
+
+  zerosFound = true;
+  while (zerosFound)
+  {
+    zerosFound = false;
+    for (col = 0; col &lt; nOfColumns; col++)
+      if (!coveredColumns[col])
+        for (row = 0; row &lt; nOfRows; row++)
+          if ((!coveredRows[row]) &amp;&amp; (fabs(distMatrix[row + nOfRows * col]) &lt; DBL_EPSILON))
+          {
+            /* prime zero */
+            primeMatrix[row + nOfRows * col] = true;
+
+            /* find starred zero in current row */
+            for (starCol = 0; starCol &lt; nOfColumns; starCol++)
+              if (starMatrix[row + nOfRows * starCol])
+                break;
+
+            if (starCol == nOfColumns) /* no starred zero found */
+            {
+              /* move to step 4 */
+              step4(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows,
+                    nOfRows, nOfColumns, minDim, row, col);
+              return;
+            } else
+            {
+              coveredRows[row] = true;
+              coveredColumns[starCol] = false;
+              zerosFound = true;
+              break;
+            }
+          }
+  }
+
+  /* move to step 5 */
+  step5(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows,
+        nOfColumns, minDim);
 }
 
 /********************************************************/
-void HungarianAlgorithm::step4(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim, int row, int col)
+void
+HungarianAlgorithm::step4(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix,
+                          bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim, int row,
+                          int col)
 {
-	int n, starRow, starCol, primeRow, primeCol;
-	int nOfElements = nOfRows*nOfColumns;
-
-	/* generate temporary copy of starMatrix */
-	for (n = 0; n&lt;nOfElements; n++)
-		newStarMatrix[n] = starMatrix[n];
-
-	/* star current zero */
-	newStarMatrix[row + nOfRows*col] = true;
-
-	/* find starred zero in current column */
-	starCol = col;
-	for (starRow = 0; starRow&lt;nOfRows; starRow++)
-		if (starMatrix[starRow + nOfRows*starCol])
-			break;
-
-	while (starRow&lt;nOfRows)
-	{
-		/* unstar the starred zero */
-		newStarMatrix[starRow + nOfRows*starCol] = false;
-
-		/* find primed zero in current row */
-		primeRow = starRow;
-		for (primeCol = 0; primeCol&lt;nOfColumns; primeCol++)
-			if (primeMatrix[primeRow + nOfRows*primeCol])
-				break;
-
-		/* star the primed zero */
-		newStarMatrix[primeRow + nOfRows*primeCol] = true;
-
-		/* find starred zero in current column */
-		starCol = primeCol;
-		for (starRow = 0; starRow&lt;nOfRows; starRow++)
-			if (starMatrix[starRow + nOfRows*starCol])
-				break;
-	}
-
-	/* use temporary copy as new starMatrix */
-	/* delete all primes, uncover all rows */
-	for (n = 0; n&lt;nOfElements; n++)
-	{
-		primeMatrix[n] = false;
-		starMatrix[n] = newStarMatrix[n];
-	}
-	for (n = 0; n&lt;nOfRows; n++)
-		coveredRows[n] = false;
-
-	/* move to step 2a */
-	step2a(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows, nOfColumns, minDim);
+  int n, starRow, starCol, primeRow, primeCol;
+  int nOfElements = nOfRows * nOfColumns;
+
+  /* generate temporary copy of starMatrix */
+  for (n = 0; n &lt; nOfElements; n++)
+    newStarMatrix[n] = starMatrix[n];
+
+  /* star current zero */
+  newStarMatrix[row + nOfRows * col] = true;
+
+  /* find starred zero in current column */
+  starCol = col;
+  for (starRow = 0; starRow &lt; nOfRows; starRow++)
+    if (starMatrix[starRow + nOfRows * starCol])
+      break;
+
+  while (starRow &lt; nOfRows)
+  {
+    /* unstar the starred zero */
+    newStarMatrix[starRow + nOfRows * starCol] = false;
+
+    /* find primed zero in current row */
+    primeRow = starRow;
+    for (primeCol = 0; primeCol &lt; nOfColumns; primeCol++)
+      if (primeMatrix[primeRow + nOfRows * primeCol])
+        break;
+
+    /* star the primed zero */
+    newStarMatrix[primeRow + nOfRows * primeCol] = true;
+
+    /* find starred zero in current column */
+    starCol = primeCol;
+    for (starRow = 0; starRow &lt; nOfRows; starRow++)
+      if (starMatrix[starRow + nOfRows * starCol])
+        break;
+  }
+
+  /* use temporary copy as new starMatrix */
+  /* delete all primes, uncover all rows */
+  for (n = 0; n &lt; nOfElements; n++)
+  {
+    primeMatrix[n] = false;
+    starMatrix[n] = newStarMatrix[n];
+  }
+  for (n = 0; n &lt; nOfRows; n++)
+    coveredRows[n] = false;
+
+  /* move to step 2a */
+  step2a(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows,
+         nOfColumns, minDim);
 }
 
 /********************************************************/
-void HungarianAlgorithm::step5(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim)
+void
+HungarianAlgorithm::step5(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix,
+                          bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim)
 {
-	double h, value;
-	int row, col;
-
-	/* find smallest uncovered element h */
-	h = DBL_MAX;
-	for (row = 0; row&lt;nOfRows; row++)
-		if (!coveredRows[row])
-			for (col = 0; col&lt;nOfColumns; col++)
-				if (!coveredColumns[col])
-				{
-					value = distMatrix[row + nOfRows*col];
-					if (value &lt; h)
-						h = value;
-				}
-
-	/* add h to each covered row */
-	for (row = 0; row&lt;nOfRows; row++)
-		if (coveredRows[row])
-			for (col = 0; col&lt;nOfColumns; col++)
-				distMatrix[row + nOfRows*col] += h;
-
-	/* subtract h from each uncovered column */
-	for (col = 0; col&lt;nOfColumns; col++)
-		if (!coveredColumns[col])
-			for (row = 0; row&lt;nOfRows; row++)
-				distMatrix[row + nOfRows*col] -= h;
-
-	/* move to step 3 */
-	step3(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows, nOfColumns, minDim);
+  double h, value;
+  int row, col;
+
+  /* find smallest uncovered element h */
+  h = DBL_MAX;
+  for (row = 0; row &lt; nOfRows; row++)
+    if (!coveredRows[row])
+      for (col = 0; col &lt; nOfColumns; col++)
+        if (!coveredColumns[col])
+        {
+          value = distMatrix[row + nOfRows * col];
+          if (value &lt; h)
+            h = value;
+        }
+
+  /* add h to each covered row */
+  for (row = 0; row &lt; nOfRows; row++)
+    if (coveredRows[row])
+      for (col = 0; col &lt; nOfColumns; col++)
+        distMatrix[row + nOfRows * col] += h;
+
+  /* subtract h from each uncovered column */
+  for (col = 0; col &lt; nOfColumns; col++)
+    if (!coveredColumns[col])
+      for (row = 0; row &lt; nOfRows; row++)
+        distMatrix[row + nOfRows * col] -= h;
+
+  /* move to step 3 */
+  step3(assignment, distMatrix, starMatrix, newStarMatrix, primeMatrix, coveredColumns, coveredRows, nOfRows,
+        nOfColumns, minDim);
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\lib\hungarian.h" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\lib\hungarian.h" added_lines="25" deleted_lines="11">
				<diff>@@ -21,19 +21,33 @@ using namespace std;
 class HungarianAlgorithm
 {
 public:
-	HungarianAlgorithm();
-	~HungarianAlgorithm();
-	double Solve(vector &lt;vector&lt;double&gt; &gt;&amp; DistMatrix, vector&lt;int&gt;&amp; Assignment);
+  HungarianAlgorithm();
+
+  ~HungarianAlgorithm();
+
+  double Solve(vector&lt;vector&lt;double&gt; &gt; &amp;DistMatrix, vector&lt;int&gt; &amp;Assignment);
 
 private:
-	void assignmentoptimal(int *assignment, double *cost, double *distMatrix, int nOfRows, int nOfColumns);
-	void buildassignmentvector(int *assignment, bool *starMatrix, int nOfRows, int nOfColumns);
-	void computeassignmentcost(int *assignment, double *cost, double *distMatrix, int nOfRows);
-	void step2a(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim);
-	void step2b(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim);
-	void step3(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim);
-	void step4(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim, int row, int col);
-	void step5(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix, bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim);
+  void assignmentoptimal(int *assignment, double *cost, double *distMatrix, int nOfRows, int nOfColumns);
+
+  void buildassignmentvector(int *assignment, bool *starMatrix, int nOfRows, int nOfColumns);
+
+  void computeassignmentcost(int *assignment, double *cost, double *distMatrix, int nOfRows);
+
+  void step2a(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix,
+              bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim);
+
+  void step2b(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix,
+              bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim);
+
+  void step3(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix,
+             bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim);
+
+  void step4(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix,
+             bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim, int row, int col);
+
+  void step5(int *assignment, double *distMatrix, bool *starMatrix, bool *newStarMatrix, bool *primeMatrix,
+             bool *coveredColumns, bool *coveredRows, int nOfRows, int nOfColumns, int minDim);
 };
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\src\vision_beyond_track.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\src\vision_beyond_track.cpp" added_lines="266" deleted_lines="263">
				<diff>@@ -37,7 +37,9 @@
 #if (CV_MAJOR_VERSION &lt;= 2)
 #include &lt;opencv2/contrib/contrib.hpp&gt;
 #else
+
 #include "gencolors.cpp"
+
 #endif
 
 const static double MAX_VALUE = 10000;
@@ -48,346 +50,347 @@ static double sz_ub[3] = {34, 31.5, 31.5};
 static double sz_lb[3] = {-34, -31.5, -31.5};
 
 beyondtrack::ObjectCuboid beyondtrack::Detection::params_car_cuboid_ = beyondtrack::ObjectCuboid(avg_car_sz, sz_ub,
-                                                                                               sz_lb);
+                                                                                                 sz_lb);
 
 namespace beyondtrack
 {
-    void BeyondTracker::initialize(cv::Mat in_angle, double in_height)
+  void BeyondTracker::initialize(cv::Mat in_angle, double in_height)
+  {
+    for (auto &amp;&amp;cd: cur_detections_)
     {
-        for (auto &amp;&amp;cd: cur_detections_)
-        {
-            cd.object_id_ = global_id_;
-            global_id_++;
-            cd.propagate_cur_det(canonical_cuboid_, in_height, camera_k_, camera_inv_k_, in_angle);
-        }
-        prev_detections_ = cur_detections_;
-        prev_pose_ = cur_pose_;
-        initialized_ = true;
+      cd.object_id_ = global_id_;
+      global_id_++;
+      cd.propagate_cur_det(canonical_cuboid_, in_height, camera_k_, camera_inv_k_, in_angle);
     }
-
-    cv::Mat BeyondTracker::create_cuboid()
+    prev_detections_ = cur_detections_;
+    prev_pose_ = cur_pose_;
+    initialized_ = true;
+  }
+
+  cv::Mat BeyondTracker::create_cuboid()
+  {
+    double l = Detection::params_car_cuboid_.avg_l / 2;
+    double h = Detection::params_car_cuboid_.avg_h / 2;
+    double w = Detection::params_car_cuboid_.avg_w / 2;
+    cv::Mat cuboid = (cv::Mat_&lt;double&gt;(8, 3) &lt;&lt;
+                                             -l, h, -w, l, h, -w, -l, h, w, l, h, w,
+      -l, -h, -w, l, -h, -w, -l, -h, w, l, -h, w);
+    return cuboid;
+  }
+
+  void BeyondTracker::propagate_detections(cv::Mat n, double h)
+  {
+    for (auto &amp;&amp;cd: cur_detections_)
     {
-        double l = Detection::params_car_cuboid_.avg_l / 2;
-        double h = Detection::params_car_cuboid_.avg_h / 2;
-        double w = Detection::params_car_cuboid_.avg_w / 2;
-        cv::Mat cuboid = (cv::Mat_&lt;double&gt;(8, 3) &lt;&lt;
-                                                 -l, h, -w, l, h, -w, -l, h, w, l, h, w,
-                -l, -h, -w, l, -h, -w, -l, -h, w, l, -h, w);
-        return cuboid;
+      cd.propagate_cur_det(canonical_cuboid_, h, camera_k_, camera_inv_k_, n);
     }
-
-    void BeyondTracker::propagate_detections(cv::Mat n, double h)
+    for (auto &amp;&amp;pd: prev_detections_)
     {
-        for (auto &amp;&amp;cd: cur_detections_)
-        {
-            cd.propagate_cur_det(canonical_cuboid_, h, camera_k_, camera_inv_k_, n);
-        }
-        for (auto &amp;&amp;pd: prev_detections_)
-        {
-            pd.propagate_prev_det(camera_k_, motion_);
-        }
+      pd.propagate_prev_det(camera_k_, motion_);
     }
+  }
 
-    std::vector&lt; std::vector&lt;double&gt; &gt; BeyondTracker::generate_score_matrices()
+  std::vector&lt;std::vector&lt;double&gt; &gt; BeyondTracker::generate_score_matrices()
+  {
+    std::vector&lt;std::vector&lt;double&gt; &gt; array;
+    for (auto &amp;&amp;pd: prev_detections_)
     {
-        std::vector&lt; std::vector&lt;double&gt; &gt; array;
-        for (auto &amp;&amp;pd: prev_detections_)
+      std::vector&lt;double&gt; tmp_array;
+      for (auto &amp;&amp;cd: cur_detections_)
+      {
+        double score_2d = get_3d2d_score(cd, pd);
+        double score_3d = get_3d3d_score(cd, pd);
+        double score = all_wts_[0] * score_3d + all_wts_[1] * score_2d;
+        if (score &gt; MAX_VALUE)
         {
-            std::vector&lt;double&gt; tmp_array;
-            for (auto &amp;&amp;cd: cur_detections_)
-            {
-                double score_2d = get_3d2d_score(cd, pd);
-                double score_3d = get_3d3d_score(cd, pd);
-                double score = all_wts_[0] * score_3d + all_wts_[1] * score_2d;
-                if (score &gt; MAX_VALUE)
-                {
-                    score = MAX_VALUE;
-                }
-                tmp_array.push_back(score);
-                // std::cout &lt;&lt; "Score 2d: " &lt;&lt; score_2d &lt;&lt; '\n';
-                // std::cout &lt;&lt; "Score 3d: " &lt;&lt; score_3d &lt;&lt; '\n';
-                // std::cout &lt;&lt; "Score: " &lt;&lt; score &lt;&lt; '\n';
-                // std::cout &lt;&lt; score &lt;&lt; '\t';
-            }
-            // std::cout &lt;&lt; '\n';
-            array.push_back(tmp_array);
+          score = MAX_VALUE;
         }
-        return array;
+        tmp_array.push_back(score);
+        // std::cout &lt;&lt; "Score 2d: " &lt;&lt; score_2d &lt;&lt; '\n';
+        // std::cout &lt;&lt; "Score 3d: " &lt;&lt; score_3d &lt;&lt; '\n';
+        // std::cout &lt;&lt; "Score: " &lt;&lt; score &lt;&lt; '\n';
+        // std::cout &lt;&lt; score &lt;&lt; '\t';
+      }
+      // std::cout &lt;&lt; '\n';
+      array.push_back(tmp_array);
     }
+    return array;
+  }
 
-    BeyondTracker::BeyondTracker(cv::Mat k_)
+  BeyondTracker::BeyondTracker(cv::Mat k_)
+  {
+    camera_k_ = k_;
+    camera_inv_k_ = camera_k_.inv();
+  }
+
+  void BeyondTracker::process(std::vector&lt;Detection&gt; in_detections, cv::Mat in_pose, cv::Mat in_angle, double in_height)
+  {
+    cur_detections_ = in_detections;
+    cur_pose_ = in_pose;
+
+    if (in_detections.empty())
     {
-        camera_k_ = k_;
-        camera_inv_k_ = camera_k_.inv();
+      initialized_ = false;
+      return;
     }
 
-    void BeyondTracker::process(std::vector&lt;Detection&gt; in_detections, cv::Mat in_pose, cv::Mat in_angle, double in_height)
+    if (!initialized_)
     {
-        cur_detections_ = in_detections;
-        cur_pose_ = in_pose;
-
-        if (in_detections.empty())
-        {
-            initialized_ = false;
-            return;
-        }
-
-        if (!initialized_)
-        {
-            initialize(in_angle, in_height);
-            return;
-        }
-
-        motion_ = -(cur_pose_ - prev_pose_);
-        motion_.at&lt;double&gt;(0, 3) = deg2rad(0); // TODO: subscribe from lidar localizer or camera localizer
-        // motion *= (1.72 / 44);
-
-        // auto start = std::chrono::system_clock::now();
-        propagate_detections(in_angle, in_height);
-        // auto end = std::chrono::system_clock::now();
-        // auto dur = end - start;
-        // auto msec = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).count();
-        // std::cout &lt;&lt; "propagate_detections: " &lt;&lt; msec &lt;&lt; " milli sec \in_angle";
-
-        // Cost estimation
-        // start = std::chrono::system_clock::now();
-        std::vector&lt; std::vector&lt;double&gt; &gt; cost_matrix = generate_score_matrices();
-        // end = std::chrono::system_clock::now();
-        // dur = end - start;
-        // msec = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).count();
-        // std::cout &lt;&lt; "generate_score_matrices: " &lt;&lt; msec &lt;&lt; " milli sec \in_angle";
-
-        // start = std::chrono::system_clock::now();
-        HungarianAlgorithm HungAlgo;
-        std::vector&lt;int&gt; assignment;
-
-        //double cost =
-        HungAlgo.Solve(cost_matrix, assignment);
-
-        // end = std::chrono::system_clock::now();
-        // dur = end - start;
-        // msec = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).count();
-        // std::cout &lt;&lt; "HungarianAlgorithm: " &lt;&lt; msec &lt;&lt; " milli sec \in_angle";
-
-        for (unsigned int x = 0; x &lt; cost_matrix.size(); x++)
-        {
-            if ((assignment[x] != -1) &amp;&amp; (cost_matrix[x][assignment[x]] &lt; THRES_SCORE))
-            {
-                // std::cout &lt;&lt; x &lt;&lt; "," &lt;&lt; assignment[x] &lt;&lt; "\t";
-                cur_detections_[assignment[x]].object_id_ = prev_detections_[x].object_id_;
-            }
-        }
-
-        for (auto &amp;&amp;cd: cur_detections_)
-        {
-            if (cd.object_id_ == -1)
-            {
-                cd.object_id_ = global_id_++;
-            }
-        }
-
-        prev_detections_ = cur_detections_;
-        prev_pose_ = cur_pose_;
+      initialize(in_angle, in_height);
+      return;
     }
 
-    std::vector&lt;Detection&gt; BeyondTracker::get_results()
+    motion_ = -(cur_pose_ - prev_pose_);
+    motion_.at&lt;double&gt;(0, 3) = deg2rad(0); // TODO: subscribe from lidar localizer or camera localizer
+    // motion *= (1.72 / 44);
+
+    // auto start = std::chrono::system_clock::now();
+    propagate_detections(in_angle, in_height);
+    // auto end = std::chrono::system_clock::now();
+    // auto dur = end - start;
+    // auto msec = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).count();
+    // std::cout &lt;&lt; "propagate_detections: " &lt;&lt; msec &lt;&lt; " milli sec \in_angle";
+
+    // Cost estimation
+    // start = std::chrono::system_clock::now();
+    std::vector&lt;std::vector&lt;double&gt; &gt; cost_matrix = generate_score_matrices();
+    // end = std::chrono::system_clock::now();
+    // dur = end - start;
+    // msec = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).count();
+    // std::cout &lt;&lt; "generate_score_matrices: " &lt;&lt; msec &lt;&lt; " milli sec \in_angle";
+
+    // start = std::chrono::system_clock::now();
+    HungarianAlgorithm HungAlgo;
+    std::vector&lt;int&gt; assignment;
+
+    //double cost =
+    HungAlgo.Solve(cost_matrix, assignment);
+
+    // end = std::chrono::system_clock::now();
+    // dur = end - start;
+    // msec = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).count();
+    // std::cout &lt;&lt; "HungarianAlgorithm: " &lt;&lt; msec &lt;&lt; " milli sec \in_angle";
+
+    for (unsigned int x = 0; x &lt; cost_matrix.size(); x++)
     {
-        return cur_detections_;
+      if ((assignment[x] != -1) &amp;&amp; (cost_matrix[x][assignment[x]] &lt; THRES_SCORE))
+      {
+        // std::cout &lt;&lt; x &lt;&lt; "," &lt;&lt; assignment[x] &lt;&lt; "\t";
+        cur_detections_[assignment[x]].object_id_ = prev_detections_[x].object_id_;
+      }
     }
 
-    void BeyondTracker::set_intrinsic(cv::Mat k_)
+    for (auto &amp;&amp;cd: cur_detections_)
     {
-        camera_k_ = k_;
-        camera_inv_k_ = camera_k_.inv();
+      if (cd.object_id_ == -1)
+      {
+        cd.object_id_ = global_id_++;
+      }
     }
 
-    double BeyondTracker::get_3d2d_score(Detection cd, Detection pd)
+    prev_detections_ = cur_detections_;
+    prev_pose_ = cur_pose_;
+  }
+
+  std::vector&lt;Detection&gt; BeyondTracker::get_results()
+  {
+    return cur_detections_;
+  }
+
+  void BeyondTracker::set_intrinsic(cv::Mat k_)
+  {
+    camera_k_ = k_;
+    camera_inv_k_ = camera_k_.inv();
+  }
+
+  double BeyondTracker::get_3d2d_score(Detection cd, Detection pd)
+  {
+    Paths solution;
+    Clipper c;
+    c.AddPaths(pd.pd_2d_convhull_clip_, ptSubject, true);
+    c.AddPaths(cd.cd_2d_convhull_clip_, ptClip, true);
+    c.Execute(ctIntersection, solution, pftNonZero, pftNonZero);
+    if (solution.size() &gt; 0)
     {
-        Paths solution;
-        Clipper c;
-        c.AddPaths(pd.pd_2d_convhull_clip_, ptSubject, true);
-        c.AddPaths(cd.cd_2d_convhull_clip_, ptClip, true);
-        c.Execute(ctIntersection, solution, pftNonZero, pftNonZero);
-        if (solution.size() &gt; 0)
-        {
-            c.Execute(ctUnion, solution, pftNonZero, pftNonZero);
-            auto area_in = Area(solution[0]);
-            double area_target = cd.cd_area_;
-            return area_in / area_target;
-        }
-        else
-        {
-            return MAX_VALUE;
-        }
+      c.Execute(ctUnion, solution, pftNonZero, pftNonZero);
+      auto area_in = Area(solution[0]);
+      double area_target = cd.cd_area_;
+      return area_in / area_target;
+    } else
+    {
+      return MAX_VALUE;
     }
-
-    double BeyondTracker::get_3d3d_score(Detection cd, Detection pd)
+  }
+
+  double BeyondTracker::get_3d3d_score(Detection cd, Detection pd)
+  {
+    Paths solution;
+    Clipper c;
+    c.AddPaths(cd.cd_3d_convhull_clip_, ptSubject, true);
+    c.AddPaths(pd.pd_3d_convhull_clip_, ptClip, true);
+    c.Execute(ctIntersection, solution, pftNonZero, pftNonZero);
+    if (solution.size() &gt; 0)
     {
-        Paths solution;
-        Clipper c;
-        c.AddPaths(cd.cd_3d_convhull_clip_, ptSubject, true);
-        c.AddPaths(pd.pd_3d_convhull_clip_, ptClip, true);
-        c.Execute(ctIntersection, solution, pftNonZero, pftNonZero);
-        if (solution.size() &gt; 0)
-        {
-            c.Execute(ctUnion, solution, pftNonZero, pftNonZero);
-            auto area_in = Area(solution[0]);
-            double area_target = cv::contourArea(cd.cd_3d_convhull_);
-            return area_in / area_target;
-        }
-        else
-        {
-            return MAX_VALUE;
-        }
+      c.Execute(ctUnion, solution, pftNonZero, pftNonZero);
+      auto area_in = Area(solution[0]);
+      double area_target = cv::contourArea(cd.cd_3d_convhull_);
+      return area_in / area_target;
+    } else
+    {
+      return MAX_VALUE;
     }
+  }
 }
 
-std::vector&lt;beyondtrack::Detection&gt;  BeyondTrackerNode::parse_detected_object(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections)
+std::vector&lt;beyondtrack::Detection&gt;
+BeyondTrackerNode::parse_detected_object(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections)
 {
-    std::vector&lt;beyondtrack::Detection&gt; detections;
-    for (const auto &amp;e: in_vision_detections-&gt;objects)
+  std::vector&lt;beyondtrack::Detection&gt; detections;
+  for (const auto &amp;e: in_vision_detections-&gt;objects)
+  {
+    //if (e.label == "person" || e.label == "car" || e.label == "truck")
     {
-        //if (e.label == "person" || e.label == "car" || e.label == "truck")
-        {
-            beyondtrack::Detection detection(e.x, e.y, e.width, e.height, e.label);
-            detections.push_back(detection);
-            // std::cout &lt;&lt; "##########################\n";
-            // std::cout &lt;&lt; "Class: " &lt;&lt; e.id &lt;&lt; '\t' &lt;&lt; e.label &lt;&lt; '\t' &lt;&lt; e.score &lt;&lt; '\n';
-            // std::cout &lt;&lt; "Input bbox_: " &lt;&lt; detection.bbox_[0] &lt;&lt; '\t' &lt;&lt; detection.bbox_[1] &lt;&lt; '\t' &lt;&lt; detection.bbox_[2] &lt;&lt; '\t' &lt;&lt; detection.bbox_[3] &lt;&lt; '\n';
-        }
+      beyondtrack::Detection detection(e.x, e.y, e.width, e.height, e.label);
+      detections.push_back(detection);
+      // std::cout &lt;&lt; "##########################\n";
+      // std::cout &lt;&lt; "Class: " &lt;&lt; e.id &lt;&lt; '\t' &lt;&lt; e.label &lt;&lt; '\t' &lt;&lt; e.score &lt;&lt; '\n';
+      // std::cout &lt;&lt; "Input bbox_: " &lt;&lt; detection.bbox_[0] &lt;&lt; '\t' &lt;&lt; detection.bbox_[1] &lt;&lt; '\t' &lt;&lt; detection.bbox_[2] &lt;&lt; '\t' &lt;&lt; detection.bbox_[3] &lt;&lt; '\n';
     }
-    return detections;
+  }
+  return detections;
 }
 
 void BeyondTrackerNode::detection_to_objects(const std::vector&lt;beyondtrack::Detection&gt; &amp;in_objects,
-                                                  autoware_msgs::DetectedObjectArray&amp; out_message)
+                                             autoware_msgs::DetectedObjectArray &amp;out_message)
 {
-    for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
-    {
-            autoware_msgs::DetectedObject obj;
-
-            obj.x = (in_objects[i].bbox_[0]);
-            obj.y = (in_objects[i].bbox_[1]);
-            obj.width = (in_objects[i].bbox_[2] - in_objects[i].bbox_[0]);
-            obj.height = (in_objects[i].bbox_[3] - in_objects[i].bbox_[1]);
-            if (obj.x &lt; 0)
-                obj.x = 0;
-            if (obj.y &lt; 0)
-                obj.y = 0;
-            if (obj.width &lt; 0)
-                obj.width = 0;
-            if (obj.height &lt; 0)
-                obj.height = 0;
-
-            size_t color_index = in_objects[i].object_id_ % colors_.size();
-            obj.color.r = colors_[color_index].val[0];
-            obj.color.g = colors_[color_index].val[1];
-            obj.color.b = colors_[color_index].val[2];
-            obj.color.a = 1.0f;
-
-            obj.score = 0.0;
-            obj.label = in_objects[i].class_type_;
-
-            obj.id = in_objects[i].object_id_;
-            obj.image_frame = out_message.header.frame_id;
-
-            // set bounding box direction
-            tf::Quaternion quat = tf::createQuaternionFromRPY(0.0, 0.0, in_objects[i].yaw_);
-            tf::quaternionTFToMsg(quat, obj.pose.orientation);
-
-            out_message.objects.push_back(obj);
-    }
+  for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
+  {
+    autoware_msgs::DetectedObject obj;
+
+    obj.x = (in_objects[i].bbox_[0]);
+    obj.y = (in_objects[i].bbox_[1]);
+    obj.width = (in_objects[i].bbox_[2] - in_objects[i].bbox_[0]);
+    obj.height = (in_objects[i].bbox_[3] - in_objects[i].bbox_[1]);
+    if (obj.x &lt; 0)
+      obj.x = 0;
+    if (obj.y &lt; 0)
+      obj.y = 0;
+    if (obj.width &lt; 0)
+      obj.width = 0;
+    if (obj.height &lt; 0)
+      obj.height = 0;
+
+    size_t color_index = in_objects[i].object_id_ % colors_.size();
+    obj.color.r = colors_[color_index].val[0];
+    obj.color.g = colors_[color_index].val[1];
+    obj.color.b = colors_[color_index].val[2];
+    obj.color.a = 1.0f;
+
+    obj.score = 0.0;
+    obj.label = in_objects[i].class_type_;
+
+    obj.id = in_objects[i].object_id_;
+    obj.image_frame = out_message.header.frame_id;
+
+    // set bounding box direction
+    tf::Quaternion quat = tf::createQuaternionFromRPY(0.0, 0.0, in_objects[i].yaw_);
+    tf::quaternionTFToMsg(quat, obj.pose.orientation);
+    obj.valid = true;
+
+    out_message.objects.push_back(obj);
+  }
 }
 
 void
 BeyondTrackerNode::vision_detection_callback(const autoware_msgs::DetectedObjectArray::ConstPtr &amp;in_vision_detections)
 {
-    if (camera_info_ok_)
+  if (camera_info_ok_)
+  {
+    if (!use_motion_)
     {
-        if (!use_motion_)
-        {
-            pose_ = cv::Mat::zeros(1, 4, CV_64FC1);
-        } else
-        {
-            // TODO
-        }
+      pose_ = cv::Mat::zeros(1, 4, CV_64FC1);
+    } else
+    {
+      // TODO
+    }
 
-        std::vector&lt;beyondtrack::Detection&gt; detections = parse_detected_object(in_vision_detections);
+    std::vector&lt;beyondtrack::Detection&gt; detections = parse_detected_object(in_vision_detections);
 
-        tracker_.process(detections, pose_, ground_angle_, camera_height_);
+    tracker_.process(detections, pose_, ground_angle_, camera_height_);
 
-        autoware_msgs::DetectedObjectArray final_objects;
+    autoware_msgs::DetectedObjectArray final_objects;
 
-        final_objects.header = in_vision_detections-&gt;header;
-        detection_to_objects(tracker_.get_results(), final_objects);
-        objects_publisher_.publish(final_objects);
+    final_objects.header = in_vision_detections-&gt;header;
+    detection_to_objects(tracker_.get_results(), final_objects);
+    objects_publisher_.publish(final_objects);
 
-        cv::Mat bg_image(image_size_, CV_8UC3, cv::Scalar(0,0,0));
-        //visualize_results(bg_image, tracker_.get_results());
+    cv::Mat bg_image(image_size_, CV_8UC3, cv::Scalar(0, 0, 0));
+    //visualize_results(bg_image, tracker_.get_results());
 
-    }
+  }
 
 }
 
 
 void BeyondTrackerNode::intrinsics_callback(const sensor_msgs::CameraInfo &amp;in_message)
 {
-    image_size_.height = in_message.height;
-    image_size_.width = in_message.width;
+  image_size_.height = in_message.height;
+  image_size_.width = in_message.width;
 
-    camera_instrinsics_ = cv::Mat(3, 3, CV_64FC1);
-    for (int row = 0; row &lt; 3; ++row)
+  camera_instrinsics_ = cv::Mat(3, 3, CV_64FC1);
+  for (int row = 0; row &lt; 3; ++row)
+  {
+    for (int col = 0; col &lt; 3; ++col)
     {
-        for (int col = 0; col &lt; 3; ++col)
-        {
-            camera_instrinsics_.at&lt;double&gt;(row, col) = in_message.K[row * 3 + col];
-        }
+      camera_instrinsics_.at&lt;double&gt;(row, col) = in_message.K[row * 3 + col];
     }
+  }
 
-    tracker_.set_intrinsic(camera_instrinsics_);
+  tracker_.set_intrinsic(camera_instrinsics_);
 
-    intrinsics_subscriber_.shutdown();
-    camera_info_ok_ = true;
-    ROS_INFO("[%s] CameraIntrinsics obtained.", __APP_NAME__);
+  intrinsics_subscriber_.shutdown();
+  camera_info_ok_ = true;
+  ROS_INFO("[%s] CameraIntrinsics obtained.", __APP_NAME__);
 }
 
 
 void BeyondTrackerNode::Run()
 {
-    ros::NodeHandle private_node_handle("~");//to receive args
+  ros::NodeHandle private_node_handle("~");//to receive args
 
-    std::string image_topic_src, camera_info_src, objects_topic_src;
+  std::string image_topic_src, camera_info_src, objects_topic_src;
 
-    private_node_handle.param&lt;std::string&gt;("camera_info_src", camera_info_src, "/camera_info");
-    private_node_handle.param&lt;std::string&gt;("objects_topic_src", objects_topic_src,
-                                           "/detection/vision_objects");
+  private_node_handle.param&lt;std::string&gt;("camera_info_src", camera_info_src, "/camera_info");
+  private_node_handle.param&lt;std::string&gt;("objects_topic_src", objects_topic_src,
+                                         "/detection/image_detector/objects");
 
-    ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, camera_info_src.c_str());
-    intrinsics_subscriber_ = private_node_handle.subscribe(
-            camera_info_src, 1, &amp;BeyondTrackerNode::intrinsics_callback, this);
+  ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, camera_info_src.c_str());
+  intrinsics_subscriber_ = private_node_handle.subscribe(
+    camera_info_src, 1, &amp;BeyondTrackerNode::intrinsics_callback, this);
 
-    ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, objects_topic_src.c_str());
-    detections_vision_subscriber_ = private_node_handle.subscribe(objects_topic_src,
-                                                                  1, &amp;BeyondTrackerNode::vision_detection_callback,
-                                                                  this);
+  ROS_INFO("[%s] Subscribing to... %s", __APP_NAME__, objects_topic_src.c_str());
+  detections_vision_subscriber_ = private_node_handle.subscribe(objects_topic_src,
+                                                                1, &amp;BeyondTrackerNode::vision_detection_callback,
+                                                                this);
 
-    private_node_handle.param&lt;double&gt;("camera_height", camera_height_, 1.2);
-    ROS_INFO("[%s] camera height: %f", __APP_NAME__, camera_height_);
+  private_node_handle.param&lt;double&gt;("camera_height", camera_height_, 1.2);
+  ROS_INFO("[%s] camera height: %f", __APP_NAME__, camera_height_);
 
-    objects_publisher_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/tracked_objects", 1);
+  objects_publisher_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/detection/image_tracker/objects",
+                                                                                  1);
 
-    #if (CV_MAJOR_VERSION &lt;= 2)
-        cv::generateColors(colors_, 20);
-    #else
-        generateColors(colors_, 20);
-    #endif
+#if (CV_MAJOR_VERSION &lt;= 2)
+  cv::generateColors(colors_, 20);
+#else
+  generateColors(colors_, 20);
+#endif
 
-    ground_angle_ = cv::Mat::zeros(1, 3, CV_64FC1);
-    ground_angle_.at&lt;double&gt;(0, 1) = 1;
+  ground_angle_ = cv::Mat::zeros(1, 3, CV_64FC1);
+  ground_angle_.at&lt;double&gt;(0, 1) = 1;
 
-    tracker_ = beyondtrack::BeyondTracker();
+  tracker_ = beyondtrack::BeyondTracker();
 
-    ros::spin();
+  ros::spin();
 
-    ROS_INFO("END beyond_tracker");
+  ROS_INFO("END beyond_tracker");
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\src\vision_beyond_track_node.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_beyond_track\src\vision_beyond_track_node.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -36,11 +36,11 @@
 
 int main(int argc, char **argv)
 {
-    ros::init(argc, argv, "vision_beyond_track");
+  ros::init(argc, argv, "vision_beyond_track");
 
-    BeyondTrackerNode app;
+  BeyondTrackerNode app;
 
-    app.Run();
+  app.Run();
 
-    return 0;
+  return 0;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\include\gencolors.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\integrated_viewer\include\gencolors.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\lib\convert_image.h" new_path="ros\src\computing\perception\detection\visualizers\packages\integrated_viewer\lib\convert_image.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\data_rate_checker_plugin\data_rate_checker_plugin.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\integrated_viewer\node\data_rate_checker_plugin\data_rate_checker_plugin.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\data_rate_checker_plugin\data_rate_checker_plugin.h" new_path="ros\src\computing\perception\detection\visualizers\packages\integrated_viewer\node\data_rate_checker_plugin\data_rate_checker_plugin.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_lane.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\integrated_viewer\node\image_viewer_plugin\draw_lane.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_lane.h" new_path="ros\src\computing\perception\detection\visualizers\packages\integrated_viewer\node\image_viewer_plugin\draw_lane.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_points.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\integrated_viewer\node\image_viewer_plugin\draw_points.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_points.h" new_path="ros\src\computing\perception\detection\visualizers\packages\integrated_viewer\node\image_viewer_plugin\draw_points.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" added_lines="5" deleted_lines="6">
				<diff>@@ -25,9 +25,9 @@ namespace integrated_viewer
     {
         // Generate color map to represent tracked object
 #if (CV_MAJOR_VERSION == 3)
-        generateColors(color_map_, 25);
+        generateColors(color_map_, 10);
 #else
-        cv::generateColors(color_map_, 25);
+        cv::generateColors(color_map_, 10);
 #endif
         car_image_ = cv::imread(DEFAULT_PATH + "car.png", cv::IMREAD_UNCHANGED);
         pedestrian_image_ = cv::imread(DEFAULT_PATH + "pedestrian.png", cv::IMREAD_UNCHANGED);
@@ -101,7 +101,7 @@ namespace integrated_viewer
                                                        cv::Point(x2,
                                                                  y2)));
                     cv::Mat color_fill(image_roi.size(), CV_8UC3,
-                                       cv::Scalar(detected_object.color.r, detected_object.color.g, detected_object.color.b));
+                                       color_map_[0]);
                     double alpha = 0.3;
                     cv::addWeighted(color_fill, alpha, image_roi, 1.0 - alpha , 0.0, image_roi);
                 }
@@ -111,7 +111,7 @@ namespace integrated_viewer
                               cv::Point(detected_object.x, detected_object.y),
                               cv::Point(x2,
                                         y2),
-                              cv::Scalar(detected_object.color.r, detected_object.color.g, detected_object.color.b),
+                              color_map_[0],
                               kRectangleThickness,
                               CV_AA,
                               0);
@@ -126,7 +126,6 @@ namespace integrated_viewer
         {
             return;
         }
-
         // Draw rectangles for each object
         for (const auto &amp;detected_object : detected_objects-&gt;objects)
         {
@@ -137,7 +136,7 @@ namespace integrated_viewer
                           cv::Point(detected_object.x, detected_object.y),
                           cv::Point(detected_object.x + detected_object.width,
                                     detected_object.y + detected_object.height),
-                          cv::Scalar(detected_object.color.r, detected_object.color.g, detected_object.color.b),
+                          color_map_[0],
                           kRectangleThickness,
                           CV_AA,
                           0);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.h" new_path="ros\src\computing\perception\detection\visualizers\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" new_path="ros\src\computing\perception\detection\visualizers\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.h" new_path="ros\src\computing\perception\detection\visualizers\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\include\gencolors.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\include\gencolors.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\image_d_viewer\image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\image_d_viewer\image_d_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\image_viewer\image_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\image_viewer\image_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\points_image_viewer\points_image_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\points_image_viewer\points_image_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\scan_image_d_viewer\scan_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\scan_image_d_viewer\scan_image_d_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\scan_image_viewer\scan_image_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\scan_image_viewer\scan_image_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\traffic_light_viewer\traffic_light_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\traffic_light_viewer\traffic_light_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\viewers\packages\viewers\nodes\vscan_image_viewer\vscan_image_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\vscan_image_viewer\vscan_image_viewer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\nodes\naive_motion_predict\naive_motion_predict.cpp" new_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\nodes\naive_motion_predict\naive_motion_predict.cpp" added_lines="6" deleted_lines="2">
				<diff>@@ -36,9 +36,9 @@ NaiveMotionPredict::NaiveMotionPredict() : nh_(), private_nh_("~")
   private_nh_.param&lt;int&gt;("num_prediction", num_prediction_, 10);
   private_nh_.param&lt;double&gt;("sensor_height_", sensor_height_, 2.0);
 
-  predicted_objects_pub_ = nh_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/prediction/objects", 1);
+  predicted_objects_pub_ = nh_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;("/prediction/motion_predictor/objects", 1);
   predicted_paths_pub_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("/prediction/motion_predictor/path_markers", 1);
-  detected_objects_sub_ = nh_.subscribe("/detection/lidar_tracker/objects", 1, &amp;NaiveMotionPredict::objectsCallback, this);
+  detected_objects_sub_ = nh_.subscribe("/detection/objects", 1, &amp;NaiveMotionPredict::objectsCallback, this);
 }
 
 NaiveMotionPredict::~NaiveMotionPredict()
@@ -206,6 +206,10 @@ void NaiveMotionPredict::objectsCallback(const autoware_msgs::DetectedObjectArra
     }
     predicted_lines.markers.push_back(predicted_line);
   }
+  for (auto &amp;object : output.objects)
+  {
+    object.valid = true;
+  }
   predicted_objects_pub_.publish(output);
   predicted_paths_pub_.publish(predicted_lines);
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\include\object_map_utils.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\include\object_map_utils.cpp" added_lines="3" deleted_lines="1">
				<diff>@@ -58,10 +58,12 @@ namespace object_map
 	                          const ros::Publisher &amp;in_publisher,
 	                          const std::string&amp; in_layer,
 	                          double in_min_value,
-	                          double in_max_value)
+	                          double in_max_value,
+	                          double in_height)
 	{
 		nav_msgs::OccupancyGrid message;
 		grid_map::GridMapRosConverter::toOccupancyGrid(in_gridmap, in_layer, in_min_value, in_max_value, message );
+		message.info.origin.position.z = in_height;
 		in_publisher.publish(message);
 	}
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\include\object_map_utils.hpp" new_path="ros\src\computing\perception\semantics\packages\object_map\include\object_map_utils.hpp" added_lines="60" deleted_lines="59">
				<diff>@@ -45,45 +45,46 @@
 
 namespace object_map
 {
-	/*!
-	 * Transforms a point using the given transformation
-	 * @param[in] in_point Point to transform
-	 * @param[in] in_tf Transformation to apply
-	 * @return Transformed point
-	 */
-	geometry_msgs::Point TransformPoint(const geometry_msgs::Point &amp;in_point, const tf::Transform &amp;in_tf);
+  /*!
+   * Transforms a point using the given transformation
+   * @param[in] in_point Point to transform
+   * @param[in] in_tf Transformation to apply
+   * @return Transformed point
+   */
+  geometry_msgs::Point TransformPoint(const geometry_msgs::Point &amp;in_point, const tf::Transform &amp;in_tf);
 
-	/*!
-	 * Publishes in_gridmap using the specified in_publisher
-	 * @param[in] in_gridmap GridMap object to publish
-	 * @param[in] in_publisher Valid Publisher object to use
-	 */
-	void PublishGridMap(const grid_map::GridMap &amp;in_gridmap, const ros::Publisher &amp;in_publisher);
+  /*!
+   * Publishes in_gridmap using the specified in_publisher
+   * @param[in] in_gridmap GridMap object to publish
+   * @param[in] in_publisher Valid Publisher object to use
+   */
+  void PublishGridMap(const grid_map::GridMap &amp;in_gridmap, const ros::Publisher &amp;in_publisher);
 
-	/*!
-	 * Convert and publishes a GridMap layer to a standard ROS OccupancyGrid
-	 * @param[in] in_gridmap GridMap object to extract the layer
-	 * @param[in] in_publisher ROS Publisher to use to publish the occupancy grid
-	 * @param[in] in_layer Name of the layer to convert
-	 * @param[in] in_min_value Minimum value in the layer
-	 * @param[in] in_max_value Maximum value in the layer
-	 */
-	void PublishOccupancyGrid(const grid_map::GridMap &amp;in_gridmap,
-	                     const ros::Publisher &amp;in_publisher,
-	                     const std::string&amp; in_layer,
-	                     double in_min_value,
-	                     double in_max_value);
+  /*!
+   * Convert and publishes a GridMap layer to a standard Ros OccupancyGrid
+   * @param[in] in_gridmap GridMap object to extract the layer
+   * @param[in] in_publisher ROS Publisher to use to publish the occupancy grid
+   * @param[in] in_layer Name of the layer to convert
+   * @param[in] in_min_value Minimum value in the layer
+   * @param[in] in_max_value Maximum value in the layer
+   */
+  void PublishOccupancyGrid(const grid_map::GridMap &amp;in_gridmap,
+                            const ros::Publisher &amp;in_publisher,
+                            const std::string &amp;in_layer,
+                            double in_min_value,
+                            double in_max_value,
+                            double in_height);
 
-	/*!
-	 * Obtains the registered transform in the tf tree
-	 * @param[in] in_target_frame Target frame to obtain the transformation
-	 * @param[in] in_source_frame Source Frame from which is desired to transform
-	 * @param[in] in_tf_listener Valid Object Listener
-	 * @return Current Transform from source to target, if available. Otherwise, it returns an identity transform.
-	 */
-	tf::StampedTransform FindTransform(const std::string &amp;in_target_frame,
-	                                   const std::string &amp;in_source_frame,
-	                                   const tf::TransformListener &amp;in_tf_listener);
+  /*!
+   * Obtains the registered transform in the tf tree
+   * @param[in] in_target_frame Target frame to obtain the transformation
+   * @param[in] in_source_frame Source Frame from which is desired to transform
+   * @param[in] in_tf_listener Valid Object Listener
+   * @return Current Transform from source to target, if available. Otherwise, it returns an identity transform.
+   */
+  tf::StampedTransform FindTransform(const std::string &amp;in_target_frame,
+                                     const std::string &amp;in_source_frame,
+                                     const tf::TransformListener &amp;in_tf_listener);
 
 	/*!
 		 * Loads regions defined as road inside the vector map, according to the field named "wayarea"
@@ -100,29 +101,29 @@ namespace object_map
 	std::vector&lt;geometry_msgs::Point&gt;
 	SearchAreaPoints(const vector_map::Area &amp;in_area, const vector_map::VectorMap &amp;in_vectormap);
 
-	/*!
-	 * Projects the in_area_points forming the road, stores the result in out_grid_map.
-	 * @param[out] out_grid_map GridMap object to add the road grid
-	 * @param[in] in_area_points Array of points containing the wayareas
-	 * @param[in] in_grid_layer_name Name to assign to the layer
-	 * @param[in] in_layer_background_value Empty state value
-	 * @param[in] in_fill_color Value to fill on wayareas
-	 * @param[in] in_layer_min_value Minimum value in the layer
-	 * @param[in] in_layer_max_value Maximum value in the later
-	 * @param[in] in_tf_target_frame Target frame to transform the wayarea points
-	 * @param[in] in_tf_source_frame Source frame, where the points are located
-	 * @param[in] in_tf_listener Valid listener to obtain the transformation
-	 */
-	void FillPolygonAreas(grid_map::GridMap &amp;out_grid_map,
-	                      const std::vector&lt;std::vector&lt;geometry_msgs::Point&gt;&gt; &amp;in_area_points,
-	                      const std::string &amp;in_grid_layer_name,
-	                      const int in_layer_background_value,
-	                      const int in_fill_color,
-	                      const int in_layer_min_value,
-	                      const int in_layer_max_value,
-	                      const std::string &amp;in_tf_target_frame,
-	                      const std::string &amp;in_tf_source_frame,
-	                      const tf::TransformListener &amp;in_tf_listener);
+  /*!
+   * Projects the in_area_points forming the road, stores the result in out_grid_map.
+   * @param[out] out_grid_map GridMap object to add the road grid
+   * @param[in] in_area_points Array of points containing the wayareas
+   * @param[in] in_grid_layer_name Name to assign to the layer
+   * @param[in] in_layer_background_value Empty state value
+   * @param[in] in_fill_color Value to fill on wayareas
+   * @param[in] in_layer_min_value Minimum value in the layer
+   * @param[in] in_layer_max_value Maximum value in the later
+   * @param[in] in_tf_target_frame Target frame to transform the wayarea points
+   * @param[in] in_tf_source_frame Source frame, where the points are located
+   * @param[in] in_tf_listener Valid listener to obtain the transformation
+   */
+  void FillPolygonAreas(grid_map::GridMap &amp;out_grid_map,
+                        const std::vector&lt;std::vector&lt;geometry_msgs::Point&gt;&gt; &amp;in_area_points,
+                        const std::string &amp;in_grid_layer_name,
+                        const int in_layer_background_value,
+                        const int in_fill_color,
+                        const int in_layer_min_value,
+                        const int in_layer_max_value,
+                        const std::string &amp;in_tf_target_frame,
+                        const std::string &amp;in_tf_source_frame,
+                        const tf::TransformListener &amp;in_tf_listener);
 
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid.cpp" added_lines="3" deleted_lines="2">
				<diff>@@ -49,7 +49,8 @@ namespace object_map
 		private_node_handle_.param&lt;double&gt;("grid_length_x", grid_length_x_, 80);
 		private_node_handle_.param&lt;double&gt;("grid_length_y", grid_length_y_, 30);
 		private_node_handle_.param&lt;double&gt;("grid_position_x", grid_position_x_, 20);
-		private_node_handle_.param&lt;double&gt;("grid_position_x", grid_position_y_, 0);
+		private_node_handle_.param&lt;double&gt;("grid_position_y", grid_position_y_, 0);
+		private_node_handle_.param&lt;double&gt;("grid_position_z", grid_position_z_, -2.f);
 
 		publisher_grid_map_ = node_handle_.advertise&lt;grid_map_msgs::GridMap&gt;("grid_map_wayarea", 1, true);
 		publisher_occupancy_ = node_handle_.advertise&lt;nav_msgs::OccupancyGrid&gt;("occupancy_wayarea", 1, true);
@@ -81,7 +82,7 @@ namespace object_map
 				                 grid_max_value_, sensor_frame_, map_frame_,
 				                 tf_listener_);
 				PublishGridMap(gridmap_, publisher_grid_map_);
-				PublishOccupancyGrid(gridmap_, publisher_occupancy_, grid_layer_name_, grid_min_value_, grid_max_value_);
+				PublishOccupancyGrid(gridmap_, publisher_occupancy_, grid_layer_name_, grid_min_value_, grid_max_value_, grid_position_z_);
 			}
 
 			// timer end
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid.h" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid.h" added_lines="1" deleted_lines="0">
				<diff>@@ -81,6 +81,7 @@ namespace object_map
 		double                  grid_length_y_;
 		double                  grid_position_x_;
 		double                  grid_position_y_;
+		double                  grid_position_z_;
 
 		tf::TransformListener   tf_listener_;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="04bf02741fbf421ffb7492fd20c97bdd2681180f" author="Yukihiro SAITO">
		<msg>change package name to detected_objects_visualizer</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\visualize_detected_objects\include\visualize_detected_objects.h" new_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\include\visualize_detected_objects.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\visualize_detected_objects\include\visualize_rects.h" new_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\include\visualize_rects.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\visualize_detected_objects\src\visualize_detected_objects.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\src\visualize_detected_objects.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\visualize_detected_objects\src\visualize_detected_objects_main.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\src\visualize_detected_objects_main.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\visualize_detected_objects\src\visualize_rects.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\src\visualize_rects.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\visualize_detected_objects\src\visualize_rects_main.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\src\visualize_rects_main.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="837aace05dee79dd48fa82f988019bf3d0eb65fe" author="YamatoAndo">
		<msg>[Fix] Disable forced termination when it can not write log data in ndt_matching (#1824)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="35" deleted_lines="23">
				<diff>@@ -42,6 +42,8 @@
 #include &lt;sstream&gt;
 #include &lt;string&gt;
 
+#include &lt;boost/filesystem.hpp&gt;
+
 #include &lt;nav_msgs/Odometry.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/Imu.h&gt;
@@ -227,6 +229,7 @@ static bool _use_local_transform = false;
 static bool _use_imu = false;
 static bool _use_odom = false;
 static bool _imu_upside_down = false;
+static bool _output_log_data = false;
 
 static std::string _imu_topic = "/imu_raw";
 
@@ -1385,25 +1388,28 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     ndt_reliability_pub.publish(ndt_reliability);
 
     // Write log
-    if (!ofs)
+    if(_output_log_data)
     {
-      std::cerr &lt;&lt; "Could not open " &lt;&lt; filename &lt;&lt; "." &lt;&lt; std::endl;
-      exit(1);
+      if (!ofs)
+      {
+        std::cerr &lt;&lt; "Could not open " &lt;&lt; filename &lt;&lt; "." &lt;&lt; std::endl;
+      }
+      else
+      {
+        ofs &lt;&lt; input-&gt;header.seq &lt;&lt; "," &lt;&lt; scan_points_num &lt;&lt; "," &lt;&lt; step_size &lt;&lt; "," &lt;&lt; trans_eps &lt;&lt; "," &lt;&lt; std::fixed
+            &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; "," &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; ","
+            &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; "," &lt;&lt; current_pose.roll &lt;&lt; "," &lt;&lt; current_pose.pitch
+            &lt;&lt; "," &lt;&lt; current_pose.yaw &lt;&lt; "," &lt;&lt; predict_pose.x &lt;&lt; "," &lt;&lt; predict_pose.y &lt;&lt; "," &lt;&lt; predict_pose.z &lt;&lt; ","
+            &lt;&lt; predict_pose.roll &lt;&lt; "," &lt;&lt; predict_pose.pitch &lt;&lt; "," &lt;&lt; predict_pose.yaw &lt;&lt; ","
+            &lt;&lt; current_pose.x - predict_pose.x &lt;&lt; "," &lt;&lt; current_pose.y - predict_pose.y &lt;&lt; ","
+            &lt;&lt; current_pose.z - predict_pose.z &lt;&lt; "," &lt;&lt; current_pose.roll - predict_pose.roll &lt;&lt; ","
+            &lt;&lt; current_pose.pitch - predict_pose.pitch &lt;&lt; "," &lt;&lt; current_pose.yaw - predict_pose.yaw &lt;&lt; ","
+            &lt;&lt; predict_pose_error &lt;&lt; "," &lt;&lt; iteration &lt;&lt; "," &lt;&lt; fitness_score &lt;&lt; "," &lt;&lt; trans_probability &lt;&lt; ","
+            &lt;&lt; ndt_reliability.data &lt;&lt; "," &lt;&lt; current_velocity &lt;&lt; "," &lt;&lt; current_velocity_smooth &lt;&lt; "," &lt;&lt; current_accel
+            &lt;&lt; "," &lt;&lt; angular_velocity &lt;&lt; "," &lt;&lt; time_ndt_matching.data &lt;&lt; "," &lt;&lt; align_time &lt;&lt; "," &lt;&lt; getFitnessScore_time
+            &lt;&lt; std::endl;
+      }
     }
-    static ros::Time start_time = input-&gt;header.stamp;
-
-    ofs &lt;&lt; input-&gt;header.seq &lt;&lt; "," &lt;&lt; scan_points_num &lt;&lt; "," &lt;&lt; step_size &lt;&lt; "," &lt;&lt; trans_eps &lt;&lt; "," &lt;&lt; std::fixed
-        &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; "," &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; ","
-        &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; "," &lt;&lt; current_pose.roll &lt;&lt; "," &lt;&lt; current_pose.pitch
-        &lt;&lt; "," &lt;&lt; current_pose.yaw &lt;&lt; "," &lt;&lt; predict_pose.x &lt;&lt; "," &lt;&lt; predict_pose.y &lt;&lt; "," &lt;&lt; predict_pose.z &lt;&lt; ","
-        &lt;&lt; predict_pose.roll &lt;&lt; "," &lt;&lt; predict_pose.pitch &lt;&lt; "," &lt;&lt; predict_pose.yaw &lt;&lt; ","
-        &lt;&lt; current_pose.x - predict_pose.x &lt;&lt; "," &lt;&lt; current_pose.y - predict_pose.y &lt;&lt; ","
-        &lt;&lt; current_pose.z - predict_pose.z &lt;&lt; "," &lt;&lt; current_pose.roll - predict_pose.roll &lt;&lt; ","
-        &lt;&lt; current_pose.pitch - predict_pose.pitch &lt;&lt; "," &lt;&lt; current_pose.yaw - predict_pose.yaw &lt;&lt; ","
-        &lt;&lt; predict_pose_error &lt;&lt; "," &lt;&lt; iteration &lt;&lt; "," &lt;&lt; fitness_score &lt;&lt; "," &lt;&lt; trans_probability &lt;&lt; ","
-        &lt;&lt; ndt_reliability.data &lt;&lt; "," &lt;&lt; current_velocity &lt;&lt; "," &lt;&lt; current_velocity_smooth &lt;&lt; "," &lt;&lt; current_accel
-        &lt;&lt; "," &lt;&lt; angular_velocity &lt;&lt; "," &lt;&lt; time_ndt_matching.data &lt;&lt; "," &lt;&lt; align_time &lt;&lt; "," &lt;&lt; getFitnessScore_time
-        &lt;&lt; std::endl;
 
     std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
     std::cout &lt;&lt; "Sequence: " &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
@@ -1494,12 +1500,18 @@ int main(int argc, char** argv)
   ros::NodeHandle private_nh("~");
 
   // Set log file name.
-  char buffer[80];
-  std::time_t now = std::time(NULL);
-  std::tm* pnow = std::localtime(&amp;now);
-  std::strftime(buffer, 80, "%Y%m%d_%H%M%S", pnow);
-  filename = "ndt_matching_" + std::string(buffer) + ".csv";
-  ofs.open(filename.c_str(), std::ios::app);
+  private_nh.getParam("output_log_data", _output_log_data);
+  if(_output_log_data)
+  {
+    char buffer[80];
+    std::time_t now = std::time(NULL);
+    std::tm* pnow = std::localtime(&amp;now);
+    std::strftime(buffer, 80, "%Y%m%d_%H%M%S", pnow);
+    std::string directory_name = "/tmp/Autoware/log/ndt_matching";
+    filename = directory_name + "/" + std::string(buffer) + ".csv";
+    boost::filesystem::create_directories(boost::filesystem::path(directory_name));
+    ofs.open(filename.c_str(), std::ios::app);
+  }
 
   // Geting parameters
   int method_type_tmp = 0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c4a3ecc174f066d84d2f45991074d978d0761c42" author="Esteve Fernandez">
		<msg>Use colcon as the build tool (#1704)

* Switch to colcon as the build tool instead of catkin

* Added cmake-target

* Added note about the second colcon call

* Added warning about catkin* scripts being deprecated

* Fix COLCON_OPTS

* Added install targets

* Update Docker image tags

* Message packages fixes

* Fix missing dependency</msg>
		<modified_files>
			<file old_path="ros\cross_toolchain.cmake" new_path="ros\cross_toolchain.cmake" added_lines="1" deleted_lines="1">
				<diff>@@ -3,7 +3,7 @@ set(CMAKE_SYSTEM_VERSION 1)
 set(CMAKE_SYSTEM_PROCESSOR aarch64)
 set(CMAKE_CROSSCOMPILING ON)
 set(CMAKE_SYSROOT $ENV{AUTOWARE_SYSROOT})
-set(CMAKE_PREFIX_PATH "${CMAKE_SYSROOT}/opt/ros/kinetic")
+#set(CMAKE_PREFIX_PATH "${CMAKE_SYSROOT}/opt/ros/kinetic")
 
 # specify the cross compiler
 set(CMAKE_C_COMPILER "/usr/bin/${CMAKE_SYSTEM_PROCESSOR}-linux-gnu-gcc")
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="765397a42136c6e3cf044403af3a5287995cd37a" author="Esteve Fernandez">
		<msg>Switch to Apache 2 license (develop branch) (#1741)

* Switch to Apache 2

* Replace BSD-3 license header with Apache 2 and reassign copyright to the
Autoware Foundation.

* Update license on Python files

* Update copyright years

* Add #ifndef/define _POINTS_IMAGE_H_

* Updated license comment</msg>
		<modified_files>
			<file old_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.cpp" new_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "pacmod_interface.h"
 
</diff>
			</file>
			<file old_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.h" new_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef PACMOD_INTERFACE_H
 #define PACMOD_INTERFACE_H
</diff>
			</file>
			<file old_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface_node.cpp" new_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface_node.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 // ROS Includes
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\actuation\vehicles\packages\ymc\include\can_utils\ymc_can.h" new_path="ros\src\actuation\vehicles\packages\ymc\include\can_utils\ymc_can.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef YMC_CAN_H
 #define YMC_CAN_H
</diff>
			</file>
			<file old_path="ros\src\actuation\vehicles\packages\ymc\node\g30esli_interface\g30esli_interface.cpp" new_path="ros\src\actuation\vehicles\packages\ymc\node\g30esli_interface\g30esli_interface.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;cmath&gt;
 #include &lt;thread&gt;
</diff>
			</file>
			<file old_path="ros\src\actuation\vehicles\packages\ymc\node\g30esli_interface\g30esli_interface_util.h" new_path="ros\src\actuation\vehicles\packages\ymc\node\g30esli_interface\g30esli_interface_util.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef G30ESLI_INTERFACE_UTIL_H
 #define G30ESLI_INTERFACE_UTIL_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\pixel_cloud_fusion\include\pixel_cloud_fusion\pixel_cloud_fusion.h" new_path="ros\src\computing\perception\detection\fusion_tools\packages\pixel_cloud_fusion\include\pixel_cloud_fusion\pixel_cloud_fusion.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\pixel_cloud_fusion\src\pixel_cloud_fusion.cpp" new_path="ros\src\computing\perception\detection\fusion_tools\packages\pixel_cloud_fusion\src\pixel_cloud_fusion.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\pixel_cloud_fusion\src\pixel_cloud_fusion_node.cpp" new_path="ros\src\computing\perception\detection\fusion_tools\packages\pixel_cloud_fusion\src\pixel_cloud_fusion_node.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\include\range_vision_fusion\range_vision_fusion.h" new_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\include\range_vision_fusion\range_vision_fusion.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\src\range_vision_fusion.cpp" new_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\src\range_vision_fusion.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\src\range_vision_fusion_node.cpp" new_path="ros\src\computing\perception\detection\fusion_tools\packages\range_vision_fusion\src\range_vision_fusion_node.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_naive_l_shape_detect\include\lidar_naive_l_shape_detect.h" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_naive_l_shape_detect\include\lidar_naive_l_shape_detect.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #ifndef OBJECT_TRACKING_BOX_FITTING_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_naive_l_shape_detect\nodes\lidar_naive_l_shape_detect\lidar_naive_l_shape_detect.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_naive_l_shape_detect\nodes\lidar_naive_l_shape_detect\lidar_naive_l_shape_detect.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_naive_l_shape_detect\nodes\lidar_naive_l_shape_detect\lidar_naive_l_shape_detect_node.cpp" new_path="ros\src\computing\perception\detection\lidar_detector\packages\lidar_naive_l_shape_detect\nodes\lidar_naive_l_shape_detect\lidar_naive_l_shape_detect_node.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include "lidar_naive_l_shape_detect.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\libs\fusion\include\fusion\fusion_func.h" new_path="ros\src\computing\perception\detection\lidar_tracker\libs\fusion\include\fusion\fusion_func.h" added_lines="15" deleted_lines="29">
				<diff>@@ -1,32 +1,18 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+/*
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef INCLUDED_MFunctions_
 #define INCLUDED_MFunctions_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\libs\fusion\src\fusion.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\libs\fusion\src\fusion.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include &lt;opencv/cv.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\imm_ukf_pda.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\imm_ukf_pda.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #ifndef OBJECT_TRACKING_IMM_UKF_JPDAF_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\ukf.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\include\ukf.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #ifndef OBJECT_TRACKING_UKF_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda_main.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\imm_ukf_pda_main.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include "imm_ukf_pda.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\ukf.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_imm_ukf_pda_track\nodes\imm_ukf_pda\ukf.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,38 +1,24 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include "ukf.h"
 
 /**
 * Initializes Unscented Kalman filter
-*/
+ */
 UKF::UKF()
   : num_state_(5)
   , num_lidar_state_(2)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\PolygonGenerator.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\PolygonGenerator.h" added_lines="10" deleted_lines="30">
				<diff>@@ -1,37 +1,17 @@
-
-/// \file  PolygonGenerator.h
-/// \brief Generate convex hull from point cloud cluster of detected object
-/// \author Hatem Darweesh
-/// \date Nov 2, 2016
-
 /*
- *  Copyright (c) 2016, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ * Copyright 2016-2019 Autoware Foundation. All rights reserved.
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #ifndef OP_POLYGONGENERATOR_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\SimpleTracker.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\SimpleTracker.h" added_lines="10" deleted_lines="30">
				<diff>@@ -1,37 +1,17 @@
-
-/// \file SimpleTracker.h
-/// \brief Kalman Filter based object tracker
-/// \author Hatem Darweesh
-/// \date Aug 11, 2016
-
 /*
- *  Copyright (c) 2016, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ * Copyright 2016-2019 Autoware Foundation. All rights reserved.
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #ifndef SimpleTracker_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\lidar_kf_contour_track_core.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\include\lidar_kf_contour_track_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef KF_CONTOUR_TRACKER_CORE
 #define KF_CONTOUR_TRACKER_CORE
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\PolygonGenerator.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\PolygonGenerator.cpp" added_lines="10" deleted_lines="30">
				<diff>@@ -1,37 +1,17 @@
-
-/// \file  PolygonGenerator.cpp
-/// \brief Generate convex hull from point cloud cluster of detected object
-/// \author Hatem Darweesh
-/// \date Nov 2, 2016
-
 /*
- *  Copyright (c) 2016, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ * Copyright 2016-2019 Autoware Foundation. All rights reserved.
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include "PolygonGenerator.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\SimpleTracker.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\SimpleTracker.cpp" added_lines="10" deleted_lines="30">
				<diff>@@ -1,37 +1,17 @@
-
-/// \file SimpleTracker.cpp
-/// \brief Kalman Filter based object tracker
-/// \author Hatem Darweesh
-/// \date Aug 11, 2016
-
 /*
- *  Copyright (c) 2016, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ * Copyright 2016-2019 Autoware Foundation. All rights reserved.
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include "SimpleTracker.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track.cpp" added_lines="11" deleted_lines="29">
				<diff>@@ -1,36 +1,18 @@
 /*
- *  Copyright (c) 2016, Nagoya University
- *  All rights reserved.
+ * Copyright 2016-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice,
- * this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "lidar_kf_contour_track_core.h"
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track_core.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\lidar_kf_contour_track\nodes\lidar_kf_contour_track\lidar_kf_contour_track_core.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include "lidar_kf_contour_track_core.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\include\axial_move.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\include\axial_move.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef AXIALMOVE
 #define AXIALMOVE
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\include\cal_obj_loc.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\include\cal_obj_loc.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #ifndef CALSELFLOC
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\include\calcoordinates.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\include\calcoordinates.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef CALCOORDINATES
 #define CALCOORDINATES
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\include\structure.h" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\include\structure.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef STRUCTURE_H
 #define STRUCTURE_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\nodes\obj_reproj\obj_reproj.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\obj_reproj\nodes\obj_reproj\obj_reproj.cpp" added_lines="10" deleted_lines="28">
				<diff>@@ -1,35 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice,
- * this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lidar_tracker\packages\range_fusion\nodes\range_fusion\range_fusion.cpp" new_path="ros\src\computing\perception\detection\lidar_tracker\packages\range_fusion\nodes\range_fusion\range_fusion.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Header.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\common\common.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\common\common.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "common.hpp"
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\GPU_init.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\GPU_init.cpp" added_lines="13" deleted_lines="27">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;cstdio&gt;
 #include &lt;cmath&gt;
@@ -69,7 +55,7 @@ CUdeviceptr *PIDX_array_dev, *def_array_dev, *DID_4_array_dev, *numpart_dev,*M_d
 
 /* init_cuda
    initialization device to use CUDA function
-*/
+ */
 void dpm_ttic_gpu_init_cuda(void)
 {
     //const char file_name[43] = "./gccDebug/GPU_function.cubin";
@@ -368,7 +354,7 @@ void dpm_ttic_gpu_init_cuda_with_cubin(const char *cubin_path)
 /* clean_cuda
 
    cleaning up after using GPU
-*/
+ */
 /*****************************************************************/
 void dpm_ttic_gpu_clean_cuda(void)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\cuda_util.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\cuda_util.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 const char *cuda_response_to_string(unsigned int res)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\cuda_util.hpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\cuda_util.hpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef _CUDA_UTIL_H_
 #define _CUDA_UTIL_H_
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\dt_GPU.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\dt_GPU.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;cstdio&gt;
 #include &lt;cstdlib&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\fconvsMT.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\fconvsMT.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 //C++ library (thread-functions are only supported by windows)
 #include &lt;cstdio&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\for_use_GPU.h" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\for_use_GPU.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef _CUDA_H
 #define _CUDA_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\switch_float.h" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\switch_float.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /* typedef to switch float and double */
 #define USE_FLOAT_AS_DECIMAL
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\switch_release.h" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\gpu\switch_release.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef _RELEASE_H
 #define _RELEASE_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\util\capability_version_checker.cpp" new_path="ros\src\computing\perception\detection\vision_detector\libs\dpm_ttic\util\capability_version_checker.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;iostream&gt;
 #include &lt;vector&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect_node.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_darknet_detect\src\vision_darknet_detect_node.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\nodes\vision_dpm_ttic_detect\vision_dpm_ttic_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_dpm_ttic_detect\nodes\vision_dpm_ttic_detect\vision_dpm_ttic_detect.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;cstdio&gt;
 #include &lt;string&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_lane_detect\nodes\vision_lane_detect\utils.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_lane_detect\nodes\vision_lane_detect\utils.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #pragma once
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_lane_detect\nodes\vision_lane_detect\vision_lane_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_lane_detect\nodes\vision_lane_detect\vision_lane_detect.cpp" added_lines="12" deleted_lines="26">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*
   lane detection program using OpenCV
@@ -599,4 +585,4 @@ int main(int argc, char *argv[])
   c-basic-offset: 2
   indent-tabs-mode: nil
   End:
-*/
+ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 #include "vision_ssd_detect.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect_node.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 #include &lt;string&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\libs\kf\src\kf_lib.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\libs\kf\src\kf_lib.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 //ROS STUFF
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_dummy_track\nodes\vision_dummy_track\vision_dummy_track.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_dummy_track\nodes\vision_dummy_track\vision_dummy_track.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;autoware_msgs/ImageObjTracked.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_kf_track\nodes\vision_kf_track\vision_kf_track.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_kf_track\nodes\vision_kf_track\vision_kf_track.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;string&gt;
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_klt_track\nodes\vision_klt_track\vision_klt_track.cpp" new_path="ros\src\computing\perception\detection\vision_tracker\packages\vision_klt_track\nodes\vision_klt_track\vision_klt_track.cpp" added_lines="11" deleted_lines="29">
				<diff>@@ -1,36 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice,
- * this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 // ROS STUFF
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\include\visualize_detected_objects.h" new_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\include\visualize_detected_objects.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Nagoya University. All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\include\visualize_rects.h" new_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\include\visualize_rects.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Nagoya University. All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\src\visualize_detected_objects.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\src\visualize_detected_objects.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Nagoya University. All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\src\visualize_detected_objects_main.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\src\visualize_detected_objects_main.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Nagoya University. All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\src\visualize_rects.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\src\visualize_rects.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Nagoya University. All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\src\visualize_rects_main.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\detected_objects_visualizer\src\visualize_rects_main.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Nagoya University. All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\image_d_viewer\image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\image_d_viewer\image_d_viewer.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\image_viewer\image_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\image_viewer\image_viewer.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *	list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *	this list of conditions and the following disclaimer in the documentation
- *	and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *	contributors may be used to endorse or promote products derived from
- *	this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;string&gt;
 #include &lt;vector&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\points_image_viewer\points_image_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\points_image_viewer\points_image_viewer.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\scan_image_d_viewer\scan_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\scan_image_d_viewer\scan_image_d_viewer.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 //openCV library
 #include &lt;opencv/cv.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\scan_image_viewer\scan_image_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\scan_image_viewer\scan_image_viewer.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 //openCV library
 #include &lt;opencv/cv.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;opencv2/opencv.hpp&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\vscan_image_viewer\vscan_image_viewer.cpp" new_path="ros\src\computing\perception\detection\visualizers\packages\viewers\nodes\vscan_image_viewer\vscan_image_viewer.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\gnss\src\geo_pos_conv.cpp" new_path="ros\src\computing\perception\localization\lib\gnss\src\geo_pos_conv.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;gnss/geo_pos_conv.hpp&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_core.cpp" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_core.cpp" added_lines="11" deleted_lines="26">
				<diff>@@ -1,33 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
-
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "can_odometry_core.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_core.h" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef CAN_ODOMETRY_CORE_H
 #define CAN_ODOMETRY_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_node.cpp" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_odometry\can_odometry_node.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_status_translator\can_status_translator_core.cpp" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_status_translator\can_status_translator_core.cpp" added_lines="11" deleted_lines="26">
				<diff>@@ -1,33 +1,18 @@
 /*
- *  Copyright (c) 2018, TierIV Inc.
- *  Copyright (c) 2015-2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2018 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "can_status_translator_core.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_status_translator\can_status_translator_core.h" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_status_translator\can_status_translator_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef CAN_STATUS_TRANSLATOR_CORE_H
 #define CAN_STATUS_TRANSLATOR_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_status_translator\can_status_translator_node.cpp" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_status_translator\can_status_translator_node.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\fix2tfpose\fix2tfpose.cpp" new_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\fix2tfpose\fix2tfpose.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;geometry_msgs/PointStamped.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_core.cpp" new_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_core.cpp" added_lines="11" deleted_lines="26">
				<diff>@@ -1,33 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
-
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "nmea2tfpose_core.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_core.h" new_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef NMEA2TFPOSE_CORE_H
 #define NMEA2TFPOSE_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_node.cpp" new_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_node.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\approximate_ndt_mapping\approximate_ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\approximate_ndt_mapping\approximate_ndt_mapping.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*
  Localization and mapping program using Normal Distributions Transform
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\icp_matching\icp_matching.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\icp_matching\icp_matching.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*
  Localization program using Normal Distributions Transform
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\lazy_ndt_mapping\lazy_ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\lazy_ndt_mapping\lazy_ndt_mapping.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*
  Localization and mapping program using Normal Distributions Transform
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*
  Localization and mapping program using Normal Distributions Transform
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="12" deleted_lines="26">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*
  Localization program using Normal Distributions Transform
@@ -160,7 +146,7 @@ static geometry_msgs::PoseStamped ndt_pose_msg;
 /*
 static ros::Publisher current_pose_pub;
 static geometry_msgs::PoseStamped current_pose_msg;
-*/
+ */
 
 static ros::Publisher localizer_pose_pub;
 static geometry_msgs::PoseStamped localizer_pose_msg;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
   ********************
     Abraham Monrroy
     based on Alexander Carballo's idea for Tsukuba Challenge for NDT monitoring.
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.h" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor_node.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\ndt_matching_monitor\ndt_matching_monitor_node.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\queue_counter\queue_counter.cpp" new_path="ros\src\computing\perception\localization\packages\lidar_localizer\nodes\queue_counter\queue_counter.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*
  Message counter in subscriber's queue.
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_mapping\orb_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_mapping\orb_mapping.cpp" added_lines="13" deleted_lines="4">
				<diff>@@ -1,9 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  XXX: Licensing has not been cleared yet.
-*/
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;iostream&gt;
 #include &lt;string&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_matching\orb_matching.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_matching\orb_matching.cpp" added_lines="12" deleted_lines="3">
				<diff>@@ -1,8 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  XXX: Licensing has not been cleared yet.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_matching\orb_matching_pf.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_matching\orb_matching_pf.cpp" added_lines="12" deleted_lines="3">
				<diff>@@ -1,8 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  XXX: Licensing has not been cleared yet.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\include\naive_motion_predict.h" new_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\include\naive_motion_predict.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #ifndef NAIVE_MOTION_PREDICT_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\nodes\naive_motion_predict\naive_motion_predict.cpp" new_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\nodes\naive_motion_predict\naive_motion_predict.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include "naive_motion_predict.h"
@@ -92,7 +78,7 @@ void NaiveMotionPredict::makePrediction(const autoware_msgs::DetectedObject&amp; obj
 This package is a template package for more sopisticated prediction packages.
 Feel free to change/modify generatePredictedObject function
 and send pull request to Autoware
-*/
+ */
 
 autoware_msgs::DetectedObject NaiveMotionPredict::generatePredictedObject(const autoware_msgs::DetectedObject&amp; object)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\nodes\naive_motion_predict\naive_motion_predict_node.cpp" new_path="ros\src\computing\perception\prediction\motion_predictor\packages\naive_motion_predict\nodes\naive_motion_predict\naive_motion_predict_node.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include "naive_motion_predict.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\include\object_map_utils.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\include\object_map_utils.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *
  */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\include\object_map_utils.hpp" new_path="ros\src\computing\perception\semantics\packages\object_map\include\object_map_utils.hpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *
  */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\grid_map_filter\grid_map_filter.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\grid_map_filter\grid_map_filter.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************/
 
 #include "grid_map_filter.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\grid_map_filter\grid_map_filter.h" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\grid_map_filter\grid_map_filter.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************/
 #ifndef GRID_MAP_FILTER_H
 #define GRID_MAP_FILTER_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\grid_map_filter\grid_map_filter_node.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\grid_map_filter\grid_map_filter_node.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  */
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\laserscan2costmap\laserscan2costmap.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\laserscan2costmap\laserscan2costmap.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;iostream&gt;
 #include &lt;vector&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\points2costmap\points2costmap.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\points2costmap\points2costmap.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************/
 
 #include "wayarea2grid.h"
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid.h" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  */
 #ifndef WAYAREA_TO_GRID_H
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid_node.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\wayarea2grid\wayarea2grid_node.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  */
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\include\road_occupancy_processor.h" new_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\include\road_occupancy_processor.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\src\road_occupancy_processor.cpp" new_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\src\road_occupancy_processor.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\src\road_occupancy_processor_node.cpp" new_path="ros\src\computing\perception\semantics\packages\road_occupancy_processor\src\road_occupancy_processor_node.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\include\lane_planner\lane_planner_vmap.hpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\include\lane_planner\lane_planner_vmap.hpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef LANE_PLANNER_VMAP_HPP
 #define LANE_PLANNER_VMAP_HPP
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\lib\lane_planner\lane_planner_vmap.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\lib\lane_planner\lane_planner_vmap.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;fstream&gt;
 #include &lt;tuple&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_navi\lane_navi.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_navi\lane_navi.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;sstream&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 // #define DEBUG
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.cpp" added_lines="11" deleted_lines="26">
				<diff>@@ -1,33 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
-
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "hermite_curve.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.h" added_lines="11" deleted_lines="26">
				<diff>@@ -1,33 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
-
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef HERMITE_CURVE_H
 #define HERMITE_CURVE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="11" deleted_lines="26">
				<diff>@@ -1,33 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
-
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "lane_select_core.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="11" deleted_lines="26">
				<diff>@@ -1,33 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
-
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef LANE_SELECT_CORE_H
 #define LANE_SELECT_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_node.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_node.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_stop\lane_stop.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_stop\lane_stop.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/console.h&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\include\op_global_planner_core.h" new_path="ros\src\computing\planning\mission\packages\op_global_planner\include\op_global_planner_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OP_GLOBAL_PLANNER
 #define OP_GLOBAL_PLANNER
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner.cpp" new_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /**
  * @brief global Planner represents the Global planning Module, to generate global plan (reference path) the nodes takes start position, goal position and return sequence of waypoints.
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\op_global_planner\nodes\op_global_planner_core.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include "op_global_planner_core.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\way_planner_core.h" new_path="ros\src\computing\planning\mission\packages\way_planner\include\way_planner_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2016, Nagoya University
- *  All rights reserved.
+ * Copyright 2016-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef WAYPLANNERCORE_H_
 #define WAYPLANNERCORE_H_
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2016, Nagoya University
- *  All rights reserved.
+ * Copyright 2016-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /**
  * @brief Way Planner represents the Global planning Module, to generate global plan (reference path) the nodes takes start position, goal position and return sequence of waypoints.
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2016, Nagoya University
- *  All rights reserved.
+ * Copyright 2016-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "way_planner_core.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_search.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_search.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "astar_search.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_search.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_search.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef ASTAR_NAVI_NODE_H
 #define ASTAR_NAVI_NODE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_util.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_util.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "astar_util.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_util.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\astar_util.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef ASTAR_UTIL_H
 #define ASTAR_UTIL_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_avoid.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_avoid.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "astar_search.h"
 #include "search_info_ros.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "search_info_ros.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\search_info_ros.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef SEARCH_INFO_ROS_H
 #define SEARCH_INFO_ROS_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include "velocity_set_info.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #ifndef VELOCITY_SET_INFO_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include "velocity_set_path.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #ifndef VELOCITY_SET_PATH_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2016, Nagoya University
- *  All rights reserved.
+ * Copyright 2016-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef dp_planner_CORE_H
 #define dp_planner_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2016, Nagoya University
- *  All rights reserved.
+ * Copyright 2016-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 #include "dp_planner_core.h"
 #include &lt;iostream&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\ff_waypoint_follower_core.h" new_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\ff_waypoint_follower_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef ff_waypoint_follower_CORE_H
 #define ff_waypoint_follower_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower.cpp" new_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 #include "ff_waypoint_follower_core.h"
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower_core.cpp" new_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower_core.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 #include "ff_waypoint_follower_core.h"
 #include "autoware_msgs/LaneArray.h"
 #include &lt;visualization_msgs/MarkerArray.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_velocity_set\lattice_velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_velocity_set\lattice_velocity_set.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\path_select\path_select.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\path_select\path_select.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_behavior_selector_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_behavior_selector_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OP_BEHAVIOR_SELECTOR_CORE
 #define OP_BEHAVIOR_SELECTOR_CORE
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_motion_predictor_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_motion_predictor_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OP_MOTION_PREDICTION
 #define OP_MOTION_PREDICTION
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_trajectory_evaluator_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_trajectory_evaluator_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OP_TRAJECTORY_EVALUATOR_CORE
 #define OP_TRAJECTORY_EVALUATOR_CORE
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_trajectory_generator_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_trajectory_generator_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OP_TRAJECTORY_GENERATOR_CORE
 #define OP_TRAJECTORY_GENERATOR_CORE
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_behavior_selector\op_behavior_selector_core.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "op_behavior_selector_core.h"
 #include "op_ros_helpers/op_ROSHelpers.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_common_params\op_common_params.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_common_params\op_common_params.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include "../include/op_motion_predictor_core.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_motion_predictor\op_motion_predictor_core.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "op_motion_predictor_core.h"
 #include "op_planner/MappingHelpers.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_evaluator\op_trajectory_evaluator.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_evaluator\op_trajectory_evaluator.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_evaluator\op_trajectory_evaluator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_evaluator\op_trajectory_evaluator_core.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "op_trajectory_evaluator_core.h"
 #include "op_ros_helpers/op_ROSHelpers.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "op_trajectory_generator_core.h"
 #include "op_ros_helpers/op_ROSHelpers.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_car_simulator_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_car_simulator_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OP_CAR_SIMULATOR
 #define OP_CAR_SIMULATOR
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_perception_simulator_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_perception_simulator_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OP_PERCEPTION_SIMULATOR
 #define OP_PERCEPTION_SIMULATOR
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_signs_simulator_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\include\op_signs_simulator_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OP_SIGNS_SIMULATOR
 #define OP_SIGNS_SIMULATOR
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 #include "op_car_simulator_core.h"
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_car_simulator\op_car_simulator_core.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "op_car_simulator_core.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_perception_simulator\op_perception_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_perception_simulator\op_perception_simulator.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "op_perception_simulator_core.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_perception_simulator\op_perception_simulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_perception_simulator\op_perception_simulator_core.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "op_perception_simulator_core.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_signs_simulator\op_signs_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_signs_simulator\op_signs_simulator.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "op_signs_simulator_core.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_signs_simulator\op_signs_simulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulation_package\nodes\op_signs_simulator\op_signs_simulator_core.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "op_signs_simulator_core.h"
 #include "op_utility/UtilityH.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\BagTopicPlayer.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\BagTopicPlayer.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef BAGTOPICPLAYER_H_
 #define BAGTOPICPLAYER_H_
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\DrawObjBase.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\DrawObjBase.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef DRAWOBJBASE_TESTING
 #define DRAWOBJBASE_TESTING
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\DrawingHelpers.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\DrawingHelpers.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef DRAWINGHELPERS_TEST
 #define DRAWINGHELPERS_TEST
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\MainWindowWrapper.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\MainWindowWrapper.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef WINDOWWRAPPER_TEST
 #define WINDOWWRAPPER_TEST
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_bag_player_core.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_bag_player_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OP_TESTING_CORE
 #define OP_TESTING_CORE
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_data_logger_core.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_data_logger_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OP_DATALOGGER
 #define OP_DATALOGGER
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_map_converter_core.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_map_converter_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OP_MAP_CONVERTER
 #define OP_MAP_CONVERTER
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_pose2tf_core.h" new_path="ros\src\computing\planning\motion\packages\op_utilities\include\op_pose2tf_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef OP_POSETF
 #define OP_POSETF
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\BagTopicPlayer.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\BagTopicPlayer.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "BagTopicPlayer.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\DrawObjBase.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\DrawObjBase.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "DrawObjBase.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\DrawingHelpers.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\DrawingHelpers.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "DrawingHelpers.h"
 #include &lt;stdarg.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\MainWindowWrapper.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\MainWindowWrapper.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "MainWindowWrapper.h"
 #include "DrawingHelpers.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\op_bag_player.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\op_bag_player.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include "op_bag_player_core.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\op_bag_player_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_bag_player\op_bag_player_core.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 #include "op_bag_player_core.h"
 #include &lt;sstream&gt;
 #include &lt;algorithm&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_data_logger\op_data_logger.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_data_logger\op_data_logger.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "op_data_logger_core.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_data_logger\op_data_logger_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_data_logger\op_data_logger_core.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "op_data_logger_core.h"
 #include "op_utility/UtilityH.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_pose2tf\op_pose2tf.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_pose2tf\op_pose2tf.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 
 #include "op_pose2tf_core.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_pose2tf\op_pose2tf_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_utilities\nodes\op_pose2tf\op_pose2tf_core.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "op_pose2tf_core.h"
 #include "math.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\include\waypoint_follower\libwaypoint_follower.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\include\waypoint_follower\libwaypoint_follower.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef _LIB_WAYPOINT_FOLLOWER_H_
 #define _LIB_WAYPOINT_FOLLOWER_H_
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\lib\libwaypoint_follower.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\lib\libwaypoint_follower.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include "waypoint_follower/libwaypoint_follower.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "pure_pursuit.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef PURE_PURSUIT_H
 #define PURE_PURSUIT_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "pure_pursuit_core.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef PURE_PURSUIT_CORE_H
 #define PURE_PURSUIT_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_node.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_node.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 // ROS Includes
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_viz.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_viz.cpp" added_lines="12" deleted_lines="26">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "pure_pursuit_viz.h"
 
@@ -289,5 +275,5 @@ void displayLinePoint(double a, double b, double c, geometry_msgs::Point target,
   marker.frame_locked = true;
   _line_point_pub.publish(marker);
 }
-*/
+ */
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_viz.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_viz.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef PURE_PURSUIT_VIZ_H
 #define PURE_PURSUIT_VIZ_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_filter\twist_filter.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_filter\twist_filter.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/String.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_clicker\waypoint_clicker.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_clicker\waypoint_clicker.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;geometry_msgs/PointStamped.h&gt;
 #include &lt;ros/console.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="11" deleted_lines="26">
				<diff>@@ -1,33 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
-
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "waypoint_loader_core.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
-// *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef WAYPOINT_LOADER_CORE_H
 #define WAYPOINT_LOADER_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_node.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_node.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 // ROS Includes
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_saver\waypoint_saver.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_saver\waypoint_saver.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_velocity_visualizer\waypoint_velocity_visualizer.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "state_machine.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef STATE_MACHINE_H
 #define STATE_MACHINE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.cpp" added_lines="11" deleted_lines="26">
				<diff>@@ -1,33 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
-
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "state_machine_core.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_core.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef STATE_MACHINE_CORE_H
 #define STATE_MACHINE_CORE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_node.cpp" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine_node.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 // ROS Includes
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\data\packages\map_file\include\map_file\get_file.h" new_path="ros\src\data\packages\map_file\include\map_file\get_file.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef _GET_FILE_H_
 #define _GET_FILE_H_
</diff>
			</file>
			<file old_path="ros\src\data\packages\map_file\lib\map_file\get_file.cpp" new_path="ros\src\data\packages\map_file\lib\map_file\get_file.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;iostream&gt;
 #include &lt;stdio.h&gt;
</diff>
			</file>
			<file old_path="ros\src\data\packages\map_file\nodes\points_map_loader\points_map_loader.cpp" new_path="ros\src\data\packages\map_file\nodes\points_map_loader\points_map_loader.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;condition_variable&gt;
 #include &lt;queue&gt;
</diff>
			</file>
			<file old_path="ros\src\data\packages\map_file\nodes\vector_map_loader\vector_map_loader.cpp" new_path="ros\src\data\packages\map_file\nodes\vector_map_loader\vector_map_loader.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/console.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
</diff>
			</file>
			<file old_path="ros\src\data\packages\obj_db\include\obj_db.h" new_path="ros\src\data\packages\obj_db\include\obj_db.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef _OBJ_DB_H_
 #define _OBJ_DB_H_
</diff>
			</file>
			<file old_path="ros\src\data\packages\obj_db\lib\obj_db\SendData.cpp" new_path="ros\src\data\packages\obj_db\lib\obj_db\SendData.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;iostream&gt;
 #include &lt;stdio.h&gt;
</diff>
			</file>
			<file old_path="ros\src\data\packages\obj_db\nodes\can_uploader\can_uploader.cpp" new_path="ros\src\data\packages\obj_db\nodes\can_uploader\can_uploader.cpp" added_lines="12" deleted_lines="26">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*
 
@@ -44,7 +30,7 @@
 
 
 
-*/
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/String.h&gt;
</diff>
			</file>
			<file old_path="ros\src\data\packages\obj_db\nodes\obj_downloader\obj_downloader.cpp" new_path="ros\src\data\packages\obj_db\nodes\obj_downloader\obj_downloader.cpp" added_lines="12" deleted_lines="26">
				<diff>@@ -1,38 +1,24 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*
 obj_downloader
 This node get location data from db server and
 publish data as ractangular plane
-*/
+ */
 
 #include "ros/ros.h"
 #include "std_msgs/String.h"
</diff>
			</file>
			<file old_path="ros\src\data\packages\obj_db\nodes\obj_uploader\obj_uploader.cpp" new_path="ros\src\data\packages\obj_db\nodes\obj_uploader\obj_uploader.cpp" added_lines="12" deleted_lines="26">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*
 
@@ -44,7 +30,7 @@
 
 
 
-*/
+ */
 
 #include &lt;cstdio&gt;
 #include &lt;time.h&gt;
</diff>
			</file>
			<file old_path="ros\src\data\packages\pos_db\include\pos_db.h" new_path="ros\src\data\packages\pos_db\include\pos_db.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef _POS_DB_H_
 #define _POS_DB_H_
</diff>
			</file>
			<file old_path="ros\src\data\packages\pos_db\lib\pos_db\SendData.cpp" new_path="ros\src\data\packages\pos_db\lib\pos_db\SendData.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;iostream&gt;
 #include &lt;stdio.h&gt;
</diff>
			</file>
			<file old_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" new_path="ros\src\data\packages\pos_db\nodes\pos_downloader\pos_downloader.cpp" added_lines="12" deleted_lines="26">
				<diff>@@ -1,38 +1,24 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*
 pos_downloader
 This node get location data from db server and
 publish data as ractangular plane
-*/
+ */
 
 #include "ros/ros.h"
 #include "std_msgs/String.h"
</diff>
			</file>
			<file old_path="ros\src\data\packages\pos_db\nodes\pos_uploader\pos_uploader.cpp" new_path="ros\src\data\packages\pos_db\nodes\pos_uploader\pos_uploader.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;cstdio&gt;
 #include &lt;time.h&gt;
</diff>
			</file>
			<file old_path="ros\src\data\packages\vector_map\include\vector_map\vector_map.h" new_path="ros\src\data\packages\vector_map\include\vector_map\vector_map.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef VECTOR_MAP_VECTOR_MAP_H
 #define VECTOR_MAP_VECTOR_MAP_H
</diff>
			</file>
			<file old_path="ros\src\data\packages\vector_map\lib\vector_map\vector_map.cpp" new_path="ros\src\data\packages\vector_map\lib\vector_map\vector_map.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;tf/transform_datatypes.h&gt;
 #include &lt;vector_map/vector_map.h&gt;
</diff>
			</file>
			<file old_path="ros\src\data\packages\vector_map_server\nodes\vector_map_client\vector_map_client.cpp" new_path="ros\src\data\packages\vector_map_server\nodes\vector_map_client\vector_map_client.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include "autoware_msgs/Lane.h"
</diff>
			</file>
			<file old_path="ros\src\data\packages\vector_map_server\nodes\vector_map_server\vector_map_server.cpp" new_path="ros\src\data\packages\vector_map_server\nodes\vector_map_server\vector_map_server.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include "autoware_msgs/Lane.h"
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\camera\packages\hexacam\nodes\hexacam\hexacam.cpp" new_path="ros\src\sensing\drivers\camera\packages\hexacam\nodes\hexacam\hexacam.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2016, Nagoya University
- *  All rights reserved.
+ * Copyright 2016-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\grasshopper3\grasshopper3.cpp" new_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\grasshopper3\grasshopper3.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 /*
@@ -34,7 +20,7 @@
   Initial version 		2014-11-14
   Added signal handler 		2015-05-01
   Added CameraInfo msg 		2015-05-01
-*/
+ */
 
 #include &lt;iostream&gt;
 #include &lt;stdlib.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\drivers\camera\packages\vectacam\nodes\vectacam\vectacam_node.cpp" new_path="ros\src\sensing\drivers\camera\packages\vectacam\nodes\vectacam\vectacam_node.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2016, Nagoya University
- *  All rights reserved.
+ * Copyright 2016-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 #include &lt;ros/ros.h&gt;
 #include "ros/package.h"
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\image_processor\nodes\image_rectifier\image_rectifier_node.cpp" new_path="ros\src\sensing\filters\packages\image_processor\nodes\image_rectifier\image_rectifier_node.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,35 +1,21 @@
 /*
- *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
 //
 // Created by amc on 2017-11-15.
 //
-*/
+ */
 #include &lt;string&gt;
 #include &lt;vector&gt;
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\image_processor\nodes\image_rotator\image_rotator_node.cpp" new_path="ros\src\sensing\filters\packages\image_processor\nodes\image_rotator\image_rotator_node.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,35 +1,21 @@
 /*
- *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
 //
 // Created by amc on 2017-11-15.
 //
-*/
+ */
 #include &lt;string&gt;
 #include &lt;vector&gt;
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\ring_filter\ring_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\ring_filter\ring_filter.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\cloud_transformer\cloud_transformer_node.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\cloud_transformer\cloud_transformer_node.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,34 +1,20 @@
 /*
- *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
-*/
+ */
 #include &lt;iostream&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\points_concat_filter\points_concat_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\points_concat_filter\points_concat_filter.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2018, Nagoya University, TierIV Inc.
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;message_filters/subscriber.h&gt;
 #include &lt;message_filters/sync_policies/approximate_time.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\include\ray_ground_filter.h" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\include\ray_ground_filter.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,34 +1,20 @@
 /*
- *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
-*/
+ */
 #ifndef RAY_GROUND_FILTER_H_
 #define RAY_GROUND_FILTER_H_
 
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\ray_ground_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\ray_ground_filter.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2017, Nagoya University
- *  All rights reserved.
+ * Copyright 2017-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  */
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\camera_lidar2d_offline_calib.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\camera_lidar2d_offline_calib.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\chessboard.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\chessboard.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "chessboard.h"
 #include "data_struct.h"
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\chessboard.h" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\chessboard.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef _chessboard_
 #define _chessboard_
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\common_2d_calib.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\common_2d_calib.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "common_2d_calib.h"
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\common_2d_calib.h" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\common_2d_calib.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef _common_2d_common_
 #define _common_2d_common_
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\data_struct.h" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\data_struct.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef _data_struct_
 #define _data_struct_
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\image_window.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\image_window.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\image_window.h" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\image_window.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef _image_window_
 #define _image_window_
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\scan_window.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\scan_window.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "scan_window.h"
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\scan_window.h" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\scan_window.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef _scan_window_
 #define _scan_window_
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\trans.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\trans.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "trans.h"
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\trans.h" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\trans.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef _trans_
 #define _trans_
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\multi_lidar_calibrator\include\multi_lidar_calibrator.h" new_path="ros\src\sensing\fusion\packages\multi_lidar_calibrator\include\multi_lidar_calibrator.h" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\multi_lidar_calibrator\src\multi_lidar_calibrator.cpp" new_path="ros\src\sensing\fusion\packages\multi_lidar_calibrator\src\multi_lidar_calibrator.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\multi_lidar_calibrator\src\multi_lidar_calibrator_node.cpp" new_path="ros\src\sensing\fusion\packages\multi_lidar_calibrator\src\multi_lidar_calibrator_node.cpp" added_lines="10" deleted_lines="24">
				<diff>@@ -1,31 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
  *
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\include\points_image\points_image.hpp" new_path="ros\src\sensing\fusion\packages\points2image\include\points_image\points_image.hpp" added_lines="15" deleted_lines="29">
				<diff>@@ -1,35 +1,21 @@
-#ifndef _POINTS_IMAGE_H_
-#define _POINTS_IMAGE_H_
-
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _POINTS_IMAGE_H_
+#define _POINTS_IMAGE_H_
 
 #include &lt;opencv2/opencv.hpp&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
@@ -43,5 +29,5 @@ autoware_msgs::PointsImage pointcloud2_to_image(const sensor_msgs::PointCloud2Co
 /*points2image::CameraExtrinsic
 pointcloud2_to_3d_calibration(const sensor_msgs::PointCloud2ConstPtr&amp; pointclound2,
             const cv::Mat&amp; cameraExtrinsicMat);
-*/
+ */
 #endif /* _POINTS_IMAGE_H_ */
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\lib\points_image\points_image.cpp" new_path="ros\src\sensing\fusion\packages\points2image\lib\points_image\points_image.cpp" added_lines="12" deleted_lines="26">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;vector&gt;
 #include &lt;include/points_image/points_image.hpp&gt;
@@ -158,4 +144,4 @@ pointcloud2_to_3d_calibration(const sensor_msgs::PointCloud2ConstPtr&amp; pointcloud
   msg.calibration = cali;
   return msg;
 }
-*/
+ */
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\nodes\points2image\main.cpp" new_path="ros\src\sensing\fusion\packages\points2image\nodes\points2image\main.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;QCoreApplication&gt;
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\nodes\points2image\points2image.cpp" new_path="ros\src\sensing\fusion\packages\points2image\nodes\points2image\points2image.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\nodes\vscan2image\vscan2image.cpp" new_path="ros\src\sensing\fusion\packages\points2image\nodes\vscan2image\vscan2image.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\nodes\vscan2linelist\vscan2linelist.cpp" new_path="ros\src\sensing\fusion\packages\points2image\nodes\vscan2linelist\vscan2linelist.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\scan2image\nodes\scan2image\scan2image.h" new_path="ros\src\sensing\fusion\packages\scan2image\nodes\scan2image\scan2image.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef _Scan_to_image_
 #define _Scan_to_image_
</diff>
			</file>
			<file old_path="ros\src\sensing\polygon\packages\points2polygon\nodes\points2polygon\points2polygon.cpp" new_path="ros\src\sensing\polygon\packages\points2polygon\nodes\points2polygon\points2polygon.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;ros/console.h&gt;
</diff>
			</file>
			<file old_path="ros\src\socket\packages\tablet_socket\nodes\tablet_receiver\tablet_receiver.cpp" new_path="ros\src\socket\packages\tablet_socket\nodes\tablet_receiver\tablet_receiver.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
</diff>
			</file>
			<file old_path="ros\src\socket\packages\tablet_socket\nodes\tablet_sender\tablet_sender.cpp" new_path="ros\src\socket\packages\tablet_socket\nodes\tablet_sender\tablet_sender.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;mutex&gt;
 
</diff>
			</file>
			<file old_path="ros\src\socket\packages\udon_socket\include\udon_socket\udon.hpp" new_path="ros\src\socket\packages\udon_socket\include\udon_socket\udon.hpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef UDON_SOCKET_UDON_HPP
 #define UDON_SOCKET_UDON_HPP
</diff>
			</file>
			<file old_path="ros\src\socket\packages\udon_socket\lib\udon_socket\udon.cpp" new_path="ros\src\socket\packages\udon_socket\lib\udon_socket\udon.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;cstddef&gt;
 #include &lt;cstring&gt;
</diff>
			</file>
			<file old_path="ros\src\socket\packages\udon_socket\nodes\udon_receiver\udon_receiver.cpp" new_path="ros\src\socket\packages\udon_socket\nodes\udon_receiver\udon_receiver.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;arpa/inet.h&gt;
 #include &lt;netinet/in.h&gt;
</diff>
			</file>
			<file old_path="ros\src\socket\packages\udon_socket\nodes\udon_sender\udon_sender.cpp" new_path="ros\src\socket\packages\udon_socket\nodes\udon_sender\udon_sender.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;arpa/inet.h&gt;
 #include &lt;netinet/in.h&gt;
</diff>
			</file>
			<file old_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_receiver\vehicle_receiver.cpp" new_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_receiver\vehicle_receiver.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include &lt;tablet_socket_msgs/mode_info.h&gt;
</diff>
			</file>
			<file old_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" new_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;ros/ros.h&gt;
 #include "autoware_msgs/VehicleCmd.h"
</diff>
			</file>
			<file old_path="ros\src\system\gazebo\laser_scan_converter\src\converter.cpp" new_path="ros\src\system\gazebo\laser_scan_converter\src\converter.cpp" added_lines="11" deleted_lines="29">
				<diff>@@ -1,36 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice,
- * this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;boost/thread.hpp&gt;
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\system\gazebo\twist_cmd_converter\src\converter.cpp" new_path="ros\src\system\gazebo\twist_cmd_converter\src\converter.cpp" added_lines="11" deleted_lines="29">
				<diff>@@ -1,36 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice,
- * this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;boost/thread.hpp&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
</diff>
			</file>
			<file old_path="ros\src\system\sync\sync_drivers.cpp" new_path="ros\src\system\sync\sync_drivers.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /* ----header---- */
 /* common header */
 #include "ros/ros.h"
</diff>
			</file>
			<file old_path="ros\src\system\sync\time_monitor.cpp" new_path="ros\src\system\sync\time_monitor.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /* ----header---- */
 /* common header */
 #include "ros/ros.h"
</diff>
			</file>
			<file old_path="ros\src\util\packages\RobotSDK\glviewer\GLViewer\glviewer.cpp" new_path="ros\src\util\packages\RobotSDK\glviewer\GLViewer\glviewer.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "glviewer/glviewer.h"
 
</diff>
			</file>
			<file old_path="ros\src\util\packages\RobotSDK\glviewer\include\glviewer\glviewer.h" new_path="ros\src\util\packages\RobotSDK\glviewer\include\glviewer\glviewer.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef GLVIEWER_H
 #define GLVIEWER_H
</diff>
			</file>
			<file old_path="ros\src\util\packages\RobotSDK\rosinterface\ROSInterface\rosinterface.cpp" new_path="ros\src\util\packages\RobotSDK\rosinterface\ROSInterface\rosinterface.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "rosinterface/rosinterface.h"
 
</diff>
			</file>
			<file old_path="ros\src\util\packages\RobotSDK\rosinterface\include\rosinterface\rosinterface.h" new_path="ros\src\util\packages\RobotSDK\rosinterface\include\rosinterface\rosinterface.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef ROSINTERFACE_H
 #define ROSINTERFACE_H
</diff>
			</file>
			<file old_path="ros\src\util\packages\autoware_bag_tools\nodes\nmea2kml\nmea2kml.cpp" new_path="ros\src\util\packages\autoware_bag_tools\nodes\nmea2kml\nmea2kml.cpp" added_lines="10" deleted_lines="29">
				<diff>@@ -1,36 +1,17 @@
-
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice,
- *this
- *    list of conditions and the following disclaimer.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- *ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- *USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 
</diff>
			</file>
			<file old_path="ros\src\util\packages\autoware_rviz_plugins\src\state_panel\state_panel.cpp" new_path="ros\src\util\packages\autoware_rviz_plugins\src\state_panel\state_panel.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;QPainter&gt;
 #include &lt;QVBoxLayout&gt;
</diff>
			</file>
			<file old_path="ros\src\util\packages\autoware_rviz_plugins\src\state_panel\state_panel.h" new_path="ros\src\util\packages\autoware_rviz_plugins\src\state_panel\state_panel.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef STATE_PANEL_H
 #define STATE_PANEL_H
</diff>
			</file>
			<file old_path="ros\src\util\packages\fake_drivers\nodes\fake_camera\fake_camera.cpp" new_path="ros\src\util\packages\fake_drivers\nodes\fake_camera\fake_camera.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;cstdlib&gt;
 #include &lt;cstdint&gt;
</diff>
			</file>
			<file old_path="ros\src\util\packages\map_tools\nodes\map_extender\map_extender.cpp" new_path="ros\src\util\packages\map_tools\nodes\map_extender\map_extender.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*
  Localization program using Normal Distributions Transform
</diff>
			</file>
			<file old_path="ros\src\util\packages\map_tools\nodes\pcd_arealist\pcd_arealist.cpp" new_path="ros\src\util\packages\map_tools\nodes\pcd_arealist\pcd_arealist.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2016, Nagoya University
- *  All rights reserved.
+ * Copyright 2016-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
</diff>
			</file>
			<file old_path="ros\src\util\packages\map_tools\nodes\pcd_grid_divider\pcd_grid_divider.cpp" new_path="ros\src\util\packages\map_tools\nodes\pcd_grid_divider\pcd_grid_divider.cpp" added_lines="10" deleted_lines="28">
				<diff>@@ -1,35 +1,17 @@
 /*
- *  Copyright (c) 2018, Nagoya University
- *  All rights reserved.
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice,
- *this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- *ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- *USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ********************
  *  v1.0: Yuki Kitsukawa (yuki.kitsukawa@tier4.jp)
  *
</diff>
			</file>
			<file old_path="ros\src\util\packages\sample_data\nodes\sample_mobility\sample_mobility.cpp" new_path="ros\src\util\packages\sample_data\nodes\sample_mobility\sample_mobility.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;fstream&gt;
 #include &lt;iostream&gt;
</diff>
			</file>
			<file old_path="ros\src\util\packages\sample_data\nodes\sample_points_map\sample_points_map.cpp" new_path="ros\src\util\packages\sample_data\nodes\sample_points_map\sample_points_map.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
</diff>
			</file>
			<file old_path="ros\src\util\packages\sample_data\nodes\sample_points_map_update\sample_points_map_update.cpp" new_path="ros\src\util\packages\sample_data\nodes\sample_points_map_update\sample_points_map_update.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
</diff>
			</file>
			<file old_path="ros\src\util\packages\sample_data\nodes\sample_trajectory\sample_trajectory.cpp" new_path="ros\src\util\packages\sample_data\nodes\sample_trajectory\sample_trajectory.cpp" added_lines="12" deleted_lines="26">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;fstream&gt;
 #include "ros/ros.h"
@@ -148,7 +134,7 @@ rosrun sample_data sample_trajectory gnss.log &lt;swap_x_y_off|swap_x_y_on&gt;
 
 # EOF
 
-*/
+ */
 
   ros::init(argc, argv, "sample_trajectory");
   ros::NodeHandle n;
</diff>
			</file>
			<file old_path="ros\src\util\packages\sample_data\nodes\sample_vector_map\sample_vector_map.cpp" new_path="ros\src\util\packages\sample_data\nodes\sample_vector_map\sample_vector_map.cpp" added_lines="12" deleted_lines="26">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;fstream&gt;
 #include "ros/ros.h"
@@ -756,7 +742,7 @@ rosrun sample_data sample_vector_map poledata.csv signaldata.csv pole.csv vector
 
 # EOF
 
-*/
+ */
 
   ros::init(argc, argv, "sample_vector_map");
   ros::NodeHandle n;
</diff>
			</file>
			<file old_path="ui\tablet\AutowareRider\jni\GhostAgent.cpp" new_path="ui\tablet\AutowareRider\jni\GhostAgent.cpp" added_lines="15" deleted_lines="29">
				<diff>@@ -1,31 +1,17 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+/*
+ * Copyright 2015 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;jni.h&gt;
</diff>
			</file>
			<file old_path="ui\tablet\AutowareRider\jni\sound_sender.c" new_path="ui\tablet\AutowareRider\jni\sound_sender.c" added_lines="15" deleted_lines="29">
				<diff>@@ -1,32 +1,18 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+/*
+ * Copyright 2015 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;errno.h&gt;
 #include &lt;fcntl.h&gt;
</diff>
			</file>
			<file old_path="vehicle\zmp\autoware_socket\autoware_socket.h" new_path="vehicle\zmp\autoware_socket\autoware_socket.h" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #ifndef __AUTOWARE_SOCKET_H__
 #define __AUTOWARE_SOCKET_H__
</diff>
			</file>
			<file old_path="vehicle\zmp\autoware_socket\can.cpp" new_path="vehicle\zmp\autoware_socket\can.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "mainwindow.h"
 #include "autoware_socket.h"
</diff>
			</file>
			<file old_path="vehicle\zmp\autoware_socket\cmd.cpp" new_path="vehicle\zmp\autoware_socket\cmd.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include &lt;string.h&gt;
 #include &lt;stdio.h&gt;
</diff>
			</file>
			<file old_path="vehicle\zmp\autoware_socket\common.cpp" new_path="vehicle\zmp\autoware_socket\common.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "mainwindow.h"
 #include "autoware_socket.h"
</diff>
			</file>
			<file old_path="vehicle\zmp\autoware_socket\drv.cpp" new_path="vehicle\zmp\autoware_socket\drv.cpp" added_lines="12" deleted_lines="26">
				<diff>@@ -1,32 +1,18 @@
- /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+/*
+ * Copyright 2015 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "mainwindow.h"
 #include "autoware_socket.h"
</diff>
			</file>
			<file old_path="vehicle\zmp\autoware_socket\str.cpp" new_path="vehicle\zmp\autoware_socket\str.cpp" added_lines="11" deleted_lines="25">
				<diff>@@ -1,32 +1,18 @@
 /*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
+ * Copyright 2015 Autoware Foundation. All rights reserved.
  *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "mainwindow.h"
 #include "autoware_socket.h"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f77b7849273cffdbb5cc2583527c77d691572c45" author="Abraham Monrroy Cano">
		<msg>[fix] SSD detector, cmake colcon (#1837)

* Fixes for new colcon script on ssd cuda based node

* Fixed to RTM and darknet launch files

* catkin_fix

* * catkin &amp; colcon build successfully
* reverted back run to devel space (for the time being)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\include\vision_ssd_detect.h" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\include\vision_ssd_detect.h" added_lines="1" deleted_lines="1">
				<diff>@@ -44,7 +44,7 @@ private:
   void Preprocess(const cv::Mat &amp;img, std::vector&lt;cv::Mat&gt; *input_channels);
 
 private:
-  boost::shared_ptr &lt;caffe::Net&lt;float&gt;&gt; net_;
+  boost::shared_ptr &lt;caffe::Net&lt;float&gt; &gt; net_;
   cv::Size input_geometry_;
   int num_channels_;
   cv::Scalar mean_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect.cpp" new_path="ros\src\computing\perception\detection\vision_detector\packages\vision_ssd_detect\src\vision_ssd_detect.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -29,7 +29,7 @@ SSDDetector::SSDDetector(const std::string&amp; in_network_definition_file,
     caffe::Caffe::set_mode(caffe::Caffe::CPU);
 
   /* Load the network. */
-  net_.reset(new caffe::Net&lt;float&gt;(in_network_definition_file, caffe::Phase::TEST));
+  net_.reset(new caffe::Net&lt;float&gt;(in_network_definition_file, caffe::TEST));
   net_-&gt;CopyTrainedLayersFrom(in_pre_trained_model_file);
 
   CHECK_EQ(net_-&gt;num_inputs(), 1) &lt;&lt; "Network should have exactly one input.";
@@ -63,7 +63,7 @@ std::vector &lt;  RectClassScore&lt;float&gt;  &gt; SSDDetector::Detect(const cv::Mat&amp; img)
   caffe::Blob&lt;float&gt; *result_blob = net_-&gt;output_blobs()[0];
   const float *result = result_blob-&gt;cpu_data();
   const int num_det = result_blob-&gt;height();
-  std::vector &lt;RectClassScore&lt;float&gt;&gt; detections;
+  std::vector &lt;RectClassScore&lt;float&gt; &gt; detections;
   for (int k = 0; k &lt; num_det; ++k)
   {
     if (result[0] == -1)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7bc443786921a471b9c45bb7f97e9266d8b44c05" author="Kenji Funaoka">
		<msg>Delete mysterious outputs</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\data_preprocessor\nodes\get_PCD\get_PCD.cpp" new_path="ros\src\util\packages\data_preprocessor\nodes\get_PCD\get_PCD.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -3,7 +3,6 @@
 
 static void check_arguments(int argc, char* argv[])
 {
-  cout &lt;&lt; "Fuck you" &lt;&lt; endl;
   if (argc != 3){
     cout &lt;&lt; "Please set arguments like below\n'rosrun data_preprocessor get_PCD save_dir topic_name'\n";
     exit(EXIT_FAILURE);
</diff>
			</file>
			<file old_path="ros\src\util\packages\data_preprocessor\scripts\get_PCD.cpp" new_path="ros\src\util\packages\data_preprocessor\scripts\get_PCD.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -3,7 +3,6 @@
 
 static void check_arguments(int argc, char* argv[])
 {
-  cout &lt;&lt; "Fuck you" &lt;&lt; endl;
   if (argc != 3){
     cout &lt;&lt; "Please set arguments like below\n'rosrun data_preprocessor get_PCD save_dir topic_name'\n";
     exit(EXIT_FAILURE);
</diff>
			</file>
		</modified_files>
	</commit>
</Root>
