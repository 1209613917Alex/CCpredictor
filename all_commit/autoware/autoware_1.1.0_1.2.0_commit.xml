<?xml version="1.0" encoding="utf-8"?>
<Root>
	<commit hash="258d48fea4bd22637395319d4bdf2978ea54feff" author="Yukihiro Saito">
		<msg>Update potential field</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\potential_field\potential_field.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\potential_field\potential_field.cpp" added_lines="71" deleted_lines="45">
				<diff>@@ -4,10 +4,10 @@
 #include &lt;grid_map_msgs/GridMap.h&gt;
 #include &lt;grid_map_ros/grid_map_ros.hpp&gt;
 #include &lt;iostream&gt;
-#include &lt;lidar_tracker/DetectedObject.h&gt;
-#include &lt;lidar_tracker/DetectedObjectArray.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
+#include &lt;lidar_tracker/DetectedObject.h&gt;
+#include &lt;lidar_tracker/DetectedObjectArray.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
@@ -31,6 +31,7 @@ private:
   double map_resolution_;
   double tf_x_;
   double tf_z_;
+  double map_x_offset_;
   GridMap map_;
   class ObstacleFieldParameter {
   public:
@@ -92,7 +93,10 @@ PotentialField::PotentialField()
     map_y_size_ = 25.0;
     ROS_INFO("map y size %f", map_y_size_);
   }
-
+  if (!private_nh.getParam("map_x_offset", map_x_offset_)) {
+    map_x_offset_ = 10.0;
+    ROS_INFO("map x offset %f", map_x_offset_);
+  }
   publisher_ =
       nh_.advertise&lt;grid_map_msgs::GridMap&gt;("/potential_field", 1, true);
 
@@ -110,7 +114,7 @@ PotentialField::PotentialField()
 
 void PotentialField::init() {
   ROS_INFO("Created map");
-  map_.setFrameId("/base_link");
+  map_.setFrameId("/potential_field_link");
   map_.setGeometry(Length(map_x_size_, map_y_size_), map_resolution_);
   for (GridMapIterator it(map_); !it.isPastEnd(); ++it) {
     Position position;
@@ -118,6 +122,7 @@ void PotentialField::init() {
     map_.at("obstacle_field", *it) = 0.0;
     map_.at("target_waypoint_field", *it) = 0.0;
     map_.at("vscan_points_field", *it) = 0.0;
+    map_.at("potential_field", *it) = 0.0;
   }
   ROS_INFO("Created map with size %f x %f m (%i x %i cells).",
            map_.getLength().x(), map_.getLength().y(), map_.getSize()(0),
@@ -137,8 +142,7 @@ void PotentialField::publish_potential_field() {
                     message.info.header.stamp.toSec());
 }
 void PotentialField::obj_callback(
-    lidar_tracker::DetectedObjectArray::ConstPtr
-        obj_msg) { // Create grid map.
+    lidar_tracker::DetectedObjectArray::ConstPtr obj_msg) { // Create grid map.
   static ObstacleFieldParameter param;
   double ver_x_p(param.ver_x_p);
   double ver_y_p(param.ver_y_p);
@@ -152,7 +156,8 @@ void PotentialField::obj_callback(
     map_.getPosition(*it, position);
     map_.at("obstacle_field", *it) = 0.0;
     for (int i(0); i &lt; (int)obj_msg-&gt;objects.size(); ++i) {
-      double pos_x = obj_msg-&gt;objects.at(i).pose.position.x + tf_x_;
+      double pos_x =
+          obj_msg-&gt;objects.at(i).pose.position.x + tf_x_ - map_x_offset_;
       double pos_y = obj_msg-&gt;objects.at(i).pose.position.y;
       double len_x = obj_msg-&gt;objects.at(i).dimensions.x / 2.0;
       double len_y = obj_msg-&gt;objects.at(i).dimensions.y / 2.0;
@@ -177,53 +182,71 @@ void PotentialField::obj_callback(
       }
       if (pos_x - len_x &lt; rotated_pos_x &amp;&amp; rotated_pos_x &lt; pos_x + len_x) {
         if (pos_y - len_y &lt; rotated_pos_y &amp;&amp; rotated_pos_y &lt; pos_y + len_y) {
-          map_.at("obstacle_field", *it) += std::exp(0.0);
+          map_.at("obstacle_field", *it) =
+              std::max(std::exp(0.0),
+                       static_cast&lt;double&gt;(map_.at("obstacle_field", *it)));
         } else if (rotated_pos_y &lt; pos_y - len_y) {
-          map_.at("obstacle_field", *it) += std::exp(
-              (-1.0 * (std::pow((rotated_pos_y - (pos_y - len_y)), 2.0) /
-                       std::pow(2.0 * ver_y_p, 2.0))));
+          map_.at("obstacle_field", *it) = std::max(
+              std::exp(
+                  (-1.0 * (std::pow((rotated_pos_y - (pos_y - len_y)), 2.0) /
+                           std::pow(2.0 * ver_y_p, 2.0)))),
+              static_cast&lt;double&gt;(map_.at("obstacle_field", *it)));
         } else if (pos_y + len_y &lt; rotated_pos_y) {
-          map_.at("obstacle_field", *it) += std::exp(
-              (-1.0 * (std::pow((rotated_pos_y - (pos_y + len_y)), 2.0) /
-                       std::pow(2.0 * ver_y_p, 2.0))));
+          map_.at("obstacle_field", *it) = std::max(
+              std::exp(
+                  (-1.0 * (std::pow((rotated_pos_y - (pos_y + len_y)), 2.0) /
+                           std::pow(2.0 * ver_y_p, 2.0)))),
+              static_cast&lt;double&gt;(map_.at("obstacle_field", *it)));
         }
       } else if (rotated_pos_x &lt; pos_x - len_x) {
         if (rotated_pos_y &lt; pos_y - len_y) {
-          map_.at("obstacle_field", *it) += std::exp(
-              (-1.0 * (std::pow((rotated_pos_y - (pos_y - len_y)), 2.0) /
-                       std::pow(2.0 * ver_y_p, 2.0))) +
-              (-1.0 * (std::pow((rotated_pos_x - (pos_x - len_x)), 2.0) /
-                       std::pow(2.0 * ver_x_p, 2.0))));
+          map_.at("obstacle_field", *it) = std::max(
+              std::exp(
+                  (-1.0 * (std::pow((rotated_pos_y - (pos_y - len_y)), 2.0) /
+                           std::pow(2.0 * ver_y_p, 2.0))) +
+                  (-1.0 * (std::pow((rotated_pos_x - (pos_x - len_x)), 2.0) /
+                           std::pow(2.0 * ver_x_p, 2.0)))),
+              static_cast&lt;double&gt;(map_.at("obstacle_field", *it)));
         } else if (pos_y + len_y &lt; rotated_pos_y) {
-          map_.at("obstacle_field", *it) += std::exp(
-              (-1.0 * (std::pow((rotated_pos_y - (pos_y + len_y)), 2.0) /
-                       std::pow(2.0 * ver_y_p, 2.0))) +
-              (-1.0 * (std::pow((rotated_pos_x - (pos_x - len_x)), 2.0) /
-                       std::pow(2.0 * ver_x_p, 2.0))));
+          map_.at("obstacle_field", *it) = std::max(
+              std::exp(
+                  (-1.0 * (std::pow((rotated_pos_y - (pos_y + len_y)), 2.0) /
+                           std::pow(2.0 * ver_y_p, 2.0))) +
+                  (-1.0 * (std::pow((rotated_pos_x - (pos_x - len_x)), 2.0) /
+                           std::pow(2.0 * ver_x_p, 2.0)))),
+              static_cast&lt;double&gt;(map_.at("obstacle_field", *it)));
         } else if (pos_y - len_y &lt; rotated_pos_y &amp;&amp;
                    rotated_pos_y &lt; pos_y + len_y) {
-          map_.at("obstacle_field", *it) += std::exp(
-              (-1.0 * (std::pow((rotated_pos_x - (pos_x - len_x)), 2.0) /
-                       std::pow(2.0 * ver_x_p, 2.0))));
+          map_.at("obstacle_field", *it) = std::max(
+              std::exp(
+                  (-1.0 * (std::pow((rotated_pos_x - (pos_x - len_x)), 2.0) /
+                           std::pow(2.0 * ver_x_p, 2.0)))),
+              static_cast&lt;double&gt;(map_.at("obstacle_field", *it)));
         }
       } else if (pos_x + len_x &lt; rotated_pos_x) {
         if (rotated_pos_y &lt; pos_y - len_y) {
-          map_.at("obstacle_field", *it) += std::exp(
-              (-1.0 * (std::pow((rotated_pos_y - (pos_y - len_y)), 2.0) /
-                       std::pow(2.0 * ver_y_p, 2.0))) +
-              (-1.0 * (std::pow((rotated_pos_x - (pos_x + len_x)), 2.0) /
-                       std::pow(2.0 * ver_x_p, 2.0))));
+          map_.at("obstacle_field", *it) = std::max(
+              std::exp(
+                  (-1.0 * (std::pow((rotated_pos_y - (pos_y - len_y)), 2.0) /
+                           std::pow(2.0 * ver_y_p, 2.0))) +
+                  (-1.0 * (std::pow((rotated_pos_x - (pos_x + len_x)), 2.0) /
+                           std::pow(2.0 * ver_x_p, 2.0)))),
+              static_cast&lt;double&gt;(map_.at("obstacle_field", *it)));
         } else if (pos_y + len_y / 2.0 &lt; rotated_pos_y) {
-          map_.at("obstacle_field", *it) += std::exp(
-              (-1.0 * (std::pow((rotated_pos_y - (pos_y + len_y)), 2.0) /
-                       std::pow(2.0 * ver_y_p, 2.0))) +
-              (-1.0 * (std::pow((rotated_pos_x - (pos_x + len_x)), 2.0) /
-                       std::pow(2.0 * ver_x_p, 2.0))));
+          map_.at("obstacle_field", *it) = std::max(
+              std::exp(
+                  (-1.0 * (std::pow((rotated_pos_y - (pos_y + len_y)), 2.0) /
+                           std::pow(2.0 * ver_y_p, 2.0))) +
+                  (-1.0 * (std::pow((rotated_pos_x - (pos_x + len_x)), 2.0) /
+                           std::pow(2.0 * ver_x_p, 2.0)))),
+              static_cast&lt;double&gt;(map_.at("obstacle_field", *it)));
         } else if (pos_y - len_y &lt; rotated_pos_y &amp;&amp;
                    rotated_pos_y &lt; pos_y + len_y) {
-          map_.at("obstacle_field", *it) += std::exp(
-              (-1.0 * (std::pow((rotated_pos_x - (pos_x + len_x)), 2.0) /
-                       std::pow(2.0 * ver_x_p, 2.0))));
+          map_.at("obstacle_field", *it) = std::max(
+              std::exp(
+                  (-1.0 * (std::pow((rotated_pos_x - (pos_x + len_x)), 2.0) /
+                           std::pow(2.0 * ver_x_p, 2.0)))),
+              static_cast&lt;double&gt;(map_.at("obstacle_field", *it)));
         }
       }
     }
@@ -245,8 +268,10 @@ void PotentialField::target_waypoint_callback(
   tf::TransformListener tflistener;
   try {
     ros::Time now = ros::Time(0);
-    tflistener.waitForTransform("/map", "/base_link", now, ros::Duration(10.0));
-    tflistener.transformPoint("/base_link", in.header.stamp, in, "/map", out);
+    tflistener.waitForTransform("/map", "/potential_field_link", now,
+                                ros::Duration(10.0));
+    tflistener.transformPoint("/potential_field_link", in.header.stamp, in,
+                              "/map", out);
 
   } catch (tf::TransformException &amp;ex) {
     ROS_ERROR("%s", ex.what());
@@ -285,14 +310,15 @@ void PotentialField::vscan_points_callback(
     map_.getPosition(*it, position);
     map_.at("vscan_points_field", *it) = 0.0;
     for (int i(0); i &lt; (int)pcl_vscan.size(); ++i) {
+      double point_x = pcl_vscan.at(i).x - map_x_offset_;
       if (3.0 &lt; pcl_vscan.at(i).z + tf_z_ || pcl_vscan.at(i).z + tf_z_ &lt; 0.3)
         continue;
-      if (length_x &lt; pcl_vscan.at(i).x &amp;&amp; pcl_vscan.at(i).x &lt; -1.0 * length_x)
+      if (length_x &lt; point_x &amp;&amp; point_x &lt; -1.0 * length_x)
         continue;
       if (length_y &lt; pcl_vscan.at(i).y &amp;&amp; pcl_vscan.at(i).y &lt; -1.0 * length_y)
         continue;
-      if (pcl_vscan.at(i).x + tf_x_ - around_x &lt; position.x() &amp;&amp;
-          position.x() &lt; pcl_vscan.at(i).x + tf_x_ + around_x) {
+      if ((point_x + tf_x_) - around_x &lt; position.x() &amp;&amp;
+          position.x() &lt; point_x + tf_x_ + around_x) {
         if (pcl_vscan.at(i).y - around_y &lt; position.y() &amp;&amp;
             position.y() &lt; pcl_vscan.at(i).y + around_y) {
           map_.at("vscan_points_field", *it) = 1.0; // std::exp(0.0) ;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4df0375f51b16298ab57e870ed67a801ab6d00bd" author="TomohitoAndo">
		<msg>Fix incorrect check for the waypoint index</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -144,7 +144,7 @@ void VelocitySetPath::avoidSuddenDeceleration(double velocity_change_limit, doub
   double square_vel = (current_vel_ - velocity_change_limit) * (current_vel_ - velocity_change_limit);
   for (int i = 0;; i++)
   {
-    if (!checkWaypoint(i, __FUNCTION__))
+    if (!checkWaypoint(closest_waypoint + i, __FUNCTION__))
       return;
 
     // sqrt(v^2 - 2ax)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c8f6ffd6e1dc7d5bfcb38769522b108bc09c5f07" author="h_ohta">
		<msg>publish closest waypoint as -1 when cannot find each closest waypoint in each lane</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="31" deleted_lines="10">
				<diff>@@ -97,6 +97,7 @@ void LaneSelectNode::initForLaneSelect()
   // search closest waypoint number for each lanes
   if (!getClosestWaypointNumberForEachLanes())
   {
+    publishClosestWaypoint(-1);
     resetLaneIdx();
     return;
   }
@@ -105,9 +106,13 @@ void LaneSelectNode::initForLaneSelect()
   findNeighborLanes();
   updateChangeFlag();
   createLaneForChange();
-  publish(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)), std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)),
-          std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)));
+
+  publishLane(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)));
+  publishClosestWaypoint(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)));
+  publishChangeFlag(std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)));
   publishVisualizer();
+
+  resetSubscriptionFlag();
   return;
 }
 
@@ -119,6 +124,13 @@ void LaneSelectNode::resetLaneIdx()
   publishVisualizer();
 }
 
+void LaneSelectNode::resetSubscriptionFlag()
+{
+  is_current_pose_subscribed_ = false;
+  is_current_velocity_subscribed_ = false;
+  is_current_state_subscribed_ = false;
+}
+
 void LaneSelectNode::processing()
 {
   if(!isAllTopicsSubscribed())
@@ -127,6 +139,7 @@ void LaneSelectNode::processing()
   // search closest waypoint number for each lanes
   if (!getClosestWaypointNumberForEachLanes())
   {
+    publishClosestWaypoint(-1);
     resetLaneIdx();
     return;
   }
@@ -134,6 +147,7 @@ void LaneSelectNode::processing()
   // if closest waypoint on current lane is -1,
   if (std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)) == -1)
   {
+    publishClosestWaypoint(-1);
     resetLaneIdx();
     return;
   }
@@ -152,16 +166,21 @@ void LaneSelectNode::processing()
     std::get&lt;2&gt;(lane_for_change_) =
         static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(lane_for_change_).waypoints.at(std::get&lt;1&gt;(lane_for_change_)).change_flag);
     ROS_INFO("closest: %d", std::get&lt;1&gt;(lane_for_change_));
-    publish(std::get&lt;0&gt;(lane_for_change_), std::get&lt;1&gt;(lane_for_change_), std::get&lt;2&gt;(lane_for_change_));
+    publishLane(std::get&lt;0&gt;(lane_for_change_));
+    publishClosestWaypoint(std::get&lt;1&gt;(lane_for_change_));
+    publishChangeFlag(std::get&lt;2&gt;(lane_for_change_));
   }
   else
   {
     updateChangeFlag();
     createLaneForChange();
-    publish(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)), std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)),
-            std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)));
+
+    publishLane(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)));
+    publishClosestWaypoint(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)));
+    publishChangeFlag(std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)));
   }
   publishVisualizer();
+  resetSubscriptionFlag();
 }
 
 int32_t LaneSelectNode::getClosestLaneChangeWaypointNumber(const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps, int32_t cl_wp)
@@ -563,23 +582,25 @@ void LaneSelectNode::publishVisualizer()
   vis_pub1_.publish(marker_array);
 }
 
-void LaneSelectNode::publish(const waypoint_follower::lane &amp;lane, const int32_t clst_wp, const ChangeFlag flag)
+void LaneSelectNode::publishLane(const waypoint_follower::lane &amp;lane)
 {
   // publish global lane
   pub1_.publish(lane);
+}
 
+void LaneSelectNode::publishClosestWaypoint(const int32_t clst_wp)
+{
   // publish closest waypoint
   std_msgs::Int32 closest_waypoint;
   closest_waypoint.data = clst_wp;
   pub2_.publish(closest_waypoint);
+}
 
+void LaneSelectNode::publishChangeFlag(const ChangeFlag flag)
+{
   std_msgs::Int32 change_flag;
   change_flag.data = enumToInteger(flag);
   pub3_.publish(change_flag);
-
-  is_current_pose_subscribed_ = false;
-  is_current_velocity_subscribed_ = false;
-  is_current_state_subscribed_ = false;
 }
 
 void LaneSelectNode::callbackFromLaneArray(const waypoint_follower::LaneArrayConstPtr &amp;msg)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="4" deleted_lines="1">
				<diff>@@ -125,9 +125,12 @@ private:
 
   // functions
   void resetLaneIdx();
+  void resetSubscriptionFlag();
   bool isAllTopicsSubscribed();
   void processing();
-  void publish(const waypoint_follower::lane &amp;lane, const int32_t clst_wp, const ChangeFlag flag);
+  void publishLane(const waypoint_follower::lane &amp;lane);
+  void publishClosestWaypoint(const int32_t clst_wp);
+  void publishChangeFlag(const ChangeFlag flag);
   bool getClosestWaypointNumberForEachLanes();
   int32_t findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec, const geometry_msgs::Point p);
   void findCurrentLane();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="eb370e816fd22197854498ffa4ba48c7bf9efd5b" author="syouji">
		<msg>Distinguish between handling of STR and DRV mode in autoware_socket</msg>
		<modified_files>
			<file old_path="vehicle\zmp\autoware_socket\autoware_socket.h" new_path="vehicle\zmp\autoware_socket\autoware_socket.h" added_lines="2" deleted_lines="0">
				<diff>@@ -57,6 +57,8 @@ using namespace zmp;
 #define CMD_GEAR_N 4
 
 #define CAN_KEY_MODE	(0)
+#define CAN_MODE_STR	(1)
+#define CAN_MODE_DRV	(2)
 #define CAN_KEY_TIME	(1)
 #define CAN_KEY_VELOC	(2)
 #define CAN_KEY_ANGLE	(3)
</diff>
			</file>
			<file old_path="vehicle\zmp\autoware_socket\can.cpp" new_path="vehicle\zmp\autoware_socket\can.cpp" added_lines="2" deleted_lines="5">
				<diff>@@ -160,11 +160,8 @@ void MainWindow::SendCAN(void)
 
   // send drive mode in addition to CAN.
   UpdateState();
-  if (ZMP_DRV_CONTROLLED() &amp;&amp; ZMP_STR_CONTROLLED()) {
-    drvmode = CMD_MODE_PROGRAM;
-  } else {
-    drvmode = CMD_MODE_MANUAL;
-  }
+  drvmode = ZMP_STR_CONTROLLED() ? CAN_MODE_STR:0;
+  drvmode |= ZMP_DRV_CONTROLLED() ? CAN_MODE_DRV:0;
   
   wrapSender();
 }
</diff>
			</file>
			<file old_path="vehicle\zmp\autoware_socket\cmd.cpp" new_path="vehicle\zmp\autoware_socket\cmd.cpp" added_lines="4" deleted_lines="2">
				<diff>@@ -181,6 +181,7 @@ void Update(void *p)
 
 void SetState(int mode, int gear, void* p) 
 {
+  // 0=manual, 1=str, 2=drv, 3=str+drv
   if (mode != current_mode) {
     current_mode = mode;
     pthread_create(&amp;_modesetter, NULL, MainWindow::ModeSetterEntry, p);
@@ -317,10 +318,11 @@ void *MainWindow::ModeSetterEntry(void *a)
   mode_is_setting = true; // loose critical section
 
   main-&gt;ClearCntDiag();
+  // 0=manual, 1=str, 2=drv, 3=str+drv
   sleep(1);
-  main-&gt;SetStrMode(current_mode); // steering
+  main-&gt;SetStrMode(((current_mode &amp; CAN_MODE_STR) != 0) ? 1:0); // steering
   sleep(1);
-  main-&gt;SetDrvMode(current_mode); // accel/brake
+  main-&gt;SetDrvMode(((current_mode &amp; CAN_MODE_DRV) != 0) ? 1:0); // accel/brake
   sleep(1);
 
   mode_is_setting = false; // loose critical section
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c7b0ab5bc225f6fe8eef62e18eb76e8b401f8de8" author="syouji">
		<msg>Handle both STR and DRV mode as automatic cruise mode in udon_socket</msg>
		<modified_files>
			<file old_path="ros\src\socket\packages\udon_socket\lib\udon_socket\udon.cpp" new_path="ros\src\socket\packages\udon_socket\lib\udon_socket\udon.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -121,7 +121,7 @@ ssize_t send_mode(int fd, std::int32_t mode)
 {
 	std::uint8_t buf[SIZE_MODE];
 	set_type(buf, TYPE_MODE);
-	set_value(buf, mode);
+	set_value(buf, (mode &gt; 0) ? 1:0);
 
 	return send(fd, &amp;buf, sizeof(buf), 0);
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="506991750094762ba0981dbf749f8d07a0f3f1d8" author="syouji">
		<msg>Ignore when mode=-1</msg>
		<modified_files>
			<file old_path="vehicle\zmp\autoware_socket\cmd.cpp" new_path="vehicle\zmp\autoware_socket\cmd.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -182,7 +182,7 @@ void Update(void *p)
 void SetState(int mode, int gear, void* p) 
 {
   // 0=manual, 1=str, 2=drv, 3=str+drv
-  if (mode != current_mode) {
+  if (mode &gt;= 0 &amp;&amp; mode != current_mode) {
     current_mode = mode;
     pthread_create(&amp;_modesetter, NULL, MainWindow::ModeSetterEntry, p);
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="526d12b80d3cd71759b290c09724c28f85cf1516" author="tange">
		<msg>Added sys dialog of ssd node.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\ssd_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\ssd_node.cpp" added_lines="19" deleted_lines="6">
				<diff>@@ -30,7 +30,7 @@
 #include &lt;string&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
-//#include &lt;runtime_manager/ConfigRcnn.h&gt;
+#include &lt;runtime_manager/ConfigSsd.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;cv_tracker/image_obj.h&gt;
@@ -57,6 +57,9 @@ class RosSsdApp
 
 	//The minimum score required to filter the detected objects by the ConvNet
 	float score_threshold_;
+	std::string image_raw_topic_str;
+	std::string network_definition_file;
+	std::string pretrained_model_file;
 
 	//If GPU is enabled, stores the GPU Device to use
 	unsigned int gpu_device_id_;
@@ -136,6 +139,19 @@ class RosSsdApp
 	}
 
 
+	void config_cb(const runtime_manager::ConfigSsd::ConstPtr&amp; param)
+	{
+		score_threshold_ 	= param-&gt;score_threshold;
+		image_raw_topic_str 	= param-&gt;image_raw_topic_str;
+		network_definition_file	= param-&gt;network_definition_file;
+		pretrained_model_file	= param-&gt;pretrained_model_file;
+		use_gpu_ 		= param-&gt;use_gpu;
+		gpu_device_id_ 	 	= param-&gt;gpu_device_id;
+
+		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
+		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosSsdApp::image_callback, this);
+	}
+
 public:
 	void Run()
 	{
@@ -143,7 +159,6 @@ public:
 		ros::NodeHandle private_node_handle("~");//to receive args
 
 		//RECEIVE IMAGE TOPIC NAME
-		std::string image_raw_topic_str;
 		if (private_node_handle.getParam("image_raw_node", image_raw_topic_str))
 		{
 			ROS_INFO("Setting image node to %s", image_raw_topic_str.c_str());
@@ -155,8 +170,6 @@ public:
 		}
 
 		//RECEIVE CONVNET FILENAMES
-		std::string network_definition_file;
-		std::string pretrained_model_file;
 		if (private_node_handle.getParam("network_definition_file", network_definition_file))
 		{
 			ROS_INFO("Network Definition File: %s", network_definition_file.c_str());
@@ -208,8 +221,8 @@ public:
 		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
 		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosSsdApp::image_callback, this);
 
-		/*std::string config_topic("/config");	config_topic += ros::this_node::getNamespace() + "/ssd";
-		subscriber_ssd_config_ =node_handle_.subscribe(config_topic, 1, &amp;RosSsdApp::config_cb, this);*/
+		std::string config_topic("/config");	config_topic += ros::this_node::getNamespace() + "/ssd";
+		subscriber_ssd_config_ =node_handle_.subscribe(config_topic, 1, &amp;RosSsdApp::config_cb, this);
 
 		ros::spin();
 		ROS_INFO("END Ssd");
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1236c6232341da2fc6bf21e8758ac67fb6fe3161" author="tange">
		<msg>Reflected the results of the review.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\ssd_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\ssd_node.cpp" added_lines="21" deleted_lines="22">
				<diff>@@ -57,9 +57,9 @@ class RosSsdApp
 
 	//The minimum score required to filter the detected objects by the ConvNet
 	float score_threshold_;
-	std::string image_raw_topic_str;
-	std::string network_definition_file;
-	std::string pretrained_model_file;
+	std::string image_raw_topic_str_;
+	std::string network_definition_file_;
+	std::string pretrained_model_file_;
 
 	//If GPU is enabled, stores the GPU Device to use
 	unsigned int gpu_device_id_;
@@ -142,14 +142,12 @@ class RosSsdApp
 	void config_cb(const runtime_manager::ConfigSsd::ConstPtr&amp; param)
 	{
 		score_threshold_ 	= param-&gt;score_threshold;
-		image_raw_topic_str 	= param-&gt;image_raw_topic_str;
-		network_definition_file	= param-&gt;network_definition_file;
-		pretrained_model_file	= param-&gt;pretrained_model_file;
-		use_gpu_ 		= param-&gt;use_gpu;
-		gpu_device_id_ 	 	= param-&gt;gpu_device_id;
-
-		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
-		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosSsdApp::image_callback, this);
+		//image_raw_topic_str_		= param-&gt;image_raw_topic_str;
+		//network_definition_file_	= param-&gt;network_definition_file;
+		//pretrained_model_file_	= param-&gt;pretrained_model_file;
+		//use_gpu_ 			= param-&gt;use_gpu;
+		//gpu_device_id_ 	 	= param-&gt;gpu_device_id;
+
 	}
 
 public:
@@ -159,29 +157,29 @@ public:
 		ros::NodeHandle private_node_handle("~");//to receive args
 
 		//RECEIVE IMAGE TOPIC NAME
-		if (private_node_handle.getParam("image_raw_node", image_raw_topic_str))
+		if (private_node_handle.getParam("image_raw_node", image_raw_topic_str_))
 		{
-			ROS_INFO("Setting image node to %s", image_raw_topic_str.c_str());
+			ROS_INFO("Setting image node to %s", image_raw_topic_str_.c_str());
 		}
 		else
 		{
 			ROS_INFO("No image node received, defaulting to /image_raw, you can use _image_raw_node:=YOUR_TOPIC");
-			image_raw_topic_str = "/image_raw";
+			image_raw_topic_str_ = "/image_raw";
 		}
 
 		//RECEIVE CONVNET FILENAMES
-		if (private_node_handle.getParam("network_definition_file", network_definition_file))
+		if (private_node_handle.getParam("network_definition_file", network_definition_file_))
 		{
-			ROS_INFO("Network Definition File: %s", network_definition_file.c_str());
+			ROS_INFO("Network Definition File: %s", network_definition_file_.c_str());
 		}
 		else
 		{
 			ROS_INFO("No Network Definition File was received. Finishing execution.");
 			return;
 		}
-		if (private_node_handle.getParam("pretrained_model_file", pretrained_model_file))
+		if (private_node_handle.getParam("pretrained_model_file", pretrained_model_file_))
 		{
-			ROS_INFO("Pretrained Model File: %s", pretrained_model_file.c_str());
+			ROS_INFO("Pretrained Model File: %s", pretrained_model_file_.c_str());
 		}
 		else
 		{
@@ -206,7 +204,7 @@ public:
 		}
 
 		//SSD STUFF
-		ssd_detector_ = new SsdDetector(network_definition_file, pretrained_model_file, pixel_mean_, use_gpu_, gpu_device_id_);
+		ssd_detector_ = new SsdDetector(network_definition_file_, pretrained_model_file_, pixel_mean_, use_gpu_, gpu_device_id_);
 
 		if (NULL == ssd_detector_)
 		{
@@ -218,10 +216,11 @@ public:
 		publisher_car_objects_ = node_handle_.advertise&lt;cv_tracker::image_obj&gt;("/obj_car/image_obj", 1);
 		publisher_person_objects_ = node_handle_.advertise&lt;cv_tracker::image_obj&gt;("/obj_person/image_obj", 1);
 
-		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
-		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosSsdApp::image_callback, this);
+		ROS_INFO("Subscribing to... %s", image_raw_topic_str_.c_str());
+		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str_, 1, &amp;RosSsdApp::image_callback, this);
 
-		std::string config_topic("/config");	config_topic += ros::this_node::getNamespace() + "/ssd";
+		std::string config_topic("/config");
+		config_topic += "/ssd";
 		subscriber_ssd_config_ =node_handle_.subscribe(config_topic, 1, &amp;RosSsdApp::config_cb, this);
 
 		ros::spin();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="35dc261ee9e47326868031ce3975c1e77342473e" author="tange">
		<msg>Fixed an indication in review.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\ssd_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\ssd_node.cpp" added_lines="14" deleted_lines="20">
				<diff>@@ -57,9 +57,6 @@ class RosSsdApp
 
 	//The minimum score required to filter the detected objects by the ConvNet
 	float score_threshold_;
-	std::string image_raw_topic_str_;
-	std::string network_definition_file_;
-	std::string pretrained_model_file_;
 
 	//If GPU is enabled, stores the GPU Device to use
 	unsigned int gpu_device_id_;
@@ -142,12 +139,6 @@ class RosSsdApp
 	void config_cb(const runtime_manager::ConfigSsd::ConstPtr&amp; param)
 	{
 		score_threshold_ 	= param-&gt;score_threshold;
-		//image_raw_topic_str_		= param-&gt;image_raw_topic_str;
-		//network_definition_file_	= param-&gt;network_definition_file;
-		//pretrained_model_file_	= param-&gt;pretrained_model_file;
-		//use_gpu_ 			= param-&gt;use_gpu;
-		//gpu_device_id_ 	 	= param-&gt;gpu_device_id;
-
 	}
 
 public:
@@ -157,29 +148,32 @@ public:
 		ros::NodeHandle private_node_handle("~");//to receive args
 
 		//RECEIVE IMAGE TOPIC NAME
-		if (private_node_handle.getParam("image_raw_node", image_raw_topic_str_))
+		std::string image_raw_topic_str;
+		if (private_node_handle.getParam("image_raw_node", image_raw_topic_str))
 		{
-			ROS_INFO("Setting image node to %s", image_raw_topic_str_.c_str());
+			ROS_INFO("Setting image node to %s", image_raw_topic_str.c_str());
 		}
 		else
 		{
 			ROS_INFO("No image node received, defaulting to /image_raw, you can use _image_raw_node:=YOUR_TOPIC");
-			image_raw_topic_str_ = "/image_raw";
+			image_raw_topic_str = "/image_raw";
 		}
 
 		//RECEIVE CONVNET FILENAMES
-		if (private_node_handle.getParam("network_definition_file", network_definition_file_))
+		std::string network_definition_file;
+		std::string pretrained_model_file;
+		if (private_node_handle.getParam("network_definition_file", network_definition_file))
 		{
-			ROS_INFO("Network Definition File: %s", network_definition_file_.c_str());
+			ROS_INFO("Network Definition File: %s", network_definition_file.c_str());
 		}
 		else
 		{
 			ROS_INFO("No Network Definition File was received. Finishing execution.");
 			return;
 		}
-		if (private_node_handle.getParam("pretrained_model_file", pretrained_model_file_))
+		if (private_node_handle.getParam("pretrained_model_file", pretrained_model_file))
 		{
-			ROS_INFO("Pretrained Model File: %s", pretrained_model_file_.c_str());
+			ROS_INFO("Pretrained Model File: %s", pretrained_model_file.c_str());
 		}
 		else
 		{
@@ -204,7 +198,7 @@ public:
 		}
 
 		//SSD STUFF
-		ssd_detector_ = new SsdDetector(network_definition_file_, pretrained_model_file_, pixel_mean_, use_gpu_, gpu_device_id_);
+		ssd_detector_ = new SsdDetector(network_definition_file, pretrained_model_file, pixel_mean_, use_gpu_, gpu_device_id_);
 
 		if (NULL == ssd_detector_)
 		{
@@ -216,12 +210,12 @@ public:
 		publisher_car_objects_ = node_handle_.advertise&lt;cv_tracker::image_obj&gt;("/obj_car/image_obj", 1);
 		publisher_person_objects_ = node_handle_.advertise&lt;cv_tracker::image_obj&gt;("/obj_person/image_obj", 1);
 
-		ROS_INFO("Subscribing to... %s", image_raw_topic_str_.c_str());
-		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str_, 1, &amp;RosSsdApp::image_callback, this);
+		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
+		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosSsdApp::image_callback, this);
 
 		std::string config_topic("/config");
 		config_topic += "/ssd";
-		subscriber_ssd_config_ =node_handle_.subscribe(config_topic, 1, &amp;RosSsdApp::config_cb, this);
+		subscriber_ssd_config_ = node_handle_.subscribe(config_topic, 1, &amp;RosSsdApp::config_cb, this);
 
 		ros::spin();
 		ROS_INFO("END Ssd");
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="55c89faa26e92161111786fb2fdb4864c4902217" author="amc-nu">
		<msg>ROS Kinectic Upgrade tested on Ubuntu 16.04 and OpenCV 3.2.0
Modules not included:
-orb_localizer
-dpm_ocv node and lib

Everything else working

Added some libraries for Gazebo on src/extras</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\cpu\dpm_ocv_cpu.cpp" new_path="removed_kinect\lib_dpm_ocv\cpu\dpm_ocv_cpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\cuda_check.h" new_path="removed_kinect\lib_dpm_ocv\gpu\cuda_check.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\dpm_ocv_gpu.cpp" new_path="removed_kinect\lib_dpm_ocv\gpu\dpm_ocv_gpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\dpm_ocv_gpu.hpp" new_path="removed_kinect\lib_dpm_ocv\gpu\dpm_ocv_gpu.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\drvapi_error_string.h" new_path="removed_kinect\lib_dpm_ocv\gpu\drvapi_error_string.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\featurepyramid_gpu.cpp" new_path="removed_kinect\lib_dpm_ocv\gpu\featurepyramid_gpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\featurepyramid_gpu.hpp" new_path="removed_kinect\lib_dpm_ocv\gpu\featurepyramid_gpu.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\for_use_gpu.h" new_path="removed_kinect\lib_dpm_ocv\gpu\for_use_gpu.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\gpu_function.cu" new_path="removed_kinect\lib_dpm_ocv\gpu\gpu_function.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\gpu_init.cpp" new_path="removed_kinect\lib_dpm_ocv\gpu\gpu_init.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\gpu_matching.h" new_path="removed_kinect\lib_dpm_ocv\gpu\gpu_matching.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\matching_gpu.cpp" new_path="removed_kinect\lib_dpm_ocv\gpu\matching_gpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\matching_gpu.hpp" new_path="removed_kinect\lib_dpm_ocv\gpu\matching_gpu.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\resizeimg_gpu.cpp" new_path="removed_kinect\lib_dpm_ocv\gpu\resizeimg_gpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\resizeimg_gpu.h" new_path="removed_kinect\lib_dpm_ocv\gpu\resizeimg_gpu.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\routine_gpu.cpp" new_path="removed_kinect\lib_dpm_ocv\gpu\routine_gpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\routine_gpu.hpp" new_path="removed_kinect\lib_dpm_ocv\gpu\routine_gpu.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\include\dpm_ocv\dpm_ocv.hpp" new_path="removed_kinect\lib_dpm_ocv\include\dpm_ocv\dpm_ocv.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ocv\dpm_ocv.cpp" new_path="removed_kinect\node_dpm_ocv\dpm_ocv.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\BowVector.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\BowVector.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\BowVector.h" new_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\BowVector.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\DUtils\Random.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\DUtils\Random.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\DUtils\Random.h" new_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\DUtils\Random.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\DUtils\Timestamp.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\DUtils\Timestamp.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\DUtils\Timestamp.h" new_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\DUtils\Timestamp.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\FClass.h" new_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\FClass.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\FORB.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\FORB.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\FORB.h" new_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\FORB.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\FeatureVector.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\FeatureVector.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\FeatureVector.h" new_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\FeatureVector.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\ScoringObject.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\ScoringObject.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\ScoringObject.h" new_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\ScoringObject.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\TemplatedVocabulary.h" new_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\TemplatedVocabulary.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\bind.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\bind.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\boostd.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\boostd.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\condition_variable.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\condition_variable.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\function.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\function.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\glconsole.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\glconsole.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\glutbitmap.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\glutbitmap.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\memory.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\memory.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\mutex.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\mutex.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\ovr.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\ovr.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\thread.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\thread.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\type_traits.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\type_traits.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\console\ConsoleInterpreter.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\console\ConsoleInterpreter.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\console\ConsoleView.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\console\ConsoleView.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\attach.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\attach.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\device\display_glut.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\device\display_glut.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\display.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\display.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\display_internal.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\display_internal.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\opengl_render_state.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\opengl_render_state.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\user_app.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\user_app.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\view.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\view.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\viewport.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\viewport.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\widgets\widgets.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\widgets\widgets.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\cg.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\cg.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\colour.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\colour.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\compat\gl2engine.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\compat\gl2engine.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\compat\gl_es_compat.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\compat\gl_es_compat.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gl.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gl.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gl.hpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gl.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glchar.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glchar.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glcuda.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glcuda.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gldraw.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gldraw.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glfont.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glfont.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glformattraits.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glformattraits.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glglut.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glglut.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glinclude.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glinclude.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glpangoglu.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glpangoglu.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glpixformat.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glpixformat.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glplatform.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glplatform.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glsl.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glsl.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glstate.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glstate.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gltext.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gltext.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gltexturecache.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gltexturecache.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glvbo.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glvbo.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler_enums.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler_enums.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler_glbuffer.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler_glbuffer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler_image.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler_image.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\image\image.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\image\image.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\image\image_common.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\image\image_common.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\image\image_io.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\image\image_io.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\log\packetstream.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\log\packetstream.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\pangolin.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\pangolin.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\platform.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\platform.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\plot\datalog.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\plot\datalog.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\plot\plotter.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\plot\plotter.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\plot\range.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\plot\range.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\file_extension.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\file_extension.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\file_utils.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\file_utils.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\params.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\params.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\picojson.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\picojson.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\simple_math.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\simple_math.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\threadedfilebuf.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\threadedfilebuf.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\timer.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\timer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\type_convert.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\type_convert.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\uri.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\uri.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml.hpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml_iterators.hpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml_iterators.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml_print.hpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml_print.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml_utils.hpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml_utils.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\input_record_repeat.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\input_record_repeat.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\var.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\var.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varextra.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varextra.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varstate.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varstate.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varvalue.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varvalue.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varvaluegeneric.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varvaluegeneric.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varvaluet.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varvaluet.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varwrapper.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varwrapper.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\config.h.in" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\config.h.in" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\console\ConsoleView.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\console\ConsoleView.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\display\device\display_glut.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\display\device\display_glut.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\display\device\display_x11.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\display\device\display_x11.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\display\display.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\display\display.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\display\opengl_render_state.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\display\opengl_render_state.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\display\view.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\display\view.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\display\viewport.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\display\viewport.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\display\widgets\widgets.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\display\widgets\widgets.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\gl\compat\gl2engine.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\gl\compat\gl2engine.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\gl\glchar.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\gl\glchar.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\gl\glfont.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\gl\glfont.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\gl\glpangoglu.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\gl\glpangoglu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\gl\gltext.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\gl\gltext.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\gl\gltexturecache.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\gl\gltexturecache.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\gl\stb_truetype.h" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\gl\stb_truetype.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\handler\handler.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\handler\handler.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\handler\handler_glbuffer.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\handler\handler_glbuffer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\image\image_common.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\image\image_common.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\image\image_io.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\image\image_io.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\log\packetstream.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\log\packetstream.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\plot\datalog.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\plot\datalog.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\plot\plotter.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\plot\plotter.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\utils\file_extension.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\utils\file_extension.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\utils\file_utils.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\utils\file_utils.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\utils\threadedfilebuf.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\utils\threadedfilebuf.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\utils\uri.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\utils\uri.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\var\input_record_repeat.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\var\input_record_repeat.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\var\vars.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\var\vars.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\config.h.in" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\config.h.in" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_binary_edge.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_binary_edge.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_binary_edge.hpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_binary_edge.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_edge.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_edge.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_multi_edge.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_multi_edge.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_multi_edge.hpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_multi_edge.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_unary_edge.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_unary_edge.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_unary_edge.hpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_unary_edge.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_vertex.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_vertex.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_vertex.hpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_vertex.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\batch_stats.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\batch_stats.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\batch_stats.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\batch_stats.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\block_solver.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\block_solver.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\block_solver.hpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\block_solver.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\cache.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\cache.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\cache.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\cache.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\creators.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\creators.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\eigen_types.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\eigen_types.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\estimate_propagator.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\estimate_propagator.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\estimate_propagator.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\estimate_propagator.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\factory.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\factory.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\factory.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\factory.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\hyper_dijkstra.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\hyper_dijkstra.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\hyper_dijkstra.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\hyper_dijkstra.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph_action.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph_action.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph_action.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph_action.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\jacobian_workspace.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\jacobian_workspace.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\jacobian_workspace.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\jacobian_workspace.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\linear_solver.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\linear_solver.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\marginal_covariance_cholesky.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\marginal_covariance_cholesky.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\marginal_covariance_cholesky.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\marginal_covariance_cholesky.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\matrix_operations.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\matrix_operations.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\matrix_structure.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\matrix_structure.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\matrix_structure.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\matrix_structure.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\openmp_mutex.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\openmp_mutex.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimizable_graph.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimizable_graph.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimizable_graph.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimizable_graph.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_dogleg.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_dogleg.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_dogleg.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_dogleg.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_factory.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_factory.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_factory.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_factory.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_gauss_newton.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_gauss_newton.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_gauss_newton.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_gauss_newton.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_levenberg.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_levenberg.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_levenberg.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_levenberg.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_property.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_property.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_with_hessian.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_with_hessian.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_with_hessian.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_with_hessian.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\parameter.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\parameter.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\parameter.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\parameter.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\parameter_container.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\parameter_container.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\parameter_container.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\parameter_container.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_factory.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_factory.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_factory.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_factory.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_impl.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_impl.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_impl.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_impl.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\solver.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\solver.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\solver.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\solver.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix.hpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix_ccs.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix_ccs.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix_diagonal.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix_diagonal.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix_test.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix_test.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\sparse_optimizer.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\sparse_optimizer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\sparse_optimizer.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\sparse_optimizer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\solvers\linear_solver_dense.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\solvers\linear_solver_dense.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\solvers\linear_solver_eigen.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\solvers\linear_solver_eigen.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\color_macros.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\color_macros.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\macros.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\macros.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\misc.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\misc.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\os_specific.c" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\os_specific.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\os_specific.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\os_specific.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\property.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\property.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\property.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\property.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\string_tools.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\string_tools.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\string_tools.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\string_tools.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\timeutil.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\timeutil.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\timeutil.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\timeutil.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\se3_ops.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\se3_ops.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\se3_ops.hpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\se3_ops.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\se3quat.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\se3quat.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\sim3.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\sim3.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\types_sba.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\types_sba.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\types_sba.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\types_sba.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\types_seven_dof_expmap.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\types_seven_dof_expmap.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\types_seven_dof_expmap.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\types_seven_dof_expmap.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\types_six_dof_expmap.cpp" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\types_six_dof_expmap.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\types_six_dof_expmap.h" new_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\types_six_dof_expmap.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\cmake_modules\FindBLAS.cmake" new_path="removed_kinect\orb_localizer\cmake_modules\FindBLAS.cmake" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\cmake_modules\FindEigen3.cmake" new_path="removed_kinect\orb_localizer\cmake_modules\FindEigen3.cmake" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\cmake_modules\FindFREEGLUT.cmake" new_path="removed_kinect\orb_localizer\cmake_modules\FindFREEGLUT.cmake" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\cmake_modules\FindLAPACK.cmake" new_path="removed_kinect\orb_localizer\cmake_modules\FindLAPACK.cmake" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Converter.h" new_path="removed_kinect\orb_localizer\include\Converter.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Frame.h" new_path="removed_kinect\orb_localizer\include\Frame.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\FrameDrawer.h" new_path="removed_kinect\orb_localizer\include\FrameDrawer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Initializer.h" new_path="removed_kinect\orb_localizer\include\Initializer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\KeyFrame.h" new_path="removed_kinect\orb_localizer\include\KeyFrame.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\KeyFrameDatabase.h" new_path="removed_kinect\orb_localizer\include\KeyFrameDatabase.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\LocalMapping.h" new_path="removed_kinect\orb_localizer\include\LocalMapping.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\LoopClosing.h" new_path="removed_kinect\orb_localizer\include\LoopClosing.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Map.h" new_path="removed_kinect\orb_localizer\include\Map.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\MapDrawer.h" new_path="removed_kinect\orb_localizer\include\MapDrawer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\MapObjectSerialization.h" new_path="removed_kinect\orb_localizer\include\MapObjectSerialization.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\MapPoint.h" new_path="removed_kinect\orb_localizer\include\MapPoint.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\ORBVocabulary.h" new_path="removed_kinect\orb_localizer\include\ORBVocabulary.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\ORBextractor.h" new_path="removed_kinect\orb_localizer\include\ORBextractor.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\ORBmatcher.h" new_path="removed_kinect\orb_localizer\include\ORBmatcher.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Optimizer.h" new_path="removed_kinect\orb_localizer\include\Optimizer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\ParticleFilter.h" new_path="removed_kinect\orb_localizer\include\ParticleFilter.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\PnPsolver.h" new_path="removed_kinect\orb_localizer\include\PnPsolver.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Sim3Solver.h" new_path="removed_kinect\orb_localizer\include\Sim3Solver.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\System.h" new_path="removed_kinect\orb_localizer\include\System.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Tracking.h" new_path="removed_kinect\orb_localizer\include\Tracking.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Viewer.h" new_path="removed_kinect\orb_localizer\include\Viewer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\cvmat_serialization.h" new_path="removed_kinect\orb_localizer\include\cvmat_serialization.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\common.cpp" new_path="removed_kinect\orb_localizer\nodes\common.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\common.h" new_path="removed_kinect\orb_localizer\nodes\common.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\dumpmap\dumpmap.cc" new_path="removed_kinect\orb_localizer\nodes\dumpmap\dumpmap.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_evaluator\orb_evaluator.cpp" new_path="removed_kinect\orb_localizer\nodes\orb_evaluator\orb_evaluator.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_mapping\orb_mapping.cpp" new_path="removed_kinect\orb_localizer\nodes\orb_mapping\orb_mapping.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_matching\orb_matching.cpp" new_path="removed_kinect\orb_localizer\nodes\orb_matching\orb_matching.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Converter.cc" new_path="removed_kinect\orb_localizer\src\Converter.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Frame.cc" new_path="removed_kinect\orb_localizer\src\Frame.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\FrameDrawer.cc" new_path="removed_kinect\orb_localizer\src\FrameDrawer.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Initializer.cc" new_path="removed_kinect\orb_localizer\src\Initializer.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\KeyFrame.cc" new_path="removed_kinect\orb_localizer\src\KeyFrame.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\KeyFrameDatabase.cc" new_path="removed_kinect\orb_localizer\src\KeyFrameDatabase.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\LocalMapping.cc" new_path="removed_kinect\orb_localizer\src\LocalMapping.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\LoopClosing.cc" new_path="removed_kinect\orb_localizer\src\LoopClosing.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Map.cc" new_path="removed_kinect\orb_localizer\src\Map.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\MapDrawer.cc" new_path="removed_kinect\orb_localizer\src\MapDrawer.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\MapPoint.cc" new_path="removed_kinect\orb_localizer\src\MapPoint.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\ORBextractor.cc" new_path="removed_kinect\orb_localizer\src\ORBextractor.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\ORBmatcher.cc" new_path="removed_kinect\orb_localizer\src\ORBmatcher.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Optimizer.cc" new_path="removed_kinect\orb_localizer\src\Optimizer.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\PnPsolver.cc" new_path="removed_kinect\orb_localizer\src\PnPsolver.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Sim3Solver.cc" new_path="removed_kinect\orb_localizer\src\Sim3Solver.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\System.cc" new_path="removed_kinect\orb_localizer\src\System.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Tracking.cc" new_path="removed_kinect\orb_localizer\src\Tracking.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Viewer.cc" new_path="removed_kinect\orb_localizer\src\Viewer.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\ImageGrabber.cc" new_path="removed_kinect\orb_localizer\src\__nodes\ImageGrabber.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\ImageGrabber.h" new_path="removed_kinect\orb_localizer\src\__nodes\ImageGrabber.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\bag_mapper.cc" new_path="removed_kinect\orb_localizer\src\__nodes\bag_mapper.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\map_publisher.cc" new_path="removed_kinect\orb_localizer\src\__nodes\map_publisher.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mapper.cc" new_path="removed_kinect\orb_localizer\src\__nodes\mapper.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\DebugMT.cc" new_path="removed_kinect\orb_localizer\src\__nodes\mt\DebugMT.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\DebugMT.h" new_path="removed_kinect\orb_localizer\src\__nodes\mt\DebugMT.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\SystemMT.cc" new_path="removed_kinect\orb_localizer\src\__nodes\mt\SystemMT.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\SystemMT.h" new_path="removed_kinect\orb_localizer\src\__nodes\mt\SystemMT.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\TrackingThread.cc" new_path="removed_kinect\orb_localizer\src\__nodes\mt\TrackingThread.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\TrackingThread.h" new_path="removed_kinect\orb_localizer\src\__nodes\mt\TrackingThread.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\matching_mt.cc" new_path="removed_kinect\orb_localizer\src\__nodes\mt\matching_mt.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\offline_offset.cc" new_path="removed_kinect\orb_localizer\src\__nodes\offline_offset.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\utils.cc" new_path="removed_kinect\orb_localizer\src\__nodes\utils.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\utils.h" new_path="removed_kinect\orb_localizer\src\__nodes\utils.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\analysis\orbslam2_python.cc" new_path="removed_kinect\orb_localizer\src\analysis\orbslam2_python.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\dumpmap.cc" new_path="removed_kinect\orb_localizer\src\dumpmap.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\kf\src\kf.cpp" new_path="ros\src\computing\perception\detection\lib\image\kf\src\kf.cpp" added_lines="31" deleted_lines="18">
				<diff>@@ -47,7 +47,6 @@
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;opencv2/objdetect/objdetect.hpp&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
-#include &lt;opencv2/contrib/contrib.hpp&gt;
 #include &lt;opencv2/video/tracking.hpp&gt;
 #include &lt;opencv2/calib3d/calib3d.hpp&gt;
 
@@ -61,6 +60,18 @@
 #define SSTR( x ) dynamic_cast&lt; std::ostringstream &amp; &gt;( \
         ( std::ostringstream() &lt;&lt; std::dec &lt;&lt; x ) ).str()
 
+
+#include "gencolors.cpp"
+
+struct ObjectDetection_
+{
+	//ObjectDetection_();
+	//ObjectDetection_(const cv::Rect&amp; rect, float score, int classId=1);
+	cv::Rect rect;
+	float score;
+	int classID;
+};
+
 ros::Publisher image_objects;//ROS
 
 static int 			DEFAULT_LIFESPAN; //LIFESPAN of objects before stop being tracked, in frames
@@ -88,7 +99,7 @@ struct kstate
 	unsigned int		id;//id of this tracked object
 	cv::Mat			image;//image containing the detected and tracked object
 	int			lifespan;//remaining lifespan before deprecate
-	cv::LatentSvmDetector::ObjectDetection obj;//currently not used
+	//ObjectDetection_ obj;//currently not used
 	cv::Scalar	color;
 	int		real_data;
 	//std::vector&lt;KeyPoint&gt; orbKeypoints;
@@ -102,7 +113,7 @@ struct kstate
 std::vector&lt;kstate&gt; 	_kstates;
 std::vector&lt;bool&gt; 	_active;
 std::vector&lt;cv::Scalar&gt;	_colors;
-std::vector&lt;cv::LatentSvmDetector::ObjectDetection&gt; _dpm_detections;
+std::vector&lt;ObjectDetection_&gt; _dpm_detections;
 
 std::string object_type;
 std::vector&lt;float&gt; _ranges;
@@ -143,7 +154,7 @@ void getRectFromPoints(std::vector&lt; cv::Point2f &gt; corners, cv::Rect&amp; outBounding
 
 }
 
-bool orbMatch(cv::Mat&amp; inImageScene, cv::Mat&amp; inImageObj, cv::Rect&amp; outBoundingBox, unsigned int inMinMatches=2, float inKnnRatio=0.7)
+/*bool orbMatch(cv::Mat&amp; inImageScene, cv::Mat&amp; inImageObj, cv::Rect&amp; outBoundingBox, unsigned int inMinMatches=2, float inKnnRatio=0.7)
 {
 	//vector of keypoints
 	std::vector&lt; cv::KeyPoint &gt; keypointsO;
@@ -230,7 +241,7 @@ bool orbMatch(cv::Mat&amp; inImageScene, cv::Mat&amp; inImageObj, cv::Rect&amp; outBoundingB
 	}
 
 	return false;
-}
+}*/
 
 ///Returns true if an im1 is contained in im2 or viceversa
 bool crossCorr(cv::Mat im1, cv::Mat im2)
@@ -328,8 +339,8 @@ void posScaleToBbox(std::vector&lt;kstate&gt; kstates, std::vector&lt;kstate&gt;&amp; trackedDet
 			tmp.max_height = kstates[i].max_height;
 
 			//fill in also LAtentSvm object
-			tmp.obj.rect = tmp.pos;
-			tmp.obj.score = tmp.score;
+			//tmp.obj.rect = tmp.pos;
+			//tmp.obj.score = tmp.score;
 
 			if (tmp.pos.x &lt; 0)
 				tmp.pos.x = 0;
@@ -360,8 +371,8 @@ int getAvailableIndex(std::vector&lt;kstate&gt;&amp; kstates)
 	return cur_size;
 }
 
-void initTracking(cv::LatentSvmDetector::ObjectDetection object, std::vector&lt;kstate&gt;&amp; kstates,
-		  cv::LatentSvmDetector::ObjectDetection detection,
+void initTracking(ObjectDetection_ object, std::vector&lt;kstate&gt;&amp; kstates,
+		  ObjectDetection_ detection,
 		  cv::Mat&amp; image, std::vector&lt;cv::Scalar&gt; colors, float range)
 {
 	kstate new_state;
@@ -567,12 +578,12 @@ void ApplyNonMaximumSuppresion(std::vector&lt; kstate &gt;&amp; in_source, float in_nms_th
 	in_source = filtered_detections;
 }
 
-void doTracking(std::vector&lt;cv::LatentSvmDetector::ObjectDetection&gt;&amp; detections, int frameNumber,
+void doTracking(std::vector&lt;ObjectDetection_&gt;&amp; detections, int frameNumber,
 		std::vector&lt;kstate&gt;&amp; kstates, std::vector&lt;bool&gt;&amp; active, cv::Mat&amp; image,
 		std::vector&lt;kstate&gt;&amp; trackedDetections, std::vector&lt;cv::Scalar&gt; &amp; colors)
 {
-	std::vector&lt;cv::LatentSvmDetector::ObjectDetection&gt; objects;
-	//vector&lt;LatentSvmDetector::ObjectDetection&gt; tracked_objects;
+	std::vector&lt;ObjectDetection_&gt; objects;
+	//vector&lt;LatentSvmDetector::ObjectDetection_&gt; tracked_objects;
 	std::vector&lt;bool&gt; predict_indices;//this will correspond to kstates i
 	std::vector&lt;bool&gt; correct_indices;//this will correspond to kstates i
 	std::vector&lt;int&gt; correct_detection_indices;//this will correspond to kstates i, used to store the index of the corresponding object
@@ -620,10 +631,10 @@ void doTracking(std::vector&lt;cv::LatentSvmDetector::ObjectDetection&gt;&amp; detections,
 				cv::Rect boundingbox;
 				bool matched = false;
 				//try to match with previous frame
-				if ( !USE_ORB )
+				//if ( !USE_ORB )
 					matched = ( !alreadyMatched(j, already_matched) &amp;&amp; crossCorr(kstates[i].image, currentObjectROI));
-				else
-					matched = (!alreadyMatched(j, already_matched) &amp;&amp; orbMatch(currentObjectROI, kstates[i].image, boundingbox, ORB_MIN_MATCHES, ORB_KNN_RATIO));
+				//else
+				//	matched = (!alreadyMatched(j, already_matched) &amp;&amp; orbMatch(currentObjectROI, kstates[i].image, boundingbox, ORB_MIN_MATCHES, ORB_KNN_RATIO));
 
 				if(matched)
 				{
@@ -789,7 +800,7 @@ void publish_if_possible()
 	}
 }
 
-void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;cv::LatentSvmDetector::ObjectDetection&gt; detections,
+void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;ObjectDetection_&gt; detections,
 			 std::vector&lt;kstate&gt;&amp; kstates, std::vector&lt;bool&gt;&amp; active,
 			 std::vector&lt;cv::Scalar&gt; colors, const sensor_msgs::Image&amp; image_source)
 {
@@ -888,7 +899,9 @@ void detections_callback(cv_tracker::image_obj_ranged image_objects_msg)
 			tmp.y = objects.at(i).rect.y;
 			tmp.width = objects.at(i).rect.width;
 			tmp.height = objects.at(i).rect.height;
-			_dpm_detections.push_back(cv::LatentSvmDetector::ObjectDetection(tmp, 0));
+			ObjectDetection_ obj_tmp;
+			obj_tmp.rect = tmp; obj_tmp.score=0;
+			_dpm_detections.push_back(obj_tmp);
 			_ranges.push_back(objects.at(i).range);
 			_min_heights.push_back(objects.at(i).min_height);
 			_max_heights.push_back(objects.at(i).max_height);
@@ -947,7 +960,7 @@ int kf_main(int argc, char* argv[])
 
 	image_objects = n.advertise&lt;cv_tracker::image_obj_tracked&gt;("image_obj_tracked", 1);
 
-	cv::generateColors(_colors, 25);
+	generateColors(_colors, 25);
 
 	std::string image_topic;
 	std::string obj_topic;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\lib\lktracker\LkTracker.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\lib\lktracker\LkTracker.cpp" added_lines="15" deleted_lines="11">
				<diff>@@ -22,7 +22,7 @@ LkTracker::LkTracker(int in_id, float in_min_height, float in_max_height, float
 	previous_centroid_x_	= 0;
 	previous_centroid_y_	= 0;
 
-	cv::generateColors(colors_, 2);
+	generateColors(colors_, 2);
 	lifespan_				= 45;
 	DEFAULT_LIFESPAN_		= 45;
 	object_id				= in_id;
@@ -31,7 +31,7 @@ LkTracker::LkTracker(int in_id, float in_min_height, float in_max_height, float
 	max_height_ 			= in_max_height;
 	range_					= in_range;
 }
-cv::LatentSvmDetector::ObjectDetection LkTracker::GetTrackedObject()
+ObjectDetection LkTracker::GetTrackedObject()
 {
 	return current_rect_;
 }
@@ -53,7 +53,7 @@ void LkTracker::ArrowedLine(cv::Mat&amp; in_image, cv::Point in_point1, cv::Point in
 	cv::line(in_image, p, in_point2, in_color, in_thickness, in_line_type, in_shift);
 }
 
-void OrbFeatures(cv::Mat in_image)
+/*void OrbFeatures(cv::Mat in_image)
 {
 	cv::OrbFeatureDetector orb(500);
 	std::vector&lt; cv::KeyPoint &gt; keypoints;
@@ -69,7 +69,7 @@ void OrbFeatures(cv::Mat in_image)
 	bow_trainer.add(descriptors);
 
 	cv::Mat vocabulary = bow_trainer.cluster();
-}
+}*/
 
 unsigned int	LkTracker::GetRemainingLifespan()
 {
@@ -86,15 +86,15 @@ unsigned long int LkTracker::GetFrameCount()
 	return frame_count_;
 }
 
-cv::Mat LkTracker::Track(cv::Mat in_image, cv::LatentSvmDetector::ObjectDetection in_detection, bool in_update)
+cv::Mat LkTracker::Track(cv::Mat in_image, ObjectDetection in_detection, bool in_update)
 {
 	cv::Mat gray_image;
 	//cv::cvtColor(in_image, in_image, cv::COLOR_RGB2BGR);
 	cv::cvtColor(in_image, gray_image, cv::COLOR_BGR2GRAY);
 	cv::Mat mask(gray_image.size(), CV_8UC1);
-	cv::TickMeter timer;
+	//cv::TickMeter timer;
 
-	timer.start();
+	//timer.start();
 
 	if (in_update &amp;&amp; in_detection.rect.width &gt; 0)
 	{
@@ -130,7 +130,8 @@ cv::Mat LkTracker::Track(cv::Mat in_image, cv::LatentSvmDetector::ObjectDetectio
 								0.04);				//harris detector free parameter
 		if (current_points_.size()&lt;=0)
 		{
-			current_rect_ = cv::LatentSvmDetector::ObjectDetection(cv::Rect(0,0,0,0),0,0);
+			ObjectDetection tmp_det; tmp_det.rect = cv::Rect(0,0,0,0); tmp_det.score=0;
+			current_rect_ = tmp_det;
 			return in_image;
 		}
 		cv::cornerSubPix(gray_image,
@@ -199,7 +200,9 @@ cv::Mat LkTracker::Track(cv::Mat in_image, cv::LatentSvmDetector::ObjectDetectio
 	}
 	if (valid_points.size()&lt;=2)
 	{
-		current_rect_ = cv::LatentSvmDetector::ObjectDetection(cv::Rect(0,0,0,0),0,0);
+		ObjectDetection tmp_det; tmp_det.rect = cv::Rect(0,0,0,0); tmp_det.score=0;
+		current_rect_ = tmp_det;
+		
 		return in_image;
 	}
 	frame_count_++;
@@ -277,7 +280,8 @@ cv::Mat LkTracker::Track(cv::Mat in_image, cv::LatentSvmDetector::ObjectDetectio
 		//std::cout &lt;&lt; "TRACK STOPPED" &lt;&lt; std::endl;
 		prev_points_.clear();
 		current_points_.clear();
-		current_rect_ = cv::LatentSvmDetector::ObjectDetection(cv::Rect(0,0,0,0),0,0);
+		ObjectDetection tmp_det; tmp_det.rect = cv::Rect(0,0,0,0); tmp_det.score=0;
+		current_rect_ = tmp_det;
 		return in_image;
 	}
 
@@ -308,7 +312,7 @@ cv::Mat LkTracker::Track(cv::Mat in_image, cv::LatentSvmDetector::ObjectDetectio
 		previous_centroid_y_ = current_centroid_y_;
 	}
 
-	timer.stop();
+	//timer.stop();
 
 	//std::cout &lt;&lt; timer.getTimeMilli() &lt;&lt; std::endl;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\lib\lktracker\LkTracker.hpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\lib\lktracker\LkTracker.hpp" added_lines="15" deleted_lines="5">
				<diff>@@ -9,11 +9,21 @@
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;opencv2/objdetect/objdetect.hpp&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
-#include &lt;opencv2/contrib/contrib.hpp&gt;
+//#include &lt;opencv2/contrib/contrib.hpp&gt;
 #include &lt;opencv2/video/tracking.hpp&gt;
 #include &lt;opencv2/calib3d/calib3d.hpp&gt;
 #include &lt;opencv2/features2d/features2d.hpp&gt;
 
+#include "gencolors.cpp"
+
+struct ObjectDetection
+{
+	//ObjectDetection();
+	//ObjectDetection(const cv::Rect&amp; rect, float score, int classId=1);
+	cv::Rect rect;
+	float score;
+	int classID;
+};
 
 class LkTracker
 {
@@ -32,8 +42,8 @@ class LkTracker
 	cv::Size 				sub_pixel_window_size_;
 	cv::Size 				window_size_;
 
-	cv::LatentSvmDetector::ObjectDetection	matched_detection_;
-	cv::LatentSvmDetector::ObjectDetection	current_rect_;//stores the current tracked object
+	ObjectDetection	matched_detection_;
+	ObjectDetection	current_rect_;//stores the current tracked object
 
 	int 					current_centroid_x_;
 	int 					current_centroid_y_;
@@ -57,8 +67,8 @@ public:
 
 
 	LkTracker(int in_id, float in_min_height, float in_max_height, float in_range);
-	cv::Mat 								Track(cv::Mat image, cv::LatentSvmDetector::ObjectDetection in_detections, bool in_update);
-	cv::LatentSvmDetector::ObjectDetection	GetTrackedObject();
+	cv::Mat 								Track(cv::Mat image, ObjectDetection in_detections, bool in_update);
+	ObjectDetection	GetTrackedObject();
 	unsigned int							GetRemainingLifespan();
 	void 									NullifyLifespan();
 	unsigned long int						GetFrameCount();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\kf_track\kf_track.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\kf_track\kf_track.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -30,7 +30,7 @@
 
 #include &lt;string&gt;
 #include &lt;ros/ros.h&gt;
-#include &lt;libdpm_ocv/ImageObjects.h&gt;
+#include &lt;cv_tracker/ImageObjects.h&gt;
 
 extern int kf_main(int argc, char* argv[]);
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\klt_track\klt_track.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\klt_track\klt_track.cpp" added_lines="13" deleted_lines="7">
				<diff>@@ -45,7 +45,7 @@
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;opencv2/objdetect/objdetect.hpp&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
-#include &lt;opencv2/contrib/contrib.hpp&gt;
+//#include &lt;opencv2/contrib/contrib.hpp&gt;
 #include &lt;opencv2/video/tracking.hpp&gt;
 #include &lt;opencv2/calib3d/calib3d.hpp&gt;
 
@@ -59,6 +59,7 @@
 #include &lt;algorithm&gt;
 #include &lt;iterator&gt;
 
+#include "gencolors.cpp"
 
 class RosTrackerApp
 {
@@ -78,7 +79,7 @@ class RosTrackerApp
 	int					num_trackers_;
 
 	std::vector&lt;LkTracker*&gt; obj_trackers_;
-	std::vector&lt;cv::LatentSvmDetector::ObjectDetection&gt; obj_detections_;
+	std::vector&lt;ObjectDetection&gt; obj_detections_;
 
 	std::vector&lt;float&gt; ranges_;
 	std::vector&lt;float&gt; min_heights_;
@@ -121,7 +122,7 @@ class RosTrackerApp
 
 		for(unsigned int i = 0; i&lt; in_out_source.size(); i++)
 		{
-			cv::LatentSvmDetector::ObjectDetection tmp = in_out_source[i]-&gt;GetTrackedObject();
+			ObjectDetection tmp = in_out_source[i]-&gt;GetTrackedObject();
 			area[i] = tmp.rect.width * tmp.rect.height;
 			if (area[i]&gt;0)
 				is_suppresed[i] = false;
@@ -187,7 +188,10 @@ public:
 	{
 		cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
 		cv::Mat image_track = cv_image-&gt;image;
-		cv::LatentSvmDetector::ObjectDetection empty_detection(cv::Rect(0,0,0,0),0,0);
+		
+		ObjectDetection empty_detection;
+		empty_detection.rect=cv::Rect(0,0,0,0);
+		empty_detection.score=0;
 		unsigned int i;
 
 		std::vector&lt;bool&gt; tracker_matched(obj_trackers_.size(), false);
@@ -201,7 +205,7 @@ public:
 				if (tracker_matched[j] || object_matched[i])
 					continue;
 
-				cv::LatentSvmDetector::ObjectDetection tmp_detection = obj_detections_[i];
+				ObjectDetection tmp_detection = obj_detections_[i];
 				int area = tmp_detection.rect.width * tmp_detection.rect.height;
 				cv::Rect intersection = tmp_detection.rect &amp; obj_trackers_[j]-&gt;GetTrackedObject().rect;
 				if ( (intersection.width * intersection.height) &gt; area*0.3 )
@@ -333,7 +337,9 @@ public:
 				tmp.y = objects.at(i).rect.y;
 				tmp.width = objects.at(i).rect.width;
 				tmp.height = objects.at(i).rect.height;
-				obj_detections_.push_back(cv::LatentSvmDetector::ObjectDetection(tmp, 0));
+				ObjectDetection tmp_obj;
+				tmp_obj.rect=tmp; tmp_obj.score=0;
+				obj_detections_.push_back(tmp_obj);
 				ranges_.push_back(objects.at(i).range);
 				min_heights_.push_back(objects.at(i).min_height);
 				max_heights_.push_back(objects.at(i).max_height);
@@ -362,7 +368,7 @@ public:
 			tmp.y = objects.at(i).y;
 			tmp.width = objects.at(i).width;
 			tmp.height = objects.at(i).height;
-			obj_detections_.push_back(cv::LatentSvmDetector::ObjectDetection(tmp, 0));
+			obj_detections_.push_back(ObjectDetection(tmp, 0));
 		}
 		ready_ = true;
 	}*/
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" added_lines="4" deleted_lines="2">
				<diff>@@ -1,7 +1,9 @@
 #include "draw_rects.h"
 #include &lt;string&gt;
 #include &lt;vector&gt;
-#include &lt;opencv2/contrib/contrib.hpp&gt;
+//#include &lt;opencv2/contrib/contrib.hpp&gt;
+#include "gencolors.cpp"
+
 
 namespace integrated_viewer
 {
@@ -11,7 +13,7 @@ namespace integrated_viewer
   
   DrawRects::DrawRects(void) {
     // Generate color map to represent tracked object
-    cv::generateColors(color_map_, 25);
+    generateColors(color_map_, 25);
 
   } // DrawRects::DrawRects()
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -1,6 +1,7 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
+#include &lt;opencv2/imgcodecs/imgcodecs.hpp&gt;
 #include &lt;QString&gt;
 #include &lt;QImage&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\traffic_light_plugin\traffic_light_plugin.cpp" added_lines="3" deleted_lines="2">
				<diff>@@ -1,7 +1,8 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;runtime_manager/traffic_light.h&gt;
-#include &lt;opencv/cv.h&gt;
-#include &lt;opencv/highgui.h&gt;
+#include &lt;opencv2/core/core.hpp&gt;
+#include &lt;opencv2/highgui/highgui.hpp&gt;
+#include &lt;opencv2/imgproc/imgproc.hpp&gt;
 #include &lt;QString&gt;
 #include &lt;QImage&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" added_lines="3" deleted_lines="2">
				<diff>@@ -49,7 +49,8 @@
 
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
-#include &lt;opencv2/contrib/contrib.hpp&gt;
+//#include &lt;opencv2/contrib/contrib.hpp&gt;
+#include "gencolors.cpp"
 
 #include &lt;chrono&gt;
 #include &lt;iostream&gt;
@@ -675,7 +676,7 @@ int main (int argc, char** argv)
 	_transform = &amp;transform;
 	_transform_listener = &amp;listener;
 
-	cv::generateColors(_colors, 100);
+	generateColors(_colors, 100);
 
 	_pub_cluster_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_cluster",1);
 	_pub_ground_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_ground",1);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\tunerBody.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\tunerBody.cpp" added_lines="12" deleted_lines="12">
				<diff>@@ -396,63 +396,63 @@ void TunerBody::saveResult(std::string fileName)
 
   /* write data to file */
   {
-    cv::WriteStructContext st_red(cvfs, "RED", CV_NODE_MAP);
+    cv::internal::WriteStructContext st_red(cvfs, "RED", CV_NODE_MAP);
     {
-      cv::WriteStructContext st_hue(cvfs, "Hue", CV_NODE_MAP);
+      cv::internal::WriteStructContext st_hue(cvfs, "Hue", CV_NODE_MAP);
       cv::write(cvfs, "center", Red_set.hue.center);
       cv::write(cvfs, "range", Red_set.hue.range);
     }
 
     {
-      cv::WriteStructContext st_hue(cvfs, "Saturation", CV_NODE_MAP);
+      cv::internal::WriteStructContext st_hue(cvfs, "Saturation", CV_NODE_MAP);
       cv::write(cvfs, "center", Red_set.sat.center);
       cv::write(cvfs, "range", Red_set.sat.range);
     }
 
     {
-      cv::WriteStructContext st_hue(cvfs, "Value", CV_NODE_MAP);
+      cv::internal::WriteStructContext st_hue(cvfs, "Value", CV_NODE_MAP);
       cv::write(cvfs, "center", Red_set.val.center);
       cv::write(cvfs, "range", Red_set.val.range);
     }
   }
 
   {
-    cv::WriteStructContext st_yellow(cvfs, "YELLOW", CV_NODE_MAP);
+    cv::internal::WriteStructContext st_yellow(cvfs, "YELLOW", CV_NODE_MAP);
     {
-      cv::WriteStructContext st_hue(cvfs, "Hue", CV_NODE_MAP);
+      cv::internal::WriteStructContext st_hue(cvfs, "Hue", CV_NODE_MAP);
       cv::write(cvfs, "center", Yellow_set.hue.center);
       cv::write(cvfs, "range", Yellow_set.hue.range);
     }
 
     {
-      cv::WriteStructContext st_hue(cvfs, "Saturation", CV_NODE_MAP);
+      cv::internal::WriteStructContext st_hue(cvfs, "Saturation", CV_NODE_MAP);
       cv::write(cvfs, "center", Yellow_set.sat.center);
       cv::write(cvfs, "range", Yellow_set.sat.range);
     }
 
     {
-      cv::WriteStructContext st_hue(cvfs, "Value", CV_NODE_MAP);
+      cv::internal::WriteStructContext st_hue(cvfs, "Value", CV_NODE_MAP);
       cv::write(cvfs, "center", Yellow_set.val.center);
       cv::write(cvfs, "range", Yellow_set.val.range);
     }
   }
 
   {
-    cv::WriteStructContext st_green(cvfs, "GREEN", CV_NODE_MAP);
+    cv::internal::WriteStructContext st_green(cvfs, "GREEN", CV_NODE_MAP);
     {
-      cv::WriteStructContext st_hue(cvfs, "Hue", CV_NODE_MAP);
+      cv::internal::WriteStructContext st_hue(cvfs, "Hue", CV_NODE_MAP);
       cv::write(cvfs, "center", Green_set.hue.center);
       cv::write(cvfs, "range", Green_set.hue.range);
     }
 
     {
-      cv::WriteStructContext st_hue(cvfs, "Saturation", CV_NODE_MAP);
+      cv::internal::WriteStructContext st_hue(cvfs, "Saturation", CV_NODE_MAP);
       cv::write(cvfs, "center", Green_set.sat.center);
       cv::write(cvfs, "range", Green_set.sat.range);
     }
 
     {
-      cv::WriteStructContext st_hue(cvfs, "Value", CV_NODE_MAP);
+      cv::internal::WriteStructContext st_hue(cvfs, "Value", CV_NODE_MAP);
       cv::write(cvfs, "center", Green_set.val.center);
       cv::write(cvfs, "range", Green_set.val.range);
     }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\image_viewer\image_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\image_viewer\image_viewer.cpp" added_lines="3" deleted_lines="4">
				<diff>@@ -31,9 +31,8 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
-#include &lt;opencv/cv.h&gt;
-#include &lt;opencv/highgui.h&gt;
-#include &lt;opencv2/contrib/contrib.hpp&gt;
+//#include &lt;opencv2/contrib/contrib.hpp&gt;
+#include "gencolors.cpp"
 
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
@@ -293,7 +292,7 @@ int main(int argc, char **argv)
 		image_topic_name = "/image_raw";
 	}
 
-	cv::generateColors(_colors, 25);
+	generateColors(_colors, 25);
 
 	ros::Subscriber scriber = n.subscribe(image_topic_name, 1, image_viewer_callback);
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" added_lines="4" deleted_lines="3">
				<diff>@@ -31,7 +31,8 @@
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
 #include &lt;opencv2/opencv.hpp&gt;
-#include &lt;opencv2/contrib/contrib.hpp&gt;
+//#include &lt;opencv2/contrib/contrib.hpp&gt;
+#include "gencolors.cpp"
 
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
@@ -178,7 +179,7 @@ void show(void)
   cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_msg, encoding);
   IplImage frame = cv_image-&gt;image;
 
-  cv::Mat matImage(&amp;frame, false);
+  cv::Mat matImage = cv::cvarrToMat(&amp;frame);//(&amp;frame, false);
 
   /* DRAW RECTANGLES of detected objects */
 #if 0
@@ -366,7 +367,7 @@ int main(int argc, char **argv)
     points_node = "/points_image";
   }
 
-  cv::generateColors(_colors, 25);
+  generateColors(_colors, 25);
 
   ros::Subscriber scriber = n.subscribe(image_topic_name, 1,
                                         image_cb);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\points_image_viewer\points_image_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\points_image_viewer\points_image_viewer.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -58,7 +58,7 @@ static void show(void)
 	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_msg, encoding);
 	IplImage frame = cv_image-&gt;image;
 
-	cv::Mat matImage(&amp;frame, false);
+	cv::Mat matImage = cv::cvarrToMat(&amp;frame);//(&amp;frame, false);
 
 	int w = matImage.size().width;
 	int h = matImage.size().height;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\traffic_light_viewer\traffic_light_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\traffic_light_viewer\traffic_light_viewer.cpp" added_lines="3" deleted_lines="2">
				<diff>@@ -1,7 +1,8 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;runtime_manager/traffic_light.h&gt;
-#include &lt;opencv/cv.h&gt;
-#include &lt;opencv/highgui.h&gt;
+#include &lt;opencv2/core/core.hpp&gt;
+#include &lt;opencv2/highgui/highgui.hpp&gt;
+#include &lt;opencv2/imgproc/imgproc.hpp&gt;
 
 #define WINDOW_NAME "traffic light detection result"
 #define WINDOW_SIZE 500
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" added_lines="6" deleted_lines="2">
				<diff>@@ -41,6 +41,10 @@
 #include &lt;math.h&gt;
 #include &lt;float.h&gt;
 
+#include &lt;opencv2/core/core.hpp&gt;
+
+#include "gencolors.cpp"
+
 #define NO_DATA 0
 static char window_name[] = "vscan_image_d_viewer";
 
@@ -148,7 +152,7 @@ static void show(void)
 	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_msg, encoding);
 	IplImage frame = cv_image-&gt;image;
 
-	cv::Mat matImage(&amp;frame, false);
+	cv::Mat matImage=cv::cvarrToMat(&amp;frame);//(&amp;frame, false);
 
 	//Draw VScan Points
 	drawVScanPoints(matImage);
@@ -253,7 +257,7 @@ int main(int argc, char **argv)
 		points_node = "/vscan_image";
 	}
 
-	cv::generateColors(_colors, 25);
+	generateColors(_colors, 25);
 
 	ros::Subscriber scriber = n.subscribe(image_topic_name, 1,
 					    image_cb);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\vscan_image_viewer\vscan_image_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\vscan_image_viewer\vscan_image_viewer.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -57,7 +57,7 @@ static void show(void)
 	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_msg, encoding);
 	IplImage frame = cv_image-&gt;image;
 
-	cv::Mat matImage(&amp;frame, false);
+	cv::Mat matImage=cv::cvarrToMat(&amp;frame);//(&amp;frame, false);
 
 	int w = matImage.size().width;
 	int h = matImage.size().height;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping_tku\ndt_mapping_tku.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping_tku\ndt_mapping_tku.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -582,7 +582,7 @@ int inv_check(double inv[3][3])
   {
     for (int j = 0; j &lt; 3; j++)
     {
-      if (isnan(inv[i][j]))
+      if (std::isnan(inv[i][j]))
         return 0;
       if (fabs(inv[i][j]) &gt; 1000)
         return 0;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching_tku\ndt_matching_tku.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching_tku\ndt_matching_tku.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -582,7 +582,7 @@ int inv_check(double inv[3][3])
   {
     for (int j = 0; j &lt; 3; j++)
     {
-      if (isnan(inv[i][j]))
+      if (std::isnan(inv[i][j]))
         return 0;
       if (fabs(inv[i][j]) &gt; 1000)
         return 0;
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\CalibrationToolkit\calibrationtoolkit.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\CalibrationToolkit\calibrationtoolkit.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -344,8 +344,8 @@ bool CalibrateCameraChessboardBase::calibrateSensor()
     {
         return 0;
     }
-    cv::vector&lt;cv::Mat&gt; rvecs;
-    cv::vector&lt;cv::Mat&gt; tvecs;
+    std::vector&lt;cv::Mat&gt; rvecs;
+    std::vector&lt;cv::Mat&gt; tvecs;
     cv::Size imgsize;
     imgsize.height=calibimages[0].rows;
     imgsize.width=calibimages[0].cols;
@@ -458,7 +458,7 @@ int CalibrateCameraChessboardBase::getChessboardNum()
     return chessboardposes.size();
 }
 
-cv::vector&lt;cv::Mat&gt; CalibrateCameraChessboardBase::getChessboardPoses()
+std::vector&lt;cv::Mat&gt; CalibrateCameraChessboardBase::getChessboardPoses()
 {
     return chessboardposes;
 }
@@ -508,7 +508,7 @@ bool CalibrateCameraChessboardROS::refreshImage()
 bool CalibrateCameraChessboardROS::grabCalibData()
 {
     camerasub-&gt;stopReceiveSlot();
-    cv::vector&lt;cv::Point2f&gt; grid2dpoint;
+    std::vector&lt;cv::Point2f&gt; grid2dpoint;
     CHESSBOARDTYPE boardtype=CHESSBOARDTYPE(chessboardtype-&gt;currentIndex());
     bool found=false;
     switch(boardtype)
@@ -662,7 +662,7 @@ void CalibrateCameraVelodyneChessboardBase::projectPointsSlot()
             camerapoints.at&lt;double&gt;(j,2)=double(calibvelodynespoints[i]-&gt;points[j].z);
         }
         camerapoints=camerapoints*invR.t()+cv::Mat::ones(m,1,CV_64F)*invT.t();
-        cv::vector&lt;cv::Point2d&gt; planepoints;
+        std::vector&lt;cv::Point2d&gt; planepoints;
         planepoints.resize(m);
         for(j=0;j&lt;m;j++)
         {
@@ -1177,7 +1177,7 @@ bool CalibrateCameraVelodyneChessboardROS::grabCalibData()
     camerasub-&gt;stopReceiveSlot();
     velodynesub-&gt;stopReceiveSlot();
 
-    cv::vector&lt;cv::Point2f&gt; grid2dpoint;
+    std::vector&lt;cv::Point2f&gt; grid2dpoint;
     CHESSBOARDTYPE boardtype=CHESSBOARDTYPE(chessboardtype-&gt;currentIndex());
     bool found=false;
     switch(boardtype)
@@ -1344,7 +1344,7 @@ void CalibrateCameraLidarChessboardBase::projectPointsSlot()
             camerapoints.at&lt;double&gt;(j,2)=double(0);
         }
         camerapoints=camerapoints*invR.t()+cv::Mat::ones(m,1,CV_64F)*invT.t();
-        cv::vector&lt;cv::Point2d&gt; planepoints;
+        std::vector&lt;cv::Point2d&gt; planepoints;
         planepoints.resize(m);
         for(j=0;j&lt;m;j++)
         {
@@ -1658,7 +1658,7 @@ bool CalibrateCameraLidarChessboardROS::grabCalibData()
     camerasub-&gt;stopReceiveSlot();
     lidarsub-&gt;stopReceiveSlot();
 
-    cv::vector&lt;cv::Point2f&gt; grid2dpoint;
+    std::vector&lt;cv::Point2f&gt; grid2dpoint;
     CHESSBOARDTYPE boardtype=CHESSBOARDTYPE(chessboardtype-&gt;currentIndex());
     bool found=false;
     switch(boardtype)
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\CalibrationToolkit\calibrationtoolkit.h" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\CalibrationToolkit\calibrationtoolkit.h" added_lines="7" deleted_lines="7">
				<diff>@@ -136,9 +136,9 @@ protected:
     cv::Size2i patternnum;
     cv::Size2f patternsize;
 
-    cv::vector&lt;cv::Point3f&gt; grid3dpoint;
-    cv::vector&lt;cv::vector&lt;cv::Point3f&gt; &gt; grid3dpoints;
-    cv::vector&lt;cv::vector&lt;cv::Point2f&gt; &gt; grid2dpoints;
+    std::vector&lt;cv::Point3f&gt; grid3dpoint;
+    std::vector&lt;std::vector&lt;cv::Point3f&gt; &gt; grid3dpoints;
+    std::vector&lt;std::vector&lt;cv::Point2f&gt; &gt; grid2dpoints;
 
     enum CHESSBOARDTYPE
     {
@@ -149,12 +149,12 @@ protected:
     QComboBox * chessboardtype;
 
     QTabWidget * chessboardtab;
-    cv::vector&lt;cv::Mat&gt; chessboardposes;
+    std::vector&lt;cv::Mat&gt; chessboardposes;
     QTabWidget * chessboardposeshow;
     double reprojectionerror;
     QLabel * reprojectionerrorshow;
 
-    cv::vector&lt;cv::Mat&gt; calibimages;
+    std::vector&lt;cv::Mat&gt; calibimages;
     QTabWidget * calibimagesshow;
 protected:
     bool removeCalibData();
@@ -163,7 +163,7 @@ protected:
     bool saveCalibResult(cv::FileStorage &amp; fs);
 public:
     int getChessboardNum();
-    cv::vector&lt;cv::Mat&gt; getChessboardPoses();
+    std::vector&lt;cv::Mat&gt; getChessboardPoses();
     cv::Mat getChessboardPose(int id);
     cv::Mat getCalibImage(int id);
 };
@@ -191,7 +191,7 @@ public:
     {
         cv::Mat chessboardnormals;   //n*3
         cv::Mat chessboardpoints;    //n*3
-        cv::vector&lt;cv::Mat&gt; velodynepoints; //n*m*3
+        std::vector&lt;cv::Mat&gt; velodynepoints; //n*m*3
         cv::Mat velodynenormals;
         cv::Mat rotationresult;
     };
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\camera_lidar2d_offline_calib.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\camera_lidar2d_offline_calib.cpp" added_lines="12" deleted_lines="9">
				<diff>@@ -35,9 +35,6 @@
 #include &lt;time.h&gt;
 
 #include &lt;math.h&gt;
-#include &lt;opencv/cv.h&gt;
-#include &lt;opencv/highgui.h&gt;
-#include &lt;opencv/cxcore.h&gt;
 #include "ros/ros.h"
 #include &lt;libxml/xmlreader.h&gt;
 #include &lt;image_transport/image_transport.h&gt;
@@ -53,6 +50,8 @@
 #include "common_2d_calib.h"
 #include "image_window.h"
 #include "data_struct.h"
+#include &lt;opencv/highgui.h&gt;
+#include "opencv2/highgui/highgui.hpp"
 
 #define XSTR(x) #x
 #define STR(x) XSTR(x)
@@ -88,7 +87,7 @@ static void on_mouse(int event, int x, int y, int flags, void *param = NULL)
         g_on_calib_flag = true;
         g_on_save_flag = false;
         switch(event) {
-        case CV_EVENT_LBUTTONDOWN:
+        case cv::EVENT_LBUTTONDOWN:
             g_calib_flag = true;
             break;
 
@@ -99,7 +98,7 @@ static void on_mouse(int event, int x, int y, int flags, void *param = NULL)
         g_on_save_flag = true;
         g_on_calib_flag = false;
         switch(event) {
-        case CV_EVENT_LBUTTONDOWN:
+        case cv::EVENT_LBUTTONDOWN:
             g_save_flag = true;
             break;
 
@@ -209,7 +208,7 @@ static void imageCallback(const sensor_msgs::Image&amp; image_raw) {
         cvmSet(affine_g2c, 2, 3, cvmGet(v_g2c, 0, 2));
         cvmSet(affine_g2c, 3, 3, 1);
 
-        cvmMul(affine_g2c, affine_l2g, affine_l2c);
+        cvMatMulAdd(affine_g2c, affine_l2g, 0, affine_l2c);
 
         printf("--transration v_g2l\n");
         print_param(v_g2l);
@@ -228,9 +227,13 @@ static void imageCallback(const sensor_msgs::Image&amp; image_raw) {
 
         cv::Size image_size(image_raw.width, image_raw.height);
 
-        fs &lt;&lt; "CameraExtrinsicMat" &lt;&lt; affine_l2c;
-        fs &lt;&lt; "CameraMat" &lt;&lt; m_intrinsic;
-        fs &lt;&lt; "DistCoeff" &lt;&lt; m_dist;
+	cv::Mat affine_l2c_mat=cv::cvarrToMat(affine_l2c);
+	cv::Mat m_intrinsic_mat=cv::cvarrToMat(m_intrinsic);
+	cv::Mat m_dist_mat=cv::cvarrToMat(m_dist);
+	
+        fs &lt;&lt; "CameraExtrinsicMat" &lt;&lt; affine_l2c_mat;
+        fs &lt;&lt; "CameraMat" &lt;&lt; m_intrinsic_mat;
+        fs &lt;&lt; "DistCoeff" &lt;&lt; m_dist_mat;
         fs &lt;&lt; "ImageSize" &lt;&lt; image_size;
         fs &lt;&lt; "ReprojectionError" &lt;&lt; 0;
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\chessboard.h" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\chessboard.h" added_lines="1" deleted_lines="0">
				<diff>@@ -32,6 +32,7 @@
 #define _chessboard_
 
 #include &lt;opencv/cv.h&gt;
+#include &lt;opencv2/calib3d/calib3d.hpp&gt;
 
 extern bool findChessboard(IplImage* image, int pat_col, int pat_row, int chess_size, CvMat* object_points, int* corner_count, CvPoint2D32f* corners, CvPoint3D32f* objects);
 extern void drawChessboard(IplImage* image, int pat_col, int pat_row, int corner_count, CvPoint2D32f* corners, CvMat* image_points);
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\image_window.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_test\image_window.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -60,7 +60,7 @@ void rad_x_bar(int val)
 
     cvInitMatHeader(&amp;m_rotation_x, 3, 3, CV_64FC1, init_m_rotation_x, CV_AUTOSTEP);
     cvCopy(m_rotation, m_rotation_temp);
-    cvmMul(m_rotation_temp, &amp;m_rotation_x, m_rotation);
+    cvMatMulAdd(m_rotation_temp, &amp;m_rotation_x, 0, m_rotation);
     previous_val_x = val;
 }
 void rad_y_bar(int val)
@@ -74,7 +74,7 @@ void rad_y_bar(int val)
 
     cvInitMatHeader(&amp;m_rotation_y, 3, 3, CV_64FC1, init_m_rotation_y, CV_AUTOSTEP);
     cvCopy(m_rotation, m_rotation_temp);
-    cvmMul(m_rotation_temp, &amp;m_rotation_y, m_rotation);
+    cvMatMulAdd(m_rotation_temp, &amp;m_rotation_y, 0, m_rotation);
     previous_val_y = val;
 }
 void rad_z_bar(int val)
@@ -88,7 +88,7 @@ void rad_z_bar(int val)
 
     cvInitMatHeader(&amp;m_rotation_z, 3, 3, CV_64FC1, init_m_rotation_z);
     cvCopy(m_rotation, m_rotation_temp);
-    cvmMul(m_rotation_temp, &amp;m_rotation_z, m_rotation);
+    cvMatMulAdd(m_rotation_temp, &amp;m_rotation_z, 0, m_rotation);
     previous_val_z = val;
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="308db411b4485e3e4ed9a066e9d37ceca5535d3a" author="Shohei Fujii">
		<msg>fix circular-dependency</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lib\fusion\fusion.cpp" new_path="ros\src\computing\perception\detection\lib\fusion\fusion.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -265,7 +265,7 @@ static void showRects(IplImage *image, int object_num, const std::vector&lt;int&gt;&amp; c
 }
 #endif
 
-void setDetectedObjects(const cv_tracker::image_obj&amp; detected_objects)
+void setDetectedObjects(const cv_tracker_msgs::image_obj&amp; detected_objects)
 {
 	objectsStored = false;
 	obj_type = detected_objects.type;
@@ -446,13 +446,13 @@ std::vector&lt;float&gt; getMaxHeights()
 	return filtered_max_heights;
 }
 
-std::vector&lt;cv_tracker::image_rect_ranged&gt; getObjectsRectRanged()
+std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; getObjectsRectRanged()
 {
-	std::vector&lt;cv_tracker::image_rect_ranged&gt; fused_objects;
+	std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; fused_objects;
 	for (int i=0; i&lt;filtered_objects_num; i++)
 	{
 		int base = i * 4;
-		cv_tracker::image_rect_ranged obj_ranged;
+		cv_tracker_msgs::image_rect_ranged obj_ranged;
 		obj_ranged.rect.x      = filtered_corner_points.at(base);
 		obj_ranged.rect.y      = filtered_corner_points.at(base + 1);
 		obj_ranged.rect.width  = filtered_corner_points.at(base + 2);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\fusion\include\fusion_func.h" new_path="ros\src\computing\perception\detection\lib\fusion\include\fusion_func.h" added_lines="5" deleted_lines="5">
				<diff>@@ -38,11 +38,11 @@
 #include &lt;vector&gt;
 
 #include &lt;ros/ros.h&gt;
-#include &lt;cv_tracker/image_obj.h&gt;
-#include &lt;cv_tracker/image_rect_ranged.h&gt;
+#include &lt;cv_tracker_msgs/image_obj.h&gt;
+#include &lt;cv_tracker_msgs/image_rect_ranged.h&gt;
 #include &lt;scan2image/ScanImage.h&gt;
 #include &lt;points2image/PointsImage.h&gt;
-#include &lt;cv_tracker/image_obj_tracked.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
 
 #include &lt;opencv2/opencv.hpp&gt;
 
@@ -81,10 +81,10 @@ extern std::vector&lt;float&gt; getMaxHeights();
 extern void setParams(float minLowHeight, float maxLowHeight, float maxHeight, int minPoints, float disp);
 
 extern void calcDistance();
-extern void setDetectedObjects(const cv_tracker::image_obj&amp; image_objects);
+extern void setDetectedObjects(const cv_tracker_msgs::image_obj&amp; image_objects);
 extern void setScanImage(const scan2image::ScanImage&amp; scan_image);
 extern void setPointsImage(const points2image::PointsImage&amp; points_image);
-extern std::vector&lt;cv_tracker::image_rect_ranged&gt; getObjectsRectRanged();
+extern std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; getObjectsRectRanged();
 extern std::string getObjectsType();
 extern void init();
 extern void destroy();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\image\kf\src\kf.cpp" new_path="ros\src\computing\perception\detection\lib\image\kf\src\kf.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -38,9 +38,9 @@
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;runtime_manager/ConfigCarKf.h&gt;
-#include &lt;cv_tracker/image_obj_ranged.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
 
-#include &lt;cv_tracker/image_obj_tracked.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
 #include &lt;std_msgs/Header.h&gt;
 
 //TRACKING STUFF
@@ -88,7 +88,7 @@ static bool 		USE_ORB;
 
 static bool 		track_ready_;
 static bool 		detect_ready_;
-static cv_tracker::image_obj_tracked kf_objects_msg_;
+static cv_tracker_msgs::image_obj_tracked kf_objects_msg_;
 
 struct kstate
 {
@@ -815,7 +815,7 @@ void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;ObjectDete
 
 	//ROS
 	int num = tracked_detections.size();
-	std::vector&lt;cv_tracker::image_rect_ranged&gt; rect_ranged_array;
+	std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; rect_ranged_array;
 	std::vector&lt;int&gt; real_data(num,0);
 	std::vector&lt;int&gt; obj_id(num, 0);
 	std::vector&lt;int&gt; lifespan(num, 0);
@@ -824,7 +824,7 @@ void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;ObjectDete
 	for (size_t i = 0; i &lt; tracked_detections.size(); i++)
 	{
 		kstate od = tracked_detections[i];
-		cv_tracker::image_rect_ranged rect_ranged_;
+		cv_tracker_msgs::image_rect_ranged rect_ranged_;
 
 		//od.rect contains x,y, width, height
 		rectangle(image, od.pos, od.color, 3);
@@ -846,7 +846,7 @@ void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;ObjectDete
 		//ENDROS
 	}
 	//more ros
-	cv_tracker::image_obj_tracked kf_objects_msg;
+	cv_tracker_msgs::image_obj_tracked kf_objects_msg;
 
 	kf_objects_msg.type = object_type;
 	kf_objects_msg.total_num = num;
@@ -878,12 +878,12 @@ void image_callback(const sensor_msgs::Image&amp; image_source)
 	_counter++;
 }
 
-void detections_callback(cv_tracker::image_obj_ranged image_objects_msg)
+void detections_callback(cv_tracker_msgs::image_obj_ranged image_objects_msg)
 {
 	if(!detect_ready_)
 	{
 		unsigned int num = image_objects_msg.obj.size();
-		std::vector&lt;cv_tracker::image_rect_ranged&gt; objects = image_objects_msg.obj;
+		std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects = image_objects_msg.obj;
 		object_type = image_objects_msg.type;
 		image_objects_header = image_objects_msg.header;
 		//points are X,Y,W,H and repeat for each instance
@@ -958,7 +958,7 @@ int kf_main(int argc, char* argv[])
 	ros::NodeHandle n;
 	ros::NodeHandle private_nh("~");
 
-	image_objects = n.advertise&lt;cv_tracker::image_obj_tracked&gt;("image_obj_tracked", 1);
+	image_objects = n.advertise&lt;cv_tracker_msgs::image_obj_tracked&gt;("image_obj_tracked", 1);
 
 	generateColors(_colors, 25);
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ttic\dpm_ttic.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ttic\dpm_ttic.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -36,7 +36,7 @@
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 
-#include &lt;cv_tracker/image_obj.h&gt;
+#include &lt;cv_tracker_msgs/image_obj.h&gt;
 #include &lt;runtime_manager/ConfigCarDpm.h&gt;
 #include &lt;runtime_manager/ConfigPedestrianDpm.h&gt;
 
@@ -67,10 +67,10 @@ static void set_default_param(DPMTTICParam&amp; param)
 	param.num_cells = 8;counter =0;
 }
 
-static void result_to_image_obj_message(cv_tracker::image_obj&amp; msg, const DPMTTICResult result)
+static void result_to_image_obj_message(cv_tracker_msgs::image_obj&amp; msg, const DPMTTICResult result)
 {
 	for (int i = 0; i &lt; result.num; ++i) {
-		cv_tracker::image_rect rect;
+		cv_tracker_msgs::image_rect rect;
 
 		int base = i * 4;
 		rect.x = result.corner_points[base];
@@ -90,7 +90,7 @@ static void image_raw_cb(const sensor_msgs::Image&amp; image_source)
 	IplImage img = cv_image-&gt;image;
 	IplImage *img_ptr = &amp;img;
 
-	cv_tracker::image_obj msg;
+	cv_tracker_msgs::image_obj msg;
 	msg.header = image_source.header;
 	msg.type = object_class;
 
@@ -190,7 +190,7 @@ int main(int argc, char* argv[])
 #endif
 
 	ros::Subscriber sub = n.subscribe(image_topic_name, 1, image_raw_cb);
-	image_obj_pub = n.advertise&lt;cv_tracker::image_obj&gt;("image_obj", 1);
+	image_obj_pub = n.advertise&lt;cv_tracker_msgs::image_obj&gt;("image_obj", 1);
 
 	ros::Subscriber config_sub;
 	std::string config_topic("/config");
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dummy_track\dummy_track.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dummy_track\dummy_track.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -29,14 +29,14 @@
 */
 
 #include &lt;ros/ros.h&gt;
-#include &lt;cv_tracker/image_obj_tracked.h&gt;
-#include &lt;cv_tracker/image_obj_ranged.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
 
 class DummyTrack{
 public:
   DummyTrack(){
     subscriber_image_obj_ = node_handle_.subscribe("image_obj_ranged", 1, &amp;DummyTrack::detections_callback, this);
-		publisher_tracked_objects_ = node_handle_.advertise&lt;cv_tracker::image_obj_tracked&gt;("image_obj_tracked", 1);
+		publisher_tracked_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj_tracked&gt;("image_obj_tracked", 1);
   }
   void run(){
     ros::spin();
@@ -46,9 +46,9 @@ private:
   ros::Publisher 		publisher_tracked_objects_;//ROS
   ros::NodeHandle 	node_handle_;
 
-  void detections_callback(cv_tracker::image_obj_ranged image_objects_msg)
+  void detections_callback(cv_tracker_msgs::image_obj_ranged image_objects_msg)
   {
-    cv_tracker::image_obj_tracked pub_msg;
+    cv_tracker_msgs::image_obj_tracked pub_msg;
     pub_msg.header = image_objects_msg.header;
     pub_msg.type = image_objects_msg.type;
     pub_msg.rect_ranged = image_objects_msg.obj;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\klt_track\klt_track.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\klt_track\klt_track.cpp" added_lines="12" deleted_lines="12">
				<diff>@@ -37,9 +37,9 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;cv_tracker/image_obj.h&gt;
-#include &lt;cv_tracker/image_obj_tracked.h&gt;
-#include &lt;cv_tracker/image_obj_ranged.h&gt;
+#include &lt;cv_tracker_msgs/image_obj.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
 
 //TRACKING STUFF
 #include &lt;opencv2/core/core.hpp&gt;
@@ -85,7 +85,7 @@ class RosTrackerApp
 	std::vector&lt;float&gt; min_heights_;
 	std::vector&lt;float&gt; max_heights_;
 
-	cv_tracker::image_obj_tracked ros_objects_msg_;//sync
+	cv_tracker_msgs::image_obj_tracked ros_objects_msg_;//sync
 
 	void Sort(const std::vector&lt;float&gt; in_scores, std::vector&lt;unsigned int&gt;&amp; in_out_indices)
 	{
@@ -260,13 +260,13 @@ public:
 
 		//copy results to ros msg
 		unsigned int num = obj_trackers_.size();
-		std::vector&lt;cv_tracker::image_rect_ranged&gt; rect_ranged_array;//tracked rectangles
+		std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; rect_ranged_array;//tracked rectangles
 		std::vector&lt;int&gt; real_data(num,0);//boolean array to show if data in rect_ranged comes from tracking or detection
 		std::vector&lt;unsigned int&gt; obj_id(num, 0);//id number for each rect_range
 		std::vector&lt;unsigned int&gt; lifespan(num, 0);//remaining lifespan of each rectranged
 		for(i=0; i &lt; num; i++)
 		{
-			cv_tracker::image_rect_ranged rect_ranged;
+			cv_tracker_msgs::image_rect_ranged rect_ranged;
 			LkTracker tracker_tmp = *obj_trackers_[i];
 			rect_ranged.rect.x = tracker_tmp.GetTrackedObject().rect.x;
 			rect_ranged.rect.y = tracker_tmp.GetTrackedObject().rect.y;
@@ -292,7 +292,7 @@ public:
 		obj_detections_.clear();
         ranges_.clear();
 
-		cv_tracker::image_obj_tracked tmp_objects_msg;
+		cv_tracker_msgs::image_obj_tracked tmp_objects_msg;
 
 		tmp_objects_msg.type = tracked_type_;
 		tmp_objects_msg.total_num = num;
@@ -317,14 +317,14 @@ public:
 
 	}
 
-	void detections_callback(cv_tracker::image_obj_ranged image_objects_msg)
+	void detections_callback(cv_tracker_msgs::image_obj_ranged image_objects_msg)
 	{
 		//if(ready_)
 		//	return;
 		if (!detect_ready_)//must NOT overwrite, data is probably being used by tracking.
 		{
 			unsigned int num = image_objects_msg.obj.size();
-			std::vector&lt;cv_tracker::image_rect_ranged&gt; objects = image_objects_msg.obj;
+			std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects = image_objects_msg.obj;
 			tracked_type_ = image_objects_msg.type;
 			//points are X,Y,W,H and repeat for each instance
 			obj_detections_.clear();
@@ -350,13 +350,13 @@ public:
 		publish_if_possible();
 		//ready_ = true;
 	}
-	/*void detections_callback(cv_tracker::image_obj image_objects_msg)
+	/*void detections_callback(cv_tracker_msgs::image_obj image_objects_msg)
 	{
 		if (ready_)
 			return;
 		ready_ = false;
 		unsigned int num = image_objects_msg.obj.size();
-		std::vector&lt;cv_tracker::image_rect&gt; objects = image_objects_msg.obj;
+		std::vector&lt;cv_tracker_msgs::image_rect&gt; objects = image_objects_msg.obj;
 		//object_type = image_objects_msg.type;
 		//points are X,Y,W,H and repeat for each instance
 		obj_detections_.clear();
@@ -406,7 +406,7 @@ public:
 		}
 
 
-		publisher_tracked_objects_ = node_handle_.advertise&lt;cv_tracker::image_obj_tracked&gt;("image_obj_tracked", 1);
+		publisher_tracked_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj_tracked&gt;("image_obj_tracked", 1);
 
 		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
 		ROS_INFO("Subscribing to... %s", image_obj_topic_str.c_str());
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\obj_reproj.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\obj_reproj.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -56,7 +56,7 @@
 #include &lt;geometry_msgs/Pose.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;cv_tracker/image_obj_tracked.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
 #include &lt;tf/tf.h&gt;
 #include &lt;tf/transform_listener.h&gt;
 #include &lt;sensor_msgs/NavSatFix.h&gt;
@@ -65,7 +65,7 @@
 #include "axialMove.h"
 #include "geo_pos_conv.hh"
 #include "CalObjLoc.h"
-#include "cv_tracker/obj_label.h"
+#include "cv_tracker_msgs/obj_label.h"
 #include "calibration_camera_lidar/projection_matrix.h"
 #include &lt;sensor_msgs/CameraInfo.h&gt;
 #include &lt;mutex&gt;
@@ -121,7 +121,7 @@ static tf::StampedTransform transformCam2Map;
 std::string camera_id_str;
 
 
-static visualization_msgs::MarkerArray convert_marker_array(const cv_tracker::obj_label&amp; src)
+static visualization_msgs::MarkerArray convert_marker_array(const cv_tracker_msgs::obj_label&amp; src)
 {
   visualization_msgs::MarkerArray ret;
   int index = 0;
@@ -196,7 +196,7 @@ static visualization_msgs::MarkerArray convert_marker_array(const cv_tracker::ob
 }
 
 #ifdef HAVE_JSK_PLUGIN
-static jsk_recognition_msgs::BoundingBoxArray convertJskBoundingBoxArray(const cv_tracker::obj_label&amp; src)
+static jsk_recognition_msgs::BoundingBoxArray convertJskBoundingBoxArray(const cv_tracker_msgs::obj_label&amp; src)
 {
   jsk_recognition_msgs::BoundingBoxArray ret;
   ret.header.frame_id ="map";
@@ -254,7 +254,7 @@ void GetRPY(const geometry_msgs::Pose &amp;pose,
 
 void makeSendDataDetectedObj(vector&lt;OBJPOS&gt; car_position_vector,
                              vector&lt;OBJPOS&gt;::iterator cp_iterator,
-                             cv_tracker::obj_label&amp; send_data)
+                             cv_tracker_msgs::obj_label&amp; send_data)
 {
   geometry_msgs::Point tmpPoint;
 
@@ -298,7 +298,7 @@ void locatePublisher(void){
   //get values from sample_corner_point , convert latitude and longitude,
   //and send database server.
 
-  cv_tracker::obj_label obj_label_msg;
+  cv_tracker_msgs::obj_label obj_label_msg;
   visualization_msgs::MarkerArray obj_label_marker_msgs;
 
   vector&lt;OBJPOS&gt;::iterator cp_iterator;
@@ -329,7 +329,7 @@ void locatePublisher(void){
 #endif  // ifdef HAVE_JSK_PLUGIN
 }
 
-static void obj_pos_xyzCallback(const cv_tracker::image_obj_tracked&amp; fused_objects)
+static void obj_pos_xyzCallback(const cv_tracker_msgs::image_obj_tracked&amp; fused_objects)
 {
   if (!ready_)
     return;
@@ -399,7 +399,7 @@ int main(int argc, char **argv){
 
   ros::Subscriber obj_pos_xyz = n.subscribe("image_obj_tracked", 1, obj_pos_xyzCallback);
 
-  pub = n.advertise&lt;cv_tracker::obj_label&gt;("obj_label",1);
+  pub = n.advertise&lt;cv_tracker_msgs::obj_label&gt;("obj_label",1);
   marker_pub = n.advertise&lt;visualization_msgs::MarkerArray&gt;("obj_label_marker", 1);
 
 #ifdef HAVE_JSK_PLUGIN
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\range_fusion\range_fusion.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\range_fusion\range_fusion.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -29,7 +29,7 @@
 */
 
 #include &lt;ros/ros.h&gt;
-#include &lt;cv_tracker/image_obj_ranged.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
 #include &lt;std_msgs/Header.h&gt;
 #include &lt;fusion_func.h&gt;
 #include &lt;runtime_manager/ConfigCarFusion.h&gt;
@@ -40,7 +40,7 @@ static std_msgs::Header sensor_header;
 
 bool ready_ = false;
 
-static void DetectedObjectsCallback(const cv_tracker::image_obj&amp; image_object)
+static void DetectedObjectsCallback(const cv_tracker_msgs::image_obj&amp; image_object)
 {
     sensor_header = image_object.header;
     setDetectedObjects(image_object);
@@ -80,7 +80,7 @@ static void publishTopic()
 	/*
 	 * Publish topic(obj position ranged).
 	 */
-	cv_tracker::image_obj_ranged fused_objects_msg;
+	cv_tracker_msgs::image_obj_ranged fused_objects_msg;
 	fused_objects_msg.header = sensor_header;
 
 	fused_objects_msg.type = getObjectsType();
@@ -133,7 +133,7 @@ int main(int argc, char **argv)
 #if _DEBUG
 	ros::Subscriber image_sub = n.subscribe(IMAGE_TOPIC, 1, IMAGE_CALLBACK);
 #endif
-	fused_objects = n.advertise&lt;cv_tracker::image_obj_ranged&gt;("image_obj_ranged", 1);
+	fused_objects = n.advertise&lt;cv_tracker_msgs::image_obj_ranged&gt;("image_obj_ranged", 1);
 
 	ros::Subscriber config_subscriber;
 	std::string config_topic("/config");
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\rcnn\rcnn_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\rcnn\rcnn_node.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -33,7 +33,7 @@
 #include &lt;runtime_manager/ConfigRcnn.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;cv_tracker/image_obj.h&gt;
+#include &lt;cv_tracker_msgs/image_obj.h&gt;
 
 #include &lt;rcnn_detector.h&gt;
 #include &lt;rect_class_score.h&gt;
@@ -73,7 +73,7 @@ class RosRcnnApp
 	//vector of indices of the classes to search for
 	std::vector&lt;unsigned int&gt; detect_classes_;
 
-	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, cv_tracker::image_obj&amp; out_message, cv::Mat&amp; in_image, std::string in_class)
+	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, cv_tracker_msgs::image_obj&amp; out_message, cv::Mat&amp; in_image, std::string in_class)
 	{
 		for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
 		{
@@ -85,7 +85,7 @@ class RosRcnnApp
 				)//check if the score is larger than minimum required
 			{
 				//std::cout &lt;&lt; in_objects[i].toString() &lt;&lt; std::endl;
-				cv_tracker::image_rect rect;
+				cv_tracker_msgs::image_rect rect;
 
 				rect.x = in_objects[i].x;
 				rect.y = in_objects[i].y;
@@ -124,8 +124,8 @@ class RosRcnnApp
 		//std::cout &lt;&lt; "Detection took: " &lt;&lt; timer.getTimeMilli() &lt;&lt; std::endl;
 
 		//Prepare Output message
-		cv_tracker::image_obj output_car_message;
-		cv_tracker::image_obj output_person_message;
+		cv_tracker_msgs::image_obj output_car_message;
+		cv_tracker_msgs::image_obj output_person_message;
 		output_car_message.header = image_source.header;
 		output_car_message.type = "car";
 
@@ -216,8 +216,8 @@ public:
 			return;
 		}
 
-		publisher_car_objects_ = node_handle_.advertise&lt;cv_tracker::image_obj&gt;("/obj_car/image_obj", 1);
-		publisher_person_objects_ = node_handle_.advertise&lt;cv_tracker::image_obj&gt;("/obj_person/image_obj", 1);
+		publisher_car_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj&gt;("/obj_car/image_obj", 1);
+		publisher_person_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj&gt;("/obj_person/image_obj", 1);
 
 		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
 		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosRcnnApp::image_callback, this);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -18,7 +18,7 @@ namespace integrated_viewer
   } // DrawRects::DrawRects()
 
 
-  void DrawRects::DrawImageObj(const cv_tracker::image_obj::ConstPtr&amp; rect_data,
+  void DrawRects::DrawImageObj(const cv_tracker_msgs::image_obj::ConstPtr&amp; rect_data,
                                cv::Mat &amp;image) {
     if (rect_data == NULL) {
       return;
@@ -52,7 +52,7 @@ namespace integrated_viewer
   } // DrawRects::DrawImageObj()
 
 
-  void DrawRects::DrawImageObjRanged(const cv_tracker::image_obj_ranged::ConstPtr&amp; rect_data,
+  void DrawRects::DrawImageObjRanged(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; rect_data,
                                      cv::Mat &amp;image) {
     if (rect_data == NULL) {
       return;
@@ -86,7 +86,7 @@ namespace integrated_viewer
   } // DrawRects::DrawImageObjRanged()
 
 
-  void DrawRects::DrawImageObjTracked(const cv_tracker::image_obj_tracked::ConstPtr&amp; rect_data,
+  void DrawRects::DrawImageObjTracked(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; rect_data,
                                       cv::Mat &amp;image) {
     if (rect_data == NULL) {
       return;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.h" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.h" added_lines="6" deleted_lines="6">
				<diff>@@ -2,18 +2,18 @@
 #define DRAW_RECTS_H
 
 #include &lt;opencv/cv.h&gt;
-#include &lt;cv_tracker/image_obj.h&gt;
-#include &lt;cv_tracker/image_obj_ranged.h&gt;
-#include &lt;cv_tracker/image_obj_tracked.h&gt;
+#include &lt;cv_tracker_msgs/image_obj.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
 
 namespace integrated_viewer {
   // helper class to draw detection result rectangle
   class DrawRects{
   public:
     explicit DrawRects(void);
-    void DrawImageObj(const cv_tracker::image_obj::ConstPtr&amp; rect_data, cv::Mat&amp; image);
-    void DrawImageObjRanged(const cv_tracker::image_obj_ranged::ConstPtr&amp; rect_data, cv::Mat&amp; image);
-    void DrawImageObjTracked(const cv_tracker::image_obj_tracked::ConstPtr&amp; rect_data, cv::Mat&amp; image);
+    void DrawImageObj(const cv_tracker_msgs::image_obj::ConstPtr&amp; rect_data, cv::Mat&amp; image);
+    void DrawImageObjRanged(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; rect_data, cv::Mat&amp; image);
+    void DrawImageObjTracked(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; rect_data, cv::Mat&amp; image);
 
   protected:
     static const int kRectangleThickness;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -15,11 +15,11 @@
 namespace integrated_viewer
 {
   const QString     ImageViewerPlugin::kImageDataType               = "sensor_msgs/Image";
-  const QString     ImageViewerPlugin::kRectDataTypeBase            = "cv_tracker/image_obj";
+  const QString     ImageViewerPlugin::kRectDataTypeBase            = "cv_tracker_msgs/image_obj";
   const QString     ImageViewerPlugin::kPointDataType               = "points2image/PointsImage";
   const QString     ImageViewerPlugin::kBlankTopic                  = "-----";
-  const std::string ImageViewerPlugin::kRectDataTypeImageObjRanged  = "cv_tracker/image_obj_ranged";
-  const std::string ImageViewerPlugin::kRectDataTypeImageObjTracked = "cv_tracker/image_obj_tracked";
+  const std::string ImageViewerPlugin::kRectDataTypeImageObjRanged  = "cv_tracker_msgs/image_obj_ranged";
+  const std::string ImageViewerPlugin::kRectDataTypeImageObjTracked = "cv_tracker_msgs/image_obj_tracked";
 
   ImageViewerPlugin::ImageViewerPlugin(QWidget* parent)
     : rviz::Panel(parent) {
@@ -200,7 +200,7 @@ namespace integrated_viewer
       image_obj_ranged_msg_  = NULL;
       image_obj_tracked_msg_ = NULL;
       // this topic type is image_obj_ranged
-      rect_sub_ = node_handle_.subscribe&lt;cv_tracker::image_obj_ranged&gt;(selected_topic,
+      rect_sub_ = node_handle_.subscribe&lt;cv_tracker_msgs::image_obj_ranged&gt;(selected_topic,
                                                                        1,
                                                                        &amp;ImageViewerPlugin::ImageObjRangedCallback,
                                                                        this);
@@ -210,7 +210,7 @@ namespace integrated_viewer
       image_obj_ranged_msg_  = NULL;
       image_obj_tracked_msg_ = NULL;
       // this topic type is image_obj_tracked
-      rect_sub_ = node_handle_.subscribe&lt;cv_tracker::image_obj_tracked&gt;(selected_topic,
+      rect_sub_ = node_handle_.subscribe&lt;cv_tracker_msgs::image_obj_tracked&gt;(selected_topic,
                                                                        1,
                                                                        &amp;ImageViewerPlugin::ImageObjTrackedCallback,
                                                                        this);
@@ -219,7 +219,7 @@ namespace integrated_viewer
       image_obj_ranged_msg_  = NULL;
       image_obj_tracked_msg_ = NULL;
       // this topic type is image_obj
-      rect_sub_ = node_handle_.subscribe&lt;cv_tracker::image_obj&gt;(selected_topic,
+      rect_sub_ = node_handle_.subscribe&lt;cv_tracker_msgs::image_obj&gt;(selected_topic,
                                                                 1,
                                                                 &amp;ImageViewerPlugin::ImageObjCallback,
                                                                 this);
@@ -229,15 +229,15 @@ namespace integrated_viewer
   } // ImageViewerPlugin::on_rect_topic_combo_box__activated()
   
 
-  void ImageViewerPlugin::ImageObjCallback(const cv_tracker::image_obj::ConstPtr&amp; msg) {
+  void ImageViewerPlugin::ImageObjCallback(const cv_tracker_msgs::image_obj::ConstPtr&amp; msg) {
     image_obj_msg_ = msg;
   } // ImageViewerPlugin::ImageObjCallback()
 
-  void ImageViewerPlugin::ImageObjRangedCallback(const cv_tracker::image_obj_ranged::ConstPtr &amp;msg) {
+  void ImageViewerPlugin::ImageObjRangedCallback(const cv_tracker_msgs::image_obj_ranged::ConstPtr &amp;msg) {
     image_obj_ranged_msg_ = msg;
   } // ImageViewerPlugin::ImageObjRangedCallback()
 
-  void ImageViewerPlugin::ImageObjTrackedCallback(const cv_tracker::image_obj_tracked::ConstPtr &amp;msg) {
+  void ImageViewerPlugin::ImageObjTrackedCallback(const cv_tracker_msgs::image_obj_tracked::ConstPtr &amp;msg) {
     image_obj_tracked_msg_ = msg;
   } // ImageViewerPlugin::ImageObjTrackedCallback()
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" added_lines="9" deleted_lines="9">
				<diff>@@ -6,9 +6,9 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;rviz/panel.h&gt;
-#include &lt;cv_tracker/image_obj.h&gt;
-#include &lt;cv_tracker/image_obj_ranged.h&gt;
-#include &lt;cv_tracker/image_obj_tracked.h&gt;
+#include &lt;cv_tracker_msgs/image_obj.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
 #include &lt;points2image/PointsImage.h&gt;
 
 #include &lt;string&gt;
@@ -47,9 +47,9 @@ namespace integrated_viewer
     
     // The Callback functions
     void ImageCallback(const sensor_msgs::Image::ConstPtr&amp; msg);
-    void ImageObjCallback(const cv_tracker::image_obj::ConstPtr&amp; msg);
-    void ImageObjRangedCallback(const cv_tracker::image_obj_ranged::ConstPtr&amp; msg);
-    void ImageObjTrackedCallback(const cv_tracker::image_obj_tracked::ConstPtr&amp; msg);
+    void ImageObjCallback(const cv_tracker_msgs::image_obj::ConstPtr&amp; msg);
+    void ImageObjRangedCallback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; msg);
+    void ImageObjTrackedCallback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; msg);
     void PointCallback(const points2image::PointsImage::ConstPtr &amp;msg);
 
    // The function to refrect modified image on UI
@@ -85,9 +85,9 @@ namespace integrated_viewer
 
     // Data pointer to hold subscribed data
     points2image::PointsImage::ConstPtr points_msg_;
-    cv_tracker::image_obj::ConstPtr image_obj_msg_;
-    cv_tracker::image_obj_ranged::ConstPtr image_obj_ranged_msg_;
-    cv_tracker::image_obj_tracked::ConstPtr image_obj_tracked_msg_;
+    cv_tracker_msgs::image_obj::ConstPtr image_obj_msg_;
+    cv_tracker_msgs::image_obj_ranged::ConstPtr image_obj_ranged_msg_;
+    cv_tracker_msgs::image_obj_tracked::ConstPtr image_obj_tracked_msg_;
 
     // data structure to hold topic information for detection result
     std::map&lt;std::string, std::string&gt; rect_topic_info_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\obj_fusion.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\obj_fusion.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,4 +1,4 @@
-#include &lt;cv_tracker/obj_label.h&gt;
+#include &lt;cv_tracker_msgs/obj_label.h&gt;
 #include &lt;float.h&gt;
 #include &lt;geometry_msgs/Point.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
@@ -154,7 +154,7 @@ static void fusion_objects(void) {
   obj_pose_timestamp_pub.publish(time);
 }
 
-void obj_label_cb(const cv_tracker::obj_label &amp;obj_label_msg) {
+void obj_label_cb(const cv_tracker_msgs::obj_label &amp;obj_label_msg) {
   object_type = obj_label_msg.type;
   obj_pose_timestamp = obj_label_msg.header.stamp;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\mainwindow.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\mainwindow.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -269,7 +269,7 @@ MainWindow::MainWindow(QWidget *parent) :
     ui-&gt;setupUi(this);
 
     scansub=new ROSSub&lt;sensor_msgs::LaserScanConstPtr&gt;("/scan",1000,10,this);
-    //detectionsub=new ROSSub&lt;cv_tracker::obj_label::ConstPtr&gt;("obj_label",1000,10,this);
+    //detectionsub=new ROSSub&lt;cv_tracker_msgs::obj_label::ConstPtr&gt;("obj_label",1000,10,this);
     boxessub=new ROSSub&lt;jsk_recognition_msgs::BoundingBoxArray::ConstPtr&gt;("bounding_boxes",1000,10,this);
     tfsub=new ROSTFSub("/world","/velodyne",10,this);
     tfMap2Lidarsub=new ROSTFSub("/velodyne","/map",10,this); // obj_pose is published into "map" frame
@@ -333,7 +333,7 @@ void MainWindow::slotReceive()
 
 void MainWindow::slotReceiveDetection()
 {
-    cv_tracker::obj_label::ConstPtr msg=detectionsub-&gt;getMessage();
+    cv_tracker_msgs::obj_label::ConstPtr msg=detectionsub-&gt;getMessage();
 
     for (const auto&amp; point : msg-&gt;reprojected_pos) {
         int msec=(msg-&gt;header.stamp.sec)%(24*60*60)*1000+(msg-&gt;header.stamp.nsec)/1000000;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\mainwindow.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\mainwindow.h" added_lines="2" deleted_lines="2">
				<diff>@@ -6,7 +6,7 @@
 #include&lt;sensor_msgs/LaserScan.h&gt;
 #include&lt;sensor_msgs/PointCloud2.h&gt;
 #include&lt;visualization_msgs/MarkerArray.h&gt;
-#include "cv_tracker/obj_label.h"
+#include "cv_tracker_msgs/obj_label.h"
 
 #include&lt;QGraphicsView&gt;
 #include&lt;QGraphicsScene&gt;
@@ -100,7 +100,7 @@ private:
     Ui::MainWindow *ui;
 public:
     ROSSub&lt;sensor_msgs::LaserScanConstPtr&gt; * scansub;
-    ROSSub&lt;cv_tracker::obj_label::ConstPtr&gt; * detectionsub;
+    ROSSub&lt;cv_tracker_msgs::obj_label::ConstPtr&gt; * detectionsub;
     ROSSub&lt;jsk_recognition_msgs::BoundingBoxArray::ConstPtr&gt; * boxessub;
     ROSTFSub * tfsub;
     ROSTFSub * tfMap2Lidarsub;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\image_d_viewer\image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\image_d_viewer\image_d_viewer.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -36,7 +36,7 @@
 #include "ros/ros.h"
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;sensor_msgs/CompressedImage.h&gt;
-#include "cv_tracker/image_obj_ranged.h"
+#include "cv_tracker_msgs/image_obj_ranged.h"
 #include &lt;math.h&gt;
 #include &lt;float.h&gt;
 #define NO_DATA 0
@@ -49,8 +49,8 @@ static IplImage temp;
 static IplImage *image;
 static double ratio = 1;	//resize ratio
 
-static cv_tracker::image_obj_ranged car_fused_objects;
-static cv_tracker::image_obj_ranged pedestrian_fused_objects;
+static cv_tracker_msgs::image_obj_ranged car_fused_objects;
+static cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
 
 static const int OBJ_RECT_THICKNESS = 3;
 static void showImage();
@@ -64,7 +64,7 @@ static inline bool isNearlyNODATA(float x)
 }
 
 void showRects(IplImage *Image,
-               std::vector&lt;cv_tracker::image_rect_ranged&gt; objects,
+               std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
                double ratio,
                CvScalar col)
 {
@@ -80,7 +80,7 @@ void showRects(IplImage *Image,
     }
 }
 
-static void obj_carCallback(const cv_tracker::image_obj_ranged&amp; fused_objects)
+static void obj_carCallback(const cv_tracker_msgs::image_obj_ranged&amp; fused_objects)
 {
     if(image == NULL){
       return;
@@ -89,7 +89,7 @@ static void obj_carCallback(const cv_tracker::image_obj_ranged&amp; fused_objects)
     showImage();
 }
 
-static void obj_personCallback(const cv_tracker::image_obj_ranged&amp; fused_objects)
+static void obj_personCallback(const cv_tracker_msgs::image_obj_ranged&amp; fused_objects)
 {
     if(image == NULL){
       return;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\image_viewer\image_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\image_viewer\image_viewer.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -38,8 +38,8 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 
-#include &lt;cv_tracker/image_obj_tracked.h&gt;
-#include &lt;cv_tracker/image_obj.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
+#include &lt;cv_tracker_msgs/image_obj.h&gt;
 
 //DPM related
 static std::vector&lt;cv::Rect&gt; cars;		//objects detected
@@ -209,7 +209,7 @@ static void image_viewer_callback(const sensor_msgs::Image&amp; image_source)
 	_drawing = false;
 }
 
-static void image_obj_update_cb(const cv_tracker::image_obj&amp; image_objs)
+static void image_obj_update_cb(const cv_tracker_msgs::image_obj&amp; image_objs)
 {
 	if(_drawing)
 		return;
@@ -239,7 +239,7 @@ static void image_obj_update_cb(const cv_tracker::image_obj&amp; image_objs)
 	}
 }
 
-static void image_obj_updater_cb_tracked(const cv_tracker::image_obj_tracked&amp; image_objs_tracked_msg)
+static void image_obj_updater_cb_tracked(const cv_tracker_msgs::image_obj_tracked&amp; image_objs_tracked_msg)
 {
 	if(_drawing)
 		return;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -39,7 +39,7 @@
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;points2image/PointsImage.h&gt;
 
-#include "cv_tracker/image_obj_ranged.h"
+#include "cv_tracker_msgs/image_obj_ranged.h"
 #include &lt;vector&gt;
 #include &lt;iostream&gt;
 #include &lt;math.h&gt;
@@ -58,8 +58,8 @@ static cv::Mat colormap;
 static std::vector&lt;cv::Rect&gt; cars;
 static std::vector&lt;cv::Rect&gt; peds;
 #else
-static cv_tracker::image_obj_ranged car_fused_objects;
-static cv_tracker::image_obj_ranged pedestrian_fused_objects;
+static cv_tracker_msgs::image_obj_ranged car_fused_objects;
+static cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
 #endif
 
 /* check whether floating value x is nearly 0 or not */
@@ -78,7 +78,7 @@ static std::vector&lt;cv::Scalar&gt; _colors;
 static const int OBJ_RECT_THICKNESS = 3;
 
 static void drawRects(IplImage *Image,
-                      std::vector&lt;cv_tracker::image_rect_ranged&gt; objects,
+                      std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
                       CvScalar color,
                       int threshold_height)
 {
@@ -93,7 +93,7 @@ static void drawRects(IplImage *Image,
 }
 
 static void putDistance(IplImage *Image,
-                        std::vector&lt;cv_tracker::image_rect_ranged&gt; objects,
+                        std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
                         int threshold_height,
                         const char* objectLabel)
 {
@@ -278,7 +278,7 @@ static void car_updater_callback(dpm::ImageObjects image_objects_msg)
   }
 }
 #else
-static void car_updater_callback(const cv_tracker::image_obj_ranged&amp; fused_car_msg)
+static void car_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_car_msg)
 {
   car_fused_objects = fused_car_msg;
   //  show();
@@ -303,7 +303,7 @@ static void ped_updater_callback(dpm::ImageObjects image_objects_msg)
   }
 }
 #else
-static void ped_updater_callback(const cv_tracker::image_obj_ranged&amp; fused_pds_msg)
+static void ped_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_pds_msg)
 {
   pedestrian_fused_objects = fused_pds_msg;
   //  show();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\scan_image_d_viewer\scan_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\scan_image_d_viewer\scan_image_d_viewer.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -42,7 +42,7 @@
 #include &lt;iostream&gt;
 #include &lt;math.h&gt;
 #include &lt;float.h&gt;
-#include "cv_tracker/image_obj_ranged.h"
+#include "cv_tracker_msgs/image_obj_ranged.h"
 #include "scan2image/ScanImage.h"
 
 #define IMAGE_WIDTH 800
@@ -58,8 +58,8 @@ bool exist_image = false;
 bool exist_scan = false;
 cv::Mat colormap;
 
-cv_tracker::image_obj_ranged car_fused_objects;
-cv_tracker::image_obj_ranged pedestrian_fused_objects;
+cv_tracker_msgs::image_obj_ranged car_fused_objects;
+cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
 static const int OBJ_RECT_THICKNESS = 3;
 
 /* check whether floating value x is nearly 0 or not */
@@ -71,7 +71,7 @@ static inline bool isNearlyNODATA(float x)
 }
 
 static void putDistance(IplImage *Image,
-                        std::vector&lt;cv_tracker::image_rect_ranged&gt; objects,
+                        std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
                         int threshold_height,
                         const char* objectLabel)
 {
@@ -147,7 +147,7 @@ static void putDistance(IplImage *Image,
 }
 
 static void drawRects(IplImage *Image,
-                      std::vector&lt;cv_tracker::image_rect_ranged&gt; objects,
+                      std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
                       CvScalar color,
                       int threshold_height)
 {
@@ -236,13 +236,13 @@ static void scan_image_callback(const scan2image::ScanImage&amp; scan_image_msg)
     show();
 }
 
-static void car_fusion_callback(const cv_tracker::image_obj_ranged&amp; fused_car_msg)
+static void car_fusion_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_car_msg)
 {
   car_fused_objects = fused_car_msg;
 //  show();
 }
 
-static void ped_fusion_callback(const cv_tracker::image_obj_ranged&amp; fused_pds_msg)
+static void ped_fusion_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_pds_msg)
 {
   pedestrian_fused_objects = fused_pds_msg;
 //  show();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -35,7 +35,7 @@
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;points2image/PointsImage.h&gt;
 
-#include &lt;cv_tracker/image_obj_ranged.h&gt;
+#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
 #include &lt;vector&gt;
 #include &lt;iostream&gt;
 #include &lt;math.h&gt;
@@ -58,8 +58,8 @@ static cv::Mat colormap;
 static std::vector&lt;cv::Rect&gt; cars;
 static std::vector&lt;cv::Rect&gt; peds;
 #else
-static cv_tracker::image_obj_ranged car_fused_objects;
-static cv_tracker::image_obj_ranged pedestrian_fused_objects;
+static cv_tracker_msgs::image_obj_ranged car_fused_objects;
+static cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
 #endif
 
 /* check whether floating value x is nearly 0 or not */
@@ -80,7 +80,7 @@ static std::vector&lt;cv::Scalar&gt; _colors;
 static const int OBJ_RECT_THICKNESS = 3;
 
 static void drawRects(cv::Mat image,
-                    std::vector&lt;cv_tracker::image_rect_ranged&gt; objects,
+                    std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
 					CvScalar color,
 					int threshold_height,
 					std::string objectClass)
@@ -176,13 +176,13 @@ static void show(void)
 		cvWaitKey(2);
 	}
 }
-static void car_updater_callback(const cv_tracker::image_obj_ranged&amp; fused_car_msg)
+static void car_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_car_msg)
 {
 	car_fused_objects = fused_car_msg;
 	//  show();
 }
 
-static void ped_updater_callback(const cv_tracker::image_obj_ranged&amp; fused_pds_msg)
+static void ped_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_pds_msg)
 {
   pedestrian_fused_objects = fused_pds_msg;
   //  show();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\freespace_planner\nodes\astar_navi\astar_navi.cpp" new_path="ros\src\computing\planning\mission\packages\freespace_planner\nodes\astar_navi\astar_navi.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -1,25 +1,25 @@
 #include "astar_search.h"
 #include "search_info_ros.h"
-#include "waypoint_follower/LaneArray.h"
+#include "waypoint_follower_msgs/LaneArray.h"
 
 namespace
 {
 
 void publishPathAsWaypoints(const ros::Publisher&amp; pub, const nav_msgs::Path&amp; path, const double waypoint_velocity_kmph)
 {
-  waypoint_follower::lane lane;
+  waypoint_follower_msgs::lane lane;
 
   lane.header = path.header;
   lane.increment = 0;
   for (const auto&amp; pose : path.poses) {
-    waypoint_follower::waypoint wp;
+    waypoint_follower_msgs::waypoint wp;
     wp.pose = pose;
     wp.twist.twist.linear.x = waypoint_velocity_kmph / 3.6;
 
     lane.waypoints.push_back(wp);
   }
 
-  waypoint_follower::LaneArray lane_array;
+  waypoint_follower_msgs::LaneArray lane_array;
   lane_array.lanes.push_back(lane);
   pub.publish(lane_array);
 
@@ -49,7 +49,7 @@ int main(int argc, char **argv)
 
   // ROS publishers
   ros::Publisher path_pub       = n.advertise&lt;nav_msgs::Path&gt;("astar_path", 1, true);
-  ros::Publisher waypoints_pub  = n.advertise&lt;waypoint_follower::LaneArray&gt;("lane_waypoints_array", 1, true);
+  ros::Publisher waypoints_pub  = n.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("lane_waypoints_array", 1, true);
   ros::Publisher debug_pose_pub = n.advertise&lt;geometry_msgs::PoseArray&gt;("debug_pose_array", 1, true);
 
   ros::Rate loop_rate(10);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\include\lane_planner\vmap.hpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\include\lane_planner\vmap.hpp" added_lines="7" deleted_lines="7">
				<diff>@@ -39,9 +39,9 @@
 #include &lt;visualization_msgs/Marker.h&gt;
 
 #include &lt;vector_map/vector_map.h&gt;
-#include &lt;tablet_socket/route_cmd.h&gt;
-#include &lt;waypoint_follower/dtlane.h&gt;
-#include &lt;waypoint_follower/lane.h&gt;
+#include &lt;tablet_socket_msgs/route_cmd.h&gt;
+#include &lt;waypoint_follower_msgs/dtlane.h&gt;
+#include &lt;waypoint_follower_msgs/lane.h&gt;
 
 namespace lane_planner {
 
@@ -77,12 +77,12 @@ bool is_connection_dtlane(const VectorMap&amp; fine_vmap, int index);
 
 geometry_msgs::Point create_geometry_msgs_point(const vector_map::Point&amp; vp);
 vector_map::Point create_vector_map_point(const geometry_msgs::Point&amp; gp);
-waypoint_follower::dtlane create_waypoint_follower_dtlane(const vector_map::DTLane&amp; vd);
-vector_map::DTLane create_vector_map_dtlane(const waypoint_follower::dtlane&amp; wd);
+waypoint_follower_msgs::dtlane create_waypoint_follower_dtlane(const vector_map::DTLane&amp; vd);
+vector_map::DTLane create_vector_map_dtlane(const waypoint_follower_msgs::dtlane&amp; wd);
 
 VectorMap create_lane_vmap(const VectorMap&amp; vmap, int lno);
-VectorMap create_coarse_vmap_from_lane(const waypoint_follower::lane&amp; lane);
-VectorMap create_coarse_vmap_from_route(const tablet_socket::route_cmd&amp; route);
+VectorMap create_coarse_vmap_from_lane(const waypoint_follower_msgs::lane&amp; lane);
+VectorMap create_coarse_vmap_from_route(const tablet_socket_msgs::route_cmd&amp; route);
 VectorMap create_fine_vmap(const VectorMap&amp; lane_vmap, int lno, const VectorMap&amp; coarse_vmap, double search_radius,
 			   int waypoint_max);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\lib\lane_planner\vmap.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\lib\lane_planner\vmap.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -33,7 +33,7 @@
 
 #include &lt;ros/console.h&gt;
 
-#include &lt;tablet_socket/Waypoint.h&gt;
+#include &lt;tablet_socket_msgs/Waypoint.h&gt;
 
 #include &lt;geo_pos_conv.hh&gt;
 #include &lt;lane_planner/vmap.hpp&gt;
@@ -506,9 +506,9 @@ vector_map::Point create_vector_map_point(const geometry_msgs::Point&amp; gp)
 	return vp;
 }
 
-waypoint_follower::dtlane create_waypoint_follower_dtlane(const vector_map::DTLane&amp; vd)
+waypoint_follower_msgs::dtlane create_waypoint_follower_dtlane(const vector_map::DTLane&amp; vd)
 {
-	waypoint_follower::dtlane wd;
+	waypoint_follower_msgs::dtlane wd;
 	wd.dist = vd.dist;
 	wd.dir = vd.dir;
 	wd.apara = vd.apara;
@@ -521,7 +521,7 @@ waypoint_follower::dtlane create_waypoint_follower_dtlane(const vector_map::DTLa
 	return wd;
 }
 
-vector_map::DTLane create_vector_map_dtlane(const waypoint_follower::dtlane&amp; wd)
+vector_map::DTLane create_vector_map_dtlane(const waypoint_follower_msgs::dtlane&amp; wd)
 {
 	vector_map::DTLane vd;
 	vd.dist = wd.dist;
@@ -572,22 +572,22 @@ VectorMap create_lane_vmap(const VectorMap&amp; vmap, int lno)
 	return lane_vmap;
 }
 
-VectorMap create_coarse_vmap_from_lane(const waypoint_follower::lane&amp; lane)
+VectorMap create_coarse_vmap_from_lane(const waypoint_follower_msgs::lane&amp; lane)
 {
 	VectorMap coarse_vmap;
-	for (const waypoint_follower::waypoint&amp; w : lane.waypoints)
+	for (const waypoint_follower_msgs::waypoint&amp; w : lane.waypoints)
 		coarse_vmap.points.push_back(create_vector_map_point(w.pose.pose.position));
 
 	return coarse_vmap;
 }
 
-VectorMap create_coarse_vmap_from_route(const tablet_socket::route_cmd&amp; route)
+VectorMap create_coarse_vmap_from_route(const tablet_socket_msgs::route_cmd&amp; route)
 {
 	geo_pos_conv geo;
 	geo.set_plane(7);
 
 	VectorMap coarse_vmap;
-	for (const tablet_socket::Waypoint&amp; w : route.point) {
+	for (const tablet_socket_msgs::Waypoint&amp; w : route.point) {
 		geo.llh_to_xyz(w.lat, w.lon, 0);
 
 		vector_map::Point p;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_navi\lane_navi.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_navi\lane_navi.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -34,7 +34,7 @@
 #include &lt;tf/transform_datatypes.h&gt;
 
 #include &lt;vector_map/vector_map.h&gt;
-#include &lt;waypoint_follower/LaneArray.h&gt;
+#include &lt;waypoint_follower_msgs/LaneArray.h&gt;
 
 #include &lt;lane_planner/vmap.hpp&gt;
 
@@ -50,7 +50,7 @@ ros::Publisher waypoint_pub;
 
 lane_planner::vmap::VectorMap all_vmap;
 lane_planner::vmap::VectorMap lane_vmap;
-tablet_socket::route_cmd cached_route;
+tablet_socket_msgs::route_cmd cached_route;
 
 std::vector&lt;std::string&gt; split(const std::string&amp; str, char delim)
 {
@@ -90,7 +90,7 @@ int count_lane(const lane_planner::vmap::VectorMap&amp; vmap)
 	return lcnt;
 }
 
-void create_waypoint(const tablet_socket::route_cmd&amp; msg)
+void create_waypoint(const tablet_socket_msgs::route_cmd&amp; msg)
 {
 	std_msgs::Header header;
 	header.stamp = ros::Time::now();
@@ -123,9 +123,9 @@ void create_waypoint(const tablet_socket::route_cmd&amp; msg)
 		fine_vmaps.push_back(v);
 	}
 
-	waypoint_follower::LaneArray lane_waypoint;
+	waypoint_follower_msgs::LaneArray lane_waypoint;
 	for (const lane_planner::vmap::VectorMap&amp; v : fine_vmaps) {
-		waypoint_follower::lane l;
+		waypoint_follower_msgs::lane l;
 		l.header = header;
 		l.increment = 1;
 
@@ -147,7 +147,7 @@ void create_waypoint(const tablet_socket::route_cmd&amp; msg)
 				yaw = atan2(p2.y - p1.y, p2.x - p1.x);
 			}
 
-			waypoint_follower::waypoint w;
+			waypoint_follower_msgs::waypoint w;
 			w.pose.header = header;
 			w.pose.pose.position = lane_planner::vmap::create_geometry_msgs_point(v.points[i]);
 			w.pose.pose.orientation = tf::createQuaternionMsgFromYaw(yaw);
@@ -237,7 +237,7 @@ int main(int argc, char **argv)
 		return EXIT_FAILURE;
 	}
 
-	waypoint_pub = n.advertise&lt;waypoint_follower::LaneArray&gt;("/lane_waypoints_array", pub_waypoint_queue_size,
+	waypoint_pub = n.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("/lane_waypoints_array", pub_waypoint_queue_size,
 								 pub_waypoint_latch);
 
 	ros::Subscriber route_sub = n.subscribe("/route_cmd", sub_route_queue_size, create_waypoint);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" added_lines="26" deleted_lines="26">
				<diff>@@ -38,7 +38,7 @@
 
 #include &lt;vector_map/vector_map.h&gt;
 #include &lt;runtime_manager/ConfigLaneRule.h&gt;
-#include &lt;waypoint_follower/LaneArray.h&gt;
+#include &lt;waypoint_follower_msgs/LaneArray.h&gt;
 
 #include &lt;lane_planner/vmap.hpp&gt;
 
@@ -65,7 +65,7 @@ lane_planner::vmap::VectorMap lane_vmap;
 double curve_radius_min;
 double crossroad_radius_min;
 double clothoid_radius_min;
-waypoint_follower::LaneArray cached_waypoint;
+waypoint_follower_msgs::LaneArray cached_waypoint;
 
 #ifdef DEBUG
 visualization_msgs::Marker debug_marker;
@@ -73,12 +73,12 @@ ros::Publisher marker_pub;
 int marker_cnt;
 #endif // DEBUG
 
-waypoint_follower::lane create_new_lane(const waypoint_follower::lane&amp; lane, const std_msgs::Header&amp; header)
+waypoint_follower_msgs::lane create_new_lane(const waypoint_follower_msgs::lane&amp; lane, const std_msgs::Header&amp; header)
 {
-	waypoint_follower::lane l = lane;
+	waypoint_follower_msgs::lane l = lane;
 	l.header = header;
 
-	for (waypoint_follower::waypoint&amp; w : l.waypoints) {
+	for (waypoint_follower_msgs::waypoint&amp; w : l.waypoints) {
 		w.pose.header = header;
 		w.twist.header = header;
 	}
@@ -86,10 +86,10 @@ waypoint_follower::lane create_new_lane(const waypoint_follower::lane&amp; lane, con
 	return l;
 }
 
-waypoint_follower::lane apply_acceleration(const waypoint_follower::lane&amp; lane, double acceleration,
+waypoint_follower_msgs::lane apply_acceleration(const waypoint_follower_msgs::lane&amp; lane, double acceleration,
 					   size_t start_index, size_t fixed_cnt, double fixed_vel)
 {
-	waypoint_follower::lane l = lane;
+	waypoint_follower_msgs::lane l = lane;
 
 	if (fixed_cnt == 0)
 		return l;
@@ -116,9 +116,9 @@ waypoint_follower::lane apply_acceleration(const waypoint_follower::lane&amp; lane,
 	return l;
 }
 
-waypoint_follower::lane apply_crossroad_acceleration(const waypoint_follower::lane&amp; lane, double acceleration)
+waypoint_follower_msgs::lane apply_crossroad_acceleration(const waypoint_follower_msgs::lane&amp; lane, double acceleration)
 {
-	waypoint_follower::lane l = lane;
+	waypoint_follower_msgs::lane l = lane;
 
 	bool crossroad = false;
 	std::vector&lt;size_t&gt; start_indexes;
@@ -162,11 +162,11 @@ waypoint_follower::lane apply_crossroad_acceleration(const waypoint_follower::la
 	return l;
 }
 
-waypoint_follower::lane apply_stopline_acceleration(const waypoint_follower::lane&amp; lane, double acceleration,
+waypoint_follower_msgs::lane apply_stopline_acceleration(const waypoint_follower_msgs::lane&amp; lane, double acceleration,
 						    const lane_planner::vmap::VectorMap&amp; fine_vmap, size_t ahead_cnt,
 						    size_t behind_cnt)
 {
-	waypoint_follower::lane l = lane;
+	waypoint_follower_msgs::lane l = lane;
 
 	std::vector&lt;size_t&gt; indexes;
 	for (size_t i = 0; i &lt; fine_vmap.stoplines.size(); ++i) {
@@ -225,7 +225,7 @@ std::vector&lt;vector_map::Point&gt; create_stop_points(const lane_planner::vmap::Vect
 }
 
 std::vector&lt;size_t&gt; create_stop_indexes(const lane_planner::vmap::VectorMap&amp; vmap,
-					const waypoint_follower::lane&amp; lane, double stopline_search_radius)
+					const waypoint_follower_msgs::lane&amp; lane, double stopline_search_radius)
 {
 	std::vector&lt;size_t&gt; stop_indexes;
 	for (const vector_map::Point&amp; p : create_stop_points(vmap)) {
@@ -249,10 +249,10 @@ std::vector&lt;size_t&gt; create_stop_indexes(const lane_planner::vmap::VectorMap&amp; vma
 	return stop_indexes;
 }
 
-waypoint_follower::lane apply_stopline_acceleration(const waypoint_follower::lane&amp; lane, double acceleration,
+waypoint_follower_msgs::lane apply_stopline_acceleration(const waypoint_follower_msgs::lane&amp; lane, double acceleration,
 						    double stopline_search_radius, size_t ahead_cnt, size_t behind_cnt)
 {
-	waypoint_follower::lane l = lane;
+	waypoint_follower_msgs::lane l = lane;
 
 	std::vector&lt;size_t&gt; indexes = create_stop_indexes(lane_vmap, l, stopline_search_radius);
 	if (indexes.empty())
@@ -276,7 +276,7 @@ waypoint_follower::lane apply_stopline_acceleration(const waypoint_follower::lan
 	return l;
 }
 
-bool is_fine_vmap(const lane_planner::vmap::VectorMap&amp; fine_vmap, const waypoint_follower::lane&amp; lane)
+bool is_fine_vmap(const lane_planner::vmap::VectorMap&amp; fine_vmap, const waypoint_follower_msgs::lane&amp; lane)
 {
 	if (fine_vmap.points.size() != lane.waypoints.size())
 		return false;
@@ -366,7 +366,7 @@ std_msgs::ColorRGBA create_color(int index)
 }
 #endif // DEBUG
 
-void create_waypoint(const waypoint_follower::LaneArray&amp; msg)
+void create_waypoint(const waypoint_follower_msgs::LaneArray&amp; msg)
 {
 	std_msgs::Header header;
 	header.stamp = ros::Time::now();
@@ -374,7 +374,7 @@ void create_waypoint(const waypoint_follower::LaneArray&amp; msg)
 
 	cached_waypoint.lanes.clear();
 	cached_waypoint.lanes.shrink_to_fit();
-	for (const waypoint_follower::lane&amp; l : msg.lanes)
+	for (const waypoint_follower_msgs::lane&amp; l : msg.lanes)
 		cached_waypoint.lanes.push_back(create_new_lane(l, header));
 	if (all_vmap.points.empty() || all_vmap.lanes.empty() || all_vmap.nodes.empty() ||
 	    all_vmap.stoplines.empty() || all_vmap.dtlanes.empty()) {
@@ -386,11 +386,11 @@ void create_waypoint(const waypoint_follower::LaneArray&amp; msg)
 	marker_cnt = msg.lanes.size();
 #endif // DEBUG
 
-	waypoint_follower::LaneArray traffic_waypoint;
-	waypoint_follower::LaneArray red_waypoint;
-	waypoint_follower::LaneArray green_waypoint;
+	waypoint_follower_msgs::LaneArray traffic_waypoint;
+	waypoint_follower_msgs::LaneArray red_waypoint;
+	waypoint_follower_msgs::LaneArray green_waypoint;
 	for (size_t i = 0; i &lt; msg.lanes.size(); ++i) {
-		waypoint_follower::lane lane = create_new_lane(msg.lanes[i], header);
+		waypoint_follower_msgs::lane lane = create_new_lane(msg.lanes[i], header);
 
 		lane_planner::vmap::VectorMap coarse_vmap =
 			lane_planner::vmap::create_coarse_vmap_from_lane(lane);
@@ -488,7 +488,7 @@ void update_values()
 #endif // DEBUG
 
 	if (!cached_waypoint.lanes.empty()) {
-		waypoint_follower::LaneArray update_waypoint = cached_waypoint;
+		waypoint_follower_msgs::LaneArray update_waypoint = cached_waypoint;
 		create_waypoint(update_waypoint);
 	}
 }
@@ -531,7 +531,7 @@ void config_parameter(const runtime_manager::ConfigLaneRule&amp; msg)
 	config_number_of_zeros_behind = msg.number_of_zeros_behind;
 
 	if (!cached_waypoint.lanes.empty()) {
-		waypoint_follower::LaneArray update_waypoint = cached_waypoint;
+		waypoint_follower_msgs::LaneArray update_waypoint = cached_waypoint;
 		create_waypoint(update_waypoint);
 	}
 }
@@ -568,11 +568,11 @@ int main(int argc, char **argv)
 	n.param&lt;double&gt;("/lane_rule/clothoid_weight", clothoid_weight, 0.215);
 	n.param&lt;std::string&gt;("/lane_rule/frame_id", frame_id, "map");
 
-	traffic_pub = n.advertise&lt;waypoint_follower::LaneArray&gt;("/traffic_waypoints_array", pub_waypoint_queue_size,
+	traffic_pub = n.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("/traffic_waypoints_array", pub_waypoint_queue_size,
 								pub_waypoint_latch);
-	red_pub = n.advertise&lt;waypoint_follower::LaneArray&gt;("/red_waypoints_array", pub_waypoint_queue_size,
+	red_pub = n.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("/red_waypoints_array", pub_waypoint_queue_size,
 							    pub_waypoint_latch);
-	green_pub = n.advertise&lt;waypoint_follower::LaneArray&gt;("/green_waypoints_array", pub_waypoint_queue_size,
+	green_pub = n.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("/green_waypoints_array", pub_waypoint_queue_size,
 							      pub_waypoint_latch);
 
 #ifdef DEBUG
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -50,11 +50,11 @@ void getPointAndVectorFromPose(const geometry_msgs::Pose &amp;pose, Element2D *point
   vector-&gt;set(tmp_tf_vevtor.getX(), tmp_tf_vevtor.getY());
 }
 
-std::vector&lt;waypoint_follower::waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
+std::vector&lt;waypoint_follower_msgs::waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
                                                                     const geometry_msgs::Pose &amp;end,
                                                                     const double velocity_mps, const double vlength)
 {
-  std::vector&lt;waypoint_follower::waypoint&gt; wps;
+  std::vector&lt;waypoint_follower_msgs::waypoint&gt; wps;
   Element2D p0(0, 0), v0(0, 0), p1(0, 0), v1(0, 0);
   getPointAndVectorFromPose(start, &amp;p0, &amp;v0);
   getPointAndVectorFromPose(end, &amp;p1, &amp;v1);
@@ -64,7 +64,7 @@ std::vector&lt;waypoint_follower::waypoint&gt; generateHermiteCurveForROS(const geomet
   double height_d = fabs(start.position.z - end.position.z);
   for (uint32_t i = 0; i &lt; result.size(); i++)
   {
-    waypoint_follower::waypoint wp;
+    waypoint_follower_msgs::waypoint wp;
     wp.pose.pose.position.x = result.at(i).x;
     wp.pose.pose.position.y = result.at(i).y;
     wp.twist.twist.linear.x = velocity_mps;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.h" added_lines="3" deleted_lines="2">
				<diff>@@ -43,7 +43,8 @@
 #include &lt;tf/transform_datatypes.h&gt;
 #include &lt;geometry_msgs/Pose.h&gt;
 
-#include "waypoint_follower/lane.h"
+#include "waypoint_follower_msgs/lane.h"
+#include "waypoint_follower_msgs/waypoint.h"
 
 namespace lane_planner
 {
@@ -65,7 +66,7 @@ struct Element2D
 
 std::vector&lt;Element2D&gt; generateHermiteCurve(const Element2D &amp;p0, const Element2D &amp;v0, const Element2D &amp;p1,
                                             const Element2D &amp;v1, const double vlength = 20);
-std::vector&lt;waypoint_follower::waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
+std::vector&lt;waypoint_follower_msgs::waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
                                                                     const geometry_msgs::Pose &amp;end,
                                                                     const double velocity, const double vlength);
 void createVectorFromPose(const geometry_msgs::Pose &amp;p, tf::Vector3 *v);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -69,7 +69,7 @@ void LaneSelectNode::initForROS()
   sub5_ = nh_.subscribe("/config/lane_select", 1, &amp;LaneSelectNode::callbackFromConfig, this);
 
   // setup publisher
-  pub1_ = nh_.advertise&lt;waypoint_follower::lane&gt;("base_waypoints", 1);
+  pub1_ = nh_.advertise&lt;waypoint_follower_msgs::lane&gt;("base_waypoints", 1);
   pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1);
   pub3_ = nh_.advertise&lt;std_msgs::Int32&gt;("change_flag", 1);
   vis_pub1_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("lane_select_marker", 1);
@@ -183,7 +183,7 @@ void LaneSelectNode::processing()
   resetSubscriptionFlag();
 }
 
-int32_t LaneSelectNode::getClosestLaneChangeWaypointNumber(const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps, int32_t cl_wp)
+int32_t LaneSelectNode::getClosestLaneChangeWaypointNumber(const std::vector&lt;waypoint_follower_msgs::waypoint&gt; &amp;wps, int32_t cl_wp)
 {
 
   for (uint32_t i = cl_wp; i &lt; wps.size(); i++)
@@ -203,7 +203,7 @@ void LaneSelectNode::createLaneForChange()
   std::get&lt;0&gt;(lane_for_change_).waypoints.shrink_to_fit();
   std::get&lt;1&gt;(lane_for_change_) = -1;
 
-  const waypoint_follower::lane &amp;cur_lane = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_));
+  const waypoint_follower_msgs::lane &amp;cur_lane = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_));
   const int32_t &amp;clst_wp = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
 
   int32_t num_lane_change = getClosestLaneChangeWaypointNumber(cur_lane.waypoints, clst_wp);
@@ -229,7 +229,7 @@ void LaneSelectNode::createLaneForChange()
                          ? current_velocity_.twist.linear.x * lane_change_target_ratio_
                          : lane_change_target_minimum_;
   ROS_INFO("dt : %lf, dt_by_vel : %lf", dt, dt_by_vel);
-  waypoint_follower::lane &amp;nghbr_lane =
+  waypoint_follower_msgs::lane &amp;nghbr_lane =
       static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right
           ? std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_))
           : std::get&lt;0&gt;(tuple_vec_.at(left_lane_idx_));
@@ -255,7 +255,7 @@ void LaneSelectNode::createLaneForChange()
     return;
 
   std::get&lt;0&gt;(lane_for_change_).header.stamp = nghbr_lane.header.stamp;
-  std::vector&lt;waypoint_follower::waypoint&gt; hermite_wps = generateHermiteCurveForROS(
+  std::vector&lt;waypoint_follower_msgs::waypoint&gt; hermite_wps = generateHermiteCurveForROS(
       cur_lane.waypoints.at(num_lane_change).pose.pose, nghbr_lane.waypoints.at(target_num).pose.pose,
       cur_lane.waypoints.at(num_lane_change).twist.twist.linear.x, vlength_hermite_curve_);
 
@@ -582,7 +582,7 @@ void LaneSelectNode::publishVisualizer()
   vis_pub1_.publish(marker_array);
 }
 
-void LaneSelectNode::publishLane(const waypoint_follower::lane &amp;lane)
+void LaneSelectNode::publishLane(const waypoint_follower_msgs::lane &amp;lane)
 {
   // publish global lane
   pub1_.publish(lane);
@@ -603,7 +603,7 @@ void LaneSelectNode::publishChangeFlag(const ChangeFlag flag)
   pub3_.publish(change_flag);
 }
 
-void LaneSelectNode::callbackFromLaneArray(const waypoint_follower::LaneArrayConstPtr &amp;msg)
+void LaneSelectNode::callbackFromLaneArray(const waypoint_follower_msgs::LaneArrayConstPtr &amp;msg)
 {
   tuple_vec_.clear();
   tuple_vec_.shrink_to_fit();
@@ -728,7 +728,7 @@ double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry
 }
 
 // get closest waypoint from current pose
-int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
+int32_t getClosestWaypointNumber(const waypoint_follower_msgs::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
                                  const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number,
                                  const double distance_threshold)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="7" deleted_lines="7">
				<diff>@@ -45,7 +45,7 @@
 #include &lt;tuple&gt;
 
 // User defined includes
-#include "waypoint_follower/LaneArray.h"
+#include "waypoint_follower_msgs/LaneArray.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "runtime_manager/ConfigLaneSelect.h"
 #include "hermite_curve.h"
@@ -91,9 +91,9 @@ private:
   int32_t current_lane_idx_;  // the index of the lane we are driving
   int32_t right_lane_idx_;
   int32_t left_lane_idx_;
-  std::vector&lt;std::tuple&lt;waypoint_follower::lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint,
+  std::vector&lt;std::tuple&lt;waypoint_follower_msgs::lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint,
                                                                                      // change_flag
-  std::tuple&lt;waypoint_follower::lane, int32_t, ChangeFlag&gt; lane_for_change_;
+  std::tuple&lt;waypoint_follower_msgs::lane, int32_t, ChangeFlag&gt; lane_for_change_;
   bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_, is_current_state_subscribed_, is_config_subscribed_;
 
   // parameter from runtime manager
@@ -105,7 +105,7 @@ private:
   std::string current_state_;
 
   // callbacks
-  void callbackFromLaneArray(const waypoint_follower::LaneArrayConstPtr &amp;msg);
+  void callbackFromLaneArray(const waypoint_follower_msgs::LaneArrayConstPtr &amp;msg);
   void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr &amp;msg);
   void callbackFromState(const std_msgs::StringConstPtr &amp;msg);
@@ -128,7 +128,7 @@ private:
   void resetSubscriptionFlag();
   bool isAllTopicsSubscribed();
   void processing();
-  void publishLane(const waypoint_follower::lane &amp;lane);
+  void publishLane(const waypoint_follower_msgs::lane &amp;lane);
   void publishClosestWaypoint(const int32_t clst_wp);
   void publishChangeFlag(const ChangeFlag flag);
   bool getClosestWaypointNumberForEachLanes();
@@ -138,10 +138,10 @@ private:
   void changeLane();
   void updateChangeFlag();
   void createLaneForChange();
-  int32_t getClosestLaneChangeWaypointNumber(const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps, int32_t cl_wp);
+  int32_t getClosestLaneChangeWaypointNumber(const std::vector&lt;waypoint_follower_msgs::waypoint&gt; &amp;wps, int32_t cl_wp);
 };
 
-int32_t getClosestWaypointNumber(const waypoint_follower::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
+int32_t getClosestWaypointNumber(const waypoint_follower_msgs::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
                                  const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number, const double distance_threshold);
 
 double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geometry_msgs::Point &amp;target2);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_stop\lane_stop.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_stop\lane_stop.cpp" added_lines="8" deleted_lines="8">
				<diff>@@ -32,7 +32,7 @@
 
 #include &lt;runtime_manager/ConfigLaneStop.h&gt;
 #include &lt;runtime_manager/traffic_light.h&gt;
-#include &lt;waypoint_follower/LaneArray.h&gt;
+#include &lt;waypoint_follower_msgs/LaneArray.h&gt;
 
 #include &lt;lane_planner/vmap.hpp&gt;
 
@@ -42,14 +42,14 @@ bool config_manual_detection = true;
 
 ros::Publisher traffic_pub;
 
-waypoint_follower::LaneArray current_red_lane;
-waypoint_follower::LaneArray current_green_lane;
+waypoint_follower_msgs::LaneArray current_red_lane;
+waypoint_follower_msgs::LaneArray current_green_lane;
 
-const waypoint_follower::LaneArray *previous_lane = &amp;current_red_lane;
+const waypoint_follower_msgs::LaneArray *previous_lane = &amp;current_red_lane;
 
 void select_current_lane(const runtime_manager::traffic_light&amp; msg)
 {
-	const waypoint_follower::LaneArray *current;
+	const waypoint_follower_msgs::LaneArray *current;
 	switch (msg.traffic_light) {
 	case lane_planner::vmap::TRAFFIC_LIGHT_RED:
 		current = &amp;current_red_lane;
@@ -87,12 +87,12 @@ void receive_manual_detection(const runtime_manager::traffic_light&amp; msg)
 		select_current_lane(msg);
 }
 
-void cache_red_lane(const waypoint_follower::LaneArray&amp; msg)
+void cache_red_lane(const waypoint_follower_msgs::LaneArray&amp; msg)
 {
 	current_red_lane = msg;
 }
 
-void cache_green_lane(const waypoint_follower::LaneArray&amp; msg)
+void cache_green_lane(const waypoint_follower_msgs::LaneArray&amp; msg)
 {
 	current_green_lane = msg;
 }
@@ -121,7 +121,7 @@ int main(int argc, char **argv)
 	bool pub_waypoint_latch;
 	n.param&lt;bool&gt;("/lane_stop/pub_waypoint_latch", pub_waypoint_latch, true);
 
-	traffic_pub = n.advertise&lt;waypoint_follower::LaneArray&gt;("/traffic_waypoints_array", pub_waypoint_queue_size,
+	traffic_pub = n.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("/traffic_waypoints_array", pub_waypoint_queue_size,
 								pub_waypoint_latch);
 
 	ros::Subscriber light_sub = n.subscribe("/light_color", sub_light_queue_size, receive_auto_detection);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_avoid.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_avoid.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -29,12 +29,12 @@
  */
 
 #include &lt;ros/ros.h&gt;
-#include &lt;waypoint_follower/lane.h&gt;
+#include &lt;waypoint_follower_msgs/lane.h&gt;
 #include &lt;iostream&gt;
 
 static ros::Publisher _pub;
 
-void callback(const waypoint_follower::lane &amp;msg)
+void callback(const waypoint_follower_msgs::lane &amp;msg)
 {
     _pub.publish(msg);
 }
@@ -46,7 +46,7 @@ int main(int argc, char **argv)
 
     ros::NodeHandle nh;
     ros::Subscriber twist_sub = nh.subscribe("temporal_waypoints", 1, callback);
-    _pub = nh.advertise&lt;waypoint_follower::lane&gt;("final_waypoints", 1000,true);
+    _pub = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("final_waypoints", 1000,true);
 
     ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -248,7 +248,7 @@ void CrossWalk::setCrossWalkPoints()
   set_points = true;
 }
 
-int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const waypoint_follower::lane&amp; lane, const int search_distance)
+int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const waypoint_follower_msgs::lane&amp; lane, const int search_distance)
 {
   if (!set_points || closest_waypoint &lt; 0)
     return -1;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" added_lines="1" deleted_lines="1">
				<diff>@@ -63,7 +63,7 @@ public:
   geometry_msgs::Point getPoint(const int &amp;pid) const;
   void calcCenterPoints();
   void setCrossWalkPoints();
-  int findClosestCrosswalk(const int closest_waypoint, const waypoint_follower::lane&amp; lane, const int search_distance);
+  int findClosestCrosswalk(const int closest_waypoint, const waypoint_follower_msgs::lane&amp; lane, const int search_distance);
   int getSize() const
   {
     return detection_points_.size();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -89,7 +89,7 @@ void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points
   //obstacle_pub.publish(marker);
 }
 
-void displayDetectionRange(const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, const int closest_waypoint, const EControl &amp;kind, const int obstacle_waypoint, const double stop_range, const double deceleration_range, const ros::Publisher&amp; detection_range_pub)
+void displayDetectionRange(const waypoint_follower_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const int closest_waypoint, const EControl &amp;kind, const int obstacle_waypoint, const double stop_range, const double deceleration_range, const ros::Publisher&amp; detection_range_pub)
 {
   // set up for marker array
   visualization_msgs::MarkerArray marker_array;
@@ -231,7 +231,7 @@ EControl crossWalkDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const
   return EControl::KEEP;  // find no obstacles
 }
 
-int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, double stop_range, double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose, ObstaclePoints* obstacle_points)
+int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const waypoint_follower_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, double stop_range, double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose, ObstaclePoints* obstacle_points)
 {
   int stop_obstacle_waypoint = -1;
   // start search from the closest waypoint
@@ -290,7 +290,7 @@ int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int c
   return stop_obstacle_waypoint;
 }
 
-int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const waypoint_follower::lane&amp; lane, const double stop_range, const double deceleration_range, const double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose, ObstaclePoints* obstacle_points)
+int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const waypoint_follower_msgs::lane&amp; lane, const double stop_range, const double deceleration_range, const double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose, ObstaclePoints* obstacle_points)
 {
   int decelerate_obstacle_waypoint = -1;
   // start search from the closest waypoint
@@ -340,7 +340,7 @@ int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const
 
 
 // Detect an obstacle by using pointcloud
-EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo&amp; vs_info, int* obstacle_waypoint, ObstaclePoints* obstacle_points)
+EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const waypoint_follower_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo&amp; vs_info, int* obstacle_waypoint, ObstaclePoints* obstacle_points)
 {
   if (points.empty() == true || closest_waypoint &lt; 0)
     return EControl::KEEP;
@@ -388,7 +388,7 @@ EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int
 
 }
 
-EControl obstacleDetection(int closest_waypoint, const waypoint_follower::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo vs_info, const ros::Publisher&amp; detection_range_pub, const ros::Publisher&amp; obstacle_pub, int* obstacle_waypoint)
+EControl obstacleDetection(int closest_waypoint, const waypoint_follower_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo vs_info, const ros::Publisher&amp; detection_range_pub, const ros::Publisher&amp; obstacle_pub, int* obstacle_waypoint)
 {
   ObstaclePoints obstacle_points;
   EControl detection_result = pointsDetection(vs_info.getPoints(), closest_waypoint, lane, crosswalk, vs_info, obstacle_waypoint, &amp;obstacle_points);
@@ -500,7 +500,7 @@ int main(int argc, char **argv)
 
   // publisher
   ros::Publisher detection_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 0);
-  ros::Publisher temporal_waypoints_pub = nh.advertise&lt;waypoint_follower::lane&gt;("temporal_waypoints", 1000, true);
+  ros::Publisher temporal_waypoints_pub = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("temporal_waypoints", 1000, true);
   ros::Publisher obstacle_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("obstacle", 0);
 
   ros::Rate loop_rate(LOOP_RATE);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -63,7 +63,7 @@ void VelocitySetPath::setTemporalWaypoints(int temporal_waypoints_size, int clos
   temporal_waypoints_.header = new_waypoints_.header;
   temporal_waypoints_.increment = new_waypoints_.increment;
   // push current pose
-  waypoint_follower::waypoint current_point;
+  waypoint_follower_msgs::waypoint current_point;
 
   current_point.pose = control_pose;
   current_point.twist = new_waypoints_.waypoints[closest_waypoint].twist;
@@ -222,7 +222,7 @@ double VelocitySetPath::calcInterval(const int begin, const int end) const
 }
 
 
-void VelocitySetPath::waypointsCallback(const waypoint_follower::laneConstPtr&amp; msg)
+void VelocitySetPath::waypointsCallback(const waypoint_follower_msgs::laneConstPtr&amp; msg)
 {
   prev_waypoints_ = *msg;
   new_waypoints_ = *msg;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_path.h" added_lines="8" deleted_lines="7">
				<diff>@@ -31,13 +31,14 @@
 #ifndef VELOCITY_SET_PATH_H
 #define VELOCITY_SET_PATH_H
 
+#include &lt;waypoint_follower_msgs/lane.h&gt;
 #include "waypoint_follower/libwaypoint_follower.h"
 class VelocitySetPath
 {
  private:
-  waypoint_follower::lane prev_waypoints_;
-  waypoint_follower::lane new_waypoints_;
-  waypoint_follower::lane temporal_waypoints_;
+  waypoint_follower_msgs::lane prev_waypoints_;
+  waypoint_follower_msgs::lane new_waypoints_;
+  waypoint_follower_msgs::lane temporal_waypoints_;
   bool set_path_;
   double current_vel_;
 
@@ -59,22 +60,22 @@ class VelocitySetPath
   void initializeNewWaypoints();
 
   // ROS Callbacks
-  void waypointsCallback(const waypoint_follower::laneConstPtr&amp; msg);
+  void waypointsCallback(const waypoint_follower_msgs::laneConstPtr&amp; msg);
   void currentVelocityCallback(const geometry_msgs::TwistStampedConstPtr&amp; msg);
 
   double calcInterval(const int begin, const int end) const;
 
-  waypoint_follower::lane getPrevWaypoints() const
+  waypoint_follower_msgs::lane getPrevWaypoints() const
   {
     return prev_waypoints_;
   }
 
-  waypoint_follower::lane getNewWaypoints() const
+  waypoint_follower_msgs::lane getNewWaypoints() const
   {
     return new_waypoints_;
   }
 
-  waypoint_follower::lane getTemporalWaypoints() const
+  waypoint_follower_msgs::lane getTemporalWaypoints() const
   {
     return temporal_waypoints_;
   }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_trajectory_gen\lattice_trajectory_gen.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_trajectory_gen\lattice_trajectory_gen.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -124,7 +124,7 @@ static void currentVelCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg)
   g_current_velocity = msg-&gt;twist.linear.x;
 }
 
-static void WayPointCallback(const waypoint_follower::laneConstPtr &amp;msg)
+static void WayPointCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg)
 {
   g_current_waypoints.setPath(*msg);
   g_waypoint_set = true;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_velocity_set\lattice_velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\lattice_velocity_set\lattice_velocity_set.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -46,7 +46,7 @@
 #include &lt;runtime_manager/ConfigLatticeVelocitySet.h&gt;
 #include &lt;iostream&gt;
 
-#include "waypoint_follower/lane.h"
+#include "waypoint_follower_msgs/lane.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "libvelocity_set.h"
 
@@ -97,7 +97,7 @@ WayPoints g_path_dk;
 class PathVset : public WayPoints
 {
 private:
-  waypoint_follower::lane temporal_waypoints_;
+  waypoint_follower_msgs::lane temporal_waypoints_;
 
 public:
   void changeWaypoints(int stop_waypoint);
@@ -106,7 +106,7 @@ public:
   void setDeceleration();
   bool checkWaypoint(int num, const char *name) const;
   void setTemporalWaypoints();
-  waypoint_follower::lane getTemporalWaypoints() const
+  waypoint_follower_msgs::lane getTemporalWaypoints() const
   {
     return temporal_waypoints_;
   }
@@ -138,7 +138,7 @@ void PathVset::setTemporalWaypoints()
   temporal_waypoints_.header = current_waypoints_.header;
   temporal_waypoints_.increment = current_waypoints_.increment;
   // push current pose
-  waypoint_follower::waypoint current_point;
+  waypoint_follower_msgs::waypoint current_point;
 
   current_point.pose = g_control_pose;
   current_point.twist = current_waypoints_.waypoints[g_closest_waypoint].twist;
@@ -279,7 +279,7 @@ void PathVset::changeWaypoints(int stop_waypoint)
 
     changed_vel = sqrt(2.0 * g_decel * (interval * i));  // sqrt(2*a*x)
 
-    waypoint_follower::waypoint initial_waypoint = g_path_dk.getCurrentWaypoints().waypoints[num];
+    waypoint_follower_msgs::waypoint initial_waypoint = g_path_dk.getCurrentWaypoints().waypoints[num];
     if (changed_vel &gt; initial_waypoint.twist.twist.linear.x)
     {  // avoid acceleration
       current_waypoints_.waypoints[num].twist.twist.linear.x = initial_waypoint.twist.twist.linear.x;
@@ -330,7 +330,7 @@ void currentVelCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg)
   g_current_vel = msg-&gt;twist.linear.x;
 }
 
-void baseWaypointCallback(const waypoint_follower::laneConstPtr &amp;msg)
+void baseWaypointCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg)
 {
   g_path_dk.setPath(*msg);
   g_path_change.setPath(*msg);
@@ -838,7 +838,7 @@ int main(int argc, char **argv)
 
   g_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 0);
   g_sound_pub = nh.advertise&lt;std_msgs::String&gt;("sound_player", 10);
-  g_temporal_waypoints_pub = nh.advertise&lt;waypoint_follower::lane&gt;("temporal_waypoints", 1000, true);
+  g_temporal_waypoints_pub = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("temporal_waypoints", 1000, true);
   ros::Publisher closest_waypoint_pub;
   closest_waypoint_pub = nh.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1000);
   g_obstacle_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("obstacle", 0);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\path_select\path_select.cpp" new_path="ros\src\computing\planning\motion\packages\lattice_planner\nodes\path_select\path_select.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -29,12 +29,12 @@
  */
 
 #include &lt;ros/ros.h&gt;
-#include &lt;waypoint_follower/lane.h&gt;
+#include &lt;waypoint_follower_msgs/lane.h&gt;
 #include &lt;iostream&gt;
 
 static ros::Publisher _pub;
 
-void callback(const waypoint_follower::lane &amp;msg)
+void callback(const waypoint_follower_msgs::lane &amp;msg)
 {
     _pub.publish(msg);
 }
@@ -46,7 +46,7 @@ int main(int argc, char **argv)
 
     ros::NodeHandle nh;
     ros::Subscriber twist_sub = nh.subscribe("temporal_waypoints", 1, callback);
-    _pub = nh.advertise&lt;waypoint_follower::lane&gt;("final_waypoints", 1000,true);
+    _pub = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("final_waypoints", 1000,true);
 
     ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\include\waypoint_follower\libwaypoint_follower.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\include\waypoint_follower\libwaypoint_follower.h" added_lines="5" deleted_lines="5">
				<diff>@@ -39,15 +39,15 @@
 // ROS header
 #include &lt;tf/transform_broadcaster.h&gt;
 #include &lt;tf/transform_listener.h&gt;
-#include "waypoint_follower/lane.h"
+#include "waypoint_follower_msgs/lane.h"
 
 class WayPoints
 {
 protected:
-  waypoint_follower::lane current_waypoints_;
+  waypoint_follower_msgs::lane current_waypoints_;
 
 public:
-  void setPath(const waypoint_follower::lane &amp;waypoints)
+  void setPath(const waypoint_follower_msgs::lane &amp;waypoints)
   {
     current_waypoints_ = waypoints;
   }
@@ -61,7 +61,7 @@ public:
   geometry_msgs::Quaternion getWaypointOrientation(int waypoint) const;
   geometry_msgs::Pose getWaypointPose(int waypoint) const;
   double getWaypointVelocityMPS(int waypoint) const;
-  waypoint_follower::lane getCurrentWaypoints() const
+  waypoint_follower_msgs::lane getCurrentWaypoints() const
   {
     return current_waypoints_;
   }
@@ -96,7 +96,7 @@ geometry_msgs::Point calcAbsoluteCoordinate(geometry_msgs::Point point,
                                                                                 // coordinate
 double getPlaneDistance(geometry_msgs::Point target1,
                         geometry_msgs::Point target2);  // get 2 dimentional distance between target 1 and target 2
-int getClosestWaypoint(const waypoint_follower::lane &amp;current_path, geometry_msgs::Pose current_pose);
+int getClosestWaypoint(const waypoint_follower_msgs::lane &amp;current_path, geometry_msgs::Pose current_pose);
 bool getLinearEquation(geometry_msgs::Point start, geometry_msgs::Point end, double *a, double *b, double *c);
 double getDistanceBetweenLineAndPoint(geometry_msgs::Point point, double sa, double b, double c);
 double getRelativeAngle(geometry_msgs::Pose waypoint_pose, geometry_msgs::Pose vehicle_pose);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\lib\libwaypoint_follower.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\lib\libwaypoint_follower.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -172,7 +172,7 @@ double getRelativeAngle(geometry_msgs::Pose waypoint_pose, geometry_msgs::Pose v
 }
 
 // get closest waypoint from current pose
-int getClosestWaypoint(const waypoint_follower::lane &amp;current_path, geometry_msgs::Pose current_pose)
+int getClosestWaypoint(const waypoint_follower_msgs::lane &amp;current_path, geometry_msgs::Pose current_pose)
 {
   WayPoints wp;
   wp.setPath(current_path);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit.h" added_lines="3" deleted_lines="3">
				<diff>@@ -37,7 +37,7 @@
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 
 // User defined includes
-#include "waypoint_follower/lane.h"
+#include "waypoint_follower_msgs/lane.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 
 namespace waypoint_follower
@@ -57,7 +57,7 @@ public:
   {
     current_linear_velocity_ = cur_vel;
   }
-  void setCurrentWaypoints(const std::vector&lt;waypoint_follower::waypoint&gt; &amp;wps)
+  void setCurrentWaypoints(const std::vector&lt;waypoint_follower_msgs::waypoint&gt; &amp;wps)
   {
     current_waypoints_ = wps;
   }
@@ -102,7 +102,7 @@ private:
   double lookahead_distance_;
   geometry_msgs::Pose current_pose_;
   double current_linear_velocity_;
-  std::vector&lt;waypoint_follower::waypoint&gt; current_waypoints_;
+  std::vector&lt;waypoint_follower_msgs::waypoint&gt; current_waypoints_;
 
   // functions
   double calcCurvature(geometry_msgs::Point target) const;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -76,7 +76,7 @@ void PurePursuitNode::initForROS()
 
   // setup publisher
   pub1_ = nh_.advertise&lt;geometry_msgs::TwistStamped&gt;("twist_raw", 10);
-  pub2_ = nh_.advertise&lt;waypoint_follower::ControlCommandStamped&gt;("ctrl_cmd", 10);
+  pub2_ = nh_.advertise&lt;waypoint_follower_msgs::ControlCommandStamped&gt;("ctrl_cmd", 10);
   pub11_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("next_waypoint_mark", 0);
   pub12_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("next_target_mark", 0);
   pub13_ = nh_.advertise&lt;visualization_msgs::Marker&gt;("search_circle_mark", 0);
@@ -134,7 +134,7 @@ void PurePursuitNode::publishControlCommandStamped(const bool &amp;can_get_curvature
   if (!publishes_for_steering_robot_)
     return;
 
-  waypoint_follower::ControlCommandStamped ccs;
+  waypoint_follower_msgs::ControlCommandStamped ccs;
   ccs.header.stamp = ros::Time::now();
   ccs.cmd.linear_velocity = can_get_curvature ? computeCommandVelocity() : 0;
   ccs.cmd.steering_angle = can_get_curvature ? convertCurvatureToSteeringAngle(wheel_base_, kappa) : 0;
@@ -186,7 +186,7 @@ void PurePursuitNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStam
   is_velocity_set_ = true;
 }
 
-void PurePursuitNode::callbackFromWayPoints(const waypoint_follower::laneConstPtr &amp;msg)
+void PurePursuitNode::callbackFromWayPoints(const waypoint_follower_msgs::laneConstPtr &amp;msg)
 {
   if (!msg-&gt;waypoints.empty())
     command_linear_velocity_ = msg-&gt;waypoints.at(0).twist.twist.linear.x;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\pure_pursuit\pure_pursuit_core.h" added_lines="3" deleted_lines="3">
				<diff>@@ -39,8 +39,8 @@
 
 // User defined includes
 #include "runtime_manager/ConfigWaypointFollower.h"
-#include "waypoint_follower/lane.h"
-#include "waypoint_follower/ControlCommandStamped.h"
+#include "waypoint_follower_msgs/lane.h"
+#include "waypoint_follower_msgs/ControlCommandStamped.h"
 #include "pure_pursuit_viz.h"
 #include "pure_pursuit.h"
 
@@ -101,7 +101,7 @@ private:
   void callbackFromConfig(const runtime_manager::ConfigWaypointFollowerConstPtr &amp;config);
   void callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStampedConstPtr &amp;msg);
-  void callbackFromWayPoints(const waypoint_follower::laneConstPtr &amp;msg);
+  void callbackFromWayPoints(const waypoint_follower_msgs::laneConstPtr &amp;msg);
 
   // initializer
   void initForROS();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -133,7 +133,7 @@ void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg)
   _initial_set = true;
 }
 
-void waypointCallback(const waypoint_follower::laneConstPtr &amp;msg)
+void waypointCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg)
 {
   // _path_og.setPath(msg);
   _current_waypoints.setPath(*msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -48,7 +48,7 @@ WaypointLoaderNode::~WaypointLoaderNode()
 void WaypointLoaderNode::initPublisher()
 {
   // setup publisher
-  lane_pub_ = nh_.advertise&lt;waypoint_follower::LaneArray&gt;("lane_waypoints_array", 10, true);
+  lane_pub_ = nh_.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("lane_waypoints_array", 10, true);
 }
 
 void WaypointLoaderNode::initParameter()
@@ -64,23 +64,23 @@ void WaypointLoaderNode::publishLaneArray()
   // extract file paths
   std::vector&lt;std::string&gt; multi_file_path;
   parseColumns(multi_lane_csv_, &amp;multi_file_path);
-  waypoint_follower::LaneArray lane_array;
+  waypoint_follower_msgs::LaneArray lane_array;
   createLaneArray(multi_file_path, &amp;lane_array);
   lane_pub_.publish(lane_array);
 }
 
 void WaypointLoaderNode::createLaneArray(const std::vector&lt;std::string&gt; &amp;paths,
-                                         waypoint_follower::LaneArray *lane_array)
+                                         waypoint_follower_msgs::LaneArray *lane_array)
 {
   for (auto el : paths)
   {
-    waypoint_follower::lane lane;
+    waypoint_follower_msgs::lane lane;
     createLaneWaypoint(el, &amp;lane);
     lane_array-&gt;lanes.push_back(lane);
   }
 }
 
-void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, waypoint_follower::lane *lane)
+void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, waypoint_follower_msgs::lane *lane)
 {
   if (!verifyFileConsistency(file_path.c_str()))
   {
@@ -90,7 +90,7 @@ void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, waypoi
 
   ROS_INFO("lane data is valid. publishing...");
   FileFormat format = checkFileFormat(file_path.c_str());
-  std::vector&lt;waypoint_follower::waypoint&gt; wps;
+  std::vector&lt;waypoint_follower_msgs::waypoint&gt; wps;
   if (format == FileFormat::ver1)
     loadWaypointsForVer1(file_path.c_str(), &amp;wps);
   else if (format == FileFormat::ver2)
@@ -103,7 +103,7 @@ void WaypointLoaderNode::createLaneWaypoint(const std::string &amp;file_path, waypoi
   lane-&gt;waypoints = wps;
 }
 
-void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;waypoint_follower::waypoint&gt; *wps)
+void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps)
 {
   std::ifstream ifs(filename);
 
@@ -115,7 +115,7 @@ void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;
 
   while (std::getline(ifs, line))
   {
-    waypoint_follower::waypoint wp;
+    waypoint_follower_msgs::waypoint wp;
     parseWaypointForVer1(line, &amp;wp);
     wps-&gt;push_back(wp);
   }
@@ -139,7 +139,7 @@ void WaypointLoaderNode::loadWaypointsForVer1(const char *filename, std::vector&lt;
   }
 }
 
-void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line, waypoint_follower::waypoint *wp)
+void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line, waypoint_follower_msgs::waypoint *wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
@@ -150,7 +150,7 @@ void WaypointLoaderNode::parseWaypointForVer1(const std::string &amp;line, waypoint_
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(columns[3]));
 }
 
-void WaypointLoaderNode::loadWaypointsForVer2(const char *filename, std::vector&lt;waypoint_follower::waypoint&gt; *wps)
+void WaypointLoaderNode::loadWaypointsForVer2(const char *filename, std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps)
 {
   std::ifstream ifs(filename);
 
@@ -162,14 +162,14 @@ void WaypointLoaderNode::loadWaypointsForVer2(const char *filename, std::vector&lt;
 
   while (std::getline(ifs, line))
   {
-    waypoint_follower::waypoint wp;
+    waypoint_follower_msgs::waypoint wp;
     parseWaypointForVer2(line, &amp;wp);
     wps-&gt;push_back(wp);
   }
   planningVelocity(&amp;*wps);
 }
 
-void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line, waypoint_follower::waypoint *wp)
+void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line, waypoint_follower_msgs::waypoint *wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
@@ -181,7 +181,7 @@ void WaypointLoaderNode::parseWaypointForVer2(const std::string &amp;line, waypoint_
   wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(columns[4]));
 }
 
-void WaypointLoaderNode::loadWaypoints(const char *filename, std::vector&lt;waypoint_follower::waypoint&gt; *wps)
+void WaypointLoaderNode::loadWaypoints(const char *filename, std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps)
 {
   std::ifstream ifs(filename);
 
@@ -196,7 +196,7 @@ void WaypointLoaderNode::loadWaypoints(const char *filename, std::vector&lt;waypoin
   std::getline(ifs, line);  // remove second line
   while (std::getline(ifs, line))
   {
-    waypoint_follower::waypoint wp;
+    waypoint_follower_msgs::waypoint wp;
     parseWaypoint(line, contents, &amp;wp);
     wps-&gt;push_back(wp);
   }
@@ -204,7 +204,7 @@ void WaypointLoaderNode::loadWaypoints(const char *filename, std::vector&lt;waypoin
 }
 
 void WaypointLoaderNode::parseWaypoint(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
-                                       waypoint_follower::waypoint *wp)
+                                       waypoint_follower_msgs::waypoint *wp)
 {
   std::vector&lt;std::string&gt; columns;
   parseColumns(line, &amp;columns);
@@ -255,7 +255,7 @@ FileFormat WaypointLoaderNode::checkFileFormat(const char *filename)
           );
 }
 
-void WaypointLoaderNode::planningVelocity(std::vector&lt;waypoint_follower::waypoint&gt; *wps)
+void WaypointLoaderNode::planningVelocity(std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps)
 {
   for (size_t i = 0; i &lt; wps-&gt;size(); ++i)
   {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="10" deleted_lines="10">
				<diff>@@ -41,7 +41,7 @@
 #include &lt;tf/transform_datatypes.h&gt;
 #include &lt;unordered_map&gt;
 
-#include "waypoint_follower/LaneArray.h"
+#include "waypoint_follower_msgs/LaneArray.h"
 
 namespace waypoint_maker
 {
@@ -96,19 +96,19 @@ private:
 
   // functions
 
-  void createLaneWaypoint(const std::string &amp;file_path, waypoint_follower::lane *lane);
-  void createLaneArray(const std::vector&lt;std::string&gt; &amp;paths, waypoint_follower::LaneArray *lane_array);
+  void createLaneWaypoint(const std::string &amp;file_path, waypoint_follower_msgs::lane *lane);
+  void createLaneArray(const std::vector&lt;std::string&gt; &amp;paths, waypoint_follower_msgs::LaneArray *lane_array);
 
   FileFormat checkFileFormat(const char *filename);
   bool verifyFileConsistency(const char *filename);
-  void loadWaypointsForVer1(const char *filename, std::vector&lt;waypoint_follower::waypoint&gt; *wps);
-  void parseWaypointForVer1(const std::string &amp;line, waypoint_follower::waypoint *wp);
-  void loadWaypointsForVer2(const char *filename, std::vector&lt;waypoint_follower::waypoint&gt; *wps);
-  void parseWaypointForVer2(const std::string &amp;line, waypoint_follower::waypoint *wp);
-  void loadWaypoints(const char *filename, std::vector&lt;waypoint_follower::waypoint&gt; *wps);
+  void loadWaypointsForVer1(const char *filename, std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps);
+  void parseWaypointForVer1(const std::string &amp;line, waypoint_follower_msgs::waypoint *wp);
+  void loadWaypointsForVer2(const char *filename, std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps);
+  void parseWaypointForVer2(const std::string &amp;line, waypoint_follower_msgs::waypoint *wp);
+  void loadWaypoints(const char *filename, std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps);
   void parseWaypoint(const std::string &amp;line, const std::vector&lt;std::string&gt; &amp;contents,
-                            waypoint_follower::waypoint *wp);
-  void planningVelocity(std::vector&lt;waypoint_follower::waypoint&gt; *wps);
+                            waypoint_follower_msgs::waypoint *wp);
+  void planningVelocity(std::vector&lt;waypoint_follower_msgs::waypoint&gt; *wps);
   double decelerate(geometry_msgs::Point p1, geometry_msgs::Point p2, double original_velocity_mps);
 
 };
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_marker_publisher\waypoint_marker_publisher.cpp" added_lines="10" deleted_lines="10">
				<diff>@@ -38,7 +38,7 @@
 #include &lt;vector&gt;
 #include &lt;string&gt;
 
-#include "waypoint_follower/LaneArray.h"
+#include "waypoint_follower_msgs/LaneArray.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 #include &lt;runtime_manager/ConfigLaneStop.h&gt;
 #include "runtime_manager/traffic_light.h"
@@ -96,7 +96,7 @@ void publishGlobalMarker()
   g_global_mark_pub.publish(marker_array);
 }
 
-void createGlobalLaneArrayVelocityMarker(const waypoint_follower::LaneArray &amp;lane_waypoints_array)
+void createGlobalLaneArrayVelocityMarker(const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
   // display by markers the velocity of each waypoint.
@@ -138,7 +138,7 @@ void createGlobalLaneArrayVelocityMarker(const waypoint_follower::LaneArray &amp;lan
                                        tmp_marker_array.markers.end());
 }
 
-void createGlobalLaneArrayChangeFlagMarker(const waypoint_follower::LaneArray &amp;lane_waypoints_array)
+void createGlobalLaneArrayChangeFlagMarker(const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
   // display by markers the velocity of each waypoint.
@@ -198,7 +198,7 @@ void createGlobalLaneArrayChangeFlagMarker(const waypoint_follower::LaneArray &amp;l
 }
 
 void createLocalWaypointVelocityMarker(std_msgs::ColorRGBA color, int closest_waypoint,
-                                       const waypoint_follower::lane &amp;lane_waypoint)
+                                       const waypoint_follower_msgs::lane &amp;lane_waypoint)
 {
 
   // display by markers the velocity of each waypoint.
@@ -231,7 +231,7 @@ void createLocalWaypointVelocityMarker(std_msgs::ColorRGBA color, int closest_wa
 
 }
 
-void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const waypoint_follower::LaneArray &amp;lane_waypoints_array)
+void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array)
 {
   visualization_msgs::Marker lane_waypoint_marker;
   lane_waypoint_marker.header.frame_id = "map";
@@ -261,7 +261,7 @@ void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const waypoint_follo
 
 }
 
-void createGlobalLaneArrayOrientationMarker(const waypoint_follower::LaneArray &amp;lane_waypoints_array)
+void createGlobalLaneArrayOrientationMarker(const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
   visualization_msgs::Marker lane_waypoint_marker;
@@ -294,7 +294,7 @@ void createGlobalLaneArrayOrientationMarker(const waypoint_follower::LaneArray &amp;
                                        tmp_marker_array.markers.end());
 }
 
-void createLocalPathMarker(std_msgs::ColorRGBA color, const waypoint_follower::lane &amp;lane_waypoint)
+void createLocalPathMarker(std_msgs::ColorRGBA color, const waypoint_follower_msgs::lane &amp;lane_waypoint)
 {
   visualization_msgs::Marker lane_waypoint_marker;
   lane_waypoint_marker.header.frame_id = "map";
@@ -317,7 +317,7 @@ void createLocalPathMarker(std_msgs::ColorRGBA color, const waypoint_follower::l
   g_local_waypoints_marker_array.markers.push_back(lane_waypoint_marker);
 }
 
-void createLocalPointMarker(const waypoint_follower::lane &amp;lane_waypoint)
+void createLocalPointMarker(const waypoint_follower_msgs::lane &amp;lane_waypoint)
 {
   visualization_msgs::Marker lane_waypoint_marker;
   lane_waypoint_marker.header.frame_id = "map";
@@ -396,7 +396,7 @@ void configParameter(const runtime_manager::ConfigLaneStopConstPtr&amp; msg)
   g_config_manual_detection = msg-&gt;manual_detection;
 }
 
-void laneArrayCallback(const waypoint_follower::LaneArrayConstPtr &amp;msg)
+void laneArrayCallback(const waypoint_follower_msgs::LaneArrayConstPtr &amp;msg)
 {
   g_global_marker_array.markers.clear();
   createGlobalLaneArrayVelocityMarker(*msg);
@@ -406,7 +406,7 @@ void laneArrayCallback(const waypoint_follower::LaneArrayConstPtr &amp;msg)
   publishGlobalMarker();
 }
 
-void temporalCallback(const waypoint_follower::laneConstPtr &amp;msg)
+void temporalCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg)
 {
   g_local_waypoints_marker_array.markers.clear();
   if (_closest_waypoint != -1)
</diff>
			</file>
			<file old_path="ros\src\data\packages\map_file\nodes\points_map_loader\points_map_loader.cpp" new_path="ros\src\data\packages\map_file\nodes\points_map_loader\points_map_loader.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -37,7 +37,7 @@
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;tf/transform_listener.h&gt;
 
-#include &lt;waypoint_follower/LaneArray.h&gt;
+#include &lt;waypoint_follower_msgs/LaneArray.h&gt;
 
 #include &lt;map_file/get_file.h&gt;
 
@@ -419,11 +419,11 @@ void publish_dragged_pcd(const geometry_msgs::PoseWithCovarianceStamped&amp; msg)
 	publish_pcd(create_pcd(p));
 }
 
-void request_lookahead_download(const waypoint_follower::LaneArray&amp; msg)
+void request_lookahead_download(const waypoint_follower_msgs::LaneArray&amp; msg)
 {
 	request_queue.clear_look_ahead();
 
-	for (const waypoint_follower::lane&amp; l : msg.lanes) {
+	for (const waypoint_follower_msgs::lane&amp; l : msg.lanes) {
 		size_t end = l.waypoints.size() - 1;
 		double distance = 0;
 		double threshold = (MARGIN_UNIT / 2) + margin; // XXX better way?
</diff>
			</file>
			<file old_path="ros\src\data\packages\pos_db\nodes\pos_uploader\pos_uploader.cpp" new_path="ros\src\data\packages\pos_db\nodes\pos_uploader\pos_uploader.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -48,7 +48,7 @@
 
 
 #include &lt;pos_db.h&gt;
-#include &lt;cv_tracker/obj_label.h&gt;
+#include &lt;cv_tracker_msgs/obj_label.h&gt;
 
 #define MYNAME		"pos_uploader"
 #define OWN_TOPIC_NAME	"current_pose"
@@ -58,8 +58,8 @@
 using namespace std;
 
 //store subscribed value
-static std::vector &lt;cv_tracker::obj_label&gt; car_positions_array;
-static std::vector &lt;cv_tracker::obj_label&gt; person_positions_array;
+static std::vector &lt;cv_tracker_msgs::obj_label&gt; car_positions_array;
+static std::vector &lt;cv_tracker_msgs::obj_label&gt; person_positions_array;
 //flag for comfirming whether updating position or not
 static size_t car_num = 0;
 static size_t person_num = 0;
@@ -156,7 +156,7 @@ static std::string point_to_insert_statement(const geometry_msgs::Point&amp; point,
   return oss.str();
 }
 
-static std::string makeSendDataDetectedObj(const cv_tracker::obj_label&amp; cp_array, const char *name)
+static std::string makeSendDataDetectedObj(const cv_tracker_msgs::obj_label&amp; cp_array, const char *name)
 {
   std::string timestamp;
   if(use_current_time  || cp_array.header.stamp.sec == 0) {
@@ -259,7 +259,7 @@ static void car_locate_cb(const visualization_msgs::MarkerArray&amp; obj_pose_msg)
 {
 	if (obj_pose_msg.markers.size() &gt; 0) {
 		geometry_msgs::Point tmpPoint;
-		cv_tracker::obj_label tmpLabel;
+		cv_tracker_msgs::obj_label tmpLabel;
 
 		pthread_mutex_lock(&amp;pose_lock_);
 
@@ -282,7 +282,7 @@ static void person_locate_cb(const visualization_msgs::MarkerArray &amp;obj_pose_msg
 {
 	if (obj_pose_msg.markers.size() &gt; 0) {
 		geometry_msgs::Point tmpPoint;
-		cv_tracker::obj_label tmpLabel;
+		cv_tracker_msgs::obj_label tmpLabel;
 
 		pthread_mutex_lock(&amp;pose_lock_);
 
</diff>
			</file>
			<file old_path="ros\src\data\packages\vector_map_server\nodes\vector_map_client\vector_map_client.cpp" new_path="ros\src\data\packages\vector_map_server\nodes\vector_map_client\vector_map_client.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -29,7 +29,7 @@
 */
 
 #include &lt;geometry_msgs/PoseStamped.h&gt;
-#include &lt;waypoint_follower/lane.h&gt;
+#include &lt;waypoint_follower_msgs/lane.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;vector_map/vector_map.h&gt;
 
@@ -61,7 +61,7 @@ class VectorMapClient
 {
 private:
   geometry_msgs::PoseStamped pose_;
-  waypoint_follower::lane waypoints_;
+  waypoint_follower_msgs::lane waypoints_;
 
 public:
   VectorMapClient()
@@ -73,7 +73,7 @@ public:
     return pose_;
   }
 
-  waypoint_follower::lane getWaypoints() const
+  waypoint_follower_msgs::lane getWaypoints() const
   {
     return waypoints_;
   }
@@ -83,7 +83,7 @@ public:
     pose_ = pose;
   }
 
-  void setWaypoints(const waypoint_follower::lane&amp; waypoints)
+  void setWaypoints(const waypoint_follower_msgs::lane&amp; waypoints)
   {
     waypoints_ = waypoints;
   }
</diff>
			</file>
			<file old_path="ros\src\data\packages\vector_map_server\nodes\vector_map_server\vector_map_server.cpp" new_path="ros\src\data\packages\vector_map_server\nodes\vector_map_server\vector_map_server.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -29,7 +29,7 @@
 */
 
 #include &lt;geometry_msgs/PoseStamped.h&gt;
-#include &lt;waypoint_follower/lane.h&gt;
+#include &lt;waypoint_follower_msgs/lane.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;vector_map/vector_map.h&gt;
 
@@ -345,7 +345,7 @@ std::vector&lt;Lane&gt; findNearLanes(const VectorMap&amp; vmap, const std::vector&lt;Lane&gt;&amp;
   return near_lanes;
 }
 
-std::vector&lt;Lane&gt; createFineLanes(const VectorMap&amp; vmap, const waypoint_follower::lane&amp; waypoints, double radius,
+std::vector&lt;Lane&gt; createFineLanes(const VectorMap&amp; vmap, const waypoint_follower_msgs::lane&amp; waypoints, double radius,
                                   int loops)
 {
   std::vector&lt;Lane&gt; null_lanes;
@@ -532,7 +532,7 @@ private:
   ros::Publisher marker_array_pub_;
 
   std::vector&lt;Lane&gt; createTravelingRoute(const geometry_msgs::PoseStamped&amp; pose,
-                                         const waypoint_follower::lane&amp; waypoints)
+                                         const waypoint_follower_msgs::lane&amp; waypoints)
   {
     std::vector&lt;Lane&gt; null_lanes;
 
</diff>
			</file>
			<file old_path="ros\src\socket\packages\tablet_socket\nodes\tablet_receiver\tablet_receiver.cpp" new_path="ros\src\socket\packages\tablet_socket\nodes\tablet_receiver\tablet_receiver.cpp" added_lines="10" deleted_lines="10">
				<diff>@@ -48,9 +48,9 @@
 #include &lt;geo_pos_conv.hh&gt;
 
 #include "ros/ros.h"
-#include "tablet_socket/gear_cmd.h"
-#include "tablet_socket/mode_cmd.h"
-#include "tablet_socket/route_cmd.h"
+#include "tablet_socket_msgs/gear_cmd.h"
+#include "tablet_socket_msgs/mode_cmd.h"
+#include "tablet_socket_msgs/route_cmd.h"
 
 #define NODE_NAME	"tablet_receiver"
 #define TOPIC_NR	(5)
@@ -139,9 +139,9 @@ int main(int argc, char *argv[])
 
 	ros::init(argc, argv, NODE_NAME);
 	ros::NodeHandle node;
-	pub[0] = node.advertise&lt;tablet_socket::gear_cmd&gt;("gear_cmd", 1);
-	pub[1] = node.advertise&lt;tablet_socket::mode_cmd&gt;("mode_cmd", 1);
-	pub[2] = node.advertise&lt;tablet_socket::route_cmd&gt;("route_cmd", 1);
+	pub[0] = node.advertise&lt;tablet_socket_msgs::gear_cmd&gt;("gear_cmd", 1);
+	pub[1] = node.advertise&lt;tablet_socket_msgs::mode_cmd&gt;("mode_cmd", 1);
+	pub[2] = node.advertise&lt;tablet_socket_msgs::route_cmd&gt;("route_cmd", 1);
 	pub[3] = node.advertise&lt;geometry_msgs::PoseStamped&gt;("gnss_pose", 1);
 	pub[4] = node.advertise&lt;std_msgs::Bool&gt;("gnss_stat", 1);
 	node.param&lt;int&gt;("tablet_receiver/port", port, DEFAULT_PORT);
@@ -245,13 +245,13 @@ static int getSensorValue(int sock, ros::Publisher pub[TOPIC_NR])
 
 	switch(info[0]) {
 	case 1: { // GEAR
-		tablet_socket::gear_cmd msg;
+		tablet_socket_msgs::gear_cmd msg;
 		msg.gear = info[1];
 		pub[0].publish(msg);
 		break;
 	}
 	case 2: { // MODE
-		tablet_socket::mode_cmd msg;
+		tablet_socket_msgs::mode_cmd msg;
 		msg.mode = info[1];
 		pub[1].publish(msg);
 		break;
@@ -284,8 +284,8 @@ static int getSensorValue(int sock, ros::Publisher pub[TOPIC_NR])
 			}
 		}
 
-		tablet_socket::route_cmd msg;
-		tablet_socket::Waypoint point;
+		tablet_socket_msgs::route_cmd msg;
+		tablet_socket_msgs::Waypoint point;
 		for (int i = 0; i &lt; points_nr; i++) {
 			if (i % 2) {
 				point.lon = points[i];
</diff>
			</file>
			<file old_path="ros\src\socket\packages\tablet_socket\nodes\tablet_sender\tablet_sender.cpp" new_path="ros\src\socket\packages\tablet_socket\nodes\tablet_sender\tablet_sender.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -37,8 +37,8 @@
 #include &lt;signal.h&gt;
 
 #include &lt;std_msgs/Bool.h&gt;
-#include &lt;tablet_socket/error_info.h&gt;
-#include &lt;tablet_socket/mode_info.h&gt;
+#include &lt;tablet_socket_msgs/error_info.h&gt;
+#include &lt;tablet_socket_msgs/mode_info.h&gt;
 #include &lt;vehicle_socket/CanInfo.h&gt;
 #include &lt;ndt_localizer/ndt_stat.h&gt;
 
@@ -62,7 +62,7 @@ struct error_request {
 	int32_t type;
 	int32_t error;
 
-	error_request(const tablet_socket::error_info&amp; msg)
+	error_request(const tablet_socket_msgs::error_info&amp; msg)
 	: type(ERROR_INFO_TYPE), error(msg.error) {
 	}
 };
@@ -80,7 +80,7 @@ struct mode_request {
 	int32_t type;
 	int32_t mode;
 
-	mode_request(const tablet_socket::mode_info&amp; msg)
+	mode_request(const tablet_socket_msgs::mode_info&amp; msg)
 	: type(MODE_INFO_TYPE), mode(msg.mode) {
 	}
 };
@@ -115,7 +115,7 @@ struct lf_request {
 	}
 };
 
-static void subscribe_error_info(const tablet_socket::error_info&amp; msg)
+static void subscribe_error_info(const tablet_socket_msgs::error_info&amp; msg)
 {
 	error_request request(msg);
 	int response;
@@ -181,7 +181,7 @@ static void subscribe_can_info(const vehicle_socket::CanInfo&amp; msg)
 	}
 }
 
-static void subscribe_mode_info(const tablet_socket::mode_info&amp; msg)
+static void subscribe_mode_info(const tablet_socket_msgs::mode_info&amp; msg)
 {
 	mode_request request(msg);
 	int response;
</diff>
			</file>
			<file old_path="ros\src\socket\packages\udon_socket\nodes\udon_sender\udon_sender.cpp" new_path="ros\src\socket\packages\udon_socket\nodes\udon_sender\udon_sender.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -41,7 +41,7 @@
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
 
-#include &lt;tablet_socket/mode_info.h&gt;
+#include &lt;tablet_socket_msgs/mode_info.h&gt;
 
 #include &lt;udon_socket/udon.hpp&gt;
 
@@ -55,7 +55,7 @@ struct Vehicle {
 Vehicle vehicle;
 boost::shared_mutex vehicle_mtx;
 
-void cache_mode(const tablet_socket::mode_info&amp; msg)
+void cache_mode(const tablet_socket_msgs::mode_info&amp; msg)
 {
 	boost::upgrade_lock&lt;boost::shared_mutex&gt; up_lock(vehicle_mtx);
 	boost::upgrade_to_unique_lock&lt;boost::shared_mutex&gt; write_lock(up_lock);
</diff>
			</file>
			<file old_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_receiver\vehicle_receiver.cpp" new_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_receiver\vehicle_receiver.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -30,7 +30,7 @@
 
 #include &lt;ros/ros.h&gt;
 #include &lt;vehicle_socket/CanInfo.h&gt;
-#include &lt;tablet_socket/mode_info.h&gt;
+#include &lt;tablet_socket_msgs/mode_info.h&gt;
 
 #include &lt;iostream&gt;
 #include &lt;string&gt;
@@ -150,7 +150,7 @@ static void* getCanValue(void *arg)
   can_msg.header.stamp = ros::Time::now();
   can_pub.publish(can_msg);
 
-  tablet_socket::mode_info mode_msg;
+  tablet_socket_msgs::mode_info mode_msg;
   mode_msg.header.frame_id = "/mode";
   mode_msg.header.stamp = ros::Time::now();
   mode_msg.mode = mode;
@@ -229,7 +229,7 @@ int main(int argc, char **argv)
   std::cout &lt;&lt; "vehicle receiver" &lt;&lt; std::endl;
 
   can_pub = nh.advertise&lt;vehicle_socket::CanInfo&gt;("can_info", 100);
-  mode_pub = nh.advertise&lt;tablet_socket::mode_info&gt;("mode_info", 100);
+  mode_pub = nh.advertise&lt;tablet_socket_msgs::mode_info&gt;("mode_info", 100);
 
   pthread_t th;
   int ret = pthread_create(&amp;th, nullptr, receiverCaller, nullptr);
</diff>
			</file>
			<file old_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" new_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -30,12 +30,12 @@
 
 #include &lt;ros/ros.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
-#include &lt;tablet_socket/mode_cmd.h&gt;
-#include &lt;tablet_socket/gear_cmd.h&gt;
+#include &lt;tablet_socket_msgs/mode_cmd.h&gt;
+#include &lt;tablet_socket_msgs/gear_cmd.h&gt;
 #include &lt;runtime_manager/accel_cmd.h&gt;
 #include &lt;runtime_manager/brake_cmd.h&gt;
 #include &lt;runtime_manager/steer_cmd.h&gt;
-#include &lt;waypoint_follower/ControlCommandStamped.h&gt;
+#include &lt;waypoint_follower_msgs/ControlCommandStamped.h&gt;
 
 #include &lt;iostream&gt;
 #include &lt;string&gt;
@@ -82,7 +82,7 @@ static void twistCMDCallback(const geometry_msgs::TwistStamped&amp; msg)
   command_data.angular_z = msg.twist.angular.z;
 }
 
-static void modeCMDCallback(const tablet_socket::mode_cmd&amp; mode)
+static void modeCMDCallback(const tablet_socket_msgs::mode_cmd&amp; mode)
 {
   if(mode.mode == -1 || mode.mode == 0){
     command_data.reset();
@@ -91,7 +91,7 @@ static void modeCMDCallback(const tablet_socket::mode_cmd&amp; mode)
   command_data.modeValue = mode.mode;
 }
 
-static void gearCMDCallback(const tablet_socket::gear_cmd&amp; gear)
+static void gearCMDCallback(const tablet_socket_msgs::gear_cmd&amp; gear)
 {
   command_data.gearValue = gear.gear;
 }
@@ -111,7 +111,7 @@ static void brakeCMDCallback(const runtime_manager::brake_cmd &amp;brake)
   command_data.brakeValue = brake.brake;
 }
 
-static void ctrlCMDCallback(const waypoint_follower::ControlCommandStamped&amp; msg)
+static void ctrlCMDCallback(const waypoint_follower_msgs::ControlCommandStamped&amp; msg)
 {
   command_data.linear_velocity = msg.cmd.linear_velocity;
   command_data.steering_angle = msg.cmd.steering_angle;
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\kf_track\sync_track.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\kf_track\sync_track.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -1,7 +1,7 @@
 #include "ros/ros.h"
 #include "sensor_msgs/Image.h"
-#include "cv_tracker/image_obj_tracked.h"
-#include "cv_tracker/image_obj_ranged.h"
+#include "cv_tracker_msgs/image_obj_tracked.h"
+#include "cv_tracker_msgs/image_obj_ranged.h"
 #include "sync.hpp"
 
 int main(int argc, char **argv) {
@@ -13,7 +13,7 @@ int main(int argc, char **argv) {
     std::string pub1("/image_obj_ranged");
     std::string pub2("/image_raw");
 
-    Synchronizer&lt;cv_tracker::image_obj_ranged, sensor_msgs::Image, cv_tracker::image_obj_tracked&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
+    Synchronizer&lt;cv_tracker_msgs::image_obj_ranged, sensor_msgs::Image, cv_tracker_msgs::image_obj_tracked&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
     synchronizer.run();
 
     return 0;
@@ -40,8 +40,8 @@ int main(int argc, char **argv) {
 #include "t_sync_message.h"
 /* user header */
 #include "sensor_msgs/Image.h"
-#include "cv_tracker/image_obj_tracked.h"
-#include "cv_tracker/image_obj_ranged.h"
+#include "cv_tracker_msgs/image_obj_tracked.h"
+#include "cv_tracker_msgs/image_obj_ranged.h"
 
 /* ----mode---- */
 #define _REQ_PUB 1
@@ -51,7 +51,7 @@ int main(int argc, char **argv) {
 bool buf_flag;
 pthread_mutex_t mutex;
 /* user var */
-boost::circular_buffer&lt;cv_tracker::image_obj_ranged&gt; image_obj_ranged_ringbuf(10);
+boost::circular_buffer&lt;cv_tracker_msgs::image_obj_ranged&gt; image_obj_ranged_ringbuf(10);
 boost::circular_buffer&lt;sensor_msgs::Image&gt; image_raw_ringbuf(10);
 ros::Publisher image_obj_ranged__pub;
 ros::Publisher image_raw__pub;
@@ -71,10 +71,10 @@ double get_time(const std_msgs::Header *timespec) {
 
 
 #if _REQ_PUB
-cv_tracker::image_obj_ranged* p_image_obj_ranged_buf;
+cv_tracker_msgs::image_obj_ranged* p_image_obj_ranged_buf;
 sensor_msgs::Image* p_image_raw_buf;
 
-void publish_msg(cv_tracker::image_obj_ranged* p_image_obj_ranged_buf, sensor_msgs::Image* p_image_raw_buf) {
+void publish_msg(cv_tracker_msgs::image_obj_ranged* p_image_obj_ranged_buf, sensor_msgs::Image* p_image_raw_buf) {
     ROS_INFO("publish");
     image_obj_ranged__pub.publish(*p_image_obj_ranged_buf);
     image_raw__pub.publish(*p_image_raw_buf);
@@ -97,7 +97,7 @@ bool publish() {
         // image_obj_ranged &gt; image_raw
         if (get_time(&amp;(image_obj_ranged_ringbuf.front().header)) &gt;= get_time(&amp;(image_raw_ringbuf.front().header))) {
             p_image_raw_buf = &amp;(image_raw_ringbuf.front());
-            boost::circular_buffer&lt;cv_tracker::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
+            boost::circular_buffer&lt;cv_tracker_msgs::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
             if (image_obj_ranged_ringbuf.size() == 1) {
                 p_image_obj_ranged_buf = &amp;*it;
                 publish_msg(p_image_obj_ranged_buf, p_image_raw_buf);
@@ -163,7 +163,7 @@ bool publish() {
     }
 }
 
-void image_obj_ranged_callback(const cv_tracker::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
+void image_obj_ranged_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ranged_ringbuf.push_front(*image_obj_ranged_msg);
     //image_raw is empty
@@ -203,7 +203,7 @@ void image_raw_callback(const sensor_msgs::Image::ConstPtr&amp; image_raw_msg) {
 #else
 #endif
 
-void image_obj_tracked_callback(const cv_tracker::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
+void image_obj_tracked_callback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_tracked_flag = true;
     ROS_INFO("catch publish request");
@@ -252,7 +252,7 @@ int main(int argc, char **argv) {
 
     ros::Subscriber image_obj_ranged_sub = nh.subscribe("/image_obj_ranged", 1, image_obj_ranged_callback);
     ros::Subscriber image_raw_sub = nh.subscribe("/sync_drivers/image_raw", 1, image_raw_callback);
-    image_obj_ranged__pub = nh.advertise&lt;cv_tracker::image_obj_ranged&gt;("/sync_tracking/image_obj_ranged", 5);
+    image_obj_ranged__pub = nh.advertise&lt;cv_tracker_msgs::image_obj_ranged&gt;("/sync_tracking/image_obj_ranged", 5);
     image_raw__pub = nh.advertise&lt;sensor_msgs::Image&gt;("/sync_tracking/image_raw", 5);
 
     while ((!buf_flag) &amp;&amp; ros::ok()) {
@@ -284,10 +284,10 @@ int main(int argc, char **argv) {
 
 
 #if 0
-cv_tracker::image_obj_ranged image_obj_ranged_buf;
+cv_tracker_msgs::image_obj_ranged image_obj_ranged_buf;
 sensor_msgs::Image image_raw_buf;
 
-void image_obj_ranged_callback(const cv_tracker::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
+void image_obj_ranged_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ranged_ringbuf.push_front(*image_obj_ranged_msg);
 
@@ -303,7 +303,7 @@ void image_obj_ranged_callback(const cv_tracker::image_obj_ranged::ConstPtr&amp; ima
     // image_obj_ranged &gt; image_raw
     if (get_time(&amp;(image_obj_ranged_ringbuf.front().header)) &gt;= get_time(&amp;(image_raw_ringbuf.front().header))) {
         image_raw_buf = image_raw_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
+        boost::circular_buffer&lt;cv_tracker_msgs::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
         if (image_obj_ranged_ringbuf.size() == 1) {
             image_obj_ranged_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -360,7 +360,7 @@ void image_raw_callback(const sensor_msgs::Image::ConstPtr&amp; image_raw_msg) {
     // image_obj_ranged &gt; image_raw
     if (get_time(&amp;(image_obj_ranged_ringbuf.front().header)) &gt;= get_time(&amp;(image_raw_ringbuf.front().header))) {
         image_raw_buf = image_raw_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
+        boost::circular_buffer&lt;cv_tracker_msgs::image_obj_ranged&gt;::iterator it = image_obj_ranged_ringbuf.begin();
         if (image_obj_ranged_ringbuf.size() == 1) {
             image_obj_ranged_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\sync_obj_reproj.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\sync_obj_reproj.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -1,7 +1,7 @@
 #include "ros/ros.h"
-#include "cv_tracker/image_obj_tracked.h"
+#include "cv_tracker_msgs/image_obj_tracked.h"
 #include "geometry_msgs/PoseStamped.h"
-#include "cv_tracker/obj_label.h"
+#include "cv_tracker_msgs/obj_label.h"
 #include "sync.hpp"
 
 int main(int argc, char **argv) {
@@ -13,7 +13,7 @@ int main(int argc, char **argv) {
     std::string pub1("/image_obj_tracked");
     std::string pub2("/current_pose");
 
-    Synchronizer&lt;cv_tracker::image_obj_tracked, geometry_msgs::PoseStamped, cv_tracker::obj_label&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
+    Synchronizer&lt;cv_tracker_msgs::image_obj_tracked, geometry_msgs::PoseStamped, cv_tracker_msgs::obj_label&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
     synchronizer.run();
 
     return 0;
@@ -39,9 +39,9 @@ int main(int argc, char **argv) {
 #include &lt;pthread.h&gt;
 #include "t_sync_message.h"
 /* user header */
-#include "cv_tracker/image_obj_tracked.h"
+#include "cv_tracker_msgs/image_obj_tracked.h"
 #include "geometry_msgs/PoseStamped.h"
-#include "cv_tracker/obj_label.h"
+#include "cv_tracker_msgs/obj_label.h"
 
 /* ----mode---- */
 #define _REQ_PUB 1
@@ -51,7 +51,7 @@ int main(int argc, char **argv) {
 bool buf_flag;
 pthread_mutex_t mutex;
 /* user var */
-boost::circular_buffer&lt;cv_tracker::image_obj_tracked&gt; image_obj_tracked_ringbuf(10);
+boost::circular_buffer&lt;cv_tracker_msgs::image_obj_tracked&gt; image_obj_tracked_ringbuf(10);
 boost::circular_buffer&lt;geometry_msgs::PoseStamped&gt; current_pose_ringbuf(10);
 ros::Publisher image_obj_tracked__pub;
 ros::Publisher current_pose__pub;
@@ -71,10 +71,10 @@ double get_time(const std_msgs::Header *timespec) {
 
 
 #if _REQ_PUB
-cv_tracker::image_obj_tracked* p_image_obj_tracked_buf;
+cv_tracker_msgs::image_obj_tracked* p_image_obj_tracked_buf;
 geometry_msgs::PoseStamped* p_current_pose_buf;
 
-void publish_msg(cv_tracker::image_obj_tracked* p_image_obj_tracked_buf, geometry_msgs::PoseStamped* p_current_pose_buf) {
+void publish_msg(cv_tracker_msgs::image_obj_tracked* p_image_obj_tracked_buf, geometry_msgs::PoseStamped* p_current_pose_buf) {
     ROS_INFO("publish");
     image_obj_tracked__pub.publish(*p_image_obj_tracked_buf);
     current_pose__pub.publish(*p_current_pose_buf);
@@ -97,7 +97,7 @@ bool publish() {
         // image_obj_tracked &gt; current_pose
         if (get_time(&amp;(image_obj_tracked_ringbuf.front().header)) &gt;= get_time(&amp;(current_pose_ringbuf.front().header))) {
             p_current_pose_buf = &amp;(current_pose_ringbuf.front());
-            boost::circular_buffer&lt;cv_tracker::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
+            boost::circular_buffer&lt;cv_tracker_msgs::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
             if (image_obj_tracked_ringbuf.size() == 1) {
                 p_image_obj_tracked_buf = &amp;*it;
                 publish_msg(p_image_obj_tracked_buf, p_current_pose_buf);
@@ -163,7 +163,7 @@ bool publish() {
     }
 }
 
-void image_obj_tracked_callback(const cv_tracker::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
+void image_obj_tracked_callback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_tracked_ringbuf.push_front(*image_obj_tracked_msg);
     //current_pose is empty
@@ -204,7 +204,7 @@ void current_pose_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_p
 #else
 #endif
 
-void obj_label_callback(const cv_tracker::obj_label::ConstPtr&amp; obj_label_msg) {
+void obj_label_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
     pthread_mutex_lock(&amp;mutex);
     obj_label_flag = true;
     ROS_INFO("catch publish request");
@@ -252,7 +252,7 @@ int main(int argc, char **argv) {
 
     ros::Subscriber image_obj_tracked_sub = nh.subscribe("/image_obj_tracked", 1, image_obj_tracked_callback);
     ros::Subscriber current_pose_sub = nh.subscribe("/current_pose", 1, current_pose_callback);
-    image_obj_tracked__pub = nh.advertise&lt;cv_tracker::image_obj_tracked&gt;("/sync_reprojection/image_obj_tracked", 5);
+    image_obj_tracked__pub = nh.advertise&lt;cv_tracker_msgs::image_obj_tracked&gt;("/sync_reprojection/image_obj_tracked", 5);
     current_pose__pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/sync_reprojection/current_pose", 5);
 
     while (!buf_flag &amp;&amp; ros::ok()) {
@@ -281,10 +281,10 @@ int main(int argc, char **argv) {
 }
 
 #if 0
-cv_tracker::image_obj_tracked image_obj_tracked_buf;
+cv_tracker_msgs::image_obj_tracked image_obj_tracked_buf;
 geometry_msgs::PoseStamped current_pose_buf;
 
-void image_obj_tracked_callback(const cv_tracker::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
+void image_obj_tracked_callback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_tracked_ringbuf.push_front(*image_obj_tracked_msg);
 
@@ -300,7 +300,7 @@ void image_obj_tracked_callback(const cv_tracker::image_obj_tracked::ConstPtr&amp; i
     // image_obj_tracked &gt; current_pose
     if (get_time(&amp;(image_obj_tracked_ringbuf.front().header)) &gt;= get_time(&amp;(current_pose_ringbuf.front().header))) {
         current_pose_buf = current_pose_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
+        boost::circular_buffer&lt;cv_tracker_msgs::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
         if (image_obj_tracked_ringbuf.size() == 1) {
             image_obj_tracked_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -372,7 +372,7 @@ void current_pose_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_p
     // image_obj_tracked &gt; current_pose
     if (get_time(&amp;(image_obj_tracked_ringbuf.front().header)) &gt;= get_time(&amp;(current_pose_ringbuf.front().header))) {
         current_pose_buf = current_pose_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
+        boost::circular_buffer&lt;cv_tracker_msgs::image_obj_tracked&gt;::iterator it = image_obj_tracked_ringbuf.begin();
         if (image_obj_tracked_ringbuf.size() == 1) {
             image_obj_tracked_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\range_fusion\sync_range_fusion.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\cv_tracker\nodes\range_fusion\sync_range_fusion.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -1,7 +1,7 @@
 #include "ros/ros.h"
-#include "cv_tracker/image_obj.h"
+#include "cv_tracker_msgs/image_obj.h"
 #include "points2image/PointsImage.h"
-#include "cv_tracker/image_obj_ranged.h"
+#include "cv_tracker_msgs/image_obj_ranged.h"
 #include "sync.hpp"
 
 int main(int argc, char **argv) {
@@ -13,7 +13,7 @@ int main(int argc, char **argv) {
     std::string pub1("/image_obj");
     std::string pub2("/vscan_image");
 
-    Synchronizer&lt;cv_tracker::image_obj, points2image::PointsImage, cv_tracker::image_obj_ranged&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
+    Synchronizer&lt;cv_tracker_msgs::image_obj, points2image::PointsImage, cv_tracker_msgs::image_obj_ranged&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
     synchronizer.run();
 
     return 0;
@@ -39,9 +39,9 @@ int main(int argc, char **argv) {
 #include &lt;pthread.h&gt;
 #include "t_sync_message.h"
 /* user header */
-#include "cv_tracker/image_obj.h"
+#include "cv_tracker_msgs/image_obj.h"
 #include "points2image/PointsImage.h"
-#include "cv_tracker/image_obj_ranged.h"
+#include "cv_tracker_msgs/image_obj_ranged.h"
 
 /* ----mode---- */
 #define _REQ_PUB 1
@@ -51,7 +51,7 @@ int main(int argc, char **argv) {
 bool buf_flag;
 pthread_mutex_t mutex;
 /* user var */
-boost::circular_buffer&lt;cv_tracker::image_obj&gt; image_obj_ringbuf(10);
+boost::circular_buffer&lt;cv_tracker_msgs::image_obj&gt; image_obj_ringbuf(10);
 boost::circular_buffer&lt;points2image::PointsImage&gt; vscan_image_ringbuf(10);
 ros::Publisher image_obj__pub;
 ros::Publisher vscan_image__pub;
@@ -71,10 +71,10 @@ double get_time(const std_msgs::Header *timespec) {
 
 
 #if _REQ_PUB
-cv_tracker::image_obj* p_image_obj_buf;
+cv_tracker_msgs::image_obj* p_image_obj_buf;
 points2image::PointsImage* p_vscan_image_buf;
 
-void publish_msg(cv_tracker::image_obj* p_image_obj_buf, points2image::PointsImage* p_vscan_image_buf) {
+void publish_msg(cv_tracker_msgs::image_obj* p_image_obj_buf, points2image::PointsImage* p_vscan_image_buf) {
     ROS_INFO("publish");
     image_obj__pub.publish(*p_image_obj_buf);
     vscan_image__pub.publish(*p_vscan_image_buf);
@@ -97,7 +97,7 @@ bool publish() {
         // image_obj &gt; vscan_image
         if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
             p_vscan_image_buf = &amp;(vscan_image_ringbuf.front());
-            boost::circular_buffer&lt;cv_tracker::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+            boost::circular_buffer&lt;cv_tracker_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
             if (image_obj_ringbuf.size() == 1) {
                 p_image_obj_buf = &amp;*it;
                 publish_msg(p_image_obj_buf, p_vscan_image_buf);
@@ -163,7 +163,7 @@ bool publish() {
     }
 }
 
-void image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
+void image_obj_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ringbuf.push_front(*image_obj_msg);
     //vscan_image is empty
@@ -203,7 +203,7 @@ void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image
 #else
 #endif
 
-void image_obj_ranged_callback(const cv_tracker::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
+void image_obj_ranged_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ranged_flag = true;
     ROS_INFO("catch publish request");
@@ -252,7 +252,7 @@ int main(int argc, char **argv) {
 
     ros::Subscriber image_obj_sub = nh.subscribe("/image_obj", 1, image_obj_callback);
     ros::Subscriber vscan_image_sub = nh.subscribe("/vscan_image", 1, vscan_image_callback);
-    image_obj__pub = nh.advertise&lt;cv_tracker::image_obj&gt;("/sync_ranging/image_obj", 5);
+    image_obj__pub = nh.advertise&lt;cv_tracker_msgs::image_obj&gt;("/sync_ranging/image_obj", 5);
     vscan_image__pub = nh.advertise&lt;points2image::PointsImage&gt;("/sync_ranging/vscan_image", 5);
 
     while ((!buf_flag) &amp;&amp; ros::ok()) {
@@ -284,10 +284,10 @@ int main(int argc, char **argv) {
 
 
 #if 0
-cv_tracker::image_obj image_obj_buf;
+cv_tracker_msgs::image_obj image_obj_buf;
 points2image::PointsImage vscan_image_buf;
 
-void image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
+void image_obj_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
     pthread_mutex_lock(&amp;mutex);
     image_obj_ringbuf.push_front(*image_obj_msg);
 
@@ -303,7 +303,7 @@ void image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
     // image_obj &gt; vscan_image
     if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
         vscan_image_buf = vscan_image_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+        boost::circular_buffer&lt;cv_tracker_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
         if (image_obj_ringbuf.size() == 1) {
             image_obj_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -360,7 +360,7 @@ void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image
     // image_obj &gt; vscan_image
     if (get_time(&amp;(image_obj_ringbuf.front().header)) &gt;= get_time(&amp;(vscan_image_ringbuf.front().header))) {
         vscan_image_buf = vscan_image_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
+        boost::circular_buffer&lt;cv_tracker_msgs::image_obj&gt;::iterator it = image_obj_ringbuf.begin();
         if (image_obj_ringbuf.size() == 1) {
             image_obj_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
</diff>
			</file>
			<file old_path="ros\src\system\sync\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\sync_obj_fusion.cpp" new_path="ros\src\system\sync\computing\perception\detection\packages\lidar_tracker\nodes\obj_fusion\sync_obj_fusion.cpp" added_lines="13" deleted_lines="13">
				<diff>@@ -1,5 +1,5 @@
 #include "ros/ros.h"
-#include "cv_tracker/obj_label.h"
+#include "cv_tracker_msgs/obj_label.h"
 #include "lidar_tracker/centroids.h"
 #include "visualization_msgs/MarkerArray.h"
 #include "sync.hpp"
@@ -13,7 +13,7 @@ int main(int argc, char **argv) {
     std::string pub1("/obj_label");
     std::string pub2("/cluster_centroids");
 
-    Synchronizer&lt;cv_tracker::obj_label, lidar_tracker::centroids, visualization_msgs::MarkerArray&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
+    Synchronizer&lt;cv_tracker_msgs::obj_label, lidar_tracker::centroids, visualization_msgs::MarkerArray&gt; synchronizer(sub1, sub2, pub1, pub2, req, ns);
     synchronizer.run();
 
     return 0;
@@ -39,7 +39,7 @@ int main(int argc, char **argv) {
 #include &lt;pthread.h&gt;
 #include "t_sync_message.h"
 /* user header */
-#include "cv_tracker/obj_label.h"
+#include "cv_tracker_msgs/obj_label.h"
 #include "lidar_tracker/centroids.h"
 #include "visualization_msgs/MarkerArray.h"
 
@@ -51,7 +51,7 @@ int main(int argc, char **argv) {
 bool buf_flag;
 pthread_mutex_t mutex;
 /* user var */
-boost::circular_buffer&lt;cv_tracker::obj_label&gt; obj_label_ringbuf(10);
+boost::circular_buffer&lt;cv_tracker_msgs::obj_label&gt; obj_label_ringbuf(10);
 boost::circular_buffer&lt;lidar_tracker::centroids&gt; cluster_centroids_ringbuf(10);
 ros::Publisher obj_label__pub;
 ros::Publisher cluster_centroids__pub;
@@ -71,10 +71,10 @@ double get_time(const std_msgs::Header *timespec) {
 
 
 #if _REQ_PUB
-cv_tracker::obj_label* p_obj_label_buf;
+cv_tracker_msgs::obj_label* p_obj_label_buf;
 lidar_tracker::centroids* p_cluster_centroids_buf;
 
-void publish_msg(cv_tracker::obj_label* p_obj_label_buf, lidar_tracker::centroids* p_cluster_centroids_buf)
+void publish_msg(cv_tracker_msgs::obj_label* p_obj_label_buf, lidar_tracker::centroids* p_cluster_centroids_buf)
 {
     ROS_INFO("publish");
     obj_label__pub.publish(*p_obj_label_buf);
@@ -98,7 +98,7 @@ bool publish() {
         // obj_label &gt; cluster_centroids
         if (get_time(&amp;(obj_label_ringbuf.front().header)) &gt;= get_time(&amp;(cluster_centroids_ringbuf.front().header))) {
             p_cluster_centroids_buf = &amp;(cluster_centroids_ringbuf.front());
-            boost::circular_buffer&lt;cv_tracker::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
+            boost::circular_buffer&lt;cv_tracker_msgs::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
             if (obj_label_ringbuf.size() == 1) {
                 p_obj_label_buf = &amp;*it;
                 publish_msg(p_obj_label_buf, p_cluster_centroids_buf);
@@ -163,7 +163,7 @@ bool publish() {
     }
 }
 
-void obj_label_callback(const cv_tracker::obj_label::ConstPtr&amp; obj_label_msg) {
+void obj_label_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
     pthread_mutex_lock(&amp;mutex);
     obj_label_ringbuf.push_front(*obj_label_msg);
     //cluster_centroids is empty
@@ -203,7 +203,7 @@ void cluster_centroids_callback(const lidar_tracker::centroids::ConstPtr&amp; cluste
 }
 
 #else
-cv_tracker::obj_label obj_label_buf;
+cv_tracker_msgs::obj_label obj_label_buf;
 lidar_tracker::centroids cluster_centroids_buf;
 
 bool publish() {
@@ -224,7 +224,7 @@ bool publish() {
     }
 }
 
-void obj_label_callback(const cv_tracker::obj_label::ConstPtr&amp; obj_label_msg) {
+void obj_label_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
     pthread_mutex_lock(&amp;mutex);
     obj_label_ringbuf.push_front(*obj_label_msg);
 
@@ -240,7 +240,7 @@ void obj_label_callback(const cv_tracker::obj_label::ConstPtr&amp; obj_label_msg) {
     // obj_label &gt; cluster_centroids
     if (get_time(&amp;(obj_label_ringbuf.front().header)) &gt;= get_time(&amp;(cluster_centroids_ringbuf.front().header))) {
         cluster_centroids_buf = cluster_centroids_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
+        boost::circular_buffer&lt;cv_tracker_msgs::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
         if (obj_label_ringbuf.size() == 1) {
             obj_label_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -307,7 +307,7 @@ void cluster_centroids_callback(const lidar_tracker::centroids::ConstPtr&amp; cluste
     // obj_label &gt; cluster_centroids
     if (get_time(&amp;(obj_label_ringbuf.front().header)) &gt;= get_time(&amp;(cluster_centroids_ringbuf.front().header))) {
         cluster_centroids_buf = cluster_centroids_ringbuf.front();
-        boost::circular_buffer&lt;cv_tracker::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
+        boost::circular_buffer&lt;cv_tracker_msgs::obj_label&gt;::iterator it = obj_label_ringbuf.begin();
         if (obj_label_ringbuf.size() == 1) {
             obj_label_buf = *it;
             pthread_mutex_unlock(&amp;mutex);
@@ -409,7 +409,7 @@ int main(int argc, char **argv) {
 
     ros::Subscriber obj_label_sub = nh.subscribe("/obj_label", 1, obj_label_callback);
     ros::Subscriber cluster_centroids_sub = nh.subscribe("/cluster_centroids", 1, cluster_centroids_callback);
-    obj_label__pub = nh.advertise&lt;cv_tracker::obj_label&gt;("/sync_obj_fusion/obj_label", 5);
+    obj_label__pub = nh.advertise&lt;cv_tracker_msgs::obj_label&gt;("/sync_obj_fusion/obj_label", 5);
     cluster_centroids__pub = nh.advertise&lt;lidar_tracker::centroids&gt;("/sync_obj_fusion/cluster_centroids", 5);
     while (!buf_flag &amp;&amp; ros::ok()) {
         ros::spinOnce();
</diff>
			</file>
			<file old_path="ros\src\system\sync\time_monitor.cpp" new_path="ros\src\system\sync\time_monitor.cpp" added_lines="20" deleted_lines="20">
				<diff>@@ -37,12 +37,12 @@
 /* user header */
 #include "sensor_msgs/Image.h"
 #include "sensor_msgs/PointCloud2.h"
-#include "cv_tracker/image_obj.h"
+#include "cv_tracker_msgs/image_obj.h"
 #include "points2image/PointsImage.h"
-#include "cv_tracker/image_obj_ranged.h"
-#include "cv_tracker/image_obj_tracked.h"
+#include "cv_tracker_msgs/image_obj_ranged.h"
+#include "cv_tracker_msgs/image_obj_tracked.h"
 #include "geometry_msgs/PoseStamped.h"
-#include "cv_tracker/obj_label.h"
+#include "cv_tracker_msgs/obj_label.h"
 #include "lidar_tracker/centroids.h"
 #include "visualization_msgs/MarkerArray.h"
 #include "synchronization/time_monitor.h"
@@ -181,19 +181,19 @@ public:
     void points_image_callback(const points2image::PointsImage::ConstPtr&amp; points_image_msg);
     void vscan_points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; vscan_points_msg);
     void vscan_image_callback(const points2image::PointsImage::ConstPtr&amp; vscan_image_msg);
-    void image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg);
-    void image_obj_ranged_callback(const cv_tracker::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg);
-    void image_obj_tracked_callback(const cv_tracker::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg);
+    void image_obj_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; image_obj_msg);
+    void image_obj_ranged_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg);
+    void image_obj_tracked_callback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg);
     void current_pose_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; current_pose_msg);
-    void obj_label_callback(const cv_tracker::obj_label::ConstPtr&amp; obj_label_msg) ;
+    void obj_label_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; obj_label_msg) ;
     void cluster_centroids_callback(const lidar_tracker::centroids::ConstPtr&amp; cluster_centroids_msg);
 //    void obj_pose_callback(const visualization_msgs::MarkerArray::ConstPtr&amp; obj_pose_msg);
     void obj_pose_callback(const std_msgs::Time::ConstPtr&amp; obj_pose_timestamp_msg);
     // sync
-    void sync_image_obj_ranged_callback(const cv_tracker::image_obj::ConstPtr&amp; sync_image_obj_msg);
-    void sync_image_obj_tracked_callback(const cv_tracker::image_obj_ranged::ConstPtr&amp; sync_image_obj_ranged_msg);
-    void sync_obj_label_callback(const cv_tracker::image_obj_tracked::ConstPtr&amp; sync_image_obj_tracked_msg);
-    void sync_obj_pose_callback(const cv_tracker::obj_label::ConstPtr&amp; sync_obj_label_msg);
+    void sync_image_obj_ranged_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; sync_image_obj_msg);
+    void sync_image_obj_tracked_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; sync_image_obj_ranged_msg);
+    void sync_obj_label_callback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; sync_image_obj_tracked_msg);
+    void sync_obj_pose_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; sync_obj_label_msg);
     // time difference
     void time_diff_callback(const synchronization::time_diff::ConstPtr&amp; time_diff_msg);
     void run();
@@ -276,17 +276,17 @@ void TimeManager::vscan_image_callback(const points2image::PointsImage::ConstPtr
     vscan_image_.push_front(vscan_image_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::image_obj_callback(const cv_tracker::image_obj::ConstPtr&amp; image_obj_msg) {
+void TimeManager::image_obj_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; image_obj_msg) {
 //    ROS_INFO("image_obj: \t\t\t%d.%d", image_obj_msg-&gt;header.stamp.sec, image_obj_msg-&gt;header.stamp.nsec);
     image_obj_.push_front(image_obj_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::image_obj_ranged_callback(const cv_tracker::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
+void TimeManager::image_obj_ranged_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; image_obj_ranged_msg) {
 //    ROS_INFO("image_obj_ranged: \t\t%d.%d", image_obj_ranged_msg-&gt;header.stamp.sec, image_obj_ranged_msg-&gt;header.stamp.nsec);
     image_obj_ranged_.push_front(image_obj_ranged_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::image_obj_tracked_callback(const cv_tracker::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
+void TimeManager::image_obj_tracked_callback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; image_obj_tracked_msg) {
 //    ROS_INFO("image_obj_tracked: \t\t%d.%d", image_obj_tracked_msg-&gt;header.stamp.sec, image_obj_tracked_msg-&gt;header.stamp.nsec);
     image_obj_tracked_.push_front(image_obj_tracked_msg-&gt;header.stamp, get_walltime_now());
 }
@@ -296,7 +296,7 @@ void TimeManager::current_pose_callback(const geometry_msgs::PoseStamped::ConstP
     current_pose_.push_front(current_pose_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::obj_label_callback(const cv_tracker::obj_label::ConstPtr&amp; obj_label_msg) {
+void TimeManager::obj_label_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; obj_label_msg) {
 //    ROS_INFO("obj_label: \t\t\t%d.%d", obj_label_msg-&gt;header.stamp.sec, obj_label_msg-&gt;header.stamp.nsec);
     obj_label_.push_front(obj_label_msg-&gt;header.stamp, get_walltime_now());
 }
@@ -307,22 +307,22 @@ void TimeManager::cluster_centroids_callback(const lidar_tracker::centroids::Con
 }
 
 /* sync */
-void TimeManager::sync_image_obj_ranged_callback(const cv_tracker::image_obj::ConstPtr&amp; sync_image_obj_msg) {
+void TimeManager::sync_image_obj_ranged_callback(const cv_tracker_msgs::image_obj::ConstPtr&amp; sync_image_obj_msg) {
 //    ROS_INFO("sync_image_obj_ranged: \t\t%d.%d", sync_image_obj_msg-&gt;header.stamp.sec, sync_image_obj_msg-&gt;header.stamp.nsec);
     sync_image_obj_ranged_.push_front(sync_image_obj_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::sync_image_obj_tracked_callback(const cv_tracker::image_obj_ranged::ConstPtr&amp; sync_image_obj_ranged_msg) {
+void TimeManager::sync_image_obj_tracked_callback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; sync_image_obj_ranged_msg) {
 //    ROS_INFO("sync_image_obj_tracked: \t%d.%d", sync_image_obj_ranged_msg-&gt;header.stamp.sec, sync_image_obj_ranged_msg-&gt;header.stamp.nsec);
     sync_image_obj_tracked_.push_front(sync_image_obj_ranged_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::sync_obj_label_callback(const cv_tracker::image_obj_tracked::ConstPtr&amp; sync_image_obj_tracked_msg) {
+void TimeManager::sync_obj_label_callback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; sync_image_obj_tracked_msg) {
 //    ROS_INFO("sync_obj_label: \t\t%d.%d", sync_image_obj_tracked_msg-&gt;header.stamp.sec, sync_image_obj_tracked_msg-&gt;header.stamp.nsec);
     sync_obj_label_.push_front(sync_image_obj_tracked_msg-&gt;header.stamp, get_walltime_now());
 }
 
-void TimeManager::sync_obj_pose_callback(const cv_tracker::obj_label::ConstPtr&amp; sync_obj_label_msg) {
+void TimeManager::sync_obj_pose_callback(const cv_tracker_msgs::obj_label::ConstPtr&amp; sync_obj_label_msg) {
 //    ROS_INFO("sync_obj_pose: \t\t\t%d.%d", sync_obj_label_msg-&gt;header.stamp.sec, sync_obj_label_msg-&gt;header.stamp.nsec);
     sync_obj_pose_.push_front(sync_obj_label_msg-&gt;header.stamp, get_walltime_now());
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ee1376741f88f68b66e07b4222094eed9660f981" author="Yusuke FUJII">
		<msg>clean directories</msg>
		<modified_files>
			<file old_path="removed_kinect\lib_dpm_ocv\cpu\dpm_ocv_cpu.cpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\cpu\dpm_ocv_cpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\cuda_check.h" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\cuda_check.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\dpm_ocv_gpu.cpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\dpm_ocv_gpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\dpm_ocv_gpu.hpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\dpm_ocv_gpu.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\drvapi_error_string.h" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\drvapi_error_string.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\featurepyramid_gpu.cpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\featurepyramid_gpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\featurepyramid_gpu.hpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\featurepyramid_gpu.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\for_use_gpu.h" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\for_use_gpu.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\gpu_function.cu" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\gpu_function.cu" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\gpu_init.cpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\gpu_init.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\gpu_matching.h" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\gpu_matching.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\matching_gpu.cpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\matching_gpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\matching_gpu.hpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\matching_gpu.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\resizeimg_gpu.cpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\resizeimg_gpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\resizeimg_gpu.h" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\resizeimg_gpu.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\routine_gpu.cpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\routine_gpu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\gpu\routine_gpu.hpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\gpu\routine_gpu.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\lib_dpm_ocv\include\dpm_ocv\dpm_ocv.hpp" new_path="ros\src\computing\perception\detection\lib\image\dpm_ocv\include\dpm_ocv\dpm_ocv.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\node_dpm_ocv\dpm_ocv.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ocv\dpm_ocv.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\BowVector.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\BowVector.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\BowVector.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\BowVector.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\DUtils\Random.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\DUtils\Random.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\DUtils\Random.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\DUtils\Random.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\DUtils\Timestamp.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\DUtils\Timestamp.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\DUtils\Timestamp.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\DUtils\Timestamp.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\FClass.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\FClass.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\FORB.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\FORB.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\FORB.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\FORB.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\FeatureVector.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\FeatureVector.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\FeatureVector.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\FeatureVector.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\ScoringObject.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\ScoringObject.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\ScoringObject.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\ScoringObject.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\DBoW2\TemplatedVocabulary.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\DBoW2\TemplatedVocabulary.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\bind.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\bind.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\boostd.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\boostd.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\condition_variable.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\condition_variable.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\function.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\function.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\glconsole.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\glconsole.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\glutbitmap.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\glutbitmap.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\memory.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\memory.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\mutex.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\mutex.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\ovr.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\ovr.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\thread.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\thread.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\type_traits.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\compat\type_traits.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\console\ConsoleInterpreter.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\console\ConsoleInterpreter.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\console\ConsoleView.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\console\ConsoleView.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\attach.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\attach.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\device\display_glut.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\device\display_glut.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\display.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\display.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\display_internal.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\display_internal.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\opengl_render_state.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\opengl_render_state.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\user_app.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\user_app.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\view.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\view.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\viewport.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\viewport.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\widgets\widgets.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\display\widgets\widgets.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\cg.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\cg.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\colour.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\colour.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\compat\gl2engine.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\compat\gl2engine.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\compat\gl_es_compat.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\compat\gl_es_compat.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gl.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gl.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gl.hpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gl.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glchar.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glchar.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glcuda.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glcuda.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gldraw.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gldraw.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glfont.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glfont.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glformattraits.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glformattraits.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glglut.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glglut.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glinclude.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glinclude.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glpangoglu.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glpangoglu.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glpixformat.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glpixformat.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glplatform.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glplatform.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glsl.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glsl.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glstate.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glstate.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gltext.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gltext.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gltexturecache.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\gltexturecache.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glvbo.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\gl\glvbo.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler_enums.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler_enums.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler_glbuffer.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler_glbuffer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler_image.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\handler\handler_image.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\image\image.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\image\image.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\image\image_common.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\image\image_common.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\image\image_io.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\image\image_io.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\log\packetstream.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\log\packetstream.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\pangolin.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\pangolin.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\platform.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\platform.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\plot\datalog.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\plot\datalog.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\plot\plotter.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\plot\plotter.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\plot\range.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\plot\range.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\file_extension.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\file_extension.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\file_utils.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\file_utils.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\params.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\params.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\picojson.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\picojson.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\simple_math.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\simple_math.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\threadedfilebuf.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\threadedfilebuf.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\timer.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\timer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\type_convert.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\type_convert.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\uri.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\uri.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml.hpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml_iterators.hpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml_iterators.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml_print.hpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml_print.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml_utils.hpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\utils\xml\rapidxml_utils.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\input_record_repeat.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\input_record_repeat.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\var.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\var.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varextra.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varextra.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varstate.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varstate.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varvalue.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varvalue.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varvaluegeneric.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varvaluegeneric.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varvaluet.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varvaluet.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varwrapper.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\var\varwrapper.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\config.h.in" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\config.h.in" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\console\ConsoleView.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\console\ConsoleView.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\display\device\display_glut.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\display\device\display_glut.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\display\device\display_x11.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\display\device\display_x11.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\display\display.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\display\display.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\display\opengl_render_state.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\display\opengl_render_state.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\display\view.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\display\view.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\display\viewport.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\display\viewport.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\display\widgets\widgets.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\display\widgets\widgets.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\gl\compat\gl2engine.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\gl\compat\gl2engine.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\gl\glchar.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\gl\glchar.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\gl\glfont.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\gl\glfont.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\gl\glpangoglu.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\gl\glpangoglu.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\gl\gltext.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\gl\gltext.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\gl\gltexturecache.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\gl\gltexturecache.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\gl\stb_truetype.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\gl\stb_truetype.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\handler\handler.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\handler\handler.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\handler\handler_glbuffer.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\handler\handler_glbuffer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\image\image_common.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\image\image_common.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\image\image_io.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\image\image_io.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\log\packetstream.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\log\packetstream.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\plot\datalog.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\plot\datalog.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\plot\plotter.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\plot\plotter.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\utils\file_extension.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\utils\file_extension.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\utils\file_utils.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\utils\file_utils.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\utils\threadedfilebuf.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\utils\threadedfilebuf.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\utils\uri.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\utils\uri.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\var\input_record_repeat.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\var\input_record_repeat.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\Pangolin\src\var\vars.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\src\var\vars.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\config.h.in" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\config.h.in" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_binary_edge.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_binary_edge.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_binary_edge.hpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_binary_edge.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_edge.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_edge.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_multi_edge.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_multi_edge.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_multi_edge.hpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_multi_edge.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_unary_edge.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_unary_edge.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_unary_edge.hpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_unary_edge.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_vertex.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_vertex.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\base_vertex.hpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\base_vertex.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\batch_stats.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\batch_stats.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\batch_stats.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\batch_stats.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\block_solver.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\block_solver.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\block_solver.hpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\block_solver.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\cache.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\cache.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\cache.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\cache.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\creators.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\creators.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\eigen_types.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\eigen_types.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\estimate_propagator.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\estimate_propagator.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\estimate_propagator.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\estimate_propagator.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\factory.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\factory.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\factory.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\factory.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\hyper_dijkstra.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\hyper_dijkstra.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\hyper_dijkstra.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\hyper_dijkstra.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph_action.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph_action.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph_action.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\hyper_graph_action.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\jacobian_workspace.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\jacobian_workspace.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\jacobian_workspace.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\jacobian_workspace.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\linear_solver.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\linear_solver.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\marginal_covariance_cholesky.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\marginal_covariance_cholesky.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\marginal_covariance_cholesky.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\marginal_covariance_cholesky.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\matrix_operations.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\matrix_operations.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\matrix_structure.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\matrix_structure.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\matrix_structure.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\matrix_structure.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\openmp_mutex.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\openmp_mutex.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimizable_graph.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimizable_graph.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimizable_graph.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimizable_graph.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_dogleg.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_dogleg.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_dogleg.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_dogleg.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_factory.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_factory.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_factory.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_factory.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_gauss_newton.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_gauss_newton.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_gauss_newton.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_gauss_newton.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_levenberg.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_levenberg.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_levenberg.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_levenberg.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_property.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_property.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_with_hessian.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_with_hessian.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_with_hessian.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\optimization_algorithm_with_hessian.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\parameter.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\parameter.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\parameter.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\parameter.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\parameter_container.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\parameter_container.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\parameter_container.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\parameter_container.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_factory.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_factory.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_factory.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_factory.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_impl.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_impl.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_impl.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\robust_kernel_impl.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\solver.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\solver.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\solver.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\solver.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix.hpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix_ccs.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix_ccs.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix_diagonal.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix_diagonal.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix_test.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\sparse_block_matrix_test.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\sparse_optimizer.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\sparse_optimizer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\core\sparse_optimizer.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\core\sparse_optimizer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\solvers\linear_solver_dense.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\solvers\linear_solver_dense.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\solvers\linear_solver_eigen.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\solvers\linear_solver_eigen.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\color_macros.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\color_macros.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\macros.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\macros.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\misc.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\misc.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\os_specific.c" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\os_specific.c" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\os_specific.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\os_specific.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\property.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\property.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\property.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\property.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\string_tools.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\string_tools.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\string_tools.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\string_tools.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\timeutil.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\timeutil.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\stuff\timeutil.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\stuff\timeutil.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\se3_ops.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\se3_ops.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\se3_ops.hpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\se3_ops.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\se3quat.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\se3quat.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\sim3.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\sim3.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\types_sba.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\types_sba.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\types_sba.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\types_sba.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\types_seven_dof_expmap.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\types_seven_dof_expmap.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\types_seven_dof_expmap.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\types_seven_dof_expmap.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\types_six_dof_expmap.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\types_six_dof_expmap.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\Thirdparty\g2o\g2o\types\types_six_dof_expmap.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\types\types_six_dof_expmap.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\cmake_modules\FindBLAS.cmake" new_path="ros\src\computing\perception\localization\packages\orb_localizer\cmake_modules\FindBLAS.cmake" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\cmake_modules\FindEigen3.cmake" new_path="ros\src\computing\perception\localization\packages\orb_localizer\cmake_modules\FindEigen3.cmake" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\cmake_modules\FindFREEGLUT.cmake" new_path="ros\src\computing\perception\localization\packages\orb_localizer\cmake_modules\FindFREEGLUT.cmake" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\cmake_modules\FindLAPACK.cmake" new_path="ros\src\computing\perception\localization\packages\orb_localizer\cmake_modules\FindLAPACK.cmake" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\Converter.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Converter.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\Frame.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Frame.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\FrameDrawer.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\FrameDrawer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\Initializer.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Initializer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\KeyFrame.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\KeyFrame.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\KeyFrameDatabase.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\KeyFrameDatabase.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\LocalMapping.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\LocalMapping.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\LoopClosing.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\LoopClosing.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\Map.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Map.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\MapDrawer.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\MapDrawer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\MapObjectSerialization.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\MapObjectSerialization.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\MapPoint.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\MapPoint.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\ORBVocabulary.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\ORBVocabulary.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\ORBextractor.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\ORBextractor.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\ORBmatcher.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\ORBmatcher.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\Optimizer.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Optimizer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\ParticleFilter.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\ParticleFilter.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\PnPsolver.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\PnPsolver.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\Sim3Solver.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Sim3Solver.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\System.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\System.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\Tracking.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Tracking.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\Viewer.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Viewer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\include\cvmat_serialization.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\cvmat_serialization.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\nodes\common.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\common.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\nodes\common.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\common.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\nodes\dumpmap\dumpmap.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\dumpmap\dumpmap.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\nodes\orb_evaluator\orb_evaluator.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_evaluator\orb_evaluator.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\nodes\orb_mapping\orb_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_mapping\orb_mapping.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\nodes\orb_matching\orb_matching.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_matching\orb_matching.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\Converter.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Converter.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\Frame.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Frame.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\FrameDrawer.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\FrameDrawer.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\Initializer.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Initializer.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\KeyFrame.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\KeyFrame.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\KeyFrameDatabase.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\KeyFrameDatabase.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\LocalMapping.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\LocalMapping.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\LoopClosing.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\LoopClosing.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\Map.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Map.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\MapDrawer.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\MapDrawer.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\MapPoint.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\MapPoint.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\ORBextractor.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\ORBextractor.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\ORBmatcher.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\ORBmatcher.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\Optimizer.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Optimizer.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\PnPsolver.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\PnPsolver.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\Sim3Solver.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Sim3Solver.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\System.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\System.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\Tracking.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Tracking.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\Viewer.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Viewer.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\ImageGrabber.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\ImageGrabber.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\ImageGrabber.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\ImageGrabber.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\bag_mapper.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\bag_mapper.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\map_publisher.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\map_publisher.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\mapper.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mapper.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\mt\DebugMT.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\DebugMT.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\mt\DebugMT.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\DebugMT.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\mt\SystemMT.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\SystemMT.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\mt\SystemMT.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\SystemMT.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\mt\TrackingThread.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\TrackingThread.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\mt\TrackingThread.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\TrackingThread.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\mt\matching_mt.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\matching_mt.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\offline_offset.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\offline_offset.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\utils.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\utils.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\__nodes\utils.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\utils.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\analysis\orbslam2_python.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\analysis\orbslam2_python.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="removed_kinect\orb_localizer\src\dumpmap.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\dumpmap.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3cf7a88726538d2e929e37ace2d2ac3e662755f9" author="AMC">
		<msg>Removed unnecesary code</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\svm_lidar_detect\svm_lidar_detect.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\svm_lidar_detect\svm_lidar_detect.cpp" added_lines="0" deleted_lines="133">
				<diff>@@ -21,7 +21,6 @@
 
 #include &lt;tf/tf.h&gt;
 
-#include "libsvm/svm.h"
 #include &lt;stdio.h&gt;
 #include &lt;string&gt;
 
@@ -46,24 +45,20 @@ private:
 	std::string model_file_path_;
 
 	FILE *model_file_handle_;
-	svm_model* model_ptr_;
 
 	void CloudClustersCallback(const lidar_tracker::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr);
 	void ClassifyFpfhDescriptor(const std::vector&lt;float&gt;&amp; in_fpfh_descriptor, double&amp; out_label, std::vector&lt;double&gt;&amp; out_scores, double&amp; out_sum_scores);
-	svm_model* LoadSvmModel(const std::string&amp; in_model_path);
 
 	void CloseModel();
 };
 
 void SvmDetect::CloseModel()
 {
-	svm_free_and_destroy_model(&amp;model_ptr_);
 	fclose(model_file_handle_);
 }
 
 SvmDetect::~SvmDetect()
 {
-	CloseModel();
 }
 
 SvmDetect::SvmDetect() :
@@ -72,28 +67,6 @@ SvmDetect::SvmDetect() :
 
 }
 
-svm_model* SvmDetect::LoadSvmModel(const std::string&amp; in_model_path)
-{
-
-	model_file_handle_ = fopen(in_model_path.c_str(),"r");
-	if(model_file_handle_ == NULL)
-	{
-		ROS_INFO("SvmDetect. can't open model file %s", in_model_path.c_str());
-		return NULL;
-	}
-
-	svm_model* model = svm_load_model(in_model_path.c_str());
-
-	if(svm_check_probability_model(model) == 0)
-	{
-		CloseModel();
-		ROS_INFO("SvmDetect. Model does not support probability estimates");
-		return NULL;
-	}
-
-	return model;
-}
-
 void SvmDetect::Run()
 {
 	ros::NodeHandle private_node_handle("~");
@@ -123,117 +96,11 @@ void SvmDetect::Run()
 
 }
 
-void SvmDetect::ClassifyFpfhDescriptor(const std::vector&lt;float&gt;&amp; in_fpfh_descriptor, double&amp; out_label, std::vector&lt;double&gt;&amp; out_scores, double&amp; out_sum_scores)
-{
-	//int svm_type =  svm_get_svm_type(model_ptr_);
-	unsigned int num_class = svm_get_nr_class(model_ptr_);
-	const unsigned int feature_number = 33;//FPFH descriptor histogram bin count
-	cv::TickMeter timer;
-	timer.reset(); timer.start();
-	svm_node* features;
-
-	features = (struct svm_node*)malloc((feature_number+1)*sizeof(struct svm_node) ); //libsvm needs an extra node to mark the end of the linked list
-
-	for(unsigned i=0;i&lt;feature_number;i++)
-	{
-		features[i].index = i+1;
-		features[i].value = in_fpfh_descriptor[i];
-	}
-	features[feature_number].index = -1;//end of the linked list
-
-	double *dec_values = (double *) malloc(sizeof(double) * num_class*(num_class-1)/2);
-	out_label = svm_predict_probability(model_ptr_, features, dec_values);
-	out_scores.clear();
-	out_sum_scores = 0.0;
-	std::cout &lt;&lt; " predicted value: " &lt;&lt; out_label &lt;&lt; ": ";
-	for(unsigned int i=0; i&lt;num_class; i++)
-	{
-		out_scores.push_back(dec_values[i]);
-		out_sum_scores+=dec_values[i];
-		std::cout &lt;&lt; (i+1) &lt;&lt; " score " &lt;&lt; dec_values[i] &lt;&lt; " | ";
-	}
-	free(dec_values);
-	free(features);
-	timer.stop(); std::cout &lt;&lt; timer.getTimeMicro() &lt;&lt; "us " ;
-}
 
 void SvmDetect::CloudClustersCallback(const lidar_tracker::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr)
 {
 	cloud_clusters_pub_.publish(*in_cloud_cluster_array_ptr);
 	return;
-	/*
-	if(model_ptr_ == NULL)
-	{
-		ROS_INFO("SvmDetect. Cannot perform classification. Invalid model file. Passing-through the clustered data.");
-		cloud_clusters_pub_.publish(*in_cloud_cluster_array_ptr);
-	}
-	else
-	{
-		lidar_tracker::CloudClusterArray classified_clusters;
-		jsk_rviz_plugins::PictogramArray pictograms_clusters;
-		classified_clusters.header = in_cloud_cluster_array_ptr-&gt;header;
-		pictograms_clusters.header = in_cloud_cluster_array_ptr-&gt;header;
-		for(unsigned int i=0; i&lt;in_cloud_cluster_array_ptr-&gt;clusters.size(); i++)
-		{
-			lidar_tracker::CloudCluster current_cluster = in_cloud_cluster_array_ptr-&gt;clusters[i];
-			double svm_label_float = -1.0, sum_scores=0.0;
-			std::vector&lt;double&gt; label_scores;
-			std::vector&lt;float&gt; descriptor =current_cluster.fpfh_descriptor.data;
-			std::string svm_class_label_str;
-			ClassifyFpfhDescriptor(descriptor, svm_label_float, label_scores, sum_scores);
-			int svm_label_int = (int) svm_label_float;
-			switch(svm_label_int)
-			{
-				case 0:
-					svm_class_label_str = "o ";
-					break;
-				case 1:
-					svm_class_label_str = "c ";
-					break;
-				case 2:
-					svm_class_label_str = "b ";
-					break;
-				case 3:
-					svm_class_label_str = "p ";
-					break;
-				default:
-					svm_class_label_str = "u ";
-					break;
-			}
-			float class_score = label_scores[svm_label_int-1]/sum_scores;
-			current_cluster.label = svm_class_label_str;
-			current_cluster.score = label_scores[svm_label_int-1];
-
-			std::cout &lt;&lt; "Object detected as:" &lt;&lt; svm_label_float &lt;&lt; " str " &lt;&lt; svm_class_label_str &lt;&lt; " score: " &lt;&lt; class_score &lt;&lt; std::endl;
-			classified_clusters.clusters.push_back(current_cluster);
-			jsk_rviz_plugins::Pictogram pictogram_cluster;
-			pictogram_cluster.header = classified_clusters.header;
-
-			pictogram_cluster.mode = pictogram_cluster.STRING_MODE;
-			pictogram_cluster.pose.position.x = current_cluster.max_point.point.x;
-			pictogram_cluster.pose.position.y = current_cluster.max_point.point.y;
-			pictogram_cluster.pose.position.z = current_cluster.max_point.point.z;
-			tf::Quaternion quat(0.0, -0.7, 0.0, 0.7);
-			tf::quaternionTFToMsg(quat, pictogram_cluster.pose.orientation);
-			pictogram_cluster.size = 4;
-			std_msgs::ColorRGBA color;
-			color.a = 1; color.r = 1; color.g = 1; color.b = 1;
-			pictogram_cluster.color = color;
-
-			std::stringstream float_str;
-			float_str &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; class_score;
-
-			//if (label_scores[svm_label_int-1]&gt;0.9)
-				pictogram_cluster.character = svm_class_label_str + float_str.str();
-			//else
-			//	pictogram_cluster.character = "";
-
-
-			pictograms_clusters.pictograms.push_back(pictogram_cluster);
-		}
-		cloud_clusters_pub_.publish(classified_clusters);
-		text_pictogram_pub_.publish(pictograms_clusters);
-	}*/
 }
 
 int main(int argc, char **argv)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="14f7eca8a5b5aecf110ce6ebb3ab0467323b75fd" author="yukikitsukawa">
		<msg>add measurement_range
refactoring</msg>
		<modified_files>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" added_lines="9" deleted_lines="1">
				<diff>@@ -39,8 +39,11 @@
 
 #include &lt;points_downsampler/PointsDownsamplerInfo.h&gt;
 
+#include &lt;algorithm&gt; // For std::min()
 #include &lt;chrono&gt;
 
+#include "points_downsampler.h"
+
 ros::Publisher filtered_points_pub;
 
 static int sample_num = 1000;
@@ -55,10 +58,12 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
+static double measurement_range;
 
 static void config_callback(const runtime_manager::ConfigDistanceFilter::ConstPtr&amp; input)
 {
   sample_num = input-&gt;sample_num;
+  measurement_range = input-&gt;measurement_range;
 }
 
 static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
@@ -67,6 +72,8 @@ static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   pcl::PointCloud&lt;pcl::PointXYZI&gt; scan;
 
   pcl::fromROSMsg(*input, scan);
+  scan = removePointsByRange(scan, 0, measurement_range);
+
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
   filtered_scan_ptr-&gt;header = scan.header;
 
@@ -110,8 +117,9 @@ static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   points_downsampler_info_msg.header = input-&gt;header;
   points_downsampler_info_msg.filter_name = "distance_filter";
+  points_downsampler_info_msg.measurement_range = measurement_range;
   points_downsampler_info_msg.original_points_size = points_num;
-  points_downsampler_info_msg.filtered_points_size = filtered_scan_ptr-&gt;size();
+  points_downsampler_info_msg.filtered_points_size = std::min((int)filtered_scan_ptr-&gt;size(), points_num);
   points_downsampler_info_msg.original_ring_size = 0;
   points_downsampler_info_msg.original_ring_size = 0;
   points_downsampler_info_msg.exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(filter_end - filter_start).count() / 1000.0;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" added_lines="14" deleted_lines="3">
				<diff>@@ -40,6 +40,8 @@
 
 #include &lt;chrono&gt;
 
+#include &lt;points_downsampler.h&gt;
+
 ros::Publisher filtered_points_pub;
 
 static int sample_num = 1000;
@@ -54,10 +56,12 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
+static double measurement_range;
 
 static void config_callback(const runtime_manager::ConfigRandomFilter::ConstPtr&amp; input)
 {
   sample_num = input-&gt;sample_num;
+  measurement_range = input-&gt;measurement_range;
 }
 
 static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
@@ -66,6 +70,7 @@ static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   pcl::PointCloud&lt;pcl::PointXYZI&gt; scan;
 
   pcl::fromROSMsg(*input, scan);
+  scan = removePointsByRange(scan, 0, measurement_range);
 
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
   filtered_scan_ptr-&gt;header = scan.header;
@@ -75,12 +80,17 @@ static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   int points_num = scan.size();
   int step = points_num / sample_num;
 
-  for (int i = 0; i &lt; points_num; i++)
+  if(scan.points.size() &gt;= sample_num)
   {
-    if ((int)filtered_scan_ptr-&gt;size() &lt; sample_num &amp;&amp; i % step == 0)
+    for (int i = 0; i &lt; points_num; i++)
     {
-      filtered_scan_ptr-&gt;points.push_back(scan.at(i));
+      if ((int)filtered_scan_ptr-&gt;size() &lt; sample_num &amp;&amp; i % step == 0)
+      {
+        filtered_scan_ptr-&gt;points.push_back(scan.at(i));
+      }
     }
+  }else{
+    filtered_scan_ptr = scan.makeShared();
   }
 
   sensor_msgs::PointCloud2 filtered_msg;
@@ -93,6 +103,7 @@ static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   points_downsampler_info_msg.header = input-&gt;header;
   points_downsampler_info_msg.filter_name = "random_filter";
+  points_downsampler_info_msg.measurement_range = measurement_range;
   points_downsampler_info_msg.original_points_size = points_num;
   points_downsampler_info_msg.filtered_points_size = filtered_scan_ptr-&gt;size();
   points_downsampler_info_msg.original_ring_size = 0;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\ring_filter\ring_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\ring_filter\ring_filter.cpp" added_lines="12" deleted_lines="6">
				<diff>@@ -61,16 +61,17 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
+static double measurement_range;
 
 static void config_callback(const runtime_manager::ConfigRingFilter::ConstPtr&amp; input)
 {
   ring_div = input-&gt;ring_div;
   voxel_leaf_size = input-&gt;voxel_leaf_size;
+  measurement_range = input-&gt;measurement_range;
 }
 
 static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 {
-  pcl::PointXYZI p;
   pcl::PointCloud&lt;pcl::PointXYZI&gt; scan;
   pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; tmp;
   sensor_msgs::PointCloud2 filtered_msg;
@@ -84,11 +85,15 @@ static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   for (pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::const_iterator item = tmp.begin(); item != tmp.end(); item++)
   {
-    p.x = (double)item-&gt;x;
-    p.y = (double)item-&gt;y;
-    p.z = (double)item-&gt;z;
-    p.intensity = (double)item-&gt;intensity;
-    if (item-&gt;ring % ring_div == 0)
+    pcl::PointXYZI p;
+    p.x = item-&gt;x;
+    p.y = item-&gt;y;
+    p.z = item-&gt;z;
+    p.intensity = item-&gt;intensity;
+
+    double distance = sqrt(p.x * p.x + p.y * p.y);
+
+    if (item-&gt;ring % ring_div == 0 &amp;&amp; distance &lt;= measurement_range)
     {
       scan.points.push_back(p);
     }
@@ -124,6 +129,7 @@ static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   points_downsampler_info_msg.header = input-&gt;header;
   points_downsampler_info_msg.filter_name = "ring_filter";
+  points_downsampler_info_msg.measurement_range = measurement_range;
   points_downsampler_info_msg.original_points_size = scan.size();
   if (voxel_leaf_size &gt;= 0.1)
   {
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" added_lines="8" deleted_lines="1">
				<diff>@@ -41,6 +41,8 @@
 
 #include &lt;chrono&gt;
 
+#include "points_downsampler.h"
+
 ros::Publisher filtered_points_pub;
 
 // Leaf size of VoxelGrid filter.
@@ -56,16 +58,21 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
+static double measurement_range;
 
 static void config_callback(const runtime_manager::ConfigVoxelGridFilter::ConstPtr&amp; input)
 {
   voxel_leaf_size = input-&gt;voxel_leaf_size;
+  measurement_range = input-&gt;measurement_range;
 }
 
 static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 {
   pcl::PointCloud&lt;pcl::PointXYZI&gt; scan;
   pcl::fromROSMsg(*input, scan);
+
+  scan = removePointsByRange(scan, 0, measurement_range);
+
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(scan));
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
 
@@ -81,7 +88,6 @@ static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
     voxel_grid_filter.setInputCloud(scan_ptr);
     voxel_grid_filter.filter(*filtered_scan_ptr);
-
     pcl::toROSMsg(*filtered_scan_ptr, filtered_msg);
   }
   else
@@ -96,6 +102,7 @@ static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   points_downsampler_info_msg.header = input-&gt;header;
   points_downsampler_info_msg.filter_name = "voxel_grid_filter";
+  points_downsampler_info_msg.measurement_range = measurement_range;
   points_downsampler_info_msg.original_points_size = scan.size();
   if (voxel_leaf_size &gt;= 0.1)
   {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d803e9e6366611fd281772578e648126fc49e5e7" author="yukikitsukawa">
		<msg>not call removePointsByRange() when measurement_range is 200
not compute sqrt</msg>
		<modified_files>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\include\points_downsampler.h" new_path="ros\src\sensing\filters\packages\points_downsampler\include\points_downsampler.h" added_lines="5" deleted_lines="3">
				<diff>@@ -4,9 +4,11 @@
 static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::PointXYZI&gt; scan, double min_range, double max_range)
 {
   pcl::PointCloud&lt;pcl::PointXYZI&gt; narrowed_scan;
-
   narrowed_scan.header = scan.header;
 
+  double square_min_range = min_range * min_range;
+  double square_max_range = max_range * max_range;
+
   for(pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator iter = scan.begin(); iter != scan.end(); ++iter)
   {
     pcl::PointXYZI p;
@@ -14,9 +16,9 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::
     p.y = iter-&gt;y;
     p.z = iter-&gt;z;
     p.intensity = iter-&gt;intensity;
-    double distance = sqrt(p.x * p.x + p.y * p.y);
+    double square_distance = p.x * p.x + p.y * p.y;
 
-    if(min_range &lt;= distance &amp;&amp; distance &lt;= max_range){
+    if(square_min_range &lt;= square_distance &amp;&amp; square_distance &lt;= square_max_range){
       narrowed_scan.points.push_back(p);
     }
   }
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\distance_filter\distance_filter.cpp" added_lines="6" deleted_lines="1">
				<diff>@@ -44,6 +44,8 @@
 
 #include "points_downsampler.h"
 
+#define MAX_MEASUREMENT_RANGE 200.0
+
 ros::Publisher filtered_points_pub;
 
 static int sample_num = 1000;
@@ -72,7 +74,10 @@ static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   pcl::PointCloud&lt;pcl::PointXYZI&gt; scan;
 
   pcl::fromROSMsg(*input, scan);
-  scan = removePointsByRange(scan, 0, measurement_range);
+
+  if(measurement_range != MAX_MEASUREMENT_RANGE){
+    scan = removePointsByRange(scan, 0, measurement_range);
+  }
 
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
   filtered_scan_ptr-&gt;header = scan.header;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\random_filter\random_filter.cpp" added_lines="7" deleted_lines="2">
				<diff>@@ -40,7 +40,9 @@
 
 #include &lt;chrono&gt;
 
-#include &lt;points_downsampler.h&gt;
+#include "points_downsampler.h"
+
+#define MAX_MEASUREMENT_RANGE 200.0
 
 ros::Publisher filtered_points_pub;
 
@@ -70,7 +72,10 @@ static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   pcl::PointCloud&lt;pcl::PointXYZI&gt; scan;
 
   pcl::fromROSMsg(*input, scan);
-  scan = removePointsByRange(scan, 0, measurement_range);
+
+  if(measurement_range != MAX_MEASUREMENT_RANGE){
+    scan = removePointsByRange(scan, 0, measurement_range);
+  }
 
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
   filtered_scan_ptr-&gt;header = scan.header;
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" new_path="ros\src\sensing\filters\packages\points_downsampler\nodes\voxel_grid_filter\voxel_grid_filter.cpp" added_lines="5" deleted_lines="1">
				<diff>@@ -43,6 +43,8 @@
 
 #include "points_downsampler.h"
 
+#define MAX_MEASUREMENT_RANGE 200.0
+
 ros::Publisher filtered_points_pub;
 
 // Leaf size of VoxelGrid filter.
@@ -71,7 +73,9 @@ static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   pcl::PointCloud&lt;pcl::PointXYZI&gt; scan;
   pcl::fromROSMsg(*input, scan);
 
-  scan = removePointsByRange(scan, 0, measurement_range);
+  if(measurement_range != MAX_MEASUREMENT_RANGE){
+    scan = removePointsByRange(scan, 0, measurement_range);
+  }
 
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(scan));
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b8ddc5f8925e8608d94bdc4051a66a9e3495a5a2" author="YamatoAndo">
		<msg>fix vg440 acceletation</msg>
		<modified_files>
			<file old_path="ros\src\sensing\drivers\imu\packages\memsic\nodes\vg440\vg440_node.cpp" new_path="ros\src\sensing\drivers\imu\packages\memsic\nodes\vg440\vg440_node.cpp" added_lines="6" deleted_lines="4">
				<diff>@@ -313,7 +313,7 @@ struct SNAV1Msg{
   double dRollRate; //[rad/s]
   double dPitchRate;
   double dYawRate;
-  double dXAccel; //[m/s^2]
+  double dXAccel; //[G]
   double dYAccel;
   double dZAccel;
   double dNVel;   //[m/s]
@@ -349,12 +349,14 @@ bool MsgToNav1(const unsigned char* data, SNAV1Msg &amp;sMsg) {
 }
 
 void Nav1ToRosImu(const SNAV1Msg &amp;rNav1, sensor_msgs::Imu &amp;ImuData) {
+  const double gravityAccel = 9.80665;
+  
   ImuData.angular_velocity.x = rNav1.dRollRate;
   ImuData.angular_velocity.y = rNav1.dPitchRate;
   ImuData.angular_velocity.z = rNav1.dYawRate;
-  ImuData.linear_acceleration.x = rNav1.dXAccel;
-  ImuData.linear_acceleration.y = rNav1.dYAccel;
-  ImuData.linear_acceleration.z = rNav1.dZAccel;
+  ImuData.linear_acceleration.x = rNav1.dXAccel * gravityAccel;
+  ImuData.linear_acceleration.y = rNav1.dYAccel * gravityAccel;
+  ImuData.linear_acceleration.z = rNav1.dZAccel * gravityAccel;
   ImuData.orientation = tf::createQuaternionMsgFromRollPitchYaw(rNav1.dRollAngle, rNav1.dPitchAngle, rNav1.dYawAngle);
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cea33d7e1e80047749a0d8a2ab3edf729399b482" author="Yusuke FUJII">
		<msg>Fixed compatibility issues with indigo</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lib\image\kf\src\kf.cpp" new_path="ros\src\computing\perception\detection\lib\image\kf\src\kf.cpp" added_lines="9" deleted_lines="1">
				<diff>@@ -60,8 +60,12 @@
 #define SSTR( x ) dynamic_cast&lt; std::ostringstream &amp; &gt;( \
         ( std::ostringstream() &lt;&lt; std::dec &lt;&lt; x ) ).str()
 
-
+#include &lt;opencv2/core/version.hpp&gt;
+#if (CV_MAJOR_VERSION == 3)
 #include "gencolors.cpp"
+#else
+#include &lt;opencv2/contrib/contrib.hpp&gt;
+#endif
 
 struct ObjectDetection_
 {
@@ -960,8 +964,12 @@ int kf_main(int argc, char* argv[])
 
 	image_objects = n.advertise&lt;cv_tracker_msgs::image_obj_tracked&gt;("image_obj_tracked", 1);
 
+#if (CV_MAJOR_VERSION == 3)
 	generateColors(_colors, 25);
+#else
+	cv::generateColors(_colors, 25);
 
+#endif
 	std::string image_topic;
 	std::string obj_topic;
 	if (private_nh.getParam("image_node", image_topic))
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\lib\lktracker\LkTracker.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\lib\lktracker\LkTracker.cpp" added_lines="4" deleted_lines="0">
				<diff>@@ -22,7 +22,11 @@ LkTracker::LkTracker(int in_id, float in_min_height, float in_max_height, float
 	previous_centroid_x_	= 0;
 	previous_centroid_y_	= 0;
 
+#if (CV_MAJOR_VERSION == 3)
 	generateColors(colors_, 2);
+#else
+	cv::generateColors(colors_, 2);
+#endif
 	lifespan_				= 45;
 	DEFAULT_LIFESPAN_		= 45;
 	object_id				= in_id;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\lib\lktracker\LkTracker.hpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\lib\lktracker\LkTracker.hpp" added_lines="5" deleted_lines="1">
				<diff>@@ -9,12 +9,16 @@
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;opencv2/objdetect/objdetect.hpp&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
-//#include &lt;opencv2/contrib/contrib.hpp&gt;
 #include &lt;opencv2/video/tracking.hpp&gt;
 #include &lt;opencv2/calib3d/calib3d.hpp&gt;
 #include &lt;opencv2/features2d/features2d.hpp&gt;
 
+#include &lt;opencv2/core/version.hpp&gt;
+#if (CV_MAJOR_VERSION == 3)
 #include "gencolors.cpp"
+#else
+#include &lt;opencv2/contrib/contrib.hpp&gt;
+#endif
 
 struct ObjectDetection
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ocv\dpm_ocv.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\dpm_ocv\dpm_ocv.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -6,7 +6,7 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;cv_tracker/image_obj.h&gt;
+#include &lt;cv_tracker_msgs/image_obj.h&gt;
 #include &lt;runtime_manager/ConfigCarDpm.h&gt;
 
 #include &lt;dpm_ocv.hpp&gt;
@@ -135,7 +135,7 @@ void objectDetect::run()
 	config_topic += ros::this_node::getNamespace() + "/dpm";
 	config_sub_ = nh_.subscribe&lt;runtime_manager::ConfigCarDpm&gt;(config_topic, 1, &amp;objectDetect::configCallback, this);
 	img_sub_ = nh_.subscribe&lt;sensor_msgs::Image&gt;(image_topic_name, 1, &amp;objectDetect::imageCallback, this);
-	detect_pub_ = nh_.advertise&lt;cv_tracker::image_obj&gt;("image_obj", 1);
+	detect_pub_ = nh_.advertise&lt;cv_tracker_msgs::image_obj&gt;("image_obj", 1);
 }
 
 // Callback
@@ -164,14 +164,14 @@ void objectDetect::imageCallback(const sensor_msgs::ImageConstPtr&amp; img)
 	std::vector&lt;int&gt; corner_point_array(num * 4.0);
 	std::vector&lt;int&gt; type_array(num, 0);
 
-	cv_tracker::image_obj msg;
+	cv_tracker_msgs::image_obj msg;
 	msg.header = img-&gt;header;
 	msg.type = object_class;
 
 	for(size_t i = 0; i &lt; detections.size(); i++)
 	{
 		const cv::LatentSvmDetector::ObjectDetection&amp; od = detections[i];
-		cv_tracker::image_rect rect;
+		cv_tracker_msgs::image_rect rect;
 
 		type_array[i] = od.classID;
 		rect.x = od.rect.x;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\kf_track\kf_track.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\kf_track\kf_track.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -30,7 +30,7 @@
 
 #include &lt;string&gt;
 #include &lt;ros/ros.h&gt;
-#include &lt;cv_tracker/ImageObjects.h&gt;
+#include &lt;cv_tracker_msgs/ImageObjects.h&gt;
 
 extern int kf_main(int argc, char* argv[]);
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_rects.cpp" added_lines="12" deleted_lines="2">
				<diff>@@ -1,10 +1,16 @@
 #include "draw_rects.h"
 #include &lt;string&gt;
 #include &lt;vector&gt;
-//#include &lt;opencv2/contrib/contrib.hpp&gt;
-#include "gencolors.cpp"
 
 
+#include &lt;opencv2/core/version.hpp&gt;
+
+#if (CV_MAJOR_VERSION == 3)
+#include "gencolors.cpp"
+#else
+#include &lt;opencv2/contrib/contrib.hpp&gt;
+#endif
+
 namespace integrated_viewer
 {
   const int        DrawRects::kRectangleThickness = 3;
@@ -13,7 +19,11 @@ namespace integrated_viewer
   
   DrawRects::DrawRects(void) {
     // Generate color map to represent tracked object
+#if (CV_MAJOR_VERSION == 3)
     generateColors(color_map_, 25);
+#else
+    cv::generateColors(color_map_, 25);
+#endif
 
   } // DrawRects::DrawRects()
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" added_lines="4" deleted_lines="0">
				<diff>@@ -1,7 +1,11 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
+
+#if (CV_MAJOR_VERSION == 3)
 #include &lt;opencv2/imgcodecs/imgcodecs.hpp&gt;
+#endif
+
 #include &lt;QString&gt;
 #include &lt;QImage&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" added_lines="9" deleted_lines="1">
				<diff>@@ -49,8 +49,12 @@
 
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
-//#include &lt;opencv2/contrib/contrib.hpp&gt;
+#include &lt;opencv2/core/version.hpp&gt;
+#if (CV_MAJOR_VERSION == 3)
 #include "gencolors.cpp"
+#else
+#include &lt;opencv2/contrib/contrib.hpp&gt;
+#endif
 
 #include &lt;chrono&gt;
 #include &lt;iostream&gt;
@@ -676,7 +680,11 @@ int main (int argc, char** argv)
 	_transform = &amp;transform;
 	_transform_listener = &amp;listener;
 
+#if (CV_MAJOR_VERSION == 3)
 	generateColors(_colors, 100);
+#else
+	cv::generateColors(_colors, 100);
+#endif
 
 	_pub_cluster_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_cluster",1);
 	_pub_ground_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;("/points_ground",1);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\tunerBody.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\tunerBody.cpp" added_lines="27" deleted_lines="12">
				<diff>@@ -1,6 +1,15 @@
 #include "tunerBody.h"
 #include "road_wizard/TunedResult.h"
 
+
+#include &lt;opencv2/core/version.hpp&gt;
+#if (CV_MAJOR_VERSION != 3)
+#define CV cv
+#else
+#define CV cv::internal
+#endif
+
+
 static constexpr int32_t ADVERTISE_QUEUE_SIZE = 10;
 static constexpr bool    ADVERTISE_LATCH      = true;
 
@@ -396,63 +405,69 @@ void TunerBody::saveResult(std::string fileName)
 
   /* write data to file */
   {
-    cv::internal::WriteStructContext st_red(cvfs, "RED", CV_NODE_MAP);
+    CV::WriteStructContext st_red(cvfs, "RED", CV_NODE_MAP);
+    //cv::internal::WriteStructContext st_red(cvfs, "RED", CV_NODE_MAP);
     {
-      cv::internal::WriteStructContext st_hue(cvfs, "Hue", CV_NODE_MAP);
+      CV::WriteStructContext st_hue(cvfs, "Hue", CV_NODE_MAP);
+      //cv::internal::WriteStructContext st_hue(cvfs, "Hue", CV_NODE_MAP);
       cv::write(cvfs, "center", Red_set.hue.center);
       cv::write(cvfs, "range", Red_set.hue.range);
     }
 
     {
-      cv::internal::WriteStructContext st_hue(cvfs, "Saturation", CV_NODE_MAP);
+      CV::WriteStructContext st_hue(cvfs, "Saturation", CV_NODE_MAP);
       cv::write(cvfs, "center", Red_set.sat.center);
       cv::write(cvfs, "range", Red_set.sat.range);
     }
 
     {
-      cv::internal::WriteStructContext st_hue(cvfs, "Value", CV_NODE_MAP);
+      CV::WriteStructContext st_hue(cvfs, "Value", CV_NODE_MAP);
       cv::write(cvfs, "center", Red_set.val.center);
       cv::write(cvfs, "range", Red_set.val.range);
     }
   }
 
   {
-    cv::internal::WriteStructContext st_yellow(cvfs, "YELLOW", CV_NODE_MAP);
+    CV::WriteStructContext st_yellow(cvfs, "YELLOW", CV_NODE_MAP);
+    //CV::WriteStructContext st_yellow(cvfs, "YELLOW", CV_NODE_MAP);
     {
-      cv::internal::WriteStructContext st_hue(cvfs, "Hue", CV_NODE_MAP);
+      CV::WriteStructContext st_hue(cvfs, "Hue", CV_NODE_MAP);
+      //CV::WriteStructContext st_hue(cvfs, "Hue", CV_NODE_MAP);
       cv::write(cvfs, "center", Yellow_set.hue.center);
       cv::write(cvfs, "range", Yellow_set.hue.range);
     }
 
     {
-      cv::internal::WriteStructContext st_hue(cvfs, "Saturation", CV_NODE_MAP);
+      CV::WriteStructContext st_hue(cvfs, "Saturation", CV_NODE_MAP);
+      //CV::WriteStructContext st_hue(cvfs, "Saturation", CV_NODE_MAP);
       cv::write(cvfs, "center", Yellow_set.sat.center);
       cv::write(cvfs, "range", Yellow_set.sat.range);
     }
 
     {
-      cv::internal::WriteStructContext st_hue(cvfs, "Value", CV_NODE_MAP);
+      CV::WriteStructContext st_hue(cvfs, "Value", CV_NODE_MAP);
+     // CV::WriteStructContext st_hue(cvfs, "Value", CV_NODE_MAP);
       cv::write(cvfs, "center", Yellow_set.val.center);
       cv::write(cvfs, "range", Yellow_set.val.range);
     }
   }
 
   {
-    cv::internal::WriteStructContext st_green(cvfs, "GREEN", CV_NODE_MAP);
+    CV::WriteStructContext st_green(cvfs, "GREEN", CV_NODE_MAP);
     {
-      cv::internal::WriteStructContext st_hue(cvfs, "Hue", CV_NODE_MAP);
+      CV::WriteStructContext st_hue(cvfs, "Hue", CV_NODE_MAP);
       cv::write(cvfs, "center", Green_set.hue.center);
       cv::write(cvfs, "range", Green_set.hue.range);
     }
 
     {
-      cv::internal::WriteStructContext st_hue(cvfs, "Saturation", CV_NODE_MAP);
+      CV::WriteStructContext st_hue(cvfs, "Saturation", CV_NODE_MAP);
       cv::write(cvfs, "center", Green_set.sat.center);
       cv::write(cvfs, "range", Green_set.sat.range);
     }
 
     {
-      cv::internal::WriteStructContext st_hue(cvfs, "Value", CV_NODE_MAP);
+      CV::WriteStructContext st_hue(cvfs, "Value", CV_NODE_MAP);
       cv::write(cvfs, "center", Green_set.val.center);
       cv::write(cvfs, "range", Green_set.val.range);
     }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\tunerBody.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\tunerBody.h" added_lines="2" deleted_lines="0">
				<diff>@@ -3,7 +3,9 @@
 
 #include &lt;iostream&gt;
 #include &lt;string&gt;
+
 #include &lt;opencv2/opencv.hpp&gt;
+
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\image_viewer\image_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\image_viewer\image_viewer.cpp" added_lines="11" deleted_lines="1">
				<diff>@@ -31,8 +31,14 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
-//#include &lt;opencv2/contrib/contrib.hpp&gt;
+#include &lt;opencv/cv.h&gt;
+#include &lt;opencv/highgui.h&gt;
+#include &lt;opencv2/core/version.hpp&gt;
+#if (CV_MAJOR_VERSION == 3)
 #include "gencolors.cpp"
+#else
+#include &lt;opencv2/contrib/contrib.hpp&gt;
+#endif
 
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
@@ -292,7 +298,11 @@ int main(int argc, char **argv)
 		image_topic_name = "/image_raw";
 	}
 
+#if (CV_MAJOR_VERSION == 3)
 	generateColors(_colors, 25);
+#else
+	cv::generateColors(_colors, 25);
+#endif
 
 	ros::Subscriber scriber = n.subscribe(image_topic_name, 1, image_viewer_callback);
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\points_image_d_viewer\points_image_d_viewer.cpp" added_lines="11" deleted_lines="2">
				<diff>@@ -31,8 +31,13 @@
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
 #include &lt;opencv2/opencv.hpp&gt;
-//#include &lt;opencv2/contrib/contrib.hpp&gt;
+
+#include &lt;opencv2/core/version.hpp&gt;
+#if (CV_MAJOR_VERSION == 3)
 #include "gencolors.cpp"
+#else
+#include &lt;opencv2/contrib/contrib.hpp&gt;
+#endif
 
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
@@ -367,7 +372,11 @@ int main(int argc, char **argv)
     points_node = "/points_image";
   }
 
-  generateColors(_colors, 25);
+#if (CV_MAJOR_VERSION == 3)
+	generateColors(_colors, 25);
+#else
+	cv::generateColors(_colors, 25);
+#endif
 
   ros::Subscriber scriber = n.subscribe(image_topic_name, 1,
                                         image_cb);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" new_path="ros\src\computing\perception\detection\packages\viewers\nodes\vscan_image_d_viewer\vscan_image_d_viewer.cpp" added_lines="4" deleted_lines="1">
				<diff>@@ -256,8 +256,11 @@ int main(int argc, char **argv)
 		ROS_INFO("No points node received, defaulting to points_image, you can use _points_node:=YOUR_TOPIC");
 		points_node = "/vscan_image";
 	}
-
+#if (CV_MAJOR_VERSION == 3)
 	generateColors(_colors, 25);
+#else
+	cv::generateColors(_colors, 25);
+#endif
 
 	ros::Subscriber scriber = n.subscribe(image_topic_name, 1,
 					    image_cb);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4e31537be93f24cba0ff9137f275a9679a16d769" author="yukikitsukawa">
		<msg>change topic name for imu data (imu_raw)</msg>
		<modified_files>
			<file old_path="ros\src\sensing\drivers\imu\packages\memsic\nodes\vg440\vg440_node.cpp" new_path="ros\src\sensing\drivers\imu\packages\memsic\nodes\vg440\vg440_node.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -344,8 +344,8 @@ bool MsgToNav1(const unsigned char* data, SNAV1Msg &amp;sMsg) {
   sMsg.dLatitude = MKInt(data+28)*2.0*M_PI/(256*256);
   sMsg.dAltitude = MKShort(data+32)/4.0;
   sMsg.xRateTemp = MKShort(data+34)*200.0/(256*256);
-  sMsg.timeITOW			= (unsigned int)MKInt(data+36);
-  sMsg.BITStatus     = (unsigned short)MKShort(data+40);
+  sMsg.timeITOW = (unsigned int)MKInt(data+36);
+  sMsg.BITStatus = (unsigned short)MKShort(data+40);
 }
 
 void Nav1ToRosImu(const SNAV1Msg &amp;rNav1, sensor_msgs::Imu &amp;ImuData) {
@@ -438,8 +438,8 @@ int main(int argc, char **argv) {
   int nBaudRate;
 
   string sFrameDefault = "/vg440";
-  string sTopicDefault = "/imu_data";
-  string sPortDefault  = "/dev/ttyUSB0";
+  string sTopicDefault = "/imu_raw";
+  string sPortDefault = "/dev/ttyUSB0";
   int nBaudRateDefault = 57600;
   ros::init(argc, argv, "vg440_node");
   ros::NodeHandle n_private_("~");
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5ab42029e745ebc850e349c8c118819dad869148" author="YamatoAndo">
		<msg>ndt with imu (temporary)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="287" deleted_lines="15">
				<diff>@@ -44,6 +44,8 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;std_msgs/Float32.h&gt;
+#include &lt;nav_msgs/Odometry.h&gt;
+#include &lt;sensor_msgs/Imu.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;velodyne_pointcloud/point_types.h&gt;
 #include &lt;velodyne_pointcloud/rawdata.h&gt;
@@ -78,9 +80,25 @@ struct pose
 };
 
 // global variables
-static pose previous_pose, guess_pose, current_pose, ndt_pose, added_pose, localizer_pose;
+static pose previous_pose, guess_pose, guess_pose_imu, guess_pose_odom, current_pose, current_pose_imu, current_pose_odom, ndt_pose, added_pose, localizer_pose;
 
-static double offset_x, offset_y, offset_z, offset_yaw;  // current_pose - previous_pose
+static ros::Time current_scan_time;
+static ros::Time previous_scan_time;
+static ros::Duration scan_duration;
+
+static double diff = 0.0;
+static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw; // current_pose - previous_pose
+static double offset_x, offset_y, offset_z, offset_roll, offset_pitch, offset_yaw;
+static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
+static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
+
+static double current_velocity_x = 0.0;
+static double current_velocity_y = 0.0;
+static double current_velocity_z = 0.0;
+
+static double current_velocity_imu_x = 0.0;
+static double current_velocity_imu_y = 0.0;
+static double current_velocity_imu_z = 0.0;
 
 static pcl::PointCloud&lt;pcl::PointXYZI&gt; map;
 
@@ -100,7 +118,9 @@ static ros::Duration d_callback, d1, d2, d3, d4, d5;
 
 static ros::Publisher ndt_map_pub;
 static ros::Publisher current_pose_pub;
-static geometry_msgs::PoseStamped current_pose_msg;
+static ros::Publisher guess_pose_linaer_pub;
+static ros::Publisher guess_pose_imu_pub;
+static geometry_msgs::PoseStamped current_pose_msg, guess_pose_msg, guess_pose_imu_msg;
 
 static ros::Publisher ndt_stat_pub;
 static std_msgs::Bool ndt_stat_msg;
@@ -120,8 +140,12 @@ static bool _use_openmp = false;
 
 static double fitness_score;
 
+static sensor_msgs::Imu imu;
+static double odom_distance_velocity = 0;
+
 static void param_callback(const runtime_manager::ConfigNdtMapping::ConstPtr&amp; input)
 {
+
   ndt_res = input-&gt;resolution;
   step_size = input-&gt;step_size;
   trans_eps = input-&gt;trans_epsilon;
@@ -186,6 +210,169 @@ static void output_callback(const runtime_manager::ConfigNdtMappingOutput::Const
   }
 }
 
+static void odom_calc(ros::Time current_time)
+{
+  static ros::Time previous_time = current_time;
+  double diff_time = (current_time - previous_time).toSec();
+
+  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
+  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
+  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;
+
+  current_pose_odom.roll  += diff_imu_roll;
+  current_pose_odom.pitch += diff_imu_pitch;
+  current_pose_odom.yaw   += diff_imu_yaw;
+
+  double diff_distance = odom_distance_velocity * diff_time;
+  offset_odom_x += diff_distance*cos(-current_pose_odom.pitch)*cos(current_pose_odom.yaw);
+  offset_odom_y += diff_distance*cos(-current_pose_odom.pitch)*sin(current_pose_odom.yaw);
+  offset_odom_z += diff_distance*sin(-current_pose_odom.pitch);
+
+  offset_odom_roll  += diff_imu_roll;
+  offset_odom_pitch += diff_imu_pitch;
+  offset_odom_yaw   += diff_imu_yaw;
+
+  guess_pose_odom.x     = previous_pose.x     + offset_odom_x;
+  guess_pose_odom.y     = previous_pose.y     + offset_odom_y;
+  guess_pose_odom.z     = previous_pose.z     + offset_odom_z;
+  guess_pose_odom.roll  = previous_pose.roll  + offset_odom_roll;
+  guess_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
+  guess_pose_odom.yaw   = previous_pose.yaw   + offset_odom_yaw;
+ 
+  previous_time = current_time;
+}
+
+static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
+{  
+  odom_distance_velocity = input-&gt;twist.twist.linear.x;
+  odom_calc(input-&gt;header.stamp);
+}
+
+
+static void imu_calc(ros::Time current_time)
+{
+
+  static ros::Time previous_time = current_time;
+  double diff_time = (current_time - previous_time).toSec();
+
+  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
+  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
+  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;
+
+  current_pose_imu.roll += diff_imu_roll;
+  current_pose_imu.pitch += diff_imu_pitch;
+  current_pose_imu.yaw += diff_imu_yaw;
+
+  double accX1 = imu.linear_acceleration.x;
+  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y
+                -std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
+  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y
+                +std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;
+
+  double accX2 = std::sin(current_pose_imu.pitch) * accZ1 + std::cos(current_pose_imu.pitch) * accX1;
+  double accY2 = accY1;
+  double accZ2 = std::cos(current_pose_imu.pitch) * accZ1 - std::sin(current_pose_imu.pitch) * accX1;
+
+  double accX = std::cos(current_pose_imu.yaw) * accX2 - std::sin(current_pose_imu.yaw) * accY2;
+  double accY = std::sin(current_pose_imu.yaw) * accX2 + std::cos(current_pose_imu.yaw) * accY2;
+  double accZ = accZ2;
+
+  offset_imu_x += current_velocity_imu_x * diff_time + accX * diff_time * diff_time / 2.0;
+  offset_imu_y += current_velocity_imu_y * diff_time + accY * diff_time * diff_time / 2.0;
+  offset_imu_z += current_velocity_imu_z * diff_time + accZ * diff_time * diff_time / 2.0;
+
+  current_velocity_imu_x += accX * diff_time;
+  current_velocity_imu_y += accY * diff_time;
+  current_velocity_imu_z += accZ * diff_time;
+
+  offset_imu_roll  += diff_imu_roll;
+  offset_imu_pitch += diff_imu_pitch;
+  offset_imu_yaw   += diff_imu_yaw;
+
+  guess_pose_imu.x     = previous_pose.x     + offset_imu_x;
+  guess_pose_imu.y     = previous_pose.y     + offset_imu_y;
+  guess_pose_imu.z     = previous_pose.z     + offset_imu_z;
+  guess_pose_imu.roll  = previous_pose.roll  + offset_imu_roll;
+  guess_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
+  guess_pose_imu.yaw   = previous_pose.yaw   + offset_imu_yaw;  
+
+  previous_time = current_time;
+}
+
+
+static double wrapToPm(double a_num, const double a_max)
+{
+    if (a_num &gt;= a_max)
+    {
+        a_num -= 2.0 * a_max;
+    }
+    return a_num;
+}
+
+static double wrapToPmPi(double a_angle_rad)
+{
+    return wrapToPm(a_angle_rad, M_PI);
+}
+
+
+static void imu_callback(const sensor_msgs::Imu::ConstPtr&amp; input)
+{
+  const ros::Time current_time = input-&gt;header.stamp;
+  static ros::Time previous_time = current_time;
+  const double diff_time =  (current_time - previous_time).toSec();
+
+  double imu_roll, imu_pitch, imu_yaw;
+  tf::Quaternion imu_orientation;
+  tf::quaternionMsgToTF(input-&gt;orientation, imu_orientation);
+  tf::Matrix3x3(imu_orientation).getRPY(imu_roll, imu_pitch, imu_yaw);
+
+  imu_roll = wrapToPmPi(imu_roll);
+  imu_pitch = wrapToPmPi(imu_pitch);
+  imu_yaw = wrapToPmPi(imu_yaw);
+
+  static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
+  const double diff_imu_roll  = imu_roll  - previous_imu_roll;
+
+  const double diff_imu_pitch = imu_pitch - previous_imu_pitch;
+
+  double diff_imu_yaw;
+  if(fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
+  {
+    if(imu_yaw &gt; 0)
+      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI*2;
+    else
+      diff_imu_yaw = -M_PI*2 - (imu_yaw - previous_imu_yaw);
+  }
+  else
+  diff_imu_yaw = imu_yaw - previous_imu_yaw;
+
+  imu.header = input-&gt;header;
+  imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
+  imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
+  imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
+
+  if(diff_time != 0)
+  {
+    imu.angular_velocity.x = diff_imu_roll  / diff_time;
+    imu.angular_velocity.y = diff_imu_pitch / diff_time;
+    imu.angular_velocity.z = diff_imu_yaw   / diff_time;
+  }
+  else
+  {
+    imu.angular_velocity.x = 0;
+    imu.angular_velocity.y = 0;
+    imu.angular_velocity.z = 0;
+  }
+
+  imu_calc(input-&gt;header.stamp);
+
+  previous_time = current_time;
+  previous_imu_roll  = imu_roll;
+  previous_imu_pitch = imu_pitch;
+  previous_imu_yaw   = imu_yaw;
+}
+
+
 static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 {
   double r;
@@ -200,7 +387,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   tf::TransformBroadcaster br;
   tf::Transform transform;
 
-  ros::Time scan_time = input-&gt;header.stamp;
+  current_scan_time = input-&gt;header.stamp;
 
   pcl::fromROSMsg(*input, tmp);
 
@@ -235,7 +422,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   voxel_grid_filter.filter(*filtered_scan_ptr);
 
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
-
+  
   ndt.setTransformationEpsilon(trans_eps);
   ndt.setStepSize(step_size);
   ndt.setResolution(ndt_res);
@@ -248,12 +435,12 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     isMapUpdate = false;
   }
 
-  guess_pose.x = previous_pose.x + offset_x;
-  guess_pose.y = previous_pose.y + offset_y;
-  guess_pose.z = previous_pose.z + offset_z;
+  guess_pose.x = previous_pose.x + diff_x;
+  guess_pose.y = previous_pose.y + diff_y;
+  guess_pose.z = previous_pose.z + diff_z;
   guess_pose.roll = previous_pose.roll;
   guess_pose.pitch = previous_pose.pitch;
-  guess_pose.yaw = previous_pose.yaw + offset_yaw;
+  guess_pose.yaw = previous_pose.yaw + diff_yaw;
 
   Eigen::AngleAxisf init_rotation_x(guess_pose.roll, Eigen::Vector3f::UnitX());
   Eigen::AngleAxisf init_rotation_y(guess_pose.pitch, Eigen::Vector3f::UnitY());
@@ -264,6 +451,28 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   Eigen::Matrix4f init_guess =
       (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).matrix() * tf_btol;
 
+/*
+  //imu_calc(current_scan_time);
+  Eigen::AngleAxisf init_rotation_x(guess_pose_imu.roll, Eigen::Vector3f::UnitX());
+  Eigen::AngleAxisf init_rotation_y(guess_pose_imu.pitch, Eigen::Vector3f::UnitY());
+  Eigen::AngleAxisf init_rotation_z(guess_pose_imu.yaw, Eigen::Vector3f::UnitZ());
+
+  Eigen::Translation3f init_translation(guess_pose_imu.x, guess_pose_imu.y, guess_pose_imu.z);
+
+  Eigen::Matrix4f init_guess =
+      (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).matrix() * tf_btol;
+*/
+/*
+  //odom_calc(current_scan_time);
+  Eigen::AngleAxisf init_rotation_x(guess_pose_odom.roll, Eigen::Vector3f::UnitX());
+  Eigen::AngleAxisf init_rotation_y(guess_pose_odom.pitch, Eigen::Vector3f::UnitY());
+  Eigen::AngleAxisf init_rotation_z(guess_pose_odom.yaw, Eigen::Vector3f::UnitZ());
+
+  Eigen::Translation3f init_translation(guess_pose_odom.x, guess_pose_odom.y, guess_pose_odom.z);
+
+  Eigen::Matrix4f init_guess =
+      (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).matrix() * tf_btol;
+*/
   t3_end = ros::Time::now();
   d3 = t3_end - t3_start;
 
@@ -327,13 +536,32 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
   transform.setRotation(q);
 
-  br.sendTransform(tf::StampedTransform(transform, scan_time, "map", "base_link"));
+  br.sendTransform(tf::StampedTransform(transform, current_scan_time, "map", "base_link"));
+
+  scan_duration = current_scan_time - previous_scan_time;
+  double secs = scan_duration.toSec();
 
   // Calculate the offset (curren_pos - previous_pos)
-  offset_x = current_pose.x - previous_pose.x;
-  offset_y = current_pose.y - previous_pose.y;
-  offset_z = current_pose.z - previous_pose.z;
-  offset_yaw = current_pose.yaw - previous_pose.yaw;
+  diff_x = current_pose.x - previous_pose.x;
+  diff_y = current_pose.y - previous_pose.y;
+  diff_z = current_pose.z - previous_pose.z;
+  diff_yaw = current_pose.yaw - previous_pose.yaw;
+  diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);
+
+  current_velocity_x = diff_x / secs;
+  current_velocity_y = diff_y / secs;
+  current_velocity_z = diff_z / secs;
+
+  current_pose_imu.x = current_pose.x;
+  current_pose_imu.y = current_pose.y;
+  current_pose_imu.z = current_pose.z;
+  current_pose_imu.roll = current_pose.roll;
+  current_pose_imu.pitch = current_pose.pitch;
+  current_pose_imu.yaw = current_pose.yaw;
+
+  current_velocity_imu_x = current_velocity_x;
+  current_velocity_imu_y = current_velocity_y;
+  current_velocity_imu_z = current_velocity_z;
 
   // Update position and posture. current_pos -&gt; previous_pos
   previous_pose.x = current_pose.x;
@@ -343,6 +571,31 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   previous_pose.pitch = current_pose.pitch;
   previous_pose.yaw = current_pose.yaw;
 
+  previous_scan_time.sec = current_scan_time.sec;
+  previous_scan_time.nsec = current_scan_time.nsec;
+  
+  offset_x = 0.0;
+  offset_y = 0.0;
+  offset_z = 0.0;
+  offset_roll = 0.0;
+  offset_pitch = 0.0;
+  offset_yaw = 0.0;
+
+  offset_imu_x = 0.0;
+  offset_imu_y = 0.0;
+  offset_imu_z = 0.0;
+  offset_imu_roll = 0.0;
+  offset_imu_pitch = 0.0;
+  offset_imu_yaw = 0.0;
+
+  offset_odom_x = 0.0;
+  offset_odom_y = 0.0;
+  offset_odom_z = 0.0;
+  offset_odom_roll = 0.0;
+  offset_odom_pitch = 0.0;
+  offset_odom_yaw = 0.0;
+
+  
   // Calculate the shift between added_pos and current_pos
   double shift = sqrt(pow(current_pose.x - added_pose.x, 2.0) + pow(current_pose.y - added_pose.y, 2.0));
   if (shift &gt;= min_add_scan_shift)
@@ -363,7 +616,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
   current_pose_msg.header.frame_id = "map";
-  current_pose_msg.header.stamp = scan_time;
+  current_pose_msg.header.stamp = current_scan_time;
   current_pose_msg.pose.position.x = current_pose.x;
   current_pose_msg.pose.position.y = current_pose.y;
   current_pose_msg.pose.position.z = current_pose.z;
@@ -374,6 +627,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   current_pose_pub.publish(current_pose_msg);
 
+
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
   std::cout &lt;&lt; "Sequence number: " &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
   std::cout &lt;&lt; "Number of scan points: " &lt;&lt; scan_ptr-&gt;size() &lt;&lt; " points." &lt;&lt; std::endl;
@@ -415,6 +669,13 @@ int main(int argc, char** argv)
   current_pose.pitch = 0.0;
   current_pose.yaw = 0.0;
 
+  current_pose_imu.x = 0.0;
+  current_pose_imu.y = 0.0;
+  current_pose_imu.z = 0.0;
+  current_pose_imu.roll = 0.0;
+  current_pose_imu.pitch = 0.0;
+  current_pose_imu.yaw = 0.0;
+
   guess_pose.x = 0.0;
   guess_pose.y = 0.0;
   guess_pose.z = 0.0;
@@ -422,6 +683,13 @@ int main(int argc, char** argv)
   guess_pose.pitch = 0.0;
   guess_pose.yaw = 0.0;
 
+  guess_pose_imu.x = 0.0;
+  guess_pose_imu.y = 0.0;
+  guess_pose_imu.z = 0.0;
+  guess_pose_imu.roll = 0.0;
+  guess_pose_imu.pitch = 0.0;
+  guess_pose_imu.yaw = 0.0;
+
   added_pose.x = 0.0;
   added_pose.y = 0.0;
   added_pose.z = 0.0;
@@ -432,6 +700,8 @@ int main(int argc, char** argv)
   offset_x = 0.0;
   offset_y = 0.0;
   offset_z = 0.0;
+  offset_roll = 0.0;
+  offset_pitch = 0.0;
   offset_yaw = 0.0;
 
   ros::init(argc, argv, "ndt_mapping");
@@ -497,6 +767,8 @@ int main(int argc, char** argv)
   ros::Subscriber param_sub = nh.subscribe("config/ndt_mapping", 10, param_callback);
   ros::Subscriber output_sub = nh.subscribe("config/ndt_mapping_output", 10, output_callback);
   ros::Subscriber points_sub = nh.subscribe("points_raw", 100000, points_callback);
+  ros::Subscriber odom_sub = nh.subscribe("odom_pose", 100000, odom_callback);
+  ros::Subscriber imu_sub = nh.subscribe("mti/sensor/imu", 100000, imu_callback);
 
   ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="322" deleted_lines="5">
				<diff>@@ -44,6 +44,8 @@
 #include &lt;std_msgs/Float32.h&gt;
 #include &lt;std_msgs/String.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
+#include &lt;nav_msgs/Odometry.h&gt;
+#include &lt;sensor_msgs/Imu.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;velodyne_pointcloud/point_types.h&gt;
 #include &lt;velodyne_pointcloud/rawdata.h&gt;
@@ -89,10 +91,12 @@ struct pose
   double yaw;
 };
 
-static pose initial_pose, predict_pose, previous_pose, ndt_pose, current_pose, localizer_pose, previous_gnss_pose,
+static pose initial_pose, predict_pose, predict_pose_imu, predict_pose_odom, previous_pose, ndt_pose, current_pose, current_pose_imu, current_pose_odom, localizer_pose, previous_gnss_pose,
     current_gnss_pose;
 
 static double offset_x, offset_y, offset_z, offset_yaw;  // current_pos - previous_pose
+static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;  // current_pos - previous_pose
+static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;  // current_pos - previous_pose
 
 // Can't load if typed "pcl::PointCloud&lt;pcl::PointXYZRGB&gt; map, add;"
 static pcl::PointCloud&lt;pcl::PointXYZ&gt; map, add;
@@ -112,6 +116,12 @@ static double trans_eps = 0.01;  // Transformation epsilon
 static ros::Publisher predict_pose_pub;
 static geometry_msgs::PoseStamped predict_pose_msg;
 
+static ros::Publisher predict_pose_imu_pub;
+static geometry_msgs::PoseStamped predict_pose_imu_msg;
+
+static ros::Publisher predict_pose_odom_pub;
+static geometry_msgs::PoseStamped predict_pose_odom_msg;
+
 static ros::Publisher ndt_pose_pub;
 static geometry_msgs::PoseStamped ndt_pose_msg;
 
@@ -146,6 +156,10 @@ static double current_velocity_z = 0.0, previous_velocity_z = 0.0;
 // static double current_velocity_yaw = 0.0, previous_velocity_yaw = 0.0;
 static double current_velocity_smooth = 0.0;
 
+static double current_velocity_imu_x = 0.0;
+static double current_velocity_imu_y = 0.0;
+static double current_velocity_imu_z = 0.0;
+
 static double current_accel = 0.0, previous_accel = 0.0;  // [m/s^2]
 static double current_accel_x = 0.0;
 static double current_accel_y = 0.0;
@@ -187,6 +201,10 @@ static bool _use_local_transform = false;
 static std::ofstream ofs;
 static std::string filename;
 
+static sensor_msgs::Imu imu;
+static double odom_distance_velocity = 0;
+
+
 // static tf::TransformListener local_transform_listener;
 static tf::StampedTransform local_transform;
 
@@ -425,6 +443,170 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
   offset_yaw = 0.0;
 }
 
+static void odom_calc(ros::Time current_time)
+{
+  static ros::Time previous_time = current_time;
+  double diff_time = (current_time - previous_time).toSec();
+
+  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
+  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
+  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;
+
+  current_pose_odom.roll  += diff_imu_roll;
+  current_pose_odom.pitch += diff_imu_pitch;
+  current_pose_odom.yaw   += diff_imu_yaw;
+
+  double diff_distance = odom_distance_velocity * diff_time;
+  offset_odom_x += diff_distance*cos(-current_pose_odom.pitch)*cos(current_pose_odom.yaw);
+  offset_odom_y += diff_distance*cos(-current_pose_odom.pitch)*sin(current_pose_odom.yaw);
+  offset_odom_z += diff_distance*sin(-current_pose_odom.pitch);
+
+  offset_odom_roll  += diff_imu_roll;
+  offset_odom_pitch += diff_imu_pitch;
+  offset_odom_yaw   += diff_imu_yaw;
+
+  predict_pose_odom.x     = previous_pose.x     + offset_odom_x;
+  predict_pose_odom.y     = previous_pose.y     + offset_odom_y;
+  predict_pose_odom.z     = previous_pose.z     + offset_odom_z;
+  predict_pose_odom.roll  = previous_pose.roll  + offset_odom_roll;
+  predict_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
+  predict_pose_odom.yaw   = previous_pose.yaw   + offset_odom_yaw;
+ 
+  previous_time = current_time;
+}
+
+
+static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
+{
+  
+  odom_distance_velocity = input-&gt;twist.twist.linear.x;
+  odom_calc(input-&gt;header.stamp);
+}
+
+
+static void imu_calc(ros::Time current_time)
+{
+
+  static ros::Time previous_time = current_time;
+  double diff_time = (current_time - previous_time).toSec();
+
+  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
+  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
+  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;
+
+  current_pose_imu.roll += diff_imu_roll;
+  current_pose_imu.pitch += diff_imu_pitch;
+  current_pose_imu.yaw += diff_imu_yaw;
+
+  double accX1 = imu.linear_acceleration.x;
+  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y
+                -std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
+  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y
+                +std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;
+
+  double accX2 = std::sin(current_pose_imu.pitch) * accZ1 + std::cos(current_pose_imu.pitch) * accX1;
+  double accY2 = accY1;
+  double accZ2 = std::cos(current_pose_imu.pitch) * accZ1 - std::sin(current_pose_imu.pitch) * accX1;
+
+  double accX = std::cos(current_pose_imu.yaw) * accX2 - std::sin(current_pose_imu.yaw) * accY2;
+  double accY = std::sin(current_pose_imu.yaw) * accX2 + std::cos(current_pose_imu.yaw) * accY2;
+  double accZ = accZ2;
+
+  offset_imu_x += current_velocity_imu_x * diff_time + accX * diff_time * diff_time / 2.0;
+  offset_imu_y += current_velocity_imu_y * diff_time + accY * diff_time * diff_time / 2.0;
+  offset_imu_z += current_velocity_imu_z * diff_time + accZ * diff_time * diff_time / 2.0;
+
+  current_velocity_imu_x += accX * diff_time;
+  current_velocity_imu_y += accY * diff_time;
+  current_velocity_imu_z += accZ * diff_time;
+
+  offset_imu_roll  += diff_imu_roll;
+  offset_imu_pitch += diff_imu_pitch;
+  offset_imu_yaw   += diff_imu_yaw;
+
+  predict_pose_imu.x     = previous_pose.x     + offset_imu_x;
+  predict_pose_imu.y     = previous_pose.y     + offset_imu_y;
+  predict_pose_imu.z     = previous_pose.z     + offset_imu_z;
+  predict_pose_imu.roll  = previous_pose.roll  + offset_imu_roll;
+  predict_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
+  predict_pose_imu.yaw   = previous_pose.yaw   + offset_imu_yaw;  
+
+  previous_time = current_time;
+}
+
+
+static const double wrapToPm(double a_num, const double a_max)
+{
+    if (a_num &gt;= a_max)
+    {
+        a_num -= 2.0 * a_max;
+    }
+    return a_num;
+}
+
+static const double wrapToPmPi(double a_angle_rad)
+{
+    return wrapToPm(a_angle_rad, M_PI);
+}
+
+
+static void imu_callback(const sensor_msgs::Imu::ConstPtr&amp; input)
+{
+  const ros::Time current_time = input-&gt;header.stamp;
+  static ros::Time previous_time = current_time;
+  const double diff_time =  (current_time - previous_time).toSec();
+
+  double imu_roll, imu_pitch, imu_yaw;
+  tf::Quaternion imu_orientation;
+  tf::quaternionMsgToTF(input-&gt;orientation, imu_orientation);
+  tf::Matrix3x3(imu_orientation).getRPY(imu_roll, imu_pitch, imu_yaw);
+
+  imu_roll = wrapToPmPi(imu_roll);
+  imu_pitch = wrapToPmPi(imu_pitch);
+  imu_yaw = wrapToPmPi(imu_yaw);
+
+  static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
+  const double diff_imu_roll  = imu_roll  - previous_imu_roll;
+
+  const double diff_imu_pitch = imu_pitch - previous_imu_pitch;
+
+  double diff_imu_yaw;
+  if(fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
+  {
+    if(imu_yaw &gt; 0)
+      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI*2;
+    else
+      diff_imu_yaw = -M_PI*2 - (imu_yaw - previous_imu_yaw);
+  }
+  else
+  diff_imu_yaw = imu_yaw - previous_imu_yaw;
+
+  imu.header = input-&gt;header;
+  imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
+  imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
+  imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
+
+  if(diff_time != 0)
+  {
+    imu.angular_velocity.x = diff_imu_roll  / diff_time;
+    imu.angular_velocity.y = diff_imu_pitch / diff_time;
+    imu.angular_velocity.z = diff_imu_yaw   / diff_time;
+  }
+  else
+  {
+    imu.angular_velocity.x = 0;
+    imu.angular_velocity.y = 0;
+    imu.angular_velocity.z = 0;
+  }
+
+  imu_calc(input-&gt;header.stamp);
+
+  previous_time = current_time;
+  previous_imu_roll  = imu_roll;
+  previous_imu_pitch = imu_pitch;
+  previous_imu_yaw   = imu_yaw;
+}
+
 static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 {
   if (map_loaded == 1 &amp;&amp; init_pos_set == 1)
@@ -467,6 +649,24 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     Eigen::AngleAxisf init_rotation_y(predict_pose.pitch, Eigen::Vector3f::UnitY());
     Eigen::AngleAxisf init_rotation_z(predict_pose.yaw, Eigen::Vector3f::UnitZ());
     Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;
+/*
+    imu_calc(current_scan_time);
+
+    Eigen::Translation3f init_translation(predict_pose_imu.x, predict_pose_imu.y, predict_pose_imu.z);
+    Eigen::AngleAxisf init_rotation_x(predict_pose_imu.roll, Eigen::Vector3f::UnitX());
+    Eigen::AngleAxisf init_rotation_y(predict_pose_imu.pitch, Eigen::Vector3f::UnitY());
+    Eigen::AngleAxisf init_rotation_z(predict_pose_imu.yaw, Eigen::Vector3f::UnitZ());
+    Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;
+*/
+/*
+    odom_calc(current_scan_time);
+
+    Eigen::Translation3f init_translation(predict_pose_odom.x, predict_pose_odom.y, predict_pose_odom.z);
+    Eigen::AngleAxisf init_rotation_x(predict_pose_odom.roll, Eigen::Vector3f::UnitX());
+    Eigen::AngleAxisf init_rotation_y(predict_pose_odom.pitch, Eigen::Vector3f::UnitY());
+    Eigen::AngleAxisf init_rotation_z(predict_pose_odom.yaw, Eigen::Vector3f::UnitZ());
+    Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;
+*/
 
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
 #ifdef USE_FAST_PCL
@@ -485,8 +685,10 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 #ifdef USE_FAST_PCL
     }
 #endif
+
     align_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(align_end - align_start).count() / 1000.0;
 
+
     t = ndt.getFinalTransformation();  // localizer
     t2 = t * tf_ltob;                  // base_link
 
@@ -511,6 +713,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
         std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(getFitnessScore_end - getFitnessScore_start).count() /
         1000.0;
 
+
     trans_probability = ndt.getTransformationProbability();
 
     tf::Matrix3x3 mat_l;  // localizer
@@ -569,6 +772,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       current_pose.yaw = predict_pose.yaw;
     }
 
+
     // Compute the velocity and acceleration
     scan_duration = current_scan_time - previous_scan_time;
     double secs = scan_duration.toSec();
@@ -584,6 +788,26 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     current_velocity_z = diff_z / secs;
     angular_velocity = diff_yaw / secs;
 
+    current_pose_imu.x = current_pose.x;
+    current_pose_imu.y = current_pose.y;
+    current_pose_imu.z = current_pose.z;
+    current_pose_imu.roll = current_pose.roll;
+    current_pose_imu.pitch = current_pose.pitch;
+    current_pose_imu.yaw = current_pose.yaw;
+
+    current_velocity_imu_x = current_velocity_x;
+    current_velocity_imu_y = current_velocity_y;
+    current_velocity_imu_z = current_velocity_z;
+
+
+    current_pose_odom.x = current_pose.x;
+    current_pose_odom.y = current_pose.y;
+    current_pose_odom.z = current_pose.z;
+    current_pose_odom.roll = current_pose.roll;
+    current_pose_odom.pitch = current_pose.pitch;
+    current_pose_odom.yaw = current_pose.yaw;
+
+
     current_velocity_smooth = (current_velocity + previous_velocity + previous_previous_velocity) / 3.0;
     if (current_velocity_smooth &lt; 0.2)
     {
@@ -630,8 +854,35 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       predict_pose_msg.pose.orientation.w = predict_q.w();
     }
 
+    tf::Quaternion predict_q_imu;
+    predict_q_imu.setRPY(predict_pose_imu.roll, predict_pose_imu.pitch, predict_pose_imu.yaw);
+    predict_pose_imu_msg.header.frame_id = "map";
+    predict_pose_imu_msg.header.stamp = input-&gt;header.stamp;
+    predict_pose_imu_msg.pose.position.x = predict_pose_imu.x;
+    predict_pose_imu_msg.pose.position.y = predict_pose_imu.y;
+    predict_pose_imu_msg.pose.position.z = predict_pose_imu.z;
+    predict_pose_imu_msg.pose.orientation.x = predict_q_imu.x();
+    predict_pose_imu_msg.pose.orientation.y = predict_q_imu.y();
+    predict_pose_imu_msg.pose.orientation.z = predict_q_imu.z();
+    predict_pose_imu_msg.pose.orientation.w = predict_q_imu.w();
+    predict_pose_imu_pub.publish(predict_pose_imu_msg);
+
+    tf::Quaternion predict_q_odom;
+    predict_q_odom.setRPY(predict_pose_odom.roll, predict_pose_odom.pitch, predict_pose_odom.yaw);
+    predict_pose_odom_msg.header.frame_id = "map";
+    predict_pose_odom_msg.header.stamp = input-&gt;header.stamp;
+    predict_pose_odom_msg.pose.position.x = predict_pose_odom.x;
+    predict_pose_odom_msg.pose.position.y = predict_pose_odom.y;
+    predict_pose_odom_msg.pose.position.z = predict_pose_odom.z;
+    predict_pose_odom_msg.pose.orientation.x = predict_q_odom.x();
+    predict_pose_odom_msg.pose.orientation.y = predict_q_odom.y();
+    predict_pose_odom_msg.pose.orientation.z = predict_q_odom.z();
+    predict_pose_odom_msg.pose.orientation.w = predict_q_odom.w();
+    predict_pose_odom_pub.publish(predict_pose_odom_msg);
+
+
     ndt_q.setRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw);
-    if (_use_local_transform == true)
+	    if (_use_local_transform == true)
     {
       tf::Vector3 v(ndt_pose.x, ndt_pose.y, ndt_pose.z);
       tf::Transform transform(ndt_q, v);
@@ -757,13 +1008,15 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
                            Wc * ((2.0 - trans_probability) / 2.0) * 100.0;
     ndt_reliability_pub.publish(ndt_reliability);
 
+
     // Write log
     if (!ofs)
     {
       std::cerr &lt;&lt; "Could not open " &lt;&lt; filename &lt;&lt; "." &lt;&lt; std::endl;
       exit(1);
     }
-    ofs &lt;&lt; input-&gt;header.seq &lt;&lt; "," &lt;&lt; scan_points_num &lt;&lt; "," &lt;&lt; step_size &lt;&lt; "," &lt;&lt; trans_eps &lt;&lt; "," &lt;&lt; std::fixed
+    static ros::Time start_time = input-&gt;header.stamp;
+    ofs &lt;&lt; input-&gt;header.seq &lt;&lt; "," &lt;&lt; input-&gt;header.stamp &lt;&lt; "," &lt;&lt; input-&gt;header.stamp - start_time &lt;&lt; scan_points_num &lt;&lt; "," &lt;&lt; step_size &lt;&lt; "," &lt;&lt; trans_eps &lt;&lt; "," &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; "," &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; ","
         &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; "," &lt;&lt; current_pose.roll &lt;&lt; "," &lt;&lt; current_pose.pitch
         &lt;&lt; "," &lt;&lt; current_pose.yaw &lt;&lt; "," &lt;&lt; predict_pose.x &lt;&lt; "," &lt;&lt; predict_pose.y &lt;&lt; "," &lt;&lt; predict_pose.z &lt;&lt; ","
@@ -773,9 +1026,21 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
         &lt;&lt; current_pose.pitch - predict_pose.pitch &lt;&lt; "," &lt;&lt; current_pose.yaw - predict_pose.yaw &lt;&lt; ","
         &lt;&lt; predict_pose_error &lt;&lt; "," &lt;&lt; iteration &lt;&lt; "," &lt;&lt; fitness_score &lt;&lt; "," &lt;&lt; trans_probability &lt;&lt; ","
         &lt;&lt; ndt_reliability.data &lt;&lt; "," &lt;&lt; current_velocity &lt;&lt; "," &lt;&lt; current_velocity_smooth &lt;&lt; "," &lt;&lt; current_accel
-        &lt;&lt; "," &lt;&lt; angular_velocity &lt;&lt; "," &lt;&lt; time_ndt_matching.data &lt;&lt; "," &lt;&lt; align_time &lt;&lt; "," &lt;&lt; getFitnessScore_time
+        &lt;&lt; "," &lt;&lt; angular_velocity &lt;&lt; "," &lt;&lt; time_ndt_matching.data &lt;&lt; "," &lt;&lt; align_time &lt;&lt; "," &lt;&lt; getFitnessScore_time 
+        &lt;&lt;"," &lt;&lt; predict_pose_imu.x &lt;&lt; "," &lt;&lt; predict_pose_imu.y &lt;&lt; "," &lt;&lt; predict_pose_imu.z &lt;&lt; ","
+        &lt;&lt; predict_pose_imu.roll &lt;&lt; "," &lt;&lt; predict_pose_imu.pitch &lt;&lt; ","  &lt;&lt; predict_pose_imu.yaw &lt;&lt; ","
+        &lt;&lt; current_pose.x - predict_pose_imu.x &lt;&lt; "," &lt;&lt; current_pose.y - predict_pose_imu.y &lt;&lt; ","
+        &lt;&lt; current_pose.z - predict_pose_imu.z &lt;&lt; "," &lt;&lt; current_pose.roll - predict_pose_imu.roll &lt;&lt; ","
+        &lt;&lt; current_pose.pitch - predict_pose_imu.pitch &lt;&lt; "," &lt;&lt; current_pose.yaw - predict_pose_imu.yaw &lt;&lt; ","
+
+        &lt;&lt;"," &lt;&lt; predict_pose_odom.x &lt;&lt; "," &lt;&lt; predict_pose_odom.y &lt;&lt; "," &lt;&lt; predict_pose_odom.z &lt;&lt; ","
+        &lt;&lt; predict_pose_odom.roll &lt;&lt; "," &lt;&lt; predict_pose_odom.pitch &lt;&lt; ","  &lt;&lt; predict_pose_odom.yaw &lt;&lt; ","
+        &lt;&lt; current_pose.x - predict_pose_odom.x &lt;&lt; "," &lt;&lt; current_pose.y - predict_pose_odom.y &lt;&lt; ","
+        &lt;&lt; current_pose.z - predict_pose_odom.z &lt;&lt; "," &lt;&lt; current_pose.roll - predict_pose_odom.roll &lt;&lt; ","
+        &lt;&lt; current_pose.pitch - predict_pose_odom.pitch &lt;&lt; "," &lt;&lt; current_pose.yaw - predict_pose_odom.yaw &lt;&lt; ","
         &lt;&lt; std::endl;
 
+
     std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
     std::cout &lt;&lt; "Sequence: " &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
     std::cout &lt;&lt; "Timestamp: " &lt;&lt; input-&gt;header.stamp &lt;&lt; std::endl;
@@ -817,6 +1082,20 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       offset_z = 0.0;
       offset_yaw = 0.0;
     }
+   
+    offset_imu_x = 0.0;
+    offset_imu_y = 0.0;
+    offset_imu_z = 0.0;
+    offset_imu_roll = 0.0;
+    offset_imu_pitch = 0.0;
+    offset_imu_yaw = 0.0;
+
+    offset_odom_x = 0.0;
+    offset_odom_y = 0.0;
+    offset_odom_z = 0.0;
+    offset_odom_roll = 0.0;
+    offset_odom_pitch = 0.0;
+    offset_odom_yaw = 0.0;
 
     // Update previous_***
     previous_pose.x = current_pose.x;
@@ -863,12 +1142,46 @@ int main(int argc, char** argv)
   private_nh.getParam("get_height", _get_height);
   private_nh.getParam("use_local_transform", _use_local_transform);
 
+  _tf_x = _tf_y = _tf_z = _tf_roll = _tf_pitch = _tf_yaw = 0;
+  _tf_z = 0.0;
+
+  offset_imu_x = 0.0;
+  offset_imu_y = 0.0;
+  offset_imu_z = 0.0;
+  offset_imu_roll = 0.0;
+  offset_imu_pitch = 0.0;
+  offset_imu_yaw = 0.0;
+
+  offset_odom_x = 0.0;
+  offset_odom_y = 0.0;
+  offset_odom_z = 0.0;
+  offset_odom_roll = 0.0;
+  offset_odom_pitch = 0.0;
+  offset_odom_yaw = 0.0;
+
+  current_pose_odom.x = 0.0;
+  current_pose_odom.y = 0.0;
+  current_pose_odom.z = 0.0;
+  current_pose_odom.roll = 0.0;
+  current_pose_odom.pitch = 0.0;
+  current_pose_odom.yaw = 0.0;
+
+  predict_pose_odom.x = 0.0;
+  predict_pose_odom.y = 0.0;
+  predict_pose_odom.z = 0.0;
+  predict_pose_odom.roll = 0.0;
+  predict_pose_odom.pitch = 0.0;
+  predict_pose_odom.yaw = 0.0;
+
+  imu.angular_velocity.x = 0;
+  imu.angular_velocity.y = 0;
+  imu.angular_velocity.z = 0;
+
   if (nh.getParam("localizer", _localizer) == false)
   {
     std::cout &lt;&lt; "localizer is not set." &lt;&lt; std::endl;
     return 1;
   }
-
   if (nh.getParam("tf_x", _tf_x) == false)
   {
     std::cout &lt;&lt; "tf_x is not set." &lt;&lt; std::endl;
@@ -935,6 +1248,8 @@ int main(int argc, char** argv)
 
   // Publishers
   predict_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose", 1000);
+  predict_pose_imu_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose_imu", 1000);
+  predict_pose_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose_odom", 1000);
   ndt_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/ndt_pose", 1000);
   // current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/current_pose", 1000);
   localizer_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/localizer_pose", 1000);
@@ -952,6 +1267,8 @@ int main(int argc, char** argv)
   ros::Subscriber map_sub = nh.subscribe("points_map", 10, map_callback);
   ros::Subscriber initialpose_sub = nh.subscribe("initialpose", 1000, initialpose_callback);
   ros::Subscriber points_sub = nh.subscribe("filtered_points", _queue_size, points_callback);
+  ros::Subscriber odom_sub = nh.subscribe("odom_pose", _queue_size*10, odom_callback);
+  ros::Subscriber imu_sub = nh.subscribe("mti/sensor/imu", _queue_size*10, imu_callback);
 
   ros::spin();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="35c05d52525612f62c10c3e363d08e5824bb345b" author="Yusuke FUJII">
		<msg>fixed compile issue for ssd node</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\ssd_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\ssd\ssd_node.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -33,7 +33,7 @@
 #include &lt;runtime_manager/ConfigSsd.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;cv_tracker/image_obj.h&gt;
+#include &lt;cv_tracker_msgs/image_obj.h&gt;
 
 #include &lt;rect_class_score.h&gt;
 
@@ -67,7 +67,7 @@ class RosSsdApp
 	//vector of indices of the classes to search for
 	std::vector&lt;unsigned int&gt; detect_classes_;
 
-	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, cv_tracker::image_obj&amp; out_message, cv::Mat&amp; in_image, std::string in_class)
+	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, cv_tracker_msgs::image_obj&amp; out_message, cv::Mat&amp; in_image, std::string in_class)
 	{
 		for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
 		{
@@ -79,7 +79,7 @@ class RosSsdApp
 				)//check if the score is larger than minimum required
 			{
 				//std::cout &lt;&lt; in_objects[i].toString() &lt;&lt; std::endl;
-				cv_tracker::image_rect rect;
+				cv_tracker_msgs::image_rect rect;
 
 				rect.x = in_objects[i].x;
 				rect.y = in_objects[i].y;
@@ -118,8 +118,8 @@ class RosSsdApp
 		//std::cout &lt;&lt; "Detection took: " &lt;&lt; timer.getTimeMilli() &lt;&lt; std::endl;
 
 		//Prepare Output message
-		cv_tracker::image_obj output_car_message;
-		cv_tracker::image_obj output_person_message;
+		cv_tracker_msgs::image_obj output_car_message;
+		cv_tracker_msgs::image_obj output_person_message;
 		output_car_message.header = image_source.header;
 		output_car_message.type = "car";
 
@@ -207,8 +207,8 @@ public:
 		}
 		ROS_INFO("SSD Detector initialized.");
 
-		publisher_car_objects_ = node_handle_.advertise&lt;cv_tracker::image_obj&gt;("/obj_car/image_obj", 1);
-		publisher_person_objects_ = node_handle_.advertise&lt;cv_tracker::image_obj&gt;("/obj_person/image_obj", 1);
+		publisher_car_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj&gt;("/obj_car/image_obj", 1);
+		publisher_person_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj&gt;("/obj_person/image_obj", 1);
 
 		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
 		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;RosSsdApp::image_callback, this);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6db940b6c4c9a2ff4ca060ca2e98bf4e7677e5c6" author="Adi Sujiwo">
		<msg>Reorganization and fix for Ubuntu 16.04</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\config.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\Pangolin\include\pangolin\config.h" added_lines="1" deleted_lines="1">
				<diff>@@ -39,7 +39,7 @@
 #define HAVE_GLEW
 /* #undef GLEW_STATIC */
 
-#define HAVE_GLUT
+/* #undef HAVE_GLUT */
 /* #undef HAVE_FREEGLUT */
 /* #undef HAVE_APPLE_OPENGL_FRAMEWORK */
 /* #undef HAVE_MODIFIED_OSXGLUT */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\solvers\.linear_solver_eigen.h.swp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\solvers\.linear_solver_eigen.h.swp" added_lines="0" deleted_lines="0">
				<diff>Binary files /dev/null and b/ros/src/computing/perception/localization/packages/orb_localizer/Thirdparty/g2o/g2o/solvers/.linear_solver_eigen.h.swp differ
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\solvers\linear_solver_eigen.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\Thirdparty\g2o\g2o\solvers\linear_solver_eigen.h" added_lines="6" deleted_lines="1">
				<diff>@@ -51,7 +51,12 @@ class LinearSolverEigen: public LinearSolver&lt;MatrixType&gt;
   public:
     typedef Eigen::SparseMatrix&lt;double, Eigen::ColMajor&gt; SparseMatrix;
     typedef Eigen::Triplet&lt;double&gt; Triplet;
-    typedef Eigen::PermutationMatrix&lt;Eigen::Dynamic, Eigen::Dynamic, SparseMatrix::Index&gt; PermutationMatrix;
+
+#if EIGEN_VERSION_AT_LEAST(3,2,90)
+    typedef Eigen::PermutationMatrix&lt;Eigen::Dynamic, Eigen::Dynamic, SparseMatrix::StorageIndex&gt; PermutationMatrix;
+#else
+    typedef Eigen::PermutationMatrix&lt;Eigen::Dynamic, Eigen::Dynamic, SparseMatrix::Index&gt; PermutationMatrix;	
+#endif
     /**
      * \brief Sub-classing Eigen's SimplicialLDLT to perform ordering with a given ordering
      */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\cmake_modules\FindBLAS.cmake" new_path="" added_lines="0" deleted_lines="419">
				<diff>@@ -1,419 +0,0 @@
-# Find BLAS library
-#
-# This module finds an installed library that implements the BLAS
-# linear-algebra interface (see http://www.netlib.org/blas/).
-# The list of libraries searched for is mainly taken
-# from the autoconf macro file, acx_blas.m4 (distributed at
-# http://ac-archive.sourceforge.net/ac-archive/acx_blas.html).
-#
-# This module sets the following variables:
-#  BLAS_FOUND - set to true if a library implementing the BLAS interface
-#    is found
-#  BLAS_INCLUDE_DIR - Directories containing the BLAS header files
-#  BLAS_DEFINITIONS - Compilation options to use BLAS
-#  BLAS_LINKER_FLAGS - Linker flags to use BLAS (excluding -l
-#    and -L).
-#  BLAS_LIBRARIES_DIR - Directories containing the BLAS libraries.
-#     May be null if BLAS_LIBRARIES contains libraries name using full path.
-#  BLAS_LIBRARIES - List of libraries to link against BLAS interface.
-#     May be null if the compiler supports auto-link (e.g. VC++).
-#  BLAS_USE_FILE - The name of the cmake module to include to compile
-#     applications or libraries using BLAS.
-#
-# This module was modified by CGAL team:
-# - find libraries for a C++ compiler, instead of Fortran
-# - added BLAS_INCLUDE_DIR, BLAS_DEFINITIONS and BLAS_LIBRARIES_DIR
-# - removed BLAS95_LIBRARIES
-
-include(CheckFunctionExists)
-
-
-# This macro checks for the existence of the combination of fortran libraries
-# given by _list.  If the combination is found, this macro checks (using the
-# check_function_exists macro) whether can link against that library
-# combination using the name of a routine given by _name using the linker
-# flags given by _flags.  If the combination of libraries is found and passes
-# the link test, LIBRARIES is set to the list of complete library paths that
-# have been found and DEFINITIONS to the required definitions.
-# Otherwise, LIBRARIES is set to FALSE.
-# N.B. _prefix is the prefix applied to the names of all cached variables that
-# are generated internally and marked advanced by this macro.
-macro(check_fortran_libraries DEFINITIONS LIBRARIES _prefix _name _flags _list _path)
-  #message("DEBUG: check_fortran_libraries(${_list} in ${_path})")
-
-  # Check for the existence of the libraries given by _list
-  set(_libraries_found TRUE)
-  set(_libraries_work FALSE)
-  set(${DEFINITIONS} "")
-  set(${LIBRARIES} "")
-  set(_combined_name)
-  foreach(_library ${_list})
-    set(_combined_name ${_combined_name}_${_library})
-
-    if(_libraries_found)
-      # search first in ${_path}
-      find_library(${_prefix}_${_library}_LIBRARY
-                  NAMES ${_library}
-                  PATHS ${_path} NO_DEFAULT_PATH
-                  )
-      # if not found, search in environment variables and system
-      if ( WIN32 )
-        find_library(${_prefix}_${_library}_LIBRARY
-                    NAMES ${_library}
-                    PATHS ENV LIB
-                    )
-      elseif ( APPLE )
-        find_library(${_prefix}_${_library}_LIBRARY
-                    NAMES ${_library}
-                    PATHS /usr/local/lib /usr/lib /usr/local/lib64 /usr/lib64 ENV DYLD_LIBRARY_PATH
-                    )
-      else ()
-        find_library(${_prefix}_${_library}_LIBRARY
-                    NAMES ${_library}
-                    PATHS /usr/local/lib /usr/lib /usr/local/lib64 /usr/lib64 ENV LD_LIBRARY_PATH
-                    )
-      endif()
-      mark_as_advanced(${_prefix}_${_library}_LIBRARY)
-      set(${LIBRARIES} ${${LIBRARIES}} ${${_prefix}_${_library}_LIBRARY})
-      set(_libraries_found ${${_prefix}_${_library}_LIBRARY})
-    endif(_libraries_found)
-  endforeach(_library ${_list})
-  if(_libraries_found)
-    set(_libraries_found ${${LIBRARIES}})
-  endif()
-
-  # Test this combination of libraries with the Fortran/f2c interface.
-  # We test the Fortran interface first as it is well standardized.
-  if(_libraries_found AND NOT _libraries_work)
-    set(${DEFINITIONS}  "-D${_prefix}_USE_F2C")
-    set(${LIBRARIES}    ${_libraries_found})
-    # Some C++ linkers require the f2c library to link with Fortran libraries.
-    # I do not know which ones, thus I just add the f2c library if it is available.
-    find_package( F2C QUIET )
-    if ( F2C_FOUND )
-      set(${DEFINITIONS}  ${${DEFINITIONS}} ${F2C_DEFINITIONS})
-      set(${LIBRARIES}    ${${LIBRARIES}} ${F2C_LIBRARIES})
-    endif()
-    set(CMAKE_REQUIRED_DEFINITIONS  ${${DEFINITIONS}})
-    set(CMAKE_REQUIRED_LIBRARIES    ${_flags} ${${LIBRARIES}})
-    #message("DEBUG: CMAKE_REQUIRED_DEFINITIONS = ${CMAKE_REQUIRED_DEFINITIONS}")
-    #message("DEBUG: CMAKE_REQUIRED_LIBRARIES = ${CMAKE_REQUIRED_LIBRARIES}")
-    # Check if function exists with f2c calling convention (ie a trailing underscore)
-    check_function_exists(${_name}_ ${_prefix}_${_name}_${_combined_name}_f2c_WORKS)
-    set(CMAKE_REQUIRED_DEFINITIONS} "")
-    set(CMAKE_REQUIRED_LIBRARIES    "")
-    mark_as_advanced(${_prefix}_${_name}_${_combined_name}_f2c_WORKS)
-    set(_libraries_work ${${_prefix}_${_name}_${_combined_name}_f2c_WORKS})
-  endif(_libraries_found AND NOT _libraries_work)
-
-  # If not found, test this combination of libraries with a C interface.
-  # A few implementations (ie ACML) provide a C interface. Unfortunately, there is no standard.
-  if(_libraries_found AND NOT _libraries_work)
-    set(${DEFINITIONS} "")
-    set(${LIBRARIES}   ${_libraries_found})
-    set(CMAKE_REQUIRED_DEFINITIONS "")
-    set(CMAKE_REQUIRED_LIBRARIES   ${_flags} ${${LIBRARIES}})
-    #message("DEBUG: CMAKE_REQUIRED_LIBRARIES = ${CMAKE_REQUIRED_LIBRARIES}")
-    check_function_exists(${_name} ${_prefix}_${_name}${_combined_name}_WORKS)
-    set(CMAKE_REQUIRED_LIBRARIES "")
-    mark_as_advanced(${_prefix}_${_name}${_combined_name}_WORKS)
-    set(_libraries_work ${${_prefix}_${_name}${_combined_name}_WORKS})
-  endif(_libraries_found AND NOT _libraries_work)
-
-  # on failure
-  if(NOT _libraries_work)
-    set(${DEFINITIONS} "")
-    set(${LIBRARIES}   FALSE)
-  endif()
-  #message("DEBUG: ${DEFINITIONS} = ${${DEFINITIONS}}")
-  #message("DEBUG: ${LIBRARIES} = ${${LIBRARIES}}")
-endmacro(check_fortran_libraries)
-
-
-#
-# main
-#
-
-# Is it already configured?
-if (BLAS_LIBRARIES_DIR OR BLAS_LIBRARIES)
-
-  set(BLAS_FOUND TRUE)
-
-else()
-
-  # reset variables
-  set( BLAS_INCLUDE_DIR "" )
-  set( BLAS_DEFINITIONS "" )
-  set( BLAS_LINKER_FLAGS "" )
-  set( BLAS_LIBRARIES "" )
-  set( BLAS_LIBRARIES_DIR "" )
-
-    #
-    # If Unix, search for BLAS function in possible libraries
-    #
-
-    # BLAS in ATLAS library? (http://math-atlas.sourceforge.net/)
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "cblas;f77blas;atlas"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-    # BLAS in PhiPACK libraries? (requires generic BLAS lib, too)
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "sgemm;dgemm;blas"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-    # BLAS in Alpha CXML library?
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "cxml"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-    # BLAS in Alpha DXML library? (now called CXML, see above)
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "dxml"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-    # BLAS in Sun Performance library?
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      "-xlic_lib=sunperf"
-      "sunperf;sunmath"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-      if(BLAS_LIBRARIES)
-        # Extra linker flag
-        set(BLAS_LINKER_FLAGS "-xlic_lib=sunperf")
-      endif()
-    endif()
-
-    # BLAS in SCSL library?  (SGI/Cray Scientific Library)
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "scsl"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-    # BLAS in SGIMATH library?
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "complib.sgimath"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-    # BLAS in IBM ESSL library? (requires generic BLAS lib, too)
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "essl;blas"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-    #BLAS in intel mkl 10 library? (em64t 64bit)
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "mkl_intel_lp64;mkl_intel_thread;mkl_core;guide;pthread"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-    ### windows version of intel mkl 10?
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      SGEMM
-      ""
-      "mkl_c_dll;mkl_intel_thread_dll;mkl_core_dll;libguide40"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-    #older versions of intel mkl libs
-
-    # BLAS in intel mkl library? (shared)
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "mkl;guide;pthread"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-    #BLAS in intel mkl library? (static, 32bit)
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "mkl_ia32;guide;pthread"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-    #BLAS in intel mkl library? (static, em64t 64bit)
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "mkl_em64t;guide;pthread"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-    #BLAS in acml library?
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "acml"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-    # Apple BLAS library?
-    if(NOT BLAS_LIBRARIES)
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "Accelerate"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-    if ( NOT BLAS_LIBRARIES )
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "vecLib"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif ( NOT BLAS_LIBRARIES )
-
-    # Generic BLAS library?
-    # This configuration *must* be the last try as this library is notably slow.
-    if ( NOT BLAS_LIBRARIES )
-      check_fortran_libraries(
-      BLAS_DEFINITIONS
-      BLAS_LIBRARIES
-      BLAS
-      sgemm
-      ""
-      "blas"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV BLAS_LIB_DIR"
-      )
-    endif()
-
-  if(BLAS_LIBRARIES_DIR OR BLAS_LIBRARIES)
-    set(BLAS_FOUND TRUE)
-  else()
-    set(BLAS_FOUND FALSE)
-  endif()
-
-  if(NOT BLAS_FIND_QUIETLY)
-    if(BLAS_FOUND)
-      message(STATUS "A library with BLAS API found.")
-    else(BLAS_FOUND)
-      if(BLAS_FIND_REQUIRED)
-        message(FATAL_ERROR "A required library with BLAS API not found. Please specify library location.")
-      else()
-        message(STATUS "A library with BLAS API not found. Please specify library location.")
-      endif()
-    endif(BLAS_FOUND)
-  endif(NOT BLAS_FIND_QUIETLY)
-
-  # Add variables to cache
-  set( BLAS_INCLUDE_DIR   "${BLAS_INCLUDE_DIR}"
-                          CACHE PATH "Directories containing the BLAS header files" FORCE )
-  set( BLAS_DEFINITIONS   "${BLAS_DEFINITIONS}"
-                          CACHE STRING "Compilation options to use BLAS" FORCE )
-  set( BLAS_LINKER_FLAGS  "${BLAS_LINKER_FLAGS}"
-                          CACHE STRING "Linker flags to use BLAS" FORCE )
-  set( BLAS_LIBRARIES     "${BLAS_LIBRARIES}"
-                          CACHE FILEPATH "BLAS libraries name" FORCE )
-  set( BLAS_LIBRARIES_DIR "${BLAS_LIBRARIES_DIR}"
-                          CACHE PATH "Directories containing the BLAS libraries" FORCE )
-
-  #message("DEBUG: BLAS_INCLUDE_DIR = ${BLAS_INCLUDE_DIR}")
-  #message("DEBUG: BLAS_DEFINITIONS = ${BLAS_DEFINITIONS}")
-  #message("DEBUG: BLAS_LINKER_FLAGS = ${BLAS_LINKER_FLAGS}")
-  #message("DEBUG: BLAS_LIBRARIES = ${BLAS_LIBRARIES}")
-  #message("DEBUG: BLAS_LIBRARIES_DIR = ${BLAS_LIBRARIES_DIR}")
-  #message("DEBUG: BLAS_FOUND = ${BLAS_FOUND}")
-
-endif(BLAS_LIBRARIES_DIR OR BLAS_LIBRARIES)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\cmake_modules\FindEigen3.cmake" new_path="" added_lines="0" deleted_lines="87">
				<diff>@@ -1,87 +0,0 @@
-# - Try to find Eigen3 lib
-#
-# This module supports requiring a minimum version, e.g. you can do
-#   find_package(Eigen3 3.1.2)
-# to require version 3.1.2 or newer of Eigen3.
-#
-# Once done this will define
-#
-#  EIGEN3_FOUND - system has eigen lib with correct version
-#  EIGEN3_INCLUDE_DIR - the eigen include directory
-#  EIGEN3_VERSION - eigen version
-
-# Copyright (c) 2006, 2007 Montel Laurent, &lt;montel@kde.org&gt;
-# Copyright (c) 2008, 2009 Gael Guennebaud, &lt;g.gael@free.fr&gt;
-# Copyright (c) 2009 Benoit Jacob &lt;jacob.benoit.1@gmail.com&gt;
-# Redistribution and use is allowed according to the terms of the 2-clause BSD license.
-
-if(NOT Eigen3_FIND_VERSION)
-  if(NOT Eigen3_FIND_VERSION_MAJOR)
-    set(Eigen3_FIND_VERSION_MAJOR 2)
-  endif(NOT Eigen3_FIND_VERSION_MAJOR)
-  if(NOT Eigen3_FIND_VERSION_MINOR)
-    set(Eigen3_FIND_VERSION_MINOR 91)
-  endif(NOT Eigen3_FIND_VERSION_MINOR)
-  if(NOT Eigen3_FIND_VERSION_PATCH)
-    set(Eigen3_FIND_VERSION_PATCH 0)
-  endif(NOT Eigen3_FIND_VERSION_PATCH)
-
-  set(Eigen3_FIND_VERSION "${Eigen3_FIND_VERSION_MAJOR}.${Eigen3_FIND_VERSION_MINOR}.${Eigen3_FIND_VERSION_PATCH}")
-endif(NOT Eigen3_FIND_VERSION)
-
-macro(_eigen3_check_version)
-  file(READ "${EIGEN3_INCLUDE_DIR}/Eigen/src/Core/util/Macros.h" _eigen3_version_header)
-
-  string(REGEX MATCH "define[ \t]+EIGEN_WORLD_VERSION[ \t]+([0-9]+)" _eigen3_world_version_match "${_eigen3_version_header}")
-  set(EIGEN3_WORLD_VERSION "${CMAKE_MATCH_1}")
-  string(REGEX MATCH "define[ \t]+EIGEN_MAJOR_VERSION[ \t]+([0-9]+)" _eigen3_major_version_match "${_eigen3_version_header}")
-  set(EIGEN3_MAJOR_VERSION "${CMAKE_MATCH_1}")
-  string(REGEX MATCH "define[ \t]+EIGEN_MINOR_VERSION[ \t]+([0-9]+)" _eigen3_minor_version_match "${_eigen3_version_header}")
-  set(EIGEN3_MINOR_VERSION "${CMAKE_MATCH_1}")
-
-  set(EIGEN3_VERSION ${EIGEN3_WORLD_VERSION}.${EIGEN3_MAJOR_VERSION}.${EIGEN3_MINOR_VERSION})
-  if(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
-    set(EIGEN3_VERSION_OK FALSE)
-  else(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
-    set(EIGEN3_VERSION_OK TRUE)
-  endif(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
-
-  if(NOT EIGEN3_VERSION_OK)
-
-    message(STATUS "Eigen3 version ${EIGEN3_VERSION} found in ${EIGEN3_INCLUDE_DIR}, "
-                   "but at least version ${Eigen3_FIND_VERSION} is required")
-  endif(NOT EIGEN3_VERSION_OK)
-endmacro(_eigen3_check_version)
-
-if (EIGEN3_INCLUDE_DIR)
-
-  # in cache already
-  _eigen3_check_version()
-  set(EIGEN3_FOUND ${EIGEN3_VERSION_OK})
-
-else (EIGEN3_INCLUDE_DIR)
-
-  # specific additional paths for some OS
-  if (WIN32)
-    set(EIGEN_ADDITIONAL_SEARCH_PATHS ${EIGEN_ADDITIONAL_SEARCH_PATHS} "C:/Program Files/Eigen/include" "C:/Program Files (x86)/Eigen/include")
-  endif(WIN32)
-
-  find_path(EIGEN3_INCLUDE_DIR NAMES signature_of_eigen3_matrix_library
-      PATHS
-      ${CMAKE_INSTALL_PREFIX}/include
-      ${EIGEN_ADDITIONAL_SEARCH_PATHS}
-      ${KDE4_INCLUDE_DIR}
-      PATH_SUFFIXES eigen3 eigen
-    )
-
-  if(EIGEN3_INCLUDE_DIR)
-    _eigen3_check_version()
-  endif(EIGEN3_INCLUDE_DIR)
-
-  include(FindPackageHandleStandardArgs)
-  find_package_handle_standard_args(Eigen3 DEFAULT_MSG EIGEN3_INCLUDE_DIR EIGEN3_VERSION_OK)
-
-  mark_as_advanced(EIGEN3_INCLUDE_DIR)
-
-endif(EIGEN3_INCLUDE_DIR)
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\cmake_modules\FindLAPACK.cmake" new_path="" added_lines="0" deleted_lines="273">
				<diff>@@ -1,273 +0,0 @@
-# Find LAPACK library
-#
-# This module finds an installed library that implements the LAPACK
-# linear-algebra interface (see http://www.netlib.org/lapack/).
-# The approach follows mostly that taken for the autoconf macro file, acx_lapack.m4
-# (distributed at http://ac-archive.sourceforge.net/ac-archive/acx_lapack.html).
-#
-# This module sets the following variables:
-#  LAPACK_FOUND - set to true if a library implementing the LAPACK interface
-#    is found
-#  LAPACK_INCLUDE_DIR - Directories containing the LAPACK header files
-#  LAPACK_DEFINITIONS - Compilation options to use LAPACK
-#  LAPACK_LINKER_FLAGS - Linker flags to use LAPACK (excluding -l
-#    and -L).
-#  LAPACK_LIBRARIES_DIR - Directories containing the LAPACK libraries.
-#     May be null if LAPACK_LIBRARIES contains libraries name using full path.
-#  LAPACK_LIBRARIES - List of libraries to link against LAPACK interface.
-#     May be null if the compiler supports auto-link (e.g. VC++).
-#  LAPACK_USE_FILE - The name of the cmake module to include to compile
-#     applications or libraries using LAPACK.
-#
-# This module was modified by CGAL team:
-# - find libraries for a C++ compiler, instead of Fortran
-# - added LAPACK_INCLUDE_DIR, LAPACK_DEFINITIONS and LAPACK_LIBRARIES_DIR
-# - removed LAPACK95_LIBRARIES
-
-
-include(CheckFunctionExists)
-
-# This macro checks for the existence of the combination of fortran libraries
-# given by _list.  If the combination is found, this macro checks (using the
-# check_function_exists macro) whether can link against that library
-# combination using the name of a routine given by _name using the linker
-# flags given by _flags.  If the combination of libraries is found and passes
-# the link test, LIBRARIES is set to the list of complete library paths that
-# have been found and DEFINITIONS to the required definitions.
-# Otherwise, LIBRARIES is set to FALSE.
-# N.B. _prefix is the prefix applied to the names of all cached variables that
-# are generated internally and marked advanced by this macro.
-macro(check_lapack_libraries DEFINITIONS LIBRARIES _prefix _name _flags _list _blas _path)
-  #message("DEBUG: check_lapack_libraries(${_list} in ${_path} with ${_blas})")
-
-  # Check for the existence of the libraries given by _list
-  set(_libraries_found TRUE)
-  set(_libraries_work FALSE)
-  set(${DEFINITIONS} "")
-  set(${LIBRARIES} "")
-  set(_combined_name)
-  foreach(_library ${_list})
-    set(_combined_name ${_combined_name}_${_library})
-
-    if(_libraries_found)
-      # search first in ${_path}
-      find_library(${_prefix}_${_library}_LIBRARY
-                  NAMES ${_library}
-                  PATHS ${_path} NO_DEFAULT_PATH
-                  )
-      # if not found, search in environment variables and system
-      if ( WIN32 )
-        find_library(${_prefix}_${_library}_LIBRARY
-                    NAMES ${_library}
-                    PATHS ENV LIB
-                    )
-      elseif ( APPLE )
-        find_library(${_prefix}_${_library}_LIBRARY
-                    NAMES ${_library}
-                    PATHS /usr/local/lib /usr/lib /usr/local/lib64 /usr/lib64 ENV DYLD_LIBRARY_PATH
-                    )
-      else ()
-        find_library(${_prefix}_${_library}_LIBRARY
-                    NAMES ${_library}
-                    PATHS /usr/local/lib /usr/lib /usr/local/lib64 /usr/lib64 ENV LD_LIBRARY_PATH
-                    )
-      endif()
-      mark_as_advanced(${_prefix}_${_library}_LIBRARY)
-      set(${LIBRARIES} ${${LIBRARIES}} ${${_prefix}_${_library}_LIBRARY})
-      set(_libraries_found ${${_prefix}_${_library}_LIBRARY})
-    endif(_libraries_found)
-  endforeach(_library ${_list})
-  if(_libraries_found)
-    set(_libraries_found ${${LIBRARIES}})
-  endif()
-
-  # Test this combination of libraries with the Fortran/f2c interface.
-  # We test the Fortran interface first as it is well standardized.
-  if(_libraries_found AND NOT _libraries_work)
-    set(${DEFINITIONS}  "-D${_prefix}_USE_F2C")
-    set(${LIBRARIES}    ${_libraries_found})
-    # Some C++ linkers require the f2c library to link with Fortran libraries.
-    # I do not know which ones, thus I just add the f2c library if it is available.
-    find_package( F2C QUIET )
-    if ( F2C_FOUND )
-      set(${DEFINITIONS}  ${${DEFINITIONS}} ${F2C_DEFINITIONS})
-      set(${LIBRARIES}    ${${LIBRARIES}} ${F2C_LIBRARIES})
-    endif()
-    set(CMAKE_REQUIRED_DEFINITIONS  ${${DEFINITIONS}})
-    set(CMAKE_REQUIRED_LIBRARIES    ${_flags} ${${LIBRARIES}} ${_blas})
-    #message("DEBUG: CMAKE_REQUIRED_DEFINITIONS = ${CMAKE_REQUIRED_DEFINITIONS}")
-    #message("DEBUG: CMAKE_REQUIRED_LIBRARIES = ${CMAKE_REQUIRED_LIBRARIES}")
-    # Check if function exists with f2c calling convention (ie a trailing underscore)
-    check_function_exists(${_name}_ ${_prefix}_${_name}_${_combined_name}_f2c_WORKS)
-    set(CMAKE_REQUIRED_DEFINITIONS} "")
-    set(CMAKE_REQUIRED_LIBRARIES    "")
-    mark_as_advanced(${_prefix}_${_name}_${_combined_name}_f2c_WORKS)
-    set(_libraries_work ${${_prefix}_${_name}_${_combined_name}_f2c_WORKS})
-  endif(_libraries_found AND NOT _libraries_work)
-
-  # If not found, test this combination of libraries with a C interface.
-  # A few implementations (ie ACML) provide a C interface. Unfortunately, there is no standard.
-  if(_libraries_found AND NOT _libraries_work)
-    set(${DEFINITIONS} "")
-    set(${LIBRARIES}   ${_libraries_found})
-    set(CMAKE_REQUIRED_DEFINITIONS "")
-    set(CMAKE_REQUIRED_LIBRARIES   ${_flags} ${${LIBRARIES}} ${_blas})
-    #message("DEBUG: CMAKE_REQUIRED_LIBRARIES = ${CMAKE_REQUIRED_LIBRARIES}")
-    check_function_exists(${_name} ${_prefix}_${_name}${_combined_name}_WORKS)
-    set(CMAKE_REQUIRED_LIBRARIES "")
-    mark_as_advanced(${_prefix}_${_name}${_combined_name}_WORKS)
-    set(_libraries_work ${${_prefix}_${_name}${_combined_name}_WORKS})
-  endif(_libraries_found AND NOT _libraries_work)
-
-  # on failure
-  if(NOT _libraries_work)
-    set(${DEFINITIONS} "")
-    set(${LIBRARIES}   FALSE)
-  endif()
-  #message("DEBUG: ${DEFINITIONS} = ${${DEFINITIONS}}")
-  #message("DEBUG: ${LIBRARIES} = ${${LIBRARIES}}")
-endmacro(check_lapack_libraries)
-
-
-#
-# main
-#
-
-# LAPACK requires BLAS
-if(LAPACK_FIND_QUIETLY OR NOT LAPACK_FIND_REQUIRED)
-  find_package(BLAS)
-else()
-  find_package(BLAS REQUIRED)
-endif()
-
-if (NOT BLAS_FOUND)
-
-  message(STATUS "LAPACK requires BLAS.")
-  set(LAPACK_FOUND FALSE)
-
-# Is it already configured?
-elseif (LAPACK_LIBRARIES_DIR OR LAPACK_LIBRARIES)
-
-  set(LAPACK_FOUND TRUE)
-
-else()
-
-  # reset variables
-  set( LAPACK_INCLUDE_DIR "" )
-  set( LAPACK_DEFINITIONS "" )
-  set( LAPACK_LINKER_FLAGS "" ) # unused (yet)
-  set( LAPACK_LIBRARIES "" )
-  set( LAPACK_LIBRARIES_DIR "" )
-
-    #
-    # If Unix, search for LAPACK function in possible libraries
-    #
-
-    #intel mkl lapack?
-    if(NOT LAPACK_LIBRARIES)
-      check_lapack_libraries(
-      LAPACK_DEFINITIONS
-      LAPACK_LIBRARIES
-      LAPACK
-      cheev
-      ""
-      "mkl_lapack"
-      "${BLAS_LIBRARIES}"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV LAPACK_LIB_DIR"
-      )
-    endif()
-
-    #acml lapack?
-    if(NOT LAPACK_LIBRARIES)
-      check_lapack_libraries(
-      LAPACK_DEFINITIONS
-      LAPACK_LIBRARIES
-      LAPACK
-      cheev
-      ""
-      "acml"
-      "${BLAS_LIBRARIES}"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV LAPACK_LIB_DIR"
-      )
-    endif()
-
-    # Apple LAPACK library?
-    if(NOT LAPACK_LIBRARIES)
-      check_lapack_libraries(
-      LAPACK_DEFINITIONS
-      LAPACK_LIBRARIES
-      LAPACK
-      cheev
-      ""
-      "Accelerate"
-      "${BLAS_LIBRARIES}"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV LAPACK_LIB_DIR"
-      )
-    endif()
-
-    if ( NOT LAPACK_LIBRARIES )
-      check_lapack_libraries(
-      LAPACK_DEFINITIONS
-      LAPACK_LIBRARIES
-      LAPACK
-      cheev
-      ""
-      "vecLib"
-      "${BLAS_LIBRARIES}"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV LAPACK_LIB_DIR"
-      )
-    endif ( NOT LAPACK_LIBRARIES )
-
-    # Generic LAPACK library?
-    # This configuration *must* be the last try as this library is notably slow.
-    if ( NOT LAPACK_LIBRARIES )
-      check_lapack_libraries(
-      LAPACK_DEFINITIONS
-      LAPACK_LIBRARIES
-      LAPACK
-      cheev
-      ""
-      "lapack"
-      "${BLAS_LIBRARIES}"
-      "${CGAL_TAUCS_LIBRARIES_DIR} ENV LAPACK_LIB_DIR"
-      )
-    endif()
-
-  if(LAPACK_LIBRARIES_DIR OR LAPACK_LIBRARIES)
-    set(LAPACK_FOUND TRUE)
-  else()
-    set(LAPACK_FOUND FALSE)
-  endif()
-
-  if(NOT LAPACK_FIND_QUIETLY)
-    if(LAPACK_FOUND)
-      message(STATUS "A library with LAPACK API found.")
-    else(LAPACK_FOUND)
-      if(LAPACK_FIND_REQUIRED)
-        message(FATAL_ERROR "A required library with LAPACK API not found. Please specify library location.")
-      else()
-        message(STATUS "A library with LAPACK API not found. Please specify library location.")
-      endif()
-    endif(LAPACK_FOUND)
-  endif(NOT LAPACK_FIND_QUIETLY)
-
-  # Add variables to cache
-  set( LAPACK_INCLUDE_DIR   "${LAPACK_INCLUDE_DIR}"
-                            CACHE PATH "Directories containing the LAPACK header files" FORCE )
-  set( LAPACK_DEFINITIONS   "${LAPACK_DEFINITIONS}"
-                            CACHE STRING "Compilation options to use LAPACK" FORCE )
-  set( LAPACK_LINKER_FLAGS  "${LAPACK_LINKER_FLAGS}"
-                            CACHE STRING "Linker flags to use LAPACK" FORCE )
-  set( LAPACK_LIBRARIES     "${LAPACK_LIBRARIES}"
-                            CACHE FILEPATH "LAPACK libraries name" FORCE )
-  set( LAPACK_LIBRARIES_DIR "${LAPACK_LIBRARIES_DIR}"
-                            CACHE PATH "Directories containing the LAPACK libraries" FORCE )
-
-  #message("DEBUG: LAPACK_INCLUDE_DIR = ${LAPACK_INCLUDE_DIR}")
-  #message("DEBUG: LAPACK_DEFINITIONS = ${LAPACK_DEFINITIONS}")
-  #message("DEBUG: LAPACK_LINKER_FLAGS = ${LAPACK_LINKER_FLAGS}")
-  #message("DEBUG: LAPACK_LIBRARIES = ${LAPACK_LIBRARIES}")
-  #message("DEBUG: LAPACK_LIBRARIES_DIR = ${LAPACK_LIBRARIES_DIR}")
-  #message("DEBUG: LAPACK_FOUND = ${LAPACK_FOUND}")
-
-endif(NOT BLAS_FOUND)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Converter.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Converter.h" added_lines="1" deleted_lines="1">
				<diff>@@ -49,7 +49,7 @@ public:
     static Eigen::Matrix&lt;double,3,1&gt; toVector3d(const cv::Point3f &amp;cvPoint);
     static Eigen::Matrix&lt;double,3,3&gt; toMatrix3d(const cv::Mat &amp;cvMat3);
 
-    static std::vector&lt;float&gt; toQuaternion(const cv::Mat &amp;M);
+    static Eigen::Quaterniond toQuaternion(const cv::Mat &amp;M);
 };
 
 }// namespace ORB_SLAM
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Frame.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Frame.h" added_lines="4" deleted_lines="0">
				<diff>@@ -189,6 +189,10 @@ public:
 
     static bool mbInitialComputations;
 
+    // the image itself. only useful for monocular
+    cv::Mat image;
+
+    void debug (const string &amp;dirname="debug");
 
 private:
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\KeyFrame.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\KeyFrame.h" added_lines="3" deleted_lines="0">
				<diff>@@ -31,6 +31,7 @@
 #include &lt;mutex&gt;
 #include &lt;list&gt;
 #include &lt;map&gt;
+#include &lt;set&gt;
 #include &lt;boost/serialization/serialization.hpp&gt;
 
 
@@ -76,6 +77,7 @@ public:
 
     // Bag of Words Representation
     void ComputeBoW();
+    void RecomputeBoW (ORBVocabulary *newvoc);
 
     // Covisibility graph functions
     void AddConnection(KeyFrame* pKF, const int &amp;weight);
@@ -213,6 +215,7 @@ public:
     int mnMaxY;
     cv::Mat mK;
 
+    void debug (const string &amp;dirname="debug");
 
     // The following variables need to be accessed trough a mutex to be thread safe.
 protected:
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\KeyFrameDatabase.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\KeyFrameDatabase.h" added_lines="7" deleted_lines="2">
				<diff>@@ -52,13 +52,14 @@ namespace ORB_SLAM2
 
 class KeyFrame;
 class Frame;
+class Map;
 
 
 class KeyFrameDatabase
 {
 public:
 
-    KeyFrameDatabase(const ORBVocabulary &amp;voc);
+    KeyFrameDatabase(ORBVocabulary &amp;voc);
 
    void add(KeyFrame* pKF);
 
@@ -72,9 +73,13 @@ public:
    // Relocalization
    std::vector&lt;KeyFrame*&gt; DetectRelocalizationCandidates(Frame* F);
 
+   std::vector&lt;KeyFrame*&gt; DetectRelocalizationCandidatesSimple (Frame* F);
+
 	ORBVocabulary* getVocabulary ()
 	{ return const_cast&lt;ORBVocabulary*&gt; (mpVoc); }
 
+	void replaceVocabulary (ORBVocabulary *newvoc, Map *cmap);
+
 protected:
 
 	template &lt;class Archive&gt;
@@ -85,7 +90,7 @@ protected:
 
 
   // Associated vocabulary
-  const ORBVocabulary* mpVoc;
+  ORBVocabulary* mpVoc;
 
   // Inverted file
   std::vector&lt;list&lt;KeyFrame*&gt; &gt; mvInvertedFile;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\LocalMapping.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\LocalMapping.h" added_lines="3" deleted_lines="1">
				<diff>@@ -40,7 +40,7 @@ class Map;
 class LocalMapping
 {
 public:
-    LocalMapping(Map* pMap, const float bMonocular);
+    LocalMapping(Map* pMap, const float bMonocular, const bool offlineMode=false);
 
     void SetLoopCloser(LoopClosing* pLoopCloser);
 
@@ -77,6 +77,8 @@ public:
 
     std::mutex localMappingRunMutex;
 
+    const bool offlineMapping;
+
 protected:
 
     bool CheckNewKeyFrames();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\LoopClosing.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\LoopClosing.h" added_lines="3" deleted_lines="1">
				<diff>@@ -51,7 +51,7 @@ public:
 
 public:
 
-    LoopClosing(Map* pMap, KeyFrameDatabase* pDB, ORBVocabulary* pVoc,const bool bFixScale);
+    LoopClosing(Map* pMap, KeyFrameDatabase* pDB, ORBVocabulary* pVoc,const bool bFixScale, const bool offlineMode=false);
 
     void SetTracker(Tracking* pTracker);
 
@@ -85,6 +85,8 @@ public:
 
     std::mutex loopCloserRunMutex;
 
+    const bool offlineMapping;
+
 protected:
 
     bool CheckNewKeyFrames();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Map.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Map.h" added_lines="15" deleted_lines="2">
				<diff>@@ -35,6 +35,7 @@
 #include &lt;pcl/octree/octree.h&gt;
 #include &lt;pcl/octree/impl/octree_search.hpp&gt;
 
+#include &lt;ORBVocabulary.h&gt;
 
 namespace ORB_SLAM2
 {
@@ -42,6 +43,7 @@ namespace ORB_SLAM2
 class MapPoint;
 class KeyFrame;
 class KeyFrameDatabase;
+class Frame;
 
 
 /*
@@ -75,6 +77,8 @@ public:
 
     long unsigned int GetMaxKFid();
 
+    void extractVocabulary (ORBVocabulary *cvoc);
+
     void clear();
 
     std::vector&lt;KeyFrame*&gt; mvpKeyFrameOrigins;
@@ -102,9 +106,16 @@ public:
 			numOfReferencePoint;
 	};
 
-	KeyFrame* getNearestKeyFrame (const float &amp;x, const float &amp;y, const float &amp;z, const float fdir_x, const float fdir_y, const float fdir_z);
+//	KeyFrame* getNearestKeyFrame (
+//		const float &amp;x, const float &amp;y, const float &amp;z,
+//		const float fdir_x, const float fdir_y, const float fdir_z,
+//		vector&lt;KeyFrame*&gt; *kfSelectors=NULL);
+	KeyFrame* getNearestKeyFrame (
+		const Eigen::Vector3f &amp;position,
+		const Eigen::Quaternionf &amp;orientation,
+		vector&lt;KeyFrame*&gt; *kfSelectors);
+
 	KeyFrame* offsetKeyframe (KeyFrame* kfSrc, int offset);
-//	KeyFrame* offsetKeyframe (KeyFrame* kfSrc, float offset);
 
 	// These are used for augmented localization
 	std::vector&lt;KeyFrame*&gt; kfListSorted;
@@ -125,6 +136,8 @@ protected:
     pcl::PointCloud&lt;KeyFramePt&gt;::Ptr kfCloud;
     pcl::octree::OctreePointCloudSearch&lt;KeyFramePt&gt;::Ptr kfOctree;
 
+    KeyFrameDatabase *mKeyFrameDb;
+
 };
 
 } //namespace ORB_SLAM
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Optimizer.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Optimizer.h" added_lines="2" deleted_lines="1">
				<diff>@@ -21,7 +21,7 @@
 #ifndef OPTIMIZER_H
 #define OPTIMIZER_H
 
-#include "Map.h"
+//#include "Map.h"
 #include "MapPoint.h"
 #include "KeyFrame.h"
 #include "LoopClosing.h"
@@ -33,6 +33,7 @@ namespace ORB_SLAM2
 {
 
 class LoopClosing;
+class Map;
 
 class Optimizer
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\System.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\System.h" added_lines="6" deleted_lines="1">
				<diff>@@ -75,7 +75,9 @@ public:
 		const eSensor sensor,
 		const bool bUseViewer = true,
 		const string &amp;mapFileName=string(),
-		const operationMode mode=System::MAPPING);
+		const operationMode mode=System::MAPPING,
+		bool doOfflineMapping=false
+    );
 
     // Proccess the given stereo frame. Images must be synchronized and rectified.
     // Input images: RGB (CV_8UC3) or grayscale (CV_8U). RGB is converted to grayscale.
@@ -139,6 +141,9 @@ public:
 
     const operationMode opMode;
 
+    const bool offlineMapping;
+    float fps;
+
 private:
 
     // Input sensor
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Tracking.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\include\Tracking.h" added_lines="14" deleted_lines="1">
				<diff>@@ -25,6 +25,8 @@
 #include&lt;opencv2/core/core.hpp&gt;
 #include&lt;opencv2/features2d/features2d.hpp&gt;
 
+#include &lt;Eigen/Geometry&gt;
+
 #include"Viewer.h"
 #include"FrameDrawer.h"
 #include"Map.h"
@@ -40,6 +42,10 @@
 
 #include &lt;mutex&gt;
 
+
+typedef Eigen::Transform&lt;float,3,Eigen::Affine&gt; Transform3;
+
+
 namespace ORB_SLAM2
 {
 
@@ -62,6 +68,8 @@ public:
     cv::Mat GrabImageRGBD(const cv::Mat &amp;imRGB,const cv::Mat &amp;imD, const double &amp;timestamp);
     cv::Mat GrabImageMonocular(const cv::Mat &amp;im, const double &amp;timestamp);
 
+    Transform3 LocalizeImage (const cv::Mat &amp;image, const double &amp;timestamp);
+
     void SetLocalMapper(LocalMapping* pLocalMapper);
     void SetLoopClosing(LoopClosing* pLoopClosing);
     void SetViewer(Viewer* pViewer);
@@ -160,7 +168,12 @@ protected:
     void UpdateLastFrame();
     bool TrackWithMotionModel();
 
-    bool Relocalization();
+    enum RelocalizationMode {
+    	SEARCH_DB = 1,
+		SEARCH_MAPPING = 2,
+		SEARCH_LOCAL_MAP = 3
+    };
+    bool Relocalization (RelocalizationMode=SEARCH_DB);
 
     void UpdateLocalMap();
     void UpdateLocalPoints();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\common.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\common.cpp" added_lines="111" deleted_lines="0">
				<diff>@@ -5,6 +5,7 @@
 #include &lt;iostream&gt;
 #include &lt;exception&gt;
 #include "common.h"
+#include "Converter.h"
 
 
 #define foreach BOOST_FOREACH
@@ -13,6 +14,66 @@
 using std::cout;
 using std::endl;
 using std::exception;
+using ORB_SLAM2::KeyFrame;
+
+
+void equalizeImageHistogramFromMask (cv::Mat &amp;input, cv::Mat &amp;output, cv::Mat &amp;mask)
+{
+	cv::Mat LUT = cv::Mat::zeros(1, 256, CV_8U);
+	cv::MatND hist;
+	int histSize = 256;
+	float range[] = {0,255};
+	const float *ranges[] = {range};
+//	uint8_t
+	cv::calcHist (&amp;input, 1, 0, mask, hist, 1, &amp;histSize, ranges, true, false);
+
+	int i=0;
+	while (!hist.at&lt;uint8_t&gt;(i))
+		i++;
+	int total = (int)input.total();
+
+	int miz=(int)hist.at&lt;float&gt;(i);
+	float scale = 255.0f / (total-miz);
+	int sum = 0;
+	for (LUT.at&lt;uchar&gt;(i++)=0; i&lt;256; ++i) {
+		sum += (int)hist.at&lt;float&gt;(i);
+		LUT.at&lt;uchar&gt;(i) = cv::saturate_cast&lt;uchar&gt;(sum * scale);
+	}
+
+	cv::LUT(input, LUT, output);
+//	cv::equalizeHist(output, output);
+}
+
+
+float detectCcdSmear (cv::Mat &amp;colorInput)
+{
+	// 1. Convert image to HSV and take V channel -&gt; V
+	cv::Mat imgHsv, V;
+	cv::cvtColor(colorInput, imgHsv, CV_BGR2HSV);
+	cv::extractChannel(imgHsv, V, 2);
+	// 2. Normalize V
+	V.convertTo(V, CV_32F);
+	V /= 255.0;
+	// Sum all elements of V per column
+	cv::Mat tv = cv::Mat::zeros(V.cols, 1, CV_32F);
+	for (int i=0; i&lt;V.cols; i++) {
+		tv.at&lt;float&gt;(i) = cv::sum(V.col(i))[0];
+	}
+	tv /= (float)V.rows;
+	// Count number of columns that are out of range
+	const float th = 0.1;
+	int nc = 0;
+	for (int i=0; i&lt;V.cols; i++) {
+		if (tv.at&lt;float&gt;(i) &gt;= 1.0-th)
+			nc += 1;
+	}
+	// done
+	if (nc &lt; 2)
+		return -1;
+	else return 1.0;
+	// XXX: how to quantize nc to scale 0~1.0 ?
+}
+
 
 
 void tfToCV(const tf::Transform &amp;src, cv::Mat &amp;position, cv::Mat &amp;orientation)
@@ -80,3 +141,53 @@ tf::Transform FramePose (ORB_SLAM2::Frame *cframe)
 
 	return tf::Transform(M, V);
 }
+
+
+tf::Transform KeyFramePoseToTf (KeyFrame *kf)
+{
+	tf::Transform kfpose;
+
+	cv::Mat t = kf-&gt;GetCameraCenter();
+	cv::Mat orient = kf-&gt;GetRotation().t();
+	Eigen::Quaterniond q = ORB_SLAM2::Converter::toQuaternion(orient);
+
+	kfpose.setOrigin(tf::Vector3(t.at&lt;float&gt;(0), t.at&lt;float&gt;(1), t.at&lt;float&gt;(2)));
+	kfpose.setRotation(tf::Quaternion(q.x(), q.y(), q.z(), q.w()));
+
+	return kfpose;
+}
+
+
+tf::Transform getKeyFrameExtPose (const KeyFrame *kf)
+{
+	tf::Transform Ext;
+
+	if (kf-&gt;extPosition.empty() or kf-&gt;extOrientation.empty()) {
+		Ext.setOrigin(tf::Vector3(NAN, NAN, NAN));
+		Ext.setRotation(tf::Quaternion(NAN, NAN, NAN, NAN));
+	}
+
+	else {
+		Ext.setOrigin (tf::Vector3(
+			kf-&gt;extPosition.at&lt;double&gt;(0),
+			kf-&gt;extPosition.at&lt;double&gt;(1),
+			kf-&gt;extPosition.at&lt;double&gt;(2) ));
+		Ext.setRotation(tf::Quaternion(
+			kf-&gt;extOrientation.at&lt;double&gt;(0),
+			kf-&gt;extOrientation.at&lt;double&gt;(1),
+			kf-&gt;extOrientation.at&lt;double&gt;(2),
+			kf-&gt;extOrientation.at&lt;double&gt;(3) ));
+	}
+	return Ext;
+}
+
+
+cv::Vec3d
+tfToCv (const tf::Vector3 &amp;pos)
+{
+	cv::Vec3d cvVec;
+	cvVec[0] = pos.x();
+	cvVec[1] = pos.y();
+	cvVec[2] = pos.z();
+	return cvVec;
+}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\common.h" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\common.h" added_lines="34" deleted_lines="0">
				<diff>@@ -2,6 +2,10 @@
 #ifndef _ORB_UTILS_H
 #define _ORB_UTILS_H 1
 
+#include &lt;opencv2/core/core.hpp&gt;
+#include &lt;opencv2/imgproc/imgproc.hpp&gt;
+#include &lt;opencv2/highgui/highgui.hpp&gt;
+
 #include &lt;tf/tf.h&gt;
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;rosbag/bag.h&gt;
@@ -9,6 +13,7 @@
 #include &lt;vector&gt;
 #include &lt;exception&gt;
 #include "Frame.h"
+#include "KeyFrame.h"
 
 
 using std::string;
@@ -30,5 +35,34 @@ void tf2positiondirection (const tf::Transform &amp;pose, float positiondirection[6]
 
 tf::Transform FramePose (ORB_SLAM2::Frame *cframe);
 
+void equalizeImageHistogramFromMask (cv::Mat &amp;input, cv::Mat &amp;output, cv::Mat &amp;mask);
+
+float detectCcdSmear (cv::Mat &amp;colorInput);
+
+// Keyframe positions
+tf::Transform KeyFramePoseToTf (ORB_SLAM2::KeyFrame *kf);
+tf::Transform getKeyFrameExtPose (const ORB_SLAM2::KeyFrame *kf);
+
+cv::Vec3d tfToCv (const tf::Vector3 &amp;pos);
+
+
+
+class OrbException: public exception
+{
+public:
+	inline OrbException (const string &amp;s):
+		msg(s)
+	{}
+
+	inline const char *what() const noexcept
+	{ return msg.c_str(); }
+
+protected:
+	string msg;
+};
+
+
+
+
 
 #endif /* _ORB_UTILS_H */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\dumpmap\dumpmap.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\dumpmap\dumpmap.cc" added_lines="54" deleted_lines="6">
				<diff>@@ -9,12 +9,38 @@
 #include &lt;iostream&gt;
 #include "Map.h"
 #include "KeyFrame.h"
+#include "MapPoint.h"
 #include "Converter.h"
+#include "ORBVocabulary.h"
 
 
 using namespace std;
 using ORB_SLAM2::Map;
 using ORB_SLAM2::KeyFrame;
+using ORB_SLAM2::MapPoint;
+
+
+const string mapvoc = "/tmp/orbvocz.txt";
+
+
+void dumpVocabularyX (const ORB_SLAM2::Map &amp;Map, const string &amp;resultingVocTextfile)
+{
+	ORB_SLAM2::ORBVocabulary mapVoc(10, 6);
+	vector&lt;vector&lt;DBoW2::FORB::TDescriptor&gt; &gt; keymapFeatures;
+	keymapFeatures.reserve(Map.kfListSorted.size());
+
+	vector&lt;KeyFrame*&gt; allKeyFrames = Map.kfListSorted;
+	for (vector&lt;KeyFrame*&gt;::const_iterator it=allKeyFrames.begin(); it!=allKeyFrames.end(); it++) {
+
+		KeyFrame *kf = *it;
+		vector&lt;cv::Mat&gt; vCurrentDesc = ORB_SLAM2::Converter::toDescriptorVector(kf-&gt;mDescriptors);
+
+		keymapFeatures.push_back(vCurrentDesc);
+	}
+
+	mapVoc.create(keymapFeatures);
+	mapVoc.saveToTextFile(resultingVocTextfile);
+}
 
 
 int main (int argc, char **argv)
@@ -33,21 +59,43 @@ int main (int argc, char **argv)
 
 		KeyFrame *kf = *it;
 		cv::Mat pos = kf-&gt;GetCameraCenter();
+		const float
+			x = pos.at&lt;float&gt;(0),
+			y = pos.at&lt;float&gt;(1),
+			z = pos.at&lt;float&gt;(2);
+
 		cv::Mat orient = kf-&gt;GetRotation().t();
-		vector&lt;float&gt; q = ORB_SLAM2::Converter::toQuaternion(orient);
+		Eigen::Quaterniond q = ORB_SLAM2::Converter::toQuaternion(orient);
+
 
 //		cout &lt;&lt; kf-&gt;mnId &lt;&lt; " ";
-        cout &lt;&lt; std::fixed &lt;&lt; setprecision(6) &lt;&lt; kf-&gt;mTimeStamp
-        		&lt;&lt; setprecision(7) &lt;&lt; " " &lt;&lt; pos.at&lt;float&gt;(0) &lt;&lt; " " &lt;&lt; pos.at&lt;float&gt;(1) &lt;&lt; " " &lt;&lt; pos.at&lt;float&gt;(2)
-          &lt;&lt; " " &lt;&lt; q[0] &lt;&lt; " " &lt;&lt; q[1] &lt;&lt; " " &lt;&lt; q[2] &lt;&lt; " " &lt;&lt; q[3];
+        cout &lt;&lt; std::fixed &lt;&lt; setprecision(6) &lt;&lt;
+        		// First column: timestamp
+        		kf-&gt;mnId &lt;&lt; " "
+        		&lt;&lt; kf-&gt;mTimeStamp
+        		&lt;&lt; setprecision(7) &lt;&lt; " "
+				// Columns 1-3: ORB coordinate
+				&lt;&lt; pos.at&lt;float&gt;(0) &lt;&lt; " " &lt;&lt; pos.at&lt;float&gt;(1) &lt;&lt; " " &lt;&lt; pos.at&lt;float&gt;(2)
+				&lt;&lt; " "
+				// Columns 4-7: ORB Orientation in quaternion
+				&lt;&lt; q.x() &lt;&lt; " " &lt;&lt; q.y() &lt;&lt; " " &lt;&lt; q.z() &lt;&lt; " " &lt;&lt; q.w();
         if (kf-&gt;extPosition.empty()) {
         	cout &lt;&lt; " x x x x x x x ";
         }
         else {
-			cout &lt;&lt; " " &lt;&lt; kf-&gt;extPosition.at&lt;double&gt;(0) &lt;&lt; " " &lt;&lt; kf-&gt;extPosition.at&lt;double&gt;(1) &lt;&lt; " " &lt;&lt; kf-&gt;extPosition.at&lt;double&gt;(2);
-			cout &lt;&lt; " " &lt;&lt; kf-&gt;extOrientation.at&lt;double&gt;(0) &lt;&lt; " " &lt;&lt; kf-&gt;extOrientation.at&lt;double&gt;(1) &lt;&lt; " " &lt;&lt; kf-&gt;extOrientation.at&lt;double&gt;(2) &lt;&lt; " " &lt;&lt; kf-&gt;extOrientation.at&lt;double&gt;(3);
+			cout &lt;&lt; " "
+				// Columns 8-10: Reference coordinate
+				&lt;&lt; kf-&gt;extPosition.at&lt;double&gt;(0) &lt;&lt; " " &lt;&lt; kf-&gt;extPosition.at&lt;double&gt;(1) &lt;&lt; " " &lt;&lt; kf-&gt;extPosition.at&lt;double&gt;(2);
+			cout &lt;&lt; " "
+				// Columns 11-14: Reference orientation in quaternion
+				&lt;&lt; kf-&gt;extOrientation.at&lt;double&gt;(0) &lt;&lt; " " &lt;&lt; kf-&gt;extOrientation.at&lt;double&gt;(1) &lt;&lt; " " &lt;&lt; kf-&gt;extOrientation.at&lt;double&gt;(2) &lt;&lt; " " &lt;&lt; kf-&gt;extOrientation.at&lt;double&gt;(3);
         }
 		cout &lt;&lt; endl;
 
 	}
+
+//	cerr &lt;&lt; "Saving vocabulary to " &lt;&lt; mapvoc &lt;&lt; endl;
+//	dumpVocabulary(World, mapvoc);
+
+	return 0;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_mapping\orb_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_mapping\orb_mapping.cpp" added_lines="22" deleted_lines="44">
				<diff>@@ -32,21 +32,15 @@ namespace enc = sensor_msgs::image_encodings;
 class ORB_Mapper
 {
 public:
-	ORB_Mapper (ORB_SLAM2::System&amp; pSL, ros::NodeHandle &amp;nh) :
+	ORB_Mapper (ORB_SLAM2::System&amp; pSL, ros::NodeHandle &amp;nh, int fps_=10) :
 		SLAMSystem (pSL),
 		rosnode (nh),
 		extListener (NULL),
 		lastImageTimestamp (0.0),
-//		doStop (false),
-		externalLocalizerThread (NULL),
+		doStop (false),
+		fps (fps_),
 		gotFirstFrame (false)
 	{
-		externalFrameFixed = (string)pSL.fsSettings["ExternalReference.Mapping.frame1"];
-		externalFrameMoving = (string)pSL.fsSettings["ExternalReference.Mapping.frame2"];
-
-		// TF Listener
-//		externalLocalizerThread = new std::thread (&amp;ORB_Mapper::externalLocalizerGrab, this);
-
 		// Image Subscription
 	    if ((int)SLAMSystem.fsSettings["Camera.compressed"]==0) {
 	    	th = image_transport::TransportHints ("raw");
@@ -57,7 +51,6 @@ public:
 		imageBuf = new image_transport::ImageTransport(rosnode);
 //		imageSub = imageBuf-&gt;subscribe((string)SLAMSystem.fsSettings["Camera.topic"], 1, &amp;ORB_Mapper::imageCallback, this, th);
 
-		// XXX: put topic name into ros parameter
 		string groundTruthPose;
 		rosnode.getParam("external_localization_topic", groundTruthPose);
 		poseSub = rosnode.subscribe (groundTruthPose, 2, &amp;ORB_Mapper::poseCallback, this);
@@ -72,34 +65,14 @@ public:
 	}
 
 
-//	void externalLocalizerGrab ()
-//	{
-//		if (extListener==NULL)
-//			extListener = new tf::TransformListener ();
-//
-//		ros::Rate fps((int)SLAMSystem.fsSettings["Camera.fps"] * 2);
-//
-//		while (ros::ok()) {
-//
-//			if (doStop == true)
-//				break;
-//
-//			try {
-//
-//				extListener-&gt;lookupTransform (externalFrameFixed, externalFrameMoving, ros::Time(0), extPose);
-//				unique_lock&lt;mutex&gt; lock(ORB_SLAM2::KeyFrame::extPoseMutex);
-//				tfToCV (extPose, ORB_SLAM2::KeyFrame::extEgoPosition, ORB_SLAM2::KeyFrame::extEgoOrientation);
-//
-//			} catch (tf::TransformException &amp;e) {
-//
-//				unique_lock&lt;mutex&gt; lock(ORB_SLAM2::KeyFrame::extPoseMutex);
-//				ORB_SLAM2::KeyFrame::extEgoPosition.release();
-//				ORB_SLAM2::KeyFrame::extEgoOrientation.release();
-//
-//			}
-//			fps.sleep();
-//		}
-//	}
+	void slamFeeder ()
+	{
+		ros::Rate hzs (fps);
+
+		while (doStop==false) {
+			hzs.sleep();
+		}
+	}
 
 
 	void poseCallback (const geometry_msgs::PoseStampedConstPtr &amp;cpose)
@@ -210,20 +183,25 @@ private:
 	ORB_SLAM2::System &amp;SLAMSystem;
 	ros::Subscriber poseSub;
 
-	string externalFrameFixed;
-	string externalFrameMoving;
+//	string externalFrameFixed;
+//	string externalFrameMoving;
 
 	double lastImageTimestamp;
 	bool gotFirstFrame;
 
+	int fps;
+
+	mutex mtxCImage;
+	cv::Mat currentImage;
+
 public:
-//	volatile bool doStop;
+	volatile bool doStop;
 
 	image_transport::TransportHints th;
 	image_transport::ImageTransport *imageBuf;
 	image_transport::Subscriber imageSub;
 
-	thread *externalLocalizerThread;
+	thread slamFeederT;
 
 };
 
@@ -257,10 +235,10 @@ int main (int argc, char *argv[])
 
 	string imageTopic;
 	nodeHandler.getParam("image_topic", imageTopic);
-	Mapper.imageSub = Mapper.imageBuf-&gt;subscribe (imageTopic, 1,  &amp;ORB_Mapper::imageCallback, &amp;Mapper, Mapper.th);
+	Mapper.imageSub = Mapper.imageBuf-&gt;subscribe (imageTopic, 100,  &amp;ORB_Mapper::imageCallback, &amp;Mapper, Mapper.th);
 
 	ros::spin();
-//    Mapper.doStop = true;
+    Mapper.doStop = true;
 //    Mapper.externalLocalizerThread-&gt;join();
 
     ros::shutdown();
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_matching\orb_matching.cpp" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\orb_matching\orb_matching.cpp" added_lines="3" deleted_lines="526">
				<diff>@@ -3,545 +3,22 @@
  *  All rights reserved.
  *
  *  XXX: Licensing has not been cleared yet.
-*/
-
-#include &lt;iostream&gt;
-#include &lt;string&gt;
-#include &lt;thread&gt;
-#include &lt;cmath&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-#include &lt;sensor_msgs/Image.h&gt;
-#include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;geometry_msgs/PoseStamped.h&gt;
-#include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
-#include &lt;cv_bridge/cv_bridge.h&gt;
-#include &lt;image_transport/image_transport.h&gt;
-#include &lt;tf/transform_broadcaster.h&gt;
-#include "boost/date_time/posix_time/posix_time.hpp"
-
-#include "System.h"
-#include "Converter.h"
-#include "../common.h"
-
-
-using namespace std;
-using namespace ORB_SLAM2;
-using namespace boost::posix_time;
-namespace enc = sensor_msgs::image_encodings;
-
-
-class ORB_Matcher
-{
-public:
-	ORB_Matcher (ORB_SLAM2::System&amp; pSL, ros::NodeHandle &amp;nh) :
-		SLAMSystem (pSL), rosnode(nh),
-		lastImageTimestamp (0.0),
-		gotFirstFrame (false),
-		lastKeyframeId (0)
-	{
-		externalFrameFixed = (string)pSL.fsSettings["Localization.frame1"];
-		externalFrameMoving = (string)pSL.fsSettings["Localization.frame2"];
-		offsetKeyframe = SLAMSystem.fsSettings["ExternalLocalization.OffsetKeyframes"];
-
-		cout &lt;&lt; "TF: From " &lt;&lt; externalFrameFixed &lt;&lt; " to " &lt;&lt; externalFrameMoving &lt;&lt; endl;
-
-		// Image Subscription
-	    if ((int)SLAMSystem.fsSettings["Camera.compressed"]==0) {
-	    	th = image_transport::TransportHints ("raw");
-	    }
-	    else if ((int)SLAMSystem.fsSettings["Camera.compressed"]==1) {
-	    	th = image_transport::TransportHints ("compressed");
-	    }
-		imageBuf = new image_transport::ImageTransport(rosnode);
-
-		// Result Publishers
-		string poseTopic;
-		rosnode.getParam("pose_topic", poseTopic);
-		posePublisher = rosnode.advertise&lt;geometry_msgs::PoseStamped&gt; (poseTopic, 1);
-		mTfBr = new tf::TransformBroadcaster();
-
-		// start of debug preparation
-		cout &lt;&lt; std::fixed &lt;&lt; setprecision(7);
-		visualDebugView = imageBuf-&gt;advertise("framebuffer", 1);
-	}
-
-
-	~ORB_Matcher ()
-	{
-		delete (imageBuf);
-		delete (mTfBr);
-	}
-
-
-	void imageCallback (const sensor_msgs::ImageConstPtr&amp; msg)
-	{
-		// Activate this timer if you need time logging
-		ptime rT1, rT2;
-		rT1 = microsec_clock::local_time();
-
-		// Copy the ros image message to cv::Mat.
-		cv_bridge::CvImageConstPtr cv_ptr;
-		try
-		{
-			cv_ptr = cv_bridge::toCvShare(msg);
-		}
-		catch (cv_bridge::Exception&amp; e)
-		{
-			ROS_ERROR("cv_bridge exception: %s", e.what());
-			return;
-		}
-
-		cv::Mat image;
-		// Check if we need debayering
-		if (enc::isBayer(msg-&gt;encoding)) {
-			int code=-1;
-			if (msg-&gt;encoding == enc::BAYER_RGGB8 ||
-				msg-&gt;encoding == enc::BAYER_RGGB16) {
-				code = cv::COLOR_BayerBG2BGR;
-			}
-			else if (msg-&gt;encoding == enc::BAYER_BGGR8 ||
-					 msg-&gt;encoding == enc::BAYER_BGGR16) {
-				code = cv::COLOR_BayerRG2BGR;
-			}
-			else if (msg-&gt;encoding == enc::BAYER_GBRG8 ||
-					 msg-&gt;encoding == enc::BAYER_GBRG16) {
-				code = cv::COLOR_BayerGR2BGR;
-			}
-			else if (msg-&gt;encoding == enc::BAYER_GRBG8 ||
-					 msg-&gt;encoding == enc::BAYER_GRBG16) {
-				code = cv::COLOR_BayerGB2BGR;
-			}
-			cv::cvtColor(cv_ptr-&gt;image, image, code);
-		}
-		else
-			image = cv_ptr-&gt;image;
-
-		const double imageTime = msg-&gt;header.stamp.toSec();
-		lastImageTimestamp = imageTime;
-
-		if (gotFirstFrame==false) {
-			double fx2, fy2, cx2, cy2;
-			recomputeNewCameraParameter (
-				(double)SLAMSystem.fsSettings["Camera.fx"],
-				(double)SLAMSystem.fsSettings["Camera.fy"],
-				(double)SLAMSystem.fsSettings["Camera.cx"],
-				(double)SLAMSystem.fsSettings["Camera.cy"],
-				fx2, fy2, cx2, cy2,
-				msg-&gt;width, msg-&gt;height,
-				(int)SLAMSystem.fsSettings["Camera.WorkingResolution.Width"],
-				(int)SLAMSystem.fsSettings["Camera.WorkingResolution.Height"]);
-			// send camera parameters to tracker
-			SLAMSystem.getTracker()-&gt;ChangeCalibration (fx2, fy2, cx2, cy2);
-			gotFirstFrame = true;
-		}
-
-		// Processing before sending image to tracker
-		// Do Resizing and cropping here
-		cv::resize(image, image,
-			cv::Size(
-				(int)SLAMSystem.fsSettings["Camera.WorkingResolution.Width"],
-				(int)SLAMSystem.fsSettings["Camera.WorkingResolution.Height"]
-			));
-		image = image(
-			cv::Rect(
-				(int)SLAMSystem.fsSettings["Camera.ROI.x0"],
-				(int)SLAMSystem.fsSettings["Camera.ROI.y0"],
-				(int)SLAMSystem.fsSettings["Camera.ROI.width"],
-				(int)SLAMSystem.fsSettings["Camera.ROI.height"]
-			)).clone();
-
-		SLAMSystem.TrackMonocular(image, imageTime);
-
-		// Reinsert TF publisher, but only for localization. Original ORB-SLAM2 removes it.
-		bool tfOk = false;
-		tf::Transform locRef;
-
-		Frame &amp;cframe = SLAMSystem.getTracker()-&gt;mCurrentFrame;
-		if (SLAMSystem.getTracker()-&gt;trackingIsGood())
-		{
-
-			tf::Transform tfTcw = FramePose(&amp;cframe);
-			mTfBr-&gt;sendTransform(tf::StampedTransform(tfTcw, ros::Time(imageTime), "/ORB_SLAM/World", "/ORB_SLAM/Camera"));
-
-	//		 Here, we use offset of external localization from the keyframe
-
-				try {
-					locRef = localizeByReference(tfTcw);
-					publishPose(&amp;locRef);
-					tfOk = true;
-//					lastDebugMessage = "";
-				} catch (exception &amp;e) {
-//					lastDebugMessage = e.what();
-					publishPose(NULL);
-				}
-
-		} else {
-			publishPose (NULL);
-		}
-
-		rT2 = microsec_clock::local_time();
-//		cputimeDebug = (rT2-rT1).total_microseconds() * 1e-6;
-
-		// Debugging
-		SLAMSystem.getFrameDrawer()-&gt;DrawFrame();
-		cv::Mat framebufferDbg = SLAMSystem.getFrameDrawer()-&gt;getLastFrame();
-		cv_bridge::CvImage bagImage;
-		bagImage.image = framebufferDbg;
-		bagImage.header.stamp = ros::Time(lastImageTimestamp);
-		bagImage.encoding = "bgr8";
-		visualDebugView.publish(bagImage.toImageMsg());
-	}
-
-private:
-	tf::Transform localizeByReference (const tf::Transform &amp;tfOrb, ORB_SLAM2::KeyFrame *kf)
-	{
-		lastKeyframeId = kf-&gt;mnId;
-
-		ORB_SLAM2::KeyFrame *kOffset = SLAMSystem.getMap()-&gt;offsetKeyframe(kf, offsetKeyframe);
-		if (kOffset==NULL)
-			throw std::out_of_range("No offset keyframe found");
-
-		if (kf-&gt;extPosition.empty() or kOffset-&gt;extPosition.empty())
-			throw std::out_of_range("External reference of keyframe not found");
-
-		tf::Transform kfTr = KeyFramePoseToTf(kf);
-		tf::Transform extRef = getKeyFrameExtPose(kf);
-
-		tf::Transform kfTrOffset = KeyFramePoseToTf(kOffset);
-		tf::Transform extRefOffset = getKeyFrameExtPose(kOffset);
-		return localizeByReference (tfOrb, kfTr, kfTrOffset, extRef, extRefOffset);
-	}
-
-
-	tf::Transform rotateAxes (const tf::Transform &amp;cPose, const float roll=0, const float pitch=0, const float yaw=0)
-	{
-		tf::Transform rotation;
-		rotation.setOrigin (tf::Vector3 (0,0,0));
-		rotation.setRotation (tf::Quaternion(roll, pitch, yaw).normalize());
-		return cPose * rotation;
-	}
-
-
-	/*
-	 * Main routine for localization by reference
-	 */
-	tf::Transform localizeByReference (
-	    	const tf::Transform &amp;tfOrb,
-			const tf::Transform &amp;tfOrbMap, const tf::Transform &amp;tfOrbMapOffset,
-	    	const tf::Transform &amp;realMapPose, const tf::Transform &amp;realMapOffset)
-	{
-		double offDistO = cv::norm(
-			tfToCv(tfOrbMap.getOrigin()) -
-			tfToCv(tfOrbMapOffset.getOrigin()));
-		double offDistE = cv::norm(
-			tfToCv(realMapPose.getOrigin()) -
-			tfToCv(realMapOffset.getOrigin()));
-		double scale = offDistE / offDistO;
-
-		// change orientation from camera to velodyne
-		tf::Transform flipAxes;
-		flipAxes.setOrigin(tf::Vector3(0, 0, 0));
-		flipAxes.setRotation (tf::Quaternion(M_PI/2, 0, -M_PI/2).normalize());
-
-		tf::Transform orbRel = tfOrbMap.inverse() * tfOrb;
-
-		tf::Transform scaledRel = orbRel;
-		scaledRel.setOrigin(orbRel.getOrigin() * scale);
-		scaledRel = flipAxes*scaledRel;
-
-		tf::Transform tfResult = realMapPose * scaledRel;
-
-		// Still need to rotate axes
-		return rotateAxes (tfResult, 0, M_PI/2, M_PI/2);
-	}
-
-
-	tf::Transform localizeByReference(const tf::Transform &amp;tfOrb)
-	{
-		float fdirx = tfOrb.getRotation().x(),
-			fdiry = tfOrb.getRotation().y(),
-			fdirz = tfOrb.getRotation().z(),
-			fdirnorm;
-		fdirnorm = sqrtf(fdirx*fdirx + fdiry*fdiry + fdirz*fdirz);
-		fdirx /= fdirnorm;
-		fdiry /= fdirnorm;
-		fdirz /= fdirnorm;
-
-		ORB_SLAM2::KeyFrame *kfNear = SLAMSystem.getMap()-&gt;getNearestKeyFrame(
-			tfOrb.getOrigin().x(),
-			tfOrb.getOrigin().y(),
-			tfOrb.getOrigin().z(),
-			fdirx, fdiry, fdirz);
-		if (kfNear==NULL)
-			throw std::out_of_range("No nearest keyframe found");
-
-		lastKeyframeId = kfNear-&gt;mnId;
-		return localizeByReference (tfOrb, kfNear);
-	}
-
-
-	tf::Transform localizeByReference(Frame *sframe)
-	{
-	//	const tf::Transform
-	}
-
-
-	tf::Transform localizeByReference(const tf::Transform &amp;tfOrb, ORB_SLAM2::Map *mapsrc, const int offsetNum)
-	{
-		float positiondir[6];
-		tf2positiondirection(tfOrb, positiondir);
-
-		ORB_SLAM2::KeyFrame *kfNear = mapsrc-&gt;getNearestKeyFrame(
-			positiondir[0], positiondir[1], positiondir[2],
-			positiondir[3], positiondir[4], positiondir[5]);
-		if (kfNear==NULL)
-			throw std::out_of_range("No keyframe found");
-		ORB_SLAM2::KeyFrame *kOffset = mapsrc-&gt;offsetKeyframe(kfNear, offsetNum);
-		if (kOffset==NULL)
-			throw std::out_of_range("No offset keyframe found");
-
-		tf::Transform kfTr = KeyFramePoseToTf(kfNear);
-		tf::Transform extRef = getKeyFrameExtPose(kfNear);
-
-		tf::Transform kfTrOffset = KeyFramePoseToTf(kOffset);
-		tf::Transform extRefOffset = getKeyFrameExtPose(kOffset);
-
-		return localizeByReference (tfOrb, kfTr, kfTrOffset, extRef, extRefOffset);
-	}
-
-
-	tf2_msgs::TFMessage createTfMessage (const tf::Transform &amp;srcTransform,
-		const string &amp;frameSrc, const string &amp;frameTarget,
-		double timestamp=-1)
-	{
-		ros::Time msgTime;
-		tf2_msgs::TFMessage tfretval;
-
-		if (timestamp&gt;0)
-			msgTime = ros::Time(timestamp);
-		else msgTime = ros::Time::now();
-
-		geometry_msgs::TransformStamped newTransform;
-		newTransform.header.stamp = msgTime;
-		newTransform.header.frame_id = frameSrc;
-		newTransform.child_frame_id = frameTarget;
-		newTransform.transform.translation.x = srcTransform.getOrigin().x();
-		newTransform.transform.translation.y = srcTransform.getOrigin().y();
-		newTransform.transform.translation.z = srcTransform.getOrigin().z();
-		newTransform.transform.rotation.x = srcTransform.getRotation().x();
-		newTransform.transform.rotation.y = srcTransform.getRotation().y();
-		newTransform.transform.rotation.z = srcTransform.getRotation().z();
-		newTransform.transform.rotation.w = srcTransform.getRotation().w();
-		tfretval.transforms.push_back (newTransform);
-
-		return tfretval;
-	}
-
-
-	tf::Transform getKeyFrameExtPose (const KeyFrame *kf)
-	{
-		tf::Transform Ext;
-
-		if (kf-&gt;extPosition.empty() or kf-&gt;extOrientation.empty()) {
-			Ext.setOrigin(tf::Vector3(NAN, NAN, NAN));
-			Ext.setRotation(tf::Quaternion(NAN, NAN, NAN, NAN));
-		}
-
-		else {
-			Ext.setOrigin (tf::Vector3(
-				kf-&gt;extPosition.at&lt;double&gt;(0),
-				kf-&gt;extPosition.at&lt;double&gt;(1),
-				kf-&gt;extPosition.at&lt;double&gt;(2) ));
-			Ext.setRotation(tf::Quaternion(
-				kf-&gt;extOrientation.at&lt;double&gt;(0),
-				kf-&gt;extOrientation.at&lt;double&gt;(1),
-				kf-&gt;extOrientation.at&lt;double&gt;(2),
-				kf-&gt;extOrientation.at&lt;double&gt;(3) ));
-		}
-		return Ext;
-	}
-
-
-	tf::Transform KeyFramePoseToTf (KeyFrame *kf)
-	{
-		tf::Transform kfpose;
-
-		cv::Mat t = kf-&gt;GetCameraCenter();
-		cv::Mat orient = kf-&gt;GetRotation().t();
-		vector&lt;float&gt; q = ORB_SLAM2::Converter::toQuaternion(orient);
-
-		kfpose.setOrigin(tf::Vector3(t.at&lt;float&gt;(0), t.at&lt;float&gt;(1), t.at&lt;float&gt;(2)));
-		kfpose.setRotation(tf::Quaternion(q[0], q[1], q[2], q[3]));
-
-		return kfpose;
-	}
-
-
-	cv::Vec3d tfToCv (const tf::Vector3 &amp;pos)
-	{
-		cv::Vec3d cvVec;
-		cvVec[0] = pos.x();
-		cvVec[1] = pos.y();
-		cvVec[2] = pos.z();
-		return cvVec;
-	}
-
-
-	cv::Mat tfToCv (const tf::Transform &amp;tfsrc)
-	{
-		cv::Mat rtval = cv::Mat::eye(4,4, CV_32F);
-		rtval.rowRange(0, 3).col(3).at&lt;float&gt;(0) = tfsrc.getOrigin().x();
-		rtval.rowRange(0, 3).col(3).at&lt;float&gt;(1) = tfsrc.getOrigin().y();
-		rtval.rowRange(0, 3).col(3).at&lt;float&gt;(2) = tfsrc.getOrigin().z();
-
-		tf::Matrix3x3 rot (tfsrc.getRotation());
-		for (int i=0; i&lt;3; i++) {
-			for (int j=0; j&lt;3; j++) {
-				rtval.at&lt;float&gt;(i,j) = rot[i][j];
-			}
-		}
-		return rtval;
-	}
-
-
-	void publishPose (const tf::Transform *pose)
-	{
-		geometry_msgs::PoseStamped gpose;
-		gpose.header.frame_id = externalFrameFixed;
-		gpose.header.stamp = ros::Time(lastImageTimestamp);
-
-		if (pose==NULL) {
-			gpose.pose.position.x =
-			gpose.pose.position.y =
-			gpose.pose.position.z = 1e15;
-			gpose.pose.orientation.x = 1.0;
-			gpose.pose.orientation.y = .0;
-			gpose.pose.orientation.z = .0;
-			gpose.pose.orientation.w = .0;
-		}
-
-		else {
-			gpose.pose.position.x = pose-&gt;getOrigin().x();
-			gpose.pose.position.y = pose-&gt;getOrigin().y();
-			gpose.pose.position.z = pose-&gt;getOrigin().z();
-			gpose.pose.orientation.x = pose-&gt;getRotation().x();
-			gpose.pose.orientation.y = pose-&gt;getRotation().y();
-			gpose.pose.orientation.z = pose-&gt;getRotation().z();
-			gpose.pose.orientation.w = pose-&gt;getRotation().w();
-			mTfBr-&gt;sendTransform (tf::StampedTransform(*pose, ros::Time(lastImageTimestamp), externalFrameFixed, externalFrameMoving));
-		}
-
-		posePublisher.publish (gpose);
-	}
-
-
-	void publishPoseWithCovariance (const tf::Transform *pose)
-	{
-		geometry_msgs::PoseWithCovarianceStamped gpose;
-		gpose.header.frame_id = externalFrameFixed;
-		gpose.header.stamp = ros::Time(lastImageTimestamp);
-
-		// XXX: check how we can set the covariance
-
-		if (pose==NULL) {
-			gpose.pose.pose.position.x =
-			gpose.pose.pose.position.y =
-			gpose.pose.pose.position.z = 1e15;
-			gpose.pose.pose.orientation.x = 1.0;
-			gpose.pose.pose.orientation.y = .0;
-			gpose.pose.pose.orientation.z = .0;
-			gpose.pose.pose.orientation.w = .0;
-		}
-
-		else {
-			gpose.pose.pose.position.x = pose-&gt;getOrigin().x();
-			gpose.pose.pose.position.y = pose-&gt;getOrigin().y();
-			gpose.pose.pose.position.z = pose-&gt;getOrigin().z();
-			gpose.pose.pose.orientation.x = pose-&gt;getRotation().x();
-			gpose.pose.pose.orientation.y = pose-&gt;getRotation().y();
-			gpose.pose.pose.orientation.z = pose-&gt;getRotation().z();
-			gpose.pose.pose.orientation.w = pose-&gt;getRotation().w();
-
-			tf::StampedTransform tfMsg;
-			tfMsg.stamp_ = ros::Time(lastImageTimestamp);
-			tfMsg.frame_id_ = externalFrameFixed;
-			tfMsg.child_frame_id_ = externalFrameMoving;
-			tfMsg.setData(*pose);
-			mTfBr-&gt;sendTransform(tfMsg);
-		}
-
-		posePublisher.publish(gpose);
-	}
-
-
-/*
- * Variable members
  */
-private:
-	tf::StampedTransform extPose;
 
-	ros::NodeHandle &amp;rosnode;
-	ORB_SLAM2::System &amp;SLAMSystem;
-	ros::Publisher posePublisher;
-	tf::TransformBroadcaster *mTfBr;
-
-	// Debug
-	image_transport::Publisher visualDebugView;
-
-	string externalFrameFixed;
-	string externalFrameMoving;
-
-	double lastImageTimestamp;
-	bool gotFirstFrame;
-
-	// Logging
-	uint32_t lastKeyframeId;
-	int offsetKeyframe;
-
-public:
-	image_transport::TransportHints th;
-	image_transport::ImageTransport *imageBuf;
-	image_transport::Subscriber imageSub;
-
-};
 
+#include &lt;iostream&gt;
+#include "Matcher.h"
 
 
 
 int main (int argc, char *argv[])
 {
-//	const string mapPath = (argc==3) ? argv[2] : string();
-	const string orbVocabFile (ORB_SLAM_VOCABULARY);
-//	const string configFile = argv[1];
-
 	ros::init(argc, argv, "orb_matching", ros::init_options::AnonymousName);
 	ros::start();
 	ros::NodeHandle nodeHandler ("~");
 
-	string mapPath;
-	nodeHandler.getParam("map_file", mapPath);
-
-	string configFile;
-	nodeHandler.getParam("configuration_file", configFile);
-
-	ORB_SLAM2::System SLAM(orbVocabFile,
-		configFile,
-		ORB_SLAM2::System::MONOCULAR,
-		false,
-		mapPath,
-		System::LOCALIZATION);
-
-	ORB_Matcher Matcher (SLAM, nodeHandler);
-	string imageTopic;
-	nodeHandler.getParam("image_topic", imageTopic);
-	Matcher.imageSub = Matcher.imageBuf-&gt;subscribe (imageTopic, 1, &amp;ORB_Matcher::imageCallback, &amp;Matcher, Matcher.th);
-	cerr &lt;&lt; "ORB Localizer ready" &lt;&lt; endl;
+	Matcher orb_matching (nodeHandler);
 	ros::spin();
 
-	SLAM.Shutdown();
 	ros::shutdown();
-
-	return 0;
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\map_publisher.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\nodes\visualization\map_publisher.cc" added_lines="13" deleted_lines="26">
				<diff>@@ -16,8 +16,10 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;geometry_msgs/PoseArray.h&gt;
+#include &lt;tf/tf.h&gt;
+#include "../common.h"
 
-#include "../__nodes/ImageGrabber.h"
+//#include "../__nodes/ImageGrabber.h"
 
 
 using namespace std;
@@ -156,43 +158,28 @@ protected:
 
 		for (KeyFrame *keyframe: keyFrameList) {
 
-			float qdir[4];
-
-			cv::Mat Tcw, Twc, ow,
-				p1w, p2w, p3w, p4w;
+			tf::Transform keyframePose;
 
 			if (pubMode==ORB_COORD) {
-				tf::Transform kfOrbPose = ImageGrabber::KeyFramePoseToTf(keyframe);
-				cv::Mat kfPose = ImageGrabber::tfToCv(kfOrbPose);
-				ow = kfPose.rowRange(0, 3).col(3);
-				qdir[0] = kfOrbPose.getRotation().x();
-				qdir[1] = kfOrbPose.getRotation().y();
-				qdir[2] = kfOrbPose.getRotation().z();
-				qdir[3] = kfOrbPose.getRotation().w();
+				keyframePose = KeyFramePoseToTf (keyframe);
 			}
 
 			else {
 				if (keyframe-&gt;extPosition.empty())
 					continue;
-				tf::Transform kfExtPose = ImageGrabber::getKeyFrameExtPose(keyframe);
-				cv::Mat extPose = ImageGrabber::tfToCv(kfExtPose);
-				ow = extPose.rowRange(0, 3).col(3);
-				qdir[0] = kfExtPose.getRotation().x();
-				qdir[1] = kfExtPose.getRotation().y();
-				qdir[2] = kfExtPose.getRotation().z();
-				qdir[3] = kfExtPose.getRotation().w();
+				keyframePose = getKeyFrameExtPose (keyframe);
 			}
 
 			geometry_msgs::Point kfCenter;
 			geometry_msgs::Quaternion kfDirection;
 
-			kfCenter.x = ow.at&lt;float&gt;(0);
-			kfCenter.y = ow.at&lt;float&gt;(1);
-			kfCenter.z = ow.at&lt;float&gt;(2);
-			kfDirection.x = qdir[0];
-			kfDirection.y = qdir[1];
-			kfDirection.z = qdir[2];
-			kfDirection.w = qdir[3];
+			kfCenter.x = keyframePose.getOrigin().x();
+			kfCenter.y = keyframePose.getOrigin().y();
+			kfCenter.z = keyframePose.getOrigin().z();
+			kfDirection.x = keyframePose.getRotation().x();
+			kfDirection.y = keyframePose.getRotation().x();
+			kfDirection.z = keyframePose.getRotation().x();
+			kfDirection.w = keyframePose.getRotation().x();
 
 			geometry_msgs::Pose kfPose;
 			kfPose.position = kfCenter;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Converter.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Converter.cc" added_lines="2" deleted_lines="8">
				<diff>@@ -134,18 +134,12 @@ Eigen::Matrix&lt;double,3,3&gt; Converter::toMatrix3d(const cv::Mat &amp;cvMat3)
     return M;
 }
 
-std::vector&lt;float&gt; Converter::toQuaternion(const cv::Mat &amp;M)
+Eigen::Quaterniond Converter::toQuaternion(const cv::Mat &amp;M)
 {
     Eigen::Matrix&lt;double,3,3&gt; eigMat = toMatrix3d(M);
     Eigen::Quaterniond q(eigMat);
 
-    std::vector&lt;float&gt; v(4);
-    v[0] = q.x();
-    v[1] = q.y();
-    v[2] = q.z();
-    v[3] = q.w();
-
-    return v;
+    return q;
 }
 
 } //namespace ORB_SLAM
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Frame.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Frame.cc" added_lines="29" deleted_lines="1">
				<diff>@@ -175,7 +175,8 @@ Frame::Frame(const cv::Mat &amp;imGray, const cv::Mat &amp;imDepth, const double &amp;timeSt
 Frame::Frame(const cv::Mat &amp;imGray, const double &amp;timeStamp, ORBextractor* extractor,ORBVocabulary* voc, cv::Mat &amp;K, cv::Mat &amp;distCoef, const float &amp;bf, const float &amp;thDepth)
     :mpORBvocabulary(voc),mpORBextractorLeft(extractor),mpORBextractorRight(static_cast&lt;ORBextractor*&gt;(NULL)),
      mTimeStamp(timeStamp), mK(K.clone()),mDistCoef(distCoef.clone()), mbf(bf), mThDepth(thDepth),
-	 mpReferenceKF(NULL)
+	 mpReferenceKF(NULL),
+	 image (imGray)
 {
     // Frame ID
     mnId=nNextId++;
@@ -682,7 +683,34 @@ cv::Mat Frame::UnprojectStereo(const int &amp;i)
 
 void Frame::getDirectionVector (float &amp;dirX, float &amp;dirY, float &amp;dirZ)
 {
+	cv::Mat orient = this-&gt;mTcw.t();
+	dirX = orient.at&lt;float&gt;(0,2);
+	dirY = orient.at&lt;float&gt;(1,2);
+	dirZ = orient.at&lt;float&gt;(2,2);
+	float norm = sqrtf(dirX*dirX + dirY*dirY + dirZ*dirZ);
+	dirX /= norm;
+	dirY /= norm;
+	dirZ /= norm;
+}
+
 
+const string frameDebugImage ("frame.jpg");
+
+void Frame::debug (const string &amp;dirname)
+{
+	const string imageFilename = dirname + "/" + frameDebugImage ;
+
+	cv::Mat dbgImage = this-&gt;image.clone();
+	if (dbgImage.channels()&lt;3)
+		cv::cvtColor (dbgImage, dbgImage, CV_GRAY2BGR);
+
+	const int size = 3;
+	for (int i=0; i&lt;mvKeys.size(); i++) {
+		cv::circle (dbgImage, mvKeys[i].pt, size, cv::Scalar(0,255,0), -1);
+	}
+
+	cv::imwrite (imageFilename, dbgImage);
 }
 
+
 } //namespace ORB_SLAM
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\FrameDrawer.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\FrameDrawer.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -119,9 +119,9 @@ cv::Mat FrameDrawer::DrawFrame()
     }
 
     // Put ORB points in frame
-	for (auto &amp;kp: vCurrentKeys) {
-		cv::circle (workingFrame, kp.pt, 1, cv::Scalar(255,0,0),-1);
-	}
+//	for (auto &amp;kp: vCurrentKeys) {
+//		cv::circle (workingFrame, kp.pt, 1, cv::Scalar(255,0,0),-1);
+//	}
 
     cv::Mat imWithInfo;
     DrawTextInfo(workingFrame,state, imWithInfo);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\KeyFrame.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\KeyFrame.cc" added_lines="23" deleted_lines="5">
				<diff>@@ -83,6 +83,17 @@ void KeyFrame::ComputeBoW()
     }
 }
 
+
+void KeyFrame::RecomputeBoW (ORBVocabulary *newvoc)
+{
+	mpORBvocabulary = newvoc;
+	mBowVec.clear();
+	mFeatVec.clear();
+	vector&lt;cv::Mat&gt; vCurrentDesc = Converter::toDescriptorVector(mDescriptors);
+	mpORBvocabulary-&gt;transform (vCurrentDesc, mBowVec, mFeatVec, 4);
+}
+
+
 void KeyFrame::SetPose(const cv::Mat &amp;Tcw_)
 {
     unique_lock&lt;mutex&gt; lock(mMutexPose);
@@ -730,11 +741,18 @@ void KeyFrame::fixConnections (Map *smap, KeyFrameDatabase *kfdb)
 void KeyFrame::getDirectionVector (float &amp;dirX, float &amp;dirY, float &amp;dirZ)
 {
 	cv::Mat orient = this-&gt;GetRotation().t();
-	vector&lt;float&gt; q = ORB_SLAM2::Converter::toQuaternion(orient);
-	float norm = sqrtf(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
-	dirX = q[0]/norm;
-	dirY = q[1]/norm;
-	dirZ = q[2]/norm;
+//	Eigen::Quaterniond q = ORB_SLAM2::Converter::toQuaternion(orient);
+//	float norm = sqrtf(q.x()*q.x() + q.y()*q.y() + q.z()*q.z());
+//	dirX = q.x()/norm;
+//	dirY = q.y()/norm;
+//	dirZ = q.z()/norm;
+	dirX = orient.at&lt;float&gt;(0,2);
+	dirY = orient.at&lt;float&gt;(1,2);
+	dirZ = orient.at&lt;float&gt;(2,2);
+	float norm = sqrtf(dirX*dirX + dirY*dirY + dirZ*dirZ);
+	dirX /= norm;
+	dirY /= norm;
+	dirZ /= norm;
 }
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\KeyFrameDatabase.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\KeyFrameDatabase.cc" added_lines="52" deleted_lines="2">
				<diff>@@ -21,6 +21,8 @@
 #include "KeyFrame.h"
 #include "KeyFrameDatabase.h"
 #include "DBoW2/BowVector.h"
+#include "Map.h"
+
 
 #include&lt;mutex&gt;
 
@@ -29,7 +31,7 @@ using namespace std;
 namespace ORB_SLAM2
 {
 
-KeyFrameDatabase::KeyFrameDatabase (const ORBVocabulary &amp;voc):
+KeyFrameDatabase::KeyFrameDatabase (ORBVocabulary &amp;voc):
     mpVoc(&amp;voc)
 {
     mvInvertedFile.resize(voc.size());
@@ -195,6 +197,38 @@ vector&lt;KeyFrame*&gt; KeyFrameDatabase::DetectLoopCandidates(KeyFrame* pKF, float mi
     return vpLoopCandidates;
 }
 
+
+vector&lt;KeyFrame*&gt; KeyFrameDatabase::DetectRelocalizationCandidatesSimple (Frame *F)
+{
+	vector&lt;KeyFrame*&gt; lKFsSharingWords;
+
+	for (auto &amp;wId: F-&gt;mBowVec) {
+		list&lt;KeyFrame*&gt; &amp;lKFs = mvInvertedFile[wId.first];
+		for (auto &amp;kfp: lKFs) {
+			lKFsSharingWords.push_back (kfp);
+		}
+	}
+
+	if (lKFsSharingWords.empty())
+		return vector&lt;KeyFrame*&gt; ();
+
+	// XXX: Bad decision
+	float s = 0;
+	KeyFrame *kfchk = NULL;
+	for (auto kf: lKFsSharingWords) {
+		float si = mpVoc-&gt;score (kf-&gt;mBowVec, F-&gt;mBowVec);
+		if (si &gt; s) {
+			s = si;
+			kfchk = kf;
+		}
+	}
+
+	vector&lt;KeyFrame*&gt; ret;
+	ret.push_back (kfchk);
+	return ret;
+}
+
+
 vector&lt;KeyFrame*&gt; KeyFrameDatabase::DetectRelocalizationCandidates(Frame *F)
 {
     list&lt;KeyFrame*&gt; lKFsSharingWords;
@@ -285,7 +319,7 @@ vector&lt;KeyFrame*&gt; KeyFrameDatabase::DetectRelocalizationCandidates(Frame *F)
             bestAccScore=accScore;
     }
 
-    // Return all those keyframes with a score higher than 0.75*bestScore
+    // Return all keyframes with a score higher than 0.75*bestScore
     float minScoreToRetain = 0.75f*bestAccScore;
     set&lt;KeyFrame*&gt; spAlreadyAddedKF;
     vector&lt;KeyFrame*&gt; vpRelocCandidates;
@@ -307,4 +341,20 @@ vector&lt;KeyFrame*&gt; KeyFrameDatabase::DetectRelocalizationCandidates(Frame *F)
     return vpRelocCandidates;
 }
 
+
+void KeyFrameDatabase::replaceVocabulary (ORBVocabulary *newvoc, Map *cmap)
+{
+	mpVoc = newvoc;
+	mvInvertedFile.clear ();
+
+	vector&lt;KeyFrame*&gt; kfList = cmap-&gt;GetAllKeyFrames();
+	mvInvertedFile.resize (kfList.size());
+
+	for (auto kf: kfList) {
+		this-&gt;add (kf);
+		kf-&gt;RecomputeBoW (newvoc);
+	}
+}
+
+
 } //namespace ORB_SLAM
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\LocalMapping.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\LocalMapping.cc" added_lines="4" deleted_lines="10">
				<diff>@@ -30,9 +30,10 @@
 namespace ORB_SLAM2
 {
 
-LocalMapping::LocalMapping(Map *pMap, const float bMonocular):
+LocalMapping::LocalMapping(Map *pMap, const float bMonocular, const bool offlineMode):
     mbMonocular(bMonocular), mbResetRequested(false), mbFinishRequested(false), mbFinished(true), mpMap(pMap),
-    mbAbortBA(false), mbStopped(false), mbStopRequested(false), mbNotStop(false), mbAcceptKeyFrames(true)
+    mbAbortBA(false), mbStopped(false), mbStopRequested(false), mbNotStop(false), mbAcceptKeyFrames(true),
+	offlineMapping (offlineMode)
 {
 }
 
@@ -126,8 +127,6 @@ void LocalMapping::Run()
 
 void LocalMapping::RunOnce()
 {
-    mbFinished = false;
-
 	// Check if there are keyframes in the queue
 	if(CheckNewKeyFrames())
 	{
@@ -148,7 +147,7 @@ void LocalMapping::RunOnce()
 
 		mbAbortBA = false;
 
-		if(!CheckNewKeyFrames() &amp;&amp; !stopRequested())
+		if(!CheckNewKeyFrames())
 		{
 			// Local BA
 			if(mpMap-&gt;KeyFramesInMap()&gt;2)
@@ -160,11 +159,6 @@ void LocalMapping::RunOnce()
 
 		mpLoopCloser-&gt;InsertKeyFrame(mpCurrentKeyFrame);
 	}
-
-	// Tracking will see that Local Mapping is busy
-	SetAcceptKeyFrames(true);
-
-    SetFinish();
 }
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\LoopClosing.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\LoopClosing.cc" added_lines="17" deleted_lines="11">
				<diff>@@ -35,10 +35,11 @@
 namespace ORB_SLAM2
 {
 
-LoopClosing::LoopClosing(Map *pMap, KeyFrameDatabase *pDB, ORBVocabulary *pVoc, const bool bFixScale):
+LoopClosing::LoopClosing(Map *pMap, KeyFrameDatabase *pDB, ORBVocabulary *pVoc, const bool bFixScale, const bool offlineMode):
     mbResetRequested(false), mbFinishRequested(false), mbFinished(true), mpMap(pMap),
     mpKeyFrameDB(pDB), mpORBVocabulary(pVoc), mLastLoopKFid(0), mbRunningGBA(false), mbFinishedGBA(true),
-    mbStopGBA(false), mbFixScale(bFixScale)
+    mbStopGBA(false), mbFixScale(bFixScale),
+	offlineMapping (offlineMode)
 {
     mnCovisibilityConsistencyTh = 3;
     mpMatchedKF = NULL;
@@ -434,7 +435,8 @@ void LoopClosing::CorrectLoop()
 
     // Send a stop signal to Local Mapping
     // Avoid new keyframes are inserted while correcting the loop
-    mpLocalMapper-&gt;RequestStop();
+    if (offlineMapping==false)
+    	mpLocalMapper-&gt;RequestStop();
 
     // If a Global Bundle Adjustment is running, abort it
     if(isRunningGBA())
@@ -449,9 +451,11 @@ void LoopClosing::CorrectLoop()
     }
 
     // Wait until Local Mapping has effectively stopped
-    while(!mpLocalMapper-&gt;isStopped())
-    {
-        usleep(1000);
+    if (offlineMapping==false) {
+		while(!mpLocalMapper-&gt;isStopped())
+		{
+			usleep(1000);
+		}
     }
 
     // Ensure current keyframe is updated
@@ -690,12 +694,14 @@ void LoopClosing::RunGlobalBundleAdjustment(unsigned long nLoopKF)
         {
             cout &lt;&lt; "Global Bundle Adjustment finished" &lt;&lt; endl;
             cout &lt;&lt; "Updating map ..." &lt;&lt; endl;
-            mpLocalMapper-&gt;RequestStop();
-            // Wait until Local Mapping has effectively stopped
 
-            while(!mpLocalMapper-&gt;isStopped() &amp;&amp; !mpLocalMapper-&gt;isFinished())
-            {
-                usleep(1000);
+            if (offlineMapping==false) {
+            	mpLocalMapper-&gt;RequestStop();
+            // Wait until Local Mapping has effectively stopped
+				while(!mpLocalMapper-&gt;isStopped() &amp;&amp; !mpLocalMapper-&gt;isFinished())
+				{
+					usleep(1000);
+				}
             }
 
             // Get Map Mutex
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Map.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Map.cc" added_lines="119" deleted_lines="18">
				<diff>@@ -20,8 +20,10 @@
 
 #include "Map.h"
 #include "KeyFrame.h"
+#include "Frame.h"
 #include "MapPoint.h"
 #include "KeyFrameDatabase.h"
+#include "ORBVocabulary.h"
 #include &lt;mutex&gt;
 #include &lt;cstdio&gt;
 #include &lt;exception&gt;
@@ -29,12 +31,24 @@
 
 #include &lt;boost/archive/binary_oarchive.hpp&gt;
 #include &lt;boost/archive/binary_iarchive.hpp&gt;
+#include &lt;boost/filesystem.hpp&gt;
 #include "MapObjectSerialization.h"
 
 
 using std::string;
 
 
+template&lt;class T&gt;
+vector&lt;T&gt; set2vector (const set&lt;T&gt; &amp;st)
+{
+	vector&lt;T&gt; rt;
+	for (auto &amp;smember: st) {
+		rt.push_back(smember);
+	}
+	return rt;
+}
+
+
 namespace ORB_SLAM2
 {
 
@@ -146,8 +160,7 @@ KeyFrame* Map::offsetKeyframe (KeyFrame* kfSrc, int offset)
 
 const char *signature = "ORBSLAM";
 
-
-void Map::saveToDisk(const string &amp;filename, KeyFrameDatabase *keyframeDatabase)
+void Map::saveToDisk(const string &amp;mapfilename, KeyFrameDatabase *keyframeDatabase)
 {
 	MapFileHeader header;
 	memcpy (header.signature, signature, sizeof(header.signature));
@@ -156,7 +169,7 @@ void Map::saveToDisk(const string &amp;filename, KeyFrameDatabase *keyframeDatabase)
 	header.numOfReferencePoint = this-&gt;mvpReferenceMapPoints.size();
 
 	fstream mapFileFd;
-	mapFileFd.open(filename.c_str(), fstream::out | fstream::trunc);
+	mapFileFd.open(mapfilename.c_str(), fstream::out | fstream::trunc);
 	if (!mapFileFd.is_open())
 		throw MapFileException();
 	mapFileFd.write ((const char*)&amp;header, sizeof(header));
@@ -165,6 +178,13 @@ void Map::saveToDisk(const string &amp;filename, KeyFrameDatabase *keyframeDatabase)
 
 	boost::archive::binary_oarchive mapArchive (mapFileFd);
 
+	// Create new vocabulary
+	cout &lt;&lt; "Creating new vocabulary... ";
+	ORBVocabulary mapVoc(10, 6);
+	extractVocabulary (&amp;mapVoc);
+	keyframeDatabase-&gt;replaceVocabulary(&amp;mapVoc, this);
+	cout &lt;&lt; "Done\n";
+
 	int p = 0;
 	for (set&lt;KeyFrame*&gt;::const_iterator kfit=mspKeyFrames.begin(); kfit!=mspKeyFrames.end(); kfit++) {
 		const KeyFrame *kf = *kfit;
@@ -172,11 +192,13 @@ void Map::saveToDisk(const string &amp;filename, KeyFrameDatabase *keyframeDatabase)
 			cerr &lt;&lt; endl &lt;&lt; "NULL KF found" &lt;&lt; endl;
 			continue;
 		}
+
 		mapArchive &lt;&lt; *kf;
 		cout &lt;&lt; "Keyframes: " &lt;&lt; ++p &lt;&lt; "/" &lt;&lt; mspKeyFrames.size() &lt;&lt; "\r";
 	}
 	cout &lt;&lt; endl;
 
+	p = 0;
 	for (set&lt;MapPoint*&gt;::iterator mpit=mspMapPoints.begin(); mpit!=mspMapPoints.end(); mpit++) {
 		const MapPoint *mp = *mpit;
 		if (mp==NULL) {
@@ -184,14 +206,22 @@ void Map::saveToDisk(const string &amp;filename, KeyFrameDatabase *keyframeDatabase)
 			continue;
 		}
 		mapArchive &lt;&lt; *mp;
+		cout &lt;&lt; "Map Points: " &lt;&lt; ++p &lt;&lt; "/" &lt;&lt; mspMapPoints.size() &lt;&lt; "\r";
 	}
+	cout &lt;&lt; endl;
 
 	vector&lt;idtype&gt; vmvpReferenceMapPoints = createIdList (mvpReferenceMapPoints);
 	mapArchive &lt;&lt; vmvpReferenceMapPoints;
 
 	mapArchive &lt;&lt; *keyframeDatabase;
-
 	mapFileFd.close();
+
+	cout &lt;&lt; "Saving vocabulary... ";
+	boost::filesystem::path mapPath (mapfilename);
+	boost::filesystem::path mapDir = mapPath.parent_path();
+	string mapVocab = mapPath.string() + ".voc";
+	mapVoc.saveToTextFile (mapVocab);
+	cout &lt;&lt; "Done\n";
 }
 
 
@@ -214,7 +244,7 @@ void Map::loadFromDisk(const string &amp;filename, KeyFrameDatabase *kfMemDb)
 		throw BadMapFile();
 	mapFileFd.read ((char*)&amp;header, sizeof(header));
 
-	if (strcmp(header.signature, signature) !=0)
+	if (strncmp(header.signature, signature, sizeof(signature)-1) !=0)
 		throw BadMapFile();
 	cout &lt;&lt; "Keyframes: " &lt;&lt; header.numOfKeyFrame &lt;&lt; ", MapPoint: " &lt;&lt; header.numOfMapPoint &lt;&lt; endl;
 
@@ -227,6 +257,12 @@ void Map::loadFromDisk(const string &amp;filename, KeyFrameDatabase *kfMemDb)
 			mspKeyFrames.insert (kf);
 		kfListSorted.push_back(kf);
 
+//		const cv::Mat camCenter = kf-&gt;GetCameraCenter();
+//		const float
+//			x = camCenter.at&lt;float&gt;(0),
+//			y = camCenter.at&lt;float&gt;(1),
+//			z = camCenter.at&lt;float&gt;(2);
+
 		// XXX: Need to increase KeyFrame::nNextId
 		// Also, adjust Frame::nNextId
 		if (kf-&gt;mnId &gt; KeyFrame::nNextId) {
@@ -304,42 +340,107 @@ void Map::loadFromDisk(const string &amp;filename, KeyFrameDatabase *kfMemDb)
 	kfOctree = pcl::octree::OctreePointCloudSearch&lt;KeyFramePt&gt;::Ptr (new pcl::octree::OctreePointCloudSearch&lt;KeyFramePt&gt; (MapOctreeResolution));
 	kfOctree-&gt;setInputCloud(kfCloud);
 	kfOctree-&gt;addPointsFromInputCloud();
+	mKeyFrameDb = kfMemDb;
 //	cout &lt;&lt; "Done restoring Octree" &lt;&lt; endl;
 }
 
 
 // we expect direction vector has been normalized,
 // as returned by Frame::getDirectionVector()
-KeyFrame* Map::getNearestKeyFrame (const float &amp;x, const float &amp;y, const float &amp;z,
-	const float fdir_x, const float fdir_y, const float fdir_z)
+//KeyFrame* Map::getNearestKeyFrame (const float &amp;x, const float &amp;y, const float &amp;z,
+//	const float fdir_x, const float fdir_y, const float fdir_z,
+//	vector&lt;KeyFrame*&gt; *kfSelectors)
+KeyFrame*
+Map::getNearestKeyFrame (const Eigen::Vector3f &amp;position,
+	const Eigen::Quaternionf &amp;orientation,
+	vector&lt;KeyFrame*&gt; *kfSelectors
+)
 {
 	KeyFramePt queryPoint;
-	queryPoint.x = x, queryPoint.y = y, queryPoint.z = z;
+	queryPoint.x = position.x(), queryPoint.y = position.y(), queryPoint.z = position.z();
 
-	const int k = 10;
+	const int k = 15;
 	vector&lt;int&gt; idcs;
 	vector&lt;float&gt; sqrDist;
 	idcs.resize(k);
 	sqrDist.resize(k);
 
 	int r = kfOctree-&gt;nearestKSearch(queryPoint, k, idcs, sqrDist);
-	if (r==0)
+	if (r==0) {
+		cerr &lt;&lt; "*\n";
 		return NULL;
+	}
+
+	Eigen::Matrix3f mOrient = orientation.toRotationMatrix();
+	float
+		fdir_x = mOrient(0,2),
+		fdir_y = mOrient(1,2),
+		fdir_z = mOrient(2,2);
 
+	float cosd = 0;
+	KeyFrame *ckf = NULL;
+	int i = 0;
 	for (auto ip: idcs) {
+
 		float dirx, diry, dirz, cosT;
-		KeyFrame *ckf = kfCloud-&gt;at(ip).kf;
-		ckf-&gt;getDirectionVector(dirx, diry, dirz);
-		cosT = dirx*fdir_x + diry*fdir_y + dirz*fdir_z;
-		if (cosT &lt;= 0.86)
+		KeyFrame *checkKF = kfCloud-&gt;at(ip).kf;
+
+		// get direction vector
+		cv::Mat orient = checkKF-&gt;GetRotation().t();
+		dirx = orient.at&lt;float&gt;(0,2);
+		diry = orient.at&lt;float&gt;(1,2);
+		dirz = orient.at&lt;float&gt;(2,2);
+		float norm = sqrtf(dirx*dirx + diry*diry + dirz*dirz);
+		dirx /= norm;
+		diry /= norm;
+		dirz /= norm;
+
+		cosT = (dirx*fdir_x + diry*fdir_y + dirz*fdir_z) / (sqrtf(fdir_x*fdir_x + fdir_y*fdir_y + fdir_z*fdir_z) * sqrtf(dirx*dirx + diry*diry + dirz*dirz));
+
+		if (cosT &lt; 0)
 			continue;
 		else
-			return ckf;
+			return checkKF;
+//		if (cosT &gt; cosd) {
+//			cosd = cosT;
+//			ckf = checkKF;
+//		}
+//		if (kfSelectors!=NULL)
+//			kfSelectors-&gt;at(i) = checkKF;
+//		i+=1;
+	}
+
+	return ckf;
+}
+
+
+void Map::extractVocabulary (ORBVocabulary *mapVoc)
+{
+	vector&lt;vector&lt;DBoW2::FORB::TDescriptor&gt; &gt; keymapFeatures;
+	keymapFeatures.reserve (mspKeyFrames.size());
+
+	vector&lt;KeyFrame*&gt; allKeyFrames = GetAllKeyFrames();
+	fprintf (stderr, "KF: %d\n", allKeyFrames.size());
+
+	for (vector&lt;KeyFrame*&gt;::const_iterator it=allKeyFrames.begin(); it!=allKeyFrames.end(); it++) {
+
+		KeyFrame *kf = *it;
+		vector&lt;cv::Mat&gt; kfDescriptor;
+
+		// take map points that are belong to this keyframe
+		set&lt;MapPoint*&gt; mapSet = kf-&gt;GetMapPoints();
+		vector&lt;MapPoint*&gt; mapPointList = set2vector(mapSet);
+
+		// for each map points, pick best descriptor and add to descriptors of this keyframe
+		for (auto &amp;mpp: mapPointList) {
+			cv::Mat mpDescriptor = mpp-&gt;GetDescriptor();
+			kfDescriptor.push_back(mpDescriptor);
+		}
+
+		keymapFeatures.push_back (kfDescriptor);
 	}
 
-	return NULL;
-//	KeyFrame *kfn = kfCloud-&gt;at(idcs[0]).kf;
-//	return kfn;
+	mapVoc-&gt;create (keymapFeatures);
 }
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Optimizer.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Optimizer.cc" added_lines="7" deleted_lines="6">
				<diff>@@ -18,6 +18,7 @@
 * along with ORB-SLAM2. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
 
+#include "Map.h"
 #include "Optimizer.h"
 
 #include "g2o/core/block_solver.h"
@@ -233,7 +234,6 @@ void Optimizer::BundleAdjustment(const vector&lt;KeyFrame *&gt; &amp;vpKFs, const vector&lt;M
             pMP-&gt;mnBAGlobalForKF = nLoopKF;
         }
     }
-
 }
 
 
@@ -451,7 +451,7 @@ int Optimizer::PoseOptimization(Frame *pFrame)
 
 
 void Optimizer::LocalBundleAdjustment(KeyFrame *pKF, bool* pbStopFlag, Map* pMap)
-{    
+{
     // Local KeyFrames: First Breath Search from Current Keyframe
     list&lt;KeyFrame*&gt; lLocalKeyFrames;
 
@@ -495,7 +495,7 @@ void Optimizer::LocalBundleAdjustment(KeyFrame *pKF, bool* pbStopFlag, Map* pMap
             KeyFrame* pKFi = mit-&gt;first;
 
             if(pKFi-&gt;mnBALocalForKF!=pKF-&gt;mnId &amp;&amp; pKFi-&gt;mnBAFixedForKF!=pKF-&gt;mnId)
-            {                
+            {
                 pKFi-&gt;mnBAFixedForKF=pKF-&gt;mnId;
                 if(!pKFi-&gt;isBad())
                     lFixedCameras.push_back(pKFi);
@@ -587,7 +587,7 @@ void Optimizer::LocalBundleAdjustment(KeyFrame *pKF, bool* pbStopFlag, Map* pMap
             KeyFrame* pKFi = mit-&gt;first;
 
             if(!pKFi-&gt;isBad())
-            {                
+            {
                 const cv::KeyPoint &amp;kpUn = pKFi-&gt;mvKeysUn[mit-&gt;second];
 
                 // Monocular observation
@@ -711,7 +711,7 @@ void Optimizer::LocalBundleAdjustment(KeyFrame *pKF, bool* pbStopFlag, Map* pMap
     vector&lt;pair&lt;KeyFrame*,MapPoint*&gt; &gt; vToErase;
     vToErase.reserve(vpEdgesMono.size()+vpEdgesStereo.size());
 
-    // Check inlier observations       
+    // Check inlier observations
     for(size_t i=0, iend=vpEdgesMono.size(); i&lt;iend;i++)
     {
         g2o::EdgeSE3ProjectXYZ* e = vpEdgesMono[i];
@@ -783,7 +783,7 @@ void Optimizer::OptimizeEssentialGraph(Map* pMap, KeyFrame* pLoopKF, KeyFrame* p
                                        const LoopClosing::KeyFrameAndPose &amp;CorrectedSim3,
                                        const map&lt;KeyFrame *, set&lt;KeyFrame *&gt; &gt; &amp;LoopConnections, const bool &amp;bFixScale)
 {
-    // Setup optimizer
+//     Setup optimizer
     g2o::SparseOptimizer optimizer;
     optimizer.setVerbose(false);
     g2o::BlockSolver_7_3::LinearSolverType * linearSolver =
@@ -1043,6 +1043,7 @@ void Optimizer::OptimizeEssentialGraph(Map* pMap, KeyFrame* pLoopKF, KeyFrame* p
     }
 }
 
+
 int Optimizer::OptimizeSim3(KeyFrame *pKF1, KeyFrame *pKF2, vector&lt;MapPoint *&gt; &amp;vpMatches1, g2o::Sim3 &amp;g2oS12, const float th2, const bool bFixScale)
 {
     g2o::SparseOptimizer optimizer;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\System.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\System.cc" added_lines="121" deleted_lines="93">
				<diff>@@ -33,13 +33,15 @@ namespace ORB_SLAM2
 System::System(const string &amp;strVocFile, const string &amp;strSettingsFile, const eSensor sensor,
                const bool bUseViewer,
 			   const string &amp;mpMapFileName,
-			   const operationMode mode):
+			   const operationMode mode,
+			   bool doOfflineMapping):
 				mSensor(sensor),
 				mapFileName(mpMapFileName),
 				mbReset(false),
 				mbActivateLocalizationMode(false),
 				mbDeactivateLocalizationMode(false),
-				opMode (mode)
+				opMode (mode),
+				offlineMapping(doOfflineMapping)
 {
     // Output welcome message
     cout &lt;&lt; endl &lt;&lt;
@@ -66,10 +68,10 @@ System::System(const string &amp;strVocFile, const string &amp;strSettingsFile, const eS
     }
 
     //Load ORB Vocabulary
-    cout &lt;&lt; endl &lt;&lt; "Loading ORB Vocabulary. This could take a while..." &lt;&lt; endl;
 
     mpVocabulary = new ORBVocabulary();
-    if (strVocFile.empty() == false) {
+    if (opMode==MAPPING and strVocFile.empty() == false) {
+    	cout &lt;&lt; endl &lt;&lt; "Loading Generic ORB Vocabulary..." &lt;&lt; endl;
 		bool bVocLoad = mpVocabulary-&gt;loadFromTextFile(strVocFile);
 		if(!bVocLoad)
 		{
@@ -79,6 +81,22 @@ System::System(const string &amp;strVocFile, const string &amp;strSettingsFile, const eS
 		}
 		cout &lt;&lt; "Vocabulary loaded!" &lt;&lt; endl &lt;&lt; endl;
     }
+    else {
+    	cout &lt;&lt; endl &lt;&lt; "Loading Custom ORB Vocabulary... " ;
+    	string mapVoc = mapFileName + ".voc";
+    	bool vocload = mpVocabulary-&gt;loadFromTextFile (mapVoc);
+		if(!vocload)
+		{
+			cerr &lt;&lt; "Failed. Falling back to generic... " &lt;&lt; endl;
+			vocload = mpVocabulary-&gt;loadFromTextFile (strVocFile);
+			if (vocload==false) {
+				cerr &lt;&lt; "Failed to open at: " &lt;&lt; strVocFile &lt;&lt; endl;
+				exit(-1);
+			}
+		}
+		cout &lt;&lt; "Vocabulary loaded!" &lt;&lt; endl &lt;&lt; endl;
+    }
+    fps = (float)fsSettings["Camera.fps"];
 
     //Create KeyFrame Database
     mpKeyFrameDatabase = new KeyFrameDatabase(*mpVocabulary);
@@ -103,16 +121,18 @@ System::System(const string &amp;strVocFile, const string &amp;strSettingsFile, const eS
     if (mpMap-&gt;mbMapUpdated)
     	mpTracker-&gt;setMapLoaded();
 
-    mpLocalMapper = new LocalMapping(mpMap, mSensor==MONOCULAR);
-    mpLoopCloser = new LoopClosing(mpMap, mpKeyFrameDatabase, mpVocabulary, mSensor!=MONOCULAR);
+    mpLocalMapper = new LocalMapping(mpMap, mSensor==MONOCULAR, offlineMapping);
+    mpLoopCloser = new LoopClosing(mpMap, mpKeyFrameDatabase, mpVocabulary, mSensor!=MONOCULAR, offlineMapping);
 
     if (opMode==System::MAPPING) {
 
-		//Initialize the Local Mapping thread and launch
-		mptLocalMapping = new thread(&amp;ORB_SLAM2::LocalMapping::Run,mpLocalMapper);
+    	if (offlineMapping==false) {
+			//Initialize the Local Mapping thread and launch
+			mptLocalMapping = new thread(&amp;ORB_SLAM2::LocalMapping::Run,mpLocalMapper);
 
-		//Initialize the Loop Closing thread and launch
-		mptLoopClosing = new thread(&amp;ORB_SLAM2::LoopClosing::Run, mpLoopCloser);
+			//Initialize the Loop Closing thread and launch
+			mptLoopClosing = new thread(&amp;ORB_SLAM2::LoopClosing::Run, mpLoopCloser);
+    	}
 
 	    mpLocalMapper-&gt;SetTracker(mpTracker);
 	    mpLocalMapper-&gt;SetLoopCloser(mpLoopCloser);
@@ -207,6 +227,14 @@ cv::Mat System::TrackMonocular(const cv::Mat &amp;im, const double &amp;timestamp)
     }
 
     cv::Mat camPosOrb = mpTracker-&gt;GrabImageMonocular(im,timestamp);
+
+    if (offlineMapping==true) {
+    	int ifps = (int)fps;
+    	mpLocalMapper-&gt;RunOnce();
+    	if (mpTracker-&gt;mCurrentFrame.mnId % ifps == 0)
+    		mpLoopCloser-&gt;RunOnce();
+    }
+
     return camPosOrb;
 }
 
@@ -250,94 +278,94 @@ void System::Shutdown()
 
 void System::SaveTrajectoryTUM(const string &amp;filename)
 {
-    cout &lt;&lt; endl &lt;&lt; "Saving camera trajectory to " &lt;&lt; filename &lt;&lt; " ..." &lt;&lt; endl;
-
-    vector&lt;KeyFrame*&gt; vpKFs = mpMap-&gt;GetAllKeyFrames();
-    sort(vpKFs.begin(),vpKFs.end(),KeyFrame::lId);
-
-    // Transform all keyframes so that the first keyframe is at the origin.
-    // After a loop closure the first keyframe might not be at the origin.
-    cv::Mat Two = vpKFs[0]-&gt;GetPoseInverse();
-
-    ofstream f;
-    f.open(filename.c_str());
-    f &lt;&lt; fixed;
-
-    // Frame pose is stored relative to its reference keyframe (which is optimized by BA and pose graph).
-    // We need to get first the keyframe pose and then concatenate the relative transformation.
-    // Frames not localized (tracking failure) are not saved.
-
-    // For each frame we have a reference keyframe (lRit), the timestamp (lT) and a flag
-    // which is true when tracking failed (lbL).
-    list&lt;ORB_SLAM2::KeyFrame*&gt;::iterator lRit = mpTracker-&gt;mlpReferences.begin();
-    list&lt;double&gt;::iterator lT = mpTracker-&gt;mlFrameTimes.begin();
-    list&lt;bool&gt;::iterator lbL = mpTracker-&gt;mlbLost.begin();
-    for(list&lt;cv::Mat&gt;::iterator lit=mpTracker-&gt;mlRelativeFramePoses.begin(),
-        lend=mpTracker-&gt;mlRelativeFramePoses.end();lit!=lend;lit++, lRit++, lT++, lbL++)
-    {
-        if(*lbL)
-            continue;
-
-        KeyFrame* pKF = *lRit;
-
-        cv::Mat Trw = cv::Mat::eye(4,4,CV_32F);
-
-        // If the reference keyframe was culled, traverse the spanning tree to get a suitable keyframe.
-        while(pKF-&gt;isBad())
-        {
-            Trw = Trw*pKF-&gt;mTcp;
-            pKF = pKF-&gt;GetParent();
-        }
-
-        Trw = Trw*pKF-&gt;GetPose()*Two;
-
-        cv::Mat Tcw = (*lit)*Trw;
-        cv::Mat Rwc = Tcw.rowRange(0,3).colRange(0,3).t();
-        cv::Mat twc = -Rwc*Tcw.rowRange(0,3).col(3);
-
-        vector&lt;float&gt; q = Converter::toQuaternion(Rwc);
-
-        f &lt;&lt; setprecision(6) &lt;&lt; *lT &lt;&lt; " " &lt;&lt;  setprecision(9) &lt;&lt; twc.at&lt;float&gt;(0) &lt;&lt; " " &lt;&lt; twc.at&lt;float&gt;(1) &lt;&lt; " " &lt;&lt; twc.at&lt;float&gt;(2) &lt;&lt; " " &lt;&lt; q[0] &lt;&lt; " " &lt;&lt; q[1] &lt;&lt; " " &lt;&lt; q[2] &lt;&lt; " " &lt;&lt; q[3] &lt;&lt; endl;
-    }
-    f.close();
-    cout &lt;&lt; endl &lt;&lt; "trajectory saved!" &lt;&lt; endl;
+//    cout &lt;&lt; endl &lt;&lt; "Saving camera trajectory to " &lt;&lt; filename &lt;&lt; " ..." &lt;&lt; endl;
+//
+//    vector&lt;KeyFrame*&gt; vpKFs = mpMap-&gt;GetAllKeyFrames();
+//    sort(vpKFs.begin(),vpKFs.end(),KeyFrame::lId);
+//
+//    // Transform all keyframes so that the first keyframe is at the origin.
+//    // After a loop closure the first keyframe might not be at the origin.
+//    cv::Mat Two = vpKFs[0]-&gt;GetPoseInverse();
+//
+//    ofstream f;
+//    f.open(filename.c_str());
+//    f &lt;&lt; fixed;
+//
+//    // Frame pose is stored relative to its reference keyframe (which is optimized by BA and pose graph).
+//    // We need to get first the keyframe pose and then concatenate the relative transformation.
+//    // Frames not localized (tracking failure) are not saved.
+//
+//    // For each frame we have a reference keyframe (lRit), the timestamp (lT) and a flag
+//    // which is true when tracking failed (lbL).
+//    list&lt;ORB_SLAM2::KeyFrame*&gt;::iterator lRit = mpTracker-&gt;mlpReferences.begin();
+//    list&lt;double&gt;::iterator lT = mpTracker-&gt;mlFrameTimes.begin();
+//    list&lt;bool&gt;::iterator lbL = mpTracker-&gt;mlbLost.begin();
+//    for(list&lt;cv::Mat&gt;::iterator lit=mpTracker-&gt;mlRelativeFramePoses.begin(),
+//        lend=mpTracker-&gt;mlRelativeFramePoses.end();lit!=lend;lit++, lRit++, lT++, lbL++)
+//    {
+//        if(*lbL)
+//            continue;
+//
+//        KeyFrame* pKF = *lRit;
+//
+//        cv::Mat Trw = cv::Mat::eye(4,4,CV_32F);
+//
+//        // If the reference keyframe was culled, traverse the spanning tree to get a suitable keyframe.
+//        while(pKF-&gt;isBad())
+//        {
+//            Trw = Trw*pKF-&gt;mTcp;
+//            pKF = pKF-&gt;GetParent();
+//        }
+//
+//        Trw = Trw*pKF-&gt;GetPose()*Two;
+//
+//        cv::Mat Tcw = (*lit)*Trw;
+//        cv::Mat Rwc = Tcw.rowRange(0,3).colRange(0,3).t();
+//        cv::Mat twc = -Rwc*Tcw.rowRange(0,3).col(3);
+//
+//        vector&lt;float&gt; q = Converter::toQuaternion(Rwc);
+//
+//        f &lt;&lt; setprecision(6) &lt;&lt; *lT &lt;&lt; " " &lt;&lt;  setprecision(9) &lt;&lt; twc.at&lt;float&gt;(0) &lt;&lt; " " &lt;&lt; twc.at&lt;float&gt;(1) &lt;&lt; " " &lt;&lt; twc.at&lt;float&gt;(2) &lt;&lt; " " &lt;&lt; q[0] &lt;&lt; " " &lt;&lt; q[1] &lt;&lt; " " &lt;&lt; q[2] &lt;&lt; " " &lt;&lt; q[3] &lt;&lt; endl;
+//    }
+//    f.close();
+//    cout &lt;&lt; endl &lt;&lt; "trajectory saved!" &lt;&lt; endl;
 }
 
 
 void System::SaveKeyFrameTrajectoryTUM(const string &amp;filename)
 {
-    cout &lt;&lt; endl &lt;&lt; "Saving keyframe trajectory to " &lt;&lt; filename &lt;&lt; " ..." &lt;&lt; endl;
-
-    vector&lt;KeyFrame*&gt; vpKFs = mpMap-&gt;GetAllKeyFrames();
-    sort(vpKFs.begin(),vpKFs.end(),KeyFrame::lId);
-
-    // Transform all keyframes so that the first keyframe is at the origin.
-    // After a loop closure the first keyframe might not be at the origin.
-    //cv::Mat Two = vpKFs[0]-&gt;GetPoseInverse();
-
-    ofstream f;
-    f.open(filename.c_str());
-    f &lt;&lt; fixed;
-
-    for(size_t i=0; i&lt;vpKFs.size(); i++)
-    {
-        KeyFrame* pKF = vpKFs[i];
-
-       // pKF-&gt;SetPose(pKF-&gt;GetPose()*Two);
-
-        if(pKF-&gt;isBad())
-            continue;
-
-        cv::Mat R = pKF-&gt;GetRotation().t();
-        vector&lt;float&gt; q = Converter::toQuaternion(R);
-        cv::Mat t = pKF-&gt;GetCameraCenter();
-        f &lt;&lt; setprecision(6) &lt;&lt; pKF-&gt;mTimeStamp &lt;&lt; setprecision(7) &lt;&lt; " " &lt;&lt; t.at&lt;float&gt;(0) &lt;&lt; " " &lt;&lt; t.at&lt;float&gt;(1) &lt;&lt; " " &lt;&lt; t.at&lt;float&gt;(2)
-          &lt;&lt; " " &lt;&lt; q[0] &lt;&lt; " " &lt;&lt; q[1] &lt;&lt; " " &lt;&lt; q[2] &lt;&lt; " " &lt;&lt; q[3] &lt;&lt; endl;
-
-    }
-
-    f.close();
-    cout &lt;&lt; endl &lt;&lt; "trajectory saved!" &lt;&lt; endl;
+//    cout &lt;&lt; endl &lt;&lt; "Saving keyframe trajectory to " &lt;&lt; filename &lt;&lt; " ..." &lt;&lt; endl;
+//
+//    vector&lt;KeyFrame*&gt; vpKFs = mpMap-&gt;GetAllKeyFrames();
+//    sort(vpKFs.begin(),vpKFs.end(),KeyFrame::lId);
+//
+//    // Transform all keyframes so that the first keyframe is at the origin.
+//    // After a loop closure the first keyframe might not be at the origin.
+//    //cv::Mat Two = vpKFs[0]-&gt;GetPoseInverse();
+//
+//    ofstream f;
+//    f.open(filename.c_str());
+//    f &lt;&lt; fixed;
+//
+//    for(size_t i=0; i&lt;vpKFs.size(); i++)
+//    {
+//        KeyFrame* pKF = vpKFs[i];
+//
+//       // pKF-&gt;SetPose(pKF-&gt;GetPose()*Two);
+//
+//        if(pKF-&gt;isBad())
+//            continue;
+//
+//        cv::Mat R = pKF-&gt;GetRotation().t();
+//        vector&lt;float&gt; q = Converter::toQuaternion(R);
+//        cv::Mat t = pKF-&gt;GetCameraCenter();
+//        f &lt;&lt; setprecision(6) &lt;&lt; pKF-&gt;mTimeStamp &lt;&lt; setprecision(7) &lt;&lt; " " &lt;&lt; t.at&lt;float&gt;(0) &lt;&lt; " " &lt;&lt; t.at&lt;float&gt;(1) &lt;&lt; " " &lt;&lt; t.at&lt;float&gt;(2)
+//          &lt;&lt; " " &lt;&lt; q[0] &lt;&lt; " " &lt;&lt; q[1] &lt;&lt; " " &lt;&lt; q[2] &lt;&lt; " " &lt;&lt; q[3] &lt;&lt; endl;
+//
+//    }
+//
+//    f.close();
+//    cout &lt;&lt; endl &lt;&lt; "trajectory saved!" &lt;&lt; endl;
 }
 
 void System::SaveTrajectoryKITTI(const string &amp;filename)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Tracking.cc" new_path="ros\src\computing\perception\localization\packages\orb_localizer\src\Tracking.cc" added_lines="115" deleted_lines="94">
				<diff>@@ -59,7 +59,7 @@ Tracking::Tracking (
     mState(NO_IMAGES_YET), mSensor(sensor), mbOnlyTracking(false), mbVO(false), mpORBVocabulary(pVoc),
     mpKeyFrameDB(pKFDB), mpInitializer(static_cast&lt;Initializer*&gt;(NULL)), mpSystem(pSys),
     mpFrameDrawer(pFrameDrawer), mpMapDrawer(pMapDrawer), mpMap(pMap), mnLastRelocFrameId(0),
-	mLocalMapper(NULL), mLoopCloser(NULL)
+	mLocalMapper(NULL), mLoopCloser(NULL), mpReferenceKF(NULL)
 
 {
     // Load camera parameters from settings file
@@ -265,7 +265,7 @@ cv::Mat Tracking::GrabImageMonocular(const cv::Mat &amp;im, const double &amp;timestamp)
             cvtColor(mImGray,mImGray,CV_BGRA2GRAY);
     }
 
-    if(mState==NOT_INITIALIZED || mState==NO_IMAGES_YET)
+    if(mState==NOT_INITIALIZED or mState==NO_IMAGES_YET or mState==LOST)
         mCurrentFrame = Frame(mImGray,timestamp,mpIniORBextractor,mpORBVocabulary,mK,mDistCoef,mbf,mThDepth);
     else
         mCurrentFrame = Frame(mImGray,timestamp,mpORBextractorLeft,mpORBVocabulary,mK,mDistCoef,mbf,mThDepth);
@@ -276,10 +276,25 @@ cv::Mat Tracking::GrabImageMonocular(const cv::Mat &amp;im, const double &amp;timestamp)
 }
 
 
-void Tracking::Track()
+Transform3 Tracking::LocalizeImage (const cv::Mat &amp;image, const double &amp;timestamp)
 {
-//	printf ("fx: %f, fy: %f, cx: %f, cy: %f\n", mK.at&lt;float&gt;(0,0), mK.at&lt;float&gt;(1,1), mK.at&lt;float&gt;(0,2), mK.at&lt;float&gt;(1,2));
+	mImGray = image;
+
+	if(mbRGB)
+		cvtColor(mImGray,mImGray,CV_RGB2GRAY);
+	else
+		cvtColor(mImGray,mImGray,CV_BGR2GRAY);
+
+	mCurrentFrame = Frame (mImGray, timestamp, mpIniORBextractor, mpORBVocabulary, mK, mDistCoef, mbf, mThDepth);
+
+	bool bOK = Relocalization();
+	if (bOK) {
+
+	}
+}
 
+void Tracking::Track()
+{
     if(mState==NO_IMAGES_YET)
     {
         mState = NOT_INITIALIZED;
@@ -332,7 +347,7 @@ void Tracking::Track()
             }
             else
             {
-                bOK = Relocalization();
+                bOK = Relocalization (SEARCH_MAPPING);
             }
 
             if (mState==MAP_OPEN) {
@@ -346,7 +361,13 @@ void Tracking::Track()
 
             if(mState==LOST || mState==MAP_OPEN)
             {
-                bOK = Relocalization();
+            	if (mpReferenceKF==NULL) {
+            		bOK = Relocalization (SEARCH_DB);
+            	}
+            	else {
+            		bOK = Relocalization(SEARCH_LOCAL_MAP);
+            		if (!bOK) bOK = Relocalization(SEARCH_DB);
+            	}
             }
             else
             {
@@ -383,7 +404,10 @@ void Tracking::Track()
                         vbOutMM = mCurrentFrame.mvbOutlier;
                         TcwMM = mCurrentFrame.mTcw.clone();
                     }
-                    bOKReloc = Relocalization();
+                    // XXX: Need to confirm if we need local map reloc.
+                    bOKReloc = Relocalization (SEARCH_LOCAL_MAP);
+                    if (!bOKReloc)
+                    	cerr &lt;&lt; "XXX: Local map reloc failed in here\n";
 
                     if(bOKMM &amp;&amp; !bOKReloc)
                     {
@@ -640,6 +664,7 @@ void Tracking::MonocularInitialization()
         // Check if there are enough correspondences
         if(nmatches&lt;100)
         {
+        	cerr &lt;&lt; "Not enough matches: " &lt;&lt; nmatches &lt;&lt; endl;
             delete mpInitializer;
             mpInitializer = static_cast&lt;Initializer*&gt;(NULL);
             return;
@@ -671,6 +696,9 @@ void Tracking::MonocularInitialization()
 
             CreateInitialMapMonocular();
         }
+        else {
+        	cerr &lt;&lt; "Initialization failed\n";
+        }
     }
 }
 
@@ -976,85 +1004,54 @@ bool Tracking::TrackWithMotionModel()
     return nmatchesMap&gt;=10;
 }
 
-//bool Tracking::TrackLocalMap()
-//{
-//#ifdef DEBUG_TRACKING
-//	cout &lt;&lt; "Tracking Mode: TrackLocalMap()" &lt;&lt; endl;
-//#endif
-//
-//    // We have an estimation of the camera pose and some map points tracked in the frame.
-//    // We retrieve the local map and try to find matches to points in the local map.
-//
-//    UpdateLocalMap();
-//
-//    SearchLocalPoints();
-//
-//    // Optimize Pose
-//    Optimizer::PoseOptimization(&amp;mCurrentFrame);
-//    mnMatchesInliers = 0;
-//
-//    // Update MapPoints Statistics
-//    for(int i=0; i&lt;mCurrentFrame.N; i++)
-//    {
-//        if(mCurrentFrame.mvpMapPoints[i])
-//        {
-//            if(!mCurrentFrame.mvbOutlier[i])
-//            {
-//                mCurrentFrame.mvpMapPoints[i]-&gt;IncreaseFound();
-//                if(!mbOnlyTracking)
-//                {
-//                    if(mCurrentFrame.mvpMapPoints[i]-&gt;Observations()&gt;0)
-//                        mnMatchesInliers++;
-//                }
-//                else
-//                    mnMatchesInliers++;
-//            }
-//            else if(mSensor==System::STEREO)
-//                mCurrentFrame.mvpMapPoints[i] = static_cast&lt;MapPoint*&gt;(NULL);
-//
-//        }
-//    }
-//
-//    // Decide if the tracking was successful
-//    // More restrictive if there was a relocalization recently
-//    if(mCurrentFrame.mnId&lt;mnLastRelocFrameId+mMaxFrames &amp;&amp; mnMatchesInliers&lt;50) {
-////    	cerr &lt;&lt; "TrackLocalMap Failure: A" &lt;&lt; endl;
-//        return false;
-//    }
-//
-//    if(mnMatchesInliers&lt;30) {
-////    	cerr &lt;&lt; "TrackLocalMap Failure: B" &lt;&lt; endl;
-//        return false;
-//    }
-//    else
-//        return true;
-//}
-
-// This is taken from ORB-SLAM v1
 bool Tracking::TrackLocalMap()
 {
-	UpdateLocalMap();
-	SearchLocalPoints();
-	mnMatchesInliers = Optimizer::PoseOptimization(&amp;mCurrentFrame);
-#ifdef DEBUG_TRACKING
-//	cout &lt;&lt; "Tracking Mode: TrackLocalMap(), matches: " &lt;&lt; mnMatchesInliers &lt;&lt; endl;
-	lastTrackingMode = TRACK_LOCAL_MAP;
-#endif
+    // We have an estimation of the camera pose and some map points tracked in the frame.
+    // We retrieve the local map and try to find matches to points in the local map.
 
-	for (size_t i=0; i&lt;mCurrentFrame.mvpMapPoints.size(); i++) {
-		if (mCurrentFrame.mvpMapPoints[i]) {
-			if (!mCurrentFrame.mvbOutlier[i])
-				mCurrentFrame.mvpMapPoints[i]-&gt;IncreaseFound();
-		}
-	}
+    UpdateLocalMap();
 
-	if(mCurrentFrame.mnId&lt;mnLastRelocFrameId+mMaxFrames &amp;&amp; mnMatchesInliers&lt;50)
-		return false;
+    SearchLocalPoints();
 
-	if(mnMatchesInliers&lt;30)
-		return false;
-	else
-		return true;
+    // Optimize Pose
+    Optimizer::PoseOptimization(&amp;mCurrentFrame);
+    mnMatchesInliers = 0;
+
+    // Update MapPoints Statistics
+    for(int i=0; i&lt;mCurrentFrame.N; i++)
+    {
+        if(mCurrentFrame.mvpMapPoints[i])
+        {
+            if(!mCurrentFrame.mvbOutlier[i])
+            {
+                mCurrentFrame.mvpMapPoints[i]-&gt;IncreaseFound();
+                if(!mbOnlyTracking)
+                {
+                    if(mCurrentFrame.mvpMapPoints[i]-&gt;Observations()&gt;0)
+                        mnMatchesInliers++;
+                }
+                else
+                    mnMatchesInliers++;
+            }
+            else if(mSensor==System::STEREO)
+                mCurrentFrame.mvpMapPoints[i] = static_cast&lt;MapPoint*&gt;(NULL);
+
+        }
+    }
+
+    // Decide if the tracking was successful
+    // More restrictive if there was a relocalization recently
+    if(mCurrentFrame.mnId&lt;mnLastRelocFrameId+mMaxFrames &amp;&amp; mnMatchesInliers&lt;50) {
+//    	cerr &lt;&lt; "TrackLocalMap Failure: A" &lt;&lt; endl;
+        return false;
+    }
+
+    if(mnMatchesInliers&lt;30) {
+//    	cerr &lt;&lt; "TrackLocalMap Failure: B" &lt;&lt; endl;
+        return false;
+    }
+    else
+        return true;
 }
 
 
@@ -1070,8 +1067,10 @@ bool Tracking::NeedNewKeyFrame()
     const int nKFs = mpMap-&gt;KeyFramesInMap();
 
     // Do not insert keyframes if not enough frames have passed from last relocalisation
-    if(mCurrentFrame.mnId&lt;mnLastRelocFrameId+mMaxFrames &amp;&amp; nKFs&gt;mMaxFrames)
-        return false;
+    if (mpSystem-&gt;offlineMapping==false) {
+		if(mCurrentFrame.mnId&lt;mnLastRelocFrameId+mMaxFrames &amp;&amp; nKFs&gt;mMaxFrames)
+			return false;
+    }
 
     // Tracked MapPoints in the reference keyframe
     int nMinObs = 3;
@@ -1080,7 +1079,12 @@ bool Tracking::NeedNewKeyFrame()
     int nRefMatches = mpReferenceKF-&gt;TrackedMapPoints(nMinObs);
 
     // Local Mapping accept keyframes?
-    bool bLocalMappingIdle = mpLocalMapper-&gt;AcceptKeyFrames();
+    bool bLocalMappingIdle;
+    if (mpSystem-&gt;offlineMapping==false) {
+    	bLocalMappingIdle = mpLocalMapper-&gt;AcceptKeyFrames();
+    }
+    else
+    	bLocalMappingIdle = true;
 
 #ifdef DEBUG_TRACKING
 //	cout &lt;&lt; "Checking if we need new keyframe" &lt;&lt; endl;
@@ -1167,7 +1171,7 @@ bool Tracking::NeedNewKeyFrame()
 
 void Tracking::CreateNewKeyFrame()
 {
-    if(!mpLocalMapper-&gt;SetNotStop(true))
+    if(mpSystem-&gt;offlineMapping==false and !mpLocalMapper-&gt;SetNotStop(true))
         return;
 
     KeyFrame* pKF = new KeyFrame(mCurrentFrame,mpMap,mpKeyFrameDB);
@@ -1239,7 +1243,8 @@ void Tracking::CreateNewKeyFrame()
 
     mpLocalMapper-&gt;InsertKeyFrame(pKF);
 
-    mpLocalMapper-&gt;SetNotStop(false);
+    if (mpSystem-&gt;offlineMapping==false)
+    	mpLocalMapper-&gt;SetNotStop(false);
 
     mnLastKeyFrameId = mCurrentFrame.mnId;
     mpLastKeyFrame = pKF;
@@ -1443,19 +1448,30 @@ void Tracking::UpdateLocalKeyFrames()
     }
 }
 
-bool Tracking::Relocalization()
+bool Tracking::Relocalization (RelocalizationMode relocmode)
 {
-#ifdef DEBUG_TRACKING
-//	cout &lt;&lt; "Tracking Mode: Relocalization()" &lt;&lt; endl;
-	lastTrackingMode = RELOCALIZATION;
-#endif
-
     // Compute Bag of Words Vector
     mCurrentFrame.ComputeBoW();
 
     // Relocalization is performed when tracking is lost
-    // Track Lost: Query KeyFrame Database for keyframe candidates for relocalisation
-    vector&lt;KeyFrame*&gt; vpCandidateKFs = mpKeyFrameDB-&gt;DetectRelocalizationCandidates(&amp;mCurrentFrame);
+    vector&lt;KeyFrame*&gt; vpCandidateKFs;
+    switch (relocmode) {
+    case SEARCH_DB: {
+
+    	vpCandidateKFs = mpKeyFrameDB-&gt;DetectRelocalizationCandidatesSimple (&amp;mCurrentFrame);
+    	cerr &lt;&lt; "Searching DB: " &lt;&lt; vpCandidateKFs.size() &lt;&lt; endl;
+    } break;
+
+    case SEARCH_MAPPING: {
+    	vpCandidateKFs = mpKeyFrameDB-&gt;DetectRelocalizationCandidates (&amp;mCurrentFrame);
+    	cerr &lt;&lt; "Searching previously matches: " &lt;&lt; vpCandidateKFs.size() &lt;&lt; endl;
+    } break;
+
+    case SEARCH_LOCAL_MAP: {
+    	vpCandidateKFs = mvpLocalKeyFrames;
+    	cerr &lt;&lt; "Searching Locality: " &lt;&lt; vpCandidateKFs.size() &lt;&lt; endl;
+    } break;
+    }
 
     if(vpCandidateKFs.empty())
         return false;
@@ -1485,8 +1501,11 @@ bool Tracking::Relocalization()
         else
         {
             int nmatches = matcher.SearchByBoW(pKF,mCurrentFrame,vvpMapPointMatches[i]);
+//            cerr &lt;&lt; "# BoW matches: " &lt;&lt; nmatches &lt;&lt; endl;
+//            if(nmatches&lt;7)
             if(nmatches&lt;15)
             {
+            	cerr &lt;&lt; "KF discarded: #" &lt;&lt; pKF-&gt;mnId &lt;&lt; endl;
                 vbDiscarded[i] = true;
                 continue;
             }
@@ -1519,6 +1538,7 @@ bool Tracking::Relocalization()
 
             PnPsolver* pSolver = vpPnPsolvers[i];
             cv::Mat Tcw = pSolver-&gt;iterate(5,bNoMore,vbInliers,nInliers);
+//            cerr &lt;&lt; "#Inliers: " &lt;&lt; nInliers &lt;&lt; endl;
 
             // If Ransac reachs max. iterations discard keyframe
             if(bNoMore)
@@ -1603,6 +1623,7 @@ bool Tracking::Relocalization()
 
     if(!bMatch)
     {
+//    	fprintf(stderr, "#KF: %d\n", nKFs);
         return false;
     }
     else
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\ImageGrabber.cc" new_path="" added_lines="0" deleted_lines="473">
				<diff>@@ -1,473 +0,0 @@
-/*
- * ImageGrabber.cc
- *
- *  Created on: May 31, 2016
- *      Author: sujiwo
- */
-
-#include "../__nodes/ImageGrabber.h"
-
-#include &lt;std_msgs/UInt32.h&gt;
-#include &lt;std_msgs/Float64.h&gt;
-
-#include "boost/date_time/posix_time/posix_time.hpp"
-
-
-using namespace std;
-using namespace boost::posix_time;
-
-using ORB_SLAM2::Frame;
-namespace enc = sensor_msgs::image_encodings;
-
-
-// define debugging topics to broadcast to
-const char
-	*framebufferDebugTopic		=	"/orbslamdebug/framebuffer",
-	*internalTopic				=	"/orbslamdebug";
-
-
-void tf2positiondirection (const tf::Transform &amp;pose, float positiondirection[6])
-{
-	// position
-	positiondirection[0] = pose.getOrigin().x();
-	positiondirection[1] = pose.getOrigin().y();
-	positiondirection[2] = pose.getOrigin().z();
-	float fdirx = pose.getRotation().x(),
-		fdiry = pose.getRotation().y(),
-		fdirz = pose.getRotation().z(),
-		fdirnorm;
-	fdirnorm = sqrtf(fdirx*fdirx + fdiry*fdiry + fdirz*fdirz);
-	fdirx /= fdirnorm;
-	fdiry /= fdirnorm;
-	fdirz /= fdirnorm;
-	positiondirection[3] = fdirx;
-	positiondirection[4] = fdiry;
-	positiondirection[5] = fdirz;
-}
-
-
-ImageGrabber::ImageGrabber(ORB_SLAM2::System* pSLAM, ros::NodeHandle *nh, bool runOffline) :
-	mpSLAM(pSLAM),
-	rosNode (nh),
-	doStop (false),
-	doDebayer (false),
-	offlineMode (runOffline),
-	mTfBr (NULL),
-	extListener (NULL),
-	imageTransport (NULL)
-{
-	// External localization
-	extFrame1 = (string)mpSLAM-&gt;fsSettings["ExternalLocalization.frame1"];
-	extFrame2 = (string)mpSLAM-&gt;fsSettings["ExternalLocalization.frame2"];
-	cout &lt;&lt; "External Reference: from " &lt;&lt; extFrame1 &lt;&lt; " to " &lt;&lt; extFrame2 &lt;&lt; endl;
-
-	offsetKeyframe = (int)mpSLAM-&gt;fsSettings["ExternalLocalization.OffsetKeyframes"];
-
-	// Initialize TF
-	if (offlineMode==false) {
-		tf::Transform tfT;
-		tfT.setIdentity();
-		mTfBr = new tf::TransformBroadcaster();
-
-		mTfBr-&gt;sendTransform(tf::StampedTransform(tfT,ros::Time::now(), "/ORB_SLAM/World", "/ORB_SLAM/Camera"));
-	}
-
-	// start of debug preparation
-
-	cout &lt;&lt; std::fixed &lt;&lt; setprecision(7);
-
-	if (pSLAM-&gt;opMode==ORB_SLAM2::System::LOCALIZATION) {
-		imageTransport = new image_transport::ImageTransport (*rosNode);
-		visualDebugView = imageTransport-&gt;advertise(framebufferDebugTopic, 1);
-		debugMsgPublisher = rosNode-&gt;advertise&lt;orb_localizer::debug&gt; (internalTopic, 1);
-	}
-}
-
-
-ImageGrabber::~ImageGrabber()
-{
-	if (mTfBr != NULL)
-		delete (mTfBr);
-	if (extListener != NULL)
-		delete (extListener);
-	if (imageTransport != NULL)
-		delete (imageTransport);
-
-//	debugBag.close();
-}
-
-
-void ImageGrabber::GrabImage(const sensor_msgs::ImageConstPtr&amp; msg)
-{
-	// Activate this timer if you need time logging
-	ptime rT1, rT2;
-	rT1 = microsec_clock::local_time();
-
-	// Copy the ros image message to cv::Mat.
-	cv_bridge::CvImageConstPtr cv_ptr;
-	try
-	{
-		cv_ptr = cv_bridge::toCvShare(msg);
-	}
-	catch (cv_bridge::Exception&amp; e)
-	{
-		ROS_ERROR("cv_bridge exception: %s", e.what());
-		return;
-	}
-
-	cv::Mat image;
-	// Check if we need debayering
-	if (enc::isBayer(msg-&gt;encoding)) {
-		int code=-1;
-		if (msg-&gt;encoding == enc::BAYER_RGGB8 ||
-			msg-&gt;encoding == enc::BAYER_RGGB16) {
-//			cout &lt;&lt; "BGR2BGR" &lt;&lt; endl;
-			code = cv::COLOR_BayerBG2BGR;
-		}
-		else if (msg-&gt;encoding == enc::BAYER_BGGR8 ||
-				 msg-&gt;encoding == enc::BAYER_BGGR16) {
-			code = cv::COLOR_BayerRG2BGR;
-		}
-		else if (msg-&gt;encoding == enc::BAYER_GBRG8 ||
-				 msg-&gt;encoding == enc::BAYER_GBRG16) {
-			code = cv::COLOR_BayerGR2BGR;
-		}
-		else if (msg-&gt;encoding == enc::BAYER_GRBG8 ||
-				 msg-&gt;encoding == enc::BAYER_GRBG16) {
-			code = cv::COLOR_BayerGB2BGR;
-		}
-		cv::cvtColor(cv_ptr-&gt;image, image, code);
-	}
-	else
-		image = cv_ptr-&gt;image;
-
-	const double imageTime = msg-&gt;header.stamp.toSec();
-	lastImageTimestamp = imageTime;
-
-	// Do Resizing and cropping here
-	cv::resize(image, image,
-		cv::Size(
-			(int)mpSLAM-&gt;fsSettings["Camera.WorkingResolution.Width"],
-			(int)mpSLAM-&gt;fsSettings["Camera.WorkingResolution.Height"]
-		));
-	image = image(
-		cv::Rect(
-			(int)mpSLAM-&gt;fsSettings["Camera.ROI.x0"],
-			(int)mpSLAM-&gt;fsSettings["Camera.ROI.y0"],
-			(int)mpSLAM-&gt;fsSettings["Camera.ROI.width"],
-			(int)mpSLAM-&gt;fsSettings["Camera.ROI.height"]
-		)).clone();
-
-	cv::Mat tmpRs = mpSLAM-&gt;TrackMonocular(image, imageTime);
-
-	// Reinsert TF publisher, but only for localization. Original ORB-SLAM2 removes it.
-	bool tfOk = false;
-	tf::Transform locRef;
-
-	tf::StampedTransform tfMsg;
-	tfMsg.stamp_ = ros::Time(imageTime);
-	tfMsg.frame_id_ = (string)mpSLAM-&gt;fsSettings["ExternalLocalization.frame1"];
-	tfMsg.child_frame_id_ = (string)mpSLAM-&gt;fsSettings["ExternalLocalization.frame2"];
-
-	Frame &amp;cframe = mpSLAM-&gt;getTracker()-&gt;mCurrentFrame;
-	if (mpSLAM-&gt;opMode==ORB_SLAM2::System::LOCALIZATION and
-		mpSLAM-&gt;getTracker()-&gt;trackingIsGood() and
-		offlineMode == false
-	) {
-
-//		cout &lt;&lt; "Got Tracking: Client" &lt;&lt; endl;
-//		cout &lt;&lt; tmpRs &lt;&lt; endl &lt;&lt; "XXX\n";
-
-		tf::Transform tfTcw = FramePose(&amp;cframe);
-		mTfBr-&gt;sendTransform(tf::StampedTransform(tfTcw, ros::Time(imageTime), "/ORB_SLAM/World", "/ORB_SLAM/Camera"));
-
-//		 Here, we use offset of external localization from the keyframe
-		if (mpSLAM-&gt;getTracker()-&gt;mbOnlyTracking==true) {
-//			ORB_SLAM2::KeyFrame *kfRef = cframe.mpReferenceKF;
-			try {
-				locRef = localizeByReference(tfTcw);
-				tfMsg.setData(locRef);
-				mTfBr-&gt;sendTransform(tfMsg);
-				tfOk = true;
-			} catch (...) {}
-		}
-
-	} else {
-//		cout &lt;&lt; "Got Lost" &lt;&lt; endl;
-	}
-
-	rT2 = microsec_clock::local_time();
-	cputimeDebug = (rT2-rT1).total_microseconds() * 1e-6;
-
-	publishDebug();
-}
-
-
-void ImageGrabber::publishDebug ()
-{
-	if (mpSLAM-&gt;opMode==ORB_SLAM2::System::LOCALIZATION) {
-		mpSLAM-&gt;getFrameDrawer()-&gt;DrawFrame();
-		framebufferDebug = mpSLAM-&gt;getFrameDrawer()-&gt;getLastFrame();
-
-		cv_bridge::CvImage bagImage;
-		bagImage.image = framebufferDebug;
-		bagImage.header.stamp = ros::Time(lastImageTimestamp);
-		bagImage.encoding = "bgr8";
-		visualDebugView.publish(bagImage.toImageMsg());
-
-		orb_localizer::debug internalDebugMsg;
-		internalDebugMsg.header.stamp = ros::Time (lastImageTimestamp);
-		internalDebugMsg.header.frame_id = "ORB_SLAM2";
-		internalDebugMsg.keyframe_id = lastKeyframeId;
-		internalDebugMsg.cputime = cputimeDebug;
-		internalDebugMsg.tracking = mpSLAM-&gt;getTracker()-&gt;trackingIsGood();
-		debugMsgPublisher.publish (internalDebugMsg);
-	}
-}
-
-
-void ImageGrabber::externalLocalizerGrab()
-{
-	if (extListener==NULL)
-		extListener = new tf::TransformListener ();
-
-	ros::Rate fps((int)mpSLAM-&gt;fsSettings["Camera.fps"] * 2);
-
-	while (ros::ok()) {
-
-		if (doStop == true)
-			break;
-
-		try {
-
-			extListener-&gt;lookupTransform (extFrame1, extFrame2, ros::Time(0), extPose);
-			unique_lock&lt;mutex&gt; lock(ORB_SLAM2::KeyFrame::extPoseMutex);
-			tfToCV (extPose, ORB_SLAM2::KeyFrame::extEgoPosition, ORB_SLAM2::KeyFrame::extEgoOrientation);
-
-		} catch (tf::TransformException &amp;e) {
-
-			unique_lock&lt;mutex&gt; lock(ORB_SLAM2::KeyFrame::extPoseMutex);
-			ORB_SLAM2::KeyFrame::extEgoPosition.release();
-			ORB_SLAM2::KeyFrame::extEgoOrientation.release();
-
-		}
-
-		fps.sleep();
-	}
-}
-
-
-tf::Transform ImageGrabber::localizeByReference (const tf::Transform &amp;tfOrb, ORB_SLAM2::KeyFrame *kf)
-{
-	lastKeyframeId = kf-&gt;mnId;
-
-	ORB_SLAM2::KeyFrame *kOffset = mpSLAM-&gt;getMap()-&gt;offsetKeyframe(kf, offsetKeyframe);
-	if (kOffset==NULL)
-		throw std::out_of_range("No offset keyframe found");
-
-	if (kf-&gt;extPosition.empty() or kOffset-&gt;extPosition.empty())
-		throw std::out_of_range("External reference of keyframe not found");
-
-	tf::Transform kfTr = KeyFramePoseToTf(kf);
-	tf::Transform extRef = getKeyFrameExtPose(kf);
-
-	tf::Transform kfTrOffset = KeyFramePoseToTf(kOffset);
-	tf::Transform extRefOffset = getKeyFrameExtPose(kOffset);
-	return localizeByReference (tfOrb, kfTr, kfTrOffset, extRef, extRefOffset);
-}
-
-
-/*
- * Main routine for localization by reference
- */
-tf::Transform ImageGrabber::localizeByReference (
-    	const tf::Transform &amp;tfOrb,
-		const tf::Transform &amp;tfOrbMap, const tf::Transform &amp;tfOrbMapOffset,
-    	const tf::Transform &amp;realMapPose, const tf::Transform &amp;realMapOffset)
-{
-	double offDistO = cv::norm(
-		ImageGrabber::tfToCv(tfOrbMap.getOrigin()) -
-		ImageGrabber::tfToCv(tfOrbMapOffset.getOrigin()));
-	double offDistE = cv::norm(
-		ImageGrabber::tfToCv(realMapPose.getOrigin()) -
-		ImageGrabber::tfToCv(realMapOffset.getOrigin()));
-	double scale = offDistE / offDistO;
-
-	// change orientation from camera to velodyne
-	tf::Transform flipAxes;
-	flipAxes.setOrigin(tf::Vector3(0, 0, 0));
-	tf::Quaternion fpq;
-	fpq.setRPY(M_PI/2,0,0);
-	fpq.normalize();
-	flipAxes.setRotation(fpq);
-//	flipAxes.setRotation (tf::Quaternion(-M_PI/2, M_PI/2, 0).normalize());
-
-	tf::Transform orbRel = tfOrbMap.inverse() * tfOrb;
-
-	tf::Transform scaledRel = orbRel;
-	scaledRel.setOrigin(orbRel.getOrigin() * scale);
-
-	tf::Transform tfResult = realMapPose * scaledRel;
-	return tfResult*flipAxes;
-}
-
-
-tf::Transform ImageGrabber::localizeByReference(const tf::Transform &amp;tfOrb)
-{
-	float fdirx = tfOrb.getRotation().x(),
-		fdiry = tfOrb.getRotation().y(),
-		fdirz = tfOrb.getRotation().z(),
-		fdirnorm;
-	fdirnorm = sqrtf(fdirx*fdirx + fdiry*fdiry + fdirz*fdirz);
-	fdirx /= fdirnorm;
-	fdiry /= fdirnorm;
-	fdirz /= fdirnorm;
-
-	ORB_SLAM2::KeyFrame *kfNear = mpSLAM-&gt;getMap()-&gt;getNearestKeyFrame(
-		tfOrb.getOrigin().x(),
-		tfOrb.getOrigin().y(),
-		tfOrb.getOrigin().z(),
-		fdirx, fdiry, fdirz);
-	if (kfNear==NULL)
-		throw std::out_of_range("No keyframe found");
-
-	lastKeyframeId = kfNear-&gt;mnId;
-	return localizeByReference (tfOrb, kfNear);
-}
-
-
-tf::Transform ImageGrabber::localizeByReference(Frame *sframe)
-{
-//	const tf::Transform
-}
-
-
-tf::Transform ImageGrabber::localizeByReference(const tf::Transform &amp;tfOrb, ORB_SLAM2::Map *mapsrc, const int offsetNum)
-{
-	float positiondir[6];
-	tf2positiondirection(tfOrb, positiondir);
-
-	ORB_SLAM2::KeyFrame *kfNear = mapsrc-&gt;getNearestKeyFrame(
-		positiondir[0], positiondir[1], positiondir[2],
-		positiondir[3], positiondir[4], positiondir[5]);
-	if (kfNear==NULL)
-		throw std::out_of_range("No keyframe found");
-	ORB_SLAM2::KeyFrame *kOffset = mapsrc-&gt;offsetKeyframe(kfNear, offsetNum);
-	if (kOffset==NULL)
-		throw std::out_of_range("No offset keyframe found");
-
-	tf::Transform kfTr = KeyFramePoseToTf(kfNear);
-	tf::Transform extRef = getKeyFrameExtPose(kfNear);
-
-	tf::Transform kfTrOffset = KeyFramePoseToTf(kOffset);
-	tf::Transform extRefOffset = getKeyFrameExtPose(kOffset);
-
-	return localizeByReference (tfOrb, kfTr, kfTrOffset, extRef, extRefOffset);
-}
-
-
-tf2_msgs::TFMessage ImageGrabber::createTfMessage (const tf::Transform &amp;srcTransform,
-	const string &amp;frameSrc, const string &amp;frameTarget,
-	double timestamp=-1)
-{
-	ros::Time msgTime;
-	tf2_msgs::TFMessage tfretval;
-
-	if (timestamp&gt;0)
-		msgTime = ros::Time(timestamp);
-	else msgTime = ros::Time::now();
-
-	geometry_msgs::TransformStamped newTransform;
-	newTransform.header.stamp = msgTime;
-	newTransform.header.frame_id = frameSrc;
-	newTransform.child_frame_id = frameTarget;
-	newTransform.transform.translation.x = srcTransform.getOrigin().x();
-	newTransform.transform.translation.y = srcTransform.getOrigin().y();
-	newTransform.transform.translation.z = srcTransform.getOrigin().z();
-	newTransform.transform.rotation.x = srcTransform.getRotation().x();
-	newTransform.transform.rotation.y = srcTransform.getRotation().y();
-	newTransform.transform.rotation.z = srcTransform.getRotation().z();
-	newTransform.transform.rotation.w = srcTransform.getRotation().w();
-	tfretval.transforms.push_back (newTransform);
-
-	return tfretval;
-}
-
-
-tf::Transform ImageGrabber::getKeyFrameExtPose (const KeyFrame *kf)
-{
-	tf::Transform Ext;
-
-	if (kf-&gt;extPosition.empty() or kf-&gt;extOrientation.empty()) {
-		Ext.setOrigin(tf::Vector3(NAN, NAN, NAN));
-		Ext.setRotation(tf::Quaternion(NAN, NAN, NAN, NAN));
-	}
-
-	else {
-		Ext.setOrigin (tf::Vector3(
-			kf-&gt;extPosition.at&lt;double&gt;(0),
-			kf-&gt;extPosition.at&lt;double&gt;(1),
-			kf-&gt;extPosition.at&lt;double&gt;(2) ));
-		Ext.setRotation(tf::Quaternion(
-			kf-&gt;extOrientation.at&lt;double&gt;(0),
-			kf-&gt;extOrientation.at&lt;double&gt;(1),
-			kf-&gt;extOrientation.at&lt;double&gt;(2),
-			kf-&gt;extOrientation.at&lt;double&gt;(3) ));
-	}
-	return Ext;
-}
-
-
-tf::Transform ImageGrabber::KeyFramePoseToTf (KeyFrame *kf)
-{
-	tf::Transform kfpose;
-
-	cv::Mat t = kf-&gt;GetCameraCenter();
-	cv::Mat orient = kf-&gt;GetRotation().t();
-	vector&lt;float&gt; q = ORB_SLAM2::Converter::toQuaternion(orient);
-
-	kfpose.setOrigin(tf::Vector3(t.at&lt;float&gt;(0), t.at&lt;float&gt;(1), t.at&lt;float&gt;(2)));
-	kfpose.setRotation(tf::Quaternion(q[0], q[1], q[2], q[3]));
-
-	return kfpose;
-}
-
-
-tf::Transform ImageGrabber::FramePose (Frame *cframe)
-{
-	cv::Mat Rwc = cframe-&gt;mTcw.rowRange(0,3).colRange(0,3).t();
-	cv::Mat twc = -Rwc * cframe-&gt;mTcw.rowRange(0,3).col(3);
-	tf::Matrix3x3 M(Rwc.at&lt;float&gt;(0,0),Rwc.at&lt;float&gt;(0,1),Rwc.at&lt;float&gt;(0,2),
-					Rwc.at&lt;float&gt;(1,0),Rwc.at&lt;float&gt;(1,1),Rwc.at&lt;float&gt;(1,2),
-					Rwc.at&lt;float&gt;(2,0),Rwc.at&lt;float&gt;(2,1),Rwc.at&lt;float&gt;(2,2));
-	tf::Vector3 V(twc.at&lt;float&gt;(0), twc.at&lt;float&gt;(1), twc.at&lt;float&gt;(2));
-
-	return tf::Transform(M, V);
-}
-
-
-cv::Vec3d ImageGrabber::tfToCv (const tf::Vector3 &amp;pos)
-{
-	cv::Vec3d cvVec;
-	cvVec[0] = pos.x();
-	cvVec[1] = pos.y();
-	cvVec[2] = pos.z();
-	return cvVec;
-}
-
-
-cv::Mat ImageGrabber::tfToCv (const tf::Transform &amp;tfsrc)
-{
-	cv::Mat rtval = cv::Mat::eye(4,4, CV_32F);
-	rtval.rowRange(0, 3).col(3).at&lt;float&gt;(0) = tfsrc.getOrigin().x();
-	rtval.rowRange(0, 3).col(3).at&lt;float&gt;(1) = tfsrc.getOrigin().y();
-	rtval.rowRange(0, 3).col(3).at&lt;float&gt;(2) = tfsrc.getOrigin().z();
-
-	tf::Matrix3x3 rot (tfsrc.getRotation());
-	for (int i=0; i&lt;3; i++) {
-		for (int j=0; j&lt;3; j++) {
-			rtval.at&lt;float&gt;(i,j) = rot[i][j];
-		}
-	}
-	return rtval;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\ImageGrabber.h" new_path="" added_lines="0" deleted_lines="104">
				<diff>@@ -1,104 +0,0 @@
-/*
- * ImageGrabber.h
- *
- *  Created on: May 31, 2016
- *      Author: sujiwo
- */
-
-#ifndef _IMAGEGRABBER_H_
-#define _IMAGEGRABBER_H_
-
-
-#include &lt;string&gt;
-
-
-#include "System.h"
-#include "Map.h"
-#include "Frame.h"
-#include "KeyFrame.h"
-#include "Converter.h"
-#include &lt;ros/ros.h&gt;
-#include &lt;cv_bridge/cv_bridge.h&gt;
-#include &lt;image_transport/image_transport.h&gt;
-#include &lt;sensor_msgs/Image.h&gt;
-#include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;tf/transform_broadcaster.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-#include &lt;thread&gt;
-
-// I Know this is unstable
-#include &lt;tf2_msgs/TFMessage.h&gt;
-#include &lt;orb_localizer/debug.h&gt;
-#include "../__nodes/utils.h"
-
-using namespace std;
-using ORB_SLAM2::KeyFrame;
-using ORB_SLAM2::Frame;
-
-
-class ImageGrabber
-{
-public:
-	ImageGrabber(ORB_SLAM2::System* pSLAM, ros::NodeHandle *nh, bool runOffline=false);
-	~ImageGrabber ();
-
-    void GrabImage(const sensor_msgs::ImageConstPtr&amp; msg);
-
-    // This function runs in separate thread
-    void externalLocalizerGrab ();
-
-    ORB_SLAM2::System* mpSLAM;
-    ros::NodeHandle *rosNode;
-
-    // External localization
-    tf::TransformBroadcaster *mTfBr;
-    tf::TransformListener *extListener;
-    tf::StampedTransform extPose;
-    string extFrame1, extFrame2;
-    bool doStop;
-    bool doDebayer;
-    bool offlineMode;
-    int offsetKeyframe;
-
-
-    tf::Transform localizeByReference (const tf::Transform &amp;tfOrb, KeyFrame *kf);
-    tf::Transform localizeByReference (const tf::Transform &amp;tfOrb);
-    tf::Transform localizeByReference (Frame *sframe);
-
-    static tf::Transform localizeByReference (
-    	const tf::Transform &amp;tfOrb,
-		const tf::Transform &amp;tfOrbMap, const tf::Transform &amp;tfOrbMapOffset,
-    	const tf::Transform &amp;realMapPose, const tf::Transform &amp;realMapOffset);
-
-    static tf::Transform localizeByReference (const tf::Transform &amp;tfOrb, ORB_SLAM2::Map *mapsrc, const int offsetNum);
-
-	static tf::Transform getKeyFrameExtPose (const KeyFrame *kf);
-
-	static tf::Transform KeyFramePoseToTf (KeyFrame *kf);
-
-	static tf::Transform FramePose (Frame *cframe);
-
-	static cv::Vec3d tfToCv (const tf::Vector3 &amp;pos);
-
-	static cv::Mat tfToCv (const tf::Transform &amp;tfsrc);
-
-	// I Know this is unstable
-	static tf2_msgs::TFMessage createTfMessage (const tf::Transform &amp;srcTransform, const string &amp;frameSrc, const string &amp;frameTarget, double timestamp);
-
-
-	// Logging
-	image_transport::ImageTransport *imageTransport;
-	image_transport::Publisher visualDebugView;
-	ros::Publisher debugMsgPublisher;
-
-	cv::Mat framebufferDebug;
-	uint32_t lastKeyframeId;
-	double cputimeDebug;
-	double lastImageTimestamp;
-
-private:
-	void publishDebug ();
-};
-
-
-#endif /* _IMAGEGRABBER_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\bag_mapper.cc" new_path="" added_lines="0" deleted_lines="140">
				<diff>@@ -1,140 +0,0 @@
-/*
- * bag_mapper.cc
- *
- *  Created on: Jun 3, 2016
- *      Author: sujiwo
- */
-
-#include &lt;cstdlib&gt;
-#include &lt;signal.h&gt;
-#include &lt;iostream&gt;
-#include &lt;string&gt;
-#include &lt;rosbag/bag.h&gt;
-#include &lt;rosbag/view.h&gt;
-#include &lt;sensor_msgs/Image.h&gt;
-#include &lt;sensor_msgs/CompressedImage.h&gt;
-
-#include &lt;boost/foreach.hpp&gt;
-#include "../__nodes/ImageGrabber.h"
-#include "../__nodes/utils.h"
-
-
-using namespace std;
-
-
-#define foreach BOOST_FOREACH
-
-
-bool doStop = false;
-
-
-void stopHandler (int signum)
-{
-	cout &lt;&lt; "Stopping..." &lt;&lt; endl;
-	doStop = true;
-}
-
-
-
-int main (int argc, char *argv[])
-{
-	if (argc &lt; 4) {
-		cerr &lt;&lt; "\nUsage: bag_mapper path_to_settings image_bag ground_truth [second_skip] [path_to_map]\n" &lt;&lt; endl;
-		exit(1);
-	}
-
-	// Set signal handler
-	signal (SIGINT, stopHandler);
-	signal (SIGTERM, stopHandler);
-
-	string mapPath = (argc&gt;=6 ? argv[5] : string());
-	double secondToSkip = argc&gt;=5 ? atof(argv[4]) : 0.0;
-	string bagPath (argv[2]);
-	string groundTruth (argv[3]);
-	string orbVocabFile (ORB_SLAM_VOCABULARY);
-
-	// Necessary Resource
-	ORB_SLAM2::System SLAM (orbVocabFile,
-		argv[1],
-		ORB_SLAM2::System::MONOCULAR,
-		true,
-		mapPath,
-		ORB_SLAM2::System::MAPPING);
-	ImageGrabber GrabBag (&amp;SLAM, NULL, true);
-	TfTimeTree TfSource (groundTruth, SLAM.fsSettings["ExternalLocalization.frame1"], SLAM.fsSettings["ExternalLocalization.frame2"]);
-
-	// Build ROSBag Query
-	rosbag::Bag bagSrc;
-	bagSrc.open (bagPath, rosbag::bagmode::Read);
-	const string imageTopic (SLAM.fsSettings["Camera.topic"]);
-	rosbag::View viewx(bagSrc, rosbag::TopicQuery(imageTopic));
-	ros::Time startTime = viewx.getBeginTime();
-	startTime.sec += secondToSkip;
-	rosbag::View view(bagSrc, rosbag::TopicQuery(imageTopic), startTime);
-
-	const double mappingStartTime = view.getBeginTime().toSec(),
-		mappingStopTime = view.getEndTime().toSec();
-	cout &lt;&lt; "Starting at " &lt;&lt; mappingStartTime &lt;&lt; ", ending at " &lt;&lt; mappingStopTime &lt;&lt; endl;
-
-	bool tracked = false;
-	uint32_t frameCounter = 0;
-	SLAM.getTracker()-&gt;setFps(10);
-
-	foreach (rosbag::MessageInstance const msg, view) {
-
-		frameCounter ++;
-		if (frameCounter % 2 == 1)
-			continue;
-
-		double timestamp;
-
-		if (doStop==true)
-			break;
-
-		// Put mutual exclusion from here ...
-		// We intend to pause LoopClosing and LocalMapper
-		// Until frame processing is done.
-		// Also, we pause frame input until LoopClosing and LocalMapper finish their rounds
-		std::lock (SLAM.getLocalMapper()-&gt;localMappingRunMutex, SLAM.getLoopCloser()-&gt;loopCloserRunMutex);
-
-		if ((int)SLAM.fsSettings["Camera.compressed"]==1) {
-			sensor_msgs::CompressedImageConstPtr imgc = msg.instantiate&lt;sensor_msgs::CompressedImage&gt;();
-			// XXX: Not finished!
-		}
-
-		else {
-			sensor_msgs::ImageConstPtr img = msg.instantiate&lt;sensor_msgs::Image&gt;();
-			timestamp = img-&gt;header.stamp.toSec();
-			GrabBag.GrabImage(img);
-		}
-		// to here
-		SLAM.getLocalMapper()-&gt;localMappingRunMutex.unlock();
-		SLAM.getLoopCloser()-&gt;loopCloserRunMutex.unlock();
-
-		// put ground truth
-		tf::Transform currentNdtPose;
-		Frame &amp;cframe = SLAM.getTracker()-&gt;mCurrentFrame;
-
-		if (cframe.mTcw.empty()==false)
-			tracked = true;
-		else {
-			if (tracked==true) {
-//				cout &lt;&lt; "Frame Counter: " &lt;&lt; frameCounter &lt;&lt; endl;
-				cout &lt;&lt; "Stopping due to lost after " &lt;&lt; frameCounter &lt;&lt; " frames, timestamp: " &lt;&lt; timestamp &lt;&lt; endl;
-				break;
-			}
-		}
-
-		try {
-			currentNdtPose = TfSource.search(timestamp);
-			tfToCV(currentNdtPose, cframe.mpReferenceKF-&gt;extPosition, cframe.mpReferenceKF-&gt;extOrientation);
-		} catch (const std::out_of_range &amp;e) {
-			currentNdtPose.setOrigin (tf::Vector3());
-			currentNdtPose.setRotation (tf::Quaternion());
-		}
-
-		frameCounter ++;
-	}
-
-	SLAM.Shutdown();
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mapper.cc" new_path="" added_lines="0" deleted_lines="106">
				<diff>@@ -1,106 +0,0 @@
-/**
-* This file is part of ORB-SLAM2.
-*
-* Copyright (C) 2014-2016 Ral Mur-Artal &lt;raulmur at unizar dot es&gt; (University of Zaragoza)
-* For more information see &lt;https://github.com/raulmur/ORB_SLAM2&gt;
-*
-* ORB-SLAM2 is free software: you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM2 is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with ORB-SLAM2. If not, see &lt;http://www.gnu.org/licenses/&gt;.
-*/
-
-
-#include &lt;iostream&gt;
-#include &lt;string&gt;
-
-#include "../__nodes/ImageGrabber.h"
-
-
-
-using namespace std;
-using ORB_SLAM2::Frame;
-namespace enc = sensor_msgs::image_encodings;
-
-
-
-
-
-int main(int argc, char **argv)
-{
-	string myname (basename(argv[0]));
-	ORB_SLAM2::System::operationMode opMode;
-	// Which name was we called by ?
-	if (myname.compare(myname.size()-7, 7, "mapping")==0) {
-		opMode = ORB_SLAM2::System::MAPPING;
-		cout &lt;&lt; "Mode: Mapper" &lt;&lt; endl;
-	}
-	else {  // == "matching"
-		opMode = ORB_SLAM2::System::LOCALIZATION;
-		cout &lt;&lt; "Mode: Localizer" &lt;&lt; endl;
-	}
-
-    ros::init(argc, argv, "orb_slam_mapper");
-    ros::start();
-    ros::NodeHandle nodeHandler;
-
-    if(argc &lt; 2)
-    {
-        cerr &lt;&lt; endl &lt;&lt; "Usage: " &lt;&lt; myname &lt;&lt; " path_to_settings [path_to_map]\n" &lt;&lt; endl;
-        ros::shutdown();
-        return 1;
-    }
-
-    // Create SLAM system. It initializes all system threads and gets ready to process frames.
-    string mapPath = (argc==3) ? argv[2] : string();
-
-    // This macro should be set by Cmake
-    string orbVocabFile (ORB_SLAM_VOCABULARY);
-    const bool useVisualization = opMode==ORB_SLAM2::System::MAPPING ? true : false;
-    ORB_SLAM2::System SLAM(orbVocabFile,
-    	argv[1],
-		ORB_SLAM2::System::MONOCULAR,
-		useVisualization,
-		mapPath,
-    	opMode);
-
-    std::thread* tExtLocalizer;
-    ImageGrabber igb(&amp;SLAM, &amp;nodeHandler);
-    if (opMode==ORB_SLAM2::System::MAPPING)
-    	tExtLocalizer = new std::thread (&amp;ImageGrabber::externalLocalizerGrab, &amp;igb);
-    else
-    	tExtLocalizer = NULL;
-
-    image_transport::TransportHints th;
-    if ((int)SLAM.fsSettings["Camera.compressed"]==0) {
-    	th = image_transport::TransportHints ("raw");
-    }
-    else if ((int)SLAM.fsSettings["Camera.compressed"]==1) {
-    	th = image_transport::TransportHints ("compressed");
-    }
-    image_transport::ImageTransport it (nodeHandler);
-    image_transport::Subscriber sub = it.subscribe ((string)SLAM.fsSettings["Camera.topic"], 1, &amp;ImageGrabber::GrabImage, &amp;igb, th);
-
-    cout &lt;&lt; endl &lt;&lt; "Mono Camera topic: " &lt;&lt; (string)SLAM.fsSettings["Camera.topic"] &lt;&lt; endl;
-    cout &lt;&lt; "Compressed images? " &lt;&lt; ((int)SLAM.fsSettings["Camera.compressed"]==1 ? "True" : "False") &lt;&lt; endl;
-
-    ros::spin();
-
-    // Stop all threads
-    SLAM.Shutdown();
-    igb.doStop = true;
-    if (tExtLocalizer != NULL)
-    	tExtLocalizer-&gt;join();
-
-    ros::shutdown();
-
-    return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\DebugMT.cc" new_path="" added_lines="0" deleted_lines="63">
				<diff>@@ -1,63 +0,0 @@
-/*
- * DebugMT.cpp
- *
- *  Created on: Jul 28, 2016
- *      Author: sujiwo
- */
-
-#include "../../__nodes/mt/DebugMT.h"
-
-#include "../../__nodes/mt/TrackingThread.h"
-
-
-
-extern const char
-	*framebufferDebugTopic,
-	*internalTopic;
-
-
-
-DebugMT::DebugMT (TrackingThread *t, ros::NodeHandle &amp;nh, const string &amp;sid) :
-
-	node (nh),
-	identifier (sid),
-	proc (t)
-
-{
-	imageTransport = new image_transport::ImageTransport (node);
-	visualDebugView = imageTransport-&gt;advertise(string(framebufferDebugTopic) + "/map" + identifier, 1);
-	debugMsgPublisher = node.advertise&lt;orb_localizer::debug&gt; (string(internalTopic) + "/map" + identifier, 1);
-}
-
-
-DebugMT::~DebugMT()
-{}
-
-
-void DebugMT::notify()
-{
-	mTfBr.sendTransform(tf::StampedTransform(
-		proc-&gt;getCurrent(),
-		ros::Time (proc-&gt;getLastTime()),
-		proc-&gt;parentFrame,
-		proc-&gt;targetFrame
-	));
-
-	proc-&gt;framedraw-&gt;DrawFrame();
-	framebufferDebug = proc-&gt;framedraw-&gt;getLastFrame();
-
-	cv_bridge::CvImage bagImage;
-	bagImage.image = framebufferDebug;
-	bagImage.header.stamp = ros::Time(lastImageTimestamp);
-	bagImage.header.frame_id = identifier;
-	bagImage.encoding = "bgr8";
-	visualDebugView.publish(bagImage.toImageMsg());
-
-//	orb_localizer::debug internalDebugMsg;
-//	internalDebugMsg.header.stamp = ros::Time (lastImageTimestamp);
-//	internalDebugMsg.header.frame_id = identifier;
-//	internalDebugMsg.keyframe_id = lastKeyframeId;
-//	internalDebugMsg.cputime = cputimeDebug;
-//	debugMsgPublisher.publish (internalDebugMsg);
-
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\DebugMT.h" new_path="" added_lines="0" deleted_lines="57">
				<diff>@@ -1,57 +0,0 @@
-/*
- * DebugMT.h
- *
- *  Created on: Jul 28, 2016
- *      Author: sujiwo
- */
-
-#ifndef _DEBUGMT_H_
-#define _DEBUGMT_H_
-
-
-#include &lt;string&gt;
-#include &lt;mutex&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;cv_bridge/cv_bridge.h&gt;
-#include &lt;image_transport/image_transport.h&gt;
-#include &lt;sensor_msgs/Image.h&gt;
-#include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;tf/transform_broadcaster.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-#include &lt;orb_localizer/debug.h&gt;
-
-
-using namespace std;
-
-
-class TrackingThread;
-
-
-class DebugMT {
-public:
-	DebugMT (TrackingThread *th, ros::NodeHandle &amp;nh, const string &amp;sid);
-	virtual ~DebugMT();
-
-	void notify ();
-
-	void publishParticles ();
-
-private:
-	TrackingThread *proc;
-	ros::NodeHandle &amp;node;
-	const string &amp;identifier;
-	tf::TransformBroadcaster mTfBr;
-
-	image_transport::ImageTransport *imageTransport;
-	image_transport::Publisher visualDebugView;
-	ros::Publisher debugMsgPublisher;
-
-	cv::Mat framebufferDebug;
-	uint32_t lastKeyframeId;
-	double cputimeDebug;
-	double lastImageTimestamp;
-
-};
-
-#endif /* _DEBUGMT_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\SystemMT.cc" new_path="" added_lines="0" deleted_lines="215">
				<diff>@@ -1,215 +0,0 @@
-/*
- * SystemMT.cpp
- *
- *  Created on: Jul 22, 2016
- *      Author: sujiwo
- */
-
-#include "../../__nodes/mt/SystemMT.h"
-
-#include &lt;string&gt;
-
-
-
-
-using namespace std;
-using ORB_SLAM2::ORBVocabulary;
-
-
-const double orbError = 0.5;
-
-
-SystemMT::SystemMT (ros::NodeHandle &amp;nh, const vector&lt;string&gt; &amp;mapPaths, const string &amp;vocabPath, const string &amp;_settingsPath) :
-
-	settingPath (_settingsPath),
-
-	imgIsNew (false),
-
-	rosnode (nh),
-
-	// XXX: we silently assume that map loading is always successful
-	readyCheck (mapPaths.size()+1)
-
-{
-	fSetting = cv::FileStorage (settingPath.c_str(), cv::FileStorage::READ);
-
-	sVocab = new ORBVocabulary();
-    if (vocabPath.empty() == false) {
-    	cout &lt;&lt; "Loading vocabulary ... ";
-		bool bVocLoad = sVocab-&gt;loadFromTextFile(vocabPath);
-		if(!bVocLoad)
-		{
-			cerr &lt;&lt; "Wrong path to vocabulary. " &lt;&lt; endl;
-			cerr &lt;&lt; "Failed to open at: " &lt;&lt; vocabPath &lt;&lt; endl;
-			exit(-1);
-		}
-		cout &lt;&lt; "Done" &lt;&lt; endl &lt;&lt; endl;
-    }
-
-    int i = 1;
-    for (auto mp: mapPaths) {
-    	string ids = std::to_string (i);
-    	TrackingThread *pth = new TrackingThread (mp, this, ids);
-    	children.push_back(pth);
-    	i += 1;
-    }
-
-    pfilter = new PF::ParticleFilter&lt;CamState, tf::Transform, double&gt; (NUMBER_OF_PARTICLE, vehicleModel);
-
-    // Wait until all workers ready
-    cout &lt;&lt; "Waiting for all workers to be ready... " &lt;&lt; endl;
-    readyCheck.wait();
-    cout &lt;&lt; "All workers ready" &lt;&lt; endl;
-}
-
-
-/*
- * XXX: this destructor does not work correctly
- */
-SystemMT::~SystemMT ()
-{
-	{
-		boost::lock_guard&lt;boost::mutex&gt; lock (imgLock);
-		for (auto proct: children)
-			proct-&gt;stop();
-	}
-	imgMon.notify_all();
-
-	for (auto proct: children)
-		delete (proct);
-//	for (auto proct: children) {
-//		proct-&gt;stop();
-//		cout &lt;&lt; "Stopping worker #" &lt;&lt; proct-&gt;identity &lt;&lt; endl;
-//		delete (proct);
-//	}
-
-	delete (pfilter);
-}
-
-
-/*
- * We expect colorful image, unbayered
- */
-void SystemMT::Track (const cv::Mat &amp;srcImage, const double timestamp)
-{
-	currentTimestamp = timestamp;
-
-	{
-		boost::lock_guard&lt;boost::mutex&gt; lock (imgLock);
-
-		currentImage = srcImage.clone();
-		// resize and crop
-		// Do Resizing and cropping here
-		cv::resize(currentImage, currentImage,
-			cv::Size(
-				(int)fSetting["Camera.WorkingResolution.Width"],
-				(int)fSetting["Camera.WorkingResolution.Height"]
-			));
-		currentImage = currentImage(
-			cv::Rect(
-				(int)fSetting["Camera.ROI.x0"],
-				(int)fSetting["Camera.ROI.y0"],
-				(int)fSetting["Camera.ROI.width"],
-				(int)fSetting["Camera.ROI.height"]
-			)).clone();
-
-		imgIsNew = true;
-		currentTimestamp = timestamp;
-	}
-	// notify worker threads to begin
-	imgMon.notify_all();
-
-//	filter ();
-
-	readyCheck.wait();
-	imgIsNew = false;
-
-}
-
-
-void SystemMT::filter()
-{
-	if (!vehicleModel.isInitialized()) {
-		for (auto proct: children) {
-			if (!proct-&gt;poseIsValid())
-				continue;
-			// we found valid pose; set this as particle initialization
-			vehicleModel.preinitialize(proct-&gt;getCurrent(), currentTimestamp);
-			break;
-		}
-		pfilter-&gt;initializeParticles();
-		return;
-	}
-//	prev
-
-}
-
-
-OrbMapFusion::OrbMapFusion() :
-	initialized (false),
-	prevTimestamp (0)
-{}
-
-
-void OrbMapFusion::preinitialize(const tf::Transform &amp;iPose, const double ts)
-{
-	prevTimestamp = ts;
-	initPose = iPose;
-	initialized = true;
-}
-
-
-CamState OrbMapFusion::initializeParticleState() const
-{
-	CamState m0 (initPose);
-	double ds = PF::nrand(orbError),
-		xn = m0.getOrigin().x(),
-		yn = m0.getOrigin().y(),
-		zn = m0.getOrigin().z();
-	m0.setOrigin(tf::Vector3(xn, yn, zn));
-	return m0;
-}
-
-
-/*
- * XXX: this motion model is untested !
- * Need to initialize velocity
- */
-CamState OrbMapFusion::motionModel(const CamState &amp;vstate, const double &amp;t) const
-{
-	CamState nstate;
-
-	double dt = t - prevTimestamp;
-	double x = vstate.getOrigin().x() + vstate.velocity.x()*dt + PF::nrand(orbError);
-	double y = vstate.getOrigin().y() + vstate.velocity.y()*dt + PF::nrand(orbError);
-	double z = vstate.getOrigin().z() + vstate.velocity.z()*dt + PF::nrand(orbError);
-	double vx = (x-vstate.getOrigin().x()) / dt;
-	double vy = (y-vstate.getOrigin().y()) / dt;
-	double vz = (z-vstate.getOrigin().z()) / dt;
-
-	nstate.setOrigin(tf::Vector3(x, y, z));
-	nstate.velocity = tf::Vector3 (vx, vy, vz);
-	return nstate;
-}
-
-
-double OrbMapFusion::measurementModel(const CamState &amp;state, const vector&lt;tf::Transform&gt; &amp;observations) const
-{
-	vector&lt;double&gt; obsWeight;
-
-	for (const auto &amp;pose: observations) {
-		double wo,
-			xt = pose.getOrigin().x(),
-			yt = pose.getOrigin().y(),
-			zt = pose.getOrigin().z(),
-			xs = state.getOrigin().x(),
-			ys = state.getOrigin().y(),
-			zs = state.getOrigin().z();
-		wo = exp (-(pow(xt-xs,2) / (2*orbError*orbError) +
-			pow(yt-ys,2) / (2*orbError*orbError)));
-		obsWeight.push_back(wo);
-	}
-
-	double w = *std::max_element(obsWeight.begin(), obsWeight.end());
-	return max(w, 0.01);
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\SystemMT.h" new_path="" added_lines="0" deleted_lines="136">
				<diff>@@ -1,136 +0,0 @@
-/*
- * SystemMT.h
- *
- *  Created on: Jul 22, 2016
- *      Author: sujiwo
- */
-
-#ifndef _SYSTEMMT_H_
-#define _SYSTEMMT_H_
-
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;mutex&gt;
-#include &lt;boost/thread.hpp&gt;
-
-#include &lt;tf/tf.h&gt;
-
-//#include "System.h"
-#include "KeyFrameDatabase.h"
-#include "ORBVocabulary.h"
-#include "ParticleFilter.h"
-#include "../../__nodes/mt/TrackingThread.h"
-
-//#include &lt;sensor_msgs/Image.h&gt;
-//#include &lt;sensor_msgs/image_encodings.h&gt;
-
-
-using namespace std;
-
-#define frameTimeout 0.1		// seconds
-#define NUMBER_OF_PARTICLE 500
-
-
-struct CamState : public tf::Transform
-{
-	CamState (const tf::Transform &amp;tfsc)
-	{
-		setOrigin(tfsc.getOrigin());
-		setRotation(tfsc.getRotation());
-		velocity.setX(0.0); velocity.setY(0.0); velocity.setZ(0.0);
-	}
-
-	CamState () {}
-
-	CamState (float dt[8])
-	{
-		setOrigin(tf::Vector3(dt[0], dt[1], dt[2]));
-		setRotation(tf::Quaternion(dt[3], dt[4], dt[5], dt[6]));
-		velocity.setX(0.0); velocity.setY(0.0); velocity.setZ(0.0);
-	}
-
-//	tfScalar&amp; x() { return getOrigin().m_floats[0]; }
-//	tfScalar&amp; y() { return getOrigin().m_floats[1]; }
-//	tfScalar&amp; z() { return getOrigin().m_floats[2]; }
-//	tfScalar&amp; qx() { return getRotation().m_floats[0]; }
-//	tfScalar&amp; qx() { return getRotation().m_floats[0]; }
-//	tfScalar&amp; qx() { return getRotation().m_floats[0]; }
-//	tfScalar&amp; qx() { return getRotation().m_floats[0]; }
-
-	// Velocity vector
-	tf::Vector3 velocity;
-};
-
-
-struct Motion: public tf::Vector3
-{
-Motion()
-{}
-
-public:
-	double timestamp;
-};
-
-
-class OrbMapFusion :
-	public PF::VehicleBase&lt;CamState, tf::Transform, double&gt;
-{
-public:
-	OrbMapFusion ();
-	void preinitialize (const tf::Transform &amp;initialPose, const double t);
-
-	CamState initializeParticleState () const;
-
-	CamState motionModel (const CamState &amp;vstate, const double &amp;v) const;
-
-	double measurementModel (const CamState &amp;state, const vector&lt;tf::Transform&gt; &amp;observations) const;
-
-	bool isInitialized () const { return initialized; }
-
-private:
-	tf::Transform initPose;
-	bool initialized;
-	double prevTimestamp;
-};
-
-
-
-class SystemMT
-{
-public:
-
-	SystemMT (ros::NodeHandle &amp;nh, const vector&lt;string&gt; &amp;mapPaths, const string &amp;vocabPath, const string &amp;settingsPath);
-	~SystemMT ();
-
-	void Track (const cv::Mat &amp;srcImage, const double timestamp);
-
-	const cv::FileStorage *getSettings () { return &amp;fSetting; }
-
-	friend class TrackingThread;
-
-private:
-	ros::NodeHandle &amp;rosnode;
-	vector&lt;TrackingThread*&gt; children;
-	ORB_SLAM2::ORBVocabulary *sVocab;
-	const string &amp;settingPath;
-
-	cv::FileStorage fSetting;
-
-	boost::barrier readyCheck;
-
-	// Monitor for localizer threads
-	boost::condition_variable imgMon;
-	boost::mutex imgLock;
-	volatile bool imgIsNew;
-
-	cv::Mat currentImage;
-	double currentTimestamp;
-
-	void filter ();
-
-	PF::ParticleFilter&lt;CamState, tf::Transform, double&gt; *pfilter;
-	OrbMapFusion vehicleModel;
-};
-
-#endif /* _SYSTEMMT_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\TrackingThread.cc" new_path="" added_lines="0" deleted_lines="125">
				<diff>@@ -1,125 +0,0 @@
-#include "../../__nodes/mt/TrackingThread.h"
-
-#include "System.h"
-// XXX: Refactor ImageGrabber.{cc,h}
-#include &lt;tf/tf.h&gt;
-#include "../../__nodes/ImageGrabber.h"
-#include "../../__nodes/mt/DebugMT.h"
-#include "../../__nodes/mt/SystemMT.h"
-
-
-using ORB_SLAM2::Map;
-using ORB_SLAM2::KeyFrameDatabase;
-using ORB_SLAM2::Tracking;
-using ORB_SLAM2::System;
-using ORB_SLAM2::FrameDrawer;
-
-
-
-TrackingThread::TrackingThread (const string &amp;mappath, SystemMT *sysmt, const string &amp;ids) :
-	sysParent (sysmt),
-	doStop (false),
-	mapFilename (mappath),
-	identity (ids),
-
-	parentFrame ((string)(sysmt-&gt;fSetting["ExternalLocalization.frame1"])),
-	targetFrame ((string)(sysmt-&gt;fSetting["ExternalLocalization.frame2"]) + "/map"+ids),
-
-	offsetKeyframeNum ( (int)sysmt-&gt;fSetting["ExternalLocalization.OffsetKeyframes"] )
-{
-	tMap = new Map ();
-	kfdb = new KeyFrameDatabase (*sysParent-&gt;sVocab);
-	framedraw = new FrameDrawer (tMap);
-
-	debugger = new DebugMT (this, sysParent-&gt;rosnode, identity);
-
-	// start map loading from here
-	proc = new thread (&amp;TrackingThread::run, this);
-}
-
-
-TrackingThread::~TrackingThread()
-{
-	doStop = true;
-	proc-&gt;join ();
-	cout &lt;&lt; "Localizer " &lt;&lt; identity &lt;&lt; " ended\n";
-}
-
-
-void TrackingThread::run ()
-{
-	tMap-&gt;loadFromDisk(mapFilename, kfdb);
-
-	tTrack = new Tracking (NULL, sysParent-&gt;sVocab, framedraw, NULL, tMap, kfdb, sysParent-&gt;settingPath, System::MONOCULAR);
-	tTrack-&gt;setMapLoaded();
-	tTrack-&gt;InformOnlyTracking(true);
-
-	cout &lt;&lt; "Worker " &lt;&lt; identity &lt;&lt; " ready" &lt;&lt; endl;
-	sysParent-&gt;readyCheck.wait();
-
-	while (true) {
-
-		{
-			boost::unique_lock&lt;boost::mutex&gt; lock (sysParent-&gt;imgLock);
-			while (sysParent-&gt;imgIsNew==false and doStop==false)
-				sysParent-&gt;imgMon.wait(lock);
-			if (doStop==true) {
-				cout &lt;&lt; "Worker " &lt;&lt; identity &lt;&lt; " quit" &lt;&lt; endl;
-				break;
-			}
-		}
-
-		tTrack-&gt;GrabImageMonocular(sysParent-&gt;currentImage, sysParent-&gt;currentTimestamp);
-		Frame &amp;cframe = tTrack-&gt;mCurrentFrame;
-		if (tTrack-&gt;mLastProcessedState==Tracking::OK) {
-
-			tf::Transform orbCPose = ImageGrabber::FramePose(&amp;cframe);
-			try {
-				tf::Transform cp = ImageGrabber::localizeByReference(orbCPose, tMap, offsetKeyframeNum);
-				currentPose.x = cp.getOrigin().x();
-				currentPose.y = cp.getOrigin().y();
-				currentPose.z = cp.getOrigin().z();
-				currentPose.qx = cp.getRotation().x();
-				currentPose.qy = cp.getRotation().y();
-				currentPose.qz = cp.getRotation().z();
-				currentPose.qw = cp.getRotation().w();
-			} catch (...) {
-				invalidPose;
-			}
-		}
-		else {
-			invalidPose;
-		}
-
-		// XXX: Do something useful here
-		debugger-&gt;notify();
-//		usleep(50000);
-
-		sysParent-&gt;readyCheck.wait();
-	}
-}
-
-
-void TrackingThread::stop()
-{
-	doStop = true;
-}
-
-
-void TrackingThread::output(cv::Mat &amp;out)
-{
-
-}
-
-
-double TrackingThread::getLastTime()
-{ return sysParent-&gt;currentTimestamp; }
-
-
-tf::Transform TrackingThread::getCurrent ()
-{
-	tf::Transform p;
-	p.setOrigin (tf::Vector3(currentPose.x, currentPose.y, currentPose.z));
-	p.setRotation(tf::Quaternion(currentPose.qx, currentPose.qy, currentPose.qz, currentPose.qw));
-	return p;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\TrackingThread.h" new_path="" added_lines="0" deleted_lines="85">
				<diff>@@ -1,85 +0,0 @@
-#ifndef _TRACKING_THREAD_H
-#define _TRACKING_THREAD_H
-
-#include &lt;vector&gt;
-#include &lt;string&gt;
-#include &lt;thread&gt;
-#include &lt;condition_variable&gt;
-
-
-#include "Tracking.h"
-#include "FrameDrawer.h"
-
-#include "../../__nodes/mt/DebugMT.h"
-
-
-using namespace std;
-
-
-class SystemMT;
-
-
-class TrackingThread
-{
-public:
-
-	TrackingThread (const string &amp;mapFilename, SystemMT *_sysmt, const string &amp;ids);
-	~TrackingThread ();
-
-	void trackImage ();
-
-	void run ();
-	void stop ();
-
-	friend class SystemMT;
-	friend class DebugMT;
-
-private:
-	ORB_SLAM2::Map *tMap;
-	ORB_SLAM2::KeyFrameDatabase *kfdb;
-	ORB_SLAM2::Tracking *tTrack;
-	ORB_SLAM2::FrameDrawer *framedraw;
-
-	DebugMT *debugger;
-
-	const string mapFilename;
-	string identity;
-	const int offsetKeyframeNum;
-
-	const string parentFrame;
-	const string targetFrame;
-
-	SystemMT *sysParent;
-	volatile bool doStop;
-	thread *proc;
-
-	void output (cv::Mat &amp;trackOutput);
-
-	union {
-		struct {
-			float x, y, z, qx, qy, qz, qw;
-		};
-		float data[8];
-	} currentPose;
-
-	inline bool poseIsValid()
-	{
-		return !isnanf(currentPose.x)
-			and !isnanf(currentPose.y)
-			and !isnanf(currentPose.z)
-			and !isnanf(currentPose.qx)
-			and !isnanf(currentPose.qy)
-			and !isnanf(currentPose.qz)
-			and !isnanf(currentPose.qw);
-	}
-
-	tf::Transform getCurrent ();
-	double getLastTime ();
-};
-
-
-#define invalidPose \
-	for (auto __i=0; __i&lt;8; __i++) currentPose.data[__i] = NAN;
-
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\mt\matching_mt.cc" new_path="" added_lines="0" deleted_lines="113">
				<diff>@@ -1,113 +0,0 @@
-#include &lt;vector&gt;
-#include &lt;thread&gt;
-#include &lt;string&gt;
-#include &lt;iostream&gt;
-
-#include "Map.h"
-#include &lt;ros/ros.h&gt;
-#include &lt;sensor_msgs/Image.h&gt;
-#include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;cv_bridge/cv_bridge.h&gt;
-#include &lt;image_transport/image_transport.h&gt;
-#include "../../__nodes/mt/SystemMT.h"
-#include "../../__nodes/mt/TrackingThread.h"
-
-
-
-using namespace std;
-namespace enc = sensor_msgs::image_encodings;
-
-
-
-SystemMT *localizer;
-
-
-
-
-
-void imageProcess (const sensor_msgs::ImageConstPtr&amp; msg)
-{
-	cv::Mat image;
-
-	// Copy the ros image message to cv::Mat.
-	cv_bridge::CvImageConstPtr cv_ptr;
-	try
-	{
-		cv_ptr = cv_bridge::toCvShare(msg);
-	}
-	catch (cv_bridge::Exception&amp; e)
-	{
-		ROS_ERROR("cv_bridge exception: %s", e.what());
-		return;
-	}
-
-	if (enc::isBayer(msg-&gt;encoding)) {
-		int code=-1;
-		if (msg-&gt;encoding == enc::BAYER_RGGB8 ||
-			msg-&gt;encoding == enc::BAYER_RGGB16) {
-			code = cv::COLOR_BayerBG2BGR;
-		}
-		else if (msg-&gt;encoding == enc::BAYER_BGGR8 ||
-				 msg-&gt;encoding == enc::BAYER_BGGR16) {
-			code = cv::COLOR_BayerRG2BGR;
-		}
-		else if (msg-&gt;encoding == enc::BAYER_GBRG8 ||
-				 msg-&gt;encoding == enc::BAYER_GBRG16) {
-			code = cv::COLOR_BayerGR2BGR;
-		}
-		else if (msg-&gt;encoding == enc::BAYER_GRBG8 ||
-				 msg-&gt;encoding == enc::BAYER_GRBG16) {
-			code = cv::COLOR_BayerGB2BGR;
-		}
-		cv::cvtColor(cv_ptr-&gt;image, image, code);
-	}
-	else
-		image = cv_ptr-&gt;image;
-
-	localizer-&gt;Track(image, msg-&gt;header.stamp.toSec());
-}
-
-
-
-int main (int argc, char *argv[])
-{
-	if (argc &lt; 3) {
-		cerr &lt;&lt; "Usage: orb_matching_mt setting_file map1 &lt;map2&gt; ... &lt;map_n&gt;" &lt;&lt; endl;
-		exit (-1);
-	}
-
-	const string settingPath = argv[1];
-	vector&lt;string&gt; mapPaths;
-	for (int i=2; i&lt;argc; i++) {
-		string mp = argv[i];
-		mapPaths.push_back(mp);
-	}
-
-    ros::init(argc, argv, "orb_matching_mt");
-    ros::start();
-    ros::NodeHandle nodeHandler;
-
-    // This macro should be set by Cmake
-	string orbVocabFile (ORB_SLAM_VOCABULARY);
-
-	localizer = new SystemMT (nodeHandler, mapPaths, orbVocabFile, settingPath);
-
-	image_transport::TransportHints th;
-	const cv::FileStorage &amp;fsetting = *(localizer-&gt;getSettings());
-	if ((int)fsetting["Camera.compressed"]==0) {
-		th = image_transport::TransportHints ("raw");
-	}
-	else if ((int)fsetting["Camera.compressed"]==1) {
-		th = image_transport::TransportHints ("compressed");
-	}
-	image_transport::ImageTransport it (nodeHandler);
-	image_transport::Subscriber sub = it.subscribe ((string)fsetting["Camera.topic"], 1, imageProcess, th);
-	cout &lt;&lt; endl &lt;&lt; "Mono Camera topic: " &lt;&lt; (string)fsetting["Camera.topic"] &lt;&lt; endl;
-	cout &lt;&lt; "Compressed images? " &lt;&lt; ((int)fsetting["Camera.compressed"]==1 ? "True" : "False") &lt;&lt; endl;
-
-	ros::spin();
-	cout &lt;&lt; "... Done" &lt;&lt; endl;
-
-	delete (localizer);
-	return 0;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\offline_offset.cc" new_path="" added_lines="0" deleted_lines="252">
				<diff>@@ -1,252 +0,0 @@
-/*
- * offline_offset.cc
- *
- *  Created on: Jun 5, 2016
- *      Author: sujiwo
- */
-
-
-#include &lt;iostream&gt;
-#include &lt;vector&gt;
-#include &lt;cstdlib&gt;
-#include &lt;cstdio&gt;
-
-#include &lt;rosbag/bag.h&gt;
-#include &lt;rosbag/view.h&gt;
-#include &lt;tf/tf.h&gt;
-#include &lt;tf/tfMessage.h&gt;
-#include &lt;tf/transform_datatypes.h&gt;
-#include &lt;boost/foreach.hpp&gt;
-
-#define PCL_NO_PRECOMPILE
-#include &lt;pcl/point_cloud.h&gt;
-#include &lt;pcl/octree/octree.h&gt;
-#include &lt;pcl/octree/impl/octree_search.hpp&gt;
-
-#include "System.h"
-#include "Map.h"
-#include "KeyFrame.h"
-#include "../__nodes/ImageGrabber.h"
-
-
-using namespace std;
-using ORB_SLAM2::System;
-using ORB_SLAM2::Map;
-using ORB_SLAM2::KeyFrame;
-
-
-#define foreach BOOST_FOREACH
-
-
-struct MapPt {
-	PCL_ADD_POINT4D;
-	uint32_t kfId;
-	EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-} EIGEN_ALIGN16 ;
-
-
-struct FakeMap
-{
-    pcl::PointCloud&lt;MapPt&gt;::Ptr kfCloud;
-    pcl::octree::OctreePointCloudSearch&lt;MapPt&gt;::Ptr kfOctree;
-
-    vector&lt;tf::Transform&gt; orbPoints;
-    vector&lt;tf::Transform&gt; realPoints;
-
-	FakeMap (const string &amp;csvPath)
-	{
-		FILE *mapfd;
-		mapfd = fopen (csvPath.c_str(), "r");
-		double
-			timestamp,
-			xo,
-			yo,
-			zo,
-			qxo,
-			qyo,
-			qzo,
-			qwo,
-			xr,
-			yr,
-			zr,
-			qxr,
-			qyr,
-			qzr,
-			qwr;
-		uint32_t pos = 0;
-
-		while (fscanf(mapfd, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
-			&amp;timestamp,
-			&amp;xo,
-			&amp;yo,
-			&amp;zo,
-			&amp;qxo,
-			&amp;qyo,
-			&amp;qzo,
-			&amp;qwo,
-			&amp;xr,
-			&amp;yr,
-			&amp;zr,
-			&amp;qxr,
-			&amp;qyr,
-			&amp;qzr,
-			&amp;qwr) != EOF) {
-
-			tf::Transform orbPt, realMapPt;
-			orbPt.setOrigin(tf::Vector3(xo, yo, zo));
-			orbPt.setRotation(tf::Quaternion(qxo, qyo, qzo, qwo));
-			realMapPt.setOrigin(tf::Vector3(xr, yr, zr));
-			realMapPt.setRotation(tf::Quaternion(qxr, qyr, qzr, qwr));
-
-			orbPoints.push_back(orbPt);
-			realPoints.push_back(realMapPt);
-		}
-
-		fclose (mapfd);
-
-		kfCloud = pcl::PointCloud&lt;MapPt&gt;::Ptr (new pcl::PointCloud&lt;MapPt&gt;);
-		kfCloud-&gt;width = orbPoints.size();
-		kfCloud-&gt;height = 1;
-		kfCloud-&gt;resize(kfCloud-&gt;width);
-		for (int p=0; p&lt;orbPoints.size(); p++) {
-			const tf::Transform &amp;kf = orbPoints[p];
-			kfCloud-&gt;at(p).x = kf.getOrigin().x();
-			kfCloud-&gt;at(p).y = kf.getOrigin().y();
-			kfCloud-&gt;at(p).z = kf.getOrigin().z();
-			kfCloud-&gt;at(p).kfId = p;
-		}
-		kfOctree = pcl::octree::OctreePointCloudSearch&lt;MapPt&gt;::Ptr (new pcl::octree::OctreePointCloudSearch&lt;MapPt&gt; (1.0));
-		kfOctree-&gt;setInputCloud(kfCloud);
-		kfOctree-&gt;addPointsFromInputCloud();
-	}
-
-	int search (const double x, const double y, const double z,
-		tf::Transform &amp;orbMapPos, tf::Transform &amp;realMapPos)
-	{
-		MapPt queryPoint;
-		queryPoint.x = x, queryPoint.y = y, queryPoint.z = z;
-
-		const int k = 2;
-		vector&lt;int&gt; idcs;
-		vector&lt;float&gt; sqrDist;
-		idcs.resize(k);
-		sqrDist.resize(k);
-
-		int r = kfOctree-&gt;nearestKSearch(queryPoint, k, idcs, sqrDist);
-		if (r==0)
-			return -1;
-		uint32_t ptId = kfCloud-&gt;at(idcs[0]).kfId;
-		orbMapPos = orbMapAt (ptId);
-		realMapPos = realMapAt (ptId);
-		return ptId;
-	}
-
-	tf::Transform orbMapAt (const uint32_t &amp;i)
-	{ return orbPoints.at(i); }
-
-	tf::Transform realMapAt (const uint32_t &amp;i)
-	{ return realPoints.at(i); }
-
-};
-
-
-
-int main (int argc, char *argv[])
-{
-	FakeMap *fakeMap = NULL;
-	double secondToSkip = 0.0;
-
-	if (argc&lt;3) {
-		cout &lt;&lt; "\nUsage:\n";
-		cout &lt;&lt; "offline_offset path_to_settings orb_result_bag map_file [secondToSkip]\n" &lt;&lt; endl;
-		exit(1);
-	}
-
-	string emptyStr;
-	System SLAM(emptyStr, argv[1], System::MONOCULAR,true, argv[3], System::LOCALIZATION);
-	Map *mapSrc = SLAM.getMap();
-	int offsetKeyframe = (int)SLAM.fsSettings["ExternalLocalization.OffsetKeyframes"];
-
-	if (mapSrc-&gt;KeyFramesInMap()==0) {
-		fakeMap = new FakeMap (argv[3]);
-	}
-
-	if (argc&gt;=4)
-		secondToSkip = atof (argv[4]);
-
-	// Build ROSBag Query
-	rosbag::Bag bagSrc;
-	bagSrc.open (argv[2], rosbag::bagmode::Read);
-	rosbag::View viewx(bagSrc, rosbag::TopicQuery("/tf"));
-	ros::Time startTime = viewx.getBeginTime();
-	startTime.sec += secondToSkip;
-	rosbag::View view(bagSrc, rosbag::TopicQuery("/tf"), startTime);
-	cout &lt;&lt; "Fetching..." &lt;&lt; endl;
-
-	const string orbSrcFrame = "/ORB_SLAM/World",
-		orbTgFrame = "/ORB_SLAM/Camera";
-
-	// prepare Stdout
-    cout &lt;&lt; std::fixed &lt;&lt; setprecision(6);
-
-	foreach (rosbag::MessageInstance const msg, view) {
-
-		// take current position from bag
-		tf::tfMessageConstPtr curPosMsg = msg.instantiate&lt;tf::tfMessage&gt;();
-		const double timestamp = curPosMsg-&gt;transforms[0].header.stamp.toSec();
-
-		if (curPosMsg-&gt;transforms[0].header.frame_id != orbSrcFrame or
-				curPosMsg-&gt;transforms[0].child_frame_id != orbTgFrame)
-			continue;
-
-		// find keyframe position in map
-		tf::Transform
-			orbPos,
-			orbMapPos,
-			realMapPos,
-			realPos;
-
-		geometry_msgs::Transform pose = curPosMsg-&gt;transforms[0].transform;
-		double x = pose.translation.x,
-			y = pose.translation.y,
-			z = pose.translation.z;
-		orbPos.setOrigin(tf::Vector3(x, y, z));
-		orbPos.setRotation(tf::Quaternion(
-			pose.rotation.x,
-			pose.rotation.y,
-			pose.rotation.z,
-			pose.rotation.w));
-
-		if (fakeMap != NULL) {
-			int ptId = fakeMap-&gt;search(x, y, z, orbMapPos, realMapPos);
-			ptId -= offsetKeyframe;
-			if (ptId&lt;0)
-				continue;
-			tf::Transform orbMapOff = fakeMap-&gt;orbMapAt(ptId);
-			tf::Transform realMapOff = fakeMap-&gt;realMapAt(ptId);
-			realPos = ImageGrabber::localizeByReference(
-				orbPos,
-				orbMapPos, orbMapOff,
-				realMapPos, realMapOff);
-		}
-		else {
-			KeyFrame *kfReference = SLAM.getMap()-&gt;getNearestKeyFrame(x, y, z),
-				*kfOffset = SLAM.getMap()-&gt;offsetKeyframe(kfReference, offsetKeyframe);
-
-			orbMapPos = ImageGrabber::KeyFramePoseToTf(kfReference);
-			realMapPos = ImageGrabber::getKeyFrameExtPose(kfReference);
-			tf::Transform orbMapOff = ImageGrabber::KeyFramePoseToTf(kfOffset);
-		}
-
-		cout &lt;&lt; timestamp &lt;&lt; " " &lt;&lt; realPos.getOrigin().x() &lt;&lt; " " &lt;&lt; realPos.getOrigin().y() &lt;&lt; " " &lt;&lt; realPos.getOrigin().z() &lt;&lt; " ";
-		cout &lt;&lt; realPos.getRotation().x() &lt;&lt; " " &lt;&lt; realPos.getRotation().y() &lt;&lt; " " &lt;&lt; realPos.getRotation().z() &lt;&lt; " " &lt;&lt; realPos.getRotation().w() &lt;&lt; endl;
-	}
-
-	SLAM.Shutdown();
-	if (fakeMap != NULL)
-		delete (fakeMap);
-	cout &lt;&lt; "Done" &lt;&lt; endl;
-	exit(0);
-}
-
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\utils.cc" new_path="" added_lines="0" deleted_lines="155">
				<diff>@@ -1,155 +0,0 @@
-#include "../__nodes/utils.h"
-
-#include &lt;boost/foreach.hpp&gt;
-#include &lt;rosbag/view.h&gt;
-#include &lt;tf/tfMessage.h&gt;
-#include &lt;geometry_msgs/TransformStamped.h&gt;
-#include &lt;iostream&gt;
-
-
-#define foreach BOOST_FOREACH
-
-
-using std::cout;
-using std::endl;
-
-
-void tfToCV(const tf::Transform &amp;src, cv::Mat &amp;position, cv::Mat &amp;orientation)
-{
-	position = cv::Mat (3,1,CV_64F);
-	tf::Vector3 p = src.getOrigin();
-	position.at&lt;double&gt;(0) = p.x(),
-		position.at&lt;double&gt;(1) = p.y(),
-		position.at&lt;double&gt;(2) = p.z();
-
-	orientation = cv::Mat (4,1,CV_64F);
-	tf::Quaternion otn = src.getRotation();
-	orientation.at&lt;double&gt;(0) = otn.x(),
-		orientation.at&lt;double&gt;(1) = otn.y(),
-		orientation.at&lt;double&gt;(2) = otn.z(),
-		orientation.at&lt;double&gt;(3) = otn.w();
-}
-
-
-TfTimeTree::TfTimeTree(const string &amp;bagSrcPath, const string &amp;fromFrame, const string &amp;toFrame, const tf::Transform &amp;shift) :
-	curpoint(INT_MAX),
-	root (NULL)
-{
-	rosbag::Bag bfg(bagSrcPath);
-	rosbag::View view(bfg, rosbag::TopicQuery(string("/tf")));
-
-	foreach (rosbag::MessageInstance m, view) {
-		tf::tfMessageConstPtr tfm = m.instantiate&lt;tf::tfMessage&gt;();
-
-		if (tfm-&gt;transforms[0].header.frame_id != fromFrame or
-			tfm-&gt;transforms[0].child_frame_id != toFrame)
-			continue;
-
-		double timeMsg = tfm-&gt;transforms[0].header.stamp.toSec();
-
-		tf::Transform ctf;
-		ctf.setOrigin(tf::Vector3(
-			tfm-&gt;transforms[0].transform.translation.x,
-			tfm-&gt;transforms[0].transform.translation.y,
-			tfm-&gt;transforms[0].transform.translation.z
-		));
-		ctf.setRotation(tf::Quaternion(
-			tfm-&gt;transforms[0].transform.rotation.x,
-			tfm-&gt;transforms[0].transform.rotation.y,
-			tfm-&gt;transforms[0].transform.rotation.z,
-			tfm-&gt;transforms[0].transform.rotation.w
-		));
-
-		Node cn(ctf, timeMsg);
-		allNodes.push_back(cn);
-//		insert (ctf, timeMsg);
-//		i ++;
-	}
-
-	cout &lt;&lt; std::fixed &lt;&lt; "From: " &lt;&lt; std::setprecision(7) &lt;&lt; allNodes[0].timevalue &lt;&lt; " to " &lt;&lt; allNodes.back().timevalue &lt;&lt; endl;
-	cout &lt;&lt; "Length: " &lt;&lt; allNodes.size() &lt;&lt; endl;
-}
-
-
-const tf::Transform&amp; TfTimeTree::search(const double timestamp, float timeTolerance)
-{
-//	Node *cnode = root;
-//	while (cnode != NULL) {
-//		if (abs(cnode-&gt;timevalue-timeTolerance)&lt;timeTolerance)
-//			return cnode-&gt;transform;
-//		else if (cnode-&gt;timevalue &lt; timestamp)
-//			cnode = cnode-&gt;right;
-//		else
-//			cnode = cnode-&gt;left;
-//	}
-//	if (cnode==NULL)
-//		throw std::out_of_range("Outside range");
-
-	if (timestamp &lt; allNodes[0].timevalue)
-		throw std::out_of_range("Less than minimum");
-	if (timestamp &gt; allNodes.back().timevalue)
-		throw std::out_of_range("Outside maximum");
-
-	uint32_t start = (curpoint==INT_MAX ? 0 : curpoint);
-
-	for (uint32_t i=start; i&lt;allNodes.size(); i++) {
-		Node &amp;n = allNodes[i];
-		if (n.timevalue &gt; timestamp) {
-			if (abs(allNodes[i-1].timevalue - timestamp) &lt; abs(n.timevalue-timestamp)) {
-				curpoint = i-1;
-			}
-			else {
-				curpoint = i;
-			}
-			break;
-		}
-	}
-	return allNodes[curpoint].transform;
-}
-
-
-const tf::Transform&amp; TfTimeTree::search(const ros::Time &amp;time, float timeTolerance)
-{
-	double ts = time.toSec();
-	return search(ts, timeTolerance);
-}
-
-
-void TfTimeTree::insert (const tf::Transform &amp;n, double &amp;ts)
-{
-	Node _cnode(n, ts);
-	allNodes.push_back(_cnode);
-	Node *cnode = &amp;(allNodes.back());
-
-	if (root==NULL) {
-		root = cnode;
-		return;
-	}
-
-	Node *current = root;
-	while (current != NULL) {
-
-		if (cnode-&gt;timevalue &lt; current-&gt;timevalue) {
-			if (current-&gt;left==NULL) {
-				current-&gt;left = cnode;
-				cnode-&gt;left = NULL;
-				cnode-&gt;right = NULL;
-				current = NULL;
-			}
-			else {
-				current = current-&gt;left;
-			}
-		}
-		else {
-			if (current-&gt;right==NULL) {
-				current-&gt;right = cnode;
-				cnode-&gt;left = NULL;
-				cnode-&gt;right = NULL;
-				current = NULL;
-			}
-			else {
-				current = current-&gt;right;
-			}
-		}
-	}
-}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\orb_localizer\src\__nodes\utils.h" new_path="" added_lines="0" deleted_lines="57">
				<diff>@@ -1,57 +0,0 @@
-
-#ifndef _ORB_UTILS_H
-#define _ORB_UTILS_H 1
-
-#include &lt;tf/tf.h&gt;
-#include &lt;opencv2/core/core.hpp&gt;
-#include &lt;rosbag/bag.h&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;exception&gt;
-
-
-using std::string;
-using std::vector;
-using std::exception;
-
-
-void tfToCV(const tf::Transform &amp;src, cv::Mat &amp;position, cv::Mat &amp;orientation);
-
-
-
-class TfTimeTree
-{
-public:
-	TfTimeTree (const string &amp;bagSrcPath, const string &amp;fromFrame, const string &amp;toFrame, const tf::Transform &amp;shift=tf::Transform());
-	const tf::Transform&amp; search(const double timestamp, float timeTolerance=0.1);
-	const tf::Transform&amp; search(const ros::Time &amp;time, float timeTolerance=0.1);
-
-	class time_not_found: public std::out_of_range {};
-
-private:
-
-	void insert (const tf::Transform &amp;n, double &amp;ts);
-
-	struct Node {
-		tf::Transform transform;
-		double timevalue;
-		Node *left, *right;
-
-//		Node (tf::Transform &amp;tsrc, double t) :
-//			transform(tsrc),
-//			timevalue(t),
-//			left(NULL), right(NULL) {}
-
-		Node (const tf::Transform &amp;tsrc, double t, Node *l=NULL, Node *r=NULL) :
-			transform(tsrc),
-			timevalue(t),
-			left(l), right(r) {}
-	};
-	vector&lt;Node&gt; allNodes;
-	uint32_t curpoint;
-
-	Node *root;
-};
-
-
-#endif /* _ORB_UTILS_H */
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="152d4202cc625d5a33842f74afad674ffe906f98" author="Manato Hirabayashi">
		<msg>Fix compile error regarding kitty_player

* Change compile flag from `-std=c++0x` to `-std=c++11` as `c++0x` seems to be deprecated later than GCC ver4.7
* Fix `ROS_ERROR_STREAM` usages as `&lt;&lt;` operator in `ROS_ERROR_STREAM` doesn't seem to be able to use with ifstream directly</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\kitti_pkg\kitti_player\src\kitti_player.cpp" new_path="ros\src\util\packages\kitti_pkg\kitti_player\src\kitti_player.cpp" added_lines="21" deleted_lines="7">
				<diff>@@ -1073,7 +1073,9 @@ int main(int argc, char **argv)
                 ifstream timestamps(str_support.c_str());
                 if (!timestamps.is_open())
                 {
-                    ROS_ERROR_STREAM("Fail to open " &lt;&lt; timestamps);
+                    string timestamps_string;
+                    timestamps &gt;&gt; timestamps_string;
+                    ROS_ERROR_STREAM("Fail to open " &lt;&lt; timestamps_string);
                     node.shutdown();
                     return -1;
                 }
@@ -1097,7 +1099,9 @@ int main(int argc, char **argv)
                 ifstream timestamps(str_support.c_str());
                 if (!timestamps.is_open())
                 {
-                    ROS_ERROR_STREAM("Fail to open " &lt;&lt; timestamps);
+                    string timestamps_string;
+                    timestamps &gt;&gt; timestamps_string;
+                    ROS_ERROR_STREAM("Fail to open " &lt;&lt; timestamps_string);
                     node.shutdown();
                     return -1;
                 }
@@ -1154,7 +1158,9 @@ int main(int argc, char **argv)
                 ifstream timestamps(str_support.c_str());
                 if (!timestamps.is_open())
                 {
-                    ROS_ERROR_STREAM("Fail to open " &lt;&lt; timestamps);
+                    string timestamps_string;
+                    timestamps &gt;&gt; timestamps_string;
+                    ROS_ERROR_STREAM("Fail to open " &lt;&lt; timestamps_string);
                     node.shutdown();
                     return -1;
                 }
@@ -1178,7 +1184,9 @@ int main(int argc, char **argv)
                 ifstream timestamps(str_support.c_str());
                 if (!timestamps.is_open())
                 {
-                    ROS_ERROR_STREAM("Fail to open " &lt;&lt; timestamps);
+                    string timestamps_string;
+                    timestamps &gt;&gt; timestamps_string;
+                    ROS_ERROR_STREAM("Fail to open " &lt;&lt; timestamps_string);
                     node.shutdown();
                     return -1;
                 }
@@ -1208,7 +1216,9 @@ int main(int argc, char **argv)
                 ifstream timestamps(str_support.c_str());
                 if (!timestamps.is_open())
                 {
-                    ROS_ERROR_STREAM("Fail to open " &lt;&lt; timestamps);
+                    string timestamps_string;
+                    timestamps &gt;&gt; timestamps_string;
+                    ROS_ERROR_STREAM("Fail to open " &lt;&lt; timestamps_string);
                     node.shutdown();
                     return -1;
                 }
@@ -1230,7 +1240,9 @@ int main(int argc, char **argv)
                 ifstream timestamps(str_support.c_str());
                 if (!timestamps.is_open())
                 {
-                    ROS_ERROR_STREAM("Fail to open " &lt;&lt; timestamps);
+                    string timestamps_string;
+                    timestamps &gt;&gt; timestamps_string;
+                    ROS_ERROR_STREAM("Fail to open " &lt;&lt; timestamps_string);
                     node.shutdown();
                     return -1;
                 }
@@ -1269,7 +1281,9 @@ int main(int argc, char **argv)
                 ifstream timestamps(str_support.c_str());
                 if (!timestamps.is_open())
                 {
-                    ROS_ERROR_STREAM("Fail to open " &lt;&lt; timestamps);
+                    string timestamps_string;
+                    timestamps &gt;&gt; timestamps_string;
+                     ROS_ERROR_STREAM("Fail to open " &lt;&lt; timestamps_string);
                     node.shutdown();
                     return -1;
                 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8b079efa0c937a1b53f5304dcdcf24d11953fdef" author="Manato Hirabayashi">
		<msg>Add function to visualize lane_detect result

Update image_viewer_plugin so that lane_detector result can be visualized</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.cpp" added_lines="50" deleted_lines="1">
				<diff>@@ -21,6 +21,7 @@ namespace integrated_viewer
   const QString     ImageViewerPlugin::kImageDataType               = "sensor_msgs/Image";
   const QString     ImageViewerPlugin::kRectDataTypeBase            = "cv_tracker_msgs/image_obj";
   const QString     ImageViewerPlugin::kPointDataType               = "points2image/PointsImage";
+  const QString     ImageViewerPlugin::kLaneDataType                = "lane_detector/ImageLaneObjects";
   const QString     ImageViewerPlugin::kBlankTopic                  = "-----";
   const std::string ImageViewerPlugin::kRectDataTypeImageObjRanged  = "cv_tracker_msgs/image_obj_ranged";
   const std::string ImageViewerPlugin::kRectDataTypeImageObjTracked = "cv_tracker_msgs/image_obj_tracked";
@@ -38,6 +39,7 @@ namespace integrated_viewer
     image_obj_msg_ = NULL;
     image_obj_ranged_msg_ = NULL;
     image_obj_tracked_msg_ = NULL;
+    lane_msg_ = NULL;
 
     UpdateTopicList();
 
@@ -49,6 +51,7 @@ namespace integrated_viewer
     ui_.image_topic_combo_box_-&gt;installEventFilter(this);
     ui_.rect_topic_combo_box_-&gt;installEventFilter(this);
     ui_.point_topic_combo_box_-&gt;installEventFilter(this);
+    ui_.lane_topic_combo_box_-&gt;installEventFilter(this);
 
   } // ImageViewerPlugin::ImageViewerPlugin()
 
@@ -58,11 +61,13 @@ namespace integrated_viewer
     QStringList image_topic_list;
     QStringList rect_topic_list;
     QStringList point_topic_list;
+    QStringList lane_topic_list;
 
     // The topic name currently chosen
     QString image_topic_current = ui_.image_topic_combo_box_-&gt;currentText();
     QString rect_topic_current = ui_.rect_topic_combo_box_-&gt;currentText();
     QString point_topic_current = ui_.point_topic_combo_box_-&gt;currentText();
+    QString lane_topic_current = ui_.lane_topic_combo_box_-&gt;currentText();
 
     if (image_topic_current == "") {
       image_topic_current = kBlankTopic;
@@ -76,6 +81,10 @@ namespace integrated_viewer
       point_topic_current = kBlankTopic;
     }
 
+    if (lane_topic_current == "") {
+      lane_topic_current = kBlankTopic;
+    }
+
     // reset topic information list for detection result
     rect_topic_info_.clear();
 
@@ -83,6 +92,7 @@ namespace integrated_viewer
     image_topic_list &lt;&lt; kBlankTopic;
     rect_topic_list  &lt;&lt; kBlankTopic;
     point_topic_list &lt;&lt; kBlankTopic;
+    lane_topic_list  &lt;&lt; kBlankTopic;
 
     // Get all available topic 
     ros::master::V_TopicInfo master_topics;
@@ -114,26 +124,36 @@ namespace integrated_viewer
         point_topic_list &lt;&lt; topic_name;
         continue;
       }
+
+      // Check whether this topic is lane
+      if (topic_type.contains(kLaneDataType) == true) {
+        lane_topic_list &lt;&lt; topic_name;
+        continue;
+      }
     }
 
     // remove all list items from combo box
     ui_.image_topic_combo_box_-&gt;clear();
     ui_.rect_topic_combo_box_-&gt;clear();
     ui_.point_topic_combo_box_-&gt;clear();
+    ui_.lane_topic_combo_box_-&gt;clear();
 
     // set new items to combo box
     ui_.image_topic_combo_box_-&gt;addItems(image_topic_list);
     ui_.rect_topic_combo_box_-&gt;addItems(rect_topic_list);
     ui_.point_topic_combo_box_-&gt;addItems(point_topic_list);
-   
+    ui_.lane_topic_combo_box_-&gt;addItems(lane_topic_list);
+
     ui_.image_topic_combo_box_-&gt;insertSeparator(1);
     ui_.rect_topic_combo_box_-&gt;insertSeparator(1);
     ui_.point_topic_combo_box_-&gt;insertSeparator(1);
+    ui_.lane_topic_combo_box_-&gt;insertSeparator(1);
 
     // set last topic as current
     int image_topic_index = ui_.image_topic_combo_box_-&gt;findText(image_topic_current);
     int rect_topic_index = ui_.rect_topic_combo_box_-&gt;findText(rect_topic_current);
     int point_topic_index = ui_.point_topic_combo_box_-&gt;findText(point_topic_current);
+    int lane_topic_index = ui_.lane_topic_combo_box_-&gt;findText(lane_topic_current);
 
     if (image_topic_index != -1) {
       ui_.image_topic_combo_box_-&gt;setCurrentIndex(image_topic_index);
@@ -147,6 +167,10 @@ namespace integrated_viewer
       ui_.point_topic_combo_box_-&gt;setCurrentIndex(point_topic_index);
     }
 
+    if (lane_topic_index != -1) {
+      ui_.lane_topic_combo_box_-&gt;setCurrentIndex(lane_topic_index);
+    }
+
   } // ImageViewerPlugin::UpdateTopicList()
 
 
@@ -270,6 +294,28 @@ namespace integrated_viewer
   } // ImageViewerPlugin::PointCallback()
 
 
+  // The behavior of combo box for detected lane
+  void ImageViewerPlugin::on_lane_topic_combo_box__activated(int index) {
+    // Extract selected topic name from combo box
+    std::string selected_topic = ui_.lane_topic_combo_box_-&gt;itemText(index).toStdString();
+    if (selected_topic == kBlankTopic.toStdString() || selected_topic == "") {
+      lane_sub_.shutdown();
+      lane_msg_ = NULL;
+      return;
+    }
+
+    // if selected topic is not blank or emtpy, start callback function
+    lane_sub_ = node_handle_.subscribe&lt;lane_detector::ImageLaneObjects&gt;(selected_topic,
+                                                                        1,
+                                                                        &amp;ImageViewerPlugin::LaneCallback,
+                                                                        this);
+  }  // void ImageViewerPlugin::on_lane_topic_combo_box__activated()
+
+
+  void ImageViewerPlugin::LaneCallback(const lane_detector::ImageLaneObjects::ConstPtr&amp; msg)  {
+    lane_msg_ = msg;
+  }
+
   void ImageViewerPlugin::ShowImageOnUi(void) {
     // Additional things will be drawn if shown image is not default one
     if (!default_image_shown_) {
@@ -280,6 +326,9 @@ namespace integrated_viewer
 
       // Draw points on the image
       points_drawer_.Draw(points_msg_, viewed_image_);
+
+      // Draw lane on the image
+      lane_drawer_.Draw(lane_msg_, viewed_image_);
     }
     // Convert cv::Mat to QPixmap to show modified image on the UI
     QPixmap view_on_ui = convert_image::CvMatToQPixmap(viewed_image_);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\image_viewer_plugin.h" added_lines="7" deleted_lines="0">
				<diff>@@ -25,6 +25,7 @@
 #include "ui_image_viewer_form.h"
 #include "draw_rects.h"
 #include "draw_points.h"
+#include "draw_lane.h"
 #endif
 
 namespace integrated_viewer
@@ -51,6 +52,7 @@ namespace integrated_viewer
     void ImageObjRangedCallback(const cv_tracker_msgs::image_obj_ranged::ConstPtr&amp; msg);
     void ImageObjTrackedCallback(const cv_tracker_msgs::image_obj_tracked::ConstPtr&amp; msg);
     void PointCallback(const points2image::PointsImage::ConstPtr &amp;msg);
+    void LaneCallback(const lane_detector::ImageLaneObjects::ConstPtr&amp; msg);
 
    // The function to refrect modified image on UI
    void ShowImageOnUi(void);
@@ -59,6 +61,7 @@ namespace integrated_viewer
     static const QString kImageDataType;
     static const QString kRectDataTypeBase;
     static const QString kPointDataType;
+    static const QString kLaneDataType;
 
     // The blank topic name
     static const QString kBlankTopic;
@@ -74,6 +77,7 @@ namespace integrated_viewer
     ros::Subscriber image_sub_;
     ros::Subscriber rect_sub_;
     ros::Subscriber point_sub_;
+    ros::Subscriber lane_sub_;
 
   private:
     // The UI components
@@ -88,6 +92,7 @@ namespace integrated_viewer
     cv_tracker_msgs::image_obj::ConstPtr image_obj_msg_;
     cv_tracker_msgs::image_obj_ranged::ConstPtr image_obj_ranged_msg_;
     cv_tracker_msgs::image_obj_tracked::ConstPtr image_obj_tracked_msg_;
+    lane_detector::ImageLaneObjects::ConstPtr lane_msg_;
 
     // data structure to hold topic information for detection result
     std::map&lt;std::string, std::string&gt; rect_topic_info_;
@@ -95,6 +100,7 @@ namespace integrated_viewer
     // The helper-class constructor for drawing
     DrawRects rects_drawer_;
     DrawPoints points_drawer_;
+    DrawLane lane_drawer_;
 
     // The flag to represent whether default image should be shown or not
     bool default_image_shown_;
@@ -106,6 +112,7 @@ namespace integrated_viewer
       void on_image_topic_combo_box__activated(int index);
       void on_rect_topic_combo_box__activated(int index);
       void on_point_topic_combo_box__activated(int index);
+      void on_lane_topic_combo_box__activated(int index);
 
   }; // end class ImageViewerPlugin
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="22791fe802087f0c83418c98b93850aef0bc1959" author="YamatoAndo">
		<msg>NDT with imu(not yet)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="117" deleted_lines="44">
				<diff>@@ -80,7 +80,7 @@ struct pose
 };
 
 // global variables
-static pose previous_pose, guess_pose, guess_pose_imu, guess_pose_odom, current_pose, current_pose_imu, current_pose_odom, ndt_pose, added_pose, localizer_pose;
+static pose previous_pose, guess_pose, guess_pose_imu, guess_pose_odom, guess_pose_imu_odom,current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, ndt_pose, added_pose, localizer_pose;
 
 static ros::Time current_scan_time;
 static ros::Time previous_scan_time;
@@ -91,6 +91,7 @@ static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw; // current_pos
 static double offset_x, offset_y, offset_z, offset_roll, offset_pitch, offset_yaw;
 static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
 static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
+static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch, offset_imu_odom_yaw;
 
 static double current_velocity_x = 0.0;
 static double current_velocity_y = 0.0;
@@ -119,8 +120,7 @@ static ros::Duration d_callback, d1, d2, d3, d4, d5;
 static ros::Publisher ndt_map_pub;
 static ros::Publisher current_pose_pub;
 static ros::Publisher guess_pose_linaer_pub;
-static ros::Publisher guess_pose_imu_pub;
-static geometry_msgs::PoseStamped current_pose_msg, guess_pose_msg, guess_pose_imu_msg;
+static geometry_msgs::PoseStamped current_pose_msg, guess_pose_msg;
 
 static ros::Publisher ndt_stat_pub;
 static std_msgs::Bool ndt_stat_msg;
@@ -137,11 +137,13 @@ static Eigen::Matrix4f tf_btol, tf_ltob;
 
 static bool isMapUpdate = true;
 static bool _use_openmp = false;
+static bool _use_imu = false;
+static bool _use_odom = false;
 
 static double fitness_score;
 
 static sensor_msgs::Imu imu;
-static double odom_distance_velocity = 0;
+static nav_msgs::Odometry odom;
 
 static void param_callback(const runtime_manager::ConfigNdtMapping::ConstPtr&amp; input)
 {
@@ -210,7 +212,7 @@ static void output_callback(const runtime_manager::ConfigNdtMappingOutput::Const
   }
 }
 
-static void odom_calc(ros::Time current_time)
+static void imu_odom_calc(ros::Time current_time)
 {
   static ros::Time previous_time = current_time;
   double diff_time = (current_time - previous_time).toSec();
@@ -219,18 +221,51 @@ static void odom_calc(ros::Time current_time)
   double diff_imu_pitch = imu.angular_velocity.y * diff_time;
   double diff_imu_yaw   = imu.angular_velocity.z * diff_time;
 
-  current_pose_odom.roll  += diff_imu_roll;
-  current_pose_odom.pitch += diff_imu_pitch;
-  current_pose_odom.yaw   += diff_imu_yaw;
+  current_pose_imu_odom.roll  += diff_imu_roll;
+  current_pose_imu_odom.pitch += diff_imu_pitch;
+  current_pose_imu_odom.yaw   += diff_imu_yaw;
+
+  double diff_distance = odom.twist.twist.linear.x * diff_time;
+  offset_imu_odom_x += diff_distance*cos(-current_pose_imu_odom.pitch)*cos(current_pose_imu_odom.yaw);
+  offset_imu_odom_y += diff_distance*cos(-current_pose_imu_odom.pitch)*sin(current_pose_imu_odom.yaw);
+  offset_imu_odom_z += diff_distance*sin(-current_pose_imu_odom.pitch);
+
+  offset_imu_odom_roll  += diff_imu_roll;
+  offset_imu_odom_pitch += diff_imu_pitch;
+  offset_imu_odom_yaw   += diff_imu_yaw;
+
+  guess_pose_imu_odom.x     = previous_pose.x     + offset_imu_odom_x;
+  guess_pose_imu_odom.y     = previous_pose.y     + offset_imu_odom_y;
+  guess_pose_imu_odom.z     = previous_pose.z     + offset_imu_odom_z;
+  guess_pose_imu_odom.roll  = previous_pose.roll  + offset_imu_odom_roll;
+  guess_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
+  guess_pose_imu_odom.yaw   = previous_pose.yaw   + offset_imu_odom_yaw;
+ 
+  previous_time = current_time;
+}
 
-  double diff_distance = odom_distance_velocity * diff_time;
+
+static void odom_calc(ros::Time current_time)
+{
+  static ros::Time previous_time = current_time;
+  double diff_time = (current_time - previous_time).toSec();
+
+  double diff_odom_roll  = odom.twist.twist.angular.x * diff_time;
+  double diff_odom_pitch = odom.twist.twist.angular.y * diff_time;
+  double diff_odom_yaw   = odom.twist.twist.angular.z * diff_time;
+
+  current_pose_odom.roll  += diff_odom_roll;
+  current_pose_odom.pitch += diff_odom_pitch;
+  current_pose_odom.yaw   += diff_odom_yaw;
+
+  double diff_distance = odom.twist.twist.linear.x * diff_time;
   offset_odom_x += diff_distance*cos(-current_pose_odom.pitch)*cos(current_pose_odom.yaw);
   offset_odom_y += diff_distance*cos(-current_pose_odom.pitch)*sin(current_pose_odom.yaw);
   offset_odom_z += diff_distance*sin(-current_pose_odom.pitch);
 
-  offset_odom_roll  += diff_imu_roll;
-  offset_odom_pitch += diff_imu_pitch;
-  offset_odom_yaw   += diff_imu_yaw;
+  offset_odom_roll  += diff_odom_roll;
+  offset_odom_pitch += diff_odom_pitch;
+  offset_odom_yaw   += diff_odom_yaw;
 
   guess_pose_odom.x     = previous_pose.x     + offset_odom_x;
   guess_pose_odom.y     = previous_pose.y     + offset_odom_y;
@@ -242,13 +277,6 @@ static void odom_calc(ros::Time current_time)
   previous_time = current_time;
 }
 
-static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
-{  
-  odom_distance_velocity = input-&gt;twist.twist.linear.x;
-  odom_calc(input-&gt;header.stamp);
-}
-
-
 static void imu_calc(ros::Time current_time)
 {
 
@@ -314,6 +342,11 @@ static double wrapToPmPi(double a_angle_rad)
     return wrapToPm(a_angle_rad, M_PI);
 }
 
+static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
+{
+  odom = *input;
+  odom_calc(input-&gt;header.stamp);
+}
 
 static void imu_callback(const sensor_msgs::Imu::ConstPtr&amp; input)
 {
@@ -442,37 +475,33 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   guess_pose.pitch = previous_pose.pitch;
   guess_pose.yaw = previous_pose.yaw + diff_yaw;
 
-  Eigen::AngleAxisf init_rotation_x(guess_pose.roll, Eigen::Vector3f::UnitX());
-  Eigen::AngleAxisf init_rotation_y(guess_pose.pitch, Eigen::Vector3f::UnitY());
-  Eigen::AngleAxisf init_rotation_z(guess_pose.yaw, Eigen::Vector3f::UnitZ());
-
-  Eigen::Translation3f init_translation(guess_pose.x, guess_pose.y, guess_pose.z);
 
-  Eigen::Matrix4f init_guess =
-      (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).matrix() * tf_btol;
+  if (_use_imu == true &amp;&amp; _use_odom == true)
+    imu_odom_calc(current_scan_time);
+  if(_use_imu == true &amp;&amp; _use_odom == true)
+    imu_calc(current_scan_time);
+  if (_use_imu == false &amp;&amp; _use_odom == true)
+    odom_calc(current_scan_time);
+
+  pose guess_pose_for_ndt;
+  if(_use_imu == true &amp;&amp; _use_odom == true)
+    guess_pose_for_ndt = guess_pose_imu_odom;
+  else if(_use_imu == true &amp;&amp; _use_odom == false)
+    guess_pose_for_ndt = guess_pose_imu;
+  else if(_use_imu == false &amp;&amp; _use_odom == true)
+    guess_pose_for_ndt = guess_pose_odom;
+  else
+    guess_pose_for_ndt = guess_pose;
 
-/*
-  //imu_calc(current_scan_time);
-  Eigen::AngleAxisf init_rotation_x(guess_pose_imu.roll, Eigen::Vector3f::UnitX());
-  Eigen::AngleAxisf init_rotation_y(guess_pose_imu.pitch, Eigen::Vector3f::UnitY());
-  Eigen::AngleAxisf init_rotation_z(guess_pose_imu.yaw, Eigen::Vector3f::UnitZ());
+  Eigen::AngleAxisf init_rotation_x(guess_pose_for_ndt.roll, Eigen::Vector3f::UnitX());
+  Eigen::AngleAxisf init_rotation_y(guess_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());
+  Eigen::AngleAxisf init_rotation_z(guess_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());
 
-  Eigen::Translation3f init_translation(guess_pose_imu.x, guess_pose_imu.y, guess_pose_imu.z);
+  Eigen::Translation3f init_translation(guess_pose_for_ndt.x, guess_pose_for_ndt.y, guess_pose_for_ndt.z);
 
   Eigen::Matrix4f init_guess =
       (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).matrix() * tf_btol;
-*/
-/*
-  //odom_calc(current_scan_time);
-  Eigen::AngleAxisf init_rotation_x(guess_pose_odom.roll, Eigen::Vector3f::UnitX());
-  Eigen::AngleAxisf init_rotation_y(guess_pose_odom.pitch, Eigen::Vector3f::UnitY());
-  Eigen::AngleAxisf init_rotation_z(guess_pose_odom.yaw, Eigen::Vector3f::UnitZ());
-
-  Eigen::Translation3f init_translation(guess_pose_odom.x, guess_pose_odom.y, guess_pose_odom.z);
 
-  Eigen::Matrix4f init_guess =
-      (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).matrix() * tf_btol;
-*/
   t3_end = ros::Time::now();
   d3 = t3_end - t3_start;
 
@@ -559,6 +588,20 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   current_pose_imu.pitch = current_pose.pitch;
   current_pose_imu.yaw = current_pose.yaw;
 
+  current_pose_odom.x = current_pose.x;
+  current_pose_odom.y = current_pose.y;
+  current_pose_odom.z = current_pose.z;
+  current_pose_odom.roll = current_pose.roll;
+  current_pose_odom.pitch = current_pose.pitch;
+  current_pose_odom.yaw = current_pose.yaw;
+
+  current_pose_imu_odom.x = current_pose.x;
+  current_pose_imu_odom.y = current_pose.y;
+  current_pose_imu_odom.z = current_pose.z;
+  current_pose_imu_odom.roll = current_pose.roll;
+  current_pose_imu_odom.pitch = current_pose.pitch;
+  current_pose_imu_odom.yaw = current_pose.yaw;
+
   current_velocity_imu_x = current_velocity_x;
   current_velocity_imu_y = current_velocity_y;
   current_velocity_imu_z = current_velocity_z;
@@ -595,6 +638,12 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   offset_odom_pitch = 0.0;
   offset_odom_yaw = 0.0;
 
+  offset_imu_odom_x = 0.0;
+  offset_imu_odom_y = 0.0;
+  offset_imu_odom_z = 0.0;
+  offset_imu_odom_roll = 0.0;
+  offset_imu_odom_pitch = 0.0;
+  offset_imu_odom_yaw = 0.0;
   
   // Calculate the shift between added_pos and current_pos
   double shift = sqrt(pow(current_pose.x - added_pose.x, 2.0) + pow(current_pose.y - added_pose.y, 2.0));
@@ -704,6 +753,27 @@ int main(int argc, char** argv)
   offset_pitch = 0.0;
   offset_yaw = 0.0;
 
+  offset_imu_x = 0.0;
+  offset_imu_y = 0.0;
+  offset_imu_z = 0.0;
+  offset_imu_roll = 0.0;
+  offset_imu_pitch = 0.0;
+  offset_imu_yaw = 0.0;
+
+  offset_odom_x = 0.0;
+  offset_odom_y = 0.0;
+  offset_odom_z = 0.0;
+  offset_odom_roll = 0.0;
+  offset_odom_pitch = 0.0;
+  offset_odom_yaw = 0.0;
+
+  offset_imu_odom_x = 0.0;
+  offset_imu_odom_y = 0.0;
+  offset_imu_odom_z = 0.0;
+  offset_imu_odom_roll = 0.0;
+  offset_imu_odom_pitch = 0.0;
+  offset_imu_odom_yaw = 0.0;
+
   ros::init(argc, argv, "ndt_mapping");
 
   ros::NodeHandle nh;
@@ -711,6 +781,9 @@ int main(int argc, char** argv)
 
   // setting parameters
   private_nh.getParam("use_openmp", _use_openmp);
+  private_nh.getParam("use_imu", _use_imu);
+  private_nh.getParam("use_odom", _use_odom);
+
   std::cout &lt;&lt; "use_openmp: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
 
   if (nh.getParam("tf_x", _tf_x) == false)
@@ -768,7 +841,7 @@ int main(int argc, char** argv)
   ros::Subscriber output_sub = nh.subscribe("config/ndt_mapping_output", 10, output_callback);
   ros::Subscriber points_sub = nh.subscribe("points_raw", 100000, points_callback);
   ros::Subscriber odom_sub = nh.subscribe("odom_pose", 100000, odom_callback);
-  ros::Subscriber imu_sub = nh.subscribe("mti/sensor/imu", 100000, imu_callback);
+  ros::Subscriber imu_sub = nh.subscribe("imu_raw", 100000, imu_callback);
 
   ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="155" deleted_lines="85">
				<diff>@@ -91,12 +91,13 @@ struct pose
   double yaw;
 };
 
-static pose initial_pose, predict_pose, predict_pose_imu, predict_pose_odom, previous_pose, ndt_pose, current_pose, current_pose_imu, current_pose_odom, localizer_pose, previous_gnss_pose,
+static pose initial_pose, predict_pose, predict_pose_imu, predict_pose_odom, predict_pose_imu_odom, previous_pose, ndt_pose, current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, localizer_pose, previous_gnss_pose,
     current_gnss_pose;
 
 static double offset_x, offset_y, offset_z, offset_yaw;  // current_pos - previous_pose
-static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;  // current_pos - previous_pose
-static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;  // current_pos - previous_pose
+static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw; 
+static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
+static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch, offset_imu_odom_yaw;
 
 // Can't load if typed "pcl::PointCloud&lt;pcl::PointXYZRGB&gt; map, add;"
 static pcl::PointCloud&lt;pcl::PointXYZ&gt; map, add;
@@ -122,6 +123,9 @@ static geometry_msgs::PoseStamped predict_pose_imu_msg;
 static ros::Publisher predict_pose_odom_pub;
 static geometry_msgs::PoseStamped predict_pose_odom_msg;
 
+static ros::Publisher predict_pose_imu_odom_pub;
+static geometry_msgs::PoseStamped predict_pose_imu_odom_msg;
+
 static ros::Publisher ndt_pose_pub;
 static geometry_msgs::PoseStamped ndt_pose_msg;
 
@@ -197,12 +201,14 @@ static std_msgs::Float32 ndt_reliability;
 static bool _use_openmp = false;
 static bool _get_height = false;
 static bool _use_local_transform = false;
+static bool _use_imu = false;
+static bool _use_odom = false;
 
 static std::ofstream ofs;
 static std::string filename;
 
 static sensor_msgs::Imu imu;
-static double odom_distance_velocity = 0;
+static nav_msgs::Odometry odom;
 
 
 // static tf::TransformListener local_transform_listener;
@@ -370,6 +376,8 @@ static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
     offset_z = current_pose.z - previous_pose.z;
     offset_yaw = current_pose.yaw - previous_pose.yaw;
 
+    //TODO: add imu and odom
+
     init_pos_set = 1;
   }
 
@@ -400,6 +408,8 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
                    input-&gt;pose.pose.orientation.w);
   tf::Matrix3x3 m(q);
 
+  //TODO: add imu and odom
+
   if (_use_local_transform == true)
   {
     current_pose.x = input-&gt;pose.pose.position.x;
@@ -429,7 +439,8 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
     }
     current_pose.z = nearest_z;
   }
-
+  
+  current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;
   previous_pose.x = current_pose.x;
   previous_pose.y = current_pose.y;
   previous_pose.z = current_pose.z;
@@ -441,9 +452,31 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
   offset_y = 0.0;
   offset_z = 0.0;
   offset_yaw = 0.0;
+
+  offset_imu_x = 0.0;
+  offset_imu_y = 0.0;
+  offset_imu_z = 0.0;
+  offset_imu_roll = 0.0;
+  offset_imu_pitch = 0.0;
+  offset_imu_yaw = 0.0;
+
+  offset_odom_x = 0.0;
+  offset_odom_y = 0.0;
+  offset_odom_z = 0.0;
+  offset_odom_roll = 0.0;
+  offset_odom_pitch = 0.0;
+  offset_odom_yaw = 0.0;
+
+  offset_imu_odom_x = 0.0;
+  offset_imu_odom_y = 0.0;
+  offset_imu_odom_z = 0.0;
+  offset_imu_odom_roll = 0.0;
+  offset_imu_odom_pitch = 0.0;
+  offset_imu_odom_yaw = 0.0;
+
 }
 
-static void odom_calc(ros::Time current_time)
+static void imu_odom_calc(ros::Time current_time)
 {
   static ros::Time previous_time = current_time;
   double diff_time = (current_time - previous_time).toSec();
@@ -452,18 +485,51 @@ static void odom_calc(ros::Time current_time)
   double diff_imu_pitch = imu.angular_velocity.y * diff_time;
   double diff_imu_yaw   = imu.angular_velocity.z * diff_time;
 
-  current_pose_odom.roll  += diff_imu_roll;
-  current_pose_odom.pitch += diff_imu_pitch;
-  current_pose_odom.yaw   += diff_imu_yaw;
+  current_pose_imu_odom.roll  += diff_imu_roll;
+  current_pose_imu_odom.pitch += diff_imu_pitch;
+  current_pose_imu_odom.yaw   += diff_imu_yaw;
+
+  double diff_distance = odom.twist.twist.linear.x * diff_time;
+  offset_imu_odom_x += diff_distance*cos(-current_pose_imu_odom.pitch)*cos(current_pose_imu_odom.yaw);
+  offset_imu_odom_y += diff_distance*cos(-current_pose_imu_odom.pitch)*sin(current_pose_imu_odom.yaw);
+  offset_imu_odom_z += diff_distance*sin(-current_pose_imu_odom.pitch);
+
+  offset_imu_odom_roll  += diff_imu_roll;
+  offset_imu_odom_pitch += diff_imu_pitch;
+  offset_imu_odom_yaw   += diff_imu_yaw;
+
+  predict_pose_imu_odom.x     = previous_pose.x     + offset_imu_odom_x;
+  predict_pose_imu_odom.y     = previous_pose.y     + offset_imu_odom_y;
+  predict_pose_imu_odom.z     = previous_pose.z     + offset_imu_odom_z;
+  predict_pose_imu_odom.roll  = previous_pose.roll  + offset_imu_odom_roll;
+  predict_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
+  predict_pose_imu_odom.yaw   = previous_pose.yaw   + offset_imu_odom_yaw;
+ 
+  previous_time = current_time;
+}
+
 
-  double diff_distance = odom_distance_velocity * diff_time;
+static void odom_calc(ros::Time current_time)
+{
+  static ros::Time previous_time = current_time;
+  double diff_time = (current_time - previous_time).toSec();
+
+  double diff_odom_roll  = odom.twist.twist.angular.x * diff_time;
+  double diff_odom_pitch = odom.twist.twist.angular.y * diff_time;
+  double diff_odom_yaw   = odom.twist.twist.angular.z * diff_time;
+
+  current_pose_odom.roll  += diff_odom_roll;
+  current_pose_odom.pitch += diff_odom_pitch;
+  current_pose_odom.yaw   += diff_odom_yaw;
+
+  double diff_distance = odom.twist.twist.linear.x * diff_time;
   offset_odom_x += diff_distance*cos(-current_pose_odom.pitch)*cos(current_pose_odom.yaw);
   offset_odom_y += diff_distance*cos(-current_pose_odom.pitch)*sin(current_pose_odom.yaw);
   offset_odom_z += diff_distance*sin(-current_pose_odom.pitch);
 
-  offset_odom_roll  += diff_imu_roll;
-  offset_odom_pitch += diff_imu_pitch;
-  offset_odom_yaw   += diff_imu_yaw;
+  offset_odom_roll  += diff_odom_roll;
+  offset_odom_pitch += diff_odom_pitch;
+  offset_odom_yaw   += diff_odom_yaw;
 
   predict_pose_odom.x     = previous_pose.x     + offset_odom_x;
   predict_pose_odom.y     = previous_pose.y     + offset_odom_y;
@@ -473,20 +539,11 @@ static void odom_calc(ros::Time current_time)
   predict_pose_odom.yaw   = previous_pose.yaw   + offset_odom_yaw;
  
   previous_time = current_time;
-}
 
-
-static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
-{
-  
-  odom_distance_velocity = input-&gt;twist.twist.linear.x;
-  odom_calc(input-&gt;header.stamp);
 }
 
-
 static void imu_calc(ros::Time current_time)
 {
-
   static ros::Time previous_time = current_time;
   double diff_time = (current_time - previous_time).toSec();
 
@@ -550,6 +607,12 @@ static const double wrapToPmPi(double a_angle_rad)
 }
 
 
+static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
+{
+  odom = *input;
+  odom_calc(input-&gt;header.stamp);
+}
+
 static void imu_callback(const sensor_msgs::Imu::ConstPtr&amp; input)
 {
   const ros::Time current_time = input-&gt;header.stamp;
@@ -644,29 +707,32 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     predict_pose.pitch = previous_pose.pitch;
     predict_pose.yaw = previous_pose.yaw + offset_yaw;
 
-    Eigen::Translation3f init_translation(predict_pose.x, predict_pose.y, predict_pose.z);
-    Eigen::AngleAxisf init_rotation_x(predict_pose.roll, Eigen::Vector3f::UnitX());
-    Eigen::AngleAxisf init_rotation_y(predict_pose.pitch, Eigen::Vector3f::UnitY());
-    Eigen::AngleAxisf init_rotation_z(predict_pose.yaw, Eigen::Vector3f::UnitZ());
-    Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;
-/*
-    imu_calc(current_scan_time);
 
-    Eigen::Translation3f init_translation(predict_pose_imu.x, predict_pose_imu.y, predict_pose_imu.z);
-    Eigen::AngleAxisf init_rotation_x(predict_pose_imu.roll, Eigen::Vector3f::UnitX());
-    Eigen::AngleAxisf init_rotation_y(predict_pose_imu.pitch, Eigen::Vector3f::UnitY());
-    Eigen::AngleAxisf init_rotation_z(predict_pose_imu.yaw, Eigen::Vector3f::UnitZ());
-    Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;
-*/
-/*
-    odom_calc(current_scan_time);
+    if (_use_imu == true &amp;&amp; _use_odom == true)
+      imu_odom_calc(current_scan_time);
+    if(_use_imu == true &amp;&amp; _use_odom == true)
+      imu_calc(current_scan_time);
+    if (_use_imu == false &amp;&amp; _use_odom == true)
+      odom_calc(current_scan_time);
+    
+    pose predict_pose_for_ndt;
+    if (_use_imu == true &amp;&amp; _use_odom == true)
+      predict_pose_for_ndt = predict_pose_imu_odom;
+    else if (_use_imu == true &amp;&amp; _use_odom == false)
+      predict_pose_for_ndt = predict_pose_imu;
+    else if (_use_imu == false &amp;&amp; _use_odom == true)
+      predict_pose_for_ndt = predict_pose_odom;
+    else
+      predict_pose_for_ndt = predict_pose;
 
-    Eigen::Translation3f init_translation(predict_pose_odom.x, predict_pose_odom.y, predict_pose_odom.z);
-    Eigen::AngleAxisf init_rotation_x(predict_pose_odom.roll, Eigen::Vector3f::UnitX());
-    Eigen::AngleAxisf init_rotation_y(predict_pose_odom.pitch, Eigen::Vector3f::UnitY());
-    Eigen::AngleAxisf init_rotation_z(predict_pose_odom.yaw, Eigen::Vector3f::UnitZ());
+    Eigen::Translation3f init_translation(predict_pose_for_ndt.x, predict_pose_for_ndt.y, predict_pose_for_ndt.z);
+    Eigen::AngleAxisf init_rotation_x(predict_pose_for_ndt.roll, Eigen::Vector3f::UnitX());
+    Eigen::AngleAxisf init_rotation_y(predict_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());
+    Eigen::AngleAxisf init_rotation_z(predict_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());
     Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;
-*/
+
+
+
 
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
 #ifdef USE_FAST_PCL
@@ -739,9 +805,9 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     mat_b.getRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, 1);
 
     // Calculate the difference between ndt_pose and predict_pose
-    predict_pose_error = sqrt((ndt_pose.x - predict_pose.x) * (ndt_pose.x - predict_pose.x) +
-                              (ndt_pose.y - predict_pose.y) * (ndt_pose.y - predict_pose.y) +
-                              (ndt_pose.z - predict_pose.z) * (ndt_pose.z - predict_pose.z));
+    predict_pose_error = sqrt((ndt_pose.x - predict_pose_for_ndt.x) * (ndt_pose.x - predict_pose_for_ndt.x) +
+                              (ndt_pose.y - predict_pose_for_ndt.y) * (ndt_pose.y - predict_pose_for_ndt.y) +
+                              (ndt_pose.z - predict_pose_for_ndt.z) * (ndt_pose.z - predict_pose_for_ndt.z));
 
     if (predict_pose_error &lt;= PREDICT_POSE_THRESHOLD)
     {
@@ -753,6 +819,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     }
     use_predict_pose = 0;
 
+
     if (use_predict_pose == 0)
     {
       current_pose.x = ndt_pose.x;
@@ -764,12 +831,12 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     }
     else
     {
-      current_pose.x = predict_pose.x;
-      current_pose.y = predict_pose.y;
-      current_pose.z = predict_pose.z;
-      current_pose.roll = predict_pose.roll;
-      current_pose.pitch = predict_pose.pitch;
-      current_pose.yaw = predict_pose.yaw;
+      current_pose.x = predict_pose_for_ndt.x;
+      current_pose.y = predict_pose_for_ndt.y;
+      current_pose.z = predict_pose_for_ndt.z;
+      current_pose.roll = predict_pose_for_ndt.roll;
+      current_pose.pitch = predict_pose_for_ndt.pitch;
+      current_pose.yaw = predict_pose_for_ndt.yaw;
     }
 
 
@@ -807,6 +874,12 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     current_pose_odom.pitch = current_pose.pitch;
     current_pose_odom.yaw = current_pose.yaw;
 
+    current_pose_imu_odom.x = current_pose.x;
+    current_pose_imu_odom.y = current_pose.y;
+    current_pose_imu_odom.z = current_pose.z;
+    current_pose_imu_odom.roll = current_pose.roll;
+    current_pose_imu_odom.pitch = current_pose.pitch;
+    current_pose_imu_odom.yaw = current_pose.yaw;
 
     current_velocity_smooth = (current_velocity + previous_velocity + previous_previous_velocity) / 3.0;
     if (current_velocity_smooth &lt; 0.2)
@@ -881,6 +954,19 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     predict_pose_odom_pub.publish(predict_pose_odom_msg);
 
 
+    tf::Quaternion predict_q_imu_odom;
+    predict_q_odom.setRPY(predict_pose_imu_odom.roll, predict_pose_imu_odom.pitch, predict_pose_imu_odom.yaw);
+    predict_pose_imu_odom_msg.header.frame_id = "map";
+    predict_pose_imu_odom_msg.header.stamp = input-&gt;header.stamp;
+    predict_pose_imu_odom_msg.pose.position.x = predict_pose_imu_odom.x;
+    predict_pose_imu_odom_msg.pose.position.y = predict_pose_imu_odom.y;
+    predict_pose_imu_odom_msg.pose.position.z = predict_pose_imu_odom.z;
+    predict_pose_imu_odom_msg.pose.orientation.x = predict_q_imu_odom.x();
+    predict_pose_imu_odom_msg.pose.orientation.y = predict_q_imu_odom.y();
+    predict_pose_imu_odom_msg.pose.orientation.z = predict_q_imu_odom.z();
+    predict_pose_imu_odom_msg.pose.orientation.w = predict_q_imu_odom.w();
+    predict_pose_imu_odom_pub.publish(predict_pose_imu_odom_msg);
+
     ndt_q.setRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw);
 	    if (_use_local_transform == true)
     {
@@ -1038,6 +1124,11 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
         &lt;&lt; current_pose.x - predict_pose_odom.x &lt;&lt; "," &lt;&lt; current_pose.y - predict_pose_odom.y &lt;&lt; ","
         &lt;&lt; current_pose.z - predict_pose_odom.z &lt;&lt; "," &lt;&lt; current_pose.roll - predict_pose_odom.roll &lt;&lt; ","
         &lt;&lt; current_pose.pitch - predict_pose_odom.pitch &lt;&lt; "," &lt;&lt; current_pose.yaw - predict_pose_odom.yaw &lt;&lt; ","
+        &lt;&lt;"," &lt;&lt; predict_pose_imu_odom.x &lt;&lt; "," &lt;&lt; predict_pose_imu_odom.y &lt;&lt; "," &lt;&lt; predict_pose_imu_odom.z &lt;&lt; ","
+        &lt;&lt; predict_pose_imu_odom.roll &lt;&lt; "," &lt;&lt; predict_pose_imu_odom.pitch &lt;&lt; ","  &lt;&lt; predict_pose_imu_odom.yaw &lt;&lt; ","
+        &lt;&lt; current_pose.x - predict_pose_imu_odom.x &lt;&lt; "," &lt;&lt; current_pose.y - predict_pose_imu_odom.y &lt;&lt; ","
+        &lt;&lt; current_pose.z - predict_pose_imu_odom.z &lt;&lt; "," &lt;&lt; current_pose.roll - predict_pose_imu_odom.roll &lt;&lt; ","
+        &lt;&lt; current_pose.pitch - predict_pose_imu_odom.pitch &lt;&lt; "," &lt;&lt; current_pose.yaw - predict_pose_imu_odom.yaw &lt;&lt; ","
         &lt;&lt; std::endl;
 
 
@@ -1097,6 +1188,13 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     offset_odom_pitch = 0.0;
     offset_odom_yaw = 0.0;
 
+    offset_imu_odom_x = 0.0;
+    offset_imu_odom_y = 0.0;
+    offset_imu_odom_z = 0.0;
+    offset_imu_odom_roll = 0.0;
+    offset_imu_odom_pitch = 0.0;
+    offset_imu_odom_yaw = 0.0;
+
     // Update previous_***
     previous_pose.x = current_pose.x;
     previous_pose.y = current_pose.y;
@@ -1141,41 +1239,10 @@ int main(int argc, char** argv)
   private_nh.getParam("use_openmp", _use_openmp);
   private_nh.getParam("get_height", _get_height);
   private_nh.getParam("use_local_transform", _use_local_transform);
+  private_nh.getParam("use_imu", _use_imu);
+  private_nh.getParam("use_odom", _use_odom);
 
   _tf_x = _tf_y = _tf_z = _tf_roll = _tf_pitch = _tf_yaw = 0;
-  _tf_z = 0.0;
-
-  offset_imu_x = 0.0;
-  offset_imu_y = 0.0;
-  offset_imu_z = 0.0;
-  offset_imu_roll = 0.0;
-  offset_imu_pitch = 0.0;
-  offset_imu_yaw = 0.0;
-
-  offset_odom_x = 0.0;
-  offset_odom_y = 0.0;
-  offset_odom_z = 0.0;
-  offset_odom_roll = 0.0;
-  offset_odom_pitch = 0.0;
-  offset_odom_yaw = 0.0;
-
-  current_pose_odom.x = 0.0;
-  current_pose_odom.y = 0.0;
-  current_pose_odom.z = 0.0;
-  current_pose_odom.roll = 0.0;
-  current_pose_odom.pitch = 0.0;
-  current_pose_odom.yaw = 0.0;
-
-  predict_pose_odom.x = 0.0;
-  predict_pose_odom.y = 0.0;
-  predict_pose_odom.z = 0.0;
-  predict_pose_odom.roll = 0.0;
-  predict_pose_odom.pitch = 0.0;
-  predict_pose_odom.yaw = 0.0;
-
-  imu.angular_velocity.x = 0;
-  imu.angular_velocity.y = 0;
-  imu.angular_velocity.z = 0;
 
   if (nh.getParam("localizer", _localizer) == false)
   {
@@ -1221,6 +1288,8 @@ int main(int argc, char** argv)
   std::cout &lt;&lt; "use_openmp: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
   std::cout &lt;&lt; "get_height: " &lt;&lt; _get_height &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_local_transform: " &lt;&lt; _use_local_transform &lt;&lt; std::endl;
+  std::cout &lt;&lt; "use_imu: " &lt;&lt; _use_imu &lt;&lt; std::endl;
+  std::cout &lt;&lt; "use_odom: " &lt;&lt; _use_odom &lt;&lt; std::endl;
   std::cout &lt;&lt; "localizer: " &lt;&lt; _localizer &lt;&lt; std::endl;
   std::cout &lt;&lt; "(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (" &lt;&lt; _tf_x &lt;&lt; ", " &lt;&lt; _tf_y &lt;&lt; ", " &lt;&lt; _tf_z &lt;&lt; ", "
             &lt;&lt; _tf_roll &lt;&lt; ", " &lt;&lt; _tf_pitch &lt;&lt; ", " &lt;&lt; _tf_yaw &lt;&lt; ")" &lt;&lt; std::endl;
@@ -1250,6 +1319,7 @@ int main(int argc, char** argv)
   predict_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose", 1000);
   predict_pose_imu_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose_imu", 1000);
   predict_pose_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose_odom", 1000);
+  predict_pose_imu_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose_imu_odom", 1000);
   ndt_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/ndt_pose", 1000);
   // current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/current_pose", 1000);
   localizer_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/localizer_pose", 1000);
@@ -1268,7 +1338,7 @@ int main(int argc, char** argv)
   ros::Subscriber initialpose_sub = nh.subscribe("initialpose", 1000, initialpose_callback);
   ros::Subscriber points_sub = nh.subscribe("filtered_points", _queue_size, points_callback);
   ros::Subscriber odom_sub = nh.subscribe("odom_pose", _queue_size*10, odom_callback);
-  ros::Subscriber imu_sub = nh.subscribe("mti/sensor/imu", _queue_size*10, imu_callback);
+  ros::Subscriber imu_sub = nh.subscribe("imu_raw", _queue_size*10, imu_callback);
 
   ros::spin();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e7e31a9c58bb04453903895c17fdbb6edde90d82" author="YamatoAndo">
		<msg>ndt_matching debug end (ndt_mapping not yet)</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -840,8 +840,8 @@ int main(int argc, char** argv)
   ros::Subscriber param_sub = nh.subscribe("config/ndt_mapping", 10, param_callback);
   ros::Subscriber output_sub = nh.subscribe("config/ndt_mapping_output", 10, output_callback);
   ros::Subscriber points_sub = nh.subscribe("points_raw", 100000, points_callback);
-  ros::Subscriber odom_sub = nh.subscribe("odom_pose", 100000, odom_callback);
-  ros::Subscriber imu_sub = nh.subscribe("imu_raw", 100000, imu_callback);
+  ros::Subscriber odom_sub = nh.subscribe("/odom_pose", 100000, odom_callback);
+  ros::Subscriber imu_sub = nh.subscribe("/imu_raw", 100000, imu_callback);
 
   ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="6" deleted_lines="4">
				<diff>@@ -609,12 +609,16 @@ static const double wrapToPmPi(double a_angle_rad)
 
 static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
 {
+  std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+
   odom = *input;
   odom_calc(input-&gt;header.stamp);
 }
 
 static void imu_callback(const sensor_msgs::Imu::ConstPtr&amp; input)
 {
+  std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+
   const ros::Time current_time = input-&gt;header.stamp;
   static ros::Time previous_time = current_time;
   const double diff_time =  (current_time - previous_time).toSec();
@@ -1242,8 +1246,6 @@ int main(int argc, char** argv)
   private_nh.getParam("use_imu", _use_imu);
   private_nh.getParam("use_odom", _use_odom);
 
-  _tf_x = _tf_y = _tf_z = _tf_roll = _tf_pitch = _tf_yaw = 0;
-
   if (nh.getParam("localizer", _localizer) == false)
   {
     std::cout &lt;&lt; "localizer is not set." &lt;&lt; std::endl;
@@ -1337,8 +1339,8 @@ int main(int argc, char** argv)
   ros::Subscriber map_sub = nh.subscribe("points_map", 10, map_callback);
   ros::Subscriber initialpose_sub = nh.subscribe("initialpose", 1000, initialpose_callback);
   ros::Subscriber points_sub = nh.subscribe("filtered_points", _queue_size, points_callback);
-  ros::Subscriber odom_sub = nh.subscribe("odom_pose", _queue_size*10, odom_callback);
-  ros::Subscriber imu_sub = nh.subscribe("imu_raw", _queue_size*10, imu_callback);
+  ros::Subscriber odom_sub = nh.subscribe("/odom_pose", _queue_size*10, odom_callback);
+  ros::Subscriber imu_sub = nh.subscribe("/imu_raw", _queue_size*10, imu_callback);
 
   ros::spin();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="dae3bdcb9e7d8cb7e66f2f0f8f3d71cdac9a62bf" author="AMC">
		<msg>Yolo OK</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\include\darknet\yolo2.h" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\include\darknet\yolo2.h" added_lines="2" deleted_lines="0">
				<diff>@@ -34,6 +34,8 @@ namespace darknet
 			~Yolo2Detector();
 			image convert_image(const sensor_msgs::ImageConstPtr&amp; in_image_msg);
 			std::vector&lt; RectClassScore&lt;float&gt; &gt; detect(float *in_data);
+			uint32_t get_network_width();
+			uint32_t get_network_height();
 
 
 	};
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\darknet\yolo2.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\darknet\yolo2.cpp" added_lines="15" deleted_lines="3">
				<diff>@@ -18,11 +18,20 @@ extern "C"
 		#include "parser.h"
 		#include "region_layer.h"
 		#include "utils.h"
+		#include "image.h"
 	#define __cplusplus
 }
 
 namespace darknet
 {
+	uint32_t Yolo2Detector::get_network_height()
+	{
+		return darknet_network_.h;
+	}
+	uint32_t Yolo2Detector::get_network_width()
+	{
+		return darknet_network_.w;
+	}
 	void Yolo2Detector::load(std::string&amp; in_model_file, std::string&amp; in_trained_file, double in_min_confidence, double in_nms_threshold)
 	{
 		min_confidence_ = in_min_confidence;
@@ -55,7 +64,7 @@ namespace darknet
 
 	image Yolo2Detector::convert_image(const sensor_msgs::ImageConstPtr&amp; msg)
 	{
-		if (msg-&gt;encoding != sensor_msgs::image_encodings::RGB8)
+		if (msg-&gt;encoding != sensor_msgs::image_encodings::BGR8)
 		{
 			ROS_ERROR("Unsupported encoding");
 			exit(-1);
@@ -79,7 +88,7 @@ namespace darknet
 
 		if (darknet_network_.w == width &amp;&amp; darknet_network_.h == height)
 		{
-		return im;
+			return im;
 		}
 		image resized = resize_image(im, darknet_network_.w, darknet_network_.h);
 		free_image(im);
@@ -102,11 +111,12 @@ namespace darknet
 		int num_classes = output_layer.classes;
 		do_nms(darknet_boxes_.data(), darknet_box_scores_.data(), output_layer.w * output_layer.h * output_layer.n, num_classes, nms_threshold_);
 		std::vector&lt; RectClassScore&lt;float&gt; &gt; detections;
+
 		for (unsigned i = 0; i &lt; darknet_box_scores_.size(); i++)
 		{
 			int class_id = max_index(darknet_box_scores_[i], num_classes);
 			float prob = darknet_box_scores_[i][class_id];
-			if (prob)
+			if (prob &gt; 0.3)
 			{
 				RectClassScore&lt;float&gt; detection;
 				box b = darknet_boxes_[i];
@@ -117,6 +127,8 @@ namespace darknet
 				detection.h = b.h;
 				detection.score = prob;
 				detection.class_type = class_id;
+				//std::cout &lt;&lt; "Box:"  &lt;&lt;detection.toString() &lt;&lt; std::endl;
+
 				detections.push_back(detection);
 			}
 		}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" added_lines="77" deleted_lines="9">
				<diff>@@ -6,10 +6,16 @@
 
 #include &lt;cv_tracker/image_obj.h&gt;
 
+#include &lt;opencv2/contrib/contrib.hpp&gt;
+#include &lt;opencv2/highgui/highgui.hpp&gt;
+
+#include &lt;cv_bridge/cv_bridge.h&gt;
 
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
+#include &lt;math.h&gt;
+
 #include &lt;rect_class_score.h&gt;
 
 #include "darknet/yolo2.h"
@@ -41,25 +47,26 @@ class Yolo2DetectorNode
 
 	float score_threshold_;
 	float nms_threshold_;
+	double image_ratio_;
 
 	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, cv_tracker::image_obj&amp; out_message, std::string in_class)
 	{
 		for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
 		{
 			if ( (in_objects[i].score &gt; score_threshold_)
-				&amp;&amp; (	(in_class == "car" &amp;&amp; (in_objects[i].class_type == Yolo2::CAR || in_objects[i].class_type == Yolo2::BUS))
+				/*&amp;&amp; (	(in_class == "car" &amp;&amp; (in_objects[i].class_type == Yolo2::CAR || in_objects[i].class_type == Yolo2::BUS))
 						|| (in_class == "person" &amp;&amp; (in_objects[i].class_type == Yolo2::PERSON || in_objects[i].class_type == Yolo2::BICYCLE))
-					)
+					)*/
 
 				)//check if the score is larger than minimum required
 			{
 				//std::cout &lt;&lt; in_objects[i].toString() &lt;&lt; std::endl;
 				cv_tracker::image_rect rect;
 
-				rect.x = in_objects[i].x;
-				rect.y = in_objects[i].y;
-				rect.width = in_objects[i].w;
-				rect.height = in_objects[i].h;
+				rect.x = in_objects[i].x * darknet_image.w;
+				rect.y = in_objects[i].y * darknet_image.h;
+				rect.width = in_objects[i].w * darknet_image.w;
+				rect.height = in_objects[i].h * darknet_image.h;
 				if (in_objects[i].x &lt; 0)
 					rect.x = 0;
 				if (in_objects[i].y &lt; 0)
@@ -71,20 +78,79 @@ class Yolo2DetectorNode
 
 				rect.score = in_objects[i].score;
 
+				std::cout &lt;&lt; "x"&lt;&lt; rect.x&lt;&lt; "y" &lt;&lt; rect.y &lt;&lt; "w"&lt;&lt; rect.width &lt;&lt; "h"&lt;&lt; rect.height&lt;&lt; "s" &lt;&lt; rect.score &lt;&lt; std::endl;
+
 				out_message.obj.push_back(rect);
 
 			}
 		}
 	}
 
+	image convert_ipl_to_image(const sensor_msgs::ImageConstPtr&amp; msg)
+	{
+		cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(msg, "bgr8");//toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
+		cv::Mat mat_image = cv_image-&gt;image;
+
+		uint32_t network_input_width = yolo_detector_.get_network_width();
+		uint32_t network_input_height = yolo_detector_.get_network_height();
+
+		uint32_t height = msg-&gt;height,
+						width = msg-&gt;width;
+
+		IplImage ipl_image;
+		cv::Mat final_mat;
+
+		ROS_INFO("Before Network (%d,%d), Image (%d,%d)", network_input_width, network_input_height, width, height);
+		if (network_input_width!=width
+				|| network_input_height != height)
+		{
+			//final_mat = cv::Mat(network_input_width, network_input_height, CV_8UC3, cv::Scalar(0,0,0));
+			image_ratio_ = (double ) network_input_width /  (double)mat_image.cols;
+			std::cout &lt;&lt; "Ratio:" &lt;&lt; image_ratio_ &lt;&lt; std::endl;
+
+			cv::resize(mat_image, final_mat, cv::Size(), image_ratio_, image_ratio_);
+			uint32_t top_bottom_border = abs(final_mat.rows-network_input_height)/2;
+			uint32_t left_right_border = abs(final_mat.cols-network_input_width)/2;
+			cv::copyMakeBorder(final_mat, final_mat, top_bottom_border, top_bottom_border, left_right_border, left_right_border, cv::BORDER_CONSTANT, cv::Scalar(0,0,0));
+		}
+		else
+			final_mat = mat_image;
+
+		ROS_INFO("After Network (%d,%d), Image (%d,%d)", network_input_width, network_input_height, final_mat.cols, final_mat.rows);
+
+		cv::imshow("cropped", final_mat);
+		cvWaitKey(10);
+
+		ipl_image = final_mat;
+
+		unsigned char *data = (unsigned char *)ipl_image.imageData;
+		int h = ipl_image.height;
+		int w = ipl_image.width;
+		int c = ipl_image.nChannels;
+		int step = ipl_image.widthStep;
+		int i, j, k;
+
+		image darknet_image = make_image(w, h, c);
+
+		for(i = 0; i &lt; h; ++i){
+			for(k= 0; k &lt; c; ++k){
+				for(j = 0; j &lt; w; ++j){
+					darknet_image.data[k*w*h + i*w + j] = data[i*step + j*c + k]/255.;
+				}
+			}
+		}
+
+		return darknet_image;
+	}
+
 	void image_callback(const sensor_msgs::ImageConstPtr&amp; in_image_message)
 	{
 		std::vector&lt; RectClassScore&lt;float&gt; &gt; detections;
-		darknet_image = yolo_detector_.convert_image(in_image_message);
+		//darknet_image = yolo_detector_.convert_image(in_image_message);
 
-		detections = yolo_detector_.detect(darknet_image.data);
+		darknet_image = convert_ipl_to_image(in_image_message);
 
-		free(darknet_image.data);
+		detections = yolo_detector_.detect(darknet_image.data);
 
 		//Prepare Output message
 		cv_tracker::image_obj output_car_message;
@@ -100,6 +166,8 @@ class Yolo2DetectorNode
 
 		publisher_car_objects_.publish(output_car_message);
 		publisher_person_objects_.publish(output_person_message);
+
+		free(darknet_image.data);
 	}
 
 	void config_cb(const runtime_manager::ConfigSsd::ConstPtr&amp; param)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ec9cf03a3f537486b46e45e27103df03be8f8e2d" author="USUDA Hisashi">
		<msg>Change topic message type.</msg>
		<modified_files>
			<file old_path="ros\src\data\packages\pos_db\nodes\pos_uploader\pos_uploader.cpp" new_path="ros\src\data\packages\pos_db\nodes\pos_uploader\pos_uploader.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -43,8 +43,8 @@
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;geometry_msgs/PoseArray.h&gt;
 #include &lt;geometry_msgs/Point.h&gt;
-#include &lt;visualization_msgs/Marker.h&gt;
-#include &lt;visualization_msgs/MarkerArray.h&gt;
+#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
+#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 
 
 #include &lt;pos_db.h&gt;
@@ -255,47 +255,47 @@ static void* intervalCall(void *unused)
 }
 
 
-static void car_locate_cb(const visualization_msgs::MarkerArray&amp; obj_pose_msg)
+static void car_locate_cb(const jsk_recognition_msgs::BoundingBoxArray&amp; obj_pose_msg)
 {
-	if (obj_pose_msg.markers.size() &gt; 0) {
+	if (obj_pose_msg.boxes.size() &gt; 0) {
 		geometry_msgs::Point tmpPoint;
 		cv_tracker::obj_label tmpLabel;
 
 		pthread_mutex_lock(&amp;pose_lock_);
 
-		for (visualization_msgs::Marker tmpMarker : obj_pose_msg.markers) {
-			tmpPoint.x = tmpMarker.pose.position.x;
-			tmpPoint.y = tmpMarker.pose.position.y;
-			tmpPoint.z = tmpMarker.pose.position.z;
+		for (jsk_recognition_msgs::BoundingBox tmpBox : obj_pose_msg.boxes) {
+			tmpPoint.x = tmpBox.pose.position.x;
+			tmpPoint.y = tmpBox.pose.position.y;
+			tmpPoint.z = tmpBox.pose.position.z;
 
 			tmpLabel.reprojected_pos.push_back(tmpPoint);
 		}
 
 		car_positions_array.push_back(tmpLabel);
-		car_num += obj_pose_msg.markers.size();
+		car_num += obj_pose_msg.boxes.size();
 
 		pthread_mutex_unlock(&amp;pose_lock_);
 	}
 }
 
-static void person_locate_cb(const visualization_msgs::MarkerArray &amp;obj_pose_msg)
+static void person_locate_cb(const jsk_recognition_msgs::BoundingBoxArray &amp;obj_pose_msg)
 {
-	if (obj_pose_msg.markers.size() &gt; 0) {
+	if (obj_pose_msg.boxes.size() &gt; 0) {
 		geometry_msgs::Point tmpPoint;
 		cv_tracker::obj_label tmpLabel;
 
 		pthread_mutex_lock(&amp;pose_lock_);
 
-		for (visualization_msgs::Marker tmpMarker : obj_pose_msg.markers) {
-			tmpPoint.x = tmpMarker.pose.position.x;
-			tmpPoint.y = tmpMarker.pose.position.y;
-			tmpPoint.z = tmpMarker.pose.position.z;
+		for (jsk_recognition_msgs::BoundingBox tmpBox : obj_pose_msg.boxes) {
+			tmpPoint.x = tmpBox.pose.position.x;
+			tmpPoint.y = tmpBox.pose.position.y;
+			tmpPoint.z = tmpBox.pose.position.z;
 
 			tmpLabel.reprojected_pos.push_back(tmpPoint);
 		}
 
 		person_positions_array.push_back(tmpLabel);
-		person_num += obj_pose_msg.markers.size();
+		person_num += obj_pose_msg.boxes.size();
 
 		pthread_mutex_unlock(&amp;pose_lock_);
 	}
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5d6cafeaad7b6095422f9b3cda022b409463b7fa" author="hatem-darweesh">
		<msg>Add OpenPlanner to Develop Branch, add OpenPlanner to Runtime Manager, and modify rviz default config file

fix map loading options

automatic replanning simulation and traffic light stop and go

add performance logging

behavior state for traffic light and stop signs fixed

fix logging shift, fix euclidean clusters problem

visualize dp steps

detection config for robot vel16

tune ff path follower for simulation

tune ff path follower for simulation

HMI update

simulated obstacle bounding box representation

HMI Update

HMI Successful Demo

improve detection accuracy to &lt; 10 cm

HMI Tested. More runtime manager options.

HMI Tested. More runtime manager options.

fix dp plan build issue

Controller - Steering Delay auto calibration

Multi-Traffic Behavior Simulation on Rviz using OpenPlanner

change node names to match ROS naming standards

change node names to match ROS naming standards

- Add OpenPlanner Vehicle Simulator
- Integrate with Autoware's pure pursut
- Revised local planning
- Unit-Test usig playback based simulation

update simulation launch files

More Unit Testing

Improve Object Tracking

CAN info message handle!

rviz config

visualization changes

add option to select velocities source

RS Planner Test</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\default.rviz" new_path="ros\src\.config\rviz\default.rviz" added_lines="263" deleted_lines="43">
				<diff>@@ -6,10 +6,14 @@ Panels:
       Expanded:
         - /Global Options1
         - /Camera1/Visibility1
-        - /Vehicle Model1/Status1
+        - /Points Raw1/Status1
         - /Local Waypoints1/Status1
+        - /Vector Map CenterLines1/Namespaces1
+        - /Global Path1/Namespaces1
+        - /Local Rollouts1/Namespaces1
+        - /GlobalPathAnimation1/Status1
       Splitter Ratio: 0.695804
-    Tree Height: 543
+    Tree Height: 1183
   - Class: rviz/Selection
     Name: Selection
   - Class: rviz/Tool Properties
@@ -36,7 +40,7 @@ Visualization Manager:
       Cell Size: 1
       Class: rviz/Grid
       Color: 160; 160; 164
-      Enabled: true
+      Enabled: false
       Line Style:
         Line Width: 0.03
         Value: Lines
@@ -49,7 +53,7 @@ Visualization Manager:
       Plane: XY
       Plane Cell Count: 10
       Reference Frame: &lt;Fixed Frame&gt;
-      Value: true
+      Value: false
     - Class: rviz/TF
       Enabled: true
       Frame Timeout: 15
@@ -59,8 +63,6 @@ Visualization Manager:
           Value: true
         map:
           Value: true
-        mobility:
-          Value: true
         velodyne:
           Value: true
         world:
@@ -73,11 +75,7 @@ Visualization Manager:
       Tree:
         world:
           map:
-            base_link:
-              velodyne:
-                {}
-            mobility:
-              {}
+            {}
       Update Interval: 0
       Value: true
     - Alpha: 0.05
@@ -138,7 +136,7 @@ Visualization Manager:
       Queue Size: 100
       Value: true
     - Class: rviz/Image
-      Enabled: true
+      Enabled: false
       Image Topic: /image_raw
       Max Value: 1
       Median window: 5
@@ -148,7 +146,7 @@ Visualization Manager:
       Queue Size: 2
       Transport Hint: raw
       Unreliable: false
-      Value: true
+      Value: false
     - Class: rviz/Camera
       Enabled: false
       Image Rendering: overlay
@@ -160,14 +158,18 @@ Visualization Manager:
       Unreliable: false
       Value: false
       Visibility:
-        "": true
+        Behavior State: true
         Bounding Boxes: true
         Control Pose: true
         Current Pose: true
         Detection Range: true
+        Global Path: true
         Global Waypoints: true
+        GlobalPathAnimation: true
         Grid: true
         Image: true
+        Laserscan Costmap: true
+        Local Rollouts: true
         Local Waypoints: true
         Next Waypoint Mark: true
         Object Pose: true
@@ -175,10 +177,31 @@ Visualization Manager:
         Points Cluster: true
         Points Map: true
         Points Raw: true
+        Safety Box: true
+        SimBehavior1: true
+        SimBehavior2: true
+        SimBehavior3: true
+        SimBehavior4: true
+        SimBehavior5: true
+        SimPath1: true
+        SimPath2: true
+        SimPath3: true
+        SimPath4: true
+        SimPath5: true
+        SimuCar1: true
+        SimuCar2: true
+        SimuCar3: true
+        SimuCar4: true
+        SimuCar5: true
+        Simulated Following Point: true
+        Simulated Obstacle: true
+        SimulatedCar Pose: true
         Stixel: true
         TF: false
+        Tracked Contours: true
         Value: true
         Vector Map: true
+        Vector Map CenterLines: true
         Vehicle Model: true
         Vscan Points: true
         Waypoint Guide: true
@@ -199,7 +222,7 @@ Visualization Manager:
       Enabled: true
       Invert Rainbow: false
       Max Color: 255; 255; 255
-      Max Intensity: 250
+      Max Intensity: 237
       Min Color: 0; 0; 0
       Min Intensity: 0
       Name: Points Raw
@@ -226,7 +249,7 @@ Visualization Manager:
       Color: 255; 255; 0
       Color Transformer: FlatColor
       Decay Time: 0
-      Enabled: false
+      Enabled: true
       Invert Rainbow: false
       Max Color: 255; 255; 255
       Max Intensity: 255
@@ -243,13 +266,13 @@ Visualization Manager:
       Unreliable: false
       Use Fixed Frame: true
       Use rainbow: true
-      Value: false
+      Value: true
     - Alpha: 1
       Axes Length: 1
       Axes Radius: 0.1
       Class: rviz/Pose
       Color: 255; 25; 0
-      Enabled: false
+      Enabled: true
       Head Length: 2
       Head Radius: 2
       Name: Control Pose
@@ -258,7 +281,7 @@ Visualization Manager:
       Shape: Arrow
       Topic: /control_pose
       Unreliable: false
-      Value: false
+      Value: true
     - Alpha: 1
       Axes Length: 1
       Axes Radius: 0.1
@@ -309,23 +332,18 @@ Visualization Manager:
     - Alpha: 1
       Class: rviz/RobotModel
       Collision Enabled: false
-      Enabled: true
+      Enabled: false
       Links:
         All Links Enabled: true
         Expand Joint Details: false
         Expand Link Details: false
         Expand Tree: false
         Link Tree Style: Links in Alphabetic Order
-        base_link:
-          Alpha: 1
-          Show Axes: false
-          Show Trail: false
-          Value: true
       Name: Vehicle Model
       Robot Description: robot_description
       TF Prefix: ""
       Update Interval: 0
-      Value: true
+      Value: false
       Visual Enabled: true
     - Alpha: 1
       Autocompute Intensity Bounds: true
@@ -339,7 +357,7 @@ Visualization Manager:
       Color: 255; 255; 255
       Color Transformer: RGB8
       Decay Time: 0
-      Enabled: false
+      Enabled: true
       Invert Rainbow: false
       Max Color: 255; 255; 255
       Max Intensity: 4096
@@ -356,7 +374,7 @@ Visualization Manager:
       Unreliable: false
       Use Fixed Frame: true
       Use rainbow: true
-      Value: false
+      Value: true
     - Class: rviz/MarkerArray
       Enabled: true
       Marker Topic: /obj_car/obj_pose
@@ -378,9 +396,7 @@ Visualization Manager:
       Marker Topic: /global_waypoints_mark
       Name: Global Waypoints
       Namespaces:
-        global_lane_array_marker: true
-        global_lane_waypoint_orientation_marker_1: true
-        global_velocity_lane_1: true
+        {}
       Queue Size: 100
       Value: true
     - Buffer length: 100
@@ -395,7 +411,6 @@ Visualization Manager:
       background color: 0; 0; 0
       backround alpha: 0
       border: true
-      caption: true
       foreground alpha: 0.6
       foreground color: 25; 255; 240
       height: 100
@@ -404,6 +419,7 @@ Visualization Manager:
       max color: 255; 0; 0
       max value: 1
       min value: -1
+      show caption: true
       text size: 12
       top: 10
       update interval: 0.04
@@ -432,10 +448,214 @@ Visualization Manager:
       Class: rviz/Map
       Color Scheme: map
       Draw Behind: false
-      Enabled: true
+      Enabled: false
       Name: Laserscan Costmap
       Topic: /ring_ogm
       Unreliable: false
+      Value: false
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /vector_map_center_lines_rviz
+      Name: Vector Map CenterLines
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /global_waypoints_rviz
+      Name: Global Path
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /local_trajectories
+      Name: Local Rollouts
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /detected_polygons
+      Name: Tracked Contours
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /curr_simu_pose
+      Name: SimulatedCar Pose
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /follow_pose
+      Name: Simulated Following Point
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /behavior_state
+      Name: Behavior State
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /AnimateGlobalPlan
+      Name: GlobalPathAnimation
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /safety_border
+      Name: Safety Box
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: jsk_rviz_plugin/BoundingBoxArray
+      Enabled: true
+      Name: Simulated Obstacle
+      Topic: /dp_planner_tracked_boxes
+      Unreliable: false
+      Value: true
+      alpha: 0.8
+      color: 25; 255; 0
+      coloring: Value
+      line width: 0.01
+      only edge: false
+      show coords: false
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /op_simulator1/curr_simu_pose_1
+      Name: SimuCar1
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /op_simulator2/curr_simu_pose_2
+      Name: SimuCar2
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /op_simulator3/curr_simu_pose_3
+      Name: SimuCar3
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /op_simulator4/curr_simu_pose_4
+      Name: SimuCar4
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /op_simulator5/curr_simu_pose_5
+      Name: SimuCar5
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /op_simulator1/simu_local_trajectory_1
+      Name: SimPath1
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /op_simulator2/simu_local_trajectory_2
+      Name: SimPath2
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /op_simulator3/simu_local_trajectory_3
+      Name: SimPath3
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /op_simulator4/simu_local_trajectory_4
+      Name: SimPath4
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/MarkerArray
+      Enabled: true
+      Marker Topic: /op_simulator5/simu_local_trajectory_5
+      Name: SimPath5
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /op_simulator1/sim_beh_txt_1
+      Name: SimBehavior1
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /op_simulator2/sim_beh_txt_2
+      Name: SimBehavior2
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /op_simulator3/sim_beh_txt_3
+      Name: SimBehavior3
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /op_simulator4/sim_beh_txt_4
+      Name: SimBehavior4
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /op_simulator5/sim_beh_txt_5
+      Name: SimBehavior5
+      Namespaces:
+        {}
+      Queue Size: 100
       Value: true
   Enabled: true
   Global Options:
@@ -460,7 +680,7 @@ Visualization Manager:
   Value: true
   Views:
     Current:
-      Angle: 0
+      Angle: 0.00500008
       Class: rviz/TopDownOrtho
       Enable Stereo Rendering:
         Stereo Eye Separation: 0.06
@@ -469,23 +689,23 @@ Visualization Manager:
         Value: false
       Name: Current View
       Near Clip Distance: 0.01
-      Scale: 10
-      Target Frame: &lt;Fixed Frame&gt;
+      Scale: 11.8606
+      Target Frame: world
       Value: TopDownOrtho (rviz)
-      X: 0
-      Y: 0
+      X: 4.39087
+      Y: 3.01324
     Saved: ~
 Window Geometry:
   Camera:
     collapsed: false
   Displays:
     collapsed: false
-  Height: 961
+  Height: 1416
   Hide Left Dock: false
   Hide Right Dock: false
   Image:
     collapsed: false
-  QMainWindow State: 000000ff00000000fd00000004000000000000016a00000338fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc0000002800000260000000dd00fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000c00430061006d0065007200610000000000ffffffff0000006500fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000001600fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb0000000000000000000000010000010f00000338fc0200000003fb0000000a00560069006500770073010000002800000338000000b000fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000005a00000003dfc0100000002fb0000000800540069006d00650100000000000005a0000002f600fffffffb0000000800540069006d006501000000000000045000000000000000000000031b0000033800000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  QMainWindow State: 000000ff00000000fd0000000400000000000001fc000004e0fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc00000028000004e0000000dd00fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000005c00fffffffb0000000c00430061006d0065007200610000000000ffffffff0000006500fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb00000000000000000000000100000163000004e0fc0200000003fb0000000a005600690065007700730100000028000004e0000000b000fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e1000001970000000300000a000000005cfc0100000002fb0000000800540069006d0065010000000000000a00000002f600fffffffb0000000800540069006d0065010000000000000450000000000000000000000695000004e000000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
@@ -494,6 +714,6 @@ Window Geometry:
     collapsed: false
   Views:
     collapsed: false
-  Width: 1440
-  X: 1895
-  Y: 44
+  Width: 2560
+  X: 1070
+  Y: -14
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="255ad8eb8663f8581056b49fc270f8a569a4c2f5" author="Yusuke FUJII">
		<msg>Restructure OpenPlanner for merging autoware develop branch</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\BehaviorStateMachine.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\BehaviorStateMachine.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\GridMap.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\GridMap.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\HMIStateMachine.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\HMIStateMachine.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\LocalPlannerH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\LocalPlannerH.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\plannerh\MappingHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\MappingHelpers.h" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
 #ifndef MAPPINGHELPERS_H_
 #define MAPPINGHELPERS_H_
 
-#include &lt;math.h&gt;
+#include &lt;cmath&gt;
 #include "RoadNetwork.h"
 #include "UtilityH.h"
 #include "DataRW.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\plannerh\MatrixOperations.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\MatrixOperations.h" added_lines="1" deleted_lines="1">
				<diff>@@ -9,7 +9,7 @@
 #define MATRIXOPERATIONS_H_
 
 #include "RoadNetwork.h"
-#include &lt;math.h&gt;
+#include &lt;cmath&gt;
 
 
 namespace PlannerHNS {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\plannerh\PlannerCommonDef.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\PlannerCommonDef.h" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
 #ifndef PLANNERCOMMONDEF_H_
 #define PLANNERCOMMONDEF_H_
 
-#include &lt;math.h&gt;
+#include &lt;cmath&gt;
 #include &lt;string&gt;
 
 namespace PlannerHNS
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\PlannerH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\PlannerH.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\PlanningHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\PlanningHelpers.h" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
 #ifndef PLANNINGHELPERS_H_
 #define PLANNINGHELPERS_H_
 
-#include &lt;math.h&gt;
+#include &lt;cmath&gt;
 #include "RoadNetwork.h"
 #include "UtilityH.h"
 #include "DataRW.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\RSPlanner.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\RSPlanner.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\RoadNetwork.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\RoadNetwork.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\TrajectoryCosts.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\TrajectoryCosts.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\include\geo_pos_conv.hh" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\geo_pos_conv.hh" added_lines="1" deleted_lines="2">
				<diff>@@ -1,8 +1,7 @@
 #ifndef __GEO_POS_CONV__
 #define __GEO_POS_CONV__
 
-#include &lt;math.h&gt;
-
+#include &lt;cmath&gt;
 
 class geo_pos_conv {
 private:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\src\BehaviorStateMachine.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\BehaviorStateMachine.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\src\GridMap.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\GridMap.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\src\HMIStateMachine.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\HMIStateMachine.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\src\LocalPlannerH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\LocalPlannerH.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\src\MappingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\MappingHelpers.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\src\MatrixOperations.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\MatrixOperations.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\src\PlannerH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\PlannerH.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\src\PlanningHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\PlanningHelpers.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\src\RSPlanner.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\RSPlanner.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\src\TrajectoryCosts.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\TrajectoryCosts.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\src\geo_pos_conv.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\geo_pos_conv.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\include\AlternativeVisualizer.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\AlternativeVisualizer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\include\CarState.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\CarState.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\include\DrawObjBase.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\DrawObjBase.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\include\DrawingHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\DrawingHelpers.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\include\Graph2dBase.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\Graph2dBase.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\include\MainWindowWrapper.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\MainWindowWrapper.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\include\PlannerTestDraw.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\PlannerTestDraw.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\include\SimpleTracker.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\SimpleTracker.h" added_lines="22" deleted_lines="7">
				<diff>@@ -12,7 +12,7 @@
 #include "opencv2/video/tracking.hpp"
 #include &lt;vector&gt;
 #include "UtilityH.h"
-#include "math.h"
+#include &lt;cmath&gt;
 #include &lt;iostream&gt;
 
 namespace SimulationNS
@@ -108,10 +108,18 @@ public:
 		m_id = id;
 
 		m_filter = cv::KalmanFilter(nStates,nMeasure);
+#if (CV_MAJOR_VERSION == 2)
 		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
-																	   	   0	,1	,0	,dt	,
-																	   	   0	,0	,1	,0	,
-																	   	   0	,0	,0	,1	);
+				0	,1	,0	,dt	,
+				0	,0	,1	,0	,
+				0	,0	,0	,1	);
+#elif (CV_MAJOR_VERSION == 3)
+		m_filter.transitionMatrix = (cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
+				0	,1	,0	,dt	,
+				0	,0	,1	,0	,
+				0	,0	,0	,1	);
+#endif		
+
 		m_filter.statePre.at&lt;float&gt;(0) = x;
 		m_filter.statePre.at&lt;float&gt;(1) = y;
 		m_filter.statePre.at&lt;float&gt;(2) = 0;
@@ -133,10 +141,17 @@ public:
 	void UpdateTracking(double _dt, const double&amp; x, const double&amp; y, const double&amp; a, double&amp; x_new, double &amp; y_new , double&amp; a_new, double&amp; v)
 	{
 		dt = _dt;
+#if (CV_MAJOR_VERSION == 2)
 		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
-																			   	   0	,1	,0	,dt	,
-																			   	   0	,0	,1	,0	,
-																			   	   0	,0	,0	,1	);
+				0	,1	,0	,dt	,
+				0	,0	,1	,0	,
+				0	,0	,0	,1	);
+#elif (CV_MAJOR_VERSION == 3)
+		m_filter.transitionMatrix = (cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
+				0	,1	,0	,dt	,
+				0	,0	,1	,0	,
+				0	,0	,0	,1	);
+#endif		
 		double a_old = a;
 
 		cv::Mat_&lt;float&gt; measurement(nMeasure,1);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\include\SimulatedTrajectoryFollower.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\SimulatedTrajectoryFollower.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\include\TrajectoryFollower.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\TrajectoryFollower.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\include\glm.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\glm.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\main.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\main.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -6,9 +6,9 @@
  */
 
 #include &lt;iostream&gt;
+#include "AlternativeVisualizer.h"
 #include "MainWindowWrapper.h"
 #include "PlannerTestDraw.h"
-#include "AlternativeVisualizer.h"
 
 using namespace  Graphics;
 #define USE_ALT_VISUALIZER 1
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\src\AlternativeVisualizer.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\AlternativeVisualizer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\src\CarState.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\CarState.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\src\DrawObjBase.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\DrawObjBase.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\src\DrawingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\DrawingHelpers.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\src\Graph2dBase.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\Graph2dBase.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\src\MainWindowWrapper.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\MainWindowWrapper.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\src\PlannerTestDraw.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\PlannerTestDraw.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\src\SimpleTracker.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\SimpleTracker.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\src\SimulatedTrajectoryFollower.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\SimulatedTrajectoryFollower.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\src\TrajectoryFollower.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\TrajectoryFollower.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\Simu\src\glm.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\glm.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\DataRW.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_utilityh\include\DataRW.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\plannerh\UtilityH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_utilityh\include\UtilityH.h" added_lines="1" deleted_lines="1">
				<diff>@@ -18,7 +18,7 @@ namespace UtilityHNS
 
 #define DEG2RAD M_PI / 180.
 #define RAD2DEG 180. / M_PI
-#define sign(x) (x &gt; 0) ? 1 : ((x &lt; 0) ? -1 : 0)
+#define SIGN(x) (x &gt; 0) ? 1 : ((x &lt; 0) ? -1 : 0)
 #define MIN(x,y) (x &lt;= y ? x : y)
 #define MAX(x,y) (x &gt;= y ? x : y)
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\UtilityH\src\DataRW.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_utilityh\src\DataRW.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\UtilityH\src\UtilityH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_utilityh\src\UtilityH.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\MappingHelpers.h" new_path="" added_lines="0" deleted_lines="108">
				<diff>@@ -1,108 +0,0 @@
-/*
- * MappingHelpers.h
- *
- *  Created on: Jul 2, 2016
- *      Author: Hatem
- */
-
-#ifndef MAPPINGHELPERS_H_
-#define MAPPINGHELPERS_H_
-
-#include &lt;math.h&gt;
-#include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "DataRW.h"
-#include "tinyxml.h"
-
-
-namespace PlannerHNS {
-
-
-class MappingHelpers {
-public:
-	MappingHelpers();
-	virtual ~MappingHelpers();
-
-	static void ConstructRoadNetworkFromRosMessage(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
-			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
-			const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
-			const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
-			const std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt;&amp; area_data,
-			const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
-			const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
-			const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
-			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
-			const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
-			const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag = false);
-
-	static void ConstructRoadNetworkFromDataFiles(const std::string vectoMapPath, RoadNetwork&amp; map, const bool&amp; bZeroOrigin = false);
-
-	static void SaveTrajectoryLonLatToKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectory);
-
-	static void GetWayPoint(const int&amp; pid, const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points, std::vector&lt;WayPoint&gt;&amp; path);
-	static bool GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; did,
-			const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dtpoints,
-			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
-			const GPSPoint&amp; origin, WayPoint&amp; way_point);
-
-	static void WriteKML(const std::string&amp; kmlFile, const std::string&amp; kmlTemplat, RoadNetwork&amp; ap);
-	static void LoadKML(const std::string&amp; kmlMap, RoadNetwork&amp; map);
-
-	static void SetRoadLinksList(TiXmlElement* pElem, std::vector&lt;RoadSegment&gt;&amp; roadSegments);
-	static void SetLaneLinksList(TiXmlElement* pElem, std::vector&lt;Lane&gt;&amp; lanes);
-	static void SetStopLinesList(TiXmlElement* pElem, std::vector&lt;StopLine&gt;&amp; stopLines);
-	static void SetTrafficLightsList(TiXmlElement* pElem, std::vector&lt;TrafficLight&gt;&amp; trafficLights);
-	static void SetTrafficSignsList(TiXmlElement* pElem, std::vector&lt;TrafficSign&gt;&amp; trafficSignes);
-
-	static TiXmlElement* GetHeadElement(TiXmlElement* pMainElem);
-	static TiXmlElement* GetDataFolder(const std::string&amp; folderName, TiXmlElement* pMainElem);
-
-
-	static Lane* GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static Lane* GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static std::vector&lt;Lane*&gt; GetClosestMultipleLanesFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static WayPoint* GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
-	static WayPoint* GetClosestBackWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
-	static WayPoint GetFirstWaypoint(RoadNetwork&amp; map);
-	static WayPoint* GetLastWaypoint(RoadNetwork&amp; map);
-
-
-	static void llaToxyz(GPSPoint&amp; lla_p, const GPSPoint&amp; origin);
-	static void llaToxyzSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
-	static void xyzTolla(GPSPoint&amp; xyz_p, const GPSPoint&amp; origin);
-	static void xyzTollaSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
-
-	static void GetUniqueNextLanes(const Lane* l,  const std::vector&lt;Lane*&gt;&amp; traversed_lanes, std::vector&lt;Lane*&gt;&amp; lanes_list);
-
-	static GPSPoint GetTransformationOrigin(const int&amp; bToyotaCityMap = 0);
-
-	static Lane* GetLaneFromPath(const WayPoint&amp; currPos, const std::vector&lt;WayPoint&gt;&amp; currPath);
-	static Lane* GetLaneById(const int&amp; id,RoadNetwork&amp; map);
-	static int GetLaneIdByWaypointId(const int&amp; id,std::vector&lt;Lane&gt;&amp; lanes);
-
-	static WayPoint* FindWaypoint(const int&amp; id, RoadNetwork&amp; map);
-
-
-	static std::vector&lt;TrafficLight&gt; GetTrafficLightsList(TiXmlElement* pElem);
-	static std::vector&lt;StopLine&gt; GetStopLinesList(TiXmlElement* pElem);
-	static std::vector&lt;Lane&gt; GetLanesList(TiXmlElement* pElem);
-	static std::vector&lt;RoadSegment&gt; GetRoadSegmentsList(TiXmlElement* pElem);
-	static std::vector&lt;int&gt; GetIDsFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::vector&lt;double&gt; GetDoubleFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::pair&lt;ACTION_TYPE, double&gt; GetActionPairFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::vector&lt;WayPoint&gt; GetCenterLaneData(TiXmlElement* pElem, const int&amp; currLaneID);
-	static std::vector&lt;WayPoint&gt; GetCenterLaneDataVer0(TiXmlElement* pElem, const int&amp; currLaneID);
-	static std::vector&lt;GPSPoint&gt; GetPointsData(TiXmlElement* pElem);
-	static std::vector&lt;std::string&gt; SplitString(const std::string&amp; str, const std::string&amp; token);
-
-	static void CreateKmlFromLocalizationPathFile(const std::string&amp; pathFileName,const double&amp; maxLaneDistance, const double&amp; density,const std::vector&lt;TrafficLight&gt;&amp; trafficLights, const std::vector&lt;GPSPoint&gt;&amp; stopLines);
-
-	static int ReplaceMyID(int&amp; id, const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; rep_list);
-
-	static double m_USING_VER_ZERO;
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* MAPPINGHELPERS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\MatrixOperations.h" new_path="" added_lines="0" deleted_lines="131">
				<diff>@@ -1,131 +0,0 @@
-/*
- * MatrixOperations.h
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
-
-#ifndef MATRIXOPERATIONS_H_
-#define MATRIXOPERATIONS_H_
-
-#include "RoadNetwork.h"
-#include &lt;math.h&gt;
-
-
-namespace PlannerHNS {
-
-
-class Mat3
-{
-	double m11, m12, m13;
-	double m21, m22, m23;
-	double m31, m32, m33;
-
-	double m[3][3];
-
-public:
-	Mat3()
-	{
-		//initialize Identity by default
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-	}
-
-	Mat3(double angle, POINT2D trans)
-	{
-		//Initialize Rotation Matrix
-		double c = cos(angle);
-		double s = sin(angle);
-		m11 = c;
-		m12 = s;
-		m21 = -s;
-		m22 = c;
-		m31 = trans.x;
-		m32 = trans.y;
-		m13 = m23= 0;
-		m33 = 1;
-	}
-
-	Mat3(double transX, double transY, bool mirrorX, bool mirrorY )
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		m[0][0] = (mirrorX == true ) ? -1 : 1; m[0][1] =  0; m[0][2] =  transX;
-		m[1][0] = 0; m[1][1] =  (mirrorY==true) ? -1 : 1; m[1][2] =  transY;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(double transX, double transY)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		m[0][0] = 1; m[0][1] =  0; m[0][2] =  transX;
-		m[1][0] = 0; m[1][1] =  1; m[1][2] =  transY;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(double rotation_angle)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		double c = cos(rotation_angle);
-		double s = sin(rotation_angle);
-		m[0][0] = c; m[0][1] = -s; m[0][2] =  0;
-		m[1][0] = s; m[1][1] =  c; m[1][2] =  0;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(GPSPoint rotationCenter)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		double c = cos(rotationCenter.a);
-		double s = sin(rotationCenter.a);
-		double u = rotationCenter.x;
-		double v = rotationCenter.y;
-		m[0][0] = c; m[0][1] = -s; m[0][2] = -u*c + v*s + u;
-		m[1][0] = s; m[1][1] =  c; m[1][2] = -u*s - v*c + v;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-
-	GPSPoint operator * (GPSPoint v)
-	{
-		GPSPoint _v = v;
-		v.x = m[0][0]*_v.x + m[0][1]*_v.y + m[0][2]*1;
-		v.y = m[1][0]*_v.x + m[1][1]*_v.y + m[1][2]*1;
-		return v;
-	}
-
-	POINT2D operator * (POINT2D v)
-	{
-		Mat3 m = *this;
-		POINT2D r;
-		r.x = m.m11 * v.x + m.m21 * v.y + m.m31 * 1;
-		r.y = m.m12 * v.x + m.m22 * v.y + m.m32 * 1;
-		return r;
-	}
-
-	Mat3 operator *(Mat3 m2)
-	{
-		Mat3 m1 = *this;
-		Mat3 r;
-		r.m11 = m1.m11 * m2.m11 + m1.m12 * m2.m21 + m1.m13 * m2.m31;
-		r.m12 = m1.m11 * m2.m12 + m1.m12 * m2.m22 + m1.m13 * m2.m32;
-		r.m13 = m1.m11 * m2.m13 + m1.m12 * m2.m23 + m1.m13 * m2.m33;
-
-		r.m21 = m1.m21 * m2.m11 + m1.m22 * m2.m21 + m1.m23 * m2.m31;
-		r.m22 = m1.m21 * m2.m12 + m1.m22 * m2.m22 + m1.m23 * m2.m32;
-		r.m23 = m1.m21 * m2.m13 + m1.m22 * m2.m23 + m1.m23 * m2.m33;
-
-		r.m31 = m1.m31 * m2.m11 + m1.m32 * m2.m21 + m1.m33 * m2.m31;
-		r.m32 = m1.m31 * m2.m12 + m1.m32 * m2.m22 + m1.m33 * m2.m32;
-		r.m33 = m1.m31 * m2.m13 + m1.m32 * m2.m23 + m1.m33 * m2.m33;
-
-		return r;
-	}
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* MATRIXOPERATIONS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\PlannerCommonDef.h" new_path="" added_lines="0" deleted_lines="156">
				<diff>@@ -1,156 +0,0 @@
-/*
- * PlannerCommonDef.h
- *
- *  Created on: Dec 14, 2016
- *      Author: hatem
- */
-
-#ifndef PLANNERCOMMONDEF_H_
-#define PLANNERCOMMONDEF_H_
-
-#include &lt;math.h&gt;
-#include &lt;string&gt;
-
-namespace PlannerHNS
-{
-
-enum CAR_TYPE
-{
-  Mv2Car, //!&lt; Mv2Car
-  PHVCar, //!&lt; PHVCar
-  HVCar,  //!&lt; HVCar
-  RoboCar,//!&lt; RoboCar
-  SimulationCar
-};
-
-class PID_CONST
-{
-public:
-	double kP;
-	double kI;
-	double kD;
-
-	PID_CONST()
-	{
-		kP = kI = kD = 0;
-	}
-
-	PID_CONST(const double&amp; p, const double&amp; i, const double&amp; d)
-	{
-		kP = p;
-		kI = i;
-		kD = d;
-	}
-};
-
-class ControllerParams
-{
-public:
-	double SimulationSteeringDelay;
-	double SteeringDelay;
-	double minPursuiteDistance;
-	PID_CONST Steering_Gain;
-	PID_CONST Velocity_Gain;
-	double Acceleration;
-	double Deceleration;
-	double FollowDistance;
-	double LowpassSteerCutoff;
-	double maxAccel;
-	double maxDecel;
-
-
-	ControllerParams()
-	{
-		SimulationSteeringDelay = 0.0;
-		SteeringDelay 		= 0.8;
-		Acceleration		= 0.5;
-		Deceleration		= -0.8;
-		FollowDistance		= 8.0;
-		LowpassSteerCutoff	= 5.0;
-		maxAccel			= 0.9;
-		minPursuiteDistance = 2.0;
-		maxDecel 			= -1.5;
-	}
-};
-
-class CAR_BASIC_INFO
-{
-public:
-  CAR_TYPE model;
-
-  double turning_radius;
-  double wheel_base;
-  double max_speed_forward;
-  double min_speed_forward;
-  double max_speed_backword;
-  double max_steer_value;
-  double min_steer_value;
-  double max_brake_value;
-  double min_brake_value;
-  double max_steer_angle;
-  double min_steer_angle;
-  double length;
-  double width;
-  double max_acceleration;
-  double max_deceleration;
-
-  CAR_BASIC_INFO()
-  {
-	  model 				= SimulationCar;
-	  turning_radius 		= 5.2;
-	  wheel_base			= 2.7;
-	  max_speed_forward		= 3.0;
-	  min_speed_forward		= 0.0;
-	  max_speed_backword	= 1.0;
-	  max_steer_value		= 660;
-	  min_steer_value		= -660;
-	  max_brake_value		= 0;
-	  min_brake_value		= 0;
-	  max_steer_angle		= 0.42;
-	  min_steer_angle		= 0.42;
-	  length				= 4.3;
-	  width					= 1.82;
-	  max_acceleration		= 1.5; // m/s2
-	  max_deceleration		= -1.5; // 1/3 G
-  }
-
-  double CalcMaxSteeringAngle()
-  {
-    return  max_steer_angle;//asin(wheel_base/turning_radius);
-  }
-
-  double BoundSpeed(double s)
-  {
-	if(s &gt; 0 &amp;&amp; s &gt; max_speed_forward)
-		return max_speed_forward;
-	if(s &lt; 0 &amp;&amp; s &lt; max_speed_backword)
-		return max_speed_backword;
-	return s;
-  }
-
-  double BoundSteerAngle(double a)
-  {
-	if(a &gt; max_steer_angle)
-		return max_steer_angle;
-	if(a &lt; min_steer_angle)
-		return min_steer_angle;
-
-	return a;
-  }
-
-  double BoundSteerValue(double v)
-  {
-	  if(v &gt;= max_steer_value)
-		return max_steer_value;
-	if(v &lt;= min_steer_value)
-		return min_steer_value;
-
-	return v;
-  }
-
-};
-
-
-} /* namespace PlannerHNS */
-
-#endif /* PLANNERCOMMONDEF_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\SimpleTracker.h" new_path="" added_lines="0" deleted_lines="272">
				<diff>@@ -1,272 +0,0 @@
-/*
- * SimpleTracker.h
- *
- *  Created on: Aug 11, 2016
- *      Author: hatem
- */
-
-#ifndef SimpleTracker_H_
-#define SimpleTracker_H_
-
-#include "RoadNetwork.h"
-#include "opencv2/video/tracking.hpp"
-#include &lt;vector&gt;
-#include "UtilityH.h"
-#include "math.h"
-#include &lt;iostream&gt;
-
-namespace SimulationNS
-{
-
-#define DEBUG_TRACKER 0
-#define NEVER_GORGET_TIME -1000
-#define MIN_EVIDENCE_NUMBER 3
-
-struct Kalman1dState
-{
-    double MovCov; //double q; //moving noise covariance
-    double MeasureCov; //double r; //measurement noise covariance
-    double x; //value
-    double p; //estimation error covariance
-    double k; //kalman gain
-};
-
-class  kalmanFilter1D
-{
-public:
-
-	Kalman1dState result;
-
-    kalmanFilter1D()
-	{
-
-	}
-    kalmanFilter1D(double MovCov, double MeasureCov, double p, double intial_value)
-    {
-        result.MovCov = MovCov;
-        result.MeasureCov = MeasureCov;
-        result.p = p;
-        result.x = intial_value;
-    }
-
-    Kalman1dState Update(double measurement)
-    {
-    	//prediction update
-		//omit x = x
-		result.p = result.p + result.MovCov;
-
-		//measurement update
-		result.k = result.p / (result.p + result.MeasureCov);
-		result.x = result.x + result.k * (measurement - result.x);
-		result.p = (1 - result.k) * result.p;
-
-		return result;
-    }
-};
-
-class KFTrackV
-{
-private:
-	cv::KalmanFilter m_filter;
-	double prev_x, prev_y, prev_v, prev_a;
-	long m_id;
-	double dt;
-	int nStates;
-	int nMeasure;
-	double circ_angle;
-
-public:
-	int region_id;
-	double forget_time;
-	int m_iLife;
-	PlannerHNS::DetectedObject obj;
-	kalmanFilter1D errorSmoother;
-
-	long GetTrackID()
-	{
-		return m_id;
-	}
-
-	KFTrackV(double x, double y, double a, long id, double _dt)
-	{
-		circ_angle = 0;
-		errorSmoother.result.MovCov = 0.125;
-		errorSmoother.result.MeasureCov = 0.1;
-		errorSmoother.result.p = 1;
-		errorSmoother.result.x = 0;
-		region_id = -1;
-		forget_time = NEVER_GORGET_TIME; // this is very bad , dangerous
-		m_iLife = 0;
-		dt = _dt;
-		prev_x = x;
-		prev_y = y;
-		prev_v = 0;
-		prev_a = a;
-		nStates = 4;
-		nMeasure = 2;
-
-		m_id = id;
-
-		m_filter = cv::KalmanFilter(nStates,nMeasure);
-		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
-																	   	   0	,1	,0	,dt	,
-																	   	   0	,0	,1	,0	,
-																	   	   0	,0	,0	,1	);
-		m_filter.statePre.at&lt;float&gt;(0) = x;
-		m_filter.statePre.at&lt;float&gt;(1) = y;
-		m_filter.statePre.at&lt;float&gt;(2) = 0;
-		m_filter.statePre.at&lt;float&gt;(3) = 0;
-
-		m_filter.statePost = m_filter.statePre;
-
-		setIdentity(m_filter.measurementMatrix);
-
-		cv::setIdentity(m_filter.measurementNoiseCov, cv::Scalar::all(0.0001));
-		cv::setIdentity(m_filter.processNoiseCov, cv::Scalar::all(0.0001));
-		cv::setIdentity(m_filter.errorCovPost, cv::Scalar::all(0.075));
-
-		m_filter.predict();
-
-		errorSmoother.Update(a);
-	}
-
-	void UpdateTracking(double _dt, const double&amp; x, const double&amp; y, const double&amp; a, double&amp; x_new, double &amp; y_new , double&amp; a_new, double&amp; v)
-	{
-		dt = _dt;
-		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
-																			   	   0	,1	,0	,dt	,
-																			   	   0	,0	,1	,0	,
-																			   	   0	,0	,0	,1	);
-		double a_old = a;
-
-		cv::Mat_&lt;float&gt; measurement(nMeasure,1);
-		cv::Mat_&lt;float&gt; prediction(nStates,1);
-
-		measurement(0) = x;
-		measurement(1) = y;
-
-		prediction = m_filter.correct(measurement);
-
-		x_new = prediction.at&lt;float&gt;(0);
-		y_new = prediction.at&lt;float&gt;(1);
-		double vx  = prediction.at&lt;float&gt;(2);
-		double vy  = prediction.at&lt;float&gt;(3);
-
-		if(m_iLife &gt; 2)
-		{
-			v = sqrt(vx*vx+vy*vy);
-			double diff_y = y_new - prev_y;
-			double diff_x = x_new - prev_x;
-			if(hypot(diff_y, diff_x) &gt; 0.5)
-			{
-				prev_y = y;
-				prev_x = x;
-				a_new = atan2(diff_y, diff_x);
-			}
-			else
-				a_new = a;
-
-		}
-		else
-		{
-			v = 0;
-			a_new = a;
-		}
-
-		circ_angle = UtilityHNS::UtilityH::GetCircularAngle(circ_angle, UtilityHNS::UtilityH::FixNegativeAngle(a_old), UtilityHNS::UtilityH::FixNegativeAngle(a_new));
-
-		circ_angle =  errorSmoother.Update(circ_angle).x;
-
-		a_new = UtilityHNS::UtilityH::SplitPositiveAngle(circ_angle);
-
-		if(v &lt; 0.1)
-			v = 0;
-
-		//std::cout &lt;&lt; "Track: Old (" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; "), New (" &lt;&lt; x_new &lt;&lt; ", " &lt;&lt; y_new &lt;&lt; ")" &lt;&lt; std::endl;
-		//std::cout &lt;&lt; "Track: " &lt;&lt; m_id &lt;&lt; ", A: " &lt;&lt; a &lt;&lt; ", A_new:(" &lt;&lt; circ_angle &lt;&lt; "," &lt;&lt;  a_new &lt;&lt; ") , V" &lt;&lt; v &lt;&lt; ", dt: " &lt;&lt; dt &lt;&lt; ", forget_time: " &lt;&lt; forget_time &lt;&lt; std::endl;
-
-		m_filter.predict();
-		m_filter.statePre.copyTo(m_filter.statePost);
-		m_filter.errorCovPre.copyTo(m_filter.errorCovPost);
-
-		forget_time -= dt;
-		m_iLife++;
-	}
-	virtual ~KFTrackV(){}
-};
-
-class InterestCircle
-{
-public:
-	int id;
-	double radius;
-	double forget_time;
-	std::vector&lt;KFTrackV*&gt; pTrackers;
-	InterestCircle* pPrevCircle;
-	InterestCircle* pNextCircle;
-
-	InterestCircle(int _id)
-	{
-		id = _id;
-		radius = 0;
-		forget_time = NEVER_GORGET_TIME; // never forget
-		pPrevCircle = 0;
-		pNextCircle = 0;
-	}
-};
-
-class CostRecordSet
-{
-public:
-	int currobj;
-	int prevObj;
-	double cost;
-	CostRecordSet(int curr_id, int prev_id, double _cost)
-	{
-		currobj = curr_id;
-		prevObj = prev_id;
-		cost = _cost;
-	}
-};
-
-class SimpleTracker
-{
-public:
-	std::vector&lt;InterestCircle*&gt; m_InterestRegions;
-	std::vector&lt;KFTrackV*&gt; m_Tracks;
-	timespec m_TrackTimer;
-	long iTracksNumber;
-	PlannerHNS::WayPoint m_PrevState;
-	std::vector&lt;PlannerHNS::DetectedObject&gt; m_PrevDetectedObjects;
-	std::vector&lt;PlannerHNS::DetectedObject&gt; m_DetectedObjects;
-
-	void CreateTrack(PlannerHNS::DetectedObject&amp; o);
-	void CreateTrackV2(PlannerHNS::DetectedObject&amp; o);
-	KFTrackV* FindTrack(long index);
-	void Track(std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; objects_list);
-	void TrackV2();
-	void CoordinateTransform(const PlannerHNS::WayPoint&amp; refCoordinate, PlannerHNS::DetectedObject&amp; obj);
-	void CoordinateTransformPoint(const PlannerHNS::WayPoint&amp; refCoordinate, PlannerHNS::GPSPoint&amp; obj);
-	void AssociateObjects();
-	void InitializeInterestRegions(double horizon, double init_raduis, double init_time, std::vector&lt;InterestCircle*&gt;&amp; regions);
-	void AssociateAndTrack();
-	void AssociateToRegions(KFTrackV&amp; detectedObject);
-	void CleanOldTracks();
-
-	void DoOneStep(const PlannerHNS::WayPoint&amp; currPose, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-
-	SimpleTracker(double horizon = 100);
-	virtual ~SimpleTracker();
-
-public:
-	double m_DT;
-	double m_MAX_ASSOCIATION_DISTANCE;
-	int m_MAX_TRACKS_AFTER_LOSING;
-	bool m_bUseCenterOnly;
-	double m_MaxKeepTime;
-	bool m_bFirstCall;
-};
-
-} /* namespace BehaviorsNS */
-
-#endif /* SimpleTracker_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\plannerh\UtilityH.h" new_path="" added_lines="0" deleted_lines="115">
				<diff>@@ -1,115 +0,0 @@
-/*
- * UtilityH.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#ifndef UTILITYH_H_
-#define UTILITYH_H_
-
-#include &lt;assert.h&gt;
-#include &lt;math.h&gt;
-#include &lt;string&gt;
-
-
-namespace UtilityHNS
-{
-
-#define DEG2RAD M_PI / 180.
-#define RAD2DEG 180. / M_PI
-#define sign(x) (x &gt; 0) ? 1 : ((x &lt; 0) ? -1 : 0)
-#define MIN(x,y) (x &lt;= y ? x : y)
-#define MAX(x,y) (x &gt;= y ? x : y)
-
-
-class UtilityH
-{
-public:
-	UtilityH();
-	virtual ~UtilityH(); 
-
-
-	static double FixNegativeAngle(const double&amp; a);
-	static double SplitPositiveAngle(const double&amp; a);
-	static double InverseAngle(const double&amp; a);
-	static double AngleBetweenTwoAnglesPositive(const double&amp; a1, const double&amp; a2);
-	static double GetCircularAngle(const double&amp; prevContAngle, const double&amp; prevAngle, const double&amp; currAngle);
-
-	//Time Functions
-	static void GetTickCount(struct timespec&amp; t);
-	static std::string GetFilePrefixHourMinuteSeconds();
-	static double GetTimeDiffNow(const struct timespec&amp; old_t);
-	static double GetTimeDiff(const struct timespec&amp; old_t,const struct timespec&amp; curr_t);
-	static std::string GetDateTimeStr();
-	static int tsCompare (struct  timespec  time1,   struct  timespec  time2, int micro_tolerance = 10);
-	static int GetSign(double x);
-	static std::string GetHomeDirectory();
-	static double GetMomentumScaleFactor(const double&amp; v);
-	static timespec GetTimeSpec(const time_t&amp; srcT);
-	static time_t GetLongTime(const struct timespec&amp; srcT);
-};
-
-class PIDController
-{
-public:
-	PIDController();
-	PIDController(const double&amp; kp, const double&amp; ki, const double&amp; kd);
-	void Init(const double&amp; kp, const double&amp; ki, const double&amp; kd);
-	void Setlimit(const double&amp; upper,const double&amp; lower);
-	double getPID(const double&amp; currValue, const double&amp; targetValue);
-	double getPID(const double&amp; e);
-	void ResetD();
-	void ResetI();
-	std::string ToString();
-	std::string ToStringHeader();
-
-
-private:
-	double kp;
-	double ki;
-	double kd;
-	double kp_v;
-	double ki_v;
-	double kd_v;
-	double pid_v;
-	double pid_lim;
-	double upper_limit;
-	double lower_limit;
-	bool   bEnableLimit;
-	double accumErr;
-	double prevErr;
-	bool bResetD;
-	bool bResetI;
-
-};
-
-class LowpassFilter
-{
-public:
-	LowpassFilter();
-	virtual ~LowpassFilter();
-
-	LowpassFilter(const int&amp; filterOrder, const double&amp; sampleFreq, const double&amp; cutOffFreq);
-	void Init(const int&amp; filterOrder, const double&amp; sampleFreq, const double&amp; cutOffFreq);
-	double getFilter(const double&amp; value);
-
-
-private:
-	int m;
-	double sampleF;
-	double cutOffF;
-	double A  ;
-	double d1 ;
-	double d2 ;
-	double w0 ;
-	double w1 ;
-	double w2 ;
-
-};
-
-}
-
-#endif
-
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\include\BehaviorStateMachine.h" new_path="" added_lines="0" deleted_lines="176">
				<diff>@@ -1,176 +0,0 @@
-/*
- * BehaviorStateMachine.h
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
-
-#ifndef BEHAVIORSTATEMACHINE_H_
-#define BEHAVIORSTATEMACHINE_H_
-
-#include "RoadNetwork.h"
-#include &lt;sstream&gt;
-
-namespace PlannerHNS
-{
-class BehaviorStateMachine
-{
-public:
-	virtual BehaviorStateMachine* GetNextState() = 0;
-	virtual void Init();
-	virtual void ResetTimer();
-	virtual void InsertNextState(BehaviorStateMachine* nextState);
-	BehaviorStateMachine(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* nextState);
-	virtual ~BehaviorStateMachine() ;
-
-	STATE_TYPE m_Behavior;
-	int m_currentStopSignID	;
-	int m_currentTrafficLightID ;
-	double decisionMakingTime;
-	double m_zero_velocity;
-
-	PreCalculatedConditions* GetCalcParams()
-	{
-		if(!m_pCalculatedValues)
-				m_pCalculatedValues = new PreCalculatedConditions();
-
-		return m_pCalculatedValues;
-	}
-
-	void SetBehaviorsParams(PlanningParams* pParams)
-	{
-		if(!pParams)
-			m_pParams = new PlanningParams;
-		else
-			m_pParams = pParams;
-	}
-
-
-	PreCalculatedConditions* m_pCalculatedValues;
-	PlanningParams* m_pParams;
-	timespec m_StateTimer;
-	std::vector&lt;BehaviorStateMachine*&gt; pNextStates;
-
-	BehaviorStateMachine* FindBehaviorState(const STATE_TYPE&amp; behavior);
-};
-
-class ForwardState : public BehaviorStateMachine
-{
-public:
-	ForwardState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FORWARD_STATE;}
-	virtual ~ForwardState(){}
-	virtual BehaviorStateMachine* GetNextState();
-};
-
-class MissionAccomplishedState : public BehaviorStateMachine
-{
-public:
-	MissionAccomplishedState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FINISH_STATE;}
-	virtual ~MissionAccomplishedState(){}
-	virtual BehaviorStateMachine* GetNextState();
-};
-
-class FollowState : public BehaviorStateMachine
-{
-public:
-	FollowState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FOLLOW_STATE;}
-	virtual ~FollowState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class SwerveState : public BehaviorStateMachine
-{
-public:
-	SwerveState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = OBSTACLE_AVOIDANCE_STATE;}
-	virtual ~SwerveState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopState : public BehaviorStateMachine
-{
-public:
-	StopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOPPING_STATE;}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class TrafficLightStopState : public BehaviorStateMachine
-{
-public:
-	TrafficLightStopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = TRAFFIC_LIGHT_STOP_STATE;}
-	virtual ~TrafficLightStopState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class TrafficLightWaitState : public BehaviorStateMachine
-{
-public:
-	TrafficLightWaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = TRAFFIC_LIGHT_WAIT_STATE;}
-	virtual ~TrafficLightWaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopSignStopState : public BehaviorStateMachine
-{
-public:
-	StopSignStopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOP_SIGN_STOP_STATE;}
-	virtual ~StopSignStopState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopSignWaitState : public BehaviorStateMachine
-{
-public:
-	StopSignWaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOP_SIGN_WAIT_STATE;}
-	virtual ~StopSignWaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class WaitState : public BehaviorStateMachine
-{
-public:
-	WaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = WAITING_STATE;}
-	virtual ~WaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class InitState : public BehaviorStateMachine
-{
-public:
-	InitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = INITIAL_STATE;}
-	virtual ~InitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class GoalState : public BehaviorStateMachine
-{
-public:
-	GoalState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = GOAL_STATE;}
-	virtual ~GoalState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* BEHAVIORSTATEMACHINE_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\include\GridMap.h" new_path="" added_lines="0" deleted_lines="230">
				<diff>@@ -1,230 +0,0 @@
-/*
- * GridMap.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#ifndef GRIDMAPSA_H_
-#define GRIDMAPSA_H_
-
-#include "RoadNetwork.h"
-
-namespace PlannerHNS
-{
-
-#define get2dIndex(r,c,w) r*w + c
-#define checkGridLimit(r,c,h,w) r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; h &amp;&amp; c &lt; w
-#define checkGridIndex(i, nCells) i &gt;= 0 &amp;&amp; i &lt; nCells
-#define SUBCELL_L 10 //subcell lenth in centimeter
-
-
-class CELL_Info
-{
-public:
-  int r,c,index;
-  GPSPoint center;
-  int nCells;
-  double heuristic;
-  double forwardHeuristic;
-  double backwardHeuristic;
-  double heuristicValue;
-  double forward_heuristicValue;
-  double backward_heuristicValue;
-  int expanded; // used in path planning
-  bool closed;
-  double value;
-  int action;
-  double localize_val;
-  double localize_prob;
-  std::vector&lt;double&gt; localize_features;
-  GPSPoint forwardCenter;
-  GPSPoint backwardCenter;
-  DIRECTION_TYPE bDir;
-  POINT2D bottom_left;
-  POINT2D top_right;
-  POINT2D bottom_right;
-  POINT2D top_left;
-  int nStaticPoints;
-  int nMovingPoints;
-
-  CELL_Info* pInnerMap;
-
-  std::vector&lt;POINT2D&gt; innerStaticPointsList;
-  std::vector&lt;POINT2D&gt; innerMovingPointsList;
-
-  std::vector&lt;GPSPoint&gt; path;
-
-
-public:
-  void InitSubCells(double cell_l, double sub_cell_l);
-/**
- * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
- * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
- */
-  void Clear(int bMovingOnly);
-  void ClearSubCells(bool bMovingOnly);
-
-  CELL_Info();
-
-  virtual ~CELL_Info();
-
-  /*
-   * Cell initialization
-   */
-  void Initialize(POINT2D bottom_left, double cell_l, int row, int col, bool bDefaultEmpty);
-
-  /*
-   * assignment operator
-   */
-  bool operator==(const CELL_Info&amp; cell);
-
-  bool operator!=(const CELL_Info&amp; cell);
-
-  inline bool PointInRect(const POINT2D&amp; p)
-   {
-     return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
-   }
-
-  bool TestWithRectangle(RECTANGLE&amp; rec);
-  bool TestWithCircle(POINT2D _center,double  width);
-   inline bool HitTest(const POINT2D&amp; p);
-
-   void UpdateSubCellCostValue(const std::vector&lt;POINT2D&gt;&amp; ps, const double&amp; cell_l, const double&amp; sub_cell_l);
-   void UpdateCostValue(const std::vector&lt;POINT2D&gt;&amp; ps);
-
-   void SaveCell(std::ostream&amp; f);
-   void LoadCell(std::ifstream&amp; f);
-
-};
-
-class GridMap
-{
-  public:
-
-	  pthread_mutex_t update_map_mutex;
-
-    double w, inner_w; // current world width
-    double h, inner_h; // current world height
-    double cell_l; // cell or block length, if this is an inner cell measurements will be in meter
-    double sub_cell_l;
-    double origin_x , origin_y;
-
-
-
-    int inner_start_row;
-    int inner_start_col;
-    int inner_end_row;
-    int inner_end_col;
-
-    bool m_bEnableInnerMap;
-    bool m_bUpdatedMap;
-
-
-
-    int wCells, nInnerWCells; // width, number of cells per row
-    int hCells, nInnerHCells; // height, number of cells per column
-	//POINT2D center;
-	int m_MaxHeuristics;
-
-	int m_DisplayResolution;
-
-	POINT2D* delta;
-
-
-    // This method map obstacles from real world space to Grid space , marking each cell or internal cells as obstacle
-	void UpdateMapObstacleValue(const Obstacle&amp; ob);
-	void UpdateMapDrivablesValue(const DrivableArea&amp; dr);
-	void UpdateMapDrivablesValuePlygon(const std::vector&lt;std::vector&lt;POINT2D&gt; &gt;&amp; points);
-	void UpdateMapObstaclesValuePlygon(const std::vector&lt;POINT2D&gt;&amp; poly, std::vector&lt;CELL_Info*&gt;&amp; modifiedCell);
-
-	/**
-	 * @brief update cell to indicate that there is an obstacle @ absolute point p
-	 * @param p absolute x,y point
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapObstaclePoint(const POINT2D&amp; p);
-
-	/**
-	 * @brief update cell to indicate that there is an obstacle @ absolute point p , and make the map thiner according to a giving threshold
-	 * @param p absolute x,y point
-	 * @param thiningTHreshold distance to search for old obstacles
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateThinMapObstaclePoint(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold);
-
-	/**
-	 * @brief update cell to indicate that there is an moving obstacle @ absolute point p
-	 * @param p absolute x,y point
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapMovingObstaclePoint(const POINT2D&amp; p);
-
-	/**
-	 * @brief update subcells cost values to reflect the effect of obstacle @ absolute pint p
-	 * @param p obstacle point (x,y)
-	 * @param currPos current car location to apply the effect of obstacle on p
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapCostValueRange(const std::vector&lt;POINT2D&gt;&amp; ps, const GPSPoint&amp; currPos, const std::vector&lt;double&gt;&amp; features);
-	/**
-	 * @brief find the cell @ p then update its localization cost and probability which were read from a map file
-	 * @param p absolute position of the cell center
-	 * @param localize_val cost value
-	 * @param localize_prob probability value (should be zero in case of updating from map file
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateSubMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);
-
-	CELL_Info* UpdateMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);
-
-	CELL_Info* GetCellFromPointInnerMap(const POINT2D&amp; p);
-	CELL_Info* GetCellFromPoint(const POINT2D&amp; p, bool bExpand = false); // return cell information from (x,y) coordinates
-	CELL_Info* GetSubCellFromPoint(const POINT2D&amp; p); // return sub cell information from (x,y) coordinates
-	CELL_Info* GetSubCellFromCell(CELL_Info* const parent, const POINT2D&amp; p); // return sub cell information from parent cell
-
-	bool CheckSubCellsInTheWay(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold, std::vector&lt;CELL_Info*&gt;&amp; pSubCellsList);
-
-	/**
-	 * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
-	 * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
-	 */
-	void ClearMap(int bMovingOnly);
-	void OpenClosedCells();
-	void BackupMap();
-
-	GridMap();
-    GridMap(double start_x, double start_y, double  map_w, double map_h, double cell_length, bool bDefaultEmpty); // initialize and construct the 2D array of the Grid cells
-    void InitInnerMap(double  map_l, GridMap* const pParentMap, const POINT2D&amp; center); // initialize and construct map from another map (cells will point to cells from the other map , width and hight will be maximum available limited by the parameters
-    virtual ~GridMap();
-
-    CELL_Info* pCells;
-    int nCells;
-
-    void SaveMap(const std::string&amp; mapFilePath, const std::string&amp; mapName);
-    void LoadMap(const std::string&amp; mapFilePath, const POINT2D&amp; pos, const double&amp; loadingRadius, const GPSPoint&amp; mapTransformation);
-
-    int GetSurroundingMainCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
-    int GetSurroundingNonObstacleCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
-    int GetSurroundingMainCellsRectangle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
-    int GetSurroundingMainCellsCircle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, double radius);
-    int GetSurroundingMainCellsRectangleNoObstacle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
-
-    bool IsUpdated()
-    {
-    	return m_bUpdatedMap;
-    }
-
-    void ObservedMap()
-    {
-    	m_bUpdatedMap = false;
-    }
-
-  private:
-    int InsidePolygon(const std::vector&lt;POINT2D&gt;&amp; polygon,const POINT2D&amp; p);
-
-    //vector&lt;CELL_Info*&gt; pDrivableCells;
-  };
-
-}
-#endif /* GRIDMAP_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\include\HMIStateMachine.h" new_path="" added_lines="0" deleted_lines="99">
				<diff>@@ -1,99 +0,0 @@
-/*
- * HMIStateMachine.h
- *
- *  Created on: February 14, 2017
- *      Author: Hatem Darweesh
- */
-
-#ifndef HMIStateMachine_H_
-#define HMIStateMachine_H_
-
-#include "RoadNetwork.h"
-#include &lt;sstream&gt;
-
-namespace PlannerHNS
-{
-
-class HMIStateMachine
-{
-public:
-	virtual HMIStateMachine* GetNextState() = 0;
-	virtual void Init();
-	virtual void ResetTimer();
-	virtual void InsertNextState(HMIStateMachine* nextState);
-	HMIStateMachine(HMIStateMachine* nextState);
-	virtual ~HMIStateMachine() ;
-
-	GLOBAL_STATE_TYPE m_Behavior;
-	double decisionMakingTime;
-
-	HMIPreCalculatedConditions* GetCalcParams()
-	{
-		if(!m_pCalculatedValues)
-				m_pCalculatedValues = new HMIPreCalculatedConditions();
-
-		return m_pCalculatedValues;
-	}
-
-	void SetBehaviorsParams(const PlanningParams&amp; params)
-	{
-		m_PlanningParams = params;
-	}
-
-	static HMIPreCalculatedConditions* m_pCalculatedValues;
-	timespec m_StateTimer;
-	std::vector&lt;HMIStateMachine*&gt; pNextStates;
-	static PlanningParams m_PlanningParams;
-
-	HMIStateMachine* FindBehaviorState(const GLOBAL_STATE_TYPE&amp; behavior);
-};
-
-class GWaitingState : public HMIStateMachine
-{
-public:
-	GWaitingState(GWaitingState* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_WAITING_STATE;}
-	virtual ~GWaitingState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GPlanningState : public HMIStateMachine
-{
-public:
-	GPlanningState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_PLANING_STATE;}
-	virtual ~GPlanningState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GForwardState : public HMIStateMachine
-{
-public:
-	GForwardState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_FORWARD_STATE;}
-	virtual ~GForwardState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GBranchingState : public HMIStateMachine
-{
-public:
-	GBranchingState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_BRANCHING_STATE;}
-	virtual ~GBranchingState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GEndState : public HMIStateMachine
-{
-public:
-	GEndState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_FINISH_STATE;}
-	virtual ~GEndState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-
-} /* namespace PlannerHNS */
-
-#endif /* HMIStateMachine_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\include\LocalPlannerH.h" new_path="" added_lines="0" deleted_lines="157">
				<diff>@@ -1,157 +0,0 @@
-/*
- * CarState.h
- *
- *  Created on: Dec 14, 2016
- *      Author: hatem
- */
-
-#ifndef LOCALPLANNERH_H_
-#define LOCALPLANNERH_H_
-
-#include "BehaviorStateMachine.h"
-#include "PlannerCommonDef.h"
-#include "RoadNetwork.h"
-#include "TrajectoryCosts.h"
-
-namespace PlannerHNS
-{
-
-class LocalPlannerH
-{
-public:
-	WayPoint state;
-	CAR_BASIC_INFO m_CarInfo;
-	ControllerParams m_ControlParams;
-	std::vector&lt;GPSPoint&gt; m_CarShapePolygon;
-	std::vector&lt;WayPoint&gt; m_Path;
-	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_TotalPath;
-	int m_iCurrentTotalPathId;
-	int m_iSafeTrajectory;
-//	int m_iGlobalPathPrevID;
-	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_PredictedPath;
-	std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt; m_RollOuts;
-	std::string carId;
-	Lane* pLane;
-	double m_SimulationSteeringDelayFactor; //second , time that every degree change in the steering wheel takes
-	timespec m_SteerDelayTimer;
-	double m_PredictionTime;
-	double m_CostCalculationTime;
-	double m_BehaviorGenTime;
-	double m_RollOutsGenerationTime;
-
-	BehaviorStateMachine* 		m_pCurrentBehaviorState;
-	ForwardState * 				m_pGoToGoalState;
-	StopState* 					m_pStopState;
-	WaitState* 					m_pWaitState;
-	InitState* 					m_pInitState;
-	MissionAccomplishedState*	m_pMissionCompleteState;
-	GoalState*					m_pGoalState;
-	FollowState*				m_pFollowState;
-	SwerveState*				m_pAvoidObstacleState;
-	TrafficLightStopState*		m_pTrafficLightStopState;
-	TrafficLightWaitState*		m_pTrafficLightWaitState;
-	StopSignStopState* 			m_pStopSignStopState;
-	StopSignWaitState* 			m_pStopSignWaitState;
-
-	TrajectoryCosts m_TrajectoryCostsCalculatotor;
-
-
-
-	//for debugging
-	std::vector&lt;WayPoint&gt; m_PathSection;
-	std::vector&lt;WayPoint&gt; m_SampledPoints;
-
-	void InitBehaviorStates();
-
-	void SetSimulatedTargetOdometryReadings(const double&amp; velocity_d, const double&amp; steering_d, const SHIFT_POS&amp; shift_d)
-	{
-		m_CurrentVelocityD = velocity_d;
-		m_CurrentSteeringD = steering_d;
-		m_CurrentShiftD = shift_d;
-	}
-
-	double GetSimulatedVelocity()
-	{
-		return m_CurrentVelocity;
-	}
-
-	double GetSimulatedSteering()
-	{
-		return m_CurrentSteering;
-	}
-
-	double GetSimulatedShift()
-	{
-		return m_CurrentShift;
-	}
-
-
-	//For Simulation
-	WayPoint m_OdometryState;
-	double m_CurrentVelocity, m_CurrentVelocityD; //meter/second
-	double m_CurrentSteering, m_CurrentSteeringD; //radians
-	SHIFT_POS m_CurrentShift , m_CurrentShiftD;
-
-	double m_CurrentAccSteerAngle; //degrees steer wheel range
-	double m_CurrentAccVelocity; // kilometer/hour
-	//std::vector&lt;TrafficLight&gt; m_TrafficLights;
-
-public:
-
-	LocalPlannerH();
-	virtual ~LocalPlannerH();
-	void Init(const ControllerParams&amp; ctrlParams, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo);
-	void InitPolygons();
-	void FirstLocalizeMe(const WayPoint&amp; initCarPos);
-	void LocalizeMe(const double&amp; dt); // in seconds
-	void UpdateState(const VehicleState&amp; state, const bool&amp; bUseDelay = false);
-	void CalculateImportantParameterForDecisionMaking(const VehicleState&amp; car_state,
-			const int&amp; goalID, const bool&amp; bEmergencyStop, const bool&amp; bGreenTrafficLight,
-			const TrajectoryCost&amp; bestTrajectory);
-
-	BehaviorState DoOneStep(
-			const double&amp; dt,
-			const VehicleState&amp; state,
-			const std::vector&lt;DetectedObject&gt;&amp; obj_list,
-			const int&amp; goalID,
-			RoadNetwork&amp; map,
-			const bool&amp; bEmergencyStop,
-			const bool&amp; bGreenTrafficLight,
-			const bool&amp; bLive = false);
-
-	void SimulateOdoPosition(const double&amp; dt, const VehicleState&amp; vehicleState);
-
-private:
-
-	//Obstacle avoidance functionalities
-	bool CalculateObstacleCosts(RoadNetwork&amp; map, const VehicleState&amp; vstatus, const std::vector&lt;DetectedObject&gt;&amp; obj_list);
-
-	double PredictTimeCostForTrajectory(std::vector&lt;WayPoint&gt;&amp; path,
-			const VehicleState&amp; vstatus,
-			const WayPoint&amp; currState);
-
-	void PredictObstacleTrajectory(RoadNetwork&amp; map,
-			const WayPoint&amp; pos,
-			const double&amp; predTime,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-	bool CalculateIntersectionVelocities(std::vector&lt;WayPoint&gt;&amp; path,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; predctedPath,
-			const DetectedObject&amp; obj);
-
-	bool GetNextTrafficLight(const int&amp; prevTrafficLightId, const std::vector&lt;TrafficLight&gt;&amp; trafficLights, TrafficLight&amp; trafficL);
-	void UpdateCurrentLane(RoadNetwork&amp; map, const double&amp; search_distance);
-	bool SelectSafeTrajectoryAndSpeedProfile(const VehicleState&amp; vehicleState);
-	BehaviorState GenerateBehaviorState(const VehicleState&amp; vehicleState);
-	void TransformPoint(const WayPoint&amp; refPose, GPSPoint&amp; p);
-	void AddAndTransformContourPoints(const DetectedObject&amp; obj, std::vector&lt;WayPoint&gt;&amp; contourPoints);
-	void UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt);
-
-	bool NoWayTest(const double&amp; min_distance, const int&amp; iGlobalPathIndex);
-
-	PlannerHNS::PlanningParams m_params;
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* LOCALPLANNERH_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\include\MappingHelpers.h" new_path="" added_lines="0" deleted_lines="108">
				<diff>@@ -1,108 +0,0 @@
-/*
- * MappingHelpers.h
- *
- *  Created on: Jul 2, 2016
- *      Author: Hatem
- */
-
-#ifndef MAPPINGHELPERS_H_
-#define MAPPINGHELPERS_H_
-
-#include &lt;math.h&gt;
-#include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "DataRW.h"
-#include "tinyxml.h"
-
-
-namespace PlannerHNS {
-
-
-class MappingHelpers {
-public:
-	MappingHelpers();
-	virtual ~MappingHelpers();
-
-	static void ConstructRoadNetworkFromRosMessage(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
-			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
-			const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
-			const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
-			const std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt;&amp; area_data,
-			const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
-			const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
-			const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
-			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
-			const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
-			const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag = false);
-
-	static void ConstructRoadNetworkFromDataFiles(const std::string vectoMapPath, RoadNetwork&amp; map, const bool&amp; bZeroOrigin = false);
-
-	static void SaveTrajectoryLonLatToKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectory);
-
-	static void GetWayPoint(const int&amp; pid, const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points, std::vector&lt;WayPoint&gt;&amp; path);
-	static bool GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; did,
-			const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dtpoints,
-			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
-			const GPSPoint&amp; origin, WayPoint&amp; way_point);
-
-	static void WriteKML(const std::string&amp; kmlFile, const std::string&amp; kmlTemplat, RoadNetwork&amp; ap);
-	static void LoadKML(const std::string&amp; kmlMap, RoadNetwork&amp; map);
-
-	static void SetRoadLinksList(TiXmlElement* pElem, std::vector&lt;RoadSegment&gt;&amp; roadSegments);
-	static void SetLaneLinksList(TiXmlElement* pElem, std::vector&lt;Lane&gt;&amp; lanes);
-	static void SetStopLinesList(TiXmlElement* pElem, std::vector&lt;StopLine&gt;&amp; stopLines);
-	static void SetTrafficLightsList(TiXmlElement* pElem, std::vector&lt;TrafficLight&gt;&amp; trafficLights);
-	static void SetTrafficSignsList(TiXmlElement* pElem, std::vector&lt;TrafficSign&gt;&amp; trafficSignes);
-
-	static TiXmlElement* GetHeadElement(TiXmlElement* pMainElem);
-	static TiXmlElement* GetDataFolder(const std::string&amp; folderName, TiXmlElement* pMainElem);
-
-
-	static Lane* GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static Lane* GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static std::vector&lt;Lane*&gt; GetClosestMultipleLanesFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static WayPoint* GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
-	static WayPoint* GetClosestBackWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
-	static WayPoint GetFirstWaypoint(RoadNetwork&amp; map);
-	static WayPoint* GetLastWaypoint(RoadNetwork&amp; map);
-
-
-	static void llaToxyz(GPSPoint&amp; lla_p, const GPSPoint&amp; origin);
-	static void llaToxyzSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
-	static void xyzTolla(GPSPoint&amp; xyz_p, const GPSPoint&amp; origin);
-	static void xyzTollaSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
-
-	static void GetUniqueNextLanes(const Lane* l,  const std::vector&lt;Lane*&gt;&amp; traversed_lanes, std::vector&lt;Lane*&gt;&amp; lanes_list);
-
-	static GPSPoint GetTransformationOrigin(const int&amp; bToyotaCityMap = 0);
-
-	static Lane* GetLaneFromPath(const WayPoint&amp; currPos, const std::vector&lt;WayPoint&gt;&amp; currPath);
-	static Lane* GetLaneById(const int&amp; id,RoadNetwork&amp; map);
-	static int GetLaneIdByWaypointId(const int&amp; id,std::vector&lt;Lane&gt;&amp; lanes);
-
-	static WayPoint* FindWaypoint(const int&amp; id, RoadNetwork&amp; map);
-
-
-	static std::vector&lt;TrafficLight&gt; GetTrafficLightsList(TiXmlElement* pElem);
-	static std::vector&lt;StopLine&gt; GetStopLinesList(TiXmlElement* pElem);
-	static std::vector&lt;Lane&gt; GetLanesList(TiXmlElement* pElem);
-	static std::vector&lt;RoadSegment&gt; GetRoadSegmentsList(TiXmlElement* pElem);
-	static std::vector&lt;int&gt; GetIDsFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::vector&lt;double&gt; GetDoubleFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::pair&lt;ACTION_TYPE, double&gt; GetActionPairFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::vector&lt;WayPoint&gt; GetCenterLaneData(TiXmlElement* pElem, const int&amp; currLaneID);
-	static std::vector&lt;WayPoint&gt; GetCenterLaneDataVer0(TiXmlElement* pElem, const int&amp; currLaneID);
-	static std::vector&lt;GPSPoint&gt; GetPointsData(TiXmlElement* pElem);
-	static std::vector&lt;std::string&gt; SplitString(const std::string&amp; str, const std::string&amp; token);
-
-	static void CreateKmlFromLocalizationPathFile(const std::string&amp; pathFileName,const double&amp; maxLaneDistance, const double&amp; density,const std::vector&lt;TrafficLight&gt;&amp; trafficLights, const std::vector&lt;GPSPoint&gt;&amp; stopLines);
-
-	static int ReplaceMyID(int&amp; id, const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; rep_list);
-
-	static double m_USING_VER_ZERO;
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* MAPPINGHELPERS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\include\MatrixOperations.h" new_path="" added_lines="0" deleted_lines="131">
				<diff>@@ -1,131 +0,0 @@
-/*
- * MatrixOperations.h
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
-
-#ifndef MATRIXOPERATIONS_H_
-#define MATRIXOPERATIONS_H_
-
-#include "RoadNetwork.h"
-#include &lt;math.h&gt;
-
-
-namespace PlannerHNS {
-
-
-class Mat3
-{
-	double m11, m12, m13;
-	double m21, m22, m23;
-	double m31, m32, m33;
-
-	double m[3][3];
-
-public:
-	Mat3()
-	{
-		//initialize Identity by default
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-	}
-
-	Mat3(double angle, POINT2D trans)
-	{
-		//Initialize Rotation Matrix
-		double c = cos(angle);
-		double s = sin(angle);
-		m11 = c;
-		m12 = s;
-		m21 = -s;
-		m22 = c;
-		m31 = trans.x;
-		m32 = trans.y;
-		m13 = m23= 0;
-		m33 = 1;
-	}
-
-	Mat3(double transX, double transY, bool mirrorX, bool mirrorY )
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		m[0][0] = (mirrorX == true ) ? -1 : 1; m[0][1] =  0; m[0][2] =  transX;
-		m[1][0] = 0; m[1][1] =  (mirrorY==true) ? -1 : 1; m[1][2] =  transY;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(double transX, double transY)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		m[0][0] = 1; m[0][1] =  0; m[0][2] =  transX;
-		m[1][0] = 0; m[1][1] =  1; m[1][2] =  transY;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(double rotation_angle)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		double c = cos(rotation_angle);
-		double s = sin(rotation_angle);
-		m[0][0] = c; m[0][1] = -s; m[0][2] =  0;
-		m[1][0] = s; m[1][1] =  c; m[1][2] =  0;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(GPSPoint rotationCenter)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		double c = cos(rotationCenter.a);
-		double s = sin(rotationCenter.a);
-		double u = rotationCenter.x;
-		double v = rotationCenter.y;
-		m[0][0] = c; m[0][1] = -s; m[0][2] = -u*c + v*s + u;
-		m[1][0] = s; m[1][1] =  c; m[1][2] = -u*s - v*c + v;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-
-	GPSPoint operator * (GPSPoint v)
-	{
-		GPSPoint _v = v;
-		v.x = m[0][0]*_v.x + m[0][1]*_v.y + m[0][2]*1;
-		v.y = m[1][0]*_v.x + m[1][1]*_v.y + m[1][2]*1;
-		return v;
-	}
-
-	POINT2D operator * (POINT2D v)
-	{
-		Mat3 m = *this;
-		POINT2D r;
-		r.x = m.m11 * v.x + m.m21 * v.y + m.m31 * 1;
-		r.y = m.m12 * v.x + m.m22 * v.y + m.m32 * 1;
-		return r;
-	}
-
-	Mat3 operator *(Mat3 m2)
-	{
-		Mat3 m1 = *this;
-		Mat3 r;
-		r.m11 = m1.m11 * m2.m11 + m1.m12 * m2.m21 + m1.m13 * m2.m31;
-		r.m12 = m1.m11 * m2.m12 + m1.m12 * m2.m22 + m1.m13 * m2.m32;
-		r.m13 = m1.m11 * m2.m13 + m1.m12 * m2.m23 + m1.m13 * m2.m33;
-
-		r.m21 = m1.m21 * m2.m11 + m1.m22 * m2.m21 + m1.m23 * m2.m31;
-		r.m22 = m1.m21 * m2.m12 + m1.m22 * m2.m22 + m1.m23 * m2.m32;
-		r.m23 = m1.m21 * m2.m13 + m1.m22 * m2.m23 + m1.m23 * m2.m33;
-
-		r.m31 = m1.m31 * m2.m11 + m1.m32 * m2.m21 + m1.m33 * m2.m31;
-		r.m32 = m1.m31 * m2.m12 + m1.m32 * m2.m22 + m1.m33 * m2.m32;
-		r.m33 = m1.m31 * m2.m13 + m1.m32 * m2.m23 + m1.m33 * m2.m33;
-
-		return r;
-	}
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* MATRIXOPERATIONS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\include\PlannerCommonDef.h" new_path="" added_lines="0" deleted_lines="156">
				<diff>@@ -1,156 +0,0 @@
-/*
- * PlannerCommonDef.h
- *
- *  Created on: Dec 14, 2016
- *      Author: hatem
- */
-
-#ifndef PLANNERCOMMONDEF_H_
-#define PLANNERCOMMONDEF_H_
-
-#include &lt;math.h&gt;
-#include &lt;string&gt;
-
-namespace PlannerHNS
-{
-
-enum CAR_TYPE
-{
-  Mv2Car, //!&lt; Mv2Car
-  PHVCar, //!&lt; PHVCar
-  HVCar,  //!&lt; HVCar
-  RoboCar,//!&lt; RoboCar
-  SimulationCar
-};
-
-class PID_CONST
-{
-public:
-	double kP;
-	double kI;
-	double kD;
-
-	PID_CONST()
-	{
-		kP = kI = kD = 0;
-	}
-
-	PID_CONST(const double&amp; p, const double&amp; i, const double&amp; d)
-	{
-		kP = p;
-		kI = i;
-		kD = d;
-	}
-};
-
-class ControllerParams
-{
-public:
-	double SimulationSteeringDelay;
-	double SteeringDelay;
-	double minPursuiteDistance;
-	PID_CONST Steering_Gain;
-	PID_CONST Velocity_Gain;
-	double Acceleration;
-	double Deceleration;
-	double FollowDistance;
-	double LowpassSteerCutoff;
-	double maxAccel;
-	double maxDecel;
-
-
-	ControllerParams()
-	{
-		SimulationSteeringDelay = 0.0;
-		SteeringDelay 		= 0.8;
-		Acceleration		= 0.5;
-		Deceleration		= -0.8;
-		FollowDistance		= 8.0;
-		LowpassSteerCutoff	= 5.0;
-		maxAccel			= 0.9;
-		minPursuiteDistance = 2.0;
-		maxDecel 			= -1.5;
-	}
-};
-
-class CAR_BASIC_INFO
-{
-public:
-  CAR_TYPE model;
-
-  double turning_radius;
-  double wheel_base;
-  double max_speed_forward;
-  double min_speed_forward;
-  double max_speed_backword;
-  double max_steer_value;
-  double min_steer_value;
-  double max_brake_value;
-  double min_brake_value;
-  double max_steer_angle;
-  double min_steer_angle;
-  double length;
-  double width;
-  double max_acceleration;
-  double max_deceleration;
-
-  CAR_BASIC_INFO()
-  {
-	  model 				= SimulationCar;
-	  turning_radius 		= 5.2;
-	  wheel_base			= 2.7;
-	  max_speed_forward		= 3.0;
-	  min_speed_forward		= 0.0;
-	  max_speed_backword	= 1.0;
-	  max_steer_value		= 660;
-	  min_steer_value		= -660;
-	  max_brake_value		= 0;
-	  min_brake_value		= 0;
-	  max_steer_angle		= 0.42;
-	  min_steer_angle		= 0.42;
-	  length				= 4.3;
-	  width					= 1.82;
-	  max_acceleration		= 1.5; // m/s2
-	  max_deceleration		= -1.5; // 1/3 G
-  }
-
-  double CalcMaxSteeringAngle()
-  {
-    return  max_steer_angle;//asin(wheel_base/turning_radius);
-  }
-
-  double BoundSpeed(double s)
-  {
-	if(s &gt; 0 &amp;&amp; s &gt; max_speed_forward)
-		return max_speed_forward;
-	if(s &lt; 0 &amp;&amp; s &lt; max_speed_backword)
-		return max_speed_backword;
-	return s;
-  }
-
-  double BoundSteerAngle(double a)
-  {
-	if(a &gt; max_steer_angle)
-		return max_steer_angle;
-	if(a &lt; min_steer_angle)
-		return min_steer_angle;
-
-	return a;
-  }
-
-  double BoundSteerValue(double v)
-  {
-	  if(v &gt;= max_steer_value)
-		return max_steer_value;
-	if(v &lt;= min_steer_value)
-		return min_steer_value;
-
-	return v;
-  }
-
-};
-
-
-} /* namespace PlannerHNS */
-
-#endif /* PLANNERCOMMONDEF_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\include\PlannerH.h" new_path="" added_lines="0" deleted_lines="119">
				<diff>@@ -1,119 +0,0 @@
-/*
- * PlannerH.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#include "RSPlanner.h"
-#include "GridMap.h"
-
-#define START_POINT_MAX_DISTANCE 8 // meters
-#define GOAL_POINT_MAX_DISTANCE 8 // meters
-#define LANE_CHANGE_SMOOTH_FACTOR_DISTANCE 8 // meters
-
-namespace PlannerHNS
-{
-
-enum PLANDIRECTION {MOVE_FORWARD_ONLY, MOVE_BACKWARD_ONLY, 	MOVE_FREE};
-enum HeuristicConstrains {EUCLIDEAN, NEIGBORHOOD,DIRECTION };
-
-class PlannerH
-{
-public:
-	PlannerH();
-	virtual ~PlannerH(); 
-
-
-	/**
-	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles
-	 * @param start: Start position for the trajectory (x,y,theta)
-	 * @param goal:  Goal position (Destination point) (x,y,theta)
-	 * @param map:  2d grid map, ( cost map or occupancy grid.
-	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
-	 * @return path length
-	 */
-	double PlanUsingReedSheppWithObstacleDetection(const WayPoint&amp; start, const WayPoint&amp; goal, GridMap&amp; map, std::vector&lt;WayPoint&gt;&amp; genSmoothedPath,
-			const double pathDensity = 0.25, const double smoothFactor = 12.0);
-
-	/**
-	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles , but if there an obstacle on the trajectory function will fail. , also this function does not guaranteed to generate trajectories
-	 * @param start: Start position for the trajectory (x,y,theta)
-	 * @param goal:  Goal position (Destination point) (x,y,theta)
-	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
-	 * @return path length
-	 */
-	double PlanUsingReedShepp(const WayPoint&amp; start, const WayPoint&amp; goal, std::vector&lt;WayPoint&gt;&amp; generatedPath,
-			const double pathDensity = 0.25, const double smoothFactor = 12.0);
-
-
-	/**
-	 * @brief Generate Roll outs for global generated path
-	 * @param referencePath center lint reference path
-	 * @param carPos current car position
-	 * @param bEnableLaneChange is lane change is available
-	 * @param speed current car speed
-	 * @param microPlanDistance distance limit for roll outs
-	 * @param maxSpeed maximum forward speed
-	 * @param minSpeed minimum forward speed
-	 * @param carTipMargin 1st roll out smoothing parameter
-	 * @param rollInMargin 2nd roll out smoothing parameter
-	 * @param rollInSpeedFactor roll out 3rd smoothing parameter
-	 * @param pathDensity distance between every two waypoints in the generated trajectory
-	 * @param rollOutDensity distance between the center line and adjacent trajectories
-	 * @param rollOutNumber number of sampled trajectories
-	 * @param SmoothDataWeight general smoothing parameter , how smoother keep close to original data 0 - 0.5
-	 * @param SmoothWeight general smoothing parameter, how smoother is trying to pull away to form the shortest and strait line possible
-	 * @param SmoothTolerance performance measure , conjugate gradient conversion factor should be 0.1 - 0.01
-	 * @param speedProfileFactor how car should slow for corners
-	 * @param bHeadingSmooth follow car heading direction or center line path heading for sampling direction
-	 */
-	void GenerateRunoffTrajectory(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; referencePaths, const WayPoint&amp; carPos, const bool&amp; bEnableLaneChange, const double&amp; speed, const double&amp; microPlanDistance,
-				const double&amp; maxSpeed,const double&amp; minSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
-				const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
-				const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
-				const double&amp; SmoothTolerance, const double&amp; speedProfileFactor, const bool&amp; bHeadingSmooth,
-				const int&amp; iCurrGlobalPath, const int&amp; iCurrLocalTraj,
-				std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOutsPaths,
-				std::vector&lt;WayPoint&gt;&amp; sectionPath, std::vector&lt;WayPoint&gt;&amp; sampledPoints);
-
-	/**
-	 * @brief Path planning for structured environment using dynamic programming
-	 * @param lane
-	 * @param carPos
-	 * @param goalPos
-	 * @param prevWayPoint
-	 * @param maxPlanningDistance
-	 * @param globalPath
-	 * @param path
-	 * @return generated path length
-	 */
-	double PlanUsingDP(const WayPoint&amp; carPos,const WayPoint&amp; goalPos,
-			const double&amp; maxPlanningDistance, const bool bEnableLaneChange, const std::vector&lt;int&gt;&amp; globalPath,
-			RoadNetwork&amp; map, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, std::vector&lt;WayPoint*&gt;* all_cell_to_delete = 0);
-
-	 double PlanUsingDPRandom(const WayPoint&amp; start,
-	 		 const double&amp; maxPlanningDistance,
-	 		 RoadNetwork&amp; map,
-	 		 std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-
-	/**
-	 * @brief Return all possible trajectories from current position to max planning distance in all directions
-	 * @param lane
-	 * @param carPos
-	 * @param maxPlanningDistance
-	 * @param paths
-	 * @return
-	 */
-	double PredictPlanUsingDP(Lane* lane, const WayPoint&amp; carPos, const double&amp; maxPlanningDistance,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-	void DeleteWaypoints(std::vector&lt;WayPoint*&gt;&amp; wps);
-
-	//PlanningInternalParams m_Params;
-};
-
-}
-
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\include\PlanningHelpers.h" new_path="" added_lines="0" deleted_lines="170">
				<diff>@@ -1,170 +0,0 @@
-/*
- * PlanningHelpers.h
- *
- *  Created on: Jun 16, 2016
- *      Author: hatem
- */
-
-#ifndef PLANNINGHELPERS_H_
-#define PLANNINGHELPERS_H_
-
-#include &lt;math.h&gt;
-#include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "DataRW.h"
-#include "tinyxml.h"
-
-
-namespace PlannerHNS {
-
-#define distance2points(from , to) sqrt(pow(to.x - from.x, 2) + pow(to.y - from.y, 2))
-#define distance2pointsSqr(from , to) pow(to.x - from.x, 2) + pow(to.y - from.y, 2)
-#define pointNorm(v) sqrt(v.x*v.x + v.y*v.y)
-#define angle2points(from , to) atan2(to.y - from.y, to.x - from.x )
-#define LANE_CHANGE_SPEED_FACTOR 0.5
-#define LANE_CHANGE_COST 3.0 // meters
-#define BACKUP_STRAIGHT_PLAN_DISTANCE 60 //meters
-
-class PlanningHelpers {
-public:
-	PlanningHelpers();
-	virtual ~PlanningHelpers();
-
-	/**
-	 * @brief Find all relative information from the point p to the trajectory such as (perpendicular distance , closest next point , closest back point, distance from perpendicular intersection point to next point, distance from perpendicular intersection point to previous point)
-	 * @param trajectory list of waypoints
-	 * @param p query point
-	 * @param info collection of calculated information
-	 * @param prevIndex initial search index
-	 * @return true if success without errors, false otherwise
-	 */
-	static bool GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex = 0);
-
-	static bool GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectories, const WayPoint&amp; p, const double&amp; searchDistance, RelativeInfo&amp; info);
-
-	/**
-	 * @brief Find point on the trajectory after initial relative point with specific distance
-	 * @param trajectory list of waypoints
-	 * @param init_p initial relative point on trajectory
-	 * @param distance distance from initial relative point to follow point
-	 * @return point on trajectory
-	 */
-	static WayPoint GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; init_p, const double&amp; distance, unsigned int&amp; point_index);
-
-	/**
-	 * @brief Calculate the precise distance from projection of point p2 (relative) to projection of point 1 (relative)
-	 * @param trajectory list of waypoints
-	 * @param p1 first relative point
-	 * @param p2 second relative point
-	 * @return distance on trajectory
-	 */
-	static double GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; p1,const RelativeInfo&amp; p2);
-
-	/**
-	 * @brief Find the closest next point on the trajectory index
-	 * @param trajectory list of waypoints
-	 * @param p query point
-	 * @param prevIndex initial search index
-	 * @return index of the closest next point from trajectory
-	 */
-	static int GetClosestNextPointIndex(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-
-	static int GetClosestNextPointIndexDirection(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-
-
-	static int GetClosestPointIndex_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex = 0 );
-	static WayPoint GetPerpendicularOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, double&amp; distance, const int&amp; prevIndex = 0);
-	static double GetPerpDistanceToTrajectorySimple_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-	static double GetPerpDistanceToVectorSimple_obsolete(const WayPoint&amp; p1, const WayPoint&amp; p2, const WayPoint&amp; pose);
-	static WayPoint GetNextPointOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const double&amp; distance, const int&amp; currIndex = 0);
-	static double GetDistanceOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
-
-
-	static void FixPathDensity(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; distanceDensity);
-	static void SmoothPath(std::vector&lt;WayPoint&gt;&amp; path, double weight_data =0.25,double weight_smooth = 0.25,double tolerance = 0.01);
-	static double CalcCircle(const GPSPoint&amp; pt1, const GPSPoint&amp; pt2, const GPSPoint&amp; pt3, GPSPoint&amp; center);
-	static double CalcAngleAndCost(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0, const bool&amp; bSmooth = true );
-	//static double CalcAngleAndCostSimple(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0);
-	static double CalcAngleAndCostAndCurvatureAnd2D(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0);
-
-	static double GetAccurateDistanceOnTrajectory(std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
-
-	static void ExtractPartFromPointToDistance(const std::vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
-			const double&amp; pathDensity, std::vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance);
-
-	static void CalculateRollInTrajectories(const WayPoint&amp; carPos, const double&amp; speed, const std::vector&lt;WayPoint&gt;&amp; originalCenter, int&amp; start_index,
-			int&amp; end_index, std::vector&lt;double&gt;&amp; end_laterals ,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; rollInPaths, const double&amp; max_roll_distance,
-			const double&amp; maxSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
-			const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
-			const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
-			const double&amp; SmoothTolerance, const bool&amp; bHeadingSmooth,
-			std::vector&lt;WayPoint&gt;&amp; sampledPoints);
-
-
-	static void SmoothSpeedProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
-	static void SmoothCurvatureProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance = 0.1);
-	static void SmoothWayPointsDirections(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
-
-	static void GenerateRecommendedSpeed(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor);
-//	static WayPoint* BuildPlanningSearchTree(Lane* l, const WayPoint&amp; prevWayPointIndex,
-//			const WayPoint&amp; startPos, const WayPoint&amp; goalPos,
-//			const std::vector&lt;int&gt;&amp; globalPath, const double&amp; DistanceLimit,
-//			int&amp; nMaxLeftBranches, int&amp; nMaxRightBranches,
-//			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static WayPoint* BuildPlanningSearchTreeV2(WayPoint* pStart,
-			const WayPoint&amp; goalPos,
-			const std::vector&lt;int&gt;&amp; globalPath, const double&amp; DistanceLimit,
-			const bool&amp; bEnableLaneChange,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static WayPoint* BuildPlanningSearchTreeStraight(WayPoint* pStart,
-			const double&amp; DistanceLimit,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static int PredictiveDP(WayPoint* pStart, const double&amp; DistanceLimit,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete, std::vector&lt;WayPoint*&gt;&amp; end_waypoints);
-
-	static bool CheckLaneIdExits(const std::vector&lt;int&gt;&amp; lanes, const Lane* pL);
-	static WayPoint* CheckLaneExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const Lane* pL);
-	static WayPoint* CheckNodeExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const WayPoint* pL);
-
-	static WayPoint* CreateLaneHeadCell(Lane* pLane, WayPoint* pLeft, WayPoint* pRight,
-			WayPoint* pBack);
-	static double GetLanePoints(Lane* l, const WayPoint&amp; prevWayPointIndex,
-			const double&amp; minDistance , const double&amp; prevCost, std::vector&lt;WayPoint&gt;&amp; points);
-
-	static WayPoint* GetMinCostCell(const std::vector&lt;WayPoint*&gt;&amp; cells, const std::vector&lt;int&gt;&amp; globalPathIds);
-
-	static void TraversePathTreeBackwards(WayPoint* pHead, WayPoint* pStartWP, const std::vector&lt;int&gt;&amp; globalPathIds,
-			std::vector&lt;WayPoint&gt;&amp; localPath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; localPaths);
-
-	static void ExtractPlanAlernatives(const std::vector&lt;WayPoint&gt;&amp; singlePath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; allPaths);
-
-	static std::vector&lt;int&gt; GetUniqueLeftRightIds(const std::vector&lt;WayPoint&gt;&amp; path);
-
-	static bool FindInList(const std::vector&lt;int&gt;&amp; list,const int&amp; x);
-	static void RemoveWithValue(std::vector&lt;int&gt;&amp; list,const int&amp; x);
-
-	static ACTION_TYPE GetBranchingDirection(WayPoint&amp; currWP, WayPoint&amp; nextWP);
-
-	static void CalcContourPointsForDetectedObjects(const WayPoint&amp; currPose, std::vector&lt;DetectedObject&gt;&amp; obj_list, const double&amp; filterDistance = 100);
-
-	static double GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; pose, const double&amp; distance);
-	static bool CompareTrajectories(const std::vector&lt;WayPoint&gt;&amp; path1, const std::vector&lt;WayPoint&gt;&amp; path2);
-
-	static double GetDistanceToClosestStopLineAndCheck(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; p, int&amp; stopLineID,int&amp; stopSignID, int&amp; trafficLightID, const int&amp; prevIndex = 0);
-
-	static void WritePathToFile(const std::string&amp; fileName, const std::vector&lt;WayPoint&gt;&amp; path);
-
-	static void TestQuadraticSpline(const std::vector&lt;WayPoint&gt;&amp; center_line, std::vector&lt;WayPoint&gt;&amp; path);
-	static double frunge ( double x );
-	static double fprunge ( double x );
-	static double fpprunge ( double x );
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* PLANNINGHELPERS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\include\RSPlanner.h" new_path="" added_lines="0" deleted_lines="77">
				<diff>@@ -1,77 +0,0 @@
-/*
- * RSPlanner.h
- *
- *  Created on: Aug 9, 2015
- *      Author: hatem
- */
-
-#include "PlanningHelpers.h"
-#ifndef RSPLANNERSA_H_
-#define RSPLANNERSA_H_
-
-namespace PlannerHNS
-{
-
-#define EPS1 1.0e-12
-#define EPS2 1.0e-12
-#define EPS3 1.0e-12
-#define EPS4 1.0e-12
-#define MYINFINITY 1000000
-
-#define MPI 3.1415926536
-#define MPIMUL2 6.2831853072
-#define MPIDIV2 1.5707963268
-
-
-
-
-class RSPlanner
-{
-public:
-	double RADCURV ;
-	double RADCURVMUL2 ;
-	double RADCURVMUL4 ;
-	double SQRADCURV ;
-	double SQRADCURVMUL2 ;
-	double PATHDENSITY;
-	RSPlanner(double curvatureFactor = 15.6);
-	virtual ~RSPlanner();
-
-	double min_length_rs(const double&amp; x1,const double&amp; y1,const double&amp; t1,const double&amp; x2,const double&amp; y2,const double&amp; t2,int&amp; numero,double&amp; t,double&amp; u,double&amp; v);
-	int constRS(int num,double t,double u,double v,double x1,double y1,double t1,double delta,std::vector&lt;WayPoint&gt;&amp; path);
-
-private:
-	struct ConfigItem
-	{
-		double length;
-		int num;
-		double t,u,v;
-	};
-
-
-	double mod2pi(const double&amp; a);
-	double my_atan2(const double&amp;  y, const double&amp; x);
-	double c_c_c(const double&amp; x,const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_cc(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double cscb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double ccu_cuc(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_cucu_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2sca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2scb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2sc2_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double cc_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csc2_ca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csc2_cb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-
-	double reed_shepp(const double&amp; x1,const double&amp; y1,const double&amp; t1,const double&amp; x2,const double&amp; y2,const double&amp; t2,int&amp; numero,double&amp; tr,double&amp; ur,double&amp; vr);
-
-	int fct_curve(const int&amp; ty,const int&amp; orientation,const double&amp; val,double&amp; x1,double&amp; y1,double&amp; t1,const double&amp; delta,std::vector&lt;WayPoint&gt;&amp; path,int n);
-
-
-
-};
-
-} /* namespace PlannerZNS */
-
-#endif /* RSPLANNER_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\include\RoadNetwork.h" new_path="" added_lines="0" deleted_lines="1018">
				<diff>@@ -1,1018 +0,0 @@
-/*
- * RoadNetwork.h
- *
- *  Created on: May 19, 2016
- *      Author: hatem
- */
-
-#ifndef ROADNETWORK_H_
-#define ROADNETWORK_H_
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;sstream&gt;
-#include "UtilityH.h"
-
-#define OPENPLANNER_ENABLE_LOGS
-
-namespace PlannerHNS
-{
-
-
-enum DIRECTION_TYPE {	FORWARD_DIR, FORWARD_LEFT_DIR, FORWARD_RIGHT_DIR,
-	BACKWARD_DIR, BACKWARD_LEFT_DIR, BACKWARD_RIGHT_DIR, STANDSTILL_DIR};
-
-enum OBSTACLE_TYPE {SIDEWALK, TREE, CAR, TRUCK, HOUSE, PEDESTRIAN, CYCLIST, GENERAL_OBSTACLE};
-
-enum DRIVABLE_TYPE {DIRT, TARMAC, PARKINGAREA, INDOOR, GENERAL_AREA};
-
-enum GLOBAL_STATE_TYPE {G_WAITING_STATE, G_PLANING_STATE, G_FORWARD_STATE, G_BRANCHING_STATE, G_FINISH_STATE};
-
-enum STATE_TYPE {INITIAL_STATE, WAITING_STATE, FORWARD_STATE, STOPPING_STATE, EMERGENCY_STATE,
-	TRAFFIC_LIGHT_STOP_STATE,TRAFFIC_LIGHT_WAIT_STATE, STOP_SIGN_STOP_STATE, STOP_SIGN_WAIT_STATE, FOLLOW_STATE, LANE_CHANGE_STATE, OBSTACLE_AVOIDANCE_STATE, GOAL_STATE, FINISH_STATE};
-
-enum LIGHT_INDICATOR {INDICATOR_LEFT, INDICATOR_RIGHT, INDICATOR_BOTH , INDICATOR_NONE};
-
-enum SHIFT_POS {SHIFT_POS_PP = 0x60, SHIFT_POS_RR = 0x40, SHIFT_POS_NN = 0x20,
-	SHIFT_POS_DD = 0x10, SHIFT_POS_BB = 0xA0, SHIFT_POS_SS = 0x0f, SHIFT_POS_UU = 0xff };
-
-enum ACTION_TYPE {FORWARD_ACTION, BACKWARD_ACTION, STOP_ACTION, LEFT_TURN_ACTION,
-	RIGHT_TURN_ACTION, U_TURN_ACTION, SWERVE_ACTION, OVERTACK_ACTION};
-
-
-class Lane;
-class TrafficLight;
-
-class ObjTimeStamp
-{
-public:
-	timespec tStamp;
-
-	ObjTimeStamp()
-	{
-		tStamp.tv_nsec = 0;
-		tStamp.tv_sec = 0;
-	}
-};
-
-class POINT2D
-{
-public:
-    double x;
-    double y;
-    double z;
-    POINT2D()
-    {
-      x=0;y=0;z=0;
-    }
-    POINT2D(double px, double py, double pz = 0)
-    {
-      x = px;
-      y = py;
-      z = pz;
-    }
-};
-
-
-
-class RECTANGLE
-
-{
-public:
-  POINT2D bottom_left;
-  POINT2D top_right;
-  double width;
-  double length;
-  bool bObstacle;
-
-
-  inline bool PointInRect(POINT2D p)
-  {
-    return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
-  }
-
-  inline bool HitTest(POINT2D p)
-  {
-    return PointInRect(p) &amp;&amp; bObstacle;
-  }
-
-  RECTANGLE()
-  {
-	  width=0;
-	  length = 0;
-    bObstacle = true;
-  }
-
-  virtual ~RECTANGLE(){}
-};
-
-class GPSPoint
-{
-public:
-	double lat, x;
-	double lon, y;
-	double alt, z;
-	double dir, a;
-
-	GPSPoint()
-	{
-		lat = x = 0;
-		lon = y = 0;
-		alt = z = 0;
-		dir = a = 0;
-	}
-
-	GPSPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
-	{
-		this-&gt;x = x;
-		this-&gt;y = y;
-		this-&gt;z = z;
-		this-&gt;a = a;
-
-		lat = 0;
-		lon = 0;
-		alt = 0;
-		dir = 0;
-	}
-
-	std::string ToString()
-	{
-		std::stringstream str;
-		str.precision(12);
-		str &lt;&lt; "X:" &lt;&lt; x &lt;&lt; ", Y:" &lt;&lt; y &lt;&lt; ", Z:" &lt;&lt; z &lt;&lt; ", A:" &lt;&lt; a &lt;&lt; std::endl;
-		str &lt;&lt; "Lon:" &lt;&lt; lon &lt;&lt; ", Lat:" &lt;&lt; lat &lt;&lt; ", Alt:" &lt;&lt; alt &lt;&lt; ", Dir:" &lt;&lt; dir &lt;&lt; std::endl;
-		return str.str();
-	}
-};
-
-class PolygonShape
-{
-public:
-	std::vector&lt;GPSPoint&gt; points;
-
-	inline int PointInsidePolygon(const PolygonShape&amp; polygon,const GPSPoint&amp; p)
-	{
-		int counter = 0;
-		  int i;
-		  double xinters;
-		  GPSPoint p1,p2;
-		  int N = polygon.points.size();
-		  if(N &lt;=0 ) return -1;
-
-		  p1 = polygon.points.at(0);
-		  for (i=1;i&lt;=N;i++)
-		  {
-		    p2 = polygon.points.at(i % N);
-
-		    if (p.y &gt; MIN(p1.y,p2.y))
-		    {
-		      if (p.y &lt;= MAX(p1.y,p2.y))
-		      {
-		        if (p.x &lt;= MAX(p1.x,p2.x))
-		        {
-		          if (p1.y != p2.y)
-		          {
-		            xinters = (p.y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
-		            if (p1.x == p2.x || p.x &lt;= xinters)
-		              counter++;
-		          }
-		        }
-		      }
-		    }
-		    p1 = p2;
-		  }
-
-		  if (counter % 2 == 0)
-		    return 0;
-		  else
-		    return 1;
-	}
-};
-
-class MapItem
-{
-public:
-  int id;
-  POINT2D sp; //start point
-  POINT2D ep; // end point
-  GPSPoint center;
-  double c; //curvature
-  double w; //width
-  double l; //length
-  std::string fileName; //
-  std::vector&lt;POINT2D&gt; polygon;
-
-
-  MapItem(int ID, POINT2D start, POINT2D end, double curvature, double width, double length, std::string objName)
-  {
-    id = ID;
-    sp = start;
-    ep = end;
-    c = curvature;
-    w = width;
-    l = length;
-    fileName = objName;
-
-  }
-
-  MapItem()
-  {
-    id = 0; c = 0; w = 0; l = 0;
-  }
-
-  virtual ~MapItem(){}
-
-  MapItem(const MapItem &amp; cmi)
-  {
-        id = cmi.id;
-        sp = cmi.sp;
-        ep = cmi.ep;
-        c = cmi.c;
-        w = cmi.w;
-        l = cmi.l;
-        fileName = cmi.fileName;
-  }
-  MapItem &amp;operator=(const MapItem &amp;cmi)
-  {
-    this-&gt;id = cmi.id;
-      this-&gt;sp = cmi.sp;
-      this-&gt;ep = cmi.ep;
-      this-&gt;c = cmi.c;
-      this-&gt;w = cmi.w;
-      this-&gt;l = cmi.l;
-      this-&gt;fileName = cmi.fileName;
-      return *this;
-  }
-
-  virtual int operator==(const MapItem &amp;mi) const
-    {
-      return this-&gt;id == mi.id;
-    }
-};
-
-class Obstacle : public MapItem
-{
-  public:
-    OBSTACLE_TYPE t;
-
-    Obstacle(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,OBSTACLE_TYPE type, std::string fileName ) : MapItem(ID, start, end, curvature, width, length, fileName)
-  {
-      t = type;
-  }
-    virtual ~Obstacle()
-    {
-    }
-
-    Obstacle() : MapItem()
-       {
-      t = SIDEWALK;
-       }
-
-    Obstacle(const Obstacle&amp; ob) : MapItem(ob)
-      {
-        t = ob.t;
-      }
-
-    Obstacle&amp; operator=(const Obstacle&amp; ob)
-      {
-      this-&gt;id = ob.id;
-      this-&gt;sp = ob.sp;
-      this-&gt;ep = ob.ep;
-      this-&gt;c = ob.c;
-      this-&gt;w = ob.w;
-      this-&gt;l = ob.l;
-      this-&gt;t = ob.t;
-      this-&gt;fileName = ob.fileName;
-      return *this;
-      }
-
-      virtual int operator==(const Obstacle &amp;ob) const
-          {
-            return this-&gt;id == ob.id &amp;&amp; this-&gt;t == ob.t;
-          }
-};
-
-class DrivableArea : public MapItem
-{
-public:
-  DRIVABLE_TYPE t; // drivable area type
-
-  DrivableArea(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,DRIVABLE_TYPE type, std::string fileName ) : MapItem( ID, start, end, curvature, width, length, fileName)
-  {
-    t = type;
-  }
-
-  virtual ~DrivableArea()
-  {
-
-  }
-
-  DrivableArea() : MapItem()
-    {
-      t = PARKINGAREA;
-    }
-
-  DrivableArea(const DrivableArea&amp; da) : MapItem(da)
-  {
-    t = da.t;
-  }
-
-  DrivableArea&amp; operator=(const DrivableArea&amp; da)
-  {
-    this-&gt;id = da.id;
-    this-&gt;sp = da.sp;
-    this-&gt;ep = da.ep;
-    this-&gt;c = da.c;
-    this-&gt;w = da.w;
-    this-&gt;l = da.l;
-    this-&gt;t = da.t;
-    this-&gt;fileName = da.fileName;
-    return *this;
-  }
-
-  virtual int operator==(const DrivableArea &amp;da) const
-      {
-        return this-&gt;id == da.id &amp;&amp; this-&gt;t == da.t;
-      }
-
-};
-
-
-
-class Rotation
-{
-public:
-	double x;
-	double y;
-	double z;
-	double w;
-
-	Rotation()
-	{
-		x = 0;
-		y = 0;
-		z = 0;
-		w = 0;
-	}
-};
-
-class WayPoint
-{
-public:
-	GPSPoint	pos;
-	Rotation 	rot;
-	double  	v;
-	double  	cost;
-	double  	timeCost;
-	double  	totalReward;
-	double  	collisionCost;
-	double 		laneChangeCost;
-	int 		laneId;
-	int 		id;
-	int 		LeftLaneId;
-	int 		RightLaneId;
-	int 		stopLineID;
-	DIRECTION_TYPE bDir;
-
-	Lane* pLane;
-	WayPoint* pLeft;
-	WayPoint* pRight;
-	std::vector&lt;int&gt; 	toIds;
-	std::vector&lt;int&gt; 	fromIds;
-	std::vector&lt;WayPoint*&gt; pFronts;
-	std::vector&lt;WayPoint*&gt; pBacks;
-	std::vector&lt;std::pair&lt;ACTION_TYPE, double&gt; &gt; actionCost;
-
-	WayPoint()
-	{
-		id = 0;
-		v = 0;
-		cost = 0;
-		laneId = -1;
-		pLane  = 0;
-		pLeft = 0;
-		pRight = 0;
-		bDir = FORWARD_DIR;
-		LeftLaneId = 0;
-		RightLaneId = 0;
-		timeCost = 0;
-		totalReward = 0;
-		collisionCost = 0;
-		laneChangeCost = 0;
-		stopLineID = -1;
-	}
-
-	WayPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
-	{
-		pos.x = x;
-		pos.y = y;
-		pos.z = z;
-		pos.a = a;
-
-		id = 0;
-		v = 0;
-		cost = 0;
-		laneId = -1;
-		pLane  = 0;
-		pLeft = 0;
-		pRight = 0;
-		bDir = FORWARD_DIR;
-		LeftLaneId = 0;
-		RightLaneId = 0;
-		timeCost = 0;
-		totalReward = 0;
-		collisionCost = 0;
-		laneChangeCost = 0;
-		stopLineID = -1;
-	}
-};
-
-class RelativeInfo
-{
-public:
-	double perp_distance;
-	double to_front_distance; //negative
-	double from_back_distance;
-	int iFront;
-	int iBack;
-	int iGlobalPath;
-	WayPoint perp_point;
-	double angle_diff; // degrees
-
-	RelativeInfo()
-	{
-		perp_distance = 0;
-		to_front_distance = 0;
-		from_back_distance = 0;
-		iFront = 0;
-		iBack = 0;
-		iGlobalPath = 0;
-		angle_diff = 0;
-	}
-};
-
-class StopLine
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-	int trafficLightID;
-	int stopSignID;
-	std::vector&lt;GPSPoint&gt; points;
-	Lane* pLane;
-
-	StopLine()
-	{
-		id    = 0;
-		laneId =0;
-		roadId =0;
-		pLane = 0;
-		trafficLightID = -1;
-		stopSignID = -1;
-	}
-};
-
-class WaitingLine
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-	std::vector&lt;GPSPoint&gt; points;
-	Lane* pLane;
-
-	WaitingLine()
-	{
-		id    = 0;
-		laneId =0;
-		roadId =0;
-		pLane = 0;
-	}
-};
-
-enum TrafficSignTypes {UNKNOWN_SIGN, STOP_SIGN, MAX_SPEED_SIGN, MIN_SPEED_SIGN};
-
-class TrafficSign
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-
-	GPSPoint pos;
-	TrafficSignTypes signType;
-	double value;
-	double fromValue;
-	double toValue;
-	std::string strValue;
-	timespec timeValue;
-	timespec fromTimeValue;
-	timespec toTimeValue;
-
-	Lane* pLane;
-
-	TrafficSign()
-	{
-		id    		= 0;
-		laneId 		= 0;
-		roadId		= 0;
-		signType  	= UNKNOWN_SIGN;
-		value		= 0;
-		fromValue	= 0;
-		toValue		= 0;
-//		timeValue	= 0;
-//		fromTimeValue = 0;
-//		toTimeValue	= 0;
-		pLane 		= 0;
-	}
-};
-
-enum TrafficLightState {UNKNOWN_LIGHT, RED_LIGHT, GREEN_LIGHT, YELLOW_LIGHT, LEFT_GREEN, FORWARD_GREEN, RIGHT_GREEN, FLASH_YELLOW, FLAH_RED};
-
-class TrafficLight
-{
-public:
-	int id;
-	GPSPoint pos;
-	TrafficLightState lightState;
-	double stoppingDistance;
-	std::vector&lt;int&gt; laneIds;
-	std::vector&lt;Lane*&gt; pLanes;
-
-	TrafficLight()
-	{
-		stoppingDistance = 2;
-		id 			= 0;
-		lightState	= GREEN_LIGHT;
-	}
-
-	bool CheckLane(const int&amp; laneId)
-	{
-		for(unsigned int i=0; i &lt; laneIds.size(); i++)
-		{
-			if(laneId == laneIds.at(i))
-				return true;
-		}
-		return false;
-	}
-};
-
-enum RoadSegmentType {NORMAL_ROAD, INTERSECTION_ROAD, UTURN_ROAD, EXIT_ROAD, MERGE_ROAD, HIGHWAY_ROAD};
-
-class RoadSegment
-{
-public:
-	int id;
-	RoadSegmentType roadType;
-	std::vector&lt;int&gt; fromIds;
-	std::vector&lt;int&gt; toIds;
-	std::vector&lt;Lane&gt; Lanes;
-
-
-	std::vector&lt;RoadSegment*&gt; fromLanes;
-	std::vector&lt;RoadSegment*&gt; toLanes;
-
-	RoadSegment()
-	{
-		id = 0;
-		roadType = NORMAL_ROAD;
-	}
-
-
-};
-
-enum LaneType{NORMAL_LANE, MERGE_LANE, EXIT_LANE, BUS_LANE, BUS_STOP_LANE, EMERGENCY_LANE};
-
-class Lane
-{
-public:
-	int id;
-	int roadId;
-	int areaId;
-	int fromAreaId;
-	int toAreaId;
-	std::vector&lt;int&gt; fromIds;
-	std::vector&lt;int&gt; toIds;
-	int num; //lane number in the road segment from left to right
-	double speed;
-	double length;
-	double dir;
-	LaneType type;
-	std::vector&lt;TrafficSign&gt; signs;
-	std::vector&lt;WayPoint&gt; points;
-	std::vector&lt;TrafficLight&gt; trafficlights;
-	std::vector&lt;StopLine&gt; stopLines;
-	WaitingLine waitingLine;
-
-	std::vector&lt;Lane*&gt; fromLanes;
-	std::vector&lt;Lane*&gt; toLanes;
-	Lane* pLeftLane;
-	Lane* pRightLane;
-
-	RoadSegment * pRoad;
-
-	Lane()
-	{
-		id 		= 0;
-		num		= 0;
-		speed 	= 0;
-		length 	= 0;
-		dir		= 0;
-		type 	= NORMAL_LANE;
-		pLeftLane = 0;
-		pRightLane = 0;
-		pRoad	= 0;
-		roadId = 0;
-		areaId = 0;
-		fromAreaId = 0;
-		toAreaId = 0;
-	}
-
-};
-
-class RoadNetwork
-{
-public:
-	std::vector&lt;RoadSegment&gt; roadSegments;
-	std::vector&lt;TrafficLight&gt; trafficLights;
-	std::vector&lt;StopLine&gt; stopLines;
-
-};
-
-class VehicleState : public ObjTimeStamp
-{
-public:
-	double speed;
-	double steer;
-	SHIFT_POS shift;
-
-	VehicleState()
-	{
-		speed = 0;
-		steer = 0;
-		shift = SHIFT_POS_NN;
-	}
-
-};
-
-class BehaviorState
-{
-public:
-	STATE_TYPE state;
-	double maxVelocity;
-	double minVelocity;
-	double stopDistance;
-	double followVelocity;
-	double followDistance;
-	LIGHT_INDICATOR indicator;
-	bool bNewPlan;
-
-
-	BehaviorState()
-	{
-		state = INITIAL_STATE;
-		maxVelocity = 0;
-		minVelocity = 0;
-		stopDistance = 0;
-		followVelocity = 0;
-		followDistance = 0;
-		indicator  = INDICATOR_NONE;
-		bNewPlan = false;
-
-	}
-
-};
-
-class DetectedObject
-{
-public:
-	int id;
-	OBSTACLE_TYPE t;
-	WayPoint center;
-	WayPoint predicted_center;
-	std::vector&lt;GPSPoint&gt; contour;
-	double w;
-	double l;
-	double h;
-	double distance_to_center;
-	DetectedObject()
-	{
-		id = 0;
-		w = 0;
-		l = 0;
-		h = 0;
-		t = GENERAL_OBSTACLE;
-		distance_to_center = 0;
-	}
-
-};
-
-class PlanningParams
-{
-public:
-	double 	maxSpeed;
-	double 	minSpeed;
-	double 	planningDistance;
-	double 	microPlanDistance;
-	double 	carTipMargin;
-	double 	rollInMargin;
-	double 	rollInSpeedFactor;
-	double 	pathDensity;
-	double 	rollOutDensity;
-	int 	rollOutNumber;
-	double 	horizonDistance;
-	double 	minFollowingDistance; //should be bigger than Distance to follow
-	double 	minDistanceToAvoid; // should be smaller than minFollowingDistance and larger than maxDistanceToAvoid
-	double	maxDistanceToAvoid; // should be smaller than minDistanceToAvoid
-	double 	speedProfileFactor;
-	double 	smoothingDataWeight;
-	double 	smoothingSmoothWeight;
-	double 	smoothingToleranceError;
-
-	double verticalSafetyDistance;
-	double horizontalSafetyDistancel;
-
-	bool 	enableLaneChange;
-	bool 	enableSwerving;
-	bool 	enableFollowing;
-	bool 	enableHeadingSmoothing;
-	bool 	enableTrafficLightBehavior;
-	bool 	enableStopSignBehavior;
-
-	bool 	enabTrajectoryVelocities;
-
-	PlanningParams()
-	{
-		maxSpeed 						= 3;
-		minSpeed 						= 0;
-		planningDistance 				= 10000;
-		microPlanDistance 				= 30;
-		carTipMargin					= 4.0;
-		rollInMargin					= 12.0;
-		rollInSpeedFactor				= 0.25;
-		pathDensity						= 0.25;
-		rollOutDensity					= 0.5;
-		rollOutNumber					= 4;
-		horizonDistance					= 120;
-		minFollowingDistance			= 35;
-		minDistanceToAvoid				= 15;
-		maxDistanceToAvoid				= 5;
-		speedProfileFactor				= 1.0;
-		smoothingDataWeight				= 0.45;
-		smoothingSmoothWeight			= 0.3;
-		smoothingToleranceError			= 0.05;
-
-		verticalSafetyDistance 			= 0.0;
-		horizontalSafetyDistancel		= 0.0;
-
-		enableHeadingSmoothing			= false;
-		enableSwerving 					= false;
-		enableFollowing					= false;
-		enableTrafficLightBehavior		= false;
-		enableLaneChange 				= false;
-		enableStopSignBehavior			= false;
-		enabTrajectoryVelocities		= false;
-	}
-};
-
-class HMIPreCalculatedConditions
-{
-public:
-
-	HMIPreCalculatedConditions()
-	{
-
-	}
-};
-
-class PreCalculatedConditions
-{
-public:
-	//-------------------------------------------//
-	//Global Goals
-	int 				currentGoalID;
-	int 				prevGoalID;
-	//-------------------------------------------//
-	//Following
-	double 				distanceToNext;
-	double				velocityOfNext;
-	//-------------------------------------------//
-	//For Lane Change
-	int 				iPrevSafeLane;
-	int 				iCurrSafeLane;
-	double				distanceToGoBack;
-	double 				timeToGoBack;
-	double 				distanceToChangeLane;
-	double				timeToChangeLane;
-	int 				currentLaneID;
-	int 				originalLaneID;
-	int 				targetLaneID;
-	bool 				bUpcomingLeft;
-	bool 				bUpcomingRight;
-	bool				bCanChangeLane;
-	bool				bTargetLaneSafe;
-	//-------------------------------------------//
-	//Traffic Lights &amp; Stop Sign
-	int 				currentStopSignID;
-	int 				prevStopSignID;
-	int 				currentTrafficLightID;
-	int 				prevTrafficLightID;
-	bool 				bTrafficIsRed; //On , off status
-	//-------------------------------------------//
-	//Swerving
-	int 				iPrevSafeTrajectory;
-	int 				iCurrSafeTrajectory;
-	int 				iCentralTrajectory;
-	bool				bFullyBlock;
-	LIGHT_INDICATOR 	indicator;
-
-	//-------------------------------------------//
-	//General
-	bool 				bNewGlobalPath;
-	bool 				bRePlan;
-	double 				currentVelocity;
-	double				minStoppingDistance; //comfortably
-	int 				bOutsideControl; // 0 waiting, 1 start, 2 Green Traffic Light, 3 Red Traffic Light, 5 Emergency Stop
-	bool				bGreenOutsideControl;
-	std::vector&lt;double&gt; stoppingDistances;
-
-
-	double distanceToStop()
-	{
-		if(stoppingDistances.size()==0) return 0;
-		double minS = stoppingDistances.at(0);
-		for(unsigned int i=0; i&lt; stoppingDistances.size(); i++)
-		{
-			if(stoppingDistances.at(i) &lt; minS)
-				minS = stoppingDistances.at(i);
-		}
-		return minS;
-	}
-
-	PreCalculatedConditions()
-	{
-		currentGoalID 			= 0;
-		prevGoalID				= -1;
-		currentVelocity 		= 0;
-		minStoppingDistance		= 1;
-		bOutsideControl			= 0;
-		bGreenOutsideControl	= false;
-		//distance to stop
-		distanceToNext			= -1;
-		velocityOfNext			= 0;
-		currentStopSignID		= -1;
-		prevStopSignID			= -1;
-		currentTrafficLightID	= -1;
-		prevTrafficLightID		= -1;
-		bTrafficIsRed			= false;
-		iCurrSafeTrajectory		= -1;
-		bFullyBlock				= false;
-
-		iPrevSafeTrajectory		= -1;
-		iCentralTrajectory		= -1;
-		bRePlan					= false;
-		bNewGlobalPath			= false;
-
-		bCanChangeLane			= false;
-		distanceToGoBack		= 0;
-		timeToGoBack			= 0;
-		distanceToChangeLane	= 0;
-		timeToChangeLane		= 0;
-		bTargetLaneSafe			= true;
-		bUpcomingLeft			= false;
-		bUpcomingRight			= false;
-		targetLaneID			= -1;
-		currentLaneID			= -1;
-		originalLaneID			= -1;
-		iCurrSafeLane 			= -1;
-		iPrevSafeLane			= -1;
-
-		indicator 				= INDICATOR_NONE;
-	}
-
-	virtual ~PreCalculatedConditions(){}
-
-	std::string ToStringHeader()
-	{
-		return "Time:General&gt;&gt;:currentVelocity:distanceToStop:minStoppingDistance:bStartBehaviorGenerator:bGoalReached:"
-				"Following&gt;&gt;:velocityOfNext:distanceToNext:"
-				"TrafficLight&gt;&gt;:currentTrafficLightID:bTrafficIsRed:"
-				"Swerving&gt;&gt;:iSafeTrajectory:bFullyBlock:";
-	}
-
-	std::string ToString(STATE_TYPE beh)
-	{
-		std::string str = "Unknown";
-		switch(beh)
-		{
-		case PlannerHNS::INITIAL_STATE:
-			str = "Init";
-			break;
-		case PlannerHNS::WAITING_STATE:
-			str = "Waiting";
-			break;
-		case PlannerHNS::FORWARD_STATE:
-			str = "Forward";
-			break;
-		case PlannerHNS::STOPPING_STATE:
-			str = "Stop";
-			break;
-		case PlannerHNS::FINISH_STATE:
-			str = "End";
-			break;
-		case PlannerHNS::FOLLOW_STATE:
-			str = "Follow";
-			break;
-		case PlannerHNS::OBSTACLE_AVOIDANCE_STATE:
-			str = "Swerving";
-			break;
-		case PlannerHNS::TRAFFIC_LIGHT_STOP_STATE:
-			str = "Light Stop";
-			break;
-		case PlannerHNS::TRAFFIC_LIGHT_WAIT_STATE:
-			str = "Light Wait";
-			break;
-		case PlannerHNS::STOP_SIGN_STOP_STATE:
-			str = "Sign Stop";
-			break;
-		case PlannerHNS::STOP_SIGN_WAIT_STATE:
-			str = "Sign Wait";
-			break;
-		default:
-			str = "Unknown";
-			break;
-		}
-
-		return str;
-	}
-};
-
-class TrajectoryCost
-{
-public:
-	int index;
-	int relative_index;
-	double closest_obj_velocity;
-	double distance_from_center;
-	double priority_cost; //0 to 1
-	double transition_cost; // 0 to 1
-	double closest_obj_cost; // 0 to 1
-	double cost;
-	double closest_obj_distance;
-
-	int lane_index;
-	double lane_change_cost;
-	double lateral_cost;
-	double longitudinal_cost;
-	bool bBlocked;
-	std::vector&lt;std::pair&lt;int, double&gt; &gt; lateral_costs;
-
-
-	TrajectoryCost()
-	{
-		lane_index = -1;
-		index = -1;
-		relative_index = -100;
-		closest_obj_velocity = 0;
-		priority_cost = 0;
-		transition_cost = 0;
-		closest_obj_cost = 0;
-		distance_from_center = 0;
-		cost = 0;
-		closest_obj_distance = -1;
-		lane_change_cost = 0;
-		lateral_cost = 0;
-		longitudinal_cost = 0;
-		bBlocked = false;
-	}
-
-	std::string ToString()
-	{
-		std::ostringstream str;
-		str.precision(4);
-		str &lt;&lt; "LaneIndex    : " &lt;&lt; lane_index;
-		str &lt;&lt; ", Index      : " &lt;&lt; relative_index;
-		str &lt;&lt; ", TotalCost  : " &lt;&lt; cost;
-		str &lt;&lt; ", Priority   : " &lt;&lt; priority_cost;
-		str &lt;&lt; ", Transition : " &lt;&lt; transition_cost;
-		str &lt;&lt; ", Lateral    : " &lt;&lt; lateral_cost;
-		str &lt;&lt; ", Longitu    : " &lt;&lt; longitudinal_cost;
-		str &lt;&lt; ", LaneChange : " &lt;&lt; lane_change_cost;
-		str &lt;&lt; ", Blocked    : " &lt;&lt; bBlocked;
-		str &lt;&lt; "\n";
-		for (unsigned int i=0; i&lt;lateral_costs.size(); i++ )
-		{
-			str &lt;&lt; " - (" &lt;&lt; lateral_costs.at(i).first &lt;&lt; ", " &lt;&lt; lateral_costs.at(i).second &lt;&lt; ")";
-		}
-
-		return str.str();
-
-	}
-};
-
-}
-
-
-#endif /* ROADNETWORK_H_ */
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\PlannerH\include\TrajectoryCosts.h" new_path="" added_lines="0" deleted_lines="50">
				<diff>@@ -1,50 +0,0 @@
-/*
- * TrajectoryCosts.h
- *
- *  Created on: Dec 14, 2016
- *      Author: user
- */
-
-#ifndef TRAJECTORYCOSTS_H_
-#define TRAJECTORYCOSTS_H_
-
-#include "RoadNetwork.h"
-#include "PlannerCommonDef.h"
-#include "PlanningHelpers.h"
-
-using namespace std;
-
-namespace PlannerHNS
-{
-
-class TrajectoryCosts
-{
-public:
-	TrajectoryCosts();
-	virtual ~TrajectoryCosts();
-
-	TrajectoryCost DoOneStep(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths,
-			const WayPoint&amp; currState, const int&amp; currTrajectoryIndex, const int&amp; currLaneIndex, const PlanningParams&amp; params,
-			const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-
-public:
-	int m_PrevCostIndex;
-	vector&lt;TrajectoryCost&gt; m_TrajectoryCosts;
-	PlanningParams m_Params;
-	PolygonShape m_SafetyBorder;
-	//vector&lt;GPSPoint&gt; m_SafetyBox;
-
-
-
-private:
-	bool ValidateRollOutsInput(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts);
-	vector&lt;TrajectoryCost&gt; CalculatePriorityAndLaneChangeCosts(const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; laneRollOuts, const int&amp; lane_index, const PlanningParams&amp; params);
-	void NormalizeCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts);
-	void CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths, const WayPoint&amp; currState, const vector&lt;WayPoint&gt;&amp; contourPoints, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState);
-	void CalculateTransitionCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const int&amp; currTrajectoryIndex, const PlanningParams&amp; params);
-
-};
-
-}
-
-#endif /* TRAJECTORYCOSTS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\UtilityH\include\DataRW.h" new_path="" added_lines="0" deleted_lines="438">
				<diff>@@ -1,438 +0,0 @@
-/*
- * DataRW.h
- *
- *  Created on: Jun 23, 2016
- *      Author: hatem
- */
-
-#ifndef DATARW_H_
-#define DATARW_H_
-
-#include &lt;string&gt;
-#include &lt;fstream&gt;
-#include &lt;sstream&gt;
-#include &lt;vector&gt;
-#include &lt;iostream&gt;
-
-namespace UtilityHNS {
-
-class DataRW
-{
-public:
-	DataRW();
-	virtual ~DataRW();
-
-	static std::string LoggingMainfolderName;
-	static std::string ControlLogFolderName;
-	static std::string PathLogFolderName;
-	static std::string StatesLogFolderName;
-	static std::string SimulationFolderName;
-	static std::string KmlMapsFolderName;
-
-
-	static void WriteKMLFile(const std::string&amp; fileName, const std::vector&lt;std::string&gt;&amp; gps_list);
-	static void WriteKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;std::string&gt; &gt;&amp; gps_list);
-	static void WriteLogData(const std::string&amp; logFolder, const std::string&amp; logTitle, const std::string&amp; header, const std::vector&lt;std::string&gt;&amp; logData);
-};
-
-class SimpleReaderBase
-{
-private:
-	std::ifstream* m_pFile;
-	std::vector&lt;std::string&gt; m_RawHeaders;
-	std::vector&lt;std::string&gt; m_DataTitlesHeader;
-	std::vector&lt;std::vector&lt;std::vector&lt;std::string&gt; &gt; &gt; m_AllData;
-	int m_nHeders;
-	int m_iDataTitles;
-	int m_nVarPerObj;
-	int m_nLineHeaders;
-	std::string m_HeaderRepeatKey;
-	char m_Separator;
-
-	void ReadHeaders();
-	void ParseDataTitles(const std::string&amp; header);
-
-public:
-	/**
-	 *
-	 * @param fileName log file name
-	 * @param nHeaders number of data headers
-	 * @param iDataTitles which row contains the data titles
-	 * @param nVariablesForOneObject 0 means each row represents one object
-	 */
-	SimpleReaderBase(const std::string&amp; fileName, const int&amp; nHeaders = 2, const char&amp; separator = ',',
-			const int&amp; iDataTitles = 1, const int&amp; nVariablesForOneObject = 0,
-			const int&amp; nLineHeaders = 0, const std::string&amp; headerRepeatKey = "...");
-	~SimpleReaderBase();
-
-protected:
-	bool ReadAllData();
-	bool ReadSingleLine(std::vector&lt;std::vector&lt;std::string&gt; &gt;&amp; line);
-
-};
-
-//class GPSLocalizerReader : public SimpleReaderBase
-//{
-//	public:
-//		GPSLocalizerReader(const std::string&amp; fileName) : SimpleReaderBase(fileName){}
-//		~GPSLocalizerReader(){}
-//
-//		bool ReadNextLine( MsgEstPose&amp; pos, double&amp; logTime);
-//		void ReadAllData(vector&lt;pair&lt;double,  MsgEstPose&gt; &gt;&amp; pos_list);
-//};
-//
-class GPSDataReader : public SimpleReaderBase
-{
-public:
-	struct GPSBasicData
-	{
-		double lat;
-		double lon;
-		double alt;
-		double dir;
-		double distance;
-
-	};
-
-	public:
-	GPSDataReader(const std::string&amp; fileName) : SimpleReaderBase(fileName){}
-	~GPSDataReader(){}
-
-	bool ReadNextLine(GPSBasicData&amp; data);
-	void ReadAllData(std::vector&lt;GPSBasicData&gt;&amp; data_list);
-};
-
-//
-//class VehicleStateReader : public SimpleReaderBase
-//{
-//	public:
-//	VehicleStateReader(const string&amp; fileName) : SimpleReaderBase(fileName){}
-//	~VehicleStateReader(){}
-//
-//	bool ReadNextLine( MsgVehicleStatus&amp; state, double&amp; logTime);
-//	void ReadAllData(vector&lt;pair&lt;double,  MsgVehicleStatus&gt; &gt;&amp; state_list);
-//};
-//
-//class MovingObjectsReader : public SimpleReaderBase
-//{
-//	public:
-//	MovingObjectsReader(const string&amp; fileName) : SimpleReaderBase(fileName, 2, 1, 28, 4){}
-//	~MovingObjectsReader(){}
-//
-//	bool ReadNextLine( MsgMovingObject&amp; state, double&amp; logTime);
-//	void ReadAllData(vector&lt;pair&lt;double,  MsgMovingObject&gt; &gt;&amp; state_list);
-//};
-
-class SimulationFileReader : public SimpleReaderBase
-{
-public:
-	struct SimulationPoint
-	{
-		double x;
-		double y;
-		double z;
-		double a;
-		double c;
-		double v;
-	};
-
-	struct SimulationData
-	{
-		SimulationPoint startPoint;
-		SimulationPoint goalPoint;
-		std::vector&lt;SimulationPoint&gt; simuCars;
-	};
-
-	SimulationFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~SimulationFileReader(){}
-
-	bool ReadNextLine(SimulationPoint&amp; data);
-	void ReadAllData(SimulationData&amp; data_list);
-};
-
-class LocalizationPathReader : public SimpleReaderBase
-{
-public:
-	struct LocalizationWayPoint
-	{
-		double t;
-		double x;
-		double y;
-		double z;
-		double a;
-		double v;
-	};
-
-	LocalizationPathReader(const std::string&amp; fileName, const char&amp; separator) : SimpleReaderBase(fileName, 1, separator){}
-	~LocalizationPathReader(){}
-
-	bool ReadNextLine(LocalizationWayPoint&amp; data);
-	void ReadAllData(std::vector&lt;LocalizationWayPoint&gt;&amp; data_list);
-};
-
-class AisanPointsFileReader : public SimpleReaderBase
-{
-public:
-	struct AisanPoints
-	{
-		int PID;
-		double B;
-		double L;
-		double H;
-		double Bx;
-		double Ly;
-		int Ref;
-		int MCODE1;
-		int MCODE2;
-		int MCODE3;
-	};
-
-	AisanPointsFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanPointsFileReader(){}
-
-	bool ReadNextLine(AisanPoints&amp; data);
-	void ReadAllData(std::vector&lt;AisanPoints&gt;&amp; data_list);
-};
-
-class AisanNodesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanNode
-	{
-		int NID;
-		int PID;
-	};
-
-	AisanNodesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanNodesFileReader(){}
-
-	bool ReadNextLine(AisanNode&amp; data);
-	void ReadAllData(std::vector&lt;AisanNode&gt;&amp; data_list);
-};
-
-class AisanLinesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanLine
-	{
-		int LID;
-		int BPID;
-		int FPID;
-		int BLID;
-		int FLID;
-	};
-
-	AisanLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanLinesFileReader(){}
-
-	bool ReadNextLine(AisanLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanLine&gt;&amp; data_list);
-};
-
-class AisanCenterLinesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanCenterLine
-	{
-		int 	DID;
-		int 	Dist;
-		int 	PID;
-		double 	Dir;
-		double 	Apara;
-		double 	r;
-		double 	slope;
-		double 	cant;
-		double 	LW;
-		double 	RW;
-	};
-
-	AisanCenterLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanCenterLinesFileReader(){}
-
-	bool ReadNextLine(AisanCenterLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanCenterLine&gt;&amp; data_list);
-};
-
-class AisanAreasFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanArea
-	{
-		int 	AID;
-		int 	SLID;
-		int 	ELID;
-	};
-
-	AisanAreasFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanAreasFileReader(){}
-
-	bool ReadNextLine(AisanArea&amp; data);
-	void ReadAllData(std::vector&lt;AisanArea&gt;&amp; data_list);
-};
-
-class AisanIntersectionFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanIntersection
-	{
-		int 	ID;
-		int 	AID;
-		int 	LinkID;
-	};
-
-	AisanIntersectionFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanIntersectionFileReader(){}
-
-	bool ReadNextLine(AisanIntersection&amp; data);
-	void ReadAllData(std::vector&lt;AisanIntersection&gt;&amp; data_list);
-};
-
-class AisanLanesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanLane
-	{
-		int LnID	;
-		int DID		;
-		int BLID	;
-		int FLID	;
-		int BNID	;
-		int FNID	;
-		int JCT		;
-		int BLID2	;
-		int BLID3	;
-		int BLID4	;
-		int FLID2	;
-		int FLID3	;
-		int FLID4	;
-		int ClossID	;
-		double Span	;
-		int LCnt	;
-		int Lno		;
-		int LaneType;
-		int LimitVel;
-		int RefVel	;
-		int RoadSecID;
-		int LaneChgFG;
-		int LinkWAID;
-		char LaneDir;
-		int  LeftLaneId;
-		int RightLaneId;
-
-	};
-
-	AisanLanesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanLanesFileReader(){}
-
-	bool ReadNextLine(AisanLane&amp; data);
-	void ReadAllData(std::vector&lt;AisanLane&gt;&amp; data_list);
-};
-
-class AisanStopLineFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanStopLine
-	{
-		int 	ID;
-		int 	LID;
-		int 	TLID;
-		int 	SignID;
-		int 	LinkID;
-	};
-
-	AisanStopLineFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanStopLineFileReader(){}
-
-	bool ReadNextLine(AisanStopLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanStopLine&gt;&amp; data_list);
-};
-
-class AisanRoadSignFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanRoadSign
-	{
-		int 	ID;
-		int 	VID;
-		int 	PLID;
-		int 	Type;
-		int 	LinkID;
-	};
-
-	AisanRoadSignFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanRoadSignFileReader(){}
-
-	bool ReadNextLine(AisanRoadSign&amp; data);
-	void ReadAllData(std::vector&lt;AisanRoadSign&gt;&amp; data_list);
-};
-
-class AisanSignalFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanSignal
-	{
-		int 	ID;
-		int 	VID;
-		int 	PLID;
-		int 	Type;
-		int 	LinkID;
-	};
-
-	AisanSignalFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanSignalFileReader(){}
-
-	bool ReadNextLine(AisanSignal&amp; data);
-	void ReadAllData(std::vector&lt;AisanSignal&gt;&amp; data_list);
-};
-
-class AisanVectorFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanVector
-	{
-		int 	VID;
-		int 	PID;
-		double 	Hang;
-		double 	Vang;
-	};
-
-	AisanVectorFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanVectorFileReader(){}
-
-	bool ReadNextLine(AisanVector&amp; data);
-	void ReadAllData(std::vector&lt;AisanVector&gt;&amp; data_list);
-};
-
-class AisanDataConnFileReader : public SimpleReaderBase
-{
-public:
-
-	struct DataConn
-	{
-		int 	LID; // lane id
-		int 	SLID; // stop line id
-		int 	SID; // signal id
-		int 	SSID; // stop sign id
-	};
-
-	AisanDataConnFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanDataConnFileReader(){}
-
-	bool ReadNextLine(DataConn&amp; data);
-	void ReadAllData(std::vector&lt;DataConn&gt;&amp; data_list);
-};
-
-
-} /* namespace UtilityHNS */
-
-#endif /* DATARW_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\plannerh_src\UtilityH\include\UtilityH.h" new_path="" added_lines="0" deleted_lines="115">
				<diff>@@ -1,115 +0,0 @@
-/*
- * UtilityH.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#ifndef UTILITYH_H_
-#define UTILITYH_H_
-
-#include &lt;assert.h&gt;
-#include &lt;math.h&gt;
-#include &lt;string&gt;
-
-
-namespace UtilityHNS
-{
-
-#define DEG2RAD M_PI / 180.
-#define RAD2DEG 180. / M_PI
-#define sign(x) (x &gt; 0) ? 1 : ((x &lt; 0) ? -1 : 0)
-#define MIN(x,y) (x &lt;= y ? x : y)
-#define MAX(x,y) (x &gt;= y ? x : y)
-
-
-class UtilityH
-{
-public:
-	UtilityH();
-	virtual ~UtilityH(); 
-
-
-	static double FixNegativeAngle(const double&amp; a);
-	static double SplitPositiveAngle(const double&amp; a);
-	static double InverseAngle(const double&amp; a);
-	static double AngleBetweenTwoAnglesPositive(const double&amp; a1, const double&amp; a2);
-	static double GetCircularAngle(const double&amp; prevContAngle, const double&amp; prevAngle, const double&amp; currAngle);
-
-	//Time Functions
-	static void GetTickCount(struct timespec&amp; t);
-	static std::string GetFilePrefixHourMinuteSeconds();
-	static double GetTimeDiffNow(const struct timespec&amp; old_t);
-	static double GetTimeDiff(const struct timespec&amp; old_t,const struct timespec&amp; curr_t);
-	static std::string GetDateTimeStr();
-	static int tsCompare (struct  timespec  time1,   struct  timespec  time2, int micro_tolerance = 10);
-	static int GetSign(double x);
-	static std::string GetHomeDirectory();
-	static double GetMomentumScaleFactor(const double&amp; v);
-	static timespec GetTimeSpec(const time_t&amp; srcT);
-	static time_t GetLongTime(const struct timespec&amp; srcT);
-};
-
-class PIDController
-{
-public:
-	PIDController();
-	PIDController(const double&amp; kp, const double&amp; ki, const double&amp; kd);
-	void Init(const double&amp; kp, const double&amp; ki, const double&amp; kd);
-	void Setlimit(const double&amp; upper,const double&amp; lower);
-	double getPID(const double&amp; currValue, const double&amp; targetValue);
-	double getPID(const double&amp; e);
-	void ResetD();
-	void ResetI();
-	std::string ToString();
-	std::string ToStringHeader();
-
-
-private:
-	double kp;
-	double ki;
-	double kd;
-	double kp_v;
-	double ki_v;
-	double kd_v;
-	double pid_v;
-	double pid_lim;
-	double upper_limit;
-	double lower_limit;
-	bool   bEnableLimit;
-	double accumErr;
-	double prevErr;
-	bool bResetD;
-	bool bResetI;
-
-};
-
-class LowpassFilter
-{
-public:
-	LowpassFilter();
-	virtual ~LowpassFilter();
-
-	LowpassFilter(const int&amp; filterOrder, const double&amp; sampleFreq, const double&amp; cutOffFreq);
-	void Init(const int&amp; filterOrder, const double&amp; sampleFreq, const double&amp; cutOffFreq);
-	double getFilter(const double&amp; value);
-
-
-private:
-	int m;
-	double sampleF;
-	double cutOffF;
-	double A  ;
-	double d1 ;
-	double d2 ;
-	double w0 ;
-	double w1 ;
-	double w2 ;
-
-};
-
-}
-
-#endif
-
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\RosHelpers.h" new_path="ros\src\computing\planning\mission\packages\way_planner\include\RosHelpers.h" added_lines="6" deleted_lines="6">
				<diff>@@ -28,7 +28,7 @@
 //#include &lt;pcl/point_types.h&gt;
 
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "waypoint_follower/LaneArray.h"
+#include "waypoint_follower_msgs/LaneArray.h"
 
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
@@ -127,7 +127,7 @@ public:
 	virtual ~RosHelpers();
 	static void GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform);
 	static void ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
-				waypoint_follower::LaneArray&amp; laneArray);
+				waypoint_follower_msgs::LaneArray&amp; laneArray);
 
 	static void ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; curr_path,
 			const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths,
@@ -138,16 +138,16 @@ public:
 
 	static void ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const PlannerHNS::RoadNetwork&amp; map,	visualization_msgs::MarkerArray&amp; markerArray);
 
-	static void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const waypoint_follower::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray);
+	static void createGlobalLaneArrayMarker(std_msgs::ColorRGBA color, const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray);
 
-	static void createGlobalLaneArrayVelocityMarker(const waypoint_follower::LaneArray &amp;lane_waypoints_array
+	static void createGlobalLaneArrayVelocityMarker(const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array
 			, visualization_msgs::MarkerArray&amp; markerArray);
 
-	static void createGlobalLaneArrayOrientationMarker(const waypoint_follower::LaneArray &amp;lane_waypoints_array
+	static void createGlobalLaneArrayOrientationMarker(const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array
 			, visualization_msgs::MarkerArray&amp; markerArray);
 
 	static void ConvertFromPlannerHPointsToAutowarePathFormat(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path,
-			waypoint_follower::LaneArray&amp; laneArray);
+			waypoint_follower_msgs::LaneArray&amp; laneArray);
 
 	static void FindIncommingBranches(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; globalPaths, const PlannerHNS::WayPoint&amp; currPose, const double&amp; min_distance,
 			std::vector&lt;PlannerHNS::WayPoint*&gt;&amp; branches, PlannerHNS::WayPoint* currOptions);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\plannerh\BehaviorStateMachine.h" new_path="" added_lines="0" deleted_lines="176">
				<diff>@@ -1,176 +0,0 @@
-/*
- * BehaviorStateMachine.h
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
-
-#ifndef BEHAVIORSTATEMACHINE_H_
-#define BEHAVIORSTATEMACHINE_H_
-
-#include "RoadNetwork.h"
-#include &lt;sstream&gt;
-
-namespace PlannerHNS
-{
-class BehaviorStateMachine
-{
-public:
-	virtual BehaviorStateMachine* GetNextState() = 0;
-	virtual void Init();
-	virtual void ResetTimer();
-	virtual void InsertNextState(BehaviorStateMachine* nextState);
-	BehaviorStateMachine(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* nextState);
-	virtual ~BehaviorStateMachine() ;
-
-	STATE_TYPE m_Behavior;
-	int m_currentStopSignID	;
-	int m_currentTrafficLightID ;
-	double decisionMakingTime;
-	double m_zero_velocity;
-
-	PreCalculatedConditions* GetCalcParams()
-	{
-		if(!m_pCalculatedValues)
-				m_pCalculatedValues = new PreCalculatedConditions();
-
-		return m_pCalculatedValues;
-	}
-
-	void SetBehaviorsParams(PlanningParams* pParams)
-	{
-		if(!pParams)
-			m_pParams = new PlanningParams;
-		else
-			m_pParams = pParams;
-	}
-
-
-	PreCalculatedConditions* m_pCalculatedValues;
-	PlanningParams* m_pParams;
-	timespec m_StateTimer;
-	std::vector&lt;BehaviorStateMachine*&gt; pNextStates;
-
-	BehaviorStateMachine* FindBehaviorState(const STATE_TYPE&amp; behavior);
-};
-
-class ForwardState : public BehaviorStateMachine
-{
-public:
-	ForwardState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FORWARD_STATE;}
-	virtual ~ForwardState(){}
-	virtual BehaviorStateMachine* GetNextState();
-};
-
-class MissionAccomplishedState : public BehaviorStateMachine
-{
-public:
-	MissionAccomplishedState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FINISH_STATE;}
-	virtual ~MissionAccomplishedState(){}
-	virtual BehaviorStateMachine* GetNextState();
-};
-
-class FollowState : public BehaviorStateMachine
-{
-public:
-	FollowState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FOLLOW_STATE;}
-	virtual ~FollowState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class SwerveState : public BehaviorStateMachine
-{
-public:
-	SwerveState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = OBSTACLE_AVOIDANCE_STATE;}
-	virtual ~SwerveState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopState : public BehaviorStateMachine
-{
-public:
-	StopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOPPING_STATE;}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class TrafficLightStopState : public BehaviorStateMachine
-{
-public:
-	TrafficLightStopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = TRAFFIC_LIGHT_STOP_STATE;}
-	virtual ~TrafficLightStopState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class TrafficLightWaitState : public BehaviorStateMachine
-{
-public:
-	TrafficLightWaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = TRAFFIC_LIGHT_WAIT_STATE;}
-	virtual ~TrafficLightWaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopSignStopState : public BehaviorStateMachine
-{
-public:
-	StopSignStopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOP_SIGN_STOP_STATE;}
-	virtual ~StopSignStopState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopSignWaitState : public BehaviorStateMachine
-{
-public:
-	StopSignWaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOP_SIGN_WAIT_STATE;}
-	virtual ~StopSignWaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class WaitState : public BehaviorStateMachine
-{
-public:
-	WaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = WAITING_STATE;}
-	virtual ~WaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class InitState : public BehaviorStateMachine
-{
-public:
-	InitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = INITIAL_STATE;}
-	virtual ~InitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class GoalState : public BehaviorStateMachine
-{
-public:
-	GoalState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = GOAL_STATE;}
-	virtual ~GoalState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* BEHAVIORSTATEMACHINE_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\plannerh\DataRW.h" new_path="" added_lines="0" deleted_lines="438">
				<diff>@@ -1,438 +0,0 @@
-/*
- * DataRW.h
- *
- *  Created on: Jun 23, 2016
- *      Author: hatem
- */
-
-#ifndef DATARW_H_
-#define DATARW_H_
-
-#include &lt;string&gt;
-#include &lt;fstream&gt;
-#include &lt;sstream&gt;
-#include &lt;vector&gt;
-#include &lt;iostream&gt;
-
-namespace UtilityHNS {
-
-class DataRW
-{
-public:
-	DataRW();
-	virtual ~DataRW();
-
-	static std::string LoggingMainfolderName;
-	static std::string ControlLogFolderName;
-	static std::string PathLogFolderName;
-	static std::string StatesLogFolderName;
-	static std::string SimulationFolderName;
-	static std::string KmlMapsFolderName;
-
-
-	static void WriteKMLFile(const std::string&amp; fileName, const std::vector&lt;std::string&gt;&amp; gps_list);
-	static void WriteKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;std::string&gt; &gt;&amp; gps_list);
-	static void WriteLogData(const std::string&amp; logFolder, const std::string&amp; logTitle, const std::string&amp; header, const std::vector&lt;std::string&gt;&amp; logData);
-};
-
-class SimpleReaderBase
-{
-private:
-	std::ifstream* m_pFile;
-	std::vector&lt;std::string&gt; m_RawHeaders;
-	std::vector&lt;std::string&gt; m_DataTitlesHeader;
-	std::vector&lt;std::vector&lt;std::vector&lt;std::string&gt; &gt; &gt; m_AllData;
-	int m_nHeders;
-	int m_iDataTitles;
-	int m_nVarPerObj;
-	int m_nLineHeaders;
-	std::string m_HeaderRepeatKey;
-	char m_Separator;
-
-	void ReadHeaders();
-	void ParseDataTitles(const std::string&amp; header);
-
-public:
-	/**
-	 *
-	 * @param fileName log file name
-	 * @param nHeaders number of data headers
-	 * @param iDataTitles which row contains the data titles
-	 * @param nVariablesForOneObject 0 means each row represents one object
-	 */
-	SimpleReaderBase(const std::string&amp; fileName, const int&amp; nHeaders = 2, const char&amp; separator = ',',
-			const int&amp; iDataTitles = 1, const int&amp; nVariablesForOneObject = 0,
-			const int&amp; nLineHeaders = 0, const std::string&amp; headerRepeatKey = "...");
-	~SimpleReaderBase();
-
-protected:
-	bool ReadAllData();
-	bool ReadSingleLine(std::vector&lt;std::vector&lt;std::string&gt; &gt;&amp; line);
-
-};
-
-//class GPSLocalizerReader : public SimpleReaderBase
-//{
-//	public:
-//		GPSLocalizerReader(const std::string&amp; fileName) : SimpleReaderBase(fileName){}
-//		~GPSLocalizerReader(){}
-//
-//		bool ReadNextLine( MsgEstPose&amp; pos, double&amp; logTime);
-//		void ReadAllData(vector&lt;pair&lt;double,  MsgEstPose&gt; &gt;&amp; pos_list);
-//};
-//
-class GPSDataReader : public SimpleReaderBase
-{
-public:
-	struct GPSBasicData
-	{
-		double lat;
-		double lon;
-		double alt;
-		double dir;
-		double distance;
-
-	};
-
-	public:
-	GPSDataReader(const std::string&amp; fileName) : SimpleReaderBase(fileName){}
-	~GPSDataReader(){}
-
-	bool ReadNextLine(GPSBasicData&amp; data);
-	void ReadAllData(std::vector&lt;GPSBasicData&gt;&amp; data_list);
-};
-
-//
-//class VehicleStateReader : public SimpleReaderBase
-//{
-//	public:
-//	VehicleStateReader(const string&amp; fileName) : SimpleReaderBase(fileName){}
-//	~VehicleStateReader(){}
-//
-//	bool ReadNextLine( MsgVehicleStatus&amp; state, double&amp; logTime);
-//	void ReadAllData(vector&lt;pair&lt;double,  MsgVehicleStatus&gt; &gt;&amp; state_list);
-//};
-//
-//class MovingObjectsReader : public SimpleReaderBase
-//{
-//	public:
-//	MovingObjectsReader(const string&amp; fileName) : SimpleReaderBase(fileName, 2, 1, 28, 4){}
-//	~MovingObjectsReader(){}
-//
-//	bool ReadNextLine( MsgMovingObject&amp; state, double&amp; logTime);
-//	void ReadAllData(vector&lt;pair&lt;double,  MsgMovingObject&gt; &gt;&amp; state_list);
-//};
-
-class SimulationFileReader : public SimpleReaderBase
-{
-public:
-	struct SimulationPoint
-	{
-		double x;
-		double y;
-		double z;
-		double a;
-		double c;
-		double v;
-	};
-
-	struct SimulationData
-	{
-		SimulationPoint startPoint;
-		SimulationPoint goalPoint;
-		std::vector&lt;SimulationPoint&gt; simuCars;
-	};
-
-	SimulationFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~SimulationFileReader(){}
-
-	bool ReadNextLine(SimulationPoint&amp; data);
-	void ReadAllData(SimulationData&amp; data_list);
-};
-
-class LocalizationPathReader : public SimpleReaderBase
-{
-public:
-	struct LocalizationWayPoint
-	{
-		double t;
-		double x;
-		double y;
-		double z;
-		double a;
-		double v;
-	};
-
-	LocalizationPathReader(const std::string&amp; fileName, const char&amp; separator) : SimpleReaderBase(fileName, 1, separator){}
-	~LocalizationPathReader(){}
-
-	bool ReadNextLine(LocalizationWayPoint&amp; data);
-	void ReadAllData(std::vector&lt;LocalizationWayPoint&gt;&amp; data_list);
-};
-
-class AisanPointsFileReader : public SimpleReaderBase
-{
-public:
-	struct AisanPoints
-	{
-		int PID;
-		double B;
-		double L;
-		double H;
-		double Bx;
-		double Ly;
-		int Ref;
-		int MCODE1;
-		int MCODE2;
-		int MCODE3;
-	};
-
-	AisanPointsFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanPointsFileReader(){}
-
-	bool ReadNextLine(AisanPoints&amp; data);
-	void ReadAllData(std::vector&lt;AisanPoints&gt;&amp; data_list);
-};
-
-class AisanNodesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanNode
-	{
-		int NID;
-		int PID;
-	};
-
-	AisanNodesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanNodesFileReader(){}
-
-	bool ReadNextLine(AisanNode&amp; data);
-	void ReadAllData(std::vector&lt;AisanNode&gt;&amp; data_list);
-};
-
-class AisanLinesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanLine
-	{
-		int LID;
-		int BPID;
-		int FPID;
-		int BLID;
-		int FLID;
-	};
-
-	AisanLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanLinesFileReader(){}
-
-	bool ReadNextLine(AisanLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanLine&gt;&amp; data_list);
-};
-
-class AisanCenterLinesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanCenterLine
-	{
-		int 	DID;
-		int 	Dist;
-		int 	PID;
-		double 	Dir;
-		double 	Apara;
-		double 	r;
-		double 	slope;
-		double 	cant;
-		double 	LW;
-		double 	RW;
-	};
-
-	AisanCenterLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanCenterLinesFileReader(){}
-
-	bool ReadNextLine(AisanCenterLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanCenterLine&gt;&amp; data_list);
-};
-
-class AisanAreasFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanArea
-	{
-		int 	AID;
-		int 	SLID;
-		int 	ELID;
-	};
-
-	AisanAreasFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanAreasFileReader(){}
-
-	bool ReadNextLine(AisanArea&amp; data);
-	void ReadAllData(std::vector&lt;AisanArea&gt;&amp; data_list);
-};
-
-class AisanIntersectionFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanIntersection
-	{
-		int 	ID;
-		int 	AID;
-		int 	LinkID;
-	};
-
-	AisanIntersectionFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanIntersectionFileReader(){}
-
-	bool ReadNextLine(AisanIntersection&amp; data);
-	void ReadAllData(std::vector&lt;AisanIntersection&gt;&amp; data_list);
-};
-
-class AisanLanesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanLane
-	{
-		int LnID	;
-		int DID		;
-		int BLID	;
-		int FLID	;
-		int BNID	;
-		int FNID	;
-		int JCT		;
-		int BLID2	;
-		int BLID3	;
-		int BLID4	;
-		int FLID2	;
-		int FLID3	;
-		int FLID4	;
-		int ClossID	;
-		double Span	;
-		int LCnt	;
-		int Lno		;
-		int LaneType;
-		int LimitVel;
-		int RefVel	;
-		int RoadSecID;
-		int LaneChgFG;
-		int LinkWAID;
-		char LaneDir;
-		int  LeftLaneId;
-		int RightLaneId;
-
-	};
-
-	AisanLanesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanLanesFileReader(){}
-
-	bool ReadNextLine(AisanLane&amp; data);
-	void ReadAllData(std::vector&lt;AisanLane&gt;&amp; data_list);
-};
-
-class AisanStopLineFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanStopLine
-	{
-		int 	ID;
-		int 	LID;
-		int 	TLID;
-		int 	SignID;
-		int 	LinkID;
-	};
-
-	AisanStopLineFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanStopLineFileReader(){}
-
-	bool ReadNextLine(AisanStopLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanStopLine&gt;&amp; data_list);
-};
-
-class AisanRoadSignFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanRoadSign
-	{
-		int 	ID;
-		int 	VID;
-		int 	PLID;
-		int 	Type;
-		int 	LinkID;
-	};
-
-	AisanRoadSignFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanRoadSignFileReader(){}
-
-	bool ReadNextLine(AisanRoadSign&amp; data);
-	void ReadAllData(std::vector&lt;AisanRoadSign&gt;&amp; data_list);
-};
-
-class AisanSignalFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanSignal
-	{
-		int 	ID;
-		int 	VID;
-		int 	PLID;
-		int 	Type;
-		int 	LinkID;
-	};
-
-	AisanSignalFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanSignalFileReader(){}
-
-	bool ReadNextLine(AisanSignal&amp; data);
-	void ReadAllData(std::vector&lt;AisanSignal&gt;&amp; data_list);
-};
-
-class AisanVectorFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanVector
-	{
-		int 	VID;
-		int 	PID;
-		double 	Hang;
-		double 	Vang;
-	};
-
-	AisanVectorFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanVectorFileReader(){}
-
-	bool ReadNextLine(AisanVector&amp; data);
-	void ReadAllData(std::vector&lt;AisanVector&gt;&amp; data_list);
-};
-
-class AisanDataConnFileReader : public SimpleReaderBase
-{
-public:
-
-	struct DataConn
-	{
-		int 	LID; // lane id
-		int 	SLID; // stop line id
-		int 	SID; // signal id
-		int 	SSID; // stop sign id
-	};
-
-	AisanDataConnFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanDataConnFileReader(){}
-
-	bool ReadNextLine(DataConn&amp; data);
-	void ReadAllData(std::vector&lt;DataConn&gt;&amp; data_list);
-};
-
-
-} /* namespace UtilityHNS */
-
-#endif /* DATARW_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\plannerh\GridMap.h" new_path="" added_lines="0" deleted_lines="230">
				<diff>@@ -1,230 +0,0 @@
-/*
- * GridMap.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#ifndef GRIDMAPSA_H_
-#define GRIDMAPSA_H_
-
-#include "RoadNetwork.h"
-
-namespace PlannerHNS
-{
-
-#define get2dIndex(r,c,w) r*w + c
-#define checkGridLimit(r,c,h,w) r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; h &amp;&amp; c &lt; w
-#define checkGridIndex(i, nCells) i &gt;= 0 &amp;&amp; i &lt; nCells
-#define SUBCELL_L 10 //subcell lenth in centimeter
-
-
-class CELL_Info
-{
-public:
-  int r,c,index;
-  GPSPoint center;
-  int nCells;
-  double heuristic;
-  double forwardHeuristic;
-  double backwardHeuristic;
-  double heuristicValue;
-  double forward_heuristicValue;
-  double backward_heuristicValue;
-  int expanded; // used in path planning
-  bool closed;
-  double value;
-  int action;
-  double localize_val;
-  double localize_prob;
-  std::vector&lt;double&gt; localize_features;
-  GPSPoint forwardCenter;
-  GPSPoint backwardCenter;
-  DIRECTION_TYPE bDir;
-  POINT2D bottom_left;
-  POINT2D top_right;
-  POINT2D bottom_right;
-  POINT2D top_left;
-  int nStaticPoints;
-  int nMovingPoints;
-
-  CELL_Info* pInnerMap;
-
-  std::vector&lt;POINT2D&gt; innerStaticPointsList;
-  std::vector&lt;POINT2D&gt; innerMovingPointsList;
-
-  std::vector&lt;GPSPoint&gt; path;
-
-
-public:
-  void InitSubCells(double cell_l, double sub_cell_l);
-/**
- * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
- * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
- */
-  void Clear(int bMovingOnly);
-  void ClearSubCells(bool bMovingOnly);
-
-  CELL_Info();
-
-  virtual ~CELL_Info();
-
-  /*
-   * Cell initialization
-   */
-  void Initialize(POINT2D bottom_left, double cell_l, int row, int col, bool bDefaultEmpty);
-
-  /*
-   * assignment operator
-   */
-  bool operator==(const CELL_Info&amp; cell);
-
-  bool operator!=(const CELL_Info&amp; cell);
-
-  inline bool PointInRect(const POINT2D&amp; p)
-   {
-     return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
-   }
-
-  bool TestWithRectangle(RECTANGLE&amp; rec);
-  bool TestWithCircle(POINT2D _center,double  width);
-   inline bool HitTest(const POINT2D&amp; p);
-
-   void UpdateSubCellCostValue(const std::vector&lt;POINT2D&gt;&amp; ps, const double&amp; cell_l, const double&amp; sub_cell_l);
-   void UpdateCostValue(const std::vector&lt;POINT2D&gt;&amp; ps);
-
-   void SaveCell(std::ostream&amp; f);
-   void LoadCell(std::ifstream&amp; f);
-
-};
-
-class GridMap
-{
-  public:
-
-	  pthread_mutex_t update_map_mutex;
-
-    double w, inner_w; // current world width
-    double h, inner_h; // current world height
-    double cell_l; // cell or block length, if this is an inner cell measurements will be in meter
-    double sub_cell_l;
-    double origin_x , origin_y;
-
-
-
-    int inner_start_row;
-    int inner_start_col;
-    int inner_end_row;
-    int inner_end_col;
-
-    bool m_bEnableInnerMap;
-    bool m_bUpdatedMap;
-
-
-
-    int wCells, nInnerWCells; // width, number of cells per row
-    int hCells, nInnerHCells; // height, number of cells per column
-	//POINT2D center;
-	int m_MaxHeuristics;
-
-	int m_DisplayResolution;
-
-	POINT2D* delta;
-
-
-    // This method map obstacles from real world space to Grid space , marking each cell or internal cells as obstacle
-	void UpdateMapObstacleValue(const Obstacle&amp; ob);
-	void UpdateMapDrivablesValue(const DrivableArea&amp; dr);
-	void UpdateMapDrivablesValuePlygon(const std::vector&lt;std::vector&lt;POINT2D&gt; &gt;&amp; points);
-	void UpdateMapObstaclesValuePlygon(const std::vector&lt;POINT2D&gt;&amp; poly, std::vector&lt;CELL_Info*&gt;&amp; modifiedCell);
-
-	/**
-	 * @brief update cell to indicate that there is an obstacle @ absolute point p
-	 * @param p absolute x,y point
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapObstaclePoint(const POINT2D&amp; p);
-
-	/**
-	 * @brief update cell to indicate that there is an obstacle @ absolute point p , and make the map thiner according to a giving threshold
-	 * @param p absolute x,y point
-	 * @param thiningTHreshold distance to search for old obstacles
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateThinMapObstaclePoint(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold);
-
-	/**
-	 * @brief update cell to indicate that there is an moving obstacle @ absolute point p
-	 * @param p absolute x,y point
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapMovingObstaclePoint(const POINT2D&amp; p);
-
-	/**
-	 * @brief update subcells cost values to reflect the effect of obstacle @ absolute pint p
-	 * @param p obstacle point (x,y)
-	 * @param currPos current car location to apply the effect of obstacle on p
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapCostValueRange(const std::vector&lt;POINT2D&gt;&amp; ps, const GPSPoint&amp; currPos, const std::vector&lt;double&gt;&amp; features);
-	/**
-	 * @brief find the cell @ p then update its localization cost and probability which were read from a map file
-	 * @param p absolute position of the cell center
-	 * @param localize_val cost value
-	 * @param localize_prob probability value (should be zero in case of updating from map file
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateSubMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);
-
-	CELL_Info* UpdateMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);
-
-	CELL_Info* GetCellFromPointInnerMap(const POINT2D&amp; p);
-	CELL_Info* GetCellFromPoint(const POINT2D&amp; p, bool bExpand = false); // return cell information from (x,y) coordinates
-	CELL_Info* GetSubCellFromPoint(const POINT2D&amp; p); // return sub cell information from (x,y) coordinates
-	CELL_Info* GetSubCellFromCell(CELL_Info* const parent, const POINT2D&amp; p); // return sub cell information from parent cell
-
-	bool CheckSubCellsInTheWay(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold, std::vector&lt;CELL_Info*&gt;&amp; pSubCellsList);
-
-	/**
-	 * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
-	 * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
-	 */
-	void ClearMap(int bMovingOnly);
-	void OpenClosedCells();
-	void BackupMap();
-
-	GridMap();
-    GridMap(double start_x, double start_y, double  map_w, double map_h, double cell_length, bool bDefaultEmpty); // initialize and construct the 2D array of the Grid cells
-    void InitInnerMap(double  map_l, GridMap* const pParentMap, const POINT2D&amp; center); // initialize and construct map from another map (cells will point to cells from the other map , width and hight will be maximum available limited by the parameters
-    virtual ~GridMap();
-
-    CELL_Info* pCells;
-    int nCells;
-
-    void SaveMap(const std::string&amp; mapFilePath, const std::string&amp; mapName);
-    void LoadMap(const std::string&amp; mapFilePath, const POINT2D&amp; pos, const double&amp; loadingRadius, const GPSPoint&amp; mapTransformation);
-
-    int GetSurroundingMainCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
-    int GetSurroundingNonObstacleCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
-    int GetSurroundingMainCellsRectangle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
-    int GetSurroundingMainCellsCircle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, double radius);
-    int GetSurroundingMainCellsRectangleNoObstacle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
-
-    bool IsUpdated()
-    {
-    	return m_bUpdatedMap;
-    }
-
-    void ObservedMap()
-    {
-    	m_bUpdatedMap = false;
-    }
-
-  private:
-    int InsidePolygon(const std::vector&lt;POINT2D&gt;&amp; polygon,const POINT2D&amp; p);
-
-    //vector&lt;CELL_Info*&gt; pDrivableCells;
-  };
-
-}
-#endif /* GRIDMAP_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\plannerh\HMIStateMachine.h" new_path="" added_lines="0" deleted_lines="99">
				<diff>@@ -1,99 +0,0 @@
-/*
- * HMIStateMachine.h
- *
- *  Created on: February 14, 2017
- *      Author: Hatem Darweesh
- */
-
-#ifndef HMIStateMachine_H_
-#define HMIStateMachine_H_
-
-#include "RoadNetwork.h"
-#include &lt;sstream&gt;
-
-namespace PlannerHNS
-{
-
-class HMIStateMachine
-{
-public:
-	virtual HMIStateMachine* GetNextState() = 0;
-	virtual void Init();
-	virtual void ResetTimer();
-	virtual void InsertNextState(HMIStateMachine* nextState);
-	HMIStateMachine(HMIStateMachine* nextState);
-	virtual ~HMIStateMachine() ;
-
-	GLOBAL_STATE_TYPE m_Behavior;
-	double decisionMakingTime;
-
-	HMIPreCalculatedConditions* GetCalcParams()
-	{
-		if(!m_pCalculatedValues)
-				m_pCalculatedValues = new HMIPreCalculatedConditions();
-
-		return m_pCalculatedValues;
-	}
-
-	void SetBehaviorsParams(const PlanningParams&amp; params)
-	{
-		m_PlanningParams = params;
-	}
-
-	static HMIPreCalculatedConditions* m_pCalculatedValues;
-	timespec m_StateTimer;
-	std::vector&lt;HMIStateMachine*&gt; pNextStates;
-	static PlanningParams m_PlanningParams;
-
-	HMIStateMachine* FindBehaviorState(const GLOBAL_STATE_TYPE&amp; behavior);
-};
-
-class GWaitingState : public HMIStateMachine
-{
-public:
-	GWaitingState(GWaitingState* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_WAITING_STATE;}
-	virtual ~GWaitingState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GPlanningState : public HMIStateMachine
-{
-public:
-	GPlanningState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_PLANING_STATE;}
-	virtual ~GPlanningState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GForwardState : public HMIStateMachine
-{
-public:
-	GForwardState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_FORWARD_STATE;}
-	virtual ~GForwardState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GBranchingState : public HMIStateMachine
-{
-public:
-	GBranchingState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_BRANCHING_STATE;}
-	virtual ~GBranchingState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GEndState : public HMIStateMachine
-{
-public:
-	GEndState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_FINISH_STATE;}
-	virtual ~GEndState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-
-} /* namespace PlannerHNS */
-
-#endif /* HMIStateMachine_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\plannerh\LocalPlannerH.h" new_path="" added_lines="0" deleted_lines="157">
				<diff>@@ -1,157 +0,0 @@
-/*
- * CarState.h
- *
- *  Created on: Dec 14, 2016
- *      Author: hatem
- */
-
-#ifndef LOCALPLANNERH_H_
-#define LOCALPLANNERH_H_
-
-#include "BehaviorStateMachine.h"
-#include "PlannerCommonDef.h"
-#include "RoadNetwork.h"
-#include "TrajectoryCosts.h"
-
-namespace PlannerHNS
-{
-
-class LocalPlannerH
-{
-public:
-	WayPoint state;
-	CAR_BASIC_INFO m_CarInfo;
-	ControllerParams m_ControlParams;
-	std::vector&lt;GPSPoint&gt; m_CarShapePolygon;
-	std::vector&lt;WayPoint&gt; m_Path;
-	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_TotalPath;
-	int m_iCurrentTotalPathId;
-	int m_iSafeTrajectory;
-//	int m_iGlobalPathPrevID;
-	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_PredictedPath;
-	std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt; m_RollOuts;
-	std::string carId;
-	Lane* pLane;
-	double m_SimulationSteeringDelayFactor; //second , time that every degree change in the steering wheel takes
-	timespec m_SteerDelayTimer;
-	double m_PredictionTime;
-	double m_CostCalculationTime;
-	double m_BehaviorGenTime;
-	double m_RollOutsGenerationTime;
-
-	BehaviorStateMachine* 		m_pCurrentBehaviorState;
-	ForwardState * 				m_pGoToGoalState;
-	StopState* 					m_pStopState;
-	WaitState* 					m_pWaitState;
-	InitState* 					m_pInitState;
-	MissionAccomplishedState*	m_pMissionCompleteState;
-	GoalState*					m_pGoalState;
-	FollowState*				m_pFollowState;
-	SwerveState*				m_pAvoidObstacleState;
-	TrafficLightStopState*		m_pTrafficLightStopState;
-	TrafficLightWaitState*		m_pTrafficLightWaitState;
-	StopSignStopState* 			m_pStopSignStopState;
-	StopSignWaitState* 			m_pStopSignWaitState;
-
-	TrajectoryCosts m_TrajectoryCostsCalculatotor;
-
-
-
-	//for debugging
-	std::vector&lt;WayPoint&gt; m_PathSection;
-	std::vector&lt;WayPoint&gt; m_SampledPoints;
-
-	void InitBehaviorStates();
-
-	void SetSimulatedTargetOdometryReadings(const double&amp; velocity_d, const double&amp; steering_d, const SHIFT_POS&amp; shift_d)
-	{
-		m_CurrentVelocityD = velocity_d;
-		m_CurrentSteeringD = steering_d;
-		m_CurrentShiftD = shift_d;
-	}
-
-	double GetSimulatedVelocity()
-	{
-		return m_CurrentVelocity;
-	}
-
-	double GetSimulatedSteering()
-	{
-		return m_CurrentSteering;
-	}
-
-	double GetSimulatedShift()
-	{
-		return m_CurrentShift;
-	}
-
-
-	//For Simulation
-	WayPoint m_OdometryState;
-	double m_CurrentVelocity, m_CurrentVelocityD; //meter/second
-	double m_CurrentSteering, m_CurrentSteeringD; //radians
-	SHIFT_POS m_CurrentShift , m_CurrentShiftD;
-
-	double m_CurrentAccSteerAngle; //degrees steer wheel range
-	double m_CurrentAccVelocity; // kilometer/hour
-	//std::vector&lt;TrafficLight&gt; m_TrafficLights;
-
-public:
-
-	LocalPlannerH();
-	virtual ~LocalPlannerH();
-	void Init(const ControllerParams&amp; ctrlParams, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo);
-	void InitPolygons();
-	void FirstLocalizeMe(const WayPoint&amp; initCarPos);
-	void LocalizeMe(const double&amp; dt); // in seconds
-	void UpdateState(const VehicleState&amp; state, const bool&amp; bUseDelay = false);
-	void CalculateImportantParameterForDecisionMaking(const VehicleState&amp; car_state,
-			const int&amp; goalID, const bool&amp; bEmergencyStop, const bool&amp; bGreenTrafficLight,
-			const TrajectoryCost&amp; bestTrajectory);
-
-	BehaviorState DoOneStep(
-			const double&amp; dt,
-			const VehicleState&amp; state,
-			const std::vector&lt;DetectedObject&gt;&amp; obj_list,
-			const int&amp; goalID,
-			RoadNetwork&amp; map,
-			const bool&amp; bEmergencyStop,
-			const bool&amp; bGreenTrafficLight,
-			const bool&amp; bLive = false);
-
-	void SimulateOdoPosition(const double&amp; dt, const VehicleState&amp; vehicleState);
-
-private:
-
-	//Obstacle avoidance functionalities
-	bool CalculateObstacleCosts(RoadNetwork&amp; map, const VehicleState&amp; vstatus, const std::vector&lt;DetectedObject&gt;&amp; obj_list);
-
-	double PredictTimeCostForTrajectory(std::vector&lt;WayPoint&gt;&amp; path,
-			const VehicleState&amp; vstatus,
-			const WayPoint&amp; currState);
-
-	void PredictObstacleTrajectory(RoadNetwork&amp; map,
-			const WayPoint&amp; pos,
-			const double&amp; predTime,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-	bool CalculateIntersectionVelocities(std::vector&lt;WayPoint&gt;&amp; path,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; predctedPath,
-			const DetectedObject&amp; obj);
-
-	bool GetNextTrafficLight(const int&amp; prevTrafficLightId, const std::vector&lt;TrafficLight&gt;&amp; trafficLights, TrafficLight&amp; trafficL);
-	void UpdateCurrentLane(RoadNetwork&amp; map, const double&amp; search_distance);
-	bool SelectSafeTrajectoryAndSpeedProfile(const VehicleState&amp; vehicleState);
-	BehaviorState GenerateBehaviorState(const VehicleState&amp; vehicleState);
-	void TransformPoint(const WayPoint&amp; refPose, GPSPoint&amp; p);
-	void AddAndTransformContourPoints(const DetectedObject&amp; obj, std::vector&lt;WayPoint&gt;&amp; contourPoints);
-	void UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt);
-
-	bool NoWayTest(const double&amp; min_distance, const int&amp; iGlobalPathIndex);
-
-	PlannerHNS::PlanningParams m_params;
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* LOCALPLANNERH_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\plannerh\PlannerH.h" new_path="" added_lines="0" deleted_lines="119">
				<diff>@@ -1,119 +0,0 @@
-/*
- * PlannerH.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#include "RSPlanner.h"
-#include "GridMap.h"
-
-#define START_POINT_MAX_DISTANCE 8 // meters
-#define GOAL_POINT_MAX_DISTANCE 8 // meters
-#define LANE_CHANGE_SMOOTH_FACTOR_DISTANCE 8 // meters
-
-namespace PlannerHNS
-{
-
-enum PLANDIRECTION {MOVE_FORWARD_ONLY, MOVE_BACKWARD_ONLY, 	MOVE_FREE};
-enum HeuristicConstrains {EUCLIDEAN, NEIGBORHOOD,DIRECTION };
-
-class PlannerH
-{
-public:
-	PlannerH();
-	virtual ~PlannerH(); 
-
-
-	/**
-	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles
-	 * @param start: Start position for the trajectory (x,y,theta)
-	 * @param goal:  Goal position (Destination point) (x,y,theta)
-	 * @param map:  2d grid map, ( cost map or occupancy grid.
-	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
-	 * @return path length
-	 */
-	double PlanUsingReedSheppWithObstacleDetection(const WayPoint&amp; start, const WayPoint&amp; goal, GridMap&amp; map, std::vector&lt;WayPoint&gt;&amp; genSmoothedPath,
-			const double pathDensity = 0.25, const double smoothFactor = 12.0);
-
-	/**
-	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles , but if there an obstacle on the trajectory function will fail. , also this function does not guaranteed to generate trajectories
-	 * @param start: Start position for the trajectory (x,y,theta)
-	 * @param goal:  Goal position (Destination point) (x,y,theta)
-	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
-	 * @return path length
-	 */
-	double PlanUsingReedShepp(const WayPoint&amp; start, const WayPoint&amp; goal, std::vector&lt;WayPoint&gt;&amp; generatedPath,
-			const double pathDensity = 0.25, const double smoothFactor = 12.0);
-
-
-	/**
-	 * @brief Generate Roll outs for global generated path
-	 * @param referencePath center lint reference path
-	 * @param carPos current car position
-	 * @param bEnableLaneChange is lane change is available
-	 * @param speed current car speed
-	 * @param microPlanDistance distance limit for roll outs
-	 * @param maxSpeed maximum forward speed
-	 * @param minSpeed minimum forward speed
-	 * @param carTipMargin 1st roll out smoothing parameter
-	 * @param rollInMargin 2nd roll out smoothing parameter
-	 * @param rollInSpeedFactor roll out 3rd smoothing parameter
-	 * @param pathDensity distance between every two waypoints in the generated trajectory
-	 * @param rollOutDensity distance between the center line and adjacent trajectories
-	 * @param rollOutNumber number of sampled trajectories
-	 * @param SmoothDataWeight general smoothing parameter , how smoother keep close to original data 0 - 0.5
-	 * @param SmoothWeight general smoothing parameter, how smoother is trying to pull away to form the shortest and strait line possible
-	 * @param SmoothTolerance performance measure , conjugate gradient conversion factor should be 0.1 - 0.01
-	 * @param speedProfileFactor how car should slow for corners
-	 * @param bHeadingSmooth follow car heading direction or center line path heading for sampling direction
-	 */
-	void GenerateRunoffTrajectory(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; referencePaths, const WayPoint&amp; carPos, const bool&amp; bEnableLaneChange, const double&amp; speed, const double&amp; microPlanDistance,
-				const double&amp; maxSpeed,const double&amp; minSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
-				const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
-				const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
-				const double&amp; SmoothTolerance, const double&amp; speedProfileFactor, const bool&amp; bHeadingSmooth,
-				const int&amp; iCurrGlobalPath, const int&amp; iCurrLocalTraj,
-				std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOutsPaths,
-				std::vector&lt;WayPoint&gt;&amp; sectionPath, std::vector&lt;WayPoint&gt;&amp; sampledPoints);
-
-	/**
-	 * @brief Path planning for structured environment using dynamic programming
-	 * @param lane
-	 * @param carPos
-	 * @param goalPos
-	 * @param prevWayPoint
-	 * @param maxPlanningDistance
-	 * @param globalPath
-	 * @param path
-	 * @return generated path length
-	 */
-	double PlanUsingDP(const WayPoint&amp; carPos,const WayPoint&amp; goalPos,
-			const double&amp; maxPlanningDistance, const bool bEnableLaneChange, const std::vector&lt;int&gt;&amp; globalPath,
-			RoadNetwork&amp; map, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, std::vector&lt;WayPoint*&gt;* all_cell_to_delete = 0);
-
-	 double PlanUsingDPRandom(const WayPoint&amp; start,
-	 		 const double&amp; maxPlanningDistance,
-	 		 RoadNetwork&amp; map,
-	 		 std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-
-	/**
-	 * @brief Return all possible trajectories from current position to max planning distance in all directions
-	 * @param lane
-	 * @param carPos
-	 * @param maxPlanningDistance
-	 * @param paths
-	 * @return
-	 */
-	double PredictPlanUsingDP(Lane* lane, const WayPoint&amp; carPos, const double&amp; maxPlanningDistance,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-	void DeleteWaypoints(std::vector&lt;WayPoint*&gt;&amp; wps);
-
-	//PlanningInternalParams m_Params;
-};
-
-}
-
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\plannerh\PlanningHelpers.h" new_path="" added_lines="0" deleted_lines="170">
				<diff>@@ -1,170 +0,0 @@
-/*
- * PlanningHelpers.h
- *
- *  Created on: Jun 16, 2016
- *      Author: hatem
- */
-
-#ifndef PLANNINGHELPERS_H_
-#define PLANNINGHELPERS_H_
-
-#include &lt;math.h&gt;
-#include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "DataRW.h"
-#include "tinyxml.h"
-
-
-namespace PlannerHNS {
-
-#define distance2points(from , to) sqrt(pow(to.x - from.x, 2) + pow(to.y - from.y, 2))
-#define distance2pointsSqr(from , to) pow(to.x - from.x, 2) + pow(to.y - from.y, 2)
-#define pointNorm(v) sqrt(v.x*v.x + v.y*v.y)
-#define angle2points(from , to) atan2(to.y - from.y, to.x - from.x )
-#define LANE_CHANGE_SPEED_FACTOR 0.5
-#define LANE_CHANGE_COST 3.0 // meters
-#define BACKUP_STRAIGHT_PLAN_DISTANCE 60 //meters
-
-class PlanningHelpers {
-public:
-	PlanningHelpers();
-	virtual ~PlanningHelpers();
-
-	/**
-	 * @brief Find all relative information from the point p to the trajectory such as (perpendicular distance , closest next point , closest back point, distance from perpendicular intersection point to next point, distance from perpendicular intersection point to previous point)
-	 * @param trajectory list of waypoints
-	 * @param p query point
-	 * @param info collection of calculated information
-	 * @param prevIndex initial search index
-	 * @return true if success without errors, false otherwise
-	 */
-	static bool GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex = 0);
-
-	static bool GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectories, const WayPoint&amp; p, const double&amp; searchDistance, RelativeInfo&amp; info);
-
-	/**
-	 * @brief Find point on the trajectory after initial relative point with specific distance
-	 * @param trajectory list of waypoints
-	 * @param init_p initial relative point on trajectory
-	 * @param distance distance from initial relative point to follow point
-	 * @return point on trajectory
-	 */
-	static WayPoint GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; init_p, const double&amp; distance, unsigned int&amp; point_index);
-
-	/**
-	 * @brief Calculate the precise distance from projection of point p2 (relative) to projection of point 1 (relative)
-	 * @param trajectory list of waypoints
-	 * @param p1 first relative point
-	 * @param p2 second relative point
-	 * @return distance on trajectory
-	 */
-	static double GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; p1,const RelativeInfo&amp; p2);
-
-	/**
-	 * @brief Find the closest next point on the trajectory index
-	 * @param trajectory list of waypoints
-	 * @param p query point
-	 * @param prevIndex initial search index
-	 * @return index of the closest next point from trajectory
-	 */
-	static int GetClosestNextPointIndex(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-
-	static int GetClosestNextPointIndexDirection(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-
-
-	static int GetClosestPointIndex_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex = 0 );
-	static WayPoint GetPerpendicularOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, double&amp; distance, const int&amp; prevIndex = 0);
-	static double GetPerpDistanceToTrajectorySimple_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-	static double GetPerpDistanceToVectorSimple_obsolete(const WayPoint&amp; p1, const WayPoint&amp; p2, const WayPoint&amp; pose);
-	static WayPoint GetNextPointOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const double&amp; distance, const int&amp; currIndex = 0);
-	static double GetDistanceOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
-
-
-	static void FixPathDensity(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; distanceDensity);
-	static void SmoothPath(std::vector&lt;WayPoint&gt;&amp; path, double weight_data =0.25,double weight_smooth = 0.25,double tolerance = 0.01);
-	static double CalcCircle(const GPSPoint&amp; pt1, const GPSPoint&amp; pt2, const GPSPoint&amp; pt3, GPSPoint&amp; center);
-	static double CalcAngleAndCost(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0, const bool&amp; bSmooth = true );
-	//static double CalcAngleAndCostSimple(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0);
-	static double CalcAngleAndCostAndCurvatureAnd2D(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0);
-
-	static double GetAccurateDistanceOnTrajectory(std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
-
-	static void ExtractPartFromPointToDistance(const std::vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
-			const double&amp; pathDensity, std::vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance);
-
-	static void CalculateRollInTrajectories(const WayPoint&amp; carPos, const double&amp; speed, const std::vector&lt;WayPoint&gt;&amp; originalCenter, int&amp; start_index,
-			int&amp; end_index, std::vector&lt;double&gt;&amp; end_laterals ,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; rollInPaths, const double&amp; max_roll_distance,
-			const double&amp; maxSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
-			const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
-			const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
-			const double&amp; SmoothTolerance, const bool&amp; bHeadingSmooth,
-			std::vector&lt;WayPoint&gt;&amp; sampledPoints);
-
-
-	static void SmoothSpeedProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
-	static void SmoothCurvatureProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance = 0.1);
-	static void SmoothWayPointsDirections(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
-
-	static void GenerateRecommendedSpeed(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor);
-//	static WayPoint* BuildPlanningSearchTree(Lane* l, const WayPoint&amp; prevWayPointIndex,
-//			const WayPoint&amp; startPos, const WayPoint&amp; goalPos,
-//			const std::vector&lt;int&gt;&amp; globalPath, const double&amp; DistanceLimit,
-//			int&amp; nMaxLeftBranches, int&amp; nMaxRightBranches,
-//			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static WayPoint* BuildPlanningSearchTreeV2(WayPoint* pStart,
-			const WayPoint&amp; goalPos,
-			const std::vector&lt;int&gt;&amp; globalPath, const double&amp; DistanceLimit,
-			const bool&amp; bEnableLaneChange,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static WayPoint* BuildPlanningSearchTreeStraight(WayPoint* pStart,
-			const double&amp; DistanceLimit,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static int PredictiveDP(WayPoint* pStart, const double&amp; DistanceLimit,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete, std::vector&lt;WayPoint*&gt;&amp; end_waypoints);
-
-	static bool CheckLaneIdExits(const std::vector&lt;int&gt;&amp; lanes, const Lane* pL);
-	static WayPoint* CheckLaneExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const Lane* pL);
-	static WayPoint* CheckNodeExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const WayPoint* pL);
-
-	static WayPoint* CreateLaneHeadCell(Lane* pLane, WayPoint* pLeft, WayPoint* pRight,
-			WayPoint* pBack);
-	static double GetLanePoints(Lane* l, const WayPoint&amp; prevWayPointIndex,
-			const double&amp; minDistance , const double&amp; prevCost, std::vector&lt;WayPoint&gt;&amp; points);
-
-	static WayPoint* GetMinCostCell(const std::vector&lt;WayPoint*&gt;&amp; cells, const std::vector&lt;int&gt;&amp; globalPathIds);
-
-	static void TraversePathTreeBackwards(WayPoint* pHead, WayPoint* pStartWP, const std::vector&lt;int&gt;&amp; globalPathIds,
-			std::vector&lt;WayPoint&gt;&amp; localPath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; localPaths);
-
-	static void ExtractPlanAlernatives(const std::vector&lt;WayPoint&gt;&amp; singlePath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; allPaths);
-
-	static std::vector&lt;int&gt; GetUniqueLeftRightIds(const std::vector&lt;WayPoint&gt;&amp; path);
-
-	static bool FindInList(const std::vector&lt;int&gt;&amp; list,const int&amp; x);
-	static void RemoveWithValue(std::vector&lt;int&gt;&amp; list,const int&amp; x);
-
-	static ACTION_TYPE GetBranchingDirection(WayPoint&amp; currWP, WayPoint&amp; nextWP);
-
-	static void CalcContourPointsForDetectedObjects(const WayPoint&amp; currPose, std::vector&lt;DetectedObject&gt;&amp; obj_list, const double&amp; filterDistance = 100);
-
-	static double GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; pose, const double&amp; distance);
-	static bool CompareTrajectories(const std::vector&lt;WayPoint&gt;&amp; path1, const std::vector&lt;WayPoint&gt;&amp; path2);
-
-	static double GetDistanceToClosestStopLineAndCheck(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; p, int&amp; stopLineID,int&amp; stopSignID, int&amp; trafficLightID, const int&amp; prevIndex = 0);
-
-	static void WritePathToFile(const std::string&amp; fileName, const std::vector&lt;WayPoint&gt;&amp; path);
-
-	static void TestQuadraticSpline(const std::vector&lt;WayPoint&gt;&amp; center_line, std::vector&lt;WayPoint&gt;&amp; path);
-	static double frunge ( double x );
-	static double fprunge ( double x );
-	static double fpprunge ( double x );
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* PLANNINGHELPERS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\plannerh\RSPlanner.h" new_path="" added_lines="0" deleted_lines="77">
				<diff>@@ -1,77 +0,0 @@
-/*
- * RSPlanner.h
- *
- *  Created on: Aug 9, 2015
- *      Author: hatem
- */
-
-#include "PlanningHelpers.h"
-#ifndef RSPLANNERSA_H_
-#define RSPLANNERSA_H_
-
-namespace PlannerHNS
-{
-
-#define EPS1 1.0e-12
-#define EPS2 1.0e-12
-#define EPS3 1.0e-12
-#define EPS4 1.0e-12
-#define MYINFINITY 1000000
-
-#define MPI 3.1415926536
-#define MPIMUL2 6.2831853072
-#define MPIDIV2 1.5707963268
-
-
-
-
-class RSPlanner
-{
-public:
-	double RADCURV ;
-	double RADCURVMUL2 ;
-	double RADCURVMUL4 ;
-	double SQRADCURV ;
-	double SQRADCURVMUL2 ;
-	double PATHDENSITY;
-	RSPlanner(double curvatureFactor = 15.6);
-	virtual ~RSPlanner();
-
-	double min_length_rs(const double&amp; x1,const double&amp; y1,const double&amp; t1,const double&amp; x2,const double&amp; y2,const double&amp; t2,int&amp; numero,double&amp; t,double&amp; u,double&amp; v);
-	int constRS(int num,double t,double u,double v,double x1,double y1,double t1,double delta,std::vector&lt;WayPoint&gt;&amp; path);
-
-private:
-	struct ConfigItem
-	{
-		double length;
-		int num;
-		double t,u,v;
-	};
-
-
-	double mod2pi(const double&amp; a);
-	double my_atan2(const double&amp;  y, const double&amp; x);
-	double c_c_c(const double&amp; x,const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_cc(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double cscb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double ccu_cuc(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_cucu_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2sca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2scb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2sc2_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double cc_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csc2_ca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csc2_cb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-
-	double reed_shepp(const double&amp; x1,const double&amp; y1,const double&amp; t1,const double&amp; x2,const double&amp; y2,const double&amp; t2,int&amp; numero,double&amp; tr,double&amp; ur,double&amp; vr);
-
-	int fct_curve(const int&amp; ty,const int&amp; orientation,const double&amp; val,double&amp; x1,double&amp; y1,double&amp; t1,const double&amp; delta,std::vector&lt;WayPoint&gt;&amp; path,int n);
-
-
-
-};
-
-} /* namespace PlannerZNS */
-
-#endif /* RSPLANNER_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\plannerh\RoadNetwork.h" new_path="" added_lines="0" deleted_lines="1018">
				<diff>@@ -1,1018 +0,0 @@
-/*
- * RoadNetwork.h
- *
- *  Created on: May 19, 2016
- *      Author: hatem
- */
-
-#ifndef ROADNETWORK_H_
-#define ROADNETWORK_H_
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;sstream&gt;
-#include "UtilityH.h"
-
-#define OPENPLANNER_ENABLE_LOGS
-
-namespace PlannerHNS
-{
-
-
-enum DIRECTION_TYPE {	FORWARD_DIR, FORWARD_LEFT_DIR, FORWARD_RIGHT_DIR,
-	BACKWARD_DIR, BACKWARD_LEFT_DIR, BACKWARD_RIGHT_DIR, STANDSTILL_DIR};
-
-enum OBSTACLE_TYPE {SIDEWALK, TREE, CAR, TRUCK, HOUSE, PEDESTRIAN, CYCLIST, GENERAL_OBSTACLE};
-
-enum DRIVABLE_TYPE {DIRT, TARMAC, PARKINGAREA, INDOOR, GENERAL_AREA};
-
-enum GLOBAL_STATE_TYPE {G_WAITING_STATE, G_PLANING_STATE, G_FORWARD_STATE, G_BRANCHING_STATE, G_FINISH_STATE};
-
-enum STATE_TYPE {INITIAL_STATE, WAITING_STATE, FORWARD_STATE, STOPPING_STATE, EMERGENCY_STATE,
-	TRAFFIC_LIGHT_STOP_STATE,TRAFFIC_LIGHT_WAIT_STATE, STOP_SIGN_STOP_STATE, STOP_SIGN_WAIT_STATE, FOLLOW_STATE, LANE_CHANGE_STATE, OBSTACLE_AVOIDANCE_STATE, GOAL_STATE, FINISH_STATE};
-
-enum LIGHT_INDICATOR {INDICATOR_LEFT, INDICATOR_RIGHT, INDICATOR_BOTH , INDICATOR_NONE};
-
-enum SHIFT_POS {SHIFT_POS_PP = 0x60, SHIFT_POS_RR = 0x40, SHIFT_POS_NN = 0x20,
-	SHIFT_POS_DD = 0x10, SHIFT_POS_BB = 0xA0, SHIFT_POS_SS = 0x0f, SHIFT_POS_UU = 0xff };
-
-enum ACTION_TYPE {FORWARD_ACTION, BACKWARD_ACTION, STOP_ACTION, LEFT_TURN_ACTION,
-	RIGHT_TURN_ACTION, U_TURN_ACTION, SWERVE_ACTION, OVERTACK_ACTION};
-
-
-class Lane;
-class TrafficLight;
-
-class ObjTimeStamp
-{
-public:
-	timespec tStamp;
-
-	ObjTimeStamp()
-	{
-		tStamp.tv_nsec = 0;
-		tStamp.tv_sec = 0;
-	}
-};
-
-class POINT2D
-{
-public:
-    double x;
-    double y;
-    double z;
-    POINT2D()
-    {
-      x=0;y=0;z=0;
-    }
-    POINT2D(double px, double py, double pz = 0)
-    {
-      x = px;
-      y = py;
-      z = pz;
-    }
-};
-
-
-
-class RECTANGLE
-
-{
-public:
-  POINT2D bottom_left;
-  POINT2D top_right;
-  double width;
-  double length;
-  bool bObstacle;
-
-
-  inline bool PointInRect(POINT2D p)
-  {
-    return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
-  }
-
-  inline bool HitTest(POINT2D p)
-  {
-    return PointInRect(p) &amp;&amp; bObstacle;
-  }
-
-  RECTANGLE()
-  {
-	  width=0;
-	  length = 0;
-    bObstacle = true;
-  }
-
-  virtual ~RECTANGLE(){}
-};
-
-class GPSPoint
-{
-public:
-	double lat, x;
-	double lon, y;
-	double alt, z;
-	double dir, a;
-
-	GPSPoint()
-	{
-		lat = x = 0;
-		lon = y = 0;
-		alt = z = 0;
-		dir = a = 0;
-	}
-
-	GPSPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
-	{
-		this-&gt;x = x;
-		this-&gt;y = y;
-		this-&gt;z = z;
-		this-&gt;a = a;
-
-		lat = 0;
-		lon = 0;
-		alt = 0;
-		dir = 0;
-	}
-
-	std::string ToString()
-	{
-		std::stringstream str;
-		str.precision(12);
-		str &lt;&lt; "X:" &lt;&lt; x &lt;&lt; ", Y:" &lt;&lt; y &lt;&lt; ", Z:" &lt;&lt; z &lt;&lt; ", A:" &lt;&lt; a &lt;&lt; std::endl;
-		str &lt;&lt; "Lon:" &lt;&lt; lon &lt;&lt; ", Lat:" &lt;&lt; lat &lt;&lt; ", Alt:" &lt;&lt; alt &lt;&lt; ", Dir:" &lt;&lt; dir &lt;&lt; std::endl;
-		return str.str();
-	}
-};
-
-class PolygonShape
-{
-public:
-	std::vector&lt;GPSPoint&gt; points;
-
-	inline int PointInsidePolygon(const PolygonShape&amp; polygon,const GPSPoint&amp; p)
-	{
-		int counter = 0;
-		  int i;
-		  double xinters;
-		  GPSPoint p1,p2;
-		  int N = polygon.points.size();
-		  if(N &lt;=0 ) return -1;
-
-		  p1 = polygon.points.at(0);
-		  for (i=1;i&lt;=N;i++)
-		  {
-		    p2 = polygon.points.at(i % N);
-
-		    if (p.y &gt; MIN(p1.y,p2.y))
-		    {
-		      if (p.y &lt;= MAX(p1.y,p2.y))
-		      {
-		        if (p.x &lt;= MAX(p1.x,p2.x))
-		        {
-		          if (p1.y != p2.y)
-		          {
-		            xinters = (p.y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
-		            if (p1.x == p2.x || p.x &lt;= xinters)
-		              counter++;
-		          }
-		        }
-		      }
-		    }
-		    p1 = p2;
-		  }
-
-		  if (counter % 2 == 0)
-		    return 0;
-		  else
-		    return 1;
-	}
-};
-
-class MapItem
-{
-public:
-  int id;
-  POINT2D sp; //start point
-  POINT2D ep; // end point
-  GPSPoint center;
-  double c; //curvature
-  double w; //width
-  double l; //length
-  std::string fileName; //
-  std::vector&lt;POINT2D&gt; polygon;
-
-
-  MapItem(int ID, POINT2D start, POINT2D end, double curvature, double width, double length, std::string objName)
-  {
-    id = ID;
-    sp = start;
-    ep = end;
-    c = curvature;
-    w = width;
-    l = length;
-    fileName = objName;
-
-  }
-
-  MapItem()
-  {
-    id = 0; c = 0; w = 0; l = 0;
-  }
-
-  virtual ~MapItem(){}
-
-  MapItem(const MapItem &amp; cmi)
-  {
-        id = cmi.id;
-        sp = cmi.sp;
-        ep = cmi.ep;
-        c = cmi.c;
-        w = cmi.w;
-        l = cmi.l;
-        fileName = cmi.fileName;
-  }
-  MapItem &amp;operator=(const MapItem &amp;cmi)
-  {
-    this-&gt;id = cmi.id;
-      this-&gt;sp = cmi.sp;
-      this-&gt;ep = cmi.ep;
-      this-&gt;c = cmi.c;
-      this-&gt;w = cmi.w;
-      this-&gt;l = cmi.l;
-      this-&gt;fileName = cmi.fileName;
-      return *this;
-  }
-
-  virtual int operator==(const MapItem &amp;mi) const
-    {
-      return this-&gt;id == mi.id;
-    }
-};
-
-class Obstacle : public MapItem
-{
-  public:
-    OBSTACLE_TYPE t;
-
-    Obstacle(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,OBSTACLE_TYPE type, std::string fileName ) : MapItem(ID, start, end, curvature, width, length, fileName)
-  {
-      t = type;
-  }
-    virtual ~Obstacle()
-    {
-    }
-
-    Obstacle() : MapItem()
-       {
-      t = SIDEWALK;
-       }
-
-    Obstacle(const Obstacle&amp; ob) : MapItem(ob)
-      {
-        t = ob.t;
-      }
-
-    Obstacle&amp; operator=(const Obstacle&amp; ob)
-      {
-      this-&gt;id = ob.id;
-      this-&gt;sp = ob.sp;
-      this-&gt;ep = ob.ep;
-      this-&gt;c = ob.c;
-      this-&gt;w = ob.w;
-      this-&gt;l = ob.l;
-      this-&gt;t = ob.t;
-      this-&gt;fileName = ob.fileName;
-      return *this;
-      }
-
-      virtual int operator==(const Obstacle &amp;ob) const
-          {
-            return this-&gt;id == ob.id &amp;&amp; this-&gt;t == ob.t;
-          }
-};
-
-class DrivableArea : public MapItem
-{
-public:
-  DRIVABLE_TYPE t; // drivable area type
-
-  DrivableArea(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,DRIVABLE_TYPE type, std::string fileName ) : MapItem( ID, start, end, curvature, width, length, fileName)
-  {
-    t = type;
-  }
-
-  virtual ~DrivableArea()
-  {
-
-  }
-
-  DrivableArea() : MapItem()
-    {
-      t = PARKINGAREA;
-    }
-
-  DrivableArea(const DrivableArea&amp; da) : MapItem(da)
-  {
-    t = da.t;
-  }
-
-  DrivableArea&amp; operator=(const DrivableArea&amp; da)
-  {
-    this-&gt;id = da.id;
-    this-&gt;sp = da.sp;
-    this-&gt;ep = da.ep;
-    this-&gt;c = da.c;
-    this-&gt;w = da.w;
-    this-&gt;l = da.l;
-    this-&gt;t = da.t;
-    this-&gt;fileName = da.fileName;
-    return *this;
-  }
-
-  virtual int operator==(const DrivableArea &amp;da) const
-      {
-        return this-&gt;id == da.id &amp;&amp; this-&gt;t == da.t;
-      }
-
-};
-
-
-
-class Rotation
-{
-public:
-	double x;
-	double y;
-	double z;
-	double w;
-
-	Rotation()
-	{
-		x = 0;
-		y = 0;
-		z = 0;
-		w = 0;
-	}
-};
-
-class WayPoint
-{
-public:
-	GPSPoint	pos;
-	Rotation 	rot;
-	double  	v;
-	double  	cost;
-	double  	timeCost;
-	double  	totalReward;
-	double  	collisionCost;
-	double 		laneChangeCost;
-	int 		laneId;
-	int 		id;
-	int 		LeftLaneId;
-	int 		RightLaneId;
-	int 		stopLineID;
-	DIRECTION_TYPE bDir;
-
-	Lane* pLane;
-	WayPoint* pLeft;
-	WayPoint* pRight;
-	std::vector&lt;int&gt; 	toIds;
-	std::vector&lt;int&gt; 	fromIds;
-	std::vector&lt;WayPoint*&gt; pFronts;
-	std::vector&lt;WayPoint*&gt; pBacks;
-	std::vector&lt;std::pair&lt;ACTION_TYPE, double&gt; &gt; actionCost;
-
-	WayPoint()
-	{
-		id = 0;
-		v = 0;
-		cost = 0;
-		laneId = -1;
-		pLane  = 0;
-		pLeft = 0;
-		pRight = 0;
-		bDir = FORWARD_DIR;
-		LeftLaneId = 0;
-		RightLaneId = 0;
-		timeCost = 0;
-		totalReward = 0;
-		collisionCost = 0;
-		laneChangeCost = 0;
-		stopLineID = -1;
-	}
-
-	WayPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
-	{
-		pos.x = x;
-		pos.y = y;
-		pos.z = z;
-		pos.a = a;
-
-		id = 0;
-		v = 0;
-		cost = 0;
-		laneId = -1;
-		pLane  = 0;
-		pLeft = 0;
-		pRight = 0;
-		bDir = FORWARD_DIR;
-		LeftLaneId = 0;
-		RightLaneId = 0;
-		timeCost = 0;
-		totalReward = 0;
-		collisionCost = 0;
-		laneChangeCost = 0;
-		stopLineID = -1;
-	}
-};
-
-class RelativeInfo
-{
-public:
-	double perp_distance;
-	double to_front_distance; //negative
-	double from_back_distance;
-	int iFront;
-	int iBack;
-	int iGlobalPath;
-	WayPoint perp_point;
-	double angle_diff; // degrees
-
-	RelativeInfo()
-	{
-		perp_distance = 0;
-		to_front_distance = 0;
-		from_back_distance = 0;
-		iFront = 0;
-		iBack = 0;
-		iGlobalPath = 0;
-		angle_diff = 0;
-	}
-};
-
-class StopLine
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-	int trafficLightID;
-	int stopSignID;
-	std::vector&lt;GPSPoint&gt; points;
-	Lane* pLane;
-
-	StopLine()
-	{
-		id    = 0;
-		laneId =0;
-		roadId =0;
-		pLane = 0;
-		trafficLightID = -1;
-		stopSignID = -1;
-	}
-};
-
-class WaitingLine
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-	std::vector&lt;GPSPoint&gt; points;
-	Lane* pLane;
-
-	WaitingLine()
-	{
-		id    = 0;
-		laneId =0;
-		roadId =0;
-		pLane = 0;
-	}
-};
-
-enum TrafficSignTypes {UNKNOWN_SIGN, STOP_SIGN, MAX_SPEED_SIGN, MIN_SPEED_SIGN};
-
-class TrafficSign
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-
-	GPSPoint pos;
-	TrafficSignTypes signType;
-	double value;
-	double fromValue;
-	double toValue;
-	std::string strValue;
-	timespec timeValue;
-	timespec fromTimeValue;
-	timespec toTimeValue;
-
-	Lane* pLane;
-
-	TrafficSign()
-	{
-		id    		= 0;
-		laneId 		= 0;
-		roadId		= 0;
-		signType  	= UNKNOWN_SIGN;
-		value		= 0;
-		fromValue	= 0;
-		toValue		= 0;
-//		timeValue	= 0;
-//		fromTimeValue = 0;
-//		toTimeValue	= 0;
-		pLane 		= 0;
-	}
-};
-
-enum TrafficLightState {UNKNOWN_LIGHT, RED_LIGHT, GREEN_LIGHT, YELLOW_LIGHT, LEFT_GREEN, FORWARD_GREEN, RIGHT_GREEN, FLASH_YELLOW, FLAH_RED};
-
-class TrafficLight
-{
-public:
-	int id;
-	GPSPoint pos;
-	TrafficLightState lightState;
-	double stoppingDistance;
-	std::vector&lt;int&gt; laneIds;
-	std::vector&lt;Lane*&gt; pLanes;
-
-	TrafficLight()
-	{
-		stoppingDistance = 2;
-		id 			= 0;
-		lightState	= GREEN_LIGHT;
-	}
-
-	bool CheckLane(const int&amp; laneId)
-	{
-		for(unsigned int i=0; i &lt; laneIds.size(); i++)
-		{
-			if(laneId == laneIds.at(i))
-				return true;
-		}
-		return false;
-	}
-};
-
-enum RoadSegmentType {NORMAL_ROAD, INTERSECTION_ROAD, UTURN_ROAD, EXIT_ROAD, MERGE_ROAD, HIGHWAY_ROAD};
-
-class RoadSegment
-{
-public:
-	int id;
-	RoadSegmentType roadType;
-	std::vector&lt;int&gt; fromIds;
-	std::vector&lt;int&gt; toIds;
-	std::vector&lt;Lane&gt; Lanes;
-
-
-	std::vector&lt;RoadSegment*&gt; fromLanes;
-	std::vector&lt;RoadSegment*&gt; toLanes;
-
-	RoadSegment()
-	{
-		id = 0;
-		roadType = NORMAL_ROAD;
-	}
-
-
-};
-
-enum LaneType{NORMAL_LANE, MERGE_LANE, EXIT_LANE, BUS_LANE, BUS_STOP_LANE, EMERGENCY_LANE};
-
-class Lane
-{
-public:
-	int id;
-	int roadId;
-	int areaId;
-	int fromAreaId;
-	int toAreaId;
-	std::vector&lt;int&gt; fromIds;
-	std::vector&lt;int&gt; toIds;
-	int num; //lane number in the road segment from left to right
-	double speed;
-	double length;
-	double dir;
-	LaneType type;
-	std::vector&lt;TrafficSign&gt; signs;
-	std::vector&lt;WayPoint&gt; points;
-	std::vector&lt;TrafficLight&gt; trafficlights;
-	std::vector&lt;StopLine&gt; stopLines;
-	WaitingLine waitingLine;
-
-	std::vector&lt;Lane*&gt; fromLanes;
-	std::vector&lt;Lane*&gt; toLanes;
-	Lane* pLeftLane;
-	Lane* pRightLane;
-
-	RoadSegment * pRoad;
-
-	Lane()
-	{
-		id 		= 0;
-		num		= 0;
-		speed 	= 0;
-		length 	= 0;
-		dir		= 0;
-		type 	= NORMAL_LANE;
-		pLeftLane = 0;
-		pRightLane = 0;
-		pRoad	= 0;
-		roadId = 0;
-		areaId = 0;
-		fromAreaId = 0;
-		toAreaId = 0;
-	}
-
-};
-
-class RoadNetwork
-{
-public:
-	std::vector&lt;RoadSegment&gt; roadSegments;
-	std::vector&lt;TrafficLight&gt; trafficLights;
-	std::vector&lt;StopLine&gt; stopLines;
-
-};
-
-class VehicleState : public ObjTimeStamp
-{
-public:
-	double speed;
-	double steer;
-	SHIFT_POS shift;
-
-	VehicleState()
-	{
-		speed = 0;
-		steer = 0;
-		shift = SHIFT_POS_NN;
-	}
-
-};
-
-class BehaviorState
-{
-public:
-	STATE_TYPE state;
-	double maxVelocity;
-	double minVelocity;
-	double stopDistance;
-	double followVelocity;
-	double followDistance;
-	LIGHT_INDICATOR indicator;
-	bool bNewPlan;
-
-
-	BehaviorState()
-	{
-		state = INITIAL_STATE;
-		maxVelocity = 0;
-		minVelocity = 0;
-		stopDistance = 0;
-		followVelocity = 0;
-		followDistance = 0;
-		indicator  = INDICATOR_NONE;
-		bNewPlan = false;
-
-	}
-
-};
-
-class DetectedObject
-{
-public:
-	int id;
-	OBSTACLE_TYPE t;
-	WayPoint center;
-	WayPoint predicted_center;
-	std::vector&lt;GPSPoint&gt; contour;
-	double w;
-	double l;
-	double h;
-	double distance_to_center;
-	DetectedObject()
-	{
-		id = 0;
-		w = 0;
-		l = 0;
-		h = 0;
-		t = GENERAL_OBSTACLE;
-		distance_to_center = 0;
-	}
-
-};
-
-class PlanningParams
-{
-public:
-	double 	maxSpeed;
-	double 	minSpeed;
-	double 	planningDistance;
-	double 	microPlanDistance;
-	double 	carTipMargin;
-	double 	rollInMargin;
-	double 	rollInSpeedFactor;
-	double 	pathDensity;
-	double 	rollOutDensity;
-	int 	rollOutNumber;
-	double 	horizonDistance;
-	double 	minFollowingDistance; //should be bigger than Distance to follow
-	double 	minDistanceToAvoid; // should be smaller than minFollowingDistance and larger than maxDistanceToAvoid
-	double	maxDistanceToAvoid; // should be smaller than minDistanceToAvoid
-	double 	speedProfileFactor;
-	double 	smoothingDataWeight;
-	double 	smoothingSmoothWeight;
-	double 	smoothingToleranceError;
-
-	double verticalSafetyDistance;
-	double horizontalSafetyDistancel;
-
-	bool 	enableLaneChange;
-	bool 	enableSwerving;
-	bool 	enableFollowing;
-	bool 	enableHeadingSmoothing;
-	bool 	enableTrafficLightBehavior;
-	bool 	enableStopSignBehavior;
-
-	bool 	enabTrajectoryVelocities;
-
-	PlanningParams()
-	{
-		maxSpeed 						= 3;
-		minSpeed 						= 0;
-		planningDistance 				= 10000;
-		microPlanDistance 				= 30;
-		carTipMargin					= 4.0;
-		rollInMargin					= 12.0;
-		rollInSpeedFactor				= 0.25;
-		pathDensity						= 0.25;
-		rollOutDensity					= 0.5;
-		rollOutNumber					= 4;
-		horizonDistance					= 120;
-		minFollowingDistance			= 35;
-		minDistanceToAvoid				= 15;
-		maxDistanceToAvoid				= 5;
-		speedProfileFactor				= 1.0;
-		smoothingDataWeight				= 0.45;
-		smoothingSmoothWeight			= 0.3;
-		smoothingToleranceError			= 0.05;
-
-		verticalSafetyDistance 			= 0.0;
-		horizontalSafetyDistancel		= 0.0;
-
-		enableHeadingSmoothing			= false;
-		enableSwerving 					= false;
-		enableFollowing					= false;
-		enableTrafficLightBehavior		= false;
-		enableLaneChange 				= false;
-		enableStopSignBehavior			= false;
-		enabTrajectoryVelocities		= false;
-	}
-};
-
-class HMIPreCalculatedConditions
-{
-public:
-
-	HMIPreCalculatedConditions()
-	{
-
-	}
-};
-
-class PreCalculatedConditions
-{
-public:
-	//-------------------------------------------//
-	//Global Goals
-	int 				currentGoalID;
-	int 				prevGoalID;
-	//-------------------------------------------//
-	//Following
-	double 				distanceToNext;
-	double				velocityOfNext;
-	//-------------------------------------------//
-	//For Lane Change
-	int 				iPrevSafeLane;
-	int 				iCurrSafeLane;
-	double				distanceToGoBack;
-	double 				timeToGoBack;
-	double 				distanceToChangeLane;
-	double				timeToChangeLane;
-	int 				currentLaneID;
-	int 				originalLaneID;
-	int 				targetLaneID;
-	bool 				bUpcomingLeft;
-	bool 				bUpcomingRight;
-	bool				bCanChangeLane;
-	bool				bTargetLaneSafe;
-	//-------------------------------------------//
-	//Traffic Lights &amp; Stop Sign
-	int 				currentStopSignID;
-	int 				prevStopSignID;
-	int 				currentTrafficLightID;
-	int 				prevTrafficLightID;
-	bool 				bTrafficIsRed; //On , off status
-	//-------------------------------------------//
-	//Swerving
-	int 				iPrevSafeTrajectory;
-	int 				iCurrSafeTrajectory;
-	int 				iCentralTrajectory;
-	bool				bFullyBlock;
-	LIGHT_INDICATOR 	indicator;
-
-	//-------------------------------------------//
-	//General
-	bool 				bNewGlobalPath;
-	bool 				bRePlan;
-	double 				currentVelocity;
-	double				minStoppingDistance; //comfortably
-	int 				bOutsideControl; // 0 waiting, 1 start, 2 Green Traffic Light, 3 Red Traffic Light, 5 Emergency Stop
-	bool				bGreenOutsideControl;
-	std::vector&lt;double&gt; stoppingDistances;
-
-
-	double distanceToStop()
-	{
-		if(stoppingDistances.size()==0) return 0;
-		double minS = stoppingDistances.at(0);
-		for(unsigned int i=0; i&lt; stoppingDistances.size(); i++)
-		{
-			if(stoppingDistances.at(i) &lt; minS)
-				minS = stoppingDistances.at(i);
-		}
-		return minS;
-	}
-
-	PreCalculatedConditions()
-	{
-		currentGoalID 			= 0;
-		prevGoalID				= -1;
-		currentVelocity 		= 0;
-		minStoppingDistance		= 1;
-		bOutsideControl			= 0;
-		bGreenOutsideControl	= false;
-		//distance to stop
-		distanceToNext			= -1;
-		velocityOfNext			= 0;
-		currentStopSignID		= -1;
-		prevStopSignID			= -1;
-		currentTrafficLightID	= -1;
-		prevTrafficLightID		= -1;
-		bTrafficIsRed			= false;
-		iCurrSafeTrajectory		= -1;
-		bFullyBlock				= false;
-
-		iPrevSafeTrajectory		= -1;
-		iCentralTrajectory		= -1;
-		bRePlan					= false;
-		bNewGlobalPath			= false;
-
-		bCanChangeLane			= false;
-		distanceToGoBack		= 0;
-		timeToGoBack			= 0;
-		distanceToChangeLane	= 0;
-		timeToChangeLane		= 0;
-		bTargetLaneSafe			= true;
-		bUpcomingLeft			= false;
-		bUpcomingRight			= false;
-		targetLaneID			= -1;
-		currentLaneID			= -1;
-		originalLaneID			= -1;
-		iCurrSafeLane 			= -1;
-		iPrevSafeLane			= -1;
-
-		indicator 				= INDICATOR_NONE;
-	}
-
-	virtual ~PreCalculatedConditions(){}
-
-	std::string ToStringHeader()
-	{
-		return "Time:General&gt;&gt;:currentVelocity:distanceToStop:minStoppingDistance:bStartBehaviorGenerator:bGoalReached:"
-				"Following&gt;&gt;:velocityOfNext:distanceToNext:"
-				"TrafficLight&gt;&gt;:currentTrafficLightID:bTrafficIsRed:"
-				"Swerving&gt;&gt;:iSafeTrajectory:bFullyBlock:";
-	}
-
-	std::string ToString(STATE_TYPE beh)
-	{
-		std::string str = "Unknown";
-		switch(beh)
-		{
-		case PlannerHNS::INITIAL_STATE:
-			str = "Init";
-			break;
-		case PlannerHNS::WAITING_STATE:
-			str = "Waiting";
-			break;
-		case PlannerHNS::FORWARD_STATE:
-			str = "Forward";
-			break;
-		case PlannerHNS::STOPPING_STATE:
-			str = "Stop";
-			break;
-		case PlannerHNS::FINISH_STATE:
-			str = "End";
-			break;
-		case PlannerHNS::FOLLOW_STATE:
-			str = "Follow";
-			break;
-		case PlannerHNS::OBSTACLE_AVOIDANCE_STATE:
-			str = "Swerving";
-			break;
-		case PlannerHNS::TRAFFIC_LIGHT_STOP_STATE:
-			str = "Light Stop";
-			break;
-		case PlannerHNS::TRAFFIC_LIGHT_WAIT_STATE:
-			str = "Light Wait";
-			break;
-		case PlannerHNS::STOP_SIGN_STOP_STATE:
-			str = "Sign Stop";
-			break;
-		case PlannerHNS::STOP_SIGN_WAIT_STATE:
-			str = "Sign Wait";
-			break;
-		default:
-			str = "Unknown";
-			break;
-		}
-
-		return str;
-	}
-};
-
-class TrajectoryCost
-{
-public:
-	int index;
-	int relative_index;
-	double closest_obj_velocity;
-	double distance_from_center;
-	double priority_cost; //0 to 1
-	double transition_cost; // 0 to 1
-	double closest_obj_cost; // 0 to 1
-	double cost;
-	double closest_obj_distance;
-
-	int lane_index;
-	double lane_change_cost;
-	double lateral_cost;
-	double longitudinal_cost;
-	bool bBlocked;
-	std::vector&lt;std::pair&lt;int, double&gt; &gt; lateral_costs;
-
-
-	TrajectoryCost()
-	{
-		lane_index = -1;
-		index = -1;
-		relative_index = -100;
-		closest_obj_velocity = 0;
-		priority_cost = 0;
-		transition_cost = 0;
-		closest_obj_cost = 0;
-		distance_from_center = 0;
-		cost = 0;
-		closest_obj_distance = -1;
-		lane_change_cost = 0;
-		lateral_cost = 0;
-		longitudinal_cost = 0;
-		bBlocked = false;
-	}
-
-	std::string ToString()
-	{
-		std::ostringstream str;
-		str.precision(4);
-		str &lt;&lt; "LaneIndex    : " &lt;&lt; lane_index;
-		str &lt;&lt; ", Index      : " &lt;&lt; relative_index;
-		str &lt;&lt; ", TotalCost  : " &lt;&lt; cost;
-		str &lt;&lt; ", Priority   : " &lt;&lt; priority_cost;
-		str &lt;&lt; ", Transition : " &lt;&lt; transition_cost;
-		str &lt;&lt; ", Lateral    : " &lt;&lt; lateral_cost;
-		str &lt;&lt; ", Longitu    : " &lt;&lt; longitudinal_cost;
-		str &lt;&lt; ", LaneChange : " &lt;&lt; lane_change_cost;
-		str &lt;&lt; ", Blocked    : " &lt;&lt; bBlocked;
-		str &lt;&lt; "\n";
-		for (unsigned int i=0; i&lt;lateral_costs.size(); i++ )
-		{
-			str &lt;&lt; " - (" &lt;&lt; lateral_costs.at(i).first &lt;&lt; ", " &lt;&lt; lateral_costs.at(i).second &lt;&lt; ")";
-		}
-
-		return str.str();
-
-	}
-};
-
-}
-
-
-#endif /* ROADNETWORK_H_ */
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\plannerh\TrajectoryCosts.h" new_path="" added_lines="0" deleted_lines="50">
				<diff>@@ -1,50 +0,0 @@
-/*
- * TrajectoryCosts.h
- *
- *  Created on: Dec 14, 2016
- *      Author: user
- */
-
-#ifndef TRAJECTORYCOSTS_H_
-#define TRAJECTORYCOSTS_H_
-
-#include "RoadNetwork.h"
-#include "PlannerCommonDef.h"
-#include "PlanningHelpers.h"
-
-using namespace std;
-
-namespace PlannerHNS
-{
-
-class TrajectoryCosts
-{
-public:
-	TrajectoryCosts();
-	virtual ~TrajectoryCosts();
-
-	TrajectoryCost DoOneStep(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths,
-			const WayPoint&amp; currState, const int&amp; currTrajectoryIndex, const int&amp; currLaneIndex, const PlanningParams&amp; params,
-			const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-
-public:
-	int m_PrevCostIndex;
-	vector&lt;TrajectoryCost&gt; m_TrajectoryCosts;
-	PlanningParams m_Params;
-	PolygonShape m_SafetyBorder;
-	//vector&lt;GPSPoint&gt; m_SafetyBox;
-
-
-
-private:
-	bool ValidateRollOutsInput(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts);
-	vector&lt;TrajectoryCost&gt; CalculatePriorityAndLaneChangeCosts(const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; laneRollOuts, const int&amp; lane_index, const PlanningParams&amp; params);
-	void NormalizeCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts);
-	void CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths, const WayPoint&amp; currState, const vector&lt;WayPoint&gt;&amp; contourPoints, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState);
-	void CalculateTransitionCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const int&amp; currTrajectoryIndex, const PlanningParams&amp; params);
-
-};
-
-}
-
-#endif /* TRAJECTORYCOSTS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\include\way_planner_core.h" new_path="ros\src\computing\planning\mission\packages\way_planner\include\way_planner_core.h" added_lines="1" deleted_lines="1">
				<diff>@@ -60,7 +60,7 @@
 
 #include &lt;std_msgs/Int8.h&gt;
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "waypoint_follower/LaneArray.h"
+#include "waypoint_follower_msgs/LaneArray.h"
 #include "vehicle_socket/CanInfo.h"
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\RosHelpers.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\RosHelpers.cpp" added_lines="11" deleted_lines="11">
				<diff>@@ -42,13 +42,13 @@ void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::s
 }
 
 void RosHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path,
-		waypoint_follower::LaneArray&amp; laneArray)
+		waypoint_follower_msgs::LaneArray&amp; laneArray)
 {
-	waypoint_follower::lane l;
+	waypoint_follower_msgs::lane l;
 
 	for(unsigned int i=0; i &lt; path.size(); i++)
 	{
-		waypoint_follower::waypoint wp;
+		waypoint_follower_msgs::waypoint wp;
 		wp.pose.pose.position.x = path.at(i).x;
 		wp.pose.pose.position.y = path.at(i).y;
 		wp.pose.pose.position.z = path.at(i).z;
@@ -63,13 +63,13 @@ void RosHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(const std::vector
 }
 
 void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
-		waypoint_follower::LaneArray&amp; laneArray)
+		waypoint_follower_msgs::LaneArray&amp; laneArray)
 {
-	waypoint_follower::lane l;
+	waypoint_follower_msgs::lane l;
 
 	for(unsigned int i=0; i &lt; path.size(); i++)
 	{
-		waypoint_follower::waypoint wp;
+		waypoint_follower_msgs::waypoint wp;
 		wp.pose.pose.position.x = path.at(i).pos.x;
 		wp.pose.pose.position.y = path.at(i).pos.y;
 		wp.pose.pose.position.z = path.at(i).pos.z;
@@ -109,7 +109,7 @@ void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;Plann
 void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const PlannerHNS::RoadNetwork&amp; map,	visualization_msgs::MarkerArray&amp; markerArray)
 {
 	markerArray.markers.clear();
-	waypoint_follower::LaneArray map_lane_array;
+	waypoint_follower_msgs::LaneArray map_lane_array;
 	for(unsigned int i = 0; i&lt; map.roadSegments.size(); i++)
 		for(unsigned int j = 0; j &lt; map.roadSegments.at(i).Lanes.size(); j++)
 			RosHelpers::ConvertFromPlannerHToAutowarePathFormat(map.roadSegments.at(i).Lanes.at(j).points, map_lane_array);
@@ -173,7 +173,7 @@ void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const Planne
 			  ns_id &lt;&lt; map.stopLines.at(i).id;
 			  stop_waypoint_marker.ns =ns_id.str();
 
-			  waypoint_follower::LaneArray lane_array_2;
+			  waypoint_follower_msgs::LaneArray lane_array_2;
 			  RosHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(map.stopLines.at(i).points, lane_array_2);
 
 			  stop_waypoint_marker.points.clear();
@@ -346,7 +346,7 @@ void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vec
 }
 
 void RosHelpers::createGlobalLaneArrayMarker(std_msgs::ColorRGBA color,
-		const waypoint_follower::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray)
+		const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray)
 {
   visualization_msgs::Marker lane_waypoint_marker;
   lane_waypoint_marker.header.frame_id = "map";
@@ -377,7 +377,7 @@ void RosHelpers::createGlobalLaneArrayMarker(std_msgs::ColorRGBA color,
 
 }
 
-void RosHelpers::createGlobalLaneArrayVelocityMarker(const waypoint_follower::LaneArray &amp;lane_waypoints_array
+void RosHelpers::createGlobalLaneArrayVelocityMarker(const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array
 		, visualization_msgs::MarkerArray&amp; markerArray)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
@@ -425,7 +425,7 @@ void RosHelpers::createGlobalLaneArrayVelocityMarker(const waypoint_follower::La
                                        tmp_marker_array.markers.end());
 }
 
-void RosHelpers::createGlobalLaneArrayOrientationMarker(const waypoint_follower::LaneArray &amp;lane_waypoints_array
+void RosHelpers::createGlobalLaneArrayOrientationMarker(const waypoint_follower_msgs::LaneArray &amp;lane_waypoints_array
 		, visualization_msgs::MarkerArray&amp; markerArray)
 {
   visualization_msgs::MarkerArray tmp_marker_array;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -34,7 +34,7 @@
  * @param Start_Position in simulation environment like rviz, this node require the user to select start position using "2D Pose Estimate" button and select starting position from the global path, //
  * if localization node is working and ndt_pose or curr_pose messages are published the node will use localization as starting position instead of "2D Pose Estimate"
  * @param Goal_Position destination to generate global plan to. if "replan" option selection used can choose multiple goal positions. goal positions are selected from Rviz using "2D Nav Goal" button.
- * @return global , reference path as list of waypoints. data type is "waypoint_follower::LaneArray" , and the topic name is "lane_waypoints_array"
+ * @return global , reference path as list of waypoints. data type is "waypoint_follower_msgs::LaneArray" , and the topic name is "lane_waypoints_array"
  */
 
 #include &lt;ros/ros.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -89,7 +89,7 @@ way_planner_core::way_planner_core()
 	m_OriginPos.position.y  = transform.getOrigin().y();
 	m_OriginPos.position.z  = transform.getOrigin().z();
 
-	pub_Paths = nh.advertise&lt;waypoint_follower::LaneArray&gt;("lane_waypoints_array", 1, true);
+	pub_Paths = nh.advertise&lt;waypoint_follower_msgs::LaneArray&gt;("lane_waypoints_array", 1, true);
 	pub_PathsRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("global_waypoints_rviz", 1, true);
 	pub_StartPointRviz = nh.advertise&lt;visualization_msgs::Marker&gt;("Global_StartPoint_rviz", 1, true);
 	pub_GoalPointRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("Global_GoalPoints_rviz", 1, true);
@@ -436,7 +436,7 @@ if(m_params.bEnableHMI)
 
 void way_planner_core::VisualizeAndSend(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; generatedTotalPaths)
 {
-	waypoint_follower::LaneArray lane_array;
+	waypoint_follower_msgs::LaneArray lane_array;
 	visualization_msgs::MarkerArray pathsToVisualize;
 
 	for(unsigned int i=0; i &lt; generatedTotalPaths.size(); i++)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\PolygonGenerator.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\PolygonGenerator.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\RosHelpers.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\RosHelpers.h" added_lines="2" deleted_lines="2">
				<diff>@@ -40,7 +40,7 @@
 #include &lt;lidar_tracker/CloudClusterArray.h&gt;
 
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "waypoint_follower/LaneArray.h"
+#include "waypoint_follower_msgs/LaneArray.h"
 
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
@@ -177,7 +177,7 @@ public:
 	virtual ~RosHelpers();
 	static void GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform);
 	static void ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
-				waypoint_follower::lane &amp; trajectory);
+				waypoint_follower_msgs::lane &amp; trajectory);
 
 	static void ConvertFromPlannerHRectangleToAutowareRviz(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; safety_rect,
 			visualization_msgs::Marker&amp; marker);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\include\dp_planner_core.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" added_lines="10" deleted_lines="7">
				<diff>@@ -47,7 +47,7 @@
 #include &lt;std_msgs/Int8.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 #include "waypoint_follower/libwaypoint_follower.h"
-#include "waypoint_follower/LaneArray.h"
+#include "waypoint_follower_msgs/LaneArray.h"
 #include "vehicle_socket/CanInfo.h"
 
 #include &lt;lidar_tracker/CloudCluster.h&gt;
@@ -64,14 +64,17 @@
 #include "RosHelpers.h"
 #include "SimpleTracker.h"
 
-#include &lt;opencv2/objdetect/objdetect.hpp&gt;
-#include &lt;opencv2/contrib/contrib.hpp&gt;
-#include &lt;opencv2/core/core.hpp&gt;
-#include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;cv.h&gt;
+#include &lt;cv_bridge/cv_bridge.h&gt;
+#include &lt;opencv2/core/core.hpp&gt;
+#include &lt;opencv2/objdetect/objdetect.hpp&gt;
 #include &lt;highgui.h&gt;
 #include &lt;opencv2/imgproc/imgproc.hpp&gt;
 
+#if (CV_MAJOR_VERSION &lt; 3)
+#include &lt;opencv2/contrib/contrib.hpp&gt;
+#endif
+
 
 namespace PlannerXNS
 {
@@ -217,8 +220,8 @@ protected:
 	void callbackGetEmergencyStop(const std_msgs::Int8&amp; msg);
 	void callbackGetTrafficLight(const std_msgs::Int8&amp; msg);
 	void callbackGetOutsideControl(const std_msgs::Int8&amp; msg);
-	void callbackGetAStarPath(const waypoint_follower::LaneArrayConstPtr&amp; msg);
-	void callbackGetWayPlannerPath(const waypoint_follower::LaneArrayConstPtr&amp; msg);
+	void callbackGetAStarPath(const waypoint_follower_msgs::LaneArrayConstPtr&amp; msg);
+	void callbackGetWayPlannerPath(const waypoint_follower_msgs::LaneArrayConstPtr&amp; msg);
 	void callbackGetCostMap(const nav_msgs::OccupancyGrid&amp; msg);
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\nodes\PolygonGenerator.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\PolygonGenerator.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\nodes\RosHelpers.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\RosHelpers.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -51,12 +51,12 @@ void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::s
 }
 
 void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
-		waypoint_follower::lane&amp; trajectory)
+		waypoint_follower_msgs::lane&amp; trajectory)
 {
 	trajectory.waypoints.clear();
 	for(unsigned int i=iStart; i &lt; path.size(); i++)
 	{
-		waypoint_follower::waypoint wp;
+		waypoint_follower_msgs::waypoint wp;
 		wp.pose.pose.position.x = path.at(i).pos.x;
 		wp.pose.pose.position.y = path.at(i).pos.y;
 		wp.pose.pose.position.z = path.at(i).pos.z;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\nodes\dp_planner.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\dp_planner\nodes\dp_planner_core.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -95,8 +95,8 @@ PlannerX::PlannerX()
 	m_OriginPos.position.z  = transform.getOrigin().z();
 
 
-	pub_LocalPath = nh.advertise&lt;waypoint_follower::lane&gt;("final_waypoints", 100,true);
-	pub_LocalBasePath = nh.advertise&lt;waypoint_follower::lane&gt;("base_waypoints", 100,true);
+	pub_LocalPath = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("final_waypoints", 100,true);
+	pub_LocalBasePath = nh.advertise&lt;waypoint_follower_msgs::lane&gt;("base_waypoints", 100,true);
 	pub_ClosestIndex = nh.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 100,true);
 
 	pub_BehaviorState = nh.advertise&lt;geometry_msgs::TwistStamped&gt;("current_behavior", 1);
@@ -730,7 +730,7 @@ void PlannerX::callbackGetOutsideControl(const std_msgs::Int8&amp; msg)
 	m_bOutsideControl  = msg.data;
 }
 
-void PlannerX::callbackGetAStarPath(const waypoint_follower::LaneArrayConstPtr&amp; msg)
+void PlannerX::callbackGetAStarPath(const waypoint_follower_msgs::LaneArrayConstPtr&amp; msg)
 {
 	if(msg-&gt;lanes.size() &gt; 0)
 	{
@@ -753,7 +753,7 @@ void PlannerX::callbackGetAStarPath(const waypoint_follower::LaneArrayConstPtr&amp;
 	}
 }
 
-void PlannerX::callbackGetWayPlannerPath(const waypoint_follower::LaneArrayConstPtr&amp; msg)
+void PlannerX::callbackGetWayPlannerPath(const waypoint_follower_msgs::LaneArrayConstPtr&amp; msg)
 {
 	if(msg-&gt;lanes.size() &gt; 0)
 	{
@@ -1026,7 +1026,7 @@ void PlannerX::PlannerMainLoop()
 		}
 
 
-		waypoint_follower::lane current_trajectory;
+		waypoint_follower_msgs::lane current_trajectory;
 		std_msgs::Int32 closest_waypoint;
 		PlannerHNS::RelativeInfo info;
 		PlannerHNS::PlanningHelpers::GetRelativeInfo(m_LocalPlanner.m_Path, m_LocalPlanner.state, info);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\BehaviorStateMachine.h" new_path="" added_lines="0" deleted_lines="176">
				<diff>@@ -1,176 +0,0 @@
-/*
- * BehaviorStateMachine.h
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
-
-#ifndef BEHAVIORSTATEMACHINE_H_
-#define BEHAVIORSTATEMACHINE_H_
-
-#include "RoadNetwork.h"
-#include &lt;sstream&gt;
-
-namespace PlannerHNS
-{
-class BehaviorStateMachine
-{
-public:
-	virtual BehaviorStateMachine* GetNextState() = 0;
-	virtual void Init();
-	virtual void ResetTimer();
-	virtual void InsertNextState(BehaviorStateMachine* nextState);
-	BehaviorStateMachine(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* nextState);
-	virtual ~BehaviorStateMachine() ;
-
-	STATE_TYPE m_Behavior;
-	int m_currentStopSignID	;
-	int m_currentTrafficLightID ;
-	double decisionMakingTime;
-	double m_zero_velocity;
-
-	PreCalculatedConditions* GetCalcParams()
-	{
-		if(!m_pCalculatedValues)
-				m_pCalculatedValues = new PreCalculatedConditions();
-
-		return m_pCalculatedValues;
-	}
-
-	void SetBehaviorsParams(PlanningParams* pParams)
-	{
-		if(!pParams)
-			m_pParams = new PlanningParams;
-		else
-			m_pParams = pParams;
-	}
-
-
-	PreCalculatedConditions* m_pCalculatedValues;
-	PlanningParams* m_pParams;
-	timespec m_StateTimer;
-	std::vector&lt;BehaviorStateMachine*&gt; pNextStates;
-
-	BehaviorStateMachine* FindBehaviorState(const STATE_TYPE&amp; behavior);
-};
-
-class ForwardState : public BehaviorStateMachine
-{
-public:
-	ForwardState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FORWARD_STATE;}
-	virtual ~ForwardState(){}
-	virtual BehaviorStateMachine* GetNextState();
-};
-
-class MissionAccomplishedState : public BehaviorStateMachine
-{
-public:
-	MissionAccomplishedState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FINISH_STATE;}
-	virtual ~MissionAccomplishedState(){}
-	virtual BehaviorStateMachine* GetNextState();
-};
-
-class FollowState : public BehaviorStateMachine
-{
-public:
-	FollowState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FOLLOW_STATE;}
-	virtual ~FollowState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class SwerveState : public BehaviorStateMachine
-{
-public:
-	SwerveState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = OBSTACLE_AVOIDANCE_STATE;}
-	virtual ~SwerveState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopState : public BehaviorStateMachine
-{
-public:
-	StopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOPPING_STATE;}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class TrafficLightStopState : public BehaviorStateMachine
-{
-public:
-	TrafficLightStopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = TRAFFIC_LIGHT_STOP_STATE;}
-	virtual ~TrafficLightStopState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class TrafficLightWaitState : public BehaviorStateMachine
-{
-public:
-	TrafficLightWaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = TRAFFIC_LIGHT_WAIT_STATE;}
-	virtual ~TrafficLightWaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopSignStopState : public BehaviorStateMachine
-{
-public:
-	StopSignStopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOP_SIGN_STOP_STATE;}
-	virtual ~StopSignStopState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopSignWaitState : public BehaviorStateMachine
-{
-public:
-	StopSignWaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOP_SIGN_WAIT_STATE;}
-	virtual ~StopSignWaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class WaitState : public BehaviorStateMachine
-{
-public:
-	WaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = WAITING_STATE;}
-	virtual ~WaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class InitState : public BehaviorStateMachine
-{
-public:
-	InitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = INITIAL_STATE;}
-	virtual ~InitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class GoalState : public BehaviorStateMachine
-{
-public:
-	GoalState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = GOAL_STATE;}
-	virtual ~GoalState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* BEHAVIORSTATEMACHINE_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\CarState.h" new_path="" added_lines="0" deleted_lines="217">
				<diff>@@ -1,217 +0,0 @@
-/*
- * CarState.h
- *
- *  Created on: Jun 20, 2016
- *      Author: hatem
- */
-
-#ifndef CARSTATE_H_
-#define CARSTATE_H_
-
-#include "BehaviorStateMachine.h"
-#include "PlannerCommonDef.h"
-#include "RoadNetwork.h"
-
-namespace SimulationNS
-{
-
-class CarState
-{
-public:
-	PlannerHNS::WayPoint state;
-	PlannerHNS::CAR_BASIC_INFO m_CarInfo;
-	PlannerHNS::ControllerParams m_ControlParams;
-	std::vector&lt;PlannerHNS::GPSPoint&gt; m_CarShapePolygon;
-	std::vector&lt;PlannerHNS::WayPoint&gt; m_Path;
-	std::vector&lt;PlannerHNS::WayPoint&gt; m_TotalPath;
-	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; m_PredictedPath;
-	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; m_RollOuts;
-	std::string carId;
-	PlannerHNS::Lane* pLane;
-	double m_SimulationSteeringDelayFactor; //second , time that every degree change in the steering wheel takes
-	timespec m_SteerDelayTimer;
-	double m_PredictionTime;
-
-	PlannerHNS::BehaviorStateMachine* 		m_pCurrentBehaviorState;
-	PlannerHNS::ForwardState * 				m_pGoToGoalState;
-	PlannerHNS::StopState* 					m_pStopState;
-	PlannerHNS::WaitState* 					m_pWaitState;
-	PlannerHNS::InitState* 					m_pInitState;
-	PlannerHNS::MissionAccomplishedState*	m_pMissionCompleteState;
-	PlannerHNS::FollowState*				m_pFollowState;
-	PlannerHNS::SwerveState*				m_pAvoidObstacleState;
-	PlannerHNS::TrafficLightStopState*		m_pTrafficLightStopState;
-	PlannerHNS::TrafficLightWaitState*		m_pTrafficLightWaitState;
-
-
-	std::vector&lt;PlannerHNS::TrajectoryCost&gt; m_TrajectoryCosts;
-
-	void InitBehaviorStates();
-
-	void SetSimulatedTargetOdometryReadings(const double&amp; velocity_d, const double&amp; steering_d, const PlannerHNS::SHIFT_POS&amp; shift_d)
-	{
-		m_CurrentVelocityD = velocity_d;
-		m_CurrentSteeringD = steering_d;
-		m_CurrentShiftD = shift_d;
-	}
-
-	double GetSimulatedVelocity()
-	{
-		return m_CurrentVelocity;
-	}
-
-	double GetSimulatedSteering()
-	{
-		return m_CurrentSteering;
-	}
-
-	double GetSimulatedShift()
-	{
-		return m_CurrentShift;
-	}
-
-
-	//For Simulation
-	PlannerHNS::WayPoint m_OdometryState;
-	double m_CurrentVelocity, m_CurrentVelocityD; //meter/second
-	double m_CurrentSteering, m_CurrentSteeringD; //radians
-	PlannerHNS::SHIFT_POS m_CurrentShift , m_CurrentShiftD;
-
-	double m_CurrentAccSteerAngle; //degrees steer wheel range
-	double m_CurrentAccVelocity; // kilometer/hour
-	std::vector&lt;PlannerHNS::TrafficLight&gt; m_TrafficLights;
-
-public:
-
-	CarState();
-	virtual ~CarState();
-	void Init(const PlannerHNS::ControllerParams ctrlParams, const PlannerHNS::PlanningParams&amp; params, const PlannerHNS::CAR_BASIC_INFO&amp; carInfo);
-	void InitPolygons();
-	void FirstLocalizeMe(const PlannerHNS::WayPoint&amp; initCarPos);
-	void LocalizeMe(const double&amp; dt); // in seconds
-	void UpdateState(const PlannerHNS::VehicleState&amp; state, const bool&amp; bUseDelay = false);
-	void CalculateImportantParameterForDecisionMaking(const PlannerHNS::VehicleState&amp; car_state,
-			const PlannerHNS::GPSPoint&amp; goal,
-			const bool&amp; bEmergencyStop,
-			const bool&amp; bGreenTrafficLight);
-
-	PlannerHNS::BehaviorState DoOneStep(
-			const double&amp; dt,
-			const PlannerHNS::VehicleState&amp; state,
-			const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list,
-			const PlannerHNS::GPSPoint&amp; goal,
-			PlannerHNS::RoadNetwork&amp; map,
-			const bool&amp; bEmergencyStop,
-			const bool&amp; bGreenTrafficLight,
-			const bool&amp; bLive = false);
-
-	void SimulateOdoPosition(const double&amp; dt, const PlannerHNS::VehicleState&amp; vehicleState);
-
-private:
-
-	//Obstacle avoidance functionalities
-	void InitializeTrajectoryCosts();
-	void CalculateTransitionCosts();
-	void CalculateDistanceCosts(const PlannerHNS::VehicleState&amp; vstatus, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-	bool CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const PlannerHNS::VehicleState&amp; vstatus, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-
-	double PredictTimeCostForTrajectory(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
-			const PlannerHNS::VehicleState&amp; vstatus,
-			const PlannerHNS::WayPoint&amp; currState);
-
-	void PredictObstacleTrajectory(PlannerHNS::RoadNetwork&amp; map,
-			const PlannerHNS::WayPoint&amp; pos,
-			const double&amp; predTime,
-			std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths);
-
-	bool CalculateIntersectionVelocities(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
-			std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; predctedPath,
-			const PlannerHNS::DetectedObject&amp; obj);
-	void FindSafeTrajectory(int&amp; safe_index, double&amp; closest_distance, double&amp; closest_velocity);
-	void FindNextBestSafeTrajectory(int&amp; safe_index);
-	bool GetNextTrafficLight(const int&amp; prevTrafficLightId, const std::vector&lt;PlannerHNS::TrafficLight&gt;&amp; trafficLights, PlannerHNS::TrafficLight&amp; trafficL);
-	bool IsGoalAchieved(const PlannerHNS::GPSPoint&amp; goal);
-	void UpdateCurrentLane(PlannerHNS::RoadNetwork&amp; map, const double&amp; search_distance);
-	bool SelectSafeTrajectoryAndSpeedProfile(const PlannerHNS::VehicleState&amp; vehicleState);
-	PlannerHNS::BehaviorState GenerateBehaviorState(const PlannerHNS::VehicleState&amp; vehicleState);
-	void TransformPoint(const PlannerHNS::WayPoint&amp; refPose, PlannerHNS::GPSPoint&amp; p);
-	void AddAndTransformContourPoints(const PlannerHNS::DetectedObject&amp; obj, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; contourPoints);
-};
-
-class SimulatedCarState
-{
-public:
-	PlannerHNS::WayPoint state;
-	PlannerHNS::CAR_BASIC_INFO m_CarInfo;
-	std::vector&lt;PlannerHNS::GPSPoint&gt; m_CarShapePolygon;
-	std::vector&lt;PlannerHNS::WayPoint&gt; m_Path;
-	std::vector&lt;PlannerHNS::WayPoint&gt; m_TotalPath;
-	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; m_RollOuts;
-	std::string carId;
-	PlannerHNS::Lane* pLane;
-	bool bDetected;
-
-	void SetSimulatedTargetOdometryReadings(const double&amp; velocity_d, const double&amp; steering_d, const PlannerHNS::SHIFT_POS&amp; shift_d)
-	{
-		m_CurrentVelocityD = velocity_d;
-		m_CurrentSteeringD = steering_d;
-		m_CurrentShiftD = shift_d;
-	}
-
-	double GetSimulatedVelocity()
-	{
-		return m_CurrentVelocity;
-	}
-
-	double GetSimulatedSteering()
-	{
-		return m_CurrentSteering;
-	}
-
-	double GetSimulatedShift()
-	{
-		return m_CurrentShift;
-	}
-
-
-	//For Simulation
-	PlannerHNS::WayPoint m_OdometryState;
-	double m_CurrentVelocity, m_CurrentVelocityD; //meter/second
-	double m_CurrentSteering, m_CurrentSteeringD; //radians
-	PlannerHNS::SHIFT_POS m_CurrentShift , m_CurrentShiftD;
-
-	//double m_CurrentAccSteerAngle; //degrees steer wheel range
-	//double m_CurrentAccVelocity; // kilometer/hour
-
-public:
-
-	SimulatedCarState();
-	virtual ~SimulatedCarState();
-	void Init(const PlannerHNS::CAR_BASIC_INFO&amp; carInfo);
-	void InitPolygons();
-	void FirstLocalizeMe(const PlannerHNS::WayPoint&amp; initCarPos);
-	void LocalizeMe(const double&amp; dt); // in seconds
-
-	void UpdateState(const bool&amp; bUseDelay = false);
-	void CalculateImportantParameterForDecisionMaking(const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list,
-			const PlannerHNS::VehicleState&amp; car_state, const PlannerHNS::GPSPoint&amp; goal, PlannerHNS::RoadNetwork&amp; map);
-
-	PlannerHNS::BehaviorState DoOneStep(
-			const double&amp; dt,
-			const PlannerHNS::VehicleState&amp; state,
-			const PlannerHNS::WayPoint&amp; currPose,
-			const PlannerHNS::GPSPoint&amp; goal,
-			PlannerHNS::RoadNetwork&amp; map);
-
-private:
-	void SimulateOdoPosition(const double&amp; dt, const PlannerHNS::VehicleState&amp; vehicleState);
-	void UpdateCurrentLane(PlannerHNS::RoadNetwork&amp; map, const double&amp; search_distance);
-	PlannerHNS::BehaviorState GenerateBehaviorState(const PlannerHNS::VehicleState&amp; vehicleState);
-	bool SelectSafeTrajectoryAndSpeedProfile(const PlannerHNS::VehicleState&amp; vehicleState);
-
-
-};
-
-} /* namespace SimulationNS */
-
-#endif /* CARSTATE_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\DataRW.h" new_path="" added_lines="0" deleted_lines="438">
				<diff>@@ -1,438 +0,0 @@
-/*
- * DataRW.h
- *
- *  Created on: Jun 23, 2016
- *      Author: hatem
- */
-
-#ifndef DATARW_H_
-#define DATARW_H_
-
-#include &lt;string&gt;
-#include &lt;fstream&gt;
-#include &lt;sstream&gt;
-#include &lt;vector&gt;
-#include &lt;iostream&gt;
-
-namespace UtilityHNS {
-
-class DataRW
-{
-public:
-	DataRW();
-	virtual ~DataRW();
-
-	static std::string LoggingMainfolderName;
-	static std::string ControlLogFolderName;
-	static std::string PathLogFolderName;
-	static std::string StatesLogFolderName;
-	static std::string SimulationFolderName;
-	static std::string KmlMapsFolderName;
-
-
-	static void WriteKMLFile(const std::string&amp; fileName, const std::vector&lt;std::string&gt;&amp; gps_list);
-	static void WriteKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;std::string&gt; &gt;&amp; gps_list);
-	static void WriteLogData(const std::string&amp; logFolder, const std::string&amp; logTitle, const std::string&amp; header, const std::vector&lt;std::string&gt;&amp; logData);
-};
-
-class SimpleReaderBase
-{
-private:
-	std::ifstream* m_pFile;
-	std::vector&lt;std::string&gt; m_RawHeaders;
-	std::vector&lt;std::string&gt; m_DataTitlesHeader;
-	std::vector&lt;std::vector&lt;std::vector&lt;std::string&gt; &gt; &gt; m_AllData;
-	int m_nHeders;
-	int m_iDataTitles;
-	int m_nVarPerObj;
-	int m_nLineHeaders;
-	std::string m_HeaderRepeatKey;
-	char m_Separator;
-
-	void ReadHeaders();
-	void ParseDataTitles(const std::string&amp; header);
-
-public:
-	/**
-	 *
-	 * @param fileName log file name
-	 * @param nHeaders number of data headers
-	 * @param iDataTitles which row contains the data titles
-	 * @param nVariablesForOneObject 0 means each row represents one object
-	 */
-	SimpleReaderBase(const std::string&amp; fileName, const int&amp; nHeaders = 2, const char&amp; separator = ',',
-			const int&amp; iDataTitles = 1, const int&amp; nVariablesForOneObject = 0,
-			const int&amp; nLineHeaders = 0, const std::string&amp; headerRepeatKey = "...");
-	~SimpleReaderBase();
-
-protected:
-	bool ReadAllData();
-	bool ReadSingleLine(std::vector&lt;std::vector&lt;std::string&gt; &gt;&amp; line);
-
-};
-
-//class GPSLocalizerReader : public SimpleReaderBase
-//{
-//	public:
-//		GPSLocalizerReader(const std::string&amp; fileName) : SimpleReaderBase(fileName){}
-//		~GPSLocalizerReader(){}
-//
-//		bool ReadNextLine( MsgEstPose&amp; pos, double&amp; logTime);
-//		void ReadAllData(vector&lt;pair&lt;double,  MsgEstPose&gt; &gt;&amp; pos_list);
-//};
-//
-class GPSDataReader : public SimpleReaderBase
-{
-public:
-	struct GPSBasicData
-	{
-		double lat;
-		double lon;
-		double alt;
-		double dir;
-		double distance;
-
-	};
-
-	public:
-	GPSDataReader(const std::string&amp; fileName) : SimpleReaderBase(fileName){}
-	~GPSDataReader(){}
-
-	bool ReadNextLine(GPSBasicData&amp; data);
-	void ReadAllData(std::vector&lt;GPSBasicData&gt;&amp; data_list);
-};
-
-//
-//class VehicleStateReader : public SimpleReaderBase
-//{
-//	public:
-//	VehicleStateReader(const string&amp; fileName) : SimpleReaderBase(fileName){}
-//	~VehicleStateReader(){}
-//
-//	bool ReadNextLine( MsgVehicleStatus&amp; state, double&amp; logTime);
-//	void ReadAllData(vector&lt;pair&lt;double,  MsgVehicleStatus&gt; &gt;&amp; state_list);
-//};
-//
-//class MovingObjectsReader : public SimpleReaderBase
-//{
-//	public:
-//	MovingObjectsReader(const string&amp; fileName) : SimpleReaderBase(fileName, 2, 1, 28, 4){}
-//	~MovingObjectsReader(){}
-//
-//	bool ReadNextLine( MsgMovingObject&amp; state, double&amp; logTime);
-//	void ReadAllData(vector&lt;pair&lt;double,  MsgMovingObject&gt; &gt;&amp; state_list);
-//};
-
-class SimulationFileReader : public SimpleReaderBase
-{
-public:
-	struct SimulationPoint
-	{
-		double x;
-		double y;
-		double z;
-		double a;
-		double c;
-		double v;
-	};
-
-	struct SimulationData
-	{
-		SimulationPoint startPoint;
-		SimulationPoint goalPoint;
-		std::vector&lt;SimulationPoint&gt; simuCars;
-	};
-
-	SimulationFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~SimulationFileReader(){}
-
-	bool ReadNextLine(SimulationPoint&amp; data);
-	void ReadAllData(SimulationData&amp; data_list);
-};
-
-class LocalizationPathReader : public SimpleReaderBase
-{
-public:
-	struct LocalizationWayPoint
-	{
-		double t;
-		double x;
-		double y;
-		double z;
-		double a;
-		double v;
-	};
-
-	LocalizationPathReader(const std::string&amp; fileName, const char&amp; separator) : SimpleReaderBase(fileName, 1, separator){}
-	~LocalizationPathReader(){}
-
-	bool ReadNextLine(LocalizationWayPoint&amp; data);
-	void ReadAllData(std::vector&lt;LocalizationWayPoint&gt;&amp; data_list);
-};
-
-class AisanPointsFileReader : public SimpleReaderBase
-{
-public:
-	struct AisanPoints
-	{
-		int PID;
-		double B;
-		double L;
-		double H;
-		double Bx;
-		double Ly;
-		int Ref;
-		int MCODE1;
-		int MCODE2;
-		int MCODE3;
-	};
-
-	AisanPointsFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanPointsFileReader(){}
-
-	bool ReadNextLine(AisanPoints&amp; data);
-	void ReadAllData(std::vector&lt;AisanPoints&gt;&amp; data_list);
-};
-
-class AisanNodesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanNode
-	{
-		int NID;
-		int PID;
-	};
-
-	AisanNodesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanNodesFileReader(){}
-
-	bool ReadNextLine(AisanNode&amp; data);
-	void ReadAllData(std::vector&lt;AisanNode&gt;&amp; data_list);
-};
-
-class AisanLinesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanLine
-	{
-		int LID;
-		int BPID;
-		int FPID;
-		int BLID;
-		int FLID;
-	};
-
-	AisanLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanLinesFileReader(){}
-
-	bool ReadNextLine(AisanLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanLine&gt;&amp; data_list);
-};
-
-class AisanCenterLinesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanCenterLine
-	{
-		int 	DID;
-		int 	Dist;
-		int 	PID;
-		double 	Dir;
-		double 	Apara;
-		double 	r;
-		double 	slope;
-		double 	cant;
-		double 	LW;
-		double 	RW;
-	};
-
-	AisanCenterLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanCenterLinesFileReader(){}
-
-	bool ReadNextLine(AisanCenterLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanCenterLine&gt;&amp; data_list);
-};
-
-class AisanAreasFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanArea
-	{
-		int 	AID;
-		int 	SLID;
-		int 	ELID;
-	};
-
-	AisanAreasFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanAreasFileReader(){}
-
-	bool ReadNextLine(AisanArea&amp; data);
-	void ReadAllData(std::vector&lt;AisanArea&gt;&amp; data_list);
-};
-
-class AisanIntersectionFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanIntersection
-	{
-		int 	ID;
-		int 	AID;
-		int 	LinkID;
-	};
-
-	AisanIntersectionFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanIntersectionFileReader(){}
-
-	bool ReadNextLine(AisanIntersection&amp; data);
-	void ReadAllData(std::vector&lt;AisanIntersection&gt;&amp; data_list);
-};
-
-class AisanLanesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanLane
-	{
-		int LnID	;
-		int DID		;
-		int BLID	;
-		int FLID	;
-		int BNID	;
-		int FNID	;
-		int JCT		;
-		int BLID2	;
-		int BLID3	;
-		int BLID4	;
-		int FLID2	;
-		int FLID3	;
-		int FLID4	;
-		int ClossID	;
-		double Span	;
-		int LCnt	;
-		int Lno		;
-		int LaneType;
-		int LimitVel;
-		int RefVel	;
-		int RoadSecID;
-		int LaneChgFG;
-		int LinkWAID;
-		char LaneDir;
-		int  LeftLaneId;
-		int RightLaneId;
-
-	};
-
-	AisanLanesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanLanesFileReader(){}
-
-	bool ReadNextLine(AisanLane&amp; data);
-	void ReadAllData(std::vector&lt;AisanLane&gt;&amp; data_list);
-};
-
-class AisanStopLineFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanStopLine
-	{
-		int 	ID;
-		int 	LID;
-		int 	TLID;
-		int 	SignID;
-		int 	LinkID;
-	};
-
-	AisanStopLineFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanStopLineFileReader(){}
-
-	bool ReadNextLine(AisanStopLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanStopLine&gt;&amp; data_list);
-};
-
-class AisanRoadSignFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanRoadSign
-	{
-		int 	ID;
-		int 	VID;
-		int 	PLID;
-		int 	Type;
-		int 	LinkID;
-	};
-
-	AisanRoadSignFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanRoadSignFileReader(){}
-
-	bool ReadNextLine(AisanRoadSign&amp; data);
-	void ReadAllData(std::vector&lt;AisanRoadSign&gt;&amp; data_list);
-};
-
-class AisanSignalFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanSignal
-	{
-		int 	ID;
-		int 	VID;
-		int 	PLID;
-		int 	Type;
-		int 	LinkID;
-	};
-
-	AisanSignalFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanSignalFileReader(){}
-
-	bool ReadNextLine(AisanSignal&amp; data);
-	void ReadAllData(std::vector&lt;AisanSignal&gt;&amp; data_list);
-};
-
-class AisanVectorFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanVector
-	{
-		int 	VID;
-		int 	PID;
-		double 	Hang;
-		double 	Vang;
-	};
-
-	AisanVectorFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanVectorFileReader(){}
-
-	bool ReadNextLine(AisanVector&amp; data);
-	void ReadAllData(std::vector&lt;AisanVector&gt;&amp; data_list);
-};
-
-class AisanDataConnFileReader : public SimpleReaderBase
-{
-public:
-
-	struct DataConn
-	{
-		int 	LID; // lane id
-		int 	SLID; // stop line id
-		int 	SID; // signal id
-		int 	SSID; // stop sign id
-	};
-
-	AisanDataConnFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanDataConnFileReader(){}
-
-	bool ReadNextLine(DataConn&amp; data);
-	void ReadAllData(std::vector&lt;DataConn&gt;&amp; data_list);
-};
-
-
-} /* namespace UtilityHNS */
-
-#endif /* DATARW_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\GridMap.h" new_path="" added_lines="0" deleted_lines="230">
				<diff>@@ -1,230 +0,0 @@
-/*
- * GridMap.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#ifndef GRIDMAPSA_H_
-#define GRIDMAPSA_H_
-
-#include "RoadNetwork.h"
-
-namespace PlannerHNS
-{
-
-#define get2dIndex(r,c,w) r*w + c
-#define checkGridLimit(r,c,h,w) r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; h &amp;&amp; c &lt; w
-#define checkGridIndex(i, nCells) i &gt;= 0 &amp;&amp; i &lt; nCells
-#define SUBCELL_L 10 //subcell lenth in centimeter
-
-
-class CELL_Info
-{
-public:
-  int r,c,index;
-  GPSPoint center;
-  int nCells;
-  double heuristic;
-  double forwardHeuristic;
-  double backwardHeuristic;
-  double heuristicValue;
-  double forward_heuristicValue;
-  double backward_heuristicValue;
-  int expanded; // used in path planning
-  bool closed;
-  double value;
-  int action;
-  double localize_val;
-  double localize_prob;
-  std::vector&lt;double&gt; localize_features;
-  GPSPoint forwardCenter;
-  GPSPoint backwardCenter;
-  DIRECTION_TYPE bDir;
-  POINT2D bottom_left;
-  POINT2D top_right;
-  POINT2D bottom_right;
-  POINT2D top_left;
-  int nStaticPoints;
-  int nMovingPoints;
-
-  CELL_Info* pInnerMap;
-
-  std::vector&lt;POINT2D&gt; innerStaticPointsList;
-  std::vector&lt;POINT2D&gt; innerMovingPointsList;
-
-  std::vector&lt;GPSPoint&gt; path;
-
-
-public:
-  void InitSubCells(double cell_l, double sub_cell_l);
-/**
- * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
- * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
- */
-  void Clear(int bMovingOnly);
-  void ClearSubCells(bool bMovingOnly);
-
-  CELL_Info();
-
-  virtual ~CELL_Info();
-
-  /*
-   * Cell initialization
-   */
-  void Initialize(POINT2D bottom_left, double cell_l, int row, int col, bool bDefaultEmpty);
-
-  /*
-   * assignment operator
-   */
-  bool operator==(const CELL_Info&amp; cell);
-
-  bool operator!=(const CELL_Info&amp; cell);
-
-  inline bool PointInRect(const POINT2D&amp; p)
-   {
-     return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
-   }
-
-  bool TestWithRectangle(RECTANGLE&amp; rec);
-  bool TestWithCircle(POINT2D _center,double  width);
-   inline bool HitTest(const POINT2D&amp; p);
-
-   void UpdateSubCellCostValue(const std::vector&lt;POINT2D&gt;&amp; ps, const double&amp; cell_l, const double&amp; sub_cell_l);
-   void UpdateCostValue(const std::vector&lt;POINT2D&gt;&amp; ps);
-
-   void SaveCell(std::ostream&amp; f);
-   void LoadCell(std::ifstream&amp; f);
-
-};
-
-class GridMap
-{
-  public:
-
-	  pthread_mutex_t update_map_mutex;
-
-    double w, inner_w; // current world width
-    double h, inner_h; // current world height
-    double cell_l; // cell or block length, if this is an inner cell measurements will be in meter
-    double sub_cell_l;
-    double origin_x , origin_y;
-
-
-
-    int inner_start_row;
-    int inner_start_col;
-    int inner_end_row;
-    int inner_end_col;
-
-    bool m_bEnableInnerMap;
-    bool m_bUpdatedMap;
-
-
-
-    int wCells, nInnerWCells; // width, number of cells per row
-    int hCells, nInnerHCells; // height, number of cells per column
-	//POINT2D center;
-	int m_MaxHeuristics;
-
-	int m_DisplayResolution;
-
-	POINT2D* delta;
-
-
-    // This method map obstacles from real world space to Grid space , marking each cell or internal cells as obstacle
-	void UpdateMapObstacleValue(const Obstacle&amp; ob);
-	void UpdateMapDrivablesValue(const DrivableArea&amp; dr);
-	void UpdateMapDrivablesValuePlygon(const std::vector&lt;std::vector&lt;POINT2D&gt; &gt;&amp; points);
-	void UpdateMapObstaclesValuePlygon(const std::vector&lt;POINT2D&gt;&amp; poly, std::vector&lt;CELL_Info*&gt;&amp; modifiedCell);
-
-	/**
-	 * @brief update cell to indicate that there is an obstacle @ absolute point p
-	 * @param p absolute x,y point
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapObstaclePoint(const POINT2D&amp; p);
-
-	/**
-	 * @brief update cell to indicate that there is an obstacle @ absolute point p , and make the map thiner according to a giving threshold
-	 * @param p absolute x,y point
-	 * @param thiningTHreshold distance to search for old obstacles
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateThinMapObstaclePoint(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold);
-
-	/**
-	 * @brief update cell to indicate that there is an moving obstacle @ absolute point p
-	 * @param p absolute x,y point
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapMovingObstaclePoint(const POINT2D&amp; p);
-
-	/**
-	 * @brief update subcells cost values to reflect the effect of obstacle @ absolute pint p
-	 * @param p obstacle point (x,y)
-	 * @param currPos current car location to apply the effect of obstacle on p
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapCostValueRange(const std::vector&lt;POINT2D&gt;&amp; ps, const GPSPoint&amp; currPos, const std::vector&lt;double&gt;&amp; features);
-	/**
-	 * @brief find the cell @ p then update its localization cost and probability which were read from a map file
-	 * @param p absolute position of the cell center
-	 * @param localize_val cost value
-	 * @param localize_prob probability value (should be zero in case of updating from map file
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateSubMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);
-
-	CELL_Info* UpdateMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);
-
-	CELL_Info* GetCellFromPointInnerMap(const POINT2D&amp; p);
-	CELL_Info* GetCellFromPoint(const POINT2D&amp; p, bool bExpand = false); // return cell information from (x,y) coordinates
-	CELL_Info* GetSubCellFromPoint(const POINT2D&amp; p); // return sub cell information from (x,y) coordinates
-	CELL_Info* GetSubCellFromCell(CELL_Info* const parent, const POINT2D&amp; p); // return sub cell information from parent cell
-
-	bool CheckSubCellsInTheWay(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold, std::vector&lt;CELL_Info*&gt;&amp; pSubCellsList);
-
-	/**
-	 * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
-	 * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
-	 */
-	void ClearMap(int bMovingOnly);
-	void OpenClosedCells();
-	void BackupMap();
-
-	GridMap();
-    GridMap(double start_x, double start_y, double  map_w, double map_h, double cell_length, bool bDefaultEmpty); // initialize and construct the 2D array of the Grid cells
-    void InitInnerMap(double  map_l, GridMap* const pParentMap, const POINT2D&amp; center); // initialize and construct map from another map (cells will point to cells from the other map , width and hight will be maximum available limited by the parameters
-    virtual ~GridMap();
-
-    CELL_Info* pCells;
-    int nCells;
-
-    void SaveMap(const std::string&amp; mapFilePath, const std::string&amp; mapName);
-    void LoadMap(const std::string&amp; mapFilePath, const POINT2D&amp; pos, const double&amp; loadingRadius, const GPSPoint&amp; mapTransformation);
-
-    int GetSurroundingMainCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
-    int GetSurroundingNonObstacleCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
-    int GetSurroundingMainCellsRectangle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
-    int GetSurroundingMainCellsCircle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, double radius);
-    int GetSurroundingMainCellsRectangleNoObstacle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
-
-    bool IsUpdated()
-    {
-    	return m_bUpdatedMap;
-    }
-
-    void ObservedMap()
-    {
-    	m_bUpdatedMap = false;
-    }
-
-  private:
-    int InsidePolygon(const std::vector&lt;POINT2D&gt;&amp; polygon,const POINT2D&amp; p);
-
-    //vector&lt;CELL_Info*&gt; pDrivableCells;
-  };
-
-}
-#endif /* GRIDMAP_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\HMIStateMachine.h" new_path="" added_lines="0" deleted_lines="99">
				<diff>@@ -1,99 +0,0 @@
-/*
- * HMIStateMachine.h
- *
- *  Created on: February 14, 2017
- *      Author: Hatem Darweesh
- */
-
-#ifndef HMIStateMachine_H_
-#define HMIStateMachine_H_
-
-#include "RoadNetwork.h"
-#include &lt;sstream&gt;
-
-namespace PlannerHNS
-{
-
-class HMIStateMachine
-{
-public:
-	virtual HMIStateMachine* GetNextState() = 0;
-	virtual void Init();
-	virtual void ResetTimer();
-	virtual void InsertNextState(HMIStateMachine* nextState);
-	HMIStateMachine(HMIStateMachine* nextState);
-	virtual ~HMIStateMachine() ;
-
-	GLOBAL_STATE_TYPE m_Behavior;
-	double decisionMakingTime;
-
-	HMIPreCalculatedConditions* GetCalcParams()
-	{
-		if(!m_pCalculatedValues)
-				m_pCalculatedValues = new HMIPreCalculatedConditions();
-
-		return m_pCalculatedValues;
-	}
-
-	void SetBehaviorsParams(const PlanningParams&amp; params)
-	{
-		m_PlanningParams = params;
-	}
-
-	static HMIPreCalculatedConditions* m_pCalculatedValues;
-	timespec m_StateTimer;
-	std::vector&lt;HMIStateMachine*&gt; pNextStates;
-	static PlanningParams m_PlanningParams;
-
-	HMIStateMachine* FindBehaviorState(const GLOBAL_STATE_TYPE&amp; behavior);
-};
-
-class GWaitingState : public HMIStateMachine
-{
-public:
-	GWaitingState(GWaitingState* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_WAITING_STATE;}
-	virtual ~GWaitingState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GPlanningState : public HMIStateMachine
-{
-public:
-	GPlanningState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_PLANING_STATE;}
-	virtual ~GPlanningState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GForwardState : public HMIStateMachine
-{
-public:
-	GForwardState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_FORWARD_STATE;}
-	virtual ~GForwardState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GBranchingState : public HMIStateMachine
-{
-public:
-	GBranchingState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_BRANCHING_STATE;}
-	virtual ~GBranchingState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GEndState : public HMIStateMachine
-{
-public:
-	GEndState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_FINISH_STATE;}
-	virtual ~GEndState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-
-} /* namespace PlannerHNS */
-
-#endif /* HMIStateMachine_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\LocalPlannerH.h" new_path="" added_lines="0" deleted_lines="157">
				<diff>@@ -1,157 +0,0 @@
-/*
- * CarState.h
- *
- *  Created on: Dec 14, 2016
- *      Author: hatem
- */
-
-#ifndef LOCALPLANNERH_H_
-#define LOCALPLANNERH_H_
-
-#include "BehaviorStateMachine.h"
-#include "PlannerCommonDef.h"
-#include "RoadNetwork.h"
-#include "TrajectoryCosts.h"
-
-namespace PlannerHNS
-{
-
-class LocalPlannerH
-{
-public:
-	WayPoint state;
-	CAR_BASIC_INFO m_CarInfo;
-	ControllerParams m_ControlParams;
-	std::vector&lt;GPSPoint&gt; m_CarShapePolygon;
-	std::vector&lt;WayPoint&gt; m_Path;
-	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_TotalPath;
-	int m_iCurrentTotalPathId;
-	int m_iSafeTrajectory;
-//	int m_iGlobalPathPrevID;
-	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_PredictedPath;
-	std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt; m_RollOuts;
-	std::string carId;
-	Lane* pLane;
-	double m_SimulationSteeringDelayFactor; //second , time that every degree change in the steering wheel takes
-	timespec m_SteerDelayTimer;
-	double m_PredictionTime;
-	double m_CostCalculationTime;
-	double m_BehaviorGenTime;
-	double m_RollOutsGenerationTime;
-
-	BehaviorStateMachine* 		m_pCurrentBehaviorState;
-	ForwardState * 				m_pGoToGoalState;
-	StopState* 					m_pStopState;
-	WaitState* 					m_pWaitState;
-	InitState* 					m_pInitState;
-	MissionAccomplishedState*	m_pMissionCompleteState;
-	GoalState*					m_pGoalState;
-	FollowState*				m_pFollowState;
-	SwerveState*				m_pAvoidObstacleState;
-	TrafficLightStopState*		m_pTrafficLightStopState;
-	TrafficLightWaitState*		m_pTrafficLightWaitState;
-	StopSignStopState* 			m_pStopSignStopState;
-	StopSignWaitState* 			m_pStopSignWaitState;
-
-	TrajectoryCosts m_TrajectoryCostsCalculatotor;
-
-
-
-	//for debugging
-	std::vector&lt;WayPoint&gt; m_PathSection;
-	std::vector&lt;WayPoint&gt; m_SampledPoints;
-
-	void InitBehaviorStates();
-
-	void SetSimulatedTargetOdometryReadings(const double&amp; velocity_d, const double&amp; steering_d, const SHIFT_POS&amp; shift_d)
-	{
-		m_CurrentVelocityD = velocity_d;
-		m_CurrentSteeringD = steering_d;
-		m_CurrentShiftD = shift_d;
-	}
-
-	double GetSimulatedVelocity()
-	{
-		return m_CurrentVelocity;
-	}
-
-	double GetSimulatedSteering()
-	{
-		return m_CurrentSteering;
-	}
-
-	double GetSimulatedShift()
-	{
-		return m_CurrentShift;
-	}
-
-
-	//For Simulation
-	WayPoint m_OdometryState;
-	double m_CurrentVelocity, m_CurrentVelocityD; //meter/second
-	double m_CurrentSteering, m_CurrentSteeringD; //radians
-	SHIFT_POS m_CurrentShift , m_CurrentShiftD;
-
-	double m_CurrentAccSteerAngle; //degrees steer wheel range
-	double m_CurrentAccVelocity; // kilometer/hour
-	//std::vector&lt;TrafficLight&gt; m_TrafficLights;
-
-public:
-
-	LocalPlannerH();
-	virtual ~LocalPlannerH();
-	void Init(const ControllerParams&amp; ctrlParams, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo);
-	void InitPolygons();
-	void FirstLocalizeMe(const WayPoint&amp; initCarPos);
-	void LocalizeMe(const double&amp; dt); // in seconds
-	void UpdateState(const VehicleState&amp; state, const bool&amp; bUseDelay = false);
-	void CalculateImportantParameterForDecisionMaking(const VehicleState&amp; car_state,
-			const int&amp; goalID, const bool&amp; bEmergencyStop, const bool&amp; bGreenTrafficLight,
-			const TrajectoryCost&amp; bestTrajectory);
-
-	BehaviorState DoOneStep(
-			const double&amp; dt,
-			const VehicleState&amp; state,
-			const std::vector&lt;DetectedObject&gt;&amp; obj_list,
-			const int&amp; goalID,
-			RoadNetwork&amp; map,
-			const bool&amp; bEmergencyStop,
-			const bool&amp; bGreenTrafficLight,
-			const bool&amp; bLive = false);
-
-	void SimulateOdoPosition(const double&amp; dt, const VehicleState&amp; vehicleState);
-
-private:
-
-	//Obstacle avoidance functionalities
-	bool CalculateObstacleCosts(RoadNetwork&amp; map, const VehicleState&amp; vstatus, const std::vector&lt;DetectedObject&gt;&amp; obj_list);
-
-	double PredictTimeCostForTrajectory(std::vector&lt;WayPoint&gt;&amp; path,
-			const VehicleState&amp; vstatus,
-			const WayPoint&amp; currState);
-
-	void PredictObstacleTrajectory(RoadNetwork&amp; map,
-			const WayPoint&amp; pos,
-			const double&amp; predTime,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-	bool CalculateIntersectionVelocities(std::vector&lt;WayPoint&gt;&amp; path,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; predctedPath,
-			const DetectedObject&amp; obj);
-
-	bool GetNextTrafficLight(const int&amp; prevTrafficLightId, const std::vector&lt;TrafficLight&gt;&amp; trafficLights, TrafficLight&amp; trafficL);
-	void UpdateCurrentLane(RoadNetwork&amp; map, const double&amp; search_distance);
-	bool SelectSafeTrajectoryAndSpeedProfile(const VehicleState&amp; vehicleState);
-	BehaviorState GenerateBehaviorState(const VehicleState&amp; vehicleState);
-	void TransformPoint(const WayPoint&amp; refPose, GPSPoint&amp; p);
-	void AddAndTransformContourPoints(const DetectedObject&amp; obj, std::vector&lt;WayPoint&gt;&amp; contourPoints);
-	void UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt);
-
-	bool NoWayTest(const double&amp; min_distance, const int&amp; iGlobalPathIndex);
-
-	PlannerHNS::PlanningParams m_params;
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* LOCALPLANNERH_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\MappingHelpers.h" new_path="" added_lines="0" deleted_lines="108">
				<diff>@@ -1,108 +0,0 @@
-/*
- * MappingHelpers.h
- *
- *  Created on: Jul 2, 2016
- *      Author: Hatem
- */
-
-#ifndef MAPPINGHELPERS_H_
-#define MAPPINGHELPERS_H_
-
-#include &lt;math.h&gt;
-#include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "DataRW.h"
-#include "tinyxml.h"
-
-
-namespace PlannerHNS {
-
-
-class MappingHelpers {
-public:
-	MappingHelpers();
-	virtual ~MappingHelpers();
-
-	static void ConstructRoadNetworkFromRosMessage(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
-			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
-			const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
-			const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
-			const std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt;&amp; area_data,
-			const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
-			const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
-			const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
-			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
-			const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
-			const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag = false);
-
-	static void ConstructRoadNetworkFromDataFiles(const std::string vectoMapPath, RoadNetwork&amp; map, const bool&amp; bZeroOrigin = false);
-
-	static void SaveTrajectoryLonLatToKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectory);
-
-	static void GetWayPoint(const int&amp; pid, const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points, std::vector&lt;WayPoint&gt;&amp; path);
-	static bool GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; did,
-			const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dtpoints,
-			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
-			const GPSPoint&amp; origin, WayPoint&amp; way_point);
-
-	static void WriteKML(const std::string&amp; kmlFile, const std::string&amp; kmlTemplat, RoadNetwork&amp; ap);
-	static void LoadKML(const std::string&amp; kmlMap, RoadNetwork&amp; map);
-
-	static void SetRoadLinksList(TiXmlElement* pElem, std::vector&lt;RoadSegment&gt;&amp; roadSegments);
-	static void SetLaneLinksList(TiXmlElement* pElem, std::vector&lt;Lane&gt;&amp; lanes);
-	static void SetStopLinesList(TiXmlElement* pElem, std::vector&lt;StopLine&gt;&amp; stopLines);
-	static void SetTrafficLightsList(TiXmlElement* pElem, std::vector&lt;TrafficLight&gt;&amp; trafficLights);
-	static void SetTrafficSignsList(TiXmlElement* pElem, std::vector&lt;TrafficSign&gt;&amp; trafficSignes);
-
-	static TiXmlElement* GetHeadElement(TiXmlElement* pMainElem);
-	static TiXmlElement* GetDataFolder(const std::string&amp; folderName, TiXmlElement* pMainElem);
-
-
-	static Lane* GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static Lane* GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static std::vector&lt;Lane*&gt; GetClosestMultipleLanesFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static WayPoint* GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
-	static WayPoint* GetClosestBackWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
-	static WayPoint GetFirstWaypoint(RoadNetwork&amp; map);
-	static WayPoint* GetLastWaypoint(RoadNetwork&amp; map);
-
-
-	static void llaToxyz(GPSPoint&amp; lla_p, const GPSPoint&amp; origin);
-	static void llaToxyzSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
-	static void xyzTolla(GPSPoint&amp; xyz_p, const GPSPoint&amp; origin);
-	static void xyzTollaSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
-
-	static void GetUniqueNextLanes(const Lane* l,  const std::vector&lt;Lane*&gt;&amp; traversed_lanes, std::vector&lt;Lane*&gt;&amp; lanes_list);
-
-	static GPSPoint GetTransformationOrigin(const int&amp; bToyotaCityMap = 0);
-
-	static Lane* GetLaneFromPath(const WayPoint&amp; currPos, const std::vector&lt;WayPoint&gt;&amp; currPath);
-	static Lane* GetLaneById(const int&amp; id,RoadNetwork&amp; map);
-	static int GetLaneIdByWaypointId(const int&amp; id,std::vector&lt;Lane&gt;&amp; lanes);
-
-	static WayPoint* FindWaypoint(const int&amp; id, RoadNetwork&amp; map);
-
-
-	static std::vector&lt;TrafficLight&gt; GetTrafficLightsList(TiXmlElement* pElem);
-	static std::vector&lt;StopLine&gt; GetStopLinesList(TiXmlElement* pElem);
-	static std::vector&lt;Lane&gt; GetLanesList(TiXmlElement* pElem);
-	static std::vector&lt;RoadSegment&gt; GetRoadSegmentsList(TiXmlElement* pElem);
-	static std::vector&lt;int&gt; GetIDsFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::vector&lt;double&gt; GetDoubleFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::pair&lt;ACTION_TYPE, double&gt; GetActionPairFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::vector&lt;WayPoint&gt; GetCenterLaneData(TiXmlElement* pElem, const int&amp; currLaneID);
-	static std::vector&lt;WayPoint&gt; GetCenterLaneDataVer0(TiXmlElement* pElem, const int&amp; currLaneID);
-	static std::vector&lt;GPSPoint&gt; GetPointsData(TiXmlElement* pElem);
-	static std::vector&lt;std::string&gt; SplitString(const std::string&amp; str, const std::string&amp; token);
-
-	static void CreateKmlFromLocalizationPathFile(const std::string&amp; pathFileName,const double&amp; maxLaneDistance, const double&amp; density,const std::vector&lt;TrafficLight&gt;&amp; trafficLights, const std::vector&lt;GPSPoint&gt;&amp; stopLines);
-
-	static int ReplaceMyID(int&amp; id, const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; rep_list);
-
-	static double m_USING_VER_ZERO;
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* MAPPINGHELPERS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\MatrixOperations.h" new_path="" added_lines="0" deleted_lines="131">
				<diff>@@ -1,131 +0,0 @@
-/*
- * MatrixOperations.h
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
-
-#ifndef MATRIXOPERATIONS_H_
-#define MATRIXOPERATIONS_H_
-
-#include "RoadNetwork.h"
-#include &lt;math.h&gt;
-
-
-namespace PlannerHNS {
-
-
-class Mat3
-{
-	double m11, m12, m13;
-	double m21, m22, m23;
-	double m31, m32, m33;
-
-	double m[3][3];
-
-public:
-	Mat3()
-	{
-		//initialize Identity by default
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-	}
-
-	Mat3(double angle, POINT2D trans)
-	{
-		//Initialize Rotation Matrix
-		double c = cos(angle);
-		double s = sin(angle);
-		m11 = c;
-		m12 = s;
-		m21 = -s;
-		m22 = c;
-		m31 = trans.x;
-		m32 = trans.y;
-		m13 = m23= 0;
-		m33 = 1;
-	}
-
-	Mat3(double transX, double transY, bool mirrorX, bool mirrorY )
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		m[0][0] = (mirrorX == true ) ? -1 : 1; m[0][1] =  0; m[0][2] =  transX;
-		m[1][0] = 0; m[1][1] =  (mirrorY==true) ? -1 : 1; m[1][2] =  transY;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(double transX, double transY)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		m[0][0] = 1; m[0][1] =  0; m[0][2] =  transX;
-		m[1][0] = 0; m[1][1] =  1; m[1][2] =  transY;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(double rotation_angle)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		double c = cos(rotation_angle);
-		double s = sin(rotation_angle);
-		m[0][0] = c; m[0][1] = -s; m[0][2] =  0;
-		m[1][0] = s; m[1][1] =  c; m[1][2] =  0;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(GPSPoint rotationCenter)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		double c = cos(rotationCenter.a);
-		double s = sin(rotationCenter.a);
-		double u = rotationCenter.x;
-		double v = rotationCenter.y;
-		m[0][0] = c; m[0][1] = -s; m[0][2] = -u*c + v*s + u;
-		m[1][0] = s; m[1][1] =  c; m[1][2] = -u*s - v*c + v;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-
-	GPSPoint operator * (GPSPoint v)
-	{
-		GPSPoint _v = v;
-		v.x = m[0][0]*_v.x + m[0][1]*_v.y + m[0][2]*1;
-		v.y = m[1][0]*_v.x + m[1][1]*_v.y + m[1][2]*1;
-		return v;
-	}
-
-	POINT2D operator * (POINT2D v)
-	{
-		Mat3 m = *this;
-		POINT2D r;
-		r.x = m.m11 * v.x + m.m21 * v.y + m.m31 * 1;
-		r.y = m.m12 * v.x + m.m22 * v.y + m.m32 * 1;
-		return r;
-	}
-
-	Mat3 operator *(Mat3 m2)
-	{
-		Mat3 m1 = *this;
-		Mat3 r;
-		r.m11 = m1.m11 * m2.m11 + m1.m12 * m2.m21 + m1.m13 * m2.m31;
-		r.m12 = m1.m11 * m2.m12 + m1.m12 * m2.m22 + m1.m13 * m2.m32;
-		r.m13 = m1.m11 * m2.m13 + m1.m12 * m2.m23 + m1.m13 * m2.m33;
-
-		r.m21 = m1.m21 * m2.m11 + m1.m22 * m2.m21 + m1.m23 * m2.m31;
-		r.m22 = m1.m21 * m2.m12 + m1.m22 * m2.m22 + m1.m23 * m2.m32;
-		r.m23 = m1.m21 * m2.m13 + m1.m22 * m2.m23 + m1.m23 * m2.m33;
-
-		r.m31 = m1.m31 * m2.m11 + m1.m32 * m2.m21 + m1.m33 * m2.m31;
-		r.m32 = m1.m31 * m2.m12 + m1.m32 * m2.m22 + m1.m33 * m2.m32;
-		r.m33 = m1.m31 * m2.m13 + m1.m32 * m2.m23 + m1.m33 * m2.m33;
-
-		return r;
-	}
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* MATRIXOPERATIONS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\PlannerCommonDef.h" new_path="" added_lines="0" deleted_lines="156">
				<diff>@@ -1,156 +0,0 @@
-/*
- * PlannerCommonDef.h
- *
- *  Created on: Dec 14, 2016
- *      Author: hatem
- */
-
-#ifndef PLANNERCOMMONDEF_H_
-#define PLANNERCOMMONDEF_H_
-
-#include &lt;math.h&gt;
-#include &lt;string&gt;
-
-namespace PlannerHNS
-{
-
-enum CAR_TYPE
-{
-  Mv2Car, //!&lt; Mv2Car
-  PHVCar, //!&lt; PHVCar
-  HVCar,  //!&lt; HVCar
-  RoboCar,//!&lt; RoboCar
-  SimulationCar
-};
-
-class PID_CONST
-{
-public:
-	double kP;
-	double kI;
-	double kD;
-
-	PID_CONST()
-	{
-		kP = kI = kD = 0;
-	}
-
-	PID_CONST(const double&amp; p, const double&amp; i, const double&amp; d)
-	{
-		kP = p;
-		kI = i;
-		kD = d;
-	}
-};
-
-class ControllerParams
-{
-public:
-	double SimulationSteeringDelay;
-	double SteeringDelay;
-	double minPursuiteDistance;
-	PID_CONST Steering_Gain;
-	PID_CONST Velocity_Gain;
-	double Acceleration;
-	double Deceleration;
-	double FollowDistance;
-	double LowpassSteerCutoff;
-	double maxAccel;
-	double maxDecel;
-
-
-	ControllerParams()
-	{
-		SimulationSteeringDelay = 0.0;
-		SteeringDelay 		= 0.8;
-		Acceleration		= 0.5;
-		Deceleration		= -0.8;
-		FollowDistance		= 8.0;
-		LowpassSteerCutoff	= 5.0;
-		maxAccel			= 0.9;
-		minPursuiteDistance = 2.0;
-		maxDecel 			= -1.5;
-	}
-};
-
-class CAR_BASIC_INFO
-{
-public:
-  CAR_TYPE model;
-
-  double turning_radius;
-  double wheel_base;
-  double max_speed_forward;
-  double min_speed_forward;
-  double max_speed_backword;
-  double max_steer_value;
-  double min_steer_value;
-  double max_brake_value;
-  double min_brake_value;
-  double max_steer_angle;
-  double min_steer_angle;
-  double length;
-  double width;
-  double max_acceleration;
-  double max_deceleration;
-
-  CAR_BASIC_INFO()
-  {
-	  model 				= SimulationCar;
-	  turning_radius 		= 5.2;
-	  wheel_base			= 2.7;
-	  max_speed_forward		= 3.0;
-	  min_speed_forward		= 0.0;
-	  max_speed_backword	= 1.0;
-	  max_steer_value		= 660;
-	  min_steer_value		= -660;
-	  max_brake_value		= 0;
-	  min_brake_value		= 0;
-	  max_steer_angle		= 0.42;
-	  min_steer_angle		= 0.42;
-	  length				= 4.3;
-	  width					= 1.82;
-	  max_acceleration		= 1.5; // m/s2
-	  max_deceleration		= -1.5; // 1/3 G
-  }
-
-  double CalcMaxSteeringAngle()
-  {
-    return  max_steer_angle;//asin(wheel_base/turning_radius);
-  }
-
-  double BoundSpeed(double s)
-  {
-	if(s &gt; 0 &amp;&amp; s &gt; max_speed_forward)
-		return max_speed_forward;
-	if(s &lt; 0 &amp;&amp; s &lt; max_speed_backword)
-		return max_speed_backword;
-	return s;
-  }
-
-  double BoundSteerAngle(double a)
-  {
-	if(a &gt; max_steer_angle)
-		return max_steer_angle;
-	if(a &lt; min_steer_angle)
-		return min_steer_angle;
-
-	return a;
-  }
-
-  double BoundSteerValue(double v)
-  {
-	  if(v &gt;= max_steer_value)
-		return max_steer_value;
-	if(v &lt;= min_steer_value)
-		return min_steer_value;
-
-	return v;
-  }
-
-};
-
-
-} /* namespace PlannerHNS */
-
-#endif /* PLANNERCOMMONDEF_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\PlannerH.h" new_path="" added_lines="0" deleted_lines="119">
				<diff>@@ -1,119 +0,0 @@
-/*
- * PlannerH.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#include "RSPlanner.h"
-#include "GridMap.h"
-
-#define START_POINT_MAX_DISTANCE 8 // meters
-#define GOAL_POINT_MAX_DISTANCE 8 // meters
-#define LANE_CHANGE_SMOOTH_FACTOR_DISTANCE 8 // meters
-
-namespace PlannerHNS
-{
-
-enum PLANDIRECTION {MOVE_FORWARD_ONLY, MOVE_BACKWARD_ONLY, 	MOVE_FREE};
-enum HeuristicConstrains {EUCLIDEAN, NEIGBORHOOD,DIRECTION };
-
-class PlannerH
-{
-public:
-	PlannerH();
-	virtual ~PlannerH(); 
-
-
-	/**
-	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles
-	 * @param start: Start position for the trajectory (x,y,theta)
-	 * @param goal:  Goal position (Destination point) (x,y,theta)
-	 * @param map:  2d grid map, ( cost map or occupancy grid.
-	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
-	 * @return path length
-	 */
-	double PlanUsingReedSheppWithObstacleDetection(const WayPoint&amp; start, const WayPoint&amp; goal, GridMap&amp; map, std::vector&lt;WayPoint&gt;&amp; genSmoothedPath,
-			const double pathDensity = 0.25, const double smoothFactor = 12.0);
-
-	/**
-	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles , but if there an obstacle on the trajectory function will fail. , also this function does not guaranteed to generate trajectories
-	 * @param start: Start position for the trajectory (x,y,theta)
-	 * @param goal:  Goal position (Destination point) (x,y,theta)
-	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
-	 * @return path length
-	 */
-	double PlanUsingReedShepp(const WayPoint&amp; start, const WayPoint&amp; goal, std::vector&lt;WayPoint&gt;&amp; generatedPath,
-			const double pathDensity = 0.25, const double smoothFactor = 12.0);
-
-
-	/**
-	 * @brief Generate Roll outs for global generated path
-	 * @param referencePath center lint reference path
-	 * @param carPos current car position
-	 * @param bEnableLaneChange is lane change is available
-	 * @param speed current car speed
-	 * @param microPlanDistance distance limit for roll outs
-	 * @param maxSpeed maximum forward speed
-	 * @param minSpeed minimum forward speed
-	 * @param carTipMargin 1st roll out smoothing parameter
-	 * @param rollInMargin 2nd roll out smoothing parameter
-	 * @param rollInSpeedFactor roll out 3rd smoothing parameter
-	 * @param pathDensity distance between every two waypoints in the generated trajectory
-	 * @param rollOutDensity distance between the center line and adjacent trajectories
-	 * @param rollOutNumber number of sampled trajectories
-	 * @param SmoothDataWeight general smoothing parameter , how smoother keep close to original data 0 - 0.5
-	 * @param SmoothWeight general smoothing parameter, how smoother is trying to pull away to form the shortest and strait line possible
-	 * @param SmoothTolerance performance measure , conjugate gradient conversion factor should be 0.1 - 0.01
-	 * @param speedProfileFactor how car should slow for corners
-	 * @param bHeadingSmooth follow car heading direction or center line path heading for sampling direction
-	 */
-	void GenerateRunoffTrajectory(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; referencePaths, const WayPoint&amp; carPos, const bool&amp; bEnableLaneChange, const double&amp; speed, const double&amp; microPlanDistance,
-				const double&amp; maxSpeed,const double&amp; minSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
-				const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
-				const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
-				const double&amp; SmoothTolerance, const double&amp; speedProfileFactor, const bool&amp; bHeadingSmooth,
-				const int&amp; iCurrGlobalPath, const int&amp; iCurrLocalTraj,
-				std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOutsPaths,
-				std::vector&lt;WayPoint&gt;&amp; sectionPath, std::vector&lt;WayPoint&gt;&amp; sampledPoints);
-
-	/**
-	 * @brief Path planning for structured environment using dynamic programming
-	 * @param lane
-	 * @param carPos
-	 * @param goalPos
-	 * @param prevWayPoint
-	 * @param maxPlanningDistance
-	 * @param globalPath
-	 * @param path
-	 * @return generated path length
-	 */
-	double PlanUsingDP(const WayPoint&amp; carPos,const WayPoint&amp; goalPos,
-			const double&amp; maxPlanningDistance, const bool bEnableLaneChange, const std::vector&lt;int&gt;&amp; globalPath,
-			RoadNetwork&amp; map, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, std::vector&lt;WayPoint*&gt;* all_cell_to_delete = 0);
-
-	 double PlanUsingDPRandom(const WayPoint&amp; start,
-	 		 const double&amp; maxPlanningDistance,
-	 		 RoadNetwork&amp; map,
-	 		 std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-
-	/**
-	 * @brief Return all possible trajectories from current position to max planning distance in all directions
-	 * @param lane
-	 * @param carPos
-	 * @param maxPlanningDistance
-	 * @param paths
-	 * @return
-	 */
-	double PredictPlanUsingDP(Lane* lane, const WayPoint&amp; carPos, const double&amp; maxPlanningDistance,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-	void DeleteWaypoints(std::vector&lt;WayPoint*&gt;&amp; wps);
-
-	//PlanningInternalParams m_Params;
-};
-
-}
-
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\PlanningHelpers.h" new_path="" added_lines="0" deleted_lines="170">
				<diff>@@ -1,170 +0,0 @@
-/*
- * PlanningHelpers.h
- *
- *  Created on: Jun 16, 2016
- *      Author: hatem
- */
-
-#ifndef PLANNINGHELPERS_H_
-#define PLANNINGHELPERS_H_
-
-#include &lt;math.h&gt;
-#include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "DataRW.h"
-#include "tinyxml.h"
-
-
-namespace PlannerHNS {
-
-#define distance2points(from , to) sqrt(pow(to.x - from.x, 2) + pow(to.y - from.y, 2))
-#define distance2pointsSqr(from , to) pow(to.x - from.x, 2) + pow(to.y - from.y, 2)
-#define pointNorm(v) sqrt(v.x*v.x + v.y*v.y)
-#define angle2points(from , to) atan2(to.y - from.y, to.x - from.x )
-#define LANE_CHANGE_SPEED_FACTOR 0.5
-#define LANE_CHANGE_COST 3.0 // meters
-#define BACKUP_STRAIGHT_PLAN_DISTANCE 60 //meters
-
-class PlanningHelpers {
-public:
-	PlanningHelpers();
-	virtual ~PlanningHelpers();
-
-	/**
-	 * @brief Find all relative information from the point p to the trajectory such as (perpendicular distance , closest next point , closest back point, distance from perpendicular intersection point to next point, distance from perpendicular intersection point to previous point)
-	 * @param trajectory list of waypoints
-	 * @param p query point
-	 * @param info collection of calculated information
-	 * @param prevIndex initial search index
-	 * @return true if success without errors, false otherwise
-	 */
-	static bool GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex = 0);
-
-	static bool GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectories, const WayPoint&amp; p, const double&amp; searchDistance, RelativeInfo&amp; info);
-
-	/**
-	 * @brief Find point on the trajectory after initial relative point with specific distance
-	 * @param trajectory list of waypoints
-	 * @param init_p initial relative point on trajectory
-	 * @param distance distance from initial relative point to follow point
-	 * @return point on trajectory
-	 */
-	static WayPoint GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; init_p, const double&amp; distance, unsigned int&amp; point_index);
-
-	/**
-	 * @brief Calculate the precise distance from projection of point p2 (relative) to projection of point 1 (relative)
-	 * @param trajectory list of waypoints
-	 * @param p1 first relative point
-	 * @param p2 second relative point
-	 * @return distance on trajectory
-	 */
-	static double GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; p1,const RelativeInfo&amp; p2);
-
-	/**
-	 * @brief Find the closest next point on the trajectory index
-	 * @param trajectory list of waypoints
-	 * @param p query point
-	 * @param prevIndex initial search index
-	 * @return index of the closest next point from trajectory
-	 */
-	static int GetClosestNextPointIndex(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-
-	static int GetClosestNextPointIndexDirection(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-
-
-	static int GetClosestPointIndex_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex = 0 );
-	static WayPoint GetPerpendicularOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, double&amp; distance, const int&amp; prevIndex = 0);
-	static double GetPerpDistanceToTrajectorySimple_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-	static double GetPerpDistanceToVectorSimple_obsolete(const WayPoint&amp; p1, const WayPoint&amp; p2, const WayPoint&amp; pose);
-	static WayPoint GetNextPointOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const double&amp; distance, const int&amp; currIndex = 0);
-	static double GetDistanceOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
-
-
-	static void FixPathDensity(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; distanceDensity);
-	static void SmoothPath(std::vector&lt;WayPoint&gt;&amp; path, double weight_data =0.25,double weight_smooth = 0.25,double tolerance = 0.01);
-	static double CalcCircle(const GPSPoint&amp; pt1, const GPSPoint&amp; pt2, const GPSPoint&amp; pt3, GPSPoint&amp; center);
-	static double CalcAngleAndCost(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0, const bool&amp; bSmooth = true );
-	//static double CalcAngleAndCostSimple(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0);
-	static double CalcAngleAndCostAndCurvatureAnd2D(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0);
-
-	static double GetAccurateDistanceOnTrajectory(std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
-
-	static void ExtractPartFromPointToDistance(const std::vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
-			const double&amp; pathDensity, std::vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance);
-
-	static void CalculateRollInTrajectories(const WayPoint&amp; carPos, const double&amp; speed, const std::vector&lt;WayPoint&gt;&amp; originalCenter, int&amp; start_index,
-			int&amp; end_index, std::vector&lt;double&gt;&amp; end_laterals ,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; rollInPaths, const double&amp; max_roll_distance,
-			const double&amp; maxSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
-			const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
-			const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
-			const double&amp; SmoothTolerance, const bool&amp; bHeadingSmooth,
-			std::vector&lt;WayPoint&gt;&amp; sampledPoints);
-
-
-	static void SmoothSpeedProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
-	static void SmoothCurvatureProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance = 0.1);
-	static void SmoothWayPointsDirections(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
-
-	static void GenerateRecommendedSpeed(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor);
-//	static WayPoint* BuildPlanningSearchTree(Lane* l, const WayPoint&amp; prevWayPointIndex,
-//			const WayPoint&amp; startPos, const WayPoint&amp; goalPos,
-//			const std::vector&lt;int&gt;&amp; globalPath, const double&amp; DistanceLimit,
-//			int&amp; nMaxLeftBranches, int&amp; nMaxRightBranches,
-//			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static WayPoint* BuildPlanningSearchTreeV2(WayPoint* pStart,
-			const WayPoint&amp; goalPos,
-			const std::vector&lt;int&gt;&amp; globalPath, const double&amp; DistanceLimit,
-			const bool&amp; bEnableLaneChange,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static WayPoint* BuildPlanningSearchTreeStraight(WayPoint* pStart,
-			const double&amp; DistanceLimit,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static int PredictiveDP(WayPoint* pStart, const double&amp; DistanceLimit,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete, std::vector&lt;WayPoint*&gt;&amp; end_waypoints);
-
-	static bool CheckLaneIdExits(const std::vector&lt;int&gt;&amp; lanes, const Lane* pL);
-	static WayPoint* CheckLaneExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const Lane* pL);
-	static WayPoint* CheckNodeExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const WayPoint* pL);
-
-	static WayPoint* CreateLaneHeadCell(Lane* pLane, WayPoint* pLeft, WayPoint* pRight,
-			WayPoint* pBack);
-	static double GetLanePoints(Lane* l, const WayPoint&amp; prevWayPointIndex,
-			const double&amp; minDistance , const double&amp; prevCost, std::vector&lt;WayPoint&gt;&amp; points);
-
-	static WayPoint* GetMinCostCell(const std::vector&lt;WayPoint*&gt;&amp; cells, const std::vector&lt;int&gt;&amp; globalPathIds);
-
-	static void TraversePathTreeBackwards(WayPoint* pHead, WayPoint* pStartWP, const std::vector&lt;int&gt;&amp; globalPathIds,
-			std::vector&lt;WayPoint&gt;&amp; localPath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; localPaths);
-
-	static void ExtractPlanAlernatives(const std::vector&lt;WayPoint&gt;&amp; singlePath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; allPaths);
-
-	static std::vector&lt;int&gt; GetUniqueLeftRightIds(const std::vector&lt;WayPoint&gt;&amp; path);
-
-	static bool FindInList(const std::vector&lt;int&gt;&amp; list,const int&amp; x);
-	static void RemoveWithValue(std::vector&lt;int&gt;&amp; list,const int&amp; x);
-
-	static ACTION_TYPE GetBranchingDirection(WayPoint&amp; currWP, WayPoint&amp; nextWP);
-
-	static void CalcContourPointsForDetectedObjects(const WayPoint&amp; currPose, std::vector&lt;DetectedObject&gt;&amp; obj_list, const double&amp; filterDistance = 100);
-
-	static double GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; pose, const double&amp; distance);
-	static bool CompareTrajectories(const std::vector&lt;WayPoint&gt;&amp; path1, const std::vector&lt;WayPoint&gt;&amp; path2);
-
-	static double GetDistanceToClosestStopLineAndCheck(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; p, int&amp; stopLineID,int&amp; stopSignID, int&amp; trafficLightID, const int&amp; prevIndex = 0);
-
-	static void WritePathToFile(const std::string&amp; fileName, const std::vector&lt;WayPoint&gt;&amp; path);
-
-	static void TestQuadraticSpline(const std::vector&lt;WayPoint&gt;&amp; center_line, std::vector&lt;WayPoint&gt;&amp; path);
-	static double frunge ( double x );
-	static double fprunge ( double x );
-	static double fpprunge ( double x );
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* PLANNINGHELPERS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\RSPlanner.h" new_path="" added_lines="0" deleted_lines="77">
				<diff>@@ -1,77 +0,0 @@
-/*
- * RSPlanner.h
- *
- *  Created on: Aug 9, 2015
- *      Author: hatem
- */
-
-#include "PlanningHelpers.h"
-#ifndef RSPLANNERSA_H_
-#define RSPLANNERSA_H_
-
-namespace PlannerHNS
-{
-
-#define EPS1 1.0e-12
-#define EPS2 1.0e-12
-#define EPS3 1.0e-12
-#define EPS4 1.0e-12
-#define MYINFINITY 1000000
-
-#define MPI 3.1415926536
-#define MPIMUL2 6.2831853072
-#define MPIDIV2 1.5707963268
-
-
-
-
-class RSPlanner
-{
-public:
-	double RADCURV ;
-	double RADCURVMUL2 ;
-	double RADCURVMUL4 ;
-	double SQRADCURV ;
-	double SQRADCURVMUL2 ;
-	double PATHDENSITY;
-	RSPlanner(double curvatureFactor = 15.6);
-	virtual ~RSPlanner();
-
-	double min_length_rs(const double&amp; x1,const double&amp; y1,const double&amp; t1,const double&amp; x2,const double&amp; y2,const double&amp; t2,int&amp; numero,double&amp; t,double&amp; u,double&amp; v);
-	int constRS(int num,double t,double u,double v,double x1,double y1,double t1,double delta,std::vector&lt;WayPoint&gt;&amp; path);
-
-private:
-	struct ConfigItem
-	{
-		double length;
-		int num;
-		double t,u,v;
-	};
-
-
-	double mod2pi(const double&amp; a);
-	double my_atan2(const double&amp;  y, const double&amp; x);
-	double c_c_c(const double&amp; x,const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_cc(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double cscb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double ccu_cuc(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_cucu_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2sca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2scb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2sc2_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double cc_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csc2_ca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csc2_cb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-
-	double reed_shepp(const double&amp; x1,const double&amp; y1,const double&amp; t1,const double&amp; x2,const double&amp; y2,const double&amp; t2,int&amp; numero,double&amp; tr,double&amp; ur,double&amp; vr);
-
-	int fct_curve(const int&amp; ty,const int&amp; orientation,const double&amp; val,double&amp; x1,double&amp; y1,double&amp; t1,const double&amp; delta,std::vector&lt;WayPoint&gt;&amp; path,int n);
-
-
-
-};
-
-} /* namespace PlannerZNS */
-
-#endif /* RSPLANNER_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\RoadNetwork.h" new_path="" added_lines="0" deleted_lines="1018">
				<diff>@@ -1,1018 +0,0 @@
-/*
- * RoadNetwork.h
- *
- *  Created on: May 19, 2016
- *      Author: hatem
- */
-
-#ifndef ROADNETWORK_H_
-#define ROADNETWORK_H_
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;sstream&gt;
-#include "UtilityH.h"
-
-#define OPENPLANNER_ENABLE_LOGS
-
-namespace PlannerHNS
-{
-
-
-enum DIRECTION_TYPE {	FORWARD_DIR, FORWARD_LEFT_DIR, FORWARD_RIGHT_DIR,
-	BACKWARD_DIR, BACKWARD_LEFT_DIR, BACKWARD_RIGHT_DIR, STANDSTILL_DIR};
-
-enum OBSTACLE_TYPE {SIDEWALK, TREE, CAR, TRUCK, HOUSE, PEDESTRIAN, CYCLIST, GENERAL_OBSTACLE};
-
-enum DRIVABLE_TYPE {DIRT, TARMAC, PARKINGAREA, INDOOR, GENERAL_AREA};
-
-enum GLOBAL_STATE_TYPE {G_WAITING_STATE, G_PLANING_STATE, G_FORWARD_STATE, G_BRANCHING_STATE, G_FINISH_STATE};
-
-enum STATE_TYPE {INITIAL_STATE, WAITING_STATE, FORWARD_STATE, STOPPING_STATE, EMERGENCY_STATE,
-	TRAFFIC_LIGHT_STOP_STATE,TRAFFIC_LIGHT_WAIT_STATE, STOP_SIGN_STOP_STATE, STOP_SIGN_WAIT_STATE, FOLLOW_STATE, LANE_CHANGE_STATE, OBSTACLE_AVOIDANCE_STATE, GOAL_STATE, FINISH_STATE};
-
-enum LIGHT_INDICATOR {INDICATOR_LEFT, INDICATOR_RIGHT, INDICATOR_BOTH , INDICATOR_NONE};
-
-enum SHIFT_POS {SHIFT_POS_PP = 0x60, SHIFT_POS_RR = 0x40, SHIFT_POS_NN = 0x20,
-	SHIFT_POS_DD = 0x10, SHIFT_POS_BB = 0xA0, SHIFT_POS_SS = 0x0f, SHIFT_POS_UU = 0xff };
-
-enum ACTION_TYPE {FORWARD_ACTION, BACKWARD_ACTION, STOP_ACTION, LEFT_TURN_ACTION,
-	RIGHT_TURN_ACTION, U_TURN_ACTION, SWERVE_ACTION, OVERTACK_ACTION};
-
-
-class Lane;
-class TrafficLight;
-
-class ObjTimeStamp
-{
-public:
-	timespec tStamp;
-
-	ObjTimeStamp()
-	{
-		tStamp.tv_nsec = 0;
-		tStamp.tv_sec = 0;
-	}
-};
-
-class POINT2D
-{
-public:
-    double x;
-    double y;
-    double z;
-    POINT2D()
-    {
-      x=0;y=0;z=0;
-    }
-    POINT2D(double px, double py, double pz = 0)
-    {
-      x = px;
-      y = py;
-      z = pz;
-    }
-};
-
-
-
-class RECTANGLE
-
-{
-public:
-  POINT2D bottom_left;
-  POINT2D top_right;
-  double width;
-  double length;
-  bool bObstacle;
-
-
-  inline bool PointInRect(POINT2D p)
-  {
-    return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
-  }
-
-  inline bool HitTest(POINT2D p)
-  {
-    return PointInRect(p) &amp;&amp; bObstacle;
-  }
-
-  RECTANGLE()
-  {
-	  width=0;
-	  length = 0;
-    bObstacle = true;
-  }
-
-  virtual ~RECTANGLE(){}
-};
-
-class GPSPoint
-{
-public:
-	double lat, x;
-	double lon, y;
-	double alt, z;
-	double dir, a;
-
-	GPSPoint()
-	{
-		lat = x = 0;
-		lon = y = 0;
-		alt = z = 0;
-		dir = a = 0;
-	}
-
-	GPSPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
-	{
-		this-&gt;x = x;
-		this-&gt;y = y;
-		this-&gt;z = z;
-		this-&gt;a = a;
-
-		lat = 0;
-		lon = 0;
-		alt = 0;
-		dir = 0;
-	}
-
-	std::string ToString()
-	{
-		std::stringstream str;
-		str.precision(12);
-		str &lt;&lt; "X:" &lt;&lt; x &lt;&lt; ", Y:" &lt;&lt; y &lt;&lt; ", Z:" &lt;&lt; z &lt;&lt; ", A:" &lt;&lt; a &lt;&lt; std::endl;
-		str &lt;&lt; "Lon:" &lt;&lt; lon &lt;&lt; ", Lat:" &lt;&lt; lat &lt;&lt; ", Alt:" &lt;&lt; alt &lt;&lt; ", Dir:" &lt;&lt; dir &lt;&lt; std::endl;
-		return str.str();
-	}
-};
-
-class PolygonShape
-{
-public:
-	std::vector&lt;GPSPoint&gt; points;
-
-	inline int PointInsidePolygon(const PolygonShape&amp; polygon,const GPSPoint&amp; p)
-	{
-		int counter = 0;
-		  int i;
-		  double xinters;
-		  GPSPoint p1,p2;
-		  int N = polygon.points.size();
-		  if(N &lt;=0 ) return -1;
-
-		  p1 = polygon.points.at(0);
-		  for (i=1;i&lt;=N;i++)
-		  {
-		    p2 = polygon.points.at(i % N);
-
-		    if (p.y &gt; MIN(p1.y,p2.y))
-		    {
-		      if (p.y &lt;= MAX(p1.y,p2.y))
-		      {
-		        if (p.x &lt;= MAX(p1.x,p2.x))
-		        {
-		          if (p1.y != p2.y)
-		          {
-		            xinters = (p.y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
-		            if (p1.x == p2.x || p.x &lt;= xinters)
-		              counter++;
-		          }
-		        }
-		      }
-		    }
-		    p1 = p2;
-		  }
-
-		  if (counter % 2 == 0)
-		    return 0;
-		  else
-		    return 1;
-	}
-};
-
-class MapItem
-{
-public:
-  int id;
-  POINT2D sp; //start point
-  POINT2D ep; // end point
-  GPSPoint center;
-  double c; //curvature
-  double w; //width
-  double l; //length
-  std::string fileName; //
-  std::vector&lt;POINT2D&gt; polygon;
-
-
-  MapItem(int ID, POINT2D start, POINT2D end, double curvature, double width, double length, std::string objName)
-  {
-    id = ID;
-    sp = start;
-    ep = end;
-    c = curvature;
-    w = width;
-    l = length;
-    fileName = objName;
-
-  }
-
-  MapItem()
-  {
-    id = 0; c = 0; w = 0; l = 0;
-  }
-
-  virtual ~MapItem(){}
-
-  MapItem(const MapItem &amp; cmi)
-  {
-        id = cmi.id;
-        sp = cmi.sp;
-        ep = cmi.ep;
-        c = cmi.c;
-        w = cmi.w;
-        l = cmi.l;
-        fileName = cmi.fileName;
-  }
-  MapItem &amp;operator=(const MapItem &amp;cmi)
-  {
-    this-&gt;id = cmi.id;
-      this-&gt;sp = cmi.sp;
-      this-&gt;ep = cmi.ep;
-      this-&gt;c = cmi.c;
-      this-&gt;w = cmi.w;
-      this-&gt;l = cmi.l;
-      this-&gt;fileName = cmi.fileName;
-      return *this;
-  }
-
-  virtual int operator==(const MapItem &amp;mi) const
-    {
-      return this-&gt;id == mi.id;
-    }
-};
-
-class Obstacle : public MapItem
-{
-  public:
-    OBSTACLE_TYPE t;
-
-    Obstacle(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,OBSTACLE_TYPE type, std::string fileName ) : MapItem(ID, start, end, curvature, width, length, fileName)
-  {
-      t = type;
-  }
-    virtual ~Obstacle()
-    {
-    }
-
-    Obstacle() : MapItem()
-       {
-      t = SIDEWALK;
-       }
-
-    Obstacle(const Obstacle&amp; ob) : MapItem(ob)
-      {
-        t = ob.t;
-      }
-
-    Obstacle&amp; operator=(const Obstacle&amp; ob)
-      {
-      this-&gt;id = ob.id;
-      this-&gt;sp = ob.sp;
-      this-&gt;ep = ob.ep;
-      this-&gt;c = ob.c;
-      this-&gt;w = ob.w;
-      this-&gt;l = ob.l;
-      this-&gt;t = ob.t;
-      this-&gt;fileName = ob.fileName;
-      return *this;
-      }
-
-      virtual int operator==(const Obstacle &amp;ob) const
-          {
-            return this-&gt;id == ob.id &amp;&amp; this-&gt;t == ob.t;
-          }
-};
-
-class DrivableArea : public MapItem
-{
-public:
-  DRIVABLE_TYPE t; // drivable area type
-
-  DrivableArea(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,DRIVABLE_TYPE type, std::string fileName ) : MapItem( ID, start, end, curvature, width, length, fileName)
-  {
-    t = type;
-  }
-
-  virtual ~DrivableArea()
-  {
-
-  }
-
-  DrivableArea() : MapItem()
-    {
-      t = PARKINGAREA;
-    }
-
-  DrivableArea(const DrivableArea&amp; da) : MapItem(da)
-  {
-    t = da.t;
-  }
-
-  DrivableArea&amp; operator=(const DrivableArea&amp; da)
-  {
-    this-&gt;id = da.id;
-    this-&gt;sp = da.sp;
-    this-&gt;ep = da.ep;
-    this-&gt;c = da.c;
-    this-&gt;w = da.w;
-    this-&gt;l = da.l;
-    this-&gt;t = da.t;
-    this-&gt;fileName = da.fileName;
-    return *this;
-  }
-
-  virtual int operator==(const DrivableArea &amp;da) const
-      {
-        return this-&gt;id == da.id &amp;&amp; this-&gt;t == da.t;
-      }
-
-};
-
-
-
-class Rotation
-{
-public:
-	double x;
-	double y;
-	double z;
-	double w;
-
-	Rotation()
-	{
-		x = 0;
-		y = 0;
-		z = 0;
-		w = 0;
-	}
-};
-
-class WayPoint
-{
-public:
-	GPSPoint	pos;
-	Rotation 	rot;
-	double  	v;
-	double  	cost;
-	double  	timeCost;
-	double  	totalReward;
-	double  	collisionCost;
-	double 		laneChangeCost;
-	int 		laneId;
-	int 		id;
-	int 		LeftLaneId;
-	int 		RightLaneId;
-	int 		stopLineID;
-	DIRECTION_TYPE bDir;
-
-	Lane* pLane;
-	WayPoint* pLeft;
-	WayPoint* pRight;
-	std::vector&lt;int&gt; 	toIds;
-	std::vector&lt;int&gt; 	fromIds;
-	std::vector&lt;WayPoint*&gt; pFronts;
-	std::vector&lt;WayPoint*&gt; pBacks;
-	std::vector&lt;std::pair&lt;ACTION_TYPE, double&gt; &gt; actionCost;
-
-	WayPoint()
-	{
-		id = 0;
-		v = 0;
-		cost = 0;
-		laneId = -1;
-		pLane  = 0;
-		pLeft = 0;
-		pRight = 0;
-		bDir = FORWARD_DIR;
-		LeftLaneId = 0;
-		RightLaneId = 0;
-		timeCost = 0;
-		totalReward = 0;
-		collisionCost = 0;
-		laneChangeCost = 0;
-		stopLineID = -1;
-	}
-
-	WayPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
-	{
-		pos.x = x;
-		pos.y = y;
-		pos.z = z;
-		pos.a = a;
-
-		id = 0;
-		v = 0;
-		cost = 0;
-		laneId = -1;
-		pLane  = 0;
-		pLeft = 0;
-		pRight = 0;
-		bDir = FORWARD_DIR;
-		LeftLaneId = 0;
-		RightLaneId = 0;
-		timeCost = 0;
-		totalReward = 0;
-		collisionCost = 0;
-		laneChangeCost = 0;
-		stopLineID = -1;
-	}
-};
-
-class RelativeInfo
-{
-public:
-	double perp_distance;
-	double to_front_distance; //negative
-	double from_back_distance;
-	int iFront;
-	int iBack;
-	int iGlobalPath;
-	WayPoint perp_point;
-	double angle_diff; // degrees
-
-	RelativeInfo()
-	{
-		perp_distance = 0;
-		to_front_distance = 0;
-		from_back_distance = 0;
-		iFront = 0;
-		iBack = 0;
-		iGlobalPath = 0;
-		angle_diff = 0;
-	}
-};
-
-class StopLine
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-	int trafficLightID;
-	int stopSignID;
-	std::vector&lt;GPSPoint&gt; points;
-	Lane* pLane;
-
-	StopLine()
-	{
-		id    = 0;
-		laneId =0;
-		roadId =0;
-		pLane = 0;
-		trafficLightID = -1;
-		stopSignID = -1;
-	}
-};
-
-class WaitingLine
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-	std::vector&lt;GPSPoint&gt; points;
-	Lane* pLane;
-
-	WaitingLine()
-	{
-		id    = 0;
-		laneId =0;
-		roadId =0;
-		pLane = 0;
-	}
-};
-
-enum TrafficSignTypes {UNKNOWN_SIGN, STOP_SIGN, MAX_SPEED_SIGN, MIN_SPEED_SIGN};
-
-class TrafficSign
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-
-	GPSPoint pos;
-	TrafficSignTypes signType;
-	double value;
-	double fromValue;
-	double toValue;
-	std::string strValue;
-	timespec timeValue;
-	timespec fromTimeValue;
-	timespec toTimeValue;
-
-	Lane* pLane;
-
-	TrafficSign()
-	{
-		id    		= 0;
-		laneId 		= 0;
-		roadId		= 0;
-		signType  	= UNKNOWN_SIGN;
-		value		= 0;
-		fromValue	= 0;
-		toValue		= 0;
-//		timeValue	= 0;
-//		fromTimeValue = 0;
-//		toTimeValue	= 0;
-		pLane 		= 0;
-	}
-};
-
-enum TrafficLightState {UNKNOWN_LIGHT, RED_LIGHT, GREEN_LIGHT, YELLOW_LIGHT, LEFT_GREEN, FORWARD_GREEN, RIGHT_GREEN, FLASH_YELLOW, FLAH_RED};
-
-class TrafficLight
-{
-public:
-	int id;
-	GPSPoint pos;
-	TrafficLightState lightState;
-	double stoppingDistance;
-	std::vector&lt;int&gt; laneIds;
-	std::vector&lt;Lane*&gt; pLanes;
-
-	TrafficLight()
-	{
-		stoppingDistance = 2;
-		id 			= 0;
-		lightState	= GREEN_LIGHT;
-	}
-
-	bool CheckLane(const int&amp; laneId)
-	{
-		for(unsigned int i=0; i &lt; laneIds.size(); i++)
-		{
-			if(laneId == laneIds.at(i))
-				return true;
-		}
-		return false;
-	}
-};
-
-enum RoadSegmentType {NORMAL_ROAD, INTERSECTION_ROAD, UTURN_ROAD, EXIT_ROAD, MERGE_ROAD, HIGHWAY_ROAD};
-
-class RoadSegment
-{
-public:
-	int id;
-	RoadSegmentType roadType;
-	std::vector&lt;int&gt; fromIds;
-	std::vector&lt;int&gt; toIds;
-	std::vector&lt;Lane&gt; Lanes;
-
-
-	std::vector&lt;RoadSegment*&gt; fromLanes;
-	std::vector&lt;RoadSegment*&gt; toLanes;
-
-	RoadSegment()
-	{
-		id = 0;
-		roadType = NORMAL_ROAD;
-	}
-
-
-};
-
-enum LaneType{NORMAL_LANE, MERGE_LANE, EXIT_LANE, BUS_LANE, BUS_STOP_LANE, EMERGENCY_LANE};
-
-class Lane
-{
-public:
-	int id;
-	int roadId;
-	int areaId;
-	int fromAreaId;
-	int toAreaId;
-	std::vector&lt;int&gt; fromIds;
-	std::vector&lt;int&gt; toIds;
-	int num; //lane number in the road segment from left to right
-	double speed;
-	double length;
-	double dir;
-	LaneType type;
-	std::vector&lt;TrafficSign&gt; signs;
-	std::vector&lt;WayPoint&gt; points;
-	std::vector&lt;TrafficLight&gt; trafficlights;
-	std::vector&lt;StopLine&gt; stopLines;
-	WaitingLine waitingLine;
-
-	std::vector&lt;Lane*&gt; fromLanes;
-	std::vector&lt;Lane*&gt; toLanes;
-	Lane* pLeftLane;
-	Lane* pRightLane;
-
-	RoadSegment * pRoad;
-
-	Lane()
-	{
-		id 		= 0;
-		num		= 0;
-		speed 	= 0;
-		length 	= 0;
-		dir		= 0;
-		type 	= NORMAL_LANE;
-		pLeftLane = 0;
-		pRightLane = 0;
-		pRoad	= 0;
-		roadId = 0;
-		areaId = 0;
-		fromAreaId = 0;
-		toAreaId = 0;
-	}
-
-};
-
-class RoadNetwork
-{
-public:
-	std::vector&lt;RoadSegment&gt; roadSegments;
-	std::vector&lt;TrafficLight&gt; trafficLights;
-	std::vector&lt;StopLine&gt; stopLines;
-
-};
-
-class VehicleState : public ObjTimeStamp
-{
-public:
-	double speed;
-	double steer;
-	SHIFT_POS shift;
-
-	VehicleState()
-	{
-		speed = 0;
-		steer = 0;
-		shift = SHIFT_POS_NN;
-	}
-
-};
-
-class BehaviorState
-{
-public:
-	STATE_TYPE state;
-	double maxVelocity;
-	double minVelocity;
-	double stopDistance;
-	double followVelocity;
-	double followDistance;
-	LIGHT_INDICATOR indicator;
-	bool bNewPlan;
-
-
-	BehaviorState()
-	{
-		state = INITIAL_STATE;
-		maxVelocity = 0;
-		minVelocity = 0;
-		stopDistance = 0;
-		followVelocity = 0;
-		followDistance = 0;
-		indicator  = INDICATOR_NONE;
-		bNewPlan = false;
-
-	}
-
-};
-
-class DetectedObject
-{
-public:
-	int id;
-	OBSTACLE_TYPE t;
-	WayPoint center;
-	WayPoint predicted_center;
-	std::vector&lt;GPSPoint&gt; contour;
-	double w;
-	double l;
-	double h;
-	double distance_to_center;
-	DetectedObject()
-	{
-		id = 0;
-		w = 0;
-		l = 0;
-		h = 0;
-		t = GENERAL_OBSTACLE;
-		distance_to_center = 0;
-	}
-
-};
-
-class PlanningParams
-{
-public:
-	double 	maxSpeed;
-	double 	minSpeed;
-	double 	planningDistance;
-	double 	microPlanDistance;
-	double 	carTipMargin;
-	double 	rollInMargin;
-	double 	rollInSpeedFactor;
-	double 	pathDensity;
-	double 	rollOutDensity;
-	int 	rollOutNumber;
-	double 	horizonDistance;
-	double 	minFollowingDistance; //should be bigger than Distance to follow
-	double 	minDistanceToAvoid; // should be smaller than minFollowingDistance and larger than maxDistanceToAvoid
-	double	maxDistanceToAvoid; // should be smaller than minDistanceToAvoid
-	double 	speedProfileFactor;
-	double 	smoothingDataWeight;
-	double 	smoothingSmoothWeight;
-	double 	smoothingToleranceError;
-
-	double verticalSafetyDistance;
-	double horizontalSafetyDistancel;
-
-	bool 	enableLaneChange;
-	bool 	enableSwerving;
-	bool 	enableFollowing;
-	bool 	enableHeadingSmoothing;
-	bool 	enableTrafficLightBehavior;
-	bool 	enableStopSignBehavior;
-
-	bool 	enabTrajectoryVelocities;
-
-	PlanningParams()
-	{
-		maxSpeed 						= 3;
-		minSpeed 						= 0;
-		planningDistance 				= 10000;
-		microPlanDistance 				= 30;
-		carTipMargin					= 4.0;
-		rollInMargin					= 12.0;
-		rollInSpeedFactor				= 0.25;
-		pathDensity						= 0.25;
-		rollOutDensity					= 0.5;
-		rollOutNumber					= 4;
-		horizonDistance					= 120;
-		minFollowingDistance			= 35;
-		minDistanceToAvoid				= 15;
-		maxDistanceToAvoid				= 5;
-		speedProfileFactor				= 1.0;
-		smoothingDataWeight				= 0.45;
-		smoothingSmoothWeight			= 0.3;
-		smoothingToleranceError			= 0.05;
-
-		verticalSafetyDistance 			= 0.0;
-		horizontalSafetyDistancel		= 0.0;
-
-		enableHeadingSmoothing			= false;
-		enableSwerving 					= false;
-		enableFollowing					= false;
-		enableTrafficLightBehavior		= false;
-		enableLaneChange 				= false;
-		enableStopSignBehavior			= false;
-		enabTrajectoryVelocities		= false;
-	}
-};
-
-class HMIPreCalculatedConditions
-{
-public:
-
-	HMIPreCalculatedConditions()
-	{
-
-	}
-};
-
-class PreCalculatedConditions
-{
-public:
-	//-------------------------------------------//
-	//Global Goals
-	int 				currentGoalID;
-	int 				prevGoalID;
-	//-------------------------------------------//
-	//Following
-	double 				distanceToNext;
-	double				velocityOfNext;
-	//-------------------------------------------//
-	//For Lane Change
-	int 				iPrevSafeLane;
-	int 				iCurrSafeLane;
-	double				distanceToGoBack;
-	double 				timeToGoBack;
-	double 				distanceToChangeLane;
-	double				timeToChangeLane;
-	int 				currentLaneID;
-	int 				originalLaneID;
-	int 				targetLaneID;
-	bool 				bUpcomingLeft;
-	bool 				bUpcomingRight;
-	bool				bCanChangeLane;
-	bool				bTargetLaneSafe;
-	//-------------------------------------------//
-	//Traffic Lights &amp; Stop Sign
-	int 				currentStopSignID;
-	int 				prevStopSignID;
-	int 				currentTrafficLightID;
-	int 				prevTrafficLightID;
-	bool 				bTrafficIsRed; //On , off status
-	//-------------------------------------------//
-	//Swerving
-	int 				iPrevSafeTrajectory;
-	int 				iCurrSafeTrajectory;
-	int 				iCentralTrajectory;
-	bool				bFullyBlock;
-	LIGHT_INDICATOR 	indicator;
-
-	//-------------------------------------------//
-	//General
-	bool 				bNewGlobalPath;
-	bool 				bRePlan;
-	double 				currentVelocity;
-	double				minStoppingDistance; //comfortably
-	int 				bOutsideControl; // 0 waiting, 1 start, 2 Green Traffic Light, 3 Red Traffic Light, 5 Emergency Stop
-	bool				bGreenOutsideControl;
-	std::vector&lt;double&gt; stoppingDistances;
-
-
-	double distanceToStop()
-	{
-		if(stoppingDistances.size()==0) return 0;
-		double minS = stoppingDistances.at(0);
-		for(unsigned int i=0; i&lt; stoppingDistances.size(); i++)
-		{
-			if(stoppingDistances.at(i) &lt; minS)
-				minS = stoppingDistances.at(i);
-		}
-		return minS;
-	}
-
-	PreCalculatedConditions()
-	{
-		currentGoalID 			= 0;
-		prevGoalID				= -1;
-		currentVelocity 		= 0;
-		minStoppingDistance		= 1;
-		bOutsideControl			= 0;
-		bGreenOutsideControl	= false;
-		//distance to stop
-		distanceToNext			= -1;
-		velocityOfNext			= 0;
-		currentStopSignID		= -1;
-		prevStopSignID			= -1;
-		currentTrafficLightID	= -1;
-		prevTrafficLightID		= -1;
-		bTrafficIsRed			= false;
-		iCurrSafeTrajectory		= -1;
-		bFullyBlock				= false;
-
-		iPrevSafeTrajectory		= -1;
-		iCentralTrajectory		= -1;
-		bRePlan					= false;
-		bNewGlobalPath			= false;
-
-		bCanChangeLane			= false;
-		distanceToGoBack		= 0;
-		timeToGoBack			= 0;
-		distanceToChangeLane	= 0;
-		timeToChangeLane		= 0;
-		bTargetLaneSafe			= true;
-		bUpcomingLeft			= false;
-		bUpcomingRight			= false;
-		targetLaneID			= -1;
-		currentLaneID			= -1;
-		originalLaneID			= -1;
-		iCurrSafeLane 			= -1;
-		iPrevSafeLane			= -1;
-
-		indicator 				= INDICATOR_NONE;
-	}
-
-	virtual ~PreCalculatedConditions(){}
-
-	std::string ToStringHeader()
-	{
-		return "Time:General&gt;&gt;:currentVelocity:distanceToStop:minStoppingDistance:bStartBehaviorGenerator:bGoalReached:"
-				"Following&gt;&gt;:velocityOfNext:distanceToNext:"
-				"TrafficLight&gt;&gt;:currentTrafficLightID:bTrafficIsRed:"
-				"Swerving&gt;&gt;:iSafeTrajectory:bFullyBlock:";
-	}
-
-	std::string ToString(STATE_TYPE beh)
-	{
-		std::string str = "Unknown";
-		switch(beh)
-		{
-		case PlannerHNS::INITIAL_STATE:
-			str = "Init";
-			break;
-		case PlannerHNS::WAITING_STATE:
-			str = "Waiting";
-			break;
-		case PlannerHNS::FORWARD_STATE:
-			str = "Forward";
-			break;
-		case PlannerHNS::STOPPING_STATE:
-			str = "Stop";
-			break;
-		case PlannerHNS::FINISH_STATE:
-			str = "End";
-			break;
-		case PlannerHNS::FOLLOW_STATE:
-			str = "Follow";
-			break;
-		case PlannerHNS::OBSTACLE_AVOIDANCE_STATE:
-			str = "Swerving";
-			break;
-		case PlannerHNS::TRAFFIC_LIGHT_STOP_STATE:
-			str = "Light Stop";
-			break;
-		case PlannerHNS::TRAFFIC_LIGHT_WAIT_STATE:
-			str = "Light Wait";
-			break;
-		case PlannerHNS::STOP_SIGN_STOP_STATE:
-			str = "Sign Stop";
-			break;
-		case PlannerHNS::STOP_SIGN_WAIT_STATE:
-			str = "Sign Wait";
-			break;
-		default:
-			str = "Unknown";
-			break;
-		}
-
-		return str;
-	}
-};
-
-class TrajectoryCost
-{
-public:
-	int index;
-	int relative_index;
-	double closest_obj_velocity;
-	double distance_from_center;
-	double priority_cost; //0 to 1
-	double transition_cost; // 0 to 1
-	double closest_obj_cost; // 0 to 1
-	double cost;
-	double closest_obj_distance;
-
-	int lane_index;
-	double lane_change_cost;
-	double lateral_cost;
-	double longitudinal_cost;
-	bool bBlocked;
-	std::vector&lt;std::pair&lt;int, double&gt; &gt; lateral_costs;
-
-
-	TrajectoryCost()
-	{
-		lane_index = -1;
-		index = -1;
-		relative_index = -100;
-		closest_obj_velocity = 0;
-		priority_cost = 0;
-		transition_cost = 0;
-		closest_obj_cost = 0;
-		distance_from_center = 0;
-		cost = 0;
-		closest_obj_distance = -1;
-		lane_change_cost = 0;
-		lateral_cost = 0;
-		longitudinal_cost = 0;
-		bBlocked = false;
-	}
-
-	std::string ToString()
-	{
-		std::ostringstream str;
-		str.precision(4);
-		str &lt;&lt; "LaneIndex    : " &lt;&lt; lane_index;
-		str &lt;&lt; ", Index      : " &lt;&lt; relative_index;
-		str &lt;&lt; ", TotalCost  : " &lt;&lt; cost;
-		str &lt;&lt; ", Priority   : " &lt;&lt; priority_cost;
-		str &lt;&lt; ", Transition : " &lt;&lt; transition_cost;
-		str &lt;&lt; ", Lateral    : " &lt;&lt; lateral_cost;
-		str &lt;&lt; ", Longitu    : " &lt;&lt; longitudinal_cost;
-		str &lt;&lt; ", LaneChange : " &lt;&lt; lane_change_cost;
-		str &lt;&lt; ", Blocked    : " &lt;&lt; bBlocked;
-		str &lt;&lt; "\n";
-		for (unsigned int i=0; i&lt;lateral_costs.size(); i++ )
-		{
-			str &lt;&lt; " - (" &lt;&lt; lateral_costs.at(i).first &lt;&lt; ", " &lt;&lt; lateral_costs.at(i).second &lt;&lt; ")";
-		}
-
-		return str.str();
-
-	}
-};
-
-}
-
-
-#endif /* ROADNETWORK_H_ */
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\SimpleTracker.h" new_path="" added_lines="0" deleted_lines="272">
				<diff>@@ -1,272 +0,0 @@
-/*
- * SimpleTracker.h
- *
- *  Created on: Aug 11, 2016
- *      Author: hatem
- */
-
-#ifndef SimpleTracker_H_
-#define SimpleTracker_H_
-
-#include "RoadNetwork.h"
-#include "opencv2/video/tracking.hpp"
-#include &lt;vector&gt;
-#include "UtilityH.h"
-#include "math.h"
-#include &lt;iostream&gt;
-
-namespace SimulationNS
-{
-
-#define DEBUG_TRACKER 0
-#define NEVER_GORGET_TIME -1000
-#define MIN_EVIDENCE_NUMBER 3
-
-struct Kalman1dState
-{
-    double MovCov; //double q; //moving noise covariance
-    double MeasureCov; //double r; //measurement noise covariance
-    double x; //value
-    double p; //estimation error covariance
-    double k; //kalman gain
-};
-
-class  kalmanFilter1D
-{
-public:
-
-	Kalman1dState result;
-
-    kalmanFilter1D()
-	{
-
-	}
-    kalmanFilter1D(double MovCov, double MeasureCov, double p, double intial_value)
-    {
-        result.MovCov = MovCov;
-        result.MeasureCov = MeasureCov;
-        result.p = p;
-        result.x = intial_value;
-    }
-
-    Kalman1dState Update(double measurement)
-    {
-    	//prediction update
-		//omit x = x
-		result.p = result.p + result.MovCov;
-
-		//measurement update
-		result.k = result.p / (result.p + result.MeasureCov);
-		result.x = result.x + result.k * (measurement - result.x);
-		result.p = (1 - result.k) * result.p;
-
-		return result;
-    }
-};
-
-class KFTrackV
-{
-private:
-	cv::KalmanFilter m_filter;
-	double prev_x, prev_y, prev_v, prev_a;
-	long m_id;
-	double dt;
-	int nStates;
-	int nMeasure;
-	double circ_angle;
-
-public:
-	int region_id;
-	double forget_time;
-	int m_iLife;
-	PlannerHNS::DetectedObject obj;
-	kalmanFilter1D errorSmoother;
-
-	long GetTrackID()
-	{
-		return m_id;
-	}
-
-	KFTrackV(double x, double y, double a, long id, double _dt)
-	{
-		circ_angle = 0;
-		errorSmoother.result.MovCov = 0.125;
-		errorSmoother.result.MeasureCov = 0.1;
-		errorSmoother.result.p = 1;
-		errorSmoother.result.x = 0;
-		region_id = -1;
-		forget_time = NEVER_GORGET_TIME; // this is very bad , dangerous
-		m_iLife = 0;
-		dt = _dt;
-		prev_x = x;
-		prev_y = y;
-		prev_v = 0;
-		prev_a = a;
-		nStates = 4;
-		nMeasure = 2;
-
-		m_id = id;
-
-		m_filter = cv::KalmanFilter(nStates,nMeasure);
-		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
-																	   	   0	,1	,0	,dt	,
-																	   	   0	,0	,1	,0	,
-																	   	   0	,0	,0	,1	);
-		m_filter.statePre.at&lt;float&gt;(0) = x;
-		m_filter.statePre.at&lt;float&gt;(1) = y;
-		m_filter.statePre.at&lt;float&gt;(2) = 0;
-		m_filter.statePre.at&lt;float&gt;(3) = 0;
-
-		m_filter.statePost = m_filter.statePre;
-
-		setIdentity(m_filter.measurementMatrix);
-
-		cv::setIdentity(m_filter.measurementNoiseCov, cv::Scalar::all(0.0001));
-		cv::setIdentity(m_filter.processNoiseCov, cv::Scalar::all(0.0001));
-		cv::setIdentity(m_filter.errorCovPost, cv::Scalar::all(0.075));
-
-		m_filter.predict();
-
-		errorSmoother.Update(a);
-	}
-
-	void UpdateTracking(double _dt, const double&amp; x, const double&amp; y, const double&amp; a, double&amp; x_new, double &amp; y_new , double&amp; a_new, double&amp; v)
-	{
-		dt = _dt;
-		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
-																			   	   0	,1	,0	,dt	,
-																			   	   0	,0	,1	,0	,
-																			   	   0	,0	,0	,1	);
-		double a_old = a;
-
-		cv::Mat_&lt;float&gt; measurement(nMeasure,1);
-		cv::Mat_&lt;float&gt; prediction(nStates,1);
-
-		measurement(0) = x;
-		measurement(1) = y;
-
-		prediction = m_filter.correct(measurement);
-
-		x_new = prediction.at&lt;float&gt;(0);
-		y_new = prediction.at&lt;float&gt;(1);
-		double vx  = prediction.at&lt;float&gt;(2);
-		double vy  = prediction.at&lt;float&gt;(3);
-
-		if(m_iLife &gt; 2)
-		{
-			v = sqrt(vx*vx+vy*vy);
-			double diff_y = y_new - prev_y;
-			double diff_x = x_new - prev_x;
-			if(hypot(diff_y, diff_x) &gt; 0.5)
-			{
-				prev_y = y;
-				prev_x = x;
-				a_new = atan2(diff_y, diff_x);
-			}
-			else
-				a_new = a;
-
-		}
-		else
-		{
-			v = 0;
-			a_new = a;
-		}
-
-		circ_angle = UtilityHNS::UtilityH::GetCircularAngle(circ_angle, UtilityHNS::UtilityH::FixNegativeAngle(a_old), UtilityHNS::UtilityH::FixNegativeAngle(a_new));
-
-		circ_angle =  errorSmoother.Update(circ_angle).x;
-
-		a_new = UtilityHNS::UtilityH::SplitPositiveAngle(circ_angle);
-
-		if(v &lt; 0.1)
-			v = 0;
-
-		//std::cout &lt;&lt; "Track: Old (" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; "), New (" &lt;&lt; x_new &lt;&lt; ", " &lt;&lt; y_new &lt;&lt; ")" &lt;&lt; std::endl;
-		//std::cout &lt;&lt; "Track: " &lt;&lt; m_id &lt;&lt; ", A: " &lt;&lt; a &lt;&lt; ", A_new:(" &lt;&lt; circ_angle &lt;&lt; "," &lt;&lt;  a_new &lt;&lt; ") , V" &lt;&lt; v &lt;&lt; ", dt: " &lt;&lt; dt &lt;&lt; ", forget_time: " &lt;&lt; forget_time &lt;&lt; std::endl;
-
-		m_filter.predict();
-		m_filter.statePre.copyTo(m_filter.statePost);
-		m_filter.errorCovPre.copyTo(m_filter.errorCovPost);
-
-		forget_time -= dt;
-		m_iLife++;
-	}
-	virtual ~KFTrackV(){}
-};
-
-class InterestCircle
-{
-public:
-	int id;
-	double radius;
-	double forget_time;
-	std::vector&lt;KFTrackV*&gt; pTrackers;
-	InterestCircle* pPrevCircle;
-	InterestCircle* pNextCircle;
-
-	InterestCircle(int _id)
-	{
-		id = _id;
-		radius = 0;
-		forget_time = NEVER_GORGET_TIME; // never forget
-		pPrevCircle = 0;
-		pNextCircle = 0;
-	}
-};
-
-class CostRecordSet
-{
-public:
-	int currobj;
-	int prevObj;
-	double cost;
-	CostRecordSet(int curr_id, int prev_id, double _cost)
-	{
-		currobj = curr_id;
-		prevObj = prev_id;
-		cost = _cost;
-	}
-};
-
-class SimpleTracker
-{
-public:
-	std::vector&lt;InterestCircle*&gt; m_InterestRegions;
-	std::vector&lt;KFTrackV*&gt; m_Tracks;
-	timespec m_TrackTimer;
-	long iTracksNumber;
-	PlannerHNS::WayPoint m_PrevState;
-	std::vector&lt;PlannerHNS::DetectedObject&gt; m_PrevDetectedObjects;
-	std::vector&lt;PlannerHNS::DetectedObject&gt; m_DetectedObjects;
-
-	void CreateTrack(PlannerHNS::DetectedObject&amp; o);
-	void CreateTrackV2(PlannerHNS::DetectedObject&amp; o);
-	KFTrackV* FindTrack(long index);
-	void Track(std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; objects_list);
-	void TrackV2();
-	void CoordinateTransform(const PlannerHNS::WayPoint&amp; refCoordinate, PlannerHNS::DetectedObject&amp; obj);
-	void CoordinateTransformPoint(const PlannerHNS::WayPoint&amp; refCoordinate, PlannerHNS::GPSPoint&amp; obj);
-	void AssociateObjects();
-	void InitializeInterestRegions(double horizon, double init_raduis, double init_time, std::vector&lt;InterestCircle*&gt;&amp; regions);
-	void AssociateAndTrack();
-	void AssociateToRegions(KFTrackV&amp; detectedObject);
-	void CleanOldTracks();
-
-	void DoOneStep(const PlannerHNS::WayPoint&amp; currPose, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-
-	SimpleTracker(double horizon = 100);
-	virtual ~SimpleTracker();
-
-public:
-	double m_DT;
-	double m_MAX_ASSOCIATION_DISTANCE;
-	int m_MAX_TRACKS_AFTER_LOSING;
-	bool m_bUseCenterOnly;
-	double m_MaxKeepTime;
-	bool m_bFirstCall;
-};
-
-} /* namespace BehaviorsNS */
-
-#endif /* SimpleTracker_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\TrajectoryCosts.h" new_path="" added_lines="0" deleted_lines="50">
				<diff>@@ -1,50 +0,0 @@
-/*
- * TrajectoryCosts.h
- *
- *  Created on: Dec 14, 2016
- *      Author: user
- */
-
-#ifndef TRAJECTORYCOSTS_H_
-#define TRAJECTORYCOSTS_H_
-
-#include "RoadNetwork.h"
-#include "PlannerCommonDef.h"
-#include "PlanningHelpers.h"
-
-using namespace std;
-
-namespace PlannerHNS
-{
-
-class TrajectoryCosts
-{
-public:
-	TrajectoryCosts();
-	virtual ~TrajectoryCosts();
-
-	TrajectoryCost DoOneStep(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths,
-			const WayPoint&amp; currState, const int&amp; currTrajectoryIndex, const int&amp; currLaneIndex, const PlanningParams&amp; params,
-			const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-
-public:
-	int m_PrevCostIndex;
-	vector&lt;TrajectoryCost&gt; m_TrajectoryCosts;
-	PlanningParams m_Params;
-	PolygonShape m_SafetyBorder;
-	//vector&lt;GPSPoint&gt; m_SafetyBox;
-
-
-
-private:
-	bool ValidateRollOutsInput(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts);
-	vector&lt;TrajectoryCost&gt; CalculatePriorityAndLaneChangeCosts(const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; laneRollOuts, const int&amp; lane_index, const PlanningParams&amp; params);
-	void NormalizeCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts);
-	void CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths, const WayPoint&amp; currState, const vector&lt;WayPoint&gt;&amp; contourPoints, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState);
-	void CalculateTransitionCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const int&amp; currTrajectoryIndex, const PlanningParams&amp; params);
-
-};
-
-}
-
-#endif /* TRAJECTORYCOSTS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\TrajectoryFollower.h" new_path="" added_lines="0" deleted_lines="111">
				<diff>@@ -1,111 +0,0 @@
-/*
- * TrajectoryFollower.h
- *
- *  Created on: Jun 18, 2016
- *      Author: hatem
- */
-
-#ifndef TRAJECTORYFOLLOWER_H_
-#define TRAJECTORYFOLLOWER_H_
-#include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "PlannerCommonDef.h"
-
-
-#define MAX_ACCELERATION_2G 20 // meter /sec/sec
-namespace SimulationNS
-{
-
-class TrajectoryFollower
-{
-public:
-	TrajectoryFollower();
-	virtual ~TrajectoryFollower();
-
-	void PrepareNextWaypoint(const PlannerHNS::WayPoint&amp; CurPos, const double&amp; currVelocity, const double&amp; currSteering);
-
-	void UpdateCurrentPath(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path);
-
-	int SteerControllerUpdate(const PlannerHNS::VehicleState&amp; CurrStatus,
-			const PlannerHNS::BehaviorState&amp; CurrBehavior, double&amp; desiredSteerAngle);
-	int VeclocityControllerUpdate(const double&amp; dt, const PlannerHNS::VehicleState&amp; CurrStatus,
-			const PlannerHNS::BehaviorState&amp; CurrBehavior, double&amp; desiredVelocity, PlannerHNS::SHIFT_POS&amp; desiredShift);
-
-	void Init(const PlannerHNS::ControllerParams&amp; params, const PlannerHNS::CAR_BASIC_INFO&amp; vehicleInfo, bool bEnableLogs = false, bool bCalibration = false);
-
-	PlannerHNS::VehicleState DoOneStep(const double&amp; dt, const PlannerHNS::BehaviorState&amp; behavior,
-				const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::WayPoint&amp; currPose,
-				const PlannerHNS::VehicleState&amp; vehicleState, const bool&amp; bNewTrajectory);
-
-	//Testing Points
-	PlannerHNS::WayPoint 	m_ForwardSimulation;
-	PlannerHNS::WayPoint 	m_PerpendicularPoint;
-	PlannerHNS::WayPoint 	m_FollowMePoint;
-	double 					m_LateralError;
-	double 					m_FollowingDistance;
-	PlannerHNS::WayPoint 	m_CurrPos;
-	int 					m_iCalculatedIndex;
-	bool					m_bEndPath;
-	double 					m_WayPointsDensity;
-
-
-private:
-	double 						m_StartFollowDistance;
-	double 						m_FollowAcc;
-	PlannerHNS::ControllerParams 			m_Params;
-	PlannerHNS::CAR_BASIC_INFO 				m_VehicleInfo;
-	std::vector&lt;PlannerHNS::WayPoint&gt; 	m_Path;
-	PlannerHNS::WayPoint 		m_DesPos;
-	double						m_PrevDesiredSteer; // control output
-	double 						m_FollowAcceleration;
-	int 						m_iPrevWayPoint;
-	UtilityHNS::PIDController 	m_pidSteer;
-	UtilityHNS::LowpassFilter 	m_lowpassSteer;
-
-	UtilityHNS::PIDController 	m_pidVelocity;
-	UtilityHNS::LowpassFilter 	m_lowpassVelocity;
-
-	bool						m_bEnableLog;
-	std::vector&lt;std::string&gt;    m_LogData;
-	std::vector&lt;std::string&gt;    m_LogSteerPIDData;
-	std::vector&lt;std::string&gt;    m_LogVelocityPIDData;
-
-	//Steering and Velocity Calibration Global Variables
-	bool						m_bCalibrationMode;
-	int							m_iNextTest;
-	std::vector&lt;std::string&gt;    m_SteerCalibrationData;
-	std::vector&lt;std::string&gt;    m_VelocityCalibrationData;
-	PlannerHNS::VehicleState 	m_prevCurrState_steer;
-	PlannerHNS::VehicleState 	m_prevDesiredState_steer;
-	PlannerHNS::VehicleState 	m_prevCurrState_vel;
-	PlannerHNS::VehicleState 	m_prevDesiredState_vel;
-	struct timespec 			m_SteerDelayTimer;
-	struct timespec 			m_VelocityDelayTimer;
-	std::vector&lt;std::pair&lt;double, double&gt; &gt; m_CalibrationRunList;
-
-
-	bool FindNextWayPoint(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::WayPoint&amp; state,
-			const double&amp; velocity, PlannerHNS::WayPoint&amp; pursuite_point, PlannerHNS::WayPoint&amp; prep,
-			double&amp; lateral_err, double&amp; follow_distance);
-
-	int SteerControllerPart(const PlannerHNS::WayPoint&amp; state, const PlannerHNS::WayPoint&amp; way_point,
-			const double&amp; lateral_error, double&amp; steerd);
-
-	void PredictMotion(double&amp; x, double &amp;y, double&amp; heading, double steering, double velocity,
-			double wheelbase, double time_elapsed);
-
-	double GetPID_LinearChange(double minVal, double maxVal, double speedMax, double currSpeed);
-
-	void AdjustPID(const double&amp; v, const double&amp; maxV,  PlannerHNS::PID_CONST&amp; steerPID);
-
-	int CalculateVelocityDesired(const double&amp; dt, const double&amp; currVel,const PlannerHNS::STATE_TYPE&amp; CurrBehavior,
-			double&amp; desiredVel);
-
-	void LogCalibrationData(const PlannerHNS::VehicleState&amp; currState,const PlannerHNS::VehicleState&amp; desiredState);
-	void InitCalibration();
-	void CalibrationStep(const double&amp; dt, const PlannerHNS::VehicleState&amp; CurrStatus, double&amp; desiredSteer, double&amp; desiredVelocity);
-};
-
-} /* namespace SimulationNS */
-
-#endif /* TRAJECTORYFOLLOWER_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\UtilityH.h" new_path="" added_lines="0" deleted_lines="115">
				<diff>@@ -1,115 +0,0 @@
-/*
- * UtilityH.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#ifndef UTILITYH_H_
-#define UTILITYH_H_
-
-#include &lt;assert.h&gt;
-#include &lt;math.h&gt;
-#include &lt;string&gt;
-
-
-namespace UtilityHNS
-{
-
-#define DEG2RAD M_PI / 180.
-#define RAD2DEG 180. / M_PI
-#define sign(x) (x &gt; 0) ? 1 : ((x &lt; 0) ? -1 : 0)
-#define MIN(x,y) (x &lt;= y ? x : y)
-#define MAX(x,y) (x &gt;= y ? x : y)
-
-
-class UtilityH
-{
-public:
-	UtilityH();
-	virtual ~UtilityH(); 
-
-
-	static double FixNegativeAngle(const double&amp; a);
-	static double SplitPositiveAngle(const double&amp; a);
-	static double InverseAngle(const double&amp; a);
-	static double AngleBetweenTwoAnglesPositive(const double&amp; a1, const double&amp; a2);
-	static double GetCircularAngle(const double&amp; prevContAngle, const double&amp; prevAngle, const double&amp; currAngle);
-
-	//Time Functions
-	static void GetTickCount(struct timespec&amp; t);
-	static std::string GetFilePrefixHourMinuteSeconds();
-	static double GetTimeDiffNow(const struct timespec&amp; old_t);
-	static double GetTimeDiff(const struct timespec&amp; old_t,const struct timespec&amp; curr_t);
-	static std::string GetDateTimeStr();
-	static int tsCompare (struct  timespec  time1,   struct  timespec  time2, int micro_tolerance = 10);
-	static int GetSign(double x);
-	static std::string GetHomeDirectory();
-	static double GetMomentumScaleFactor(const double&amp; v);
-	static timespec GetTimeSpec(const time_t&amp; srcT);
-	static time_t GetLongTime(const struct timespec&amp; srcT);
-};
-
-class PIDController
-{
-public:
-	PIDController();
-	PIDController(const double&amp; kp, const double&amp; ki, const double&amp; kd);
-	void Init(const double&amp; kp, const double&amp; ki, const double&amp; kd);
-	void Setlimit(const double&amp; upper,const double&amp; lower);
-	double getPID(const double&amp; currValue, const double&amp; targetValue);
-	double getPID(const double&amp; e);
-	void ResetD();
-	void ResetI();
-	std::string ToString();
-	std::string ToStringHeader();
-
-
-private:
-	double kp;
-	double ki;
-	double kd;
-	double kp_v;
-	double ki_v;
-	double kd_v;
-	double pid_v;
-	double pid_lim;
-	double upper_limit;
-	double lower_limit;
-	bool   bEnableLimit;
-	double accumErr;
-	double prevErr;
-	bool bResetD;
-	bool bResetI;
-
-};
-
-class LowpassFilter
-{
-public:
-	LowpassFilter();
-	virtual ~LowpassFilter();
-
-	LowpassFilter(const int&amp; filterOrder, const double&amp; sampleFreq, const double&amp; cutOffFreq);
-	void Init(const int&amp; filterOrder, const double&amp; sampleFreq, const double&amp; cutOffFreq);
-	double getFilter(const double&amp; value);
-
-
-private:
-	int m;
-	double sampleF;
-	double cutOffF;
-	double A  ;
-	double d1 ;
-	double d2 ;
-	double w0 ;
-	double w1 ;
-	double w2 ;
-
-};
-
-}
-
-#endif
-
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\ff_waypoint_follower_core.h" new_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\include\ff_waypoint_follower_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -35,7 +35,6 @@
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
-#include &lt;cv_tracker/obj_label.h&gt;
 #include &lt;runtime_manager/traffic_light.h&gt;
 
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
@@ -47,6 +46,7 @@
 #include &lt;tf/tf.h&gt;
 #include &lt;std_msgs/Int8.h&gt;
 #include "waypoint_follower/libwaypoint_follower.h"
+#include "waypoint_follower_msgs/LaneArray.h"
 #include "TrajectoryFollower.h"
 //#include "CarState.h"
 #include "LocalPlannerH.h"
@@ -166,7 +166,7 @@ protected:
 	void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg);
 	void callbackGetCurrentVelocity(const geometry_msgs::TwistStampedConstPtr&amp; msg);
 	void callbackGetBehaviorState(const geometry_msgs::TwistStampedConstPtr&amp; msg );
-	void callbackGetCurrentTrajectory(const waypoint_follower::laneConstPtr&amp; msg);
+	void callbackGetCurrentTrajectory(const waypoint_follower_msgs::laneConstPtr&amp; msg);
 	//void callbackGetAutowareOdom(const geometry_msgs::TwistStampedConstPtr &amp;msg);
 	void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg);
 	void callbackGetOutsideControl(const std_msgs::Int8&amp; msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower_core.cpp" new_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower_core.cpp" added_lines="2" deleted_lines="3">
				<diff>@@ -28,7 +28,7 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #include "ff_waypoint_follower_core.h"
-#include "waypoint_follower/LaneArray.h"
+#include "waypoint_follower_msgs/LaneArray.h"
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;visualization_msgs/InteractiveMarkerPose.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
@@ -41,7 +41,6 @@ using namespace std;
 
 namespace FFSteerControlNS
 {
-//#define kmlTemplateFile "/home/hatem/workspace/Data/templates/PlannerX_MapTemplate.kml"
 
 FFSteerControl::FFSteerControl()
 {
@@ -267,7 +266,7 @@ void FFSteerControl::callbackGetBehaviorState(const geometry_msgs::TwistStampedC
 	bNewBehaviorState = true;
 }
 
-void FFSteerControl::callbackGetCurrentTrajectory(const waypoint_follower::laneConstPtr &amp;msg)
+void FFSteerControl::callbackGetCurrentTrajectory(const waypoint_follower_msgs::laneConstPtr &amp;msg)
 {
 	m_State.m_Path.clear();
 	for(unsigned int i = 0 ; i &lt; msg-&gt;waypoints.size(); i++)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\BehaviorStateMachine.h" new_path="" added_lines="0" deleted_lines="176">
				<diff>@@ -1,176 +0,0 @@
-/*
- * BehaviorStateMachine.h
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
-
-#ifndef BEHAVIORSTATEMACHINE_H_
-#define BEHAVIORSTATEMACHINE_H_
-
-#include "RoadNetwork.h"
-#include &lt;sstream&gt;
-
-namespace PlannerHNS
-{
-class BehaviorStateMachine
-{
-public:
-	virtual BehaviorStateMachine* GetNextState() = 0;
-	virtual void Init();
-	virtual void ResetTimer();
-	virtual void InsertNextState(BehaviorStateMachine* nextState);
-	BehaviorStateMachine(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* nextState);
-	virtual ~BehaviorStateMachine() ;
-
-	STATE_TYPE m_Behavior;
-	int m_currentStopSignID	;
-	int m_currentTrafficLightID ;
-	double decisionMakingTime;
-	double m_zero_velocity;
-
-	PreCalculatedConditions* GetCalcParams()
-	{
-		if(!m_pCalculatedValues)
-				m_pCalculatedValues = new PreCalculatedConditions();
-
-		return m_pCalculatedValues;
-	}
-
-	void SetBehaviorsParams(PlanningParams* pParams)
-	{
-		if(!pParams)
-			m_pParams = new PlanningParams;
-		else
-			m_pParams = pParams;
-	}
-
-
-	PreCalculatedConditions* m_pCalculatedValues;
-	PlanningParams* m_pParams;
-	timespec m_StateTimer;
-	std::vector&lt;BehaviorStateMachine*&gt; pNextStates;
-
-	BehaviorStateMachine* FindBehaviorState(const STATE_TYPE&amp; behavior);
-};
-
-class ForwardState : public BehaviorStateMachine
-{
-public:
-	ForwardState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FORWARD_STATE;}
-	virtual ~ForwardState(){}
-	virtual BehaviorStateMachine* GetNextState();
-};
-
-class MissionAccomplishedState : public BehaviorStateMachine
-{
-public:
-	MissionAccomplishedState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FINISH_STATE;}
-	virtual ~MissionAccomplishedState(){}
-	virtual BehaviorStateMachine* GetNextState();
-};
-
-class FollowState : public BehaviorStateMachine
-{
-public:
-	FollowState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FOLLOW_STATE;}
-	virtual ~FollowState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class SwerveState : public BehaviorStateMachine
-{
-public:
-	SwerveState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = OBSTACLE_AVOIDANCE_STATE;}
-	virtual ~SwerveState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopState : public BehaviorStateMachine
-{
-public:
-	StopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOPPING_STATE;}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class TrafficLightStopState : public BehaviorStateMachine
-{
-public:
-	TrafficLightStopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = TRAFFIC_LIGHT_STOP_STATE;}
-	virtual ~TrafficLightStopState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class TrafficLightWaitState : public BehaviorStateMachine
-{
-public:
-	TrafficLightWaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = TRAFFIC_LIGHT_WAIT_STATE;}
-	virtual ~TrafficLightWaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopSignStopState : public BehaviorStateMachine
-{
-public:
-	StopSignStopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOP_SIGN_STOP_STATE;}
-	virtual ~StopSignStopState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopSignWaitState : public BehaviorStateMachine
-{
-public:
-	StopSignWaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOP_SIGN_WAIT_STATE;}
-	virtual ~StopSignWaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class WaitState : public BehaviorStateMachine
-{
-public:
-	WaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = WAITING_STATE;}
-	virtual ~WaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class InitState : public BehaviorStateMachine
-{
-public:
-	InitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = INITIAL_STATE;}
-	virtual ~InitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class GoalState : public BehaviorStateMachine
-{
-public:
-	GoalState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = GOAL_STATE;}
-	virtual ~GoalState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* BEHAVIORSTATEMACHINE_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\DataRW.h" new_path="" added_lines="0" deleted_lines="438">
				<diff>@@ -1,438 +0,0 @@
-/*
- * DataRW.h
- *
- *  Created on: Jun 23, 2016
- *      Author: hatem
- */
-
-#ifndef DATARW_H_
-#define DATARW_H_
-
-#include &lt;string&gt;
-#include &lt;fstream&gt;
-#include &lt;sstream&gt;
-#include &lt;vector&gt;
-#include &lt;iostream&gt;
-
-namespace UtilityHNS {
-
-class DataRW
-{
-public:
-	DataRW();
-	virtual ~DataRW();
-
-	static std::string LoggingMainfolderName;
-	static std::string ControlLogFolderName;
-	static std::string PathLogFolderName;
-	static std::string StatesLogFolderName;
-	static std::string SimulationFolderName;
-	static std::string KmlMapsFolderName;
-
-
-	static void WriteKMLFile(const std::string&amp; fileName, const std::vector&lt;std::string&gt;&amp; gps_list);
-	static void WriteKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;std::string&gt; &gt;&amp; gps_list);
-	static void WriteLogData(const std::string&amp; logFolder, const std::string&amp; logTitle, const std::string&amp; header, const std::vector&lt;std::string&gt;&amp; logData);
-};
-
-class SimpleReaderBase
-{
-private:
-	std::ifstream* m_pFile;
-	std::vector&lt;std::string&gt; m_RawHeaders;
-	std::vector&lt;std::string&gt; m_DataTitlesHeader;
-	std::vector&lt;std::vector&lt;std::vector&lt;std::string&gt; &gt; &gt; m_AllData;
-	int m_nHeders;
-	int m_iDataTitles;
-	int m_nVarPerObj;
-	int m_nLineHeaders;
-	std::string m_HeaderRepeatKey;
-	char m_Separator;
-
-	void ReadHeaders();
-	void ParseDataTitles(const std::string&amp; header);
-
-public:
-	/**
-	 *
-	 * @param fileName log file name
-	 * @param nHeaders number of data headers
-	 * @param iDataTitles which row contains the data titles
-	 * @param nVariablesForOneObject 0 means each row represents one object
-	 */
-	SimpleReaderBase(const std::string&amp; fileName, const int&amp; nHeaders = 2, const char&amp; separator = ',',
-			const int&amp; iDataTitles = 1, const int&amp; nVariablesForOneObject = 0,
-			const int&amp; nLineHeaders = 0, const std::string&amp; headerRepeatKey = "...");
-	~SimpleReaderBase();
-
-protected:
-	bool ReadAllData();
-	bool ReadSingleLine(std::vector&lt;std::vector&lt;std::string&gt; &gt;&amp; line);
-
-};
-
-//class GPSLocalizerReader : public SimpleReaderBase
-//{
-//	public:
-//		GPSLocalizerReader(const std::string&amp; fileName) : SimpleReaderBase(fileName){}
-//		~GPSLocalizerReader(){}
-//
-//		bool ReadNextLine( MsgEstPose&amp; pos, double&amp; logTime);
-//		void ReadAllData(vector&lt;pair&lt;double,  MsgEstPose&gt; &gt;&amp; pos_list);
-//};
-//
-class GPSDataReader : public SimpleReaderBase
-{
-public:
-	struct GPSBasicData
-	{
-		double lat;
-		double lon;
-		double alt;
-		double dir;
-		double distance;
-
-	};
-
-	public:
-	GPSDataReader(const std::string&amp; fileName) : SimpleReaderBase(fileName){}
-	~GPSDataReader(){}
-
-	bool ReadNextLine(GPSBasicData&amp; data);
-	void ReadAllData(std::vector&lt;GPSBasicData&gt;&amp; data_list);
-};
-
-//
-//class VehicleStateReader : public SimpleReaderBase
-//{
-//	public:
-//	VehicleStateReader(const string&amp; fileName) : SimpleReaderBase(fileName){}
-//	~VehicleStateReader(){}
-//
-//	bool ReadNextLine( MsgVehicleStatus&amp; state, double&amp; logTime);
-//	void ReadAllData(vector&lt;pair&lt;double,  MsgVehicleStatus&gt; &gt;&amp; state_list);
-//};
-//
-//class MovingObjectsReader : public SimpleReaderBase
-//{
-//	public:
-//	MovingObjectsReader(const string&amp; fileName) : SimpleReaderBase(fileName, 2, 1, 28, 4){}
-//	~MovingObjectsReader(){}
-//
-//	bool ReadNextLine( MsgMovingObject&amp; state, double&amp; logTime);
-//	void ReadAllData(vector&lt;pair&lt;double,  MsgMovingObject&gt; &gt;&amp; state_list);
-//};
-
-class SimulationFileReader : public SimpleReaderBase
-{
-public:
-	struct SimulationPoint
-	{
-		double x;
-		double y;
-		double z;
-		double a;
-		double c;
-		double v;
-	};
-
-	struct SimulationData
-	{
-		SimulationPoint startPoint;
-		SimulationPoint goalPoint;
-		std::vector&lt;SimulationPoint&gt; simuCars;
-	};
-
-	SimulationFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~SimulationFileReader(){}
-
-	bool ReadNextLine(SimulationPoint&amp; data);
-	void ReadAllData(SimulationData&amp; data_list);
-};
-
-class LocalizationPathReader : public SimpleReaderBase
-{
-public:
-	struct LocalizationWayPoint
-	{
-		double t;
-		double x;
-		double y;
-		double z;
-		double a;
-		double v;
-	};
-
-	LocalizationPathReader(const std::string&amp; fileName, const char&amp; separator) : SimpleReaderBase(fileName, 1, separator){}
-	~LocalizationPathReader(){}
-
-	bool ReadNextLine(LocalizationWayPoint&amp; data);
-	void ReadAllData(std::vector&lt;LocalizationWayPoint&gt;&amp; data_list);
-};
-
-class AisanPointsFileReader : public SimpleReaderBase
-{
-public:
-	struct AisanPoints
-	{
-		int PID;
-		double B;
-		double L;
-		double H;
-		double Bx;
-		double Ly;
-		int Ref;
-		int MCODE1;
-		int MCODE2;
-		int MCODE3;
-	};
-
-	AisanPointsFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanPointsFileReader(){}
-
-	bool ReadNextLine(AisanPoints&amp; data);
-	void ReadAllData(std::vector&lt;AisanPoints&gt;&amp; data_list);
-};
-
-class AisanNodesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanNode
-	{
-		int NID;
-		int PID;
-	};
-
-	AisanNodesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanNodesFileReader(){}
-
-	bool ReadNextLine(AisanNode&amp; data);
-	void ReadAllData(std::vector&lt;AisanNode&gt;&amp; data_list);
-};
-
-class AisanLinesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanLine
-	{
-		int LID;
-		int BPID;
-		int FPID;
-		int BLID;
-		int FLID;
-	};
-
-	AisanLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanLinesFileReader(){}
-
-	bool ReadNextLine(AisanLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanLine&gt;&amp; data_list);
-};
-
-class AisanCenterLinesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanCenterLine
-	{
-		int 	DID;
-		int 	Dist;
-		int 	PID;
-		double 	Dir;
-		double 	Apara;
-		double 	r;
-		double 	slope;
-		double 	cant;
-		double 	LW;
-		double 	RW;
-	};
-
-	AisanCenterLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanCenterLinesFileReader(){}
-
-	bool ReadNextLine(AisanCenterLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanCenterLine&gt;&amp; data_list);
-};
-
-class AisanAreasFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanArea
-	{
-		int 	AID;
-		int 	SLID;
-		int 	ELID;
-	};
-
-	AisanAreasFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanAreasFileReader(){}
-
-	bool ReadNextLine(AisanArea&amp; data);
-	void ReadAllData(std::vector&lt;AisanArea&gt;&amp; data_list);
-};
-
-class AisanIntersectionFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanIntersection
-	{
-		int 	ID;
-		int 	AID;
-		int 	LinkID;
-	};
-
-	AisanIntersectionFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanIntersectionFileReader(){}
-
-	bool ReadNextLine(AisanIntersection&amp; data);
-	void ReadAllData(std::vector&lt;AisanIntersection&gt;&amp; data_list);
-};
-
-class AisanLanesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanLane
-	{
-		int LnID	;
-		int DID		;
-		int BLID	;
-		int FLID	;
-		int BNID	;
-		int FNID	;
-		int JCT		;
-		int BLID2	;
-		int BLID3	;
-		int BLID4	;
-		int FLID2	;
-		int FLID3	;
-		int FLID4	;
-		int ClossID	;
-		double Span	;
-		int LCnt	;
-		int Lno		;
-		int LaneType;
-		int LimitVel;
-		int RefVel	;
-		int RoadSecID;
-		int LaneChgFG;
-		int LinkWAID;
-		char LaneDir;
-		int  LeftLaneId;
-		int RightLaneId;
-
-	};
-
-	AisanLanesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanLanesFileReader(){}
-
-	bool ReadNextLine(AisanLane&amp; data);
-	void ReadAllData(std::vector&lt;AisanLane&gt;&amp; data_list);
-};
-
-class AisanStopLineFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanStopLine
-	{
-		int 	ID;
-		int 	LID;
-		int 	TLID;
-		int 	SignID;
-		int 	LinkID;
-	};
-
-	AisanStopLineFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanStopLineFileReader(){}
-
-	bool ReadNextLine(AisanStopLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanStopLine&gt;&amp; data_list);
-};
-
-class AisanRoadSignFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanRoadSign
-	{
-		int 	ID;
-		int 	VID;
-		int 	PLID;
-		int 	Type;
-		int 	LinkID;
-	};
-
-	AisanRoadSignFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanRoadSignFileReader(){}
-
-	bool ReadNextLine(AisanRoadSign&amp; data);
-	void ReadAllData(std::vector&lt;AisanRoadSign&gt;&amp; data_list);
-};
-
-class AisanSignalFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanSignal
-	{
-		int 	ID;
-		int 	VID;
-		int 	PLID;
-		int 	Type;
-		int 	LinkID;
-	};
-
-	AisanSignalFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanSignalFileReader(){}
-
-	bool ReadNextLine(AisanSignal&amp; data);
-	void ReadAllData(std::vector&lt;AisanSignal&gt;&amp; data_list);
-};
-
-class AisanVectorFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanVector
-	{
-		int 	VID;
-		int 	PID;
-		double 	Hang;
-		double 	Vang;
-	};
-
-	AisanVectorFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanVectorFileReader(){}
-
-	bool ReadNextLine(AisanVector&amp; data);
-	void ReadAllData(std::vector&lt;AisanVector&gt;&amp; data_list);
-};
-
-class AisanDataConnFileReader : public SimpleReaderBase
-{
-public:
-
-	struct DataConn
-	{
-		int 	LID; // lane id
-		int 	SLID; // stop line id
-		int 	SID; // signal id
-		int 	SSID; // stop sign id
-	};
-
-	AisanDataConnFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanDataConnFileReader(){}
-
-	bool ReadNextLine(DataConn&amp; data);
-	void ReadAllData(std::vector&lt;DataConn&gt;&amp; data_list);
-};
-
-
-} /* namespace UtilityHNS */
-
-#endif /* DATARW_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\GridMap.h" new_path="" added_lines="0" deleted_lines="230">
				<diff>@@ -1,230 +0,0 @@
-/*
- * GridMap.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#ifndef GRIDMAPSA_H_
-#define GRIDMAPSA_H_
-
-#include "RoadNetwork.h"
-
-namespace PlannerHNS
-{
-
-#define get2dIndex(r,c,w) r*w + c
-#define checkGridLimit(r,c,h,w) r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; h &amp;&amp; c &lt; w
-#define checkGridIndex(i, nCells) i &gt;= 0 &amp;&amp; i &lt; nCells
-#define SUBCELL_L 10 //subcell lenth in centimeter
-
-
-class CELL_Info
-{
-public:
-  int r,c,index;
-  GPSPoint center;
-  int nCells;
-  double heuristic;
-  double forwardHeuristic;
-  double backwardHeuristic;
-  double heuristicValue;
-  double forward_heuristicValue;
-  double backward_heuristicValue;
-  int expanded; // used in path planning
-  bool closed;
-  double value;
-  int action;
-  double localize_val;
-  double localize_prob;
-  std::vector&lt;double&gt; localize_features;
-  GPSPoint forwardCenter;
-  GPSPoint backwardCenter;
-  DIRECTION_TYPE bDir;
-  POINT2D bottom_left;
-  POINT2D top_right;
-  POINT2D bottom_right;
-  POINT2D top_left;
-  int nStaticPoints;
-  int nMovingPoints;
-
-  CELL_Info* pInnerMap;
-
-  std::vector&lt;POINT2D&gt; innerStaticPointsList;
-  std::vector&lt;POINT2D&gt; innerMovingPointsList;
-
-  std::vector&lt;GPSPoint&gt; path;
-
-
-public:
-  void InitSubCells(double cell_l, double sub_cell_l);
-/**
- * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
- * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
- */
-  void Clear(int bMovingOnly);
-  void ClearSubCells(bool bMovingOnly);
-
-  CELL_Info();
-
-  virtual ~CELL_Info();
-
-  /*
-   * Cell initialization
-   */
-  void Initialize(POINT2D bottom_left, double cell_l, int row, int col, bool bDefaultEmpty);
-
-  /*
-   * assignment operator
-   */
-  bool operator==(const CELL_Info&amp; cell);
-
-  bool operator!=(const CELL_Info&amp; cell);
-
-  inline bool PointInRect(const POINT2D&amp; p)
-   {
-     return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
-   }
-
-  bool TestWithRectangle(RECTANGLE&amp; rec);
-  bool TestWithCircle(POINT2D _center,double  width);
-   inline bool HitTest(const POINT2D&amp; p);
-
-   void UpdateSubCellCostValue(const std::vector&lt;POINT2D&gt;&amp; ps, const double&amp; cell_l, const double&amp; sub_cell_l);
-   void UpdateCostValue(const std::vector&lt;POINT2D&gt;&amp; ps);
-
-   void SaveCell(std::ostream&amp; f);
-   void LoadCell(std::ifstream&amp; f);
-
-};
-
-class GridMap
-{
-  public:
-
-	  pthread_mutex_t update_map_mutex;
-
-    double w, inner_w; // current world width
-    double h, inner_h; // current world height
-    double cell_l; // cell or block length, if this is an inner cell measurements will be in meter
-    double sub_cell_l;
-    double origin_x , origin_y;
-
-
-
-    int inner_start_row;
-    int inner_start_col;
-    int inner_end_row;
-    int inner_end_col;
-
-    bool m_bEnableInnerMap;
-    bool m_bUpdatedMap;
-
-
-
-    int wCells, nInnerWCells; // width, number of cells per row
-    int hCells, nInnerHCells; // height, number of cells per column
-	//POINT2D center;
-	int m_MaxHeuristics;
-
-	int m_DisplayResolution;
-
-	POINT2D* delta;
-
-
-    // This method map obstacles from real world space to Grid space , marking each cell or internal cells as obstacle
-	void UpdateMapObstacleValue(const Obstacle&amp; ob);
-	void UpdateMapDrivablesValue(const DrivableArea&amp; dr);
-	void UpdateMapDrivablesValuePlygon(const std::vector&lt;std::vector&lt;POINT2D&gt; &gt;&amp; points);
-	void UpdateMapObstaclesValuePlygon(const std::vector&lt;POINT2D&gt;&amp; poly, std::vector&lt;CELL_Info*&gt;&amp; modifiedCell);
-
-	/**
-	 * @brief update cell to indicate that there is an obstacle @ absolute point p
-	 * @param p absolute x,y point
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapObstaclePoint(const POINT2D&amp; p);
-
-	/**
-	 * @brief update cell to indicate that there is an obstacle @ absolute point p , and make the map thiner according to a giving threshold
-	 * @param p absolute x,y point
-	 * @param thiningTHreshold distance to search for old obstacles
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateThinMapObstaclePoint(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold);
-
-	/**
-	 * @brief update cell to indicate that there is an moving obstacle @ absolute point p
-	 * @param p absolute x,y point
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapMovingObstaclePoint(const POINT2D&amp; p);
-
-	/**
-	 * @brief update subcells cost values to reflect the effect of obstacle @ absolute pint p
-	 * @param p obstacle point (x,y)
-	 * @param currPos current car location to apply the effect of obstacle on p
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapCostValueRange(const std::vector&lt;POINT2D&gt;&amp; ps, const GPSPoint&amp; currPos, const std::vector&lt;double&gt;&amp; features);
-	/**
-	 * @brief find the cell @ p then update its localization cost and probability which were read from a map file
-	 * @param p absolute position of the cell center
-	 * @param localize_val cost value
-	 * @param localize_prob probability value (should be zero in case of updating from map file
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateSubMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);
-
-	CELL_Info* UpdateMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);
-
-	CELL_Info* GetCellFromPointInnerMap(const POINT2D&amp; p);
-	CELL_Info* GetCellFromPoint(const POINT2D&amp; p, bool bExpand = false); // return cell information from (x,y) coordinates
-	CELL_Info* GetSubCellFromPoint(const POINT2D&amp; p); // return sub cell information from (x,y) coordinates
-	CELL_Info* GetSubCellFromCell(CELL_Info* const parent, const POINT2D&amp; p); // return sub cell information from parent cell
-
-	bool CheckSubCellsInTheWay(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold, std::vector&lt;CELL_Info*&gt;&amp; pSubCellsList);
-
-	/**
-	 * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
-	 * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
-	 */
-	void ClearMap(int bMovingOnly);
-	void OpenClosedCells();
-	void BackupMap();
-
-	GridMap();
-    GridMap(double start_x, double start_y, double  map_w, double map_h, double cell_length, bool bDefaultEmpty); // initialize and construct the 2D array of the Grid cells
-    void InitInnerMap(double  map_l, GridMap* const pParentMap, const POINT2D&amp; center); // initialize and construct map from another map (cells will point to cells from the other map , width and hight will be maximum available limited by the parameters
-    virtual ~GridMap();
-
-    CELL_Info* pCells;
-    int nCells;
-
-    void SaveMap(const std::string&amp; mapFilePath, const std::string&amp; mapName);
-    void LoadMap(const std::string&amp; mapFilePath, const POINT2D&amp; pos, const double&amp; loadingRadius, const GPSPoint&amp; mapTransformation);
-
-    int GetSurroundingMainCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
-    int GetSurroundingNonObstacleCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
-    int GetSurroundingMainCellsRectangle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
-    int GetSurroundingMainCellsCircle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, double radius);
-    int GetSurroundingMainCellsRectangleNoObstacle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
-
-    bool IsUpdated()
-    {
-    	return m_bUpdatedMap;
-    }
-
-    void ObservedMap()
-    {
-    	m_bUpdatedMap = false;
-    }
-
-  private:
-    int InsidePolygon(const std::vector&lt;POINT2D&gt;&amp; polygon,const POINT2D&amp; p);
-
-    //vector&lt;CELL_Info*&gt; pDrivableCells;
-  };
-
-}
-#endif /* GRIDMAP_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\HMIStateMachine.h" new_path="" added_lines="0" deleted_lines="99">
				<diff>@@ -1,99 +0,0 @@
-/*
- * HMIStateMachine.h
- *
- *  Created on: February 14, 2017
- *      Author: Hatem Darweesh
- */
-
-#ifndef HMIStateMachine_H_
-#define HMIStateMachine_H_
-
-#include "RoadNetwork.h"
-#include &lt;sstream&gt;
-
-namespace PlannerHNS
-{
-
-class HMIStateMachine
-{
-public:
-	virtual HMIStateMachine* GetNextState() = 0;
-	virtual void Init();
-	virtual void ResetTimer();
-	virtual void InsertNextState(HMIStateMachine* nextState);
-	HMIStateMachine(HMIStateMachine* nextState);
-	virtual ~HMIStateMachine() ;
-
-	GLOBAL_STATE_TYPE m_Behavior;
-	double decisionMakingTime;
-
-	HMIPreCalculatedConditions* GetCalcParams()
-	{
-		if(!m_pCalculatedValues)
-				m_pCalculatedValues = new HMIPreCalculatedConditions();
-
-		return m_pCalculatedValues;
-	}
-
-	void SetBehaviorsParams(const PlanningParams&amp; params)
-	{
-		m_PlanningParams = params;
-	}
-
-	static HMIPreCalculatedConditions* m_pCalculatedValues;
-	timespec m_StateTimer;
-	std::vector&lt;HMIStateMachine*&gt; pNextStates;
-	static PlanningParams m_PlanningParams;
-
-	HMIStateMachine* FindBehaviorState(const GLOBAL_STATE_TYPE&amp; behavior);
-};
-
-class GWaitingState : public HMIStateMachine
-{
-public:
-	GWaitingState(GWaitingState* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_WAITING_STATE;}
-	virtual ~GWaitingState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GPlanningState : public HMIStateMachine
-{
-public:
-	GPlanningState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_PLANING_STATE;}
-	virtual ~GPlanningState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GForwardState : public HMIStateMachine
-{
-public:
-	GForwardState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_FORWARD_STATE;}
-	virtual ~GForwardState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GBranchingState : public HMIStateMachine
-{
-public:
-	GBranchingState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_BRANCHING_STATE;}
-	virtual ~GBranchingState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GEndState : public HMIStateMachine
-{
-public:
-	GEndState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_FINISH_STATE;}
-	virtual ~GEndState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-
-} /* namespace PlannerHNS */
-
-#endif /* HMIStateMachine_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\LocalPlannerH.h" new_path="" added_lines="0" deleted_lines="157">
				<diff>@@ -1,157 +0,0 @@
-/*
- * CarState.h
- *
- *  Created on: Dec 14, 2016
- *      Author: hatem
- */
-
-#ifndef LOCALPLANNERH_H_
-#define LOCALPLANNERH_H_
-
-#include "BehaviorStateMachine.h"
-#include "PlannerCommonDef.h"
-#include "RoadNetwork.h"
-#include "TrajectoryCosts.h"
-
-namespace PlannerHNS
-{
-
-class LocalPlannerH
-{
-public:
-	WayPoint state;
-	CAR_BASIC_INFO m_CarInfo;
-	ControllerParams m_ControlParams;
-	std::vector&lt;GPSPoint&gt; m_CarShapePolygon;
-	std::vector&lt;WayPoint&gt; m_Path;
-	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_TotalPath;
-	int m_iCurrentTotalPathId;
-	int m_iSafeTrajectory;
-//	int m_iGlobalPathPrevID;
-	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_PredictedPath;
-	std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt; m_RollOuts;
-	std::string carId;
-	Lane* pLane;
-	double m_SimulationSteeringDelayFactor; //second , time that every degree change in the steering wheel takes
-	timespec m_SteerDelayTimer;
-	double m_PredictionTime;
-	double m_CostCalculationTime;
-	double m_BehaviorGenTime;
-	double m_RollOutsGenerationTime;
-
-	BehaviorStateMachine* 		m_pCurrentBehaviorState;
-	ForwardState * 				m_pGoToGoalState;
-	StopState* 					m_pStopState;
-	WaitState* 					m_pWaitState;
-	InitState* 					m_pInitState;
-	MissionAccomplishedState*	m_pMissionCompleteState;
-	GoalState*					m_pGoalState;
-	FollowState*				m_pFollowState;
-	SwerveState*				m_pAvoidObstacleState;
-	TrafficLightStopState*		m_pTrafficLightStopState;
-	TrafficLightWaitState*		m_pTrafficLightWaitState;
-	StopSignStopState* 			m_pStopSignStopState;
-	StopSignWaitState* 			m_pStopSignWaitState;
-
-	TrajectoryCosts m_TrajectoryCostsCalculatotor;
-
-
-
-	//for debugging
-	std::vector&lt;WayPoint&gt; m_PathSection;
-	std::vector&lt;WayPoint&gt; m_SampledPoints;
-
-	void InitBehaviorStates();
-
-	void SetSimulatedTargetOdometryReadings(const double&amp; velocity_d, const double&amp; steering_d, const SHIFT_POS&amp; shift_d)
-	{
-		m_CurrentVelocityD = velocity_d;
-		m_CurrentSteeringD = steering_d;
-		m_CurrentShiftD = shift_d;
-	}
-
-	double GetSimulatedVelocity()
-	{
-		return m_CurrentVelocity;
-	}
-
-	double GetSimulatedSteering()
-	{
-		return m_CurrentSteering;
-	}
-
-	double GetSimulatedShift()
-	{
-		return m_CurrentShift;
-	}
-
-
-	//For Simulation
-	WayPoint m_OdometryState;
-	double m_CurrentVelocity, m_CurrentVelocityD; //meter/second
-	double m_CurrentSteering, m_CurrentSteeringD; //radians
-	SHIFT_POS m_CurrentShift , m_CurrentShiftD;
-
-	double m_CurrentAccSteerAngle; //degrees steer wheel range
-	double m_CurrentAccVelocity; // kilometer/hour
-	//std::vector&lt;TrafficLight&gt; m_TrafficLights;
-
-public:
-
-	LocalPlannerH();
-	virtual ~LocalPlannerH();
-	void Init(const ControllerParams&amp; ctrlParams, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo);
-	void InitPolygons();
-	void FirstLocalizeMe(const WayPoint&amp; initCarPos);
-	void LocalizeMe(const double&amp; dt); // in seconds
-	void UpdateState(const VehicleState&amp; state, const bool&amp; bUseDelay = false);
-	void CalculateImportantParameterForDecisionMaking(const VehicleState&amp; car_state,
-			const int&amp; goalID, const bool&amp; bEmergencyStop, const bool&amp; bGreenTrafficLight,
-			const TrajectoryCost&amp; bestTrajectory);
-
-	BehaviorState DoOneStep(
-			const double&amp; dt,
-			const VehicleState&amp; state,
-			const std::vector&lt;DetectedObject&gt;&amp; obj_list,
-			const int&amp; goalID,
-			RoadNetwork&amp; map,
-			const bool&amp; bEmergencyStop,
-			const bool&amp; bGreenTrafficLight,
-			const bool&amp; bLive = false);
-
-	void SimulateOdoPosition(const double&amp; dt, const VehicleState&amp; vehicleState);
-
-private:
-
-	//Obstacle avoidance functionalities
-	bool CalculateObstacleCosts(RoadNetwork&amp; map, const VehicleState&amp; vstatus, const std::vector&lt;DetectedObject&gt;&amp; obj_list);
-
-	double PredictTimeCostForTrajectory(std::vector&lt;WayPoint&gt;&amp; path,
-			const VehicleState&amp; vstatus,
-			const WayPoint&amp; currState);
-
-	void PredictObstacleTrajectory(RoadNetwork&amp; map,
-			const WayPoint&amp; pos,
-			const double&amp; predTime,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-	bool CalculateIntersectionVelocities(std::vector&lt;WayPoint&gt;&amp; path,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; predctedPath,
-			const DetectedObject&amp; obj);
-
-	bool GetNextTrafficLight(const int&amp; prevTrafficLightId, const std::vector&lt;TrafficLight&gt;&amp; trafficLights, TrafficLight&amp; trafficL);
-	void UpdateCurrentLane(RoadNetwork&amp; map, const double&amp; search_distance);
-	bool SelectSafeTrajectoryAndSpeedProfile(const VehicleState&amp; vehicleState);
-	BehaviorState GenerateBehaviorState(const VehicleState&amp; vehicleState);
-	void TransformPoint(const WayPoint&amp; refPose, GPSPoint&amp; p);
-	void AddAndTransformContourPoints(const DetectedObject&amp; obj, std::vector&lt;WayPoint&gt;&amp; contourPoints);
-	void UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt);
-
-	bool NoWayTest(const double&amp; min_distance, const int&amp; iGlobalPathIndex);
-
-	PlannerHNS::PlanningParams m_params;
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* LOCALPLANNERH_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\MappingHelpers.h" new_path="" added_lines="0" deleted_lines="108">
				<diff>@@ -1,108 +0,0 @@
-/*
- * MappingHelpers.h
- *
- *  Created on: Jul 2, 2016
- *      Author: Hatem
- */
-
-#ifndef MAPPINGHELPERS_H_
-#define MAPPINGHELPERS_H_
-
-#include &lt;math.h&gt;
-#include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "DataRW.h"
-#include "tinyxml.h"
-
-
-namespace PlannerHNS {
-
-
-class MappingHelpers {
-public:
-	MappingHelpers();
-	virtual ~MappingHelpers();
-
-	static void ConstructRoadNetworkFromRosMessage(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
-			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
-			const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
-			const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
-			const std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt;&amp; area_data,
-			const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
-			const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
-			const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
-			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
-			const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
-			const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag = false);
-
-	static void ConstructRoadNetworkFromDataFiles(const std::string vectoMapPath, RoadNetwork&amp; map, const bool&amp; bZeroOrigin = false);
-
-	static void SaveTrajectoryLonLatToKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectory);
-
-	static void GetWayPoint(const int&amp; pid, const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points, std::vector&lt;WayPoint&gt;&amp; path);
-	static bool GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; did,
-			const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dtpoints,
-			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
-			const GPSPoint&amp; origin, WayPoint&amp; way_point);
-
-	static void WriteKML(const std::string&amp; kmlFile, const std::string&amp; kmlTemplat, RoadNetwork&amp; ap);
-	static void LoadKML(const std::string&amp; kmlMap, RoadNetwork&amp; map);
-
-	static void SetRoadLinksList(TiXmlElement* pElem, std::vector&lt;RoadSegment&gt;&amp; roadSegments);
-	static void SetLaneLinksList(TiXmlElement* pElem, std::vector&lt;Lane&gt;&amp; lanes);
-	static void SetStopLinesList(TiXmlElement* pElem, std::vector&lt;StopLine&gt;&amp; stopLines);
-	static void SetTrafficLightsList(TiXmlElement* pElem, std::vector&lt;TrafficLight&gt;&amp; trafficLights);
-	static void SetTrafficSignsList(TiXmlElement* pElem, std::vector&lt;TrafficSign&gt;&amp; trafficSignes);
-
-	static TiXmlElement* GetHeadElement(TiXmlElement* pMainElem);
-	static TiXmlElement* GetDataFolder(const std::string&amp; folderName, TiXmlElement* pMainElem);
-
-
-	static Lane* GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static Lane* GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static std::vector&lt;Lane*&gt; GetClosestMultipleLanesFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static WayPoint* GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
-	static WayPoint* GetClosestBackWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
-	static WayPoint GetFirstWaypoint(RoadNetwork&amp; map);
-	static WayPoint* GetLastWaypoint(RoadNetwork&amp; map);
-
-
-	static void llaToxyz(GPSPoint&amp; lla_p, const GPSPoint&amp; origin);
-	static void llaToxyzSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
-	static void xyzTolla(GPSPoint&amp; xyz_p, const GPSPoint&amp; origin);
-	static void xyzTollaSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
-
-	static void GetUniqueNextLanes(const Lane* l,  const std::vector&lt;Lane*&gt;&amp; traversed_lanes, std::vector&lt;Lane*&gt;&amp; lanes_list);
-
-	static GPSPoint GetTransformationOrigin(const int&amp; bToyotaCityMap = 0);
-
-	static Lane* GetLaneFromPath(const WayPoint&amp; currPos, const std::vector&lt;WayPoint&gt;&amp; currPath);
-	static Lane* GetLaneById(const int&amp; id,RoadNetwork&amp; map);
-	static int GetLaneIdByWaypointId(const int&amp; id,std::vector&lt;Lane&gt;&amp; lanes);
-
-	static WayPoint* FindWaypoint(const int&amp; id, RoadNetwork&amp; map);
-
-
-	static std::vector&lt;TrafficLight&gt; GetTrafficLightsList(TiXmlElement* pElem);
-	static std::vector&lt;StopLine&gt; GetStopLinesList(TiXmlElement* pElem);
-	static std::vector&lt;Lane&gt; GetLanesList(TiXmlElement* pElem);
-	static std::vector&lt;RoadSegment&gt; GetRoadSegmentsList(TiXmlElement* pElem);
-	static std::vector&lt;int&gt; GetIDsFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::vector&lt;double&gt; GetDoubleFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::pair&lt;ACTION_TYPE, double&gt; GetActionPairFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::vector&lt;WayPoint&gt; GetCenterLaneData(TiXmlElement* pElem, const int&amp; currLaneID);
-	static std::vector&lt;WayPoint&gt; GetCenterLaneDataVer0(TiXmlElement* pElem, const int&amp; currLaneID);
-	static std::vector&lt;GPSPoint&gt; GetPointsData(TiXmlElement* pElem);
-	static std::vector&lt;std::string&gt; SplitString(const std::string&amp; str, const std::string&amp; token);
-
-	static void CreateKmlFromLocalizationPathFile(const std::string&amp; pathFileName,const double&amp; maxLaneDistance, const double&amp; density,const std::vector&lt;TrafficLight&gt;&amp; trafficLights, const std::vector&lt;GPSPoint&gt;&amp; stopLines);
-
-	static int ReplaceMyID(int&amp; id, const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; rep_list);
-
-	static double m_USING_VER_ZERO;
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* MAPPINGHELPERS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\MatrixOperations.h" new_path="" added_lines="0" deleted_lines="131">
				<diff>@@ -1,131 +0,0 @@
-/*
- * MatrixOperations.h
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
-
-#ifndef MATRIXOPERATIONS_H_
-#define MATRIXOPERATIONS_H_
-
-#include "RoadNetwork.h"
-#include &lt;math.h&gt;
-
-
-namespace PlannerHNS {
-
-
-class Mat3
-{
-	double m11, m12, m13;
-	double m21, m22, m23;
-	double m31, m32, m33;
-
-	double m[3][3];
-
-public:
-	Mat3()
-	{
-		//initialize Identity by default
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-	}
-
-	Mat3(double angle, POINT2D trans)
-	{
-		//Initialize Rotation Matrix
-		double c = cos(angle);
-		double s = sin(angle);
-		m11 = c;
-		m12 = s;
-		m21 = -s;
-		m22 = c;
-		m31 = trans.x;
-		m32 = trans.y;
-		m13 = m23= 0;
-		m33 = 1;
-	}
-
-	Mat3(double transX, double transY, bool mirrorX, bool mirrorY )
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		m[0][0] = (mirrorX == true ) ? -1 : 1; m[0][1] =  0; m[0][2] =  transX;
-		m[1][0] = 0; m[1][1] =  (mirrorY==true) ? -1 : 1; m[1][2] =  transY;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(double transX, double transY)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		m[0][0] = 1; m[0][1] =  0; m[0][2] =  transX;
-		m[1][0] = 0; m[1][1] =  1; m[1][2] =  transY;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(double rotation_angle)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		double c = cos(rotation_angle);
-		double s = sin(rotation_angle);
-		m[0][0] = c; m[0][1] = -s; m[0][2] =  0;
-		m[1][0] = s; m[1][1] =  c; m[1][2] =  0;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(GPSPoint rotationCenter)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		double c = cos(rotationCenter.a);
-		double s = sin(rotationCenter.a);
-		double u = rotationCenter.x;
-		double v = rotationCenter.y;
-		m[0][0] = c; m[0][1] = -s; m[0][2] = -u*c + v*s + u;
-		m[1][0] = s; m[1][1] =  c; m[1][2] = -u*s - v*c + v;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-
-	GPSPoint operator * (GPSPoint v)
-	{
-		GPSPoint _v = v;
-		v.x = m[0][0]*_v.x + m[0][1]*_v.y + m[0][2]*1;
-		v.y = m[1][0]*_v.x + m[1][1]*_v.y + m[1][2]*1;
-		return v;
-	}
-
-	POINT2D operator * (POINT2D v)
-	{
-		Mat3 m = *this;
-		POINT2D r;
-		r.x = m.m11 * v.x + m.m21 * v.y + m.m31 * 1;
-		r.y = m.m12 * v.x + m.m22 * v.y + m.m32 * 1;
-		return r;
-	}
-
-	Mat3 operator *(Mat3 m2)
-	{
-		Mat3 m1 = *this;
-		Mat3 r;
-		r.m11 = m1.m11 * m2.m11 + m1.m12 * m2.m21 + m1.m13 * m2.m31;
-		r.m12 = m1.m11 * m2.m12 + m1.m12 * m2.m22 + m1.m13 * m2.m32;
-		r.m13 = m1.m11 * m2.m13 + m1.m12 * m2.m23 + m1.m13 * m2.m33;
-
-		r.m21 = m1.m21 * m2.m11 + m1.m22 * m2.m21 + m1.m23 * m2.m31;
-		r.m22 = m1.m21 * m2.m12 + m1.m22 * m2.m22 + m1.m23 * m2.m32;
-		r.m23 = m1.m21 * m2.m13 + m1.m22 * m2.m23 + m1.m23 * m2.m33;
-
-		r.m31 = m1.m31 * m2.m11 + m1.m32 * m2.m21 + m1.m33 * m2.m31;
-		r.m32 = m1.m31 * m2.m12 + m1.m32 * m2.m22 + m1.m33 * m2.m32;
-		r.m33 = m1.m31 * m2.m13 + m1.m32 * m2.m23 + m1.m33 * m2.m33;
-
-		return r;
-	}
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* MATRIXOPERATIONS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\OpenPlannerSimulator_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulator\include\OpenPlannerSimulator_core.h" added_lines="1" deleted_lines="3">
				<diff>@@ -35,7 +35,7 @@
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
-#include &lt;cv_tracker/obj_label.h&gt;
+#include &lt;cv_tracker_msgs/obj_label.h&gt;
 #include &lt;runtime_manager/traffic_light.h&gt;
 
 #include &lt;geometry_msgs/Vector3Stamped.h&gt;
@@ -46,13 +46,11 @@
 #include &lt;tf/transform_listener.h&gt;
 #include &lt;tf/tf.h&gt;
 #include &lt;std_msgs/Int8.h&gt;
-#include "waypoint_follower/libwaypoint_follower.h"
 #include "TrajectoryFollower.h"
 #include "LocalPlannerH.h"
 #include "PlannerH.h"
 #include "MappingHelpers.h"
 
-#include "waypoint_follower/LaneArray.h"
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;visualization_msgs/InteractiveMarkerPose.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\PlannerCommonDef.h" new_path="" added_lines="0" deleted_lines="156">
				<diff>@@ -1,156 +0,0 @@
-/*
- * PlannerCommonDef.h
- *
- *  Created on: Dec 14, 2016
- *      Author: hatem
- */
-
-#ifndef PLANNERCOMMONDEF_H_
-#define PLANNERCOMMONDEF_H_
-
-#include &lt;math.h&gt;
-#include &lt;string&gt;
-
-namespace PlannerHNS
-{
-
-enum CAR_TYPE
-{
-  Mv2Car, //!&lt; Mv2Car
-  PHVCar, //!&lt; PHVCar
-  HVCar,  //!&lt; HVCar
-  RoboCar,//!&lt; RoboCar
-  SimulationCar
-};
-
-class PID_CONST
-{
-public:
-	double kP;
-	double kI;
-	double kD;
-
-	PID_CONST()
-	{
-		kP = kI = kD = 0;
-	}
-
-	PID_CONST(const double&amp; p, const double&amp; i, const double&amp; d)
-	{
-		kP = p;
-		kI = i;
-		kD = d;
-	}
-};
-
-class ControllerParams
-{
-public:
-	double SimulationSteeringDelay;
-	double SteeringDelay;
-	double minPursuiteDistance;
-	PID_CONST Steering_Gain;
-	PID_CONST Velocity_Gain;
-	double Acceleration;
-	double Deceleration;
-	double FollowDistance;
-	double LowpassSteerCutoff;
-	double maxAccel;
-	double maxDecel;
-
-
-	ControllerParams()
-	{
-		SimulationSteeringDelay = 0.0;
-		SteeringDelay 		= 0.8;
-		Acceleration		= 0.5;
-		Deceleration		= -0.8;
-		FollowDistance		= 8.0;
-		LowpassSteerCutoff	= 5.0;
-		maxAccel			= 0.9;
-		minPursuiteDistance = 2.0;
-		maxDecel 			= -1.5;
-	}
-};
-
-class CAR_BASIC_INFO
-{
-public:
-  CAR_TYPE model;
-
-  double turning_radius;
-  double wheel_base;
-  double max_speed_forward;
-  double min_speed_forward;
-  double max_speed_backword;
-  double max_steer_value;
-  double min_steer_value;
-  double max_brake_value;
-  double min_brake_value;
-  double max_steer_angle;
-  double min_steer_angle;
-  double length;
-  double width;
-  double max_acceleration;
-  double max_deceleration;
-
-  CAR_BASIC_INFO()
-  {
-	  model 				= SimulationCar;
-	  turning_radius 		= 5.2;
-	  wheel_base			= 2.7;
-	  max_speed_forward		= 3.0;
-	  min_speed_forward		= 0.0;
-	  max_speed_backword	= 1.0;
-	  max_steer_value		= 660;
-	  min_steer_value		= -660;
-	  max_brake_value		= 0;
-	  min_brake_value		= 0;
-	  max_steer_angle		= 0.42;
-	  min_steer_angle		= 0.42;
-	  length				= 4.3;
-	  width					= 1.82;
-	  max_acceleration		= 1.5; // m/s2
-	  max_deceleration		= -1.5; // 1/3 G
-  }
-
-  double CalcMaxSteeringAngle()
-  {
-    return  max_steer_angle;//asin(wheel_base/turning_radius);
-  }
-
-  double BoundSpeed(double s)
-  {
-	if(s &gt; 0 &amp;&amp; s &gt; max_speed_forward)
-		return max_speed_forward;
-	if(s &lt; 0 &amp;&amp; s &lt; max_speed_backword)
-		return max_speed_backword;
-	return s;
-  }
-
-  double BoundSteerAngle(double a)
-  {
-	if(a &gt; max_steer_angle)
-		return max_steer_angle;
-	if(a &lt; min_steer_angle)
-		return min_steer_angle;
-
-	return a;
-  }
-
-  double BoundSteerValue(double v)
-  {
-	  if(v &gt;= max_steer_value)
-		return max_steer_value;
-	if(v &lt;= min_steer_value)
-		return min_steer_value;
-
-	return v;
-  }
-
-};
-
-
-} /* namespace PlannerHNS */
-
-#endif /* PLANNERCOMMONDEF_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\PlannerH.h" new_path="" added_lines="0" deleted_lines="119">
				<diff>@@ -1,119 +0,0 @@
-/*
- * PlannerH.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#include "RSPlanner.h"
-#include "GridMap.h"
-
-#define START_POINT_MAX_DISTANCE 8 // meters
-#define GOAL_POINT_MAX_DISTANCE 8 // meters
-#define LANE_CHANGE_SMOOTH_FACTOR_DISTANCE 8 // meters
-
-namespace PlannerHNS
-{
-
-enum PLANDIRECTION {MOVE_FORWARD_ONLY, MOVE_BACKWARD_ONLY, 	MOVE_FREE};
-enum HeuristicConstrains {EUCLIDEAN, NEIGBORHOOD,DIRECTION };
-
-class PlannerH
-{
-public:
-	PlannerH();
-	virtual ~PlannerH(); 
-
-
-	/**
-	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles
-	 * @param start: Start position for the trajectory (x,y,theta)
-	 * @param goal:  Goal position (Destination point) (x,y,theta)
-	 * @param map:  2d grid map, ( cost map or occupancy grid.
-	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
-	 * @return path length
-	 */
-	double PlanUsingReedSheppWithObstacleDetection(const WayPoint&amp; start, const WayPoint&amp; goal, GridMap&amp; map, std::vector&lt;WayPoint&gt;&amp; genSmoothedPath,
-			const double pathDensity = 0.25, const double smoothFactor = 12.0);
-
-	/**
-	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles , but if there an obstacle on the trajectory function will fail. , also this function does not guaranteed to generate trajectories
-	 * @param start: Start position for the trajectory (x,y,theta)
-	 * @param goal:  Goal position (Destination point) (x,y,theta)
-	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
-	 * @return path length
-	 */
-	double PlanUsingReedShepp(const WayPoint&amp; start, const WayPoint&amp; goal, std::vector&lt;WayPoint&gt;&amp; generatedPath,
-			const double pathDensity = 0.25, const double smoothFactor = 12.0);
-
-
-	/**
-	 * @brief Generate Roll outs for global generated path
-	 * @param referencePath center lint reference path
-	 * @param carPos current car position
-	 * @param bEnableLaneChange is lane change is available
-	 * @param speed current car speed
-	 * @param microPlanDistance distance limit for roll outs
-	 * @param maxSpeed maximum forward speed
-	 * @param minSpeed minimum forward speed
-	 * @param carTipMargin 1st roll out smoothing parameter
-	 * @param rollInMargin 2nd roll out smoothing parameter
-	 * @param rollInSpeedFactor roll out 3rd smoothing parameter
-	 * @param pathDensity distance between every two waypoints in the generated trajectory
-	 * @param rollOutDensity distance between the center line and adjacent trajectories
-	 * @param rollOutNumber number of sampled trajectories
-	 * @param SmoothDataWeight general smoothing parameter , how smoother keep close to original data 0 - 0.5
-	 * @param SmoothWeight general smoothing parameter, how smoother is trying to pull away to form the shortest and strait line possible
-	 * @param SmoothTolerance performance measure , conjugate gradient conversion factor should be 0.1 - 0.01
-	 * @param speedProfileFactor how car should slow for corners
-	 * @param bHeadingSmooth follow car heading direction or center line path heading for sampling direction
-	 */
-	void GenerateRunoffTrajectory(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; referencePaths, const WayPoint&amp; carPos, const bool&amp; bEnableLaneChange, const double&amp; speed, const double&amp; microPlanDistance,
-				const double&amp; maxSpeed,const double&amp; minSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
-				const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
-				const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
-				const double&amp; SmoothTolerance, const double&amp; speedProfileFactor, const bool&amp; bHeadingSmooth,
-				const int&amp; iCurrGlobalPath, const int&amp; iCurrLocalTraj,
-				std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOutsPaths,
-				std::vector&lt;WayPoint&gt;&amp; sectionPath, std::vector&lt;WayPoint&gt;&amp; sampledPoints);
-
-	/**
-	 * @brief Path planning for structured environment using dynamic programming
-	 * @param lane
-	 * @param carPos
-	 * @param goalPos
-	 * @param prevWayPoint
-	 * @param maxPlanningDistance
-	 * @param globalPath
-	 * @param path
-	 * @return generated path length
-	 */
-	double PlanUsingDP(const WayPoint&amp; carPos,const WayPoint&amp; goalPos,
-			const double&amp; maxPlanningDistance, const bool bEnableLaneChange, const std::vector&lt;int&gt;&amp; globalPath,
-			RoadNetwork&amp; map, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, std::vector&lt;WayPoint*&gt;* all_cell_to_delete = 0);
-
-	 double PlanUsingDPRandom(const WayPoint&amp; start,
-	 		 const double&amp; maxPlanningDistance,
-	 		 RoadNetwork&amp; map,
-	 		 std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-
-	/**
-	 * @brief Return all possible trajectories from current position to max planning distance in all directions
-	 * @param lane
-	 * @param carPos
-	 * @param maxPlanningDistance
-	 * @param paths
-	 * @return
-	 */
-	double PredictPlanUsingDP(Lane* lane, const WayPoint&amp; carPos, const double&amp; maxPlanningDistance,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-	void DeleteWaypoints(std::vector&lt;WayPoint*&gt;&amp; wps);
-
-	//PlanningInternalParams m_Params;
-};
-
-}
-
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\PlanningHelpers.h" new_path="" added_lines="0" deleted_lines="170">
				<diff>@@ -1,170 +0,0 @@
-/*
- * PlanningHelpers.h
- *
- *  Created on: Jun 16, 2016
- *      Author: hatem
- */
-
-#ifndef PLANNINGHELPERS_H_
-#define PLANNINGHELPERS_H_
-
-#include &lt;math.h&gt;
-#include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "DataRW.h"
-#include "tinyxml.h"
-
-
-namespace PlannerHNS {
-
-#define distance2points(from , to) sqrt(pow(to.x - from.x, 2) + pow(to.y - from.y, 2))
-#define distance2pointsSqr(from , to) pow(to.x - from.x, 2) + pow(to.y - from.y, 2)
-#define pointNorm(v) sqrt(v.x*v.x + v.y*v.y)
-#define angle2points(from , to) atan2(to.y - from.y, to.x - from.x )
-#define LANE_CHANGE_SPEED_FACTOR 0.5
-#define LANE_CHANGE_COST 3.0 // meters
-#define BACKUP_STRAIGHT_PLAN_DISTANCE 60 //meters
-
-class PlanningHelpers {
-public:
-	PlanningHelpers();
-	virtual ~PlanningHelpers();
-
-	/**
-	 * @brief Find all relative information from the point p to the trajectory such as (perpendicular distance , closest next point , closest back point, distance from perpendicular intersection point to next point, distance from perpendicular intersection point to previous point)
-	 * @param trajectory list of waypoints
-	 * @param p query point
-	 * @param info collection of calculated information
-	 * @param prevIndex initial search index
-	 * @return true if success without errors, false otherwise
-	 */
-	static bool GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex = 0);
-
-	static bool GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectories, const WayPoint&amp; p, const double&amp; searchDistance, RelativeInfo&amp; info);
-
-	/**
-	 * @brief Find point on the trajectory after initial relative point with specific distance
-	 * @param trajectory list of waypoints
-	 * @param init_p initial relative point on trajectory
-	 * @param distance distance from initial relative point to follow point
-	 * @return point on trajectory
-	 */
-	static WayPoint GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; init_p, const double&amp; distance, unsigned int&amp; point_index);
-
-	/**
-	 * @brief Calculate the precise distance from projection of point p2 (relative) to projection of point 1 (relative)
-	 * @param trajectory list of waypoints
-	 * @param p1 first relative point
-	 * @param p2 second relative point
-	 * @return distance on trajectory
-	 */
-	static double GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; p1,const RelativeInfo&amp; p2);
-
-	/**
-	 * @brief Find the closest next point on the trajectory index
-	 * @param trajectory list of waypoints
-	 * @param p query point
-	 * @param prevIndex initial search index
-	 * @return index of the closest next point from trajectory
-	 */
-	static int GetClosestNextPointIndex(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-
-	static int GetClosestNextPointIndexDirection(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-
-
-	static int GetClosestPointIndex_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex = 0 );
-	static WayPoint GetPerpendicularOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, double&amp; distance, const int&amp; prevIndex = 0);
-	static double GetPerpDistanceToTrajectorySimple_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-	static double GetPerpDistanceToVectorSimple_obsolete(const WayPoint&amp; p1, const WayPoint&amp; p2, const WayPoint&amp; pose);
-	static WayPoint GetNextPointOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const double&amp; distance, const int&amp; currIndex = 0);
-	static double GetDistanceOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
-
-
-	static void FixPathDensity(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; distanceDensity);
-	static void SmoothPath(std::vector&lt;WayPoint&gt;&amp; path, double weight_data =0.25,double weight_smooth = 0.25,double tolerance = 0.01);
-	static double CalcCircle(const GPSPoint&amp; pt1, const GPSPoint&amp; pt2, const GPSPoint&amp; pt3, GPSPoint&amp; center);
-	static double CalcAngleAndCost(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0, const bool&amp; bSmooth = true );
-	//static double CalcAngleAndCostSimple(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0);
-	static double CalcAngleAndCostAndCurvatureAnd2D(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0);
-
-	static double GetAccurateDistanceOnTrajectory(std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
-
-	static void ExtractPartFromPointToDistance(const std::vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
-			const double&amp; pathDensity, std::vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance);
-
-	static void CalculateRollInTrajectories(const WayPoint&amp; carPos, const double&amp; speed, const std::vector&lt;WayPoint&gt;&amp; originalCenter, int&amp; start_index,
-			int&amp; end_index, std::vector&lt;double&gt;&amp; end_laterals ,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; rollInPaths, const double&amp; max_roll_distance,
-			const double&amp; maxSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
-			const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
-			const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
-			const double&amp; SmoothTolerance, const bool&amp; bHeadingSmooth,
-			std::vector&lt;WayPoint&gt;&amp; sampledPoints);
-
-
-	static void SmoothSpeedProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
-	static void SmoothCurvatureProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance = 0.1);
-	static void SmoothWayPointsDirections(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
-
-	static void GenerateRecommendedSpeed(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor);
-//	static WayPoint* BuildPlanningSearchTree(Lane* l, const WayPoint&amp; prevWayPointIndex,
-//			const WayPoint&amp; startPos, const WayPoint&amp; goalPos,
-//			const std::vector&lt;int&gt;&amp; globalPath, const double&amp; DistanceLimit,
-//			int&amp; nMaxLeftBranches, int&amp; nMaxRightBranches,
-//			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static WayPoint* BuildPlanningSearchTreeV2(WayPoint* pStart,
-			const WayPoint&amp; goalPos,
-			const std::vector&lt;int&gt;&amp; globalPath, const double&amp; DistanceLimit,
-			const bool&amp; bEnableLaneChange,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static WayPoint* BuildPlanningSearchTreeStraight(WayPoint* pStart,
-			const double&amp; DistanceLimit,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static int PredictiveDP(WayPoint* pStart, const double&amp; DistanceLimit,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete, std::vector&lt;WayPoint*&gt;&amp; end_waypoints);
-
-	static bool CheckLaneIdExits(const std::vector&lt;int&gt;&amp; lanes, const Lane* pL);
-	static WayPoint* CheckLaneExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const Lane* pL);
-	static WayPoint* CheckNodeExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const WayPoint* pL);
-
-	static WayPoint* CreateLaneHeadCell(Lane* pLane, WayPoint* pLeft, WayPoint* pRight,
-			WayPoint* pBack);
-	static double GetLanePoints(Lane* l, const WayPoint&amp; prevWayPointIndex,
-			const double&amp; minDistance , const double&amp; prevCost, std::vector&lt;WayPoint&gt;&amp; points);
-
-	static WayPoint* GetMinCostCell(const std::vector&lt;WayPoint*&gt;&amp; cells, const std::vector&lt;int&gt;&amp; globalPathIds);
-
-	static void TraversePathTreeBackwards(WayPoint* pHead, WayPoint* pStartWP, const std::vector&lt;int&gt;&amp; globalPathIds,
-			std::vector&lt;WayPoint&gt;&amp; localPath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; localPaths);
-
-	static void ExtractPlanAlernatives(const std::vector&lt;WayPoint&gt;&amp; singlePath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; allPaths);
-
-	static std::vector&lt;int&gt; GetUniqueLeftRightIds(const std::vector&lt;WayPoint&gt;&amp; path);
-
-	static bool FindInList(const std::vector&lt;int&gt;&amp; list,const int&amp; x);
-	static void RemoveWithValue(std::vector&lt;int&gt;&amp; list,const int&amp; x);
-
-	static ACTION_TYPE GetBranchingDirection(WayPoint&amp; currWP, WayPoint&amp; nextWP);
-
-	static void CalcContourPointsForDetectedObjects(const WayPoint&amp; currPose, std::vector&lt;DetectedObject&gt;&amp; obj_list, const double&amp; filterDistance = 100);
-
-	static double GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; pose, const double&amp; distance);
-	static bool CompareTrajectories(const std::vector&lt;WayPoint&gt;&amp; path1, const std::vector&lt;WayPoint&gt;&amp; path2);
-
-	static double GetDistanceToClosestStopLineAndCheck(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; p, int&amp; stopLineID,int&amp; stopSignID, int&amp; trafficLightID, const int&amp; prevIndex = 0);
-
-	static void WritePathToFile(const std::string&amp; fileName, const std::vector&lt;WayPoint&gt;&amp; path);
-
-	static void TestQuadraticSpline(const std::vector&lt;WayPoint&gt;&amp; center_line, std::vector&lt;WayPoint&gt;&amp; path);
-	static double frunge ( double x );
-	static double fprunge ( double x );
-	static double fpprunge ( double x );
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* PLANNINGHELPERS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\PolygonGenerator.h" new_path="ros\src\computing\planning\motion\packages\op_simulator\include\PolygonGenerator.h" added_lines="1" deleted_lines="1">
				<diff>@@ -15,7 +15,7 @@
 #include &lt;pcl/io/pcd_io.h&gt;
 #include &lt;pcl/point_types.h&gt;
 
-#include "../../op_simulator/include/RoadNetwork.h"
+#include &lt;RoadNetwork.h&gt;
 
 namespace OpenPlannerSimulatorNS
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\RSPlanner.h" new_path="" added_lines="0" deleted_lines="77">
				<diff>@@ -1,77 +0,0 @@
-/*
- * RSPlanner.h
- *
- *  Created on: Aug 9, 2015
- *      Author: hatem
- */
-
-#include "PlanningHelpers.h"
-#ifndef RSPLANNERSA_H_
-#define RSPLANNERSA_H_
-
-namespace PlannerHNS
-{
-
-#define EPS1 1.0e-12
-#define EPS2 1.0e-12
-#define EPS3 1.0e-12
-#define EPS4 1.0e-12
-#define MYINFINITY 1000000
-
-#define MPI 3.1415926536
-#define MPIMUL2 6.2831853072
-#define MPIDIV2 1.5707963268
-
-
-
-
-class RSPlanner
-{
-public:
-	double RADCURV ;
-	double RADCURVMUL2 ;
-	double RADCURVMUL4 ;
-	double SQRADCURV ;
-	double SQRADCURVMUL2 ;
-	double PATHDENSITY;
-	RSPlanner(double curvatureFactor = 15.6);
-	virtual ~RSPlanner();
-
-	double min_length_rs(const double&amp; x1,const double&amp; y1,const double&amp; t1,const double&amp; x2,const double&amp; y2,const double&amp; t2,int&amp; numero,double&amp; t,double&amp; u,double&amp; v);
-	int constRS(int num,double t,double u,double v,double x1,double y1,double t1,double delta,std::vector&lt;WayPoint&gt;&amp; path);
-
-private:
-	struct ConfigItem
-	{
-		double length;
-		int num;
-		double t,u,v;
-	};
-
-
-	double mod2pi(const double&amp; a);
-	double my_atan2(const double&amp;  y, const double&amp; x);
-	double c_c_c(const double&amp; x,const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_cc(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double cscb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double ccu_cuc(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_cucu_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2sca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2scb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2sc2_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double cc_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csc2_ca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csc2_cb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-
-	double reed_shepp(const double&amp; x1,const double&amp; y1,const double&amp; t1,const double&amp; x2,const double&amp; y2,const double&amp; t2,int&amp; numero,double&amp; tr,double&amp; ur,double&amp; vr);
-
-	int fct_curve(const int&amp; ty,const int&amp; orientation,const double&amp; val,double&amp; x1,double&amp; y1,double&amp; t1,const double&amp; delta,std::vector&lt;WayPoint&gt;&amp; path,int n);
-
-
-
-};
-
-} /* namespace PlannerZNS */
-
-#endif /* RSPLANNER_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\RoadNetwork.h" new_path="" added_lines="0" deleted_lines="1018">
				<diff>@@ -1,1018 +0,0 @@
-/*
- * RoadNetwork.h
- *
- *  Created on: May 19, 2016
- *      Author: hatem
- */
-
-#ifndef ROADNETWORK_H_
-#define ROADNETWORK_H_
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;sstream&gt;
-#include "UtilityH.h"
-
-#define OPENPLANNER_ENABLE_LOGS
-
-namespace PlannerHNS
-{
-
-
-enum DIRECTION_TYPE {	FORWARD_DIR, FORWARD_LEFT_DIR, FORWARD_RIGHT_DIR,
-	BACKWARD_DIR, BACKWARD_LEFT_DIR, BACKWARD_RIGHT_DIR, STANDSTILL_DIR};
-
-enum OBSTACLE_TYPE {SIDEWALK, TREE, CAR, TRUCK, HOUSE, PEDESTRIAN, CYCLIST, GENERAL_OBSTACLE};
-
-enum DRIVABLE_TYPE {DIRT, TARMAC, PARKINGAREA, INDOOR, GENERAL_AREA};
-
-enum GLOBAL_STATE_TYPE {G_WAITING_STATE, G_PLANING_STATE, G_FORWARD_STATE, G_BRANCHING_STATE, G_FINISH_STATE};
-
-enum STATE_TYPE {INITIAL_STATE, WAITING_STATE, FORWARD_STATE, STOPPING_STATE, EMERGENCY_STATE,
-	TRAFFIC_LIGHT_STOP_STATE,TRAFFIC_LIGHT_WAIT_STATE, STOP_SIGN_STOP_STATE, STOP_SIGN_WAIT_STATE, FOLLOW_STATE, LANE_CHANGE_STATE, OBSTACLE_AVOIDANCE_STATE, GOAL_STATE, FINISH_STATE};
-
-enum LIGHT_INDICATOR {INDICATOR_LEFT, INDICATOR_RIGHT, INDICATOR_BOTH , INDICATOR_NONE};
-
-enum SHIFT_POS {SHIFT_POS_PP = 0x60, SHIFT_POS_RR = 0x40, SHIFT_POS_NN = 0x20,
-	SHIFT_POS_DD = 0x10, SHIFT_POS_BB = 0xA0, SHIFT_POS_SS = 0x0f, SHIFT_POS_UU = 0xff };
-
-enum ACTION_TYPE {FORWARD_ACTION, BACKWARD_ACTION, STOP_ACTION, LEFT_TURN_ACTION,
-	RIGHT_TURN_ACTION, U_TURN_ACTION, SWERVE_ACTION, OVERTACK_ACTION};
-
-
-class Lane;
-class TrafficLight;
-
-class ObjTimeStamp
-{
-public:
-	timespec tStamp;
-
-	ObjTimeStamp()
-	{
-		tStamp.tv_nsec = 0;
-		tStamp.tv_sec = 0;
-	}
-};
-
-class POINT2D
-{
-public:
-    double x;
-    double y;
-    double z;
-    POINT2D()
-    {
-      x=0;y=0;z=0;
-    }
-    POINT2D(double px, double py, double pz = 0)
-    {
-      x = px;
-      y = py;
-      z = pz;
-    }
-};
-
-
-
-class RECTANGLE
-
-{
-public:
-  POINT2D bottom_left;
-  POINT2D top_right;
-  double width;
-  double length;
-  bool bObstacle;
-
-
-  inline bool PointInRect(POINT2D p)
-  {
-    return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
-  }
-
-  inline bool HitTest(POINT2D p)
-  {
-    return PointInRect(p) &amp;&amp; bObstacle;
-  }
-
-  RECTANGLE()
-  {
-	  width=0;
-	  length = 0;
-    bObstacle = true;
-  }
-
-  virtual ~RECTANGLE(){}
-};
-
-class GPSPoint
-{
-public:
-	double lat, x;
-	double lon, y;
-	double alt, z;
-	double dir, a;
-
-	GPSPoint()
-	{
-		lat = x = 0;
-		lon = y = 0;
-		alt = z = 0;
-		dir = a = 0;
-	}
-
-	GPSPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
-	{
-		this-&gt;x = x;
-		this-&gt;y = y;
-		this-&gt;z = z;
-		this-&gt;a = a;
-
-		lat = 0;
-		lon = 0;
-		alt = 0;
-		dir = 0;
-	}
-
-	std::string ToString()
-	{
-		std::stringstream str;
-		str.precision(12);
-		str &lt;&lt; "X:" &lt;&lt; x &lt;&lt; ", Y:" &lt;&lt; y &lt;&lt; ", Z:" &lt;&lt; z &lt;&lt; ", A:" &lt;&lt; a &lt;&lt; std::endl;
-		str &lt;&lt; "Lon:" &lt;&lt; lon &lt;&lt; ", Lat:" &lt;&lt; lat &lt;&lt; ", Alt:" &lt;&lt; alt &lt;&lt; ", Dir:" &lt;&lt; dir &lt;&lt; std::endl;
-		return str.str();
-	}
-};
-
-class PolygonShape
-{
-public:
-	std::vector&lt;GPSPoint&gt; points;
-
-	inline int PointInsidePolygon(const PolygonShape&amp; polygon,const GPSPoint&amp; p)
-	{
-		int counter = 0;
-		  int i;
-		  double xinters;
-		  GPSPoint p1,p2;
-		  int N = polygon.points.size();
-		  if(N &lt;=0 ) return -1;
-
-		  p1 = polygon.points.at(0);
-		  for (i=1;i&lt;=N;i++)
-		  {
-		    p2 = polygon.points.at(i % N);
-
-		    if (p.y &gt; MIN(p1.y,p2.y))
-		    {
-		      if (p.y &lt;= MAX(p1.y,p2.y))
-		      {
-		        if (p.x &lt;= MAX(p1.x,p2.x))
-		        {
-		          if (p1.y != p2.y)
-		          {
-		            xinters = (p.y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
-		            if (p1.x == p2.x || p.x &lt;= xinters)
-		              counter++;
-		          }
-		        }
-		      }
-		    }
-		    p1 = p2;
-		  }
-
-		  if (counter % 2 == 0)
-		    return 0;
-		  else
-		    return 1;
-	}
-};
-
-class MapItem
-{
-public:
-  int id;
-  POINT2D sp; //start point
-  POINT2D ep; // end point
-  GPSPoint center;
-  double c; //curvature
-  double w; //width
-  double l; //length
-  std::string fileName; //
-  std::vector&lt;POINT2D&gt; polygon;
-
-
-  MapItem(int ID, POINT2D start, POINT2D end, double curvature, double width, double length, std::string objName)
-  {
-    id = ID;
-    sp = start;
-    ep = end;
-    c = curvature;
-    w = width;
-    l = length;
-    fileName = objName;
-
-  }
-
-  MapItem()
-  {
-    id = 0; c = 0; w = 0; l = 0;
-  }
-
-  virtual ~MapItem(){}
-
-  MapItem(const MapItem &amp; cmi)
-  {
-        id = cmi.id;
-        sp = cmi.sp;
-        ep = cmi.ep;
-        c = cmi.c;
-        w = cmi.w;
-        l = cmi.l;
-        fileName = cmi.fileName;
-  }
-  MapItem &amp;operator=(const MapItem &amp;cmi)
-  {
-    this-&gt;id = cmi.id;
-      this-&gt;sp = cmi.sp;
-      this-&gt;ep = cmi.ep;
-      this-&gt;c = cmi.c;
-      this-&gt;w = cmi.w;
-      this-&gt;l = cmi.l;
-      this-&gt;fileName = cmi.fileName;
-      return *this;
-  }
-
-  virtual int operator==(const MapItem &amp;mi) const
-    {
-      return this-&gt;id == mi.id;
-    }
-};
-
-class Obstacle : public MapItem
-{
-  public:
-    OBSTACLE_TYPE t;
-
-    Obstacle(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,OBSTACLE_TYPE type, std::string fileName ) : MapItem(ID, start, end, curvature, width, length, fileName)
-  {
-      t = type;
-  }
-    virtual ~Obstacle()
-    {
-    }
-
-    Obstacle() : MapItem()
-       {
-      t = SIDEWALK;
-       }
-
-    Obstacle(const Obstacle&amp; ob) : MapItem(ob)
-      {
-        t = ob.t;
-      }
-
-    Obstacle&amp; operator=(const Obstacle&amp; ob)
-      {
-      this-&gt;id = ob.id;
-      this-&gt;sp = ob.sp;
-      this-&gt;ep = ob.ep;
-      this-&gt;c = ob.c;
-      this-&gt;w = ob.w;
-      this-&gt;l = ob.l;
-      this-&gt;t = ob.t;
-      this-&gt;fileName = ob.fileName;
-      return *this;
-      }
-
-      virtual int operator==(const Obstacle &amp;ob) const
-          {
-            return this-&gt;id == ob.id &amp;&amp; this-&gt;t == ob.t;
-          }
-};
-
-class DrivableArea : public MapItem
-{
-public:
-  DRIVABLE_TYPE t; // drivable area type
-
-  DrivableArea(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,DRIVABLE_TYPE type, std::string fileName ) : MapItem( ID, start, end, curvature, width, length, fileName)
-  {
-    t = type;
-  }
-
-  virtual ~DrivableArea()
-  {
-
-  }
-
-  DrivableArea() : MapItem()
-    {
-      t = PARKINGAREA;
-    }
-
-  DrivableArea(const DrivableArea&amp; da) : MapItem(da)
-  {
-    t = da.t;
-  }
-
-  DrivableArea&amp; operator=(const DrivableArea&amp; da)
-  {
-    this-&gt;id = da.id;
-    this-&gt;sp = da.sp;
-    this-&gt;ep = da.ep;
-    this-&gt;c = da.c;
-    this-&gt;w = da.w;
-    this-&gt;l = da.l;
-    this-&gt;t = da.t;
-    this-&gt;fileName = da.fileName;
-    return *this;
-  }
-
-  virtual int operator==(const DrivableArea &amp;da) const
-      {
-        return this-&gt;id == da.id &amp;&amp; this-&gt;t == da.t;
-      }
-
-};
-
-
-
-class Rotation
-{
-public:
-	double x;
-	double y;
-	double z;
-	double w;
-
-	Rotation()
-	{
-		x = 0;
-		y = 0;
-		z = 0;
-		w = 0;
-	}
-};
-
-class WayPoint
-{
-public:
-	GPSPoint	pos;
-	Rotation 	rot;
-	double  	v;
-	double  	cost;
-	double  	timeCost;
-	double  	totalReward;
-	double  	collisionCost;
-	double 		laneChangeCost;
-	int 		laneId;
-	int 		id;
-	int 		LeftLaneId;
-	int 		RightLaneId;
-	int 		stopLineID;
-	DIRECTION_TYPE bDir;
-
-	Lane* pLane;
-	WayPoint* pLeft;
-	WayPoint* pRight;
-	std::vector&lt;int&gt; 	toIds;
-	std::vector&lt;int&gt; 	fromIds;
-	std::vector&lt;WayPoint*&gt; pFronts;
-	std::vector&lt;WayPoint*&gt; pBacks;
-	std::vector&lt;std::pair&lt;ACTION_TYPE, double&gt; &gt; actionCost;
-
-	WayPoint()
-	{
-		id = 0;
-		v = 0;
-		cost = 0;
-		laneId = -1;
-		pLane  = 0;
-		pLeft = 0;
-		pRight = 0;
-		bDir = FORWARD_DIR;
-		LeftLaneId = 0;
-		RightLaneId = 0;
-		timeCost = 0;
-		totalReward = 0;
-		collisionCost = 0;
-		laneChangeCost = 0;
-		stopLineID = -1;
-	}
-
-	WayPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
-	{
-		pos.x = x;
-		pos.y = y;
-		pos.z = z;
-		pos.a = a;
-
-		id = 0;
-		v = 0;
-		cost = 0;
-		laneId = -1;
-		pLane  = 0;
-		pLeft = 0;
-		pRight = 0;
-		bDir = FORWARD_DIR;
-		LeftLaneId = 0;
-		RightLaneId = 0;
-		timeCost = 0;
-		totalReward = 0;
-		collisionCost = 0;
-		laneChangeCost = 0;
-		stopLineID = -1;
-	}
-};
-
-class RelativeInfo
-{
-public:
-	double perp_distance;
-	double to_front_distance; //negative
-	double from_back_distance;
-	int iFront;
-	int iBack;
-	int iGlobalPath;
-	WayPoint perp_point;
-	double angle_diff; // degrees
-
-	RelativeInfo()
-	{
-		perp_distance = 0;
-		to_front_distance = 0;
-		from_back_distance = 0;
-		iFront = 0;
-		iBack = 0;
-		iGlobalPath = 0;
-		angle_diff = 0;
-	}
-};
-
-class StopLine
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-	int trafficLightID;
-	int stopSignID;
-	std::vector&lt;GPSPoint&gt; points;
-	Lane* pLane;
-
-	StopLine()
-	{
-		id    = 0;
-		laneId =0;
-		roadId =0;
-		pLane = 0;
-		trafficLightID = -1;
-		stopSignID = -1;
-	}
-};
-
-class WaitingLine
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-	std::vector&lt;GPSPoint&gt; points;
-	Lane* pLane;
-
-	WaitingLine()
-	{
-		id    = 0;
-		laneId =0;
-		roadId =0;
-		pLane = 0;
-	}
-};
-
-enum TrafficSignTypes {UNKNOWN_SIGN, STOP_SIGN, MAX_SPEED_SIGN, MIN_SPEED_SIGN};
-
-class TrafficSign
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-
-	GPSPoint pos;
-	TrafficSignTypes signType;
-	double value;
-	double fromValue;
-	double toValue;
-	std::string strValue;
-	timespec timeValue;
-	timespec fromTimeValue;
-	timespec toTimeValue;
-
-	Lane* pLane;
-
-	TrafficSign()
-	{
-		id    		= 0;
-		laneId 		= 0;
-		roadId		= 0;
-		signType  	= UNKNOWN_SIGN;
-		value		= 0;
-		fromValue	= 0;
-		toValue		= 0;
-//		timeValue	= 0;
-//		fromTimeValue = 0;
-//		toTimeValue	= 0;
-		pLane 		= 0;
-	}
-};
-
-enum TrafficLightState {UNKNOWN_LIGHT, RED_LIGHT, GREEN_LIGHT, YELLOW_LIGHT, LEFT_GREEN, FORWARD_GREEN, RIGHT_GREEN, FLASH_YELLOW, FLAH_RED};
-
-class TrafficLight
-{
-public:
-	int id;
-	GPSPoint pos;
-	TrafficLightState lightState;
-	double stoppingDistance;
-	std::vector&lt;int&gt; laneIds;
-	std::vector&lt;Lane*&gt; pLanes;
-
-	TrafficLight()
-	{
-		stoppingDistance = 2;
-		id 			= 0;
-		lightState	= GREEN_LIGHT;
-	}
-
-	bool CheckLane(const int&amp; laneId)
-	{
-		for(unsigned int i=0; i &lt; laneIds.size(); i++)
-		{
-			if(laneId == laneIds.at(i))
-				return true;
-		}
-		return false;
-	}
-};
-
-enum RoadSegmentType {NORMAL_ROAD, INTERSECTION_ROAD, UTURN_ROAD, EXIT_ROAD, MERGE_ROAD, HIGHWAY_ROAD};
-
-class RoadSegment
-{
-public:
-	int id;
-	RoadSegmentType roadType;
-	std::vector&lt;int&gt; fromIds;
-	std::vector&lt;int&gt; toIds;
-	std::vector&lt;Lane&gt; Lanes;
-
-
-	std::vector&lt;RoadSegment*&gt; fromLanes;
-	std::vector&lt;RoadSegment*&gt; toLanes;
-
-	RoadSegment()
-	{
-		id = 0;
-		roadType = NORMAL_ROAD;
-	}
-
-
-};
-
-enum LaneType{NORMAL_LANE, MERGE_LANE, EXIT_LANE, BUS_LANE, BUS_STOP_LANE, EMERGENCY_LANE};
-
-class Lane
-{
-public:
-	int id;
-	int roadId;
-	int areaId;
-	int fromAreaId;
-	int toAreaId;
-	std::vector&lt;int&gt; fromIds;
-	std::vector&lt;int&gt; toIds;
-	int num; //lane number in the road segment from left to right
-	double speed;
-	double length;
-	double dir;
-	LaneType type;
-	std::vector&lt;TrafficSign&gt; signs;
-	std::vector&lt;WayPoint&gt; points;
-	std::vector&lt;TrafficLight&gt; trafficlights;
-	std::vector&lt;StopLine&gt; stopLines;
-	WaitingLine waitingLine;
-
-	std::vector&lt;Lane*&gt; fromLanes;
-	std::vector&lt;Lane*&gt; toLanes;
-	Lane* pLeftLane;
-	Lane* pRightLane;
-
-	RoadSegment * pRoad;
-
-	Lane()
-	{
-		id 		= 0;
-		num		= 0;
-		speed 	= 0;
-		length 	= 0;
-		dir		= 0;
-		type 	= NORMAL_LANE;
-		pLeftLane = 0;
-		pRightLane = 0;
-		pRoad	= 0;
-		roadId = 0;
-		areaId = 0;
-		fromAreaId = 0;
-		toAreaId = 0;
-	}
-
-};
-
-class RoadNetwork
-{
-public:
-	std::vector&lt;RoadSegment&gt; roadSegments;
-	std::vector&lt;TrafficLight&gt; trafficLights;
-	std::vector&lt;StopLine&gt; stopLines;
-
-};
-
-class VehicleState : public ObjTimeStamp
-{
-public:
-	double speed;
-	double steer;
-	SHIFT_POS shift;
-
-	VehicleState()
-	{
-		speed = 0;
-		steer = 0;
-		shift = SHIFT_POS_NN;
-	}
-
-};
-
-class BehaviorState
-{
-public:
-	STATE_TYPE state;
-	double maxVelocity;
-	double minVelocity;
-	double stopDistance;
-	double followVelocity;
-	double followDistance;
-	LIGHT_INDICATOR indicator;
-	bool bNewPlan;
-
-
-	BehaviorState()
-	{
-		state = INITIAL_STATE;
-		maxVelocity = 0;
-		minVelocity = 0;
-		stopDistance = 0;
-		followVelocity = 0;
-		followDistance = 0;
-		indicator  = INDICATOR_NONE;
-		bNewPlan = false;
-
-	}
-
-};
-
-class DetectedObject
-{
-public:
-	int id;
-	OBSTACLE_TYPE t;
-	WayPoint center;
-	WayPoint predicted_center;
-	std::vector&lt;GPSPoint&gt; contour;
-	double w;
-	double l;
-	double h;
-	double distance_to_center;
-	DetectedObject()
-	{
-		id = 0;
-		w = 0;
-		l = 0;
-		h = 0;
-		t = GENERAL_OBSTACLE;
-		distance_to_center = 0;
-	}
-
-};
-
-class PlanningParams
-{
-public:
-	double 	maxSpeed;
-	double 	minSpeed;
-	double 	planningDistance;
-	double 	microPlanDistance;
-	double 	carTipMargin;
-	double 	rollInMargin;
-	double 	rollInSpeedFactor;
-	double 	pathDensity;
-	double 	rollOutDensity;
-	int 	rollOutNumber;
-	double 	horizonDistance;
-	double 	minFollowingDistance; //should be bigger than Distance to follow
-	double 	minDistanceToAvoid; // should be smaller than minFollowingDistance and larger than maxDistanceToAvoid
-	double	maxDistanceToAvoid; // should be smaller than minDistanceToAvoid
-	double 	speedProfileFactor;
-	double 	smoothingDataWeight;
-	double 	smoothingSmoothWeight;
-	double 	smoothingToleranceError;
-
-	double verticalSafetyDistance;
-	double horizontalSafetyDistancel;
-
-	bool 	enableLaneChange;
-	bool 	enableSwerving;
-	bool 	enableFollowing;
-	bool 	enableHeadingSmoothing;
-	bool 	enableTrafficLightBehavior;
-	bool 	enableStopSignBehavior;
-
-	bool 	enabTrajectoryVelocities;
-
-	PlanningParams()
-	{
-		maxSpeed 						= 3;
-		minSpeed 						= 0;
-		planningDistance 				= 10000;
-		microPlanDistance 				= 30;
-		carTipMargin					= 4.0;
-		rollInMargin					= 12.0;
-		rollInSpeedFactor				= 0.25;
-		pathDensity						= 0.25;
-		rollOutDensity					= 0.5;
-		rollOutNumber					= 4;
-		horizonDistance					= 120;
-		minFollowingDistance			= 35;
-		minDistanceToAvoid				= 15;
-		maxDistanceToAvoid				= 5;
-		speedProfileFactor				= 1.0;
-		smoothingDataWeight				= 0.45;
-		smoothingSmoothWeight			= 0.3;
-		smoothingToleranceError			= 0.05;
-
-		verticalSafetyDistance 			= 0.0;
-		horizontalSafetyDistancel		= 0.0;
-
-		enableHeadingSmoothing			= false;
-		enableSwerving 					= false;
-		enableFollowing					= false;
-		enableTrafficLightBehavior		= false;
-		enableLaneChange 				= false;
-		enableStopSignBehavior			= false;
-		enabTrajectoryVelocities		= false;
-	}
-};
-
-class HMIPreCalculatedConditions
-{
-public:
-
-	HMIPreCalculatedConditions()
-	{
-
-	}
-};
-
-class PreCalculatedConditions
-{
-public:
-	//-------------------------------------------//
-	//Global Goals
-	int 				currentGoalID;
-	int 				prevGoalID;
-	//-------------------------------------------//
-	//Following
-	double 				distanceToNext;
-	double				velocityOfNext;
-	//-------------------------------------------//
-	//For Lane Change
-	int 				iPrevSafeLane;
-	int 				iCurrSafeLane;
-	double				distanceToGoBack;
-	double 				timeToGoBack;
-	double 				distanceToChangeLane;
-	double				timeToChangeLane;
-	int 				currentLaneID;
-	int 				originalLaneID;
-	int 				targetLaneID;
-	bool 				bUpcomingLeft;
-	bool 				bUpcomingRight;
-	bool				bCanChangeLane;
-	bool				bTargetLaneSafe;
-	//-------------------------------------------//
-	//Traffic Lights &amp; Stop Sign
-	int 				currentStopSignID;
-	int 				prevStopSignID;
-	int 				currentTrafficLightID;
-	int 				prevTrafficLightID;
-	bool 				bTrafficIsRed; //On , off status
-	//-------------------------------------------//
-	//Swerving
-	int 				iPrevSafeTrajectory;
-	int 				iCurrSafeTrajectory;
-	int 				iCentralTrajectory;
-	bool				bFullyBlock;
-	LIGHT_INDICATOR 	indicator;
-
-	//-------------------------------------------//
-	//General
-	bool 				bNewGlobalPath;
-	bool 				bRePlan;
-	double 				currentVelocity;
-	double				minStoppingDistance; //comfortably
-	int 				bOutsideControl; // 0 waiting, 1 start, 2 Green Traffic Light, 3 Red Traffic Light, 5 Emergency Stop
-	bool				bGreenOutsideControl;
-	std::vector&lt;double&gt; stoppingDistances;
-
-
-	double distanceToStop()
-	{
-		if(stoppingDistances.size()==0) return 0;
-		double minS = stoppingDistances.at(0);
-		for(unsigned int i=0; i&lt; stoppingDistances.size(); i++)
-		{
-			if(stoppingDistances.at(i) &lt; minS)
-				minS = stoppingDistances.at(i);
-		}
-		return minS;
-	}
-
-	PreCalculatedConditions()
-	{
-		currentGoalID 			= 0;
-		prevGoalID				= -1;
-		currentVelocity 		= 0;
-		minStoppingDistance		= 1;
-		bOutsideControl			= 0;
-		bGreenOutsideControl	= false;
-		//distance to stop
-		distanceToNext			= -1;
-		velocityOfNext			= 0;
-		currentStopSignID		= -1;
-		prevStopSignID			= -1;
-		currentTrafficLightID	= -1;
-		prevTrafficLightID		= -1;
-		bTrafficIsRed			= false;
-		iCurrSafeTrajectory		= -1;
-		bFullyBlock				= false;
-
-		iPrevSafeTrajectory		= -1;
-		iCentralTrajectory		= -1;
-		bRePlan					= false;
-		bNewGlobalPath			= false;
-
-		bCanChangeLane			= false;
-		distanceToGoBack		= 0;
-		timeToGoBack			= 0;
-		distanceToChangeLane	= 0;
-		timeToChangeLane		= 0;
-		bTargetLaneSafe			= true;
-		bUpcomingLeft			= false;
-		bUpcomingRight			= false;
-		targetLaneID			= -1;
-		currentLaneID			= -1;
-		originalLaneID			= -1;
-		iCurrSafeLane 			= -1;
-		iPrevSafeLane			= -1;
-
-		indicator 				= INDICATOR_NONE;
-	}
-
-	virtual ~PreCalculatedConditions(){}
-
-	std::string ToStringHeader()
-	{
-		return "Time:General&gt;&gt;:currentVelocity:distanceToStop:minStoppingDistance:bStartBehaviorGenerator:bGoalReached:"
-				"Following&gt;&gt;:velocityOfNext:distanceToNext:"
-				"TrafficLight&gt;&gt;:currentTrafficLightID:bTrafficIsRed:"
-				"Swerving&gt;&gt;:iSafeTrajectory:bFullyBlock:";
-	}
-
-	std::string ToString(STATE_TYPE beh)
-	{
-		std::string str = "Unknown";
-		switch(beh)
-		{
-		case PlannerHNS::INITIAL_STATE:
-			str = "Init";
-			break;
-		case PlannerHNS::WAITING_STATE:
-			str = "Waiting";
-			break;
-		case PlannerHNS::FORWARD_STATE:
-			str = "Forward";
-			break;
-		case PlannerHNS::STOPPING_STATE:
-			str = "Stop";
-			break;
-		case PlannerHNS::FINISH_STATE:
-			str = "End";
-			break;
-		case PlannerHNS::FOLLOW_STATE:
-			str = "Follow";
-			break;
-		case PlannerHNS::OBSTACLE_AVOIDANCE_STATE:
-			str = "Swerving";
-			break;
-		case PlannerHNS::TRAFFIC_LIGHT_STOP_STATE:
-			str = "Light Stop";
-			break;
-		case PlannerHNS::TRAFFIC_LIGHT_WAIT_STATE:
-			str = "Light Wait";
-			break;
-		case PlannerHNS::STOP_SIGN_STOP_STATE:
-			str = "Sign Stop";
-			break;
-		case PlannerHNS::STOP_SIGN_WAIT_STATE:
-			str = "Sign Wait";
-			break;
-		default:
-			str = "Unknown";
-			break;
-		}
-
-		return str;
-	}
-};
-
-class TrajectoryCost
-{
-public:
-	int index;
-	int relative_index;
-	double closest_obj_velocity;
-	double distance_from_center;
-	double priority_cost; //0 to 1
-	double transition_cost; // 0 to 1
-	double closest_obj_cost; // 0 to 1
-	double cost;
-	double closest_obj_distance;
-
-	int lane_index;
-	double lane_change_cost;
-	double lateral_cost;
-	double longitudinal_cost;
-	bool bBlocked;
-	std::vector&lt;std::pair&lt;int, double&gt; &gt; lateral_costs;
-
-
-	TrajectoryCost()
-	{
-		lane_index = -1;
-		index = -1;
-		relative_index = -100;
-		closest_obj_velocity = 0;
-		priority_cost = 0;
-		transition_cost = 0;
-		closest_obj_cost = 0;
-		distance_from_center = 0;
-		cost = 0;
-		closest_obj_distance = -1;
-		lane_change_cost = 0;
-		lateral_cost = 0;
-		longitudinal_cost = 0;
-		bBlocked = false;
-	}
-
-	std::string ToString()
-	{
-		std::ostringstream str;
-		str.precision(4);
-		str &lt;&lt; "LaneIndex    : " &lt;&lt; lane_index;
-		str &lt;&lt; ", Index      : " &lt;&lt; relative_index;
-		str &lt;&lt; ", TotalCost  : " &lt;&lt; cost;
-		str &lt;&lt; ", Priority   : " &lt;&lt; priority_cost;
-		str &lt;&lt; ", Transition : " &lt;&lt; transition_cost;
-		str &lt;&lt; ", Lateral    : " &lt;&lt; lateral_cost;
-		str &lt;&lt; ", Longitu    : " &lt;&lt; longitudinal_cost;
-		str &lt;&lt; ", LaneChange : " &lt;&lt; lane_change_cost;
-		str &lt;&lt; ", Blocked    : " &lt;&lt; bBlocked;
-		str &lt;&lt; "\n";
-		for (unsigned int i=0; i&lt;lateral_costs.size(); i++ )
-		{
-			str &lt;&lt; " - (" &lt;&lt; lateral_costs.at(i).first &lt;&lt; ", " &lt;&lt; lateral_costs.at(i).second &lt;&lt; ")";
-		}
-
-		return str.str();
-
-	}
-};
-
-}
-
-
-#endif /* ROADNETWORK_H_ */
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\SimpleTracker.h" new_path="" added_lines="0" deleted_lines="272">
				<diff>@@ -1,272 +0,0 @@
-/*
- * SimpleTracker.h
- *
- *  Created on: Aug 11, 2016
- *      Author: hatem
- */
-
-#ifndef SimpleTracker_H_
-#define SimpleTracker_H_
-
-#include "RoadNetwork.h"
-#include "opencv2/video/tracking.hpp"
-#include &lt;vector&gt;
-#include "UtilityH.h"
-#include "math.h"
-#include &lt;iostream&gt;
-
-namespace SimulationNS
-{
-
-#define DEBUG_TRACKER 0
-#define NEVER_GORGET_TIME -1000
-#define MIN_EVIDENCE_NUMBER 3
-
-struct Kalman1dState
-{
-    double MovCov; //double q; //moving noise covariance
-    double MeasureCov; //double r; //measurement noise covariance
-    double x; //value
-    double p; //estimation error covariance
-    double k; //kalman gain
-};
-
-class  kalmanFilter1D
-{
-public:
-
-	Kalman1dState result;
-
-    kalmanFilter1D()
-	{
-
-	}
-    kalmanFilter1D(double MovCov, double MeasureCov, double p, double intial_value)
-    {
-        result.MovCov = MovCov;
-        result.MeasureCov = MeasureCov;
-        result.p = p;
-        result.x = intial_value;
-    }
-
-    Kalman1dState Update(double measurement)
-    {
-    	//prediction update
-		//omit x = x
-		result.p = result.p + result.MovCov;
-
-		//measurement update
-		result.k = result.p / (result.p + result.MeasureCov);
-		result.x = result.x + result.k * (measurement - result.x);
-		result.p = (1 - result.k) * result.p;
-
-		return result;
-    }
-};
-
-class KFTrackV
-{
-private:
-	cv::KalmanFilter m_filter;
-	double prev_x, prev_y, prev_v, prev_a;
-	long m_id;
-	double dt;
-	int nStates;
-	int nMeasure;
-	double circ_angle;
-
-public:
-	int region_id;
-	double forget_time;
-	int m_iLife;
-	PlannerHNS::DetectedObject obj;
-	kalmanFilter1D errorSmoother;
-
-	long GetTrackID()
-	{
-		return m_id;
-	}
-
-	KFTrackV(double x, double y, double a, long id, double _dt)
-	{
-		circ_angle = 0;
-		errorSmoother.result.MovCov = 0.125;
-		errorSmoother.result.MeasureCov = 0.1;
-		errorSmoother.result.p = 1;
-		errorSmoother.result.x = 0;
-		region_id = -1;
-		forget_time = NEVER_GORGET_TIME; // this is very bad , dangerous
-		m_iLife = 0;
-		dt = _dt;
-		prev_x = x;
-		prev_y = y;
-		prev_v = 0;
-		prev_a = a;
-		nStates = 4;
-		nMeasure = 2;
-
-		m_id = id;
-
-		m_filter = cv::KalmanFilter(nStates,nMeasure);
-		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
-																	   	   0	,1	,0	,dt	,
-																	   	   0	,0	,1	,0	,
-																	   	   0	,0	,0	,1	);
-		m_filter.statePre.at&lt;float&gt;(0) = x;
-		m_filter.statePre.at&lt;float&gt;(1) = y;
-		m_filter.statePre.at&lt;float&gt;(2) = 0;
-		m_filter.statePre.at&lt;float&gt;(3) = 0;
-
-		m_filter.statePost = m_filter.statePre;
-
-		setIdentity(m_filter.measurementMatrix);
-
-		cv::setIdentity(m_filter.measurementNoiseCov, cv::Scalar::all(0.0001));
-		cv::setIdentity(m_filter.processNoiseCov, cv::Scalar::all(0.0001));
-		cv::setIdentity(m_filter.errorCovPost, cv::Scalar::all(0.075));
-
-		m_filter.predict();
-
-		errorSmoother.Update(a);
-	}
-
-	void UpdateTracking(double _dt, const double&amp; x, const double&amp; y, const double&amp; a, double&amp; x_new, double &amp; y_new , double&amp; a_new, double&amp; v)
-	{
-		dt = _dt;
-		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
-																			   	   0	,1	,0	,dt	,
-																			   	   0	,0	,1	,0	,
-																			   	   0	,0	,0	,1	);
-		double a_old = a;
-
-		cv::Mat_&lt;float&gt; measurement(nMeasure,1);
-		cv::Mat_&lt;float&gt; prediction(nStates,1);
-
-		measurement(0) = x;
-		measurement(1) = y;
-
-		prediction = m_filter.correct(measurement);
-
-		x_new = prediction.at&lt;float&gt;(0);
-		y_new = prediction.at&lt;float&gt;(1);
-		double vx  = prediction.at&lt;float&gt;(2);
-		double vy  = prediction.at&lt;float&gt;(3);
-
-		if(m_iLife &gt; 2)
-		{
-			v = sqrt(vx*vx+vy*vy);
-			double diff_y = y_new - prev_y;
-			double diff_x = x_new - prev_x;
-			if(hypot(diff_y, diff_x) &gt; 0.5)
-			{
-				prev_y = y;
-				prev_x = x;
-				a_new = atan2(diff_y, diff_x);
-			}
-			else
-				a_new = a;
-
-		}
-		else
-		{
-			v = 0;
-			a_new = a;
-		}
-
-		circ_angle = UtilityHNS::UtilityH::GetCircularAngle(circ_angle, UtilityHNS::UtilityH::FixNegativeAngle(a_old), UtilityHNS::UtilityH::FixNegativeAngle(a_new));
-
-		circ_angle =  errorSmoother.Update(circ_angle).x;
-
-		a_new = UtilityHNS::UtilityH::SplitPositiveAngle(circ_angle);
-
-		if(v &lt; 0.1)
-			v = 0;
-
-		//std::cout &lt;&lt; "Track: Old (" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; "), New (" &lt;&lt; x_new &lt;&lt; ", " &lt;&lt; y_new &lt;&lt; ")" &lt;&lt; std::endl;
-		//std::cout &lt;&lt; "Track: " &lt;&lt; m_id &lt;&lt; ", A: " &lt;&lt; a &lt;&lt; ", A_new:(" &lt;&lt; circ_angle &lt;&lt; "," &lt;&lt;  a_new &lt;&lt; ") , V" &lt;&lt; v &lt;&lt; ", dt: " &lt;&lt; dt &lt;&lt; ", forget_time: " &lt;&lt; forget_time &lt;&lt; std::endl;
-
-		m_filter.predict();
-		m_filter.statePre.copyTo(m_filter.statePost);
-		m_filter.errorCovPre.copyTo(m_filter.errorCovPost);
-
-		forget_time -= dt;
-		m_iLife++;
-	}
-	virtual ~KFTrackV(){}
-};
-
-class InterestCircle
-{
-public:
-	int id;
-	double radius;
-	double forget_time;
-	std::vector&lt;KFTrackV*&gt; pTrackers;
-	InterestCircle* pPrevCircle;
-	InterestCircle* pNextCircle;
-
-	InterestCircle(int _id)
-	{
-		id = _id;
-		radius = 0;
-		forget_time = NEVER_GORGET_TIME; // never forget
-		pPrevCircle = 0;
-		pNextCircle = 0;
-	}
-};
-
-class CostRecordSet
-{
-public:
-	int currobj;
-	int prevObj;
-	double cost;
-	CostRecordSet(int curr_id, int prev_id, double _cost)
-	{
-		currobj = curr_id;
-		prevObj = prev_id;
-		cost = _cost;
-	}
-};
-
-class SimpleTracker
-{
-public:
-	std::vector&lt;InterestCircle*&gt; m_InterestRegions;
-	std::vector&lt;KFTrackV*&gt; m_Tracks;
-	timespec m_TrackTimer;
-	long iTracksNumber;
-	PlannerHNS::WayPoint m_PrevState;
-	std::vector&lt;PlannerHNS::DetectedObject&gt; m_PrevDetectedObjects;
-	std::vector&lt;PlannerHNS::DetectedObject&gt; m_DetectedObjects;
-
-	void CreateTrack(PlannerHNS::DetectedObject&amp; o);
-	void CreateTrackV2(PlannerHNS::DetectedObject&amp; o);
-	KFTrackV* FindTrack(long index);
-	void Track(std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; objects_list);
-	void TrackV2();
-	void CoordinateTransform(const PlannerHNS::WayPoint&amp; refCoordinate, PlannerHNS::DetectedObject&amp; obj);
-	void CoordinateTransformPoint(const PlannerHNS::WayPoint&amp; refCoordinate, PlannerHNS::GPSPoint&amp; obj);
-	void AssociateObjects();
-	void InitializeInterestRegions(double horizon, double init_raduis, double init_time, std::vector&lt;InterestCircle*&gt;&amp; regions);
-	void AssociateAndTrack();
-	void AssociateToRegions(KFTrackV&amp; detectedObject);
-	void CleanOldTracks();
-
-	void DoOneStep(const PlannerHNS::WayPoint&amp; currPose, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-
-	SimpleTracker(double horizon = 100);
-	virtual ~SimpleTracker();
-
-public:
-	double m_DT;
-	double m_MAX_ASSOCIATION_DISTANCE;
-	int m_MAX_TRACKS_AFTER_LOSING;
-	bool m_bUseCenterOnly;
-	double m_MaxKeepTime;
-	bool m_bFirstCall;
-};
-
-} /* namespace BehaviorsNS */
-
-#endif /* SimpleTracker_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\TrajectoryCosts.h" new_path="" added_lines="0" deleted_lines="50">
				<diff>@@ -1,50 +0,0 @@
-/*
- * TrajectoryCosts.h
- *
- *  Created on: Dec 14, 2016
- *      Author: user
- */
-
-#ifndef TRAJECTORYCOSTS_H_
-#define TRAJECTORYCOSTS_H_
-
-#include "RoadNetwork.h"
-#include "PlannerCommonDef.h"
-#include "PlanningHelpers.h"
-
-using namespace std;
-
-namespace PlannerHNS
-{
-
-class TrajectoryCosts
-{
-public:
-	TrajectoryCosts();
-	virtual ~TrajectoryCosts();
-
-	TrajectoryCost DoOneStep(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths,
-			const WayPoint&amp; currState, const int&amp; currTrajectoryIndex, const int&amp; currLaneIndex, const PlanningParams&amp; params,
-			const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-
-public:
-	int m_PrevCostIndex;
-	vector&lt;TrajectoryCost&gt; m_TrajectoryCosts;
-	PlanningParams m_Params;
-	PolygonShape m_SafetyBorder;
-	//vector&lt;GPSPoint&gt; m_SafetyBox;
-
-
-
-private:
-	bool ValidateRollOutsInput(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts);
-	vector&lt;TrajectoryCost&gt; CalculatePriorityAndLaneChangeCosts(const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; laneRollOuts, const int&amp; lane_index, const PlanningParams&amp; params);
-	void NormalizeCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts);
-	void CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths, const WayPoint&amp; currState, const vector&lt;WayPoint&gt;&amp; contourPoints, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState);
-	void CalculateTransitionCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const int&amp; currTrajectoryIndex, const PlanningParams&amp; params);
-
-};
-
-}
-
-#endif /* TRAJECTORYCOSTS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\TrajectoryFollower.h" new_path="" added_lines="0" deleted_lines="111">
				<diff>@@ -1,111 +0,0 @@
-/*
- * TrajectoryFollower.h
- *
- *  Created on: Jun 18, 2016
- *      Author: hatem
- */
-
-#ifndef TRAJECTORYFOLLOWER_H_
-#define TRAJECTORYFOLLOWER_H_
-#include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "PlannerCommonDef.h"
-
-
-#define MAX_ACCELERATION_2G 20 // meter /sec/sec
-namespace SimulationNS
-{
-
-class TrajectoryFollower
-{
-public:
-	TrajectoryFollower();
-	virtual ~TrajectoryFollower();
-
-	void PrepareNextWaypoint(const PlannerHNS::WayPoint&amp; CurPos, const double&amp; currVelocity, const double&amp; currSteering);
-
-	void UpdateCurrentPath(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path);
-
-	int SteerControllerUpdate(const PlannerHNS::VehicleState&amp; CurrStatus,
-			const PlannerHNS::BehaviorState&amp; CurrBehavior, double&amp; desiredSteerAngle);
-	int VeclocityControllerUpdate(const double&amp; dt, const PlannerHNS::VehicleState&amp; CurrStatus,
-			const PlannerHNS::BehaviorState&amp; CurrBehavior, double&amp; desiredVelocity, PlannerHNS::SHIFT_POS&amp; desiredShift);
-
-	void Init(const PlannerHNS::ControllerParams&amp; params, const PlannerHNS::CAR_BASIC_INFO&amp; vehicleInfo, bool bEnableLogs = false, bool bCalibration = false);
-
-	PlannerHNS::VehicleState DoOneStep(const double&amp; dt, const PlannerHNS::BehaviorState&amp; behavior,
-				const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::WayPoint&amp; currPose,
-				const PlannerHNS::VehicleState&amp; vehicleState, const bool&amp; bNewTrajectory);
-
-	//Testing Points
-	PlannerHNS::WayPoint 	m_ForwardSimulation;
-	PlannerHNS::WayPoint 	m_PerpendicularPoint;
-	PlannerHNS::WayPoint 	m_FollowMePoint;
-	double 					m_LateralError;
-	double 					m_FollowingDistance;
-	PlannerHNS::WayPoint 	m_CurrPos;
-	int 					m_iCalculatedIndex;
-	bool					m_bEndPath;
-	double 					m_WayPointsDensity;
-
-
-private:
-	double 						m_StartFollowDistance;
-	double 						m_FollowAcc;
-	PlannerHNS::ControllerParams 			m_Params;
-	PlannerHNS::CAR_BASIC_INFO 				m_VehicleInfo;
-	std::vector&lt;PlannerHNS::WayPoint&gt; 	m_Path;
-	PlannerHNS::WayPoint 		m_DesPos;
-	double						m_PrevDesiredSteer; // control output
-	double 						m_FollowAcceleration;
-	int 						m_iPrevWayPoint;
-	UtilityHNS::PIDController 	m_pidSteer;
-	UtilityHNS::LowpassFilter 	m_lowpassSteer;
-
-	UtilityHNS::PIDController 	m_pidVelocity;
-	UtilityHNS::LowpassFilter 	m_lowpassVelocity;
-
-	bool						m_bEnableLog;
-	std::vector&lt;std::string&gt;    m_LogData;
-	std::vector&lt;std::string&gt;    m_LogSteerPIDData;
-	std::vector&lt;std::string&gt;    m_LogVelocityPIDData;
-
-	//Steering and Velocity Calibration Global Variables
-	bool						m_bCalibrationMode;
-	int							m_iNextTest;
-	std::vector&lt;std::string&gt;    m_SteerCalibrationData;
-	std::vector&lt;std::string&gt;    m_VelocityCalibrationData;
-	PlannerHNS::VehicleState 	m_prevCurrState_steer;
-	PlannerHNS::VehicleState 	m_prevDesiredState_steer;
-	PlannerHNS::VehicleState 	m_prevCurrState_vel;
-	PlannerHNS::VehicleState 	m_prevDesiredState_vel;
-	struct timespec 			m_SteerDelayTimer;
-	struct timespec 			m_VelocityDelayTimer;
-	std::vector&lt;std::pair&lt;double, double&gt; &gt; m_CalibrationRunList;
-
-
-	bool FindNextWayPoint(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::WayPoint&amp; state,
-			const double&amp; velocity, PlannerHNS::WayPoint&amp; pursuite_point, PlannerHNS::WayPoint&amp; prep,
-			double&amp; lateral_err, double&amp; follow_distance);
-
-	int SteerControllerPart(const PlannerHNS::WayPoint&amp; state, const PlannerHNS::WayPoint&amp; way_point,
-			const double&amp; lateral_error, double&amp; steerd);
-
-	void PredictMotion(double&amp; x, double &amp;y, double&amp; heading, double steering, double velocity,
-			double wheelbase, double time_elapsed);
-
-	double GetPID_LinearChange(double minVal, double maxVal, double speedMax, double currSpeed);
-
-	void AdjustPID(const double&amp; v, const double&amp; maxV,  PlannerHNS::PID_CONST&amp; steerPID);
-
-	int CalculateVelocityDesired(const double&amp; dt, const double&amp; currVel,const PlannerHNS::STATE_TYPE&amp; CurrBehavior,
-			double&amp; desiredVel);
-
-	void LogCalibrationData(const PlannerHNS::VehicleState&amp; currState,const PlannerHNS::VehicleState&amp; desiredState);
-	void InitCalibration();
-	void CalibrationStep(const double&amp; dt, const PlannerHNS::VehicleState&amp; CurrStatus, double&amp; desiredSteer, double&amp; desiredVelocity);
-};
-
-} /* namespace SimulationNS */
-
-#endif /* TRAJECTORYFOLLOWER_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\UtilityH.h" new_path="" added_lines="0" deleted_lines="115">
				<diff>@@ -1,115 +0,0 @@
-/*
- * UtilityH.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#ifndef UTILITYH_H_
-#define UTILITYH_H_
-
-#include &lt;assert.h&gt;
-#include &lt;math.h&gt;
-#include &lt;string&gt;
-
-
-namespace UtilityHNS
-{
-
-#define DEG2RAD M_PI / 180.
-#define RAD2DEG 180. / M_PI
-#define sign(x) (x &gt; 0) ? 1 : ((x &lt; 0) ? -1 : 0)
-#define MIN(x,y) (x &lt;= y ? x : y)
-#define MAX(x,y) (x &gt;= y ? x : y)
-
-
-class UtilityH
-{
-public:
-	UtilityH();
-	virtual ~UtilityH(); 
-
-
-	static double FixNegativeAngle(const double&amp; a);
-	static double SplitPositiveAngle(const double&amp; a);
-	static double InverseAngle(const double&amp; a);
-	static double AngleBetweenTwoAnglesPositive(const double&amp; a1, const double&amp; a2);
-	static double GetCircularAngle(const double&amp; prevContAngle, const double&amp; prevAngle, const double&amp; currAngle);
-
-	//Time Functions
-	static void GetTickCount(struct timespec&amp; t);
-	static std::string GetFilePrefixHourMinuteSeconds();
-	static double GetTimeDiffNow(const struct timespec&amp; old_t);
-	static double GetTimeDiff(const struct timespec&amp; old_t,const struct timespec&amp; curr_t);
-	static std::string GetDateTimeStr();
-	static int tsCompare (struct  timespec  time1,   struct  timespec  time2, int micro_tolerance = 10);
-	static int GetSign(double x);
-	static std::string GetHomeDirectory();
-	static double GetMomentumScaleFactor(const double&amp; v);
-	static timespec GetTimeSpec(const time_t&amp; srcT);
-	static time_t GetLongTime(const struct timespec&amp; srcT);
-};
-
-class PIDController
-{
-public:
-	PIDController();
-	PIDController(const double&amp; kp, const double&amp; ki, const double&amp; kd);
-	void Init(const double&amp; kp, const double&amp; ki, const double&amp; kd);
-	void Setlimit(const double&amp; upper,const double&amp; lower);
-	double getPID(const double&amp; currValue, const double&amp; targetValue);
-	double getPID(const double&amp; e);
-	void ResetD();
-	void ResetI();
-	std::string ToString();
-	std::string ToStringHeader();
-
-
-private:
-	double kp;
-	double ki;
-	double kd;
-	double kp_v;
-	double ki_v;
-	double kd_v;
-	double pid_v;
-	double pid_lim;
-	double upper_limit;
-	double lower_limit;
-	bool   bEnableLimit;
-	double accumErr;
-	double prevErr;
-	bool bResetD;
-	bool bResetI;
-
-};
-
-class LowpassFilter
-{
-public:
-	LowpassFilter();
-	virtual ~LowpassFilter();
-
-	LowpassFilter(const int&amp; filterOrder, const double&amp; sampleFreq, const double&amp; cutOffFreq);
-	void Init(const int&amp; filterOrder, const double&amp; sampleFreq, const double&amp; cutOffFreq);
-	double getFilter(const double&amp; value);
-
-
-private:
-	int m;
-	double sampleF;
-	double cutOffF;
-	double A  ;
-	double d1 ;
-	double d2 ;
-	double w0 ;
-	double w1 ;
-	double w2 ;
-
-};
-
-}
-
-#endif
-
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\BehaviorStateMachine.h" new_path="" added_lines="0" deleted_lines="176">
				<diff>@@ -1,176 +0,0 @@
-/*
- * BehaviorStateMachine.h
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
-
-#ifndef BEHAVIORSTATEMACHINE_H_
-#define BEHAVIORSTATEMACHINE_H_
-
-#include "RoadNetwork.h"
-#include &lt;sstream&gt;
-
-namespace PlannerHNS
-{
-class BehaviorStateMachine
-{
-public:
-	virtual BehaviorStateMachine* GetNextState() = 0;
-	virtual void Init();
-	virtual void ResetTimer();
-	virtual void InsertNextState(BehaviorStateMachine* nextState);
-	BehaviorStateMachine(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* nextState);
-	virtual ~BehaviorStateMachine() ;
-
-	STATE_TYPE m_Behavior;
-	int m_currentStopSignID	;
-	int m_currentTrafficLightID ;
-	double decisionMakingTime;
-	double m_zero_velocity;
-
-	PreCalculatedConditions* GetCalcParams()
-	{
-		if(!m_pCalculatedValues)
-				m_pCalculatedValues = new PreCalculatedConditions();
-
-		return m_pCalculatedValues;
-	}
-
-	void SetBehaviorsParams(PlanningParams* pParams)
-	{
-		if(!pParams)
-			m_pParams = new PlanningParams;
-		else
-			m_pParams = pParams;
-	}
-
-
-	PreCalculatedConditions* m_pCalculatedValues;
-	PlanningParams* m_pParams;
-	timespec m_StateTimer;
-	std::vector&lt;BehaviorStateMachine*&gt; pNextStates;
-
-	BehaviorStateMachine* FindBehaviorState(const STATE_TYPE&amp; behavior);
-};
-
-class ForwardState : public BehaviorStateMachine
-{
-public:
-	ForwardState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FORWARD_STATE;}
-	virtual ~ForwardState(){}
-	virtual BehaviorStateMachine* GetNextState();
-};
-
-class MissionAccomplishedState : public BehaviorStateMachine
-{
-public:
-	MissionAccomplishedState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FINISH_STATE;}
-	virtual ~MissionAccomplishedState(){}
-	virtual BehaviorStateMachine* GetNextState();
-};
-
-class FollowState : public BehaviorStateMachine
-{
-public:
-	FollowState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = FOLLOW_STATE;}
-	virtual ~FollowState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class SwerveState : public BehaviorStateMachine
-{
-public:
-	SwerveState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = OBSTACLE_AVOIDANCE_STATE;}
-	virtual ~SwerveState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopState : public BehaviorStateMachine
-{
-public:
-	StopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOPPING_STATE;}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class TrafficLightStopState : public BehaviorStateMachine
-{
-public:
-	TrafficLightStopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = TRAFFIC_LIGHT_STOP_STATE;}
-	virtual ~TrafficLightStopState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class TrafficLightWaitState : public BehaviorStateMachine
-{
-public:
-	TrafficLightWaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = TRAFFIC_LIGHT_WAIT_STATE;}
-	virtual ~TrafficLightWaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopSignStopState : public BehaviorStateMachine
-{
-public:
-	StopSignStopState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOP_SIGN_STOP_STATE;}
-	virtual ~StopSignStopState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class StopSignWaitState : public BehaviorStateMachine
-{
-public:
-	StopSignWaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = STOP_SIGN_WAIT_STATE;}
-	virtual ~StopSignWaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class WaitState : public BehaviorStateMachine
-{
-public:
-	WaitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = WAITING_STATE;}
-	virtual ~WaitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class InitState : public BehaviorStateMachine
-{
-public:
-	InitState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = INITIAL_STATE;}
-	virtual ~InitState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-class GoalState : public BehaviorStateMachine
-{
-public:
-	GoalState(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* pNextState)
-	: BehaviorStateMachine(pParams, pPreCalcVal, pNextState){m_Behavior = GOAL_STATE;}
-	virtual ~GoalState(){}
-	virtual BehaviorStateMachine* GetNextState();
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* BEHAVIORSTATEMACHINE_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\DataRW.h" new_path="" added_lines="0" deleted_lines="438">
				<diff>@@ -1,438 +0,0 @@
-/*
- * DataRW.h
- *
- *  Created on: Jun 23, 2016
- *      Author: hatem
- */
-
-#ifndef DATARW_H_
-#define DATARW_H_
-
-#include &lt;string&gt;
-#include &lt;fstream&gt;
-#include &lt;sstream&gt;
-#include &lt;vector&gt;
-#include &lt;iostream&gt;
-
-namespace UtilityHNS {
-
-class DataRW
-{
-public:
-	DataRW();
-	virtual ~DataRW();
-
-	static std::string LoggingMainfolderName;
-	static std::string ControlLogFolderName;
-	static std::string PathLogFolderName;
-	static std::string StatesLogFolderName;
-	static std::string SimulationFolderName;
-	static std::string KmlMapsFolderName;
-
-
-	static void WriteKMLFile(const std::string&amp; fileName, const std::vector&lt;std::string&gt;&amp; gps_list);
-	static void WriteKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;std::string&gt; &gt;&amp; gps_list);
-	static void WriteLogData(const std::string&amp; logFolder, const std::string&amp; logTitle, const std::string&amp; header, const std::vector&lt;std::string&gt;&amp; logData);
-};
-
-class SimpleReaderBase
-{
-private:
-	std::ifstream* m_pFile;
-	std::vector&lt;std::string&gt; m_RawHeaders;
-	std::vector&lt;std::string&gt; m_DataTitlesHeader;
-	std::vector&lt;std::vector&lt;std::vector&lt;std::string&gt; &gt; &gt; m_AllData;
-	int m_nHeders;
-	int m_iDataTitles;
-	int m_nVarPerObj;
-	int m_nLineHeaders;
-	std::string m_HeaderRepeatKey;
-	char m_Separator;
-
-	void ReadHeaders();
-	void ParseDataTitles(const std::string&amp; header);
-
-public:
-	/**
-	 *
-	 * @param fileName log file name
-	 * @param nHeaders number of data headers
-	 * @param iDataTitles which row contains the data titles
-	 * @param nVariablesForOneObject 0 means each row represents one object
-	 */
-	SimpleReaderBase(const std::string&amp; fileName, const int&amp; nHeaders = 2, const char&amp; separator = ',',
-			const int&amp; iDataTitles = 1, const int&amp; nVariablesForOneObject = 0,
-			const int&amp; nLineHeaders = 0, const std::string&amp; headerRepeatKey = "...");
-	~SimpleReaderBase();
-
-protected:
-	bool ReadAllData();
-	bool ReadSingleLine(std::vector&lt;std::vector&lt;std::string&gt; &gt;&amp; line);
-
-};
-
-//class GPSLocalizerReader : public SimpleReaderBase
-//{
-//	public:
-//		GPSLocalizerReader(const std::string&amp; fileName) : SimpleReaderBase(fileName){}
-//		~GPSLocalizerReader(){}
-//
-//		bool ReadNextLine( MsgEstPose&amp; pos, double&amp; logTime);
-//		void ReadAllData(vector&lt;pair&lt;double,  MsgEstPose&gt; &gt;&amp; pos_list);
-//};
-//
-class GPSDataReader : public SimpleReaderBase
-{
-public:
-	struct GPSBasicData
-	{
-		double lat;
-		double lon;
-		double alt;
-		double dir;
-		double distance;
-
-	};
-
-	public:
-	GPSDataReader(const std::string&amp; fileName) : SimpleReaderBase(fileName){}
-	~GPSDataReader(){}
-
-	bool ReadNextLine(GPSBasicData&amp; data);
-	void ReadAllData(std::vector&lt;GPSBasicData&gt;&amp; data_list);
-};
-
-//
-//class VehicleStateReader : public SimpleReaderBase
-//{
-//	public:
-//	VehicleStateReader(const string&amp; fileName) : SimpleReaderBase(fileName){}
-//	~VehicleStateReader(){}
-//
-//	bool ReadNextLine( MsgVehicleStatus&amp; state, double&amp; logTime);
-//	void ReadAllData(vector&lt;pair&lt;double,  MsgVehicleStatus&gt; &gt;&amp; state_list);
-//};
-//
-//class MovingObjectsReader : public SimpleReaderBase
-//{
-//	public:
-//	MovingObjectsReader(const string&amp; fileName) : SimpleReaderBase(fileName, 2, 1, 28, 4){}
-//	~MovingObjectsReader(){}
-//
-//	bool ReadNextLine( MsgMovingObject&amp; state, double&amp; logTime);
-//	void ReadAllData(vector&lt;pair&lt;double,  MsgMovingObject&gt; &gt;&amp; state_list);
-//};
-
-class SimulationFileReader : public SimpleReaderBase
-{
-public:
-	struct SimulationPoint
-	{
-		double x;
-		double y;
-		double z;
-		double a;
-		double c;
-		double v;
-	};
-
-	struct SimulationData
-	{
-		SimulationPoint startPoint;
-		SimulationPoint goalPoint;
-		std::vector&lt;SimulationPoint&gt; simuCars;
-	};
-
-	SimulationFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~SimulationFileReader(){}
-
-	bool ReadNextLine(SimulationPoint&amp; data);
-	void ReadAllData(SimulationData&amp; data_list);
-};
-
-class LocalizationPathReader : public SimpleReaderBase
-{
-public:
-	struct LocalizationWayPoint
-	{
-		double t;
-		double x;
-		double y;
-		double z;
-		double a;
-		double v;
-	};
-
-	LocalizationPathReader(const std::string&amp; fileName, const char&amp; separator) : SimpleReaderBase(fileName, 1, separator){}
-	~LocalizationPathReader(){}
-
-	bool ReadNextLine(LocalizationWayPoint&amp; data);
-	void ReadAllData(std::vector&lt;LocalizationWayPoint&gt;&amp; data_list);
-};
-
-class AisanPointsFileReader : public SimpleReaderBase
-{
-public:
-	struct AisanPoints
-	{
-		int PID;
-		double B;
-		double L;
-		double H;
-		double Bx;
-		double Ly;
-		int Ref;
-		int MCODE1;
-		int MCODE2;
-		int MCODE3;
-	};
-
-	AisanPointsFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanPointsFileReader(){}
-
-	bool ReadNextLine(AisanPoints&amp; data);
-	void ReadAllData(std::vector&lt;AisanPoints&gt;&amp; data_list);
-};
-
-class AisanNodesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanNode
-	{
-		int NID;
-		int PID;
-	};
-
-	AisanNodesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanNodesFileReader(){}
-
-	bool ReadNextLine(AisanNode&amp; data);
-	void ReadAllData(std::vector&lt;AisanNode&gt;&amp; data_list);
-};
-
-class AisanLinesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanLine
-	{
-		int LID;
-		int BPID;
-		int FPID;
-		int BLID;
-		int FLID;
-	};
-
-	AisanLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanLinesFileReader(){}
-
-	bool ReadNextLine(AisanLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanLine&gt;&amp; data_list);
-};
-
-class AisanCenterLinesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanCenterLine
-	{
-		int 	DID;
-		int 	Dist;
-		int 	PID;
-		double 	Dir;
-		double 	Apara;
-		double 	r;
-		double 	slope;
-		double 	cant;
-		double 	LW;
-		double 	RW;
-	};
-
-	AisanCenterLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanCenterLinesFileReader(){}
-
-	bool ReadNextLine(AisanCenterLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanCenterLine&gt;&amp; data_list);
-};
-
-class AisanAreasFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanArea
-	{
-		int 	AID;
-		int 	SLID;
-		int 	ELID;
-	};
-
-	AisanAreasFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanAreasFileReader(){}
-
-	bool ReadNextLine(AisanArea&amp; data);
-	void ReadAllData(std::vector&lt;AisanArea&gt;&amp; data_list);
-};
-
-class AisanIntersectionFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanIntersection
-	{
-		int 	ID;
-		int 	AID;
-		int 	LinkID;
-	};
-
-	AisanIntersectionFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanIntersectionFileReader(){}
-
-	bool ReadNextLine(AisanIntersection&amp; data);
-	void ReadAllData(std::vector&lt;AisanIntersection&gt;&amp; data_list);
-};
-
-class AisanLanesFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanLane
-	{
-		int LnID	;
-		int DID		;
-		int BLID	;
-		int FLID	;
-		int BNID	;
-		int FNID	;
-		int JCT		;
-		int BLID2	;
-		int BLID3	;
-		int BLID4	;
-		int FLID2	;
-		int FLID3	;
-		int FLID4	;
-		int ClossID	;
-		double Span	;
-		int LCnt	;
-		int Lno		;
-		int LaneType;
-		int LimitVel;
-		int RefVel	;
-		int RoadSecID;
-		int LaneChgFG;
-		int LinkWAID;
-		char LaneDir;
-		int  LeftLaneId;
-		int RightLaneId;
-
-	};
-
-	AisanLanesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanLanesFileReader(){}
-
-	bool ReadNextLine(AisanLane&amp; data);
-	void ReadAllData(std::vector&lt;AisanLane&gt;&amp; data_list);
-};
-
-class AisanStopLineFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanStopLine
-	{
-		int 	ID;
-		int 	LID;
-		int 	TLID;
-		int 	SignID;
-		int 	LinkID;
-	};
-
-	AisanStopLineFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanStopLineFileReader(){}
-
-	bool ReadNextLine(AisanStopLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanStopLine&gt;&amp; data_list);
-};
-
-class AisanRoadSignFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanRoadSign
-	{
-		int 	ID;
-		int 	VID;
-		int 	PLID;
-		int 	Type;
-		int 	LinkID;
-	};
-
-	AisanRoadSignFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanRoadSignFileReader(){}
-
-	bool ReadNextLine(AisanRoadSign&amp; data);
-	void ReadAllData(std::vector&lt;AisanRoadSign&gt;&amp; data_list);
-};
-
-class AisanSignalFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanSignal
-	{
-		int 	ID;
-		int 	VID;
-		int 	PLID;
-		int 	Type;
-		int 	LinkID;
-	};
-
-	AisanSignalFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanSignalFileReader(){}
-
-	bool ReadNextLine(AisanSignal&amp; data);
-	void ReadAllData(std::vector&lt;AisanSignal&gt;&amp; data_list);
-};
-
-class AisanVectorFileReader : public SimpleReaderBase
-{
-public:
-
-	struct AisanVector
-	{
-		int 	VID;
-		int 	PID;
-		double 	Hang;
-		double 	Vang;
-	};
-
-	AisanVectorFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanVectorFileReader(){}
-
-	bool ReadNextLine(AisanVector&amp; data);
-	void ReadAllData(std::vector&lt;AisanVector&gt;&amp; data_list);
-};
-
-class AisanDataConnFileReader : public SimpleReaderBase
-{
-public:
-
-	struct DataConn
-	{
-		int 	LID; // lane id
-		int 	SLID; // stop line id
-		int 	SID; // signal id
-		int 	SSID; // stop sign id
-	};
-
-	AisanDataConnFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
-	~AisanDataConnFileReader(){}
-
-	bool ReadNextLine(DataConn&amp; data);
-	void ReadAllData(std::vector&lt;DataConn&gt;&amp; data_list);
-};
-
-
-} /* namespace UtilityHNS */
-
-#endif /* DATARW_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\GridMap.h" new_path="" added_lines="0" deleted_lines="230">
				<diff>@@ -1,230 +0,0 @@
-/*
- * GridMap.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#ifndef GRIDMAPSA_H_
-#define GRIDMAPSA_H_
-
-#include "RoadNetwork.h"
-
-namespace PlannerHNS
-{
-
-#define get2dIndex(r,c,w) r*w + c
-#define checkGridLimit(r,c,h,w) r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; h &amp;&amp; c &lt; w
-#define checkGridIndex(i, nCells) i &gt;= 0 &amp;&amp; i &lt; nCells
-#define SUBCELL_L 10 //subcell lenth in centimeter
-
-
-class CELL_Info
-{
-public:
-  int r,c,index;
-  GPSPoint center;
-  int nCells;
-  double heuristic;
-  double forwardHeuristic;
-  double backwardHeuristic;
-  double heuristicValue;
-  double forward_heuristicValue;
-  double backward_heuristicValue;
-  int expanded; // used in path planning
-  bool closed;
-  double value;
-  int action;
-  double localize_val;
-  double localize_prob;
-  std::vector&lt;double&gt; localize_features;
-  GPSPoint forwardCenter;
-  GPSPoint backwardCenter;
-  DIRECTION_TYPE bDir;
-  POINT2D bottom_left;
-  POINT2D top_right;
-  POINT2D bottom_right;
-  POINT2D top_left;
-  int nStaticPoints;
-  int nMovingPoints;
-
-  CELL_Info* pInnerMap;
-
-  std::vector&lt;POINT2D&gt; innerStaticPointsList;
-  std::vector&lt;POINT2D&gt; innerMovingPointsList;
-
-  std::vector&lt;GPSPoint&gt; path;
-
-
-public:
-  void InitSubCells(double cell_l, double sub_cell_l);
-/**
- * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
- * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
- */
-  void Clear(int bMovingOnly);
-  void ClearSubCells(bool bMovingOnly);
-
-  CELL_Info();
-
-  virtual ~CELL_Info();
-
-  /*
-   * Cell initialization
-   */
-  void Initialize(POINT2D bottom_left, double cell_l, int row, int col, bool bDefaultEmpty);
-
-  /*
-   * assignment operator
-   */
-  bool operator==(const CELL_Info&amp; cell);
-
-  bool operator!=(const CELL_Info&amp; cell);
-
-  inline bool PointInRect(const POINT2D&amp; p)
-   {
-     return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
-   }
-
-  bool TestWithRectangle(RECTANGLE&amp; rec);
-  bool TestWithCircle(POINT2D _center,double  width);
-   inline bool HitTest(const POINT2D&amp; p);
-
-   void UpdateSubCellCostValue(const std::vector&lt;POINT2D&gt;&amp; ps, const double&amp; cell_l, const double&amp; sub_cell_l);
-   void UpdateCostValue(const std::vector&lt;POINT2D&gt;&amp; ps);
-
-   void SaveCell(std::ostream&amp; f);
-   void LoadCell(std::ifstream&amp; f);
-
-};
-
-class GridMap
-{
-  public:
-
-	  pthread_mutex_t update_map_mutex;
-
-    double w, inner_w; // current world width
-    double h, inner_h; // current world height
-    double cell_l; // cell or block length, if this is an inner cell measurements will be in meter
-    double sub_cell_l;
-    double origin_x , origin_y;
-
-
-
-    int inner_start_row;
-    int inner_start_col;
-    int inner_end_row;
-    int inner_end_col;
-
-    bool m_bEnableInnerMap;
-    bool m_bUpdatedMap;
-
-
-
-    int wCells, nInnerWCells; // width, number of cells per row
-    int hCells, nInnerHCells; // height, number of cells per column
-	//POINT2D center;
-	int m_MaxHeuristics;
-
-	int m_DisplayResolution;
-
-	POINT2D* delta;
-
-
-    // This method map obstacles from real world space to Grid space , marking each cell or internal cells as obstacle
-	void UpdateMapObstacleValue(const Obstacle&amp; ob);
-	void UpdateMapDrivablesValue(const DrivableArea&amp; dr);
-	void UpdateMapDrivablesValuePlygon(const std::vector&lt;std::vector&lt;POINT2D&gt; &gt;&amp; points);
-	void UpdateMapObstaclesValuePlygon(const std::vector&lt;POINT2D&gt;&amp; poly, std::vector&lt;CELL_Info*&gt;&amp; modifiedCell);
-
-	/**
-	 * @brief update cell to indicate that there is an obstacle @ absolute point p
-	 * @param p absolute x,y point
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapObstaclePoint(const POINT2D&amp; p);
-
-	/**
-	 * @brief update cell to indicate that there is an obstacle @ absolute point p , and make the map thiner according to a giving threshold
-	 * @param p absolute x,y point
-	 * @param thiningTHreshold distance to search for old obstacles
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateThinMapObstaclePoint(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold);
-
-	/**
-	 * @brief update cell to indicate that there is an moving obstacle @ absolute point p
-	 * @param p absolute x,y point
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapMovingObstaclePoint(const POINT2D&amp; p);
-
-	/**
-	 * @brief update subcells cost values to reflect the effect of obstacle @ absolute pint p
-	 * @param p obstacle point (x,y)
-	 * @param currPos current car location to apply the effect of obstacle on p
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapCostValueRange(const std::vector&lt;POINT2D&gt;&amp; ps, const GPSPoint&amp; currPos, const std::vector&lt;double&gt;&amp; features);
-	/**
-	 * @brief find the cell @ p then update its localization cost and probability which were read from a map file
-	 * @param p absolute position of the cell center
-	 * @param localize_val cost value
-	 * @param localize_prob probability value (should be zero in case of updating from map file
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateSubMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);
-
-	CELL_Info* UpdateMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);
-
-	CELL_Info* GetCellFromPointInnerMap(const POINT2D&amp; p);
-	CELL_Info* GetCellFromPoint(const POINT2D&amp; p, bool bExpand = false); // return cell information from (x,y) coordinates
-	CELL_Info* GetSubCellFromPoint(const POINT2D&amp; p); // return sub cell information from (x,y) coordinates
-	CELL_Info* GetSubCellFromCell(CELL_Info* const parent, const POINT2D&amp; p); // return sub cell information from parent cell
-
-	bool CheckSubCellsInTheWay(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold, std::vector&lt;CELL_Info*&gt;&amp; pSubCellsList);
-
-	/**
-	 * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
-	 * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
-	 */
-	void ClearMap(int bMovingOnly);
-	void OpenClosedCells();
-	void BackupMap();
-
-	GridMap();
-    GridMap(double start_x, double start_y, double  map_w, double map_h, double cell_length, bool bDefaultEmpty); // initialize and construct the 2D array of the Grid cells
-    void InitInnerMap(double  map_l, GridMap* const pParentMap, const POINT2D&amp; center); // initialize and construct map from another map (cells will point to cells from the other map , width and hight will be maximum available limited by the parameters
-    virtual ~GridMap();
-
-    CELL_Info* pCells;
-    int nCells;
-
-    void SaveMap(const std::string&amp; mapFilePath, const std::string&amp; mapName);
-    void LoadMap(const std::string&amp; mapFilePath, const POINT2D&amp; pos, const double&amp; loadingRadius, const GPSPoint&amp; mapTransformation);
-
-    int GetSurroundingMainCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
-    int GetSurroundingNonObstacleCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
-    int GetSurroundingMainCellsRectangle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
-    int GetSurroundingMainCellsCircle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, double radius);
-    int GetSurroundingMainCellsRectangleNoObstacle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
-
-    bool IsUpdated()
-    {
-    	return m_bUpdatedMap;
-    }
-
-    void ObservedMap()
-    {
-    	m_bUpdatedMap = false;
-    }
-
-  private:
-    int InsidePolygon(const std::vector&lt;POINT2D&gt;&amp; polygon,const POINT2D&amp; p);
-
-    //vector&lt;CELL_Info*&gt; pDrivableCells;
-  };
-
-}
-#endif /* GRIDMAP_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\HMIStateMachine.h" new_path="" added_lines="0" deleted_lines="99">
				<diff>@@ -1,99 +0,0 @@
-/*
- * HMIStateMachine.h
- *
- *  Created on: February 14, 2017
- *      Author: Hatem Darweesh
- */
-
-#ifndef HMIStateMachine_H_
-#define HMIStateMachine_H_
-
-#include "RoadNetwork.h"
-#include &lt;sstream&gt;
-
-namespace PlannerHNS
-{
-
-class HMIStateMachine
-{
-public:
-	virtual HMIStateMachine* GetNextState() = 0;
-	virtual void Init();
-	virtual void ResetTimer();
-	virtual void InsertNextState(HMIStateMachine* nextState);
-	HMIStateMachine(HMIStateMachine* nextState);
-	virtual ~HMIStateMachine() ;
-
-	GLOBAL_STATE_TYPE m_Behavior;
-	double decisionMakingTime;
-
-	HMIPreCalculatedConditions* GetCalcParams()
-	{
-		if(!m_pCalculatedValues)
-				m_pCalculatedValues = new HMIPreCalculatedConditions();
-
-		return m_pCalculatedValues;
-	}
-
-	void SetBehaviorsParams(const PlanningParams&amp; params)
-	{
-		m_PlanningParams = params;
-	}
-
-	static HMIPreCalculatedConditions* m_pCalculatedValues;
-	timespec m_StateTimer;
-	std::vector&lt;HMIStateMachine*&gt; pNextStates;
-	static PlanningParams m_PlanningParams;
-
-	HMIStateMachine* FindBehaviorState(const GLOBAL_STATE_TYPE&amp; behavior);
-};
-
-class GWaitingState : public HMIStateMachine
-{
-public:
-	GWaitingState(GWaitingState* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_WAITING_STATE;}
-	virtual ~GWaitingState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GPlanningState : public HMIStateMachine
-{
-public:
-	GPlanningState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_PLANING_STATE;}
-	virtual ~GPlanningState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GForwardState : public HMIStateMachine
-{
-public:
-	GForwardState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_FORWARD_STATE;}
-	virtual ~GForwardState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GBranchingState : public HMIStateMachine
-{
-public:
-	GBranchingState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_BRANCHING_STATE;}
-	virtual ~GBranchingState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GEndState : public HMIStateMachine
-{
-public:
-	GEndState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_FINISH_STATE;}
-	virtual ~GEndState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-
-} /* namespace PlannerHNS */
-
-#endif /* HMIStateMachine_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\LocalPlannerH.h" new_path="" added_lines="0" deleted_lines="157">
				<diff>@@ -1,157 +0,0 @@
-/*
- * CarState.h
- *
- *  Created on: Dec 14, 2016
- *      Author: hatem
- */
-
-#ifndef LOCALPLANNERH_H_
-#define LOCALPLANNERH_H_
-
-#include "BehaviorStateMachine.h"
-#include "PlannerCommonDef.h"
-#include "RoadNetwork.h"
-#include "TrajectoryCosts.h"
-
-namespace PlannerHNS
-{
-
-class LocalPlannerH
-{
-public:
-	WayPoint state;
-	CAR_BASIC_INFO m_CarInfo;
-	ControllerParams m_ControlParams;
-	std::vector&lt;GPSPoint&gt; m_CarShapePolygon;
-	std::vector&lt;WayPoint&gt; m_Path;
-	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_TotalPath;
-	int m_iCurrentTotalPathId;
-	int m_iSafeTrajectory;
-//	int m_iGlobalPathPrevID;
-	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_PredictedPath;
-	std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt; m_RollOuts;
-	std::string carId;
-	Lane* pLane;
-	double m_SimulationSteeringDelayFactor; //second , time that every degree change in the steering wheel takes
-	timespec m_SteerDelayTimer;
-	double m_PredictionTime;
-	double m_CostCalculationTime;
-	double m_BehaviorGenTime;
-	double m_RollOutsGenerationTime;
-
-	BehaviorStateMachine* 		m_pCurrentBehaviorState;
-	ForwardState * 				m_pGoToGoalState;
-	StopState* 					m_pStopState;
-	WaitState* 					m_pWaitState;
-	InitState* 					m_pInitState;
-	MissionAccomplishedState*	m_pMissionCompleteState;
-	GoalState*					m_pGoalState;
-	FollowState*				m_pFollowState;
-	SwerveState*				m_pAvoidObstacleState;
-	TrafficLightStopState*		m_pTrafficLightStopState;
-	TrafficLightWaitState*		m_pTrafficLightWaitState;
-	StopSignStopState* 			m_pStopSignStopState;
-	StopSignWaitState* 			m_pStopSignWaitState;
-
-	TrajectoryCosts m_TrajectoryCostsCalculatotor;
-
-
-
-	//for debugging
-	std::vector&lt;WayPoint&gt; m_PathSection;
-	std::vector&lt;WayPoint&gt; m_SampledPoints;
-
-	void InitBehaviorStates();
-
-	void SetSimulatedTargetOdometryReadings(const double&amp; velocity_d, const double&amp; steering_d, const SHIFT_POS&amp; shift_d)
-	{
-		m_CurrentVelocityD = velocity_d;
-		m_CurrentSteeringD = steering_d;
-		m_CurrentShiftD = shift_d;
-	}
-
-	double GetSimulatedVelocity()
-	{
-		return m_CurrentVelocity;
-	}
-
-	double GetSimulatedSteering()
-	{
-		return m_CurrentSteering;
-	}
-
-	double GetSimulatedShift()
-	{
-		return m_CurrentShift;
-	}
-
-
-	//For Simulation
-	WayPoint m_OdometryState;
-	double m_CurrentVelocity, m_CurrentVelocityD; //meter/second
-	double m_CurrentSteering, m_CurrentSteeringD; //radians
-	SHIFT_POS m_CurrentShift , m_CurrentShiftD;
-
-	double m_CurrentAccSteerAngle; //degrees steer wheel range
-	double m_CurrentAccVelocity; // kilometer/hour
-	//std::vector&lt;TrafficLight&gt; m_TrafficLights;
-
-public:
-
-	LocalPlannerH();
-	virtual ~LocalPlannerH();
-	void Init(const ControllerParams&amp; ctrlParams, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo);
-	void InitPolygons();
-	void FirstLocalizeMe(const WayPoint&amp; initCarPos);
-	void LocalizeMe(const double&amp; dt); // in seconds
-	void UpdateState(const VehicleState&amp; state, const bool&amp; bUseDelay = false);
-	void CalculateImportantParameterForDecisionMaking(const VehicleState&amp; car_state,
-			const int&amp; goalID, const bool&amp; bEmergencyStop, const bool&amp; bGreenTrafficLight,
-			const TrajectoryCost&amp; bestTrajectory);
-
-	BehaviorState DoOneStep(
-			const double&amp; dt,
-			const VehicleState&amp; state,
-			const std::vector&lt;DetectedObject&gt;&amp; obj_list,
-			const int&amp; goalID,
-			RoadNetwork&amp; map,
-			const bool&amp; bEmergencyStop,
-			const bool&amp; bGreenTrafficLight,
-			const bool&amp; bLive = false);
-
-	void SimulateOdoPosition(const double&amp; dt, const VehicleState&amp; vehicleState);
-
-private:
-
-	//Obstacle avoidance functionalities
-	bool CalculateObstacleCosts(RoadNetwork&amp; map, const VehicleState&amp; vstatus, const std::vector&lt;DetectedObject&gt;&amp; obj_list);
-
-	double PredictTimeCostForTrajectory(std::vector&lt;WayPoint&gt;&amp; path,
-			const VehicleState&amp; vstatus,
-			const WayPoint&amp; currState);
-
-	void PredictObstacleTrajectory(RoadNetwork&amp; map,
-			const WayPoint&amp; pos,
-			const double&amp; predTime,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-	bool CalculateIntersectionVelocities(std::vector&lt;WayPoint&gt;&amp; path,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; predctedPath,
-			const DetectedObject&amp; obj);
-
-	bool GetNextTrafficLight(const int&amp; prevTrafficLightId, const std::vector&lt;TrafficLight&gt;&amp; trafficLights, TrafficLight&amp; trafficL);
-	void UpdateCurrentLane(RoadNetwork&amp; map, const double&amp; search_distance);
-	bool SelectSafeTrajectoryAndSpeedProfile(const VehicleState&amp; vehicleState);
-	BehaviorState GenerateBehaviorState(const VehicleState&amp; vehicleState);
-	void TransformPoint(const WayPoint&amp; refPose, GPSPoint&amp; p);
-	void AddAndTransformContourPoints(const DetectedObject&amp; obj, std::vector&lt;WayPoint&gt;&amp; contourPoints);
-	void UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt);
-
-	bool NoWayTest(const double&amp; min_distance, const int&amp; iGlobalPathIndex);
-
-	PlannerHNS::PlanningParams m_params;
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* LOCALPLANNERH_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\MappingHelpers.h" new_path="" added_lines="0" deleted_lines="108">
				<diff>@@ -1,108 +0,0 @@
-/*
- * MappingHelpers.h
- *
- *  Created on: Jul 2, 2016
- *      Author: Hatem
- */
-
-#ifndef MAPPINGHELPERS_H_
-#define MAPPINGHELPERS_H_
-
-#include &lt;math.h&gt;
-#include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "DataRW.h"
-#include "tinyxml.h"
-
-
-namespace PlannerHNS {
-
-
-class MappingHelpers {
-public:
-	MappingHelpers();
-	virtual ~MappingHelpers();
-
-	static void ConstructRoadNetworkFromRosMessage(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
-			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
-			const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
-			const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
-			const std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt;&amp; area_data,
-			const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
-			const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
-			const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
-			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
-			const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
-			const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag = false);
-
-	static void ConstructRoadNetworkFromDataFiles(const std::string vectoMapPath, RoadNetwork&amp; map, const bool&amp; bZeroOrigin = false);
-
-	static void SaveTrajectoryLonLatToKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectory);
-
-	static void GetWayPoint(const int&amp; pid, const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points, std::vector&lt;WayPoint&gt;&amp; path);
-	static bool GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; did,
-			const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dtpoints,
-			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
-			const GPSPoint&amp; origin, WayPoint&amp; way_point);
-
-	static void WriteKML(const std::string&amp; kmlFile, const std::string&amp; kmlTemplat, RoadNetwork&amp; ap);
-	static void LoadKML(const std::string&amp; kmlMap, RoadNetwork&amp; map);
-
-	static void SetRoadLinksList(TiXmlElement* pElem, std::vector&lt;RoadSegment&gt;&amp; roadSegments);
-	static void SetLaneLinksList(TiXmlElement* pElem, std::vector&lt;Lane&gt;&amp; lanes);
-	static void SetStopLinesList(TiXmlElement* pElem, std::vector&lt;StopLine&gt;&amp; stopLines);
-	static void SetTrafficLightsList(TiXmlElement* pElem, std::vector&lt;TrafficLight&gt;&amp; trafficLights);
-	static void SetTrafficSignsList(TiXmlElement* pElem, std::vector&lt;TrafficSign&gt;&amp; trafficSignes);
-
-	static TiXmlElement* GetHeadElement(TiXmlElement* pMainElem);
-	static TiXmlElement* GetDataFolder(const std::string&amp; folderName, TiXmlElement* pMainElem);
-
-
-	static Lane* GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static Lane* GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static std::vector&lt;Lane*&gt; GetClosestMultipleLanesFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static WayPoint* GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
-	static WayPoint* GetClosestBackWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
-	static WayPoint GetFirstWaypoint(RoadNetwork&amp; map);
-	static WayPoint* GetLastWaypoint(RoadNetwork&amp; map);
-
-
-	static void llaToxyz(GPSPoint&amp; lla_p, const GPSPoint&amp; origin);
-	static void llaToxyzSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
-	static void xyzTolla(GPSPoint&amp; xyz_p, const GPSPoint&amp; origin);
-	static void xyzTollaSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
-
-	static void GetUniqueNextLanes(const Lane* l,  const std::vector&lt;Lane*&gt;&amp; traversed_lanes, std::vector&lt;Lane*&gt;&amp; lanes_list);
-
-	static GPSPoint GetTransformationOrigin(const int&amp; bToyotaCityMap = 0);
-
-	static Lane* GetLaneFromPath(const WayPoint&amp; currPos, const std::vector&lt;WayPoint&gt;&amp; currPath);
-	static Lane* GetLaneById(const int&amp; id,RoadNetwork&amp; map);
-	static int GetLaneIdByWaypointId(const int&amp; id,std::vector&lt;Lane&gt;&amp; lanes);
-
-	static WayPoint* FindWaypoint(const int&amp; id, RoadNetwork&amp; map);
-
-
-	static std::vector&lt;TrafficLight&gt; GetTrafficLightsList(TiXmlElement* pElem);
-	static std::vector&lt;StopLine&gt; GetStopLinesList(TiXmlElement* pElem);
-	static std::vector&lt;Lane&gt; GetLanesList(TiXmlElement* pElem);
-	static std::vector&lt;RoadSegment&gt; GetRoadSegmentsList(TiXmlElement* pElem);
-	static std::vector&lt;int&gt; GetIDsFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::vector&lt;double&gt; GetDoubleFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::pair&lt;ACTION_TYPE, double&gt; GetActionPairFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
-	static std::vector&lt;WayPoint&gt; GetCenterLaneData(TiXmlElement* pElem, const int&amp; currLaneID);
-	static std::vector&lt;WayPoint&gt; GetCenterLaneDataVer0(TiXmlElement* pElem, const int&amp; currLaneID);
-	static std::vector&lt;GPSPoint&gt; GetPointsData(TiXmlElement* pElem);
-	static std::vector&lt;std::string&gt; SplitString(const std::string&amp; str, const std::string&amp; token);
-
-	static void CreateKmlFromLocalizationPathFile(const std::string&amp; pathFileName,const double&amp; maxLaneDistance, const double&amp; density,const std::vector&lt;TrafficLight&gt;&amp; trafficLights, const std::vector&lt;GPSPoint&gt;&amp; stopLines);
-
-	static int ReplaceMyID(int&amp; id, const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; rep_list);
-
-	static double m_USING_VER_ZERO;
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* MAPPINGHELPERS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\MatrixOperations.h" new_path="" added_lines="0" deleted_lines="131">
				<diff>@@ -1,131 +0,0 @@
-/*
- * MatrixOperations.h
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
-
-#ifndef MATRIXOPERATIONS_H_
-#define MATRIXOPERATIONS_H_
-
-#include "RoadNetwork.h"
-#include &lt;math.h&gt;
-
-
-namespace PlannerHNS {
-
-
-class Mat3
-{
-	double m11, m12, m13;
-	double m21, m22, m23;
-	double m31, m32, m33;
-
-	double m[3][3];
-
-public:
-	Mat3()
-	{
-		//initialize Identity by default
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-	}
-
-	Mat3(double angle, POINT2D trans)
-	{
-		//Initialize Rotation Matrix
-		double c = cos(angle);
-		double s = sin(angle);
-		m11 = c;
-		m12 = s;
-		m21 = -s;
-		m22 = c;
-		m31 = trans.x;
-		m32 = trans.y;
-		m13 = m23= 0;
-		m33 = 1;
-	}
-
-	Mat3(double transX, double transY, bool mirrorX, bool mirrorY )
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		m[0][0] = (mirrorX == true ) ? -1 : 1; m[0][1] =  0; m[0][2] =  transX;
-		m[1][0] = 0; m[1][1] =  (mirrorY==true) ? -1 : 1; m[1][2] =  transY;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(double transX, double transY)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		m[0][0] = 1; m[0][1] =  0; m[0][2] =  transX;
-		m[1][0] = 0; m[1][1] =  1; m[1][2] =  transY;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(double rotation_angle)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		double c = cos(rotation_angle);
-		double s = sin(rotation_angle);
-		m[0][0] = c; m[0][1] = -s; m[0][2] =  0;
-		m[1][0] = s; m[1][1] =  c; m[1][2] =  0;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-	Mat3(GPSPoint rotationCenter)
-	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-		double c = cos(rotationCenter.a);
-		double s = sin(rotationCenter.a);
-		double u = rotationCenter.x;
-		double v = rotationCenter.y;
-		m[0][0] = c; m[0][1] = -s; m[0][2] = -u*c + v*s + u;
-		m[1][0] = s; m[1][1] =  c; m[1][2] = -u*s - v*c + v;
-		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
-	}
-
-
-	GPSPoint operator * (GPSPoint v)
-	{
-		GPSPoint _v = v;
-		v.x = m[0][0]*_v.x + m[0][1]*_v.y + m[0][2]*1;
-		v.y = m[1][0]*_v.x + m[1][1]*_v.y + m[1][2]*1;
-		return v;
-	}
-
-	POINT2D operator * (POINT2D v)
-	{
-		Mat3 m = *this;
-		POINT2D r;
-		r.x = m.m11 * v.x + m.m21 * v.y + m.m31 * 1;
-		r.y = m.m12 * v.x + m.m22 * v.y + m.m32 * 1;
-		return r;
-	}
-
-	Mat3 operator *(Mat3 m2)
-	{
-		Mat3 m1 = *this;
-		Mat3 r;
-		r.m11 = m1.m11 * m2.m11 + m1.m12 * m2.m21 + m1.m13 * m2.m31;
-		r.m12 = m1.m11 * m2.m12 + m1.m12 * m2.m22 + m1.m13 * m2.m32;
-		r.m13 = m1.m11 * m2.m13 + m1.m12 * m2.m23 + m1.m13 * m2.m33;
-
-		r.m21 = m1.m21 * m2.m11 + m1.m22 * m2.m21 + m1.m23 * m2.m31;
-		r.m22 = m1.m21 * m2.m12 + m1.m22 * m2.m22 + m1.m23 * m2.m32;
-		r.m23 = m1.m21 * m2.m13 + m1.m22 * m2.m23 + m1.m23 * m2.m33;
-
-		r.m31 = m1.m31 * m2.m11 + m1.m32 * m2.m21 + m1.m33 * m2.m31;
-		r.m32 = m1.m31 * m2.m12 + m1.m32 * m2.m22 + m1.m33 * m2.m32;
-		r.m33 = m1.m31 * m2.m13 + m1.m32 * m2.m23 + m1.m33 * m2.m33;
-
-		return r;
-	}
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* MATRIXOPERATIONS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\OpenPlannerSimulatorPerception_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\OpenPlannerSimulatorPerception_core.h" added_lines="0" deleted_lines="2">
				<diff>@@ -45,8 +45,6 @@
 #include &lt;tf/transform_listener.h&gt;
 #include &lt;tf/tf.h&gt;
 #include &lt;std_msgs/Int8.h&gt;
-#include "waypoint_follower/libwaypoint_follower.h"
-#include "waypoint_follower/LaneArray.h"
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;visualization_msgs/InteractiveMarkerPose.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\PlannerCommonDef.h" new_path="" added_lines="0" deleted_lines="156">
				<diff>@@ -1,156 +0,0 @@
-/*
- * PlannerCommonDef.h
- *
- *  Created on: Dec 14, 2016
- *      Author: hatem
- */
-
-#ifndef PLANNERCOMMONDEF_H_
-#define PLANNERCOMMONDEF_H_
-
-#include &lt;math.h&gt;
-#include &lt;string&gt;
-
-namespace PlannerHNS
-{
-
-enum CAR_TYPE
-{
-  Mv2Car, //!&lt; Mv2Car
-  PHVCar, //!&lt; PHVCar
-  HVCar,  //!&lt; HVCar
-  RoboCar,//!&lt; RoboCar
-  SimulationCar
-};
-
-class PID_CONST
-{
-public:
-	double kP;
-	double kI;
-	double kD;
-
-	PID_CONST()
-	{
-		kP = kI = kD = 0;
-	}
-
-	PID_CONST(const double&amp; p, const double&amp; i, const double&amp; d)
-	{
-		kP = p;
-		kI = i;
-		kD = d;
-	}
-};
-
-class ControllerParams
-{
-public:
-	double SimulationSteeringDelay;
-	double SteeringDelay;
-	double minPursuiteDistance;
-	PID_CONST Steering_Gain;
-	PID_CONST Velocity_Gain;
-	double Acceleration;
-	double Deceleration;
-	double FollowDistance;
-	double LowpassSteerCutoff;
-	double maxAccel;
-	double maxDecel;
-
-
-	ControllerParams()
-	{
-		SimulationSteeringDelay = 0.0;
-		SteeringDelay 		= 0.8;
-		Acceleration		= 0.5;
-		Deceleration		= -0.8;
-		FollowDistance		= 8.0;
-		LowpassSteerCutoff	= 5.0;
-		maxAccel			= 0.9;
-		minPursuiteDistance = 2.0;
-		maxDecel 			= -1.5;
-	}
-};
-
-class CAR_BASIC_INFO
-{
-public:
-  CAR_TYPE model;
-
-  double turning_radius;
-  double wheel_base;
-  double max_speed_forward;
-  double min_speed_forward;
-  double max_speed_backword;
-  double max_steer_value;
-  double min_steer_value;
-  double max_brake_value;
-  double min_brake_value;
-  double max_steer_angle;
-  double min_steer_angle;
-  double length;
-  double width;
-  double max_acceleration;
-  double max_deceleration;
-
-  CAR_BASIC_INFO()
-  {
-	  model 				= SimulationCar;
-	  turning_radius 		= 5.2;
-	  wheel_base			= 2.7;
-	  max_speed_forward		= 3.0;
-	  min_speed_forward		= 0.0;
-	  max_speed_backword	= 1.0;
-	  max_steer_value		= 660;
-	  min_steer_value		= -660;
-	  max_brake_value		= 0;
-	  min_brake_value		= 0;
-	  max_steer_angle		= 0.42;
-	  min_steer_angle		= 0.42;
-	  length				= 4.3;
-	  width					= 1.82;
-	  max_acceleration		= 1.5; // m/s2
-	  max_deceleration		= -1.5; // 1/3 G
-  }
-
-  double CalcMaxSteeringAngle()
-  {
-    return  max_steer_angle;//asin(wheel_base/turning_radius);
-  }
-
-  double BoundSpeed(double s)
-  {
-	if(s &gt; 0 &amp;&amp; s &gt; max_speed_forward)
-		return max_speed_forward;
-	if(s &lt; 0 &amp;&amp; s &lt; max_speed_backword)
-		return max_speed_backword;
-	return s;
-  }
-
-  double BoundSteerAngle(double a)
-  {
-	if(a &gt; max_steer_angle)
-		return max_steer_angle;
-	if(a &lt; min_steer_angle)
-		return min_steer_angle;
-
-	return a;
-  }
-
-  double BoundSteerValue(double v)
-  {
-	  if(v &gt;= max_steer_value)
-		return max_steer_value;
-	if(v &lt;= min_steer_value)
-		return min_steer_value;
-
-	return v;
-  }
-
-};
-
-
-} /* namespace PlannerHNS */
-
-#endif /* PLANNERCOMMONDEF_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\PlannerH.h" new_path="" added_lines="0" deleted_lines="119">
				<diff>@@ -1,119 +0,0 @@
-/*
- * PlannerH.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#include "RSPlanner.h"
-#include "GridMap.h"
-
-#define START_POINT_MAX_DISTANCE 8 // meters
-#define GOAL_POINT_MAX_DISTANCE 8 // meters
-#define LANE_CHANGE_SMOOTH_FACTOR_DISTANCE 8 // meters
-
-namespace PlannerHNS
-{
-
-enum PLANDIRECTION {MOVE_FORWARD_ONLY, MOVE_BACKWARD_ONLY, 	MOVE_FREE};
-enum HeuristicConstrains {EUCLIDEAN, NEIGBORHOOD,DIRECTION };
-
-class PlannerH
-{
-public:
-	PlannerH();
-	virtual ~PlannerH(); 
-
-
-	/**
-	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles
-	 * @param start: Start position for the trajectory (x,y,theta)
-	 * @param goal:  Goal position (Destination point) (x,y,theta)
-	 * @param map:  2d grid map, ( cost map or occupancy grid.
-	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
-	 * @return path length
-	 */
-	double PlanUsingReedSheppWithObstacleDetection(const WayPoint&amp; start, const WayPoint&amp; goal, GridMap&amp; map, std::vector&lt;WayPoint&gt;&amp; genSmoothedPath,
-			const double pathDensity = 0.25, const double smoothFactor = 12.0);
-
-	/**
-	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles , but if there an obstacle on the trajectory function will fail. , also this function does not guaranteed to generate trajectories
-	 * @param start: Start position for the trajectory (x,y,theta)
-	 * @param goal:  Goal position (Destination point) (x,y,theta)
-	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
-	 * @return path length
-	 */
-	double PlanUsingReedShepp(const WayPoint&amp; start, const WayPoint&amp; goal, std::vector&lt;WayPoint&gt;&amp; generatedPath,
-			const double pathDensity = 0.25, const double smoothFactor = 12.0);
-
-
-	/**
-	 * @brief Generate Roll outs for global generated path
-	 * @param referencePath center lint reference path
-	 * @param carPos current car position
-	 * @param bEnableLaneChange is lane change is available
-	 * @param speed current car speed
-	 * @param microPlanDistance distance limit for roll outs
-	 * @param maxSpeed maximum forward speed
-	 * @param minSpeed minimum forward speed
-	 * @param carTipMargin 1st roll out smoothing parameter
-	 * @param rollInMargin 2nd roll out smoothing parameter
-	 * @param rollInSpeedFactor roll out 3rd smoothing parameter
-	 * @param pathDensity distance between every two waypoints in the generated trajectory
-	 * @param rollOutDensity distance between the center line and adjacent trajectories
-	 * @param rollOutNumber number of sampled trajectories
-	 * @param SmoothDataWeight general smoothing parameter , how smoother keep close to original data 0 - 0.5
-	 * @param SmoothWeight general smoothing parameter, how smoother is trying to pull away to form the shortest and strait line possible
-	 * @param SmoothTolerance performance measure , conjugate gradient conversion factor should be 0.1 - 0.01
-	 * @param speedProfileFactor how car should slow for corners
-	 * @param bHeadingSmooth follow car heading direction or center line path heading for sampling direction
-	 */
-	void GenerateRunoffTrajectory(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; referencePaths, const WayPoint&amp; carPos, const bool&amp; bEnableLaneChange, const double&amp; speed, const double&amp; microPlanDistance,
-				const double&amp; maxSpeed,const double&amp; minSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
-				const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
-				const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
-				const double&amp; SmoothTolerance, const double&amp; speedProfileFactor, const bool&amp; bHeadingSmooth,
-				const int&amp; iCurrGlobalPath, const int&amp; iCurrLocalTraj,
-				std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOutsPaths,
-				std::vector&lt;WayPoint&gt;&amp; sectionPath, std::vector&lt;WayPoint&gt;&amp; sampledPoints);
-
-	/**
-	 * @brief Path planning for structured environment using dynamic programming
-	 * @param lane
-	 * @param carPos
-	 * @param goalPos
-	 * @param prevWayPoint
-	 * @param maxPlanningDistance
-	 * @param globalPath
-	 * @param path
-	 * @return generated path length
-	 */
-	double PlanUsingDP(const WayPoint&amp; carPos,const WayPoint&amp; goalPos,
-			const double&amp; maxPlanningDistance, const bool bEnableLaneChange, const std::vector&lt;int&gt;&amp; globalPath,
-			RoadNetwork&amp; map, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, std::vector&lt;WayPoint*&gt;* all_cell_to_delete = 0);
-
-	 double PlanUsingDPRandom(const WayPoint&amp; start,
-	 		 const double&amp; maxPlanningDistance,
-	 		 RoadNetwork&amp; map,
-	 		 std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-
-	/**
-	 * @brief Return all possible trajectories from current position to max planning distance in all directions
-	 * @param lane
-	 * @param carPos
-	 * @param maxPlanningDistance
-	 * @param paths
-	 * @return
-	 */
-	double PredictPlanUsingDP(Lane* lane, const WayPoint&amp; carPos, const double&amp; maxPlanningDistance,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-	void DeleteWaypoints(std::vector&lt;WayPoint*&gt;&amp; wps);
-
-	//PlanningInternalParams m_Params;
-};
-
-}
-
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\PlanningHelpers.h" new_path="" added_lines="0" deleted_lines="170">
				<diff>@@ -1,170 +0,0 @@
-/*
- * PlanningHelpers.h
- *
- *  Created on: Jun 16, 2016
- *      Author: hatem
- */
-
-#ifndef PLANNINGHELPERS_H_
-#define PLANNINGHELPERS_H_
-
-#include &lt;math.h&gt;
-#include "RoadNetwork.h"
-#include "UtilityH.h"
-#include "DataRW.h"
-#include "tinyxml.h"
-
-
-namespace PlannerHNS {
-
-#define distance2points(from , to) sqrt(pow(to.x - from.x, 2) + pow(to.y - from.y, 2))
-#define distance2pointsSqr(from , to) pow(to.x - from.x, 2) + pow(to.y - from.y, 2)
-#define pointNorm(v) sqrt(v.x*v.x + v.y*v.y)
-#define angle2points(from , to) atan2(to.y - from.y, to.x - from.x )
-#define LANE_CHANGE_SPEED_FACTOR 0.5
-#define LANE_CHANGE_COST 3.0 // meters
-#define BACKUP_STRAIGHT_PLAN_DISTANCE 60 //meters
-
-class PlanningHelpers {
-public:
-	PlanningHelpers();
-	virtual ~PlanningHelpers();
-
-	/**
-	 * @brief Find all relative information from the point p to the trajectory such as (perpendicular distance , closest next point , closest back point, distance from perpendicular intersection point to next point, distance from perpendicular intersection point to previous point)
-	 * @param trajectory list of waypoints
-	 * @param p query point
-	 * @param info collection of calculated information
-	 * @param prevIndex initial search index
-	 * @return true if success without errors, false otherwise
-	 */
-	static bool GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex = 0);
-
-	static bool GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectories, const WayPoint&amp; p, const double&amp; searchDistance, RelativeInfo&amp; info);
-
-	/**
-	 * @brief Find point on the trajectory after initial relative point with specific distance
-	 * @param trajectory list of waypoints
-	 * @param init_p initial relative point on trajectory
-	 * @param distance distance from initial relative point to follow point
-	 * @return point on trajectory
-	 */
-	static WayPoint GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; init_p, const double&amp; distance, unsigned int&amp; point_index);
-
-	/**
-	 * @brief Calculate the precise distance from projection of point p2 (relative) to projection of point 1 (relative)
-	 * @param trajectory list of waypoints
-	 * @param p1 first relative point
-	 * @param p2 second relative point
-	 * @return distance on trajectory
-	 */
-	static double GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; p1,const RelativeInfo&amp; p2);
-
-	/**
-	 * @brief Find the closest next point on the trajectory index
-	 * @param trajectory list of waypoints
-	 * @param p query point
-	 * @param prevIndex initial search index
-	 * @return index of the closest next point from trajectory
-	 */
-	static int GetClosestNextPointIndex(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-
-	static int GetClosestNextPointIndexDirection(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-
-
-	static int GetClosestPointIndex_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex = 0 );
-	static WayPoint GetPerpendicularOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, double&amp; distance, const int&amp; prevIndex = 0);
-	static double GetPerpDistanceToTrajectorySimple_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
-	static double GetPerpDistanceToVectorSimple_obsolete(const WayPoint&amp; p1, const WayPoint&amp; p2, const WayPoint&amp; pose);
-	static WayPoint GetNextPointOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const double&amp; distance, const int&amp; currIndex = 0);
-	static double GetDistanceOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
-
-
-	static void FixPathDensity(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; distanceDensity);
-	static void SmoothPath(std::vector&lt;WayPoint&gt;&amp; path, double weight_data =0.25,double weight_smooth = 0.25,double tolerance = 0.01);
-	static double CalcCircle(const GPSPoint&amp; pt1, const GPSPoint&amp; pt2, const GPSPoint&amp; pt3, GPSPoint&amp; center);
-	static double CalcAngleAndCost(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0, const bool&amp; bSmooth = true );
-	//static double CalcAngleAndCostSimple(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0);
-	static double CalcAngleAndCostAndCurvatureAnd2D(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0);
-
-	static double GetAccurateDistanceOnTrajectory(std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
-
-	static void ExtractPartFromPointToDistance(const std::vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
-			const double&amp; pathDensity, std::vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance);
-
-	static void CalculateRollInTrajectories(const WayPoint&amp; carPos, const double&amp; speed, const std::vector&lt;WayPoint&gt;&amp; originalCenter, int&amp; start_index,
-			int&amp; end_index, std::vector&lt;double&gt;&amp; end_laterals ,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; rollInPaths, const double&amp; max_roll_distance,
-			const double&amp; maxSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
-			const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
-			const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
-			const double&amp; SmoothTolerance, const bool&amp; bHeadingSmooth,
-			std::vector&lt;WayPoint&gt;&amp; sampledPoints);
-
-
-	static void SmoothSpeedProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
-	static void SmoothCurvatureProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance = 0.1);
-	static void SmoothWayPointsDirections(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
-
-	static void GenerateRecommendedSpeed(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor);
-//	static WayPoint* BuildPlanningSearchTree(Lane* l, const WayPoint&amp; prevWayPointIndex,
-//			const WayPoint&amp; startPos, const WayPoint&amp; goalPos,
-//			const std::vector&lt;int&gt;&amp; globalPath, const double&amp; DistanceLimit,
-//			int&amp; nMaxLeftBranches, int&amp; nMaxRightBranches,
-//			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static WayPoint* BuildPlanningSearchTreeV2(WayPoint* pStart,
-			const WayPoint&amp; goalPos,
-			const std::vector&lt;int&gt;&amp; globalPath, const double&amp; DistanceLimit,
-			const bool&amp; bEnableLaneChange,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static WayPoint* BuildPlanningSearchTreeStraight(WayPoint* pStart,
-			const double&amp; DistanceLimit,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );
-
-	static int PredictiveDP(WayPoint* pStart, const double&amp; DistanceLimit,
-			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete, std::vector&lt;WayPoint*&gt;&amp; end_waypoints);
-
-	static bool CheckLaneIdExits(const std::vector&lt;int&gt;&amp; lanes, const Lane* pL);
-	static WayPoint* CheckLaneExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const Lane* pL);
-	static WayPoint* CheckNodeExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const WayPoint* pL);
-
-	static WayPoint* CreateLaneHeadCell(Lane* pLane, WayPoint* pLeft, WayPoint* pRight,
-			WayPoint* pBack);
-	static double GetLanePoints(Lane* l, const WayPoint&amp; prevWayPointIndex,
-			const double&amp; minDistance , const double&amp; prevCost, std::vector&lt;WayPoint&gt;&amp; points);
-
-	static WayPoint* GetMinCostCell(const std::vector&lt;WayPoint*&gt;&amp; cells, const std::vector&lt;int&gt;&amp; globalPathIds);
-
-	static void TraversePathTreeBackwards(WayPoint* pHead, WayPoint* pStartWP, const std::vector&lt;int&gt;&amp; globalPathIds,
-			std::vector&lt;WayPoint&gt;&amp; localPath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; localPaths);
-
-	static void ExtractPlanAlernatives(const std::vector&lt;WayPoint&gt;&amp; singlePath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; allPaths);
-
-	static std::vector&lt;int&gt; GetUniqueLeftRightIds(const std::vector&lt;WayPoint&gt;&amp; path);
-
-	static bool FindInList(const std::vector&lt;int&gt;&amp; list,const int&amp; x);
-	static void RemoveWithValue(std::vector&lt;int&gt;&amp; list,const int&amp; x);
-
-	static ACTION_TYPE GetBranchingDirection(WayPoint&amp; currWP, WayPoint&amp; nextWP);
-
-	static void CalcContourPointsForDetectedObjects(const WayPoint&amp; currPose, std::vector&lt;DetectedObject&gt;&amp; obj_list, const double&amp; filterDistance = 100);
-
-	static double GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; pose, const double&amp; distance);
-	static bool CompareTrajectories(const std::vector&lt;WayPoint&gt;&amp; path1, const std::vector&lt;WayPoint&gt;&amp; path2);
-
-	static double GetDistanceToClosestStopLineAndCheck(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; p, int&amp; stopLineID,int&amp; stopSignID, int&amp; trafficLightID, const int&amp; prevIndex = 0);
-
-	static void WritePathToFile(const std::string&amp; fileName, const std::vector&lt;WayPoint&gt;&amp; path);
-
-	static void TestQuadraticSpline(const std::vector&lt;WayPoint&gt;&amp; center_line, std::vector&lt;WayPoint&gt;&amp; path);
-	static double frunge ( double x );
-	static double fprunge ( double x );
-	static double fpprunge ( double x );
-
-};
-
-} /* namespace PlannerHNS */
-
-#endif /* PLANNINGHELPERS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\RSPlanner.h" new_path="" added_lines="0" deleted_lines="77">
				<diff>@@ -1,77 +0,0 @@
-/*
- * RSPlanner.h
- *
- *  Created on: Aug 9, 2015
- *      Author: hatem
- */
-
-#include "PlanningHelpers.h"
-#ifndef RSPLANNERSA_H_
-#define RSPLANNERSA_H_
-
-namespace PlannerHNS
-{
-
-#define EPS1 1.0e-12
-#define EPS2 1.0e-12
-#define EPS3 1.0e-12
-#define EPS4 1.0e-12
-#define MYINFINITY 1000000
-
-#define MPI 3.1415926536
-#define MPIMUL2 6.2831853072
-#define MPIDIV2 1.5707963268
-
-
-
-
-class RSPlanner
-{
-public:
-	double RADCURV ;
-	double RADCURVMUL2 ;
-	double RADCURVMUL4 ;
-	double SQRADCURV ;
-	double SQRADCURVMUL2 ;
-	double PATHDENSITY;
-	RSPlanner(double curvatureFactor = 15.6);
-	virtual ~RSPlanner();
-
-	double min_length_rs(const double&amp; x1,const double&amp; y1,const double&amp; t1,const double&amp; x2,const double&amp; y2,const double&amp; t2,int&amp; numero,double&amp; t,double&amp; u,double&amp; v);
-	int constRS(int num,double t,double u,double v,double x1,double y1,double t1,double delta,std::vector&lt;WayPoint&gt;&amp; path);
-
-private:
-	struct ConfigItem
-	{
-		double length;
-		int num;
-		double t,u,v;
-	};
-
-
-	double mod2pi(const double&amp; a);
-	double my_atan2(const double&amp;  y, const double&amp; x);
-	double c_c_c(const double&amp; x,const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_cc(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double cscb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double ccu_cuc(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_cucu_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2sca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2scb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double c_c2sc2_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double cc_c(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csc2_ca(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-	double csc2_cb(const double&amp; x, const double&amp; y,const double&amp; phi,const double&amp; rs,const double&amp; rc,double&amp; t,double&amp; u,double&amp; v);
-
-	double reed_shepp(const double&amp; x1,const double&amp; y1,const double&amp; t1,const double&amp; x2,const double&amp; y2,const double&amp; t2,int&amp; numero,double&amp; tr,double&amp; ur,double&amp; vr);
-
-	int fct_curve(const int&amp; ty,const int&amp; orientation,const double&amp; val,double&amp; x1,double&amp; y1,double&amp; t1,const double&amp; delta,std::vector&lt;WayPoint&gt;&amp; path,int n);
-
-
-
-};
-
-} /* namespace PlannerZNS */
-
-#endif /* RSPLANNER_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\RoadNetwork.h" new_path="" added_lines="0" deleted_lines="1018">
				<diff>@@ -1,1018 +0,0 @@
-/*
- * RoadNetwork.h
- *
- *  Created on: May 19, 2016
- *      Author: hatem
- */
-
-#ifndef ROADNETWORK_H_
-#define ROADNETWORK_H_
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;sstream&gt;
-#include "UtilityH.h"
-
-#define OPENPLANNER_ENABLE_LOGS
-
-namespace PlannerHNS
-{
-
-
-enum DIRECTION_TYPE {	FORWARD_DIR, FORWARD_LEFT_DIR, FORWARD_RIGHT_DIR,
-	BACKWARD_DIR, BACKWARD_LEFT_DIR, BACKWARD_RIGHT_DIR, STANDSTILL_DIR};
-
-enum OBSTACLE_TYPE {SIDEWALK, TREE, CAR, TRUCK, HOUSE, PEDESTRIAN, CYCLIST, GENERAL_OBSTACLE};
-
-enum DRIVABLE_TYPE {DIRT, TARMAC, PARKINGAREA, INDOOR, GENERAL_AREA};
-
-enum GLOBAL_STATE_TYPE {G_WAITING_STATE, G_PLANING_STATE, G_FORWARD_STATE, G_BRANCHING_STATE, G_FINISH_STATE};
-
-enum STATE_TYPE {INITIAL_STATE, WAITING_STATE, FORWARD_STATE, STOPPING_STATE, EMERGENCY_STATE,
-	TRAFFIC_LIGHT_STOP_STATE,TRAFFIC_LIGHT_WAIT_STATE, STOP_SIGN_STOP_STATE, STOP_SIGN_WAIT_STATE, FOLLOW_STATE, LANE_CHANGE_STATE, OBSTACLE_AVOIDANCE_STATE, GOAL_STATE, FINISH_STATE};
-
-enum LIGHT_INDICATOR {INDICATOR_LEFT, INDICATOR_RIGHT, INDICATOR_BOTH , INDICATOR_NONE};
-
-enum SHIFT_POS {SHIFT_POS_PP = 0x60, SHIFT_POS_RR = 0x40, SHIFT_POS_NN = 0x20,
-	SHIFT_POS_DD = 0x10, SHIFT_POS_BB = 0xA0, SHIFT_POS_SS = 0x0f, SHIFT_POS_UU = 0xff };
-
-enum ACTION_TYPE {FORWARD_ACTION, BACKWARD_ACTION, STOP_ACTION, LEFT_TURN_ACTION,
-	RIGHT_TURN_ACTION, U_TURN_ACTION, SWERVE_ACTION, OVERTACK_ACTION};
-
-
-class Lane;
-class TrafficLight;
-
-class ObjTimeStamp
-{
-public:
-	timespec tStamp;
-
-	ObjTimeStamp()
-	{
-		tStamp.tv_nsec = 0;
-		tStamp.tv_sec = 0;
-	}
-};
-
-class POINT2D
-{
-public:
-    double x;
-    double y;
-    double z;
-    POINT2D()
-    {
-      x=0;y=0;z=0;
-    }
-    POINT2D(double px, double py, double pz = 0)
-    {
-      x = px;
-      y = py;
-      z = pz;
-    }
-};
-
-
-
-class RECTANGLE
-
-{
-public:
-  POINT2D bottom_left;
-  POINT2D top_right;
-  double width;
-  double length;
-  bool bObstacle;
-
-
-  inline bool PointInRect(POINT2D p)
-  {
-    return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
-  }
-
-  inline bool HitTest(POINT2D p)
-  {
-    return PointInRect(p) &amp;&amp; bObstacle;
-  }
-
-  RECTANGLE()
-  {
-	  width=0;
-	  length = 0;
-    bObstacle = true;
-  }
-
-  virtual ~RECTANGLE(){}
-};
-
-class GPSPoint
-{
-public:
-	double lat, x;
-	double lon, y;
-	double alt, z;
-	double dir, a;
-
-	GPSPoint()
-	{
-		lat = x = 0;
-		lon = y = 0;
-		alt = z = 0;
-		dir = a = 0;
-	}
-
-	GPSPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
-	{
-		this-&gt;x = x;
-		this-&gt;y = y;
-		this-&gt;z = z;
-		this-&gt;a = a;
-
-		lat = 0;
-		lon = 0;
-		alt = 0;
-		dir = 0;
-	}
-
-	std::string ToString()
-	{
-		std::stringstream str;
-		str.precision(12);
-		str &lt;&lt; "X:" &lt;&lt; x &lt;&lt; ", Y:" &lt;&lt; y &lt;&lt; ", Z:" &lt;&lt; z &lt;&lt; ", A:" &lt;&lt; a &lt;&lt; std::endl;
-		str &lt;&lt; "Lon:" &lt;&lt; lon &lt;&lt; ", Lat:" &lt;&lt; lat &lt;&lt; ", Alt:" &lt;&lt; alt &lt;&lt; ", Dir:" &lt;&lt; dir &lt;&lt; std::endl;
-		return str.str();
-	}
-};
-
-class PolygonShape
-{
-public:
-	std::vector&lt;GPSPoint&gt; points;
-
-	inline int PointInsidePolygon(const PolygonShape&amp; polygon,const GPSPoint&amp; p)
-	{
-		int counter = 0;
-		  int i;
-		  double xinters;
-		  GPSPoint p1,p2;
-		  int N = polygon.points.size();
-		  if(N &lt;=0 ) return -1;
-
-		  p1 = polygon.points.at(0);
-		  for (i=1;i&lt;=N;i++)
-		  {
-		    p2 = polygon.points.at(i % N);
-
-		    if (p.y &gt; MIN(p1.y,p2.y))
-		    {
-		      if (p.y &lt;= MAX(p1.y,p2.y))
-		      {
-		        if (p.x &lt;= MAX(p1.x,p2.x))
-		        {
-		          if (p1.y != p2.y)
-		          {
-		            xinters = (p.y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
-		            if (p1.x == p2.x || p.x &lt;= xinters)
-		              counter++;
-		          }
-		        }
-		      }
-		    }
-		    p1 = p2;
-		  }
-
-		  if (counter % 2 == 0)
-		    return 0;
-		  else
-		    return 1;
-	}
-};
-
-class MapItem
-{
-public:
-  int id;
-  POINT2D sp; //start point
-  POINT2D ep; // end point
-  GPSPoint center;
-  double c; //curvature
-  double w; //width
-  double l; //length
-  std::string fileName; //
-  std::vector&lt;POINT2D&gt; polygon;
-
-
-  MapItem(int ID, POINT2D start, POINT2D end, double curvature, double width, double length, std::string objName)
-  {
-    id = ID;
-    sp = start;
-    ep = end;
-    c = curvature;
-    w = width;
-    l = length;
-    fileName = objName;
-
-  }
-
-  MapItem()
-  {
-    id = 0; c = 0; w = 0; l = 0;
-  }
-
-  virtual ~MapItem(){}
-
-  MapItem(const MapItem &amp; cmi)
-  {
-        id = cmi.id;
-        sp = cmi.sp;
-        ep = cmi.ep;
-        c = cmi.c;
-        w = cmi.w;
-        l = cmi.l;
-        fileName = cmi.fileName;
-  }
-  MapItem &amp;operator=(const MapItem &amp;cmi)
-  {
-    this-&gt;id = cmi.id;
-      this-&gt;sp = cmi.sp;
-      this-&gt;ep = cmi.ep;
-      this-&gt;c = cmi.c;
-      this-&gt;w = cmi.w;
-      this-&gt;l = cmi.l;
-      this-&gt;fileName = cmi.fileName;
-      return *this;
-  }
-
-  virtual int operator==(const MapItem &amp;mi) const
-    {
-      return this-&gt;id == mi.id;
-    }
-};
-
-class Obstacle : public MapItem
-{
-  public:
-    OBSTACLE_TYPE t;
-
-    Obstacle(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,OBSTACLE_TYPE type, std::string fileName ) : MapItem(ID, start, end, curvature, width, length, fileName)
-  {
-      t = type;
-  }
-    virtual ~Obstacle()
-    {
-    }
-
-    Obstacle() : MapItem()
-       {
-      t = SIDEWALK;
-       }
-
-    Obstacle(const Obstacle&amp; ob) : MapItem(ob)
-      {
-        t = ob.t;
-      }
-
-    Obstacle&amp; operator=(const Obstacle&amp; ob)
-      {
-      this-&gt;id = ob.id;
-      this-&gt;sp = ob.sp;
-      this-&gt;ep = ob.ep;
-      this-&gt;c = ob.c;
-      this-&gt;w = ob.w;
-      this-&gt;l = ob.l;
-      this-&gt;t = ob.t;
-      this-&gt;fileName = ob.fileName;
-      return *this;
-      }
-
-      virtual int operator==(const Obstacle &amp;ob) const
-          {
-            return this-&gt;id == ob.id &amp;&amp; this-&gt;t == ob.t;
-          }
-};
-
-class DrivableArea : public MapItem
-{
-public:
-  DRIVABLE_TYPE t; // drivable area type
-
-  DrivableArea(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,DRIVABLE_TYPE type, std::string fileName ) : MapItem( ID, start, end, curvature, width, length, fileName)
-  {
-    t = type;
-  }
-
-  virtual ~DrivableArea()
-  {
-
-  }
-
-  DrivableArea() : MapItem()
-    {
-      t = PARKINGAREA;
-    }
-
-  DrivableArea(const DrivableArea&amp; da) : MapItem(da)
-  {
-    t = da.t;
-  }
-
-  DrivableArea&amp; operator=(const DrivableArea&amp; da)
-  {
-    this-&gt;id = da.id;
-    this-&gt;sp = da.sp;
-    this-&gt;ep = da.ep;
-    this-&gt;c = da.c;
-    this-&gt;w = da.w;
-    this-&gt;l = da.l;
-    this-&gt;t = da.t;
-    this-&gt;fileName = da.fileName;
-    return *this;
-  }
-
-  virtual int operator==(const DrivableArea &amp;da) const
-      {
-        return this-&gt;id == da.id &amp;&amp; this-&gt;t == da.t;
-      }
-
-};
-
-
-
-class Rotation
-{
-public:
-	double x;
-	double y;
-	double z;
-	double w;
-
-	Rotation()
-	{
-		x = 0;
-		y = 0;
-		z = 0;
-		w = 0;
-	}
-};
-
-class WayPoint
-{
-public:
-	GPSPoint	pos;
-	Rotation 	rot;
-	double  	v;
-	double  	cost;
-	double  	timeCost;
-	double  	totalReward;
-	double  	collisionCost;
-	double 		laneChangeCost;
-	int 		laneId;
-	int 		id;
-	int 		LeftLaneId;
-	int 		RightLaneId;
-	int 		stopLineID;
-	DIRECTION_TYPE bDir;
-
-	Lane* pLane;
-	WayPoint* pLeft;
-	WayPoint* pRight;
-	std::vector&lt;int&gt; 	toIds;
-	std::vector&lt;int&gt; 	fromIds;
-	std::vector&lt;WayPoint*&gt; pFronts;
-	std::vector&lt;WayPoint*&gt; pBacks;
-	std::vector&lt;std::pair&lt;ACTION_TYPE, double&gt; &gt; actionCost;
-
-	WayPoint()
-	{
-		id = 0;
-		v = 0;
-		cost = 0;
-		laneId = -1;
-		pLane  = 0;
-		pLeft = 0;
-		pRight = 0;
-		bDir = FORWARD_DIR;
-		LeftLaneId = 0;
-		RightLaneId = 0;
-		timeCost = 0;
-		totalReward = 0;
-		collisionCost = 0;
-		laneChangeCost = 0;
-		stopLineID = -1;
-	}
-
-	WayPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
-	{
-		pos.x = x;
-		pos.y = y;
-		pos.z = z;
-		pos.a = a;
-
-		id = 0;
-		v = 0;
-		cost = 0;
-		laneId = -1;
-		pLane  = 0;
-		pLeft = 0;
-		pRight = 0;
-		bDir = FORWARD_DIR;
-		LeftLaneId = 0;
-		RightLaneId = 0;
-		timeCost = 0;
-		totalReward = 0;
-		collisionCost = 0;
-		laneChangeCost = 0;
-		stopLineID = -1;
-	}
-};
-
-class RelativeInfo
-{
-public:
-	double perp_distance;
-	double to_front_distance; //negative
-	double from_back_distance;
-	int iFront;
-	int iBack;
-	int iGlobalPath;
-	WayPoint perp_point;
-	double angle_diff; // degrees
-
-	RelativeInfo()
-	{
-		perp_distance = 0;
-		to_front_distance = 0;
-		from_back_distance = 0;
-		iFront = 0;
-		iBack = 0;
-		iGlobalPath = 0;
-		angle_diff = 0;
-	}
-};
-
-class StopLine
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-	int trafficLightID;
-	int stopSignID;
-	std::vector&lt;GPSPoint&gt; points;
-	Lane* pLane;
-
-	StopLine()
-	{
-		id    = 0;
-		laneId =0;
-		roadId =0;
-		pLane = 0;
-		trafficLightID = -1;
-		stopSignID = -1;
-	}
-};
-
-class WaitingLine
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-	std::vector&lt;GPSPoint&gt; points;
-	Lane* pLane;
-
-	WaitingLine()
-	{
-		id    = 0;
-		laneId =0;
-		roadId =0;
-		pLane = 0;
-	}
-};
-
-enum TrafficSignTypes {UNKNOWN_SIGN, STOP_SIGN, MAX_SPEED_SIGN, MIN_SPEED_SIGN};
-
-class TrafficSign
-{
-public:
-	int id;
-	int laneId;
-	int roadId;
-
-	GPSPoint pos;
-	TrafficSignTypes signType;
-	double value;
-	double fromValue;
-	double toValue;
-	std::string strValue;
-	timespec timeValue;
-	timespec fromTimeValue;
-	timespec toTimeValue;
-
-	Lane* pLane;
-
-	TrafficSign()
-	{
-		id    		= 0;
-		laneId 		= 0;
-		roadId		= 0;
-		signType  	= UNKNOWN_SIGN;
-		value		= 0;
-		fromValue	= 0;
-		toValue		= 0;
-//		timeValue	= 0;
-//		fromTimeValue = 0;
-//		toTimeValue	= 0;
-		pLane 		= 0;
-	}
-};
-
-enum TrafficLightState {UNKNOWN_LIGHT, RED_LIGHT, GREEN_LIGHT, YELLOW_LIGHT, LEFT_GREEN, FORWARD_GREEN, RIGHT_GREEN, FLASH_YELLOW, FLAH_RED};
-
-class TrafficLight
-{
-public:
-	int id;
-	GPSPoint pos;
-	TrafficLightState lightState;
-	double stoppingDistance;
-	std::vector&lt;int&gt; laneIds;
-	std::vector&lt;Lane*&gt; pLanes;
-
-	TrafficLight()
-	{
-		stoppingDistance = 2;
-		id 			= 0;
-		lightState	= GREEN_LIGHT;
-	}
-
-	bool CheckLane(const int&amp; laneId)
-	{
-		for(unsigned int i=0; i &lt; laneIds.size(); i++)
-		{
-			if(laneId == laneIds.at(i))
-				return true;
-		}
-		return false;
-	}
-};
-
-enum RoadSegmentType {NORMAL_ROAD, INTERSECTION_ROAD, UTURN_ROAD, EXIT_ROAD, MERGE_ROAD, HIGHWAY_ROAD};
-
-class RoadSegment
-{
-public:
-	int id;
-	RoadSegmentType roadType;
-	std::vector&lt;int&gt; fromIds;
-	std::vector&lt;int&gt; toIds;
-	std::vector&lt;Lane&gt; Lanes;
-
-
-	std::vector&lt;RoadSegment*&gt; fromLanes;
-	std::vector&lt;RoadSegment*&gt; toLanes;
-
-	RoadSegment()
-	{
-		id = 0;
-		roadType = NORMAL_ROAD;
-	}
-
-
-};
-
-enum LaneType{NORMAL_LANE, MERGE_LANE, EXIT_LANE, BUS_LANE, BUS_STOP_LANE, EMERGENCY_LANE};
-
-class Lane
-{
-public:
-	int id;
-	int roadId;
-	int areaId;
-	int fromAreaId;
-	int toAreaId;
-	std::vector&lt;int&gt; fromIds;
-	std::vector&lt;int&gt; toIds;
-	int num; //lane number in the road segment from left to right
-	double speed;
-	double length;
-	double dir;
-	LaneType type;
-	std::vector&lt;TrafficSign&gt; signs;
-	std::vector&lt;WayPoint&gt; points;
-	std::vector&lt;TrafficLight&gt; trafficlights;
-	std::vector&lt;StopLine&gt; stopLines;
-	WaitingLine waitingLine;
-
-	std::vector&lt;Lane*&gt; fromLanes;
-	std::vector&lt;Lane*&gt; toLanes;
-	Lane* pLeftLane;
-	Lane* pRightLane;
-
-	RoadSegment * pRoad;
-
-	Lane()
-	{
-		id 		= 0;
-		num		= 0;
-		speed 	= 0;
-		length 	= 0;
-		dir		= 0;
-		type 	= NORMAL_LANE;
-		pLeftLane = 0;
-		pRightLane = 0;
-		pRoad	= 0;
-		roadId = 0;
-		areaId = 0;
-		fromAreaId = 0;
-		toAreaId = 0;
-	}
-
-};
-
-class RoadNetwork
-{
-public:
-	std::vector&lt;RoadSegment&gt; roadSegments;
-	std::vector&lt;TrafficLight&gt; trafficLights;
-	std::vector&lt;StopLine&gt; stopLines;
-
-};
-
-class VehicleState : public ObjTimeStamp
-{
-public:
-	double speed;
-	double steer;
-	SHIFT_POS shift;
-
-	VehicleState()
-	{
-		speed = 0;
-		steer = 0;
-		shift = SHIFT_POS_NN;
-	}
-
-};
-
-class BehaviorState
-{
-public:
-	STATE_TYPE state;
-	double maxVelocity;
-	double minVelocity;
-	double stopDistance;
-	double followVelocity;
-	double followDistance;
-	LIGHT_INDICATOR indicator;
-	bool bNewPlan;
-
-
-	BehaviorState()
-	{
-		state = INITIAL_STATE;
-		maxVelocity = 0;
-		minVelocity = 0;
-		stopDistance = 0;
-		followVelocity = 0;
-		followDistance = 0;
-		indicator  = INDICATOR_NONE;
-		bNewPlan = false;
-
-	}
-
-};
-
-class DetectedObject
-{
-public:
-	int id;
-	OBSTACLE_TYPE t;
-	WayPoint center;
-	WayPoint predicted_center;
-	std::vector&lt;GPSPoint&gt; contour;
-	double w;
-	double l;
-	double h;
-	double distance_to_center;
-	DetectedObject()
-	{
-		id = 0;
-		w = 0;
-		l = 0;
-		h = 0;
-		t = GENERAL_OBSTACLE;
-		distance_to_center = 0;
-	}
-
-};
-
-class PlanningParams
-{
-public:
-	double 	maxSpeed;
-	double 	minSpeed;
-	double 	planningDistance;
-	double 	microPlanDistance;
-	double 	carTipMargin;
-	double 	rollInMargin;
-	double 	rollInSpeedFactor;
-	double 	pathDensity;
-	double 	rollOutDensity;
-	int 	rollOutNumber;
-	double 	horizonDistance;
-	double 	minFollowingDistance; //should be bigger than Distance to follow
-	double 	minDistanceToAvoid; // should be smaller than minFollowingDistance and larger than maxDistanceToAvoid
-	double	maxDistanceToAvoid; // should be smaller than minDistanceToAvoid
-	double 	speedProfileFactor;
-	double 	smoothingDataWeight;
-	double 	smoothingSmoothWeight;
-	double 	smoothingToleranceError;
-
-	double verticalSafetyDistance;
-	double horizontalSafetyDistancel;
-
-	bool 	enableLaneChange;
-	bool 	enableSwerving;
-	bool 	enableFollowing;
-	bool 	enableHeadingSmoothing;
-	bool 	enableTrafficLightBehavior;
-	bool 	enableStopSignBehavior;
-
-	bool 	enabTrajectoryVelocities;
-
-	PlanningParams()
-	{
-		maxSpeed 						= 3;
-		minSpeed 						= 0;
-		planningDistance 				= 10000;
-		microPlanDistance 				= 30;
-		carTipMargin					= 4.0;
-		rollInMargin					= 12.0;
-		rollInSpeedFactor				= 0.25;
-		pathDensity						= 0.25;
-		rollOutDensity					= 0.5;
-		rollOutNumber					= 4;
-		horizonDistance					= 120;
-		minFollowingDistance			= 35;
-		minDistanceToAvoid				= 15;
-		maxDistanceToAvoid				= 5;
-		speedProfileFactor				= 1.0;
-		smoothingDataWeight				= 0.45;
-		smoothingSmoothWeight			= 0.3;
-		smoothingToleranceError			= 0.05;
-
-		verticalSafetyDistance 			= 0.0;
-		horizontalSafetyDistancel		= 0.0;
-
-		enableHeadingSmoothing			= false;
-		enableSwerving 					= false;
-		enableFollowing					= false;
-		enableTrafficLightBehavior		= false;
-		enableLaneChange 				= false;
-		enableStopSignBehavior			= false;
-		enabTrajectoryVelocities		= false;
-	}
-};
-
-class HMIPreCalculatedConditions
-{
-public:
-
-	HMIPreCalculatedConditions()
-	{
-
-	}
-};
-
-class PreCalculatedConditions
-{
-public:
-	//-------------------------------------------//
-	//Global Goals
-	int 				currentGoalID;
-	int 				prevGoalID;
-	//-------------------------------------------//
-	//Following
-	double 				distanceToNext;
-	double				velocityOfNext;
-	//-------------------------------------------//
-	//For Lane Change
-	int 				iPrevSafeLane;
-	int 				iCurrSafeLane;
-	double				distanceToGoBack;
-	double 				timeToGoBack;
-	double 				distanceToChangeLane;
-	double				timeToChangeLane;
-	int 				currentLaneID;
-	int 				originalLaneID;
-	int 				targetLaneID;
-	bool 				bUpcomingLeft;
-	bool 				bUpcomingRight;
-	bool				bCanChangeLane;
-	bool				bTargetLaneSafe;
-	//-------------------------------------------//
-	//Traffic Lights &amp; Stop Sign
-	int 				currentStopSignID;
-	int 				prevStopSignID;
-	int 				currentTrafficLightID;
-	int 				prevTrafficLightID;
-	bool 				bTrafficIsRed; //On , off status
-	//-------------------------------------------//
-	//Swerving
-	int 				iPrevSafeTrajectory;
-	int 				iCurrSafeTrajectory;
-	int 				iCentralTrajectory;
-	bool				bFullyBlock;
-	LIGHT_INDICATOR 	indicator;
-
-	//-------------------------------------------//
-	//General
-	bool 				bNewGlobalPath;
-	bool 				bRePlan;
-	double 				currentVelocity;
-	double				minStoppingDistance; //comfortably
-	int 				bOutsideControl; // 0 waiting, 1 start, 2 Green Traffic Light, 3 Red Traffic Light, 5 Emergency Stop
-	bool				bGreenOutsideControl;
-	std::vector&lt;double&gt; stoppingDistances;
-
-
-	double distanceToStop()
-	{
-		if(stoppingDistances.size()==0) return 0;
-		double minS = stoppingDistances.at(0);
-		for(unsigned int i=0; i&lt; stoppingDistances.size(); i++)
-		{
-			if(stoppingDistances.at(i) &lt; minS)
-				minS = stoppingDistances.at(i);
-		}
-		return minS;
-	}
-
-	PreCalculatedConditions()
-	{
-		currentGoalID 			= 0;
-		prevGoalID				= -1;
-		currentVelocity 		= 0;
-		minStoppingDistance		= 1;
-		bOutsideControl			= 0;
-		bGreenOutsideControl	= false;
-		//distance to stop
-		distanceToNext			= -1;
-		velocityOfNext			= 0;
-		currentStopSignID		= -1;
-		prevStopSignID			= -1;
-		currentTrafficLightID	= -1;
-		prevTrafficLightID		= -1;
-		bTrafficIsRed			= false;
-		iCurrSafeTrajectory		= -1;
-		bFullyBlock				= false;
-
-		iPrevSafeTrajectory		= -1;
-		iCentralTrajectory		= -1;
-		bRePlan					= false;
-		bNewGlobalPath			= false;
-
-		bCanChangeLane			= false;
-		distanceToGoBack		= 0;
-		timeToGoBack			= 0;
-		distanceToChangeLane	= 0;
-		timeToChangeLane		= 0;
-		bTargetLaneSafe			= true;
-		bUpcomingLeft			= false;
-		bUpcomingRight			= false;
-		targetLaneID			= -1;
-		currentLaneID			= -1;
-		originalLaneID			= -1;
-		iCurrSafeLane 			= -1;
-		iPrevSafeLane			= -1;
-
-		indicator 				= INDICATOR_NONE;
-	}
-
-	virtual ~PreCalculatedConditions(){}
-
-	std::string ToStringHeader()
-	{
-		return "Time:General&gt;&gt;:currentVelocity:distanceToStop:minStoppingDistance:bStartBehaviorGenerator:bGoalReached:"
-				"Following&gt;&gt;:velocityOfNext:distanceToNext:"
-				"TrafficLight&gt;&gt;:currentTrafficLightID:bTrafficIsRed:"
-				"Swerving&gt;&gt;:iSafeTrajectory:bFullyBlock:";
-	}
-
-	std::string ToString(STATE_TYPE beh)
-	{
-		std::string str = "Unknown";
-		switch(beh)
-		{
-		case PlannerHNS::INITIAL_STATE:
-			str = "Init";
-			break;
-		case PlannerHNS::WAITING_STATE:
-			str = "Waiting";
-			break;
-		case PlannerHNS::FORWARD_STATE:
-			str = "Forward";
-			break;
-		case PlannerHNS::STOPPING_STATE:
-			str = "Stop";
-			break;
-		case PlannerHNS::FINISH_STATE:
-			str = "End";
-			break;
-		case PlannerHNS::FOLLOW_STATE:
-			str = "Follow";
-			break;
-		case PlannerHNS::OBSTACLE_AVOIDANCE_STATE:
-			str = "Swerving";
-			break;
-		case PlannerHNS::TRAFFIC_LIGHT_STOP_STATE:
-			str = "Light Stop";
-			break;
-		case PlannerHNS::TRAFFIC_LIGHT_WAIT_STATE:
-			str = "Light Wait";
-			break;
-		case PlannerHNS::STOP_SIGN_STOP_STATE:
-			str = "Sign Stop";
-			break;
-		case PlannerHNS::STOP_SIGN_WAIT_STATE:
-			str = "Sign Wait";
-			break;
-		default:
-			str = "Unknown";
-			break;
-		}
-
-		return str;
-	}
-};
-
-class TrajectoryCost
-{
-public:
-	int index;
-	int relative_index;
-	double closest_obj_velocity;
-	double distance_from_center;
-	double priority_cost; //0 to 1
-	double transition_cost; // 0 to 1
-	double closest_obj_cost; // 0 to 1
-	double cost;
-	double closest_obj_distance;
-
-	int lane_index;
-	double lane_change_cost;
-	double lateral_cost;
-	double longitudinal_cost;
-	bool bBlocked;
-	std::vector&lt;std::pair&lt;int, double&gt; &gt; lateral_costs;
-
-
-	TrajectoryCost()
-	{
-		lane_index = -1;
-		index = -1;
-		relative_index = -100;
-		closest_obj_velocity = 0;
-		priority_cost = 0;
-		transition_cost = 0;
-		closest_obj_cost = 0;
-		distance_from_center = 0;
-		cost = 0;
-		closest_obj_distance = -1;
-		lane_change_cost = 0;
-		lateral_cost = 0;
-		longitudinal_cost = 0;
-		bBlocked = false;
-	}
-
-	std::string ToString()
-	{
-		std::ostringstream str;
-		str.precision(4);
-		str &lt;&lt; "LaneIndex    : " &lt;&lt; lane_index;
-		str &lt;&lt; ", Index      : " &lt;&lt; relative_index;
-		str &lt;&lt; ", TotalCost  : " &lt;&lt; cost;
-		str &lt;&lt; ", Priority   : " &lt;&lt; priority_cost;
-		str &lt;&lt; ", Transition : " &lt;&lt; transition_cost;
-		str &lt;&lt; ", Lateral    : " &lt;&lt; lateral_cost;
-		str &lt;&lt; ", Longitu    : " &lt;&lt; longitudinal_cost;
-		str &lt;&lt; ", LaneChange : " &lt;&lt; lane_change_cost;
-		str &lt;&lt; ", Blocked    : " &lt;&lt; bBlocked;
-		str &lt;&lt; "\n";
-		for (unsigned int i=0; i&lt;lateral_costs.size(); i++ )
-		{
-			str &lt;&lt; " - (" &lt;&lt; lateral_costs.at(i).first &lt;&lt; ", " &lt;&lt; lateral_costs.at(i).second &lt;&lt; ")";
-		}
-
-		return str.str();
-
-	}
-};
-
-}
-
-
-#endif /* ROADNETWORK_H_ */
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\TrajectoryCosts.h" new_path="" added_lines="0" deleted_lines="50">
				<diff>@@ -1,50 +0,0 @@
-/*
- * TrajectoryCosts.h
- *
- *  Created on: Dec 14, 2016
- *      Author: user
- */
-
-#ifndef TRAJECTORYCOSTS_H_
-#define TRAJECTORYCOSTS_H_
-
-#include "RoadNetwork.h"
-#include "PlannerCommonDef.h"
-#include "PlanningHelpers.h"
-
-using namespace std;
-
-namespace PlannerHNS
-{
-
-class TrajectoryCosts
-{
-public:
-	TrajectoryCosts();
-	virtual ~TrajectoryCosts();
-
-	TrajectoryCost DoOneStep(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths,
-			const WayPoint&amp; currState, const int&amp; currTrajectoryIndex, const int&amp; currLaneIndex, const PlanningParams&amp; params,
-			const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
-
-public:
-	int m_PrevCostIndex;
-	vector&lt;TrajectoryCost&gt; m_TrajectoryCosts;
-	PlanningParams m_Params;
-	PolygonShape m_SafetyBorder;
-	//vector&lt;GPSPoint&gt; m_SafetyBox;
-
-
-
-private:
-	bool ValidateRollOutsInput(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts);
-	vector&lt;TrajectoryCost&gt; CalculatePriorityAndLaneChangeCosts(const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; laneRollOuts, const int&amp; lane_index, const PlanningParams&amp; params);
-	void NormalizeCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts);
-	void CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths, const WayPoint&amp; currState, const vector&lt;WayPoint&gt;&amp; contourPoints, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState);
-	void CalculateTransitionCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const int&amp; currTrajectoryIndex, const PlanningParams&amp; params);
-
-};
-
-}
-
-#endif /* TRAJECTORYCOSTS_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\include\UtilityH.h" new_path="" added_lines="0" deleted_lines="115">
				<diff>@@ -1,115 +0,0 @@
-/*
- * UtilityH.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#ifndef UTILITYH_H_
-#define UTILITYH_H_
-
-#include &lt;assert.h&gt;
-#include &lt;math.h&gt;
-#include &lt;string&gt;
-
-
-namespace UtilityHNS
-{
-
-#define DEG2RAD M_PI / 180.
-#define RAD2DEG 180. / M_PI
-#define sign(x) (x &gt; 0) ? 1 : ((x &lt; 0) ? -1 : 0)
-#define MIN(x,y) (x &lt;= y ? x : y)
-#define MAX(x,y) (x &gt;= y ? x : y)
-
-
-class UtilityH
-{
-public:
-	UtilityH();
-	virtual ~UtilityH(); 
-
-
-	static double FixNegativeAngle(const double&amp; a);
-	static double SplitPositiveAngle(const double&amp; a);
-	static double InverseAngle(const double&amp; a);
-	static double AngleBetweenTwoAnglesPositive(const double&amp; a1, const double&amp; a2);
-	static double GetCircularAngle(const double&amp; prevContAngle, const double&amp; prevAngle, const double&amp; currAngle);
-
-	//Time Functions
-	static void GetTickCount(struct timespec&amp; t);
-	static std::string GetFilePrefixHourMinuteSeconds();
-	static double GetTimeDiffNow(const struct timespec&amp; old_t);
-	static double GetTimeDiff(const struct timespec&amp; old_t,const struct timespec&amp; curr_t);
-	static std::string GetDateTimeStr();
-	static int tsCompare (struct  timespec  time1,   struct  timespec  time2, int micro_tolerance = 10);
-	static int GetSign(double x);
-	static std::string GetHomeDirectory();
-	static double GetMomentumScaleFactor(const double&amp; v);
-	static timespec GetTimeSpec(const time_t&amp; srcT);
-	static time_t GetLongTime(const struct timespec&amp; srcT);
-};
-
-class PIDController
-{
-public:
-	PIDController();
-	PIDController(const double&amp; kp, const double&amp; ki, const double&amp; kd);
-	void Init(const double&amp; kp, const double&amp; ki, const double&amp; kd);
-	void Setlimit(const double&amp; upper,const double&amp; lower);
-	double getPID(const double&amp; currValue, const double&amp; targetValue);
-	double getPID(const double&amp; e);
-	void ResetD();
-	void ResetI();
-	std::string ToString();
-	std::string ToStringHeader();
-
-
-private:
-	double kp;
-	double ki;
-	double kd;
-	double kp_v;
-	double ki_v;
-	double kd_v;
-	double pid_v;
-	double pid_lim;
-	double upper_limit;
-	double lower_limit;
-	bool   bEnableLimit;
-	double accumErr;
-	double prevErr;
-	bool bResetD;
-	bool bResetI;
-
-};
-
-class LowpassFilter
-{
-public:
-	LowpassFilter();
-	virtual ~LowpassFilter();
-
-	LowpassFilter(const int&amp; filterOrder, const double&amp; sampleFreq, const double&amp; cutOffFreq);
-	void Init(const int&amp; filterOrder, const double&amp; sampleFreq, const double&amp; cutOffFreq);
-	double getFilter(const double&amp; value);
-
-
-private:
-	int m;
-	double sampleF;
-	double cutOffF;
-	double A  ;
-	double d1 ;
-	double d2 ;
-	double w0 ;
-	double w1 ;
-	double w2 ;
-
-};
-
-}
-
-#endif
-
-
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4a39ea095b60d74f40ca3f3bae0715c14b294a66" author="Yusuke FUJII">
		<msg>fix a math library compatibility</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\MappingHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\MappingHelpers.h" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
 #ifndef MAPPINGHELPERS_H_
 #define MAPPINGHELPERS_H_
 
-#include &lt;cmath&gt;
+#include &lt;math.h&gt;
 #include "RoadNetwork.h"
 #include "UtilityH.h"
 #include "DataRW.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\MatrixOperations.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\MatrixOperations.h" added_lines="1" deleted_lines="1">
				<diff>@@ -9,7 +9,7 @@
 #define MATRIXOPERATIONS_H_
 
 #include "RoadNetwork.h"
-#include &lt;cmath&gt;
+#include &lt;math.h&gt;
 
 
 namespace PlannerHNS {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\PlannerCommonDef.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\PlannerCommonDef.h" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
 #ifndef PLANNERCOMMONDEF_H_
 #define PLANNERCOMMONDEF_H_
 
-#include &lt;cmath&gt;
+#include &lt;math.h&gt;
 #include &lt;string&gt;
 
 namespace PlannerHNS
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\PlanningHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\PlanningHelpers.h" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
 #ifndef PLANNINGHELPERS_H_
 #define PLANNINGHELPERS_H_
 
-#include &lt;cmath&gt;
+#include &lt;math.h&gt;
 #include "RoadNetwork.h"
 #include "UtilityH.h"
 #include "DataRW.h"
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\geo_pos_conv.hh" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\geo_pos_conv.hh" added_lines="1" deleted_lines="1">
				<diff>@@ -1,7 +1,7 @@
 #ifndef __GEO_POS_CONV__
 #define __GEO_POS_CONV__
 
-#include &lt;cmath&gt;
+#include &lt;math.h&gt;
 
 class geo_pos_conv {
 private:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\LocalPlannerH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\LocalPlannerH.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -159,7 +159,7 @@ void LocalPlannerH::InitPolygons()
 		 double diff = desiredSteerDeg - currSteerDeg;
 		 double diffSign = UtilityH::GetSign(diff);
 		 double inc = 1.0*diffSign;
-		 if(abs(diff) &lt; 1.0 )
+		 if(fabs(diff) &lt; 1.0 )
 			 inc = diff;
 
 //		 std::cout &lt;&lt; "Delay: " &lt;&lt; m_SimulationSteeringDelayFactor
@@ -515,7 +515,7 @@ bool LocalPlannerH::CalculateIntersectionVelocities(std::vector&lt;PlannerHNS::WayP
 				{
 					double collision_distance = hypot(ego_path.at(i).pos.x-predctedPath.at(k).at(j).pos.x, ego_path.at(i).pos.y-predctedPath.at(k).at(j).pos.y);
 					double contact_distance = hypot(state.pos.x - ego_path.at(i).pos.x,state.pos.y - ego_path.at(i).pos.y);
-					if(collision_distance &lt;= m_CarInfo.width  &amp;&amp; abs(ego_path.at(i).timeCost - predctedPath.at(k).at(j).timeCost)&lt;4.0)
+					if(collision_distance &lt;= m_CarInfo.width  &amp;&amp; fabs(ego_path.at(i).timeCost - predctedPath.at(k).at(j).timeCost)&lt;4.0)
 					{
 						ego_path.at(i).collisionCost = 1;
 						double a = UtilityH::AngleBetweenTwoAnglesPositive(ego_path.at(i).pos.a, predctedPath.at(k).at(j).pos.a);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\PlanningHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\PlanningHelpers.cpp" added_lines="0" deleted_lines="2">
				<diff>@@ -15,8 +15,6 @@
 using namespace UtilityHNS;
 using namespace std;
 
-
-
 namespace PlannerHNS {
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\SimpleTracker.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\SimpleTracker.h" added_lines="1" deleted_lines="1">
				<diff>@@ -12,7 +12,7 @@
 #include "opencv2/video/tracking.hpp"
 #include &lt;vector&gt;
 #include "UtilityH.h"
-#include &lt;cmath&gt;
+#include &lt;math.h&gt;
 #include &lt;iostream&gt;
 
 namespace SimulationNS
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\DrawingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\DrawingHelpers.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
 #include "DrawingHelpers.h"
 #include &lt;stdarg.h&gt;
 #include &lt;stdio.h&gt;
-#include &lt;math.h&gt;
+#include &lt;cmath&gt;
 #include "UtilityH.h"
 #include "PlanningHelpers.h"
 #include &lt;GL/freeglut.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\MainWindowWrapper.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\MainWindowWrapper.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
 #include "MainWindowWrapper.h"
 #include "DrawingHelpers.h"
 #include &lt;iostream&gt;
-#include &lt;math.h&gt;
+#include &lt;cmath&gt;
 #include "UtilityH.h"
 #include "GL/freeglut_ext.h"
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\SimulatedTrajectoryFollower.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\SimulatedTrajectoryFollower.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -7,7 +7,7 @@
 
 #include "SimulatedTrajectoryFollower.h"
 #include "PlanningHelpers.h"
-#include &lt;math.h&gt;
+#include &lt;cmath&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;iostream&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\TrajectoryFollower.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\TrajectoryFollower.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -7,7 +7,7 @@
 
 #include "TrajectoryFollower.h"
 #include "PlanningHelpers.h"
-#include &lt;math.h&gt;
+#include &lt;cmath&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;iostream&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utilityh\src\UtilityH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_utilityh\src\UtilityH.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -6,7 +6,6 @@
  */
 
 #include "UtilityH.h"
-#include &lt;math.h&gt;
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;
 #include &lt;string.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" added_lines="2" deleted_lines="2">
				<diff>@@ -64,11 +64,11 @@
 #include "RosHelpers.h"
 #include "SimpleTracker.h"
 
-#include &lt;cv.h&gt;
+#include &lt;opencv/cv.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;opencv2/objdetect/objdetect.hpp&gt;
-#include &lt;highgui.h&gt;
+#include &lt;opencv/highgui.h&gt;
 #include &lt;opencv2/imgproc/imgproc.hpp&gt;
 
 #if (CV_MAJOR_VERSION &lt; 3)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="af6ff2a699e2dbe5af31adf9587ef829479ab2d1" author="YamatoAndo">
		<msg>not use imu linear accleration y and z</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="11" deleted_lines="22">
				<diff>@@ -88,7 +88,6 @@ static ros::Duration scan_duration;
 
 static double diff = 0.0;
 static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw; // current_pose - previous_pose
-static double offset_x, offset_y, offset_z, offset_roll, offset_pitch, offset_yaw;
 static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
 static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
 static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch, offset_imu_odom_yaw;
@@ -381,8 +380,10 @@ static void imu_callback(const sensor_msgs::Imu::ConstPtr&amp; input)
 
   imu.header = input-&gt;header;
   imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
-  imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
-  imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
+  //imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
+  //imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
+  imu.linear_acceleration.y = 0;
+  imu.linear_acceleration.z = 0;
 
   if(diff_time != 0)
   {
@@ -493,6 +494,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   else
     guess_pose_for_ndt = guess_pose;
 
+
   Eigen::AngleAxisf init_rotation_x(guess_pose_for_ndt.roll, Eigen::Vector3f::UnitX());
   Eigen::AngleAxisf init_rotation_y(guess_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());
   Eigen::AngleAxisf init_rotation_z(guess_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());
@@ -617,12 +619,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   previous_scan_time.sec = current_scan_time.sec;
   previous_scan_time.nsec = current_scan_time.nsec;
   
-  offset_x = 0.0;
-  offset_y = 0.0;
-  offset_z = 0.0;
-  offset_roll = 0.0;
-  offset_pitch = 0.0;
-  offset_yaw = 0.0;
 
   offset_imu_x = 0.0;
   offset_imu_y = 0.0;
@@ -732,13 +728,6 @@ int main(int argc, char** argv)
   guess_pose.pitch = 0.0;
   guess_pose.yaw = 0.0;
 
-  guess_pose_imu.x = 0.0;
-  guess_pose_imu.y = 0.0;
-  guess_pose_imu.z = 0.0;
-  guess_pose_imu.roll = 0.0;
-  guess_pose_imu.pitch = 0.0;
-  guess_pose_imu.yaw = 0.0;
-
   added_pose.x = 0.0;
   added_pose.y = 0.0;
   added_pose.z = 0.0;
@@ -746,12 +735,10 @@ int main(int argc, char** argv)
   added_pose.pitch = 0.0;
   added_pose.yaw = 0.0;
 
-  offset_x = 0.0;
-  offset_y = 0.0;
-  offset_z = 0.0;
-  offset_roll = 0.0;
-  offset_pitch = 0.0;
-  offset_yaw = 0.0;
+  diff_x = 0.0;
+  diff_y = 0.0;
+  diff_z = 0.0;
+  diff_yaw = 0.0;
 
   offset_imu_x = 0.0;
   offset_imu_y = 0.0;
@@ -785,6 +772,8 @@ int main(int argc, char** argv)
   private_nh.getParam("use_odom", _use_odom);
 
   std::cout &lt;&lt; "use_openmp: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
+  std::cout &lt;&lt; "use_imu: " &lt;&lt; _use_imu &lt;&lt; std::endl;
+  std::cout &lt;&lt; "use_odom: " &lt;&lt; _use_odom &lt;&lt; std::endl;
 
   if (nh.getParam("tf_x", _tf_x) == false)
   {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="34" deleted_lines="3">
				<diff>@@ -303,6 +303,22 @@ static void param_callback(const runtime_manager::ConfigNdt::ConstPtr&amp; input)
     current_pose.pitch = initial_pose.pitch;
     current_pose.yaw = initial_pose.yaw;
 
+    current_velocity = 0;
+    current_velocity_x = 0;
+    current_velocity_y = 0;
+    current_velocity_z = 0;
+    angular_velocity = 0;
+
+    current_pose_imu.x = 0;
+    current_pose_imu.y = 0;
+    current_pose_imu.z = 0;
+    current_pose_imu.roll = 0;
+    current_pose_imu.pitch = 0;
+    current_pose_imu.yaw = 0;
+
+    current_velocity_imu_x = current_velocity_x;
+    current_velocity_imu_y = current_velocity_y;
+    current_velocity_imu_z = current_velocity_z;
     init_pos_set = 1;
   }
 }
@@ -650,8 +666,10 @@ static void imu_callback(const sensor_msgs::Imu::ConstPtr&amp; input)
 
   imu.header = input-&gt;header;
   imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
-  imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
-  imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
+  //imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
+  //imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
+  imu.linear_acceleration.y = 0;
+  imu.linear_acceleration.z = 0;
 
   if(diff_time != 0)
   {
@@ -1106,6 +1124,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       exit(1);
     }
     static ros::Time start_time = input-&gt;header.stamp;
+/*
     ofs &lt;&lt; input-&gt;header.seq &lt;&lt; "," &lt;&lt; input-&gt;header.stamp &lt;&lt; "," &lt;&lt; input-&gt;header.stamp - start_time &lt;&lt; scan_points_num &lt;&lt; "," &lt;&lt; step_size &lt;&lt; "," &lt;&lt; trans_eps &lt;&lt; "," &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; "," &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; ","
         &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; "," &lt;&lt; current_pose.roll &lt;&lt; "," &lt;&lt; current_pose.pitch
@@ -1134,7 +1153,19 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
         &lt;&lt; current_pose.z - predict_pose_imu_odom.z &lt;&lt; "," &lt;&lt; current_pose.roll - predict_pose_imu_odom.roll &lt;&lt; ","
         &lt;&lt; current_pose.pitch - predict_pose_imu_odom.pitch &lt;&lt; "," &lt;&lt; current_pose.yaw - predict_pose_imu_odom.yaw &lt;&lt; ","
         &lt;&lt; std::endl;
-
+*/
+    ofs &lt;&lt; input-&gt;header.seq &lt;&lt; "," &lt;&lt; scan_points_num &lt;&lt; "," &lt;&lt; step_size &lt;&lt; "," &lt;&lt; trans_eps &lt;&lt; "," &lt;&lt; std::fixed
+        &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; "," &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; ","
+        &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; "," &lt;&lt; current_pose.roll &lt;&lt; "," &lt;&lt; current_pose.pitch
+        &lt;&lt; "," &lt;&lt; current_pose.yaw &lt;&lt; "," &lt;&lt; predict_pose.x &lt;&lt; "," &lt;&lt; predict_pose.y &lt;&lt; "," &lt;&lt; predict_pose.z &lt;&lt; ","
+        &lt;&lt; predict_pose.roll &lt;&lt; "," &lt;&lt; predict_pose.pitch &lt;&lt; "," &lt;&lt; predict_pose.yaw &lt;&lt; ","
+        &lt;&lt; current_pose.x - predict_pose.x &lt;&lt; "," &lt;&lt; current_pose.y - predict_pose.y &lt;&lt; ","
+        &lt;&lt; current_pose.z - predict_pose.z &lt;&lt; "," &lt;&lt; current_pose.roll - predict_pose.roll &lt;&lt; ","
+        &lt;&lt; current_pose.pitch - predict_pose.pitch &lt;&lt; "," &lt;&lt; current_pose.yaw - predict_pose.yaw &lt;&lt; ","
+        &lt;&lt; predict_pose_error &lt;&lt; "," &lt;&lt; iteration &lt;&lt; "," &lt;&lt; fitness_score &lt;&lt; "," &lt;&lt; trans_probability &lt;&lt; ","
+        &lt;&lt; ndt_reliability.data &lt;&lt; "," &lt;&lt; current_velocity &lt;&lt; "," &lt;&lt; current_velocity_smooth &lt;&lt; "," &lt;&lt; current_accel
+        &lt;&lt; "," &lt;&lt; angular_velocity &lt;&lt; "," &lt;&lt; time_ndt_matching.data &lt;&lt; "," &lt;&lt; align_time &lt;&lt; "," &lt;&lt; getFitnessScore_time
+        &lt;&lt; std::endl;
 
     std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
     std::cout &lt;&lt; "Sequence: " &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="155aa7c330a169613aa1c73daa3a0df498b430f5" author="yukitsuji">
		<msg>Rename data processor to data preprocessor, and rename package and dependency</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\dataprocess\nodes\get_Depth\get_Depth.cpp" new_path="ros\src\util\packages\data_preprocessor\nodes\get_Depth\get_Depth.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 #include "get_Depth.hpp"
-// catkin_create_pkg dataprocess pcd_tutorial std_msgs roscpp pcl_ros pcl_msgs pcl_conversions libpcl-all-dev cv_bridge
+// catkin_create_pkg data_preprocessor pcd_tutorial std_msgs roscpp pcl_ros pcl_msgs pcl_conversions libpcl-all-dev cv_bridge
 
 // static cv::Mat CameraExtrinsicMat;
 // static cv::Mat CameraMat;
@@ -9,7 +9,7 @@
 static void check_arguments(int argc, char* argv[])
 {
   if (argc != 5){
-    cout &lt;&lt; "Please set arguments like below\n'rosrun dataprocess get_PCD save_dir topic_name'\n";
+    cout &lt;&lt; "Please set arguments like below\n'rosrun data_preprocessor get_PCD save_dir topic_name'\n";
     exit(EXIT_FAILURE);
   }
 }
</diff>
			</file>
			<file old_path="ros\src\util\packages\dataprocess\nodes\get_Depth\get_Depth.hpp" new_path="ros\src\util\packages\data_preprocessor\nodes\get_Depth\get_Depth.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\util\packages\dataprocess\scripts\get_Image.cpp" new_path="ros\src\util\packages\data_preprocessor\nodes\get_Image\get_Image.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -3,7 +3,7 @@
 static void check_arguments(int argc, char* argv[])
 {
   if (argc != 3){
-    cout &lt;&lt; "Please set arguments like below\n'rosrun dataprocess get_Image save_dir topic_name'\n";
+    cout &lt;&lt; "Please set arguments like below\n'rosrun data_preprocessor get_Image save_dir topic_name'\n";
     exit(EXIT_FAILURE);
   }
 }
</diff>
			</file>
			<file old_path="ros\src\util\packages\dataprocess\nodes\get_Image\get_Image.hpp" new_path="ros\src\util\packages\data_preprocessor\nodes\get_Image\get_Image.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\util\packages\dataprocess\nodes\get_PCD\get_PCD.cpp" new_path="ros\src\util\packages\data_preprocessor\nodes\get_PCD\get_PCD.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -5,7 +5,7 @@ static void check_arguments(int argc, char* argv[])
 {
   cout &lt;&lt; "Fuck you" &lt;&lt; endl;
   if (argc != 3){
-    cout &lt;&lt; "Please set arguments like below\n'rosrun dataprocess get_PCD save_dir topic_name'\n";
+    cout &lt;&lt; "Please set arguments like below\n'rosrun data_preprocessor get_PCD save_dir topic_name'\n";
     exit(EXIT_FAILURE);
   }
 }
</diff>
			</file>
			<file old_path="ros\src\util\packages\dataprocess\nodes\get_PCD\get_PCD.hpp" new_path="ros\src\util\packages\data_preprocessor\nodes\get_PCD\get_PCD.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\util\packages\dataprocess\scripts\get_Depth.cpp" new_path="ros\src\util\packages\data_preprocessor\scripts\get_Depth.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 #include "get_Depth.hpp"
-// catkin_create_pkg dataprocess pcd_tutorial std_msgs roscpp pcl_ros pcl_msgs pcl_conversions libpcl-all-dev cv_bridge
+// catkin_create_pkg data_preprocessor pcd_tutorial std_msgs roscpp pcl_ros pcl_msgs pcl_conversions libpcl-all-dev cv_bridge
 
 // static cv::Mat CameraExtrinsicMat;
 // static cv::Mat CameraMat;
@@ -9,7 +9,7 @@
 static void check_arguments(int argc, char* argv[])
 {
   if (argc != 5){
-    cout &lt;&lt; "Please set arguments like below\n'rosrun dataprocess get_PCD save_dir topic_name'\n";
+    cout &lt;&lt; "Please set arguments like below\n'rosrun data_preprocessor get_PCD save_dir topic_name'\n";
     exit(EXIT_FAILURE);
   }
 }
</diff>
			</file>
			<file old_path="ros\src\util\packages\dataprocess\scripts\get_Depth.hpp" new_path="ros\src\util\packages\data_preprocessor\scripts\get_Depth.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\util\packages\dataprocess\nodes\get_Image\get_Image.cpp" new_path="ros\src\util\packages\data_preprocessor\scripts\get_Image.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -3,7 +3,7 @@
 static void check_arguments(int argc, char* argv[])
 {
   if (argc != 3){
-    cout &lt;&lt; "Please set arguments like below\n'rosrun dataprocess get_Image save_dir topic_name'\n";
+    cout &lt;&lt; "Please set arguments like below\n'rosrun data_preprocessor get_Image save_dir topic_name'\n";
     exit(EXIT_FAILURE);
   }
 }
</diff>
			</file>
			<file old_path="ros\src\util\packages\dataprocess\scripts\get_Image.hpp" new_path="ros\src\util\packages\data_preprocessor\scripts\get_Image.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\util\packages\dataprocess\scripts\get_PCD.cpp" new_path="ros\src\util\packages\data_preprocessor\scripts\get_PCD.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -5,7 +5,7 @@ static void check_arguments(int argc, char* argv[])
 {
   cout &lt;&lt; "Fuck you" &lt;&lt; endl;
   if (argc != 3){
-    cout &lt;&lt; "Please set arguments like below\n'rosrun dataprocess get_PCD save_dir topic_name'\n";
+    cout &lt;&lt; "Please set arguments like below\n'rosrun data_preprocessor get_PCD save_dir topic_name'\n";
     exit(EXIT_FAILURE);
   }
 }
</diff>
			</file>
			<file old_path="ros\src\util\packages\dataprocess\scripts\get_PCD.hpp" new_path="ros\src\util\packages\data_preprocessor\scripts\get_PCD.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d341c9a7a8a2a1c63b790726a96458ec4cbb1a1f" author="Yusuke FUJII">
		<msg>fix a build issue for kinetic</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_lane.cpp" new_path="ros\src\computing\perception\detection\packages\integrated_viewer\node\image_viewer_plugin\draw_lane.cpp" added_lines="2" deleted_lines="3">
				<diff>@@ -1,10 +1,9 @@
 #include "draw_lane.h"
 
+#include &lt;opencv/cv.hpp&gt;
 #include &lt;opencv2/core/version.hpp&gt;
 
-#if (CV_MAJOR_VERSION == 3)
-#include "gencolors.cpp"
-#else
+#if (CV_MAJOR_VERSION != 3)
 #include &lt;opencv2/contrib/contrib.hpp&gt;
 #endif
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="96e02231a241f3e4aa736826b1ef6654bdba3f32" author="Yusuke FUJII">
		<msg>fixed build issues</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -26,7 +26,6 @@
 #include &lt;pcl/segmentation/sac_segmentation.h&gt;
 #include &lt;pcl/segmentation/extract_clusters.h&gt;
 #include &lt;pcl/segmentation/conditional_euclidean_clustering.h&gt;
-#include &lt;pcl/segmentation/progressive_morphological_filter.h&gt;
 
 #include &lt;pcl/common/common.h&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\svm_lidar_detect\svm_lidar_detect.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\svm_lidar_detect\svm_lidar_detect.cpp" added_lines="3" deleted_lines="0">
				<diff>@@ -26,7 +26,10 @@
 
 #include &lt;opencv/cv.h&gt;
 #include &lt;opencv/highgui.h&gt;
+
+#if(CV_MAJOR_VERSION !=3)
 #include &lt;opencv2/contrib/contrib.hpp&gt;
+#endif
 
 class SvmDetect
 {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b5496a19d25c6eeffe8086c73d8ce6140d2b2c8e" author="hatem-darweesh">
		<msg>Change OpenPlanner stand alone libraries names.</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\default.rviz" new_path="ros\src\.config\rviz\default.rviz" added_lines="23" deleted_lines="14">
				<diff>@@ -75,7 +75,9 @@ Visualization Manager:
       Tree:
         world:
           map:
-            {}
+            base_link:
+              velodyne:
+                {}
       Update Interval: 0
       Value: true
     - Alpha: 0.05
@@ -332,18 +334,23 @@ Visualization Manager:
     - Alpha: 1
       Class: rviz/RobotModel
       Collision Enabled: false
-      Enabled: false
+      Enabled: true
       Links:
         All Links Enabled: true
         Expand Joint Details: false
         Expand Link Details: false
         Expand Tree: false
         Link Tree Style: Links in Alphabetic Order
+        base_link:
+          Alpha: 1
+          Show Axes: false
+          Show Trail: false
+          Value: true
       Name: Vehicle Model
       Robot Description: robot_description
       TF Prefix: ""
       Update Interval: 0
-      Value: false
+      Value: true
       Visual Enabled: true
     - Alpha: 1
       Autocompute Intensity Bounds: true
@@ -454,19 +461,21 @@ Visualization Manager:
       Unreliable: false
       Value: false
     - Class: rviz/MarkerArray
-      Enabled: true
+      Enabled: false
       Marker Topic: /vector_map_center_lines_rviz
       Name: Vector Map CenterLines
       Namespaces:
         {}
       Queue Size: 100
-      Value: true
+      Value: false
     - Class: rviz/MarkerArray
       Enabled: true
       Marker Topic: /global_waypoints_rviz
       Name: Global Path
       Namespaces:
-        {}
+        global_lane_array_marker: true
+        global_lane_waypoint_orientation_marker: true
+        global_velocity_lane_1: true
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -474,7 +483,7 @@ Visualization Manager:
       Marker Topic: /local_trajectories
       Name: Local Rollouts
       Namespaces:
-        {}
+        global_lane_array_marker: true
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -490,7 +499,7 @@ Visualization Manager:
       Marker Topic: /curr_simu_pose
       Name: SimulatedCar Pose
       Namespaces:
-        {}
+        curr_simu_pose: true
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -498,7 +507,7 @@ Visualization Manager:
       Marker Topic: /follow_pose
       Name: Simulated Following Point
       Namespaces:
-        {}
+        follow_pose: true
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -506,7 +515,7 @@ Visualization Manager:
       Marker Topic: /behavior_state
       Name: Behavior State
       Namespaces:
-        {}
+        detected_polygons_velocity: true
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -522,7 +531,7 @@ Visualization Manager:
       Marker Topic: /safety_border
       Name: Safety Box
       Namespaces:
-        {}
+        global_lane_array_marker: true
       Queue Size: 100
       Value: true
     - Class: jsk_rviz_plugin/BoundingBoxArray
@@ -689,11 +698,11 @@ Visualization Manager:
         Value: false
       Name: Current View
       Near Clip Distance: 0.01
-      Scale: 11.8606
+      Scale: 22.8087
       Target Frame: world
       Value: TopDownOrtho (rviz)
-      X: 4.39087
-      Y: 3.01324
+      X: 3.80643
+      Y: -18.6686
     Saved: ~
 Window Geometry:
   Camera:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\BehaviorStateMachine.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\BehaviorStateMachine.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\GridMap.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\GridMap.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\HMIStateMachine.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\HMIStateMachine.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\LocalPlannerH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\LocalPlannerH.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\MappingHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\MappingHelpers.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\MatrixOperations.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\MatrixOperations.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\PlannerCommonDef.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\PlannerCommonDef.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\PlannerH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\PlannerH.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\PlanningHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\PlanningHelpers.h" added_lines="1" deleted_lines="1">
				<diff>@@ -23,7 +23,7 @@ namespace PlannerHNS {
 #define angle2points(from , to) atan2(to.y - from.y, to.x - from.x )
 #define LANE_CHANGE_SPEED_FACTOR 0.5
 #define LANE_CHANGE_COST 3.0 // meters
-#define BACKUP_STRAIGHT_PLAN_DISTANCE 60 //meters
+#define BACKUP_STRAIGHT_PLAN_DISTANCE 75 //meters
 
 class PlanningHelpers {
 public:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\RSPlanner.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\RSPlanner.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\RoadNetwork.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\RoadNetwork.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\TrajectoryCosts.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\TrajectoryCosts.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\include\geo_pos_conv.hh" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\geo_pos_conv.hh" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\BehaviorStateMachine.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\BehaviorStateMachine.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\GridMap.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\GridMap.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\HMIStateMachine.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\HMIStateMachine.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\LocalPlannerH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\LocalPlannerH.cpp" added_lines="12" deleted_lines="1">
				<diff>@@ -45,7 +45,18 @@ LocalPlannerH::LocalPlannerH()
 
 LocalPlannerH::~LocalPlannerH()
 {
-
+	delete m_pStopState;
+	delete m_pMissionCompleteState ;
+	delete m_pGoalState			;
+	delete m_pGoToGoalState 		;
+	delete m_pWaitState 			;
+	delete m_pInitState 			;
+	delete m_pFollowState			;
+	delete m_pAvoidObstacleState	;
+	delete m_pTrafficLightStopState;
+	delete m_pTrafficLightWaitState;
+	delete m_pStopSignWaitState	;
+	delete m_pStopSignStopState;
 }
 
 void LocalPlannerH::Init(const ControllerParams&amp; ctrlParams, const PlannerHNS::PlanningParams&amp; params,const CAR_BASIC_INFO&amp; carInfo)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\MappingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" added_lines="4" deleted_lines="3">
				<diff>@@ -24,7 +24,8 @@ using namespace UtilityHNS;
 using namespace std;
 #define FIND_LEFT_RIGHT_LANES
 #define _SMOOTH_MAP_WAYPOINTS
-#define LEFT_RIGHT_INITIAL_TURNS_COST 0
+#define RIGHT_INITIAL_TURNS_COST 100
+#define LEFT_INITIAL_TURNS_COST 100
 
 
 namespace PlannerHNS {
@@ -206,12 +207,12 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 
 		if(curr_lane_point.LaneDir == 'L')
 		{
-			wp.actionCost.push_back(make_pair(LEFT_TURN_ACTION, LEFT_RIGHT_INITIAL_TURNS_COST));
+			wp.actionCost.push_back(make_pair(LEFT_TURN_ACTION, LEFT_INITIAL_TURNS_COST));
 			//std::cout &lt;&lt; " Left Lane : " &lt;&lt; curr_lane_point.LnID &lt;&lt; std::endl ;
 		}
 		else  if(curr_lane_point.LaneDir == 'R')
 		{
-			wp.actionCost.push_back(make_pair(RIGHT_TURN_ACTION, LEFT_RIGHT_INITIAL_TURNS_COST));
+			wp.actionCost.push_back(make_pair(RIGHT_TURN_ACTION, RIGHT_INITIAL_TURNS_COST));
 			//std::cout &lt;&lt; " Right Lane : " &lt;&lt; curr_lane_point.LnID &lt;&lt; std::endl ;
 		}
 		else
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\MatrixOperations.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MatrixOperations.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\PlannerH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlannerH.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\PlanningHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" added_lines="2" deleted_lines="0">
				<diff>@@ -15,6 +15,8 @@
 using namespace UtilityHNS;
 using namespace std;
 
+
+
 namespace PlannerHNS {
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\RSPlanner.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\RSPlanner.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\TrajectoryCosts.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\TrajectoryCosts.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_plannerh\src\geo_pos_conv.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\geo_pos_conv.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\cmake\FindTinyXML.cmake" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\cmake\FindTinyXML.cmake" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\AlternativeVisualizer.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\AlternativeVisualizer.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\CarState.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\CarState.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\DrawObjBase.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\DrawObjBase.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\DrawingHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\DrawingHelpers.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\Graph2dBase.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\Graph2dBase.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\MainWindowWrapper.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\MainWindowWrapper.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\PlannerTestDraw.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\PlannerTestDraw.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\SimpleTracker.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\SimpleTracker.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\SimulatedTrajectoryFollower.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\SimulatedTrajectoryFollower.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\TrajectoryFollower.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\TrajectoryFollower.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\include\glm.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\glm.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\main.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\main.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\AlternativeVisualizer.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\AlternativeVisualizer.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\CarState.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\CarState.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\DrawObjBase.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\DrawObjBase.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\DrawingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\DrawingHelpers.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\Graph2dBase.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\Graph2dBase.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\MainWindowWrapper.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\MainWindowWrapper.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\PlannerTestDraw.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\PlannerTestDraw.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\SimpleTracker.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\SimpleTracker.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\SimulatedTrajectoryFollower.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\SimulatedTrajectoryFollower.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\TrajectoryFollower.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\TrajectoryFollower.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simuh\src\glm.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\glm.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utilityh\cmake\FindTinyXML.cmake" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\cmake\FindTinyXML.cmake" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utilityh\include\DataRW.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\DataRW.h" added_lines="19" deleted_lines="19">
				<diff>@@ -66,7 +66,7 @@ public:
 	~SimpleReaderBase();
 
 protected:
-	bool ReadAllData();
+	int ReadAllData();
 	bool ReadSingleLine(std::vector&lt;std::vector&lt;std::string&gt; &gt;&amp; line);
 
 };
@@ -78,7 +78,7 @@ protected:
 //		~GPSLocalizerReader(){}
 //
 //		bool ReadNextLine( MsgEstPose&amp; pos, double&amp; logTime);
-//		void ReadAllData(vector&lt;pair&lt;double,  MsgEstPose&gt; &gt;&amp; pos_list);
+//		int ReadAllData(vector&lt;pair&lt;double,  MsgEstPose&gt; &gt;&amp; pos_list);
 //};
 //
 class GPSDataReader : public SimpleReaderBase
@@ -99,7 +99,7 @@ public:
 	~GPSDataReader(){}
 
 	bool ReadNextLine(GPSBasicData&amp; data);
-	void ReadAllData(std::vector&lt;GPSBasicData&gt;&amp; data_list);
+	int ReadAllData(std::vector&lt;GPSBasicData&gt;&amp; data_list);
 };
 
 //
@@ -110,7 +110,7 @@ public:
 //	~VehicleStateReader(){}
 //
 //	bool ReadNextLine( MsgVehicleStatus&amp; state, double&amp; logTime);
-//	void ReadAllData(vector&lt;pair&lt;double,  MsgVehicleStatus&gt; &gt;&amp; state_list);
+//	int ReadAllData(vector&lt;pair&lt;double,  MsgVehicleStatus&gt; &gt;&amp; state_list);
 //};
 //
 //class MovingObjectsReader : public SimpleReaderBase
@@ -120,7 +120,7 @@ public:
 //	~MovingObjectsReader(){}
 //
 //	bool ReadNextLine( MsgMovingObject&amp; state, double&amp; logTime);
-//	void ReadAllData(vector&lt;pair&lt;double,  MsgMovingObject&gt; &gt;&amp; state_list);
+//	int ReadAllData(vector&lt;pair&lt;double,  MsgMovingObject&gt; &gt;&amp; state_list);
 //};
 
 class SimulationFileReader : public SimpleReaderBase
@@ -147,7 +147,7 @@ public:
 	~SimulationFileReader(){}
 
 	bool ReadNextLine(SimulationPoint&amp; data);
-	void ReadAllData(SimulationData&amp; data_list);
+	int ReadAllData(SimulationData&amp; data_list);
 };
 
 class LocalizationPathReader : public SimpleReaderBase
@@ -167,7 +167,7 @@ public:
 	~LocalizationPathReader(){}
 
 	bool ReadNextLine(LocalizationWayPoint&amp; data);
-	void ReadAllData(std::vector&lt;LocalizationWayPoint&gt;&amp; data_list);
+	int ReadAllData(std::vector&lt;LocalizationWayPoint&gt;&amp; data_list);
 };
 
 class AisanPointsFileReader : public SimpleReaderBase
@@ -191,7 +191,7 @@ public:
 	~AisanPointsFileReader(){}
 
 	bool ReadNextLine(AisanPoints&amp; data);
-	void ReadAllData(std::vector&lt;AisanPoints&gt;&amp; data_list);
+	int ReadAllData(std::vector&lt;AisanPoints&gt;&amp; data_list);
 };
 
 class AisanNodesFileReader : public SimpleReaderBase
@@ -208,7 +208,7 @@ public:
 	~AisanNodesFileReader(){}
 
 	bool ReadNextLine(AisanNode&amp; data);
-	void ReadAllData(std::vector&lt;AisanNode&gt;&amp; data_list);
+	int ReadAllData(std::vector&lt;AisanNode&gt;&amp; data_list);
 };
 
 class AisanLinesFileReader : public SimpleReaderBase
@@ -228,7 +228,7 @@ public:
 	~AisanLinesFileReader(){}
 
 	bool ReadNextLine(AisanLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanLine&gt;&amp; data_list);
+	int ReadAllData(std::vector&lt;AisanLine&gt;&amp; data_list);
 };
 
 class AisanCenterLinesFileReader : public SimpleReaderBase
@@ -253,7 +253,7 @@ public:
 	~AisanCenterLinesFileReader(){}
 
 	bool ReadNextLine(AisanCenterLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanCenterLine&gt;&amp; data_list);
+	int ReadAllData(std::vector&lt;AisanCenterLine&gt;&amp; data_list);
 };
 
 class AisanAreasFileReader : public SimpleReaderBase
@@ -271,7 +271,7 @@ public:
 	~AisanAreasFileReader(){}
 
 	bool ReadNextLine(AisanArea&amp; data);
-	void ReadAllData(std::vector&lt;AisanArea&gt;&amp; data_list);
+	int ReadAllData(std::vector&lt;AisanArea&gt;&amp; data_list);
 };
 
 class AisanIntersectionFileReader : public SimpleReaderBase
@@ -289,7 +289,7 @@ public:
 	~AisanIntersectionFileReader(){}
 
 	bool ReadNextLine(AisanIntersection&amp; data);
-	void ReadAllData(std::vector&lt;AisanIntersection&gt;&amp; data_list);
+	int ReadAllData(std::vector&lt;AisanIntersection&gt;&amp; data_list);
 };
 
 class AisanLanesFileReader : public SimpleReaderBase
@@ -331,7 +331,7 @@ public:
 	~AisanLanesFileReader(){}
 
 	bool ReadNextLine(AisanLane&amp; data);
-	void ReadAllData(std::vector&lt;AisanLane&gt;&amp; data_list);
+	int ReadAllData(std::vector&lt;AisanLane&gt;&amp; data_list);
 };
 
 class AisanStopLineFileReader : public SimpleReaderBase
@@ -351,7 +351,7 @@ public:
 	~AisanStopLineFileReader(){}
 
 	bool ReadNextLine(AisanStopLine&amp; data);
-	void ReadAllData(std::vector&lt;AisanStopLine&gt;&amp; data_list);
+	int ReadAllData(std::vector&lt;AisanStopLine&gt;&amp; data_list);
 };
 
 class AisanRoadSignFileReader : public SimpleReaderBase
@@ -371,7 +371,7 @@ public:
 	~AisanRoadSignFileReader(){}
 
 	bool ReadNextLine(AisanRoadSign&amp; data);
-	void ReadAllData(std::vector&lt;AisanRoadSign&gt;&amp; data_list);
+	int ReadAllData(std::vector&lt;AisanRoadSign&gt;&amp; data_list);
 };
 
 class AisanSignalFileReader : public SimpleReaderBase
@@ -391,7 +391,7 @@ public:
 	~AisanSignalFileReader(){}
 
 	bool ReadNextLine(AisanSignal&amp; data);
-	void ReadAllData(std::vector&lt;AisanSignal&gt;&amp; data_list);
+	int ReadAllData(std::vector&lt;AisanSignal&gt;&amp; data_list);
 };
 
 class AisanVectorFileReader : public SimpleReaderBase
@@ -410,7 +410,7 @@ public:
 	~AisanVectorFileReader(){}
 
 	bool ReadNextLine(AisanVector&amp; data);
-	void ReadAllData(std::vector&lt;AisanVector&gt;&amp; data_list);
+	int ReadAllData(std::vector&lt;AisanVector&gt;&amp; data_list);
 };
 
 class AisanDataConnFileReader : public SimpleReaderBase
@@ -429,7 +429,7 @@ public:
 	~AisanDataConnFileReader(){}
 
 	bool ReadNextLine(DataConn&amp; data);
-	void ReadAllData(std::vector&lt;DataConn&gt;&amp; data_list);
+	int ReadAllData(std::vector&lt;DataConn&gt;&amp; data_list);
 };
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utilityh\include\UtilityH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\UtilityH.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utilityh\src\DataRW.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" added_lines="91" deleted_lines="18">
				<diff>@@ -244,9 +244,9 @@ bool SimpleReaderBase::ReadSingleLine(vector&lt;vector&lt;string&gt; &gt;&amp; line)
 	return true;
 }
 
-bool SimpleReaderBase::ReadAllData()
+int SimpleReaderBase::ReadAllData()
 {
-	if(!m_pFile-&gt;is_open()) return false;
+	if(!m_pFile-&gt;is_open()) return 0;
 
 	m_AllData.clear();
 	vector&lt;vector&lt;string&gt; &gt; singleLine;
@@ -256,7 +256,7 @@ bool SimpleReaderBase::ReadAllData()
 		m_AllData.push_back(singleLine);
 	}
 
-	return true;
+	return m_AllData.size();
 }
 
 void SimpleReaderBase::ReadHeaders()
@@ -310,12 +310,17 @@ bool GPSDataReader::ReadNextLine(GPSBasicData&amp; data)
 		return false;
 }
 
-void GPSDataReader::ReadAllData(vector&lt;GPSBasicData&gt;&amp; data_list)
+int GPSDataReader::ReadAllData(vector&lt;GPSBasicData&gt;&amp; data_list)
 {
 	data_list.clear();
 	GPSBasicData data;
+	int count = 0;
 	while(ReadNextLine(data))
+	{
 		data_list.push_back(data);
+		count++;
+	}
+	return count;
 }
 
 bool SimulationFileReader::ReadNextLine(SimulationPoint&amp; data)
@@ -340,7 +345,7 @@ bool SimulationFileReader::ReadNextLine(SimulationPoint&amp; data)
 		return false;
 }
 
-void SimulationFileReader::ReadAllData(SimulationData&amp; data_list)
+int SimulationFileReader::ReadAllData(SimulationData&amp; data_list)
 {
 	data_list.simuCars.clear();
 	SimulationPoint data;
@@ -357,6 +362,8 @@ void SimulationFileReader::ReadAllData(SimulationData&amp; data_list)
 
 		count++;
 	}
+
+	return count;
 }
 
 bool LocalizationPathReader::ReadNextLine(LocalizationWayPoint&amp; data)
@@ -381,13 +388,18 @@ bool LocalizationPathReader::ReadNextLine(LocalizationWayPoint&amp; data)
 		return false;
 }
 
-void LocalizationPathReader::ReadAllData(vector&lt;LocalizationWayPoint&gt;&amp; data_list)
+int LocalizationPathReader::ReadAllData(vector&lt;LocalizationWayPoint&gt;&amp; data_list)
 {
 	data_list.clear();
 	LocalizationWayPoint data;
 	//double logTime = 0;
+	int count = 0;
 	while(ReadNextLine(data))
+	{
 		data_list.push_back(data);
+		count++;
+	}
+	return count;
 }
 
 bool AisanNodesFileReader::ReadNextLine(AisanNode&amp; data)
@@ -408,13 +420,18 @@ bool AisanNodesFileReader::ReadNextLine(AisanNode&amp; data)
 		return false;
 }
 
-void AisanNodesFileReader::ReadAllData(vector&lt;AisanNode&gt;&amp; data_list)
+int AisanNodesFileReader::ReadAllData(vector&lt;AisanNode&gt;&amp; data_list)
 {
 	data_list.clear();
 	AisanNode data;
 	//double logTime = 0;
+	int count = 0;
 	while(ReadNextLine(data))
+	{
 		data_list.push_back(data);
+		count++;
+	}
+	return count;
 }
 
 bool AisanPointsFileReader::ReadNextLine(AisanPoints&amp; data)
@@ -444,13 +461,18 @@ bool AisanPointsFileReader::ReadNextLine(AisanPoints&amp; data)
 		return false;
 }
 
-void AisanPointsFileReader::ReadAllData(vector&lt;AisanPoints&gt;&amp; data_list)
+int AisanPointsFileReader::ReadAllData(vector&lt;AisanPoints&gt;&amp; data_list)
 {
 	data_list.clear();
 	AisanPoints data;
 	//double logTime = 0;
+	int count = 0;
 	while(ReadNextLine(data))
+	{
 		data_list.push_back(data);
+		count++;
+	}
+	return count;
 }
 
 bool AisanLinesFileReader::ReadNextLine(AisanLine&amp; data)
@@ -473,13 +495,18 @@ bool AisanLinesFileReader::ReadNextLine(AisanLine&amp; data)
 		return false;
 }
 
-void AisanLinesFileReader::ReadAllData(vector&lt;AisanLine&gt;&amp; data_list)
+int AisanLinesFileReader::ReadAllData(vector&lt;AisanLine&gt;&amp; data_list)
 {
 	data_list.clear();
 	AisanLine data;
 	//double logTime = 0;
+	int count = 0;
 	while(ReadNextLine(data))
+	{
 		data_list.push_back(data);
+		count++;
+	}
+	return count;
 }
 
 bool AisanCenterLinesFileReader::ReadNextLine(AisanCenterLine&amp; data)
@@ -508,13 +535,18 @@ bool AisanCenterLinesFileReader::ReadNextLine(AisanCenterLine&amp; data)
 		return false;
 }
 
-void AisanCenterLinesFileReader::ReadAllData(vector&lt;AisanCenterLine&gt;&amp; data_list)
+int AisanCenterLinesFileReader::ReadAllData(vector&lt;AisanCenterLine&gt;&amp; data_list)
 {
 	data_list.clear();
 	AisanCenterLine data;
 	//double logTime = 0;
+	int count = 0;
 	while(ReadNextLine(data))
+	{
 		data_list.push_back(data);
+		count++;
+	}
+	return count;
 }
 
 bool AisanLanesFileReader::ReadNextLine(AisanLane&amp; data)
@@ -575,13 +607,18 @@ bool AisanLanesFileReader::ReadNextLine(AisanLane&amp; data)
 		return false;
 }
 
-void AisanLanesFileReader::ReadAllData(vector&lt;AisanLane&gt;&amp; data_list)
+int AisanLanesFileReader::ReadAllData(vector&lt;AisanLane&gt;&amp; data_list)
 {
 	data_list.clear();
 	AisanLane data;
 	//double logTime = 0;
+	int count = 0;
 	while(ReadNextLine(data))
+	{
 		data_list.push_back(data);
+		count++;
+	}
+	return count;
 }
 
 bool AisanAreasFileReader::ReadNextLine(AisanArea&amp; data)
@@ -603,13 +640,18 @@ bool AisanAreasFileReader::ReadNextLine(AisanArea&amp; data)
 		return false;
 }
 
-void AisanAreasFileReader::ReadAllData(vector&lt;AisanArea&gt;&amp; data_list)
+int AisanAreasFileReader::ReadAllData(vector&lt;AisanArea&gt;&amp; data_list)
 {
 	data_list.clear();
 	AisanArea data;
 	//double logTime = 0;
+	int count = 0;
 	while(ReadNextLine(data))
+	{
 		data_list.push_back(data);
+		count++;
+	}
+	return count;
 }
 
 bool AisanIntersectionFileReader::ReadNextLine(AisanIntersection&amp; data)
@@ -631,13 +673,18 @@ bool AisanIntersectionFileReader::ReadNextLine(AisanIntersection&amp; data)
 		return false;
 }
 
-void AisanIntersectionFileReader::ReadAllData(vector&lt;AisanIntersection&gt;&amp; data_list)
+int AisanIntersectionFileReader::ReadAllData(vector&lt;AisanIntersection&gt;&amp; data_list)
 {
 	data_list.clear();
 	AisanIntersection data;
 	//double logTime = 0;
+	int count = 0;
 	while(ReadNextLine(data))
+	{
 		data_list.push_back(data);
+		count++;
+	}
+	return count;
 }
 
 bool AisanStopLineFileReader::ReadNextLine(AisanStopLine&amp; data)
@@ -661,13 +708,18 @@ bool AisanStopLineFileReader::ReadNextLine(AisanStopLine&amp; data)
 		return false;
 }
 
-void AisanStopLineFileReader::ReadAllData(vector&lt;AisanStopLine&gt;&amp; data_list)
+int AisanStopLineFileReader::ReadAllData(vector&lt;AisanStopLine&gt;&amp; data_list)
 {
 	data_list.clear();
 	AisanStopLine data;
 	//double logTime = 0;
+	int count = 0;
 	while(ReadNextLine(data))
+	{
 		data_list.push_back(data);
+		count++;
+	}
+	return count;
 }
 
 bool AisanRoadSignFileReader::ReadNextLine(AisanRoadSign&amp; data)
@@ -691,13 +743,18 @@ bool AisanRoadSignFileReader::ReadNextLine(AisanRoadSign&amp; data)
 		return false;
 }
 
-void AisanRoadSignFileReader::ReadAllData(vector&lt;AisanRoadSign&gt;&amp; data_list)
+int AisanRoadSignFileReader::ReadAllData(vector&lt;AisanRoadSign&gt;&amp; data_list)
 {
 	data_list.clear();
 	AisanRoadSign data;
 	//double logTime = 0;
+	int count = 0;
 	while(ReadNextLine(data))
+	{
 		data_list.push_back(data);
+		count++;
+	}
+	return count;
 }
 
 bool AisanSignalFileReader::ReadNextLine(AisanSignal&amp; data)
@@ -721,13 +778,19 @@ bool AisanSignalFileReader::ReadNextLine(AisanSignal&amp; data)
 		return false;
 }
 
-void AisanSignalFileReader::ReadAllData(vector&lt;AisanSignal&gt;&amp; data_list)
+int AisanSignalFileReader::ReadAllData(vector&lt;AisanSignal&gt;&amp; data_list)
 {
 	data_list.clear();
 	AisanSignal data;
 	//double logTime = 0;
+	int count = 0;
 	while(ReadNextLine(data))
+	{
 		data_list.push_back(data);
+		count++;
+	}
+
+	return count;
 }
 
 bool AisanVectorFileReader::ReadNextLine(AisanVector&amp; data)
@@ -750,13 +813,18 @@ bool AisanVectorFileReader::ReadNextLine(AisanVector&amp; data)
 		return false;
 }
 
-void AisanVectorFileReader::ReadAllData(vector&lt;AisanVector&gt;&amp; data_list)
+int AisanVectorFileReader::ReadAllData(vector&lt;AisanVector&gt;&amp; data_list)
 {
 	data_list.clear();
 	AisanVector data;
 	//double logTime = 0;
+	int count = 0;
 	while(ReadNextLine(data))
+	{
 		data_list.push_back(data);
+		count++;
+	}
+	return count;
 }
 
 bool AisanDataConnFileReader::ReadNextLine(DataConn&amp; data)
@@ -779,13 +847,18 @@ bool AisanDataConnFileReader::ReadNextLine(DataConn&amp; data)
 		return false;
 }
 
-void AisanDataConnFileReader::ReadAllData(vector&lt;DataConn&gt;&amp; data_list)
+int AisanDataConnFileReader::ReadAllData(vector&lt;DataConn&gt;&amp; data_list)
 {
 	data_list.clear();
 	DataConn data;
 	//double logTime = 0;
+	int count = 0;
 	while(ReadNextLine(data))
+	{
 		data_list.push_back(data);
+		count++;
+	}
+	return count;
 }
 
 } /* namespace UtilityHNS */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utilityh\src\UtilityH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\UtilityH.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower_core.cpp" new_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower_core.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -296,7 +296,7 @@ void FFSteerControl::callbackGetCurrentTrajectory(const waypoint_follower_msgs::
 		m_State.m_Path.push_back(wp);
 	}
 
-	cout &lt;&lt; "### Current Trajectory CallBaclk -&gt; " &lt;&lt; m_State.m_Path.size() &lt;&lt; endl;
+//	cout &lt;&lt; "### Current Trajectory CallBaclk -&gt; " &lt;&lt; m_State.m_Path.size() &lt;&lt; endl;
 
 	bNewTrajectory = true;
 }
@@ -559,7 +559,7 @@ void FFSteerControl::PlannerMainLoop()
 			{
 				m_FollowingTrajectory = m_State.m_Path;
 				bNewPath = true;
-				cout &lt;&lt; "Path is Updated in the controller .. " &lt;&lt; m_State.m_Path.size() &lt;&lt; endl;
+//				cout &lt;&lt; "Path is Updated in the controller .. " &lt;&lt; m_State.m_Path.size() &lt;&lt; endl;
 			}
 
 			//PlannerHNS::ControllerParams c_params = m_ControlParams;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\OpenPlannerSimulator_core.h" new_path="ros\src\computing\planning\motion\packages\op_simulator\include\OpenPlannerSimulator_core.h" added_lines="6" deleted_lines="0">
				<diff>@@ -74,6 +74,7 @@ public:
 	std::string 	logPath;
 	MAP_SOURCE_TYPE	mapSource;
 	bool			bRandomStart;
+	bool 			bLooper;
 	PlannerHNS::WayPoint startPose;
 	std_msgs::ColorRGBA modelColor;
 
@@ -81,6 +82,7 @@ public:
 	{
 		id = 0;
 		bRandomStart = false;
+		bLooper = false;
 		mapSource = MAP_KML_FILE;
 		modelColor.a = 1;
 		modelColor.b = 1;
@@ -150,6 +152,10 @@ public:
   PlannerHNS::WayPoint GetRealCenter(const PlannerHNS::WayPoint&amp; currState);
 
   void visualizeBehaviors();
+
+  void SaveSimulationData();
+  bool LoadSimulationData(PlannerHNS::WayPoint&amp; start_p);
+  void InitializeSimuCar(PlannerHNS::WayPoint start_pose);
 };
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\OpenPlannerSimulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\OpenPlannerSimulator_core.cpp" added_lines="107" deleted_lines="32">
				<diff>@@ -64,15 +64,11 @@ OpenPlannerSimulator::OpenPlannerSimulator()
 	nh.getParam("id" 		, m_SimParams.strID);
 	nh.getParam("id" 		, m_SimParams.id);
 	nh.getParam("enableRvizPoseEst" 	, m_SimParams.bRandomStart);
+	nh.getParam("enableLooper" 			, m_SimParams.bLooper);
 	nh.getParam("startPoseX" 			, m_SimParams.startPose.pos.x);
 	nh.getParam("startPoseY" 			, m_SimParams.startPose.pos.y);
 	nh.getParam("startPoseA" 			, m_SimParams.startPose.pos.a);
 
-	if(m_SimParams.bRandomStart)
-		bInitPos = false;
-	else
-		bInitPos = true;
-
 	nh.getParam("meshPath" 				, m_SimParams.meshPath);
 	nh.getParam("baseColorR" 			, m_SimParams.modelColor.r);
 	nh.getParam("baseColorG" 			, m_SimParams.modelColor.g);
@@ -127,15 +123,29 @@ OpenPlannerSimulator::OpenPlannerSimulator()
 	pub_LocalTrajectoriesRviz   = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(str_s6.str(), 1);
 	pub_BehaviorStateRviz		= nh.advertise&lt;visualization_msgs::Marker&gt;(str_s2.str(), 1);
 
-	cout &lt;&lt; endl &lt;&lt; " ID " &lt;&lt; m_SimParams.strID &lt;&lt; " , But X = " &lt;&lt; m_SimParams.startPose.pos.x &lt;&lt; "," &lt;&lt; str_s1.str() &lt;&lt; endl;
-
 	// define subscribers.
-	sub_initialpose 		= nh.subscribe("/initialpose", 		100, &amp;OpenPlannerSimulator::callbackGetInitPose, 		this);
-	sub_cloudClusters 		= nh.subscribe("/cloud_clusters", 		1, &amp;OpenPlannerSimulator::callbackGetCloudClusters, 		this);
+	if(m_SimParams.bRandomStart)
+	{
+		bInitPos = false;
+		sub_initialpose 		= nh.subscribe("/initialpose", 		100, &amp;OpenPlannerSimulator::callbackGetInitPose, 		this);
+	}
+	else
+	{
+		bInitPos = true;
+		PlannerHNS::WayPoint start_p;
+		if(LoadSimulationData(start_p))
+		{
+			m_SimParams.startPose.pos = start_p.pos;
+			m_CarInfo.max_speed_forward = start_p.v;
+		}
+
+		//InitializeSimuCar(m_SimParams.startPose);
+	}
+
+	sub_cloudClusters 		= nh.subscribe("/cloud_clusters", 	1, &amp;OpenPlannerSimulator::callbackGetCloudClusters, 		this);
 
 	UtilityHNS::UtilityH::GetTickCount(m_PlanningTimer);
 	std::cout &lt;&lt; "OpenPlannerSimulator initialized successfully " &lt;&lt; std::endl;
-
 }
 
 void OpenPlannerSimulator::ReadParamFromLaunchFile(PlannerHNS::CAR_BASIC_INFO&amp; m_CarInfo,
@@ -170,10 +180,10 @@ void OpenPlannerSimulator::ReadParamFromLaunchFile(PlannerHNS::CAR_BASIC_INFO&amp; m
 	m_PlanningParams.horizonDistance = 100;
 	m_PlanningParams.horizontalSafetyDistancel = 0.1;
 	m_PlanningParams.verticalSafetyDistance = 0.8;
-	m_PlanningParams.maxDistanceToAvoid = 4;
+	m_PlanningParams.maxDistanceToAvoid = 2;
 	m_PlanningParams.microPlanDistance = 50;
-	m_PlanningParams.minDistanceToAvoid = 10;
-	m_PlanningParams.minFollowingDistance = 20;
+	m_PlanningParams.minDistanceToAvoid = 4;
+	m_PlanningParams.minFollowingDistance = 7;
 	m_PlanningParams.pathDensity = 0.5;
 	m_PlanningParams.planningDistance = 1000;
 	m_PlanningParams.carTipMargin = 2;
@@ -198,15 +208,29 @@ void OpenPlannerSimulator::callbackGetInitPose(const geometry_msgs::PoseWithCova
 		p.position.y  = msg-&gt;pose.pose.position.y + m_OriginPos.position.y;
 		p.position.z  = msg-&gt;pose.pose.position.z + m_OriginPos.position.z;
 		p.orientation = msg-&gt;pose.pose.orientation;
-
 		m_SimParams.startPose =  PlannerHNS::WayPoint(p.position.x, p.position.y, p.position.z , tf::getYaw(p.orientation));
-		m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = 1;
-		m_LocalPlanner.FirstLocalizeMe(m_SimParams.startPose);
-		m_LocalPlanner.LocalizeMe(0);
+
+		SaveSimulationData();
+
+		InitializeSimuCar(m_SimParams.startPose);
+
 		bInitPos = true;
 	}
 }
 
+void OpenPlannerSimulator::InitializeSimuCar(PlannerHNS::WayPoint start_pose)
+{
+	m_LocalPlanner.m_pCurrentBehaviorState = m_LocalPlanner.m_pInitState;
+	m_LocalPlanner.m_TotalPath.clear();
+	m_LocalPlanner.m_Path.clear();
+	m_LocalPlanner.m_pCurrentBehaviorState-&gt;m_Behavior = PlannerHNS::INITIAL_STATE;
+	m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = 1;
+	m_LocalPlanner.FirstLocalizeMe(start_pose);
+	m_LocalPlanner.LocalizeMe(0);
+
+	cout &lt;&lt; endl &lt;&lt; "LocalPlannerInit: ID " &lt;&lt; m_SimParams.strID &lt;&lt; " , Pose = ( "  &lt;&lt; start_pose.pos.ToString() &lt;&lt; ")" &lt;&lt; endl;
+}
+
 void OpenPlannerSimulator::GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
 {
 	static tf::TransformListener listener;
@@ -232,8 +256,9 @@ void OpenPlannerSimulator::callbackGetCloudClusters(const lidar_tracker::CloudCl
 	int nOriginalPoints=0, nContourPoints = 0;
 
 	ConvertFromAutowareCloudClusterObstaclesToPlannerH(m_LocalPlanner.state, m_LocalPlanner.m_CarInfo, *msg, m_OriginalClusters, nOriginalPoints, nContourPoints);
-	m_ObstacleTracking.DoOneStep(m_LocalPlanner.state, m_OriginalClusters);
-	m_TrackedClusters = m_ObstacleTracking.m_DetectedObjects;
+	//m_ObstacleTracking.DoOneStep(m_LocalPlanner.state, m_OriginalClusters);
+	//m_TrackedClusters = m_ObstacleTracking.m_DetectedObjects;
+	m_TrackedClusters = m_OriginalClusters;
 
 	//m_nTrackObjects = m_TrackedClusters.size();
 	//m_TrackingTime = UtilityHNS::UtilityH::GetTimeDiffNow(timerTemp);
@@ -280,8 +305,8 @@ void OpenPlannerSimulator::displayFollowingInfo(const std::vector&lt;PlannerHNS::GP
 
   m1.pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(0, 0, UtilityHNS::UtilityH::SplitPositiveAngle(curr_pose.pos.a));
   m1.color = m_SimParams.modelColor;
-  m1.scale.x = 1.0;
-  m1.scale.y = 1.0;
+  m1.scale.x = 1.0*m_CarInfo.length/4.2;
+  m1.scale.y = 1.0*m_CarInfo.width/1.85;
   m1.scale.z = 1.0;
   m1.frame_locked = true;
   pub_CurrPoseRviz.publish(m1);
@@ -313,7 +338,6 @@ void OpenPlannerSimulator::displayFollowingInfo(const std::vector&lt;PlannerHNS::GP
 
 }
 
-
 void OpenPlannerSimulator::visualizePath(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
 {
 	visualization_msgs::MarkerArray markerArray;
@@ -491,6 +515,56 @@ void OpenPlannerSimulator::visualizeBehaviors()
 	pub_BehaviorStateRviz.publish(behaviorMarker);
 }
 
+void OpenPlannerSimulator::SaveSimulationData()
+{
+	std::vector&lt;std::string&gt; simulationDataPoints;
+	std::ostringstream startStr;
+	startStr &lt;&lt; m_SimParams.startPose.pos.x &lt;&lt; "," &lt;&lt; m_SimParams.startPose.pos.y &lt;&lt; "," &lt;&lt; m_SimParams.startPose.pos.z &lt;&lt; "," &lt;&lt; m_SimParams.startPose.pos.a &lt;&lt; ","&lt;&lt; m_SimParams.startPose.cost &lt;&lt; "," &lt;&lt; m_CarInfo.max_speed_forward &lt;&lt; ",";
+	simulationDataPoints.push_back(startStr.str());
+	std::ostringstream goalStr;
+	simulationDataPoints.push_back(goalStr.str());
+
+	std::string header = "X,Y,Z,A,C,V,";
+
+	ostringstream fileName;
+	fileName &lt;&lt; UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName+UtilityHNS::DataRW::SimulationFolderName;
+	fileName &lt;&lt; "SimuCar_";
+	fileName &lt;&lt; m_SimParams.id;
+	fileName &lt;&lt; ".csv";
+
+	std::ofstream f(fileName.str().c_str());
+
+	if(f.is_open())
+	{
+		if(header.size() &gt; 0)
+			f &lt;&lt; header &lt;&lt; "\r\n";
+		for(unsigned int i = 0 ; i &lt; simulationDataPoints.size(); i++)
+			f &lt;&lt; simulationDataPoints.at(i) &lt;&lt; "\r\n";
+	}
+
+	f.close();
+}
+
+bool OpenPlannerSimulator::LoadSimulationData(PlannerHNS::WayPoint&amp; start_p)
+{
+	ostringstream fileName;
+	fileName &lt;&lt; "SimuCar_";
+	fileName &lt;&lt; m_SimParams.id;
+	fileName &lt;&lt; ".csv";
+
+	string simuDataFileName = UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName+UtilityHNS::DataRW::SimulationFolderName + fileName.str();
+	UtilityHNS::SimulationFileReader sfr(simuDataFileName);
+	UtilityHNS::SimulationFileReader::SimulationData data;
+
+	if(sfr.ReadAllData(data) == 0)
+		return false;
+
+	start_p = PlannerHNS::WayPoint(data.startPoint.x, data.startPoint.y, data.startPoint.z, data.startPoint.a);
+	start_p.v = data.startPoint.v;
+	start_p.cost = data.startPoint.c;
+	return true;
+}
+
 void OpenPlannerSimulator::PlannerMainLoop()
 {
 
@@ -511,22 +585,14 @@ void OpenPlannerSimulator::PlannerMainLoop()
 			m_bMap = true;
 			PlannerHNS::MappingHelpers::LoadKML(m_SimParams.KmlMapPath, m_Map);
 			if(!m_SimParams.bRandomStart)
-			{
-				m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = 1;
-				m_LocalPlanner.FirstLocalizeMe(m_SimParams.startPose);
-				m_LocalPlanner.LocalizeMe(0);
-			}
+				InitializeSimuCar(m_SimParams.startPose);
 		}
 		else if (m_SimParams.mapSource == MAP_FOLDER &amp;&amp; !m_bMap)
 		{
 			m_bMap = true;
 			PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_SimParams.KmlMapPath, m_Map, true);
 			if(!m_SimParams.bRandomStart)
-			{
-				m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = 1;
-				m_LocalPlanner.FirstLocalizeMe(m_SimParams.startPose);
-				m_LocalPlanner.LocalizeMe(0);
-			}
+				InitializeSimuCar(m_SimParams.startPose);
 		}
 
 		if(m_bMap &amp;&amp; bInitPos)
@@ -543,7 +609,11 @@ void OpenPlannerSimulator::PlannerMainLoop()
 				{
 					double remaining_distance =  m_LocalPlanner.m_TotalPath.at(info.iGlobalPath).at(m_LocalPlanner.m_TotalPath.at(info.iGlobalPath).size()-1).cost - (m_LocalPlanner.m_TotalPath.at(info.iGlobalPath).at(info.iFront).cost + info.to_front_distance);
 					if(remaining_distance &lt;= REPLANNING_DISTANCE)
+					{
 						bMakeNewPlan = true;
+						if(m_SimParams.bLooper)
+							InitializeSimuCar(m_SimParams.startPose);
+					}
 				}
 			}
 			else
@@ -617,6 +687,11 @@ void OpenPlannerSimulator::PlannerMainLoop()
 				str_out &lt;&lt; "LocalPath_";
 				PlannerHNS::PlanningHelpers::WritePathToFile(str_out.str(),  m_LocalPlanner.m_Path);
 			}
+
+			if(m_SimParams.bLooper &amp;&amp; currBehavior.state == PlannerHNS::FINISH_STATE)
+			{
+				InitializeSimuCar(m_SimParams.startPose);
+			}
 		}
 
 		loop_rate.sleep();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bff02f8f1c3c3bdf39b75eb5055a72831bd33be3" author="yukikitsukawa">
		<msg>add can2odom.launch</msg>
		<modified_files>
			<file old_path="ros\src\.config\vehicle_info\nhw20_info.yaml" new_path="" added_lines="0" deleted_lines="3">
				<diff>@@ -1,3 +0,0 @@
-vehicle_info: {maximum_steering_angle: 666.0, minimum_turning_radius: 5.1, wheel_base: 2.7}
-
-
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_info_translator\can_info_translator_core.h" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_info_translator\can_info_translator_core.h" added_lines="11" deleted_lines="7">
				<diff>@@ -53,9 +53,9 @@ struct VehicleInfo {
   VehicleInfo()
   {
     is_stored = false;
-    wheel_base = 0;
-    minimum_turning_radius = 0;
-    maximum_steering_angle = 0;
+    wheel_base = 0.0;
+    minimum_turning_radius = 0.0;
+    maximum_steering_angle = 0.0;
   }
   double convertSteeringAngleToAngularVelocity(const double cur_vel_mps, const double cur_angle_deg) // rad/s
   {
@@ -88,19 +88,23 @@ struct Odometry {
 
   Odometry(const ros::Time &amp;time)
   {
-    x = 0;
-    y = 0;
-    th = 0;
+    x = 0.0;
+    y = 0.0;
+    th = 0.0;
     stamp = time;
   }
 
   void updateOdometry(const double vx, const double vth, const ros::Time &amp;cur_time)
   {
-
+    if(stamp.sec == 0 &amp;&amp; stamp.nsec == 0)
+    {
+      stamp = cur_time;
+    }
     double dt = (cur_time - stamp).toSec();
     double delta_x = (vx * cos(th)) * dt;
     double delta_y = (vx * sin(th)) * dt;
     double delta_th = vth * dt;
+
     std::cout &lt;&lt; "dt : " &lt;&lt; dt &lt;&lt; "delta (x y th) : (" &lt;&lt; delta_x &lt;&lt; " " &lt;&lt; delta_y &lt;&lt; " " &lt;&lt; delta_th &lt;&lt; ")" &lt;&lt; std::endl;
 
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ea3d84c3ae64618c85f40160f38a7d82edefe9fd" author="AMC">
		<msg>Yolo 2 Node completed</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\darknet\yolo2.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\darknet\yolo2.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -86,7 +86,7 @@ namespace darknet
 			j += offset;
 		}
 
-		if (darknet_network_.w == width &amp;&amp; darknet_network_.h == height)
+		if (darknet_network_.w == (int) width &amp;&amp; darknet_network_.h == (int) height)
 		{
 			return im;
 		}
@@ -116,13 +116,13 @@ namespace darknet
 		{
 			int class_id = max_index(darknet_box_scores_[i], num_classes);
 			float prob = darknet_box_scores_[i][class_id];
-			if (prob &gt; 0.3)
+			//if (prob &gt; 0.3)
 			{
 				RectClassScore&lt;float&gt; detection;
 				box b = darknet_boxes_[i];
 
-				detection.x = b.x;
-				detection.y = b.y;
+				detection.x = b.x - b.w/2.;
+				detection.y = b.y - b.h/2.;
 				detection.w = b.w;
 				detection.h = b.h;
 				detection.score = prob;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" added_lines="65" deleted_lines="114">
				<diff>@@ -15,6 +15,7 @@
 #include &lt;vector&gt;
 
 #include &lt;math.h&gt;
+#include &lt;stdlib.h&gt;
 
 #include &lt;rect_class_score.h&gt;
 
@@ -22,14 +23,16 @@
 
 namespace Yolo2
 {
-	enum YoloDetectorClasses
+	enum YoloDetectorClasses//using coco for default cfg and weights
 	{
-		BACKGROUND,
-		PLANE, BICYCLE, BIRD, BOAT,
-		BOTTLE, BUS, CAR, CAT, CHAIR,
-		COW, TABLE, DOG, HORSE,
-		MOTORBIKE, PERSON, PLANT,
-		SHEEP, SOFA, TRAIN, TV, NUM_CLASSES
+		PERSON, BICYCLE, CAR, MOTORBIKE, AEROPLANE, BUS, TRAIN, TRUCK, BOAT, TRAFFIC_LIGHT,
+		FIRE_HYDRANT, STOP_SIGN, PARKING_METER, BENCH, BIRD, CAT, DOG, HORSE, SHEEP, COW,
+		ELEPHANT, BEAR, ZEBRA, GIRAFFE, BACKPACK, UMBRELLA, HANDBAG, TIE, SUITCASE, FRISBEE,
+		SKIS, SNOWBOARD, SPORTS_BALL, KITE, BASEBALL_BAT, BASEBALL_GLOVE, SKATEBOARD, SURFBOARD, TENNIS_RACKET, BOTTLE,
+		WINE_GLASS, CUP, FORK, KNIFE, SPOON, BOWL, BANANA, APPLE, SANDWICH, ORANGE,
+		BROCCOLI, CARROT, HOT_DOG, PIZZA, DONUT, CAKE, CHAIR, SOFA, POTTEDPLANT, BED,
+		DININGTABLE, TOILET, TVMONITOR, LAPTOP, MOUSE, REMOTE, KEYBOARD, CELL_PHONE, MICROWAVE, OVEN,
+		TOASTER, SINK, REFRIGERATOR, BOOK, CLOCK, VASE, SCISSORS, TEDDY_BEAR, HAIR_DRIER, TOOTHBRUSH,
 	};
 }
 
@@ -47,26 +50,39 @@ class Yolo2DetectorNode
 
 	float score_threshold_;
 	float nms_threshold_;
-	double image_ratio_;
+	double image_ratio_;//resdize ratio used to fit input image to network input size
+	uint32_t image_top_bottom_border_;//black strips added to the input image to maintain aspect ratio while resizing it to fit the network input size
+	uint32_t image_left_right_border_;
 
 	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, cv_tracker::image_obj&amp; out_message, std::string in_class)
 	{
 		for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
 		{
 			if ( (in_objects[i].score &gt; score_threshold_)
-				/*&amp;&amp; (	(in_class == "car" &amp;&amp; (in_objects[i].class_type == Yolo2::CAR || in_objects[i].class_type == Yolo2::BUS))
-						|| (in_class == "person" &amp;&amp; (in_objects[i].class_type == Yolo2::PERSON || in_objects[i].class_type == Yolo2::BICYCLE))
-					)*/
-
+				&amp;&amp; (	(in_class == "car"
+							&amp;&amp; (in_objects[i].class_type == Yolo2::CAR
+								|| in_objects[i].class_type == Yolo2::BUS
+								|| in_objects[i].class_type == Yolo2::TRUCK
+								|| in_objects[i].class_type == Yolo2::MOTORBIKE
+								)
+						)
+					|| (in_class == "person"
+							&amp;&amp; (in_objects[i].class_type == Yolo2::PERSON
+								|| in_objects[i].class_type == Yolo2::BICYCLE
+								|| in_objects[i].class_type == Yolo2::DOG
+								|| in_objects[i].class_type == Yolo2::CAT
+								|| in_objects[i].class_type == Yolo2::HORSE
+								)
+						)
+					)
 				)//check if the score is larger than minimum required
 			{
-				//std::cout &lt;&lt; in_objects[i].toString() &lt;&lt; std::endl;
 				cv_tracker::image_rect rect;
 
-				rect.x = in_objects[i].x * darknet_image.w;
-				rect.y = in_objects[i].y * darknet_image.h;
-				rect.width = in_objects[i].w * darknet_image.w;
-				rect.height = in_objects[i].h * darknet_image.h;
+				rect.x = (in_objects[i].x * darknet_image.w /image_ratio_) - image_left_right_border_/image_ratio_;
+				rect.y = (in_objects[i].y * darknet_image.h /image_ratio_) - image_top_bottom_border_/image_ratio_;
+				rect.width = in_objects[i].w * darknet_image.w/image_ratio_;
+				rect.height = in_objects[i].h * darknet_image.h/image_ratio_;
 				if (in_objects[i].x &lt; 0)
 					rect.x = 0;
 				if (in_objects[i].y &lt; 0)
@@ -78,7 +94,7 @@ class Yolo2DetectorNode
 
 				rect.score = in_objects[i].score;
 
-				std::cout &lt;&lt; "x"&lt;&lt; rect.x&lt;&lt; "y" &lt;&lt; rect.y &lt;&lt; "w"&lt;&lt; rect.width &lt;&lt; "h"&lt;&lt; rect.height&lt;&lt; "s" &lt;&lt; rect.score &lt;&lt; std::endl;
+				//std::cout &lt;&lt; "x "&lt;&lt; rect.x&lt;&lt; " y " &lt;&lt; rect.y &lt;&lt; " w "&lt;&lt; rect.width &lt;&lt; " h "&lt;&lt; rect.height&lt;&lt; " s " &lt;&lt; rect.score &lt;&lt; " c " &lt;&lt; in_objects[i].class_type &lt;&lt; std::endl;
 
 				out_message.obj.push_back(rect);
 
@@ -94,32 +110,46 @@ class Yolo2DetectorNode
 		uint32_t network_input_width = yolo_detector_.get_network_width();
 		uint32_t network_input_height = yolo_detector_.get_network_height();
 
-		uint32_t height = msg-&gt;height,
-						width = msg-&gt;width;
+		uint32_t image_height = msg-&gt;height,
+						image_width = msg-&gt;width;
 
 		IplImage ipl_image;
 		cv::Mat final_mat;
 
-		ROS_INFO("Before Network (%d,%d), Image (%d,%d)", network_input_width, network_input_height, width, height);
-		if (network_input_width!=width
-				|| network_input_height != height)
+		//ROS_INFO("Before Network (%d,%d), Image (%d,%d)", network_input_width, network_input_height, image_width, image_height);
+		if (network_input_width!=image_width
+				|| network_input_height != image_height)
 		{
 			//final_mat = cv::Mat(network_input_width, network_input_height, CV_8UC3, cv::Scalar(0,0,0));
 			image_ratio_ = (double ) network_input_width /  (double)mat_image.cols;
-			std::cout &lt;&lt; "Ratio:" &lt;&lt; image_ratio_ &lt;&lt; std::endl;
+			//std::cout &lt;&lt; "Ratio:" &lt;&lt; image_ratio_ &lt;&lt; std::endl;
 
 			cv::resize(mat_image, final_mat, cv::Size(), image_ratio_, image_ratio_);
-			uint32_t top_bottom_border = abs(final_mat.rows-network_input_height)/2;
-			uint32_t left_right_border = abs(final_mat.cols-network_input_width)/2;
-			cv::copyMakeBorder(final_mat, final_mat, top_bottom_border, top_bottom_border, left_right_border, left_right_border, cv::BORDER_CONSTANT, cv::Scalar(0,0,0));
+			image_top_bottom_border_ = abs(final_mat.rows-network_input_height)/2;
+			image_left_right_border_ = abs(final_mat.cols-network_input_width)/2;
+			cv::copyMakeBorder(final_mat, final_mat,
+								image_top_bottom_border_, image_top_bottom_border_,
+								image_left_right_border_, image_left_right_border_,
+								cv::BORDER_CONSTANT, cv::Scalar(0,0,0));
+
+			/*
+			 //CROP CENTER
+			 * uint32_t crop_x, crop_y;
+			crop_x = (image_width-network_input_width)/2;
+			crop_y = (image_height-network_input_height)/2;
+			cv::Rect center_crop(crop_x, crop_y, network_input_width, network_input_height);
+			std::cout &lt;&lt; mat_image.cols &lt;&lt; ", " &lt;&lt; mat_image.rows &lt;&lt; std::endl;
+			cv::Mat cropped_mat = mat_image(center_crop);
+			cropped_mat.copyTo(final_mat);
+			*/
+
+			//VILE RESIZE
+			//cv::resize(mat_image, final_mat, cv::Size(network_input_width, network_input_height));
 		}
 		else
 			final_mat = mat_image;
 
-		ROS_INFO("After Network (%d,%d), Image (%d,%d)", network_input_width, network_input_height, final_mat.cols, final_mat.rows);
-
-		cv::imshow("cropped", final_mat);
-		cvWaitKey(10);
+		//ROS_INFO("After Network (%d,%d), Image (%d,%d)", network_input_width, network_input_height, final_mat.cols, final_mat.rows);
 
 		ipl_image = final_mat;
 
@@ -139,7 +169,6 @@ class Yolo2DetectorNode
 				}
 			}
 		}
-
 		return darknet_image;
 	}
 
@@ -152,6 +181,8 @@ class Yolo2DetectorNode
 
 		detections = yolo_detector_.detect(darknet_image.data);
 
+		//ROS_INFO("Detections: %ud", (unsigned int)detections.size());
+
 		//Prepare Output message
 		cv_tracker::image_obj output_car_message;
 		cv_tracker::image_obj output_person_message;
@@ -234,11 +265,11 @@ public:
 		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;Yolo2DetectorNode::image_callback, this);
 
 		std::string config_topic("/config");
-		config_topic += "/ssd";
+		config_topic += "/yolo2";
 		subscriber_yolo_config_ = node_handle_.subscribe(config_topic, 1, &amp;Yolo2DetectorNode::config_cb, this);
 
 		ros::spin();
-		ROS_INFO("END Ssd");
+		ROS_INFO("END Yolo2");
 
 	}
 };
@@ -254,83 +285,3 @@ int main(int argc, char **argv)
 	return 0;
 }
 
-/*
-namespace
-{
-	darknet::Yolo2Detector yolo;
-	ros::Publisher publisher;
-	image im = {};
-	float *image_data = nullptr;
-	ros::Time timestamp;
-	std::mutex mutex;
-	std::condition_variable im_condition;
-
-	void imageCallback(const sensor_msgs::ImageConstPtr&amp; msg)
-	{
-	  im = yolo.convert_image(msg);
-	  std::unique_lock&lt;std::mutex&gt; lock(mutex);
-	  if (image_data)
-		free(image_data);
-	  timestamp = msg-&gt;header.stamp;
-	  image_data = im.data;
-	  lock.unlock();
-	  im_condition.notify_one();
-	}
-	}  // namespace
-
-	namespace yolo2
-	{
-	class Yolo2Nodelet : public nodelet::Nodelet
-	{
-	 public:
-	  virtual void onInit()
-	  {
-		ros::NodeHandle&amp; node = getPrivateNodeHandle();
-		const std::string NET_DATA = ros::package::getPath("yolo2") + "/data/";
-		std::string config = NET_DATA + "yolo.cfg", weights = NET_DATA + "yolo.weights";
-		double confidence, nms;
-		node.param&lt;double&gt;("confidence", confidence, .8);
-		node.param&lt;double&gt;("nms", nms, .4);
-		yolo.load(config, weights, confidence, nms);
-
-		image_transport::ImageTransport transport = image_transport::ImageTransport(node);
-		subscriber = transport.subscribe("image", 1, imageCallback);
-		publisher = node.advertise&lt;yolo2::ImageDetections&gt;("detections", 5);
-
-		yolo_thread = new std::thread(run_yolo);
-	  }
-
-	  ~Yolo2Nodelet()
-	  {
-		yolo_thread-&gt;join();
-		delete yolo_thread;
-	  }
-
-	 private:
-	  image_transport::Subscriber subscriber;
-	  std::thread *yolo_thread;
-
-	  static void run_yolo()
-	  {
-		while (ros::ok())
-		{
-		  float *data;
-		  ros::Time stamp;
-		  {
-			std::unique_lock&lt;std::mutex&gt; lock(mutex);
-			while (!image_data)
-			  im_condition.wait(lock);
-			data = image_data;
-			image_data = nullptr;
-			stamp = timestamp;
-		  }
-		  boost::shared_ptr&lt;yolo2::ImageDetections&gt; detections(new yolo2::ImageDetections);
-		  *detections = yolo.detect(data);
-		  detections-&gt;header.stamp = stamp;
-		  publisher.publish(detections);
-		  free(data);
-		}
-	  }
-	};
-}  // namespace yolo2
-*/
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="caddf1d3537018b319672d6b6d1dd492a8bbf8f6" author="yukikitsukawa">
		<msg>fix rviz config
remove jsk_rviz_plugin
remove the setting of window size and position
remove image</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\default.rviz" new_path="ros\src\.config\rviz\default.rviz" added_lines="1" deleted_lines="52">
				<diff>@@ -137,18 +137,6 @@ Visualization Manager:
         zebra_zone: true
       Queue Size: 100
       Value: true
-    - Class: rviz/Image
-      Enabled: true
-      Image Topic: /image_raw
-      Max Value: 1
-      Median window: 5
-      Min Value: 0
-      Name: Image
-      Normalize Range: true
-      Queue Size: 2
-      Transport Hint: raw
-      Unreliable: false
-      Value: true
     - Class: rviz/Camera
       Enabled: false
       Image Rendering: overlay
@@ -383,43 +371,6 @@ Visualization Manager:
         global_velocity_lane_1: true
       Queue Size: 100
       Value: true
-    - Buffer length: 100
-      Class: jsk_rviz_plugin/Plotter2D
-      Enabled: true
-      Name: km/h
-      Show Value: true
-      Topic: /linear_velocity_viz
-      Value: true
-      auto color change: false
-      auto scale: true
-      background color: 0; 0; 0
-      backround alpha: 0
-      border: true
-      caption: true
-      foreground alpha: 0.6
-      foreground color: 25; 255; 240
-      height: 100
-      left: 10
-      linewidth: 1
-      max color: 255; 0; 0
-      max value: 1
-      min value: -1
-      text size: 12
-      top: 10
-      update interval: 0.04
-      width: 100
-    - Class: jsk_rviz_plugin/BoundingBoxArray
-      Enabled: true
-      Name: Bounding Boxes
-      Topic: /bounding_boxes
-      Unreliable: false
-      Value: true
-      alpha: 0.8
-      color: 25; 255; 0
-      coloring: Auto
-      line width: 0.005
-      only edge: false
-      show coords: false
     - Class: rviz/Marker
       Enabled: true
       Marker Topic: /waypoint_guide
@@ -494,6 +445,4 @@ Window Geometry:
     collapsed: false
   Views:
     collapsed: false
-  Width: 1440
-  X: 1895
-  Y: 44
+
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="39ab5250d0b35700a4a1eb0344994685dd3094df" author="AMC">
		<msg>Changes to code to adapt to new cv_tracker messages structure</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\darknet\yolo2.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\darknet\yolo2.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -2,7 +2,7 @@
 
 #include &lt;image_transport/image_transport.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;cv_tracker/image_obj.h&gt;
+#include &lt;cv_tracker_msgs/image_obj.h&gt;
 
 #include &lt;cstdint&gt;
 #include &lt;cstdlib&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -4,7 +4,7 @@
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 
-#include &lt;cv_tracker/image_obj.h&gt;
+#include &lt;cv_tracker_msgs/image_obj.h&gt;
 
 #include &lt;opencv2/contrib/contrib.hpp&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
@@ -54,7 +54,7 @@ class Yolo2DetectorNode
 	uint32_t image_top_bottom_border_;//black strips added to the input image to maintain aspect ratio while resizing it to fit the network input size
 	uint32_t image_left_right_border_;
 
-	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, cv_tracker::image_obj&amp; out_message, std::string in_class)
+	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, cv_tracker_msgs::image_obj&amp; out_message, std::string in_class)
 	{
 		for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
 		{
@@ -77,7 +77,7 @@ class Yolo2DetectorNode
 					)
 				)//check if the score is larger than minimum required
 			{
-				cv_tracker::image_rect rect;
+				cv_tracker_msgs::image_rect rect;
 
 				rect.x = (in_objects[i].x * darknet_image.w /image_ratio_) - image_left_right_border_/image_ratio_;
 				rect.y = (in_objects[i].y * darknet_image.h /image_ratio_) - image_top_bottom_border_/image_ratio_;
@@ -184,8 +184,8 @@ class Yolo2DetectorNode
 		//ROS_INFO("Detections: %ud", (unsigned int)detections.size());
 
 		//Prepare Output message
-		cv_tracker::image_obj output_car_message;
-		cv_tracker::image_obj output_person_message;
+		cv_tracker_msgs::image_obj output_car_message;
+		cv_tracker_msgs::image_obj output_person_message;
 		output_car_message.header = in_image_message-&gt;header;
 		output_car_message.type = "car";
 
@@ -258,8 +258,8 @@ public:
 		yolo_detector_.load(network_definition_file, pretrained_model_file, score_threshold_, nms_threshold_);
 		ROS_INFO("Initialization complete.");
 
-		publisher_car_objects_ = node_handle_.advertise&lt;cv_tracker::image_obj&gt;("/obj_car/image_obj", 1);
-		publisher_person_objects_ = node_handle_.advertise&lt;cv_tracker::image_obj&gt;("/obj_person/image_obj", 1);
+		publisher_car_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj&gt;("/obj_car/image_obj", 1);
+		publisher_person_objects_ = node_handle_.advertise&lt;cv_tracker_msgs::image_obj&gt;("/obj_person/image_obj", 1);
 
 		ROS_INFO("Subscribing to... %s", image_raw_topic_str.c_str());
 		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;Yolo2DetectorNode::image_callback, this);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f5447110dcfae9d20a48f5c00283ae09726afe6d" author="YamatoAndo">
		<msg>add imuUpsideDown() and params</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="43" deleted_lines="2">
				<diff>@@ -138,6 +138,10 @@ static bool isMapUpdate = true;
 static bool _use_openmp = false;
 static bool _use_imu = false;
 static bool _use_odom = false;
+static bool _imu_upside_down = false;
+
+static std::string _imu_topic = "/imu_raw";
+
 
 static double fitness_score;
 
@@ -343,12 +347,44 @@ static double wrapToPmPi(double a_angle_rad)
 
 static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
 {
+  std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+
   odom = *input;
   odom_calc(input-&gt;header.stamp);
 }
 
-static void imu_callback(const sensor_msgs::Imu::ConstPtr&amp; input)
+
+static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
+{
+  double input_roll, input_pitch, input_yaw;
+
+  tf::Quaternion input_orientation;
+  tf::quaternionMsgToTF(input-&gt;orientation, input_orientation);
+  tf::Matrix3x3(input_orientation).getRPY(input_roll, input_pitch, input_yaw);
+
+  input-&gt;angular_velocity.x *= -1;
+  input-&gt;angular_velocity.y *= -1;
+  input-&gt;angular_velocity.z *= -1;
+
+  input-&gt;linear_acceleration.x *= -1;
+  input-&gt;linear_acceleration.y *= -1;
+  input-&gt;linear_acceleration.z *= -1;
+
+  input_roll  *= -1;
+  input_pitch *= -1;
+  input_yaw   *= -1;
+
+  input-&gt;orientation = tf::createQuaternionMsgFromRollPitchYaw(input_roll, input_pitch, input_yaw);
+}
+
+
+static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
 {
+  std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+
+  if(_imu_upside_down)
+    imuUpsideDown(input);
+
   const ros::Time current_time = input-&gt;header.stamp;
   static ros::Time previous_time = current_time;
   const double diff_time =  (current_time - previous_time).toSec();
@@ -770,11 +806,16 @@ int main(int argc, char** argv)
   private_nh.getParam("use_openmp", _use_openmp);
   private_nh.getParam("use_imu", _use_imu);
   private_nh.getParam("use_odom", _use_odom);
+  private_nh.getParam("imu_upside_down", _imu_upside_down);
+  private_nh.getParam("imu_topic", _imu_topic);
 
   std::cout &lt;&lt; "use_openmp: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_imu: " &lt;&lt; _use_imu &lt;&lt; std::endl;
+  std::cout &lt;&lt; "imu_upside_down: " &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_odom: " &lt;&lt; _use_odom &lt;&lt; std::endl;
 
+  std::cout &lt;&lt; "imu_topic: " &lt;&lt; _imu_topic &lt;&lt; std::endl;
+
   if (nh.getParam("tf_x", _tf_x) == false)
   {
     std::cout &lt;&lt; "tf_x is not set." &lt;&lt; std::endl;
@@ -830,7 +871,7 @@ int main(int argc, char** argv)
   ros::Subscriber output_sub = nh.subscribe("config/ndt_mapping_output", 10, output_callback);
   ros::Subscriber points_sub = nh.subscribe("points_raw", 100000, points_callback);
   ros::Subscriber odom_sub = nh.subscribe("/odom_pose", 100000, odom_callback);
-  ros::Subscriber imu_sub = nh.subscribe("/imu_raw", 100000, imu_callback);
+  ros::Subscriber imu_sub = nh.subscribe(_imu_topic, 100000, imu_callback);
 
   ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="36" deleted_lines="32">
				<diff>@@ -203,6 +203,9 @@ static bool _get_height = false;
 static bool _use_local_transform = false;
 static bool _use_imu = false;
 static bool _use_odom = false;
+static bool _imu_upside_down = false;
+
+static std::string _imu_topic = "/imu_raw";
 
 static std::ofstream ofs;
 static std::string filename;
@@ -631,10 +634,36 @@ static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
   odom_calc(input-&gt;header.stamp);
 }
 
-static void imu_callback(const sensor_msgs::Imu::ConstPtr&amp; input)
+static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
+{
+  double input_roll, input_pitch, input_yaw;
+
+  tf::Quaternion input_orientation;
+  tf::quaternionMsgToTF(input-&gt;orientation, input_orientation);
+  tf::Matrix3x3(input_orientation).getRPY(input_roll, input_pitch, input_yaw);
+
+  input-&gt;angular_velocity.x *= -1;
+  input-&gt;angular_velocity.y *= -1;
+  input-&gt;angular_velocity.z *= -1;
+
+  input-&gt;linear_acceleration.x *= -1;
+  input-&gt;linear_acceleration.y *= -1;
+  input-&gt;linear_acceleration.z *= -1;
+
+  input_roll  *= -1;
+  input_pitch *= -1;
+  input_yaw   *= -1;
+
+  input-&gt;orientation = tf::createQuaternionMsgFromRollPitchYaw(input_roll, input_pitch, input_yaw);
+}
+
+static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
 {
   std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 
+  if(_imu_upside_down)
+    imuUpsideDown(input);
+
   const ros::Time current_time = input-&gt;header.stamp;
   static ros::Time previous_time = current_time;
   const double diff_time =  (current_time - previous_time).toSec();
@@ -1124,36 +1153,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       exit(1);
     }
     static ros::Time start_time = input-&gt;header.stamp;
-/*
-    ofs &lt;&lt; input-&gt;header.seq &lt;&lt; "," &lt;&lt; input-&gt;header.stamp &lt;&lt; "," &lt;&lt; input-&gt;header.stamp - start_time &lt;&lt; scan_points_num &lt;&lt; "," &lt;&lt; step_size &lt;&lt; "," &lt;&lt; trans_eps &lt;&lt; "," &lt;&lt; std::fixed
-        &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; "," &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; ","
-        &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; "," &lt;&lt; current_pose.roll &lt;&lt; "," &lt;&lt; current_pose.pitch
-        &lt;&lt; "," &lt;&lt; current_pose.yaw &lt;&lt; "," &lt;&lt; predict_pose.x &lt;&lt; "," &lt;&lt; predict_pose.y &lt;&lt; "," &lt;&lt; predict_pose.z &lt;&lt; ","
-        &lt;&lt; predict_pose.roll &lt;&lt; "," &lt;&lt; predict_pose.pitch &lt;&lt; "," &lt;&lt; predict_pose.yaw &lt;&lt; ","
-        &lt;&lt; current_pose.x - predict_pose.x &lt;&lt; "," &lt;&lt; current_pose.y - predict_pose.y &lt;&lt; ","
-        &lt;&lt; current_pose.z - predict_pose.z &lt;&lt; "," &lt;&lt; current_pose.roll - predict_pose.roll &lt;&lt; ","
-        &lt;&lt; current_pose.pitch - predict_pose.pitch &lt;&lt; "," &lt;&lt; current_pose.yaw - predict_pose.yaw &lt;&lt; ","
-        &lt;&lt; predict_pose_error &lt;&lt; "," &lt;&lt; iteration &lt;&lt; "," &lt;&lt; fitness_score &lt;&lt; "," &lt;&lt; trans_probability &lt;&lt; ","
-        &lt;&lt; ndt_reliability.data &lt;&lt; "," &lt;&lt; current_velocity &lt;&lt; "," &lt;&lt; current_velocity_smooth &lt;&lt; "," &lt;&lt; current_accel
-        &lt;&lt; "," &lt;&lt; angular_velocity &lt;&lt; "," &lt;&lt; time_ndt_matching.data &lt;&lt; "," &lt;&lt; align_time &lt;&lt; "," &lt;&lt; getFitnessScore_time 
-        &lt;&lt;"," &lt;&lt; predict_pose_imu.x &lt;&lt; "," &lt;&lt; predict_pose_imu.y &lt;&lt; "," &lt;&lt; predict_pose_imu.z &lt;&lt; ","
-        &lt;&lt; predict_pose_imu.roll &lt;&lt; "," &lt;&lt; predict_pose_imu.pitch &lt;&lt; ","  &lt;&lt; predict_pose_imu.yaw &lt;&lt; ","
-        &lt;&lt; current_pose.x - predict_pose_imu.x &lt;&lt; "," &lt;&lt; current_pose.y - predict_pose_imu.y &lt;&lt; ","
-        &lt;&lt; current_pose.z - predict_pose_imu.z &lt;&lt; "," &lt;&lt; current_pose.roll - predict_pose_imu.roll &lt;&lt; ","
-        &lt;&lt; current_pose.pitch - predict_pose_imu.pitch &lt;&lt; "," &lt;&lt; current_pose.yaw - predict_pose_imu.yaw &lt;&lt; ","
-
-        &lt;&lt;"," &lt;&lt; predict_pose_odom.x &lt;&lt; "," &lt;&lt; predict_pose_odom.y &lt;&lt; "," &lt;&lt; predict_pose_odom.z &lt;&lt; ","
-        &lt;&lt; predict_pose_odom.roll &lt;&lt; "," &lt;&lt; predict_pose_odom.pitch &lt;&lt; ","  &lt;&lt; predict_pose_odom.yaw &lt;&lt; ","
-        &lt;&lt; current_pose.x - predict_pose_odom.x &lt;&lt; "," &lt;&lt; current_pose.y - predict_pose_odom.y &lt;&lt; ","
-        &lt;&lt; current_pose.z - predict_pose_odom.z &lt;&lt; "," &lt;&lt; current_pose.roll - predict_pose_odom.roll &lt;&lt; ","
-        &lt;&lt; current_pose.pitch - predict_pose_odom.pitch &lt;&lt; "," &lt;&lt; current_pose.yaw - predict_pose_odom.yaw &lt;&lt; ","
-        &lt;&lt;"," &lt;&lt; predict_pose_imu_odom.x &lt;&lt; "," &lt;&lt; predict_pose_imu_odom.y &lt;&lt; "," &lt;&lt; predict_pose_imu_odom.z &lt;&lt; ","
-        &lt;&lt; predict_pose_imu_odom.roll &lt;&lt; "," &lt;&lt; predict_pose_imu_odom.pitch &lt;&lt; ","  &lt;&lt; predict_pose_imu_odom.yaw &lt;&lt; ","
-        &lt;&lt; current_pose.x - predict_pose_imu_odom.x &lt;&lt; "," &lt;&lt; current_pose.y - predict_pose_imu_odom.y &lt;&lt; ","
-        &lt;&lt; current_pose.z - predict_pose_imu_odom.z &lt;&lt; "," &lt;&lt; current_pose.roll - predict_pose_imu_odom.roll &lt;&lt; ","
-        &lt;&lt; current_pose.pitch - predict_pose_imu_odom.pitch &lt;&lt; "," &lt;&lt; current_pose.yaw - predict_pose_imu_odom.yaw &lt;&lt; ","
-        &lt;&lt; std::endl;
-*/
+
     ofs &lt;&lt; input-&gt;header.seq &lt;&lt; "," &lt;&lt; scan_points_num &lt;&lt; "," &lt;&lt; step_size &lt;&lt; "," &lt;&lt; trans_eps &lt;&lt; "," &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; "," &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; ","
         &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; "," &lt;&lt; current_pose.roll &lt;&lt; "," &lt;&lt; current_pose.pitch
@@ -1276,6 +1276,8 @@ int main(int argc, char** argv)
   private_nh.getParam("use_local_transform", _use_local_transform);
   private_nh.getParam("use_imu", _use_imu);
   private_nh.getParam("use_odom", _use_odom);
+  private_nh.getParam("imu_upside_down", _imu_upside_down);
+  private_nh.getParam("imu_topic", _imu_topic);
 
   if (nh.getParam("localizer", _localizer) == false)
   {
@@ -1323,7 +1325,9 @@ int main(int argc, char** argv)
   std::cout &lt;&lt; "use_local_transform: " &lt;&lt; _use_local_transform &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_imu: " &lt;&lt; _use_imu &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_odom: " &lt;&lt; _use_odom &lt;&lt; std::endl;
+  std::cout &lt;&lt; "imu_upside_down: " &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
   std::cout &lt;&lt; "localizer: " &lt;&lt; _localizer &lt;&lt; std::endl;
+  std::cout &lt;&lt; "imu_topic: " &lt;&lt; _imu_topic &lt;&lt; std::endl;
   std::cout &lt;&lt; "(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (" &lt;&lt; _tf_x &lt;&lt; ", " &lt;&lt; _tf_y &lt;&lt; ", " &lt;&lt; _tf_z &lt;&lt; ", "
             &lt;&lt; _tf_roll &lt;&lt; ", " &lt;&lt; _tf_pitch &lt;&lt; ", " &lt;&lt; _tf_yaw &lt;&lt; ")" &lt;&lt; std::endl;
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
@@ -1371,7 +1375,7 @@ int main(int argc, char** argv)
   ros::Subscriber initialpose_sub = nh.subscribe("initialpose", 1000, initialpose_callback);
   ros::Subscriber points_sub = nh.subscribe("filtered_points", _queue_size, points_callback);
   ros::Subscriber odom_sub = nh.subscribe("/odom_pose", _queue_size*10, odom_callback);
-  ros::Subscriber imu_sub = nh.subscribe("/imu_raw", _queue_size*10, imu_callback);
+  ros::Subscriber imu_sub = nh.subscribe(_imu_topic.c_str(), _queue_size*10, imu_callback);
 
   ros::spin();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="08919c8c9c1146082c7cb88d13d42273b89b7faa" author="YamatoAndo">
		<msg>ndt with imu and odom for predict pose</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -347,7 +347,7 @@ static double wrapToPmPi(double a_angle_rad)
 
 static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
 {
-  std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 
   odom = *input;
   odom_calc(input-&gt;header.stamp);
@@ -380,7 +380,7 @@ static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
 
 static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
 {
-  std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 
   if(_imu_upside_down)
     imuUpsideDown(input);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="5" deleted_lines="7">
				<diff>@@ -390,13 +390,13 @@ static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
     current_pose.pitch = current_gnss_pose.pitch;
     current_pose.yaw = current_gnss_pose.yaw;
 
+    current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;
+
     offset_x = current_pose.x - previous_pose.x;
     offset_y = current_pose.y - previous_pose.y;
     offset_z = current_pose.z - previous_pose.z;
     offset_yaw = current_pose.yaw - previous_pose.yaw;
 
-    //TODO: add imu and odom
-
     init_pos_set = 1;
   }
 
@@ -427,8 +427,6 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
                    input-&gt;pose.pose.orientation.w);
   tf::Matrix3x3 m(q);
 
-  //TODO: add imu and odom
-
   if (_use_local_transform == true)
   {
     current_pose.x = input-&gt;pose.pose.position.x;
@@ -628,7 +626,7 @@ static const double wrapToPmPi(double a_angle_rad)
 
 static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
 {
-  std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 
   odom = *input;
   odom_calc(input-&gt;header.stamp);
@@ -659,7 +657,7 @@ static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
 
 static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
 {
-  std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 
   if(_imu_upside_down)
     imuUpsideDown(input);
@@ -1019,7 +1017,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     predict_pose_imu_odom_pub.publish(predict_pose_imu_odom_msg);
 
     ndt_q.setRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw);
-	    if (_use_local_transform == true)
+    if (_use_local_transform == true)
     {
       tf::Vector3 v(ndt_pose.x, ndt_pose.y, ndt_pose.z);
       tf::Transform transform(ndt_q, v);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="92a705c938b51894c255dc1a251df7e1f84c7d54" author="YamatoAndo">
		<msg>fix a typo</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1004,7 +1004,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
 
     tf::Quaternion predict_q_imu_odom;
-    predict_q_odom.setRPY(predict_pose_imu_odom.roll, predict_pose_imu_odom.pitch, predict_pose_imu_odom.yaw);
+    predict_q_imu_odom.setRPY(predict_pose_imu_odom.roll, predict_pose_imu_odom.pitch, predict_pose_imu_odom.yaw);
     predict_pose_imu_odom_msg.header.frame_id = "map";
     predict_pose_imu_odom_msg.header.stamp = input-&gt;header.stamp;
     predict_pose_imu_odom_msg.pose.position.x = predict_pose_imu_odom.x;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3883b3042dbb48c2cfd2800c83a464843f9db29b" author="AMC">
		<msg>updated yolo2 for compatibility with commit 56d69e73aba37283ea7b9726b81afd2f79cd1134 @pjreddie pjreddie committed 4 hours ago</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\include\darknet\yolo2.h" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\include\darknet\yolo2.h" added_lines="2" deleted_lines="2">
				<diff>@@ -22,7 +22,7 @@ namespace darknet
 	class Yolo2Detector
 	{
 		private:
-			std::vector&lt; RectClassScore&lt;float&gt; &gt; forward(float *data);
+			std::vector&lt; RectClassScore&lt;float&gt; &gt; forward(image&amp; in_darknet_image);
 
 			double min_confidence_, nms_threshold_;
 			network darknet_network_;
@@ -33,7 +33,7 @@ namespace darknet
 			void load(std::string&amp; in_model_file, std::string&amp; in_trained_file, double in_min_confidence, double in_nms_threshold);
 			~Yolo2Detector();
 			image convert_image(const sensor_msgs::ImageConstPtr&amp; in_image_msg);
-			std::vector&lt; RectClassScore&lt;float&gt; &gt; detect(float *in_data);
+			std::vector&lt; RectClassScore&lt;float&gt; &gt; detect(image&amp; in_darknet_image);
 			uint32_t get_network_width();
 			uint32_t get_network_height();
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\darknet\yolo2.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\darknet\yolo2.cpp" added_lines="10" deleted_lines="4">
				<diff>@@ -57,9 +57,9 @@ namespace darknet
 		free_network(darknet_network_);
 	}
 
-	std::vector&lt; RectClassScore&lt;float&gt; &gt; Yolo2Detector::detect(float *in_data)
+	std::vector&lt; RectClassScore&lt;float&gt; &gt; Yolo2Detector::detect(image&amp; in_darknet_image)
 	{
-		return forward(in_data);
+		return forward(in_darknet_image);
 	}
 
 	image Yolo2Detector::convert_image(const sensor_msgs::ImageConstPtr&amp; msg)
@@ -95,8 +95,9 @@ namespace darknet
 		return resized;
 	}
 
-	std::vector&lt; RectClassScore&lt;float&gt; &gt; Yolo2Detector::forward(float *in_data)
+	std::vector&lt; RectClassScore&lt;float&gt; &gt; Yolo2Detector::forward(image&amp; in_darknet_image)
 	{
+		float * in_data = in_darknet_image.data;
 		float *prediction = network_predict(darknet_network_, in_data);
 		layer output_layer = darknet_network_.layers[darknet_network_.n - 1];
 
@@ -104,7 +105,12 @@ namespace darknet
 		if (output_layer.type == DETECTION)
 			get_detection_boxes(output_layer, 1, 1, min_confidence_, darknet_box_scores_.data(), darknet_boxes_.data(), 0);
 		else if (output_layer.type == REGION)
-			get_region_boxes(output_layer, 1, 1, min_confidence_, darknet_box_scores_.data(), darknet_boxes_.data(), 0, 0, 0.5);
+		{
+			get_region_boxes(output_layer, in_darknet_image.w, in_darknet_image.h,
+							darknet_network_.w, darknet_network_.h,
+							min_confidence_, darknet_box_scores_.data(), darknet_boxes_.data(),
+							0, 0, 0.5, 1);
+		}
 		else
 			error("Last layer must produce detections\n");
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" added_lines="13" deleted_lines="1">
				<diff>@@ -102,6 +102,17 @@ class Yolo2DetectorNode
 		}
 	}
 
+	void rgbgr_image(image&amp; im)
+	{
+		int i;
+		for(i = 0; i &lt; im.w*im.h; ++i)
+		{
+			float swap = im.data[i];
+			im.data[i] = im.data[i+im.w*im.h*2];
+			im.data[i+im.w*im.h*2] = swap;
+		}
+	}
+
 	image convert_ipl_to_image(const sensor_msgs::ImageConstPtr&amp; msg)
 	{
 		cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(msg, "bgr8");//toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
@@ -169,6 +180,7 @@ class Yolo2DetectorNode
 				}
 			}
 		}
+		rgbgr_image(darknet_image);
 		return darknet_image;
 	}
 
@@ -179,7 +191,7 @@ class Yolo2DetectorNode
 
 		darknet_image = convert_ipl_to_image(in_image_message);
 
-		detections = yolo_detector_.detect(darknet_image.data);
+		detections = yolo_detector_.detect(darknet_image);
 
 		//ROS_INFO("Detections: %ud", (unsigned int)detections.size());
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="59ca15735c743b46b573352927e2c7bf2bdb1d85" author="Yusuke FUJII">
		<msg>fix a compile problem due to duplicate declaration of std and opencv3</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\yolo2\src\yolo2_node.cpp" added_lines="4" deleted_lines="0">
				<diff>@@ -6,7 +6,11 @@
 
 #include &lt;cv_tracker_msgs/image_obj.h&gt;
 
+#include &lt;opencv2/opencv.hpp&gt;
+
+#if (CV_MAJOR_VERSION != 3)
 #include &lt;opencv2/contrib/contrib.hpp&gt;
+#endif
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 
 #include &lt;cv_bridge/cv_bridge.h&gt;
</diff>
			</file>
		</modified_files>
	</commit>
</Root>
